{"id": "4l2cD3", "name": "Dual 3D Truchet Tiles", "author": "Shane", "description": "Utilizing two unique Truchet blocks to produce something analogous to a random pipe system.", "tags": ["raymarching", "glow", "truchet", "dual", "tile", "caustic"], "likes": 172, "viewed": 10359, "published": "Public API", "date": "1510922567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tDual 3D Truchet Tiles\n\t---------------------\n\n\tThis is yet another 3D Truchet example, but it consists of two unique Truchet blocks, which gives \n\tthe pattern a bit more variation. Truchet patterns usually make use of one block, consisting\n\tof three strategically placed tori designed to intersect the centers of all cube faces.\n\n\tThis particular pattern introduces another variation that consists of two tori intersecting four \n\tfaces and a straight segment that runs through opposing faces. The resultant pattern has more of a \n\trandom pipework look -- as opposed to the standard snake-like one. By the way, you could save a \n    lot of extra decision making and use just the second tile, but I feel the pattern lacks a little\n\tvariance when doing that.\n\t\n\tAnyway, apart from some extra decision making and construction, the code doesn't differ too much \n\tfrom regular examples. By the way, I can thank Mattz for reminding me of a concept that I'd forgotten, \n\twhich helped me speed up the distance field equation. Without it, this example would run much slower.\n\tI've described it briefly somewhere in among the distance field setup.\n\n\tWhilst on the subject of optimization, I should probably mention that I often take shortcuts with\n\tthe distance field equations in order to save the GPU extra calculations. For instance, I'll use a \n\tbound, like \"max(max(x, y), z),\" for a cube instead of the correct - but usually more expensive - \n\tone. For the most part, you can get away with it, but things like shadows, etc, can be affected. \n\tIQ has an example that illustrates the point here:\n\n\tRotational symmetry - iq\n\thttps://www.shadertoy.com/view/XtSczV\n\n\t\n\tBased on:\n\n\t// Same concept, but with one tile, which makes it easier to comprehend.\n\tCubic Truchet Pattern - Shane\n\thttps://www.shadertoy.com/view/4lfcRl\n\n\tOther Truchet examples:\n\n\t// 3D Truchet flow. Very cool. If you have easy questions to ask, feel free to send me an email, \n    // but if you have difficult ones, ask Mattz. :)\n\trandom cubic Truchet flow - mattz\n\thttps://www.shadertoy.com/view/MtSyRz\n\n\t// Psuedo 3D version, rendered in an oldschool game style.\n\t2D Pipe Pattern - Shane\n\thttps://www.shadertoy.com/view/XlXBzl\n\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 80.\n\n// Cross-sectional shape.\n// 0, 1, 2, or 3: Round, square, rounded-square or octagonal.\n#define TUBE_SHAPE 3 \n\n// Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need\n// to add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n// maybe later. :)\n#define CAMERA_WEAVE\n\n\n// Global storage vectors for object identification: I'm not fond of using globals inside distance field\n// functions, but felt it was necessary in this case.\nvec3 vObjID;\n//float gID; \n\n// Global glow variable. Accumulated in the raymarching function.\nfloat glow;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n// IQ's correct box formula.\nfloat sdBox( vec2 p, float b ){\n  //vec2 d = abs(p) - b; // \"p\" is already in absolute form, in this case.\n  vec2 d = p - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat tube(vec2 p, float sc, float rad){\n    \n    // Normally needed, but in this example \"p\" is passed to the function in its absoluted form.\n    //p = abs(p);\n    \n    \n    #if TUBE_SHAPE == 0\n    \n    return length(p) - rad; // Standard round pipes.\n\n    #elif TUBE_SHAPE == 1\n    \n    // Box shape: I've left the correct and cheap version for comparison. Uncomment each, then\n    // pause and check the shadows. The structure remains the same, but the shadows do not.\n    return sdBox(p, rad); // Correct square distance field equation.\n    //return max(p.x, p.y) - rad; // Cheaper shortcut. Almost the same, but not quite.\n    \n    #elif TUBE_SHAPE == 2\n    // Rounded square tube. Two versions.\n    return smax(p.x, p.y, .015) - rad; // Rounded square. Smooth minimum version.\n    //return pow(dot(pow(p, vec2(8)), vec2(1)), 1./8.) - rad; // Rounded square. Super-elliptical.\n    \n    #else\n    \n    // Ocatagonal shape.\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad; // .7071 for an octagon.\n    \n    #endif\n    \n}\n\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec4 torTube(vec3 p){\n\n\n    // Tube width.\n    const float rad2 = .07;\n    \n    \n    // Main tube. If it were not for the additional tube decorations, the following \n    // would be all that'd be required.\n    //\n    // Note that we're converting one of the coordinates to its circular form. That way, \n    // we're rendering a circular tube, instead of a straight one. It's an oversimplification, \n    // but that's basically all a torus is. By the way, it doesn't have to be circular, \n    // converting \"p.xy\" to an octagonal form, etc, would work also.\n    float tb = tube(abs(vec2(length(p.xy) - .5, p.z)), .75, rad2);\n    \n\n    \n    // Adding some details to the tube. \n    \n    \n    // Inner tube for colored lights.\n    float innerTb = 1e5; //tb + .0075; \n    \n   \n    \n    // Tube segments - for the bands and holes.\n    //\n    // Number of tube segments. Breaking a circle into 8 lots of 3. Other combinations can\n    // work though.\n    const float aNum = 12.; \n    \n    // Realigning the segments.\n    p.xy = rot2(3.14159/4.)*p.xy;\n    \n    // To place things evenly around the tube, you need to obtain the angle subtended to the center,\n    // partition it into the required number of cells (aNum), then obtain the angle at the center.\n    float a = atan(p.y, p.x);    \n    float ia = floor(a/6.283*aNum) + .5; // .5 to move to the cell center.\n\n    // Converting to polar coordinates - In effect: Radial position, \"p.x,\" and angular position, \"p.y.\"\n    p.xy = rot2(ia*6.283/aNum)*p.xy;\n    // The radial coordinate effective starts off at the center, so to spread the objects out, you have\n    // to advance them  along the radial coordinate in the radial direction. In this case, we want the \n    // objects to have the same radius as the torus we're attaching them to, which is \".5.\"\n    p.x -= .5;\n\n    // Drawing the objects within each of the partitioned cells. In this case, we're rendering some \n    // colored sleeves (or bands), and boring out some holes.\n    \n    p = abs(p);\n    \n    // Bands, or sleeves.\n    float band = max(tube(p.xz, .75,  rad2 + .0075), p.y - .06);\n    vec2 peg = vec2(tube(p.xy, .64, .0425), tube(p.yz, .64, .0425)); \n    \n    \n    // Group the 24 cell partitions into groups of 3 - in order to cover every third cell with the \n    // band and create a portal in the others... I figured it'd break up the monotony. :)\n    // On a side note, I try to avoid \"if\" statements inside distance functions when I can, but I \n    // figured this would be the best way for readability. Although, I might rework it later.\n    if(mod(ia + 1., 3.)>2.){\n        \n        band = min(band, max(tube(p.xz, .6, rad2 + .015), p.y - .04));\n    \t//band = max(band, min(band + .005, -p.y + .015));\n        band = min(band, max(tube(p.xz, .6, rad2 + .025), p.y - .04/3.));\n    }\n    else {\n        \n        // Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        // Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.z - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else \n        band = min(band, min(max(peg.x, p.z - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n        // Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        // it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n    \n\n    \n    // Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n}\n\n\n\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec4 straightTube(vec3 p){\n    \n    \n    // Tube width.\n    const float rad2 = .07;\n    \n    \n    // Main tube. If it were not for the additional tube decorations, the following \n    // would be all that'd be required.\n    float tb = tube(abs(p.xy), .75, rad2);\n    \n    \n    // Inner tube for colored lights.\n    float innerTb = 1e5; //tb + .0075; \n    \n    \n    // Adding some details to the tube.\n\n    float band = 1e5;\n    const float aNum = 1.;\n\n    \n    float ia = floor(p.z*3.*aNum);\n\n    float opz = mod(p.z + 1./aNum/3., 1./aNum);\n    \n    p.z = mod(p.z, 1./aNum/3.) - .5/aNum/3.;\n\tp = abs(p);\n    \n    // Bands, or sleeves.\n    band = max(tb - .0075, p.z - .06);\n    vec2 peg = vec2(tube(p.xz, .64, .0425), tube(p.yz, .64, .0425)); \n\n    \n    if(opz>2./aNum/3.){\n  \n        band = min(band, max(tube(p.xy, .6, rad2 + .015), p.z - .04));\n    \t//band = max(band, min(band + .005, -p.z + .015));\n        band = min(band, max(tube(p.xy, .6, rad2 + .025), p.z - .04/3.));\n    }\n    else {\n    \n        // Portals on alternate bands.\n        \n        float hole = min(peg.x, peg.y);\n        \n        // Octagonal portal flush. The rest are raised a little. No reason. Just a design choice.\n        #if TUBE_SHAPE == 3\n        band = min(band, min(max(peg.x, p.y - rad2 - .0075), max(peg.y, p.x - rad2 - .0075)));\n        #else\n        band = min(band, min(max(peg.x, p.y - rad2 - .02), max(peg.y, p.x - rad2 - .02)));\n        #endif\n        band = max(band, -(hole + .015));\n        \n        tb = max(tb, -(hole + .015));\n        \n                // Inner tube. Actually, just some spheres at the portal positions, but to the observer,\n        // it gives the impression of an inner tube.\n        innerTb = length(p) - rad2 + .01;\n        \n    }\n\n    \n    // Return the tube, bands, and inner tube objects.\n    return vec4(tb, band, innerTb, ia);\n    \n    \n}\n\n\n\n// I can thank Mattz for reminding me of this. You don't need to call all three decorated tubes,\n// then determine the minimum. You can determine the minimum main tube, then call the function\n// for the tube containing the more elaborate detailing that corresponds to it. And by that I\n// mean return the unique oriented point that corresponds to the nearest tube segment distance.\n//\nvec4 torTubeTest(vec3 p){\n    \n    vec2 v = vec2(length(p.xy) - .5, p.z);\n    \n    // Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    // Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\nvec4 straightTubeTest(vec3 p){\n    \n    vec2 v = p.xy;\n    \n    // Main tube distance squared. Note: If a + c < b + c, then a*a<b*b.\n    // Ie: we don't need to test length(v) - r, just dot(v, v);\n    return vec4(p, dot(v, v));\n}\n\n\n/*\n\n\tThe Truchet pattern:\n\n\tA standard 3D Truchet tile consists of three toroids centered on three edges of a cube, \n    positioned to enter and exit six cube faces... Look one up on the internet, and that \n\tdiatribe will make more sense. :) The idea is to connect the tiles in a 3D grid, then \n\trandomly rotate each around one of the axes to produce an interesting spaghetti looking \n\tpattern.\n\n\tConstructing the individual tiles is as simple as breaking space into a cubic grid then\n\tpositioning three tori in each cell. If you can position, rotate and render a torus,\n\tthen it should be rudimentary.\n\n\tThis example uses an additional block consisting of a straight tube connecting two\n\topposite faces and two tori to connect the other four. That should be easy enough to\n\tconstruct too.\n\n*/\n\nfloat map(vec3 p)\n{\n \n    // Random ID for each grid cube.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n    float rnd2 = fract(rnd*41739.7613 + .131);\n\n    // Partition space into a grid of unit cubes - centered at the origin and ranging from\n    // vec3(-.5, -.5, -.5) to vec3(-.5, -.5, -.5).\n    p = fract(p) - .5;\n      \n    // Use each cube's random ID to rotate it in such a way that another one of its faces is \n    // facing forward. In case you're not aware, the swizzling below is a cheap trick used to\n    // achieve this. By the way, there may be a faster way to write the conditionals - using \n    // ternary operators, or something to that effect, but I'm leaving it this way for now... \n    // However, if a GPU expert feels that it's unnecessarily slow, then feel free to let me \n    // know, and I'll change it.\n    if(rnd>.833) p = p.xzy;\n    else if(rnd>.666) p = p.yxz;\n    else if(rnd>.5) p = p.yzx;\n    else if(rnd>.333) p = p.zxy;\n    else if(rnd>.166) p = p.zyx;\n        \n    // I can thank Mattz for reminding me of this step. Each Truchet tile contains three decorated\n    // tubes. However, you only need to find the closest tube, \"not\" the closest decorated tube, which\n    // requires a lot more GPU power. Each of these return the closest point and the distance...\n    // Actually, the squared distance, which for comparisson purposes, is the same thing.\n    vec4 tb1, tb2, tb3;\n    tb1 = torTubeTest(vec3(p.xy + .5, p.z));\n    if(rnd2>.66){\n    \t\n    \ttb2 = torTubeTest(vec3(p.yz - .5, p.x));\n    \ttb3 = torTubeTest(vec3(p.xz - vec2(.5, -.5), p.y));\n    }\n    else {\n    \t\n    \ttb2 = torTubeTest(vec3(p.xy - .5, p.z));\n    \ttb3 = straightTubeTest(p);  \n    }\n     \n    // Sort the distances, then return the closest point.\n    p = tb1.w<tb2.w && tb1.w<tb3.w ? tb1.xyz : tb2.w<tb3.w ? tb2.xyz : tb3.xyz;\n \n    // Render the randomly aligned Truchet block. Ie, the three tori - plus bells and whistles.\n    // Each quarter torus consists of three separate objects: A white tube with some holes in it, \n    // some bracing (the colored sleeve looking things) and a colored inner tube. That's nine\n    // objects returned in all. If it were not for the need to sort objects and attain a segment\n    // identifier (tb.w), only a float would be necessary.\n    vec4 tb;\n    \n    if(rnd2<=.66 && tb3.w<tb1.w && tb3.w<tb2.w) tb = straightTube(p);\n    else tb = torTube(p);\n        \n\n    /// A unique angular segment identifier - Not used here.\n    //gID = tb.w;\n    \n     \n    // Each torus segment contains three individual objects. Here, we're finding the minimum in\n    // each category. We're keeping a global copy here that will be sorted for object identification\n    // outside the raymarching loop. The reason this step is necessary is because the line below\n    // finds the closest object, but doesn't tell us which object that is. That requires sorting,\n    // which is best done outside the loop, for speed reasons.\n    vObjID = tb.xyz;\n    \n    // Finding the minimum of the above to determine the overall minimum object in the scene.\n    return min(min(vObjID.x, vObjID.y), vObjID.z);\n    \n    \n}\n\n\n/*\n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat lightBlink(vec3 p, float gID){\n    \n    // Unique identifier for the cubic grid cell.\n    float rnd = fract(sin(dot(floor(p + vec3(111, 73, 27)), vec3(7.63, 157.31, 113.97)))*43758.5453);\n \n    // Reusing \"rnd\" to produce a new random number, then using that\n    // random number to create lights that blink at random intervals.\n    rnd = fract(rnd + gID*43758.54571);\n    \n    // Blink at random.\n    return smoothstep(0.33, .66, sin(rnd*6.283 + iTime*3.)*.5 + .5);\n\n    \n}\n*/\n\n\n// Standard raymarching algorithm.\nfloat trace(vec3 o, vec3 r){\n    \n    glow = 0.;\n    \n    // Total ray distance travelled, and nearest distance at the current ray position.\n    float t = 0., d, ad;\n    \n    for (int i = 0; i<128; i++) {\n        \n        // Surface distance.\n        d = map(o + r*t);\n        ad = abs(d);\n        \n        // Applying some glow. There are better ways to go about it, but this will do.\n        //if(ad<.25) glow += (.25 - ad)/(1. + d*8.);\n        //if(ad<.25) glow += (.25 - ad)/(.25 + ad*ad);\n        glow += 1./(1. + ad*ad*8.);\n        //if(vObjID.z<vObjID.x && vObjID.z<vObjID.y && ad<.25) glow += (.25 - ad))/(1. + t);\n        \n        // If the ray position is within the surface threshold (\"abs\" means either side of the \n        // surface), or if we've traversed beyond the maximum, exit the loop.\n        if(ad<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        // Standard jump.\n        t += d; \n        \n        // Shortening the ray jump right near the camera to alleviated near-camera artifacts.\n        //t += t<.125 ? d*.7 : d; \n    }\n    \n    // Clamp the total distance to \"FAR.\" It can sometimes get rid of far surface artifacts.\n    return min(t, FAR);\n}\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat shadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I sometimes add a constant to the final shade value, which lightens the shadow a bit. It's a preference \n    // thing. Really dark shadows look too brutal to me. Sometimes, I'll also add AO, just for kicks. :)\n    return min(max(shade, 0.) + .0, 1.); \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.25, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nrm(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(1./mix(400., iResolution.y, .5)*(1. + t*.5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Ray origin, or camera - Moving along the Z-axis.\n    float tm = iTime;\n    #ifdef CAMERA_WEAVE\n    tm *= .75;\n    #endif\n    \n    vec3 o = vec3(0, 0, tm); \n    // Light. Situated near the camera whilst moving along with it.\n\t//vec3 lp = vec3(-1, 3, -.25) + o;\n    vec3 lp = o + vec3(-1, 3, -1);\n    \n    // Cheap, last minute camera weave. Suggested by ExNihilo. To implement this properly, I need to add\n\t// add a few lines to set up a proper \"too\" and \"from\" camera... add a camera path function...\n    // maybe later. :)\n    #ifdef CAMERA_WEAVE\n    o.x += sin(tm * 3.14159265/6. + 1.5707963);\n    #endif\n    \n    // Unit ray vector.\n    //vec3 r = normalize(vec3(uv, 1));\n    // Slight bulbous scene warp.\n    vec3 r = normalize(vec3(uv, 1.15));\n    r = normalize(vec3(r.xy, r.z - length(r.xy)*.15));\n    \n    // Rotating \"r\" back and forth along various axes for some cheap camera movement. \n    #ifdef CAMERA_WEAVE\n    r.xz *= rot2(-sin(tm/2. - 1.5707963) * 0.6);\n    r.xy *= rot2(-sin(tm/2. - 1.5707963) * 0.4);\n    //r.yz *= rot2(-sin(tm/2.) * 0.2);\n    #else\n    r.xz *= rot2(sin(tm/2.) * 0.4);\n    r.xy *= rot2(cos(tm/2.) * 0.2);\n    #endif\n    \n    // Trace out the scene.\n    float t = trace(o, r);\n     \n    // Determining the object ID. Sorting the three different objects outside the loop\n    // is a little less readable, but usually faster. See the distance function.\n    //\n    // Scene object ID: Main tube, colored inner tube or band.\n    float objID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z) ? 0. : (vObjID.y<vObjID.z) ? 1. : 2.;\n\n    // Segment ID: Sorting the segments to determine the unique ID. This ID is fed\n    // into a function to give various effects. Not used here.\n    //float svGID = gID;\n \n\t// Initiate the scene color to zero.\n    vec3 sc = vec3(0);\n    \n    \n    // An object in the scene has been hit, so light it.\n    if(t<FAR){\n        \n        // Hit position.\n        vec3 sp = o + r*t;\n        \n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 sn = nrm(sp, edge, crv, t);\n\n        \n        // Producing a gradient color based on position. Made up on the spot.\n        vec3 oCol = vec3(1);\n        vec3 bCol = mix(vec3(1, .1, .3).zyx, vec3(1, .5, .1).zyx, dot(sin(sp*8. - cos(sp.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        //bCol = bCol.zyx; //bCol.yzx; // Other colors, if you prefer.\n\n\n        \n        // Color the individual objects, based on object ID.\n        if(objID<.5)oCol = mix(bCol, vec3(1), .97);\n        else if(objID>1.5) oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        else oCol = oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        // A bit of subtle texture applied to the object.\n        vec3 tx = tex3D(iChannel0, sp*2., sn);\n        tx = smoothstep(.0, .5, tx)*2.;\n        //\n        if(objID<1.5) oCol *= tx;\n        else oCol *= mix(vec3(1), tx, .5);\n        \n        \n        // Ambient occlusion and shadows.\n        float ao = cAO(sp, sn);\n        float sh = shadow(sp + sn*.002, lp, 16., t); \n        \n\n        // Point light direction vector.\n        vec3 ld = lp - sp;\n        float dist = max(length(ld), 0.001); // Distance.\n        ld /= dist; // Using the distance to nomalize the point light direction vector.\n        \n\n        // Attenuation - based on light to surface distance.\n        float atten = 3.5/(1. + dist*0.05 + dist*dist*0.05);\n        \n        // Diffuse light.\n        float diff = max(dot(ld, sn), 0.);\n        if(objID<1.5) diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, sn), r), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        \n       \t\n        \n        // Combining the above terms to produce the final color.\n        sc = oCol*(diff + ao*.2) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n        \n        // Fake caustic lighting... Very fake. :)\n        sc += .015/max(abs(.05 - map(sp*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n        \n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID<1.5) sc += bCol*glow*.025;\n        else sc += bCol*glow*1.5;\n        \n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        sc *= (1. - edge*.7);\n        sc *= atten*(sh + ao*.25)*ao;\n        \n    }\n    \n    \n    \n    // Applying some basic camera distance fog. Not to be confused with the light\n    // to surface attenuation.\n    float fog = 1./(1. + t*.125 + t*t*.05);\n    sc = mix(vec3(0), sc, fog);//\n    //sc = mix(sc, vec3(0), smoothstep(0.0, .2, t/FAR));\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sc *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    //sc = mix(pow(min(vec3(1.5, 1, 1).zyx*sc, 1.), vec3(1, 3, 16).zyx), sc, \n             //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.75 + .25);\n    \n    \n\tfragColor = vec4(sqrt(max(sc, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2858, 2891, 2913, 2913, 2971], [2974, 3023, 3061, 3061, 3156], [3159, 3317, 3364, 3364, 3872], [3875, 3904, 3935, 4010, 4084], [4086, 4194, 4234, 4354, 5221], [5224, 5388, 5409, 5430, 9064], [9069, 9233, 9259, 9288, 11095], [11099, 11484, 11509, 11509, 11732], [11734, 11734, 11764, 11764, 11963], [11966, 12761, 12780, 12819, 15949], [16565, 16600, 16628, 16628, 17775], [17777, 18078, 18127, 18244, 19549], [19552, 19704, 19737, 19737, 19986], [19989, 20055, 20117, 20460, 21441], [21445, 21445, 21502, 21549, 26590]], "test": "untested"}
{"id": "4l2cRt", "name": "MacSearlas erosion", "author": "FlorentTournade", "description": "Raymarched version here: https://www.shadertoy.com/view/XlBcDG\n\n//Adapted from cpu by Florent Tournade\n//original algorithm by \"YankeeMinstrel\" ( https://www.reddit.com/r/proceduralgeneration/comments/797fgw/iterative_pseudoerosion/ )", "tags": ["fractal", "erosion"], "likes": 10, "viewed": 767, "published": "Public", "date": "1509785607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//THIS IS WIP, DOESN'T FULLY WORK YET !!! (Feel free to contribute)\n//there's an issue when wsPos is negative (comment #define NEGATIVE_POS_BUG_WORKAROUND to see)\n//and at grid boundaries\n\n//Adapted from cpu by Florent Tournade\n//original algorithm by \"YankeeMinstrel\" ( https://www.reddit.com/r/proceduralgeneration/comments/797fgw/iterative_pseudoerosion/ )\n//cpu re-implementation by \"smcameron\" ( https://github.com/smcameron/pseudo-erosion )\n//uses bicubic filtered noise from https://www.shadertoy.com/view/4df3Dn\n\n//TODO: -try adding some distortion\n\n#define BICUBIC //how the baseheighmap samplesthe noise texture\n#define EROSION_OCTAVE_MODE 3 //0: only base map / 1: one erosion octave / 2: fbm style / 3: MacSearlas style \n#define NEGATIVE_POS_BUG_WORKAROUND\n#define GRIDSIZE 100.0\n#define BASE_HEIGHT 0.9\n#define EROSION_HEIGHT 0.6\n\n// w0, w1, w2, and w3 are the four cubic B-spline basis functions\nfloat w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nfloat h1(float a)\n{\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize)\n{\n\tuv = uv*texelSize.zw + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = h0(fuv.x);\n    float h1x = h1(fuv.x);\n    float h0y = h0(fuv.y);\n    float h1y = h1(fuv.y);\n\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\t\n    return g0(fuv.y) * (g0x * texture(tex, p0)  +\n                        g1x * texture(tex, p1)) +\n           g1(fuv.y) * (g0x * texture(tex, p2)  +\n                        g1x * texture(tex, p3));\n}\n\nfloat BaseHeightmap( vec2 uv )\n{\n    uv *= 0.00001;\n        \n#ifdef BICUBIC\n    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy); \n\tfloat noise = texture_bicubic( iChannel0, uv, texelSize ).x;\n#else\n    float noise = texture( iChannel0, uv ).x;\n#endif\n    return noise;\n}\n\nfloat sqr( float x ) { return x * x; }\n\nvec2 hash2( ivec2 p ) { return fract(sin( float(p.x) + float(p.y) * vec2(793.34,934.78) ) * vec2(12345.0,5432.0))-0.5; }\n\nfloat sdLine( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat PseudoErosion( vec2 pos, float gridSize )\n{\n    ivec2 pi = ivec2(0.5 + pos/gridSize);\n\n    float minh = 1e20;\n    \n    float dm = 0.0;\n    for( int j=-1; j<=1 ; j++ )\n    for( int i=-1; i<=1 ; i++ )\n    {\n        ivec2 pa = pi + ivec2(i,j);\n        \n        vec2  p1 = (vec2(pa) + hash2(pa)) * gridSize;\n\n        vec2 p2;\n        float lowestNeighbor = 1e20;\n\n        for( int n=-1 ; n<=1 ; n++ )\n        for( int m=-1 ; m<=1 ; m++ )\n        {\n            ivec2 pb = pa + ivec2(m,n);\n            vec2 candidate = (vec2(pb) + hash2(pb)) * gridSize;\n\n            float height = BaseHeightmap( candidate );\n            if( height < lowestNeighbor )\n            {\n                p2 = candidate;\n                lowestNeighbor = height;\n            }\n        }\n\n        float h = sdLine( pos, p1, p2 );\n        minh = min(h,minh);\n    }\n\n    minh = minh/gridSize;\n    return minh;\n}\n\nfloat PseudoErosionFractal( vec2 wsPos )\n{\n\tfloat baseHeight = BaseHeightmap( wsPos );\n\n#if (EROSION_OCTAVE_MODE == 0)\n\tfloat erosion = 0.0;\n    \n#elif (EROSION_OCTAVE_MODE == 1)\n\t//1 erosion octave\n    float erosion = PseudoErosion( wsPos, GRIDSIZE );\n    \n#elif (EROSION_OCTAVE_MODE == 2)\n    //fbm style\n\n    float erosion = 0.0;\n    \n    const int numOctaves = 4;\n    \n    float scale = 1.0f;\n    float gridSize = GRIDSIZE;\n    \n    for( int i=0 ; i < numOctaves ; ++i )\n    {\n\t    erosion += PseudoErosion( wsPos, gridSize ) * scale;\n        scale *= 0.5;\n        gridSize *= 0.5;\n    }\n\n#elif (EROSION_OCTAVE_MODE == 3)\n    //MacSearlas  style\n \n    float r1 = PseudoErosion( wsPos, GRIDSIZE );\n\tfloat erosion = sqr(r1);\n    \n    float r2 = PseudoErosion( wsPos, GRIDSIZE / 2.0 );\n    erosion += r1 * r2 / 2.0;\n    \n    float r3 = PseudoErosion( wsPos, GRIDSIZE / 4.0 );\n\terosion += sqrt(r1*r2)*r3 / 3.0;\n\n#endif\n    return baseHeight * BASE_HEIGHT + erosion * EROSION_HEIGHT;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy) / iResolution.xy;\n    vec2 wsPos = (p - 0.5) * 4000.0 * ( sin( iTime * 0.3 ) + 1.0 );\n\n#ifdef NEGATIVE_POS_BUG_WORKAROUND\n    wsPos += 8000.0f;\n#endif\n    \n    float map = PseudoErosionFractal( wsPos );\n    \n    fragColor = vec4( map, map, map, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[844, 910, 929, 929, 984], [986, 986, 1005, 1005, 1055], [1057, 1057, 1076, 1076, 1135], [1137, 1137, 1156, 1156, 1188], [1190, 1235, 1254, 1254, 1282], [1284, 1284, 1303, 1303, 1331], [1333, 1375, 1394, 1394, 1439], [1441, 1441, 1460, 1460, 1504], [1506, 1506, 1568, 1568, 2278], [2280, 2280, 2312, 2312, 2584], [2586, 2586, 2608, 2608, 2624], [2626, 2626, 2649, 2649, 2746], [2748, 2748, 2788, 2788, 2898], [2900, 2900, 2949, 2949, 3784], [3786, 3786, 3828, 3828, 4771], [4773, 4773, 4830, 4830, 5112]], "test": "untested"}
{"id": "4l2cWK", "name": "Checkerboard beauty", "author": "AzazelN28", "description": "Checkerboard", "tags": ["2d", "checkerboard"], "likes": 0, "viewed": 73, "published": "Public", "date": "1510144737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tile = floor(uv.xy * iResolution.xy / 16.0);\n    if (mod(tile.x, 2.0) == 0.0) {\n        if (mod(tile.y, 2.0) == 0.0) {\n\t   \t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n        } else {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        }\n    } else {\n        if (mod(tile.y, 2.0) == 0.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n         \tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);   \n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2cWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 544]], "test": "untested"}
{"id": "4lByWK", "name": "smooth curvature on mirror", "author": "ollj", "description": "mouse does things:\n\nTo smoother curvature on a mirror axis (here a heart shape) (and for better performance), use;\nx=abs(p)\nx=almostIdentity(s,a,a*.5);", "tags": ["heart", "smooth", "curvature", "cherry", "continuity", "almostidentity"], "likes": 5, "viewed": 610, "published": "Public API", "date": "1510082979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sign 3d almost identity smooth heart curvature\n//self: https://www.shadertoy.com/new\n\n/*\nto smoother curvature on a mirror axis (here a heart shape) (and better performance) just use;\nx=abs(p)\nx=almostIdentity(s,a,a*.5);\n x is a mirrored domain, assumed to have an L1 discontinuity (a sharp corner) , unless x is orthogonal to the mirror)\n a is \"smoothing delta\" == \"smoothing area\"\n\nthis is VERY useful for \"superprim\" generalizations.\nthis is a game changer for all typefaces \n and symbols and architecture with mirror symmetry.\nthis can solve all the continuity issues that you get with teleporters.\n as such, it even evades uncertainty of double-slit scenarios.\n by asserting that the double slit experiment is just a\n  special case of 2 linked-list-portals.\n\nparent shader had the solution to smoothing curvature along a mirror \n 1 day after i asked for it\n and 1 year before I noticed that it had it\n  and han I made this fork for it.\n*/\n\n//parent: https://www.shadertoy.com/view/4lK3Rc\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Code for the making of this video: https://www.youtube.com/watch?v=aNR4n0i2ZlM\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n//below is special case of above; n=m*.5;\nfloat almostIdentity( float x, float m){\n    //x is asserted to be x=abs(x);\n    if(x>=m) return x;//sadly essential to also catch /0 case!\n    float t = x/m;\n    return (t*t+1.)*(.5*m);\n}\n\n\nvec2 map( vec3 q )\n{\n    q *= 100.0;\n\n    vec2 res = vec2( q.y, 2.0 );\n\n\n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    \n    float m=iMouse.y*20./iResolution.y;\n   // x = (almostIdentity((x), m, m*.5)); // remove discontinuity (http://www.iquilezles.org/www/articles/functions/functions.htm)\n    x = almostIdentity(x, m); // remove discontinuity (http://www.iquilezles.org/www/articles/functions/functions.htm)\n\n        \n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    d = d/3.0;\n    if( d<res.x ) res = vec2( d, 1.0 );\n    \n    res.x /= 100.0;\n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 1.0;\n\n    vec2 res = vec2(0.0);\n    float t = 0.2;\n    for( int i=0; i<300; i++ )\n    {\n\t    vec2 h = map( ro+rd*t );\n        if( (h.x<0.0) || (t>maxd) ) break;\n        t += h.x;\n        res = vec2( t, h.y );\n    }\n\n    if( t>maxd ) res=vec2(-1.0);\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 kk;\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.01 + ap*0.2 ).x*20.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec2 p )\n{\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 0.2*(iMouse.x*40./iResolution.x+2.);\n\n\tvec3 ro = vec3(0.4*sin(an),0.25,0.4*cos(an));\n    vec3 ta = vec3(0.0,0.15,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(1.0,0.82,0.9);\n\n\t// raymarch\n    vec3 uvw;\n    vec2 res = intersect(ro,rd);\n    float t = res.x;\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        \n        float occ = calcAO( pos, nor ); occ = occ*occ;\n\n        if( res.y<1.5 ) // heart\n        {\n            col = vec3(0.9,0.02,0.01);\n            col = col*0.72 + 0.2*fre*vec3(1.0,0.8,0.2);\n            \n            vec3 lin  = 4.0*vec3(0.7,0.80,1.00)*(0.5+0.5*nor.y)*occ;\n                 lin += 0.5*fre*vec3(1.0,1.0,1.00)*(0.6+0.4*occ);\n            col = col * lin;\n            col += 4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.4,ref.y)*(0.06+0.94*pow(fre,5.0))*occ;\n\n            col = pow(col,vec3(0.4545));\n        }\n        else // ground\n        {\n            col *= clamp(sqrt(occ*1.8),0.0,1.0);\n        }\n    }\n\n    col = clamp(col,0.0,1.0);\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    vec3 col = render( p );\n   \n    vec2 q = fragCoord/iResolution.xy;\n   // col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lByWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1120, 1204, 1228, 1228, 1270], [1379, 1379, 1415, 1415, 1591], [1593, 1593, 1644, 1644, 1773], [1774, 1816, 1856, 1892, 2004], [2007, 2007, 2027, 2027, 2821], [2823, 2823, 2865, 2865, 3149], [3151, 3151, 3183, 3183, 3406], [3408, 3408, 3450, 3450, 3743], [3745, 3745, 3771, 3905, 5368], [5369, 5369, 5426, 5426, 5666]], "test": "untested"}
{"id": "4lfBRr", "name": "Warpy Lattice", "author": "0x4d4147", "description": "2D warpy lattice thing make with rotating crosses and repeated space.", "tags": ["2d", "repetition", "pattern"], "likes": 2, "viewed": 385, "published": "Public API", "date": "1510719396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// THE PIECES\n\n// Rotate the space around (0, 0) by angle.\nvec2 rotate(vec2 uv, float angle)\n{\n\treturn vec2(\n\t\tuv.x*cos(angle) - uv.y*sin(angle),\n\t\tuv.x*sin(angle) + uv.y*cos(angle)\n\t);\n}\n\n// Return 1 if even, 0 if odd.\nfloat is_even(float n)\n{\n    return 1.0 - step(1.0, mod(n, 2.0));\n}\n\n// Tile space, repeats 0->1 for number of times (per square unit space).\nvec4 tile_space(vec2 uv, float times)\n{\n    vec2 scaledUV = uv * times;\n    return vec4(fract(scaledUV), floor(scaledUV));\n}\n\n// Values from Wikipedia page on YUV colorspace.\nvec3 yuv_to_rgb(vec3 yuvCol)\n{\n    return vec3(\n        yuvCol.x +                    1.13983*yuvCol.z,\n\t\tyuvCol.x - 0.39465*yuvCol.y - 0.58060*yuvCol.z,\n\t\tyuvCol.x + 2.03211*yuvCol.y\n    );\n}\n\n// From pixel spirit deck.\nfloat rectSDF(vec2 uv, vec2 size)\n{\n\tuv = uv * 2. - 1.;\n\treturn max(\n\t\tabs(uv.x/size.x),\n\t\tabs(uv.y/size.y)\n\t);\n}\n\n// Adapted from pixel spirit deck.\nfloat crossSDF(vec2 uv, float s, float thick)\n{\n\treturn min(\n\t\trectSDF(uv, vec2(s, thick)),\n\t\trectSDF(uv, vec2(thick, s))\n\t);\n}\n\n// From pixel spirit deck.\nfloat fill(float x, float size)\n{\n\treturn 1.0 - step(size, x);\n}\n\n\n// THE CONSTRUCTION\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize UVs.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Background color parameter.\n    vec4 bgCol = mix(vec4(.05, .05, .05, 1), vec4(.25, .25, .25, 1.), distance(uv, vec2(.5))*1.4);\n    \n    // Correct UV aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // More parameters.\n    vec4 strokeCol = vec4(yuv_to_rgb(vec3(.5, uv.x, uv.y-.1)), 1.);\n    const float tileAmt = 4.0;\n    const float crossSize = 4.;\n    float crossThickness = .9;\n    \n    // Build on these.\n    float sdf = 0.;\n    vec4 col;\n    \n    // Tile the space.\n    vec4 tiledSpace = tile_space(uv, tileAmt);\n    uv = tiledSpace.xy;\n    \n    // Make checkerboard mask to flip rotations for the effect.\n    float xor = is_even(tiledSpace.w) + is_even(tiledSpace.z);\n    xor = (1.0 - step(1.5, xor)) * xor;\n    \n    // Rotate the space (works per tile).\n    uv -= vec2(.5);\n    uv = rotate(uv, mix(1., -1., xor)*iTime*0.5f);\n    uv += vec2(.5);\n    \n    // Shape the SDF with a cross.\n    sdf = crossSDF(uv, crossSize, crossThickness);\n    \n    // Mix the colors for the final result.\n    col = mix(bgCol, strokeCol, fill(sdf, 0.5));\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 59, 94, 94, 187], [189, 220, 244, 244, 287], [289, 362, 401, 401, 486], [488, 537, 567, 567, 729], [731, 758, 793, 793, 871], [873, 908, 955, 955, 1035], [1037, 1064, 1097, 1097, 1128], [1131, 1152, 1207, 1229, 2369]], "test": "untested"}
{"id": "4lfBWH", "name": "Fit Distance Cone to Point", "author": "paniq", "description": "find the position on an ice cream cone that touches a point on the cone's circle", "tags": ["sphere", "cone", "tracing", "radius"], "likes": 11, "viewed": 837, "published": "Public API", "date": "1511700974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fit distance cone to point\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// source channel for texture font\n#define font_texture_source iChannel1\n// draw a letter with the given texture coordinate\nvoid letter(ivec2 l);\nvoid letter(int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nvoid paint() {\n    // clear screen with a subtle gradient\n\n    set_source_rgb(vec3(1.0));\n    clear();\n\n    translate(-1.0, 0.0);\n    \n    set_source_rgb(vec3(0.0));\n\tset_line_width_px(1.0);\n    \n    float aperture = (iMouse.z > 0.5)?abs(get_query().y):0.7;\n    float len = 2.0;\n    \n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of circle at t=1\n    float R = aperture/C;\n    // adjustment factor for a position whose circle touches t at the right hand\n    float A0 = C / (C + aperture);\n    // adjustment factor for a position whose circle touches t at the left hand\n    float A1 = C / (C - aperture);\n    \n    move_to(0.0, 0.0);\n    line_to(len, len*aperture);\n    stroke();\n    move_to(0.0, 0.0);\n    line_to(len, -len*aperture);\n    stroke();\n    move_to(0.0, 0.0);\n\tline_to(len, 0.0);\n    stroke();\n    \n    float t = 1.0 + sin(iTime)*0.5;\n    circle(t, 0.0, 0.02);\n    fill();    \n    // adjust position\n    t = t * A0;\n    // radius of circle at t\n    float r = t*R;        \n    circle(t, 0.0, r);\n    stroke();\n    \n    /*\n\ty = aperture * x\n    x = t - aperture * y\n    \n\tq0 = 1 + a0 * a0\n\tq1 = 1 + a1 * a1\n    \n\tt0 * q1 / q0 = t1\n\t*/\n    \n    float C0 = C;\n    aperture = tan(atan(aperture)*0.5);\n    vec2 d = normalize(vec2(len, len*aperture));\n\n    move_to(0.0, 0.0);\n    line_to(len, len*aperture);\n    stroke();\n\n    C = sqrt(aperture*aperture + 1.0);\n    R = aperture/C;\n    A0 = C / (C + aperture);\n\n    t = t * C / C0;\n\n    circle(d * t, 0.02);\n    fill();    \n\n    r = t * R;\n    circle(d * t, r);\n    stroke();   \n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(int lx, int ly) {\n    letter(ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lfBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6071, 6155, 6169, 6212, 7702], [7879, 7939, 7966, 7966, 7992], [7994, 8054, 8075, 8075, 8182], [8184, 8184, 8221, 8221, 8307], [8309, 8309, 8355, 8355, 8388], [8390, 8528, 8556, 8556, 9016], [9044, 9044, 9063, 9063, 9096], [9098, 9098, 9116, 9116, 9149], [9151, 9151, 9175, 9175, 9279], [9281, 9281, 9298, 9298, 9319], [9321, 9321, 9348, 9370, 9653], [9655, 9655, 9683, 9683, 9917], [9919, 9919, 9943, 9943, 10029], [10031, 10031, 10058, 10058, 10271], [10273, 10273, 10299, 10299, 10527], [10529, 10529, 10551, 10551, 10677], [10679, 10679, 10699, 10699, 10759], [10761, 10761, 10793, 10793, 10820], [10822, 10822, 10843, 10843, 10865], [10867, 10867, 10891, 10891, 10951], [10953, 10953, 10987, 10987, 11011], [11013, 11013, 11027, 11027, 11091], [11093, 11093, 11119, 11119, 11157], [11159, 11159, 11185, 11185, 11206], [11208, 11208, 11231, 11231, 11326], [11328, 11328, 11352, 11352, 11421], [11423, 11423, 11448, 11448, 11495], [11497, 11497, 11514, 11514, 11627], [11629, 11629, 11652, 11652, 11781], [11783, 11783, 11811, 11811, 11939], [11941, 11941, 11965, 11965, 12105], [12107, 12107, 12145, 12145, 12279], [12281, 12281, 12318, 12318, 12353], [12355, 12355, 12382, 12382, 12432], [12434, 12434, 12464, 12464, 12520], [12522, 12522, 12551, 12551, 12732], [12734, 12734, 12756, 12756, 12923], [12925, 12925, 12938, 12938, 12977], [12979, 12979, 13009, 13009, 13038], [13040, 13040, 13073, 13073, 13130], [13132, 13132, 13158, 13158, 13208], [13210, 13210, 13231, 13231, 13296], [13298, 13298, 13322, 13322, 13405], [13407, 13407, 13422, 13422, 13463], [13465, 13465, 13481, 13481, 13519], [13521, 13521, 13539, 13539, 13596], [13598, 13598, 13628, 13650, 14032], [14034, 14034, 14092, 14092, 14130], [14132, 14132, 14161, 14161, 14197], [14199, 14199, 14247, 14247, 14278], [14280, 14280, 14314, 14314, 14373], [14375, 14375, 14452, 14452, 14617], [14619, 14619, 14696, 14696, 14776], [14778, 14778, 14854, 14854, 14970], [14972, 14972, 15048, 15048, 15126], [15128, 15128, 15166, 15166, 15200], [15202, 15202, 15224, 15224, 15270], [15272, 15272, 15299, 15299, 15343], [15345, 15345, 15367, 15367, 15761], [15763, 15763, 15792, 15792, 15820], [15822, 15822, 15871, 15871, 16132], [16134, 16134, 16207, 16207, 16261], [16263, 16263, 16295, 16295, 16331], [16333, 16333, 16389, 16389, 16445], [16447, 16447, 16477, 16477, 16570], [16571, 16571, 16611, 16611, 16634], [16636, 16682, 16721, 16721, 17877], [17879, 17879, 17909, 17909, 18011], [18013, 18013, 18065, 18065, 18105], [18107, 18107, 18129, 18129, 18180], [18182, 18182, 18214, 18214, 18236], [18238, 18253, 18275, 18275, 18567], [18569, 18569, 18601, 18601, 18623], [18625, 18625, 18644, 18644, 18676], [18725, 18788, 18830, 18830, 18896], [18898, 18968, 19019, 19019, 19371], [19373, 19407, 19453, 19453, 19965], [19967, 20036, 20082, 20082, 20588], [20590, 20590, 20623, 20623, 20839], [20841, 20841, 20900, 20900, 20945], [20947, 20947, 20990, 20990, 21051], [21053, 21053, 21095, 21095, 21137], [21139, 21199, 21256, 21256, 21455]], "test": "untested"}
{"id": "4llBD4", "name": "Thru Looking Glass", "author": "somesuch", "description": "By somesuch November 28, 2017 and based off of \"Noise 3D Fly Through\" Created by Kamil Kolaczynski (revers) - 2016 https://www.shadertoy.com/view/4ddXW4", "tags": ["tunnel", "mirror", "shiny"], "likes": 1, "viewed": 144, "published": "Public", "date": "1511893192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n * Modification by Somesuch -2017\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader, as always, uses a lot of code (raymarching, noise and lighting) credited to iq \n * [ https://www.shadertoy.com/view/Xds3zN ]. \n * Camera path is based on Shane's \"Subterranean Fly-Through\" [ https://www.shadertoy.com/view/XlXXWj ].\n * Additional specular lighting trick is based on \"Wet stone\" by TDM [ https://www.shadertoy.com/view/ldSSzV ].\n * Thanks for sharing great code guys!\n * \n * The shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\nconst float FOV = 5.0;\nconst float MarchDumping = 0.7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float CameraSpeed = 5.5099998;\nconst float TunnelSmoothFactor = 2.5;\nconst float TunnelRadius = 4.85660005;\nconst float TunnelFreqA = 0.18003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.319;\nconst float NoiseScale = 25.9980001;\nconst vec3 Color = vec3(1.0, 1.0, 1.0);\n\n#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 200.0), hash(n + 200.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 11.0), hash(n + 11.0), f.x),\n\t\t\t\t\tmix(hash(n + 27.0), hash(n + 27.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise(p);\n\n\treturn f;\n}\n\n// by iq. http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.9 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (fbm(p) - NoiseIsoline) * NoiseScale;\n}\n\nvec2 map(vec3 p) {\n\tfloat d = noiseDist(p);\n\tfloat d2 = length(p.xy - path(p.z)) - TunnelRadius;\n\td = smax(d, -d2, TunnelSmoothFactor);\n\n\tvec2 res = vec2(d, M_NOISE);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 10.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\t// material\n\t\tcol = Color + sin(t * 0.1) * 0.1;\n\t\tcol += 0.3 * sin(vec3(0.15, 0.02, 0.10) * iTime * 6.0);\n\n\t\t// lighitng\n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = -rd;\n\t\tfloat amb = clamp(0.5 + 0.005 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\t// Additional specular lighting trick,\n\t\t// taken from \"Wet stone\" by TDM\n\t\t// https://www.shadertoy.com/view/ldSSzV\n\t\tnor = normalize(nor - normalize(pos) * 0.2);\n\t\tref = reflect(rd, nor);\n\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\t\tbrdf += 2.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\tbrdf += 0.40 * amb * vec3(0.00, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tcol = mix(col, vec3(0.0), 1.0 - exp(-0.005 * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 rotationZ(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\n\treturn mat3(ca, sa, 0.0, -sa, ca, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n    float t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 dir = normalize(target - ro);\n    vec3 up = vec3(-0.9309864, -0.33987653, 0.1332234) * rotationZ(iTime * 0.05);\n    vec3 upOrtho = normalize(up - dot(dir, up) * dir);\n    vec3 right = normalize(cross(dir, upOrtho));\n\n    vec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llBD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1200, 1221, 1221, 1262], [1264, 1264, 1285, 1285, 1625], [1627, 1627, 1646, 1646, 1774], [1776, 1835, 1874, 1874, 1971], [1973, 2055, 2075, 2075, 2161], [2163, 2163, 2188, 2188, 2257], [2259, 2259, 2277, 2277, 2440], [2442, 2442, 2474, 2474, 2793], [2795, 2795, 2855, 2855, 3098], [3100, 3100, 3127, 3127, 3343], [3345, 3345, 3379, 3379, 3638], [3640, 3640, 3671, 3671, 4950], [4952, 4952, 4977, 4977, 5076], [5078, 5078, 5133, 5133, 5786]], "test": "untested"}
{"id": "4llBz4", "name": "[TP5]Shadowed Scene", "author": "Sando", "description": "Illuminated scene with floor and added shadows and movement.", "tags": ["3d", "shadow", "tp"], "likes": 1, "viewed": 150, "published": "Public", "date": "1511195080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FLT_MAX = 1.0 / 0.0;   \nconst int MAX_NB_BOUNCES = 10;\nconst int NB_SHOT_RAY = 15;\nconst float FLT_NB_SHOT_RAY = 15.0;\n\nstruct Material\n{\n    float Ka; // ambiant\t\tcoefficient\n    float Kd; // diffuse\t\tcoefficient\n    float Ks; // specular\t\tcoefficient\n    float Kn; // specular power coefficient\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadeCol;\n    float Ks;\n};\n    \n// Camera Parameters\n      vec3\t\tcameraInitPos\t= vec3(6, 4, -5);\n\t  vec3 \t\tcameraPos \t\t= vec3(6, 4, -5);\nconst vec3 \t\tcameraTarget\t= vec3(3, 1, -8);\nconst float \tcameraFovY\t\t= 80.0;\n\n//Light Parameters\nconst vec3\t\tambiantCol\t= vec3(0,0,1);\nconst vec3\t\tlightCol\t= vec3(1,1,1);\nconst vec3 \t\tlightInitPos= vec3(8, 10, -12);\n      vec3\t\tlightPos\t= vec3(8, 10, -12);\n    \n// Sky Parameters\nconst vec3\t\tskyCol\t= vec3(0.2);\nconst int\t\tskyId\t= 0;\nconst Material\tskyMat\t= Material(1.0,0.0,0.0,0.0);\n\n// Sphere Parameters\nconst int \t\tsphereId \t\t= 1;\nconst vec3 \t\tspherePos\t\t= cameraTarget + vec3(0, 1, 2);\nconst float \tsphereRadius\t= 1.0;\nconst vec3\t\tsphereCol\t\t= vec3(1,0,0);\nconst Material \tsphereMat\t\t= Material(0.2, 0.7, 0.1, 50.0);\n\n// Sphere2 Parameters\nconst int \t\tsphere2Id \t\t= 2;\nconst vec3 \t\tsphere2Pos\t\t= cameraTarget + vec3(2, 1, 5);\nconst float \tsphere2Radius\t= 1.0;\nconst vec3\t\tsphere2Col\t\t= vec3(0.2,0.5,0.5);\nconst Material \tsphere2Mat\t\t= Material(0.5, 0.7, 1.0, 500.0);\n\n// Plan Parameters\nconst int \t\tplaneId \t\t= 3;\nconst vec3 \t\tplanePos\t\t= vec3(0, 0.1, 0);\nconst vec3\t\tplaneNormal\t\t= vec3(0, 1.0, 0);\nconst vec3\t \tplaneCol1\t\t= vec3(1.0);\nconst vec3\t\tplaneCol2\t\t= vec3(0.4);\nconst Material \tplaneMat\t\t= Material(0.2, 1.0, 0.2, 5.0);\n\n\nvoid animateCamera(){\n    cameraPos = vec3(cameraTarget.x+5.0*cos(iTime/4.0), cameraInitPos.y, cameraTarget.z+5.0*sin(iTime/4.0));\n\tlightPos  = vec3(lightInitPos.x - 8.0*sin(iTime), lightInitPos.y, lightInitPos.z + 12.0*cos(iTime));\n\n}\n\nvoid computeCameraRayFromPixel(vec2 fragCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float fragX = fragCoord.x - iResolution.x/2.0;\n    float fragY = iResolution.y/2.0 - fragCoord.y;\n    float fragZ = iResolution.y/(2.0*tan(radians(cameraFovY/2.0)));\n \n    vec3 cz = normalize(cameraTarget - cameraPos); \n    \n    vec3 tmpCy = vec3(0, -1, 0);\n    vec3 tmpCx = cross(tmpCy, cz);\n    \n    vec3 cx = normalize(tmpCx);\n    vec3 cy = cross(cz, cx);\n    \n    rayDir = normalize(fragX*cx + fragY*cy + fragZ*cz);\n    rayPos = cameraPos;\n}\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersectPt, out vec3 normalP)\n{\n   \tfloat den = dot(planeNormal, rayDir);\n    if(abs(den) < 0.0001)\n        return(-1.0);\n    float intersectDist = dot(planeNormal, planePos - rayPos)/den;\n    intersectPt = rayPos + rayDir*intersectDist;\n    normalP = -sign(den)*planeNormal;\n    return intersectDist;\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersectS, out vec3 normalS)\n{\n    float intersectDist = 0.0;\n    vec3 camSph = spherePos - rayPos;\n\tfloat proj = dot(camSph, rayDir);\n    float intersect = pow(sphereRadius, 2.0)+ pow(proj,2.0) - pow(length(camSph),2.0);\n    if(intersect > 0.0)\n        intersectDist = proj - sqrt(intersect);\n    intersectS = rayPos + rayDir*intersectDist;\n    normalS = normalize(intersectS - spherePos);\n    \n    return intersectDist;\n}\n\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersectI, out vec3 normalI){\n\tfloat minDist = FLT_MAX;\n    objectId = skyId;\n    \n    vec3 intersectS, normalS;\n\tfloat distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersectS, normalS);\n    if((distS > 0.0) && (distS < minDist)){\n    \tintersectI = intersectS;\n        normalI = normalS;\n        minDist = distS;\n        objectId = sphereId;\n    }\n    \n    vec3 intersectS2, normalS2;\n\tfloat distS2 = raySphere(rayPos, rayDir, vec3(sphere2Pos.x+cos(iTime), sphere2Pos.y+sin(iTime), sphere2Pos.z), sphere2Radius, intersectS2, normalS2);\n    if((distS2 > 0.0) && (distS2 < minDist)){\n    \tintersectI = intersectS2;\n        normalI = normalS2;\n        minDist = distS2;\n        objectId = sphere2Id;\n    }\n    \n    vec3 intersectP, normalP;\n    float distP = rayPlane(rayPos, rayDir, planePos, planeNormal, intersectP, normalP);\n    if((distP > 0.0) && (distP < minDist)){\n    \tintersectI = intersectP;\n        normalI = normalP;\n        minDist = distP;\n        objectId = planeId;\n    }\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return(minDist);\n}\n\nvec3 getSphereColorAtPoint(vec3 pt){\n    return(sphereCol);\n}\n\nvec3 getSphere2ColorAtPoint(vec3 pt){\n    return(sphere2Col);\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt){    \n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n    vec3 diff = pt - planePos; \n    \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    vec3 planeCol = (mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0) ? planeCol1 : planeCol2;\n    return(planeCol);\n}\n\nvec3 getColorAtPoint(int object, vec3 pt, out Material objectMat){\n    if (object == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (object == sphere2Id)\n    {\n        objectMat = sphere2Mat;\n        return getSphere2ColorAtPoint(pt);\n    } \n    else if (object == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowCoeffAtPoint(Material object, vec3 pt, vec3 normal, vec3 lightPos, vec3 L){\n    vec3 null1, null2;\n    int null3;\n    \n    float distToL = distance(pt, lightPos);\n    float epsilon = 0.00001;\n    \n    float distIntersect = computeNearestIntersection(pt+normal*epsilon, L, null3, null1, null2);\n    \n    if(distIntersect < 0.0 || distIntersect >= distToL){\n        return(1.0);\n    } else {\n        return(object.Ka);\n    }\n}\n\nvec3 computePhongShader(float shadowCoeff, vec3 objectCol, Material objectMat, vec3 normalI, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant \t= objectMat.Ka*ambiantCol;\n    float cosTheta\t= max(dot(normalI,L),0.0);\n    float cosAlpha\t= max(dot(R, V),0.0);\n    \n    vec3 diffuse \t= objectMat.Kd*lightCol*objectCol*cosTheta;   \n    vec3 specular\t= objectMat.Ks*lightCol*pow(cosAlpha,objectMat.Kn);\n    \n    float shadowCoeffSpec = shadowCoeff<1.0 ? 0.0 : 1.0; \n    \n    return ambiant + diffuse*shadowCoeff + specular*shadowCoeff;\n}\n\nvec3 RayTraceAtPixelCoord(vec2 pixCoord){\n    \n\t// Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n\t\n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do{\n        \n        // Test ray-objects intersections and find the nearest one\n        // (with its associated intersection point and normal at the object surface)\n        int objectId;\n        vec3 intersectI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersectI, normalI);\n        \n        //We did not hit the sphere, so we have the sky color (here : black)\n        if (distI <= 0.0){\n            infos[nbBounces].shadeCol \t= skyCol;\n            infos[nbBounces].Ks\t\t\t= 0.0;\n            break;\n        }\n        \n        // Apply the shading to the points that are on the surface and seen by the camera\n\n        // Unit-vector from surface point to light\n    \tvec3 L = normalize(lightPos - intersectI);\n    \t// Unit-vector of reflection direction of the light at the surface point\n    \tvec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n    \t// Unit-vector from surface point to camera\n\t    vec3 V = normalize(cameraPos - intersectI);\n        \n\t    //Get point color\n    \tMaterial objectMaterial;\n\t    vec3 color = getColorAtPoint(objectId, intersectI, objectMaterial); \n        \n        float shadowCoeff;\n        shadowCoeff = getShadowCoeffAtPoint(objectMaterial, intersectI, normalI, lightPos, L);\n   \t \n    \tinfos[nbBounces].shadeCol \t= computePhongShader(shadowCoeff, color, objectMaterial, normalI, L, R, V);\n        infos[nbBounces].Ks\t\t\t= objectMaterial.Ks;\n                \n        // Bounce from the surface towards the reflected direction of the ray\n        rayPos = intersectI ;\n        rayDir = rayDir - 2.0*normalI*dot(rayDir, normalI);\n        \n        nbBounces++;\n    }\n    while(nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    for(int i=nbBounces; i>=0; i--){\n     \tresCol = infos[i].shadeCol + infos[i].Ks*resCol; \n    }\n    \n    return resCol;\n}\n\nvec2 noise2(vec2 location, vec2 delta){\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) * m)\n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Test intersection\n\tanimateCamera();\n    vec3 pixelCol = vec3(0);\n    for(int i=0; i<NB_SHOT_RAY; i++){\n\t    pixelCol += RayTraceAtPixelCoord(fragCoord + noise2(fragCoord,vec2(i,i*i)));\n    }\n    fragColor = vec4(pixelCol/FLT_NB_SHOT_RAY, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1355, 1620, 1641, 1641, 1855], [1857, 1857, 1939, 1939, 2389], [2391, 2391, 2506, 2506, 2778], [2780, 2780, 2898, 2898, 3291], [3294, 3294, 3410, 3410, 4459], [4461, 4461, 4497, 4497, 4522], [4524, 4524, 4561, 4561, 4587], [4589, 4589, 4624, 4624, 5019], [5021, 5021, 5087, 5087, 5467], [5469, 5469, 5559, 5559, 5908], [5910, 5910, 6027, 6027, 6434], [6436, 6436, 6477, 6554, 8536], [8538, 8538, 8577, 8577, 8797], [8800, 8800, 8857, 8881, 9109]], "test": "untested"}
{"id": "4llfW4", "name": "Time Travel Through Space", "author": "somesuch", "description": "Created by Kamil Kolaczynski (revers) - 2016\nModification by Somesuch -2017", "tags": ["tunnel", "space", "blue", "timetravel", "spacetravel"], "likes": 1, "viewed": 125, "published": "Public", "date": "1511883039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n * Modification by Somesuch -2017\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader, as always, uses a lot of code (raymarching, noise and lighting) credited to iq \n * [ https://www.shadertoy.com/view/Xds3zN ]. \n * Camera path is based on Shane's \"Subterranean Fly-Through\" [ https://www.shadertoy.com/view/XlXXWj ].\n * Additional specular lighting trick is based on \"Wet stone\" by TDM [ https://www.shadertoy.com/view/ldSSzV ].\n * Thanks for sharing great code guys!\n * \n * The shader was created and exported from Synthclipse [ http://synthclipse.sourceforge.net/ ].\n */\nconst float FOV = 1.5;\nconst float MarchDumping = 0.7579;\nconst float Far = 38.925;\nconst int MaxSteps = 128;\nconst float CameraSpeed = 2.5099998;\nconst float TunnelSmoothFactor = .5;\nconst float TunnelRadius = 4.85660005;\nconst float TunnelFreqA = 0.18003;\nconst float TunnelFreqB = 0.25;\nconst float TunnelAmpA = 3.6230998;\nconst float TunnelAmpB = 2.4324;\nconst float NoiseIsoline = 0.319;\nconst float NoiseScale = 10.9980001;\nconst vec3 Color = vec3(0.085, 0.658, 1.0);\n\n#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 200.0), hash(n + 200.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 11.0), hash(n + 11.0), f.x),\n\t\t\t\t\tmix(hash(n + 27.0), hash(n + 27.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise(p);\n\n\treturn f;\n}\n\n// by iq. http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.9 * (b - a) / k, 0.0, 1.0);\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\n// From \"Subterranean Fly-Through\" by Shane https://www.shadertoy.com/view/XlXXWj\nvec2 path(float z) {\n\treturn vec2(TunnelAmpA * sin(z * TunnelFreqA), TunnelAmpB * cos(z * TunnelFreqB));\n}\n\nfloat noiseDist(vec3 p) {\n\tp = p / NoiseScale;\n\treturn (fbm(p) - NoiseIsoline) * NoiseScale;\n}\n\nvec2 map(vec3 p) {\n\tfloat d = noiseDist(p);\n\tfloat d2 = length(p.xy - path(p.z)) - TunnelRadius;\n\td = smax(d, -d2, TunnelSmoothFactor);\n\n\tvec2 res = vec2(d, M_NOISE);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = M_NONE;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = M_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 10.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\t// material\n\t\tcol = Color + sin(t * 0.1) * 0.1;\n\t\tcol += 0.3 * sin(vec3(0.15, 0.02, 0.10) * iTime * 6.0);\n\n\t\t// lighitng\n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = -rd;\n\t\tfloat amb = clamp(0.5 + 0.005 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n\t\tvec3 ref = reflect(rd, nor);\n\t\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\n\t\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\t\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\t// Additional specular lighting trick,\n\t\t// taken from \"Wet stone\" by TDM\n\t\t// https://www.shadertoy.com/view/ldSSzV\n\t\tnor = normalize(nor - normalize(pos) * 0.2);\n\t\tref = reflect(rd, nor);\n\t\tspe = pow(clamp(dot(ref, lig), 0.0, 1.0), 100.0);\n\t\tbrdf += 2.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\n\t\tbrdf += 0.40 * amb * vec3(0.00, 0.70, 1.00) * occ;\n\t\tbrdf += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n\t\tcol = col * brdf;\n\n\t\tcol = mix(col, vec3(0.0), 1.0 - exp(-0.005 * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 rotationZ(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\n\treturn mat3(ca, sa, 0.0, -sa, ca, 0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tcoord *= FOV;\n\n    float t = iTime * CameraSpeed + 4.0 * 60.0;\n    vec3 ro = vec3(path(t), t);\n\n    t += 0.5;\n    vec3 target = vec3(path(t), t);\n    vec3 dir = normalize(target - ro);\n    vec3 up = vec3(-0.9309864, -0.33987653, 0.1332234) * rotationZ(iTime * 0.05);\n    vec3 upOrtho = normalize(up - dot(dir, up) * dir);\n    vec3 right = normalize(cross(dir, upOrtho));\n\n    vec3 rd = normalize(dir + coord.x * right + coord.y * upOrtho);\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llfW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1203, 1224, 1224, 1265], [1267, 1267, 1288, 1288, 1628], [1630, 1630, 1649, 1649, 1777], [1779, 1838, 1877, 1877, 1974], [1976, 2058, 2078, 2078, 2164], [2166, 2166, 2191, 2191, 2260], [2262, 2262, 2280, 2280, 2443], [2445, 2445, 2477, 2477, 2796], [2798, 2798, 2858, 2858, 3101], [3103, 3103, 3130, 3130, 3346], [3348, 3348, 3382, 3382, 3641], [3643, 3643, 3674, 3674, 4953], [4955, 4955, 4980, 4980, 5079], [5081, 5081, 5136, 5136, 5789]], "test": "untested"}
{"id": "4llfz8", "name": "RaymarchingCube", "author": "smkgames", "description": "Raymarching", "tags": ["3d", "raymarching", "tutorial", "sphere", "box"], "likes": 0, "viewed": 457, "published": "Public API", "date": "1510996999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Seyed Morteza Kamaly - SMK/2017\n\n//I could create this shader by helping this tutorial https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Constants.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\nmat2 rotate(float a) { \n    return mat2( cos(a), sin(a), -sin(a), cos(a) );\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Function of distance.\nfloat map( vec3 p ) {\n    p += vec3(0,-1,0); \n    p.xz *= rotate(iTime);\n    float Sphere = sdSphere(p,1.4);\n        float Box = sdBox(p,vec3(1.1));\n    return opS(Sphere,Box) ;\n   }\n\n// Gradient (numeric) function of the distance function.\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n\tvec3 n = normalize(grad(ro + t*rd));\n    return vec3(0.3, 0.8, 0.7)*pow(1.0-dot(-rd, n), 1.5);\n}\n\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Prepare the radius.\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n\n   \n    vec3 ro = vec3(0.0, 1.0, 3.0); // start of the radius.\n    vec3 rd = normalize(vec3(uv, -1.0)); // direction of the radius.\n    \n    // Loop do raymarcher.\n    float t = 0.0, d = EPS;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (d < EPS || t > FAR) break;\n        t += d;\n    }\n\n    // Shading.\n    vec3 col = d < EPS ? shade(ro, rd, t) : vec3(0.3, 0.6, 0.7)*(2.0-length(uv));\n    \n    // Post-processing. \n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 311, 333, 333, 388], [390, 390, 423, 423, 449], [451, 451, 486, 486, 510], [512, 512, 543, 543, 630], [632, 657, 678, 678, 839], [841, 898, 917, 917, 1097], [1099, 1099, 1138, 1138, 1236], [1243, 1243, 1300, 1327, 1950]], "test": "untested"}
{"id": "4lScW3", "name": "Black Amoeba", "author": "digorydoo", "description": "Simple 2D effect", "tags": ["2d", "distancefield", "simple"], "likes": 0, "viewed": 81, "published": "Public", "date": "1510235166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere (vec2 p, vec2 m, float r)\n{\n    return max (0.0, distance (p, m) - r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.y / iResolution.x;\n    screenPos.x /= ratio;\n    screenPos.x -= 0.5 * (iResolution.x - iResolution.y)\n        / iResolution.y;\n\n    int i;\n    float s = 1.0;\n    \n    for (i = 0; i < 10; i++)\n    {\n        float fi = float (i);\n        float x = 0.5 + 0.4 * cos (iTime * (0.1 + 0.1 * fi) + fi);\n        float y = 0.5 + 0.4 * sin (iTime * (0.1 + 0.2 * fi) + fi);\n        s = s * sphere (screenPos, vec2 (x, y), 0.125f);\n    }\n\n    fragColor =\n          s > 0.001    ? vec4 (0.5, 0.5, 0.5, 1.0)\n        : s > 0.0001   ? vec4 (0.2, 0.2, 0.2, 1.0)\n        : s > 0.00001  ? vec4 (0.3, 0.2, 0.1, 1.0)\n        : s > 0.000005 ? vec4 (0.7, 0.5, 0.1, 1.0)\n        :                vec4 (0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lScW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 85], [87, 87, 144, 144, 923]], "test": "untested"}
{"id": "4lsfRN", "name": "Toying with Pacman", "author": "budsan", "description": "Just a try to draw a pacman with simple shading", "tags": ["pacman"], "likes": 1, "viewed": 84, "published": "Public", "date": "1511196468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.yy) - vec2(ratio * 0.5, 0.5); // center is (0,0)\n    vec2 uvNorm = normalize(uv);\n    \n    float bodyRadius = 0.4f;\n    float z = sqrt((bodyRadius * bodyRadius) - (uv.x * uv.x + uv.y * uv.y));\n    vec3 bodyNormal = normalize(vec3(uv.xy, z));\n    \n    float shading = dot(bodyNormal, vec3(0,0,1));\n    float eyepos = dot(bodyNormal, normalize(vec3(0.6, 0.6, 1)));\n    float bodyMask = (1.0 - smoothstep(bodyRadius - 0.005, bodyRadius, length(uv)));\n    float fMouthTime = abs(sin(iTime * 8.0) * 0.4f);\n    float outMouth = max(step(0.0, -uvNorm.x), smoothstep(fMouthTime - 0.02, fMouthTime, abs(uvNorm.y)));\n    \n\tfragColor = vec4(0.9,0.9f,0.0f,1.0f) * bodyMask * shading * outMouth // body\n        * smoothstep(0.004, 0.005, 1.0 - eyepos) // eye hole\n        + vec4(1.0f) * (1.0f - shading) * bodyMask * outMouth; // external glow\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 978]], "test": "untested"}
{"id": "4lsfRr", "name": "DataVis", "author": "c0de517e", "description": "Test - WIP of palettes for data visualization", "tags": ["palette", "datavis"], "likes": 5, "viewed": 214, "published": "Public", "date": "1510800692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// One dimensional, sequential data. This is similar to Viridis palette\n// The idea is to have good range by being brighness linear but still exploit color and saturation\nvec3 ColorFn1D (float x)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\n\tfloat r = -0.121 + 0.893 * x + 0.276 * sin (1.94 - 5.69 * x);\n\tfloat g = 0.07 + 0.947 * x;\n\tfloat b = 0.107 + (1.5 - 1.22 * x) * x;\n\treturn vec3 (r, g, b);\n}\n\n// One dimensional, diverging data\nvec3 ColorFn1Ddiv (float y)\n{\n\ty = clamp (y, -1.0, 1.0); // optional\n\t\n#if 0\n\tfloat r = 0.569 + (0.396 + 0.834 * y) * sin (2.15 + 0.93 * y);\n\tfloat g = 0.911 + (-0.06 - 0.863 * y) * sin (0.181 + 1.3 * y);\n\tfloat b = 0.939 + (-0.309 - 0.705 * y) * sin (0.125 + 2.18 * y);\n#else // This one is more similar to ColorFn1D, if one cares:\n\tfloat r = 0.484 + (0.432 - 0.104*y)*sin(1.29 + 2.53*y);\n\tfloat g = 0.334 + (0.585 + 0.00332*y)*sin(1.82 + 1.95*y);\n\tfloat b = 0.517 + (0.406 - 0.0348*y)*sin(1.23 + 2.49*y);\n#endif\n\treturn vec3 (r, g, b);\n}\n\n// One dimensional, sequential data, two categories\nvec3 ColorFn1DtwoC (float x, int c)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\t\n\tfloat r, g, b;\n\tif (c == 0)\n\t{\n\t\tr = max (0.0, -0.724 + (2.52 - 0.865*x)*x);\n\t\tg = 0.315 + 0.589*x;\n\t\tb = x > 0.464 ? (0.302*x + 0.641) : (1.27*x + 0.191);\n\t}\n\telse\n\t{\n\t\tr = min (1.0, 0.5 + 1.36*x);\n\t\tg = max (0.0, -0.5 + (2.31 - 0.878*x)*x);\n\t\tb = 0.142 + 0.539*x*x*x;\n\t}\n\treturn vec3 (r, g, b);\n}\n\nvec3 ColorFn1DfiveC (float x, int c) // One dimensional, sequential data, up to five categories\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\t\n\tfloat r, g, b;\n\tswitch (c)\n\t{\n\t\tcase 1 :\n\t\tr = 0.22 + 0.71*x; g = 0.036 + 0.95*x; b = 0.5 + 0.49*x;\n\t\tbreak;\n\n\t\tcase 2 :\n\t\tr = 0.63 + 0.47*x; g = 0.1 + 0.8*x; b = 0.64*x;\n\t\tr = 0.48 + x * (1.7 + (-1.8 + 0.56 * x) * x);\n\t\tb = x * (-0.21 + x);\n\t\tbreak;\n\n\t\tcase 3 :\n\t\tr = 0.85*x; g = 0.33 + 0.69*x; b = 0.059 + 0.78*x;\n\t\tr = x * (-0.21 + (2.6 - 1.5 * x) * x);\n\t\tbreak;\n\n\t\tcase 4 :\n\t\tr = 0.83*x; g = 0.22 + 0.75*x; b = 0.52 + 0.5*x;\n\t\tr = 0.033 + x * (-0.35 + (2.7 - 1.5 * x) * x);\n\t\tb = 0.45 + (0.97 - 0.46 * x) * x;\n\t\tbreak;\n\n\t\tdefault :\n\t\tr = g = b = 0.025 + 0.96*x;\n\t}\n\treturn vec3 (r, g, b);\n}\n\n// One dimension is sequential, the other diverging - EXPERIMENTAL\nvec3 ColorFn2Ddiv (float x, float div)\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\tdiv = clamp (div, -1.0, 1.0); // optional\n\n#if 0\n\tdiv = div * 0.5 + 0.5;\n\tfloat r1 = (0.0812 + (0.479 + 0.267) * x) * div;\n\tfloat g1 = (0.216 + 0.407 * x) * div;\n\tfloat b1 = (0.323 + 0.679 * x) * div;\n\n\tdiv = 1.0 - div;\n\tfloat r2 = (0.0399 + (0.391 + 0.196) * x) * div;\n\tfloat g2 = (0.232 + 0.422 * x) * div;\n\tfloat b2 = (0.0910 + (0.137 - 0.213) * x) * div;\n    \n    return vec3(r1, g1, b1) + vec3(r2, g2, b2);\n#else\n    float r = 0.651 + (-0.427 - 0.138*div) * sin(0.689 + 1.95*div);\n    float g = 0.713 + 0.107*div - 0.0565*div*div;\n    float b = 0.849 - 0.13*div - 0.233*div*div;\n    \n    return vec3 (r, g, b) * (x * 0.7 + 0.3);\n#endif\n}\n\nvec3 ColorFn2D (float x, float y) // Two sequential dimensions - EXPERIMENTAL\n{\n\tx = clamp (abs (x), 0.0, 1.0); // optional\n\ty = clamp (abs (y), 0.0, 1.0); // optional\n\n#if 0\n\tfloat r = x;\n\tfloat g = 0.5*(x + 0.6)*y;\n\tfloat b = y;\n#else\n    x = x < 0.0433 ? 1.37 * x : x * (0.194 * x + 0.773) + 0.0254;\n\ty = y < 0.0433 ? 1.37 * y : y * (0.194 * y + 0.773) + 0.0254;\n    \n\tfloat r = x;\n\tfloat g = 0.6 * y;\n\tfloat b = 0.0;\n#endif\n\n\treturn vec3 (r, g, b);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tfloat plas;\n\tfloat p2 = 0.0;\n\n\tif (p.y <= 0.05) plas = p.x*2.0 - 1.0;\n\telse if (p.y <= 0.1) plas = p.x;\n\telse if (p.y <= 0.15) { plas = -p.x; p2 = 1.0; }\n\telse\n\t{\n\t\tp *= 0.25;\n\t\tfloat part1 = sin (p.x*(90.0 + 21.0*cos (p.y*0.0)) + time);\n\t\tfloat part2 = cos (p.y*(32.0 + 11.0*sin (p.x*57.0)) + time);\n\t\tfloat part3 = sin (p.x*(55.0 + 21.0*sin (p.y*32.0)) + time);\n\t\tplas = 0.5 + 0.65*part1*part2 + 0.35*part3*part2;\n\n\t\tp2 = sin (p.x*(30.0 + 20.0*cos (p.y*7.0)) + time);\n\t\tp2 *= cos (p.x*(20.0 + 50.0*sin (p.y*7.0)) + time);\n\t\tp2 += 0.25 * sin (p.x*(40.0 + 70.0*sin (p.y*7.0)) + time);\n\t}\n\n#if 0\n\tfragColor = vec4 (ColorFn2D (plas, p2), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn2Ddiv (plas, p2*2.0 - 1.0), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn1DfiveC (plas, int (p2*4.5)), 1.0);\n#elif 1\n\tfragColor = vec4 (ColorFn1DtwoC (plas, int (p2*2.0)), 1.0);\n#elif 0\n\tfragColor = vec4 (ColorFn1Ddiv (plas), 1.0);\n#else\n\tfragColor = vec4 (ColorFn1D (plas), 1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 171, 197, 197, 401], [403, 438, 467, 467, 977], [979, 1031, 1068, 1068, 1414], [1416, 1416, 1513, 1513, 2155], [2157, 2224, 2264, 2264, 2952], [2954, 2954, 3033, 3033, 3408], [3410, 3410, 3466, 3466, 4488]], "test": "untested"}
{"id": "4lsfzH", "name": "DiscoWibble", "author": "Del", "description": "Disco + Wibble?", "tags": ["plasma"], "likes": 1, "viewed": 164, "published": "Public", "date": "1511026445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n    \n\tvec2 p = fragCoord.xy/iResolution.xy;\n    \n    vec2 _p2 = 12.0*p;\n   float wibble = floor(fract(abs(_p2.x+_p2.y)-sin(_p2.y+iTime)/2.)*2.);\n    \n    float b1 =  2.0 * sin(p.x+time);\n    float b2 =  2.0 * cos(p.x*p.y+ time);\n    b1 = clamp(b1,0.85,1.25);\n    b2 = clamp(b2,0.85,1.25);\n    \n    float mag = 1.225;\n    mag += sin(time*0.25)*0.35;\n\tp*=mag;\n    \n    p.y *= 0.015;\n    p.x -= 4.0;\n    float p2 = sin (p.x*(20.0*cos (p.y*12.0)) + time);\n\tp2 *= cos (p.x*(15.0*sin (p.y*14.0)) + time);\n    \n    vec3 col1 = vec3(0.65,0.65,0.9);\n    vec3 col2 = vec3(0.6,0.52,0.95);\n    \n    col2.r += (wibble*0.25);\n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (p2<0.0)\n        col = col2 * abs(p2*b1);\n    else\n        col = col1 * p2*b2;\n\n    \n    fragColor = vec4(col.xyz,1.0);    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 863]], "test": "untested"}
{"id": "4lXBDH", "name": "try sphere", "author": "cailuming", "description": "sphere remarching, but no visibility test,and I don't know how to make visibility test", "tags": ["3dsphereraymarching"], "likes": 0, "viewed": 143, "published": "Public", "date": "1511770431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 200.\n#define BIAS 1.1\n\n// just draw a 3d point\nvec4 dawDot(vec3 eyePos,vec3 rayDir,vec3 center,vec4 color){\n    \n \n    float dist=0.;\n    float eyeToCenter=distance(center,eyePos);\n    vec3 detectP=vec3(1);\n    for(float i=0.;i<MAX_STEP;i++){\n       detectP=eyePos+rayDir*(eyeToCenter*(i/MAX_STEP));\n       dist=distance(detectP,center);\n    }\n   \n    dist=0.1/dist;\n    \n    \n    vec4 col=vec4(dist,dist,dist,detectP.z)*color;\n    return col;\n}\n\n// draw a sphere\nvec4 drawSphere(vec3 eyePos,vec3 rayDir,vec3 center,float radius,vec3 lightPos,vec4 color){\n   \n    vec3 detectP=vec3(1.);\n    vec4 col=vec4(0,0,0,0);\n    vec3 sphereNorm=vec3(0,0,0);\n    \n    float eyeToCenter=distance(center,eyePos)-radius+BIAS;\n    float nl=0.;\n    float dist=0.;\n    \n    for(float i=0.;i<MAX_STEP;i++){\n       detectP=eyePos+rayDir*(eyeToCenter*(i/MAX_STEP));\n       dist=distance(detectP,center);\n       if(dist<=radius){        \n           \n            //calculate the norm\n            sphereNorm=normalize(detectP-center);\n            vec3 lightDir=normalize(lightPos-detectP);\n            nl=clamp(dot(lightDir,sphereNorm),0.1,1.);\n            break;\n       }\n    }\n    float fnl=mix(nl,pow(nl,60.),0.4);\n    col=vec4(fnl,fnl,fnl,detectP.z)*color;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 uvc=2.*uv-vec2(1);\n    vec3 scnPos=vec3(uvc,0);\n    vec3 eyePos=vec3(0,0,-3);\n    float time=iTime;\n    float freq=texture(iChannel0,vec2(vec2(iTime,iTime))).y;\n    vec3 rayDir=normalize(vec3(scnPos-eyePos));\n    vec3 lightPos=vec3(cos(time)*0.6,sin(time)*0.8+freq*0.2,-5.*cos(time)+3.2);\n    vec4 col =vec4(0);\n    \n   \n    vec4 col1=dawDot(eyePos,rayDir,lightPos,vec4(cos(iTime),1,0.3,1));\n    vec4 col2=drawSphere(eyePos,rayDir,eyePos+vec3(0,0,1)*6.,0.5,lightPos,vec4(1,0,0.3,1));\n    vec4 col3=drawSphere(eyePos,rayDir,eyePos+vec3(0.2,0,1)*5.,0.5,lightPos,vec4(.6,cos(iTime),0.3,1));\n    vec4 col4=drawSphere(eyePos,rayDir,eyePos+vec3(0.5,0,1)*5.,0.5,lightPos,vec4(cos(iTime),1,0.3,1));\n    \n    col=col1;\n    \n    if(col2.z<col1.z){\n       col=col2;\n    }\n    if(col3.z<col2.z){\n       col=col3;\n    }\n    if(col4.z<col3.z){\n       col=col4;\n    }\n    \n\tfragColor = vec4(col1+col2+col3+col4);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 64, 124, 124, 462], [464, 481, 572, 572, 1272], [1274, 1274, 1331, 1331, 2286]], "test": "untested"}
{"id": "4lXfDr", "name": "sine dots ( 74 chars )", "author": "FabriceNeyret2", "description": "Just wait :-)", "tags": ["aliasing", "short", "onetweet", "golf"], "likes": 1, "viewed": 387, "published": "Public API", "date": "1511564438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 U) { O += 1./ ( U.y - iResolution.y * ( .5+ .5* sin( .01* iTime* U.x ) ) ); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 109]], "test": "untested"}
{"id": "4lXfWH", "name": "Active Flowers", "author": "dr2", "description": "Lots of colorful flowers", "tags": ["raymarch", "flower", "hexagon"], "likes": 8, "viewed": 548, "published": "Public API", "date": "1511701732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Active Flowers\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, gSize, szFac, rotAng, rotAngF, dTwist;\nint idObj;\nconst float pi = 3.14159;\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a, r, h;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId);\n  p.xz = Rot2D (p.xz, rotAngF);\n  p.z -= 0.1;\n  p /= szFac;\n  q = p;\n  h = 1.5;\n  d = 0.8 * max (length (Rot2D (q.xz - vec2 (0., 0.07), 4. * pi * dTwist * q.y / h) -\n     vec2 (0., 0.03)) - (0.06 - 0.015 * q.y / h + 0.005 * sin (4. * pi * q.y)), abs (q.y - h) - h);\n  if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  q = p;\n  r = length (q.xz);\n  h = 0.2 * (0.8 - r);\n  d = 0.8 * max (max (r - 0.8, abs (q.y - h) - h), - q.y);\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = q; }\n  p.xz = Rot2D (p.xz, rotAng);\n  qq = p;\n  qq.y -= 3.1;\n  qq.yz = Rot2D (qq.yz, 0.3 * pi + 0.1 * rotAng);\n  q = qq;\n  r = length (q.xz);\n  d = max (r - 0.25, abs (q.y) - 0.1 * (1. - 1.5 * r));\n  if (d < dMin) { dMin = d;  idObj = 3;  qHit = q; }\n  d = length (q - vec3 (0., clamp (q.y, -0.2, 0.), 0.)) - 0.15;\n  if (d < dMin) { dMin = d;  idObj = 4;  qHit = q; }\n  for (float k = 0.; k < 2.; k ++) {\n    q = qq;\n    if (k > 0.) q.xz = Rot2D (q.xz, pi / 6.);\n    a = atan (q.z, - q.x);\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a / (2. * pi) + 0.5) / 6.));\n    q.x += 0.2;\n    q.y -= 0.01 * (1. - 2. * k) + 0.4 * dot (q.xz, q.xz);\n    q.z *= 2.5;\n    d = 0.5 * max (length (q.xz + vec2 (0.4, 0.)) - 0.5, abs (q.y) - 0.03 * (1.2 - length (q.xz)));\n    if (d < dMin) { dMin = d;  idObj = 5;  qHit = q; }\n  }\n  return szFac * dMin;\n}\n\nvoid SetFlwConf ()\n{\n  float s;\n  s = length (vec3 (gId.xy, gId.x + gId.y)) / gSize;\n  szFac = 0.7 * (1. - 0.2 * s * s + 0.2 * (Hashfv2 (17. * gId + 99.) - 0.5));\n  s = Hashfv2 (23. * gId + 99.) - 0.5;\n  dTwist = sign (s);\n  s = max (0.1, abs (s)) * dTwist;\n  rotAngF = 0.2 * pi * s;\n  rotAng = 0.3 * pi * (sin (pi * s * (tCur + 10.)) + s) - rotAngF;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = (SQRT3/2.) - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= gSize) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetFlwConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.005;\n      pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.002, -0.002, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + rd * d;\n    gId = PixToHex (p.xz);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= gSize) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetFlwConf ();\n      }\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n      d += clamp (h, 0.05, 0.5);\n    } else d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, a, sh, hue, spec, glit;\n  bool isBg;\n  gSize = 12.;\n  isBg = true;\n  spec = 0.1;\n  glit = 0.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz);\n    vn = ObjNf (ro);\n    hue = Hashfv2 (gId * vec2 (17., 27.) + 0.5);\n    if (idObj >= 3) a = atan (qHit.z, - qHit.x) / (2. * pi);\n    if (idObj == 1) {\n      col = vec3 (0.7, 0.4, 0.);\n      vf = vec2 (64., 2.);\n    } else if (idObj == 2) {\n      col = mix (vec3 (0.4, 0.1, 0.), vec3 (0.1, 0.4, 0.), Fbm2 (16. * ro.xz));\n      vf = vec2 (16., 10.);\n    } else if (idObj == 3) {\n      col = HsvToRgb (vec3 (mod (hue + 0.6, 1.), 1., 0.7)) *\n         (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, mod (16. * a, 1.)));\n      vf = vec2 (32., 1.);\n    } else if (idObj == 4) {\n      col = HsvToRgb (vec3 (mod (hue + 0.1, 1.), 0.7, 1.)) *\n         (0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, mod (8. * a, 1.)));\n      vf = vec2 (64., 1.);\n    } else if (idObj == 5) {\n      col = HsvToRgb (vec3 (mod (hue, 1.), 0.7 + 0.3 * mod (7. * hue, 1.), 1.));\n      col *= 1. - 0.1 * SmoothBump (0.05, 0.95, 0.01, mod (16. * a, 1.));\n      spec = 0.05;\n      glit = 500. * step (0.01, max (0., dot (vn, sunDir))) *\n         pow (max (0., dot (sunDir, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (1000. * ro, vn, 2.))), 8.);\n      vf = vec2 (128., 0.1);\n    }\n    vn = VaryNf (vf.x * qHit, vn, vf.y);\n    sh = ObjSShadow (ro, sunDir);\n  } else if (rd.y < 0.) {\n    isBg = false;\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 5. * (1. - smoothstep (0.5, 1., dstObj / dstFar)));\n    sh = (dstObj < dstFar) ? ObjSShadow (ro, sunDir) : 1.;\n    col = mix (vec3 (0.4, 0.1, 0.), vec3 (0.1, 0.4, 0.), Fbm2 (16. * ro.xz));\n  }\n  if (isBg) col = vec3 (0., 0., 0.2);\n  else {\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) + vec3 (1., 1., 0.5) * sh *\n       (glit + spec * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.));\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi;\n  el = -0.13 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az +=  pi * (SmoothBump (0.25, 0.75, 0.25, mod (0.01 * tCur, 1.)) - 0.5);\n  }\n  el = clamp (el, - 0.4 * pi, -0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -45.);\n  zmFac = 15. - 10. * SmoothBump (0.25, 0.75, 0.15, mod (az / pi, 1.));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.1, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXfWH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 469, 493, 493, 723], [725, 725, 749, 749, 809], [811, 811, 833, 833, 2243], [2245, 2245, 2265, 2265, 2597], [2599, 2599, 2632, 2632, 3751], [3753, 3753, 3774, 3774, 3976], [3978, 3978, 4015, 4015, 4523], [4525, 4525, 4560, 4560, 6686], [6688, 6688, 6741, 6741, 7703], [7705, 7705, 7729, 7729, 7865], [7867, 7867, 7897, 7897, 7955], [7957, 7957, 8014, 8014, 8097], [8131, 8131, 8155, 8155, 8215], [8216, 8216, 8240, 8240, 8370], [8372, 8372, 8397, 8397, 8583], [8585, 8585, 8606, 8606, 8761], [8763, 8763, 8792, 8792, 9004], [9006, 9006, 9045, 9045, 9252]], "test": "untested"}
{"id": "4lyXWW", "name": "FFT-IFS", "author": "nshelton", "description": "fft ifs", "tags": ["fft", "ifs"], "likes": 15, "viewed": 513, "published": "Public", "date": "1511766087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define MAX_ITER 20\n#define MAX_ITER 50\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nmat3 ir;\n\nfloat DE(vec3 p) \n{\n\tvec3 p_o = p;\n    float d = 1e10;\n    \n    float s = 1.; //sin(iTime /60.0) / 10.0 + 0.6;\n    vec3 t = vec3(0.1 + 0.2 * iMouse.xy/iResolution.xy, 0.1 + 0.1 * sin(iTime/200.));\n    \n    float fftVal = texture(iChannel0,vec2(length(p/5.), 0.2)).x *0.1;\n    vec3 dim = vec3( fftVal, 0.9, fftVal);\n    \n    for ( int i = 0; i < 6; i ++)\n    {\n        p -= t*s;\n        p = (ir * (p-t/s));\n        \n     \t//d = min\t(d, udBox(p*s, dim/s) /s);\n\n \t\tp = abs(p);\n        \n        \n        \n        float circleSize = fftVal + 0.03 * (sin(iTime + length(p_o) * 5.) )\n            + 0.01;\n        d = min(d, length(p - t) - circleSize/s);\n        s *= s;\n\t\t\n    }\n\n\n    return d;\n}\n\n\nfloat lighting( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.01;\n    \n    float k = 12.0;\n    \n    for( int i = 0; i < 2; i++ )\n    {\n        float h = DE(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        res = min( res,k * h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 gradient(vec3 p) {\n\tvec2 e = vec2(0., 0.0001);\n\n\treturn normalize(\n\t\tvec3(\n\t\t\tDE(p+e.yxx) - DE(p-e.yxx),\n\t\t\tDE(p+e.xyx) - DE(p-e.xyx),\n\t\t\tDE(p+e.xxy) - DE(p-e.xxy)\n\t\t)\n\t);\n}\n\n\n\n\n//http://iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = .9 + 20.0 / float(MAX_ITER);\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.1,0.1,0.0), \n                           vec3(1.0,0.9,0.7),\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 cam = vec3(0,0, - sin(iTime /32. ) - 2.0);\n    vec3 ray = normalize( vec3(uv, 1.0));\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    vec3 p;\n    float depth = 0.0;\n    bool hit = false;\n    float iter = 0.0;\n    \n    float fog = 0.0;\n    vec3 sun = normalize( vec3(1,1,1));\n\n    ir = rotationMatrix(normalize(vec3(sin(iTime/50.0),sin(iTime/100.0),sin(iTime/150.0))), 1.5 + iTime/30.0);\n    \n    mat3 mv = rotationMatrix(vec3(0,1,0), iTime/10.0);\n        \n    cam = mv * cam;\n    ray = mv * ray;\n        \n    for( int i= 0; i < MAX_ITER; i ++) {\n        p = depth * ray + cam;\n        float dist = DE(p);\n        \n  \n        \tdepth += dist * 0.9;\n         \n        \n        if ( dist < 0.001)\n        {\n        \thit = true;\n            break;\n        }\n        \n        iter ++;\n    }\n    float fakeAO = 1.0 - iter / float(MAX_ITER);    \n    vec3 n = gradient(p);\n    \n\n    if (hit) {\n    \tcolor = vec3(fakeAO + dot(-ray,n) / 2.0);\n    }\n\n        \n\tcolor = applyFog(color, depth, ray, sun) ;\n    \n   //color *= vec3(1.0 - fog);\n    \n    color = pow(color, vec3(0.6));\n\n    \n\tfragColor = vec4(color ,1.0);\n}\n\n\n\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 88, 88, 528], [531, 531, 562, 562, 600], [612, 612, 631, 631, 1301], [1304, 1304, 1345, 1345, 1617], [1619, 1619, 1642, 1642, 1797], [1802, 1851, 2096, 2096, 2432], [2435, 2435, 2492, 2492, 3736]], "test": "untested"}
{"id": "4t2cDy", "name": "462 Shader Quiz", "author": "KeenanCrane", "description": "Fill in the \"TODOs\" in the method shade() at the top of the program.", "tags": ["educational", "material"], "likes": 2, "viewed": 592, "published": "Public", "date": "1510021420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\nvec3 shade( in vec3 N, in vec3 L, in vec3 V, in vec3 R )\n{   \n    // color of each term\n    vec3 diffuseColor = vec3(1,0,0);\n    vec3 specularColor = vec3(1,.8,.5);\n    vec3 fresnelColor = vec3(1,1,1);\n    vec3 ambientColor = vec3(1,1,1);\n    \n    // intensity of each term\n    float kd = .9;\n    float ks = .6;\n    float kf = .4;\n    float ka = .03;\n    \n    // tuning parameters\n    float k = 10.; // specular glossiness\n    float p = 5.; // fresnel sharpness\n    \n    // TODO add the diffuse term\n    float diffuse = 0.;\n    \n    // TODO add the specular term\n    float specular = 0.;\n    \n    // TODO add the fresnel term\n    float fresnel = 0.;\n    \n    // TODO add the ambient term\n    float ambient = 0.;\n    \n    return kd * diffuse * diffuseColor +\n           ks * specular * specularColor +\n           kf * fresnel * fresnelColor +\n           ka * ambient * ambientColor ;\n}\n\n//------------------------------------------------------------------------------\n// (Nothing to edit below this line)\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    \n    vec3 color = vec3(0,0,0);\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n\n    // We've hit something in the scene\n    if (hit.y > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l1 = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 l2 = normalize(vec3(-0.6, 0.5, 0.7));\n        vec3 r = normalize(reflect(direction, n));\n\n\n        vec3 diffuseColor;\n        \n        if (hit.y < 4.0)  {\n            // sphere\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            diffuseColor = 0.4 + f * vec3(0.6);\n            color = diffuseColor;\n        } else if (hit.y < 16.0) {\n            // sphere\n            diffuseColor = vec3(0.3, 0.0, 0.0);\n            color  = shade( n, l1, v, r );\n            color += shade( n, l2, v, r );\n        }\n    }\n\n    return color;\n}\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0,.4,0);\n\n    origin.x += 1.1 * cos(iTime * 0.2);\n    origin.z += 1.1 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.8, 0.8, 1.0), 1.0 - exp2(-0.1 * distance * distance));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 123, 152, 949], [951, 1151, 1177, 1177, 1195], [1197, 1197, 1233, 1233, 1261], [1263, 1263, 1300, 1300, 1358], [1360, 1360, 1392, 1392, 1428], [1430, 1430, 1460, 1460, 1621], [1623, 1623, 1673, 1673, 1996], [1998, 1998, 2029, 2029, 2349], [2351, 2351, 2419, 2419, 3378], [3380, 3380, 3444, 3444, 3696], [3698, 3698, 3753, 3783, 4461]], "test": "untested"}
{"id": "4t2cz3", "name": "testing portals", "author": "abje", "description": "portals are super boring, they just move 2 truchet cells in the direction it's facing", "tags": ["test"], "likes": 1, "viewed": 215, "published": "Public API", "date": "1509565572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define dir3(num) vec3(equal(abs(dir),vec3(num)))\n\n#define dot2(p) dot(p,p)\n\n#define pi acos(-1.0)\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\nfloat mid(vec3 p) {\n    //if(var3)\n    p = min(p,p.yzx);\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat torus(vec3 p, vec2 r) {//creates 4 toruses\n    return length(vec2(abs(abs(length(p.xy)-r.x)-0.05),abs(p.z)-0.05))-r.y;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 p2 = mod(p,2.0)-1.0;\n    vec3 floorpos = floor(p*0.5);\n    float len = 1e10;\n    \n    //the truchet flipping\n    vec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0;\n    \n    //actually flipping the truchet\n    vec3 p3 = p2*flipping;\n    \n    //positions relative to truchet centers\n    mat3 truchet = mat3(\n        vec3(+p3.yz+vec2(-1.0, 1.0),p3.x),\n        vec3(+p3.zx+vec2(-1.0, 1.0),p3.y),\n        vec3(+p3.yx+vec2( 1.0,-1.0),p3.z)\n    );\n    \n    //finding distance to truchet\n    len = min(min(\n        torus(truchet[0],vec2(1.0,0.01)),\n        torus(truchet[1],vec2(1.0,0.01))),\n        torus(truchet[2],vec2(1.0,0.01)));\n    \n    return len;\n}\n\n//normal calculation\nvec3 findnormal(vec3 p, float len) {\n    const vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec3(\n        len-map(p-eps.xyy),\n        len-map(p-eps.yxy),\n        len-map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 floorpos = vec3(0.0,0.0,0.0);\n    vec3 pos = vec3(1.0,1.0,0.0);\n    vec3 dir = vec3(3.0,2.0,1.0);\n    int num = 2;\n    float time = abs(mod(iTime*0.4+50.0,100.0)-50.0);\n    for (float i = 0.0; i <= floor(time); i++) {\n        \n        pos += dir*dir3(1);\n        \n    \tvec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n        \n        dir *= flipping;\n        \n        int num2 = (num-int(dot(dir,dir3(1)))+3)%3;\n        float back = dir[num2];\n        dir[num2] = dir[num];\n        dir[num] = -back;\n        num = num2;\n        \n        dir *= flipping;\n        \n        vec3 portalpos = floorpos+dir*dir3(1)*0.5;\n        if (hash31(portalpos) < 0.2) {\n            floorpos += dir*dir3(1)*2.0;\n        \tpos += dir*dir3(1)*4.0;\n        }\n        floorpos += dir*dir3(1);\n        pos += dir*dir3(1);\n    }\n\t\n    vec3 flipping = floor(hash33(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n    vec3 dir2 = dir;\n    \n    dir *= flipping;\n    \n    int num2 = (num-int(dot(dir,dir3(1)))+3)%3;\n    float back = dir[num2];\n    dir[num2] = dir[num];\n    dir[num] = -back;\n    num = num2;\n    \n    dir *= flipping;\n\t\n    //animation\n    pos += dir2*vec3(equal(abs(dir2),vec3(1.0)))*(sin(fract(time)*3.14*0.5));\n    pos += dir*dir3(1)*(1.0-cos(fract(time)*3.14*0.5));\n    \n    //normal pointing towards where the camera moves, would be nice if the camera was looking in that direction\n    vec3 forward = dir2*vec3(equal(abs(dir2),vec3(1.0)))*cos(fract(time)*3.14*0.5)+dir*dir3(1)*sin(fract(time)*3.14*0.5);\n    \n    /*\n    mat3 rotation = mat3(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0));\n    rotation[2] = forward;\n    rotation[1] = normalize(cross(forward,vec3(1)));\n    rotation[0] = cross(rotation[1],forward);\n    */\n    \n    mat3 rotation = mat3(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0));\n    \n    vec2 t = vec2(cos(fract(time)*3.14*0.5),sin(fract(time)*3.14*0.5));\n\trotation[2] = normalize(dir2*vec3(equal(abs(dir2),vec3(1)))*t.x+dir*dir3(1)*t.y);\n    rotation[1] = normalize(dir2*vec3(equal(abs(dir2),vec3(2)))*t.x+dir*dir3(2)*t.y);\n    rotation[0] = normalize(dir2*vec3(equal(abs(dir2),vec3(3)))*t.x+dir*dir3(3)*t.y);\n    \n    \n    \n    vec3 ro = pos+rotation[1]*0.125;\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    rd = rd*transpose(rotation);\n    \n    \n    bool hit = false;\n    float len;\n    float dist = 0.0;\n    \n    //floorpos = floor(ro*0.5);\n    vec3 signdir = sign(rd);\n    vec3 invdir = 2.0/(abs(rd)+0.0001);\n    vec3 dists = abs(-signdir*0.5-0.5+ro*0.5-floorpos)*invdir;\n    \n    for (int i = 0; i < 100; i++) {\n        float smallest = min(min(dists.x,dists.y),dists.z);\n        len = map(ro);\n        if (len < 1.0/iResolution.y*dist||dist>10.0) {\n            hit = dist < 10.0;//len < 0.01*dist;\n            break;\n        }\n        \n        len = min(len,smallest);\n        \n        ro += rd*len;\n        dist += len;\n        \n        smallest -= len;\n        dists -= len;\n        if (smallest <= 0.0) {\n            vec3 mask = step(dists,vec3(smallest));\n            vec3 localpos = (ro+dot(mask*dists,vec3(1))*rd) - floorpos*2.0-1.0;\n            \n            vec2 q = vec2(dot(mask.yzx,localpos),dot(mask.zxy,localpos));\n            \n            vec3 portalpos = floorpos+mask*signdir*0.5;\n            vec4 random = vec4(hash31(portalpos),hash33(portalpos));\n            random.x = random.x/0.2;\n            //vec3 randompos = floor(hash33(portalpos)*100.0-50.0);\n            \n            float t = iTime*random.x+random.y;\n            float portalsize =\n                length(q)\n                +sin(atan(q.x,q.y)* 8.0+t    )*0.04*sin(t*2.0)\n                +sin(atan(q.x,q.y)*16.0+t*1.5)*0.02*sin(t*4.0);\n            \n            if (random.x > 1.0) portalsize+=100.0;\n            if (portalsize < 0.4) {\n                //vec3 randdirection = vec3(equal(vec3(1,2,3),vec3(clamp(floor(random.x*3.0),0.0,3.0))));\n                \n                floorpos += mask*signdir;\n                vec3 localpos = ro-floorpos*2.0;\n                floorpos += mask*signdir*2.0;\n                ro = floorpos*2.0+localpos;\n                \n                //randdirection *= floor(0.5+random.yzw)*2.0-1.0;\n                \n            } else if (portalsize < 0.45) {\n                fragColor = vec4(-mask*signdir*0.5+0.5,1);\n                fragColor = vec4(random.yzwx);\n                return;\n            } else {\n                floorpos += mask*signdir;\n            }\n            dists = (1.0-mask)*dists+mask*invdir;\n        }\n        \n    }\n    if (hit) {\n        \n\t\tfragColor = vec4(findnormal(ro,len)*0.5+0.5,1.0);\n        fragColor /= (dist*dist*0.05+1.0);\n        //if (all(equal(floor(ro*0.5),floorpos))) fragColor = 1.0-fragColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 358, 380, 380, 489], [491, 561, 584, 584, 687], [689, 689, 708, 723, 781], [783, 783, 812, 831, 909], [911, 911, 930, 930, 1596], [1598, 1619, 1655, 1655, 1812], [1814, 1814, 1871, 1871, 6830]], "test": "untested"}
{"id": "4t2yR3", "name": "Colored Sphere and Cube", "author": "nhoughto", "description": "Using the distance function of a sphere and a cube to display overlap.", "tags": ["3d", "cube", "sphere"], "likes": 0, "viewed": 96, "published": "Public", "date": "1509547168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Referencing the tutorial here: http://fabricecastel.github.io/blog/2016-02-11/main.html\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nconst float S = 0.01;\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, vec3 center){\n    return length(center - p) - 1.0;\n}\n\nfloat distanceToNearestSurface(vec3 p){\n  float amp = 2.0;\n  return min(cube(p), sphere(p, vec3(amp * cos(iTime), amp * sin(iTime), 0.0)));\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n    \tdistanceToNearestSurface(p + deltax)-d,\n        distanceToNearestSurface(p + deltay)-d,\n        distanceToNearestSurface(p + deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n                \nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime),\n                             \t30.0 * cos(iTime),\n                              \t30.0 * cos(iTime));\n            return computeLambert(hit, computeSurfaceNormal(hit), light);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n  \t// camera attributes\n    // cameraDirection and cameraUp MUST be normalized\n    // (ie. their length must be equal to 1)\n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(cameraDistance * sin(iTime), 0, cameraDistance * cos(iTime));\n    vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0 * cos(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n\tvec3 pixelColor = intersectsWithWorld(cameraPosition, rayDirection);\n    pixelColor.r *= cos(iTime);\n    pixelColor.g *= 2.0 * sin(1.0 * iTime);\n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2yR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 337, 356, 356, 482], [484, 484, 518, 518, 557], [559, 559, 598, 598, 700], [702, 702, 736, 736, 956], [958, 958, 1002, 1002, 1045], [1063, 1063, 1106, 1106, 1625], [1627, 1627, 1684, 1684, 2697]], "test": "untested"}
{"id": "4tBcDt", "name": "Glimmer", "author": "pn", "description": "layers upon layers, twisting and turning", "tags": ["procedural", "2d", "patterns"], "likes": 4, "viewed": 131, "published": "Public", "date": "1510498294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Try changing these:\nconst int layerCount = 6;\nconst float layerAlpha = 0.3;\nconst float spatialFrequency = 50.0;\nconst float fisheyeFactor = 4.0;\nconst float baseMagnification = 1.1;\nconst float speed = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y;\n    \n    float time = (iTime + 256.0) * 0.01 * speed;\n    \n    float totalIntensity = 0.0;\n    float angle = time;\n    mat2 rotation = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    for (int i = 0; i < layerCount; ++i)\n    {\n        position *= rotation;\n        position *= pow((sin(time * 50.0)*0.01 + baseMagnification), - fisheyeFactor * length(position));\n        \n    \tvec2 fromGrid = fract(position * spatialFrequency) * 2.0 - 1.0;\n        float distanceFromGrid = length(fromGrid);\n    \tfloat circles = smoothstep(0.5, 0.6, distanceFromGrid);\n        totalIntensity += circles * layerAlpha;\n        \n        \n    }\n    fragColor = vec4(vec3(1.0 - totalIntensity), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 212, 269, 269, 1036]], "test": "untested"}
{"id": "4tBcRt", "name": "Volumic lines", "author": "CoyHot", "description": "Trying to simulate 3D moving shapes, only using 2D lines and offset tricks", "tags": ["2d", "volume", "lines"], "likes": 4, "viewed": 122, "published": "Public", "date": "1509656516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t-------------\n\tVolumic lines\n\t-------------\n\n\tTrying to simulate 3D moving shapes, only using 2D lines and offset tricks\n\n\tFrancois 'CoyHot' Grassard - 2017\n*/\n\n#define DispStrenght 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5)/vec2(iResolution.y / iResolution.x, 1);\n    \n   \n\tuv.x *= 10.;\n\n\tfragColor = vec4(sin((atan(exp(abs(uv.x)*(-1.)),uv.y)+iTime/2.+uv.x+uv.y)*10.)); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 191, 248, 248, 446]], "test": "untested"}
{"id": "4tByDV", "name": "Sun burning a Planet", "author": "twenkid", "description": "Playing with Przemyslaw Zaworski's: https://www.shadertoy.com/view/llscW7 (Thanks!) Added the Sun (the planet may be hidden), planet's \"dance\", \"heating\" patterns, rotation of the planet over Z, parameters, comments. (...) Version 1.0, 8-11-2017", "tags": ["burn", "sun", "planet"], "likes": 1, "viewed": 226, "published": "Public", "date": "1510118263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A study/play, based on: \n//https://www.shadertoy.com/view/llscW7\n//Author: Przemyslaw Zaworski, 12.09.2017, version 1.1\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Extended by Todor Arnaudov, who has added:\n// The Sun (by changing the background gradient),\n// Planet's trajectory with some matrices multiplications,\n// \"Burning\" of the \"surface\"; mouse Y now rotates the planet also over the Z axis.\n// The grid is turned off.\n//\n// The \"burn\" pattern could be better synchronized to adjust the interaction, such as:\n// turning red-black exactly on the sides that are turned to the sun and when the planet is approaching it etc.\n//\n// Currently it is \"some changes/play\" with formulas in two variants.\n//\n// Future work: more sync, black background with stars, bump-mapped planet?, clouds?, comets?, asteroids?, moon?,\n// ... correctly rotating around the sun/the planet?\n// ... a watermellon pattern?\n//\n// Version 1.0, 8-11-2017\n\n\n// Comment to hide the planet\n#define PLANET 1;\n\n// Increase for a huge sun, covering the whole screen. 0.1 - 0.3 for a small one, going dark\nconst float sunSize = 0.95; //1.13; //1.39; \n\n\nfloat generate_map = 50.0;\n\nconst int ssaa=4;\n\nmat2 rotation(float x)\n{\n    return mat2(cos(x),-sin(x),sin(x),cos(x));\n}\n\nfloat noise (vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin_a (vec3 n)\n{\n    vec3 x = floor(n * 64.0) * 0.015625;\n    vec3 k = vec3(0.015625, 0.0, 0.0);\n    float a = noise(x);\n    float b = noise(x + k.xyy);\n    float c = noise(x + k.yxy);\n    float d = noise(x + k.xxy);\n    vec3 p = (n - x) * 64.0;\n    float u = mix(a, b, p.x);\n    float v = mix(c, d, p.x);\n    return mix(u,v,p.y);\n}\n\nfloat perlin_b (vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z * 64.0) * 0.015625);\n    vec3 dd = vec3(0.015625, 0.0, 0.0);\n    vec3 p = (n - base) *  64.0;\n    float front = perlin_a(base + dd.yyy);\n    float back = perlin_a(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.1;\n    for (int i = 0; i < 5; i++)\n    {\n        t += perlin_b(n * a) * b;\n        a *= 0.5;\n        b *= 2.0;\n    }\n    return t;\n}\n\nvec3 heightmap (vec3 n)\n{\n\treturn vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);\n}\n\nvec3 grid(vec2 p)\n{\n    return vec3(1.0)*smoothstep(0.99,1.0,max(sin((p.x)*32.0),sin((p.y)*32.0)));\n}\n\nfloat sphere(vec3 ro, vec3 rd)\n{\n    float b = dot(ro,rd);\n    float c = dot(ro,ro)-1.0;\n    float h = b*b-c;\n    return (h<0.0)?-1.0:-b-sqrt(h);\n}\n\nvec3 atlas(vec2 uv)\n{    \n \tfloat color = clamp(vec4(vec3((heightmap(vec3(uv*5.0,generate_map)*0.02)-1.0)),1.0).r,0.0,1.0);\n    return \n    color<0.10 ? vec3(0.77,0.90,0.98):\n    color<0.20 ? vec3(0.82,0.92,0.99):\n    color<0.30 ? vec3(0.91,0.97,0.99):\n    color<0.55 ? vec3(0.62,0.75,0.59):\n    color<0.65 ? vec3(0.86,0.90,0.68):\n    color<0.75 ? vec3(0.99,0.99,0.63):\n    color<0.85 ? vec3(0.99,0.83,0.59):\n    color<0.95 ? vec3(0.98,0.71,0.49):     \n    color<0.99 ? vec3(0.98,0.57,0.47):              \n    vec3(0.79,0.48,0.43); \n}\n\n//ro - ray origin, rd - ray direction, p - polar(spherical) coordinates? over the planet\nvec3 raycast (vec3 ro, vec3 rd, vec2 p)\n{\n    float pattern=abs(cos(iTime/5.0));\n#ifdef PLANET\n    float t = sphere(ro,rd);\n    if (t > 0.0)\n    {\n    \tvec3 d = ro+rd*t;\n        p=vec2(acos(d.y/length(d)), atan(d.z,d.x));  \n                \n        //vec3 ret =  (atlas(p).xyz+grid(p*3.0));\n        vec3 ret =  (atlas(p).xyz); //no grid\n        //ret+=(1.0, 0.0, 0.0);\n        ret+= (vec3(max(min(abs(d.z), abs(d.y))/2., sin(d.z))+abs(sin(iTime/5.0)*2.), -max(d.z, d.y)/2.0, abs(sin(d.z))))/2.; //red ball\n        ret-=vec3(d.y, abs(sin(d.z)), abs(sin(d.y))*2.);\n        float dark = abs(min(cos(iTime), sin(iTime/2.0)))*(dot(ro,rd)*sin(iTime))/6.;\n        //ret-=vec3(min(max(dark, sin(d.z+d.y)), max(cos(d.y), sin(d.z))), dark, dark)*3.;\n        float red = min(max(dark, sin(d.z+d.y)), max(cos(d.y), sin(d.z)));\n        \n        \n        if (pattern>0.5) ret-=vec3(red, red/2., sin(red))*3.;\n        else ret-=abs(vec3(abs(sin(iTime+644533.)/3.), max(abs(sin(d.z)), sin(ro.z)), acos(d.z/length(d))));\n            \n        return ret;\n        \n        //return (atlas(p).xyz+grid(p*3.0));        \n        //return (atlas(p).xyz-grid(p*3.0));    //-grid -->black\n    } \n#endif    \n    //return 1.7-vec3(length(p));\n    return sunSize+0.3*sin(iTime)-vec3(0., max(length(p)-0.5, 0.0)*fbm(rd), length(p)+0.5); // -- red ball\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 c = vec3(0.0);\n    float slow = 4.0; //speed of planet cycling\n    \n\tfor (int m=0;m<ssaa;m++)\n\t{\n\t\tfor (int n=0;n<ssaa;n++)\n\t\t{\n\t\t\tvec2 offset = vec2(float(m),float(n))/float(ssaa)-0.5;\n\t\t\tvec2 p = (fragCoord.xy+offset.xy)/iResolution.xy-0.5;\t\n            p.x*=iResolution.x/iResolution.y;\n            vec2 m = iMouse.xy / iResolution.xy-0.5;\n            m.x *= iResolution.x/iResolution.y;\n            p*= 1.5;\n            vec3 ro = vec3(0.0,0.0,2.4);\n            vec3 rd = normalize(vec3(p,-1.5));\n            mat2 rx = rotation(iTime*0.4+m.x*5.0);\n            ro.xz *= rx; rd.xz *= rx;  \n            //+ mouse Y, vertical rotation\n            mat2 ry = rotation(iTime*0.4+m.y*5.0);\n            ro.yz *=-ry; rd.yz *= -ry;\n            \n            /*\n            mat2 zoom = mat2(vec2(1.0+abs(sin(iTime)), 0),\n                             vec2(0.0, 1.0+vec2(1.0+abs(cos(iTime))))\n                                  );\n            */\n          /*  mat2 zoom = mat2(vec2(1.0+abs(sin(iTime)), 0),\n                             vec2(0.0, 1.0+vec2(1.0+abs(sin(iTime))))\n                                  );\n   */\n            mat2 zoom = mat2(vec2(0.7 + abs(sin(iTime/slow)), 0),\n                             vec2(0.0, 0.7+abs(sin(iTime/slow)))\n                                  );\n            \n             mat3 zoom3 = mat3(vec3(1.0+abs(sin(iTime)), 0, 0),\n                             vec3(0.0, 1.0+abs(sin(iTime)), 0.0),\n                             vec3(0.0, 0.0, 1.0+abs(sin(iTime)))\n                                  );\n            zoom*=zoom*zoom;\n            ro*=zoom3;\n            ro.yz*=zoom;\n            //ro.yz*=zoom;\n                                  \n            \n\t\t\tc+=raycast(ro,rd,p);\n\t\t}\n\t}\n\tc=c/float(ssaa*ssaa);    //gradient - angles, black\n\tfragColor = vec4(c, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tByDV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1032, 1219, 1243, 1243, 1292], [1294, 1294, 1317, 1317, 1397], [1399, 1399, 1424, 1424, 1740], [1742, 1742, 1767, 1767, 2023], [2025, 2025, 2044, 2044, 2231], [2233, 2233, 2258, 2258, 2333], [2335, 2335, 2354, 2354, 2436], [2438, 2438, 2470, 2470, 2585], [2587, 2587, 2608, 2608, 3121], [3123, 3212, 3253, 3253, 4536], [4538, 4538, 4595, 4595, 6387]], "test": "untested"}
{"id": "4tffDH", "name": "Doyle spirals", "author": "knighty", "description": "A port a [url=http://www.fractalforums.com/fragmentarium/doyle-spirals/]fragmentarium shader drawing Doyle spirals[/url]. The original draws it in 3D instead. Maybe next time :) .\nChange the parameters (P, Q) at the beginning of the script.", "tags": ["spiral", "doyle"], "likes": 29, "viewed": 473, "published": "Public", "date": "1511709861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Doyle Spirals. Port from fragmentarium shader done a long time ago.\n//Public domain\n\n//Links:\n//http://www.fractalforums.com/fragmentarium/doyle-spirals/\n//http://www.josleys.com/show_gallery.php?galid=265\n//http://www.josleys.com/article_show.php?id=3\n//http://klein.math.okstate.edu/IndrasPearls/cusp.pdf\n\n#define PI 3.14159\n\n//Constant parameters: feel free to change these.\n//These control the shape of the spiral\nconst int P = 18;\nconst int Q = 7;//should be at least 3\n\n//Want do do an inversion?\nconst bool DoInversion = true;//false;//\n//Inversion center\nconst vec2 InvCenter = vec2(.7,0.);\n//Inversion radius squared\nconst float InvRadius = 1.;\n\n//to change the radius of the discs\nfloat SRadScl = 1.;\n\n//Draw circles?\nconst bool DrawCircles = true;//false;//\nconst float DRadius=0.7, Width=1.4, Gamma=2.2;\nconst vec3 BackgroundColor = vec3(.8);\nconst vec3 CurveColor = vec3(0.);\n\n\n//Initializations\n//all the initialization calculations done here could (and should) be done in the host program.\n\n//Global variables\nmat2 Mat,iMat;\nvec4 rads, xps, yps;\n\n//given an etimated z find the solution to Doyle spiral equations using Newton-Raphson method\n//The unknowns are the similarities a = exp(z), b = exp(zt) and the radius r.\n//The equations are:\n//r = ( exp( 2 * z.x ) - 2 * exp( z.x ) * cos( z.y ) + 1 ) / ( exp( z.x ) + 1 )\n//r = ( exp( 2 * zt.x) - 2 * exp( zt.x) * cos( zt.y) + 1 ) / ( exp( zt.x) + 1 )\n//r = ( exp( 2 * z.x ) - 2 * exp( z.x ) * exp( zt.x) * cos( z.y - zt.y ) + exp( 2 * zt.x ) ) / ( exp( z.x ) + exp( zt.x ) )\n//z.x * p = zt.x * q\n//z.y * p + 2 * PI = zt.y * q\n//In fact the last equation should be:\n//   z.y * p + 2 * k * PI = zt.y * q\n//Where k is an integer. I haven't esplored other values of k than 1\n//For more information see the articles cited above.\n\nvec2 solve( vec2 z ) {\n\t//Newton-Raphson method\n\tfloat k = float( P ) / float( Q );\n\tfor ( int i=0; i<2; i++ ){//2 iterations are usually sufficient: the convergence is very fast. especially when P o=and/or Q are relatively big\n\t\tfloat lb = z.x * k, tb = z.y * k + 2. * PI / float( Q );\n\t\tfloat ra = exp( z.x ),rb = exp( lb );\n        float ca = cos( z.y ), cb = cos( tb ), cab = cos( z.y - tb );\n\t\t\n        //compute function values\n\t\tvec3 v = vec3( ( ra * ra - 2. * ra * ca + 1. ) / (( ra + 1. ) * ( ra + 1. )),\n\t\t\t\t\t   ( rb * rb - 2. * rb * cb + 1. ) / (( rb + 1. ) * ( rb + 1. )),\n\t\t\t\t\t   ( ra * ra - 2. * ra * rb * cab + rb * rb ) / (( ra + rb ) * ( ra + rb )));\n\t\tvec2 f = v.xy - v.yz;\n\t\t\n        //compute jacobian\n\t\tvec3 c = 2.* vec3( ra / (( ra + 1. ) * ( ra + 1. )),\n                           k * rb / (( rb + 1. ) * ( rb + 1. )),\n                           ( 1. - k ) * ra * rb / (( ra + rb ) * ( ra + rb )));\n\t\tvec3 v0 = c * vec3( ( 1. + ca ) * ( ra - 1. ) / ( ra + 1. ),\n                            ( 1. + cb ) * ( rb - 1. ) / ( rb + 1. ),\n                            ( 1. + cab) * ( ra - rb ) / ( ra + rb ));\n\t\tvec3 v1 = c * sin( vec3( z.y, tb, z.y - tb ));\n\t\tmat2 J  = mat2(0.);\n\t\tJ[0]    = v0.xy - v0.yz; J[1] = v1.xy - v1.yz;\n        \n\t\t//compute inverse of J\n#if 1\n\t\tfloat idet = 1. / ( J[0][0] * J[1][1] - J[0][1] * J[1][0] );\n\t\tmat2 iJ    = -J;\n\t\tiJ[0][0]   = J[1][1];\n\t\tiJ[1][1]   = J[0][0];\n        //next value\n\t\tz -= idet * ( iJ * f );\n#else\n        //of course\n        mat2 iJ = inverse(J);\n        //but slightly slower\n        //next value\n\t\tz -= iJ * f;\n#endif\n\t}\n\treturn z;\n}\n\nvoid init() {\n\t//Find estimate then use Newton Raphson method to refine the solution.\n\t//Notice that for big P and/or Q the packing will look just like hexagonal one\n\t//If we take the centers of all packed circles in log-polar plane we will get almost a triangular array\n\t//That's why I'm using log-polar plane\n\t//Notice also the link to Drost effect ;)\n\t//Someone already noticed that before: http://gimpchat.com/viewtopic.php?f=10&t=3941\n\t\n    //Estimate z\n    vec2  v  = vec2( -float( P ) + float( Q ) * 0.5 , float( Q ) * sqrt( 3. ) * 0.5 );\n\tfloat vd = 1. / length(v);\n\tfloat scl = 2. * PI * vd;\n\tvec2  z  = scl * vd * v.yx;\n\t\n    //Refine. \n    z=solve(z);\n\t\n    //Compute the parameters used for drawing the circle packing\n    float k = float( P ) / float( Q );\n\t\n    vec2  zt= vec2( z.x * k, z.y * k + 2. * PI / float( Q ));\n\tMat[0]  = z; Mat[1] = zt;\n\tiMat    = -Mat;\n\tiMat[0][0] = Mat[1][1]; iMat[1][1] = Mat[0][0];\n\tiMat *= 1. / ( Mat[0][0] * Mat[1][1] - Mat[0][1] * Mat[1][0] );\n\t\n    float ra = exp( z.x ), rb = exp( zt.x ), ca = cos( z.y );\n\tfloat rs = sqrt(( ra * ra - 2. * ra * ca + 1. ) / (( ra + 1. ) * ( ra + 1. )));//radius of the circle centered at (1,0)\n\trs *= SRadScl;//for some variations\n\trads = rs * vec4( 1., ra, rb, ra * rb );//radius for the 4 circles in the fundamental domain\n\txps = vec4( 1., ra * ca, rb * cos( zt.y ), ra * rb * cos( z.y + zt.y ));//Their x coordinates\n\typs = vec4( 0., ra * sin( z.y ), rb * sin( zt.y ), ra * rb * sin( z.y + zt.y ));//y\n}\n\n//End initializations\n\n\nvec4 CDoyle( vec2 z ){\n\tvec2 p = z;\n\t\n    //transform to the plane log-polar\n\tp = vec2( log( length( p ) ), atan( p.y, p.x ));\n\t\n    //transform into the \"oblique\" base (defined by z and zt in vinit() function above)\n\tvec2 pl = iMat * p;\n\t\n    //go to the losange defined by z and zt (as defined in vinit())\n\tvec2 ip = floor( pl );\n\tpl = pl - ip;\n\t\n    //back to log-polar plane\n\tpl = Mat * pl;\n\t\n    //scale and delta-angle\n\tfloat scl = exp( pl.x - p.x ), angle = pl.y - p.y;\n\t\n    //the original z is scaled and rotated using scl and angle\n\tz *= scl;\n\tfloat c = cos(angle),s = sin(angle);\n\tz.xy = z.xy * mat2(vec2( c, -s ), vec2( s, c ));//rotate z\n\t\n    //distances to the discs that are inside the fundamental domain\n\tvec4 vx = vec4( z.x ) - xps;\n\tvec4 vy = vec4( z.y ) - yps;\n\tvec4 dists = sqrt( vx * vx + vy * vy ) - rads;\n\t\n    //take the minimal distance\n\tfloat mindist = min( min( dists.x, dists.y ) , min( dists.z, dists.w ) );\n\t\t\n    //what is the nearest sphere\n\tbvec4 bvhit = equal( dists, vec4( mindist ) );\n\tint mindex  = int( dot( vec4( bvhit ), vec4( 0., 1., 2., 3. ) ) );\n    \n#if 0\n    const mat4 set = mat4(vec4(0.),vec4(1.,0.,1.,0.),vec4(0.,1.,1.,0.),vec4(1.,1.,2.,0.));\n\tvec3  minprop  = set[ mindex ].xyz;\n#else\n    vec3 minprop;\n    if( mindex == 0 )      minprop = vec3(0.);\n    else if( mindex == 1 ) minprop = vec3(1.,0.,1.);\n    else if( mindex == 2 ) minprop = vec3(0.,1.,1.);\n    else                   minprop = vec3(1.,1.,2.);\n#endif\n\t\n    vec3 bc = vec3( ip, ip.x + ip.y ) + minprop;\n\tbc = bc / vec3( P, Q, max( abs( float( P - Q ) ), 1.) );\n\tbc-= floor( bc );\n\t\n\treturn vec4( bc, mindist/scl );//For coloring\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1. - smoothstep( -1., 1., t );\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td = d * 1. / pixsize;\n\tfloat v1 = ( d - 0.5 * lineWidth ) / DRadius;\n\tfloat v2 = ( d + 0.5 * lineWidth ) / DRadius;\n\treturn coverageFunction( v1 ) - coverageFunction( v2 );\n}\n\nfloat coverage(float d, float lineWidth, float pixsize){\n\td = d * 1. / pixsize;\n\tfloat v1 = ( d - 0.5 * lineWidth ) / DRadius;\n\treturn coverageFunction( v1 );\n}\n\nvec3 color(vec2 p) {\n    float pixsize = dFdx( p.x );\n    \n    vec4 col = vec4(0.);\n    \n    float ang = iTime * 0.5;\n    float c = cos( ang ), s = sin( ang );\n\tmat2 rot= mat2( vec2( c, -s ), vec2( s, c ) );\n    \n    if( DoInversion ) {\n\t\tp = p - InvCenter;\n\t\tfloat r2 = dot( p, p );\n        float r  = sqrt(r2);\n\t\tp = ( InvRadius / r2 ) * p + InvCenter;\n        col = CDoyle( rot * p );\n        col.w = r2 * col.w / (InvRadius + r * col.w);\n\t} else\n        col = CDoyle( rot * p );\n        \n    float v=coverage(col.w, Width, pixsize);\n    col.rgb = sin( 2. * PI * col.rgb + .0) * 0.5 + 0.5;\n    col.rgb = mix( pow(BackgroundColor, vec3(Gamma)), pow(col.rgb, vec3(Gamma)), v);\n    if(DrawCircles){\n    \tv=coverageLine(col.w, Width, pixsize);\n    \tcol.rgb = mix( col.rgb, pow(CurveColor, vec3(Gamma)),v);\n    }\n    return pow( col.rgb, vec3( 1. / Gamma ) ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float scaleFactor = 1.4;\n\tvec2 uv = scaleFactor * ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    SRadScl = sin( iTime ) * 0.05 + 0.95;\n\tinit(); \n\tfragColor = vec4( color( uv ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tffDH.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[1064, 1791, 1813, 1838, 3396], [3398, 3398, 3411, 3856, 4886], [4888, 4912, 4934, 4934, 6556], [6558, 6558, 6590, 6824, 6982], [6984, 6984, 7044, 7044, 7220], [7222, 7222, 7278, 7278, 7382], [7384, 7384, 7404, 7404, 8244], [8246, 8246, 8303, 8303, 8510]], "test": "untested"}
{"id": "4tffzN", "name": "Toon Water with FBM", "author": "rafaelcastrocouto", "description": "https://thebookofshaders.com/13/", "tags": ["texture"], "likes": 7, "viewed": 594, "published": "Public", "date": "1511132764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n\n// All noise functions are designed for values on integer scale.\n// They are tuned to avoid visible periodicity for both positive and\n// negative coordinates within a few orders of magnitude.\n\n// For multiple octaves\n#define NOISE fbm\n#define NUM_NOISE_OCTAVES 2\n#define SPEED 1.0\n//#define SMOOTH 1\n\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return  (sin(iTime*3.0*SPEED)*0.02) + fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = fragCoord.xy * 0.015 - vec2(iTime * 0.5, iResolution.y / 2.0);\n    float speed = 0.3*SPEED;\n    float limit = 0.1;\n    float border = 0.025;\n    float c = NOISE(coord - speed*iTime ) * NOISE(coord + speed*iTime );\n    //vec3 color = vec3(c, c, c);\n    vec3 color = vec3(step(limit-border,c), step(limit, c), 1);\n    if (color.x == 1.0 && color.y != 1.0 && color.x == 1.0) { color = vec3(1.0, 1.0, 1.0); }\n    else { color = vec3(0.06, 0.4, 1.0); }\n#ifdef SMOOTH\n    c = smoothstep(limit - border, limit, c) - smoothstep(limit, limit + border, c);\n    fragColor = vec4(c * c * c, 0.25 + 0.75 * c * c, 0.5 + 0.5 * c, 1.0);\n#else\n    fragColor.rgb = clamp(color, 0.0, 1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tffzN.jpg", "access": "shaders20k", "license": "bsd-new", "functions": [[381, 402, 423, 423, 453], [454, 454, 474, 474, 593], [595, 595, 617, 617, 749], [752, 752, 773, 773, 1407], [1410, 1410, 1431, 1431, 2192], [2195, 2195, 2215, 2215, 2393], [2396, 2396, 2415, 2415, 2692], [2695, 2695, 2714, 2714, 2890], [2893, 2893, 2950, 2950, 3647]], "test": "untested"}
{"id": "4tjcW3", "name": "test cam path", "author": "lapin", "description": "little test on cam path with bezier curve to get the path betwen 2 torus. you can also juste see how look the camera from a fixed point of view.", "tags": ["torus", "bezier", "campath"], "likes": 2, "viewed": 99, "published": "Public", "date": "1510753848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nshader:\n\tBased on:\thttps://www.shadertoy.com/view/MldGDl\t----------------\tBy: \t\tgeoff\n\nmath:\n\tBased on:\thttps://www.3dgep.com/understanding-quaternions/\t----\t\n\t\t\t\thttps://pomax.github.io/bezierinfo/\t--------------------\t\n\t\t\t\t\n*/\n\n//\n//\t|\tif you uncomment DEBUG_VIEW you see the sence frome a fixed place and you see\n//\t|\thow look the camera (position and orientation)\n//\tv\n\n//#define DEBUG_VIEW \n\n\n///////// color \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n#define COLUMN_COL vec3(0.7, 0.35, 0.7)\n#define A0 vec3(0.5, 0.5, 0.5)\n#define A1 vec3(1.0, 0.0, 0.0)\n#define A2 vec3(0.0, 1.0, 0.0)\n#define A3 vec3(0.0, 0.0, 1.0)\n#define\tB1 vec3(1.0, 1.0, 0.0)\n#define\tB2 vec3(0.0, 1.0, 1.0)\n\n#define FLOOR_COL_A vec3(0.8)\n#define FLOOR_COL_B vec3(0.2)\n\nfloat closeObj = 0.0;\nconst float PI = 3.14159;\n\nstruct\ts_torus\n{\n    mat3\tpos;\n    mat3\trot;\n    vec2\tsize1;\n    vec2\tsize2;\n};\n\nmat3 rotX(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(1.0, 0.0, 0.0,\n                0.0,   c,  -s,\n                0.0,   s,   c );\n}\n\nmat3 rotY(float d){\n    float s = sin(d);\n    float c = cos(d);\n    return mat3(  c, 0.0,  -s,\n                0.0, 1.0, 0.0,\n                  s, 0.0,   c );\n}\n\nmat3 rotZ(float d){\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(  c,  s, 0.0,\n                 -s,  c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// p \nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\nreturn length(q) - t.y;\n}\n\n\n\nvec2 vecMin(vec2 a, vec2 b){\n    if(a.x <= b.x){\n        return a;\n    }\n    return b;\n}\n\n\n/*\n\tPour conaitre les normale\n*/\n\n//\t----------------------------------------------------\n\n\nvec3\tpermute1(vec3 v)\n{\n    return (v.yzx);\n}\n\nvec3\tpermute2(vec3 v)\n{\n    return (v.zxy);\n}\n\nmat3\tbezier_derivate(mat4 controle_point)\n{\n    mat3\tderivate;\n\n    derivate[0] = ((controle_point[1].xyz - controle_point[0].xyz) * 3.0);\n\tderivate[1] = ((controle_point[2].xyz - controle_point[1].xyz) * 3.0);\n\tderivate[2] = ((controle_point[3].xyz - controle_point[2].xyz) * 3.0);\n    return (derivate);\n}\n\n\n// \tbezier quadratique... dim 3\nvec3\tbezier_pos(mat4 controle_point, float t)\n{\n    vec3\tres;\n\n    res  = (pow(t, 0.0) * pow(1.0 - t, 3.0) * 1.0) * controle_point[0].xyz;\n    res += (pow(t, 1.0) * pow(1.0 - t, 2.0) * 3.0) * controle_point[1].xyz;\n    res += (pow(t, 2.0) * pow(1.0 - t, 1.0) * 3.0) * controle_point[2].xyz;\n    res += (pow(t, 3.0) * pow(1.0 - t, 0.0) * 1.0) * controle_point[3].xyz;\n    return (res);\n}\n\nvec3\tbezier_dir_front(mat3 derivate_point, float t)\n{\n    vec3\tres;\n    \n    res  = (pow(t, 0.0) * pow(1.0 - t, 2.0) * 1.0) * derivate_point[0];\n    res += (pow(t, 1.0) * pow(1.0 - t, 1.0) * 2.0) * derivate_point[1];\n    res += (pow(t, 2.0) * pow(1.0 - t, 0.0) * 1.0) * derivate_point[2];   \n    return (normalize(res));\n}\n\n/*\nvec3\tbezier_derive_2(mat3 derivate, float t)\n{\n    vec3\tres;\n    mat3\td2;\n    \n    d2 = bezier_derivate(mat4(derivate[0], 0.0, derivate[1], 0.0, derivate[2], 0.0, vec4(0.0))) * 2.0;\n    res  = (1.0 - t)* d2[0];\n    res +=  \tt\t* d2[1]; \n    return (res);\n}\n*/\n\n/*\nvec3\tbezier_left_dir(vec3 dir, mat3 cp, float t)\n{\n    vec3\tres;\n    vec3\tt2, r, n;\n    mat3\trot;\n    \n    //t \t=> tangeante\n    //t2\t=> derive de tangeant, ou nexte tangeante\n    //r \t=> normalize(t cross t2)\n    \n    t2 = bezier_derive_2(cp, t);\n    r = normalize(cross(t2, dir));\n    rot = mat3(\tvec3(  r.x * r.x  , r.x*r.y - r.z, r.x*r.z + r.y),\n              \tvec3(r.x*r.y + r.z,   r.y * r.y  , r.y*r.z - r.x),\n              \tvec3(r.x*r.z - r.y, r.y*r.z + r.x,   r.z * r.z  ));\n    n = normalize(rot * dir);\n    res.yzx = dir.xyz;\n\treturn (res);\n}*/\n\n\n/*\n\tLe but serait de recuperer toutes les direction directement dans \n\tavec une fonction. On met la direction dans uz, puis les 2 normale \n\ta la courbe dans uy et uz;\n\n\td'ailleurs on pourrait tres problablement genere le ux ou le uy en fonction\n\tde uz et le plus sim ple des deux a caleculer en passant par ce tres cher \"cross\"\n\t\n\tEt puis comme ca la vie est belle =)\n*/\n\nmat3\tbezier_cam_dir_pos(vec3 pos, mat4 cp, float t)\n{\n    mat3\tcp_d1;\n    mat3\tcp_d2;\n    mat3\tret;\n    vec3\tt2;\n    \n    cp_d1 = bezier_derivate(cp);\n    cp_d2 = bezier_derivate(mat4(cp_d1[0], .0, cp_d1[1], .0, cp_d1[2], .0, vec4(.0)));\n    \n    ret[2] = normalize(bezier_dir_front(cp_d1, t));\t\t// z => tangeante\n\n//    t2 = bezier_derive_2(cp_d2, t);    \n    ret[0] = permute2(ret[2]);\n    ret[1] = normalize(cross(ret[2], ret[0]));\n    ret[0] = cross(ret[1], ret[2]);\n    \n    \n    ret[2] += pos;\n    ret[1] += pos;\n    ret[0] += pos;\n    return (ret);\n}\n\nmat3\tbezier_cam_dir(mat4 cp, float t)\n{\n    mat3\tcp_d1;\n    mat3\tcp_d2;\n    mat3\tret;\n    vec3\tt2;\n    \n    cp_d1 = bezier_derivate(cp);\n    cp_d2 = bezier_derivate(mat4(cp_d1[0], .0, cp_d1[1], .0, cp_d1[2], .0, vec4(.0)));\n    \n    ret[2] = normalize(bezier_dir_front(cp_d1, t));\n    ret[0] = permute2(ret[2]);\n    ret[1] = normalize(cross(ret[2], ret[0]));\n    ret[0] = cross(ret[1], ret[2]);\n    return (ret);\n}\n\n\n//\t-----------------------------------------------------\n\n\ns_torus\tset_torus(vec3 p, vec3 t, vec2 size_ok, vec2 size_debug)\n{\n    s_torus\tret;\n    vec3\tp1, p2, n;\n    \n    ret.rot = (rotZ(t.z) * rotY(t.y) * rotX(t.x));\n    ret.pos[0] = p;\n    ret.pos[1] = p +  (n = vec3(.0, 7.0, .0)) * ret.rot;\n    ret.pos[2] = p +  (-n * ret.rot);\n    ret.size1 = size_ok;\n    ret.size2 = size_debug;\n    return (ret);\n}\n\n\nmat4\tset_bezier_coef(s_torus tt1, s_torus tt2)\n{\n    mat4\tb;\n    \n    b[0].xyz = tt1.pos[0];\n    b[1].xyz = tt1.pos[1];\n    b[2].xyz = tt2.pos[2];\n    b[3].xyz = tt2.pos[0];\n    return (b);\n}\n\n\nvec2\tdist_torus_debug(vec3 p, s_torus t)\n{\n    vec2\td, n1, n2;\n\t \n    d  = vec2(torus(t.rot * (p - t.pos[0]), t.size1), 2.0);\n    n1 = vec2(torus((p - t.pos[1]), t.size2), 5.0);\n    n2 = vec2(torus((p - t.pos[2]), t.size2), 6.0);\n    return (vecMin(d, vecMin(n1, n2)));\n}\n\nvec2\tdist_torus(vec3 p, s_torus t)\n{\n    vec2\td;\n\t \n    d  = vec2(torus(t.rot * (p - t.pos[0]), t.size1), 2);\n    return (d);\n}\n//\t-----------------------------------\n\nvec2\t\tdist_cam(vec3 p, vec3 pos, vec3 uz, vec3 ux, vec3 uy)\n{\n    vec2\td;\n    vec2 s = vec2(.0, 0.1);\n    \n    d = vec2(torus((p - pos), s), 8.0);\n\td = vecMin(d, vec2(torus((p - uz), s), 5.0));\n\td = vecMin(d, vec2(torus((p - ux), s), 4.0));\n\td = vecMin(d, vec2(torus((p - uy), s), 3.0));\n    return (d);\n}\n\ns_torus\ttt1, tt2, tt3;\nmat4\tbb;\nmat3\tbbd;\nfloat\ttime, time1, time2;\n\nvoid\tset_torus(float t1)\n{\n    vec3\tp1, ang1, p2, ang2, p3, ang3;\n    vec2\ts1, s2, ret;\n    \n    float dd = 3.0;\n    float ddpp = 7.0;\n    p1  = vec3(0, dd / 2.0, ddpp);\n    p2  = vec3(-dd, -dd / 2.0, ddpp);\n    p3  = vec3(dd, -dd / 2.0, ddpp);\n    \n    ang1 = vec3(t1, t1 * 0.3, t1 * 0.4);\n    ang2 = vec3(t1 * 0.3, t1, t1 * 0.4);\n    ang3 = vec3(t1 * 0.3, t1 * 0.4, t1);\n    \n    s1  = vec2(0.6, 0.3);\n    s2  = vec2(0.0, 0.2);\n    \n    tt1  = set_torus(p1, ang1, s1, s2);\n    tt2  = set_torus(p2, ang2, s1, s2);\n    tt3  = set_torus(p3, ang3, s1, s2);\n}\n\n\nvoid\tset_bezier_path(float t2)\n{\n    if      (mod(t2, 3.0) <= 1.0)\n        bb = set_bezier_coef(tt1, tt2);\n    else if (mod(t2, 3.0) <= 2.0)\n        bb = set_bezier_coef(tt2, tt3);\n    else if (mod(t2, 3.0) <= 3.0)\n        bb = set_bezier_coef(tt3, tt1);\n\t\n    bbd = bezier_derivate(bb);\n}\n\nvoid\tset_time(float t)\n{\n    float\ttime = t / 0.5;\n    time1 = time / 6.0;\n    time2 = 0.1 * time;\n}\n\nvec2 mapMat(vec3 p){\n    float\tt1 = time1;\n    float\tt2 = time2;\n    mat3\tcam_d;\n    vec3\tpcam;\n    vec2\tret = vec2(10000.0, 0.0);\n     \n    \n//    ret = vecMin(dist_torus_debug(p, tt1), dist_torus_debug(p, tt2));\n//    ret = vecMin(ret, dist_torus_debug(p, tt3));\n \n\n    ret = vecMin(dist_torus(p, tt1), dist_torus(p, tt2));\n    ret = vecMin(ret, dist_torus(p, tt3));\n\n\n#ifdef DEBUG_VIEW\n    t2 = t2 - floor(t2);\n    pcam =  bezier_pos(bb, t2);\n    cam_d = bezier_cam_dir_pos(pcam, bb, t2);\n    ret = vecMin(ret, dist_cam(p, pcam, cam_d[2], cam_d[0], cam_d[1]));\n#endif\n\tvec2 flo = vec2(p.y + 5.5, 1.0);\n    vec2 roof = vec2(-p.y + 5.5, 1.0);\n\treturn vecMin(ret, vecMin(flo, roof));\n}\n\n\n\n//Returns the min distance\nfloat map(vec3 p){\n    return mapMat(p).x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 1.0;\n    float d = 0.0;\n    float w = 1.4;\n    float ld = 0.0;\n    float ls = 0.0;\n    float s = 0.0;\n    float cerr = 10000.0;\n    float ct = 0.0;\n    float pixradius = 0.4 / iResolution.x;\n    vec2 c;\n    int inter = 0;\n    for(int i = 0; i < 256; i++){\n        ld = d;\n        c = mapMat(ro + rd * t);\n        d = c.x;      \n        //Detect intersections missed by over-relaxation\n        if(w > 1.0 && abs(ld) + abs(d) < s){\n            s -= w * s;\n            w = 1.0;\n            t += s;\n            continue;\n        }       \n        s = w * d;\n        \n        float err = d / t;\n        \n        if(abs(err) < abs(cerr)){\n            ct = t;\n            cerr = err;\n        }\n\n        //Intersect when d / t < one pixel\n        if(abs(err) < pixradius){\n            inter = 1;\n            break;\n        }\n\n        t += s;\n        if(t > 20.0){\n            break;\n        }\n    }\n    closeObj = c.y;\n    if(inter == 0){\n        ct = -1.0;\n    }\n    return ct;\n}\n\n\n//Approximate normal\nvec3 normal(vec3 p){\n    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),\n                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),\n                \t      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));\n}\n\nvec3 camPos = vec3(1.0);\nvec3 lightPos = vec3(0.0);\n\nfloat occlusion(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float d = 0.0;\n    float occ = 0.0;\n    for(int i = 0; i < 25; i++){\n        d = map(ro + 0.1 * k * rd);\n        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);\n        k += 1.0;\n    }\n    return 1.0 - clamp(1.0 * occ, 0.0, 1.0);\n}\n\n//Square\nfloat sqr(float x){\n  return x * x;\n}\n\n//Diffusion normalisation\nfloat diff(float albedo){\n  return albedo / PI;\n}\n\n//GGX NDF\nfloat specD(float NdotH, float a){\n    float asqr = sqr(a);\n  float NdotHsqr = sqr(NdotH);\n  return asqr / (PI * sqr((NdotHsqr) * (asqr - 1.0) + 1.0));\n}\n\nfloat G1(float NdotX, float k){\n//    return 0.0;\n  return NdotX / (NdotX * (1.0 - k) + k);\n}\n\n//Geometric attenuation term\nfloat specG(float NdotV, float NdotL, float k){\n  k /= 20.0;\n  return G1(NdotV, k) * G1(NdotL, k);\n}\n\n//Schlick fresnel approximation used by Unreal Engine\nfloat fresnel(float AdotB){\n  float power = pow(2.0, (-5.55473 * AdotB - 6.98316) * AdotB);\n  return 0.04 + (1.0 - 0.04) * power;\n}\n\n\nvec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 c, float metallic, float roughness, float s, float o){\n  vec3 H = normalize(L + V);\n  float NdotH = dot(N, H);\n  float NdotL = dot(N, L);\n  float NdotV = dot(N, V);\n  \n  if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0);\n  \n  float VdotH = dot(V, H);\n  float alpha = roughness * roughness;\n\n  float conductor = 1.0 - metallic;\n\n  vec3 specCol = mix(vec3(1.0), c, metallic);\n  \n  float FresL = fresnel(NdotL);\n  float FresV = fresnel(NdotV);\n  float Fresd90 = 0.5 + 2.0 * sqr(VdotH) * roughness;\n  float Fresd = mix(1.0, Fresd90, FresL) * mix(1.0, Fresd90, FresV); \n  \n  float Ds = specD(NdotH, alpha);\n  float FresH = fresnel(VdotH);\n  vec3 Fress = mix(specCol, vec3(1.0), FresH);\n  float Gs = specG(NdotV, NdotL, roughness);\n\n  return (diff(conductor) * Fresd * max(0.0, NdotL) * o * c + Gs * Fress * Ds * floor(s)) - (0.25 - 0.25 * s) * c;\n}\n\nvec3 colour(vec3 p, float id){\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    vec3 v = normalize(camPos - p);\n    vec3 col;\n    \n    float o = occlusion(p, n);\n    \n    if(id == 1.0){\n        vec2 t = mod(floor(p.xz), 2.0);\n        if(t == vec2(0.0) || t == vec2(1.0)){\n            col = FLOOR_COL_A;\n        }else{\n            col = FLOOR_COL_B;\n        }\n        return BRDF(l, v, n, col, 0.4, 0.2, 1.0, o);\n    }\n    else if(id >= 2.0 || id <= 8.0)\n    {\n        float metal = iMouse.x / iResolution.x;\n        float rough = iMouse.y / iResolution.y;\n        if(rough == 0.0 && metal == 0.0)\n        {\n            metal = 0.1;\n            rough = 0.1;\n        }\n        \n        if (id == 2.0)\n            col = vec3(0.7, 0.35, 0.7);\n        if (id == 3.0)\n            col = A1;\n        if (id == 4.0)\n            col = A2;\n        if (id == 5.0)\n            col = A3;\n        if (id == 6.0)\n            col = B1;\n        if (id == 7.0)\n            col = B2;\n        if (id == 8.0)\n            col = A0;\n        return BRDF(l, v, n, col, metal, rough, 1.0, o);\n    }\n    return vec3(0.0, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    mat3\tcam_d;\n    vec3\tro, rd;\n    float\tt2;\n    \n    set_time(iTime);\n    set_torus(time1);\n    set_bezier_path(time2);\n    \n    \n    lightPos = vec3(sin(iTime) * 3.0, cos(iTime), 0.0);\n    \n#ifdef DEBUG_VIEW \n    camPos = vec3(0.0 , 0.0, 0.0);\n    ro = camPos;\n    rd = normalize(vec3(uv, 1.0));\n#else\n    t2 = time2 - floor(time2);\n    ro = bezier_pos(bb, t2);\n    cam_d = bezier_cam_dir(bb, t2);\n    rd = normalize(uv.x * cam_d[0] + uv.y * cam_d[1] + cam_d[2]);\n#endif\n        \n    float d = trace(ro, rd);\n    vec3 c = ro + rd * d;\n    vec3 col = vec3(0.0);\n    //If intersected\n    if(d > 0.0){\n        //Colour the point\n        col = colour(c, closeObj);\n        //Apply fog\n    \tcol *= 1.0 / exp(d * 0.1);\n    }else{\n        col = vec3(0.0);\n    }\n    col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col,1.0);\n}\n\n/*\n\tro\t: ray_origin\n\trd\t: ray_direction\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 852, 871, 871, 1012], [1014, 1014, 1033, 1033, 1174], [1176, 1176, 1195, 1195, 1338], [1340, 1346, 1375, 1375, 1443], [1447, 1447, 1475, 1475, 1535], [1572, 1630, 1653, 1653, 1675], [1677, 1677, 1700, 1700, 1722], [1724, 1724, 1767, 1767, 2031], [2034, 2066, 2113, 2113, 2452], [2454, 2454, 2507, 2507, 2776], [3601, 3973, 4026, 4026, 4530], [4532, 4532, 4571, 4571, 4946], [4949, 5008, 5074, 5074, 5355], [5358, 5358, 5406, 5406, 5549], [5552, 5552, 5594, 5594, 5823], [5825, 5825, 5861, 5861, 5952], [5953, 5993, 6054, 6054, 6298], [6369, 6369, 6395, 6395, 6925], [6928, 6928, 6960, 6960, 7217], [7219, 7219, 7243, 7243, 7319], [7321, 7321, 7341, 7341, 8006], [8010, 8037, 8055, 8055, 8081], [8083, 8083, 8113, 8113, 9099], [9102, 9123, 9143, 9143, 9419], [9474, 9474, 9508, 9508, 9757], [9759, 9768, 9787, 9787, 9805], [9807, 9833, 9858, 9858, 9882], [9884, 9894, 9928, 9928, 10047], [10049, 10049, 10080, 10098, 10142], [10144, 10173, 10220, 10220, 10273], [10275, 10329, 10356, 10356, 10460], [10463, 10463, 10556, 10556, 11344], [11346, 11346, 11376, 11376, 12468], [12470, 12470, 12526, 12526, 13466]], "test": "untested"}
{"id": "4tlBD4", "name": "Algebraic primitives - more fun", "author": "tale3d", "description": "Fork of example1 for analytic surfaces", "tags": ["implicit", "algebraic", "teachingmaterial"], "likes": 0, "viewed": 1153, "published": "Public", "date": "1511890251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//defining a simple primitive - circle\nfloat circle(in vec2 position, in vec2 centre, in float radius)\n{\n    vec2 pc = position-centre;\n    return pc.x*pc.x + pc.y*pc.y - radius*radius;\n}\n\nfloat ellipse(in vec2 position, in vec2 centre, in float radius1, in float radius2)\n{\n    vec2 pc = position-centre;\n    return (pc.x*pc.x)/(radius1*radius1) + (pc.y*pc.y)/(radius2*radius2) - 1.0;\n}\n\nfloat tanglecube(in vec2 position, in float z)\n{\n    float x = position.x; \n    float y = position.y;\n    return x*x*x*x - 5.0*x*x + y*y*y*y - 5.0*y*y + z*z*z*z - 5.0*z*z + 11.8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //taking fragment coordinates, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    //map fragment coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n\n    \n\t//time mapped to [0.5,1]- not used at the moment\n\tfloat time = 0.5+0.5*abs(sin(iTime));\n\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    \n    //setup parameters of the shape\n    vec2 circle_centre = vec2(cos(iTime),sin(iTime)); //centre of the circle\n    float radius = time/2.0; //radius of the circle, note it is dynamic depending on time parameter\n\n    vec3 colour = vec3(1.0, 1.0, 1.0); //background colour\n\n    //find the function for circle\n    float function_value = circle(c, circle_centre, radius); \n    //the function for the implicit curve is 0 on the surface, here we are drawing points which are \"close\" to 0\n    float thickness = 0.01; //note that thickness is not in geometric sense, but in the function value\n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,0.0); //circle is drawn in black\n\n    //note polar coordinates for the centre here and everywhere\n    circle_centre = vec2(cos(iTime+1.57),sin(iTime+1.57));\n    function_value = circle(c, circle_centre, radius); \n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,0.0); //circle is drawn in black\n\n    circle_centre = vec2(cos(iTime+3.14),sin(iTime+3.14));\n    function_value = circle(c, circle_centre, radius); \n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,0.0); //circle is drawn in black\n\n    circle_centre = vec2(cos(iTime+4.71),sin(iTime+4.71));\n    function_value = circle(c, circle_centre, radius); \n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,0.0); //circle is drawn in black\n\n    \n    //repeat for ellipse\n    vec2 ellipse_centre = vec2(0,0); //centre of the circle\n    function_value = ellipse(c, ellipse_centre, (2.0-time)/2.0, time/2.0); \n    if (abs(function_value) < 0.1) colour = vec3(0.0,0.0,1.0); //ellipse is drawn in blue\n    \n    float z = 2.0*sin(iTime);\n    function_value = tanglecube(c*2.0, z);\n    if (abs(function_value) < 0.1) colour = vec3(0.0,1.0,1.0); //ellipse is drawn in blue\n    \n\tfragColor = vec4(colour,1.0); //set the colour of the fragment\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 104, 104, 187], [189, 189, 274, 274, 387], [389, 389, 437, 437, 569], [572, 572, 629, 676, 2895]], "test": "untested"}
{"id": "4tlBW4", "name": "Blobby model: 2d case", "author": "tale3d", "description": "Shape modelling, topic \"Implicit curves and surfaces\", part 2: blobby model (2D case). \nThis example shows a blobby model with 3 skeleton points. As in previous example, we only visualise the surface of the object by using proximity to 0.   ", "tags": ["curve", "implicit", "teachingmaterial"], "likes": 1, "viewed": 72, "published": "Public", "date": "1511874898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//defining a blob with three points\nfloat blob3(in vec2 position, in vec2 p1, in vec2 p2, in vec2 p3)\n{\n    float time = 0.5+0.5*sin(iTime);\n\n\n    float a1 = 2.0, a2 = 2.0, a3 = 2.0; //parameters A for each skeletal element\n    float b1 = 2.0, b2 = 2.0, b3 = 2.0; //parameters B for each skeletal element\n    float T = 1.0; //threshold value\n    \n    float r1 = dot(position-p1, position-p1); //the same as (position.x-p1.x)*(position1.x-p1.x) + (position.y-p1.y)*(position1.y-p1.y)...\n    float r2 = dot(position-p2, position-p2);\n    float r3 = dot(position-p3, position-p3);\n\n    return b1*exp(-a1*r1)+b2*exp(-a2*r2)+b3*exp(-a3*r3)-T; //sum of fields minus threshold\n}\n\n//defining a simple primitive - circle\nfloat circle(in vec2 position, in vec2 centre, in float radius)\n{\n    vec2 pc = position-centre;\n    return pc.x*pc.x + pc.y*pc.y - radius*radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //taking fragment coordinates, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    //map fragment coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    \n\t//time mapped to [0,1]- not used at the moment\n\tfloat time = 0.5+0.5*sin(iTime);\n\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n\n    //blob skeleton points positions, those will be time-dependent to create an animation\n    vec2 p1 = vec2(0.5+time, 0.0);\n    vec2 p2 = vec2(0.0, 0.5-time);\n    vec2 p3 = vec2(0.2+0.5*time, 0.2);\n\n    //background colour by default\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n    \n    //find the value of blobby function\n    float blob_function = blob3(c,p1,p2,p3); \n    float thickness = 0.01; //note that thickness is not in geometric sense, but in the function value\n    \n    if (abs(blob_function) < thickness) colour = vec3(0.0,0.0,0.0);\n    \n    //visualise blobby model skeleton points by drawing very small circles\n    float small_radius = 0.001;\n    float small_thickness = 0.001;\n    if (abs(circle(c, p1, small_radius)) < small_thickness) colour = vec3(1.0,0.0,0.0); // first is red \n    if (abs(circle(c, p2, small_radius)) < small_thickness) colour = vec3(0.0,1.0,0.0); // second is green\n    if (abs(circle(c, p3, small_radius)) < small_thickness) colour = vec3(0.0,0.0,1.0); // third is blue\n        \n\tfragColor = vec4(colour,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 103, 103, 671], [673, 712, 777, 777, 860], [862, 862, 919, 966, 2341]], "test": "untested"}
{"id": "4tlBz8", "name": "Tiny Clouds: Unpacked & No Tex", "author": "demofox", "description": "Unpacking tiny clouds to better understand it, and to get rid of the texture read\ntiny clouds: https://www.shadertoy.com/view/lsBfDz\n\nA blog post explaining \"tiny clouds\" is here:\nhttps://blog.demofox.org/2017/11/26/dissecting-tiny-clouds/", "tags": ["clouds"], "likes": 41, "viewed": 2335, "published": "Public API", "date": "1511729388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_STEPS 200\n#define NUM_NOISE_OCTAVES 4\n\n#define HEIGHT_OFFSET 1.25\n\n#define USE_TEXTURE false\n#define WHITE_NOISE_GRID_SIZE 256.0\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 443.8975\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// NOTE: the bilinear interpolation is important! without it, the clouds look blocky.\n// You can see this by returning noise00 or by having the texture use the \"nearest\" filter\nfloat BilinearInterpolateWhiteNoise (vec2 uv)\n{\n    uv = fract(uv);\n    \n    vec2 uvPixels = uv * WHITE_NOISE_GRID_SIZE;\n    \n    vec2 uvFrac = uvPixels - floor(uvPixels);\n    \n    vec2 uvDiscreteFloor = floor(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    vec2 uvDiscreteCeil = ceil(uvPixels) / WHITE_NOISE_GRID_SIZE;\n    \n    float noise00 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteFloor.y));\n    float noise01 = hash12(vec2(uvDiscreteFloor.x, uvDiscreteCeil.y ));\n    float noise10 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteFloor.y));\n    float noise11 = hash12(vec2(uvDiscreteCeil.x , uvDiscreteCeil.y ));\n    \n    float noise0_ = mix(noise00, noise01, uvFrac.y);\n    float noise1_ = mix(noise10, noise11, uvFrac.y);\n    \n    float noise = mix(noise0_, noise1_, uvFrac.x);\n\n    return noise;\n}\n\nfloat RandomNumber (in vec3 position)\n{\n    // NOTE: the ceil here is important interestingly. it makes the clouds look round and puffy instead of whispy in a glitchy way\n    vec2 uv = (position.yz+ceil(position.x))/float(NUM_STEPS);\n    \n    if (USE_TEXTURE)\n    \treturn texture(iChannel0, uv).y;\n    else\n        return BilinearInterpolateWhiteNoise(uv);\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    // x,y,z is the direction the ray for this pixel travels in.\n    // x is into the screen\n    // y is the screen's x axis. the left side is -0.8 and the right side value depends on the aspect ratio seems to be be roughly +0.8 for me.\n    // z is the screen's y axis (also the up axis). it ranges from -0.8 at the bottom of the screen to 0.2 at the top of the screen\n    // NOTE: in tiny clouds, this is a vec4 where the y field is unused. I've made it a vec3 and removed the y field.\n    vec3 direction = vec3(0.8, fragCoord/iResolution.y-0.8);\n\n    // this is a sky blue color\n    // NOTE: tiny clouds gets the 0.8 from direction.x\n    vec3 skyColor = vec3(0.6, 0.7, 0.8);\n    \n    // initialize the pixel color to a gradient of sky blue (at top) to white (at bottom)\n    vec3 pixelColor = skyColor - direction.z;\n    \n    // Tiny clouds adds a per pixel value to rayStep that is in [-1,1].\n    // I think that gives it some higher frequency noise to make the clouds look a little more detailed.  \n    // NOTE: this ray marches back to front so that alpha blending math is easier\n    for (int rayStep = 0; rayStep < NUM_STEPS; ++rayStep)\n    {\n        // NOTE: tiny clouds has position as a vec4 but never uses the y component. I removed it here.\n        // position.z is up\n        vec3 position = 0.05 * float(NUM_STEPS - rayStep) * direction;\n        \n        // move the camera on the x and z axis over time\n        position.xy+=iTime;\n        \n        // tiny clouds initializes this to 2.0, but whenever using it divides it by 4. So, just dividing 2 by 4 here.\n        float noiseScale=0.5;\n        \n        // Note: position.z is the height. adding this moves the camera up. tiny clouds uses 1.0\n        float signedCloudDistance = position.z + HEIGHT_OFFSET;\n        \n        // Note: each sampling doubles the position but halves the value read there. it's multiple octaves of noise i think?        \n        for (int octaveIndex = 0; octaveIndex < NUM_NOISE_OCTAVES; ++octaveIndex)\n        {\n            position *= 2.0;\n            noiseScale *= 2.0;\n            signedCloudDistance -= RandomNumber(position) / noiseScale;\n        }\n        \n        // Note: signed cloud distance is also cloud density if negative.\n        // the below is equivelant to a lerp between the current pixel color and the color that the cloud is at that location.\n        // the lerp amount is controlled by the density time 0.4.\n        // The color is reversed so it \"looks like\" the sky color.\n        // Lerping is equivelant to standard alpha blending, so we are just doing alpha compositing.\n        if (signedCloudDistance < 0.0)\n            pixelColor = pixelColor + (pixelColor - 1.0 - signedCloudDistance * skyColor.zyx)*signedCloudDistance*0.4;\n\t}\n    \n    fragColor.rgb = pixelColor;\n    fragColor.a = 1.0;\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 255, 277, 277, 399], [401, 578, 625, 625, 1369], [1371, 1371, 1410, 1541, 1729], [1731, 1731, 1782, 2269, 4596]], "test": "untested"}
{"id": "4tlfDM", "name": "liquid spinner", "author": "laserdog", "description": "classic windows spinner in 3d with smooth min", "tags": ["raymarching"], "likes": 10, "viewed": 315, "published": "Public", "date": "1512080901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\nconst float tau = 6.28318; \nconst float epsilon = .0001;\n\nvec3 translate(vec3 p, vec3 amount) \n{\n    return p - amount;\n}\n\nfloat sphereSDF(vec3 p, float size)\n{\n    return length(p) - size;\n}\n\n// iq's smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mergeSDF(float d1, float d2, float k)\n{\n\treturn smin(d1, d2, k);\n}\n\nfloat sceneSDF(vec3 p)\n{\n    const float secondsPerCycle = 1.5;\n    const float secondsBetweenBalls = .06;\n    const float radius = 3.85;\n    float res = 2.;\n    \n    vec3 pos = p;\n    \n    for (float i = 0.; i < 5.; i++) {\n    \tfloat x = i * secondsBetweenBalls + iTime / secondsPerCycle;\n    \tfloat angle = tau * x + pi / 6. - 3.5/ tau * sin(tau * x);\n    \tpos = translate(p, vec3(sin(angle) * radius, cos(angle) * radius, 0.));\n        res = mergeSDF(res, sphereSDF(pos, .4), 1.2);\n    }\n    return res;\n}\n\nvec3 gradient(vec3 p)\n{\n\tconst vec3 dx = vec3(epsilon, 0., 0.);\n    const vec3 dy = vec3(0., epsilon, 0.);\n    const vec3 dz = vec3(0., 0., epsilon);\n    \n    return normalize(vec3(\n    \tsceneSDF(p + dx) - sceneSDF(p - dx),\n        sceneSDF(p + dy) - sceneSDF(p - dy),\n        sceneSDF(p + dz) - sceneSDF(p - dz)\n    ));\n}\n\nvec3 phong(vec3 p, vec3 view, vec3 light)\n{\n\tconst vec3 diffuseColor = vec3(1., .5, 0.);\n    const vec3 specularColor = vec3(1., 1., 1.) ;\n    const vec3 ambientColor = vec3(1., .5, 0.);\n    const float ambientStrength = .5;\n    const float glossiness = 16.;\n    \n    vec3 normal = gradient(p);\n    vec3 diffuse = max(0., dot(normal, light)) * diffuseColor;\n    vec3 specular = pow(max(0., dot(view, reflect(-light, normal))), glossiness) * specularColor;\n    vec3 ambient = ambientStrength * ambientColor;\n    \n    return diffuse + specular + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 light = vec3(0., 2., 2.);\n    vec3 dir = normalize(vec3(uv, -1.));\n    \n    // march\n    vec3 pos = eye;\n    float dist = 0.;\n    for (int i = 0; i < 70; i++) \n    {\n        dist = sceneSDF(pos);\n        pos += dist * dir;\n    }\n    \n\tfragColor = vec4(0.);\n    \n    if (dist < epsilon)\n    {\n        fragColor.rgb = phong(pos, normalize(eye - pos), normalize(light - pos));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 122, 122, 147], [149, 149, 186, 186, 217], [219, 238, 279, 279, 372], [374, 374, 419, 419, 446], [448, 448, 472, 472, 956], [958, 958, 981, 981, 1280], [1282, 1282, 1325, 1325, 1836], [1838, 1838, 1895, 1895, 2384]], "test": "untested"}
{"id": "4tsBWn", "name": "[WST1] Worm C", "author": "Vaticinator", "description": "My first try on that field. Special greetings for maqflp!", "tags": ["bug", "art", "bio", "fires"], "likes": 1, "viewed": 115, "published": "Public", "date": "1511652800", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Worm C, Author: Vaticinator\n// This shader is prepared for the first Wroclaw Shader Competition\n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\n#define S 0.2\n\n// sphere - distance function\nfloat sphere(vec3 r, float R)\n{ return length(r) - R; }\n\n//  distance from the scene\nfloat dist(vec3 r)\n{\n\tfloat d = 1e10;\n    \n    //borders y -2 0    x 1 -2.6, center:\n    //d = min(d, sphere(r + vec3(-0.8,-1,3), 0.1));\n    \n    float variator1 = iMouse.y/iResolution.y;\n    float variator2 = iMouse.x/iResolution.x;    \n    \n    //this could be commented\n    variator1 = abs(sin(iTime)) * 0.06 + 0.1;\n    variator2 = iTime * .01;    \n    \n    int n = 5;\n    for(int j=0; j<n; ++j){\n        float scale = 0.98;\n        float radius = variator1;\n        float angle = variator2;\n        angle = angle * 2.0 * 3.1415926535897932384626433832795;\n        angle = angle + angle * float(j);\n        vec3 offset = vec3(-0.8 + cos(angle)*radius, -1.0 + sin(angle)*radius, 3.0);\n        d = min(d, sphere(r + offset, .4));\n\n        for(int i=0; i<10; ++i){\n            angle = variator2;\n            angle = angle * 2.0 * 3.1415926535897932384626433832795 * float(i) * 3.0;\n            angle = angle + angle * float(j);\n            offset = vec3(offset.x + cos(angle)*radius, offset.y + sin(angle)*radius, 3.0);\n            d = min(d, sphere(r + offset, .3 * scale));\n            scale = scale * scale;\n        }   \n    }\n    \n    \n    int extraBallsNumber = 9;    \n    vec3 s[9] = vec3[](\n        //vec3(-2.6, -2.0, 3.0),\n        //vec3(1.0, 0.0, 3.0),\n        vec3(-1.2, -1.6, 6.0),\n        vec3(-2.0, -1.2, 5.0),\n        vec3(-1.0, -1.6, 4.0),\n        vec3(-1.6, -0.8, 2.0),\n        vec3(-1.0, 0.0, 3.0),\n        vec3(-1.7, -1.1, 3.0),\n        vec3(-2.4, 0.0, 5.0),\n        vec3(0.8, -0.9, 3.0),\n        vec3(1.1, -0.7, 7.0));    \n    for(int i=0; i<extraBallsNumber; ++i){\n   \t\td = min(d, sphere(r + s[i] + vec3(0, sin(iTime + float(i))*0.2, 0), .03));\n    }\n\t\n    return d;\n}\n\n// shadow is just sum of distances from the scene while marching towards light (l)\nfloat shadow(vec3 p, vec3 l, float d)\n{\n\tfloat o=0.0;\n\tfor (int i=12; i > 0; i--) \n\t{\n\t\to += dist( p+l*float(i)*d );\n\t}\n\n\treturn clamp(o, 0.0, 1.0);\n}\n\n// normal vector (needed for lighting)\n// http://www.pouet.net/topic.php?which=7920&page=10\n// rar\nvec3 normal(vec3 p)\n{\n\t#define dr 1e-4\n\tvec3 drx = vec3(dr,0,0);\n\tvec3 dry = vec3(0,dr,0);\n\tvec3 drz = vec3(0,0,dr);\n\treturn ( vec3( dist(p+drx), dist(p+dry), dist(p+drz) ) - dist(p)) / dr;\n}\n\n#define ITER 90\t\n#define EPS 0.0001\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = fragCoord.xy / iResolution.xy;\n\tr.x*=(iResolution.x/iResolution.y);\n\t\n\tvec4 color=vec4(0,0,0,1);\n\n\tvec3 camera = vec3(1.0,2.0,1.0);\n\tvec3 p = vec3(r.x, r.y+1.0, -1.0);\n\tvec3 dir = normalize(p-camera);\n\t\n\tfor(int i=0; i<ITER; i++)\n\t{\n\t\tfloat d = dist( p );\n\t\tif(d < EPS)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tp = p + dir * d;\n\t}\n\n\tvec3 n = normal(p);\n\t\n\t//vec3 light_pos = vec3(1.2,4.2,-0.5);\n    vec3 light_pos = vec3(cos(iTime)*2.0, 4.2, .0 + sin(iTime)*2.0);\n    \n\tfloat light = 15.0 + 1.2*(dot(n,light_pos));\n\tvec3 lightdir = normalize(light_pos-p);\n\tlight /= 0.2*pow(length(light_pos-p),3.4);\n\t\n    // uncomment for shadows\n\tlight *= shadow(p, lightdir, 0.01) * (abs(sin(iTime * 0.4)) - 0.2);\n\t\n\t//vec4 color2 = vec4(texture(iChannel0,r.xy ).xyz,1.0);//,light*0.891,light*0.998,1.0);\n\tcolor = vec4(light*0.89,light*0.891,light*0.998,1.0)*2.0;\n    \n    r.x *= 9.9;\n    r.x += iTime * 0.2;\n    vec2 uv = r * 6.0;\n    vec3 col = texture(iChannel0, uv).rgb;\n    color += vec4(max(vec3(col.r - .45), vec3(0)), 1.0);\n    \n\tfragColor = color;\n}\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 251, 282, 282, 306], [308, 336, 356, 356, 2024], [2026, 2109, 2148, 2148, 2259], [2261, 2360, 2381, 2381, 2551], [2589, 2589, 2646, 2646, 3683]], "test": "untested"}
{"id": "4tScDy", "name": "demo_04", "author": "jzllove9", "description": "依旧是从threejs扒过来的shader，但是做了部分更改", "tags": ["demo"], "likes": 0, "viewed": 104, "published": "Public", "date": "1509933296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* learn from :\n*\n* threejs example - webgl_shader2\n*\n* https://www.shadertoy.com/user/candycat\n*\n* sorry for my poor Artistic attainments o(╥﹏╥)o\n*\n*/\n\n//#define NOT_MIX_EDG\n\nconst float smoothLevel = 0.03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv = -1.0 + 2.0 * uv; //会变形\n\tvec2 uv = ( 2. * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);    \n    \n    vec3 bgColor =  vec3( 1.0 ) * ( 1.0 - 0.3 * length(uv) );\n    \n    float a = atan( uv.y, uv.x ); //当前像素所在弧度\n    float r = sqrt( dot( uv, uv ) ); //模长\n    \n    //把他们扭成一个根据时间变化的圆形区域\n    uv.x = cos( a ) / clamp(r, .5, 1.);\n    uv.y = sin( a ) / clamp(r, .5, 1.);\n    uv += iTime * 0.05;\n    \n    //偷来的颜色变化函数 ^_^\n    float color = 1.0;\n    color += sin(uv.x * cos(iTime/15.) * 80.) + cos(uv.y * cos(iTime/15.) * 10.);\n    color += sin( uv.y * sin( iTime / 10.0 ) * 40.0 ) + cos( uv.x * sin( iTime / 25.0 ) * 40.0 );\n    color += sin( uv.x * sin( iTime / 5.0 ) * 10.0 ) + sin( uv.y * sin( iTime / 35.0 ) * 80.0 );\n    color *= sin( iTime / 10.0 ) * 0.5;\n      \n    //输出\n    #ifdef NOT_MIX_EDG\n    \n\t//这种方式输出边界会有锯齿\n    fragColor = vec4(bgColor, 1.0);\n\tif( r <= 1.0 ){\n   \t \tfragColor = vec4(vec3(color, color * 0.5, sin(color + iTime/3.) * .75), 1.);\n    }\n    \n\t#else\n    \n    //通过mix + smoothstep混合边界\n    vec3 _color = mix( bgColor, vec3(color, color * .5, sin(color + iTime/3.) ), smoothstep(-smoothLevel, smoothLevel, 1.0 - r ) );\n    fragColor = vec4(_color, 1.0);\n    \n    #endif    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tScDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 217, 274, 314, 1613]], "test": "untested"}
{"id": "4tsfzn", "name": "signed distance edge AA", "author": "ShnitzelKiller", "description": "I tried to use the cone tracing technique for antialiasing, where each pixel blends between the seen object and a grazed object based on the covered area approximated from the grazing distance.\nIt doesn't seem to work very well. I exaggerated the effect.", "tags": ["antialiasing", "technique"], "likes": 1, "viewed": 572, "published": "Public API", "date": "1510791886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fdist 0.3\n#define iters 100\n#define tol 0.005\n#define maxdist 8.\n#define eps 0.01\n#define bevel 0.05\n#define innerradius 0.1\n#define sidelength 0.25\n#define pix (edgeblur/iResolution.x/fdist)\n#define lightdir vec3(1., 1., 1.)\n#define shadoweps 0.1\n#define shadowiters 20\n#define shadowstep 0.03\n#define sharpness 5.\n\n#define PI 3.1415926\n\n//factor by which to enlarge the solid angle subtended by a pixel in AA\n#define edgeblur 2.5\n\nfloat bevcube(vec3 ro) {\n    vec3 rad = clamp(ro, -sidelength, sidelength);\n    return length(ro-rad) - bevel;\n}\n\nvec2 map(vec3 ro) {\n    \n    //beveled cubes\n    vec2 disp = vec2(1., 0.);\n    float d = bevcube(ro);\n    d = min(d, bevcube(ro + disp.xyy));\n    d = min(d, bevcube(ro - disp.xyy));\n    d = min(d, bevcube(ro + disp.yyx));\n    d = min(d, bevcube(ro - disp.yyx));\n    d = min(d, bevcube(ro - disp.yxy));\n    \n    float d2 = min(d, length(ro + vec3(0., 10., 0.)) - 9.6);\n    if (d2 < d) {\n        return vec2(d2, 2.0);\n    } else {\n    \treturn vec2(d, 1.0);\n    }\n}\n\nfloat shadowtrace(vec3 ro, vec3 rd) {\n    int i;\n    float t = shadoweps;\n    float dist = map(ro+t*rd).x;\n    float fac = 1.0;\n    for (i=0; i<shadowiters; i++) {\n        t += shadowstep;\n        dist = map(ro + t*rd).x;\n        fac = min(fac, dist * sharpness / t);\n    }\n    return fac > 0. ? mix(0.5, 1., fac) : mix(0.5, 0., -fac);\n}\n\nvec4 raytrace(vec3 ro, vec3 rd) {\n    vec2 t = vec2(0.);\n    vec2 m = map(ro);\n    //fac.xyz are consecutive measurements, fac.w is the last local minimum\n    vec4 fac = vec4(maxdist);\n    int i;\n    for (i=0; i<iters; i++) {\n        t.x += m.x;\n        m = map(ro + rd * t.x);\n        fac.x = m.x / t.x;\n        //update facmin to last seen local minimum (not counting voxel borders)\n        if (fac.y < fac.x && fac.y <= fac.z && fac.y < fac.w) {\n            fac.w = fac.y;\n            t.y = t.x;\n        }\n        fac.zy = fac.yx;\n        if (abs(m.x) < tol) {\n            return vec4(t, m.y, fac.w);\n        } else if (t.x > maxdist) {\n            break;\n        }\n    }\n    return vec4(t, 0., fac.w);\n}\n\nvec4 getnormal(vec3 ro) {\n    vec2 d = vec2(eps, 0.0);\n    float x1 = map(ro+d.xyy).x;\n    float x2 = map(ro-d.xyy).x;\n    float y1 = map(ro+d.yxy).x;\n    float y2 = map(ro-d.yxy).x;\n    float z1 = map(ro+d.yyx).x;\n    float z2 = map(ro-d.yyx).x;\n    return vec4(normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2)),\n        x1+x2+y1+y2+z1+z2-6.*map(ro).x);\n}\n\nvec3 shade(vec3 pos, float mat, vec3 rd) {\n    vec3 col;\n    if (mat < 0.5) return mix(vec3(0.8, 0.9, 1.), vec3(0.2, 0.2, 0.3), pow(abs(rd.y), 3.5));\n    else if (mat < 1.5) col = vec3(0.6, 0.3, 0.8);\n    else col = vec3(0.4, 1., 0.4);\n    vec4 n = getnormal(pos);\n    float fac = dot(n.xyz, lightdir);\n    fac = min(fac, shadowtrace(pos + lightdir * shadoweps, lightdir));\n    fac = max(0.8, fac);\n\n    return fac * col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iMouse.y < 1. ? 0.2 : (iMouse.y/iResolution.y - 0.5) * PI;\n    float ww = (iMouse.x < 1. ? 0. : (iMouse.x/iResolution.x - 0.5) * PI) + iTime/2.;\n    vec3 ro = 2.*vec3(sin(ww)*cos(h), sin(h), cos(ww)*cos(h));\n    vec3 w = -normalize(ro);\n    vec3 u = normalize(cross(w, vec3(0., 10.0, 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n    vec4 d = raytrace(ro, rd);\n    float mat = map(ro + d.y*rd).y;\n    vec3 col1 = shade(ro + rd*d.x, d.z, rd);\n    vec3 col2 = shade(ro + rd*d.y, mat, rd);\n    //fac is an approximation of x*sqrt(1-x^2)+arcsin(x), the proportion of area of a\n    //circle that's covered by an edge at position x\n    //float fac = (sin((clamp(d.w/pix, 0., 1.)-0.5)*PI)+1.)/2.;\n    \n    //or just a linear ramp... I don't see the difference\n    float fac = clamp(d.w/pix, 0., 1.);\n    fragColor = vec4(mix(col2, col1, fac), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 441, 465, 465, 553], [555, 555, 574, 599, 1017], [1019, 1019, 1056, 1056, 1356], [1358, 1358, 1391, 1391, 2065], [2067, 2067, 2092, 2092, 2435], [2437, 2437, 2479, 2479, 2860], [2862, 2862, 2919, 2919, 3880]], "test": "untested"}
{"id": "4tXBWM", "name": "infinicube", "author": "laserdog", "description": "just more experimentation with raymarching. super basic stuff", "tags": ["raymarching", "noob"], "likes": 9, "viewed": 746, "published": "Public", "date": "1512063711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi  3.14159\n#define tau 6.28318\n#define t iTime\n\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\t\n    \n// source: http://iquilezles.org/www/articles/palettes/palettes.htm\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\n              in float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nconst float epsilon = .0001;\n\nvec3 rotateZ(vec3 p, float rads) {\n    return mat3(vec3(cos(rads), sin(rads), 0.), vec3(-sin(rads), cos(rads), 0.), vec3(0., 0., 1.)) * p;\n}\n\n// IQ distance functions\nfloat roundBoxSDF(vec3 p, vec3 size, float r)\n{\n\treturn length(max(abs(p) - size, 0.0))-r;\n}\n\nfloat opRep(vec3 p, vec3 c)\n{\n\tvec3 q = mod(p, c) - .5 * c;\n    return roundBoxSDF(q, vec3(.15), .1);\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return opRep(p, vec3(1.));\n}\n\nvec3 gradient(vec3 p)\n{\n    vec3 dx = vec3(epsilon, 0., 0.);\n    vec3 dy = vec3(0., epsilon, 0.);\n    vec3 dz = vec3(0., 0., epsilon);\n    return normalize(vec3(\n    \tsceneSDF(p + dx) - sceneSDF(p - dx),\n        sceneSDF(p + dy) - sceneSDF(p - dy),\n        sceneSDF(p + dz) - sceneSDF(p - dz)\n    ));\n}\n\nvec3 phong(vec3 p, vec3 eye, vec3[1] lights, vec3 color)\n{\n    const vec3 specularColor = vec3(1.);\n    const float ambientStrength = .5;\n    \n    vec3 norm = gradient(p);\n    vec3 col = vec3(0.);\n    vec3 view = normalize(eye - p);\n    \n    for (int i = 0; i < lights.length(); i++)\n    {\n        float kd = dot(lights[i], norm);\n        vec3 reflection = reflect(normalize(p - lights[i]), norm);\n        float ks = pow(max(dot(view, reflection), 0.), 16.);\n        \n        col += color * kd + ks * specularColor;\n    }\n    \n    return col + color * ambientStrength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfragColor = vec4(0.);\n    vec3 ray = normalize(vec3(uv, -1.));\n    vec3 eye = vec3(sin(iTime), sin(iTime), -iTime * 3.);\n    vec3[1] lights;\n    lights[0] = vec3(1., 2., 5.);\n    \n    vec3 pos = eye;\n    \n    float dist = 0.;\n    for (float i = 0.; i < 70.; i++)\n    {\n    \tdist = sceneSDF(rotateZ(pos, iTime));\n        pos += ray * dist;\n    }\n    \n    if (dist < epsilon) {\n        pos = rotateZ(pos, iTime);\n        float colorIndex = floor(pos.x) + floor(pos.y) + floor(pos.z);\n        colorIndex *= .2;\n        colorIndex += iTime;\n        \n        // https://www.shadertoy.com/view/MdXGDr\n\t\tfloat fogFact = clamp(exp(-distance(eye, pos) * 0.3), 0.0, 1.0);\n        \n    \tfragColor.rgb = fogFact * phong(pos, eye, lights, .5 * palette(colorIndex, p0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 245, 441, 441, 532], [564, 564, 598, 598, 704], [706, 731, 778, 778, 823], [825, 825, 854, 854, 928], [930, 930, 954, 954, 987], [989, 989, 1012, 1012, 1291], [1293, 1293, 1351, 1351, 1863], [1865, 1865, 1922, 1922, 2750]], "test": "untested"}
{"id": "4tXBzM", "name": "(no-signal) TV noise", "author": "Otringal", "description": "A simple emulation of a \"no-signal\" TV noise.", "tags": ["noise", "tv", "no", "channel", "signal", "radio", "antenna"], "likes": 2, "viewed": 269, "published": "Public", "date": "1511280423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getUVCoords(in vec2 fragCoords)\n{\n    vec2 standardUVs = (fragCoords - 0.5) / (iResolution.xy - 1.0);\n    return standardUVs;\n}\n\nfloat getRandomValue(vec2 uvCoords)\n{\n    return fract(sin(fract(iTime) / 10.0 * dot(uvCoords, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = getUVCoords(fragCoord);\n    vec4 image = texture(iChannel0, uv);\n    \n    fragColor = getRandomValue(uv) + 0.2 * image;\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 132], [134, 134, 171, 171, 272], [274, 274, 329, 329, 465]], "test": "untested"}
{"id": "4tXfD7", "name": "Torus_Thingy_4", "author": "balkhan", "description": "torus", "tags": ["3d", "raymarch", "tori"], "likes": 9, "viewed": 145, "published": "Public", "date": "1512031670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t200\n#define E\t\t\t0.001\n#define FAR\t\t\t10.\n\n#define\tFUDGE\n// artifactus disparatus !! (fudge needed cuz of high curvature distorsion)\n//#define PHONG\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tbase;\nvec3\th;\nvec3\tvolumetric;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    volumetric *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2((f.x-.5*iResolution.x)/iResolution.x, (f.y-.5*iResolution.y)/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 25.0-sin(iTime*.125)*25.*0.-21.+2.);\n\n    vec4\tinter = (march(pos, dir));\n\n    if (inter.y == 1.)\n    {\n    \tbase = vec3(.5, .25, .8);\n\t    #ifdef PHONG\n        // substracting a bit from the ray to get a better normal\n\t\tvec3\tv = pos+(inter.w-E*10.)*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(0.0, 0.0, 0.0);\n\t\tvec3\tlight_color = vec3(.0, .5, .2);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 10.8 );\n        col.xyz = light_color * (specular) + diffuse * base;\n        float\tdt = 1. - dot(n, normalize(-ev) );\n        col += smoothstep(.0, 1.0, dt)*vec3(.2, .7, .90);\n\t#else\n    \tcol.xyz = 1.*( +vec3(.3, .4, .2)*inter.w * .3-inter.x*.1 * vec3(.15, .2, .15) );\n\t#endif\n    \tcol  -= -.25 + h;\n    }\n    col += volumetric;\n    c_out =  vec4(col, h.x);\n}\n\nfloat\tscene(vec3 p)\n{\n    p.z+=sin(t*.5)*2.;\n    float\tballs = 1e5;\n    float\tlumos = 1e5;\n\tvec3\tpr;\n\n    vec2\tq;\n    \n    pr = p;\n    \n    rotate(pr.yz , iTime*.5);\n    rotate(pr.xz , iTime*1.);\n        \n    float\tata = atan(pr.x, pr.y)*1.+0.;\n    \n    q = vec2(length(pr.xy)-2., pr.z);\n    \n    rotate(q.xy, +iTime*2.+ata*2.);\n    \n    q.xy = abs(q.xy)-.25;\n    \n    rotate(q.xy, -iTime*2.+ata*1. );\n    q.x = abs(q.x)-.25;\n    rotate(q.xy, +iTime*2.+ata*8. );\n    q.xy = abs(q.xy)-.051;\n    balls = mylength(q)+(-.0405+sin( (ata*2.)-iTime*3.)*.0251);\n    \n    \n    \n    float\tlight = length(pr)-.01;\n\n\t#ifdef\tFUDGE\n    balls *= .5;\n    #endif\n    rotate(p.yx, iTime*.5);\n    #ifdef\tFUDGE\n    lumos = length(p.y-18.)-20.1;\n    h += (.251/(lumos + 10.1))*vec3(.0,.0,.5);\n    lumos = length(p.y+18.)-20.1;\n    h += (.251/(lumos + 10.1))*vec3(.0, .5, .0);\n    volumetric += .1/(light+2.1)*vec3(.085,.105,.505);\n    #else\n    lumos = length(p.y-18.)-10.1;\n    h += (.51/(lumos + 10.1))*vec3(.0,.0,.5);\n    lumos = length(p.y+18.)-10.1;\n    h += (.51/(lumos + 10.1))*vec3(.0, .5, .0);\n    volumetric += .2/(light+2.1)*vec3(.085,.105,.505);\n    #endif\n\t\n    return(balls);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*1.;\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXfD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[174, 496, 539, 539, 1718], [1720, 1720, 1741, 1741, 2890], [2892, 2892, 2924, 2924, 3429], [3431, 3445, 3469, 3469, 3613], [3615, 3615, 3639, 3639, 3777], [3779, 3779, 3819, 3819, 3894], [3896, 3896, 3946, 3946, 4206], [4208, 4208, 4230, 4230, 4436]], "test": "untested"}
{"id": "4tXfR8", "name": "Mobius Floater", "author": "Zanzlanz", "description": "Drag mouse to set number of weaves!\n\nA floating, pulsating weaved thing! It's a Mobius knot! It's similar to my Sierpinski Floater: https://www.shadertoy.com/view/XtyGD1\n\nAn alt version - b&w with a neat background: https://www.shadertoy.com/view/4tXBRH", "tags": ["2d", "mobius", "ring", "hsv", "hue", "knot", "weave"], "likes": 6, "viewed": 462, "published": "Public API", "date": "1510880361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Use it, change it, enjoy! By Zanzlanz :)\n// Here's an alt version: https://www.shadertoy.com/view/4tXBRH\n\n#define pi 3.14159265358979\n\n// Hue. https://www.laurivan.com/rgb-to-hsv-to-rgb-for-shaders/\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Black background\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n    \n    // Set the moose (xmouse)\n    float moose = iMouse.x/iResolution.x;\n    if(iMouse.x == 0.0 && iMouse.y == 0.0) moose = .4;\n    \n    // Make the X coordinates the same distance as the Y\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    uv.xy -= .5;\n\tuv.x += (1.0-iResolution.x/iResolution.y)/2.0;\n    \n    // Rotate the camera a bit, then draw grid\n    float gridSize = sin(iTime/5.0)*.01+.07;\n    uv.xy = vec2(uv.x*cos(.1) - uv.y*sin(.1), uv.x*sin(.1) + uv.y*cos(.1));\n    float d2E = smoothstep(0.0, 1.0, min(min(mod(uv.x, gridSize), mod(uv.y, gridSize)), min(gridSize-mod(uv.x, gridSize), gridSize-mod(uv.y, gridSize)))*200.0);\n    col = vec3(d2E*.04+.49, d2E*.04+.66, d2E*.05+.73);\n    \n    // Move mobius thing around\n    uv.x += sin(iTime/5.0)*.4;\n    uv.y += cos(iTime/4.0)*.1;\n    \n    float globalRotationTime = iTime/10.0;\n    uv.xy = vec2(uv.x*cos(globalRotationTime) - uv.y*sin(globalRotationTime), uv.x*sin(globalRotationTime) + uv.y*cos(globalRotationTime));\n\n    // Now many weaves there are (.5 though, because Mobius <3)\n    float cuts = 1.5 + floor(moose*10.0);\n\t\n    // Radians of the first loop   \n    float rotA = atan(uv.y, uv.x)+pi;\n    \n    // Radius of overal circle - fun to change per pixel\n    float rawRadius = .30 + sin(iTime/2.0)*.07;\n    \n\t// How thick the strands are\n    float separation = sin(iTime+rotA*3.0)*.01 + .02;\n    \n\t// Distance between the two strands\n\tfloat dist = sqrt(uv.x*uv.x + uv.y*uv.y);\n\n\t// Radius of first loop\n\tfloat radiusA = sin(rotA*cuts)*.039+rawRadius;\n\n    // Radians and radius of the second loop\n\tfloat rotB = rotA + pi*2.0/cuts/2.0;\n\tfloat radiusB = sin(rotB*cuts)*.02+rawRadius;\n\n\t// Draw black border around shape\n    col = mix(col, vec3(.34, .37, .43), \n              smoothstep(0.0, 1.0, 1.0-200.0*min(abs(dist - radiusA) - separation, abs(dist - radiusB) - separation)));\n    \n\t// Draw the first loops\n    if(abs(dist - radiusA) < separation) {\n        col = hsv2rgb(mix(vec3(0.0, 1.0, 0.7), vec3(.5, 1.0, 0.7), rotA/2.0/pi + iTime/20.0));\n    }\n    \n    // Draw the second loop\n    // If it's going behind the first loop, only draw it if the pixel isn't colliding with that region\n\tif(fract((rotB/2.0/pi+1.0/(cuts*4.0))*cuts)>.5 || abs(dist - radiusA) > separation) {\n        if(abs(dist - radiusB) < separation) {\n            col = hsv2rgb(mix(vec3(.5, 1.0, 0.7), vec3(1.0, 1.0, 0.7), rotA/2.0/pi + iTime/20.0));\n        }\n\t}\n    \n    // Boop!\n\tfragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 202, 224, 224, 393], [395, 395, 452, 476, 2953]], "test": "untested"}
{"id": "4tXfRr", "name": "MeshFromPlanes", "author": "MrShoor", "description": "small sample of raycasts to planes", "tags": ["raytrace"], "likes": 3, "viewed": 256, "published": "Public", "date": "1510714537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define planes_cnt  80\nvec4 planes[planes_cnt];\n\nvoid init_planes(){\nplanes[ 0 ] = vec4( 0.54464017315 , -0.81413923881 , -0.201356354805 , -0.943523476532 );\nplanes[ 1 ] = vec4( 0.940030081246 , -0.339036050957 , 0.0373898716834 , -0.943522897356 );\nplanes[ 2 ] = vec4( 0.210969315095 , -0.899183404549 , -0.383355126575 , -0.943522843872 );\nplanes[ 3 ] = vec4( 0.191103708694 , -0.681940395046 , -0.706000474595 , -0.943522854432 );\nplanes[ 4 ] = vec4( 0.51249698306 , -0.46263317111 , -0.723406795201 , -0.943523515601 );\nplanes[ 5 ] = vec4( 0.9672732032 , -0.0159771640312 , 0.253233648238 , -0.943522045293 );\nplanes[ 6 ] = vec4( 0.223392303424 , -0.754384288562 , 0.617252155883 , -0.94352133689 );\nplanes[ 7 ] = vec4( -0.617239817425 , -0.779532176567 , -0.106511001694 , -0.943521849828 );\nplanes[ 8 ] = vec4( -0.392886504299 , -0.0566671399175 , -0.917839326894 , -0.943521100907 );\nplanes[ 9 ] = vec4( 0.586396852264 , 0.4152335237 , -0.695499714199 , -0.943521492953 );\nplanes[ 10 ] = vec4( 0.797757057719 , -0.0861272896318 , 0.596796252368 , -0.943521097419 );\nplanes[ 11 ] = vec4( -0.164627101792 , -0.742831132347 , 0.648922049381 , -0.943521514501 );\nplanes[ 12 ] = vec4( -0.818899282682 , -0.498171366121 , -0.285007464464 , -0.943522997753 );\nplanes[ 13 ] = vec4( -0.260878351176 , 0.309737320856 , -0.91433324229 , -0.943521502657 );\nplanes[ 14 ] = vec4( 0.738270785188 , 0.564393687874 , -0.369345384194 , -0.943521120671 );\nplanes[ 15 ] = vec4( 0.0864553115838 , 0.294679500373 , 0.951677188525 , -0.943521936839 );\nplanes[ 16 ] = vec4( -0.69419416658 , -0.041678980738 , 0.718580073235 , -0.943522583511 );\nplanes[ 17 ] = vec4( -0.940030081246 , 0.339036050957 , -0.0373898716834 , -0.943522897356 );\nplanes[ 18 ] = vec4( -0.311323244067 , 0.910690313294 , -0.271516097084 , -0.943522483652 );\nplanes[ 19 ] = vec4( 0.323087362833 , 0.88327574782 , 0.339762430664 , -0.943522830784 );\nplanes[ 20 ] = vec4( -0.210969316635 , 0.899183463939 , 0.383354986426 , -0.943522821645 );\nplanes[ 21 ] = vec4( 0.0471338065867 , 0.973883074805 , 0.222103941623 , -0.934172769829 );\nplanes[ 22 ] = vec4( 0.0223478911823 , 0.995734562625 , -0.0895167724674 , -0.943521881356 );\nplanes[ 23 ] = vec4( -0.544640090428 , 0.814139314409 , 0.20135627289 , -0.943523450529 );\nplanes[ 24 ] = vec4( -0.564252373405 , 0.818055676839 , -0.111374003693 , -0.934173197453 );\nplanes[ 25 ] = vec4( -0.753680118405 , 0.608837357822 , -0.247554743123 , -0.943522553468 );\nplanes[ 26 ] = vec4( -0.730989639978 , 0.544338757965 , 0.411520914197 , -0.943523907839 );\nplanes[ 27 ] = vec4( -0.90570749993 , 0.323690648444 , 0.273712054319 , -0.934173756305 );\nplanes[ 28 ] = vec4( -0.91268748288 , 0.0400266617521 , 0.406693281163 , -0.943522930686 );\nplanes[ 29 ] = vec4( -0.51249692643 , 0.462633145411 , 0.723406851756 , -0.943523499855 );\nplanes[ 30 ] = vec4( -0.505355830051 , 0.173983823021 , 0.845189395556 , -0.934173244497 );\nplanes[ 31 ] = vec4( -0.23493837827 , 0.0753715401824 , 0.969083633824 , -0.943522510519 );\nplanes[ 32 ] = vec4( -0.19110371034 , 0.681940326138 , 0.706000540709 , -0.943522839495 );\nplanes[ 33 ] = vec4( 0.0835341491243 , 0.575822725969 , 0.813295908134 , -0.934172796884 );\nplanes[ 34 ] = vec4( 0.342952874182 , 0.666033238885 , 0.662407012939 , -0.943522824942 );\nplanes[ 35 ] = vec4( 0.61723981945 , 0.779532174756 , 0.106511003214 , -0.943521848824 );\nplanes[ 36 ] = vec4( 0.58611618715 , 0.783791498097 , -0.205277136262 , -0.934171247427 );\nplanes[ 37 ] = vec4( 0.316501024118 , 0.891990949157 , -0.322768103061 , -0.943521101105 );\nplanes[ 38 ] = vec4( -0.223392308181 , 0.754384287977 , -0.617252154876 , -0.943521335972 );\nplanes[ 39 ] = vec4( -0.403133426416 , 0.531661207055 , -0.7448622701 , -0.934171364222 );\nplanes[ 40 ] = vec4( -0.665748942334 , 0.45253209033 , -0.593290024358 , -0.943521476812 );\nplanes[ 41 ] = vec4( -0.9672732032 , 0.0159771640312 , -0.253233648238 , -0.943522045293 );\nplanes[ 42 ] = vec4( -0.955624671829 , -0.268240484645 , -0.121772447576 , -0.934172584634 );\nplanes[ 43 ] = vec4( -0.939930613317 , -0.283031959581 , 0.190849029352 , -0.943522047872 );\nplanes[ 44 ] = vec4( -0.586396852264 , -0.4152335237 , 0.695499714199 , -0.943521492953 );\nplanes[ 45 ] = vec4( -0.307836092953 , -0.510476351341 , 0.802901509898 , -0.934171366418 );\nplanes[ 46 ] = vec4( -0.127141289939 , -0.298183957307 , 0.946002864688 , -0.943521328004 );\nplanes[ 47 ] = vec4( 0.392886505185 , 0.0566671430578 , 0.917839326321 , -0.943521100287 );\nplanes[ 48 ] = vec4( 0.645012967097 , 0.139716928764 , 0.751290524427 , -0.934171238614 );\nplanes[ 49 ] = vec4( 0.649383422732 , 0.428020722167 , 0.628569353115 , -0.943521846976 );\nplanes[ 50 ] = vec4( 0.164627100239 , 0.742831130405 , -0.648922051997 , -0.943521511372 );\nplanes[ 51 ] = vec4( 0.307836092953 , 0.510476351341 , -0.802901509898 , -0.934171366418 );\nplanes[ 52 ] = vec4( 0.127141289305 , 0.298183956536 , -0.946002865016 , -0.943521328352 );\nplanes[ 53 ] = vec4( -0.797757057719 , 0.0861272896318 , -0.596796252368 , -0.943521097419 );\nplanes[ 54 ] = vec4( -0.645012967097 , -0.139716928764 , -0.751290524427 , -0.934171238614 );\nplanes[ 55 ] = vec4( -0.649383422732 , -0.428020722167 , -0.628569353115 , -0.943521846976 );\nplanes[ 56 ] = vec4( -0.738270785188 , -0.564393687874 , 0.369345384194 , -0.943521115168 );\nplanes[ 57 ] = vec4( -0.58611618715 , -0.783791498097 , 0.205277136262 , -0.934171247427 );\nplanes[ 58 ] = vec4( -0.316501043777 , -0.891990944717 , 0.322768096054 , -0.943521094035 );\nplanes[ 59 ] = vec4( 0.260878349338 , -0.309737320916 , 0.914333242794 , -0.943521503014 );\nplanes[ 60 ] = vec4( 0.403133426416 , -0.531661207055 , 0.7448622701 , -0.934171364222 );\nplanes[ 61 ] = vec4( 0.665748942334 , -0.45253209033 , 0.593290024358 , -0.943521476812 );\nplanes[ 62 ] = vec4( 0.818899287367 , 0.498171367532 , 0.285007448535 , -0.943522994632 );\nplanes[ 63 ] = vec4( 0.955624671829 , 0.268240484645 , 0.121772447576 , -0.934172584634 );\nplanes[ 64 ] = vec4( 0.939930610839 , 0.283031959617 , -0.190849041505 , -0.943522054825 );\nplanes[ 65 ] = vec4( 0.69419416658 , 0.041678980738 , -0.718580073235 , -0.943522583511 );\nplanes[ 66 ] = vec4( 0.505355843426 , -0.173983810055 , -0.845189390228 , -0.934173247954 );\nplanes[ 67 ] = vec4( 0.234938372959 , -0.0753715184715 , -0.969083636801 , -0.943522514743 );\nplanes[ 68 ] = vec4( -0.0864553356722 , -0.294679483775 , -0.951677191476 , -0.943521942346 );\nplanes[ 69 ] = vec4( -0.0835342038274 , -0.575822746717 , -0.813295887825 , -0.934172806665 );\nplanes[ 70 ] = vec4( -0.342952874182 , -0.666033238885 , -0.662407012939 , -0.943522824942 );\nplanes[ 71 ] = vec4( -0.323087360526 , -0.883275755633 , -0.339762412547 , -0.943522827063 );\nplanes[ 72 ] = vec4( -0.0471339128539 , -0.973883058465 , -0.22210399072 , -0.934172790916 );\nplanes[ 73 ] = vec4( -0.0223479772943 , -0.995734554412 , 0.0895168423356 , -0.943521902186 );\nplanes[ 74 ] = vec4( 0.91268748288 , -0.0400266617521 , -0.406693281163 , -0.943522930686 );\nplanes[ 75 ] = vec4( 0.905707491462 , -0.323690645086 , -0.273712086312 , -0.934173760017 );\nplanes[ 76 ] = vec4( 0.730989639978 , -0.544338757965 , -0.411520914197 , -0.943523907839 );\nplanes[ 77 ] = vec4( 0.311323230701 , -0.910690291665 , 0.271516184956 , -0.943522504829 );\nplanes[ 78 ] = vec4( 0.564252478034 , -0.81805560055 , 0.11137403396 , -0.934173213706 );\nplanes[ 79 ] = vec4( 0.753680118405 , -0.608837357822 , 0.247554743123 , -0.943522553468 );\n}\n\nstruct hit_test {\n    vec4 p;\n    float t;\n};\n\nhit_test h_t(vec3 ro, vec3 rd, vec4 p) {\n    hit_test Out;\n    float dp = dot(rd, p.xyz);\n    float t = (-p.w - dot(p.xyz, ro))/dp;\n    Out.t = t;\n    Out.p = p;\n    return Out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    init_planes();\n    \n    vec3 rd;\n    rd.xy = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    rd.x *= iResolution.x/iResolution.y;\n    rd.z = 1.0;\n    vec3 ro = vec3(0.0,0.0,-2.0);\n    \n    fragColor = vec4(-normalize(rd).y);\n    \n    float fi = iTime*0.5;\n    vec2 a = vec2(cos(fi), sin(fi));\n    mat2 rot = mat2(a, -a.y, a.x);    \n    ro.xz = rot*ro.xz;\n    rd.xz = rot*rd.xz;\n\n    hit_test res = h_t(ro, rd, planes[0]);\n    hit_test h;\n    bool inited = false;\n    for (int i=0; i < planes_cnt; i++) {\n        if (dot(rd, planes[i].xyz) < 0.0) {\n            h = h_t(ro, rd, planes[i]);\n            if (h.t > 0.0) {\n                if (!inited||(h.t > res.t)) {\n                    res = h;\n                    inited = true;\n                }\n            }\n        }\n    }\n    \n    for (int i=0; i < planes_cnt; i++) {\n        if (dot(rd, planes[i].xyz) > 0.0) {\n            h = h_t(ro, rd, planes[i]);\n            if (h.t < res.t) return;\n        }\n    }\n    \n    if (!inited) return;\n    \n    fragColor=vec4(vec3(-dot(res.p.xyz, rd)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 68, 68, 7446], [7495, 7495, 7535, 7535, 7674], [7676, 7676, 7733, 7733, 8782]], "test": "untested"}
{"id": "ll2cDG", "name": "White Folly", "author": "dr2", "description": "Folly (architectural) with spiral stairways (in a pond filled with Voronoi stones); mouse enabled.", "tags": ["voronoi", "refraction", "symmetry", "architecture", "stairs"], "likes": 26, "viewed": 761, "published": "Public API", "date": "1510057197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"White Folly\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\n\nvec3 sunDir, qHit;\nfloat dstFar, tCur, tWav;\nint idObj;\nbool inWat;\nconst int idStr = 1, idBal = 2, idPlat = 3, idBalc = 4, idPil = 5, idWl = 6, idFlr = 7;\n\nfloat ObjDfS (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, db, s, a;\n  q = p;\n  q.xz = abs (Rot2D (q.xz, pi)) - 6.5;\n  db = PrBox2Df (q.xz, vec2 (4.));\n  q.xz += 6.5;\n  q.xz = Rot2D (q.xz, 0.75 * pi);\n  q.x += 4.;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = vec2 (24. * a, length (q.xz) - 6.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  s = mod (q.x, sqrt (0.5));\n  d = max (0.3 * max (q.y - min (s, sqrt (0.5) - s), max (-0.1 - q.y, abs (q.z) - 1.5)),\n     abs (p.y) - 3.5);\n  d = max (d, db);\n  if (d < dMin) { dMin = d;  idObj = idStr; }\n  q.xy -= vec2 (1.5, 1.4);\n  q.z = abs (q.z) - 1.43;\n  d = PrBoxDf (q, vec3 (4.7, 0.07, 0.07));\n  q.x = 0.5 * mod (96. * a + 0.5, 1.) - 0.35;\n  q.y += 0.7;\n  d = min (d,  PrCylDf (q.xzy, 0.05, 0.7));\n  d = max (0.3 * d, db);\n  if (d < dMin) { dMin = d;  idObj = idBal; }\n  return dMin;\n}\n\n/*\n  This function is called twice, for the two orientations of the horizontal \n  walkway. Could be replaced by a single call, with orientation dependent on \n  position along ray path; this is faster (good) but there are visual artifacts for \n  certain view directions (bad). Artifacts can be removed by using cells in the \n  vertical direction (good), but this is slower (bad).\n*/\n\nfloat ObjDfB (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = max (PrBoxDf (q, vec3 (10.35, 0.26, 2.85)),\n    - max (length (vec2 (mod (q.x + 2., 4.) - 2., q.z)) - 1.5, 0.3 - abs (q.z)));\n  if (d < dMin) { dMin = d;  idObj = idPlat;  qHit = q; }\n  q = p;  q.y -= 2.05;  q.z = abs (q.z) - 2.45;\n  d = PrBoxDf (q, vec3 (7.45, 0.08, 0.07));\n  q.x = mod (q.x + 0.25, 0.5) - 0.25;\n  q.y += 0.95;\n  d = min (d, max (PrCylDf (q.xzy, 0.06, 0.9), abs (p.x) - 7.45));\n  q = p;  q.y -= 1.06;  q.x = abs (q.x) - 10.23;  q.y -= 0.95;\n  d = min (d, PrBoxDf (q, vec3 (0.07, 0.08, 2.5)));\n  q.y += 0.95;  q.z = mod (q.z + 0.25, 0.5) - 0.25;\n  d = min (d, max (PrCylDf (q.xzy, 0.06, 0.9), abs (p.z) - 2.45));\n  if (d < dMin) { dMin = d;  idObj = idBalc; }\n  q = p;  q.xz = abs (q.xz) - vec2 (8.8, 2.4);  q.x = abs (q.x) - 1.45;  q.y -= 1.3;\n  d = PrCylDf (q.xzy, 0.2, 1.05);\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.y -= 3.;\n  if (! inWat) {\n    dMin = ObjDfS (p, dMin);\n    q = p;  q.y -= 3.25;\n    dMin = ObjDfB (q, dMin);\n    q = p;  q.y -= -3.25;  q.xz = vec2 (- q.z, q.x);\n    dMin = ObjDfB (q, dMin);\n    q = p;  q.y -= 9.;\n    d = max (PrBoxDf (q, vec3 (2.5, 0.15, 2.5)),\n       - max (length (q.xz) - 1., max (0.1 - abs (q.x), 0.1 - abs (q.z))));\n    if (d < dMin) { dMin = d;  idObj = idPlat;  qHit = q; }\n  }\n  q = p;  q.xz = abs (q.xz) - 1.8;  q.y -= 1.;\n  d = PrCylDf (q.xzy, 0.2, 8.);\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  q = p;  q.y -= -5.2;\n  d = PrCylAnDf (q.xzy, 20., 0.3, 2.3);\n  if (d < dMin) { dMin = d;  idObj = idWl; }\n  q = p;  q.y -= -7.4;\n  d = PrCylDf (q.xzy, 20., 0.01);\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d, eps;\n  eps = 0.001;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y >= 0.) col = mix (vec3 (0.1, 0.2, 0.4), vec3 (1.), 0.1 + 0.8 * rd.y);\n  else {\n    ro -= ((ro.y + 0.5) / rd.y) * rd;\n    col = mix (0.7 * mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), Fbm2 (ro.xz)) *\n         (1. - 0.15 * Noisefv2 (330. * ro.xz)), vec3 (0.18, 0.28, 0.48), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 3. * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, vnw, row, rdw, col;\n  float dstObj, dstWat, s, a, sh;\n  bool isRefl;\n  HexVorInit ();\n  inWat = false;\n  isRefl = false;\n  tWav = 0.3 * tCur;\n  dstObj = ObjRay (ro, rd);\n  dstWat = - (ro.y + 0.6) / rd.y;\n  if (dstWat < min (dstObj, dstFar) && length ((ro + dstWat * rd).xz) < 20.) {\n    ro += dstWat * rd;\n    row = ro;\n    rdw = rd;\n    vnw = WaveNf (1.5 * ro, dstWat);;\n    rd = refract (rd, vnw, 1./1.333);\n    ro += 0.01 * rd;\n    inWat = true;\n    dstObj = ObjRay (ro, rd);\n    inWat = false;\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    if (ro.y < -0.5 && length (ro.xz) > 20.3) col = BgCol (ro, rd);\n    else {\n      vn = ObjNf (ro);\n      if (idObj == idStr) {\n        col = vec3 (0.95, 0.95, 1.);\n      } else if (idObj == idBal || idObj == idBalc) {\n        col = vec3 (0.8, 0.8, 1.);\n      } else if (idObj == idPlat) {\n        col = vec3 (1.);\n        if (vn.y > 0.99) {\n          if (ro.y > 7.5) s = mod (3. * length (qHit.xz), 1.);\n          else s = mod (3. * qHit.x, 1.);\n          col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, s);\n        } else if (abs (vn.y) < 0.01) {\n          s = mod (8. * ro.y, 1.);\n          col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, s);\n        }\n        vn = VaryNf (100. * ro, vn, 0.2); \n      } else if (idObj == idPil) {\n        if (abs (vn.y) < 0.01) {\n          a = (length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / pi : 0.;\n          s = mod (3. * qHit.y + a, 1.);\n          vn.y = 0.2 * (1. - SmoothBump (0.2, 0.8, 0.1, s)) * sign (s - 0.5);\n          vn.xz *= sqrt (1. - vn.y * vn.y);\n        }\n        col = vec3 (0.9, 0.9, 0.3);\n      } else if (idObj == idWl) {\n        a = (length (ro.xz) > 0.) ? atan (ro.z, - ro.x) / pi : 0.;\n        col = vec3 (0.6, 0.4, 0.3) * (0.5 +\n           0.5 * SmoothBump (0.05, 0.95, 0.02, mod (64. * a, 1.))) *\n           (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (ro.y + 0.5, 1.)));\n        vn = VaryNf (20. * ro, vn, 1.);   \n      } else if (idObj == idFlr) {\n        vc = HexVor (ro.xz);\n        vn.xz = - 0.7 * vc.yz;\n        vn = normalize (vn);\n        s = mod (10. * vc.w, 1.);\n        col = HsvToRgb (vec3 (0.1 + 0.3 * step (2. * s, 1.) + 0.1 * mod (5. * s, 1.),\n           0.5 + 0.5 * mod (17. * s, 1.), 0.7 + 0.3 * mod (12. * s, 1.))) *\n           (0.6 + 0.4 * smoothstep (0., 0.2, vc.x)) * (1. - 0.2 * Noisefv2 (128. * ro.xz));\n      }\n      sh = 0.4 + 0.6 * ObjSShadow (ro, sunDir);\n      col = col * (0.2 + sh * max (dot (sunDir, vn), 0.) +\n         0.1 * max (dot (- sunDir.xz, vn.xz), 0.)) +\n         0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else {\n    if (isRefl) sh = ObjSShadow (row, sunDir);\n    col = BgCol (ro, rd);\n  }\n  if (isRefl) {\n    col = mix (0.9 * col, vec3 (1., 1., 0.9), sh *\n       pow (max (0., dot (sunDir, reflect (rdw, vnw))), 64.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 120.;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az -= 0.1 * tCur;\n    el -= 0.1 * pi * cos (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 7. - 2. * cos (az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 1., -70.);\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2cDG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 795, 830, 830, 1645], [1647, 2030, 2065, 2065, 2971], [2973, 2973, 2995, 2995, 3810], [3812, 3812, 3845, 3845, 4039], [4041, 4041, 4062, 4062, 4264], [4266, 4266, 4303, 4303, 4513], [4515, 4515, 4546, 4546, 4887], [4889, 4889, 4912, 4912, 5435], [5437, 5437, 5468, 5468, 5671], [5673, 5673, 5708, 5708, 8601], [8603, 8603, 8659, 8659, 9565], [9567, 9567, 9599, 9599, 9699], [9701, 9701, 9734, 9734, 9823], [9825, 9825, 9867, 9867, 9918], [9920, 9920, 9973, 9973, 10034], [10084, 10084, 10108, 10108, 10338], [10340, 10340, 10364, 10364, 10424], [10426, 10426, 10446, 10446, 10666], [10668, 10668, 10690, 10690, 11286], [11288, 11288, 11333, 11333, 11436], [11438, 11438, 11495, 11495, 11578], [11580, 11580, 11610, 11610, 11668], [11670, 11670, 11694, 11694, 11830], [11864, 11864, 11888, 11888, 11948], [11950, 11950, 11974, 11974, 12104], [12106, 12106, 12131, 12131, 12317], [12319, 12319, 12340, 12340, 12495], [12497, 12497, 12526, 12526, 12742], [12744, 12744, 12783, 12783, 12963]], "test": "untested"}
{"id": "ll2cDK", "name": "Hilbert Curve Visualization", "author": "Equations", "description": "Since Hilbert curve iterations contain one another, we can use that to create a (kind of) nice zoom out effect.\nAlso knowing myself, this Code is probably rater unoptimized, so feel free to send suggestions!", "tags": ["hilbertcurve"], "likes": 5, "viewed": 186, "published": "Public", "date": "1510250276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//scaleFactor = ln(2) / 2 / pi\nconst float scaleFactor = 0.110317800;\n//zoomSpeed: at 2.0 new Iteration every PÍ seconds\nconst float zoomSpeed = 2.0;\nconst float lineThicknessBase = 0.025;\nconst float lineThicknessIncrease = 0.5;\nconst int maxIterations = 10;\n//maxsize = 2^maxIterations\nconst float maxSize = 1024.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    float scale = min(exp((zoomSpeed * iTime - sin(zoomSpeed * iTime)) * scaleFactor), maxSize);\n    //different scale depending on if your screen is higher or wider\n    vec2 uv = vec2(fragCoord.x - max((iResolution.x - iResolution.y) / 2.0, 0.0), \n                   fragCoord.y - max((iResolution.y - iResolution.x) / 2.0, 0.0)) \n        / min(iResolution.y, iResolution.x) * scale;\n    \n    float lineThickness = lineThicknessBase * pow(scale, lineThicknessIncrease);\n    \n    float size = maxSize;\n    for(int it = 0; it < maxIterations; ++it)\n    {\n        if(scale < size)\n        {\n            size = size / 2.0;\n        \tcontinue;\n        }\n    \t\n        size = size / 2.0;\n        //test if uv is at a left/middle/right connection piece of iteration\n        if(  (abs(uv.x - 0.5) < lineThickness && uv.y >= size - 0.5 && uv.y <= size + 0.5)\n          || (abs(uv.y - size + 0.5) < lineThickness && uv.x >= size - 0.5 && uv.x <= size + 0.5) \n          || (abs(uv.x - 2.0 * size + 0.5) < lineThickness && uv.y >= size - 0.5 && uv.y <= size + 0.5))\n        {\n        \tfragColor = vec4(0.0);\n            return;\n        }\n        //rotate vector uv into correct quadrant for next iteration\n        if(uv.y > size)\n        {\n            uv = vec2(2.0 * size - uv.y, abs(uv.x - size));\n        }\n        else if(uv.x > size)\n        {\n        \tuv.x = uv.x - size;\n        }\n    }\n    //add dot\n    if(distance(uv, vec2(0.5, 0.5)) < lineThickness)\n    {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 320, 377, 377, 1898]], "test": "untested"}
{"id": "ll2cWt", "name": "Volumetric Light Demo", "author": "Crow", "description": "volume light", "tags": ["raymarching", "volumetric"], "likes": 8, "viewed": 425, "published": "Public", "date": "1511623309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define NEAR 0.1\n#define FAR 10.0\n#define CYC 0.5\n#define MOVRADA 0.6\n#define MOVRADB 1.1\n#define EMIRAD 0.2\n#define STEPS 30.0\n\nfloat SdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nvec2 OpU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat OpS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nvec2 Map( vec3 pos )\n{    \n    vec3 movPos = vec3(sin(iTime * CYC), 0.0, cos(iTime * CYC)) * MOVRADA\n        \t\t  + vec3(cos(iTime * CYC * 2.0 + PI * 0.5), 0.0, sin(iTime * CYC * 2.0 + PI * 0.5)) * MOVRADB;\n    vec2 res = vec2(SdSphere(pos - (vec3(0, 1.0, 0) + movPos), EMIRAD), 1.0);\n    \n    vec2 res2 = vec2(OpU(vec2(SdSphere(pos - vec3(0.0, 1.0, -1.0), 0.6), 2.0),\n                         OpU(vec2(SdSphere(pos - vec3(0.866, 1.0, 0.5), 0.6), 2.0),\n                             vec2(SdSphere(pos - vec3(-0.866, 1.0, 0.5), 0.6), 2.0))));\n    res = OpU(res, vec2(OpS(SdSphere(pos - vec3(0, 1.0, 0), 1.0), \n                             OpU(vec2(SdSphere(pos - vec3(0, 1.0, 0), 0.8), 2.0), \n                                 res2).x), 2.0));\n\n    return res;\n}\n\nvec2 CastRay( vec3 camPos, vec3 rayDir, float nearClip, float farClip )\n{\n    float dis = nearClip;\n    float mat = -1.0;\n    for(int i = 0; i < 50; i++)\n    {\n\t    vec2 res = Map(camPos + rayDir * dis);\n        if(res.x < 0.001) \n            break;\n        \n        dis += res.x;\n        mat = res.y;\n        if(dis >= farClip)\n        {\n            dis = farClip;\n            mat = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(dis, mat);\n}\n\n//---material--------------------------------------------------\nstruct Mat\n{\n    vec3 basCol;\n    vec3 emiCol;\n    float spe;\n};\n\nMat CreateMat( vec3 basCol, vec3 emiCol, float spe )\n{\n    Mat mat;\n    mat.basCol = basCol;\n    mat.emiCol = emiCol;\n    mat.spe = spe;\n    return mat;\n}\n\nMat GetMat( vec3 pos, float matNumber )\n{\n    if(matNumber < 1.5)\n    {\n        return CreateMat(vec3(0.0), vec3(0.9, 0.4, 0.1) * 1.5, 0.001);\n    }\n    else if(matNumber < 2.5)\n    {\n        float n = step(0.3, mod(pos.x, 0.6));\n        return CreateMat(n * vec3(0.2) + vec3(0.0, 0.8, 0.3), vec3(0.0), 0.25);\n    }\n}\n\n//---light--------------------------------------------------\nstruct Light\n{\n    vec3 lightPos;\n    vec3 lightCol;\n    float lightRan;\n    vec3 amb;\n};\n    \nLight CreateLight( vec3 lightPos, vec3 lightCol, float lightRan, vec3 amb )\n{\n    Light light;\n    light.lightPos = lightPos;\n    light.lightCol = lightCol;\n    light.lightRan = lightRan;\n    light.amb = amb;\n    return light;\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy).x - Map(pos - eps.xyy).x,\n                    Map(pos + eps.yxy).x - Map(pos - eps.yxy).x,\n                    Map(pos + eps.yyx).x - Map(pos - eps.yyx).x );\n\treturn normalize(nor); \n}\n\nfloat GetShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float shadow = step(CastRay(ro, rd, mint, maxt).y, 0.0);\n    return shadow;\n}\n\nfloat GetVolumeLight( vec3 camPos, vec3 rayDir, vec3 lightPos, float lightRan, float hit, vec2 screenPos )\n{    \n    float maxDis = min(FAR, hit);\n    float stepDis = (FAR - NEAR) / STEPS;\n    vec3 stepVec = rayDir * stepDis;\n    \n    float noise = texture(iChannel0, screenPos / iChannelResolution[0].xy).r;\n    float dis = NEAR + noise * 0.5;\n    vec3 pos = camPos + rayDir * dis;\n        \n    float sum = 0.0;\n    for(float i = 0.0; i < STEPS; i++)\n    {        \n        vec3 lightVec = lightPos - pos;\n        float lenLightVec = length(lightVec);\n        if(lenLightVec < lightRan)\n        {\n        \tvec3 lightDir = normalize(lightVec);\n            float shadow = GetShadow(pos, lightDir, 0.0, lenLightVec - EMIRAD - 0.03);\n            float atten = max(1.0 - lenLightVec / lightRan, 0.0);\n        \tsum += shadow * atten / STEPS;\n        }\n        \n        dis += stepDis;        \n        if(dis > maxDis)\n        \tbreak;        \n        pos += stepVec;\n    }    \n    \n    return sum;\n}\n\nvec3 Render( vec3 camPos, vec3 rayDir, vec2 screenPos )\n{\n    vec3 movPos = vec3(sin(iTime * CYC), 0.0, cos(iTime * CYC)) * MOVRADA\n        \t\t  + vec3(cos(iTime * CYC * 2.0 + PI * 0.5), 0.0, sin(iTime * CYC * 2.0 + PI * 0.5)) * MOVRADB;\n    Light light = CreateLight(vec3(0, 1.0, 0) + movPos, vec3(0.9, 0.4, 0.1) * 1.5, 4.0, vec3(0.2));\n    \n    vec3 col;    \n    vec3 pos = camPos;\n        \n    vec2 res = CastRay(pos, rayDir, NEAR, FAR);\n    float dis = res.x;\n    float m = res.y;     \n    if(m > 0.0)\n    {\n        pos += rayDir * dis;\n        Mat mat = GetMat(pos, m);\n\n        vec3 viewDir = -rayDir;\n        vec3 lightVec = light.lightPos - pos;\n        vec3 lightDir = normalize(lightVec);\n        float lenLightVec = length(lightVec);\n        \n        vec3 nor = GetNormal(pos);\n        float shadow = GetShadow(pos, lightDir, 0.03, lenLightVec - EMIRAD - 0.03);\n                       \n        float nl = max(dot(nor, lightDir), 0.0);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float nh = max(dot(nor, halfDir), 0.0);\n        \n        float specular = pow(nh, mat.spe * 128.0);\n        \n        float atten = max(1.0 - lenLightVec / light.lightRan, 0.0);\n        \n        col = (mat.basCol + specular) * light.lightCol * nl * shadow * atten \n               + mat.basCol * light.amb\n               + mat.emiCol;\n    }\n    else\n    {\n        col = vec3(0.03);\n    }\n    \n    //---volume light---\n    col += GetVolumeLight(camPos, rayDir, light.lightPos, light.lightRan, dis, screenPos) * light.lightCol * 0.3;\n    \n    //---halo---\n    vec3 ligVec = camPos - light.lightPos;\n    vec3 ligDir = normalize(ligVec);\n    float lenLigVec = length(ligVec);\n    float depthTest = step(CastRay(light.lightPos + EMIRAD * ligDir, ligDir, 0.03, 5.0).y, 0.0);\n    col += pow(max(dot(-rayDir, ligDir), 0.0), 128.0 * lenLigVec) * light.lightCol * depthTest;\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 camPos = vec3(3.0 * cos(7.0 * mouse.x), 1.0 + 3.0 * mouse.y, 3.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);\n    \n    mat3 camMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 rayDir = normalize(camMatrix * vec3(p.xy, 1.5));\n    \n    vec3 col = Render(camPos, rayDir, fragCoord.xy);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2cWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 182, 182, 210], [212, 212, 242, 242, 277], [279, 279, 312, 312, 339], [341, 341, 363, 363, 1099], [1101, 1101, 1174, 1174, 1559], [1561, 1691, 1745, 1745, 1845], [1847, 1847, 1888, 1888, 2164], [2166, 2322, 2399, 2399, 2550], [2552, 2613, 2641, 2641, 2900], [2902, 2902, 2963, 2963, 3045], [3047, 3047, 3155, 3155, 4039], [4041, 4041, 4098, 4098, 5933], [5934, 5994, 6040, 6040, 6216], [6218, 6218, 6275, 6275, 6820]], "test": "untested"}
{"id": "ll2yDc", "name": "oi", "author": "Imsure1200q_1UWE130", "description": "oi", "tags": ["oi"], "likes": 1, "viewed": 360, "published": "Public API", "date": "1510472519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sd(vec3 p)\n{\n    vec3 pos = p;\n    float x;\n    float s1 = length(sqrt(abs(pos)))-0.5;\n    float s2 = length(floor(abs(pos)))+0.3;\n    x = s1*sqrt(sqrt(s2));\n    return x;\n}\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        float shape = sd(p);\n        t += shape * 0.5;\n    }\n    return t;\n}\nmat2 rot(float t)\n{\n    return mat2(-cos(t), sin(t), sin(t), cos(t));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    float X = iMouse.x / iResolution.x;\n    float Y = iMouse.y / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float time = iTime;\n    rd.xz *= mat2(-cos(time+X*2.5+res.x/2.), sin(time+X*2.5+res.x/2.),\n                  sin(time+X*2.5+res.x/2.), cos(time+X*2.5+res.x/2.));\n    //rd.xy *= mat2(cos(time+X+Y), -sin(time+X+Y), sin(time+X+Y), cos(time+X+Y));\n    //rd.yx *= mat2(cos(time+Y+X), sin(time+Y+X), -sin(time+Y+X), cos(time+Y+X));\n    vec3 ro = vec3(-sin(time), 0, -cos(time));\n    float t = trace(ro, rd);\n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(1./t);\n    fragColor = vec4(fc, 1.0) - .5+vec4(0.025,0.025,0.6,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2yDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 179], [180, 180, 211, 211, 371], [372, 372, 391, 391, 443], [444, 444, 501, 501, 1292]], "test": "untested"}
{"id": "llffD7", "name": "Thick Sine Wave (100)", "author": "Assossa", "description": "Leaderboard:\ncoyote - 100\nAssossa - 105\nAssossa - 126", "tags": ["sin", "sine", "small", "golf", "codegolf"], "likes": 2, "viewed": 110, "published": "Public", "date": "1512067171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 100\nvoid mainImage(out vec4 a, vec2 b) {\n\tvec2 r = iResolution.xy,\n    \tu = (b+b-r) / r.y;\n    a += step(.1, abs(sin(u.x + iTime) + asin(u.y)));}\n\n/*\n// 105\n#define mainImage(a,b) \\\n\tvec3 r = iResolution; \\\n    vec2 u = (b+b-r.xy) / r.y; \\\n    a += step(.1, abs(sin(u.x + iTime) + asin(u.y)))\n*/\n\n/*\n// 126\nvoid mainImage( out vec4 a, in vec2 b )\n{\n    vec3 r = iResolution;\n\tvec2 uv = (b+b-r.xy) / r.y;\n\ta += step(0.05, abs(sin(uv.x + iTime) + asin(uv.y)));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llffD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 43, 43, 148]], "test": "untested"}
{"id": "lljcz3", "name": "demo_02 heatbeat", "author": "jzllove9", "description": "从shader女神的博文中找来的shader效果，link：http://blog.csdn.net/candycat1992/article/details/44040273", "tags": ["demo"], "likes": 2, "viewed": 117, "published": "Public", "date": "1509601571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.131593;\nconst float smoothlevel = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //background\n    vec2 p = ( 2. * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    p.y -= 0.25;\n    \n    vec3 bcol = vec3( 1.0, 0.8, 0.7 - 0.07 * p.y ) * ( 1.0 - 0.25 * length(p) );\n           \n    //animate\n    float tt = mod(iTime, 1.5) / 1.5;\n    float ss = pow(tt, 0.2) * 0.5 + 0.5;\n    ss = 1.0 + ss * 0.5 * sin(tt * PI * 2.0 * 3.0 + p.y * 0.5) * exp(-tt * 4.0);\n    p *= vec2(0.5, 1.5) + ss * vec2(0.5, -0.5);\n    \n    //shape\n    float a = atan(p.x, p.y)/PI;\n    float r = length(p);\n    float h = abs(a);\n    float d = ( 13. * h - 22. * h * h + 10. * h * h * h ) / ( 6. - 5. * h ); //通过数学公式进行的形状约束，使其成为桃心的形状\n    \n    //color 变量s用来约束颜色，使其约束在shape内部并且有渐变的效果\n    float s = 1.0 - 0.5 * clamp(r/h, 0.0, 1.0); //本句其实是没用的，因为后面s直接被赋值了\n    s = 1.0 + 0.75 * p.x;\n    s *= 1.0 - 0.25 * r;\n    s = 0.5 + 0.6 * s;\n   \ts *= 0.5 + 0.5 * pow( 1.0 - clamp(r/d, 0.0, 1.0) , 0.1);\n\n    \n    vec3 hcol = vec3(1.0, 0.5 * r, 0.3) * s; \n    vec3 col = mix( bcol, hcol, smoothstep( -smoothlevel , smoothlevel , d - r) );\n     \n\tfragColor = vec4( col,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lljcz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 116, 133, 1322]], "test": "untested"}
{"id": "lllBR7", "name": "\"HelloWorld!!\"", "author": "felipunkerito", "description": "Just learning ", "tags": ["trigonometry"], "likes": 2, "viewed": 460, "published": "Public API", "date": "1511483426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle( vec2 uv, vec2 p, float r, float blur )\n{\n\n\tfloat d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n    \n}\n\nfloat Hash( float h )\n{\n\n    return h = fract(cos(h) * 5422.2465);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float c = 0.0;\n    \n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    float sizer = 1.0;\n    float steper = .1;\n    for(float i = -sizer; i<sizer; i+=steper)\n        for(float j = -sizer; j<sizer; j+=steper){\n    {\t\n        float timer = .5;\n        float resetTimer = 7.0;\n    \t//c = Circle(uv, vec2(0.0,0), sin(iTime*timer), 0.1);\n    \t//c -= Circle(uv, vec2(0.0,0.0), sin(iTime*timer+.2), 0.1);\n        if(c<=1.0){\n    \t\t\n            c += Circle(uv, vec2(i, j),sin(Hash(i))*cos(Hash(j))*(mod(iTime*timer, resetTimer)), sin(Hash(j)));\n        \n        }\n        else if(c>=1.0)\n        {\n            c -= Circle(uv, vec2(i, j),sin(Hash(i))*cos(Hash(j))*(mod(iTime*timer, resetTimer)), sin(Hash(j)));     \n        }\n        }\n    }\n    fragColor = vec4( vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 143], [145, 145, 168, 168, 214], [216, 216, 273, 273, 1101]], "test": "untested"}
{"id": "lllBR8", "name": "3d voronoi car", "author": "flockaroo", "description": "new 3d car distance field texture in shaderoo.org. (here substituted by some dist field primitives)\nsee [url]https://www.shaderoo.org/?shader=oPd8FA[/url]", "tags": ["3d", "voronoi"], "likes": 22, "viewed": 1169, "published": "Public API", "date": "1511031317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// 3d voronoi car\n\n// see https://www.shaderoo.org/?shader=oPd8FA\n// this is a test of the new shaderoo 3d-car-distance-field-texture.\n// (here substituted by some distance field primitives to work in shadetoy)\n\nvec3 getRand3d(vec3 pos)\n{\n    vec4 r1=texelFetch(iChannel1,(ivec2(pos.xy+.5)%ivec2(64)+ivec2(floor(pos.z+.5)*vec2(27,13))+1024)%ivec2(256),0);\n    return r1.xyz;\n}\n\nvec4 voronoiDist(in vec3 texc, float voronoiStrength, float voronoiScale)\n{\n    voronoiStrength=clamp(voronoiStrength,0.,2.);\n\n    vec3 p = texc*voronoiScale;\n    vec2 o;\n    vec3 g = floor(p);\n    p -= g;\n\n    vec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    float mindist = 10.;\n    float mindist2 = 10.;\n    float mindist3 = 10.;\n    float mindist4 = 10.;\n    vec3 minPos=p;\n    vec3 minPos2=p;\n    vec3 minPos3=p;\n    vec3 minPos4=p;\n\n    int sampWidth=max(1,int(floor(voronoiStrength)));\n\n    vec3 pos0 = voronoiStrength*(getRand3d( g ));\n    for(int z = -sampWidth; z <= sampWidth; z++)\n    {\n        for(int y = -sampWidth; y <= sampWidth; y++)\n        {\n            for(int x = -sampWidth; x <= sampWidth; x++)\n            {\n                //vec3 hexOffs = 1.0*vec2(0.5,0.0)*(int(g.y+y)&1);\n                vec3 pos = vec3(x,y,z)+voronoiStrength*getRand3d( g + vec3(x,y,z) );\n                //vec2 pos = hexOffs + vec2(x,y)+voronoiStrength*(getVoronoiOffs((g+vec2(x,y))/voronoiScale/vec2(aspect,1.0))*(1.0-hexOffs));\n                float dist = dot(pos-p, pos-p);\n\n                if(dist<mindist)\n                {\n                    mindist=dist; minPos=pos;\n                }\n            }\n        }\n    }\n    vec3 minhdir=vec3(0.0);\n    float minhdist=0.0;\n    float sum=0.;\n    float softSize=0.05;\n    for(int z = -sampWidth; z <= sampWidth; z++)\n    {\n        for(int y = -sampWidth; y <= sampWidth; y++)\n        {\n            for(int x = -sampWidth; x <= sampWidth; x++)\n            {\n                vec3 pos = vec3(x,y,z)+voronoiStrength*getRand3d( g + vec3(x,y,z) );\n                if(dot(pos-minPos,pos-minPos) > 0.00001)\n                {\n                    float hdist=length(dot(p-(pos+minPos)*0.5,normalize(pos-minPos)))-0.1;\n                    minhdist += exp( -hdist/softSize );\n                }\n            }\n        }\n    }\n    minhdist=-log(minhdist)*softSize/*+0.07*/;\n\n    return vec4(minhdist/voronoiScale,normalize(minhdir));\n}\n\n// smoothed minimum - copied from iq's site (http://iquilezles.org/www/articles/smin/smin.htm)\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (http://iquilezles.org/www/articles/smin/smin.htm)\nfloat maxcomp2(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp2(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n#define WheelRadius 0.45\n#define ObjBoundRadius 3.5\n\nfloat distCar(vec3 pos)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return length(pos)-ObjBoundRadius*0.5;\n    float dist = 100000.0;\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin2(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS((pos-WheelFR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelFL).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    return dist;\n}\n\n\nfloat maxcomp(vec3 v) { return max(max(v.x,v.y),v.z); }\nfloat mincomp(vec3 v) { return min(min(v.x,v.y),v.z); }\n\nvec2 mdist(vec3 pos)\n{\n    float m=1.;\n    vec3 tpos=clamp(pos,-.95,.95);\n    #ifdef SHADEROO\n    float d=texture(iChannel0,tpos*.5+.5).x;\n    #else\n    float d=distCar(tpos*2.5-vec3(0,0,-.3))/2.5;\n    #endif\n    //d+=maxcomp(abs(tpos-pos));\n    /*if (fract(iTime)>0.5)\n        d-=.005;\n    else*/\n        d=abs(d)-.005;\n        \n    d+=length(tpos-pos)*.5;\n    float dp=d;\n    d=max(d,voronoiDist(pos,.5,15.).x);\n    d=min(d,pos.z+.33);\n    if (d<dp) m=2.;\n    return vec2(d,m);\n}\n\nfloat dist(vec3 pos)\n{\n    return mdist(pos).x;\n}\n\n#define PI2 6.2832\n#define LNUM 5\n\nvec3 getGrad(vec3 p)\n{\n    float eps=.01;\n    vec3 d = vec3(eps,0,0);\n    return vec3(\n        dist(p+d.xyz)-dist(p-d.xyz),\n        dist(p+d.zxy)-dist(p-d.zxy),\n        dist(p+d.yzx)-dist(p-d.yzx)\n        )/eps;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec3 refl(vec3 dir)\n{\n    return mix(vec3(.2,.3,.4),vec3(.7,.85,1)*1.5,clamp(dir.z*3.+.5,0.,1.));\n\t//return texture(iChannel0,dir.yzx).zyx*1.2+.1;\n}\n\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float rval=0.0;\n    float R = 1.01;\n    float d0=length(pos);\n\n    // do some bounding check for better performance\n    bool inside = false;\n    // bounding sphere\n    vec3 pn = pos-dir*dot(pos,dir);\n    float d=length(pn);\n    inside = inside || (d<R);\n    inside=true;\n    if(!inside) return 0.0;\n    \n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n       \tfloat d=dist(pos);\n        if(d<eps) { rval=mdist(pos).y; break; }\n        if(d>d0+R) { rval=0.0; break; }\n        pos+=dir*d*1.;\n    }\n    return rval;\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(iChannel1,coord+.003*iTime);\n    c+=texture(iChannel1,coord/2.+.003*iTime)*2.;\n    c+=texture(iChannel1,coord/4.+.003*iTime)*4.;\n    c+=texture(iChannel1,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.33\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec3 colHor=vec3(.5,.55,.6);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*1.3,vec3(.8,.9,1)*1.3,clamp(7.*dir.z,0.,1.));\n    vec3 skyPos=pos+dir/abs(dir.z)*(20.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.001).x-.5));\n    colSky*=mix(1.,cloudPat,step(0.,dir.z));\n    vec3 colFloor=vec3(1.,.95,.9);\n    vec3 colScale=vec3(.0,.3,.5);\n    vec3 floorPos=pos-dir/dir.z*(pos.z-FloorZ);\n    vec2 s;\n    float scale=1.;\n    s=sin(floorPos.xy*PI2*.5*period);\n    scale*=(1.-.3*exp(-s.x*s.x/.01))*(1.-.3*exp(-s.y*s.y/.01));\n    s=sin(floorPos.xy*PI2*.5/10.*period);\n    scale*=(1.-.5*exp(-s.x*s.x/.001))*(1.-.5*exp(-s.y*s.y/.001));\n    colFloor=mix(colFloor,colScale,1.-scale)*(1.+.4*(getRand(floorPos.xy*.001).x-.5));\n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*6.)-.1,0.,1.));\n    return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec3 pos = vec3(0,0,2.5);\n    #ifdef SHADEROO\n \tpos *= 1.-iMouseData.z/1000.;\n    #endif\n \tvec3 dir = normalize(vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x,-1.));\n    vec2 ang=PI2*(iMouse.xy/iResolution.xy*vec2(-1,.3)-vec2(0,.02));\n    if(iMouse.x==0. && iMouse.y==0.) ang = vec2(1.+.3*iTime,1.4);\n    vec4 q = vec4(0,0,0,1);\n    q = multQuat(q,axAng2Quat(vec3(0,0,1),ang.x));\n    q = multQuat(q,axAng2Quat(vec3(1,0,0),ang.y));\n    pos=transformVecByQuat(pos,q);\n   \tdir=transformVecByQuat(dir,q);\n   \tvec3 camDir=transformVecByQuat(vec3(0,0,-1),q);\n   \tvec3 camPos=pos;\n    float m = march(pos,dir);\n    vec3 n = normalize(getGrad(pos));\n    \n    vec3 bg=mix(vec3(1),vec3(.3,.3,1),length(fragCoord.xy-.5*iResolution.xy)/iResolution.x);\n    \n    float fres=abs(dot(dir,n));\n    fres=1.-fres;\n    //fres*=fres;\n    fres=.7+.3*fres;\n    vec3 col=vec3(.75,.8,.85); // material color of car\n    if(int(m+.1)!=1) col=vec3(1);  // set to 1 if bg or floor\n    if(int(m+.1)==1) col*=1.-fres;\n    if(int(m+.1)==1) col+=.9*fres*myenv(pos,reflect(dir,n),10.).xyz;\n    col=.1+col*.9;\n    bg = refl(dir);\n    bg=myenv(pos,dir,10.).xyz;\n    // calc ao by stepping along normal\n    float ao=1.;\n    ao*=.2+.8*dist(pos+n.xyz*.12)/.12;\n    ao*=.4+.6*dist(pos+n.xyz*.25)/.25;\n    ao*=.6+.4*dist(pos+n.xyz*.5)/.5;\n    col*=clamp(ao*.7+.3,0.,1.);\n    \n    float vign = (1.1-.2*dot((fragCoord.xy/iResolution.xy)*2.-1.,(fragCoord.xy/iResolution.xy)*2.-1.));    \n    fragColor.xyz=col;\n    if(int(m+.1)!=1) fragColor.xyz*=bg;\n    fragColor.xyz*=vign;\n    pos=mix(pos,pos+dir*10000.,1.-m);\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[158, 351, 377, 377, 515], [517, 517, 592, 592, 2514], [2516, 2611, 2653, 2653, 2724], [2726, 2822, 2850, 2850, 2881], [2883, 2883, 2928, 2928, 3015], [3017, 3017, 3073, 3073, 3113], [3115, 3115, 3169, 3169, 3251], [3253, 3253, 3298, 3298, 3326], [3529, 3529, 3554, 3611, 4607], [4610, 4610, 4633, 4633, 4665], [4666, 4666, 4689, 4689, 4721], [4723, 4723, 4745, 4745, 5204], [5206, 5206, 5228, 5228, 5255], [5292, 5292, 5314, 5314, 5505], [5507, 5507, 5533, 5618, 5649], [5651, 5651, 5682, 5682, 5773], [5775, 5775, 5818, 5818, 5884], [5886, 5886, 5923, 5923, 5998], [6000, 6000, 6021, 6021, 6148], [6151, 6151, 6190, 6190, 6713], [6715, 6715, 6741, 6741, 6985], [7007, 7007, 7053, 7053, 7913], [7915, 7915, 7972, 7972, 9570]], "test": "untested"}
{"id": "lllBRM", "name": "InterFEAR", "author": "frZ", "description": "interference pattern test", "tags": ["interference", "glitch", "noisy", "graphic"], "likes": 2, "viewed": 2806, "published": "Public API", "date": "1511451454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + 13.1;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.0*atan(t);\n    uv = fract(uv+iTime);\n    vec2 uv2 = fract(uv + t *0.23);\n\tvec4 P = vec4(uv2,0.5+0.5*cos(t),1.0);\n    vec4 O = vec4(uv,0.5+0.5*cos(t),1.0);\n\n    float M = step( (O.r / P.r), abs(sin(t * uv.y)));\n    fragColor.rgb = vec3(M);\n;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 388]], "test": "untested"}
{"id": "lllBWn", "name": "[WST1]Positive Energy in Wroclaw", "author": "Ania", "description": "Positive Energy in Wroclaw  described by Sierpinski triangle.\nIt's my first procjet ;)", "tags": ["sierpinskifractalfirstproject"], "likes": 9, "viewed": 2073, "published": "Public API", "date": "1511657629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Title: \"Wroclaw - my city\", Author: Anna Nowacka\n// This shader is prepared for the first Wroclaw Shader Competition \n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\n\n\n\nfloat length2( in vec2 p ) { return dot(p,p); }\n\nconst vec2 va = vec2(  0.0, 1.73-0.85 );\nconst vec2 vb = vec2(  1.0, 0.00-0.85 );\nconst vec2 vc = vec2( -1.0, 0.00-0.85 );\n//const vec3 vd = vec3( 1.0, 0.0, 0.00-0.85 );\n\n\n    // return distance and address\nvec2 map( vec2 p )\n{\n\tfloat a = 0.0;\n\tvec2 c;\n\tfloat dist, d, t;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\td = length2(p-va);                 c = va; dist=d; t=0.0;\n        d = length2(p-vb); if (d < dist) { c = vb; dist=d; t=1.0; }\n        d = length2(p-vc); if (d < dist) { c = vc; dist=d; t=2.0; }\n\t\tp = c + 2.0*(p - c);\n\t\ta = t + a*2.5;\n\t}\n\t\n\treturn vec2( length(p)/pow(2.0, 7.0), a/pow(3.0,7.0) );\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 2.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n\t\n    \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n    vec2 r = map( uv*cos(0.3*iTime));\n\t\n\tvec3 col = 0.3 + 0.5*sin( 3.1416*r.y +vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n\tcol *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5+0.5*tan(iTime);\n\tfragColor = vec4( col, 1.0 );\n    //vec2 m = vec2(1.5);\n    //float an = 3.2 + 0.5*iTime - 6.2831*(m.x-0.5);\n      \n    if(iTime > 15.0)   \n    {vec3 col = 0.3 + 0.5*sin( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n\tcol *= 1.0 - smoothstep( 0.0, 0.02, r.x +0.50*tan(iTime)-0.5);\n     fragColor = vec4( col, 1.0 );}\n        \n    if(iTime > 31.0)\n    {vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n    vec2 r = map( uv*cos(0.3*iTime));\n\t\n\tvec3 col = 0.5 + 0.5*sin( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n\tcol *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5*sin(iTime);\n\tfragColor = vec4( col, 1.0 );\n    }\n    if(iTime > 51.0)\n    {vec2 uv = (1.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n    vec2 r = map( uv*cos(0.3*iTime));\n\t\n\tvec3 col = 0.5 + 0.5*sin( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n\tcol *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5*(1.00/(cos(iTime)))+1.00;\n\tfragColor = vec4( col, 1.0 );\n    }\n    \n    if (iTime > 74.0)\n    {vec3 col =  1.0 + 0.5*sin( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n     col *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5*(1.00/(cos(iTime)))+1.00;\n\t fragColor = vec4( col, 1.0 );\n     \n        }\n    if (iTime > 89.0)\n    {vec3 col =  1.0 + 0.5*sin( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.4*sin(iTime);\n     col *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5*(1.00/(cos(iTime)))+1.00;\n\t fragColor = floor(vec4( col, 1.0 ));\n    }\n    if (iTime > 100.0)\n    {\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n    vec2 r = map( uv*sin(cos(0.3*iTime)));\n\tvec3 col =  1.0 + 0.5*tan( 3.1416*r.y + vec3(0.0,5.5,5.0) )+0.5*sin(iTime);\n     col *= 1.0 - smoothstep( 0.0, 0.02, r.x )+0.5*tan(iTime)+1.00;\n\t fragColor =(log(vec4( col, 2.0 )));\n    }\n    \n    if (iTime > 120.0)\n    {\n        col = vec3(0.0);\n        fragColor = vec4(col, 1.0);\n    }\n\n}\n\n", "image_inputs": [{"id": "ldSXRh", "previewfilepath": "https://soundcloud.com/aminashkan/kaleo-way-down-we-go#t=0:08", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/aminashkan/kaleo-way-down-we-go#t=0:08", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllBWn.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1301, 1329, 1329, 1348], [1526, 1557, 1577, 1577, 1951], [1953, 1953, 2000, 2000, 2071], [2072, 2072, 2134, 2134, 4230]], "test": "untested"}
{"id": "llsBR4", "name": "lava flow", "author": "laserdog", "description": "some cartoony lava", "tags": ["2d", "noise", "lava"], "likes": 8, "viewed": 696, "published": "Public", "date": "1511216543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// random2 function by Patricio Gonzalez\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 orange = vec3(1., .45, 0.);\n    vec3 yellow = vec3(1., 1., 0.);\n    \n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    uv.y += cos(iTime / 10.) * .1 + iTime / 10.;\n    uv.x *= sin(iTime * 1. + uv.y * 4.) * .1 + .8;\n    uv += noise(uv * 2.25 + iTime / 5.);\n\n    float col = smoothstep(.01,.2, noise(uv * 3.))\n        + smoothstep(.01,.2, noise(uv * 6. + .5))\n        + smoothstep(.01,.3, noise(uv * 7. + .2));\n\n    orange.rg += .3 * sin(uv.y * 4. + iTime / 1.) * sin(uv.x * 5. + iTime / 1.);\n\n    fragColor.rgb = mix(yellow, orange, vec3(smoothstep(0., 1., col)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 63, 63, 202], [204, 286, 308, 308, 714], [716, 716, 773, 773, 1365]], "test": "untested"}
{"id": "llsBRH", "name": "Torus_Thingy_2", "author": "balkhan", "description": "No idea how I got 3 duplicate \"Image\" buffers, shit's crazy !! Seems to be working fine on osx, no access to other machines atm. Also, it's been more than a year since I use this social network. Great community and learning tool, thanks to you all !! ", "tags": ["3d", "torus", "bug", "tentacles"], "likes": 20, "viewed": 395, "published": "Public", "date": "1511154619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t200\n#define E\t\t\t0.001\n#define FAR\t\t\t10.\n\n#define\tFUDGE\n// artifactus disparatus !! (fudge needed cuz of high curvature distorsion)\n#define PHONG\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tbase;\nvec3\th;\nvec3\tvolumetric;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    h *= 0.;\n    volumetric *= 0.;\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2((f.x-.5*iResolution.x)/iResolution.x, (f.y-.5*iResolution.y)/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 25.0-sin(iTime*.125)*25.*0.-21.+2.);\n\n    vec4\tinter = (march(pos, dir));\n\n    if (inter.y == 1.)\n    {\n    \tbase = vec3(.4, .5, .2);\n\t    #ifdef PHONG\n        // substracting a bit from the ray to get a better normal\n\t\tvec3\tv = pos+(inter.w-E*10.)*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(0.0, -100.0, 1000.0);\n\t\tvec3\tlight_color = vec3(1.8, .5, .2);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 10.8 );\n        col.xyz = light_color * (specular) + diffuse * base;\n        float\tdt = 1. - dot(n, normalize(-ev) );\n        col += smoothstep(.0, 1.0, dt)*vec3(.2, .7, .90);\n\t#else\n    \tcol.xyz = 1.*( +vec3(.65, .4, .2)*inter.w * .3-inter.x*.1 * vec3(.3, .2, .15) );\n\t#endif\n    \tcol  -= -.25 + h;\n    }\n    col += volumetric;\n    c_out =  vec4(col, h.x);\n}\n\nfloat\tscene(vec3 p)\n{\n    p.z+=sin(t*1.5)*2.;\n    float\tballs = 1e5;\n    float\tlumos = 1e5;\n\tvec3\tpr;\n\n    vec2\tq;\n    \n    pr = p;\n    \n    rotate(pr.xz , iTime*1.);\n\t\n    /*\n\t* Trying to get an ID for the 4 big toruses and rotating them with it\n\t* Turns out I might need recursivity, I'll try to tackle this problem later\n\t* ID's of not twisted toruses are given by the following\n    q = vec2(length(pr.xy)-2., pr.z);\n    float\tara;\n    ara = \n\t        (( (q.x) > 0. && q.y <= -abs(q.y) ) ?0.70:1.0)\n            *\n\t\t    (( (q.x) > 0. && q.y >= +abs(q.y) ) ?2.70:1.0)\n            *\n\t        (( (q.y) > 0. && q.x <= -abs(q.x) ) ?1.50:1.0)\n            *\n\t        (( (q.y) < 0. && q.x <= -abs(q.x) ) ?4.57:1.0)\n\t        ;\n    rotate(pr.xy, ara+iTime);\n\t*/\n        \n    float\tata = atan(pr.x, pr.y)*1.+0.;\n    \n    q = vec2(length(pr.xy)-2., pr.z);\n    \n    rotate(q.xy, +iTime*2.+ata*3.);\n    \n    q.xy = abs(q.xy)-.25;\n    \n    rotate(q.xy, -iTime*2.+ata*8. );\n    q.xy = abs(q.xy)-.1; // .25 == butterflys\n    rotate(q.xy, +iTime*2.+ata*4. );\n    q.xy = abs(q.xy)-.051;\n    balls = mylength(q)+(-.0305-.011*(abs(ata)-3.00));//sin(6.28*ata+iTime)*1.;\n    p.y -= 2.;\n    rotate(p.xz , iTime*1.);\n    float\tlight = dot(p,p);\n    balls = max(balls, -(light-.65) ); // Cut the extremities\n\n\t#ifdef\tFUDGE\n    balls *= .5;\n    #endif\n    rotate(p.yx, iTime*.5);\n    #ifdef\tFUDGE\n    lumos = length(p.y-18.)-10.1;\n    h += .251/(lumos + 10.1)*vec3(.0,.0,.5);\n    lumos = length(p.y+18.)-10.1;\n    h += .251/(lumos + 10.1)*vec3(.0, .5, .0);\n    balls = min(balls, light);\n    volumetric += .0251/(light+.01)*vec3(.085,.105,.505);\n    #else\n    lumos = length(p.y-18.)-10.1;\n    h += .51/(lumos + 10.1)*vec3(.0,.0,.5);\n    lumos = length(p.y+18.)-10.1;\n    h += .51/(lumos + 10.1)*vec3(.0, .5, .0);\n    balls = min(balls, light);\n    volumetric += .051/(light+.01)*vec3(.085,.105,.505);\n    #endif\n\t\n    return(balls);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*1.;\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsBRH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[174, 494, 537, 537, 1722], [1724, 1724, 1745, 1745, 3634], [3636, 3636, 3668, 3668, 4173], [4175, 4189, 4213, 4213, 4357], [4359, 4359, 4383, 4383, 4521], [4523, 4523, 4563, 4563, 4638], [4640, 4640, 4690, 4690, 4950], [4952, 4952, 4974, 4974, 5180]], "test": "untested"}
{"id": "llsBWn", "name": "[WST1] Hope", "author": "tpalayda", "description": "My first shader made for my faculty :)", "tags": ["wroclaw"], "likes": 3, "viewed": 134, "published": "Public", "date": "1511691515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: \"Hope\", Author: Taras Palayda\n// This shader is prepared for the first Wroclaw Shader Competition\n// Organized by Faculty of Physics and Astronomy, Khronos Chapter \n// and SIggraph Chapter from Wroclaw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0+2.0*q)*vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat rho = sin(iChannelTime[0]/p.x*p.y)*(1.0-length(p)); \n\tfloat ang = atan(p.x,p.y);\n\tfloat shear = rho+iTime; \n\tfloat c = cos(shear), s=sin(shear);\n\n\tfloat r;\n\tr = rho; \n    float dens = exp(c*r);\n\tfloat phase = 10.0*(ang-shear);\n\t\n    ang = sin(phase);\n\tq = r*vec2(cos(ang),sin(ang));\n\t   \n    float spires = 10.0*sin(phase);\n\n    dens /= c+spires;\t\n\t\n\tvec3 col = vec3(dens,dens*p.x*p.x,dens);\n\t\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 213, 270, 270, 810]], "test": "untested"}
{"id": "llsfz7", "name": "rainbow group", "author": "ga354", "description": "rainbow", "tags": ["rainbow"], "likes": 1, "viewed": 438, "published": "Public API", "date": "1511516869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415;\n\n//AA would be nice\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5, 0.);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float theta = atan(uv.y, uv.x);\n    float r = length(uv);\n    float rainbow = floor(r*7.);\n    \n    //thanks fabrice\n    fragColor = vec4(1.)*mod(rainbow+1.,2.); \n    fragColor += vec4(equal(vec4(rainbow),vec4(5.,3.,1., 0.)));\n    \n    //spinning :D\n    theta += iTime/5.*mod(7.-rainbow,7.);\n    \n    //eww I don't like this check :'(, w component will be 1 if not red green or blue -> flip if on the left.\n    if(mod(theta, pi) > pi/2.){\n    \tfragColor = vec4(1.-fragColor.w);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 46, 103, 103, 702]], "test": "untested"}
{"id": "llsfzM", "name": "Trippy Crumblenaut", "author": "bwestlin", "description": "A trippy tunnel effect", "tags": ["tunnel", "sound", "soundcloud"], "likes": 3, "viewed": 265, "published": "Public", "date": "1511480257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Used to have https://soundcloud.com/twistedmusic/younger-brother-crumblenaut but stopped working\n#define M_PI radians(180.0)\n#define t (iTime + 1.0)\n\nvec3 surface(vec2 uv, float size) {\n    float hSize = size / 2.0;\n    float h2Size = hSize / 2.0;\n    float s = size / 20.0;\n    float o = size / (7.0 + 2.0 * sin(t * 3.0));\n    vec2 uv2 = abs(mod(uv, size) - hSize);\n    float c = max(smoothstep(h2Size + o - s, h2Size + o + s, uv2.x),\n                  smoothstep(h2Size + o - s, h2Size + o + s, uv2.y));    \n    float m1 = texture(iChannel0, vec2(mod(uv.x / 100.0, 1.0), 0.)).x + 0.5;\n    float m2 = texture(iChannel0, vec2(0.1, 0.)).x + 0.5;\n    return mix(\n        vec3(1.0, 0.5, 0.0) * m1,\n        vec3(0.9, 0.3 + 0.3 * sin(t * 2.0), 0.1) * m2,\n        c);\n}\n\nfloat wave(vec2 pos) {\n    return (sin(pos.y * 17.0 - t * 2.0) + 1.0) / (2.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.y *= (iResolution.y / iResolution.x);\n       \n    float dy = 5.0 / length(uv);\n    vec2 hit = vec2(\n       dy * sin(t * 0.937), \n       floor(10.0 + 6.0 * sin(t * 0.5)) * -atan(uv.x, uv.y) / M_PI\n    );\n    \n    float m1 = texture(iChannel0, vec2(0.1, 0.)).x;\n    hit.y += (hit.x / (4.0 - (m1 * 3.0))) * sin(t);\n    \n    float fade = min(1.0, 2000.0 / (hit.x * hit.x));\n    \n    hit.x += t * 2.0;\n\n    float m2 = texture(iChannel0, vec2(0.6, 0.)).x + 0.7;\n    fragColor = vec4(fade * surface(hit, 1.0), 1.0);\n    fragColor += vec4(fade * vec3(0.6 + sin(t * 0.6), 1.0, 0.6 + sin(t)) * wave(-hit.yx / 20.0), 1.0) * m2;\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 153, 188, 188, 766], [768, 768, 790, 790, 852], [854, 854, 911, 911, 1594]], "test": "untested"}
{"id": "llXBWn", "name": "Penner's SSS, visual approx.", "author": "iq", "description": "I tried to match Penner's paper on preintegrated SSS, Siggraph 2011. It's a visual approximation, this has nothing that has been done in any numerically meaningful way.", "tags": ["2d", "sss", "subsurface"], "likes": 28, "viewed": 1398, "published": "Public API", "date": "1511571140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// I tried to match Penner's paper on preintegrated SSS, Siggraph 2011. It's a visual approximation, this has nothing\n// that has been done in any numerically meaningful way.\n//\n// See Nevi7's shader here for mroe info: https://www.shadertoy.com/view/4tXBWr\n//\n\n\n// Enable the one bellow to show the LUT\n//#define SHOW_LUT\n\n\n// simpler approximation\n//#define SIMPLE_APPROX\n\n\nvec3 sss( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n\n    return vec3(pndl) + \n#ifndef SIMPLE_APPROX\n           vec3(1.0,0.1,0.01)*0.2*(1.0-pndl)*(1.0-pndl)*pow(1.0-nndl,3.0/(ir+0.001))*clamp(ir-0.04,0.0,1.0);\n#else\n           vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_LUT\n\tvec2 p = fragCoord / iResolution.xy;\n    vec3 col = sss( -1.0+2.0*p.x, p.y );\n#else    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n\tfloat an = 2.0 + 0.5*iTime + 6.2831*iMouse.x/iResolution.x;\n\n\tvec3 ww = vec3(cos(an),0.0,sin(an));\n    vec3 uu = vec3(-ww.z,0.0,ww.x);\n    vec3 vv = vec3(0.0,1.0,0.0);\n    vec3 ro = -2.5*ww;\n    \n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\tvec3 col = vec3(0.0);\n\n\tfloat b = dot( rd, ro );\n\tfloat c = dot( ro, ro ) - 1.0;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tfloat t = -b - sqrt(h);\n\t    vec3 pos = ro + t*rd;\n\t\tvec3 nor = normalize(pos); \n        const float r = 0.5;  // curvature\n\t\tcol = vec3(1.0,0.9,0.8) * sss( dot(nor,vec3(0.57703)), r );\n\t}\n#endif\n    \n\tcol = pow( col, vec3(0.4545) );\n\t\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXBWn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1406, 1457, 1490, 1490, 1816], [1818, 1818, 1875, 1875, 2684]], "test": "untested"}
{"id": "llXfRr", "name": "fractal trees gif", "author": "macbooktall", "description": "the idea is to rotate the fractal based on distance from the camera.\ni used it to make this gif https://media.giphy.com/media/l2QE1mlTRVy7Y7Hfa/giphy.gif", "tags": ["fractal", "raymarch", "cineshader"], "likes": 87, "viewed": 95090, "published": "Public API", "date": "1510763647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXDIST 50.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n  \n// from netgrind\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\n// ------\n\n// by iq\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\n// ------\n\n// from hg_sdf \n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -------\n\n\nfloat fractal(vec3 p)\n{\n    const int iterations = 20;\n\t\n    float d = iTime*5. - p.z;\n   \tp=p.yxz;\n    pR(p.yz, 1.570795);\n    p.x += 6.5;\n\n    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;\n    float scale = 1.25;\n    \n    p.xy /= (1.+d*d*0.0005);\n    \n\tfloat l = 0.;\n\t\n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);\n        \n\t\tpR(p.xy,0.35-d*0.015);\n\t\tpR(p.yz,0.5+d*0.02);\n\t\t\n        l =length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.15;\n}\n\nvec2 map(vec3 pos) \n{\n    float dist = 10.; \n    dist = opU(dist, fractal(pos));\n    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);\n    return vec2(dist, 0.);\n}\n\nvec3 vmarch(Ray ray, float dist)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    vec3 c = hue(vec3(0.,0.,1.),5.5);\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.015;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.15,-r.x);\n        sum += abs(col)*.5;\n    }\n    return sum;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 50;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, 50.);\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    ray.ro = pos;\n   \tcol = vmarch(ray, res.x);\n    \n    col = mix(col, vec3(0.), clamp(res.x/50., 0., 1.));\n   \treturn vec4(col, res.x);\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= uv.x*uv.x*0.15;\n    vec3 camPos = vec3(3., -1.5, iTime*5.);\n    vec3 camDir = camPos+vec3(-1.25,0.1, 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, .8));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    \n\tfragColor = vec4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 80, 115, 115, 1064], [1077, 1087, 1120, 1120, 1145], [1147, 1147, 1187, 1187, 1280], [1282, 1282, 1307, 1307, 1371], [1384, 1401, 1457, 1457, 1499], [1501, 1501, 1533, 1533, 1575], [1577, 1590, 1613, 1613, 2091], [2093, 2093, 2114, 2114, 2265], [2267, 2267, 2301, 2301, 2641], [2643, 2643, 2665, 2665, 3031], [3033, 3033, 3061, 3061, 3328], [3330, 3330, 3353, 3353, 3656], [3658, 3658, 3707, 3707, 3919], [3921, 3921, 3978, 3978, 4462]], "test": "untested"}
{"id": "lt2yRc", "name": "POISON 0", "author": "Nicolas2", "description": "My first project\n\ninspired by http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["liquid"], "likes": 4, "viewed": 215, "published": "Public", "date": "1509617135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(1.9898,78.233)))\n                 * 4443478.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 p){\n    float result = noise(p*vec2(1.0,1.0));\n\tresult += 0.5*noise(p*vec2(3.0,2.0));\n    result += 0.25*noise(p*vec2(-8.0,8.0));\n     result += 0.25*noise(p*vec2(12.0,12.0));\n    \n    return result;\n}\n\n\n float pattern( in vec2 p )\n  {\n      vec2 q = vec2( fbm( p + vec2(iTime/10.0,0.0) ),\n                     fbm( p + vec2(iMouse.x/iResolution.x*5.2,iMouse.x/iResolution.x*5.2) ) );\n\n      vec2 r = vec2( fbm( p + 4.0*q + vec2(iMouse.x/iResolution.x*5.2,iMouse.x/iResolution.x*5.2) ),\n                     fbm( p + 4.0*q + vec2(6.3,2.8) ) );\n\n      return fbm( p + 5.0*r );\n  }\n\n\n\n    \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float p=pattern(fragCoord.xy/1000.);\n    float p2=pattern(fragCoord.xy*vec2(-1,-1)/100.);\n\tfragColor = vec4(p,0.1*(p2+p),pow(p,2.0)/5.0,0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2yRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 146], [148, 148, 174, 174, 693], [695, 695, 716, 716, 914], [918, 918, 948, 948, 1292], [1305, 1305, 1362, 1362, 1514]], "test": "untested"}
{"id": "ltBcRc", "name": "more colorful than average", "author": "ollj", "description": "because\nhttps://www.shadertoy.com/view/XlSczc\nclaimed to be \"more colorful than average\"\ni remembered this one from glslsandbox, which explodes into suprisingly high hue contrasts.", "tags": ["fractal", "rainbow", "esplosion"], "likes": 68, "viewed": 2858, "published": "Public API", "date": "1509498750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define l 120\nvoid mainImage(out vec4 FragColor,vec2 FragCoord){\n\tvec2 v = (FragCoord.xy - iResolution.xy/2.) / min(iResolution.y,iResolution.x) * 30.;\n\tvec2 vv = v;// vec2 vvv = v;\n\tfloat ft = iTime+360.1;\n\tfloat tm = ft*0.1;\n\tfloat tm2 = ft*0.3;\n\tvec2 mspt = (vec2(\n\t\t\tsin(tm)+cos(tm*0.2)+sin(tm*0.5)+cos(tm*-0.4)+sin(tm*1.3),\n\t\t\tcos(tm)+sin(tm*0.1)+cos(tm*0.8)+sin(tm*-1.1)+cos(tm*1.5)\n\t\t\t)+1.0)*0.35; //5x harmonics, scale back to [0,1]\n\tfloat R = 0.0;\n\tfloat RR = 0.0;\n\tfloat RRR = 0.0;\n\tfloat a = (1.-mspt.x)*0.5;\n\tfloat C = cos(tm2*0.03+a*0.01)*1.1;\n\tfloat S = sin(tm2*0.033+a*0.23)*1.1;\n\tfloat C2 = cos(tm2*0.024+a*0.23)*3.1;\n\tfloat S2 = sin(tm2*0.03+a*0.01)*3.3;\n\tvec2 xa=vec2(C, -S);\n\tvec2 ya=vec2(S, C);\n\tvec2 xa2=vec2(C2, -S2);\n\tvec2 ya2=vec2(S2, C2);\n\tvec2 shift = vec2( 0.033, 0.14);\n\tvec2 shift2 = vec2( -0.023, -0.22);\n\tfloat Z = 0.4 + mspt.y*0.3;\n\tfloat m = 0.99+sin(iTime*0.03)*0.003;\n\tfor ( int i = 0; i < l; i++ ){\n\t\tfloat r = dot(v,v);\n\t\tfloat r2 = dot(vv,vv);\n\t\tif ( r > 1.0 )\n\t\t{\n\t\t\tr = (1.0)/r ;\n\t\t\tv.x = v.x * r;\n\t\t\tv.y = v.y * r;\n\t\t}\n\t\tif ( r2 > 1.0 )\n\t\t{\n\t\t\tr2 = (1.0)/r2 ;\n\t\t\tvv.x = vv.x * r2;\n\t\t\tvv.y = vv.y * r2;\n\t\t}\n\t\tR *= m;\n\t\tR += r;\n\t\tR *= m;\n\t\tR += r2;\n\t\tif(i < l-1){\n\t\t\tRR *= m;\n\t\t\tRR += r;\n\t\t\tRR *= m;\n\t\t\tRR += r2;\n\t\t\tif(i < l-2){\n\t\t\t\tRRR *= m;\n\t\t\t\tRRR += r;\n\t\t\t\tRRR *= m;\n\t\t\t\tRRR += r2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tv = vec2( dot(v, xa), dot(v, ya)) * Z + shift;\n\t\tvv = vec2( dot(vv, xa2), dot(vv, ya2)) * Z + shift2;\n\t}\n\t\n\tfloat c = ((mod(R,2.0)>1.0)?1.0-fract(R):fract(R));\n\tfloat cc = ((mod(RR,2.0)>1.0)?1.0-fract(RR):fract(RR));\n\tfloat ccc = ((mod(RRR,2.0)>1.0)?1.0-fract(RRR):fract(RRR));\n\tFragColor = vec4(ccc, cc, c, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBcRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 65, 65, 1656]], "test": "untested"}
{"id": "ltBczc", "name": "Ocean Structure", "author": "dr2", "description": "Abstract construction with fire, smoke, reflections and aurora.\nLook around using mouse; mouse to lower-right corner for daylight view.", "tags": ["raymarch", "water", "smoke", "aurora"], "likes": 88, "viewed": 8407, "published": "Public API", "date": "1509524526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ocean Structure\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define REAL_WAVE 0   // real (=1) or fake (=0, less work) water waves\n#define N_REFL    3   // number of reflections (1-4, 0 = none)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 qHit, sunDir, smkPos;\nfloat dstFar, tCur, smkRadEx, smkRadIn, smkPhs, smkHt, tWav;\nint idObj;\nbool isNite;\nconst int idBase = 1, idPlat = 2, isShel = 3, idFrm = 4, idDway = 5,\n   idTwr = 6, idBrg = 7, idBrCab = 8, idRdw = 9;\nconst float pi = 3.14159;\n\nfloat BridgeDf (vec3 p, float dMin)\n{\n  float cbRad = 0.06;\n  vec3 q, qq;\n  float d, cLen, wRd;\n  wRd = 1.;\n  q = p;  q.x = abs (q.x) - wRd;  q.y -= -0.3;\n  d = PrBoxDf (q, vec3 (0.15, 5., 0.15));\n  q = p;  q.y -= 4.85;\n  d = min (d, PrBoxDf (q, vec3 (wRd + 0.15, 0.15, 0.15)));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBrg; }\n  qq = p;  qq.x = abs (qq.x) - wRd + 0.07;  qq.z = abs (qq.z);\n  q = qq;  q.y -= 4.92;\n  q.yz = Rot2D (q.yz, -0.1 * pi);\n  q.z -= 9.5;\n  d = PrCylDf (q, cbRad, 9.5);\n  q = qq;  q.y -= 4.82;\n  q.yz = Rot2D (q.yz, -0.15 * pi);\n  q.z -= 6.4;\n  d = min (d, PrCylDf (q, cbRad, 6.4));\n  q = qq;  q.y -= 4.77;\n  q.yz = Rot2D (q.yz, -0.26 * pi);\n  q.z -= 4.;\n  d = min (d, PrCylDf (q, cbRad, 4.));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBrCab; }\n  return dMin;\n}\n\nfloat CentStrucDf (vec3 p, float dMin, float ar)\n{\n  float cRad = 6., cLen = 8., ww = 0.03, wThk = 0.05,\n     doorHt = 1.6, doorWd = 1.4;\n  vec3 q;\n  vec2 qo;\n  float d, dd;\n  q = p;  q.y -= -1.05;\n  d = PrCylDf (q.xzy, 8.5, 0.15);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idPlat; }\n  d = PrTorusDf (vec3 (q.xz, abs (abs (q.y - 1.1) - 0.4) - 0.2), 0.03, 8.5);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * ar) + 0.5) / 16.);\n  q.xy -= vec2 (-8.5, 0.9);\n  d = min (d, PrCylDf (q.xzy, 0.05, 0.82));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBrCab; }\n  q = p;\n  qo = Rot2D (q.xz, 2. * pi * (floor (4. * ar) + 0.5) / 4.);\n  q.xz = qo;  q.y -= cLen + 1.2 * doorHt - 9.;\n  dd = PrFlatCylDf (q.yzx, doorHt, doorWd, 0.);\n  q = p;  q.y -= cLen - 9.;\n  d = max (max (max (PrCapsAnDf (q.xzy, cRad, wThk, cLen), - q.y), q.y - 1.635 * cLen), - dd);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = isShel; }\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * ar) + 0.5) / 8.);\n  d = max (max (max (PrCapsAnDf (q.xzy, cRad, 0.2, cLen),\n     min (abs (mod (q.y, 2.) - 1.) - 0.1,\n     dot (vec2 (q.x, abs (q.z)), vec2 (sin (0.04 * 2. * pi / 16.), cos (0.04 * 2. * pi / 16.))))),\n     - q.y), - dd);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idFrm; }\n  q = p;  q.xz = qo;  q.xy -= vec2 (-0.98 * cRad, cLen + 1.2 * doorHt - 9.);\n  d = max (max (max (PrFlatCylDf (q.yzx, doorHt, doorWd, 0.1 * cRad),\n     - PrFlatCylDf (q.yzx, doorHt - ww, doorWd - ww, 0.)),\n     - (q.y + 2. * doorHt - ww - wThk)), - (q.y + 1.2 * doorHt));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idDway; }\n  return dMin;\n}\n\nfloat CornStrucDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a;\n  q = p;  q.y -= -1.2;\n  d = PrCylDf (q.xzy, 3.2, 0.15);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idPlat; }\n  q = p;  q.y -= 1.;\n  d = max (PrCapsAnDf  (q.xzy, 2.5, 0.1, 3.), -2.2 - q.y);\n  q = p;  q.y -= 7.;\n  d = min (d, max (PrCapsDf (q.xzy, 0.7, 2.), -1. - q.y));\n  q = p;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * a + 0.5) / 4.));\n  d = max (d, - PrFlatCylDf (q.yzx, 1.5, 1., 0.));\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a) + 0.5) / 16.);\n  q.y -= 4.3;\n  d = max (d, - (length (max (abs (q.yz) - vec2 (0.6, 0.08), 0.)) - 0.2));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idTwr; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dMin, hs, wRd, ar;\n  dMin = dstFar;\n  hs = 5.;\n  q = p;  q.xz = abs (q.xz) - 4.;\n  d = max (PrSphAnDf (q, 4.85, 0.15), - min (3.9 - q.y, q.y));\n  q.y -= 0.5;\n  d = max (d, 2.2 - min (length (q.yz), length (q.xy)));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBase; }\n  q = p;  q.xz = abs (q.xz) - 20.;\n  d = max (PrSphAnDf (q, 4.85, 0.15), - min (3.9 - q.y, q.y));\n  q.y -= 0.5;\n  d = max (d, 2.2 - min (length (q.yz), length (q.xy)));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBase; }\n  wRd = 1.;\n  q = p;  q.xz = abs (q.xz) - 20.7 + wRd;\n  d = max (max (length (max (q.xz - wRd, 0.)) - 0.3,\n     - (length (max (q.xz + wRd, 0.)) - 0.3)), abs (q.y - hs + 1.) - 0.1);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idRdw; }\n  q = p;\n  ar = (length (p.xz) > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  q.y -= hs;\n  dMin = CentStrucDf (q, dMin, ar);\n  q = p;  q.y -= hs;  q.xz = abs (q.xz) - vec2 (20.);\n  dMin = CornStrucDf (q, dMin);\n  q = p;  q.y -= hs;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * ar + 0.5) / 4.));\n  q.x += 20.;\n  dMin = BridgeDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.3;\n  vn.xz = 0.4 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\n#if REAL_WAVE\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi, f1, f2;\n  dHit = dstFar;\n  f1 = 0.4;\n  f2 = 0.3;\n  s = max (- (ro.y - 1.2 * f1) / rd.y, 0.);\n  sLo = s;\n  for (int j = 0; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - f1 * WaveHt (f2 * p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.3, h) + 0.005 * s;\n    if (s >= dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - f1 * WaveHt (f2 * p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\n#endif\n\nfloat SmokeDens (vec3 p)\n{\n  mat2 rMat;\n  vec3 q, u;\n  float f;\n  f = PrTorusDf (p.xzy, smkRadIn, smkRadEx);\n  if (f < 0.) {\n    q = p.xzy / smkRadEx;\n    u = normalize (vec3 (q.xy, 0.));\n    q -= u;\n    rMat = mat2 (vec2 (u.x, - u.y), u.yx);\n    q.xy = rMat * q.xy;\n    q.xz = Rot2D (q.xz, 2.5 * tCur);\n    q.xy = q.xy * rMat;\n    q += u;\n    q.xy = Rot2D (q.xy, 0.1 * tCur);\n    f = smoothstep (0., smkRadIn, - f) * Fbm3 (10. * q);\n  } else f = 0.;\n  return f;\n}\n\nvec4 SmokeCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec4 col4;\n  vec3 q;\n  float densFac, dens, d, h, sh;\n  d = 0.;\n  for (int j = 0; j < 150; j ++) {\n    q = ro + d * rd;\n    q.xz = abs (q.xz);\n    q -= smkPos;\n    h = PrTorusDf (q.xzy, smkRadIn, smkRadEx);\n    d += h;\n    if (h < 0.001 || d > dstFar) break;\n  }\n  col4 = vec4 (0.);\n  if (d < min (dstObj, dstFar)) {\n    densFac = 1.45 * (1.08 - pow (smkPhs, 1.5));\n    for (int j = 0; j < 150; j ++) {\n      q = ro + d * rd;\n      q.xz = abs (q.xz);\n      q -= smkPos;\n      dens = SmokeDens (q);\n      sh = 0.3 + 0.7 * smoothstep (-0.3, 0.1, dens - SmokeDens (q + 0.1 * sunDir));\n      col4 += densFac * dens * (1. - col4.w) * vec4 (sh * vec3 (0.9) - col4.rgb, 0.3);\n      d += 2.2 * smkRadEx / 150.;\n      if (col4.w > 0.99 || d > dstFar) break;\n    }\n  }\n  if (isNite) col4.rgb *= vec3 (0.3, 0.4, 0.3);\n  return col4;\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col;\n  if (idObj == idBase) col = vec4 (0.3, 0.4, 0.1, 0.1);\n  else if (idObj == idPlat) col = vec4 (0.4, 0.4, 0.3, 0.1);\n  else if (idObj == isShel) col = vec4 (0.5, 0.5, 0.5, 0.3);\n  else if (idObj == idFrm) col = vec4 (0.8, 0.8, 0.9, 0.5);\n  else if (idObj == idDway) col = vec4 (0.7, 0.8, 0.7, 0.3);\n  else if (idObj == idTwr) col = vec4 (0.7, 0.7, 0.6, 0.3);\n  else if (idObj == idBrg) col = vec4 (1., 0.3, 0.3, 0.3);\n  else if (idObj == idBrCab) col = vec4 (0.9, 0.9, 1., 0.5);\n  else if (idObj == idRdw) col = vec4 (0.4, 0.3, 0.3, 0.1);\n  return col;\n}\n\nvec4 AurCol (vec3 ro, vec3 rd)\n{\n  vec4 col, mCol;\n  vec3 p, dp;\n  float ar;\n  dp = rd / rd.y;\n  p = ro + (40. - ro.y) * dp;\n  col = vec4 (0.);\n  mCol = vec4 (0.);\n  tWav = 0.05 * tCur;\n  for (float ns = 0.; ns < 50.; ns ++) {\n    p += dp;\n    ar = 0.05 - clamp (0.06 * WaveHt (0.01 * p.xz), 0., 0.04);\n    mCol = mix (mCol, ar * vec4 (HsvToRgb (vec3 (0.34 + 0.007 * ns, 1., 1. - 0.02 * ns)), 1.), 0.5);\n    col += mCol;\n  }\n  return col;\n}\n\nvec3 NtSkyCol (vec3 rd)\n{\n  vec3 rds;\n  rds = floor (2000. * rd);\n  rds = 0.00015 * rds + 0.1 * Noisefv3 (0.0005 * rds.yzx);\n  for (int j = 0; j < 19; j ++) rds = abs (rds) / dot (rds, rds) - 0.9;\n  return 0.3 * vec3 (1., 1., 0.9) * min (1., 0.5e-3 * pow (min (6., length (rds)), 5.));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float f, a;\n  if (rd.y > 0.) {\n    a = atan (rd.x, - rd.z);\n    if (rd.y < 0.03 * Fbm1 (32. * a) + 0.005)\n       col = (isNite ? vec3 (0.07, 0.1, 0.07) : vec3 (0.4, 0.5, 0.7)) * (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n    else {\n      if (isNite) {\n        vec4 aCol = AurCol (ro, rd);\n        col = (1. - 0.5 * aCol.a) * NtSkyCol (rd) + 0.6 * aCol.rgb;\n      } else {\n        ro.xz += 2. * tCur;\n        col = vec3 (0.2, 0.3, 0.6) + 0.2 * (1. - max (rd.y, 0.)) +\n           0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n        f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.01)));\n        col = mix (col, vec3 (1.), 0.2 + 0.8 * f * rd.y);\n      }\n    }\n  } else {\n    col = vec3 (0.6, 0.5, 0.3);\n    if (- ro.y / rd.y < dstFar) {\n      ro += - (ro.y / rd.y) * rd;\n      col *= 1.1 - 0.2 * Noisefv2 (30. * ro.xz);\n    }\n    col = mix (col, 0.9 * (vec3 (0.4, 0.2, 0.1) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nvec4 GlowCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 gloDir;\n  float gloDist, wGlow, s;\n  wGlow = 0.;\n  for (float j = 0.; j < 4.; j ++) {\n    gloDir = vec3 (20., 9.3, 20.) * (1. - 2. * vec3 (floor (j / 2.), 0., mod (j, 2.))) - ro;\n    gloDist = length (gloDir);\n    s = dot (rd, normalize (gloDir));\n    if (s > 0. && gloDist < dstObj) wGlow += 1. - smoothstep (1., 2., sqrt (1. - s * s) * gloDist);\n  }\n  gloDir = vec3 (0., 15.5, 0.) - ro;\n  gloDist = length (gloDir);\n  s = dot (rd, normalize (gloDir));\n  if (s > 0. && gloDist < dstObj) wGlow += 1. - smoothstep (2., 3., sqrt (1. - s * s) * gloDist);\n  return (0.6 + 0.4 * sin (0.3 * 2. * pi * tCur)) * clamp (wGlow, 0., 1.) * vec4 (1., 0.5, 0.3, 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol, smkCol, smkColR, smkColW, glwCol, glwColR, glwColW;\n  vec3 col, vn;\n  float dstObj, dstWat, reflCol;\n  bool wRefl;\n  col = vec3 (0.2, 0.2, 0.);\n  wRefl = false;\n  dstObj = ObjRay (ro, rd);\n  smkCol = SmokeCol (ro, rd, dstObj);\n  glwCol = GlowCol (ro, rd, dstObj);\n  glwColR = vec4 (0.);\n  glwColW = vec4 (0.);\n  smkColR = vec4 (0.);\n  smkColW = vec4 (0.);\n  tWav = 0.4 * tCur;\n  reflCol = 1.;\n  if (N_REFL >= 2 && dstObj < dstFar && idObj == isShel) {\n    if (length (qHit.xz) > 6. || qHit.y >= 8.8) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n      smkColR = SmokeCol (ro, rd, dstObj);\n      glwColR = GlowCol (ro, rd, dstObj);\n      reflCol *= 0.9;\n    }\n  }\n  if (N_REFL >= 1 && rd.y < 0.) {\n#if REAL_WAVE\n    dstWat = WaveRay (ro, rd);\n#else\n    dstWat = - ro.y / rd.y;\n#endif\n    if (dstWat < min (dstObj, dstFar)) {\n      wRefl = true;\n      ro += dstWat * rd;\n      vn = WaveNf (ro, dstWat);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n      smkColW = SmokeCol (ro, rd, dstObj);\n      glwColW = GlowCol (ro, rd, dstObj);\n      if (N_REFL >= 3 && dstObj < dstFar && idObj == isShel) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        rd = reflect (rd, vn);\n        if (N_REFL == 4) {\n          ro += 0.01 * rd;\n          dstObj = ObjRay (ro, rd);\n        } else {\n          dstObj = dstFar;\n        }\n      }\n      reflCol *= 0.7;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idRdw) vn = VaryNf (5. * qHit, vn, 1.);\n    else if (idObj == idBase) vn = VaryNf (2. * floor (16. * qHit), vn, 2.);\n    objCol = ObjCol (vn);\n    if (isNite) col = objCol.rgb * vec3 (0.3, 0.35, 0.3) * (0.2 + 0.8 * max (0.,vn.y));\n    else col = objCol.rgb * (0.2 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) + \n       objCol.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n  } else if (rd.y > 0.) {\n    col = BgCol (ro, rd);\n  } else {\n#if N_REFL == 0\n    dstWat = - ro.y / rd.y;\n#endif\n    col = BgCol (ro + dstWat * rd, reflect (rd, vec3 (0., 1., 0.)));\n    reflCol = 0.7;\n  }\n  col = clamp (reflCol * col, 0., 1.);\n  col = mix (col, glwCol.rgb, glwCol.a);\n  col = mix (col, glwColR.rgb, glwColR.a);\n  col = mix (col, smkCol.rgb, smkCol.a);\n  col = mix (col, smkColR.rgb, smkColR.a);\n  if (wRefl) {\n    col = mix (col, reflCol * glwColW.rgb, glwColW.a);\n    col = mix (col, reflCol * smkColW.rgb, smkColW.a);\n    col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0., 0.05, 0.05),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), col, 1. - pow (abs (rd.y), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 uv, ori, ca, sa;\n  float el, az;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  smkPhs = mod (0.15 * tCur + 0.3, 1.);\n  smkPos = vec3 (20., 9. + 10. * smkPhs, 20.);\n  smkRadIn = 0.6 * (0.1 + 0.9 * smoothstep (0.01, 0.1, smkPhs));\n  smkRadEx = smkRadIn + 2.5;\n  dstFar = 140.;\n  isNite = true;\n  az = 0.33 * pi;\n  el = -0.016 * pi;\n  if (mPtr.z > 0.) {\n    if (mPtr.x > 0.45 && mPtr.y < -0.45) isNite = false;\n    else {\n      az += pi * mPtr.x;\n      el += 0.05 * pi * mPtr.y;\n    }\n  } else {\n    az += 0.002 * pi * tCur;\n    el += 0.01 * pi * sin (0.01 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 10., -100.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (length (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - length (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (rhi * clamp (p.x / rhi, -1., 1.), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBczc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1076, 1113, 1113, 1877], [1879, 1879, 1929, 1929, 3473], [3475, 3475, 3515, 3515, 4237], [4239, 4239, 4261, 4261, 5375], [5377, 5377, 5410, 5410, 5586], [5588, 5588, 5609, 5609, 5811], [5813, 5813, 5836, 5836, 6359], [6361, 6361, 6392, 6392, 6596], [7272, 7272, 7298, 7298, 7736], [7738, 7738, 7786, 7786, 8612], [8614, 8614, 8636, 8636, 9203], [9205, 9205, 9237, 9237, 9645], [9647, 9647, 9672, 9672, 9934], [9936, 9936, 9967, 9967, 10924], [10926, 10926, 10973, 10973, 11635], [11637, 11637, 11672, 11672, 14369], [14371, 14371, 14427, 14427, 15577], [15579, 15579, 15611, 15611, 15711], [15713, 15713, 15746, 15746, 15773], [15775, 15775, 15819, 15819, 15856], [15858, 15858, 15900, 15900, 15951], [15953, 15953, 15996, 15996, 16069], [16071, 16071, 16125, 16125, 16272], [16274, 16274, 16333, 16333, 16473], [16475, 16475, 16521, 16521, 16578], [16612, 16612, 16636, 16636, 16689], [16691, 16691, 16715, 16715, 16845], [16847, 16847, 16871, 16871, 17091], [17093, 17093, 17118, 17118, 17264], [17266, 17266, 17291, 17291, 17477], [17479, 17479, 17504, 17504, 17729], [17731, 17731, 17753, 17753, 17907], [17909, 17909, 17930, 17930, 18085], [18087, 18087, 18108, 18108, 18263], [18265, 18265, 18294, 18294, 18510], [18512, 18512, 18551, 18551, 18731], [18733, 18733, 18757, 18757, 18893], [18895, 18895, 18925, 18925, 18983]], "test": "untested"}
{"id": "ltfBRn", "name": "MyCircles2.0", "author": "Arseny", "description": "Fixed one", "tags": ["2d"], "likes": 2, "viewed": 383, "published": "Public", "date": "1510739741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat H, W, fr;\nfloat thickness = 0.5;\nfloat a = 0.;\nfloat intensive = 1.25;\nconst int k = 3;\nconst int N = int(pow(3., float(k) + 1.) - 1.) / 2;\nconst int M = int(pow(3., float(k)) - 1.) / 2;\nvec2 fcenter, mainvec;\nfloat multiplier = sqrt(3.) / (2. + sqrt(3.)); // constant which provides tangency of circles\nfloat pi = 4. * atan(-1.);\n\nfloat circle_influence(vec2 center,float r,vec2 uv){\n    float delta = abs(distance(center, uv) - r);\n    return pow(thickness / delta, intensive);\n}\n\n#define _R (0.3089)\n#define _G (0.5670)\n#define to_gray (vec3(_R, _G, 1. - _R - _G))\n\nvec3 from_RGrayB(vec2 RB, float gray){\n    float g = (gray - dot(RB, to_gray.xz)) / to_gray.y;\n    if (g < 0.){\n        g = 0.;\n        RB *= gray / dot(RB, to_gray.xz);\n    }\n    if (g > 1.){\n        g = 1.;\n        RB *= (gray - to_gray.y) / dot(RB, to_gray.xz);\n    }\n    return vec3(RB.x, g, RB.y);\n}\n\nvoid mainImage( out vec4 ans, in vec2 fragCoord )\n{\n    ans = vec4(0, 0, 0, 0);\n    H = iResolution.y;\n    W = iResolution.x;\n\tvec2 uv = fragCoord.xy;\n    fcenter = vec2(W / 2., H / 2.);\n    fr = min(H, W) / 2.1;\n    mainvec = vec2(fr, 0);\n    a = iTime; \n    mainvec = mainvec * rot(a);\n    vec3 queue[N]; // queue of circles (center and radius)\n    int l = 0;\n    queue[0] = vec3(fcenter, fr);\n    int r = 1;\n    ans += circle_influence(fcenter, fr, uv);\n    while (l < M){\n        vec2 nowvec = mainvec;\n        vec2 nowc = vec2(queue[l].x, queue[l].y);\n        for (int j = 0; j < 3; j++){\n            vec2 newc = (fcenter + nowvec) + (nowc - (fcenter + nowvec)) * multiplier;\n            float newr = queue[l].z * multiplier;\n            ans += vec4(1) * circle_influence(newc, newr, uv);\n            queue[r] = vec3(newc.xy, newr);\n            r++;\n            nowvec = nowvec * rot(2. * pi / 3.);\n        }\n        l++;\n    }\n    vec2 RB = vec2(0.3);\n    RB += iMouse.xy / iResolution.xy;\n    RB = fract(RB);\n    ans = vec4(from_RGrayB(RB, ans.x), 1.);\n    /*if (ans.x < 0.1){\n        ans = vec4(from_RGrayB(RB, 0.5), 1.);\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 389, 441, 441, 538], [626, 626, 664, 664, 930], [932, 932, 983, 983, 2071]], "test": "untested"}
{"id": "ltfBWn", "name": "Flowing grid", "author": "CensoredUsername", "description": "First attempt at writing a raymarching shader. Basic shading on a grid field with varied blending parameters.", "tags": ["grid"], "likes": 1, "viewed": 94, "published": "Public", "date": "1511573185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DISTANCE = 1000.;\nconst float SCREEN_DISTANCE = 2.;\nconst int MAX_ITER = 120;\n\nfloat smootherstep(float e0, float e1, float x) {\n    x = clamp((x - e0) / (e1 - e0), 0., 1.);\n    return x * x * x * (x * (x * 6. - 15.) + 10.);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(b-a)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = smootherstep(0., 1., 0.5+0.5*(a - b)/k);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat infcylinder(vec3 p, float r) {\n    return length(p.xy) - r;\n}\n\nfloat infcross(vec3 p, float r) {\n    return smin(infcylinder(p, r), smin(infcylinder(p.yzx, r), infcylinder(p.zxy, r), 1.15), 3.3);\n}\n\nfloat map(vec3 p, out float reduce) {\n    vec3 porig = p;\n    p += iTime * 40.0;\n    vec3 p2 = mod(p + 20., 40.) - 20.;\n\n    \n    float pabs = (porig.x + porig.y + porig.z) / 3.;\n    float a = cos(pabs / 20. * 3.14 - 3.);\n    float f = sign(a) * pow(abs(a), 0.5);\n\n    reduce = 0.75 * (abs(f) * 0.9 + 0.1);\n    return smax(\n        f * sphere(p2 / abs(f), 4.),\n        -f * infcross(p2 / abs(f), 2.7),\n        2.\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenpos = 2. * (fragCoord.xy - iResolution.xy / 2. ) / iResolution.y;\n\n\n    vec3 viewpoint_location = vec3(20.0, 10.0, 0.0);\n\n    float b = iTime / 3.;\n  \tvec3 viewpoint_direction = normalize(1. + 0.5 * vec3(cos(b), cos(b + 2.10), cos(b + 4.20)));\n  \t// create the upwards and sideways components of the reference frame.\n  \tvec3 upwards = vec3(0., 0., 1.);\n  \tvec3 viewpoint_sideways = normalize(cross(viewpoint_direction, upwards));\n  \tvec3 viewpoint_upwards = cross(viewpoint_sideways, viewpoint_direction);\n  \n  \tvec3 ray_relative_start = SCREEN_DISTANCE * viewpoint_direction +\n                              screenpos.x     * viewpoint_sideways  +\n                              screenpos.y     * viewpoint_upwards   ;\n  \n  \t// calculate initial values\n    vec3 o = viewpoint_location;\n  \tvec3 p = vec3(0., 0., 0.);\n  \tvec3 d = normalize(ray_relative_start);\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        float reduce;\n        float r = map(o + p, reduce);\n        \n        float e = (EPSILON * length(p) / SCREEN_DISTANCE);\n        \n        if (r < e) {\n            e = 0.1;\n            vec3 ep = vec3(0.1, 0., 0.);\n            float dr_dx = map(o + p + ep.xyz, reduce) - map(o + p - ep.xyz, reduce);\n            float dr_dy = map(o + p + ep.yxz, reduce) - map(o + p - ep.yxz, reduce);\n            float dr_dz = map(o + p + ep.yzx, reduce) - map(o + p - ep.yzx, reduce);\n            vec3 normal_world = normalize(vec3(dr_dx, dr_dy, dr_dz));\n            \n            vec3 color = vec3(0.3, 0.35, 0.4);\n            \n            for (int i = 0; i < 3; i++) {\n                vec3 lightpos;\n                vec3 lightcolor;\n                if (i == 0) {\n                    lightpos = vec3(40.,  30., 140.); lightcolor = vec3(0.6, 0.7, 0.8);\n                } else if (i == 1) {\n                    lightpos = vec3(40., 150.,  20.); lightcolor = vec3(0.6, 0.7, 0.8);\n                } else {\n                    lightpos = vec3(160., 30.,  20.); lightcolor = vec3(0.6, 0.7, 0.8);\n                }\n                \n                vec3 dir = (o + p) - lightpos;\n                color += lightcolor * max(0.0, -dot(normal_world, normalize(dir))) * pow(120. / length(dir), 1.) * 0.5;\n                \n            }\n            color;\n            fragColor.xyzw = vec4(color * 60. / (length(p) + 25.) + 0.1, 1.);\n            return;\n        }\n        \n        p += d * r * reduce;\n        \n        if (length(p) > MAX_DISTANCE) {\n            break;\n        }\n    }\n    fragColor.xyzw = vec4(0.1, 0.1, 0.1, 1.);\n    return;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 173, 173, 271], [273, 273, 312, 312, 408], [410, 410, 449, 449, 547], [549, 549, 580, 580, 608], [610, 610, 637, 637, 680], [682, 682, 718, 718, 749], [751, 751, 784, 784, 885], [887, 887, 924, 924, 1308], [1310, 1310, 1367, 1367, 3910]], "test": "untested"}
{"id": "ltfBzM", "name": "Nebulous Tunnel", "author": "Shane", "description": "A simple volumetric tunnel winding through a nebulous substrate.", "tags": ["clouds", "volumetric"], "likes": 61, "viewed": 2362, "published": "Public API", "date": "1511533803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tNebulous Tunnel\n\t---------------\n\n    Volumetrically raymarching an organic distance field to produce a tunnel winding\n\tthrough a nebulous substrate... I'm not entirely sure how to describe it, but I\n\tguess it resembles a microbial dust flythough. :) Either way, there's nothing new \n\there - I just thought it'd be fun to make.\t\n\n\tThere are two common ways to apply volumetrics to a distance field: One is to\n\tstep evenly through the field accumulating layer colors at each point. Layers \n\tare assigned a weight according to the distance from the viewer. \n\n\tThe other method is to sphere-trace to the surface, then accumulate color once\n\tthe ray crosses a certain surface distance threshold. The color weighing is \n\tcalculated according to distance from the surface.  \n\n\tThe first method gives an overall gaseous kind of effect. The latter method \n\tdisplays more of the underlying surface and is the one I'm using here. You can \n\talso use hybrids of the two. There's no right or wrong way to do it. It all \n\tdepends on what you're trying to achieve.\n\n\tVolumetric calculations are generally more expensive, due to the number of steps\n\tinvolved, and the need to calculate lighting at each one. In a perfect world, \n\tyou'd calculate normals (numerically, or analytically, if possible), etc, to give \n\tbetter results. Unfortunately, that's expensive, so it's common to use a cheap \n\t(directional derivative) lighting trick to get the job done. If you're interested, \n\tIQ explains it here:\n\n    Directional Derivative - www.iquilezles.org/www/articles/derivative/derivative.htm\n\n\tI've tried to keep the GPU workload down do a dull roar, but that was at the\n\texpense of quality via various detail sacrifices. However, hopefully, it will run \n\tat a reasonal pace on moderate systems. By the way, if you prefer a slighly more \n\tconventional look, uncomment the \"WHITE_FLUFFY_CLOUDS\" and the \"BETWEEN_LAYERS\" \n\tdefine.\n\t\n\t\n\tBased on:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n*/\n\n#define FAR 50.\n\n// More conventional look. Probably more pleasing to the eye, but a vacuum cleaner \n// dust flythrough was the look I was going for. :D\n//#define WHITE_FLUFFY_CLOUDS\n\n// A between cloud layers look. Works better with the white clouds. Needs work, but\n// it's there to give you a different perspective.\n//#define BETWEEN_LAYERS\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    \n    //return texture(iChannel1, p/24., 0.25).x;\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n/*\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n*/\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just a couple of layers are used here.\n    //float n = n3D(p*8. + iTime*.2); // Not great.\n    float n = n3D(p*6. + iTime*.2)*.67 +  n3D(p*12. + iTime*.4)*.33; // Compromise.\n    // Nicer, but I figured too many layers was pushing it. :)\n    //float n = n3D(p*6. + iTime*.2)*.57 +  n3D(p*12. + iTime*.4)*.28 +  n3D(p*24. + iTime*.8)*.15;\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265 + 3.14159265/4.))*.5 + .5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265 + 3.14159265/4.))*.5 + .5;\n    res += (dot(t, vec3(0.333)))*0.7071; \n    \n\t \n\treturn ((res/1.7071))*.85 + n*.15;\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.075)*8., cos(z*.1)*.75); // Windy path.\n    \n}\n\n// Distance function.\nfloat map(vec3 p) {\n    \n    // Cheap and nasty fBm emulation. Two noise layers and a couple of sinusoidal layers.\n    // Sadly, you get what you pay for. :) Having said that, it works fine here.\n    float tn = trigNoise3D(p*.5);\n    \n    // Mapping the tunnel around the path.\n    p.xy -= path(p.z);\n    \n    #ifndef BETWEEN_LAYERS\n    // Smoothly carve out the windy tunnel path from the nebulous substrate.\n    return smax(tn - .025, -length(p.xy) + .25, 2.);\n    #else\n    // Between cloud layers... I guess. The \"trigNoise3D\" function above would have\n    // to be reworked to look more like clouds, but it gives you a rough idea.\n    return smax(tn - .05, -abs(p.y - sign(p.y)*(tn - .5)) + .125, 2.);\n    #endif\n\n\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 fNorm(in vec3 p){\n\n    // Note the large sampling distance.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n// Less accurate 4 tap (3 extra taps, in this case) normal calculation. Good enough for this example.\nvec3 fNorm(in vec3 p, float d){\n    \n    // Note the large sampling distance.\n    vec2 e = vec2(.01, 0); \n\n    // Return the normal.\n    return normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy), d - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \t\n    \t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.75; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.15));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/16.);\n    \n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Anyway, the hash below is used to\n    // at jitter to the jump off point (ray origin).\n    //    \n    // It's also used for some color based jittering inside the loop.\n    vec3 rnd = hash33(rd.yzx + fract(iTime));\n\n    // Local density, total density, and weighting factor.\n    float lDen = 0., td = 0., w = 0.;\n\n    // Closest surface distance, a second sample distance variable, and total ray distance \n    // travelled. Note the comparitively large jitter offset. Unfortunately, due to cost \n    // cutting (64 largish steps, it was  necessary to get rid of banding.\n    float d = 1., d2 = 0., t = dot(rnd, vec3(.333));\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n    \n    // Directional light. Don't quote me on it, but I think directional derivative lighting\n    // only works with unidirectional light... Thankfully, the light source is the cun which \n    // tends to be unidirectional anyway.\n    vec3 ld = normalize(vec3(-.2, .3, .4));\n    \n    // Using the light position to produce a blueish sky and sun. Pretty standard.\n    vec3 sky = vec3(.6, .8, 1.)*min((1.5+rd.y*.5)/2., 1.); \t\n    sky = mix(vec3(1, 1, .9), vec3(.31, .42, .53), rd.y*0.5 + 0.5);\n    //sky = mix(vec3(1, .8, .7), vec3(.31, .52, .73), rd.y*0.5 + 0.5);\n    \n    \n    // Sun position in the sky - Note that the sun has been cheated down a little lower for \n    // aesthetic purposes. All this is fake anyway.\n    float sun = clamp(dot(normalize(vec3(-.2, .3, .4*4.)), rd), 0.0, 1.0);\n    \n    \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 16.)*.35; \n\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n        \n        // Loop break conditions - If the ray hits the surface, the accumulated density maxes out,\n        // or if the total ray distance goes beyong the maximum, break.\n        if(d<.001*(1. + t*.125) || td>1. || t>FAR) break;\n\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        // On a side note, you could wrap the next few lines in an \"if\" statement to save a\n        // few extra \"map\" calls, etc. However, some cards hate branching, nesting, etc, so it\n        // could be a case of diminishing returns... Not sure what the right call is, so I'll \n        // leave it to the experts. :)\n        w = d<h? (1. - td)*(h - d) : 0.;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        //td += w*w*8. + 1./60.; // More transparent looking... kind of.\n        td += w + 1./64.; // Looks cleaner, but a little washed out.\n\n        \n       \n        // Lighting calculations.\n        // Standard diffuse calculation using a cheap 4 tap normal. \"d\" is passed in, so that means \n        // only 3 extra taps. It's more expensive than 2 tap (1 extra tap) directional derivative\n        // lighting. However, it will work with point light, and enables better lighting.\n        //float diff = max(dot(ld, fNorm(sp, d)), 0.);\n        \n        // Directional derivative-based diffuse calculation. Uses only two function taps,\n        // but only works with unidirectional light. By the way, the \"1 + t*.125\" is a fake\n        // tweak to hightlight further down the tunnel, but it doesn't belong there. :)\n        d2 = map(sp + ld*.02*(1. + t*.125));\n        // Possibly quicker than the line above, but I feel it overcomplicates things... Maybe. \n        //d2 = d<h? map(sp + ld*.02*(1. + t*.125)) : d;\n        float diff = max(d2 - d, 0.)*50.*(1. + t*.125);\n        //float diff = max(d2*d2 - d*d, 0.)*100.; // Slightly softer diffuse effect.\n        \n\n\n        // Accumulating the color. You can do this any way you like.\n        //\n        #ifdef WHITE_FLUFFY_CLOUDS\n        // I wanted dust, but here's something fluffier - The effects you can create are endless.\n        col += w*d*(diff*vec3(1, .85, .7) + 2.5)*1.25;\n        // Other variations - Tweak them to suit your needs.\n        //col += w*d*(sqrt(diff)*vec3(1, .85, .7)*2. + 3.);\n        //col += w*d*((1.-exp(-diff*8.))*vec3(1, .85, .7)*1.5 + 2.5);\n        \n        \n        #else\n        col += w*d*(.5 + diff*vec3(1, .8, .6)*4.);\n        #endif\n        \n        // Optional extra: Color-based jittering. Roughens up the clouds that hit the camera lens.\n        col *= .98 + fract(rnd*289. + t*41.13)*.04;\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t += max(d*.5, .05); //\n        //t += 0.25; // t += d*.5;// These also work - It depends what you're trying to achieve.\n\n    }\n    \n    col = max(col, 0.);\n    \n    \n    #ifndef WHITE_FLUFFY_CLOUDS\n    // Adding a bit of a firey tinge to the volumetric substance.\n    col = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.2 + .8);\n    #endif\n \n    \n    \n    // Fogging out the volumetric substance. The fog blend is heavier than usual. It was a style\n    // choice - Not sure if was the right one though. :)\n    col = mix(col, sky, smoothstep(0., .55, t/FAR));\n \tcol += vec3(1, .4, .05)*pow(sun, 16.)*.25; \t\n    \n    // Tweaking the contrast.\n    col = pow(col, vec3(1.5));\n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .25)*.35 + .65;\n    // Colored varation.\n    //col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16)), col, \n              //pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5);\n \n    // Done.\n    fragColor = vec4(sqrt(min(col, 1.)), 1.0);\n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2464, 2652, 2672, 2672, 2730], [2732, 2893, 2913, 2913, 3017], [3020, 3366, 3389, 3442, 3610], [6037, 6185, 6214, 6214, 7306], [7310, 7359, 7397, 7397, 7492], [7494, 7594, 7616, 7658, 7728], [7730, 7752, 7771, 7947, 8473], [8777, 8879, 8910, 8956, 9101], [9103, 9103, 9159, 9192, 16772]], "test": "untested"}
{"id": "ltjcDV", "name": "PAD Tutorial 09", "author": "dpadrial", "description": "a", "tags": ["tutorial"], "likes": 1, "viewed": 119, "published": "Public", "date": "1510216338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // 画面上の座標を求める.\n    // iTimeは、現在の時間経過に関する値で時間経過で変化するようなアニメーション表現に利用する.\n    // この例では、iTimeをsin関数に与えることで周期的な色の変化を行なっている。\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);\n    \n    // 画面上の座標値を-1.0から\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    color *= abs(1.0 / (sin(pos.x + cos(pos.y + iTime) * 0.5) * sin(iTime * .3) * 70.0));\n    color *= abs(1.0 / (sin(pos.y + cos(pos.x + iTime) * 0.2) * sin(iTime * .3) * 70.0));\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 350, 741]], "test": "untested"}
{"id": "ltlBDN", "name": "Moss in a Cup", "author": "zackpudil", "description": "I don't know how to name things.", "tags": ["2d", "fractal", "glass"], "likes": 9, "viewed": 204, "published": "Public", "date": "1511972355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float x) {\n    return fract(sin(x*343.234334)*393873.3433);\n}\n\nfloat noise(vec2 x) {\n    vec2 f = floor(x);\n    vec2 g = fract(x);\n    \n    float n = f.x + 57.0*f.y;\n    \n    return mix(\n        mix(hash(n), hash(n + 1.0), g.x),\n        mix(hash(n + 57.0), hash(n + 58.0), g.x),\n        g.y);\n}\n\nvec2 rot(vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c)*p;\n}\n\nfloat de(vec2 a) {\n\tvec3 p = vec3(a, 1);\n\t\n\tp.xy += vec2(iTime, 4.0*sin(0.25*iTime));\n    float d = 2.0*noise(p.xy);\n    vec2 c = floor(p.xy + 1.0)/2.0;\n    \n\tp.xy = mod(p.xy + 1.0, 2.0) - 1.0;\n\tp.xy -= 1.0;\n    \n    // ABS box fractal\n\tfor(int i = 0; i < 3; i++) {\n\t\tp.xy = abs(p.xy + 1.0) - 1.0;\n\t\tp /= clamp(dot(p.xy, p.xy), 0.4, 1.0);\n        \n        p.xy = rot(p.xy, 1.2*d);\n\t\tp *= 1.4;\n\t}\n\t\n\treturn (length(p.xz) - 0.26)/p.z;\n}\n\nvec3 bump(vec2 p) {\n\tvec2 h = vec2(0.02, 0.0);\n\treturn normalize(vec3(\n\t\tde(p + h.xy) - de(p - h.xy),\n\t\tde(p + h.yx) - de(p - h.yx),\n\t\t-0.03));\n}\n\nvec3 render(vec2 p) {\n\tvec3 rd = normalize(vec3(p, 1));\n\tvec3 sn = bump(p);\n\t\n\tvec3 re = reflect(rd, sn);\n\t\n    // just need a specular light\n\treturn vec3(pow(clamp(dot(re, sn), 0.0, 1.0), 15.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec2 q = p;\n    \n    // pillar like deformation\n    p.x *= 1.0 + 0.8*smoothstep(0.8, 4.0, abs(p.x));\n\t\n\tfloat d = de(p);\n\t\n    // light * material.\n\tvec3 col = render(p)\n\t\t*mix(vec3(1), vec3(0.4, 0.8, 2.0), smoothstep(0.97, 1.0, d))\n\t\t*mix(vec3(1.8, 0.6, 0.3), vec3(1), smoothstep(0.97, 1.0, d));\n    \n    // moss like emission.\n    col += texture(iChannel0, 2.0*(p - 0.1*bump(p).xy) + vec2(iTime, 4.0*sin(0.25*iTime))).xyz\n        *vec3(0.5, 2.0, 0.4)*smoothstep(0.99, 1.1, d*d);\n\t\n    // darken edges.\n    col *= 1.0 - smoothstep(0.1, 2.0, abs(q.x));\n    \n    // tone mapping and gamma correction.\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 72], [74, 74, 95, 95, 305], [307, 307, 334, 334, 417], [419, 419, 437, 437, 853], [855, 855, 874, 874, 1000], [1002, 1002, 1023, 1023, 1200], [1202, 1202, 1259, 1259, 2016]], "test": "untested"}
{"id": "ltlfD4", "name": "Unsigned distance to hyperbola2", "author": "mv", "description": "Based on https://www.shadertoy.com/view/XllfWH, but extended to arbitrary hyperbola by a coordinate transformation.\n\nOne foci is controlled by the mouse cursor.\n\nOnly guaranteed to work as long as the circles do not overlap.", "tags": ["distance", "hyperbola", "arbitrary", "unsigned"], "likes": 0, "viewed": 440, "published": "Public API", "date": "1511952150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Extension of https://www.shadertoy.com/view/XllfWH\n//\n// An arbitrary hyperbola placed halfway between two circles\n// is drawn by approximating the (unsigned) distance using\n// a typical Newton-Rhapson iteration scheme. \n//\n//\n// We first translate the coordinates such that the midpoint\n// between the two foci becomes the new origin,\n// then we rotate it so that the two foci lies along the x-axis,\n// and finally we scale such that the foci lies at (±1, 0)\n//\n\nfloat dist_circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nvec3 dist_hyperbola(vec2 p, float a, float c)\n{\n\n    float a2 = a*a;\n    float c2 = c*c;\n    float b2 = c2 - a2;\n    float b = sqrt(b2);\n    \n    float A = a*p.x/(a2 + b2);\n    float B = b*p.y/(a2 + b2);\n    \n    float t = 0.0;\n    \n    int i;\n    for (i = 0; i < 1000;i++) {\n        float ch = cosh(t);\n        float sh = sinh(t);\n        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);\n        t = t - dt;\n        if (abs(dt) < 1.0e-3) break;\n    }\n    \n    vec2 P = vec2(a*cosh(t), b*sinh(t));\n    \n    return vec3(length(P - p), float(i), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(2.0*fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n\t// time dependent radii\n    float r1 = 0.5 + 0.4*cos(iTime);\n    float r2 = 0.5 - 0.4*cos(2.0*iTime);\n    \n    // positions, one on the mouse cursor\n    vec2 p2 = 2.0*(2.0*iMouse.xy - iResolution.xy) / iResolution.yy;\n    vec2 p1 = vec2(-1.0, -1.0);\n\t//vec2 p1 = -p2;\n\t//vec2 p1 = vec2(0.0, 0.0);\n    \n\n    // half-distance between points\n    float D = length(p2 - p1)/2.0;\n    \n    // distance to circles based on original coordinates,\n    // but scaled\n    float d1 = dist_circle(uv - p1, r1)/D;\n    float d2 = dist_circle(uv - p2, r2)/D;\n    \n    /*\n\t// midpoint\n    vec2 M = (p1 + p2)/2.0;\n    \n    // cosine and sine of angle with horizontal\n    vec2 cs = (p2-p1)/(2.0*D);\n\n    // translation matrix\n    mat3 T = mat3(vec3( 1.0,  0.0, 0.0),\n                  vec3( 0.0,  1.0, 0.0),\n                  vec3(-M.x, -M.y, 1.0));\n                  \n    // rotation matrix\n\tmat3 R = mat3(vec3(cs.x, -cs.y, 0.0), \n                  vec3(cs.y,  cs.x, 0.0),\n                  vec3(0.0,   0.0,  1.0));\n    \n    // scale matrix\n    mat3 S = mat3(vec3(1.0/D, 0.0,   0.0),\n                  vec3(0.0,   1.0/D, 0.0),\n                  vec3(0.0,   0.0,   1.0));\n    \n    // The composited matrix is:\n    //\n    //         |  c/D  s/D  -Mx*c/D - My*s/D |\n    // S*R*T = | -s/D  c/D   Mx*s/D - My*c/D |\n    //         |   0    0           1       |\n    //\n    // where c = cos(angle), s = sin(angle)\n    //\n    // which boils down to\n    //\n    //       1  | x2-x1  y2-y1  0.5*((x1+x2)*(x1-x2) + (y1+y2)*(y2-y1))\n    //      --- | y1-y2  x2-x1  0.5*((x1+x2)*(y2-y1) + (y1+y2)*(x1-x2))\n    //      D^2 |   0      0                         1\n    //\n    // composited matrix\n    mat3 SRT = S*R*T;\n\n    // transform coordinates such that the hyperbola is \n    // in canonical form\n    uv = (SRT*vec3(uv, 1.0)).xy;\n    */\n    \n    // optimized version of the above\n    vec2 q1 = vec2(-p1.y, p1.x);\n    vec2 q2 = vec2(-p2.y, p2.x);\n\n    uv = vec2(dot(p2-p1, uv) - 0.5*dot(p1+p2, p2-p1), \n              dot(q2-q1, uv) - 0.5*dot(p1+p2, q2-q1))/D/D/2.0;\n    \n    // line thickness and smoothing width\n    float t = 1.0*fwidth(uv.x); \n    float w = 1.0*fwidth(uv.x);\n    \n    // vertex position\n    float a = (r1 - r2)/2.0/D;\n    \n    // same as before\n    \n    // get distance, iterations and parameter of closest point\n    vec3 res = dist_hyperbola(uv, a, 1.0);\n    float d3 = res.x;\n    float iter = res.y;\n    //float t_min = res.z;\n\t\n    float s1 = smoothstep(w/2.0, -w/2.0, abs(d1) - t);\n    float s2 = smoothstep(w/2.0, -w/2.0, abs(d2) - t);\n    float s3 = smoothstep(w/2.0, -w/2.0, abs(d3) - t);\n    \n    vec3 bgColor = vec3(0.5 + 0.5*cos(iter));\n    vec3 circleColor = vec3(0.0, 0.0, 1.0);\n    vec3 hyperbolaColor = vec3(0.0, 1.0, 0.0);\n    \n    vec3 col = bgColor;\n    col = col*(1.0 - s1) + circleColor*s1;\n    col = col*(1.0 - s2) + circleColor*s2;\n    col = col*(1.0 - s3) + hyperbolaColor*s3;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 471, 507, 507, 532], [534, 534, 581, 581, 1114], [1116, 1116, 1173, 1173, 4171]], "test": "untested"}
{"id": "ltlfRM", "name": "Flicky", "author": "frZ", "description": "flickering patterns", "tags": ["simple", "trigonometry", "graphic", "flick"], "likes": 1, "viewed": 2897, "published": "Public API", "date": "1511455690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 0.51;\n    float t = iTime*0.25 + 1.0;\n    float s = mod(fract(uv.x * 3.+uv.x+t),0.05)*sin(t*10.)*100.;\n    float r = tan( cos(uv.y+t)*100.);\n    float m = tan(sin(uv.y + t*.3)*100.);\n    \n\tfragColor = vec4(vec3(m/r*s),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 335]], "test": "untested"}
{"id": "ltlfRN", "name": "Torus_Thingy_3", "author": "balkhan", "description": "An happy accident.", "tags": ["3d", "torus", "tentacles"], "likes": 6, "viewed": 182, "published": "Public", "date": "1511250922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t200\n#define E\t\t\t0.001\n#define FAR\t\t\t10.\n\n#define\tFUDGE\n// artifactus disparatus !! (fudge needed cuz of high curvature distorsion)\n#define PHONG\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tbase;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2((f.x-.5*iResolution.x)/iResolution.x, (f.y-.5*iResolution.y)/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-.0, .0, 6.);\n\n    vec4\tinter = (march(pos, dir));\n\n    if (inter.y == 1.)\n    {\n    \tbase = vec3(.7, .8, .9);\n\t    #ifdef PHONG\n        // substracting a bit from the ray to get a better normal\n\t\tvec3\tv = pos+(inter.w-E*50.)*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(0.0, 10.0, 100.0);\n\t\tvec3\tlight_color = vec3(1., .5, .2)*1.+0.;\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 10.8 );\n        col.xyz = light_color * (specular) + diffuse * base;\n\t#else\n    \tcol.xyz = 1.*( +vec3(.65, .4, .2)*inter.w * .3-inter.x*.1 * vec3(.3, .2, .15) );\n\t#endif\n    }\n\tc_out =  vec4(col, 1.);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tballs = 1e5;\n    float\tlumos = 1e5;\n\tvec3\tpr;\n\n    vec2\tq;\n    \n    pr = p;\n    \n    rotate(pr.xz , iTime*1.);\n\n    q = vec2(length(pr.xy)-2., pr.z);\n\n    rotate(q.xy, +iTime*.5+atan(pr.x, pr.y)*6. );\n    q.xy = abs(q.xy)-.25;\n    rotate(q.xy, -iTime*.5+atan(pr.x, pr.y)*.75 );\n    q.xy = abs(q.xy)-.19; // .25 == butterflys\n\n    balls = mylength(q.xy)-.025;//mylength(q)-.02305;\n    \n    balls = max(balls, max((length(vec2(length(pr.xy)-2., pr.z))-.3), (length(vec2(length(pr.xy)-2., pr.z))-.7)) );\n\n\t#ifdef\tFUDGE\n    balls *= .5;\n    #endif\n\t\n    return(balls);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x*1.;\n        // log trick by aiekick\n        if (log(dist.y*dist.y/dist.x/1e5)>0. || dist.x < E || dist.y >= FAR)\n        {\n            if (dist.x < E)\n\t            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y;\n    return (step);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y + p.z;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n    \n    p = p*p;\n    p = p*p;\n    p = p*p;\n    \n    ret = p.x + p.y;\n    ret = pow(ret, 1./8.);\n    \n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[174, 469, 512, 512, 1475], [1477, 1477, 1498, 1498, 2075], [2077, 2077, 2109, 2109, 2614], [2616, 2630, 2654, 2654, 2798], [2800, 2800, 2824, 2824, 2962], [2964, 2964, 3004, 3004, 3079], [3081, 3081, 3131, 3131, 3391], [3393, 3393, 3415, 3415, 3621]], "test": "untested"}
{"id": "ltlfz8", "name": "Identity", "author": "MaciejRayMarcin", "description": "My first shader that I wrote from scratch.\n\nMusic: arikuyo - Identity", "tags": ["visualizer"], "likes": 1, "viewed": 464, "published": "Public API", "date": "1511045916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BARCOUNT_INT 32\n#define BARCOUNT 32.0\n\n\nvec3 visualizerBar(sampler2D audio, vec2 uv, int barIndex)\n{\n    float intensity = texture(iChannel0, vec2(float(barIndex)/BARCOUNT , 0.1)).x;\n    if(uv.y > 0.0 && uv.y < (abs(intensity) - abs((uv.x) - (float(barIndex) + sin(iTime)*sin(iTime))/BARCOUNT ) ))\n        return mix(vec3(0.0,0.0,0.0), vec3(1.0-uv.x, 0.1, 0.6 + (uv.x - (float(barIndex)/BARCOUNT ))/(1.0/BARCOUNT )*0.4), 0.25+0.5*uv.y);\n    return vec3(uv.y-abs(intensity), 0.0, uv.y-abs(intensity)*0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.9+0.1*sin(iTime),0.6+0.4*sin(iTime*0.67));\n    vec4 outputC = vec4(0.0,0.0,0.0,0.0);\n    for(int i = 0; i < BARCOUNT_INT; i++)\n    {\n        if(uv.x < ((float(i)+2.0)/BARCOUNT ) && uv.x > (float(i)/BARCOUNT ))\n            outputC = mix(fragColor, vec4(visualizerBar(iChannel0, uv, i), 1.0), 1.0-(0.4*uv.x));\n    }\n    fragColor = mix(fragColor, outputC, 0.5);\n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 0.0), 0.2*texture(iChannel0, (vec2(0.35, 0.1)+vec2(0.15, 0.1))/2.0).x);\n}", "image_inputs": [{"id": "MdjXRR", "previewfilepath": "http://soundcloud.com/arikuyo/identity", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "http://soundcloud.com/arikuyo/identity", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 108, 108, 514], [516, 516, 573, 573, 1123]], "test": "untested"}
{"id": "ltsfz4", "name": "Ad Infinitum", "author": "uditmahajan", "description": "Ad Infinitum by Udit Mahajan", "tags": ["glsl"], "likes": 0, "viewed": 419, "published": "Public API", "date": "1511232271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 uv){\n    uv = vec2( dot(uv,vec2(127.1,311.7)),\n              dot(uv,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(uv)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *=.5;\n    uv.x += iTime*0.002;\n    vec3 color = vec3(0.0);\n\n    float t = 1.0;\n    t = abs(1.0-(0.5*sin((iTime/100.))))*1.;\n    uv += noise(uv*2.)*t;\n    \n    color += smoothstep(.15,.26,noise(uv*8.))+vec3(0.,.6,0.4); \n\n    color += vec3(1.3) * smoothstep(.01,1.,noise(uv));\n    \n    \n    color += smoothstep(.1,.11,noise(uv*20.))+vec3(0.9,0.2,0.0);\n    color -= smoothstep(.15,.4,noise(uv*10.));\n\n    color /= vec3(noise(uv*100.), noise(uv*150.), noise(uv*200.));\n\n    fragColor = vec4(color-vec3(0.,1.,1.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 245, 267, 267, 673], [675, 675, 732, 732, 1301]], "test": "untested"}
{"id": "ltsfz8", "name": "Julia_waterEffect", "author": "juliaupdegraff", "description": "Image distortion", "tags": ["fx"], "likes": 7, "viewed": 271, "published": "Public", "date": "1511047560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\t\n\tposition.x = position.x * 1.7;\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tmouse.x = mouse.x * 1.7;\n\t\n\tfloat radius = 0.5*iTime;\n\t\n\tfloat posDist = distance(position, mouse);\n\t\n\tfloat dist2 = 5.0*abs(radius - posDist);\n\t\n\tfloat distort = 2.5-(sin(dist2)+1.0)/2.0;\n    \n    vec2 samplePos = fragCoord/iResolution.y;\n    \n    samplePos= samplePos * distort;\n    \n    vec4 color = texture(iChannel0, samplePos);\n    \n    vec4 tint = vec4(0.9, 0.9, 0.5, 1);\n    \n    tint = tint * (1.9 - distort);\n    \n    color = color + tint/2.0;\n       \n\tfragColor = color;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 677]], "test": "untested"}
{"id": "ltsfzN", "name": "Truncated Icosahedron", "author": "marian42", "description": "Truncated Icosahedron, aka soccer polyhedron or buckyball", "tags": ["3d", "geometry", "buckyball"], "likes": 20, "viewed": 617, "published": "Public API", "date": "1511629139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float focalLength = 4.0;\nconst float cameraDistance = 5.0;\nconst vec3 lightDir = vec3(-0.7, 0.7, -0.14);\n\nvec3 getNormal(int i) {\n\tint block = i / 4;\n    vec3 signs = sign(vec3(i & ivec3(4, 2, 1)) - 0.1);\n    \n    if (block > 5) {\n        return 0.5774 * signs;\n    }\n    \n    vec3 r = signs * (block < 3 ? vec3(0.0, 0.5257, 0.8507) : vec3(0.0, 0.9342, 0.3568));\n    return vec3(r[block % 3], r[(block + 2) % 3], r[(block + 1) % 3]);    \n}\n\nmat2 getRotationMatrix(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat fragment(vec3 L, vec3 N, vec3 V) {\n\tfloat ambient = 0.1;\n\tfloat diffuse = 0.5 + 0.5 * dot(L, N);\n\tvec3 R = reflect(-L, N);\n\tfloat specular = pow(max(0.0, dot(R, V)), 2.0);\n\treturn ambient + 0.8 * diffuse + 0.3 * specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 viewDir = normalize(vec3(uv.xy, focalLength));\n\tmat2 rotation = getRotationMatrix(iTime);\n\t\n\tfloat z_back = 1e8;\n\tfloat z_front = 0.0;\n\tvec3 result_normal;\n    \n\tfor (int i = 0; i < 32; i++) {\n\t\tvec3 normal = getNormal(i);\n        normal.xz = rotation * normal.xz;\n\t\tfloat dist = i < 12 ? 1.0 : 0.975;\n\t\t\n\t\tfloat viewDirDotNormal = dot(viewDir, normal);\n\t\tfloat z = (dist + normal.z * cameraDistance) / viewDirDotNormal;\n\t\tbool front = viewDirDotNormal < 0.0;\n\t\tif (front && z > z_front) {\n\t\t\tresult_normal = normal;\n\t\t\tz_front = z;\n\t\t}\n\t\tif (!front && z < z_back) {\n\t\t\tz_back = z;\n\t\t}\n\t}\n    \n\tfragColor = vec4(z_front > z_back ? 0.0 : fragment(lightDir, result_normal, -viewDir));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 135, 135, 445], [447, 447, 484, 484, 559], [561, 561, 601, 601, 790], [792, 792, 847, 847, 1604]], "test": "untested"}
{"id": "ltSyW3", "name": "rainbow diamond flow", "author": "jes5199", "description": "wom wom wom", "tags": ["2d", "plasma", "diamonds"], "likes": 1, "viewed": 163, "published": "Public", "date": "1510275690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((100.0 + 0.*pow(iTime / 5., 0.9))) * ((fragCoord.xy - (iResolution.xy / 2.0)) / iResolution.y);\n    \n    float value =  pow(sin(uv.x) * uv.y + sin(uv.y) * uv.x, 0.5);\n    float color = (value + iTime / 1.0) * 0.1;\n    \n    fragColor = vec4(hsv2rgb(vec3(color, 1, 1)),1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [194, 194, 251, 251, 541]], "test": "untested"}
{"id": "ltSyWt", "name": "Over the Moon+ [BigWings+]", "author": "twenkid", "description": "Vers. 19-11-2017: Meteors! (pyBlob's), moonglow (returned), new moon (test), animated moon - \"day/night\". Work in progress (experiments). Original work & suggestions by Martijn Steinrucken aka BigWIngs. Thanks! https://www.shadertoy.com/view/4s33zf", "tags": ["2d", "tree", "stars", "moon", "night", "mask", "extraction"], "likes": 19, "viewed": 1168, "published": "Public API", "date": "1510543077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Original work:\n 1. \"Over the Moon\" by Martijn Steinrucken aka BigWings - 2015\n  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n 2. The meteor code from \"2D fractal trees\" by pyBlob: (the meteor routines) https://www.shadertoy.com/view/Mt33Dn\n \n 3.  +Todor Arnaudov's (Twenkid/Tosh) additions and integration. \n\n 4. Music: https://soundcloud.com/jrhodespianist/clair-de-lune-debussy\n \n [ Warning: Work in progress! Experiments and dirty code are present! ]\n\n// Version history:\n//\n// 13-11-2017: Added rotation of the Moon and corrected the glowing routine,\n//             so that it does not light up the landscape when the moon is under the horizon.\n//\n// 14-11-2017: Masked the moon out from the stars, varied the gradient of the light,\n//             optimized glowing after BigWIngs'suggestions.\n//\n//             However it appeared that the glow is correct even *without* masking,\n//             thus moonGlow was turned off.\n// \n// Work needed: [FIXED] There's a \"light leakage\" below horizon, perhaps due to\n//              \"black/0\" values of the landscape and trees contours.\n//\n//       Ideas: Drawing it inverted, starting from 1.0 and subtracting, or just quitting\n//             after any non-zero operation/marking a flag - a simple hit-check.\n\n   15-11-2017:  The light leakage was fixed: \n                vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n                col = max(mask, trees);\n\n   16-11-2017: #define NEWMOON - experimental with noise textures, changed starsMasked (using .a).\n               Looks bad in full screen. A better and smoother crater generation is needed.\n               This one seems out of the style of the trees and the landscape.\n\n   19-11-2017: Returned the Bingwing's moonglow (fixed a bug in the masking in the moonglow function )\n               Meteors were added! (pyBlob routines)\n               Have been working on mapping of NickWest's craters to a sphere (moon). That shader is still a draft, though.\n               Strange bugs/black borders, noise on my main Windows machine, while on an older Linux computer it runs correctly,\n               both with Intel integrated GPUs. Something related to the noise generation routines/the fract-float-... implementations, I guess.\n\n   18-12-2017: Added Debussy's \"Claire de Lune\" as a soundtrack. Moon slowed down in order to sync it. /5. slowTrees = 0.6\n               \n// Future work: \n//\n// 1. [DONE] (credit: pyBlob): A falling star. Probably drawn in the moonglow routine in order\n//    to use the mask and the position of the moon, in order to synchronize it\n//    when the moon is below the horizon and then draw the meteor in the darkest part of the sky.\n//\n// 2. Trees swinging\n//\n// 3. Leafs and/or cones flying/rolling.\n//\n// 4. Day cycle - Moon sets, then Sun dawns, the sky turns blue, \n//    then the colors of the trees and the landscape get natural - brown, green.\n//\n// 5. Winter - snow falls and covers the trees and the landscape.\n//\n*/\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,b) S(x, x+b, z)*S(y+b, y, z)\n#define saturate(x) clamp(x,0.,1.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n#define MOONPOS vec2(1.3, .8)\n\n//twenkid\n\n#define NEWMOON 1  //Experimental with noise textures - one higher resolution and one lower\n#undef NEWMOON\n\n\nfloat slowTrees=0.66; //18-12-2017 - for more appropriate tempo (Claire de Lune) - in moonglow, mainImage *t\n\n/*\n NickWests' craters.  https://www.shadertoy.com/view/ldtXWf\n To be drawn over the moon later: \n*/\n\n/*\n//#define animSpeed 0.05 //not needed\n\n//-----------------------------------------------------------------------------\n// Crater in -1.0 to 1.0 space\nfloat crater(in vec2 pos) {\n    float len = length(pos);\n    float pi = 3.1415926535;\n    float x = clamp(pow(len, 4.0) * 8.0, pi*0.5, pi*2.5);\n    float t = clamp(len, 0.0, 1.0);\n    return sin(-x) + 0.5 - 0.5 * cos(t * pi);\n}\n\n//-----------------------------------------------------------------------------\nvec2 pseudoRand(in vec2 uv) {\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    return vec2(noiseX, noiseY);}\n\n//-----------------------------------------------------------------------------\nfloat repeatingCraters(in vec2 pos, in float repeat, in float scaleWeight) {\n    vec2 pos01 = fract(pos * vec2(repeat));\n    vec2 index = (pos * vec2(repeat) - pos01) / repeat;\n    vec2 scale = pseudoRand(index);\n    float craterY = crater(vec2(2.0) * (pos01 - vec2(0.5)));\n    return mix(1.0, pow(0.5*(scale.x + scale.y), 4.0), scaleWeight) * craterY; \n}\n\n//-----------------------------------------------------------------------------\nfloat getY(in vec2 pos) {    \n    float y = 0.5;\n    for(int i=0;i<int(20);++i) {\n        float f01 = float(i) / float(15); //float(99.0);\n        //float magnitude = pow(f01, 2.3);\n          float magnitude = f01*f01; // 2.3);\n        vec2 offs = pseudoRand(vec2(float(i+2), pow(float(i+7), 3.1)));\n        float repeat = 0.5 / (magnitude + 0.0001);\n\n        y += magnitude * repeatingCraters(pos+offs, repeat, 1.0);\n    }\n    \n\treturn y;\n}\n\n//-----------------------------------------------------------------------------\nvec4 drawCraters( in vec2 pos ) {\n//\tvec2 pos = (fragCoord.xy - iResolution.xy*0.5) / vec2(iResolution.y);\n    pos += vec2(1.0); // avoid negative coords\n\n    vec2 offs = vec2(0.001, -0.001);\n    \n    //After certain tenths of seconds - glitches in the image\n    \n   // pos.x += fract(iTime)*10. * animSpeed;\n   // pos.y -= fract(iTime)*10.0 * animSpeed * 0.25;\n\n\n     pos.x +=  0.; //fract(iTime)*10. * animSpeed;\n    pos.y -= 0.0 ;//fract(iTime)*10.0 * animSpeed * 0.25;\n    \n    float y = getY(pos);\n    float y1 = getY(pos - offs);\n    //float y2 = getY(pos + offs);\n\n    vec3 normal = normalize(vec3(0.01, y-y1, 0.01));\n\n    float d = 0.5 + 0.5 * dot(normal, normalize(vec3(2.0, 1.0, 2.0)));\n    \n    float shadeScale = 1.0;\n\n    float c = y * 0.02 - 0.5 + d * 1.3;\n\n    // color ramp\n    vec3 rgb = vec3(mix(mix(vec3(0.0,0.0,0.0), vec3(0.8,0.6,0.4), c), vec3(1.0,0.95,0.90), c));\n    \n    return vec4(rgb,1.0);\n}\n*/\n\n\n\n// pyBlob's meteor showers\n//https://www.shadertoy.com/view/Mt33Dn\n\n#define round2(x, f) (floor((x)/(f) + 0.5) * (f))\n\nfloat random(float p)\n{\n    return fract(52.043*sin(p*205.429));\n}\nfloat random2(float p)\n{\n    return random(p)*2.0-1.0;\n}\n\nvec3 meteor(vec2 uv, float gtime, float delay)\n{\n    float seed = round2(gtime, delay);\n    \n    float startTime = (delay - 1.5) * random(seed);\n    float time = max(0.0, min(1.0, gtime-seed - startTime));\n    \n    vec2 start = vec2(\n        random2(seed),\n        0.7 + 0.3 * random(seed+0.1)\n    );\n    \n    vec2 end = start * 0.5;\n    \n    uv = uv - mix(start, end, time);\n    \n    end = normalize(end - start);\n    uv = uv * mat2(end.x, end.y, -end.y, end.x);\n    uv.x *= 0.1;\n    \n    float alpha = 16.0 * pow(time, 2.0) * pow(time - 1.0, 2.0);\n    return vec3(max(0.0, alpha - iResolution.y * length(uv)));\n}\n\nvec3 meteorstorm(vec2 uv)\n{\n    return\n        meteor(uv, iTime, 9.5837/1.4) +\n        meteor(uv, iTime + 15.3, 15.459/1.5) +\n        meteor(uv, iTime + 125.0, 31.2/1.3);\n}\n\n//End of pyBlob's meteor code\n\n//BigWings'\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p) {\n    // From Dave Hoskins\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a) / (b-a)) * (d-c) + c;\n}\n\nfloat within(float a, float b, float t) {\t\n    return (t-a) / (b-a); \n    \n}\n\n\n\nfloat Band(float t,float start, float end, float blur){\n    float step1 = smoothstep(start - blur, start + blur, t);\n    float step2 = smoothstep(end + blur, end - blur, t);\n    return step1 * step2;\n}\n\nfloat Rect2(vec2 uv, float width, float height, float blur, float size){\n    uv /= size;\n    float band1 = Band(uv.x, -width, width, blur);\n    float band2 = Band(uv.y, -height, height, blur);\n    return band1 * band2 ;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur, float size){\n    uv /= size;\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1 * band2 ;\n}\n\n\nfloat skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {\n\tfloat y = within(top.z, bottom.z, uv.y);\n    float left = mix(top.x, bottom.x, y);\n    float right = mix(top.y, bottom.y, y);\n    \n    float horizontal = B(left, right, uv.x, blur);\n    float vertical = B(bottom.z, top.z, uv.y, blur);\n    return horizontal*vertical;\n}\n\nvec4 pine(vec2 uv, vec2 p, float s, float focus) {\n\tuv.x -= .5;\n    float c = skewbox(uv, vec3(.0, .0, 1.), vec3(-.14, .14, .65), focus);\n    c += skewbox(uv, vec3(-.10, .10, .65), vec3(-.18, .18, .43), focus);\n    c += skewbox(uv, vec3(-.13, .13, .43), vec3(-.22, .22, .2), focus);\n    c += skewbox(uv, vec3(-.04, .04, .2), vec3(-.04, .04, -.1), focus);    \n        \n    vec4 col = vec4(1.,1.,1.,0.);\n    col.a = c;\n   \n    float shadow = skewbox(uv.yx, vec3(.6, .65, .13), vec3(.65, .65, -.1), focus);\n    shadow += skewbox(uv.yx, vec3(.43, .43, .13), vec3(.36, .43, -.2), focus);\n    shadow += skewbox(uv.yx, vec3(.15, .2, .08), vec3(.17, .2, -.08), focus);\n    \n    col.rgb = mix(col.rgb, col.rgb*.8, shadow);\n    \n    return col;\n}\n\nfloat getheight(float x) {\n    return sin(x) + sin(x*2.234+.123)*.5 + sin(x*4.45+2.2345)*.25;\n}\n\nvec4 landscape(vec2 uv, float d, float p, float f, float a, float y, float seed, float focus) {\n\tuv *= d;\n    float x = uv.x*PI*f+p;\n    float c = getheight(x)*a+y;\n    \n    float b = floor(x*5.)/5.+.1;\n    float h =  getheight(b)*a+y;\n    \n    float e = fwidth(uv.y);\n    \n    vec4 col = vec4(S(c+e, c-e, uv.y));\n    //col.rgb *= mix(0.9, 1., abs(uv.y-c)*20.);\n    \n    x *= 5.;\n    float id = floor(x);\n    float n = hash11(id+seed);\n    \n    x = fract(x);\n    \n    y = (uv.y - h)*mix(5., 3., n)*3.5;\n    float treeHeight = (.07/d) * mix(1.3, .5, n);\n    y = within(h, h+treeHeight, uv.y);\n    x += (n-.5)*.6;\n    vec4 pineCol = pine(vec2(x, y/d), vec2(0.), 1., focus);\n    //col += pineCol;\n    col.rgb = mix(col.rgb, pineCol.rgb, pineCol.a);\n    col.a = max(col.a, pineCol.a);   \n    \n    \n    return saturate(col);\n}\n\nvec4 gradient(vec2 uv) {\n    \n\tfloat c = 1.-length(MOONPOS-uv)/1.4;\n    \n    vec4 col = vec4(c);\n    \n    return col;\n}\n\n/*\nfloat circMask(vec2 uv, vec2 pos, float radius) {\n\tfloat dist = length(uv-pos);    \n    return S(radius+blur, radius-blur, dist);\n}\n*/\n\nfloat circ(vec2 uv, vec2 pos, float radius, float blur) {\n\tfloat dist = length(uv-pos) + hash11(pos.x)*0.02;\n    return S(radius+blur, radius-blur, dist);\n}\n\nvec4 moon(vec2 uv) {\n   \n    float focus = 0.001; //default moon\n    \n    #ifdef NEWMOON\n    focus = 0.005; //set more blur due to to the contrast from the noise\n    #endif\n    \n    float c = circ(uv, MOONPOS, .07, focus);\n    //float c = circ(uv, MOONPOS, .07, .001); //default\n   \t\n    \n    #ifndef NEWMOON\n    c *= 1.-circ(uv, MOONPOS+vec2(.03), .07, .001)*0.95; //.95 --> original moon; <... -- darker \n    c = saturate(c);\n    #endif\n    \n    \n    vec4 col = vec4(c);\n    //col.rgb *=.8; //original\n    float moonMult = 0.8; \n    #ifdef NEWMOON\n    moonMult -= (texture(iChannel0, uv).x + texture(iChannel1, uv).x); //*max(0.5,abs(sin(iTime)))*4.0;\n    #endif\n    col.rgb *= moonMult;\n    //float b = clamp(col.b*1.1, 1.0, 1.0);\n    //col.b = b;\n   // col.b*=1.3; col.g*=0.8; col.r*=0.7;\n    \n    //col.rgb *=.8 - (texture(iChannel0, uv).x + texture(iChannel1, uv).x); //original\n    //float craters = min(0.4, texture(iChannel0, uv).x + texture(iChannel1, uv).x);// hash11(iTime)/20.0;\n   // float craters = (texture(iChannel0, uv).x + texture(iChannel1, uv).x)*(circ(uv, MOONPOS, .07, .001);\n   // craters = clamp(craters, 0., 0.5);\n    //col.rgb-=craters;\n    \n    return col;\n      \n}\n\n\n//Todor added uvBasic and the extraction of the glow from the landscape and the trees.\n//Without these modification, the landscape would glow.\nvec4 moonglow(vec2 uv, float foreground, vec2 uvBasic, vec2 guv) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n    \n    // \"Mask extraction\" - could be in a function.\n    // This is a copy of a segment from mainImage,\n    // which \"redraws the landscape and the trees\n    // in order to check if the glow is under the horizon.\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    float t = iTime*.05;\n    t*=slowTrees;  //18-12-2017\n    \n   // uvBasic = uv;\n    /*\n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uvBasic).x, 1.-i/10.);\n        trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n        trees. a = max(trees.a, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    //If the pixel is not hitting the trees and the landscape, it would be black.\n    //Then, add the glow. Else - ignore this component.\n     vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    col= max(mask, trees.rgba);\n   // col*= trees.r <= 0.0 ? 1.0 : 0.; \n*/\n    \n    float horizon = 0.25;\n    float birghtness = 1.0 + horizon - uvBasic.y; \n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01); //1\n        //vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .00); //1\n    \t       //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.); //2 - black mask of the trees and landscape           \n        \n        //no gradient here\n       //// layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1)+clamp(gradient(uv).x*birghtness, 0.0, 1.5)*2., 1.-i/10.);\n        \n              layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1), 1.-i/10.);\n        \n        //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3), 1.-i/10.);  //the leakage is not due to the gradient?\n        \n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a); //3 white trees, landscape with contours        \n        trees = mix(trees, layer, layer.a); //trees.rgba  = mix(trees.rgba, layer.rgba, layer.a);\n                 // trees.a = max(trees.a, layer.a);  ////BigWIngs optimization        \n        \n        dist -= .1;\n        height -= .06;\n    }\n    \n        vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n   \n    \n    guv.y-=0.2;\n    vec3 m = meteorstorm(guv); //\n    m*=(1.-trees.a);\n    mask.rgb+=m;\n    \n    \n      return mask; //OK\n    //if (col.r > abs(sin(iTime/5.))) //trees.a >0.5)\n    //if (col.r > 0.5 && trees.r < 0.01 && trees.a  > 0.005) col = trees;//trees.a >0.5)\n    //else\n    //col = mix(col, trees, trees.a)*(1.-trees.a); //mask\n    \n    /* Sun :) ...\n\n    float maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., .65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.1))*60.;\n    mix(c, maskline, 1.0); //trees.a);\n    col.rgb = vec3(c);\n    vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    */\n    \n    //col = mix(col, trees, trees.a)*mask; //(1.-trees.a);\n    \n    \n      //White rectangle!\n    float maxdistance = 0.06; //distance(vec2(0.87, 0.65+0.25), vec2(0.87, 0.66+0.25)); //distance(uv, vec2(0.87,0.65);\n    //float maskline = Rect(uv-0.5, 0.2, 0.4, -.3, 0.3, 0.01, 1.); //window\n    //float maskline = Rect(uv, 0.87, 0.93+abs(cos(iTime*5.))/20., 0.65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    \n    /*\nfloat maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., 0.65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(maxdistance-distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.2))*60.; //.*cos(distance(uv, vec2(0.87,0.65))); //smoothstep(18., 20.20.;\n*/\n    \n    /*\n    float maskline = Rect(uv, 0.87, 0.93-abs(cos(iTime*5.))/20., .65*uv.x + 0.05, 0.66*uv.x + 0.05, 0.005, 1.); //window\n    maskline *= max(0., pow(distance(uv, vec2(0.87,0.65-abs(cos(iTime*5.))/20.)),1.1))*60.; //.*cos(distance(uv, vec2(0.87,0.65))); //smoothstep(18., 20.20.;\n    //maskline *=mask.r;    \n    \n    col = vec4(1.);//maskline; //col*maskline;\n    */\n    \n    return col;\n}\n\n\n//Todor added uvBasic and the extraction of the glow from the landscape and the trees.\n//Without these modification, the landscape would glow.\nvec4 moonglowBasic(vec2 uv, float foreground) {\n    \n   \tfloat c = circ(uv, MOONPOS, .1, .2);\n    \n    vec4 col = vec4(c);\n    col.rgb *=.2;\n    \n/*    \n    // \"Mask extraction\" - could be in a function.\n    // This is a copy of a segment from mainImage,\n    // which \"redraws the landscape and the trees\n    // in order to check if the glow is under the horizon.\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n    float t = iTime*.05;\n    \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uvBasic, dist, t+i, 3., amplitude, height, i, .01);\n    \tlayer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uvBasic).x, 1.-i/10.);\n        trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n        trees. a = max(trees.a, layer.a);\n        \n        dist -= .1;\n        height -= .06;\n    }\n    //If the pixel is not hitting the trees and the landscape, it would be black.\n    //Then, add the glow. Else - ignore this component.\n    col*= trees.r < 0.0 ? 1.0 : 0.; \n*/    \n     col*= col.r == 0.0001 ? 1.0 : 0.; \n    \n    return col;\n}\n\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    \n    \n    return alpha1 * alpha2 * twinkle;\n    \n   // float c = moon(uv, MOONPOS, .1, .2);\n   // return c > 0.0 ? 0.0 : alpha1 * alpha2 * twinkle;    \n    \n}\n\n\nfloat starsMasked(vec2 uv, float t, vec2 moonUV) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    \n    //return alpha1 * alpha2 * twinkle;\n           \n    vec4 m = moon(moonUV);\n    return m.a > 0.0 ? 0.0 : (alpha1 * alpha2 * twinkle);    //was m.r, but now has black also - 16.11\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*.05;\n   \n     \n    vec2 bgUV = uv*vec2(iResolution.x/iResolution.y, 1.);\n    vec2 uvBasic = uv;//bgUV; //The original value - for the glow extraction\n    vec2 guv = (fragCoord.xy - vec2(iResolution.x*0.5, 0.0)) / iResolution.y; //pyBlob's coordinates\n    \n    // Adjusting the position of the moon and its trajectory. \n    bgUV.y+=0.43;    \n    bgUV.x+=PI*sin((iTime/6.+3090.)/1.76)/5.;      //iTime/6... - slow down to Sync it with the \"Claire de Lune\" piece\n    bgUV.y+=(PI/1.12)*cos((iTime/6.+3090.)/1.76)/5.;\n    bgUV.x+=0.5;\n    \n    //vec4 col = vec4(0.); //gradient(bgUV)*.8;  //higher contrast, black\n    vec4 col = gradient(bgUV)*.8;  //higher contrast, black\n    col += moon(bgUV); //, bgUVBasic);\n    //col += moonLeakage2(bgUV, bgUVBasic); //no\n   \n   // col += stars(uv, t);\n    col += starsMasked(uv, t, bgUV);\n    \n    float dist = .10;\n    float height = -.01;\n    float amplitude = .02;\n    \n    dist = 1.;\n    height = .55;\n      \n    float horizon = 0.25;\n    float birghtness = 1.0 + horizon - bgUV.y; //BingWings's suggestion to darken when the moon is below horizon,\n                                               //however implemented with a gradual change.\n   \n    vec4 trees = vec4(0.);\n    for(float i=0.; i<10.; i++) {    \n    \tvec4 layer = landscape(uv, dist, t*slowTrees+i, 3., amplitude, height, i, .01); //1\n        //vec4 layer = landscape(uv, dist, t+i, 3., amplitude, height, i, .00); //1\n    \t       //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3)+gradient(uv).x, 1.-i/10.); //2 - black mask of the trees and landscape           \n        \n        layer.rgb *= mix(vec3(.1, .1, .2), vec3(.1)+clamp(gradient(uv).x*birghtness, 0.0, 1.5)*2., 1.-i/10.);\n        \n        //layer.rgb *= mix(vec3(.1, .1, .2), vec3(.3), 1.-i/10.);  //the leakage is not due to the gradient?\n        \n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a);\n                 //trees.rgb = mix(trees.rgb, layer.rgb, layer.a); //3 white trees, landscape with contours        \n        trees = mix(trees, layer, layer.a); //trees.rgba  = mix(trees.rgba, layer.rgba, layer.a);\n                 // trees.a = max(trees.a, layer.a);  ////BigWIngs optimization        \n        \n        dist -= .1;\n        height -= .06;\n    }\n    \n    //if (col.r > abs(sin(iTime/5.))) //trees.a >0.5)\n    //if (col.r > 0.5 && trees.r < 0.01 && trees.a  > 0.005) col = trees;//trees.a >0.5)\n    //else\n    //col = mix(col, trees, trees.a)*(1.-trees.a); //mask\n    vec4 mask = mix(col, trees, trees.a)*(1.-trees.a);\n    col = max(mask, trees); //trees, trees.a)*(1.-trees.a);\n    \n    //col += moonglow(bgUV, 1., uvBasic)*(1.-trees.a); //*(1.-trees.a); \n    col += moonglow(bgUV, 1., uvBasic, guv)*(1.-trees.a); //*(1.-trees.a);  //+meteors\n    \n    \n    \n    //col += moonglowBasic(bgUV, 1.); //*(1.-trees.a); \n    \n    \n/* Black circle\n    vec4 maskmoon = moon(bgUV);\n    if (maskmoon.r < 0.001)\n    col = mix(col, trees, trees.a);\n    else col = trees;\n*/    \n   // col += moonglow(bgUV, 1., bgUVBasic); //Twenkid's first simple solution \n   // col += moonglowBasic(bgUVBasic, 1.)*(1.-trees.a); //BigWIngs's optimization - however the glow appears without callung glow?\n    \n    //col = moonglowLeakage(bgUV, 1., bgUVBasic);//*(1.-trees.a); //Attempts to remove white leakage\n    \n    col = saturate(col);\n    \n    \n    vec4 foreground = landscape(uv, .02, t*slowTrees, 3., .0, -0.04, 1., .1);\n    foreground.rgb *= vec3(.1, .1, .2)*.5;\n            \n    col = mix(col, foreground, foreground.a);\n    \n   \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "lt23DG", "previewfilepath": "https://soundcloud.com/claude-debussy/clair-de-lune", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/claude-debussy/clair-de-lune", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSyWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[6281, 6400, 6423, 6423, 6466], [6467, 6467, 6491, 6491, 6523], [6525, 6525, 6573, 6573, 7139], [7141, 7141, 7168, 7168, 7313], [7359, 7469, 7492, 7517, 7629], [7631, 7650, 7672, 7672, 7788], [7790, 7790, 7848, 7848, 7887], [7889, 7889, 7930, 7930, 7965], [7969, 7969, 8024, 8024, 8170], [8172, 8172, 8244, 8244, 8393], [8395, 8395, 8489, 8489, 8632], [8635, 8635, 8694, 8694, 8964], [8966, 8966, 9016, 9016, 9702], [9704, 9704, 9730, 9730, 9799], [9801, 9801, 9896, 9896, 10622], [10624, 10624, 10648, 10648, 10743], [10745, 10884, 10941, 10941, 11040], [11042, 11042, 11062, 11062, 12235], [12238, 12381, 12447, 12447, 16753], [16756, 16899, 16946, 16946, 18036], [18039, 18039, 18070, 18070, 18543], [18546, 18546, 18596, 18596, 19100], [19102, 19102, 19159, 19159, 22750]], "test": "untested"}
{"id": "ltSyzc", "name": "demo_01", "author": "jzllove9", "description": "一个简单的测试demo", "tags": ["demo"], "likes": 0, "viewed": 59, "published": "Public", "date": "1509501023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*the begin of glsl ES personal*/\nconst float PI = 3.14159265;\nconst float step = 15.0;\n\nbool judge( float x, float y ){\n    float _x = sin( (x * 2.0 * PI * step) );\n    float _y = sin( (y * 2.0 * PI * step) );\n\n    if( _x * _y >= 0.0){\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(0.0,1.0,1.0,1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    /*1.default*/\n    \n    /*\n    float color = 0.0;\n    color += sin(uv.x * cos(iTime / 15.0) * 80.0) + cos(uv.y * sin(iTime / 15.0) * 10.0);\n    color += sin(uv.y * sin(iTime / 10.0) * 40.0)  + cos(uv.x * sin(iTime / 25.0) * 40.0);\n    color += sin(uv.x * sin(iTime / 5.0) * 10.0)  + sin(uv.y * sin(iTime / 35.0) * 80.0);\n    color *= sin( iTime / 10.0 ) * 0.5;\n    fragColor = vec4(uv, 0.5 * sin( iTime * 2.0 ), 1.0);\n    fragColor = vec4( vec3( color, color * 0.5, sin( color + iTime / 3.0 ) * 0.75 ), 1.0 );\n    fragColor = vec4( vec3( color, color , color), 1.0 );\n\t*/\n    \n    /*2.chess*/\n   \t/*\n\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0);\n    if( judge(uv.x, uv.y) ){\n    \tfragColor.rgb = vec3(1.0, 1.0, 1.0);\n    }\n\t*/\n    \n    /*3.others*/\n    /*\n     fragColor = vec4(0.0, 0.0, 0.0, 1.0);// 将默认颜色设置为黑色\n    //x坐标大于300的像素颜色设置为红色\n    if (uv.x > 0.3) {\n        fragColor.r = 1.0;\n    }\n\t*/\n    /*\n\tvec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now\n    solidRed.r = xy.x; //Set its red component to the normalized x value\n    fragColor = solidRed;\n\t*/\n    \n    /* 4.texture & black & white & outline*/  \n    \n    vec4 texColor = texture(iChannel0, uv);\n    float lum = (texColor.x + texColor.y + texColor.z) / 3.;\n    \n    /*此处处理成灰度图并输出*/\n    //fragColor = vec4(vec3(lum), 1.);\n    \n    /*此处从灰度图中抽取颜色比较深的像素并输出*/\n    float level = 0.2;\n    if( lum <= level && \n        lum <= level &&\n      \tlum <= level\n      ){\n    \ttexColor.r = sin(iTime);\n        texColor.g = cos(iTime);\n        texColor.b = 0.0;\n    }else{\n    \ttexColor.r = 1.0;\n        texColor.g = 1.0;\n        texColor.b = 1.0;\n    }\n    fragColor = texColor;\n\n    /* 5.texture & chess */\n    /*\n    vec4 texColor = texture(iChannel0, uv); //Get the pixel at xy from iChannel0\n    \n    if( judge(uv.x, uv.y) ){\n    \t//texColor.r = uv.x;\n        //texColor.g = uv.y;\n        texColor.b = uv.x;\n    }\n    \n    fragColor = texColor;//Set the screen pixel to that color\n\t*/\n    \n    /* 6.texture & time */\n    /*\n    vec2 xy = fragCoord.xy / iResolution.xy; // Condensing this into one line\n    vec4 texColor = texture(iChannel0,xy); // Get the pixel at xy from iChannel0\n    \n    texColor.r *= abs(sin(iTime));\n    texColor.g *= abs(cos(iTime));\n    texColor.b *= abs(sin(iTime) * cos(iTime));\n    \n    fragColor = texColor; // Set the screen pixel to that color\n\t*/\n    \n    /* 7.the green screen handle */\n    /*\n    vec4 texColor = texture(iChannel0, uv);\n    vec4 texColor_1 = texture(iChannel1, uv);\n    \n    float g_level = 0.6;\n    float o_level = 0.3;\n    \n    if(texColor.g >= 0.4 && texColor.r <= 0.4 && texColor.b <= 0.4){\n    \tfragColor = texColor_1;\n    }\n    else{\n   \t\tfragColor = texColor;\n    }\n    */\n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 120, 120, 284], [286, 286, 343, 384, 3515]], "test": "untested"}
{"id": "ltXBDN", "name": "MoonSea", "author": "challenge", "description": "A moon, A sea", "tags": ["2d", "sea", "moon"], "likes": 0, "viewed": 443, "published": "Public API", "date": "1511857069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) - smoothstep( pct, pct+0.02, st.y);  \n}\n\nfloat rand (float i) {\n    return fract(sin(i)*100000.0);\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //uv *=2.0;\n\n    float i = floor(uv.x + iTime); \n\tfloat f = fract(uv.x + iTime); \n    float u = f * f * (3.0 - 2.0 * f );\n\tfloat y = mix(rand(i), rand(i + 1.0), u);\n    y = y / 5.0 + 0.3;\n    float ly = plot(uv,y);\n    \n    vec3 color = vec3(ly);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    \n    vec2 translate = vec2(sin(iTime),0);\n    st += translate*0.35;\n    \n    float yellow = circle(vec2(st.x, st.y-0.3), 0.05);\n    color +=  vec3(yellow,yellow,0);\n    \n    float kill_yellow = circle(vec2(st.x-0.1, st.y-0.3), 0.05);\n    color -=  vec3(kill_yellow,kill_yellow,0);\n    \n    color.b += smoothstep(0.0,1.0-y, 1.0-uv.y) - step(1.0-y, 1.0-uv.y)*(1.0-uv.y);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 114], [116, 116, 138, 138, 175], [177, 177, 221, 221, 395], [397, 397, 454, 454, 1228]], "test": "untested"}
{"id": "ltXBz7", "name": "2D Grid Traversal w/ Refraction", "author": "glk7", "description": "Traversal of a 2d grid with refraction. Blueish cells have a refraction index of 1 while reddish ones have a higher index (2.7). The mouse can be used to point the ray.", "tags": ["2d", "grid", "refraction", "traversal"], "likes": 21, "viewed": 753, "published": "Public API", "date": "1511644300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float w = 2.;\n\nfloat grid(vec2 uv, float e) \n{\n   vec2 g = smoothstep(0.0, w*e, abs(fract(uv + 0.5) - 0.5)); \n   return g.x * g.y;\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(0.07, 0.07 + w*e, length(uv - p)); \n}\n\nfloat segment(vec2 uv, float e, vec2 d, vec2 p, float l) \n{\n    return max(1.0 - min(step(0.0, dot(d, uv - p)), \n                         step(0.0, dot(d, p + d*l - uv))),\n   \t\t       smoothstep(0.015, 0.015 + w*e, abs(dot(vec2(-d.y, d.x), p - uv))));\n}\n\nfloat refract_index(vec2 c) \n{\n    return 1.0 + step(-3.2, -length(c - vec2(7.0, 6.0)))*1.7;\n}\n\nvec2 traversal(vec2 uv, float e, vec2 ro, vec2 rd) \n{   \n    vec2 v = vec2(1.0);\n    \n    vec2 n = vec2(0.0);\n    vec2 c = floor(ro) + 0.5;\n    ro -= c;\n    \n    float refri = refract_index(c - 0.5);\n    \n    for( int s = 32; s > 0; --s ){\n        vec2 d = (sign(rd)*0.5 - ro) / rd;\n        \n        v.x = min(v.x, segment(uv, e, rd, c + ro, min(d.x, d.y))); // Draw segments.\n        \n        ro += min(d.x, d.y) * rd;\n        n = -sign(rd) * step(d.xy, d.yx);\n\n        // Refraction part.\n        #if 1\n        float nrefri = refract_index(c - 0.5 - n);\n        \n        vec2 reflrd = reflect(rd, n);\n        rd = refract(rd, n, refri/nrefri);\n        \n        float t = step(0.0, -dot(rd, rd));\n       \trefri = mix(nrefri, refri, t);\n        rd += reflrd*t;\n        n *= 1.0 - t;\n        #endif\n        \n        c -= n;\n       \tro += n;\n        \n        // Draw cells and points.\n        v = min(v, \n                vec2(point(uv, e, c + ro), \n                \t step(0.5, length(floor(uv) - c + 0.5))));\n    }\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 25.0 / iResolution.x;\n    vec2 offset = vec2(5.0, 3.0);\n\tvec2 uv = fragCoord.xy*e - offset;\n    \n    vec2 ro = vec2(1.7, 1.2);\n    \n    vec2 rd = (length(iMouse.xy) < 10.0)\n        \t? normalize(vec2(1.0, sin(iTime*0.2) + 1.5))\n    \t\t: normalize(iMouse.xy*e - offset - ro);\n    \n    float ri = refract_index(floor(uv));\n    vec3 c = vec3(1.0 - step(0.0, 1.0 - ri), 0.2, \n                  step(0.0, 1.0 - ri)) + 0.3;\n   \n    vec2 t = traversal(uv, e, ro, rd);\n    c += (1.0 - t.y) * 0.2;\n    c *= t.x;\n    c *= grid(uv, e);\n    c *= point(uv, e, ro);\n    \n\tfragColor = vec4(pow(clamp(c, 0.0, 1.0), vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXBz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 138, 169, 169, 255], [257, 257, 297, 297, 354], [356, 356, 415, 415, 609], [611, 611, 641, 641, 705], [707, 707, 760, 760, 1740], [1742, 1742, 1799, 1799, 2433]], "test": "untested"}
{"id": "ltXBzn", "name": "DancingShader", "author": "hop", "description": "Dancing shader", "tags": ["test", "music", "fun", "bit", "dancer"], "likes": 2, "viewed": 178, "published": "Public", "date": "1510762637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 background(vec2 fCoord)\n{\n    vec2 gb = vec2(abs(fCoord.x / iResolution.x - (0.5 + 0.4 * sin(iTime / 4.0)))\n                   ,abs(fCoord.y / iResolution.y - (0.5 + 0.4 * cos(iTime / 3.0))));\n\treturn vec4(0.8 * abs(cos(iTime / 4.0)), gb, 1.0);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 dancer(vec2 fCoord, vec4 fColor, vec2 center, float radFactor)\n{\n    float rad = min(iResolution.x, iResolution.y) * radFactor;\n    rad += rad * texelFetch(iChannel0, ivec2(0,0), 0).x;\n    vec2 dist = center - fCoord;\n    float dist2 = dist.x * dist.x + dist.y * dist.y;\n    float rad2 = rad * rad;\n    // main circle\n    if (dist2 < rad2) {\n    \tfColor = fColor + 0.3;\n    }\n    // hands\n    vec2 x = vec2(1, 0);\n    float angle = degrees(acos(dot(normalize(dist), x)));\n    if (dist.y < 0.) {\n    \tangle += 180.;\n    }\n    int texel = int(angle / 10.);\n    //atan(dist.x / dist.y);\n    if (dist2 < rad2 + rad2 * texelFetch(iChannel0, ivec2(texel, 0), 0).x) {\n    \tfColor = fColor + 0.3;\n    }\n    return fColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = background(fragCoord);\n    fragColor = dancer(fragCoord, fragColor, iResolution.xy / 2.0, 0.1);\n}", "image_inputs": [{"id": "MsSXRz", "previewfilepath": "https://soundcloud.com/mcfearless/veridis-quo-daft-punk-original", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mcfearless/veridis-quo-daft-punk-original", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 251], [253, 253, 273, 273, 343], [345, 345, 414, 414, 1065], [1067, 1067, 1122, 1122, 1233]], "test": "untested"}
{"id": "ltXfzr", "name": "White Folly 2", "author": "dr2", "description": "Another architectural folly; mouse enabled", "tags": ["raymarch", "symmetry", "architecture"], "likes": 8, "viewed": 457, "published": "Public API", "date": "1510768613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"White Folly 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat dstFar, tCur, tWav;\nint idObj;\nconst int idStr = 1, idRail = 2, idFlr = 3, idPil = 4;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qs;\n  float dMin, d, s, aq, a, db;\n  const float flGap = 4., flShift = 3.9, flRad = 9.85, flWid = 1.7, bcRadV = 0.04,\n     bcRadH = 0.07, bcLen = 1.1;\n  dMin = dstFar;\n  q = p;\n  aq = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * aq / (2. * pi) + 0.5) / 4.));\n  qs.y = q.y;\n  qs.xz = Rot2D (q.xz + vec2 (11.3, 6.), -0.25 * pi);\n  db = PrBox2Df (qs.yz + vec2 (-8.9, 0.), vec2 (1.4, 0.5));\n  qs.xz = Rot2D (q.xz + vec2 (11.3, -6.), 0.25 * pi);\n  db = min (db, PrBox2Df (qs.yz + vec2 (-1.1, 0.), vec2 (1.2, 0.5)));\n  qs.y = q.y - flGap;\n  qs.xz = Rot2D (vec2 (q.x + 11.3, abs (q.z) - 6.), -0.25 * pi);\n  q.xz = vec2 (- q.z, q.x + 6.);\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = vec2 (28. * a / (2. * pi), length (q.xz) - 8.);\n  q.y += 3.;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  s = mod (q.x, 0.5 * sqrt (2.));\n  d = 0.3 * max (max (max (q.y - min (s, 0.5 * sqrt (2.) - s), abs (q.z) - 1.5), -0.07 - q.y), qs.x - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idStr;  qHit = q; }\n  q.z = abs (q.z);\n  q -= vec3 (-11.3, 1.4, 1.43);\n  d = max (min (PrBoxDf (q, vec3 (5.8, 0.9 * bcRadH, bcRadH)),\n     PrBoxDf (vec3 (0.5 * mod (17.8 * a + 0.5, 1.) - 0.25, q.y + 0.7, q.z),\n     vec3 (bcRadV, 0.7, bcRadV))), qs.x - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idRail; }\n  q = p;  q.y = abs (qs.y + 0.05) - flShift;\n  d = PrCylAnDf (q.xzy, flRad, flWid, 0.15);\n  q.xz = qs.xz + vec2 (-2., 0.2);\n  d = min (d, PrBoxDf (q, vec3 (2.1, 0.15, 1.7)));\n  if (d < dMin) { dMin = d;  idObj = idFlr;  qHit = q; }\n  q = vec3 (p.x, abs (qs.y - 2.1) - flShift, p.z);\n  d = min (PrCylAnDf (q.xzy, flRad - flWid + 0.15, bcRadH, bcRadH),\n     max (PrCylAnDf (q.xzy, flRad + flWid - 0.15, bcRadH, bcRadH), 2. - abs (qs.x - 2.)));\n  q.y = abs (qs.y - 1.) - flShift;\n  q.xz = Rot2D (p.xz, 2. * pi * (floor (128. * aq / (2. * pi) + 0.5) / 128.));\n  d = min (min (d, PrBoxDf (vec3 (q.x + flRad - flWid + 0.15, q.yz), vec3 (bcRadV, bcLen, bcRadV))),\n     max (PrBoxDf (vec3 (q.x + flRad + flWid - 0.15, q.yz), vec3 (bcRadV, bcLen, bcRadV)), 2. - abs (qs.x - 2.)));\n  d = min (d, max (min (PrBoxDf (vec3 (qs.x - 2., abs (qs.y - 2.1) - flShift, qs.z - 1.45),\n     vec3 (2., bcRadH, bcRadH)), PrBoxDf (vec3 (mod (qs.x + 0.25, 0.5) - 0.25,\n     abs (qs.y - 1.) - flShift, qs.z - 1.45), vec3 (bcRadV, bcLen, bcRadV))), abs (qs.x - 2.) - 2.));\n  d = min (d, max (min (PrBoxDf (vec3 (qs.x, abs (qs.y - 2.1) - flShift, qs.z), vec3 (bcRadH, bcRadH, 1.45)),\n     max (PrBoxDf (vec3 (qs.x, abs (qs.y - 1.) - flShift,\n     mod (qs.z + 0.25, 0.5) - 0.25), vec3 (bcRadV, bcLen, bcRadV)), abs (qs.z) - 1.45)), - db));\n  if (d < dMin) { dMin = d;  idObj = idRail; }\n  d = min (PrCapsDf (vec3 (qs.x, abs (qs.y - bcLen) - flShift, qs.z - 1.43).xzy, 0.15, 1.2),\n     PrCapsDf (vec3 (qs.x, qs.y - bcLen, qs.z + 1.43).xzy, 0.15, flShift + 1.2));\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 32; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    col = vec3 (0.2, 0.3, 0.6) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), 0.2 + 0.8 * f * rd.y);\n  } else {\n    col = mix (0.6 * mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), Fbm2 (ro.xz)) *\n       (1. - 0.2 * Noisefv2 (32. * ro.xz)), vec3 (0.18, 0.28, 0.48), pow (1. + rd.y, 5.));\n    f = 1. - smoothstep (0.1, 1., length (ro.xz) / dstFar);\n    vn = VaryNf (ro, vec3 (0., 1., 0.), 2. * f);\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.));\n  }\n  return col;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 3. * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col;\n  float dstObj, r, s, sh;\n  bool isBg;\n  HexVorInit ();\n  tWav = 0.2 * tCur;\n  isBg = true;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idFlr) {\n      col = vec3 (1.);\n      r = length (ro.xz);\n      if (abs (vn.y) > 0.99) col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03,\n         ((r < 11.6) ? mod (2.42 * r, 1.) : mod (2. * qHit.x, 1.)));\n      else if (abs (vn.y) < 0.01) col *= 0.8 +\n         0.2 * SmoothBump (0.2, 0.8, 0.03, mod (12. * ro.y, 1.));\n      vn = VaryNf (100. * ro, vn, 0.2); \n    } else if (idObj == idStr) {\n      col = vec3 (0.95, 0.95, 1.);\n    } else if (idObj == idRail) {\n      col = vec3 (0.8, 0.8, 1.);\n    } else if (idObj == idPil) {\n      col = vec3 (0.8, 0.8, 1.);\n    }\n    sh = 0.5 + 0.5 * ObjSShadow (ro, sunDir);\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    sh = 0.5 + 0.5 * ObjSShadow (ro, sunDir);\n    if (length (ro.xz) < 8.1) {\n      isBg = false;\n      rd = refract (rd, WaveNf (ro, 20.), 1./1.333);\n      ro += rd;\n      vc = HexVor (2. * ro.xz);\n      vn.xz = - 0.9 * vc.yz;\n      vn.y = 1.;\n      vn = normalize (vn);\n      s = mod (16. * vc.w, 1.);\n      col = HsvToRgb (vec3 (0.1 + 0.3 * step (2. * s, 1.) + 0.1 * mod (5. * s, 1.),\n        0.5 + 0.5 * mod (17. * s, 1.), 0.7 + 0.3 * mod (12. * s, 1.))) *\n        (0.6 + 0.4 * smoothstep (0., 0.2, vc.x)) * (1. - 0.2 * Noisefv2 (128. * ro.xz));\n    }\n  }\n  if (! isBg) col = col * (0.3 + 0.1 * max (dot (- sunDir.xz, vn.xz), 0.) +\n     0.7 * sh * max (dot (sunDir, vn), 0.)) +\n     0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n  else col = sh * BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 120.;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az += 2.5 * pi * sin (0.003 * pi * tCur);\n    el += 0.1 * pi * cos (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 7. - 2. * cos (az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 5., -70.);\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXfzr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 794, 816, 816, 3751], [3753, 3753, 3786, 3786, 3963], [3965, 3965, 3986, 3986, 4188], [4190, 4190, 4227, 4227, 4449], [4451, 4451, 4482, 4482, 5181], [5183, 5183, 5206, 5206, 5729], [5731, 5731, 5762, 5762, 5965], [5967, 5967, 6002, 6002, 7752], [7754, 7754, 7810, 7810, 8739], [8741, 8741, 8773, 8773, 8873], [8875, 8875, 8908, 8908, 8997], [8999, 8999, 9041, 9041, 9092], [9094, 9094, 9137, 9137, 9201], [9203, 9203, 9256, 9256, 9317], [9367, 9367, 9391, 9391, 9621], [9623, 9623, 9647, 9647, 9707], [9709, 9709, 9729, 9729, 9949], [9951, 9951, 9973, 9973, 10569], [10571, 10571, 10616, 10616, 10719], [10721, 10721, 10778, 10778, 10861], [10863, 10863, 10893, 10893, 10951], [10953, 10953, 10977, 10977, 11113], [11147, 11147, 11171, 11171, 11231], [11233, 11233, 11257, 11257, 11387], [11389, 11389, 11414, 11414, 11600], [11602, 11602, 11623, 11623, 11778], [11780, 11780, 11809, 11809, 12025], [12027, 12027, 12066, 12066, 12246]], "test": "untested"}
{"id": "Ml2cDd", "name": "Antialiasing Demo", "author": "olano", "description": "Demo of aliasing and different antialiasing kernels.\n  Left = horribly aliased one sample per pixel.\n  Right = 256 samples per pixel, quasi-random distribution, Lanczos weights\nEdit constants at top of shader to explore different antialiasing strategies", "tags": ["aliasing", "filtering"], "likes": 2, "viewed": 358, "published": "Public", "date": "1510685018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Aliasing and antialiasing demo\n// infinitely scrolling checkerboard\n// change parameters below to adjust kernel, jitter, sample pattern, etc.\n\n// worst: samples=1, DIST=GRID, FILT=BOX\n// good: samples=8, DIST=QUASIRANDOM, FILT=LANCZOS\n\n// sample distribution, options for dist[]\n#define GRID 0\t\t\t/* uniform grid */\n#define JITTER 1\t\t/* random jitter */\n#define QUASIRANDOM 2\t/* Hammersley quasi-random */\n\n// filter kernel, options for filt[]\n#define BOX 0\t\t\t\t/* Equal-weight spatial box filter */\n#define LANCZOS 1\t\t\t/* Lanczos filter of order given by lanczosOrder */\n#define LANCZOS_RADIAL 2\t/* Radially symmetric Lanczos filter */\n#define GAUSSIAN 3\t\t\t/* Gaussian weights */\n#define GAUSS_SAMP 4\t\t/* Gaussian-distributed importance samples */\n\n// sampling parameters\nstruct Parameters {\n    int samples;\t// samples * samples per pixel\n    int dist;\t\t// sample distribution\n    int filt;\t\t// filter kernel\n    int order;\t\t// Lanczos order (for Lanczos) integer >= 1\n};\n    \n\n///////////////////////////////////////////////////////////////////////\n// begin changable parameters\n\n// scrolling speed\nconst float speed = 0.1;\n\n// number of options to compare\nconst int splits = 2;\n\nconst Parameters param[splits] = Parameters[splits](\n    Parameters(8, GRID, BOX, 1),\n    Parameters(8, GRID, GAUSSIAN, 1)\n    );\n\n// end of parameters\n///////////////////////////////////////////////////////////////////////\n\n// Epic PCG3D generator\nuvec3 PCG3D(uvec3 v) {\n    v = 1664525u * v + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v>>16u;\n}\n\n// jitter for sample i,j\nvec2 jitter(int dist, int i, int j) {\n    // random jitter within cell\n    if (dist == JITTER)\n    \treturn vec2(PCG3D(uvec3(gl_FragCoord.xy,0)).xy)/float(0xffff);\n    \n\t// jitter based on Hammersley bit-reversal sequence\n    if (dist == QUASIRANDOM) {\n    \tvec2 offset = vec2(0), scale = vec2(0.5);\n        for(int x = j;  x > 0;  x>>=2, scale.x*=0.5)\n            offset.x += float(x&1) * scale.x;\n        for(int y = i;  y > 0;  y>>=2, scale.y*=0.5)\n            offset.y += float(y&1) * scale.y;\n        return offset;\n    }\n    \n    // no jitter\n    return vec2(0.5);\n}\n\n// compute new location for importance sampling\nvec2 distribution(int filt, vec2 offset) {\n    if (filt == GAUSS_SAMP) {\n        // Box-Mueller transform to get Gaussian-distributed sample locations\n        // assumes components of offset are distributed between -1 and 1\n        float radius = sqrt(-2.0 * log(offset.x*.5 + .5));\n        float theta = 3.14159265359 * offset.y;\n        return vec2(radius * cos(theta), radius * sin(theta));\n    }\n\n    // all others use weights\n    return offset;\n}\n\n// Lanczos kernel of order a\nfloat lanczos(float x, float a) {\n    // basic Lanczos function: sinc(x) * sinc(x/a)\n    float f = a * sin(x) * sin(x/a) / (x*x);\n\n    if (abs(x)>a) f = 0.0;        // Lanczos is 0 for x past window\n    if (f != f) f = 1.0;          // NaN for x=0, in the limit = 1\n    return f;\n}\n\n// filter weight\nfloat weight(int filt, vec2 offset, float order) {\n    // Gaussian with standard deviation width/2:\n    if (filt == GAUSSIAN)\n        return exp(-2. * dot(offset,offset));\n\n    if (filt == LANCZOS)\n   \t\treturn lanczos(offset.x, order)*lanczos(offset.y, order);\n\n    if (filt == LANCZOS_RADIAL)\n    \treturn lanczos(length(offset), order);\n\n    // equal-weight for box filter or Gaussian importance sampling\n    return 1.0;\n}\n\n// filter width in pixels\nfloat filterWidth(int filt, float order) {\n    if (filt == GAUSSIAN)\n    \treturn 1.66;\n\n    if (filt == LANCZOS || filt == LANCZOS_RADIAL)\n   \t\treturn order;\n\n    // equal-weight box filter\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // which set of options?\n    int s = splits * int(fragCoord.x) / int(iResolution.x);\n    int samples = param[s].samples;\n    int dist = param[s].dist;\n    int filt = param[s].filt;\n    float order = float(param[s].order);\n    \n    vec2 pix = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 kernelSize = filterWidth(filt, order) / iResolution.xy;\n\n    vec4 color = vec4(0);\n\tfor(int i=0; i < samples; ++i) {\n\t    for(int j=0; j < samples; ++j) {\n    \t    // sample offset (possibly with jitter)\n        \tvec2 offset = (vec2(i,j) + jitter(dist, i,j)) / float(samples) - 0.5;\n            offset = distribution(filt, offset);\n\n\t        // ray direction\n    \t    vec3 ray = vec3(pix + offset*kernelSize,2);\n\n        \tvec3 samp = vec3(0.5, 0.7, 0.9); // background color\n            if (ray.y < 0.0) { // ray intersects x/z plane through 0,-1,0\n\t            // where is intersection\n    \t        vec2 p = -ray.xz / ray.y + speed * iTime;\n                samp = vec3((int(p.x)&1) == (int(p.y)&1));\n            }\n \t\t\n\t        // accumulate with weight\n    \t    color += vec4(samp,1) * weight(filt, offset, order);\n \t   }\n\t}\n    \n\tfragColor = color / color.a;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2cDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1409, 1433, 1455, 1455, 1616], [1618, 1643, 1680, 1713, 2214], [2216, 2264, 2306, 2306, 2715], [2717, 2746, 2779, 2830, 3027], [3029, 3046, 3096, 3145, 3469], [3471, 3497, 3539, 3539, 3703], [3705, 3705, 3762, 3791, 4923]], "test": "untested"}
{"id": "Ml2cDK", "name": "Radar Music Visualizer", "author": "laserdog", "description": "Radar that moves to the music.", "tags": ["radar"], "likes": 8, "viewed": 495, "published": "Public", "date": "1510273944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 points[15];\n    points[0] = vec2(.1, .1);\n    points[1] = vec2(.15, -.2);\n    points[2] = vec2(-.3, .05);\n    points[3] = vec2(-.25, -.1);\n    points[4] = vec2(-.12, .23);\n    points[5] = vec2(.3, .28);\n    points[6] = vec2(.11, .35);\n    points[7] = vec2(.4, -.4);\n    points[8] = vec2(-.223, .3);\n    points[9] = vec2(.4, -.18);\n    points[10] = vec2(.32, -.1);\n    points[11] = vec2(.2, -.32);\n    points[12] = vec2(-.13, .15);\n    points[13] = vec2(-.102, -.17);\n    points[14] = vec2(-.25, -.31);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    float dist = length(uv);\n    \n    float speed = .75;\n    float angle = mod(-iTime * speed, 2. * PI);\n    float clippedGreen = 0.;\n\n    // draw outer ring\n    float containerRadius = .475;\n    float clipToRadius = clamp(floor(containerRadius / dist), 0., 1.);\n    float containerThickness = max(.01, .75 * (pow(clamp(texture(iChannel0, abs(uv)).r, .1, 2.), 4.)\n                                   + pow(clamp(texture(iChannel0, abs(vec2(uv.y, uv.x))).r, .1, 2.), 4.)));\n    float container = smoothstep(containerRadius + containerThickness / 2., containerRadius, dist)\n        * smoothstep(containerRadius - containerThickness / 2., containerRadius, dist);\n    \n    // draw blips\n    float blipSpeed = .075;\n    float ringThickness = .01;\n    for (int x = 0; x < 15; x++) {\n    \tfloat blipDist = distance(uv, points[x]);\n        \n    \tfloat blipAngle = mod(atan(points[x].y, points[x].x) + PI * 2., PI * 2.) - PI / 3.;\n    \tfloat angleDiff = mod(angle - blipAngle, 2. * PI);\n        \n    \tfloat blipRadius = (1. - angleDiff) * blipSpeed;\n    \n    \tfloat addend = smoothstep(blipRadius, blipRadius - ringThickness / 2., blipDist)\n        \t* pow(smoothstep(0., blipRadius - ringThickness / 2., blipDist), 3.);\n        clippedGreen += max(0., mix(addend, 0., blipRadius / blipSpeed));\n    }\n    \n    // draw line from center\n    float lineThickness = .015;\n    vec2 line = normalize(vec2(cos(angle), sin(angle)));\n    float multiply = clamp(sign(dot(uv, line)), 0., 1.);\n    float distFromLine = sqrt(pow(dist, 2.) - pow(dot(uv, line), 2.));\n    clippedGreen += pow(smoothstep(lineThickness / 2., 0., distFromLine), 3.) * multiply;\n        \n    // draw grid\n    float gridIncrement = .1;\n    float gridLineThickness = 1. /iResolution.y;\n    float gridAddend = (1. - step(gridLineThickness, mod(uv.x, gridIncrement)))\n        + (1. - step(gridLineThickness, mod(uv.y, gridIncrement)));\n    clippedGreen += gridAddend;\n        \n    // draw gradient\n    float gradientAngleAmount = PI / 2.;\n    float uvAngle = mod(atan(uv.y, uv.x) + PI * 2., PI * 2.);\n    float angleDiff = mod(uvAngle - angle, 2. * PI);\n    clippedGreen += smoothstep(gradientAngleAmount, 0., angleDiff);\n                                \n    // why doesn't changing the alpha value do anything?\n    // color.a = 0.;\n    uv.x /= iResolution.x / iResolution.y;\n    uv += .5;\n    vec4 color = texture(iChannel1, uv);\n    color.g += clippedGreen * clipToRadius + container;\n    fragColor = color;\n}", "image_inputs": [{"id": "MsBXRR", "previewfilepath": "https://soundcloud.com/binster/clockwork", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/binster/clockwork", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 123, 123, 3198]], "test": "untested"}
{"id": "Ml2czt", "name": "Flowering", "author": "Nicolas2", "description": "Drafting", "tags": ["relaxation"], "likes": 2, "viewed": 101, "published": "Public", "date": "1509882548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 O=vec2(iResolution.x/2.,iResolution.y/2.);\n    vec2 p=vec2(fragCoord.x,fragCoord.y);\n    vec2 pnorm=normalize(p-O);\n    \n    vec2 up=vec2(0,1.);\n    vec2 down=vec2(0,-1.);\n    vec2 left=vec2(1.,0.);\n    vec2 right=vec2(-1.,0.);\n    \n    \n \n       \n    float c=fract((length(p-O)+50.*dot(up,pnorm))/length(vec2(0,0)-O)*10.-iTime*0.5);\n    \n    float d=fract((length(p-O)+100.*dot(up,pnorm))/length(vec2(0,0)-O)*10.-iTime);\n    \n    float g=fract((length(p-O)+150.*dot(up,pnorm))/length(vec2(0,0)-O)*10.-iTime*2.);\n    \n   \n\tfragColor = vec4(1./c,d/2.,g,1.0);\n    \n    //fragColor = vec4(c/2.,d/3.,g,1.0);\n    \n   \n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2czt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 696]], "test": "untested"}
{"id": "Ml2yDG", "name": "PBR: Disney BRDF 2012", "author": "ref2401", "description": "Anisotropic Disney BRDF 2012, single directional light source.", "tags": ["brdf", "anisotropic", "pbr"], "likes": 12, "viewed": 1008, "published": "Public", "date": "1510249064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// References:\n//\t\tPhysically-Based Shading at Disney 2012;\n// \t\tUnderstanding the Masking-Shadowing Function in Microfacet-Based BRDFs;\n//\t\n// Single directional light source;\n// No ambient lighting;\n// No anti-aliasing (solved only sphere jagged edges);\n// One can change light's position in func called 'init_light_view_directions_ts'.\n// One can change material's params in func called 'generate_material'.\n//\n// Prefixis:\n// \t\tis \t- image space;\n// \t\tndc - normalized device coordinates space;\n// \t\tts\t- tangent space;\n\n\nconst float\tc_1_over_pi = 1.0 / 3.1415926535;\n\nstruct material {\n    vec3 \tbase_color;\n    vec3 \treflect_color;\n   \tvec2 \tlinear_roughness; \t// [0.07, 1], ggx is zero when roughness is zero.\n    float \tmetallic_mask;\t\t\n};\n    \n\nvec3 calc_diffuse_term(float dot_nl, float dot_nv, float dot_lh, vec3 base_color, float rough_s)\n{\n    float fd_90_minus_1 = 2.0 * dot_lh * dot_lh * rough_s - 0.5;\n    \n    return base_color * c_1_over_pi \n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nl, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nv, 5.0));\n}\n\n// anisotropic GGX / Trowbridge-Reitz\n//\nfloat calc_distribution_ggx(float dot_nh, float dot_ht, float dot_hb, vec2 linear_roughness)\n{\n    float rought_x \t= linear_roughness.x * linear_roughness.x;\n    float rought_y \t= linear_roughness.y * linear_roughness.y;\n    float rough_x_s = rought_x * rought_x;\n\tfloat rough_y_s = rought_y * rought_y;\n    \n\tfloat d = (dot_nh * dot_nh\n        + dot_ht * dot_ht * (1.0 / rough_x_s)\n    \t+ dot_hb * dot_hb * (1.0 / rough_y_s));\n\t\n    return c_1_over_pi * (1.0 / (rought_x * rought_y * d * d));\n}\n\nvec3 calc_fresnel_schlick(vec3 f0, float dot_vn)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - dot_vn, 5.0);\n}\n\nfloat calc_smith_lambda(float a2, float cos_angle)\n{\n    if (cos_angle < 0.01) return 0.0;\n    \n    float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n\tfloat tan_angle = sin_angle * (1.0 * cos_angle);\n\n\treturn sqrt(1.0 + a2 * tan_angle * tan_angle) * 0.5 - 0.5;\n}\n\nfloat calc_masking_shadow_factor(float dot_nl, float dot_nv, float rought_s)\n{\n    // smith correlated\n\tfloat a2 \t\t= rought_s * 0.5;\n\tfloat lambda_l \t= calc_smith_lambda(a2, dot_nl);\n\tfloat lambda_v \t= calc_smith_lambda(a2, dot_nv);\n\treturn 1.0f / (1.0 + lambda_l + lambda_v);\n}\n\nvec3 calc_specular_term(vec3 fresnel, float dot_nl, float dot_nv, float dot_nh, float dot_lh, \n                        float dot_ht, float dot_hb, vec2 linear_roughness, float rough_s)\n{\n    float v_1_over_denom = 1.0 / (4.0 * dot_nl * dot_nv);\n\n\treturn fresnel\n        * calc_distribution_ggx(dot_nh, dot_ht, dot_hb, linear_roughness)\n        * calc_masking_shadow_factor(dot_nl, dot_nv, rough_s)\n        * v_1_over_denom;\n}\n\n// Performs tone mapping and gamma corretion.\n//\nvec3 convert_hdr_to_srgb(vec3 hdr)\n{\n    const float gamma = 1.0 / 2.2;\n    \n    vec3 ldr = hdr * (1.0 / (hdr + 1.0));\t// hell of a tone mapping\n    return vec3(pow(ldr.x, gamma), \n                pow(ldr.y, gamma), \n                pow(ldr.z, gamma));\t\t\t// for some reason I could not write pow(ldr, gamma)\n}\n\nmaterial generate_material(int time_base)\n{\n    //material m = material(/* base_color */\t\tvec3(0.5),\n    //                      /* reflect_color */\t\tvec3(1.0),\n    //                      /* linear_roughness */\tvec2(0.15, 0.15),\n    //                      /* metallic_mask */\t\t0.8);\n\n    vec3 fct_bc\t\t= cos(vec3(time_base) * vec3(0.002, 0.0013, 0.0015));\n    vec4 fct_pack\t= sin(vec4(time_base) * vec4(0.005, 0.012, 0.0188, 0.0057));\n\n    material m;\n    m.base_color \t\t\t= mix(vec3(0.1), vec3(1.0), fct_bc * fct_bc);\n    m.reflect_color \t\t= mix(vec3(0.4), vec3(1.0), pow(fct_pack.x, 4.0));\n    m.linear_roughness.x \t= mix(0.11, 1.0, pow(fct_pack.y, 6.0));\n    m.linear_roughness.y \t= mix(0.11, 1.0, pow(fct_pack.z, 6.0));\n   \tm.metallic_mask \t\t= mix(0.0, 0.8, pow(fct_pack.w, 4.0));\n    \n    return m;\n}\n\n// Sets directions to the light and to the view in the tangent space \n// using the given position of a fragment.\n//\nvoid init_light_view_directions_ts(vec3 pos_ndc, int time_base, out vec3 to_light_ts, out vec3 to_view_ts)\n{\n    float x = cos(float(time_base) * 0.02);\n    float y = sin(float(time_base) * 0.01);\n    vec3 direction_to_light_ndc = normalize(vec3(x, y, 1.0));\n    \n    // compose matrix ndc -> ts.\n    vec3 t = normalize(dFdx(pos_ndc));\n    vec3 b = normalize(dFdy(pos_ndc));\n    vec3 n = normalize(cross(t, b));\n    mat3 ndc_to_ts_matrix = transpose(mat3(t, b, n));\n    \n    to_light_ts = ndc_to_ts_matrix * direction_to_light_ndc;\n    to_view_ts \t= ndc_to_ts_matrix * normalize(vec3(0, 0, 1) - pos_ndc);\n}\n    \nvoid mainImage( out vec4 frag_color, in vec2 fragCoord)\n{\n\tconst float c_radius_ndc = 0.2;\n    \n    // discard a fragment if it does not belong to the spehre.\n    // xy_is is relative to the center of the render target.\n    vec2 xy_is \t\t= gl_FragCoord.xy * (1.0 / iResolution.xy) + vec2(-0.5);\n    vec2 xy_ndc \t= xy_is * vec2(1, iResolution.y * (1.0 / iResolution.x));\n    float dist_ndc \t= length(xy_ndc);\n\n    if (dist_ndc > c_radius_ndc) discard;\n    \n    // reconstruct fragment's position on a sphere in the ndc space.\n    float z_ndc \t\t= sqrt(c_radius_ndc * c_radius_ndc + dot(xy_ndc, -xy_ndc));\n    vec3 position_ndc \t= vec3(xy_ndc.xy, z_ndc);\n    \n    // light equation's directions\n    vec3 l_ts;\n    vec3 v_ts;\n    init_light_view_directions_ts(position_ndc, iFrame, l_ts, v_ts);\n    \n    vec3 h_ts \t\t= normalize(l_ts + v_ts);\n    float dot_nl \t= clamp(l_ts.z, 0.0, 1.0);\n    float dot_nv \t= clamp(v_ts.z, 0.0, 1.0);\n    float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n    float dot_lh \t= clamp(dot(l_ts, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n    float dot_ht\t= h_ts.x;\n    float dot_hb\t= h_ts.y;\n   \n    // material params\n    material m \t\t\t= generate_material(iFrame);\n    float rough_s\t\t= dot_ht * dot_ht * m.linear_roughness.x * m.linear_roughness.x\n        \t\t\t\t+ dot_hb * dot_hb * m.linear_roughness.y * m.linear_roughness.y; // uniform roughness squared\n    vec3 reflect_color \t= 0.16 * m.reflect_color * m.reflect_color;\n    vec3 f0\t\t\t\t= mix(reflect_color, m.base_color, m.metallic_mask);\n    vec3 fresnel\t\t= calc_fresnel_schlick(f0, dot_nv);\n    \n    // lighting\n    vec3 diffuse_factor\t\t= (1.0 - fresnel) * (1.0 - m.metallic_mask);\n    vec3 diffuse_term \t\t= diffuse_factor * calc_diffuse_term(dot_nl, dot_nv, dot_lh, m.base_color, rough_s);\n   \tvec3 specular_term \t\t= calc_specular_term(fresnel, dot_nl, dot_nv, dot_nh, dot_lh, \n                                             dot_ht, dot_hb, m.linear_roughness, rough_s);    \n   \n    vec3 hdr\t= (diffuse_term + specular_term) * dot_nl;\n    vec3 srgb \t= convert_hdr_to_srgb(hdr);\n    \n    // interpolate between black color and srgb value to get rid of those nasty jagged edges.\n    const float c_radius_falloff_start_ndc = c_radius_ndc - 0.007;\n    float mix_factor\t= (c_radius_falloff_start_ndc - dist_ndc) / (c_radius_ndc - dist_ndc);\n    vec3 final_color\t= mix(vec3(0.0), srgb, mix_factor);\n    \n\tfrag_color = vec4(final_color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml2yDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 754, 852, 852, 1076], [1078, 1119, 1213, 1213, 1614], [1616, 1616, 1666, 1666, 1718], [1720, 1720, 1772, 1772, 1985], [1987, 1987, 2065, 2089, 2265], [2267, 2267, 2453, 2453, 2692], [2694, 2743, 2779, 2779, 3052], [3054, 3054, 3097, 3338, 3859], [3861, 3977, 4085, 4085, 4583], [4589, 4589, 4646, 4646, 6993]], "test": "untested"}
{"id": "MlBcDy", "name": "I tried to edit Deep Realms xD", "author": "Imsure1200q_1UWE130", "description": "idk", "tags": ["deeprealm"], "likes": 1, "viewed": 365, "published": "Public API", "date": "1509984975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.141592653589793238462643383;\n\n#ifdef GL_FRAGMENT_PRECISICION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nfloat map(vec3 p)\n{\n    float time = iTime;\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    // length(max(vec3(dot(cos(p), sin(p))), cos(p))*2.0-1.0) - 3.0;\n    return length(sin(p)*dot(cos(p),tan(p))*2.0-1.0)-3.0;\n}\nvec3 trace(vec2 uv)\n{\n    float time = iTime;\n    float t = 0.0;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.xz *= mat2(cos(time/2.0), -sin(time/2.0), sin(time/2.0), cos(time/2.0));\n    vec3 ro = vec3(cos(time)+iTime/2., sin(6.0)-3., sin(time));\n    for(int i = 0; i < 24; i++)\n    {\n        vec3 p = ro+t*rd;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    float fog = 1.0/(1.0+t*t*0.1);\n    vec3 fc = vec3(fog);\n    return fc;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 p = normalize(vec3(uv, 1.0));\n    vec3 x = trace(uv);\n\tfragColor = vec4( cos(uv.y) ) +\n        sin(p.z)/2.\n        *vec4(.5,.2,0.,1.)\n        +vec4(0.25,0.25,0.,1.)\n        -vec4(x, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 160, 160, 361], [362, 362, 383, 383, 873], [874, 874, 931, 931, 1196]], "test": "untested"}
{"id": "MlByR3", "name": "3D Cube", "author": "nhoughto", "description": "Cube, 3D", "tags": ["3d", "floating", "rotatingcube"], "likes": 2, "viewed": 561, "published": "Public", "date": "1509545926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Referencing the tutorial here: http://fabricecastel.github.io/blog/2016-02-11/main.html\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nconst float S = 0.01;\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    float s = 1.0;\n    vec3 q = abs(p) - vec3(s);\n    float dist = max(max(q.x, q.y), q.z);\n    if(q.x > 0.0 && q.y > 0.0 && q.z > 0.0){\n        dist = length(q);\n    }\n    return dist;\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n    \tdistanceToNearestSurface(p + deltax)-d,\n        distanceToNearestSurface(p + deltay)-d,\n        distanceToNearestSurface(p + deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n                \nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime),\n                             \t30.0 * cos(iTime),\n                              \t30.0 * cos(iTime));\n            return computeLambert(hit, computeSurfaceNormal(hit), light);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n  \t// camera attributes\n    // cameraDirection and cameraUp MUST be normalized\n    // (ie. their length must be equal to 1)\n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(cameraDistance * sin(iTime), 0.2 * cameraDistance * cos(iTime), cameraDistance * cos(iTime));\n    vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0 * cos(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n\tvec3 pixelColor = intersectsWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlByR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 337, 376, 376, 564], [566, 566, 600, 600, 820], [822, 822, 866, 866, 909], [927, 927, 970, 970, 1489], [1491, 1491, 1548, 1548, 2517]], "test": "untested"}
{"id": "MlByRc", "name": "Live Goo toon texture", "author": "rafaelcastrocouto", "description": "\n", "tags": ["cell"], "likes": 3, "viewed": 92, "published": "Public", "date": "1509492872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 1.0\n// #define SMOOTH 1\n#define NUM_NOISE_OCTAVES 4\n\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return  /*(sin(iTime*3.0*SPEED)*0.02) +*/ fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfloat shift = float(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 0.2;\n    float limit = 0.5 + (sin(iTime*10.0)*0.001);\n    float border = 0.02;\n    float t = iTime*0.8;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float vo = voronoi2D(((1.0/size) * uv ));\n    \n    vec2 coord = fragCoord.xy / 50.0;\n    \n    float c = fbm(vec2(vo/1.0 - coord.x + t,  coord.y  ));\n    vec3 color = vec3(step(limit-border,c), step(limit+border, c), 1);\n    if (color.x == 1.0 && color.y == 1.0 && color.z == 1.0)  { color = vec3(0.8, 0.05, 0.05); }\n    else if (color.x == 1.0 && color.y != 1.0 && color.x == 1.0) { color = vec3(0.5, 0.05, 0.05); }\n    else { color = vec3(0.2, 0.05, 0.05); }\n    \n#ifdef SMOOTH\n    c = smoothstep(limit - border, limit, c) - smoothstep(limit, limit + border, c);\n    fragColor = vec4(c * c * c, 0.25 + 0.75 * c * c, 0.5 + 0.5 * c, 1.0);\n#else\n    fragColor.rgb = clamp(color, 0.0, 1.0);\n  //  fragColor.rgb = clamp(vec3(c,c,c), 0.0, 1.0);\n#endif\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlByRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 67, 88, 88, 118], [119, 119, 139, 139, 262], [264, 264, 286, 286, 418], [419, 419, 440, 440, 1074], [1077, 1077, 1097, 1097, 1275], [1276, 1276, 1295, 1295, 1572], [1576, 1576, 1602, 1602, 1978], [1980, 1980, 2037, 2037, 2959]], "test": "untested"}
{"id": "MlffW8", "name": "SDF Raymarch Quadtree", "author": "paniq", "description": "subdividing screen space where a tile is crossing the contour of a distance field", "tags": ["raymarch", "sdf", "quadtree"], "likes": 38, "viewed": 1318, "published": "Public API", "date": "1511725075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\nfloat sdUnterprim(vec3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    vec3 d = abs(p) - s.xyz;\n    float q = length(max(d.xy, 0.0)) + min(0.0,max(d.x,d.y)) - r.x;\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = abs(q) - s.w;\n#endif\n    \n    vec2 pa = vec2(q, p.z - s.z);\n    vec2 diag = pa - vec2(r.z,sz2) * clamp(dot(pa,ba), 0.0, 1.0);\n    vec2 h0 = vec2(max(q - r.z,0.0),p.z + s.z);\n    vec2 h1 = vec2(max(q,0.0),p.z - s.z);\n    \n    return sqrt(min(dot(diag,diag),min(dot(h0,h0),dot(h1,h1))))\n        * sign(max(dot(pa,vec2(-ba.y, ba.x)), d.z)) - r.y;\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nfloat sdUberprim(vec3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat doobject (vec3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return  sdUberprim(p.zyx, mix(sa,sb,u), mix(ra,rb,u));\n}\n\nbool interior;\n\nfloat doModel( vec3 p ) {\n    float k = iTime*0.5;\n    float d = doobject(p - vec3(0.0,0.0,-0.5), k);\n    float d2 = doobject(p - vec3(0.0,0.0,0.5), k + 1.0);\n    if (interior)\n    \td = min(d, d2);\n   \telse\n    \td = smin(d, d2, 0.4);\n    \n    return d;\n}\n\nfloat calcIntersection( in float t, in vec3 ro, in vec3 rd, vec2 pixel, float bias, inout int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = 0.7071067811866 * max(pixel.y,pixel.x);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n\tfloat res = -1.0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    t = t * C;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = steps + 1;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;\n\t    float h = doModel( ro+rd*t );\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res / C;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( inout float dist, inout int steps, out vec3 position, in vec2 p, in vec2 pixel, in float bias)\n{\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( dist, ro, rd, pixel, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 c0 = vec2(-2.0,-2.0);\n    vec2 c1 = vec2(2.0,2.0);\n    const int N = 9;\n    vec3 color = vec3(0.1);\n    int steps = 0;\n    float dist = 0.0;\n    for (int i = 0; i <= N; ++i) {\n        vec2 c = (c0 + c1)*0.5;\n        vec2 h = (c1 - c0)*0.5;\n        if (p.x < c.x) {\n            c1.x = c.x;\n        } else {\n            c0.x = c.x;\n        }\n        if (p.y < c.y) {\n            c1.y = c.y;\n        } else {\n            c0.y = c.y;\n        }\n        vec2 u = vec2(c0.x,c1.x);\n        vec2 v = vec2(c0.y,c1.y);\n        \n        vec2 center = vec2(u.y + u.x, v.y + v.x)*0.5;\n        vec2 radius = vec2(u.y - u.x, v.y - v.x)*0.5;\n        \n        vec3 pos;\n        bool outer_hit = dorender(dist, steps, pos, center, radius, 1.0);\n        float dist2 = dist;\n        bool inner_hit = dorender(dist2, steps, pos, center, radius, -1.0);\n        if (!outer_hit || inner_hit || (i == N)) {\n            color = normhue(float(steps)/float(MAX_STEPS * N));\n            float q = abs(max(abs(p.x - center.x), abs(p.y - center.y)) - radius.x)-0.0001;\n            q = clamp(q*200.0, 0.0, 1.0);\n            color *= vec3(q);\n            break;\n        }\n    }    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlffW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 139, 202, 202, 735], [737, 837, 879, 922, 1123], [1125, 1171, 1219, 1232, 2090], [2092, 2092, 2175, 2175, 2298], [2300, 2300, 2327, 2327, 2362], [2364, 2400, 2441, 2441, 2534], [2536, 2536, 2570, 2570, 2867], [2885, 2885, 2910, 2910, 3139], [3141, 3141, 3244, 3244, 4144], [4146, 4146, 4178, 4178, 4589], [4591, 4591, 4655, 4655, 4833], [4835, 4835, 4946, 5104, 5731], [5733, 5733, 5759, 5759, 5844], [5846, 5894, 5919, 5919, 5977], [5980, 5980, 6036, 6036, 7290]], "test": "untested"}
{"id": "MljcWd", "name": "Lazer Beamz", "author": "digorydoo", "description": "A simple screensaver-like effect.", "tags": ["2d", "simple", "screensaver"], "likes": 1, "viewed": 157, "published": "Public", "date": "1510674648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distanceToLine (vec2 s, vec2 p, vec2 q)\n{\n    return abs ((q.y - p.y) * s.x - (q.x - p.x) * s.y \n        + q.x * p.y - q.y * p.x) / distance (p, q);\n}\n\nfloat triangle (vec2 pos, float t, float val, float step)\n{\n    float t1 = t * 0.523;\n    float t2 = t * 0.645;\n    float t3 = t * 0.779;\n    \n    vec2 p1 = 0.5 + 0.5 * vec2 (cos (t1      ), sin (t2      ));\n    vec2 p2 = 0.5 + 0.5 * vec2 (cos (t2 + 1.0), sin (t3 + 1.0));\n    vec2 p3 = 0.5 + 0.5 * vec2 (cos (t3 + 2.0), sin (t1 + 2.0));\n\n    float d = distanceToLine (pos, p1, p2);\n    val += d < 0.01 ? step : 0.0;\n\n    d = distanceToLine (pos, p2, p3);\n    val += d < 0.01 ? step : 0.0;\n    \n    d = distanceToLine (pos, p3, p1);\n    val += d < 0.01 ? step : 0.0;\n    \n    return val;\n}\n\nvec3 Red     = vec3 (1.0, 0.0, 0.0);\nvec3 Yellow  = vec3 (1.0, 1.0, 0.0);\nvec3 Green   = vec3 (0.0, 1.0, 0.0);\nvec3 Cyan    = vec3 (0.0, 1.0, 1.0);\nvec3 Blue    = vec3 (0.0, 0.0, 1.0);\nvec3 Magenta = vec3 (1.0, 0.0, 1.0);\n\nvec3 hue (float t)\n{\n    float f = 1.0 / 6.0;\n    \n    if (t < f)\n    {\n        return mix (Red, Yellow, t / f);\n    }\n    else if (t < 2.0 * f)\n    {\n        return mix (Yellow, Green, (t - f) / f);\n    }\n    else if (t < 3.0 * f)\n    {\n        return mix (Green, Cyan, (t - 2.0 * f) / f);\n    }\n    else if (t < 4.0 * f)\n    {\n        return mix (Cyan, Blue, (t - 3.0 * f) / f);\n    }\n    else if (t < 5.0 * f)\n    {\n        return mix (Blue, Magenta, (t - 4.0 * f) / f);\n    }\n    else\n    {\n        return mix (Magenta, Red, (t - 5.0 * f) / f);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = iResolution.xy;\n    vec2 pos = (fragCoord - 0.5 * res) / res.y + 0.5;\n\n    float val = 0.0;\n\n    for (float f = 0.0; f < 10.0; f++)\n    {\n        val += triangle (pos, iTime + f*0.05, val, 0.01 * f / 10.0);\n    }\n    \n    val = min (1.0, val);\n    val = 1.0 - (1.0 - val) * (1.0 - val);\n\n\tfragColor = vec4(val * hue (0.5 + 0.5 * sin (iTime + val)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 156], [158, 158, 217, 217, 747], [972, 972, 992, 992, 1528], [1530, 1530, 1587, 1587, 1956]], "test": "untested"}
{"id": "MljyRt", "name": "Space Glowing 3", "author": "tholzer", "description": "A variant of 'Space Glowing 2' seen through a koleidoscope.\nSymmetry defined by Mouse.y position.\nAgain ... switch to full screen and lean back!", "tags": ["3d", "antialiasing", "space", "raytrace", "glowing", "satiny"], "likes": 13, "viewed": 272, "published": "Public", "date": "1509840878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------------------\n// SpaceGlowing3.glsl  by Antony Holzer \n//\n// A variant of 'Space Glowing 2' seen through a koleidoscope.\n// Symmetry defined by Mouse.y position.\n// Again ... switch to full screen and lean back!\n//\n//   v1.0  2017-11-05  initial release\n//   v2.0  2017-11-22  variable symmetry \n//\n// variantOf: https://www.shadertoy.com/view/ldjBRW\n// see also:  https://www.shadertoy.com/view/Mlj3zW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// tags:      3d, antialiasing, space, raytrace, glowing, satiny\n//----------------------------------------------------------------\n\nvec3 rotateY(vec3 p, float angle)\n{\n  float sa = sin(angle),   ca = cos(angle);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n//----------------------------------------------------------------\nfloat map (in vec3 p) \n{\n\tvec3 c = p; \n    float res = 0.0;\n\tfor (int i=0; i < 4; i++) \n\t{\n\t\tp = abs(p) / dot(p,p) -0.7;\n\t\tp.yz = vec2(p.y*p.y-p.z*p.z, 2.*p.y*p.z);\n\t\tres += exp(-20.0 * abs(dot(p,c)));\n\t}\n\treturn res * 0.4;\n}\n\n//----------------------------------------------------------------\nvec3 raymarch (vec3 ro, vec3 rd)\n{\n\tfloat t = 5.0;\n    float c = 0.0;\n\tvec3 col = vec3(0.0); \n\tfor (int i=0; i < 6; i++)\n\t{\n\t\tt += exp(c * -2.0) * 0.02;\n\t\tc = map(t * rd + ro);               \n\t\tcol= vec3(22.0*c*c, 2.0*c, 6.0*c*c*c) *0.16 + col *0.6;\n\t\tc = map(t*0.99 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 22.0*c*c, c) *0.16 + col *0.6;\n\t\tc = map(t*1.01 * rd + ro);               \n\t\tcol+= vec3(4.0*c*c, 8.0*c*c, 11.*c)*0.16 + col *0.6;\n         // blue\n//\t\tcol= vec3(c*c, c, 6.0*c*c*c) *0.16 + col *0.96;\n\t\tcol= vec3(8.0*c*c*c, 2.0*c*c, 8.0*c) *0.16 + col *0.96;\n\t\tcol= vec3(c, 18.0*c*c*c, 8.0*c*c)*0.16 + col *0.96;\n\t\t\n\t}\n\treturn col*0.2;\n}\n\n//----------------------------------------------------------------\n\nconst float PI = 3.14159265359;\n\n//float sideCount = 1.0;  // min. number of sides\n\n//----------------------------------------------------------------\n// equal to koleidoscope, but more compact \n//----------------------------------------------------------------\nvoid smallKoleidoscope(inout vec2 uv, float ka)\n{\n  float angle = abs (mod (atan (uv.x, uv.y), 2.0 * ka) - ka) + 0.01*iTime;\n  uv = length(uv) * vec2(cos(angle), sin(angle));\n}\n\n//----------------------------------------------------------------\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = 2.0*(fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 mp = iMouse.xy / iResolution.xy;\n        \n    float sideCount = 1.0 + round(mp.y * 11.0);\n    \n    smallKoleidoscope(p, PI / sideCount);    \n    \n    vec3 ro = rotateY(vec3(3.), iTime*0.2 + iMouse.x / iResolution.x);\n    vec3 uu = normalize(cross(ro, vec3(1.0, 0.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ro));\n    vec3 rd = normalize(p.x*uu + p.y*vv - ro*0.5);\n    fragColor.rgb = log(raymarch(ro,rd) + 1.0)*0.5;\n    fragColor.a = 1.0;\n}\n", "image_inputs": [{"id": "4sBSRz", "previewfilepath": "https://soundcloud.com/patrik-cybercom-detter/jarre-mix-jean-michel-jarre", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/patrik-cybercom-detter/jarre-mix-jean-michel-jarre", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljyRt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 676, 711, 711, 820], [822, 889, 913, 913, 1114], [1116, 1183, 1217, 1217, 1834], [1988, 2166, 2215, 2215, 2342], [2344, 2411, 2467, 2467, 2988]], "test": "untested"}
{"id": "MllBD4", "name": "1/2, 1", "author": "Warezovvv", "description": "15 shaders in a row. This is first one.", "tags": ["learning"], "likes": 1, "viewed": 382, "published": "Public API", "date": "1511947929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nfloat sdSphere(vec3 p, float r);\n\n\nfloat opRepSphere( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c) - .5 * c;\n    return sdSphere(q + vec3(0, sin(iTime + length(q)), 0), 1.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udBox(vec3 p, vec3 b) {\n  return length(max(abs(p)-b, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    vec3 dist = vec3(sin(0.5 * p.x), sin(3. * p.y), sin(0.5 * p.z));\n    return length(p) + length(dist) - r;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 b = vec3(0.2, 0.2, 0.2);\n    float res = sdPlane(p);\n    res = smin(res, opRepSphere(p, vec3(2.0, 0.0, 2.0)), 0.9);\n    //res = max(res, -opRepSphere(p, vec3(4.0, 0.0, 4.0)));\n    return res;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n       \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0, 2.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n\tfloat dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0, 0, 0);\n    vec3 K_d = vec3(1, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 0.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 196, 196, 296], [298, 298, 339, 339, 432], [434, 434, 463, 463, 502], [504, 504, 537, 537, 649], [651, 651, 674, 674, 692], [694, 694, 718, 718, 921], [923, 923, 1014, 1014, 1320], [1330, 1330, 1395, 1395, 1527], [1529, 1529, 1558, 1558, 1868], [1870, 1870, 2010, 2010, 2600], [2602, 2602, 2687, 2687, 3487], [3489, 3489, 3538, 3573, 3799], [3801, 3801, 3858, 3858, 4593]], "test": "untested"}
{"id": "MllBDN", "name": "Walls Wave", "author": "aiekick", "description": "mouse for control : x,y => count bars / bar height", "tags": ["wave", "wall"], "likes": 8, "viewed": 541, "published": "Public API", "date": "1511974265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// link : https://www.shadertoy.com/view/XllBW4\n\nfloat path(float x, float t)\n{\n\treturn cos(x*2.) + cos(x + sin(x * 3.) * 5.) * 0.2 + sin(x * 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat n = 10. + 30. * iMouse.x / iResolution.x;\n   \tfloat s = 0.1 + 0.3 * iMouse.y / iResolution.y;\n    \n    if (iMouse.x == 0.) n = 10.;\n    if (iMouse.y == 0.) s = 0.3;\n    \n    float t = iTime * 2.;\n    \n    vec2 v = (fragCoord.xy*2. - iResolution.xy) / iResolution.y;\n    v.x *= 0.5;\n    \n    //v.x += t * 0.1;\n    \n    vec2 mv = v;\n\t\n    float offsetX = t * 0.5;\n    float offsetY = 0.5;\n    \n    v.x += offsetX;\n    v.y += path(v.x,t) * 0.3 + offsetY;\n    float line = 1e-4 / v.y / v.y;\n\t \n\tmv.y += path(floor(mv.x*n)/n+offsetX,t) * 0.3 + offsetY;\n\tmv.x = mod(mv.x, 1.0/n)-0.5/n;\n\t\n\tfloat rect = length(max(abs(mv) - vec2(0.4/n,s),0.0));\n\trect = smoothstep(0.01,0.0,rect);\n    \n\tfragColor = vec4(rect - line);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 205, 235, 235, 304], [306, 306, 363, 363, 1082]], "test": "untested"}
{"id": "MllBR7", "name": "M.A.M. Stairs", "author": "leon", "description": "Another raymarching sketch inspired by Marc-Antoine Mathieu.", "tags": ["stairs", "book"], "likes": 46, "viewed": 966, "published": "Public", "date": "1511521892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// M.A.M. Stairs by Leon Denise aka ponk\n// another raymarching sketch inspired by Marc-Antoine Mathieu.\n// using code from IQ, Mercury, LJ, Duke, Koltes\n// made with Atom Editor GLSL viewer (that's why there is 2 space tabulations)\n// 2017-11-24\n\n#define STEPS 50.\n#define VOLUME 0.01\n#define PI 3.14159\n#define TAU (2.*PI)\n#define time iTime\n#define repeat(v,c) (mod(v,c)-c/2.)\n#define sDist(v,r) (length(v)-r)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(32.649,321.547)))*43415.); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat aindex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); return mix(c,abs(c),step(count*.5,abs(c))); }\nfloat map (vec3);\nvec3 getNormal (vec3 p) { vec2 e = vec2(.001,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }\nfloat hardShadow (vec3 pos, vec3 light) {\n    vec3 dir = normalize(light - pos);\n    float maxt = length(light - pos);\n    float t = .02;\n    for (float i = 0.; i <= 1.; i += 1./30.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return 1.;\n}\n\nfloat map (vec3 pos) {\n  float scene = 1000.;\n  float wallThin = .2;\n  float wallRadius = 8.;\n  float wallOffset = .2;\n  float wallCount = 10.;\n  float floorThin = .1;\n  float stairRadius = 5.;\n  float stairHeight = .4;\n  float stairCount = 40.;\n  float stairDepth = .31;\n  float bookCount = 100.;\n  float bookRadius = 9.5;\n  float bookSpace = 1.75;\n  vec3 bookSize = vec3(1.,.2,.2);\n  vec3 panelSize = vec3(.03,.2,.7);\n  vec2 cell = vec2(1.4,3.);\n  float paperRadius = 4.;\n  vec3 paperSize = vec3(.3,.01,.4);\n  vec3 p;\n\n  // move it\n  pos.y += time;\n\n  // twist it\n  // pos.xz *= rot(pos.y*.05+time*.1);\n  // pos.xz += normalize(pos.xz) * sin(pos.y*.5+time);\n\n  // holes\n  float holeWall = sDist(pos.xz, wallRadius);\n  float holeStair = sDist(pos.xz, stairRadius);\n\n  // walls\n  p = pos;\n  amod(p.xz, wallCount);\n  p.x -= wallRadius;\n  scene = min(scene, max(-p.x, abs(p.z)-wallThin));\n  scene = max(scene, -sDist(pos.xz, wallRadius-wallOffset));\n\n  // floors\n  p = pos;\n  p.y = repeat(p.y, cell.y);\n  float disk = max(sDist(p.xz, 1000.), abs(p.y)-floorThin);\n  disk = max(disk, -sDist(pos.xz, wallRadius));\n  scene = min(scene, disk);\n\n  // stairs\n  p = pos;\n  float stairIndex = amod(p.xz, stairCount);\n  p.y -= stairIndex*stairHeight;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  float stair = sdBox(p, vec3(100,stairHeight,stairDepth));\n  scene = min(scene, max(stair, max(holeWall, -holeStair)));\n  p = pos;\n  p.xz *= rot(PI/stairCount);\n  stairIndex = amod(p.xz, stairCount);\n  p.y -= stairIndex*stairHeight;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  stair = sdBox(p, vec3(100,stairHeight,stairDepth));\n  scene = min(scene, max(stair, max(holeWall, -holeStair)));\n  p = pos;\n  p.y += stairHeight*.5;\n  p.y -= stairHeight*stairCount*atan(p.z,p.x)/TAU;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  scene = min(scene, max(max(sDist(p.xz, wallRadius), abs(p.y)-stairHeight), -holeStair));\n\n  // books\n  p = pos;\n  p.y -= cell.y*.5;\n  vec2 seed = vec2(floor(p.y/cell.y), 0);\n  p.y = repeat(p.y, cell.y);\n  p.xz *= rot(PI/wallCount);\n  seed.y += amod(p.xz, wallCount)/10.;\n  seed.y += floor(p.z/(bookSize.z*bookSpace));\n  p.z = repeat(p.z, bookSize.z*bookSpace);\n  float salt = rng(seed);\n  bookSize.x *= .5+.5*salt;\n  bookSize.y += salt;\n  bookSize.z *= .5+.5*salt;\n  p.x -= bookRadius + wallOffset;\n  p.x += cos(p.z*2.) - bookSize.x - salt * .25;\n  p.x += .01*smoothstep(.99,1.,sin(p.y*(1.+10.*salt)));\n  scene = min(scene, max(sdBox(p, vec3(bookSize.x,100.,bookSize.z)), p.y-bookSize.y));\n\n  // panel\n  p = pos;\n  p.y = repeat(p.y, cell.y);\n  p.xz *= rot(PI/wallCount);\n  amod(p.xz, wallCount);\n  p.x -= wallRadius;\n  float panel = sdBox(p, panelSize);\n  float pz = p.z;\n  p.z = repeat(p.z, .2+.3*salt);\n  panel = min(panel, max(sdBox(p, vec3(.1,.1,.04)), abs(pz)-panelSize.z*.8));\n  scene = min(scene, panel);\n\n  // papers\n  p = pos;\n  p.y -= stairHeight;\n  p.y += time*2.;\n  p.xz *= rot(PI/stairCount);\n  float ry = 8.;\n  float iy = floor(p.y/ry);\n  salt = rng(vec2(iy));\n  float a = iy;\n  p.xz -= vec2(cos(a),sin(a))*paperRadius;\n  p.y = repeat(p.y, ry);\n  p.xy *= rot(p.z);\n  p.xz *= rot(PI/4.+salt+time);\n  scene = min(scene, sdBox(p, paperSize));\n\n  return scene;\n}\n\nvec3 getCamera (vec3 eye, vec2 uv) {\n  vec3 lookAt = vec3(0.);\n  float click = clamp(iMouse.w,0.,1.);\n  lookAt.x += mix(0.,((iMouse.x/iResolution.x)*2.-1.) * 10., click);\n  lookAt.y += mix(0.,iMouse.y/iResolution.y * 10., click);\n  float fov = .65;\n  vec3 forward = normalize(lookAt - eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(fov * forward + uv.x * right + uv.y * up);\n}\n\nfloat getLight (vec3 pos, vec3 eye) {\n  vec3 light = vec3(-.5,7.,1.);\n  vec3 normal = getNormal(pos);\n  vec3 view = normalize(eye-pos);\n  float shade = dot(normal, view);\n  shade *= hardShadow(pos, light);\n  return shade;\n}\n\nvec4 raymarch () {\n  vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float dither = rng(uv+fract(time));\n  vec3 eye = vec3(0,5,-4.5);\n  vec3 ray = getCamera(eye, uv);\n  vec3 pos = eye;\n  float shade = 0.;\n  for (float i = 0.; i <= 1.; i += 1./STEPS) {\n    float dist = map(pos);\n\t\tif (dist < VOLUME) {\n\t\t\tshade = 1.-i;\n\t\t\tbreak;\n\t\t}\n    dist *= .5 + .1 * dither;\n    pos += ray * dist;\n  }\n\n  vec4 color = vec4(shade);\n  color *= getLight(pos, eye);\n  color = smoothstep(.0, .5, color);\n  color = sqrt(color);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = raymarch();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 415, 435, 435, 485], [486, 486, 509, 509, 575], [576, 576, 607, 607, 690], [691, 691, 731, 731, 919], [920, 920, 956, 956, 1078], [1097, 1097, 1122, 1122, 1250], [1251, 1251, 1292, 1292, 1586], [1588, 1588, 1610, 1610, 4772], [4774, 4774, 4810, 4810, 5229], [5231, 5231, 5268, 5268, 5454], [5456, 5456, 5474, 5474, 5998], [6000, 6000, 6057, 6057, 6084]], "test": "untested"}
{"id": "MllBRM", "name": "Hypnose_moiré", "author": "frZ", "description": "some trigonometrical moiré deformation", "tags": ["deformation", "trigonometry", "graphic"], "likes": 2, "viewed": 2661, "published": "Public API", "date": "1511452427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv += vec2(0.5);\n    uv *= 7.0;\n    \n    float t = iTime;\n    uv *= (sin(uv + t));\n\n    float M = sin(uv.x*uv.y + sin(t));\n    \n\tfragColor = vec4(vec3(M),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 265]], "test": "untested"}
{"id": "MllBRr", "name": "Value noise - 1D 2D 3D 4D", "author": "afl_ext", "description": "Finally I was able to craft these monsters from scratch. Do whatever you want. I just got bored seeing IQ noise everywhere.", "tags": ["procedural", "2d", "3d", "noise", "4d", "1d", "value"], "likes": 8, "viewed": 1016, "published": "Public API", "date": "1510842788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nCopyright afl_ext\nReleased to PUBLIC DOMAIN\n\ncontains 1d 2d 3d 4d noises with the same characteristics\ndo whatever you want.\n\n*/\n\n\nfloat oct(float p){\n\treturn fract(4768.1232345456 * sin(p));\n}\nfloat oct(vec2 p){\n\treturn fract(4768.1232345456 * sin((p.x+p.y*43.0)));\n}\nfloat oct(vec3 p){\n\treturn fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\nfloat oct(vec4 p){\n\treturn fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0+p.w*2666.0)));\n}\n\nfloat achnoise(float x){\n\tfloat p = floor(x);\n\tfloat fr = fract(x);\n\tfloat L = p;\n\tfloat R = p + 1.0;\n\t\n\tfloat Lo = oct(L);\n\tfloat Ro = oct(R);\n\t\n\treturn mix(Lo, Ro, fr);\n} \n\nfloat achnoise(vec2 x){\n\tvec2 p = floor(x);\n\tvec2 fr = fract(x);\n\tvec2 LB = p;\n\tvec2 LT = p + vec2(0.0, 1.0);\n\tvec2 RB = p + vec2(1.0, 0.0);\n\tvec2 RT = p + vec2(1.0, 1.0);\n\t\n\tfloat LBo = oct(LB);\n\tfloat RBo = oct(RB);\n\tfloat LTo = oct(LT);\n\tfloat RTo = oct(RT);\n\t\n\tfloat noise1d1 = mix(LBo, RBo, fr.x);\n\tfloat noise1d2 = mix(LTo, RTo, fr.x);\n\t\n\tfloat noise2d = mix(noise1d1, noise1d2, fr.y);\n\t\n\treturn noise2d;\n} \nfloat achnoise(vec3 x){ \n\tvec3 p = floor(x);\n\tvec3 fr = fract(x);\n\tvec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n\tvec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n\tvec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n\tvec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\t                   \n\tvec3 LBF = p + vec3(0.0, 0.0, 1.0);\n\tvec3 LTF = p + vec3(0.0, 1.0, 1.0);\n\tvec3 RBF = p + vec3(1.0, 0.0, 1.0);\n\tvec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\t\n\tfloat l0candidate1 = oct(LBZ);\n\tfloat l0candidate2 = oct(RBZ);\n\tfloat l0candidate3 = oct(LTZ);\n\tfloat l0candidate4 = oct(RTZ);\n\t\n\tfloat l0candidate5 = oct(LBF);\n\tfloat l0candidate6 = oct(RBF);\n\tfloat l0candidate7 = oct(LTF);\n\tfloat l0candidate8 = oct(RTF);\n\t\n\tfloat l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n\tfloat l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n\tfloat l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n\tfloat l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\t\n\t\n\tfloat l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n\tfloat l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\t\n\t\n\tfloat l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\t\n\treturn l3candidate1;\n} \n\n\nfloat achnoise(vec4 x){ \n\tvec4 p = floor(x);\n\tvec4 fr = fract(x);\n\tvec4 LBZU = p + vec4(0.0, 0.0, 0.0, 0.0);\n\tvec4 LTZU = p + vec4(0.0, 1.0, 0.0, 0.0);\n\tvec4 RBZU = p + vec4(1.0, 0.0, 0.0, 0.0);\n\tvec4 RTZU = p + vec4(1.0, 1.0, 0.0, 0.0);\n\t                 \n\tvec4 LBFU = p + vec4(0.0, 0.0, 1.0, 0.0);\n\tvec4 LTFU = p + vec4(0.0, 1.0, 1.0, 0.0);\n\tvec4 RBFU = p + vec4(1.0, 0.0, 1.0, 0.0);\n\tvec4 RTFU = p + vec4(1.0, 1.0, 1.0, 0.0);\n\t                 \n\tvec4 LBZD = p + vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 LTZD = p + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 RBZD = p + vec4(1.0, 0.0, 0.0, 1.0);\n\tvec4 RTZD = p + vec4(1.0, 1.0, 0.0, 1.0);\n\t                 \n\tvec4 LBFD = p + vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 LTFD = p + vec4(0.0, 1.0, 1.0, 1.0);\n\tvec4 RBFD = p + vec4(1.0, 0.0, 1.0, 1.0);\n\tvec4 RTFD = p + vec4(1.0, 1.0, 1.0, 1.0);\n\t\n\tfloat l0candidate1  = oct(LBZU);\n\tfloat l0candidate2  = oct(RBZU);\n\tfloat l0candidate3  = oct(LTZU);\n\tfloat l0candidate4  = oct(RTZU);\n\t\n\tfloat l0candidate5  = oct(LBFU);\n\tfloat l0candidate6  = oct(RBFU);\n\tfloat l0candidate7  = oct(LTFU);\n\tfloat l0candidate8  = oct(RTFU);\n\t\n\tfloat l0candidate9  = oct(LBZD);\n\tfloat l0candidate10 = oct(RBZD);\n\tfloat l0candidate11 = oct(LTZD);\n\tfloat l0candidate12 = oct(RTZD);\n\t\n\tfloat l0candidate13 = oct(LBFD);\n\tfloat l0candidate14 = oct(RBFD);\n\tfloat l0candidate15 = oct(LTFD);\n\tfloat l0candidate16 = oct(RTFD);\n\t\n\tfloat l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n\tfloat l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n\tfloat l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n\tfloat l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\tfloat l1candidate5 = mix(l0candidate9, l0candidate10, fr[0]);\n\tfloat l1candidate6 = mix(l0candidate11, l0candidate12, fr[0]);\n\tfloat l1candidate7 = mix(l0candidate13, l0candidate14, fr[0]);\n\tfloat l1candidate8 = mix(l0candidate15, l0candidate16, fr[0]);\n\t\n\t\n\tfloat l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n\tfloat l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\tfloat l2candidate3 = mix(l1candidate5, l1candidate6, fr[1]);\n\tfloat l2candidate4 = mix(l1candidate7, l1candidate8, fr[1]);\n\t\n\t\n\tfloat l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\tfloat l3candidate2 = mix(l2candidate3, l2candidate4, fr[2]);\n\t\n\tfloat l4candidate1 = mix(l3candidate1, l3candidate2, fr[3]);\n\t\n\treturn l4candidate1;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tvec2 position = (uv) * 100.0;\n\n\tfloat color = 0.0;\n\t\n\tif(uv.x < 0.5 && uv.y < 0.5){\n\t\tcolor = achnoise(position.x);\t\n\t}\n\telse if(uv.x > 0.5 && uv.y < 0.5){\n\t\tcolor = achnoise(position);\t\n\t}\n\telse if(uv.x < 0.5 && uv.y > 0.5){\n\t\tcolor = achnoise(vec3(position, iTime));\t\n\t}\n\telse if(uv.x > 0.5 && uv.y > 0.5){\n\t\tcolor = achnoise(vec4(position, iMouse.x / iResolution.x, iTime));\t\n\t}\n\tfragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBRr.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[1, 135, 154, 154, 197], [198, 198, 216, 216, 272], [273, 273, 291, 291, 357], [358, 358, 376, 376, 453], [455, 455, 479, 479, 627], [630, 630, 653, 653, 1042], [1044, 1044, 1067, 1067, 2156], [2160, 2160, 2183, 2183, 4497], [4500, 4500, 4557, 4557, 5021]], "test": "untested"}
{"id": "MllBzH", "name": "Magic Tree 2", "author": "dr2", "description": "Based on \"White Folly 2\" and \"Magic Tree\"", "tags": ["fractal", "tree", "architecture", "folly"], "likes": 23, "viewed": 599, "published": "Public API", "date": "1511082301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Magic Tree 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SHAD  1  // = 1 for shadows (more work)\n#define TREE  1  // = 0 replace tree by reflecting sphere (less work)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 RMat3D (vec3 a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, vnBall;\nfloat dstFar, tCur;\nint idObj;\nbool isShad;\nconst int idStr = 1, idRail = 2, idFlr = 3, idPil = 4, idBrl = 5;\nconst float pi = 3.14159;\n\n#if TREE\n\nmat3 bRot, trRot;\nfloat trAge, trBloom, szTree, nCyc, flRad, brLen, brRad, brRadMax;\nconst float sScale = 0.726;\nconst int idBrnch = 101, idFlwr = 120;\n\nfloat TreeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rFac, d, fr;\n  p.y -= 2.;\n  q = p / szTree;\n  q.xz = Rot2D (q.xz, 1.3 * nCyc);\n  q *= trRot;\n  rFac = 1.;\n  for (int j = 0; j < 8; j ++) {\n    rFac *= sScale;\n    brRad = max (brRadMax - 0.02 * q.y, 0.02);\n    d = PrCapsDf ((q + vec3 (0., -0.5 * brLen, 0.)).xzy, brRad, 0.5 * brLen) * rFac;\n    if (d < dMin) {\n      dMin = SmoothMin (dMin, d, 0.1 * brRad * rFac);\n      idObj = idBrnch + j;\n      qHit = q;\n    }\n    q = vec3 (abs (q.x), q.y - brLen, q.z) * bRot;\n  }\n  fr = 0.8 * flRad;\n  for (int j = 0; j < 4; j ++) {\n    rFac *= sScale;\n    d = PrCylDf (q + vec3 (brRad, brLen, 0.), fr, 0.03 * brLen) * rFac;\n    if (d < dMin) {\n      dMin = d;\n      idObj = idFlwr + j;\n      qHit = q;\n    }\n    q = vec3 (abs (q.x), q.y - brLen, q.z) * bRot;\n    fr += 0.05 * flRad;\n  }\n  return dMin;\n}\n\nfloat ShTreeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float rFac, fr;\n  p.y -= 2.;\n  q = p / szTree;\n  q.xz = Rot2D (q.xz, 1.3 * nCyc);\n  q *= trRot;\n  rFac = 1.;\n  for (int j = 0; j < 5; j ++) {\n    rFac *= sScale;\n    brRad = max (brRadMax - 0.02 * q.y, 0.02);\n    dMin = min (dMin, PrCapsDf ((q + vec3 (0., -0.5 * brLen, 0.)).xzy, brRad, 0.5 * brLen) * rFac);\n    q = vec3 (abs (q.x), q.y - brLen, q.z) * bRot;\n  }\n  fr = 0.8 * flRad;\n  for (int j = 0; j < 2; j ++) {\n    rFac *= sScale;\n    dMin = min (dMin, PrCylDf (q + vec3 (brRad, brLen, 0.), fr, 0.03 * brLen) * rFac);\n    q = vec3 (abs (q.x), q.y - brLen, q.z) * bRot;\n    fr += 0.05 * flRad;\n  }\n  return dMin;\n}\n\nvoid SetupTree ()\n{\n  float t;\n  nCyc = floor (tCur / 90.);\n  trAge = tCur / 90. - nCyc;\n  trBloom = mod (5. * trAge, 1.);\n  szTree = 1.5 * (2.3 - 2.2 * smoothstep (0.93, 0.98, trAge));\n  t = min (trAge, 0.8);\n  brLen = min (0.95, 0.03 + 1.3 * sqrt (t));\n  brRadMax = 0.01 + 0.12 * sqrt (t);\n  flRad = (0.2 + 6. * t) * (0.05 + 0.8 * clamp (6. * trBloom * (1. - trBloom) - 0.1, 0., 1.));\n  trRot = RMat3D (vec3 (0.2, 0.5, -0.2));\n  bRot = RMat3D (vec3 (-0.5 + 0.3 * t, -1.5, 0.7 + 0.2 * t) + 0.05 * sin (0.5 * nCyc)) / sScale;\n}\n\n#endif\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qs;\n  float dMin, d, s, aq, a, db;\n  const float flGap = 4., flShift = 3.9, flRad = 9.85, flWid = 1.7, bcRadV = 0.05,\n     bcRadH = 0.08, bcLen = 1.1;\n  dMin = dstFar;\n  p.x = -p.x;\n  q = p;\n  aq = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * aq / (2. * pi) + 0.5) / 4.));\n  qs.y = q.y;\n  qs.xz = Rot2D (q.xz + vec2 (11.3, 6.), -0.25 * pi);\n  db = PrBox2Df (qs.yz + vec2 (-8.9, 0.), vec2 (1.4, 0.5));\n  qs.xz = Rot2D (q.xz + vec2 (11.3, -6.), 0.25 * pi);\n  db = min (db, PrBox2Df (qs.yz + vec2 (-1.1, 0.), vec2 (1.2, 0.5)));\n  qs.y = q.y - flGap;\n  qs.xz = Rot2D (vec2 (q.x + 11.3, abs (q.z) - 6.), -0.25 * pi);\n  q.xz = vec2 (- q.z, q.x + 6.);\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = vec2 (28. * a / (2. * pi), length (q.xz) - 8.);\n  q.y += 3.;\n  q.xy = Rot2D (q.xy, 0.25 * pi);\n  s = mod (q.x, 0.5 * sqrt (2.));\n  d = 0.3 * max (max (max (q.y - min (s, 0.5 * sqrt (2.) - s), abs (q.z) - 1.5), -0.07 - q.y), qs.x - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idStr;  qHit = q; }\n  q.z = abs (q.z);\n  q -= vec3 (-11.3, 1.4, 1.43);\n  d = max (min (PrCylDf (q.yzx, bcRadH, 5.8),\n     PrCylDf (vec3 (0.5 * mod (17.8 * a + 0.5, 1.) - 0.25, q.y + 0.7, q.z).xzy, bcRadV, 0.7)), qs.x - 0.1);\n  if (d < dMin) { dMin = d;  idObj = idRail; }\n  q = p;  q.y = abs (qs.y + 0.05) - flShift;\n  d = PrCylAnDf (q.xzy, flRad, flWid, 0.15);\n  q.xz = qs.xz + vec2 (-2., 0.2);\n  d = min (d, PrBoxDf (q, vec3 (2.1, 0.15, 1.7)));\n  if (d < dMin) { dMin = d;  idObj = idFlr;  qHit = q; }\n  q = vec3 (p.x, abs (qs.y - 2.1) - flShift, p.z);\n  s = length (q.xz) - flRad;\n  d = min (length (vec2 (s + flWid - 0.15, q.y)) - bcRadH,\n     max (length (vec2 (s - flWid + 0.15, q.y)) - bcRadH, 2. - abs (qs.x - 2.)));\n  q.y = abs (qs.y - 1.) - flShift;\n  q.xz = Rot2D (p.xz, 2. * pi * (floor (128. * aq / (2. * pi) + 0.5) / 128.));\n  d = min (min (d, PrCylDf (vec3 (q.x + flRad - flWid + 0.15, q.yz).xzy, bcRadV, bcLen)),\n     max (PrCylDf (vec3 (q.x + flRad + flWid - 0.15, q.yz).xzy, bcRadV, bcLen), 2. - abs (qs.x - 2.)));\n  d = min (d, max (min (PrCylDf (vec3 (qs.x - 2., abs (qs.y - 2.1) - flShift, qs.z - 1.45).yzx, bcRadH, 2.),\n     PrCylDf (vec3 (mod (qs.x + 0.25, 0.5) - 0.25, abs (qs.y - 1.) - flShift, qs.z - 1.45).xzy, bcRadV, bcLen)),\n     abs (qs.x - 2.) - 2.));\n  d = min (d, max (min (PrCylDf (vec3 (qs.x, abs (qs.y - 2.1) - flShift, qs.z), bcRadH, 1.45),\n     max (PrCylDf (vec3 (qs.x, abs (qs.y - 1.) - flShift,\n     mod (qs.z + 0.25, 0.5) - 0.25).xzy, bcRadV, bcLen), abs (qs.z) - 1.45)), - db));\n  if (d < dMin) { dMin = d;  idObj = idRail; }\n  d = min (PrCapsDf (vec3 (qs.x, abs (qs.y - bcLen) - flShift, qs.z - 1.43).xzy, 0.15, 1.2),\n     PrCapsDf (vec3 (qs.x, qs.y - bcLen, qs.z + 1.43).xzy, 0.15, flShift + 1.2));\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  d = PrCylDf ((p + vec3 (0., -1., 0.)).xzy, 1.5, 1.);\n  if (d < dMin) { dMin = d;  idObj = idBrl; }\n#if TREE\n  dMin = isShad ? ShTreeDf (p, dMin) : TreeDf (p, dMin);\n#endif\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isShad = true;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 32; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  isShad = false;\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    col = vec3 (0.2, 0.3, 0.6) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), 0.2 + 0.8 * f * rd.y);\n  } else {\n    col = mix (0.6 * mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), Fbm2 (ro.xz)) *\n       (1. - 0.2 * Noisefv2 (32. * ro.xz)), vec3 (0.18, 0.28, 0.48), pow (1. + rd.y, 5.));\n    f = 1. - smoothstep (0.1, 1., length (ro.xz) / dstFar);\n    vn = VaryNf (ro, vec3 (0., 1., 0.), 2. * f);\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.));\n  }\n  return col;\n}\n\n#if ! TREE\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  rad = 3.;\n  p = vec3 (0., 2. + rad, 0.);\n  u = ro - p;\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\n#endif\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col;\n  float dstObj, dstBall, r, s, sh;\n  bool isBg;\n#if TREE\n  SetupTree ();\n#endif\n  HexVorInit ();\n  isShad = false;\n  isBg = true;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n#if ! TREE\n  dstBall = BallHit (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) {\n    ro += dstBall * rd;\n    rd = reflect (rd, vnBall);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n#endif\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    r = length (ro.xz);\n    if (idObj == idFlr) {\n      col = vec3 (1., 0.8, 0.6);\n      if (abs (vn.y) > 0.99) {\n        if (r < 11.6) {\n          s = mod (2.42 * r, 2.);\n          col *= (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, mod (s, 1.))) *\n             (0.8 + 0.2 * SmoothBump (0.05, 0.95, 0.02,\n             mod (64. * atan (ro.z, - ro.x) / (2. * pi) + 0.5 * step (s, 1.), 1.)));\n        } else {\n          col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, mod (2. * qHit.x, 1.));\n        }\n      } else if (abs (vn.y) < 0.01) col *= 0.8 +\n         0.2 * SmoothBump (0.2, 0.8, 0.03, mod (12. * ro.y, 1.));\n      vn = VaryNf (100. * ro, vn, 0.2); \n    } else if (idObj == idStr) {\n      col = vec3 (0.9, 0.7, 0.5);\n    } else if (idObj == idRail) {\n      col = vec3 (0.8, 0.8, 0.9);\n    } else if (idObj == idPil) {\n      col = vec3 (0.7, 0.7, 0.8);\n    } else if (idObj == idBrl) {\n      if (vn.y < 0.99 || r > 1.4) {\n        col = vec3 (0.7, 0.5, 0.2) * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02,\n           mod (32. * ((r > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.), 1.))) *\n           (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, mod (4. * ro.y + 0.5, 1.)));\n        vn = VaryNf (20. * ro, vn, 1.);   \n      } else col = vec3 (0.2, 0.05, 0.) * (0.5 + 0.5 * Fbm2 (64. * ro.xz));\n#if TREE\n    } else if (idObj >= idBrnch && idObj < idFlwr + 4) {\n      if (idObj < idFlwr) {\n        col = 1.5 * mix (vec3 (0.3, 0.7, 0.3), vec3 (0.5, 0.3, 0.1),\n           smoothstep (0.02, 0.05, trAge));\n        col *= (0.7 + 0.3 * clamp (0.7 + 0.6 * cos (11. * qHit.y), 0., 1.));\n        vn.xz = Rot2D (vn.xz, 0.5 * sin (pi * mod (20. * (atan (qHit.z, qHit.x) / (2. * pi) + 0.5), 1.)));\n        vn = VaryNf (50. * ro, vn, 2. * smoothstep (0.03, 0.08, trAge));\n      } else {\n        col = HsvToRgb (vec3 (0.35 * max (0.05 * float (idObj - idFlwr) +\n           1. - 1.2 * trBloom, 0.),\n           0.05 + 0.95 * smoothstep (0.15, 0.2, trBloom), 1.)); \n        if (idObj == idFlwr + 3) col = mix (vec3 (1., 0., 0.), col,\n           smoothstep (0.05, 0.2, trBloom));\n        col = mix (col, vec3 (0.5, 0.3, 0.1), smoothstep (0.9, 1., trBloom));\n      }\n      col = mix (col, vec3 (0.8), smoothstep (0.93, 0.98, trAge));\n#endif\n    }\n#if SHAD\n#if TREE\n    if (idObj < idBrnch)\n#endif\n    sh = 0.6 + 0.4 * ObjSShadow (ro, sunDir);\n#endif\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n#if SHAD\n    sh = 0.7 + 0.3 * ObjSShadow (ro, sunDir);\n#endif\n    r = length (ro.xz);\n    if (r < 8.1) {\n      isBg = false;\n      vc = HexVor (8. * ro.xz);\n      vn.xz = - 0.9 * vc.yz;\n      vn.y = 1.;\n      vn = normalize (vn);\n      s = mod (16. * vc.w, 1.);\n      col = HsvToRgb (vec3 (0.1 + 0.4 * step (2. * s, 1.) + 0.1 * mod (5. * s, 1.),\n         0.4 + 0.2 * mod (17. * s, 1.), 0.3 + 0.3 * mod (8. * s, 1.))) *\n         (0.6 + 0.4 * smoothstep (0., 0.2, vc.x)) * (0.7 + 0.3 * smoothstep (1.5, 2.5, r));\n    }\n  }\n  if (! isBg) col = col * (0.3 + 0.1 * max (dot (- sunDir.xz, vn.xz), 0.) +\n     0.7 * sh * max (dot (sunDir, vn), 0.)) +\n     0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n  else col = sh * BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 120.;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az -= 2.5 * pi * sin (0.003 * pi * tCur);\n    el += 0.1 * pi * cos (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.1 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 7. - 2. * cos (az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 5., -70.);\n  sunDir = vuMat * normalize (vec3 (1., 3., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 RMat3D (vec3 a)\n{\n  vec3 cr, sr;\n  cr = cos (a);\n  sr = sin (a);\n  return mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n         mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n         mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllBzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 3180, 3202, 3202, 6233], [6235, 6235, 6268, 6268, 6445], [6447, 6447, 6468, 6468, 6670], [6672, 6672, 6709, 6709, 6966], [6968, 6968, 6999, 6999, 7698], [8076, 8076, 8111, 8111, 11752], [11754, 11754, 11810, 11810, 12739], [12741, 12741, 12773, 12773, 12873], [12875, 12875, 12908, 12908, 12997], [12999, 12999, 13041, 13041, 13092], [13094, 13094, 13137, 13137, 13201], [13203, 13203, 13256, 13256, 13317], [13367, 13367, 13391, 13391, 13621], [13623, 13623, 13647, 13647, 13707], [13709, 13709, 13729, 13729, 13949], [13951, 13951, 13973, 13973, 14569], [14571, 14571, 14616, 14616, 14719], [14721, 14721, 14778, 14778, 14861], [14863, 14863, 14893, 14893, 14951], [14953, 14953, 14975, 14975, 15212], [15214, 15214, 15238, 15238, 15374], [15408, 15408, 15432, 15432, 15492], [15494, 15494, 15518, 15518, 15648], [15650, 15650, 15675, 15675, 15861], [15863, 15863, 15884, 15884, 16039], [16041, 16041, 16070, 16070, 16286], [16288, 16288, 16327, 16327, 16507]], "test": "untested"}
{"id": "MllfDn", "name": "Simplex Fire", "author": "tsuhre", "description": "A simple fire effect created with combined ocatves of 3d simplex noise sliced by a moving 2d plane", "tags": ["noise", "fire"], "likes": 7, "viewed": 423, "published": "Public", "date": "1511642094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = .1;\n    float rate = 5.0;\n    \n    float t = iTime/rate;\n    \n    float result = 0.0;\n    \n    //octaves\n    for (float i = 0.0; i < 5.0; i++){\n    \tresult += snoise(vec3((uv.x*2.0)/scale, (uv.y - t)/scale, t*5.0))/pow(2.0, i);\n        scale /= 2.0;\n    }\n    result = (result + 2.0)/4.0;\n    \n    //powers for steeper curves\n    float p1 = pow(fragCoord.y/iResolution.y, 1.7);\n    float p2 = 8.0*(1.0 - p1);\n    result = pow(result, 8.0 - p2);\n    \n    //power for coloring\n    float g = pow(result, 6.0);\n    fragColor = vec4(result, g, 0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2106, 2106, 2716]], "test": "untested"}
{"id": "MllfDr", "name": "[WST1] Abstract Wroclavia", "author": "Levigo", "description": "Title: \"Abstrakcyjny zarys galerii Wroclavia\", Author: Krzysztof Wiewióra\nThis shader is prepared for the first Wroclaw Shader Competition \"\norganized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\"", "tags": ["training"], "likes": 3, "viewed": 143, "published": "Public", "date": "1511689388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0+2.0*q)*vec2(iResolution.x/iResolution.y,1.0);\n    vec2 uv = p;\n\n   \tfloat d = cos(p.y-.7)+cos(p.x+.7);;\n   \tuv=vec2(p*20.0)/(d);                         \n    \n    uv-=iTime;\n    \n    vec3 col = texture(iChannel0, uv+iTime*5.0 ).rgb;\n    \n    col*=d*.9;\n      float dist = \n        exp(3.0-15.0*length( p-vec2(0.75+0.01*sin(iTime),0.7))); \n\tfragColor = vec4(col+dist, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 492]], "test": "untested"}
{"id": "MlsBWN", "name": "Cubic Hermite Spline Demo", "author": "lexmar", "description": "Cubic Hermite Spline", "tags": ["hermite"], "likes": 2, "viewed": 175, "published": "Public", "date": "1511965425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float t = uv.x;\n    \n  \tfloat m1 = -0.5 + 1.5*sin(1.1*iTime);\n    float m2 = 0.2 + 2.2*cos(1.7*iTime);\n    \n    float a = m1 + m2;\n    float b = -2.0*m1 - m2;\n    float c = m1;\n    \n    float v = a*t*t*t + b*t*t + c*t;\n    \n    float sy = (uv.y - 0.5);\n    \n    float err = 0.005;\n    if(sy >= (v - err) && sy <= (v + err))\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    else if(sy >= (t*m1 - err) && sy <= (t*m1 + err))\n    {\n     \tfragColor = vec4(0.0, 1.0, 0.0, 1.0);   \n    }\n    else if(-sy >= (1.0-t)*m2 - err && -sy <= (1.0-t)*m2 + err)\n    {\n        fragColor = vec4(1.0, 0.0, 1.0, 1.0);   \n    }\n    else\n    {\n     \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 795]], "test": "untested"}
{"id": "MlsBzN", "name": "Succulent Forest", "author": "dr2", "description": "For all non-users of hexagon-based Voronoi tesselations (you do the arithmetic)", "tags": ["voronoi", "raymarch", "hexagon", "cactus"], "likes": 9, "viewed": 725, "published": "Public API", "date": "1511264560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Succulent Forest\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec3 HsvToRgb (vec3 c);\n\nvec3 sunDir, qHit;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 TwHexVor (vec3 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a, twf, twa;\n  amp = 0.7;\n  p.xz *= 1.1;\n  ip = PixToHex (p.xz);\n  fp = p.xz - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    twf = 4. * mod (32. * u.x, 1.) - 2.;\n    twa = 1. - 0.25 * abs (twf);\n    a = 2. * pi * (u.y - 0.5);\n    a += twa * sin (a + twf * p.y);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  vec3 q;\n  float d, h, r;\n  vc = TwHexVor (p);\n  h = 2. + vc.w;\n  q.xz = vc.yz;\n  q.y = p.y - h;\n  r = mix (0.02 + 0.12 * (2. - p.y / h), 0.7 * vc.x, 1. - smoothstep (0.1 * h, 0.4 * h, p.y));\n  r *= 1. + 0.1 * sin (4. * pi * p.y);\n  q.xz = abs (q.xz) - 0.5 * r;\n  d = 0.35 * max (PrCapsDf (q.xzy, r, h), - p.y);\n  qHit = q;\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n   return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 32; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n  col = vec3 (0.2, 0.3, 0.55) + 0.1 * pow (1. - max (rd.y, 0.), 4.) +\n     0.35 * pow (max (dot (rd, sunDir), 0.), 8.);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, vn;\n  float dstObj, sh, a, spec;\n  bool isBg;\n  HexVorInit ();\n  dstObj = ObjRay (ro, rd);\n  isBg = true;\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (32. * ro, vn, 5. - 4.5 * smoothstep (0.5, 2., ro.y));\n    a = atan (qHit.z, - qHit.x) / pi;\n    vc = TwHexVor (ro);\n    col = HsvToRgb (vec3 (0.15 + 0.3 * mod (37. * vc.w, 1.), 1.,\n       0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (6. * a, 1.))));\n    col = mix (col, vec3 (0.4, 0.2, 0.1), 1. - 0.9 * smoothstep (0., 1., ro.y));\n    col *= (1. - 0.3 * Fbm2 (64. * vec2 (a, 4. * qHit.y))) * (0.5 + 0.5 * smoothstep (0., 0.5, ro.y));\n    spec = 0.3 * smoothstep (2., 4., ro.y);\n  } else if (rd.y < 0.) {\n    isBg = false;\n    ro += (- ro.y / rd.y) * rd;\n    vn = VaryNf (32. * ro, vec3 (0., 1., 0.), 10.);\n    col = mix (vec3 (0.2, 0.05, 0.), vec3 (0.05, 0.2, 0.), Fbm2 (16. * ro.xz));\n    spec = 0.;\n  }\n  if (! isBg) {\n    sh = 0.3 + 0.7 * ObjSShadow (ro, sunDir);\n    col = col * (0.2 + 0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) +\n       0.1 * max (dot (- normalize (sunDir.xz), normalize (vn.xz)), 0.) +\n       spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  rd = normalize (vec3 (uv, 3.));\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.3 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * rd;\n  ro = vec3 (0., 5., 0.5 * tCur);\n  sunDir = normalize (vec3 (0.5, 1., -1.));\n  dstFar = 120.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2), dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsBzN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 539, 559, 559, 779], [781, 781, 805, 805, 1542], [1544, 1544, 1566, 1566, 1916], [1918, 1918, 1951, 1951, 2129], [2131, 2131, 2152, 2152, 2360], [2362, 2362, 2399, 2399, 2628], [2630, 2630, 2662, 2662, 2952], [2954, 2954, 2989, 2989, 4293], [4295, 4295, 4351, 4351, 5199], [5201, 5201, 5244, 5244, 5308], [5335, 5335, 5359, 5359, 5589], [5591, 5591, 5615, 5615, 5675], [5677, 5677, 5722, 5722, 5825], [5827, 5827, 5884, 5884, 5967], [6001, 6001, 6025, 6025, 6085], [6087, 6087, 6111, 6111, 6279], [6281, 6281, 6306, 6306, 6492], [6494, 6494, 6515, 6515, 6670], [6672, 6672, 6701, 6701, 6917], [6919, 6919, 6958, 6958, 7138], [7140, 7140, 7164, 7164, 7300]], "test": "untested"}
{"id": "MlScD3", "name": "NewLand", "author": "mbixo", "description": "land", "tags": ["land"], "likes": 2, "viewed": 371, "published": "Public API", "date": "1510315182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants ----------\n#define PI 3.14159265358979\n#define P2 6.28318530717959\n\nconst int   MAX_TRACE_STEP = 60;\nconst float MAX_TRACE_DIST = 180.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR = .82;\nconst vec3  GAMMA = vec3(1.3/2.2);\n\nconst float GI_LENGTH = .8;\nconst float GI_STRENGTH = .4;\nconst float AO_STRENGTH = .4;\nconst int   MAX_SHADOW_TRACE_STEP = 110;\nconst float MAX_SHADOW_TRACE_DIST = 10.;\nconst float MIN_SHADOW_MARCHING = .2;\nconst float SHADOW_SHARPNESS = 4.;\n\nconst float LENS_BLUR = .3;\n\n\n// Structures ----------\nstruct Surface {\n  float d;\n  vec4 kd;  // should be \"kd.w=1\" for ao shadow strength\n};\nSurface _min(Surface s,Surface t) {if(s.d<t.d)return s;return t;}\n\nstruct Ray {\n  vec3 org, dir;\n  float len, stp;\n};\nvec3 _pos(Ray r) {return r.org+r.dir*r.len;}\n\nstruct Hit {\n  vec3 pos;\n  Ray ray;\n  Surface srf;\n};\n\nstruct Camera {\n  vec3 pos, tgt;\n  float rol, fcs;\n};\nmat3 _mat3(Camera c) {\n  vec3 w = normalize(c.pos-c.tgt);\n  vec3 u = normalize(cross(w,vec3(sin(c.rol),cos(c.rol),0)));\n  return mat3(u,normalize(cross(u,w)),w);\n}\n\nstruct AmbientLight {\n  vec3 dir, col;\n};\nvec3 _lit(vec3 n, AmbientLight l){return clamp((dot(n, l.dir)+1.)*.5,0.,1.)*l.col;}\n\n\n// Grobal valiables ----------\nconst float bpm = 144.;\nconst AmbientLight amb = AmbientLight(vec3(0,1,0), vec3(.7,.7,.7));\nconst AmbientLight dif = AmbientLight(normalize(vec3(1,2,1)), vec3(.7,.7,.7));\nfloat phase;\n\n\n// Utilities ----------\nvec3 _rgb(vec3 v) {\n  return ((clamp(abs(fract(v.x+vec3(0,2./3.,1./3.))*2.-1.)*3.-1.,0.,1.)-1.)*v.y+1.)*v.z;\n}\n\nmat3 _sMat(float th, float ph) {\n  float x=cos(th), y=cos(ph), z=sin(th), w=sin(ph);\n  return mat3(y,w*z,-w*x,0,x,z,w,-y*z,y*x);\n}\n\n\n// Distance Functions ----------\nfloat fPlane(vec3 p, vec3 n, float d) {\n  return dot(p,n) + d;\n}\n\nfloat fBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.)) - r;\n}\n\nvec3 repXZ(vec3 p, vec2 r){\n  vec2 hr = r * .5;\n  return vec3(mod(p.x+hr.x, r.x)-hr.x, p.y, mod(p.z+hr.y, r.y)-hr.y);\n}\n\nfloat fHex(vec3 p, vec2 h, float r) {\n  vec3 q = abs(p);\n  q.x = max(q.x*0.866025+q.z*0.5,q.z);\n  return length(max(q.xy-h.xy,0.)) - r;\n}\n\n// World Mapping ----------\nSurface map(vec3 p){\n  float lv = min(1., iTime / 16.);\n  float es = exp(sin(phase*.5-length(p)*.2));\n  vec2  bs = vec2(.6/es,.6*es);\n  vec3  hx = vec3(1.73205081,1,0)*4.;\n  vec3  rp =  repXZ(p, hx.xy);\n  vec3  rp2 = repXZ(p+hx.xzy*.5, hx.xy);\n  vec3  col = _rgb(vec3(phase/256.,1.4,1.4));\n  rp.y -= bs.y+.4-length(p)*.01;\n  rp2.y -= bs.y+.4-length(p)*.01;\n\n  return _min(\n    Surface(fPlane(p, vec3(0,1,0), lv*3.8-3.8), vec4(col,1)), \n    _min(\n      Surface(fHex(rp,  bs, .4), vec4(.7,.7,.7,1)),\n      Surface(fHex(rp2, bs, .4), vec4(.3,.3,.3,1))\n    )\n  );\n}\n\n\n// Lighting ----------\nvec3 calcNormal(in vec3 p){\n  vec3 v=vec3(.001,0,map(p).d);\n  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));\n}\n\nfloat ss(in vec3 pos, in vec3 dir) {\n  float sdw=1., len=.01;\n  for( int i=0; i<MAX_SHADOW_TRACE_STEP; i++ ) {\n    float d = map(pos + dir*len).d;\n    sdw = min(sdw, SHADOW_SHARPNESS*d/len);\n    len += max(d, MIN_SHADOW_MARCHING);\n    if (d<TRACE_PRECISION || len>MAX_SHADOW_TRACE_DIST) break;\n  }\n  return clamp(sdw, 0., 1.);\n}\n\nvec4 gi(in vec3 p, in vec3 n) {\n  vec4 col = vec4(0);\n  for (int i=0; i<4; i++) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(n * hr + p);\n    col += s.kd * (hr - s.d);\n  }\n  col.rgb *= GI_STRENGTH / GI_LENGTH;\n  col.w = clamp(1.-col.w * AO_STRENGTH / GI_LENGTH, 0., 1.);\n  return col;\n}\n\nvec3 lighting(in Hit h) {\n  vec3 n = calcNormal(h.pos);\n  vec4 gin = gi(h.pos, n);\n  //   lin = ([Ambient]    + [Diffuse]    * [Soft shadow])      * [A.O] + [G.I.]\n  vec3 lin = (_lit(n, amb) + _lit(n, dif) * ss(h.pos, dif.dir)) * gin.w + gin.rgb;\n  return  h.srf.kd.rgb * lin;\n}\n\n\n// Ray tracing ----------\nRay ray(in vec2 p, in Camera c) {\n  return Ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)), .0, .0);\n}\n\nRay bray(in Ray r, Camera c, float b) {\n  vec3 p = c.pos + normalize(cross(r.dir, vec3(1))) * b;\n  return Ray(p, normalize(r.org + r.dir * length(c.tgt - c.pos) - p), .0, .0);\n}\n\nHit trace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;\n  }\n  return Hit(_pos(r), r, s);\n}\n\nvec4 render(in Hit h){\n  if (h.ray.len > MAX_TRACE_DIST) return vec4(1.8,2.8,.8,h.ray.len);\n  return vec4(lighting(h), h.ray.len);\n}\n\nvec4 gamma(in vec4 i) {\n  return vec4(pow(i.xyz, GAMMA), i.w);\n}\n\n\n// Entry point ----------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  phase = iTime * bpm / 60. * P2;\n\n  Camera c = Camera(vec3(sin(phase/32.)*20., exp(cos(phase/64.)*1.2)*40., cos(phase/32.)*20.), vec3(0), .4, 1.73205081);\n  Ray    r = ray((fragCoord.xy * 2. - iResolution.xy) / iResolution.x, c);\n\n  vec4 col = render(trace(r));\n  col += render(trace(bray(r, c, LENS_BLUR)));\n  col += render(trace(bray(r, c, -LENS_BLUR)));\n  fragColor = gamma(col/3.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlScD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 640, 675, 675, 705], [758, 758, 776, 776, 802], [913, 913, 935, 935, 1076], [1120, 1120, 1154, 1154, 1203], [1423, 1447, 1466, 1466, 1557], [1559, 1559, 1591, 1591, 1689], [1692, 1725, 1764, 1764, 1789], [1791, 1791, 1828, 1828, 1869], [1871, 1871, 1898, 1898, 1990], [1992, 1992, 2029, 2029, 2129], [2131, 2159, 2179, 2179, 2720], [2723, 2746, 2773, 2773, 2891], [2893, 2893, 2929, 2929, 3221], [3223, 3223, 3254, 3254, 3534], [3536, 3536, 3561, 3561, 3814], [3817, 3843, 3876, 3876, 3949], [3951, 3951, 3990, 3990, 4128], [4130, 4130, 4151, 4151, 4380], [4382, 4382, 4404, 4404, 4514], [4516, 4516, 4539, 4539, 4580], [4583, 4609, 4664, 4664, 5053]], "test": "untested"}
{"id": "MlScRV", "name": "The maple leaf flag", "author": "CodingDuff", "description": "Canadian flag \"A mari usque ad mare\"", "tags": ["2d", "flag", "red", "canada"], "likes": 1, "viewed": 141, "published": "Public", "date": "1509643436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float merge(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat sdSphere(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\n//***/\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat mapleLeafSDF(vec2 p, float r)\n{\n    p.x = -abs(p.x);\n    p.y-=0.045;\n    float s = sdSphere(p, 0.65);\n    float t = sdTriangle(vec2(0.045,-0.4), vec2(1.0,-0.56), vec2(0.06,-1.0), p) - r; \n    t = merge(t, sdTriangle(vec2(-0.045,-0.4), vec2(-1.0,-0.56), vec2(-0.06,-1.0), p) - r);\t\n    t = merge(t, sdTriangle(vec2(-0.35,-0.35), vec2(-0.75,0.0), vec2(-1.0,-1.6), p) - r);  \t\n    t = merge(t, sdTriangle(vec2(-0.57,0.0), vec2(-1.0,1.0), vec2(-1.5,-0.5), p) - r);    \n    t = merge(t, sdTriangle(vec2(-0.42,0.15), vec2(-1.2,0.35), vec2(-0.3,1.0), p) - r);   \n    t = merge(t, sdTriangle(vec2(-0.21,0.05), vec2(-1.0,1.0), vec2(-0.35,1.0), p) - r);   \n    t = merge(t, sdTriangle(vec2(-0.12,0.35), vec2(-1.0,0.75), vec2(0.25,1.0), p) - r);  \n    return sub(t,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *=1.2;\n    \n    float wave = 0.05*sin((iTime+uv.x)*2.0)/2.0*(uv.x+1.75);    \n    uv.y += wave;\n    \n    vec3 red = vec3(.835, .169, .118);\n    vec3 wh = vec3(1.0);\n    vec3 bl = vec3(0.2);\n    vec3 bg;\n    vec3 grey = vec3(0.3);\n    vec4 col;\n    \n    bg = mix(grey, bl, length(uv)-3.)+ wave*0.8;\n    /*** Draw ***/    \n    col.rgb = (length(uv.x) > .8 || mapleLeafSDF(uv, 0.03) < 0.0) ? red : wh;\n    col.rgb = (length(uv.y) > 1. || length(uv.x) > 1.8) ?  bg : col.rgb + wave*0.7;\n \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlScRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 59], [61, 61, 92, 92, 119], [121, 121, 154, 154, 179], [181, 188, 255, 255, 864], [866, 866, 903, 903, 1631], [1633, 1633, 1690, 1690, 2303]], "test": "untested"}
{"id": "MlsfR4", "name": "fractal pulse", "author": "macbooktall", "description": "0f9isdf", "tags": ["1320", "cineshader"], "likes": 21, "viewed": 16621, "published": "Public API", "date": "1511222012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXDIST 20.\n#define GIFLENGTH 1.570795\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nfloat fractal(vec3 p)\n{\n   \tfloat len = length(p);\n    p=p.yxz;\n\n    float scale = 1.25;\n    const int iterations = 28;\n    float a = iTime;\n\tfloat l = 0.;\n    \n    vec2 rotationAnimAmp = vec2(0.05,0.04);\n\tvec2 rotationPhase = vec2(.45 + sin(iTime*4. + len*0.4) * 0.025,0.15 + cos(-0.2+iTime*4. + len*0.2) * 0.05);\n\t\n    // uncomment this to find good spots with the mouse :)\n    //m = iMouse.xy / iResolution.xy;\n    \n    vec3 juliaOffset = vec3(-3.,-1.15,-.5);\n    \n    pR(p.xy,.5+sin(-0.25+iTime*4.)*0.1);\n    \n    for (int i=0; i<iterations; i++) {\n\t\tp = abs(p);\n        // scale and offset the position\n\t\tp = p*scale + juliaOffset;\n        \n        // Rotate the position\n        pR(p.xz,rotationPhase.x*3.14 + cos(iTime*4. + len)*rotationAnimAmp.y);\n\t\tpR(p.yz,rotationPhase.y*3.14 + sin(iTime*4. + len)*rotationAnimAmp.x);\t\t\n        l=length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.25;\n}\n\nvec2 map(vec3 pos) {\n    float l = length(pos);\n\n    float dist = fractal(pos);\n\n    return vec2(dist, 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 30;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.2*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, MAXDIST);\n    }\n    \n    vec3 p = ray.ro+res.x*ray.rd;\n    vec3 normal = calcNormal(p);\n    vec3 pos = p;\n    ray.ro = pos;\n    // color with ambient occlusion\n   \tcol = vec3(pow(calcAO(p, normal), 3.2))*0.5;\n   \n    col = mix(col, vec3(0.), clamp(res.x/MAXDIST, 0., 1.));\n   \treturn vec4(col, res.x);\n}\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(9., 6.5, 12.);\n    vec3 camDir = camPos + vec3(-.85, -.5, -1. );\n    mat3 cam = camera(camPos, camDir, 0.);\n    \n    vec3 rayDir = cam * normalize( vec3(uv, 1. + sin(iTime*4.)*0.05) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    col.xyz = pow(col.xyz, vec3(0.6));\n\tfragColor = vec4(col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}", "image_inputs": [{"id": "XsXGR8", "previewfilepath": "/media/previz/buffer01.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer01.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 120, 120, 162], [164, 164, 189, 189, 253], [255, 255, 278, 278, 1158], [1160, 1160, 1180, 1180, 1269], [1271, 1271, 1293, 1293, 1659], [1661, 1661, 1689, 1689, 1956], [1958, 1958, 2000, 2000, 2289], [2290, 2290, 2313, 2313, 2727], [2728, 2728, 2777, 2777, 2989], [2991, 2991, 3048, 3048, 3565]], "test": "untested"}
{"id": "MlSyD3", "name": "Steam Engine No.1", "author": "dr2", "description": "Simple steam engine as found in your local museum", "tags": ["kinematics", "mechanism"], "likes": 9, "viewed": 406, "published": "Public API", "date": "1510309427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Steam Engine No.1\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\nvec3 ltDir, qHit;\nvec2 aCs, crCs, crMid;\nfloat tCur, dstFar, crRad, crLen, aRot;\nint idObj;\nconst int idWhl = 1, idSpk = 2, idCrnk = 3, idAx = 4, idPis = 5, idCrod = 6, idCyl = 7,\n   idCylEnt = 8, idValv = 9, idPipes = 10, idSup = 11, idBase = 12;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  dMin = dstFar;\n  p.x -= 8.;\n  qq = p;  qq.z -= 2.;\n  qq.xy = Rot2Cs (qq.xy, aCs);\n  q = qq;\n  d = min (PrCylAnDf (q, 5.5, 0.25, 0.5), PrCylDf (q, 1., 0.5));\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (12. * atan (q.y, - q.x) / (2. * pi) + 0.5)) / 12.);\n  d = SmoothMin (d, PrCylDf ((q + vec3 (2.75, 0., 0.)).yzx, 0.25, 2.75), 0.1);\n  if (d < dMin) { dMin = d;  idObj = idSpk; }\n  q = qq;\n  d = min (PrBoxDf (vec3 (q.x + 0.5 * crRad, q.y, abs (q.z + 2.) - 0.5), vec3 (0.5 * crRad, 0.2, 0.1)),\n     PrCylDf (vec3 (abs (q.x + 0.5 * crRad) - 0.5 * crRad, q.y, abs (q.z + 2.) - 0.5), 0.6, 0.1));\n  if (d < dMin) { dMin = d;  idObj = idCrnk; }\n  d = min (PrCylDf (q + vec3 (crRad, 0., 2.), 0.3, 0.75), max (PrCylDf (p, 0.3, 3.7), 0.3 - abs (p.z)));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  q = p;\n  q.xy = Rot2Cs (q.xy + crMid, crCs);\n  d = min (PrCylDf (vec3 (abs (q.y) - 0.12, q.zx), 0.15, crLen - 0.5),\n     PrCylDf (vec3 (abs (q.x) - crLen, q.yz), 0.6, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idCrod; }\n  q = p;  q.x -= - (4.5 + crMid.x + crLen * crCs.x);\n  d = PrCylDf (q.yzx, 0.25, 3.7);\n  if (d < dMin) { dMin = d;  idObj = idPis; }\n  d = PrCylDf ((q - vec3 (0.7, 1.7, 0.)).yzx, 0.07, 3.);\n  if (d < dMin) { dMin = d;  idObj = idPis; }\n  q.x -= 4.5;\n  d = PrCylDf (q, 0.3, 0.65);\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = min (min (PrCylDf ((q + vec3 (0.8, 0., 0.)).yzx, 0.6, 0.13),\n     PrCylDf ((q + vec3 (0.8, -0.8, 0.)).xzy, 0.08, 0.95)),\n     PrCylDf (vec3 (q.xy, abs (q.z) - 0.35), 0.7, 0.1));\n  if (d < dMin) { dMin = d;  idObj = idCrnk; }\n  q = p + vec3 (16.9, 0., 0.);\n  d = PrCylDf (q.yzx, 1.5, 3.5);\n  if (d < dMin) { dMin = d;  idObj = idCyl;  qHit = q; }\n  d = PrCylDf ((p + vec3 (13.4, 0., 0.)).yzx, 0.7, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idCylEnt;  qHit = q; }\n  q = p + vec3 (16.9, -1.7, 0.);\n  d = PrCylDf (q.yzx, 0.5, 2.5);\n  if (d < dMin) { dMin = d;  idObj = idValv;  qHit = q; }\n  q = vec3 (abs (p.x + 16.9) - 1., p.y - 3., p.z);\n  d = PrCylAnDf (q.xzy, 0.3, 0.05, 1.);\n  if (d < dMin) { dMin = d;  idObj = idPipes;  qHit = q; }\n  d = min (PrBoxDf (vec3 (p.x, p.y + 1.6, abs (p.z) - 3.3), vec3 (0.5, 1.5, 0.3)),\n     PrBoxDf (vec3 (p.x, p.y + 3., abs (p.z) - 1.05), vec3 (0.5, 2.9, 0.1)));\n  d = min (d, PrCylDf (vec3 (p.xy, abs (abs (p.z) - 2.18) - 1.12), 0.5, 0.35));\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  d = max (PrBoxDf (p + vec3 (7.5, 4.5, 0.), vec3 (14.5, 1.5, 4.)),\n     - PrBoxDf (p + vec3 (2.5, 4.4, 0.), vec3 (8.5, 1.55, 3.)));\n  d = min (d, PrBoxDf (p + vec3 (16.9, 2.6, 0.), vec3 (3., 1.3, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idBase; }\n  q = p + vec3 (0., -1.8, 3.3);\n  d = PrCylDf ((q + vec3 (0., 0.6, 0.)).xzy, 0.15, 0.7);\n  q.xz = Rot2D (q.xz, 8. * aRot);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 4.);\n  d = min (d, PrCylDf ((q + vec3 (0.4, 0., 0.)).yzx, 0.05, 0.4));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = PrSphDf (q + vec3 (0.8, 0., 0.), 0.2);\n  if (d < dMin) { dMin = d;  idObj = idPis; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0005, -0.0005, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, rg;\n  vec2 qBlk;\n  float dstObj, a, s, sh;\n  bool fxz;\n  aRot = -0.2 * 2. * pi * tCur;\n  aCs = vec2 (cos (aRot), sin (aRot));\n  crRad = 2.;\n  crLen = 5.;\n  crMid.y = -0.5 * crRad * aCs.y;\n  crCs = vec2 (cos (asin (crMid.y / crLen)), crMid.y / crLen);\n  crMid.x = crLen * crCs.x + crRad * aCs.x;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);\n    if (idObj == idBase) {\n      col4 = vec4 (0.9, 0.3, 0.1, 0.);\n      if (abs (vn.y) < 0.01) {\n        rg = ro;\n        rg.y += 0.5;\n        fxz = (abs (vn.x) > 0.99);\n        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));\n        rg.xz *= sign (fxz ? vn.x : vn.z);\n        if (fxz) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      } else {\n        rg = ShGrid (ro.xz);\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);\n        if (vn.y > 0.99) {\n          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n          else vn.yx = Rot2D (vn.yx, rg.x);\n        }\n      }\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == idCyl) {\n      col4 = vec4 (0.7, 0.3, 0.1, 0.2);\n      a = atan (qHit.z, - qHit.y) / (2. * pi);\n      if (abs (vn.x) > 0.99) {\n        col4.r *= 1. - 0.3 * Fbm2 (4. * qHit.yz);\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *\n           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));\n      } else {\n        col4.r *= 1. - 0.3 * Fbm2 (4. * vec2 (8. * a, qHit.x));\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));\n      }\n    } else if (idObj == idWhl) {\n      if (abs (vn.z) < 0.01) qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);\n      col4 = vec4 (0.8, 0.6, 0.1, 0.1) * (1. - 0.2 * Noisefv2 (128. * qHit.xy));\n    } else if (idObj == idSpk) {\n      col4 = 0.9 * vec4 (0.8, 0.6, 0.1, 0.2);\n    } else if (idObj == idCrnk) {\n      col4 = vec4 (0.6, 0.6, 0.4, 0.2);\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.7, 0.4, 0.1, 0.3);\n    } else if (idObj == idPis) {\n      col4 = vec4 (0.4, 0.4, 0.4, 0.3);\n    } else if (idObj == idCrod) {\n      col4 = vec4 (0.6, 0.5, 0.6, 0.3);\n    } else if (idObj == idCylEnt) {\n      col4 = vec4 (0.7, 0.4, 0.1, 0.2);\n      if (length (qHit.yz) < 0.33) col4.rgb *= 0.5;\n    } else if (idObj == idValv) {\n       col4 = vec4 (0.7, 0.4, 0.1, 0.2);\n       if (vn.x > 0. && length (qHit.yz) < 0.13) col4.rgb *= 0.5;\n    } else if (idObj == idPipes) {\n       col4 = (length (qHit.xz) > 0.3) ? vec4 (0.7, 0.4, 0.1, 0.2) : vec4 (0.3, 0.2, 0., 0.);\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.1, 0.6, 0.1, 0.05);\n      vn = VaryNf (32. * ro, vn, 1.);\n    }\n    sh = 0.5 + 0.5 * ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    col += col4.a * vec3 (0.4) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n  } else {\n    qBlk = mod (4. * BlkHit (ro, rd), 1.);\n    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., -2., -40.);\n  zmFac = 3.6;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSyD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 809, 831, 831, 3967], [3969, 3969, 4002, 4002, 4179], [4181, 4181, 4202, 4202, 4406], [4408, 4408, 4430, 4430, 4715], [4717, 4717, 4751, 4751, 5105], [5107, 5107, 5144, 5144, 5366], [5368, 5368, 5400, 5400, 5944], [5946, 5946, 5981, 5981, 9613], [9615, 9615, 9668, 9668, 10573], [10575, 10575, 10607, 10607, 10707], [10709, 10709, 10742, 10742, 10769], [10771, 10771, 10813, 10813, 10864], [10866, 10866, 10919, 10919, 10980], [10982, 10982, 11027, 11027, 11130], [11132, 11132, 11189, 11189, 11272], [11274, 11274, 11304, 11304, 11362], [11364, 11364, 11395, 11395, 11459], [11493, 11493, 11517, 11517, 11647], [11649, 11649, 11674, 11674, 11860], [11862, 11862, 11883, 11883, 12038], [12040, 12040, 12069, 12069, 12281], [12283, 12283, 12322, 12322, 12506]], "test": "untested"}
{"id": "MlSyRK", "name": "Generalized Möbius", "author": "Reedbeta", "description": "Generalization of a Möbius transformation with a quadratic denominator.", "tags": ["procedural", "2d", "math", "complex", "diagram"], "likes": 17, "viewed": 522, "published": "Public API", "date": "1510202146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 10.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderUnitSquare(vec2 pos, inout vec3 fragColor)\n{\n#if 0\n    // Put a texture in there\n    if (pos.x >= 0.0 && pos.y >= 0.0 && pos.x <= 1.0 && pos.y <= 1.0)\n    {\n        fragColor.rgb = texture(iChannel0, pos).rgb;\n    }\n#endif\n\n    float dist = sdistQuadConvex(vec2(0, 0),\n                                 vec2(1, 0),\n                                 vec2(1, 1),\n                                 vec2(0, 1), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.007, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 csqr(vec2 a)\n{\n    return cmul(a, a);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, vec2(b.x, -b.y)) / dot(b, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.5 - vec2((1.5*aspect - 1.0)/2.0, 0.25);\n\n    // apply a generalized Möbius transformation to the plane\n#if 0\n    // mouse-controlled version\n    vec2 urcorner = (iMouse.xy / iResolution.xy) * 2.0;\n    vec2 b = vec2(0);\n    vec2 e = vec2(1, 0);\n    vec2 d = cmul(vec2(1,1) - urcorner, vec2(0,1));\n    vec2 c = cmul(d, vec2(-0.5, 0.5));\n    vec2 a = c + d + e;\n    pos = cdiv(cmul(a, pos) + b, cmul(c, csqr(pos)) + cmul(d, pos) + e);\n#else\n    // animated version\n    vec2 a = vec2(1, sin(0.4*iTime));\n    vec2 b = vec2(0);\n    vec2 c = vec2(0.3*cos(0.7*iTime), 0.3*sin(0.5*iTime));\n    vec2 d = vec2(0.3*cos(0.6*iTime), 0.3*sin(0.8*iTime));\n    vec2 e = vec2(1, 0.5*cos(0.3*iTime));\n    pos -= vec2(0.5);\n    pos = cdiv(cmul(a, pos) + b, cmul(c, csqr(pos)) + cmul(d, pos) + e);\n    pos += vec2(0.5);\n#endif\n\n    // render the grid and stuff\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderUnitSquare(pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 50], [52, 52, 138, 138, 275], [277, 277, 344, 344, 445], [447, 447, 494, 494, 1070], [1072, 1072, 1115, 1115, 1167], [1169, 1169, 1219, 1219, 1337], [1339, 1339, 1404, 1404, 1565], [1567, 1567, 1622, 1622, 2061], [2063, 2063, 2125, 2125, 3290], [3292, 3292, 3319, 3319, 3376], [3378, 3378, 3397, 3397, 3422], [3424, 3424, 3451, 3451, 3502], [3504, 3504, 3559, 3559, 4639]], "test": "untested"}
{"id": "MlSyW3", "name": "Boiling melting smoke", "author": "twenkid", "description": "A practice, starting from an Electricity spark shader - https://www.shadertoy.com/view/MsSfRD  by Coolok - and mutating it. Could be a a basis of a background of a title sequence shader.", "tags": ["electricity", "modified"], "likes": 9, "viewed": 348, "published": "Public", "date": "1510449291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Todor Arnaudov playing, \"Boiling melting smoke\"-something, starting with\n//https://www.shadertoy.com/view/MsSfRD by Coolok\n//10-11-2017\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec4 w, d;\n\t \n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return dot(d, vec4(52.0));\n}\n\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float aspect = iResolution.y / iResolution.x; \n  vec2 uv = fragCoord.xy / iResolution.xy;  \n  //  uv.y *= 1.5+0.5*sin(iTime);\n  uv = uv * 2. -1.;  \n \n // vec2 p = fragCoord.xy*(sin(fragCoord.x))/iResolution.x*(cos(fragCoord.y));  \n  //vec2 p = fragCoord.xy*(sin(fragCoord.x))/iResolution.x*(cos(fragCoord.y));\n  vec2 p = fragCoord.xy/iResolution.x;\n  //p*=p*p*p*p; //lower frequency from the left\n  vec3 p3 = vec3(p, iTime*0.4*0.5);    \n  \n  float a = sin(iTime/299.);\n  mat2 rot = mat2(vec2(sin(a), cos(a)), vec2(cos(a), -sin(a)));\n  //mat2 tr = mat2(vec2(sin(a), cos(a)), vec2(cos(a), -sin(a)));\n  p3.xy*=rot;\n  p3.yz*=rot;\n  p3.xz*=rot;\n                 \n  \n  float intensity = noise(vec3(p3*12.0+12.0));\n    \n  float border = max(1.0, 1.0 + abs(sin(iTime)));\n  //float t = clamp((uv.x * -uv.x * 0.16) + 0.15, 0., 1.);                         \n  float t = clamp((uv.x * -uv.x * border) + 0.15, 0., 1.);  \n    \n  //t = clamp((uv.x*(max(min(cos(iTime), 0.5), 1.)) * -uv.x * border) + 0.15, 0., 1.);  \n  \n  float y;\n    \n  y = abs(intensity * -t + uv.y);//*sin(iTime); electricity\n  \n //Covers the screen\n  //y = abs(intensity*5. * -t + uv.y*sin(iTime/2.));//*sin(iTime);  //inverted, ...\n  \n    //\n  y = abs(clamp(intensity*2., 0.2, 1.0) * -t + uv.y*sin(iTime/2.));//*sin(iTime);\n  //y = abs(intensity * -t + uv.y*(1.5 + (sin(iTime/4.))));//*sin(iTime);\n    \n  float g = pow(y, 0.2);\n                          \n  vec3 col = vec3(1.70, 1.48, 1.78);\n  col = col * -g + col;                    \n  col = col * col;\n  col = col * col;\n    \n  col*=1.0-distance(p, vec2(0.5, 0.5*aspect))*cos(iTime)*5.; //Circle\n  col*=vec3(0.3, 0.8, 1.8); //Blue-ish\n    \n  if (sin(iTime)>0.5){\n    vec3 back = texture(iChannel0, p).rgb * noise(vec3(p3*6.+3.));\n    back*=vec3(9., 1.2, 1.3);\n    col = mix(col, back, 0.1);\n  }\n  //col = mix(col, texture(iChannel0, p).rgb, 0.1);  //OK\n  \n    \n // y = abs(intensity*5. * -t + uv.y*sin(iTime/2.));    \n // g = pow(y, 0.2);\n // col = min(col, vec3(1.70*(-g), 1.48*1.48, 1.78*1.78)/10.);\n  \n  fragColor.rgb = col;                          \n  fragColor.w = 1.;  \n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 139, 161, 161, 334], [395, 395, 420, 420, 1058], [1060, 1060, 1081, 1081, 1213], [1215, 1215, 1272, 1272, 3362]], "test": "untested"}
{"id": "MlXBzH", "name": "Codevember 2017 17 Speed stripes", "author": "zeh", "description": "Speed stripes", "tags": ["bricks"], "likes": 2, "viewed": 113, "published": "Public", "date": "1510945166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int numRows = 10;\nint numCols = 10;\n\n   \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat rowHeight = 1.0 / float(numRows);\n\tfloat colWidth = 1.0 / float(numCols);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    int row = int(uv.y / rowHeight);\n    \n    float speed = float(row) / float(numRows);\n\n    float offset = speed * iTime * 2.0;\n    \n    int col = int((uv.x + offset) / colWidth);\n    float blurDistance = float(row) * rowHeight;\n    float positionInCol = (uv.x + offset - (float(col) * colWidth)) / colWidth;\n\n    float blurGray = positionInCol > blurDistance / 2.0 ? (positionInCol < 1.0 - blurDistance / 2.0 ? 0.0 : 0.5 - ((1.0 - positionInCol) / blurDistance)) : 0.5 - (positionInCol / blurDistance);\n    \n    if (col % 2 == 0) {\n    \tfragColor = vec4(1.0 - blurGray, 1.0 - blurGray, 1.0 - blurGray, 1.0);\n    } else {\n        fragColor = vec4(0.0 + blurGray, 0.0 + blurGray, 0.0 + blurGray, 1.0);\n    }\n    \n    //fragColor = vec4(positionInCol, positionInCol, positionInCol, 1.0);\n    //fragColor = vec4(offset, offset, offset, 1.0);\n}\n\n/*\nfloat thickness = 2.0;\nfloat width = 50.0;\nfloat height = 30.0;\n//float diamondSize = 10.0;\nvec4 colorWhite = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 colorBlack = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 colorRed = vec4(1.0, 0.0, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float diamondSize = 10.0 * abs(sin(iTime));\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float fx = mod(fragCoord.x, width);\n    float fy = mod(fragCoord.y, height);\n    float fax = min(fx, width - fx);\n    float fay = min(fy, height - fy);\n    if (fax + fay <= diamondSize) {\n        if (fax + fay < diamondSize - thickness) {\n\t        fragColor = colorWhite;\n        } else {\n\t        fragColor = colorBlack;\n        }\n    } else if (fax <= thickness / 2.0) {\n        fragColor = colorBlack;\n    } else if (fay <= thickness / 2.0) {\n        fragColor = colorBlack;\n    } else {\n        fragColor = colorWhite;\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 96, 96, 1066]], "test": "untested"}
{"id": "MlXfDH", "name": "Linear map: circle to ellipse", "author": "Reedbeta", "description": "An arbitrary linear transformation of the plane—including shearing or nonuniform scaling—maps a circle to an ellipse in general.", "tags": ["procedural", "2d", "math", "diagram"], "likes": 12, "viewed": 6499, "published": "Public API", "date": "1511745104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 v, float angle)\n{\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 8.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderCircle(vec2 center, float radius, vec2 pos, inout vec3 fragColor)\n{\n    float dist = length(pos - center) - radius;\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.005, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.375 - 6.0 * 0.0075;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 pos = (fragCoord / iResolution.y) * 1.0 - vec2((1.0*aspect)/2.0, 1.0/2.0);\n\n    // animate the grid a bit with rotation, shear, and nonuniform scale\n    pos *= vec2(sin(iTime*0.72) * 0.5 + 1.0, 1.0);\n    pos = rotate(pos, cos(iTime) * 0.1);\n    pos.x += pos.y * sin(iTime*0.89) * 0.5;\n\n    fragColor.a = 1.0;\n\trenderGrid(pos, fragColor.rgb);\n    renderCircle(vec2(0), 0.375, pos, fragColor.rgb);\n    renderAxes(vec2(0), pos, fragColor.rgb);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 145], [147, 147, 167, 167, 197], [199, 199, 285, 285, 422], [424, 424, 491, 491, 592], [594, 594, 641, 641, 1216], [1218, 1218, 1261, 1261, 1313], [1315, 1315, 1365, 1365, 1483], [1485, 1485, 1550, 1550, 1711], [1713, 1713, 1791, 1791, 1913], [1915, 1915, 1977, 1977, 3159], [3161, 3161, 3216, 3216, 3715]], "test": "untested"}
{"id": "Mt2cRt", "name": "Simple 2D ray marching", "author": "syaoming", "description": "Spherical tracing with jittered sampling.\nLooks like a disk-shaped volumetric light.", "tags": ["raymarching"], "likes": 2, "viewed": 214, "published": "Public", "date": "1509858573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////\n// Global variables\n\nconst float PI = 3.1417;\nconst float PI2 = PI * 2.0;\n\n// sampling constants\nconst int SAMPLE = 64;\nconst float SAMPLE_F = float(SAMPLE);\n\n// ray-marching constants\nconst int MAX_STEP = 20;\nconst float EPSILON = 1e-3; // small enough, because distance is in pixels\n\n// the disk light\nfloat radius = 50.0; // radius in pixel\nconst float intensity = 3.0;\n\n\n////\n// Functions\n\n// signed distance function, of the disk\nfloat sdf(float px, float py)\n{\n    // SDF of a 2D disk, at the center of screen\n    float x = px - iResolution.x / 2.0;\n    float y = py - iResolution.y / 2.0;\n    return sqrt(x * x + y * y) - radius;\n}\n\n// ray-marching for a ray; return light intensity if hitted.\nfloat ray_marching(float ox, float oy, float dx, float dy)\n{\n    // ray: origin (ox, oy), direction (dx, dy)    \n    for (int i = 0; i < MAX_STEP; i++)\n    {\n        float sd = sdf(ox, oy);\n        if (sd < EPSILON)\n        {\n            return intensity;\n        }\n        ox += dx * sd;\n        oy += dy * sd;\n    }\n    return 0.0;\n}\n\n// a fake-randon function; copied from some webpage\nfloat rand(vec2 seed)\n{\n    return fract(sin(dot(seed ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// jittered sampling for fragment (ox, oy)\nfloat sampling(float ox, float oy)\n{    \n    float ret = 0.0;\n\n    float dx = 0.0;\n    float dy = 0.0;\n    vec2 seed = texture(iChannel0, vec2(ox / iResolution.x, oy / iResolution.y)).xy;\n    for (int i = 0; i < SAMPLE; i++)\n    {\n        // modify the seed each iteration\n\t\tseed.x += 0.368;\n        seed.y += 0.082;\n        \n        // jitterred degree-sampling\n        float deg = (float(i) + rand(seed)) / SAMPLE_F * PI2;\n        dx = cos(deg);\n        dy = sin(deg);\n        \n        ret += ray_marching(ox, oy, dx, dy);\n    }\n    \n    return ret / SAMPLE_F;\n}\n\n// main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    // compute volumetic lighting\n    const vec3 light_color = vec3(1.0, .95, .9);\n    float intensity = sampling(fragCoord.x, fragCoord.y);\n    float alpha = clamp(intensity, 0.0, 1.0); // saturate\n    \n    // blend the volumic lighting with background\n    fragColor.xyz = light_color * alpha + fragColor.xyz * (1.0 - alpha);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2cRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 440, 471, 520, 643], [645, 706, 766, 818, 1041], [1043, 1095, 1118, 1118, 1189], [1191, 1234, 1270, 1270, 1798], [1800, 1817, 1874, 1874, 2296]], "test": "untested"}
{"id": "Mt2cWy", "name": "Smiley smile", "author": "Dombass", "description": "you should smile more", "tags": ["smile"], "likes": 1, "viewed": 56, "published": "Public", "date": "1510068098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool c(vec2 uv, vec2 origin, float radius)\n{\n    float x2 = (uv.x+origin.x) * (uv.x+origin.x);\n    float y2 = (uv.y+origin.y) * (uv.y+origin.y);\n    \n    if (x2 + y2 < radius)\n    {\n    \treturn true;\n    }\n    \n    return false;\n}\n\nbool background(vec2 uv, vec2 origin, float radius)\n{\n    float x2 = (uv.x+origin.x) * (uv.x+origin.x);\n    float y2 = (uv.y+origin.y) * (uv.y+origin.y);\n    \n    if (x2 + y2 < radius)\n    {\n    \treturn true;\n    }\n    \n    return false;\n}\n\nbool onLine(vec2 uv, vec2 start, vec2 finish)\n{   \n    if (uv.x > start.x && uv.x < finish.x && uv.y > start.y && uv.y < finish.y)\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.,0.,0.,1.0);\n    \n    for (float x = 0.; x < 5.; x++)\n    {\n        for(float y = 0.; y < 50.; y++)\n        {\n            if (background(uv, vec2(-4.-(.05*x*cos(iTime))+ (0.3*y)+1.*sin(iTime), -.95 + 0.2*x), 0.005+.0005*sin(iTime)))\n            {\n                fragColor = vec4(0.2*x, 0.5+0.5*sin(iTime), 0.5+0.5*cos(iTime), 1.);\n            }\n        }\n    }\n    \n\n    \n    //head\n    if( c(uv, vec2(-0.5, -0.5), .05+(0.001*iTime)) )\n    {\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    }\n    \n    //eyes\n    if (c(uv, vec2(-0.4, -.55), .0005))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n    \n    if (c(uv, vec2(-0.6, -.55), .0005))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n   \n    //mouth\n    if (onLine(uv, vec2(0.35, 0.4), vec2(.65, .42)))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n    \n    //chin\n    if (onLine(uv, vec2(0.45, 0.35), vec2(.55, .37)))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n    \n    //nose\n    if (onLine(uv, vec2(0.475, 0.45), vec2(.525, .47)))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n    if (onLine(uv, vec2(0.52, 0.45), vec2(.525, .57)))\n    {\n        fragColor = vec4(0.,0.,0.,1.0);\n    }\n    \n        for (float x = -50.; x < 200.; x++)\n    {\n    \tif (onLine(uv, vec2(0.1+0.01*x*.75+0.25*sin(iTime), 0.), vec2(0.1+(0.01*x*.75+0.25*sin(iTime))+0.001, 1.)))\n        {\n        \tfragColor = vec4(0.,0.,0.,1.0);\n        }\n        \n        if (onLine(uv, vec2(0.,0.1+0.01*x*.75+0.25*cos(iTime)), vec2(1.,0.1+(0.01*x*.75+0.25*cos(iTime))+0.001)))\n        {\n        \tfragColor = vec4(0.,0.,0.,1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2cWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 230], [232, 232, 285, 285, 471], [473, 473, 520, 520, 661], [663, 663, 720, 720, 2381]], "test": "untested"}
{"id": "MtBcR3", "name": "Iq Apollonian Fork", "author": "aiekick", "description": "based on iq Apollonian [url=https://www.shadertoy.com/view/4ds3zn]Apollonian[/url]", "tags": ["fork", "apollonian"], "likes": 22, "viewed": 1710, "published": "Public API", "date": "1510969115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define PATTERN_TIME_EVOLUTION\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\n// iq Apollonian : https://www.shadertoy.com/view/4ds3zn\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n    float tt = 0.45+(sin(iTime*2.)*.5+.5)*.65;\n    \n#ifndef PATTERN_TIME_EVOLUTION\n   \ttt = 0.5;\n#endif\n    \n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n        \n        \n        r2 = r2 * tt + max(abs(p.x), max(abs(p.y),abs(p.z))) * (1.0 - tt);\n        \n        orb = min( orb, vec4(abs(p),r2) );\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd,1.6);\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBcR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[380, 437, 467, 467, 944], [946, 946, 994, 994, 1247], [1249, 1249, 1305, 1305, 1556], [1558, 1558, 1612, 1626, 2611], [2613, 2613, 2670, 2670, 3670], [3672, 3672, 3766, 3766, 3993]], "test": "untested"}
{"id": "MtBcWc", "name": "Steam Engine No.2", "author": "dr2", "description": "Two-cylinder steam engine (better than one)", "tags": ["mechanics", "kinematics"], "likes": 11, "viewed": 495, "published": "Public API", "date": "1510331369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Steam Engine No.2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nvec2 aCs[2], crCs[2], crMid[2];\nfloat tCur, dstFar, crRad, crLen, aRot;\nconst float pi = 3.14159;\nint idObj;\nconst int idWhl = 1, idSpk = 2, idCrnk = 3, idAx = 4, idPis = 5, idCrod = 6, idCyl = 7,\n   idCylEnt = 8, idValv = 9, idPipes = 10, idSup = 11, idBase = 12;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dz;\n  dMin = dstFar;\n  p.x -= 8.;\n  q = p;\n  q.xy = Rot2Cs (q.xy, aCs[0]);\n  q.z = abs (q.z) - 5.;\n  d = min (PrCylAnDf (q, 4., 0.15, 1.), PrCylDf (q, 0.6, 1.));\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (8. * atan (q.y, - q.x) / (2. * pi) + 0.5)) / 8.);\n  d = PrCylDf (vec3 (q.x + 2.2, q.y, abs (q.z) - 0.5).yzx, 0.2, 1.7);\n  if (d < dMin) { dMin = d;  idObj = idSpk; }\n  d = max (PrCylDf (p, 0.3, 6.1), 0.35 - abs (abs (p.z) - 2.));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  for (int k = 0; k < 2; k ++) {\n    dz = (k == 0) ? -2. : 2.;\n    q = p;\n    q.xy = Rot2Cs (q.xy, aCs[k]);\n    q.z += dz;\n    d = min (PrBoxDf (vec3 (q.x + 0.5 * crRad, q.y, abs (q.z) - 0.5), vec3 (0.5 * crRad, 0.2, 0.1)),\n       PrCylDf (vec3 (abs (q.x + 0.5 * crRad) - 0.5 * crRad, q.y, abs (q.z) - 0.5), 0.6, 0.1));\n    if (d < dMin) { dMin = d;  idObj = idCrnk; }\n    d = min (PrCylDf (vec3 (q.x + crRad, q.yz), 0.3, 0.65), d);\n    if (d < dMin) { dMin = d;  idObj = idAx; }\n    q = p;  q.z += dz;\n    q.xy = Rot2Cs (q.xy + crMid[k], crCs[k]);\n    d = min (PrCylDf (vec3 (abs (q.y) - 0.12, q.zx), 0.15, crLen - 0.5),\n       PrCylDf (vec3 (abs (q.x) - crLen, q.yz), 0.6, 0.15));\n    if (d < dMin) { dMin = d;  idObj = idCrod; }\n    q = p;  q.z += dz;  q.x -= - (4.5 + crMid[k].x + crLen * crCs[k].x);\n    d = PrCylDf (q.yzx, 0.25, 3.7);\n    if (d < dMin) { dMin = d;  idObj = idPis; }\n    d = PrCylDf ((q - vec3 (0.7, 1.7, 0.)).yzx, 0.07, 3.);\n    if (d < dMin) { dMin = d;  idObj = idPis; }\n    q.x -= 4.5;\n    d = PrCylDf (q, 0.3, 0.5);\n    if (d < dMin) { dMin = d;  idObj = idAx; }\n    d = min (min (PrCylDf ((q + vec3 (0.8, 0., 0.)).yzx, 0.6, 0.13),\n       PrCylDf ((q + vec3 (0.8, -0.8, 0.)).xzy, 0.08, 0.95)),\n       PrCylDf (vec3 (q.xy, abs (q.z) - 0.35), 0.7, 0.1));\n    if (d < dMin) { dMin = d;  idObj = idCrnk; }\n  }\n  q = p + vec3 (16.9, 0., 0.);  q.z = abs (q.z) - 2.;\n  d = PrCylDf ((q + vec3 (-3.5, 0., 0.)).yzx, 0.7, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idCylEnt;  qHit = q; }\n  d = PrCylDf (q.yzx, 1.5, 3.5);\n  if (d < dMin) { dMin = d;  idObj = idCyl;  qHit = q; }\n  q = p + vec3 (16.9, -1.7, 0.);  q.z = abs (q.z) - 2.;\n  d = PrCylDf (q.yzx, 0.5, 2.5);\n  if (d < dMin) { dMin = d;  idObj = idValv;  qHit = q; }\n  q = vec3 (abs (p.x + 16.9) - 1., p.y - 1.8, p.z);\n  d = min (PrCylDf (q, 0.37, 2.), PrCylAnDf ((q + vec3 (0., -1.2, 0.)).xzy, 0.3, 0.05, 1.));\n  if (d < dMin) { dMin = d;  idObj = idPipes;  qHit = q; }\n  d = min (PrBoxDf (vec3 (p.x, p.y + 1.6, abs (p.z) - 3.3), vec3 (0.5, 1.5, 0.2)),\n     PrBoxDf (vec3 (p.x, p.y + 1.6, p.z), vec3 (0.5, 1.5, 0.2)));\n  d = min (d, min (PrCylDf (vec3 (p.xy, abs (p.z) - 3.3), 0.5, 0.3),\n     PrCylDf (vec3 (p.xy, p.z), 0.5, 0.5)));\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  q = p + vec3 (0., -1.8, 0.);\n  d = PrCylDf ((q + vec3 (0., 0.6, 0.)).xzy, 0.15, 0.7);\n  q.xz = Rot2D (q.xz, 4. * aRot);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 4.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  d = min (d, PrCylDf ((q + vec3 (0.4, -0.1, 0.)).yzx, 0.05, 0.4));\n  if (d < dMin) { dMin = d;  idObj = idAx; }\n  d = PrSphDf (q + vec3 (0.7, -0.1, 0.), 0.15);\n  if (d < dMin) { dMin = d;  idObj = idPis; }\n  d = min (PrBoxDf (p + vec3 (8., 4., 0.), vec3 (13., 1., 3.5)),\n     PrBoxDf (p + vec3 (16.9, 2.5, 0.), vec3 (3., 1.4, 3.)));\n  if (d < dMin) { dMin = d;  idObj = idBase; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0005, -0.0005, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, qnBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    qnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, qnBlk), dot (u.yzx, qnBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, rg;\n  vec2 qBlk;\n  float dstObj, a, s, sh;\n  bool fxz;\n  aRot = -0.3 * 2. * pi * tCur;\n  aCs[0] = vec2 (cos (aRot), sin (aRot));\n  aCs[1] = vec2 (cos (aRot + pi), sin (aRot + pi));\n  crRad = 2.;\n  crLen = 5.;\n  for (int k = 0; k < 2; k ++) {\n    crMid[k].y = -0.5 * crRad * aCs[k].y;\n    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);\n    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;\n  }\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);\n    if (idObj == idBase) {\n      col4 = vec4 (0.1, 0.6, 0.1, 0.1);\n      if (abs (vn.y) < 0.01) {\n        rg = ro;\n        rg.y += 0.5;\n        fxz = (abs (vn.x) > 0.99);\n        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));\n        rg.xz *= sign (fxz ? vn.x : vn.z);\n        if (fxz) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      } else {\n        rg = ShGrid (ro.xz);\n        col4.r *= rg.y;\n        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);\n        if (vn.y > 0.99) {\n          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n          else vn.yx = Rot2D (vn.yx, rg.x);\n        }\n      }\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == idCyl) {\n      col4 = vec4 (0.7, 0.3, 0.1, 0.2);\n      a = atan (qHit.z, - qHit.y) / (2. * pi);\n      if (abs (vn.x) > 0.99) {\n        col4.r *= 1. - 0.3 * Fbm2 (4. * qHit.yz);\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *\n           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));\n      } else {\n        col4.r *= 1. - 0.3 * Fbm2 (4. * vec2 (8. * a, qHit.x));\n        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));\n        a = mod (32. * a, 1.);\n        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *\n           sign (a - 0.5) * sign (ro.z));\n      }\n    } else if (idObj == idWhl) {\n      if (abs (vn.z) < 0.01) qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);\n      col4 = vec4 (0.5, 0.5, 0.6, 0.1) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));\n    } else if (idObj == idSpk) {\n      col4 = 1.1 * vec4 (0.5, 0.5, 0.6, 0.2);\n    } else if (idObj == idCrnk) {\n      col4 = vec4 (0.4, 0.4, 0.5, 0.2);\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.6, 0.4, 0.1, 0.3);\n    } else if (idObj == idPis) {\n      col4 = vec4 (0.5, 0.5, 0.2, 0.3);\n    } else if (idObj == idCrod) {\n      col4 = vec4 (0.6, 0.5, 0.6, 0.3);\n    } else if (idObj == idCylEnt) {\n      col4 = vec4 (0.7, 0.4, 0.1, 0.2);\n      if (length (qHit.yz) < 0.33) col4.rgb *= 0.5;\n    } else if (idObj == idValv) {\n       col4 = vec4 (0.7, 0.4, 0.1, 0.2);\n       if (vn.x > 0. && length (qHit.yz) < 0.13) col4.rgb *= 0.5;\n    } else if (idObj == idPipes) {\n       col4 = (qHit.y < 0. || length (qHit.xz) > 0.3) ?\n          vec4 (0.7, 0.4, 0.1, 0.2) : vec4 (0.3, 0.2, 0., 0.);\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.05);\n      vn = VaryNf (32. * ro, vn, 1.);\n    }\n    sh = 0.5 + 0.5 * ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    col += col4.a * vec3 (0.4) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n  } else {\n    qBlk = mod (4. * BlkHit (ro, rd), 1.);\n    col = vec3 (1., 0.6, 0.6) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.1 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., -1., -40.);\n  zmFac = 3.7;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 70.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBcWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 818, 840, 840, 4300], [4302, 4302, 4335, 4335, 4512], [4514, 4514, 4535, 4535, 4739], [4741, 4741, 4763, 4763, 5048], [5050, 5050, 5084, 5084, 5438], [5440, 5440, 5477, 5477, 5699], [5701, 5701, 5733, 5733, 6277], [6279, 6279, 6314, 6314, 10259], [10261, 10261, 10314, 10314, 11218], [11220, 11220, 11252, 11252, 11352], [11354, 11354, 11387, 11387, 11414], [11416, 11416, 11458, 11458, 11509], [11511, 11511, 11564, 11564, 11625], [11627, 11627, 11672, 11672, 11775], [11777, 11777, 11834, 11834, 11917], [11919, 11919, 11949, 11949, 12007], [12009, 12009, 12040, 12040, 12104], [12138, 12138, 12162, 12162, 12292], [12294, 12294, 12319, 12319, 12505], [12507, 12507, 12528, 12528, 12683], [12685, 12685, 12714, 12714, 12926], [12928, 12928, 12967, 12967, 13151]], "test": "untested"}
{"id": "MtByRc", "name": "Log Spirals 1-17", "author": "pyBlob", "description": "Based on: https://www.shadertoy.com/view/MlBcR3\nDisplays log-spirals with n=1..17 branches.", "tags": ["visualization", "spiral", "opticalillusion", "neon", "logpolar"], "likes": 6, "viewed": 531, "published": "Public API", "date": "1509493629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LOG_POLAR\n#define RING_FREQ 1.0\n#define ANIM_MASTER 1.0\n\n#define PI radians(180.0)\n\n#define ANIM_TURN (anim_on && (mod(iTime, 24.0) < 16.0))\n#define ANIM_SCALE (anim_on && (mod(iTime + 8.0, 24.0) < 16.0))\n#ifndef ANIM_MASTER\n\t#define ANIM_MASTER 0.0\n#endif\n#define ANIM_AMPLITUDE (ANIM_MASTER * (0.5 - 0.5 * cos(iTime*PI/4.0)))\n#define TURN_FREQ (1.0*PI)\n#define SCALE_FREQ (1.0*PI)\n\nbool log_dot = false;\nbool anim_on = false;\nvec2 win_mouse;\nvec2 win_size;\nfloat win_scale = 1.0;\n\nvec4 red = vec4(1.0,0.0,0.0,1.0);\nvec4 green = vec4(0.0,1.0,0.0,1.0);\nvec4 black = vec4(0.0,0.0,0.0,1.0);\n\nfloat pingpong(float f, float n)\n{\n    return abs(mod(f, n*2.0) - n);\n}\n\nfloat steppy(float f)\n{\n    float t = mod(f, 1.0);\n    return floor(f)\n        + 1.5 * smoothstep(0.8, 0.86, t)\n        - 0.7 * smoothstep(0.86, 0.93, t)\n        + 0.2 * smoothstep(0.93, 1.0, t)\n    ;\n}\n\nvoid set_hue( inout vec4 fragColor, in vec2 uv)\n{\n    float hue = atan(uv.y, uv.x);\n    \n    fragColor = vec4(\n        0.5 + 0.5 * vec3(cos(hue - radians(0.0)), cos(hue - radians(120.0)), cos(hue - radians(240.0))),\n        1.0\n   \t);\n}\n\nvoid texture_uv( inout vec4 fragColor, in vec2 uv)\n{\n    uv -= 0.5;\n    \n    float p = atan(uv.y, uv.x);\n    float d = log(length(uv));\n    \n    float n = 1.0 + pingpong(steppy(iTime), 16.0);\n    \n    float a1 = (p + d) * n;\n    float a2 = (p - d) * n;\n    \n    float f1 = 0.0;\n    float f2 = 0.0;\n    f1 = smoothstep(0.7, 1.0, cos(a1));\n    f2 = smoothstep(0.7, 1.0, cos(a2));\n    \n    vec4 col;\n    set_hue(col, uv);\n    \n    fragColor = mix(black, col, f1 + f2);\n}\n\nvoid dot_uv( inout vec4 fragColor, in vec2 uv, in float frq)\n{\n    frq *= PI;\n    float dist = length(uv);\n    \n    vec4 col;\n    set_hue(col, uv);\n    \n    float f = abs(sin(log(dist) * frq));\n    if (log_dot)\n    \tf = smoothstep(0.0, 1.0, f / frq * win_size.y * 0.5);\n   \telse\n    \tf = smoothstep(0.0, 1.0, f * dist / frq * win_scale);\n    \n    fragColor = mix(col, fragColor, f);\n}\n\nvoid combined_uv( inout vec4 fragColor, in vec2 uv)\n{\n    if (ANIM_TURN)\n    {\n        uv -= win_mouse;\n        float angle = sin(iTime * TURN_FREQ) * ANIM_AMPLITUDE;\n        vec2 v1 = vec2(cos(angle), sin(angle));\n        vec2 v2 = vec2(-v1.y, v1.x);\n        uv = v1 * uv.x + v2 * uv.y;\n        uv += win_mouse;\n    }\n    \n    if (ANIM_SCALE)\n    {\n        uv -= win_mouse;\n        float scale = exp(cos(iTime * SCALE_FREQ) * ANIM_AMPLITUDE);\n        uv *= scale;\n        win_scale = 1.0/scale;\n        uv += win_mouse;\n    }\n    \n    texture_uv(fragColor, uv);\n    dot_uv(fragColor, (uv - win_mouse) * win_size, RING_FREQ);\n}\n\nvec2 log_polar( in vec2 pd )\n{\n    return vec2(cos(pd.x), sin(pd.x)) * exp(pd.y);\n}\n\nvec2 polar( in vec2 pd )\n{\n    return vec2(cos(pd.x), sin(pd.x)) * pd.y;\n}\n\nvec3 window( inout vec4 fragColor, in vec2 uv, in vec2 pos, in vec2 size, in bool enabled)\n{\n    vec3 mouse = vec3((iMouse.xy - pos) / size, 0.0);\n\n    uv -= pos;\n    uv /= size;\n    \n    if (iMouse.xy == vec2(0.0, 0.0))\n        mouse.xy = vec2(0.5, 0.5);\n    \n    win_size = size;\n    if (enabled)\n\t    win_mouse = mouse.xy;\n    \n    if (floor(uv) == vec2(0))\n    {\n        mouse.z = 1.0;\n        combined_uv(fragColor, uv);\n        \n        vec2 grid = abs(uv - floor(uv + 0.5)) * size;\n        if (min(grid.x, grid.y) < 1.0)\n            fragColor = mix(black, red, enabled ? 1.0 : 0.5);\n        \n    }\n    \n    return mouse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = max(min(vec2(150.0), vec2(iResolution.xx / 4.0)), vec2(iResolution.yy / 3.0));\n    vec3 mouse = window(fragColor, fragCoord,\n    \tvec2(10, iResolution.y - size.y - 10.0),\n        size,\n        true\n    );\n    \n    anim_on = true;\n    if (mouse.z == 0.0)\n    {\n        vec2 uv = fragCoord;\n        uv.x -= iResolution.x / 2.0;\n        \n        vec2 img = uv;\n        img /= iResolution.xy / 2.0;\n        img.x *= PI;\n        img.y *= 1.0;\n \n        #ifdef LOG_POLAR\n        \tlog_dot = true;\n        \timg = log_polar(img * vec2(1.0, 2.0) - vec2(0.0, 2.0));\n        #else\n        \timg = polar(img);\n        #endif\n        \n        combined_uv(fragColor, win_mouse + img);\n    }\n    \n    win_scale = 1.0;\n    log_dot = false;\n    window(fragColor, fragCoord,\n    \tvec2(iResolution.x - size.x - 10.0, iResolution.y - size.y - 10.0),\n        size,\n        false\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtByRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[598, 598, 632, 632, 669], [671, 671, 694, 694, 873], [875, 875, 924, 924, 1111], [1113, 1113, 1165, 1165, 1580], [1582, 1582, 1644, 1644, 1966], [1968, 1968, 2021, 2021, 2595], [2597, 2597, 2627, 2627, 2680], [2682, 2682, 2708, 2708, 2756], [2758, 2758, 2850, 2850, 3387], [3389, 3389, 3446, 3446, 4327]], "test": "untested"}
{"id": "MtByzc", "name": "Gradient Metaphor", "author": "notbloom", "description": "Orlando Bascunan - ", "tags": ["generativeanimation"], "likes": 1, "viewed": 82, "published": "Public", "date": "1509566530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Time multiplier\n    float t = 4000.0;\n    //Zoom\n    float z = 0.01;\n    float p = 0.5+0.5*cos(iTime*t+M_PI*z*(fragCoord.x-iResolution.x/2.0)*(fragCoord.y-iResolution.y/2.0));\n    fragColor = vec4(p,p,p,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtByzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 104, 126, 321]], "test": "untested"}
{"id": "MtfBDN", "name": "Contrast speed illusion", "author": "reinder", "description": "Both rectangles are moving at exactly the same speed.\n\nBased on the [url=https://scratch.mit.edu/projects/188838060/]flash implementation[/url] by Jim Cash and https://quote.ucsd.edu/anstislab/files/2012/11/2001-Footsteps-and-inchworms.pdf.", "tags": ["contrast", "illusion", "speed", "perception"], "likes": 20, "viewed": 938, "published": "Public API", "date": "1511863416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Contrast speed illusion. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/MtfBDN\n//\n// Both rectangles are moving at exactly the same speed.\n//\n// Based on the flash implementation by Jim Cash: https://scratch.mit.edu/projects/188838060/\n//\n// Research paper:\n//\n// https://quote.ucsd.edu/anstislab/files/2012/11/2001-Footsteps-and-inchworms.pdf\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = iResolution.x / 300.;\n    \n    float fade = smoothstep(0.1,0.2,abs(fract(iTime*.05+.5)-.5));\n    \n    vec3 bgpattern = vec3(round(fract(uv.x*20.*scale)-.02*scale));\n    // vec3 bgpattern = .6+.6*cos(6.28*uv.x*20.*scale+vec3(0,-2.1,2.1));\n    // vec3 bgpattern = vec3(.5+.5*sin(6.28*uv.x*20.*scale));\n    \n    vec3 c = mix(vec3(.7), bgpattern, fade);\n    \n    float p = fract(iTime*.1/scale);\n    float x = step(uv.x,p+.3/scale)*step(p,uv.x);\n    \n    c = mix(c, vec3(1,1,0), x*step(abs(uv.y-.3),.03));\n    c = mix(c, vec3(0,0,0.7), x*step(abs(uv.y-.7),.03));\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfBDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[0, 477, 534, 534, 1186]], "test": "untested"}
{"id": "MtffW8", "name": "Alien Spawning Pool", "author": "ChristinaCoffin", "description": "warning: code has lots of number constant hacks to get desired visual effect, see reference source for proper fbm+noise code as a starting point.", "tags": ["procedural", "fbm", "distortion"], "likes": 21, "viewed": 643, "published": "Public", "date": "1511721704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Alien Spawning Pool' by @christinacoffin \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// hacked up version of https://www.shadertoy.com/view/4s23zz#\n// See http://www.iquilezles.org/www/articles/warp/warp.htm for details\n// \n//\n#define iGlobalTime iTime\nfloat noise( in vec2 x )\n{\n    x.x +=0.3*cos(x.y+(iTime*0.3));//crawling under myyyy skinnn!\n    x.y +=0.3*sin(x.x);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n \n    //edit: using texture instead of textureLod so this compiles+runs on mobile\n    vec4 a_vec = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-32.0);\n\tvec4 b_vec = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-32.0);\n\tvec4 c_vec = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-32.0);\n\tvec4 d_vec = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-32.0);   \n   \n    float a = a_vec.x;\n    float b = b_vec.x;\n    float c = c_vec.x;\n    float d = d_vec.x;    \n    \n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.480,  0.60, -0.60,  0.480 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.15000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.63125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.996875;\n}\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    float ql = length( q );\n    q.x += 0.015*sin(0.11*iGlobalTime+ql*14.0);\n    q.y += 0.035*sin(0.13*iGlobalTime+ql*14.0);\n    q *= 0.7 + 0.2*cos(0.05*iGlobalTime);\n\n    q = (q+1.0)*0.5;\n\n    o.x = 0.5 + 0.5*fbm4( vec2(2.0*q*vec2(1.0,1.0)          )  );\n    o.y = 0.5 + 0.5*fbm4( vec2(2.0*q*vec2(1.0,1.0)+vec2(5.2))  );\n\n    float ol = length( o*o );\n    o.x += 0.003*sin(0.911*iGlobalTime*ol)/ol;\n    o.y += 0.002*sin(0.913*iGlobalTime*ol)/ol;\n\n\n    n.x = fbm6( vec2(4.0*o*vec2(1.0,1.0)+vec2(9.2))  );\n    n.y = fbm6( vec2(4.0*o*vec2(1.0,1.0)+vec2(5.7))  );\n\n    vec2 p = 11.0*q + 3.0*n;\n\n    float f = 0.5 + 0.85*fbm4( p );\n\n    f = mix( f, f*f*f*-3.5, -f*abs(n.x) );\n\n    float g = 0.5+0.5*sin(1.0*p.x)*sin(1.0*p.y);\n    f *= 1.0-0.5*pow( g, 7.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = (-iResolution.xy + 2.0*fragCoord.xy) /iResolution.y;\n    vec2 o, n;\n    float f = func(q, o, n);\n    vec3 col = vec3(-0.91620);  \n\tcol = mix( vec3(0.2,0.1,0.4), col, f ); \n    col = mix( vec3(0.2,0.1,0.4), col * vec3(0.13,0.05,0.05), f );\n    col = mix( col, vec3(0.19,0.9,0.9), dot(n,n)*n.x*1.357 );\n    col = mix( col, vec3(0.5,0.2,0.2), 0.5*o.y*o.y );\n\tcol += 0.05*mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.02,1.3,abs(n.y)+abs(n.x*n.x)) );\n    col *= f*(5.92+(1.1*cos(iTime)));//animate glowy translucent underbits\n   \n\tcol = mix( col, vec3(-1.0,0.2,0.4), 0.5*smoothstep(1.02,1.3,abs(n.y)+abs(n.x*n.x)) );   \n\tcol = mix( col, vec3(0.40,0.92,0.4), 0.5*smoothstep(0.602,1.93,abs(n.y)+abs(n.x*n.x)) );    \n    \n    vec2 ex = -1.* vec2( 2.0 / iResolution.x, 0.0 );\n    vec2 ey = -1.*vec2( 0.0, 2.0 / iResolution.y );\n\tvec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n    vec3 lig = normalize( vec3( 0.19, -0.2, -0.4 ) );\n    float dif = clamp( 0.03+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n    col *= bdrf/f;\n    col = vec3(0.8)-col;\n    col = col*col;\n    col *= vec3(0.8,1.15,1.2);    \n\tcol *= 0.45 + 0.5 * sqrt(16.0*p.x*p.y*p.y*(2.0-p.x)*(1.0-p.y)) * vec3(1.,0.3,0.);\n\n    col = clamp(col,0.0,1.0);\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtffW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 304, 330, 330, 994], [1051, 1051, 1073, 1073, 1322], [1324, 1324, 1346, 1346, 1654], [1656, 1656, 1702, 1702, 2472], [2474, 2474, 2500, 2500, 2545], [2548, 2548, 2605, 2605, 4064]], "test": "untested"}
{"id": "MtffWN", "name": "Spins", "author": "TechEpic", "description": "This wasn't the original plan, but an unintentional effect I decided to improve and release.\n\nMouse to move around.\n\nUPDATE: Removed some old code from when I was testing, should be much more efficient now.", "tags": ["grayscale", "iteration"], "likes": 2, "viewed": 175, "published": "Public", "date": "1511926730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 5.\n\n#define ZOOM 1.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.x;\n    float col = 0.0;\n    uv.x -= 0.5;\n    uv.y -= iResolution.y/iResolution.x/2.0;\n    \n    uv *= ZOOM;\n    \n    if(iMouse.z > 0.0) {\n    \tvec2 mv = iMouse.xy/iResolution.x;\n    \tmv.x -= 0.5;\n    \tmv.y -= iResolution.y/iResolution.x/2.0;\n   \t\tuv -= mv*ZOOM;\n    }\n    \n    vec2 branch = vec2(0);\n    vec2 relative;\n    float dir;\n    for(float i = 1.0; i <= ITERATIONS; i++) {\n    \trelative = uv-branch;\n        relative *= relative;\n        dir = atan(relative.y,relative.x);\n        dir *= 3.;\n        dir -= iTime / 3.;\n    \trelative = vec2(cos(dir), sin(dir));\n    \tbranch += relative/10./distance(uv, branch)*i;\n    }\n    float dist = distance(uv, branch);\n    col = dist/ITERATIONS/2.0;\n    \n\tfragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtffWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 95, 95, 873]], "test": "untested"}
{"id": "MtjyDt", "name": "Quadric Quadtree", "author": "paniq", "description": "Using Quadric Frustum Tracing to subdivide the screen where two quadrics intersect. Drag the mouse to see how ranges are evaluated for a given screen tile.", "tags": ["quadric", "intersection", "frustum"], "likes": 52, "viewed": 1786, "published": "Public API", "date": "1510745414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quadric Quadtree\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n#define SUBTRACTION 0\n#define UNION 1\n#define INTERSECTION 2\n\n// what operation to demonstrate\n#define CSG_MODE SUBTRACTION\n\nstruct surface2x3 {\n    float c[10];\n};\n\nstruct surface2x2 {\n    float c[6];\n};\n\n#define surface2x1 vec3\n\nconst float infinity = 1.0/0.0;\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);\n}\n\n// rotation matrix constructor from versor\nmat3 rotation (vec4 q) {\n    float n = dot(q,q);\n    vec4 qs = (n == 0.0)?vec4(0.0):(q * (2.0 / n));\n    vec3 w = qs.w * q.xyz;\n    vec3 x = qs.x * q.xyz;\n    vec3 y = qs.y * q.xyz;\n    float zz = qs.z * q.z;\n    return mat3(\n        1.0 - (y.y + zz), x.y + w.z, x.z - w.y,\n        x.y - w.z, 1.0 - (x.x + zz), y.z + w.x,\n        x.z + w.y, y.z - w.x, 1.0 - (x.x + y.y));\n}\n\n// swizzle the components of a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// performing this twice selects zxy\nvoid surface2x3_swizzle_yzx(in surface2x3 surf, out surface2x3 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float XZ = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tdest.c[0] = YY;\n\tdest.c[1] = ZZ;\n\tdest.c[2] = XX;\n\n    dest.c[3] = YZ;\n\tdest.c[4] = XY;\n\tdest.c[5] = XZ;\n\n    dest.c[6] = Y;\n\tdest.c[7] = Z;\n\tdest.c[8] = X;\n    dest.c[9] = surf.c[9];\n}\n\n// swap the x and y components of a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x2_swizzle_yx(in surface2x2 surf, out surface2x2 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1];\n\tfloat X = surf.c[3]; float Y = surf.c[4];\n    dest.c[0] = YY;\n    dest.c[1] = XX;\n    dest.c[2] = surf.c[2];\n    dest.c[3] = Y;\n    dest.c[4] = X;\n    dest.c[5] = surf.c[5];\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the partial differential for the given position (x y z)\nvec3 surface2x3_diff(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    return vec3(\n        2.0*A*p.x + D*p.y + E*p.z + G,\n    \tD*p.x + 2.0*B*p.y + F*p.z + H,\n    \tE*p.x + F*p.y + 2.0*C*p.z + I);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the value for the given position (x y z)\nfloat surface2x3_eval(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n    return A*p.x*p.x + B*p.y*p.y + C*p.z*p.z\n        + D*p.x*p.y + E*p.x*p.z + F*p.y*p.z\n        + G*p.x + H*p.y + I*p.z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the value for the given position (x y)\nfloat surface2x2_eval(in surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return A*p.x*p.x + B*p.y*p.y + C*p.x*p.y + D*p.x + E*p.y + F;\n}\n\n// transform a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// by a 4x3 matrix to yield a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\nvoid surface2x3_new(in vec4 quadric, in mat4 mtx, out surface2x3 surf) {\n    float A = quadric.x; float B = quadric.y; float C = quadric.z; float J = quadric.w;\n    vec3 ABC = vec3(A,B,C);\n    vec3 ABC2 = ABC*2.0;\n    surf.c[0] = dot(ABC, mtx[0].xyz*mtx[0].xyz);\n    surf.c[1] = dot(ABC, mtx[1].xyz*mtx[1].xyz);\n    surf.c[2] = dot(ABC, mtx[2].xyz*mtx[2].xyz);\n    surf.c[3] = dot(ABC2, mtx[0].xyz*mtx[1].xyz);\n    surf.c[4] = dot(ABC2, mtx[0].xyz*mtx[2].xyz);\n    surf.c[5] = dot(ABC2, mtx[1].xyz*mtx[2].xyz);\n    surf.c[6] = dot(ABC2, mtx[0].xyz*mtx[3].xyz);\n    surf.c[7] = dot(ABC2, mtx[1].xyz*mtx[3].xyz);\n    surf.c[8] = dot(ABC2, mtx[2].xyz*mtx[3].xyz);\n    surf.c[9] = dot(ABC, mtx[3].xyz*mtx[3].xyz) + J;\n}\n\nvoid transformed_quadric(vec4 coeffs, vec4 rot, vec3 pos, out surface2x3 surf) {\n    mat4 mtx = mat4(transpose(rotation(rot)));\n    mat4 translate = mat4(1.0);\n    translate[3] = vec4(-pos, 1.0);\n    surface2x3_new(coeffs, mtx * translate, surf);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and x\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_x(in surface2x3 surf, float x,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zx -> x\n    // y -> y\n    slice.c[0] = (XX*x + ZX)*x + ZZ;\n    slice.c[1] = YY;\n    slice.c[2] = XY*x + YZ;\n    slice.c[3] = X*x + Z;\n    slice.c[4] = Y;\n    slice.c[5] = O;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and y\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_y(in surface2x3 surf, float y,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zy -> x\n    // x -> y\n    slice.c[0] = (YY*y + YZ)*y + ZZ;\n    slice.c[1] = XX;\n    slice.c[2] = XY*y + ZX;\n    slice.c[3] = Y*y + Z;\n    slice.c[4] = X;\n    slice.c[5] = O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a projective line that goes through the origin and y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_perspective_plane(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n    slice[0] = (B*y + C)*y + A;\n    slice[1] = E*y + D;\n    slice[2] = F;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a xy plane that goes through z\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_ortho_plane_z(in surface2x3 surf, float z,\n\tout surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice.c[0] = A;\n    slice.c[1] = B;\n    slice.c[2] = D;\n    slice.c[3] = E*z + G;\n    slice.c[4] = F*z + H;\n    slice.c[5] = (C*z + I)*z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a vertical line that goes through x\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_x(in surface2x2 surf, float x,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = YY;\n    slice[1] = XY*x + Y;\n    slice[2] = (XX*x + X)*x + O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a horizontal line that goes through y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_y(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = XX;\n    slice[1] = XY*y + X;\n    slice[2] = (YY*y + Y)*y + O;\n}\n\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the coordinate of the inflection point\nvec2 surface2x2_center(in surface2x2 surf) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n\tfloat f = 1.0/(4.0*A*B - C*C);\n    return vec2(\n\t\t(C*E - 2.0*B*D)*f,\n        (C*D - 2.0*A*E)*f);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective ray that goes through the origin and (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_perspective_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = (A*p.x + E)*p.x + (D*p.x + B*p.y + F)*p.y + C;\n    slice[1] = G*p.x + H*p.y + I;\n    slice[2] = J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and an orthogonal ray that goes through (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_ortho_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = C;\n    slice[1] = E*p.x + F*p.y + I;\n    slice[2] = (A*p.x + G)*p.x + (D*p.x + B*p.y + H)*p.y + J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_xy(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    ZZ *= 4.0;\n\tslice.c[0] = XX*ZZ - ZX*ZX;\n    slice.c[1] = YY*ZZ - YZ*YZ;\n    slice.c[2] = XY*ZZ - 2.0*ZX*YZ;\n    slice.c[3] = X*ZZ - 2.0*ZX*Z;\n    slice.c[4] = Y*ZZ - 2.0*YZ*Z;\n    slice.c[5] = O*ZZ - Z*Z;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal yz plane\nvoid surface2x3_project_ortho_yz(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    XX *= 4.0;\n\tslice.c[0] = YY*XX - XY*XY;\n    slice.c[1] = ZZ*XX - ZX*ZX;\n    slice.c[2] = YZ*XX - 2.0*XY*ZX;\n    slice.c[3] = Y*XX - 2.0*XY*X;\n    slice.c[4] = Z*XX - 2.0*ZX*X;\n    slice.c[5] = O*XX - X*X;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal zx plane\nvoid surface2x3_project_ortho_zx(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tslice.c[0] = ZZ*YY - YZ*YZ;\n    slice.c[1] = XX*YY - XY*XY;\n    slice.c[2] = ZX*YY - 2.0*YZ*XY;\n    slice.c[3] = Z*YY - 2.0*YZ*Y;\n    slice.c[4] = X*YY - 2.0*XY*Y;\n    slice.c[5] = O*YY - Y*Y;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the slice of the line that describes the contour of the surface\n// observed from the orthogonal x plane\nvoid surface2x2_project_ortho_x(in surface2x2 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n\tfloat X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n    YY *= 4.0;\n\tslice[0] = XX*YY - XY*XY;\n    slice[1] = X*YY - 2.0*XY*Y;\n    slice[2] = O*YY - Y*Y;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_z(in surface2x3 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tfloat NXX = ZZ*YY - YZ*YZ;\n    float NYY = (XX*YY - XY*XY)*4.0;\n    float NXY = ZX*YY - 2.0*YZ*XY;\n    float NY = X*YY - 2.0*XY*Y;\n\tslice[0] = NXX*NYY - NXY*NXY;\n    slice[1] = (Z*YY - 2.0*YZ*Y)*NYY - 2.0*NXY*NY;\n    slice[2] = (O*YY - Y*Y)*NYY - NY*NY;\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(float A, float B, float C) {\n    // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n    float a_neg_rcp = -1.0/A;\n    float k = 0.5*B*a_neg_rcp;\n    float q = sqrt(k*k + C*a_neg_rcp);\n    return k + vec2(-q,q);\n}\n\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return surface2x1_bounds(A, B, C);\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the coordinate of the inflection point\nfloat surface2x1_center(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return -B / (2.0*A);\n}\n\nstruct bounds2x3 {\n    vec3 v0, v1;\n    vec3 eh0_0, eh0_1, eh1_0, eh1_1;\n    vec3 ev0_0, ev0_1, ev1_0, ev1_1;\n    vec3 c00_0, c01_0, c10_0, c11_0;\n    vec3 c00_1, c01_1, c10_1, c11_1;\n};\n\nbool in_wedge(vec2 p, vec2 u) {\n    return (p.x >= u[0]*p.y) && (p.x <= u[1]*p.y);\n}\nbool in_frustum(vec3 p, vec2 u, vec2 v) {\n    return in_wedge(p.xz, u) && in_wedge(p.yz, v);\n}\n\nvoid merge_plane_range(inout vec2 front, inout vec2 back, vec2 p0, vec2 p1, vec2 u) {\n    front[0] = in_wedge(p0, u)?min(front[0], p0.y):front[0];\n    back[1] = in_wedge(p1, u)?max(back[1], p1.y):back[1];\n}\n\nvoid merge_corner_range(inout vec2 front, inout vec2 back, float z0, float z1) {\n    front[0] = min(front[0], z0);\n    back[1] = max(back[1], z1);\n    front[1] = max(front[1], (z0 == z0)?z0:infinity);\n    back[0] = min(back[0], (z1 == z1)?z1:-infinity);\n}\n\nvec4 compute_bounds(bounds2x3 bounds, vec2 u, vec2 v) {\n    vec2 front = vec2(infinity, -infinity);\n    vec2 back = vec2(infinity, -infinity);\n\n    front[0] = in_frustum(bounds.v0, u, v)?min(front[0], bounds.v0.z):front[0];\n    back[1] = in_frustum(bounds.v1, u, v)?max(back[1], bounds.v1.z):back[1];\n\n    merge_corner_range(front, back, bounds.c00_0.z, bounds.c00_1.z);\n    merge_corner_range(front, back, bounds.c01_0.z, bounds.c01_1.z);\n    merge_corner_range(front, back, bounds.c10_0.z, bounds.c10_1.z);\n    merge_corner_range(front, back, bounds.c11_0.z, bounds.c11_1.z);\n\n    merge_plane_range(front, back, bounds.eh0_0.yz, bounds.eh0_1.yz, v);\n    merge_plane_range(front, back, bounds.eh1_0.yz, bounds.eh1_1.yz, v);\n    merge_plane_range(front, back, bounds.ev0_0.xz, bounds.ev0_1.xz, u);\n    merge_plane_range(front, back, bounds.ev1_0.xz, bounds.ev1_1.xz, u);\n\n    front[1] = min(front[1], back[1]);\n    back[0] = max(back[0], front[0]);\n    return vec4(front, back);\n}\n\nvoid compute_bounding_points_compact(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n    float surf_c7_c7 = surf.c[7]*surf.c[7];\n    float surf_2x_c0 = 2.0*surf.c[0];\n    float surf_2x_c1 = 2.0*surf.c[1];\n    float surf_2x_c3 = 2.0*surf.c[3];\n    float surf_2x_c6 = 2.0*surf.c[6];\n    float surf_4x_c1 = 4.0*surf.c[1];\n\n    {\n\t    float surf_4x_c0_c1_sub_c3_c3 = surf_2x_c0*surf_2x_c1 - surf.c[3]*surf.c[3];\n\n        // extract contour of quadratic along z plane\n        float NXY = surf.c[4]*surf_4x_c1 - surf.c[5]*surf_2x_c3;\n        float NY = surf.c[6]*surf_4x_c1 - surf.c[7]*surf_2x_c3;\n        float NYY = surf_4x_c0_c1_sub_c3_c3*4.0;\n\n        // compute z bounds of volume\n        vec2 vz = surface2x1_bounds(\n        \t(surf.c[2]*surf_4x_c1 - surf.c[5]*surf.c[5])*NYY - NXY*NXY,\n        \t(surf.c[8]*surf_4x_c1 - 2.0*surf.c[5]*surf.c[7])*NYY - 2.0*NXY*NY,\n        \t(surf.c[9]*surf_4x_c1 - surf_c7_c7)*NYY - NY*NY);\n        // extract quadratic of plane at volume z bounds\n        float slice_z0_c3 = surf.c[4]*vz[0] + surf.c[6];\n        float slice_z0_c4 = surf.c[5]*vz[0] + surf.c[7];\n\n        float slice_z1_c3 = surf.c[4]*vz[1] + surf.c[6];\n        float slice_z1_c4 = surf.c[5]*vz[1] + surf.c[7];\n\n        // compute position of contact points at volume z bounds\n        float f = 1.0/surf_4x_c0_c1_sub_c3_c3;\n        bounds.v0 = vec3(\n            (surf.c[3]*slice_z0_c4 - surf_2x_c1*slice_z0_c3)*f,\n            (surf.c[3]*slice_z0_c3 - surf_2x_c0*slice_z0_c4)*f,\n        \tvz[0]);\n        bounds.v1 = vec3(\n            (surf.c[3]*slice_z1_c4 - surf_2x_c1*slice_z1_c3)*f,\n            (surf.c[3]*slice_z1_c3 - surf_2x_c0*slice_z1_c4)*f,\n        \tvz[1]);\n    }\n\n    // compute z bounds of corner quadratics\n    // compute position of contact points at corner z bounds\n    {\n    \tfloat surf_2x_c7 = 2.0*surf.c[7];\n        float surf_c1_v0 = surf.c[1]*v[0];\n        float surf_c7_v0 = surf.c[7]*v[0];\n        float surf_c1_v1 = surf.c[1]*v[1];\n        float surf_c7_v1 = surf.c[7]*v[1];\n\n        // compute z bounds of plane contours\n        // compute position of contact points at plane z bounds\n        float surf_2x_c1_neg_rcp = -1.0 / surf_2x_c1;\n\t    float surf_4x_c9_c1_sub_c7_c7 = surf.c[9]*surf_4x_c1 - surf_c7_c7;\n\n        {\n            float slice_x0_c0 = (surf.c[0]*u[0] + surf.c[4])*u[0] + surf.c[2];\n            float slice_x0_c2 = surf.c[3]*u[0] + surf.c[5];\n            float slice_x0_c3 = surf.c[6]*u[0] + surf.c[8];\n\n            {\n                vec2 cx0y0 = surface2x1_bounds((surf_c1_v0 + slice_x0_c2)*v[0] + slice_x0_c0, surf_c7_v0 + slice_x0_c3, surf.c[9]);\n                bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n                bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\n            }\n            {\n                vec2 cx0y1 = surface2x1_bounds((surf_c1_v1 + slice_x0_c2)*v[1] + slice_x0_c0, surf_c7_v1 + slice_x0_c3, surf.c[9]);\n                bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n                bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n            }\n            {\n                vec2 ph0 = surface2x1_bounds(slice_x0_c0*surf_4x_c1 - slice_x0_c2*slice_x0_c2, slice_x0_c3*surf_4x_c1 - slice_x0_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);\n                bounds.eh0_0 = vec3(ph0[0] * u[0], (slice_x0_c2*ph0[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[0]);\n                bounds.eh0_1 = vec3(ph0[1] * u[0], (slice_x0_c2*ph0[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[1]);\n            }\n\n        }\n        {\n            float slice_x1_c0 = (surf.c[0]*u[1] + surf.c[4])*u[1] + surf.c[2];\n            float slice_x1_c2 = surf.c[3]*u[1] + surf.c[5];\n            float slice_x1_c3 = surf.c[6]*u[1] + surf.c[8];\n\n            {\n                vec2 cx1y0 = surface2x1_bounds((surf_c1_v0 + slice_x1_c2)*v[0] + slice_x1_c0, surf_c7_v0 + slice_x1_c3, surf.c[9]);\n                bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n                bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n            }\n            {\n                vec2 cx1y1 = surface2x1_bounds((surf_c1_v1 + slice_x1_c2)*v[1] + slice_x1_c0, surf_c7_v1 + slice_x1_c3, surf.c[9]);\n                bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n                bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n            }\n            {\n                vec2 ph1 = surface2x1_bounds(slice_x1_c0*surf_4x_c1 - slice_x1_c2*slice_x1_c2, slice_x1_c3*surf_4x_c1 - slice_x1_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);\n                bounds.eh1_0 = vec3(ph1[0] * u[1], (slice_x1_c2*ph1[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[0]);\n                bounds.eh1_1 = vec3(ph1[1] * u[1], (slice_x1_c2*ph1[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[1]);\n            }\n\n        }\n    }\n\n    {\n\t    float surf_4x_c0 = 4.0*surf.c[0];\n    \tfloat surf_4x_c9_c0_sub_c6_c6 = surf.c[9]*surf_4x_c0 - surf.c[6]*surf.c[6];\n\n        // compute z bounds of plane contours\n        // compute position of contact points at plane z bounds\n        float surf_2x_c0_neg_rcp = -1.0 / surf_2x_c0;\n        {\n            float slice_y0_c0 = (surf.c[1]*v[0] + surf.c[5])*v[0] + surf.c[2];\n            float slice_y0_c2 = surf.c[3]*v[0] + surf.c[4];\n            float slice_y0_c3 = surf.c[7]*v[0] + surf.c[8];\n\n            vec2 pv0 = surface2x1_bounds(slice_y0_c0*surf_4x_c0 - slice_y0_c2*slice_y0_c2, slice_y0_c3*surf_4x_c0 - slice_y0_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev0_0 = vec3((slice_y0_c2*pv0[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[0] * v[0], pv0[0]);\n            bounds.ev0_1 = vec3((slice_y0_c2*pv0[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[1] * v[0], pv0[1]);\n        }\n\n        {\n            float slice_y1_c0 = (surf.c[1]*v[1] + surf.c[5])*v[1] + surf.c[2];\n            float slice_y1_c2 = surf.c[3]*v[1] + surf.c[4];\n            float slice_y1_c3 = surf.c[7]*v[1] + surf.c[8];\n\n            vec2 pv1 = surface2x1_bounds(slice_y1_c0*surf_4x_c0 - slice_y1_c2*slice_y1_c2, slice_y1_c3*surf_4x_c0 - slice_y1_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev1_0 = vec3((slice_y1_c2*pv1[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[0] * v[1], pv1[0]);\n            bounds.ev1_1 = vec3((slice_y1_c2*pv1[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[1] * v[1], pv1[1]);\n        }\n    }\n}\n\nvoid compute_bounding_points_clean(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n\n    surface2x1 contour_z;\n    // extract contour of quadratic along z plane\n    surface2x3_project_ortho_z(surf, contour_z);\n    // compute z bounds of volume\n    vec2 vz = surface2x1_bounds(contour_z);\n    surface2x2 slice_z0;\n    surface2x2 slice_z1;\n    // extract quadratic of plane at volume z bounds\n    surface2x3_ortho_plane_z(surf, vz[0], slice_z0);\n    surface2x3_ortho_plane_z(surf, vz[1], slice_z1);\n    // compute position of contact points at volume z bounds\n    bounds.v0 = vec3(surface2x2_center(slice_z0),vz[0]);\n    bounds.v1 = vec3(surface2x2_center(slice_z1),vz[1]);\n\n    // extract quadratic at planes\n    surface2x2 slice_x0;\n    surface2x2 slice_x1;\n    surface2x2 slice_y0;\n    surface2x2 slice_y1;\n\tsurface2x3_perspective_plane_x(surf, u[0], slice_x0);\n    surface2x3_perspective_plane_x(surf, u[1], slice_x1);\n\tsurface2x3_perspective_plane_y(surf, v[0], slice_y0);\n    surface2x3_perspective_plane_y(surf, v[1], slice_y1);\n\n    surface2x1 contour_h0;\n    surface2x1 contour_h1;\n    surface2x1 contour_v0;\n    surface2x1 contour_v1;\n    // extract contour of quadratics at planes\n    surface2x2_project_ortho_x(slice_x0, contour_h0);\n    surface2x2_project_ortho_x(slice_x1, contour_h1);\n    surface2x2_project_ortho_x(slice_y0, contour_v0);\n    surface2x2_project_ortho_x(slice_y1, contour_v1);\n    // compute z bounds of plane contours\n    vec2 ph0 = surface2x1_bounds(contour_h0);\n    vec2 ph1 = surface2x1_bounds(contour_h1);\n    vec2 pv0 = surface2x1_bounds(contour_v0);\n    vec2 pv1 = surface2x1_bounds(contour_v1);\n\n\n    surface2x1 slice_h0z0;\n    surface2x1 slice_h0z1;\n    surface2x1 slice_h1z0;\n    surface2x1 slice_h1z1;\n    surface2x1 slice_v0z0;\n    surface2x1 slice_v0z1;\n    surface2x1 slice_v1z0;\n    surface2x1 slice_v1z1;\n\n    // extract quadratic of line at plane z bounds\n    surface2x2_ortho_plane_x(slice_x0, ph0[0], slice_h0z0);\n    surface2x2_ortho_plane_x(slice_x0, ph0[1], slice_h0z1);\n    surface2x2_ortho_plane_x(slice_x1, ph1[0], slice_h1z0);\n    surface2x2_ortho_plane_x(slice_x1, ph1[1], slice_h1z1);\n    surface2x2_ortho_plane_x(slice_y0, pv0[0], slice_v0z0);\n    surface2x2_ortho_plane_x(slice_y0, pv0[1], slice_v0z1);\n    surface2x2_ortho_plane_x(slice_y1, pv1[0], slice_v1z0);\n    surface2x2_ortho_plane_x(slice_y1, pv1[1], slice_v1z1);\n\n    // compute position of contact points at plane z bounds\n    bounds.eh0_0 = vec3(ph0[0] * u[0], surface2x1_center(slice_h0z0), ph0[0]);\n    bounds.eh1_0 = vec3(ph1[0] * u[1], surface2x1_center(slice_h1z0), ph1[0]);\n    bounds.ev0_0 = vec3(surface2x1_center(slice_v0z0), pv0[0] * vec2(v[0],1.0));\n    bounds.ev1_0 = vec3(surface2x1_center(slice_v1z0), pv1[0] * vec2(v[1],1.0));\n    bounds.eh0_1 = vec3(ph0[1] * u[0], surface2x1_center(slice_h0z1), ph0[1]);\n    bounds.eh1_1 = vec3(ph1[1] * u[1], surface2x1_center(slice_h1z1), ph1[1]);\n    bounds.ev0_1 = vec3(surface2x1_center(slice_v0z1), pv0[1] * vec2(v[0],1.0));\n    bounds.ev1_1 = vec3(surface2x1_center(slice_v1z1), pv1[1] * vec2(v[1],1.0));\n\n    // extract quadratic of corners\n    surface2x1 slice_x0y0;\n    surface2x1 slice_x0y1;\n    surface2x1 slice_x1y0;\n    surface2x1 slice_x1y1;\n\tsurface2x2_perspective_plane(slice_x0, v[0], slice_x0y0);\n    surface2x2_perspective_plane(slice_x0, v[1], slice_x0y1);\n\tsurface2x2_perspective_plane(slice_x1, v[0], slice_x1y0);\n    surface2x2_perspective_plane(slice_x1, v[1], slice_x1y1);\n\n    // compute z bounds of corner quadratics\n    vec2 cx0y0 = surface2x1_bounds(slice_x0y0);\n    vec2 cx0y1 = surface2x1_bounds(slice_x0y1);\n    vec2 cx1y0 = surface2x1_bounds(slice_x1y0);\n    vec2 cx1y1 = surface2x1_bounds(slice_x1y1);\n\n    // compute position of contact points at corner z bounds\n    bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n    bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n    bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n    bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n    bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\n    bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n    bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n    bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n\n\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid setup_quadric(inout surface2x3 surf, float t) {\n    vec2 plane_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    vec4 plane_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    vec3 plane_normal = rotate(plane_rotation, vec3(0.0, 0.0, 1.0));\n    vec3 ellipsoid_size = vec3(1.0,3.0,1.0) * 0.3;\n    transformed_quadric(\n        vec4(1.0 / (ellipsoid_size*ellipsoid_size) * vec3(1.0,1.0,1.0),-1.0),\n\t\tplane_rotation, vec3(plane_offset + vec2(0.0,0.0),1.0), surf);\n}\n\nsurface2x3 surf3;\nsurface2x3 surf3_b;\n\nvoid setup_globals(float t) {\n\n    setup_quadric(surf3, t);\n    setup_quadric(surf3_b, -t*1.1 - 1.0);\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat distborder(float x) {\n\treturn 1.0 - clamp(x*400.0, 0.0, 1.0);\n}\n\nbool is_solid(vec4 range) {\n    return range[1] < range[2];\n}\n\nbool join_a_b(vec4 range_a, vec4 range_b) {\n    bool solid_a = is_solid(range_a);\n    bool solid_b = is_solid(range_b);\n    vec2 r_a = range_a.xy;\n    vec2 r_ae = range_a.zw;\n    vec2 r_b = range_b.xy;\n\n    bool used = false;\n    if ((range_a[0] != infinity) && (range_b[0] != infinity)) {\n        used = true;\n        if ((r_a[0] >= range_b[3]) || (r_a[1] <= range_b[0])) {\n            used = false;\n        }\n        #if 0\n        if ((r_ae[0] < r_b[1]) && (r_ae[1] > r_b[0])) {\n            used = true;\n        }\n        #endif\n    }\n\n    return used;\n}\n\nbool join_a_nb(vec4 range_a, vec4 range_b) {\n    bool solid_a = is_solid(range_a);\n    bool solid_b = is_solid(range_b);\n    vec2 r_a = range_a.xy;\n    vec2 r_ae = range_a.zw;\n    vec2 r_b = range_b.zw;\n\n    bool used = false;\n    if (range_a[0] != infinity) {\n        used = true;\n        if (range_b[0] != infinity) {\n            if (solid_b\n                && (r_a[0] >= range_b[1])\n                && (r_a[1] <= range_b[2])) {\n                used = false;\n            }\n            #if 1\n            if ((r_b[0] < r_ae[1]) && (r_b[1] > r_ae[0])) {\n                used = true;\n            }\n            #endif\n        }\n    }\n\n    return used;\n}\nbool join_na_b(vec4 range_a, vec4 range_b) {\n    bool solid_a = is_solid(range_a);\n    bool solid_b = is_solid(range_b);\n    vec2 r_a = range_a.zw;\n    vec2 r_ae = range_a.xy;\n    vec2 r_b = range_b.xy;\n\n    bool used = false;\n    if (range_a[0] != infinity) {\n        used = true;\n        if (range_b[0] != infinity) {\n            if ((r_a[0] >= range_b[3]) || (r_a[1] <= range_b[0])) {\n                used = false;\n            }\n            #if 1\n            if ((r_ae[0] < r_b[1]) && (r_ae[1] > r_b[0])) {\n               used = true;\n            }\n            #endif\n        } else {\n            used = false;\n        }\n    }\n\n    return used;\n}\n\nfloat cull_brushes(vec4 range_a, vec4 range_b, out bool use_a, out bool use_b) {\n    float z_occ = infinity;\n    bool solid_a = (range_a[1] < range_a[2]);\n    bool solid_b = (range_b[1] < range_b[2]);\n\tuse_a = false;\n    use_b = false;\n    \n#if (CSG_MODE == SUBTRACTION)\n    vec2 r_a = range_a.xy;\n    vec2 r_b = range_b.zw;\n    use_a = join_a_nb(range_a, range_b);\n    use_b = join_na_b(range_b, range_a);\n    if (use_a) {\n        if (solid_a) z_occ = min(z_occ, r_a[1]);\n    }\n    if (use_b) {\n        if (solid_b) z_occ = min(z_occ, r_b[1]);\n    }\n    if (range_a[0] > z_occ)\n        use_a = false;\n    if (range_b[0] > z_occ)\n        use_b = false;\n#elif (CSG_MODE == INTERSECTION)\n    vec2 r_a = range_a.xy;\n    vec2 r_b = range_b.xy;\n    use_a = join_a_b(range_a, range_b);\n    use_b = join_a_b(range_b, range_a);\n    if (use_a) {\n        if (solid_a) z_occ = min(z_occ, r_a[1]);\n    }\n    if (use_b) {\n        if (solid_b) z_occ = min(z_occ, r_b[1]);\n    }\n    if (range_a[0] > z_occ)\n        use_a = false;\n    if (range_b[0] > z_occ)\n        use_b = false;\n#else\n    vec2 r_a = range_a.xy;\n    vec2 r_b = range_b.xy;\n    use_a = range_a[0] != infinity;\n    use_b = range_b[0] != infinity;\n    if (use_a) {\n        if (solid_a) z_occ = min(z_occ, r_a[1]);\n    }\n    if (use_b) {\n        if (solid_b) z_occ = min(z_occ, r_b[1]);\n    }\n    if (range_a[0] > z_occ)\n        use_a = false;\n    if (range_b[0] > z_occ)\n        use_b = false;\n#endif    \n    return z_occ;\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);\n\n    //scale(0.3);\n\n    float rdot = AAINV*2.0;\n\n    vec2 p = get_origin();\n    surface2x1 surf1;\n    surface2x3_perspective_ray(surf3, p, surf1);\n    vec2 d = surface2x1_bounds(surf1);\n    d.x = min(infinity, d.x);\n    d.y = max(-infinity, d.y);\n\n    surface2x1 surf1b;\n    surface2x3_perspective_ray(surf3_b, p, surf1b);\n    vec2 db = surface2x1_bounds(surf1b);\n    db.x = min(infinity, db.x);\n    db.y = max(-infinity, db.y);\n\n    float z = infinity;\n    vec3 normal = vec3(0.5);\n    {\n    \tfloat q = d[0];\n#if (CSG_MODE == SUBTRACTION)\n        if ((q > db[0]) && (q < db[1])) {\n            q = infinity;\n        }\n#elif (CSG_MODE == INTERSECTION)\n        if ((q < db[0]) || (q > db[1])) {\n            q = infinity;\n        }\n#else\n#endif\n        if (q < z) {\n            z = q;\n            normal = normalize(surface2x3_diff(surf3, vec3(p,1.0)*q));\n        }\n    }\n    {\n\t\tfloat q;\n        float s = 1.0;\n#if (CSG_MODE == SUBTRACTION)    \n        q = db[1];\n        if ((q < d[0]) || (q > d[1])) {\n            q = infinity;\n        }\n        s = -1.0;\n#elif (CSG_MODE == INTERSECTION)\n        q = db[0];\n        if ((q < d[0]) || (q > d[1])) {\n            q = infinity;\n        }    \n#else\n\t    q = db[0];\n#endif\n        if (q < z) {\n            z = q;\n            normal = s*normalize(surface2x3_diff(surf3_b, vec3(p,1.0)*q));\n        }\n    }    \n\n    if ((z > 0.0) && (z != infinity)) {\n        vec3 pos = vec3(p,1.0) * z;\n        vec3 color = (normal * 0.5 + 0.5);\n\n        color = clamp(color, vec3(0.0), vec3(1.0));\n        set_source_rgb(color);\n        clear();\n    } else {\n        set_source_rgb(vec3(0.0,0.0,0.2));\n        clear();\n    }\n\n    set_source_rgb(vec3(1.0));\n    set_line_width_px(1.3);\n    vec2 c0 = vec2(-2.0,-2.0);\n    vec2 c1 = vec2(2.0,2.0);\n    const int N = 9;\n    for (int i = 0; i <= N; ++i) {\n        vec2 c = (c0 + c1)*0.5;\n        vec2 h = (c1 - c0)*0.5;\n        if (p.x < c.x) {\n            c1.x = c.x;\n        } else {\n            c0.x = c.x;\n        }\n        if (p.y < c.y) {\n            c1.y = c.y;\n        } else {\n            c0.y = c.y;\n        }\n        vec2 u = vec2(c0.x,c1.x);\n        vec2 v = vec2(c0.y,c1.y);\n        vec4 range_a;\n        vec4 range_b;\n        bounds2x3 bounds;\n        compute_bounding_points_compact(surf3, u, v, bounds);\n        range_a = compute_bounds(bounds, u, v);\n        compute_bounding_points_compact(surf3_b, u, v, bounds);\n        range_b = compute_bounds(bounds, u, v);\n\n        bool use_a = false;\n        bool use_b = false;\n        cull_brushes(range_a, range_b, use_a, use_b);\n\n        if (use_a == use_b) {\n            if (!use_a)\n            \tset_source_rgb(vec3(0.3));\n            else\n                set_source_rgb(vec3(1.0));\n        } else if (use_a)\n            set_source_rgb(vec3(1.0, 0.5, 0.1));\n        else if (use_b)\n            set_source_rgb(vec3(0.1, 0.5, 1.0));\n        else\n            set_source_rgb(vec3(1.0, 0.0, 0.0));\n\n        if (!use_a || !use_b || (i == N)) {\n\t        rectangle(c0, c1 - c0);\n\t        stroke();\n            break;\n        }\n    }\n\n    if (iMouse.z > 0.5) {\n        vec4 range_a;\n        vec4 range_b;\n        vec2 m = get_query();\n        vec2 r = vec2(-1.0,1.0)*(1.0/64.0);\n        vec2 u = m.x + r;\n        vec2 v = m.y + r;\n        set_source_rgb(1.0,0.0,0.0);\n        rectangle(vec2(u[0],v[0]), vec2(u[1] - u[0],v[1] - v[0]));\n        stroke();\n        bounds2x3 bounds;\n        compute_bounding_points_compact(surf3, u, v, bounds);\n        range_a = compute_bounds(bounds, u, v);\n        compute_bounding_points_compact(surf3_b, u, v, bounds);\n        range_b = compute_bounds(bounds, u, v);\n        bool solid_a = (range_a[1] < range_a[2]);\n        bool solid_b = (range_b[1] < range_b[2]);\n\n        range_a = range_a*2.0 - 2.0;\n        range_b = range_b*2.0 - 2.0;\n        \n        bool use_a = false;\n        bool use_b = false;\n\t\tfloat z_occ = cull_brushes(range_a, range_b, use_a, use_b);\n        \n        range_a[1] = min(range_a[1], 2.0);\n        range_a[2] = max(range_a[2], -2.0);\n        range_b[1] = min(range_b[1], 2.0);\n        range_b[2] = max(range_b[2], -2.0);\n\n        float h = 0.05;\n        float y = -1.0 + h*3.0;\n        vec3 color_a = use_a?vec3(1.0, 0.5, 0.1):vec3(1.0,0.0,0.0);\n        vec3 color_b = use_b?vec3(0.1, 0.5, 1.0):vec3(1.0,0.0,0.0);\n        set_source_rgba(vec4(color_a,1.0));\n        rectangle(range_a[0], y, range_a[1] - range_a[0], h);\n        fill();\n        y -= h;\n        rectangle(range_a[2], y, range_a[3] - range_a[2], h);\n        fill();\n        y -= h;\n        set_source_rgba(vec4(color_b, 1.0));\n        rectangle(range_b[0], y, range_b[1] - range_b[0], h);\n        fill();\n        y -= h;\n        rectangle(range_b[2], y, range_b[3] - range_b[2], h);\n        fill();\n        set_source_rgb(vec3(1.0));\n        move_to(z_occ, y);\n        line_to(z_occ, y + h*4.0);\n        stroke();\n    }\n\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = sqrt(_color);\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    c = clamp(c, vec4(0.0), vec4(1.0));\n    c.rgb = c.rgb*c.rgb;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 409, 446, 446, 515], [517, 536, 560, 560, 592], [594, 645, 674, 674, 753], [755, 798, 822, 822, 1171], [1173, 1344, 1414, 1414, 1799], [1801, 1907, 1976, 1976, 2198], [2200, 2379, 2429, 2429, 2752], [2754, 2918, 2969, 2969, 3314], [3316, 3445, 3496, 3496, 3692], [3694, 3890, 3962, 3962, 4605], [4607, 4607, 4687, 4687, 4855], [4857, 5162, 5251, 5251, 5658], [5660, 5965, 6054, 6054, 6461], [6463, 6702, 6789, 6789, 7000], [7002, 7275, 7358, 7358, 7724], [7726, 7948, 8031, 8031, 8248], [8250, 8474, 8557, 8557, 8774], [8777, 8905, 8949, 8949, 9184], [9186, 9467, 9551, 9551, 9885], [9887, 10154, 10232, 10232, 10566], [10568, 10796, 10872, 10872, 11303], [11305, 11533, 11609, 11609, 12040], [12042, 12270, 12346, 12346, 12777], [12779, 12972, 13047, 13047, 13281], [13283, 13511, 13586, 13586, 14078], [14080, 14206, 14257, 14300, 14429], [14432, 14558, 14602, 14602, 14704], [14706, 14811, 14856, 14856, 14944], [15134, 15134, 15165, 15165, 15218], [15219, 15219, 15260, 15260, 15313], [15315, 15315, 15400, 15400, 15521], [15523, 15523, 15603, 15603, 15778], [15780, 15780, 15835, 15835, 16760], [16762, 16762, 16855, 16855, 22982], [22984, 22984, 23075, 23075, 27190], [27192, 27192, 27235, 27235, 27274], [27276, 27276, 27328, 27328, 27737], [27778, 27778, 27807, 27807, 27881], [33693, 33758, 33785, 33785, 33827], [33829, 33829, 33856, 33856, 33890], [33892, 33892, 33935, 33935, 34448], [34450, 34450, 34494, 34494, 35100], [35101, 35101, 35145, 35145, 35750], [35752, 35752, 35832, 35832, 37226], [37228, 37228, 37242, 37242, 42163], [42317, 42377, 42404, 42404, 42430], [42432, 42492, 42513, 42513, 42620], [42622, 42622, 42659, 42659, 42745], [42747, 42747, 42793, 42793, 42826], [42828, 42966, 42994, 42994, 43454], [43482, 43482, 43501, 43501, 43534], [43536, 43536, 43554, 43554, 43587], [43589, 43589, 43613, 43613, 43717], [43719, 43719, 43736, 43736, 43757], [43759, 43759, 43786, 43808, 44091], [44093, 44093, 44121, 44121, 44355], [44357, 44357, 44381, 44381, 44467], [44469, 44469, 44496, 44496, 44709], [44711, 44711, 44737, 44737, 44965], [44967, 44967, 44989, 44989, 45115], [45117, 45117, 45137, 45137, 45197], [45199, 45199, 45231, 45231, 45258], [45260, 45260, 45281, 45281, 45303], [45305, 45305, 45329, 45329, 45389], [45391, 45391, 45425, 45425, 45449], [45451, 45451, 45465, 45465, 45529], [45531, 45531, 45557, 45557, 45595], [45597, 45597, 45623, 45623, 45650], [45652, 45652, 45675, 45675, 45770], [45772, 45772, 45796, 45796, 45865], [45867, 45867, 45892, 45892, 45939], [45941, 45941, 45958, 45958, 46071], [46073, 46073, 46096, 46096, 46225], [46227, 46227, 46255, 46255, 46383], [46385, 46385, 46409, 46409, 46549], [46551, 46551, 46589, 46589, 46723], [46725, 46725, 46762, 46762, 46797], [46799, 46799, 46826, 46826, 46876], [46878, 46878, 46908, 46908, 46964], [46966, 46966, 46995, 46995, 47176], [47178, 47178, 47200, 47200, 47359], [47361, 47361, 47374, 47374, 47413], [47415, 47415, 47445, 47445, 47474], [47476, 47476, 47509, 47509, 47566], [47568, 47568, 47594, 47594, 47644], [47646, 47646, 47667, 47667, 47732], [47734, 47734, 47758, 47758, 47841], [47843, 47843, 47858, 47858, 47899], [47901, 47901, 47917, 47917, 47955], [47957, 47957, 47975, 47975, 48032], [48034, 48034, 48064, 48064, 48499], [48501, 48501, 48559, 48559, 48597], [48599, 48599, 48628, 48628, 48664], [48666, 48666, 48714, 48714, 48745], [48747, 48747, 48781, 48781, 48840], [48842, 48842, 48919, 48919, 49084], [49086, 49086, 49163, 49163, 49243], [49245, 49245, 49321, 49321, 49437], [49439, 49439, 49515, 49515, 49593], [49595, 49595, 49633, 49633, 49667], [49669, 49669, 49691, 49691, 49737], [49739, 49739, 49766, 49766, 49810], [49812, 49812, 49861, 49861, 50122], [50124, 50124, 50197, 50197, 50251], [50253, 50253, 50285, 50285, 50321], [50323, 50323, 50379, 50379, 50435], [50437, 50437, 50467, 50467, 50560], [50561, 50561, 50601, 50601, 50624], [50626, 50672, 50711, 50711, 51859], [51861, 51861, 51891, 51891, 51993], [51995, 51995, 52047, 52047, 52087], [52089, 52089, 52111, 52111, 52162], [52164, 52164, 52196, 52196, 52218], [52220, 52235, 52257, 52257, 52549], [52551, 52551, 52583, 52583, 52605], [52607, 52607, 52626, 52626, 52658], [52707, 52770, 52812, 52812, 52878], [52880, 52950, 53001, 53001, 53353], [53355, 53389, 53435, 53435, 53947], [53949, 54018, 54064, 54064, 54570], [54572, 54572, 54605, 54605, 54821], [54823, 54823, 54882, 54882, 54927], [54929, 54929, 54972, 54972, 55033], [55035, 55035, 55077, 55077, 55119], [55121, 55181, 55238, 55238, 55437]], "test": "untested"}
{"id": "MtjyWd", "name": "boys and girls", "author": "laserdog", "description": "experimenting with parametric motion and trails (https://www.shadertoy.com/view/Xl33D7)", "tags": ["metaballs", "parametric"], "likes": 9, "viewed": 263, "published": "Public", "date": "1510674085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318\n#define numBlobs 15\n\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\t\n    \n// source: http://iquilezles.org/www/articles/palettes/palettes.htm\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\n              in float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\n\nconst float radius = .07;\nconst float edgeWidth = .01;\nconst int numTrailParticles = 10;\nconst float trailLength = .3;\nconst float metaballThreshold = .8;\nconst float metaballRadius = .00325;\nconst float speedMultiplier = 1.1;\nvec2 getPos(float t, float aspect) {\n    float tx = t / aspect;\n    vec2 p = vec2(sin(2.2 * tx) + cos(1.4 * tx), cos(.3 * t) + sin(-1.9 * t));\n    p.y *= 0.2;\n    p.x *= 0.4;\n    return p;\n}\nfloat metaballFunc(vec2 pos, vec2 uv, float radius)\n{\n    return radius / length(uv - pos);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(.0, 0., .0);\n    vec3 colorFinal = vec3(0.);\n    float finalFactor = 0.;\n    float aspect = iResolution.x / iResolution.y;\n    float mb = 0.;\n    float[numBlobs] closeness;\n    float tot = 0.;\n    \n    for (int i = 0; i < numBlobs; i++)\n    {\n        float minDistance = 1.0;\n        float colorMul = 1.0;\n        for (int j = 0; j < numTrailParticles; j++) {\n            float pct = float(j) / float(numTrailParticles);\n            vec2 pos = getPos(iTime * speedMultiplier + float(i) * 1.5 - pct * trailLength, aspect);\n            float segmentLength = length(pos - uv);\n            minDistance = min(minDistance, segmentLength + pct * (radius + edgeWidth));\n            mb += metaballFunc(pos, uv, metaballRadius * pct);\n        }\n        finalFactor += smoothstep(radius + edgeWidth, radius, minDistance);\n    \tcloseness[i] = pow(1. / minDistance, 3.);\n    \ttot += closeness[i];\n    }\n    \n    for (int i = 0; i < numBlobs; i++) {\n    \tcolor += (closeness[i] / tot) * palette(float(i) / 2., p0);\n    }\n        \n    finalFactor += smoothstep(mb + .03, mb, metaballThreshold);\n    \n    fragColor = vec4(min(finalFactor, 1.) * color * 1.2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtjyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 229, 425, 425, 516], [746, 746, 782, 782, 936], [937, 937, 990, 990, 1030], [1031, 1031, 1088, 1088, 2359]], "test": "untested"}
{"id": "MtsBDr", "name": "sludge star", "author": "laserdog", "description": "teaching myself ray marching", "tags": ["raymarching", "noob"], "likes": 8, "viewed": 230, "published": "Public", "date": "1511678316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi  3.14159\n#define tau 6.28318\n\nconst float MAX_DISTANCE = 100.;\nconst float EPSILON = .0001;\nconst int NUM_MARCHES = 255;\n\nvec3 translate(vec3 pos, vec3 offset)\n{\n    return pos - offset;\n}\n\nvec3 scale(vec3 pos, vec3 scale)\n{\n    return pos / scale;\n}\n\n// iq's smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mergeSDF(float d1, float d2, float k)\n{\n    // higher k = more merging\n\treturn smin(d1, d2, k);\n}\n\nfloat sphereSDF(vec3 p) \n{\n    return length(p) - 1.;\n}\n\nfloat blobEffectSDF(vec3 p)\n{\n\tfloat res = sphereSDF(scale(p, vec3(.75))) * .75;\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 3; j++) \n        {\n        \tfloat angle = float(i) * 3. * pi / 4. + float(j) * 3. * pi / 4.;\n        \tvec3 dir = normalize(vec3(cos(angle), sin(angle), 0.));\n        \tvec3 offset = dir * abs(sin(1.5 * iTime + float(i + j) * .07)\n                                    *  float(j) * 2.35);\n            float size = .5 * pow(1. / float(j), .75);\n    \t\tres = mergeSDF(res, sphereSDF(scale(translate(p, offset),\n                                                vec3(size))) * size, .7);\n        }\n    }\n    return res;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return blobEffectSDF(p);\n}\n\nvec3 phong(vec3 normal, vec3 light, vec3 view)\n{\n    const vec3 ambientColor = vec3(1., 0., 1.);\n    const vec3 diffuseColor = vec3(0.9, 0., 0.7);\n    const vec3 specularColor = vec3(1., 1., 1.);\n    const float shininess = 16.;\n    const float ambientStrength = .25;\n    \n    vec3 diffuse = max(dot(normal, light), 0.) * diffuseColor;\n    // light is negated because the first argument to reflect is the incident vector\n    vec3 specular = pow(max(dot(reflect(-light, normal), view), 0.), shininess) * specularColor;\n    vec3 ambient = ambientStrength * ambientColor;\n    \n    return diffuse + specular + ambient;\n}\n\nvec3 gradient(vec3 pos)\n{\n    const vec3 dx = vec3(EPSILON, 0., 0.);\n    const vec3 dy = vec3(0., EPSILON, 0.);\n    const vec3 dz = vec3(0., 0., EPSILON);\n    \n    return normalize(vec3(\n    \tsceneSDF(pos + dx) - sceneSDF(pos - dx),\n        sceneSDF(pos + dy) - sceneSDF(pos - dy),\n        sceneSDF(pos + dz) - sceneSDF(pos - dz)\n    ));\n}\n\nfloat distanceToShape(vec3 pos, vec3 dir)\n{\n    float tot = 0.;\n    for(int i = 0; i < NUM_MARCHES; i++) {\n        float dist = sceneSDF(pos);\n        if (dist < EPSILON || tot > MAX_DISTANCE) {\n        \treturn tot;\n        }\n        \n        tot += dist;\n        pos += dir * dist;\n    }\n    return MAX_DISTANCE;\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, 0.),\n        vec4(u, 0.),\n        vec4(-f, 0.),\n        vec4(0., 0., 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 eye = vec3(0., 0., 7.5);\n    vec3 light = vec3(0., 3., 3.);\n    vec3 ray = normalize(vec3(uv, -1.));\n    \n    mat4 viewMat = lookAt(eye, vec3(0.), vec3(0., 1., 0.));\n    ray = (viewMat * vec4(ray, 1.)).xyz;\n    \n    float dist = distanceToShape(eye, ray);\n    vec3 pos = eye + ray * dist;\n    \n    fragColor = vec4(0.);\n    \n    if (dist < MAX_DISTANCE) {\n    \tfragColor.rgb = phong(normalize(gradient(pos)), normalize(light - pos), normalize(eye - pos));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 172, 172, 199], [201, 201, 235, 235, 261], [263, 282, 323, 323, 416], [418, 418, 463, 494, 521], [523, 523, 549, 549, 578], [580, 580, 609, 609, 1237], [1239, 1239, 1263, 1263, 1294], [1296, 1296, 1344, 1344, 1912], [1914, 1914, 1939, 1939, 2253], [2255, 2255, 2298, 2298, 2570], [2572, 2572, 2617, 2617, 2849], [2852, 2852, 2909, 2909, 3452]], "test": "untested"}
{"id": "MtsBR8", "name": "Continuous LOD Marching Cubes", "author": "huwb", "description": "Idea: continuous LOD marching squares by smoothly varying sample points, seems to work pretty well. LMB to add a blob under the cursor for fun, and to move the detail center.", "tags": ["lod", "sampling", "marchingcubes", "cdlod"], "likes": 19, "viewed": 626, "published": "Public", "date": "1511032082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Uses similar ideas to continuous level of detail clipmaps: https://www.shadertoy.com/view/MstGRn .\n// Emulates a basic implementation of 2D marching cubes (without any fanciness with Hermite data).\n// \n// Varies sample points smoothly to achieve continuous LOD. Just moving points seems to be enough to\n// get pretty good results. There are some artifacts that need polishing and could use more work.\n//\n// I think this could work well in full 3D with generated geometry, and is an interesting direction\n// for future work.\n//\n// Some relevant links:\n//  http://catlikecoding.com/unity/tutorials/marching-squares-3/\n//  https://github.com/Scrawk/Marching-Cubes-On-The-GPU\n//\n// Huw Bowles 2017\n\n#define VEL 20.\n\n// the function that is being sampled. geometry will be generate along the isoline\n// = 0.5 of this function\nfloat ImplicitFunction( vec2 x, float sep, float lod )\n{\n    vec2 y = x;\n    y.y -= iTime*VEL;\n\n    // hacky form of prefiltering - blend out stuff that is too high res for the lod\n    float result = 0.;\n    result += (texture( iChannel0, y/32000. ).x-0.5) * .7;\n    result += (texture( iChannel0, y/16000. ).x-0.5) * .5;\n    result += smoothstep( 64., 32., sep*(1.+lod) ) * (texture( iChannel0, y/ 8000. ).x-0.5) * .25;\n    result += smoothstep( 32., 16., sep*(1.+lod) ) * (texture( iChannel0, y/ 4000. ).x-0.5) * .125;\n    result += smoothstep( 8., 4., sep*(1.+lod) ) * (texture( iChannel0, y/ 1000. ).x-0.5) * .0625;\n    \n    result += .7;\n    result *= max(0., 1. - x.y/iResolution.y);\n    \n    if( iMouse.z > 0. )\n    {\n        float r = length(iMouse.xy-x);\n        //dens += 16.*cos(.05*r)/r;\n        result += 1.-smoothstep(0., 40., r);\n    }\n    \n    return result;\n}\n\nstruct Edge\n{\n    bool valid;\n    vec2 s; // start\n    vec2 e; // end\n};\nstruct EdgePair\n{\n    Edge e0;\n    Edge e1;\n};\n#if 0\n;\n#endif\n\nEdgePair g_EdgeTable[8];\n\nvoid InitMarchingCubeLUT()\n{\n    // the look up table copied from here:\n    // https://en.wikipedia.org/wiki/Marching_squares\n    \n    // no edges\n    g_EdgeTable[0].e0.valid = false;\n    g_EdgeTable[0].e1.valid = false;\n    \n    // one edge\n    g_EdgeTable[1].e0.valid = true;\n    g_EdgeTable[1].e0.s = vec2(0., .5);\n    g_EdgeTable[1].e0.e = vec2(.5, 0.);\n    g_EdgeTable[1].e1.valid = false;\n    \n    g_EdgeTable[2].e0.valid = true;\n    g_EdgeTable[2].e0.s = vec2(1., .5);\n    g_EdgeTable[2].e0.e = vec2(.5, 0.);\n    g_EdgeTable[2].e1.valid = false;\n    \n    g_EdgeTable[3].e0.valid = true;\n    g_EdgeTable[3].e0.s = vec2(0., .5);\n    g_EdgeTable[3].e0.e = vec2(1., .5);\n    g_EdgeTable[3].e1.valid = false;\n\n    g_EdgeTable[4].e0.valid = true;\n    g_EdgeTable[4].e0.s = vec2(.5, 1.);\n    g_EdgeTable[4].e0.e = vec2(1., .5);\n    g_EdgeTable[4].e1.valid = false;\n\n    // two edges\n    g_EdgeTable[5].e0.valid = true;\n    g_EdgeTable[5].e1.valid = true;\n    g_EdgeTable[5].e0.s = vec2(0., .5);\n    g_EdgeTable[5].e0.e = vec2(.5, 1.);\n    g_EdgeTable[5].e1.s = vec2(.5, 0.);\n    g_EdgeTable[5].e1.e = vec2(1., .5);\n    \n    g_EdgeTable[6].e0.valid = true;\n    g_EdgeTable[6].e0.s = vec2(.5, 0.);\n    g_EdgeTable[6].e0.e = vec2(.5, 1.);\n    g_EdgeTable[6].e1.valid = false;\n\n    g_EdgeTable[7].e0.valid = true;\n    g_EdgeTable[7].e0.s = vec2(.0, .5);\n    g_EdgeTable[7].e0.e = vec2(.5, 1.);\n    g_EdgeTable[7].e1.valid = false;\n}\n\nEdgePair LookupEdges(int mask)\n{\n    // symmetry! https://en.wikipedia.org/wiki/Marching_squares\n    if( mask > 7 ) mask = 15 - mask;\n    \n    return g_EdgeTable[mask];\n}\n\n// adjusts the vertex position to approximate the isosurface, given values\n// sampled at cube corners\nvec2 MakeVertexLerpData( vec2 p, float v00, float v01, float v10, float v11 )\n{\n    vec2 result = p;\n    \n\tif\t\t( p.y == 0. ) result.x = p.x * 2. * (0.5-v00) / (v10-v00);\n\telse if ( p.y == 1. ) result.x = p.x * 2. * (0.5-v01) / (v11-v01);\n\tif\t\t( p.x == 0. ) result.y = p.y * 2. * (0.5-v00) / (v01-v00);\n\telse if ( p.x == 1. ) result.y = p.y * 2. * (0.5-v10) / (v11-v10);\n    \n    // could do a second sample at new position and do a secant method step,\n    // but this may be too expensive in practive.\n        \n    return result;\n}\n\n// compute the 1 or 2 edges for this cube\nEdgePair GenerateEdges( vec2 x00, vec2 cubeSize, float sep, float lod )\n{\n    vec2 x10 = x00 + vec2(cubeSize.x,0.);\n    vec2 x01 = x00 + vec2(0.,cubeSize.y);\n    vec2 x11 = x00 + cubeSize;\n    \n    // minus 0.5 baked into the uses of vXY\n    float v00 = ImplicitFunction(x00, sep, lod);// - 0.5;\n    float v01 = ImplicitFunction(x01, sep, lod);// - 0.5;\n    float v10 = ImplicitFunction(x10, sep, lod);// - 0.5;\n    float v11 = ImplicitFunction(x11, sep, lod);// - 0.5;\n    \n    int mask = 0;\n    \n    if( v00 < 0.5 ) mask += 1;\n    if( v10 < 0.5 ) mask += 2;\n    if( v11 < 0.5 ) mask += 4;\n    if( v01 < 0.5 ) mask += 8;\n\n    EdgePair e = LookupEdges(mask);\n    \n    if( e.e0.valid )\n    {\n        e.e0.s = MakeVertexLerpData( e.e0.s, v00, v01, v10, v11 );\n        e.e0.e = MakeVertexLerpData( e.e0.e, v00, v01, v10, v11 );\n    }\n    if( e.e1.valid )\n    {\n        e.e1.s = MakeVertexLerpData( e.e1.s, v00, v01, v10, v11 );\n        e.e1.e = MakeVertexLerpData( e.e1.e, v00, v01, v10, v11 );\n    }\n    \n    return e;\n}\n\n// compute grid resolution, and interpolation factor between lods.\n// the resolution could be seeded directly by geometry.\nvoid ComputeSepLod(in vec2 x, in vec2 detailCenter, out float sep, out float lod )\n{\n    // detail driven by taxicab norm, this gives square isolines that can be a good\n    // fit to rectilinear world space textures. we use this in our Crest ocean renderer\n    // see slides: https://github.com/huwb/crest-oceanrender\n    float taxi = max(abs(x.x-detailCenter.x),abs(x.y-detailCenter.y));\n    float sepLin = taxi / 20.;\n    float sepLog = log2(sepLin);\n    float sepLogMin = 2.; // min spacing: 4\n    sepLog = max( sepLog, sepLogMin );\n    float sepLogFloor = floor(sepLog);\n    \n    sep = exp2( sepLogFloor );\n    lod = sepLog - sepLogFloor;\n}\n\n// compute the marching cube around the current pixel. ordinarily the cube\n// geometry would be submitted as vertices to a geometry shader explicitly. there is\n// currently some error in this function, especially visible at low lods.\nvoid ComputeCubeFromPixel(vec2 x, float sep, float lod, out vec2 x00, out vec2 cubeSize)\n{\n    cubeSize = vec2(sep);\n    \n    vec2 xrem = mod(x+vec2(0.,-iTime*VEL*.7-iMouse.y*0.), 2.*cubeSize);\n    x00 = x - xrem;\n    \n    // hackery to emulate smoothly changing cube sizes\n    \n    if( xrem.x < (1. - lod)*cubeSize.x )\n    {\n\t    cubeSize.x *= 1. - lod;\n    }\n    else\n    {\n        x00.x += (1. - lod)*cubeSize.x;\n        cubeSize.x *= 1. + lod;\n    }\n    if( xrem.y < (1. - lod)*cubeSize.y )\n    {\n\t    cubeSize.y *= 1. - lod;\n    }\n    else\n    {\n        x00.y += (1. - lod)*cubeSize.y;\n        cubeSize.y *= 1. + lod;\n    }\n}\n\nfloat Dot(vec2 x, vec2 c);\nfloat Line(vec2 x, vec2 a, vec2 b);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitMarchingCubeLUT();\n    \n    vec2 x = fragCoord;\n    \n    // detail center\n    vec2 detailCenter = vec2(.5-0.5*cos(.4*iTime),0.5) * iResolution.xy;\n    if( iMouse.z > 0. )\n        detailCenter = iMouse.xy;\n    \n    // compute grid resolution, and interpolation factor between lods.\n    float lod, sep;\n    ComputeSepLod( x, detailCenter, sep, lod );\n    \n    // compute the marching cube around the current pixel.\n    vec2 x00, cubeSize;\n\tComputeCubeFromPixel( x, sep, lod, x00, cubeSize);\n    \n    // compute 1 or 2 edges that pass through this cube\n    EdgePair e = GenerateEdges(x00, cubeSize, sep, lod);\n    \n    // draw the lines\n    if( e.e0.valid ) fragColor.xy += Line(x, x00 + e.e0.s * cubeSize, x00 + e.e0.e * cubeSize);\n    if( e.e1.valid ) fragColor.xy += Line(x, x00 + e.e1.s * cubeSize, x00 + e.e1.e * cubeSize);\n    \n    // draw the value at the center of the cube for debug vis\n    fragColor.b += clamp(.5+20.*(ImplicitFunction(x00+.5*cubeSize,max(cubeSize.x,cubeSize.y),0.)-.5),0.,.4);\n    // draw the cube corners for debug vis\n    if(iMouse.z > 0. || true)\n    {\n        float v = 0.;\n        v = max( v, Dot(x00,x) );\n        v = max( v, Dot(x00+cubeSize,x) );\n        v = max( v, Dot(x00+vec2(cubeSize.x,0.),x) );\n        v = max( v, Dot(x00+vec2(0.,cubeSize.y),x) );\n        fragColor += .6*v;\n    }\n    \n    fragColor.rgb += .1;\n}\n\n// Utility functions...\n\n// Return minimum distance between line segment vw and point p\n// HB: This code is not mine, I lost the reference, sorry original author!\nfloat line_d(vec2 p, vec2 v, vec2 w)\n{\n  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  float t = dot(p - v, w - v) / l2;\n  if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment\n  else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\nfloat Dot(vec2 x, vec2 c)\n{\n    float R = 1.5;\n    return smoothstep(R,0.,length(x-c));\n}\n\nfloat Line(vec2 x, vec2 a, vec2 b)\n{\n    float R = 2.;\n    return smoothstep(R,0.,line_d(x,a,b));\n}\n\n// transition points in opposite x direction\n/*if( xrem.x < (1.+lod)*cubeSize.x )\n{\ncubeSize.x *= 1. + lod;\n}\nelse\n{\nx00.x += (1.+lod)*cubeSize.x;\ncubeSize.x *= 1. - lod;\n}*/\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[715, 824, 880, 880, 1700], [1864, 1864, 1892, 2010, 3292], [3294, 3294, 3326, 3390, 3464], [3466, 3568, 3647, 3647, 4099], [4101, 4143, 4216, 4216, 5161], [5163, 5286, 5370, 5603, 5930], [5932, 6166, 6256, 6256, 6796], [6862, 6862, 6919, 6919, 8280], [8307, 8445, 8483, 8483, 9087], [9089, 9089, 9116, 9116, 9178], [9180, 9180, 9216, 9216, 9279]], "test": "untested"}
{"id": "MtsBW8", "name": "Buoyant Balls", "author": "dr2", "description": "Lots of balls", "tags": ["raymarch", "underwater"], "likes": 24, "viewed": 3608, "published": "Public API", "date": "1511810161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Buoyant Balls\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst vec3 bGrid = vec3 (2.);\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p, vec3 cId)\n{\n  vec3 h;\n  float s, d, r, a;\n  d = dstFar;\n  h = Hashv3v3 (cId);\n  if (h.x * step (2., length (cId.xz)) > 0.5) {\n    p -= bGrid * (cId + 0.5);\n    s = fract (64. * length (h));\n    s *= s;\n    r = 0.2 + 0.2 * bGrid.x * h.x * (1. - s) * abs (sin (3. * pi * h.y * (1. - s)));\n    a = h.z * tCur + h.x;\n    d = length (p - r * vec3 (cos (a), 0., sin (a))) - 0.4 + 0.3 * s;\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  dHit = eps;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    cId.xz = floor (p.xz / bGrid.xz);\n    p.y -= tCur * (1. + Hashfv2 (cId.xz));\n    cId.y = floor (p.y / bGrid.y);\n    d = ObjDf (p, cId);\n    s = (bGrid * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + eps);\n    if (d < eps || dHit > dstFar) break;\n    dHit += d;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDfN (vec3 p)\n{\n  vec3 cId;\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y -= tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return ObjDf (p, cId);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDfN (p + e.xxx), ObjDfN (p + e.xyy), ObjDfN (p + e.yxy), ObjDfN (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.25, 0.5, 1.), vec3 (0., 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.15 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj;\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = mix (vec3 (0.15, 0.35, 0.7), BgCol (reflect (rd, vn)), 0.8);\n    col = col * (0.4 + 0.1 * max (vn.y, 0.) + 0.5 * max (dot (vn, ltDir), 0.)) +\n       0.05 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col *= 0.3 + 0.7 * min (rd.y + 1., 1.5);\n    col = mix (col, bgCol, smoothstep (0.5 * dstFar, dstFar, dstObj));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.03 * pi * tCur;\n  el = 0.2 * pi * sin (0.02 * pi * tCur);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.6 * pi * mPtr.y;\n  }\n  tCur += 100.;\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vec3 (0.5);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  dstFar = 50.;\n  fragColor = vec4 (pow (ShowScene (ro, rd), vec3 (0.8)), 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (vec3 (dot (p, cHashVA3), dot (p + vec3 (1., 0., 0.), cHashVA3),\n     dot (p + vec3 (0., 1., 0.), cHashVA3))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 259, 291, 291, 680], [682, 682, 715, 715, 1262], [1264, 1264, 1287, 1287, 1436], [1438, 1438, 1459, 1459, 1665], [1667, 1667, 1689, 1689, 2110], [2112, 2112, 2147, 2147, 2696], [2698, 2698, 2751, 2751, 3583], [3617, 3617, 3641, 3641, 3701], [3703, 3703, 3727, 3727, 3910]], "test": "untested"}
{"id": "MtsBzn", "name": "MIPmap Demo", "author": "FabriceNeyret2", "description": "Pixel footprint in texture space. B,G frame = (dFdx,dFdy)\nRed: geometry used for x16 aniso.  Note axe is longer than B.\nB,G quads: squares of size |axisB|,|axisG|\nDash O: mean = MIPmap level\nO quads: ceil,floor levels\nWhite tiles: 8 pyramid texels fetched", "tags": ["antialiasing", "filtering", "ellipse", "anisotropic", "footprint"], "likes": 7, "viewed": 735, "published": "Public API", "date": "1510851266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "                                                    // --- find ellipse geometry\nvoid ellips(in mat2 M, out vec2 A0, out vec2 A1, out float r0, out float r1) {\n    vec2 I = M[0], J = M[1];                        // ellipse: P = cos(u).I + sin(u).J \n    float a = ( dot(J,J) - dot(I,I) ) / dot (I,J),  // -> search for extrema of length(P) \n          D = sqrt(a*a+4.),                         // get tan(u) -> s, c, axis*radii\n          t0 = (a+D)/2., t1 = (a-D)/2.;\n    A0 = (I + t0*J) / sqrt(1.+t0*t0);               // c = 1/sqrt(1+t²), s = t/sqrt(1+t²)\n    A1 = (I + t1*J) / sqrt(1.+t1*t1);               // axis also encodes radius\n    r0 = length(A0); A0 /= r0;\n    r1 = length(A1); A1 /= r1;\n          \n}\n\nfloat square(vec2 U,vec2 r, float e) {             // --- draw framed square\n    U = abs(U) - r/2.;\n    return abs(max(U.x,U.y)) - e/iResolution.y;\n}\nfloat square(vec2 U,float r, float e) { return square(U,vec2(r),e); }\nfloat squareF(vec2 U,float r, float e) {           // --- draw filled square\n    U = abs(U) - r/2.;\n    return step( max(U.x,U.y),0.);\n}\n\nfloat segment(vec2 u, vec2 a, vec2 b)  {           // --- draw line segment\n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat checker(vec2 U, float n) {                   // --- draw checker   \n    ivec2 V = ivec2( U * n ) % 2;        \n    return float( V.x == V.y );  \n}    \n\n#define rot(a)      mat2(cos(a),sin(a),-sin(a),cos(a))\n#define S(v)        smoothstep( 1./R.y, 0., v )\n#define blend(v,C)  O = mix(O, C, S(v) )\n#define spot(v,C)   blend ( 2.*(length(v) - r/R.y) , C )  \n\nvoid mainImage( out vec4 O, vec2 U )               // === draw MIPmap footprint\n{\n    vec2 R = iResolution.xy,\n         P = iMouse.xy,\n         e = vec2(1./R.y,0);\n    float t = iTime;\n    if (length(P)<10.) P = R*.5 + .15*R*vec2(cos(t),sin(t)); \n    U /= R.y; P /= R.y; \n         \n    O = vec4(.1+.1*checker(U,32.));                // --- (fake) texture   \n    O.a = 0.;\n    \n                                                   // --- drawing footprints\n    float r = .03*R.y;                             // \"pixel\" radius\n    vec4 red = vec4(1,0,0,1), blue = vec4(0,0,1,1), green = vec4(0,1,0,1),\n      orange = vec4(1,.6,.3,1), white = vec4(1), grey = vec4(.7,.7,.7,1), black = vec4(0,0,0,1);\n\n    mat2 J = mat2(3,6, 3.+3.*sin(t*.7),-5)/R.y;   // Jacobian of some pixel projection on texture\n\tJ = rot(.3*sin(t)) * J * (1.+.3*cos(t/2.));\n    \n    vec2 A,a, Q,q; float M,m, k,f,T;              // get ellipse geomtry for texture footprint\n    ellips(J, A,a,M,m); \n    Q = (U-P) * mat2(A/M,a/m)/R.y;\n    spot( Q , grey);                              // draw ellipse\n\tblend( segment(U, P,P+J[0]*r)/2., blue);      // draw footprint frame = ( dFdx, dFdy )\n\tblend( segment(U, P,P+J[1]*r)/2., green);\n    Q = (U-P) * mat2(A,a);\n\tblend( segment(U, P,P+A*M*r), red);           // draw ellipse axis\n\tblend( segment(U, P,P+a*m*r), red);\n    blend( square( Q, vec2(M,m)*r*2., 1.), red);  // footprint fitting rectangle ( used for x16 aniso)\n    \n                                                  // --- MIPmap footprint      \n    M = length(J[0]) *r*2.; \n    m = length(J[1]) *r*2.;\n    // log2( M );                                 // MIPmap level corresponding to M\n    // log2( m );                                 // MIPmap level corresponding to m\n    blend( square( U-P, M, 1.), blue);            // axis-aligned box \n    blend( square( U-P, m, 1.), green);\n    k = (M+m)/2.;\n    blend( square( U-P, k, 1.), orange*checker(U-P,128.));   // mean (constructor choice. Maybe max).\n    M = exp2(ceil(log2(k)));\n    m = exp2(floor(log2(k)));\n    f = fract(log2(k));\n    blend( square( U-P, M, .5), orange);          // trilinear: up stored level\n    blend( square( U-P, m, .5), orange);          // trilinear: bottom stored level\n    Q = U-floor(P/M)*M,\n    q = U-floor(P/m)*m;\n    T = 1.-O.a;\n    for( int i=0; i<4; i++ ) {                    // bilinear: 4 fetchs\n        vec2 C = vec2(i%2,i/2),                   // 2x2 index\n             G = abs(1.-C-fract(P/M)),            // weight for each\n             g = abs(1.-C-fract(P/m));\n        O += T* step(square( Q-M*C, M, .5), 0.);  // texels at upper level\n        O += T* step(square( q-m*C, m, .5), 0.);  // texels at downer level\n    \tO.r += T* squareF( Q-M*C, M, .5) *G.x*G.y*f*2.;      // painted with weight\n    \tO.g += T* squareF( q-m*C, m, .5) *g.x*g.y*(1.-f)*2.;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 81, 159, 159, 712], [714, 714, 752, 790, 863], [864, 864, 903, 903, 933], [934, 934, 974, 1010, 1070], [1072, 1072, 1112, 1147, 1235], [1237, 1237, 1269, 1310, 1388], [1598, 1598, 1679, 1679, 4423]], "test": "untested"}
{"id": "MtXBDr", "name": "[WST1] Boring stuff", "author": "Foxeh", "description": "First \"shader\" of mine, done for Shadertoy event in Wroclaw.\nStrong 2/10, but hey, that's a start, I guess!\n(I had fun trying things out regardless :)", "tags": ["fox"], "likes": 4, "viewed": 474, "published": "Public", "date": "1511615022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: [WTS1] Boring stuff, Author: K.K\n// This shader is prepared for the first Wroclaw Shader Competition \n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIGGRAPH Chapter from Wroclaw\n#define effect1 ((mod(t, ct) > 15.0 && mod(t, ct) < 30.0) || (mod(t, ct) > 90.0 && mod(t,ct) < 105.0))\n#define effect2 ((mod(t, ct) > 30.0 && mod(t, ct) < 45.0) || (mod(t, ct) > 105.0 && mod(t, ct) < 120.0))\n#define effect3 ((mod(t, ct) > 45.0 && mod(t, ct) < 60.0) || (mod(t, ct) > 120.0 && mod(t, ct) < 135.0))\n#define effect4 ((mod(t, ct) > 60.0 && mod(t, ct) < 75.0) || (mod(t, ct) > 135.0))\n#define rtimer (mod(t, ct) < 30.0 || (mod(t, ct) > 75.0 && mod(t, ct) < 105.0))\n#define txt1 (t > 8.5 && t < 8.65)\n#define txt2 (t> 12.8 && t < 12.95)\n#define txt3 (t> 15.7 && t < 15.85)\n#define txt4 (t > 17.1 && t < 17.25)\n#define txt5 (t > 18.1 && t < 18.25)\n#define txt6 (t > 19.3 && t < 19.65)\n#define txt7 (t > 150.0 && t < 160.0)\n#define nastyTimes (txt1 || txt2 || txt3 || txt4 || txt5 || txt6 || txt7)\n#define t iTime\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat magic(int ch, vec2 fragCoord) {\n    return mod(rand(vec2(fragCoord.y, iTime)), 1.0);\n}\n// txt encoding done with https://github.com/knarkowicz/ShadertoyText\nfloat GlyphSDF( vec2 p, float glyph ) {\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel0, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p ) {    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 20. * vec2( 1., glyphRatio );\n    if(txt7) { glyphScale = 7. * vec2(1., glyphRatio); }\n    vec2 t0 = floor( p / glyphScale );\n\n    uint v = 0u;\n    if(txt1) {\n        v = t0.y == 1. ? ( t0.x < 4. ? 538976288u : ( t0.x < 8. ? 538976288u : ( t0.x < 12. ? 1668248151u : 7823724u ) ) ) : v;\n        v = t0.x >= 0. && t0.x < 16. ? v : 0u;\n    } else if(txt2) {\n        v = t0.y == 1. ? ( t0.x < 4. ? 538976288u : ( t0.x < 8. ? 1180114976u : ( t0.x < 12. ? 1465196609u : 114u ) ) ) : v;\n  \t\tv = t0.x >= 0. && t0.x < 16. ? v : 0u;\n    } else if(txt3) {\n        v = t0.y == 0. ? ( t0.x < 4. ? 538976288u : 1296900128u ) : v;\n  \t\tv = t0.x >= 0. && t0.x < 8. ? v : 0u;\n    } else if(txt4) {\n        v = t0.y == 2. ? ( t0.x < 4. ? 1195854163u : ( t0.x < 8. ? 1213219154u : ( t0.x < 12. ? 1634222880u : 1919251568u ) ) ) : v;\n  \t\tv = t0.x >= 0. && t0.x < 16. ? v : 0u;\n    } else if(txt5) {\n        v = t0.y == 0. ? ( t0.x < 4. ? 1869768779u : ( t0.x < 8. ? 544436078u : ( t0.x < 12. ? 1885431875u : 7497076u ) ) ) : v;\n  \t\tv = t0.x >= 0. && t0.x < 16. ? v : 0u;\n    } else if(txt6) {\n        v = t0.y == 2. ? ( t0.x < 4. ? 544303392u : ( t0.x < 8. ? 1867522086u : 108u ) ) : v;\n        v = t0.y == 1. ? ( t0.x < 4. ? 1713381408u : ( t0.x < 8. ? 29295u : 0u ) ) : v;\n        v = t0.y == 0. ? ( t0.x < 4. ? 1684105299u : ( t0.x < 8. ? 1867805285u : 8569u ) ) : v;\n        v = t0.x >= 0. && t0.x < 12. ? v : 0u;\n    } else if(txt7) {\n        v = t0.y == 6. ? ( t0.x < 4. ? 1663069769u : ( t0.x < 8. ? 543519585u : ( t0.x < 12. ? 544567161u : ( t0.x < 16. ? 1936943469u : ( t0.x < 20. ? 975201381u : ( t0.x < 24. ? 41u : 0u ) ) ) ) ) ) : v;\n        v = t0.y == 5. ? ( t0.x < 4. ? 1868854603u : ( t0.x < 8. ? 1869881459u : ( t0.x < 12. ? 541936928u : ( t0.x < 16. ? 544370534u : ( t0.x < 20. ? 543516788u : ( t0.x < 24. ? 1852143205u : ( t0.x < 28. ? 8564u : 0u ) ) ) ) ) ) ) : v;\n        v = t0.y == 4. ? ( t0.x < 4. ? 1970235475u : ( t0.x < 8. ? 1953853300u : ( t0.x < 12. ? 1919903264u : ( t0.x < 16. ? 1195987744u : ( t0.x < 20. ? 1095911239u : ( t0.x < 24. ? 639649872u : ( t0.x < 28. ? 1919437600u : ( t0.x < 32. ? 1936682607u : 33u ) ) ) ) ) ) ) ) : v;\n        v = t0.y == 3. ? 0u : v;\n        v = t0.y == 2. ? ( t0.x < 4. ? 639660393u : ( t0.x < 8. ? 1819234336u : ( t0.x < 12. ? 1919903264u : ( t0.x < 16. ? 1634226976u : ( t0.x < 20. ? 1953654116u : ( t0.x < 24. ? 2193775u : 0u ) ) ) ) ) ) : v;\n        v = t0.y == 1. ? ( t0.x < 4. ? 1630416430u : ( t0.x < 8. ? 1629512814u : ( t0.x < 12. ? 1948281964u : ( t0.x < 16. ? 1881171304u : ( t0.x < 20. ? 1819307877u : ( t0.x < 24. ? 101u : 0u ) ) ) ) ) ) : v;\n        v = t0.y == 0. ? ( t0.x < 4. ? 538976288u : ( t0.x < 8. ? 1752637472u : ( t0.x < 12. ? 1952522351u : ( t0.x < 16. ? 1701733748u : ( t0.x < 20. ? 8548u : 0u ) ) ) ) ) : v;\n        v = t0.x >= 0. && t0.x < 36. ? v : 0u;\n    }\n\tfloat c = float( ( v >> uint( 8. * t0.x ) ) & 255u );\n    \n    p = ( p - t0 * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. ) {\n    \tcolor = mix( vec3( .2 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float ct = 150.0;\n    \n    if(nastyTimes) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 p = 2. * uv - 1.;\n        p.x *= iResolution.x / iResolution.y;    \n        p = p * 100. - vec2( -150, -78 );\n\n        float woot = mod(t, ct);\n        vec3 col = vec3(0.0);\n        if(txt4) {\n        col = vec3(tan(woot), woot/100.0, sin(woot) * tan(woot));\n        } else {\n        col = vec3(cos(woot), mod(exp(woot), 1.0), tan(cos(uv.x)) * woot/100.0);\n        }\n        if(txt7) {\n            col = vec3(0.5);\n        }\n            \n        \n        Text( col, p );\n        fragColor = vec4( col, 1. );\n    }\n    if(!nastyTimes) {\n\n        int choice = 0;\n        \n        float t1 = 2.42;\n        float rot = radians(t * 45.0);\n        vec2 m = vec2(sin(rot), cos(rot));\n        vec2 q = fragCoord.xy / iResolution.xy;\n        vec2 p = (-1.0 + 2.0 * q) * vec2(iResolution.x / iResolution.y, 1.0) * m;\n        //vec2 q = fragCoord.xy / iResolution.xy;\n        //vec2 p = 2. * q - 1. * m;\n        mat2 re = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n        if(mod(t, 15.0) > 7.5) {\n\n            if(mod(floor(fragCoord.y), floor(2.0)) == floor(0.0)) {\n                fragCoord.x += 40.0;\n                choice = 1;\n            } else {\n                fragCoord.x -= 40.0;\n                choice = 2;\n            }\n        }\n\n\n        if(mod(t, ct) < 30.0 || mod(t, ct) > 60.0) {\n            p = (-1.0 + 2.0 * q) * vec2(iResolution.x / iResolution.y, 1.0);\n        } else if(mod(t, ct) > 45.0 && mod(t, ct) < 60.0) {\n            m = vec2(tan(rot), sin(rot)/cos(rot));\n            p = (-1.0 + 2.0 * q) * vec2(iResolution.x / iResolution.y, 1.0) * m / 2.0;\n        }\n\n        float d = abs(sin(length(p)*10.0+0.5)) + 0.6;\n        vec2 uv = vec2(p)/d;\n\n        if(rtimer || effect4) {\n            uv *= re; \n        }\n        uv = uv * (tan(t*t1));\n\n        float woot = mod(t, ct);\n        vec3 col = vec3(sin(woot), woot/100.0, tan(woot));\n\n        if(effect1) { //15-30s 90-105\n            col = vec3(woot/100.0, sin(woot), mod(exp(woot), 1.0) * tan(woot));\n        } else if(effect2) { //30-45s 105-120\n            woot = magic(choice, fragCoord.xy);\n            uv.y -= 0.2;\n            col = vec3(cos(woot), mod(exp(woot), 1.0), tan(cos(uv.x)) * woot/100.0);\n        } else if(effect3) { //45-60s 120-135\n            woot = magic(choice, fragCoord.xy);\n            uv.y -= 0.2;\n            col = vec3(tan(woot), woot/100.0, sin(woot) * tan(woot)); \n        } else if(effect4) { //60-75s 135-150\n            woot = magic(choice, fragCoord.xy);\n            col = vec3(mod(abs(exp(woot) - exp(fragCoord.x)) * sin(woot), 1.0),\n                       woot/100.0 * magic(choice, uv.xy) * sin(uv.y),\n                       sin(uv.x / 0.5 * uv.y));\n        }\n\n\n        if(mod(t, 30.0) < 15.0 || (mod(t, ct) > 60.0 && mod(t,ct) < 75.0)) { \n            col = col * 1.5 / d * (abs(sin(5.0 + mod(t, 4.0)))) * uv.x;\n        } else {\n            col = col * 1.5 / d * (abs(sin(5.0 + mod(t, 4.0)))) * uv.y;\n        }\n        col *= -1.0;\n        if(choice == 2 ) {\n            col *= -1.0;\n        } else if(mod(t, 30.0) < 15.0 && mod(t, ct) < 45.0) {\n            col *= mod(exp(mod(t, 15.0)), 1.0);\n        } else if(effect1) {\n            if(mod(t, 15.0) < 7.5)\n                col *= cos(exp(fragCoord.y/ uv.x));\n            else col *= cos(exp(fragCoord.y / uv.y)) * sin(uv.y / uv.x) * -1.0;\n        } else if(effect4) {\n            col *= mod(floor(exp(uv.x)) * uv.y * tan(rot), 1.0) * abs(sin(uv.x / uv.y));\n        }\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "MdSSzh", "previewfilepath": "https://soundcloud.com/dancewiththedead/screams-and-whispers", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dancewiththedead/screams-and-whispers", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1035, 1056, 1056, 1126], [1128, 1128, 1165, 1165, 1220], [1221, 1291, 1330, 1330, 1529], [1532, 1532, 1571, 1571, 4739], [4741, 4741, 4798, 4798, 8375]], "test": "untested"}
{"id": "MtXBWn", "name": "smallest Lissajoux (134 chars)", "author": "FabriceNeyret2", "description": "- solve for t :  U = R* ( .5+ .5* sin( vec2(2,3) * t ) )    -> 4 branches + modulos\n- do these in parallel in a vec4 + fract\n- add time as x vs y dephasing\n:-D", "tags": ["aliasing", "short", "onetweet", "golf", "loopless"], "likes": 8, "viewed": 520, "published": "Public API", "date": "1511602395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// O = length( U - iResolution.xy * ( .5+ .5* sin( vec2(2,3) * t ) ) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O.xy = asin( 4.* u / iResolution.xy - 2. ),\n    O.zw = - O.xy;\n    O =  O.xxzz / 2. - O.ywyw / 3. + iTime;\n    O = fwidth(O) / abs( fract( O * 1.9 ) -.5 ); O += O.a; }\n\n\n        \n         \n//  O = .5* fwidth(O) / abs( mod( O , .52 ) -.5 ); O += O.a\n               \n//  O = .5* fwidth(O) / mod( O , 3.14/6. ); O += O.a    // shorter but a bit aliased", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 72, 108, 108, 280]], "test": "untested"}
{"id": "MtXBWr", "name": "Equaliser | Bangers", "author": "Sedawrath", "description": "Good meme", "tags": ["equaliser", "bangers"], "likes": 3, "viewed": 203, "published": "Public", "date": "1511604296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\nvec2 CorrectAspectRatio(vec2 vec, vec2 iRes)\n{\n    vec = (( vec / iRes.xy) * 2.0) - 1.0;\n    vec.x *= iRes.x / iRes.y;\n    return vec;\n}\n\n//\nconst float INVERSE_MAX_UINT = 1.0 / 4294967295.0;\n \n// The GPU version of rand()\nfloat rand(uint seed, float range)\n{\n    uint i = (seed ^ 12345391u) * 2654435769u;\n    i ^= (i << 6u) ^ (i >> 26u);\n    i *= 2654435769u;\n    i += (i << 5u) ^ (i >> 12u);\n    return float(range * float(i)) * INVERSE_MAX_UINT;\n}\n \n// Helper function for rand()\nfloat ra(uint seed)\n{\n    return rand(seed++, 2.0) - 1.0;\n}\n\nfloat sdSphereBlur(vec2 uv, vec2 p, float r, float b) {\n    \n    float d = length(uv-p);\n    return smoothstep(r, r - b, d);\n}\n\nvec3 ColouringA(vec2 uv, vec2 p, float iMd, float mixer, float wave)\n{\n    uv = uv-p;\n    \n    uint seed = uint((iTime + iMd) * 10.);\n\tvec3 c = vec3(0);\n    // generate random values -1 to 1\n    vec3 r = vec3(ra(seed++), ra(seed++), ra(seed++));\n    \n    r = (r / .5) * (sin(10./iTime) + 1.0);\n\n    // Warps perspective of colours\n    c.r = r.r * (uv.x + sin(r.r + iTime));\n    c.g = r.g * (uv.y + tan(r.b + iTime));\n    c.b = c.r + r.b / sin(iTime);\n\n    c /= length(c)  * sin(iTime);\n\n    c.r /= mod(c.g, c.r);\n    c.g /= mod(c.b, c.g);\n    c.b /= mod(c.r, c.b);\n    c -= c.r * sin(0.5/r.b);\n    \n    if(mixer==1.0) {\n        r -= (r / .5) * (sin(1./iTime) + 1.0);\n\n        // Warps perspective of colours\n        c.r = r.r / length(sin(iTime)/uv.x) / sin(r.r) * wave;\n        c.g = r.g * length(tan(iTime)/uv.y) / cos(r.g * length(uv*wave)) * wave;\n\n        c = cos(-0.5/r);\n        c *= 0.001;\n    }\n    return c;\n}\n\nfloat GenerateBalls(vec2 uv, float mixer, float wave)\n{\n    float m = 0.0;\n    float maxS = 20.0 - (10.0 * mixer);\n    for(float i = 0.0; i < maxS; i+=1.0) {\n\t\t\n        float ang = (i/maxS) * (2. * 3.14) + mixer * (.1 * (tan(length(uv) / pow(iTime, wave))));\n        ang += sin(iTime);\n        float z =  1.5 * wave + (mixer * 1.0);\n        float cen = (i-(maxS/2.)) * 0.1;\n\n        float x = z * sin(ang);\n        float y = z * cos(ang);\n        vec2 p = vec2(x,y);\n        m += sdSphereBlur(uv, p, 0.12 + mixer * z/1.0, 0.1 + (mixer * 0.01));\n    }\n    \n    return m;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV definition\n    float m = 0.0;\n    vec3 c = vec3(0.0);\n    \n    //\n\tvec2 uv = CorrectAspectRatio(fragCoord.xy, \tiResolution.xy);\n    vec2 cP = vec2(iResolution.x,iResolution.y)/2. + vec2(sin(iTime), cos(iTime));\n    vec2 iM = CorrectAspectRatio(cP, iResolution.xy);\n    float iMDelta = length(iM.xy - uv.xy);\n    \n    vec2 p = vec2(0.0);\n    \n    int tx = int(uv.x/512.0);\n    float freq = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    float wave = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n    float mixer = ((freq > 0.39) && (wave > 0.8)) ? 1.0 : 0.0;\n    \n    //wave = mix(wave, pow(wave, exp(wave)), mixer);\n    \n    \n    c = ColouringA(uv, p, iMDelta, mixer, wave);\n    m = GenerateBalls(uv, mixer, wave);\n    \n    for(float i = 0.; i < 10.; i+= 1.0)\n   \t\tm += GenerateBalls(uv * (i * .75), mixer, wave);\n    \n    m = m - 1.0;// - (wave + mixer) * 1.;\n    //m += 1.0;\n    c = (c*m) + 1.0;\n    \n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "XsSXz1", "previewfilepath": "https://soundcloud.com/dylan-veprek/too-filthy-melbourne-edition-vol8-old-school-set-2703-4456", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dylan-veprek/too-filthy-melbourne-edition-vol8-old-school-set-2703-4456", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 3, 49, 49, 139], [197, 226, 262, 262, 454], [457, 487, 508, 508, 546], [548, 548, 603, 603, 674], [676, 676, 746, 746, 1595], [1597, 1597, 1652, 1652, 2168], [2171, 2171, 2228, 2249, 3171]], "test": "untested"}
{"id": "Xl2cDG", "name": "Thue-Morse Sequence Thing", "author": "Ykulvaarlck", "description": "Lines of the thue-morse offset by a constant number, and the difference between the middle lines and the rest of the lines.", "tags": ["fractal"], "likes": 4, "viewed": 115, "published": "Public", "date": "1509996090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hw(float a)\n{\n    float c = 0.0;\n    \n    for(int i = 0; i < 64; i++)\n    {\n        a = floor(a);\n        if(a == 0.0) break;\n        c += step(0.5, mod(a, 2.0));\n        a = a / 2.0;\n    }\n    \n    return c;\n}\n\nfloat fe(float a) // todo; find exponent (largest i such that 2^i divides a)\n{\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float wr = 128.0;\n    float hr = 64.0;\n    float np = 2.0;\n    float tw = 1.0;\n    \n    float it = iTime * tw;\n    it = floor(it) + smoothstep(0.5, 1.0, mod(it, 1.0));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ouv = uv;\n    uv.y = 1.0 - uv.y - 0.5;\n    uv.x *= wr;\n    float bw = hw(uv.x);\n    \n    uv.x += floor(uv.y * hr) * it;\n    uv.x = hw(uv.x);\n    uv.x += bw * step(0.5, ouv.x);\n    uv.x = mod(uv.x, np);\n    uv.x /= (np - 1.0);\n\tfragColor = vec4(uv.xxx, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2cDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 216], [218, 218, 296, 296, 314], [316, 316, 373, 373, 861]], "test": "untested"}
{"id": "Xl2cR3", "name": "Color Sines", "author": "TornAsunder", "description": "simple example of cumulative sine waves", "tags": ["sine"], "likes": 1, "viewed": 133, "published": "Public", "date": "1509628919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float f3 = 1.0 - abs(uv.y + sin(uv.x * 3.14159 * 4.0 + iTime)*0.5 - 0.5);\n    float f2 = 1.0 - abs(uv.y + sin(uv.x * 3.14159 * 3.0 + iTime)*0.5 - 0.5);\n    float f = 1.0 - abs(uv.y + sin(uv.x * 3.14159 * 2.0 + iTime)*0.5 - 0.5);\n    vec4 color = vec4(pow(f,3.0)*pow(f2,30.0), f*f*f*f2, pow(f3,4.0) * f2 * f,1);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2cR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 446]], "test": "untested"}
{"id": "XlBcDd", "name": "rainbow ripples", "author": "colinterface", "description": "this is my first shader, it sets the hue based on distance from the mouse. \n\ni got the hsv to rgb conversion code from here: \nhttps://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl", "tags": ["2d", "pulse", "mouse", "rainbow", "hsv", "concentric"], "likes": 3, "viewed": 273, "published": "Public", "date": "1510537051", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float range = 2.0;\n    float speed = 2.0;\n    float xOffset = sin(iTime * speed) * range;\n    float yOffset = cos(iTime * speed) * range;\n    vec2 center = iMouse.xy;\n    center.x += xOffset;\n    center.y += yOffset;\n    float hue = (distance(center, fragCoord.xy) / (yOffset + 70.0)) - iTime / 2.0;\n    float saturation = 1.0;\n    float value = 1.0;\n    vec3 c = vec3(hue, saturation, value);\n \tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n \tvec3 rgb = c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\n   \tfragColor.rgb = rgb;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 647]], "test": "untested"}
{"id": "XlfBRn", "name": "Quasicrystal", "author": "pn", "description": "sine waves from every angle\n\nhttp://wealoneonearth.blogspot.com/2011/10/animated-quasicrystals.html", "tags": ["2d", "pattern"], "likes": 18, "viewed": 306, "published": "Public", "date": "1510687563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float tau = 6.2831;\n\n// Feel free to change these:\nconst float magnification = 3.0;\nconst float periodTimeInSeconds = 10.0;\nconst int waveCount = 15; // odd numbers are more interesting\nconst bool stepped = false;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y * 1000.0;\n    float totalIntensity = 0.0;\n\tfloat recipWaveCount = 1.0 / float(waveCount);\n    float angle = tau * recipWaveCount;\n    mat2 rotation = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    vec2 direction = vec2(0, 1);\n   \tfor (int i = 0; i < waveCount; i++)\n    {\n        float spacePattern = dot(uv, direction) / magnification;\n        float timePattern = tau * iTime / periodTimeInSeconds;\n       \ttotalIntensity += sin(timePattern + spacePattern);\n        direction *= rotation;\n    }\n    totalIntensity *= recipWaveCount;\n    float smoothing = 0.02;\n    float steppedIntensity = smoothstep(-smoothing, smoothing, totalIntensity);\n    vec3 finalColor = vec3(stepped ? steppedIntensity : totalIntensity);\n\tfragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 221, 278, 278, 1107]], "test": "untested"}
{"id": "XlffW7", "name": "ColorCycler", "author": "kgoulding", "description": "Simple Color Cycle Shader", "tags": ["colorcycler"], "likes": 1, "viewed": 74, "published": "Public", "date": "1512063414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy; \n    vec4 texColor = texture(iChannel0,xy); \n    \n    float timeBit = abs(sin(iTime / 4.0));\n    \n    float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    gray = (gray - 0.5) * 2.0;\n    if (gray < 0.0) {\n     \tgray += 1.0;   \n    }\n    \n    float redShift = gray + timeBit; \n    if (redShift > 1.0) {\n     \tredShift -= 1.0;   \n    }\n    \n    texColor.r = 0.0;\n    texColor.g = redShift;\n    texColor.b = redShift;\n        ;\n    fragColor = texColor; \n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlffW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 570]], "test": "untested"}
{"id": "XlffWr", "name": "mandelzoomquick", "author": "t4ce", "description": "short implementation of mandelbrot visualization ", "tags": ["mandelbrotzoom"], "likes": 3, "viewed": 412, "published": "Public API", "date": "1511558499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mul(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom\n    float z = 1.0 - (float(iTime) / 10.0);\n    // slightly translate the view\n    float t = -0.05* float(iTime);\n    // map -2 to 1 on X Axis and 1 to -1 on Y Axis to iResolution\n    vec2 coord = vec2(fragCoord.x / iResolution.x * (3.0 * z) - (2.0 * z) + t, fragCoord.y / iResolution.y * (2.0 * z) - (1.0 * z) + t);  \n    // z0 = 0\n    vec2 cm = vec2(0, 0);\n    int j = 0;\n    for(int i = 0; i < 25; i++){\n        j++;\n        // zn = zn-1 + c\n        cm = mul(cm, cm);\n    \tcm = cm + coord;\n        if (dot(cm,cm) > 4.0)\n        \tbreak;\n    }\n    // grayscale\n    fragColor = vec4(j) / 24.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlffWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 139, 734]], "test": "untested"}
{"id": "XllBD8", "name": "felipepantone3", "author": "nshelton", "description": "experiment3", "tags": ["felipepantone"], "likes": 0, "viewed": 73, "published": "Public", "date": "1511767443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n    #define lineRot(a) mat2( sin(a), cos(a), cos(a), -sin(a))\n\nfloat line(vec2 uv)   \n{\n    float a = iTime;\n    uv -= 1.0;\n    uv =  lineRot(iTime*0.1) * uv;\n   \tfloat v = 1.5* abs(uv.y );\n    \n    return pow(v, 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 nuv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float n = 0.09;\n    uv.x = n * round(uv.x /n);\n    \n    vec2 delta = lineRot(iTime*0.03) * vec2(0.2, 0.2);\n    \n    //uv.y += round(sin(uv.x * 4.0 + iTime) * 2.0 + sin(uv.x* 84.0+ iTime* 6.0)) / 10.0;\n    uv.y = fract(uv.y/2.0  ) * 4.0 - 1.0;\n    uv.y = round(uv.y / n)*n;\n     \n    \n    uv.y += nuv.x;\n    \n    if( sin( 10.0 * lineRot(iTime*0.1) * (uv - 1.0) + iTime ). x > 0.0)\n    {\n     \tdelta = vec2(0.0);   \n    }\n\n    \n    vec3 col;\n    col.r = line(uv - delta);\n    col.g = line(uv);\n    col.b = line(uv + delta);\n    \n    col = pow(col, vec3(4.0));\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 88, 88, 221], [223, 223, 280, 280, 1014]], "test": "untested"}
{"id": "XllBDr", "name": "rotate ribbon", "author": "cailuming", "description": "useful tail,just for math trying", "tags": ["2d"], "likes": 0, "viewed": 97, "published": "Public", "date": "1511629187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WINGNUM 4.\n#define CAVATURE 20.\n\nvoid drawMisc(out vec4 fragColor, in vec2 uv ,vec2 center,float freq){\n  \n    vec2 p= uv-center;\n    float radius=length(p);\n    float angle=atan(p.y,p.x);\n   \n    float wings=sin(WINGNUM*angle+CAVATURE*radius*sin(iTime)+CAVATURE*cos(iTime));\n   \n   \n    float wingMdf=cos(5.*radius);\n    \n   \n    radius=0.3/radius*clamp(wings,.3,1.)*wingMdf;\n    \n    \n\tfragColor = vec4(radius*sin(iTime),radius*freq*cos(iTime),.2*radius,radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freq=smoothstep(0.1,1.,texture(iChannel0,vec2(0.5,0.5)).y);\n  \n    vec2 uv = fragCoord.xy / iResolution.y;\n    fragColor=vec4(0);\n    \n    drawMisc(fragColor,uv,vec2(0.8,0.5),freq);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 111, 111, 474], [476, 476, 533, 533, 727]], "test": "untested"}
{"id": "XllBW8", "name": "Night and day", "author": "draco_nite", "description": "I am a simple man who cannot read your fancy-schmancy raymarching shaders. Especially when you use one-character variables and no comments.", "tags": ["circle", "night", "day"], "likes": 1, "viewed": 181, "published": "Public", "date": "1511749005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 center = iResolution.xy / 2.;\n    #define radius 200.0\n    float r = radius;\n    \n    center.x += sin(iTime) * radius; // moves the circle left and right\n    r *= (cos(iTime) + 2.0) / 3.; // zooms the circle in and out\n\n    vec4 day =   vec4(1., .85, .28, 1.);\n    vec4 night = vec4(.22, 0., .72, 1.);\n   \t\n    float n; // n is the circle\n    \n    // this makes the circle boundary\n    if (distance(fragCoord, center) > r) {\n        n = 0.;\n    } else {\n        n = 1.;\n    }\n    \n    float lerpVal = (sin(iTime) + 1.) / 2.;\n    \n\tfragColor = n * mix(day, night, lerpVal); // vec4(n,n,n,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 702]], "test": "untested"}
{"id": "XllfD8", "name": "mandelbrot bezo97", "author": "bezo97", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 79, "published": "Public", "date": "1511773640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float AAradius=0.0f;\nfloat AAstep=0.5f;\nbool julia=false;\n\nint calc(float Cre, float Cim, float Zr, float Zi, int maxiter, float bailout, out float col)\n{\n    //iter\n    float Zre = Zr;\n    float Zim = Zi;\n    int iterCnt = 0;\n    while (Zre * Zre + Zim * Zim < bailout && iterCnt < maxiter)\n    {\n        float ZreTmp = Zre * Zre - Zim * Zim + Cre;\n        Zim = (2.0f * Zre * Zim + Cim);\n        Zre = (ZreTmp);\n        iterCnt++;\n    }\n\n    float fractIter = float(iterCnt);\n    if (iterCnt < maxiter)\n    {\n        float log_zn = log(Zre * Zre + Zim * Zim) / 2.0f;\n        float nu = log(log_zn / log(2.0f)) / log(2.0f);\n        fractIter = fractIter + 1.0f - nu;\n    }\n\n    col = fractIter;\n    return iterCnt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iTime*100.0f;    \n    float dX=-iMouse.x+iResolution.x/2.0f;\n    float dY=-iMouse.y+iResolution.y/2.0f;\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    float px = fragCoord.x;\n    float py = fragCoord.y;\n\n            //map position\n            vec3 acc;\n            for (float aax = -AAradius; aax <= AAradius; aax += AAstep)//anti-alias dolgok\n            {\n                for (float aay = -AAradius; aay <= AAradius; aay += AAstep)\n                {\n                    float colInterp = 0.0f;\n                    int iterNr;\n                    if (julia)\n                    {\n                        float Zr = float(px + dX - iResolution.x / 2.0f) / zoom;\n                        float Zi = float(py + dY - iResolution.y / 2.0f) / zoom;\n                        iterNr = calc(-0.4f, -0.6f, Zr, Zi, 255, 40.0f, colInterp);\n                    }\n                    else\n                    {\n                        float Cre = float(px + dX - iResolution.x / 2.0f + aax) / zoom;//-2 to 2\n                        float Cim = float(py + dY - iResolution.y / 2.0f + aay) / zoom;//-2 to 2\n                        iterNr = calc(Cre, Cim, 0.0f, 0.0f, 255, 40.0, colInterp);\n                    }\n\n                    float color1 = floor(float(iterNr) / 15.0f);\n                    float color2 = floor(float(iterNr+1) / 15.0f);\n                    colInterp = mix(color1, color2, fract(colInterp));//vagy mix\n                    vec3 colS = vec3(colInterp);\n\n\n                    float aar = sqrt(aax * aax + aay * aay);\n                    if (AAradius == 0.0f)\n                        aar = 0.0f;\n                    acc += colS*(1.0-aar);\n\n                }\n            }\n            float normalizalo = 1.5f*pow(2.0f * AAradius / AAstep, 2.0);//TODO cone filter normalizalas meg ide jon\n            if (AAradius == 0.0)\n                normalizalo = 1.0;\n   \t\t\tfragColor = vec4(acc / normalizalo,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 154, 165, 717], [719, 719, 776, 776, 2750]], "test": "untested"}
{"id": "XllfWH", "name": "Unsigned distance to hyperbola", "author": "mv", "description": "See explanation and description in comments. \n\nWith a focus on clarity and readablility, not performance.\n\n(Approximate) Line count:\nComments: 158\nWhitespace: 32\nCode: 50\nTotal: 240", "tags": ["distance", "hyperbola"], "likes": 3, "viewed": 492, "published": "Public API", "date": "1511790466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \n// We approximate the (unsigned) distance from a point in the plane to the right branch of\n// a hyperbola in canonical form. \n//\n// The hyperbola is defined such that any point on the hyperbola (green) is equidistant \n// to the surface of two circles (blue) of varying radius.\n//\n// Note: Any hyperbola can be reduced to canonical form by an appropriate change\n//       of coordinates, i.e. by scaling, rotating and translating. \n//\n// Note: For debugging purposes the background is colored according to the number of \n//       iterations required to terminate the Newton-Rhapson iteration, and not the distance. \n//\t\t Each band corresponds to one iteration.\n//\n\nfloat dist_circle(vec2 p, float r)\n{\n    //\n    // Calculates the (signed) distance to a circle\n    //\n\treturn length(p) - r;\n}\n\nvec3 dist_hyperbola(vec2 p, float a, float c)\n{\n    //\n    // Calculates the (unsigned) distance to a hyperbola (in canonical form)\n    // with foci on the x-axis\n    // \n    \n    //\n    // EXPLANATION/DERIVATION:\n    //\n    \n    //\n\t// Given a canonical hyperbola with foci (±c, 0) and vertices (±a, 0), then\n\t// \n\t//     (x/a)² - (y/b)² = 1\n\t// \n\t// holds for any point (x,y) on the hyperbola, where b² = c² - a².\n    // \n    // A possible parametrization of the right branch of this curve is \n    //\n    //     P(t) = (x(t), y(t)), \n    //\n    // where\n    //\n    //     x(t) = a cosh(t)\n    //     y(t) = b sinh(t)\n    //\n    // since\n    //\n    //     cosh²(t) - sinh²(t) = 1.\n    //\n    \n    //\n    // The distance between a point p = (x,y) and the curve P(t) is found by \n    // calculating the value of t such that the distance between P(t) and p \n    // is minimized, or symbolically:\n    //\n    //     d/dt |P(t) - p| = 0\n    // \n    // The absolute value isn't convenient to work with, so we'll work with the\n    // square instead, which has the same solution for t:\n    //\n    //     d/dt |P(t) - p|² = 0\n    //\n    // This is convenient form, because we can work with the dot product\n    //\n    //     f(t) = |P(t) - p|² = dot(P(t) - p, P(t) - p)\n    // \n    \n    //\n    // When differentiating, using the chain rule, we get \n    // \n    //     d/dt (P(t) - p)² = 2 (P(t) - p) * d/dt (P(t) - p)) = 0\n    //\n    // or\n    //\n    //     (P(t) - p) * dP/dt = 0\n    //\n    // where the * represents a dot product, since we're working with vectors.\n    //\n    \n    // \n    // Differentiating x(t) and y(t) gives\n    //\n    //     dx/dt = d/dt cosh(t) = sinh(t)\n    //     dy/dt = d/dt sinh(t) = cosh(t)\n    //\n    // such that\n    //\n    //     dP/dt = (a sinh(t), b cosh(t))\n    //\n    \n    //\n    // We end up with\n    //\n    //     (a cosh(t) - x)*(a sinh(t)) + (b sinh(t) - y)*(b cosh(t)) = 0\n    //\n    // where p = (x,y) has been used. Simplifying, we get\n    //\n    //     a² cosh(t) sinh(t) + b² sinh(t) cosh(t) - a x sinh(t) - b y cosh(t) = 0\n    //\n    // and, by collecting terms and reordering, we get\n    //\n    //     f'(t) = g(t) = cosh(t) sinh(t) - A sinh(t) - B cosh(t) \n    //\n    // where \n    //\n    //     A = a x /(a² + b²)\n    //     B = b y /(a² + b²)\n    //\n    \n    //\n    // This expression might have analytical roots, but these are most likely not very nice\n    // to calculate or work with, as it's equivalent to solving a quartic polynomial. \n    // Instead we attempt a numerical solution, hoping that it converges rather quickly \n    // and consistently. \n    //\n    \n    //\n    // We will use a standard Newton-Rhapson iterative scheme for root solving:\n    //\n    // Given a function g(x) = 0, and an initial guess x_0, then by applying the following\n    // iterative scheme,\n    //\n    //     x_{n+1} = x_n - f(x_n)/f'(x_n)\n    // \n    // we should converge to a root as long as the function g(x) is sufficiently \"nice\".\n    //\n    \n    //\n    // By choosing the initial guess t_0 well, we can (hopefully) be guaranteed to reach the \n    // global minimum, thereby finding the value of t such that the distance is minimized.\n    //\n    \n    // \n    // At this point we have everything we need, so let's go:\n    //\n    \n    \n    //\n    // CALCULATIONS:\n    //\n    \n    // Helper quantities\n    float a2 = a*a;\n    float c2 = c*c;\n    float b2 = c2 - a2;\n    float b = sqrt(b2);\n    \n    float A = a*p.x/(a2 + b2);\n    float B = b*p.y/(a2 + b2);\n    \n    // try t = 0 as initial guess, this could/should most likely be improved\n    float t = 0.0;\n    //float t = p.y;\n    //float t = 1.0*length(p)*sign(p.y);\n    \n    // iterate\n    int i;\n    for (i = 0; i < 1000;i++) {\n        float ch = cosh(t);\n        float sh = sinh(t);\n        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);\n        t = t - dt;\n        if (abs(dt) < 1.0e-3) break; // until sufficiently close to solution\n    }\n    \n    // calculate closest point\n    vec2 P = vec2(a*cosh(t), b*sinh(t));\n    \n    // return distance, iteration count and parameter\n    return vec3(length(P - p), float(i), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // between -2 and +2 on y axis, and similar on x axis after aspect ratio correction\n\tvec2 uv = 2.0*(2.0*fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // thickness of lines and smoothing width \n    float t = 0.04; \n    float w = 2.0*fwidth(uv.x);\n    \n    //\n    // Given a circle (-1.0, 0.0) and (1.0, 0.0) with radius r1 and r2, respectively,\n    // draw a hyperbola that is equidistant from both circles (surfaces) for any point \n    // along the hyperbola\n    //\n\n    float r1 = 0.5 + 0.4*cos(iTime);\n    float r2 = 0.5 - 0.4*cos(2.0*iTime);\n    \n    //\n    // Note, c = 1.0, since we place our circles (foci) at (±1, 0).\n    // instead, we vary the vertex position by varying the radius\n    //\n    // The rightmost point on the left circle has x coordinate (-1 + r1), and\n    // the leftmost point on the right circle has x coordinate (1 - r2).\n    // \n    // The vertex of the right branch of the hyperbola should pass through halfway \n    // between these two points:\n    //\n    //     ((-1 + r1) + (+1 - r2))/2 = (r1 - r2)/2\n    //\n    float a = (r1 - r2)/2.0;\n    \n    // calculate distance to hyperbola branch, and iteration count (for background color)\n    vec3 res = dist_hyperbola(uv, a, 1.0);\n    \n    // calculate distance to circles and extract distance from hyperbola from results\n\tfloat d1 = dist_circle(uv - vec2(-1.0, 0.0), r1);\n    float d2 = dist_circle(uv - vec2( 1.0, 0.0), r2);\n    float d3 = res.x;\n\t\n    // pass them through smoothstep to get thick anti-aliased lines (s = 1 inside, s = 0 outside)\n    float s1 = smoothstep(w/2.0, -w/2.0, abs(d1) - t);\n    float s2 = smoothstep(w/2.0, -w/2.0, abs(d2) - t);\n    float s3 = smoothstep(w/2.0, -w/2.0, abs(d3) - t);\n    \n    // define colors\n    vec3 bgColor = vec3(0.5 + 0.5*cos(res.y));\n    vec3 circleColor = vec3(0.0, 0.0, 1.0);\n    vec3 hyperbolaColor = vec3(0.0, 1.0, 0.0);\n    \n    // compose colors\n    vec3 col = bgColor;\n    col = col*(1.0 - s1) + circleColor*s1;\n    col = col*(1.0 - s2) + circleColor*s2;\n    col = col*(1.0 - s3) + hyperbolaColor*s3;\n    \n    // final output\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 667, 703, 769, 794], [796, 796, 843, 4146, 4957], [4959, 4959, 5016, 5104, 7128]], "test": "untested"}
{"id": "Xllfz4", "name": "Rotating LED strip", "author": "Cathier", "description": "Simple rotating LED strip", "tags": ["simple"], "likes": 0, "viewed": 417, "published": "Public API", "date": "1511187571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265359\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy / 2.0;\n\tfloat Dist = distance(center, fragCoord);\n    float Angle = atan((center.y - fragCoord.y), (center.x - fragCoord.x));\n    float angle = -20.0 * (iTime - (5.0 * cos((M_PI * iTime) / 5.0))/ M_PI);\n    float velocity = 20.0 * (1.0 + sin((M_PI * iTime) / 5.0));\n    \n    if(mod(Dist, 20.0) < 10.0 && Dist < 120.0)\n        fragColor = clamp((mod(Angle + angle, M_PI) / 4.0) - (1.0 - velocity / 20.0), 0.0, 1.0) * (20.0 / velocity) * vec4(fragCoord / iResolution.xy, 0.5+0.5*sin(iTime), 1.0);\n    else\n        fragColor = vec4(0, 0, 0, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xllfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 83, 83, 660]], "test": "untested"}
{"id": "XllfzH", "name": "discotime", "author": "Del", "description": "plasma disco thing", "tags": ["plasma"], "likes": 1, "viewed": 118, "published": "Public", "date": "1511022632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime;\n    \n\tvec2 p = fragCoord.xy/iResolution.xy;\n    \n    float b1 =  2.0 * sin(p.x+time);\n    float b2 =  2.0 * cos(p.x*p.y+ time);\n    b1 = clamp(b1,0.85,1.25);\n    b2 = clamp(b2,0.85,1.25);\n    \n    float mag = 1.925;\n    mag += sin(time*0.25)*0.35;\n\tp*=mag;\n    \n    p.y *= 0.015;\n    p.x += 2.0;\n    float p2 = sin (p.x*(20.0*cos (p.y*12.0)) + time);\n\tp2 *= cos (p.x*(15.0*sin (p.y*14.0)) + time);\n    \n    vec3 col1 = vec3(0.7,0.35,0.7);\n    vec3 col2 = vec3(0.5,0.72,0.25);\n    \n    col1.r *= b1;\n    col2.g *= b2;\n    \n    vec3 col = vec3(0.0);\n    \n    if (p2<0.0)\n        col = col2 * abs(p2*b1);\n    else\n        col = col1 * p2*b2;\n        \n    \n    \n    fragColor = vec4(col.xyz,1.0);    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 776]], "test": "untested"}
{"id": "XlsBRn", "name": "1e8 ", "author": "nabr", "description": "abc", "tags": ["raymarching", "music", "dance"], "likes": 13, "viewed": 500, "published": "Public", "date": "1510778518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/XlsBRn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    float t = iTime * 0.1;\n\n    vec3 ro = vec3(0.0, 0.0, -17.0);\n    vec3 rd = normalize(vec3((fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y), 1.));\n\n    // ---- rotation \n    float s = sin(t), c = cos(t);\n    mat3 r = mat3(1., 0, 0, 0, c, -s, 0, s, c) * mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n\n    // ---- positions \n    float ptmp = mod(t, 5.) / 12. + 1.49;\n    vec3 n = vec3(0.001) + (mod(t, 5.) / 12.0 + 1.495);\n    float sec = -(mod(t, -60.) / 8.);\n    \n    // ---- raymarch\n    for (int i = 0; i < 8; i++)\n        ro += (length(\n            (sin(ro * sin(ro) * r) - n) + (cos(t * .001) - .5) \n             / .5 + atan(ro.z * 1e-8 - exp(1e8 * t), -rd.z)) - 0.9) * rd;\n\n    // ---- shading\n    // vec3 col = .5 + (-vec3(.102, .238, .261) * ro.z + .2);\n    \n    lowp vec3 col = (-vec3(.102, .238, .261) * ro.z + .2);\n    vec3 x = max(vec3(0.001), 0.827 + col);\n    col = (x * (9.7 * x - .57)) / (x * (9.4142 * x + 0.99) + 0.6) * x;\n    \n    fragColor = vec4(sqrt(col), 1.);\n}", "image_inputs": [{"id": "lsjSzR", "previewfilepath": "https://soundcloud.com/aleksandramikulska/04-karol-szymanowski-pr-ludium", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/aleksandramikulska/04-karol-szymanowski-pr-ludium", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsBRn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 191, 246, 246, 1246]], "test": "untested"}
{"id": "XlScDt", "name": "raymarching test 2 ", "author": "pedwards", "description": "extra ball", "tags": ["raymarching"], "likes": 0, "viewed": 66, "published": "Public", "date": "1510503697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n\n\nvec3 p1 = vec3(-1.2,0.0,0.0);\nfloat r1 = 1.0;\nfloat alpha1 = 0.9;\nfloat F01 = 0.1;\nvec3 diffC1 = vec3(1.0,0.2,0.2);\nvec3 speC1 = vec3(1.0,1.0,1.0);\n\nvec3 p2 = vec3(1.2,0.0,0.0);\nfloat r2 = 1.0;\nfloat alpha2 = 0.2;\nfloat F02 = 1.95;\nvec3 diffC2 = vec3(0.5,0.3,0.05);\nvec3 speC2 = 0.5*vec3(0.8,0.6,0.1);\n\nfloat floorH = -1.5;\nfloat alphafloor = 0.3;\nfloat F0floor = 0.2;\nvec3 diffCfloor = vec3(0.2,0.5,0.7);\nvec3 speCfloor = vec3(0.9,0.9,0.9);\n\nfloat backZ = 5.0;\nfloat alphaback = 0.5;\nfloat F0back = 0.8;\nvec3 diffCback = vec3(0.1,0.5,0.1);\nvec3 speCback = vec3(0.2,0.2,0.2);\n\n\nfloat D(vec3 wh, vec3 n, float alphap){\n    float alpha2 = alphap*alphap;\n    float nwh2 = pow(dot(n,wh),2.0);\n    //return alpha2/(PI*pow(1.0+(alpha2-1.0)*pow(dot(n,wh),2.0),2.0));\n    return exp((nwh2-1.0)/(alpha2*nwh2))/(PI*alpha2*pow(nwh2,2.0));\n}\n\nfloat F(vec3 wi, vec3 wh, float F0p){\n    return F0p+(1.0-F0p)*pow(1.0-max(0.0,dot(wi,wh)),5.0);\n}\n\nfloat G(vec3 wo, vec3 wi, vec3 wh, vec3 wn){\n \treturn min(1.0,min(2.0*dot(wn,wh)*dot(wn,wi)/dot(wo,wh),2.0*dot(wn,wh)*dot(wn,wo)/dot(wo,wh)));\n}\n\nvec3 diffusemap(vec3 r){\n    if(r.y-floorH<0.01){\n     \treturn diffCfloor;   \n    }\n    if(backZ-r.z<0.01){\n     \treturn diffCback;   \n    }\n    if(length(r-p1)<length(r-p2)){\n        return diffC1;\n    }else{\n        return diffC2;\n    }\n}\n\nvec3 specularmap(vec3 r){\n    if(r.y-floorH<0.01){\n     \treturn speCfloor;   \n    }\n    if(backZ-r.z<0.01){\n     \treturn speCback;   \n    }\n    if(length(r-p1)<length(r-p2)){\n        return speC1;\n    }else{\n        return speC2;\n    }\n}\n\nfloat alphamap(vec3 r){\n    if(r.y-floorH<0.01){\n     \treturn alphafloor;   \n    }\n    if(backZ-r.z<0.01){\n     \treturn alphaback;   \n    }\n    if(length(r-p1)<length(r-p2)){\n        return alpha1;\n    }else{\n        return alpha2;\n    }\n}\n\nfloat fmap(vec3 r){\n    if(r.y-floorH<0.01){\n     \treturn F0floor;   \n    }\n    if(backZ-r.z<0.01){\n     \treturn F0back;   \n    }\n    if(length(r-p1)<length(r-p2)){\n        return F01;\n    }else{\n        return F02;\n    }\n}\n\nfloat map(vec3 r){\n    return min(length(r-p1)-r1,\n               min(length(r-p2)-r2,\n               min(r.y-floorH,\n               backZ-r.z)));\n}\n\nvec3 nmap(vec3 r){\n    if(r.y-floorH<0.01){\n     \treturn vec3(0.0,1.0,0.0);   \n    }\n    if(backZ-r.z<0.01){\n     \treturn vec3(0.0,0.0,-1.0);   \n    }\n    if(length(r-p1)<length(r-p2)){\n        return normalize(r-p1);\n    }else{\n        return normalize(r-p2);\n    }\n}\n\nfloat trace(vec3 o, vec3 r){\n    r=normalize(r);\n    float t = 0.1;\n    for(int i=0; i<96; i++){\n        float d = map(o+t*r);\n       if(abs(d)<0.005 || abs(d)>10.0) break;\n        t+=d*0.95;\n    }\n    return t;\n}\n\n\nvec3 specdif(vec3 p, vec3 wo, vec3 lightp, vec3 lightc){\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    vec3 wn = nmap(p);\n    float alphap = alphamap(p);\n    float F0p = fmap(p);\n    vec3 diffC = diffusemap(p);\n    vec3 specularC = specularmap(p);\n\n    float d = trace(p,lightp-p);\n    vec3 wi = normalize(lightp-p);\n    vec3 wh = normalize(wi+wo);\n    if(d>length(lightp-p) && dot(wi,wn)>0.0 && dot(wo,wn)>0.0){\n        col+=dot(wi,wn)/3.0*lightc*diffC;\n        col+=D(wh,wn,alphap)*F(wi,wh,F0p)*G(wo,wi,wh,wn)/(4.0*dot(wn,wi)*dot(wn,wo)+1.0)*lightc*specularC;\n        //col=vec3(G(wo,wi,wh,wn));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float speed = 1.0;\n    float myTime = iTime*speed;\n    \n    vec3 light = 3.0*vec3(cos(myTime),0.5,sin(myTime));\n    vec3 lightc = vec3(1.0,1.0,1.0);\n    vec3 light2 = 3.0*vec3(cos(myTime+2.0*PI/3.0),0.5,sin(myTime+2.0*PI/3.0));\n    vec3 lightc2 = vec3(1.0,1.0,1.0);\n    vec3 light3 = 3.0*vec3(cos(myTime+4.0*PI/3.0),0.5,sin(myTime+4.0*PI/3.0));\n    vec3 lightc3 = vec3(1.0,1.0,1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = 2.0*uv - 1.0;\n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 o = vec3(0.0,0.0,-3.0);\n    vec3 wo = normalize(vec3(uv,1.0));\n    \n    float t =  trace(o,wo);\n    \n    float col = 0.0;\n    float col2 = 0.0;\n    float col3 = 0.0;\n    \n    vec3 colv = vec3(0.0,0.0,0.0);\n    \n    if(t<1000.0){\n        vec3 p = o+t*wo;\n        \n        colv+=specdif(p,-wo,light,lightc);\n        colv+=specdif(p,-wo,light2,lightc2);\n        colv+=specdif(p,-wo,light3,lightc3);\n    }\n    \n    \n\tfragColor = vec4(colv,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlScDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 604, 643, 643, 855], [857, 857, 894, 894, 955], [957, 957, 1001, 1001, 1101], [1103, 1103, 1127, 1127, 1343], [1345, 1345, 1370, 1370, 1582], [1584, 1584, 1607, 1607, 1823], [1825, 1825, 1844, 1844, 2048], [2050, 2050, 2068, 2068, 2198], [2200, 2200, 2218, 2218, 2468], [2470, 2470, 2498, 2498, 2683], [2686, 2686, 2742, 2742, 3304], [3306, 3306, 3361, 3361, 4324]], "test": "untested"}
{"id": "XlScRt", "name": "Basic Mandelbrot Set", "author": "Donald", "description": "Draws the Mandelbrot set.", "tags": ["fractal"], "likes": 1, "viewed": 451, "published": "Public API", "date": "1509655176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 squ(vec2 c){return vec2(c.x*c.x-c.y*c.y,2.*c.x*c.y);}\nfloat pyt=3.1415926*2./3.;\nvec2 zoompt=vec2(-0.6586,0.3775);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float jTime=iTime-30.*floor(iTime/30.);\n\tvec2 uv = (4.*fragCoord.xy / iResolution.x-vec2(2.,1.1))/pow(1.5,jTime+0.5)+zoompt;\n\n    vec2 c=uv;\n    for(int i=0;i<20+int(jTime*2.5);i++){\n    c=squ(c)+uv;\n     fragColor = vec4(0.,0.,0.,1.);\n    if (length(c)>2.){\n        float f=float(i)*0.3;\n        fragColor = vec4(sin(f),sin(f+pyt),sin(f-pyt),1.0);\n        break;\n    \n    \n    }\n     \n    }}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlScRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 58], [120, 120, 176, 176, 573]], "test": "untested"}
{"id": "XlScWt", "name": "Just Gears", "author": "0x4d4147", "description": "Just gears.", "tags": ["2d", "gears"], "likes": 3, "viewed": 422, "published": "Public API", "date": "1510488381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 as_polar(vec2 uv, vec2 center)\n{\n    vec2 pos = vec2(center) - uv;\n    float r = length(pos)*2.0;\n    float a = atan(pos.y, pos.x);\n    return vec2(r, a);\n}\n\nfloat impulse(float x, float k)\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nvec4 gear(\n    vec2 uv,\n    vec2 center,\n    float rad,\n    float speed,\n    vec4 gearCol,\n    vec4 gearOutlineCol\n) {\n    vec4 col = vec4(0.0);\n    vec2 uvp = as_polar(uv, center);\n    float impulsedSpeed = iTime*speed*0.5 + 1.5*sign(speed)*impulse(mod(iTime, 1.), 10.);\n    float gearSDF = smoothstep(-0.556,0.8, cos(uvp.y*6. + impulsedSpeed))*0.15+0.5;\n    \n    // Determine gear body.\n    float gearMask = 1.0 - smoothstep(rad-0.008, rad, gearSDF*uvp.x);\n    \n    // Cutout the center hole.\n    float holeRad = rad * 0.95;\n    float holeMask = 1.0 - smoothstep(holeRad-0.01, holeRad, uvp.x);\n    float gearMaskMinHole = gearMask - holeMask; // Cut hole.\n    col = mix(col, gearCol, gearMaskMinHole);\n    \n    // Determine gear outline.\n    float outlineRad = rad + 0.012;\n    float gearOutlineMask = abs(\n        (1.0 - smoothstep(outlineRad-0.008, outlineRad, gearSDF*uvp.x)) - gearMask\n    );\n    float holeOutlineRad = holeRad - 0.03;\n    float holeOutlineMask = abs(\n        (1.0 - smoothstep(holeOutlineRad-0.01, holeOutlineRad, uvp.x)) - holeMask\n    );\n    col = mix(col, gearOutlineCol, gearOutlineMask + holeOutlineMask);\n    \n    //return mix(vec4(0.), gearOutlineCol, gearOutlineMask); // Debug outline..\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float res = clamp(iResolution.y, 300., 600.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    uv *= 2.0;\n    \n    float gearSpeed = 10.;\n    float gearRadius = 0.49;\n    vec4 col = vec4(0.65, 0.88, 0.88, 1.);\n    vec4 gearCol = vec4(0.88, 0.3, 0.3, 1.);\n    vec4 gearOutlineCol = vec4(0.3, 0.1, 0.1, 1.);\n    \n    vec4 gearOutputCol;\n    \n    // Middle row.\n    gearOutputCol = gear(uv, vec2(  0.0,  0.0), gearRadius,  gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2( 1.26,  0.0), gearRadius,  gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2(-1.26,  0.0), gearRadius,  gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    // Top row.\n    gearOutputCol = gear(uv, vec2(-1.89, 0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2(-0.63, 0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2( 0.63, 0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2( 1.89, 0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    // Bottom row.\n    gearOutputCol = gear(uv, vec2(-1.89,-0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2(-0.63,-0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n   \n    gearOutputCol = gear(uv, vec2( 0.63,-0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n    \n    gearOutputCol = gear(uv, vec2( 1.89,-0.63), gearRadius, -gearSpeed, gearCol, gearOutlineCol);\n    col = mix(col, gearOutputCol, gearOutputCol.a);\n\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlScWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 161], [163, 163, 196, 196, 242], [244, 244, 362, 362, 1481], [1483, 1483, 1540, 1540, 3664]], "test": "untested"}
{"id": "XlSczt", "name": "API test 1", "author": "MacroMachines", "description": "Testing the api in a CODEA iOS app", "tags": ["test"], "likes": 0, "viewed": 647, "published": "Public API", "date": "1509670535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "untested"}
{"id": "XlsfD4", "name": "AV Ray Marching", "author": "AVitt", "description": "ray marching experiments", "tags": ["raymarching"], "likes": 0, "viewed": 478, "published": "Public API", "date": "1511913177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nint raySteps = 33;\n\nvec3 sunColour = vec3(1.0,0.9,0.75);\nvec3 sunDirection = vec3(0.4,1.0,-0.3);\n\nvec3 fogColour = vec3(0.85,0.85,0.9);\n\nfloat plane(vec3 p)\n{\n    \treturn p.y;\n}\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat cube(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat fractalBox( vec3 p, vec3 b )\n{\n    vec3 q = fract(p)*1.0-0.5;\n    vec3 d =  abs(vec3(q.x,p.y-0.5,q.z))-b;\n    //vec3 d = abs(fract(p)*2.0-1.0)-b; \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n//------------------------------------\nfloat map(vec3 p)\n{\n    float result = opU( plane(p), cube(p+vec3(0.0,-1.0,-4.0) , vec3(1.0,5.6,1.0))  );\n          result = opU( result  , cube(p+vec3(4.0,-1.0,-4.0) , vec3(1.0,4.6,1.0))  );\n    \t  result = opU( result  , cube(p+vec3(-4.0,-1.0,-4.0), vec3(1.0,3.8,1.0)) );\n \n    \t  result = opU( result  , cube(p+vec3(0.0,-1.0,4.0) , vec3(1.0,6.6,1.0))  );\n          result = opU( result  , cube(p+vec3(4.0,-1.0,4.0) , vec3(1.0,4.2,1.0))  );\n    \t  result = opU( result  , cube(p+vec3(-4.0,-1.0,4.0), vec3(1.0,5.2,1.0)) );\n              \t  \n    \t  result = opU( result  ,    fractalBox( p+vec3(0.0,0.5,0.0), vec3(0.480,0.015,0.480) ) );\n    \n    \t  result = opS( result  , sphere(p+vec3(-sin(iTime*1.25)*4.0,-1.0,4.0), 1.0*-sin(iTime*5.+5.)+0.5) );\n          result = opS( result  , sphere(p+vec3(sin(iTime*1.25)*4.0,-1.0,-4.0), 1.25) );\n           \n\treturn result;\n}\n\nfloat rayMarch(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for(int i = 0; i<raySteps; i++)\n    {\n        float precis = 0.00001*t;\n        vec3 p = o+r*t;\n        float d  = map(p);\n        //float d1 = map(p+vec3(0.0,0.0,4.0));\n        //float f = opU(d,d1);\n        if( d < precis || t>1000. ) break;\n        t += d;\n    }\n    return t;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.5, 0.5, 0.5);\n    float res = rayMarch(ro,rd);\n    \n    vec3 pos = ro + res*rd;\n    vec3 nor = calcNormal( pos );\n    \n    vec3  lig = normalize( sunDirection );\n\tfloat amb = clamp( 1.0*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, dif );\n    \n    vec3 lin = vec3(0.0);\n         lin += 1.00*dif*sunColour;\n    \t lin += 0.50*amb;\n         lin += 0.50*dom;\n         lin += 0.50*bac;\n    \t col = col*lin;\n\n    \tcol = mix( col, fogColour, 1.0-exp( -0.001*res*res*res ));\n    \n    return vec3( clamp(col,0.0,1.0) );\n}\n//------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    \n    float the = iTime * 0.1;\n    \n    vec3 r = normalize(vec3(uv,1.2));\n    vec3 o = vec3(0.0,3.0,-8.0);\n        \n    o.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    r.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    \n    vec3 col = render(o,r);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 159, 159, 178], [179, 179, 210, 210, 233], [235, 235, 263, 263, 354], [355, 355, 391, 391, 573], [574, 644, 677, 677, 703], [705, 705, 738, 738, 767], [769, 769, 799, 799, 828], [830, 830, 854, 854, 986], [987, 1026, 1045, 1045, 1894], [1896, 1896, 1928, 1928, 2233], [2234, 2234, 2266, 2266, 2702], [2703, 2703, 2742, 2742, 3450], [3451, 3490, 3547, 3547, 3955]], "test": "untested"}
{"id": "XlsfRr", "name": "Glitchy Blue thing", "author": "HephaChronos", "description": "I borrowed the 3d part of the code and modified to get this. Still trying to understand how 3d works", "tags": ["3d"], "likes": 1, "viewed": 308, "published": "Public", "date": "1510800052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    vec3 q = fract(p*1.+1.) * 2. - 1.;\n    return length(q) -.25;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.;\n    for (int i = 0; i < 32; i++) {\n    \tvec3 p = o + r* t;\n        float d = map(p);\n        t += d *.5+pow(abs(.2+.15*cos(2.*iTime) ), 2. );\n    }\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;   \n    vec3 r = vec3(uv, 1.);\n    float a = abs(1.3+1.3*sin(.25*iTime) );\n    r.xz *= mat2( cos(a*1.)+1., -sin(a*1.)+1., sin(a*1.)+1., cos(a*1.)+1. );\n    vec3 o = vec3(iTime, 0.8+iTime, iTime );\n    float t = trace(o, r);\n    float fog = 1. / (1. + t * t * .1);\n    vec3 fc = vec3(uv.x/2. +.5*cos(32.*iTime), .5+.8*sin(4.*iTime), uv.y/2. +1.5 );\n    fc *= fog;\n\tfragColor = vec4( 3.*fc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 86], [88, 88, 116, 116, 298], [299, 299, 356, 356, 817]], "test": "untested"}
{"id": "XlsfWH", "name": "Basic Raymarching Cubes", "author": "AVitt", "description": "Uses simple ray marching technique to draw a 3D field of spheres. Based on a tutorial by Dila https://www.youtube.com/watch?v=yxNnRSefK94", "tags": ["raymarching", "domaintest"], "likes": 3, "viewed": 754, "published": "Public API", "date": "1511803628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n\tvec3 q = fract(p)*2.0-1.0;\n    return length(q)-0.25;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = fract(p)*2.0-1.0;\n    vec3 d =  abs(vec3(q.x,p.y-0.5,q.z))-b;\n    //vec3 d = abs(fract(p)*2.0-1.0)-b; \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for(int i=0;i<64;i++){\n        \n        float precis = 0.0005*t;\n        vec3 p = o+r*t;\n        \n        float d = sdBox(p,vec3(0.6,1.5,0.6));\n        if( d < precis || t>200. ) break;\n        t+=d*0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,1.));\n    \n    float the = iTime * 0.2;\n    r.xz *= mat2(cos(the),-sin(the),sin(the),cos(the));\n    \n    vec3 o = vec3(2.0,sin(iTime*0.1)*1.5+0.9,iTime*0.25);\n    \n    float t = trace(o,r);\n    \n    float fog = 0.5/(1.0+t*t*0.25)*(0.25+t*t*0.5);\n    \n    vec3 fc = clamp(vec3(fog),-0.,1.);\n    \n\tfragColor = vec4(fc.x*0.75,fc.y*0.95,fc.z*1.,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 76], [78, 78, 109, 109, 291], [293, 293, 322, 322, 568], [570, 570, 627, 627, 1135]], "test": "untested"}
{"id": "XlsfzH", "name": "happy squares", "author": "laserdog", "description": "Just some happy rounded rectangles to brighten your day.", "tags": ["roundedrectangles"], "likes": 15, "viewed": 526, "published": "Public", "date": "1511027063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) // col1a col1b col2a col2b\nconst float gridWidth = .33;\n\nvec3 hue( float c )\n{\n    return smoothstep(0.,1., abs(mod(c*6.+vec3(0,4,2), 6.)-3.)-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float threshold = .03;\n    vec2 node = round(uv / gridWidth) * gridWidth;\n    \n    float sizeNum = sin((-iTime * 1.5  + pow(length(node), 3.2)) * 1.5) * 1.3;\n    vec2 to = uv - node;\n    to /= abs(sizeNum) + .4;\n    to *= rot(sin(iTime * 15.) * .15);\n    float d = length(max(abs(to) - .050, 0.));\n    \n    vec3 col = .5 + .5 * hue(sizeNum / 3.);\n    \n    float val = smoothstep(threshold + .01, threshold, d);\n\tfragColor.rgb = mix( vec3(0,.5,.5), col, val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 131, 131, 201], [203, 203, 260, 260, 787]], "test": "untested"}
{"id": "Xlsfzn", "name": "2D Texture Glint", "author": "Del", "description": "glint / sheen effect for a texture...\n\nFeel free to suggest improvements :)", "tags": ["2d", "texture", "shine", "glint"], "likes": 8, "viewed": 941, "published": "Public API", "date": "1510791139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple 2d texture glint effect - Del 15/11/2017\n//\n// Please feel free to suggest improvements...!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float speed = 0.58;\n    float linewidth = 0.58;\n    float grad = 3.0;\n    vec4 col1 = vec4(0.3,0.0,0.0,1.0);\n    vec4 col2 = vec4(0.85,0.85,0.85,1.0);\n        \n    // Sample texture...\n    vec4 t1 = texture(iChannel0, uv);\n\n    // Plot line...\n    vec2 linepos = uv;\n    linepos.x = linepos.x - mod(iTime*speed,2.0)+0.5;\n\n    float y = linepos.x*grad;\n\tfloat s = smoothstep( y-linewidth, y, linepos.y) - smoothstep( y, y+linewidth, linepos.y); \n    \n    // Merge texture + Glint\n\tfragColor = t1 + ((s*col1)+(s*col2));\n}\n\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlsfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 103, 160, 160, 727]], "test": "untested"}
{"id": "XlSyzt", "name": "Psychotic plasma blobs and lines", "author": "CoyHot", "description": "Colorfull moving blobs, lines and cells", "tags": ["blobs", "plasma", "colors"], "likes": 4, "viewed": 171, "published": "Public", "date": "1509661380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t------------\n\tPlasma blobs\n\t------------\n\n\tDeforming some plasams, lines and cells\n\n\tFrancois 'CoyHot' Grassard - 2017\n*/\n\n\nvec4 plas( vec2 v, float time )\n{\n\tfloat c = sin(v.y*50.0)/cos(v.x*100.0)*cos(iTime*1.0);\n\tc /= cos(v.y*50.0)/sin(v.x*50.0);\n\tfloat ci = cos(v.y*25.0)/sin(v.x*25.0);\n\tc += ci;\n\n\treturn vec4( c*sin(iTime), c*cos(iTime)/2., c+sin(iTime), 1.0 );\n}\n\nvec4 grid( vec2 v, float time )\n{\n  float c =(v.x)/(v.y);\n\n  return vec4( c*sin(iTime), c*cos(iTime)/2., c+sin(iTime), 1.0 );\n}\n\n\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = cos(a*v.y/10.+iTime/2.);\n\tfloat c = sin(a+v.x*3.-iTime/2.);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5);\n\tuv = rotate(uv,iTime/20.);\n\n    vec2 uv2 = rotate(uv,20.*iTime/200.);\n    \n\tvec4 t = plas(vec2(uv[0],uv[1]), iTime/100.0 );\n \tvec4 g = grid (vec2(uv2[0],uv2[1]), iTime/100.0 );\n\n\tfragColor = sin(t)-cos(g)+cos(t)+sin(g);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlSyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 161, 161, 372], [374, 374, 407, 407, 501], [505, 505, 535, 535, 652], [655, 655, 712, 712, 985]], "test": "untested"}
{"id": "XlXBWH", "name": "[WST1] Night in the city", "author": "johnny66", "description": "Good evening in Wroclaw\nEvening city\nDobry wieczór we wrocławiu\n", "tags": ["city", "wroclaw"], "likes": 2, "viewed": 181, "published": "Public", "date": "1511694265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Good evening in Wroclaw, Author: Jonatan\n// This shader is prepared for the first Wroclaw Shader Competition \"\n// organized by Faculty of Physics and Astronomy, Khronos Chapter and SIggraph Chapter from Wroclaw\"\n\n#define LIMIT 1187000\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = sin( x.x * 17.11 );\n    float yhash = cos( x.y * 5.2 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\n\n\n\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 4.0, 5.0 , 1.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.4, 4.4), c.y);\n}\n\nfloat cam(float f) {\n    float tt = mod(f, 25.0) * 3.0;\n\tfloat go = smoothstep(3.0, 45.0, tt) - smoothstep(6.0, 95.0, tt);\n    return go *540.0*iTime;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    float t = iTime;\n    //stars\n    vec3 vColor = vec3( (sin(t)*0.1)*.32, (sin(t)*0.1)*.32, 0.4 ) * fragCoord.y / iResolution.y;\n    float StarFieldThreshhold = 0.98;\n\n    // Stars with a slow crawl.\n    float xRate = 0.2;\n    float yRate = 0.0;\n    vec2 vSamplePos = fragCoord.xy + vec2( xRate * float( iFrame ), yRate * float( iFrame ) );\n\tfloat StarVal = StableStarField( vSamplePos, StarFieldThreshhold );\n    vColor += vec3( StarVal );\n\t//fragColor = vec4(vColor, 1.0);\n        \n    //stars\n    \n    \n    float x = floor(fragCoord.x) + floor(cam(t));\n    float y = floor(fragCoord.y)+ floor (sin(cam(t)));\n    float wtf = 1.;\n    float c = 0.0;    \n    float bgOff = 1.0;\n\n    for (int k = 0; k < LIMIT; k++) {\n        c++;\n        \n        if (x <= 1.) {\n            c = 0.2;\n            bgOff = 0.1;\n        \tbreak;   \n        }\n        if (c >= y / (0.0014 * iResolution.y)) {\n        \tbreak;   \n        }\n        if (mod(x,  2.0) == 0.0) {\n            x = x / 2.0;\n        } else {\n            x = x * 3.0 + wtf;\n            if (x <= wtf * 4.0) {\n            \tx = 9990.0;   \n            }\n        }\n       \n    }\n   \n   // fragColor = vec4(vColor, 1.0);\n    fragColor = \n   vec4(hsv2rgb(vec3(x/2., 0.33, 0.5 * bgOff)), 1.0)   \n   + vec4(vColor, 1.0)\n   + vec4(.1,.1,.1,1.0)\n   + vec4((sin(t)*0.41)*.32,(sin(t)*0.41)*.32, sin(t)*.4, 1.0) ;\n    \n    \n    \n    \n}\n\n\n\n", "image_inputs": [{"id": "MsSSR1", "previewfilepath": "https://soundcloud.com/user5384344/the-prodigy-climbatize", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user5384344/the-prodigy-climbatize", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 314, 342, 342, 469], [471, 561, 624, 624, 830], [832, 898, 962, 1132, 1763], [1769, 1769, 1791, 1791, 1949], [1951, 1951, 1971, 1971, 2103], [2105, 2105, 2161, 2161, 3532]], "test": "untested"}
{"id": "Xt2cD3", "name": "Quadric Frustum Tracing", "author": "paniq", "description": "Visualizing feature point and depth range computation for a small slice of the perspective frustum. The sphere is clipped against the depth bound so that only the section enclosed by the frustum is taken into account.", "tags": ["quadric", "intersection", "frustum"], "likes": 5, "viewed": 509, "published": "Public API", "date": "1510564589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Quadric Frustum Tracing\n// using 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n\n// note that this version is very verbose and purposefully lacks\n// any form of optimization for the sake of education.\n\nstruct surface2x3 {\n    float c[10];\n};\n\nstruct surface2x2 {\n    float c[6];\n};\n\n#define surface2x1 vec3\n\nconst vec2 min_frustum_half_size = vec2(1.77778,1.0)/30.0;\nconst vec2 max_frustum_half_size = vec2(1.77778,1.0)/6.0;\n\nconst float infinity = 1.0/0.0;\n\nsurface2x3 surf3;\n\n// versor (unit quaternion) from axis and angle\nvec4 versor(vec3 axis, float angle) {\n    float a = angle * 0.5;\n    return vec4(axis * sin(a), cos(a));\n}\n\n// invert rotation\nvec4 conjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\n// rotate point by versor\n// q (t) * V * q (t) ^-1\nvec3 rotate(vec4 q, vec3 p) {\n    vec3 t = cross(q.xyz,p) * 2.0;\n    return p + q.w * t + cross(q.xyz, t);\n}\n\n// rotation matrix constructor from versor\nmat3 rotation (vec4 q) {\n    float n = dot(q,q);\n    vec4 qs = (n == 0.0)?vec4(0.0):(q * (2.0 / n));\n    vec3 w = qs.w * q.xyz;\n    vec3 x = qs.x * q.xyz;\n    vec3 y = qs.y * q.xyz;\n    float zz = qs.z * q.z;\n    return mat3(\n        1.0 - (y.y + zz), x.y + w.z, x.z - w.y,\n        x.y - w.z, 1.0 - (x.x + zz), y.z + w.x,\n        x.z + w.y, y.z - w.x, 1.0 - (x.x + y.y));\n}\n\n// swizzle the components of a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// performing this twice selects zxy\nvoid surface2x3_swizzle_yzx(in surface2x3 surf, out surface2x3 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float XZ = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tdest.c[0] = YY;\n\tdest.c[1] = ZZ;\n\tdest.c[2] = XX;\n\n    dest.c[3] = YZ;\n\tdest.c[4] = XY;\n\tdest.c[5] = XZ;\n\n    dest.c[6] = Y;\n\tdest.c[7] = Z;\n\tdest.c[8] = X;\n    dest.c[9] = surf.c[9];\n}\n\n// swap the x and y components of a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x2_swizzle_yx(in surface2x2 surf, out surface2x2 dest) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1];\n\tfloat X = surf.c[3]; float Y = surf.c[4];\n    dest.c[0] = YY;\n    dest.c[1] = XX;\n    dest.c[2] = surf.c[2];\n    dest.c[3] = Y;\n    dest.c[4] = X;\n    dest.c[5] = surf.c[5];\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the partial differential for the given position (x y z)\nvec3 surface2x3_diff(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    return vec3(\n        2.0*A*p.x + D*p.y + E*p.z + G,\n    \tD*p.x + 2.0*B*p.y + F*p.z + H,\n    \tE*p.x + F*p.y + 2.0*C*p.z + I);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// compute the value for the given position (x y z)\nfloat surface2x3_eval(in surface2x3 surf, vec3 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n    return A*p.x*p.x + B*p.y*p.y + C*p.z*p.z\n        + D*p.x*p.y + E*p.x*p.z + F*p.y*p.z\n        + G*p.x + H*p.y + I*p.z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// compute the value for the given position (x y)\nfloat surface2x2_eval(in surface2x2 surf, vec2 p) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n    return A*p.x*p.x + B*p.y*p.y + C*p.x*p.y + D*p.x + E*p.y + F;\n}\n\n// transform a quadric\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + J\n// by a 4x3 matrix to yield a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\nvoid surface2x3_new(in vec4 quadric, in mat4 mtx, out surface2x3 surf) {\n    float A = quadric.x; float B = quadric.y; float C = quadric.z; float J = quadric.w;\n    vec3 ABC = vec3(A,B,C);\n    vec3 ABC2 = ABC*2.0;\n    surf.c[0] = dot(ABC, mtx[0].xyz*mtx[0].xyz);\n    surf.c[1] = dot(ABC, mtx[1].xyz*mtx[1].xyz);\n    surf.c[2] = dot(ABC, mtx[2].xyz*mtx[2].xyz);\n    surf.c[3] = dot(ABC2, mtx[0].xyz*mtx[1].xyz);\n    surf.c[4] = dot(ABC2, mtx[0].xyz*mtx[2].xyz);\n    surf.c[5] = dot(ABC2, mtx[1].xyz*mtx[2].xyz);\n    surf.c[6] = dot(ABC2, mtx[0].xyz*mtx[3].xyz);\n    surf.c[7] = dot(ABC2, mtx[1].xyz*mtx[3].xyz);\n    surf.c[8] = dot(ABC2, mtx[2].xyz*mtx[3].xyz);\n    surf.c[9] = dot(ABC, mtx[3].xyz*mtx[3].xyz) + J;\n}\n\nvoid transformed_quadric(vec4 coeffs, vec4 rot, vec3 pos, out surface2x3 surf) {\n    mat4 mtx = mat4(transpose(rotation(rot)));\n    mat4 translate = mat4(1.0);\n    translate[3] = vec4(-pos, 1.0);\n    surface2x3_new(coeffs, mtx * translate, surf);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and x\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_x(in surface2x3 surf, float x,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zx -> x\n    // y -> y\n    slice.c[0] = (XX*x + ZX)*x + ZZ;\n    slice.c[1] = YY;\n    slice.c[2] = XY*x + YZ;\n    slice.c[3] = X*x + Z;\n    slice.c[4] = Y;\n    slice.c[5] = O;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective vertical plane that goes through the origin and y\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_perspective_plane_y(in surface2x3 surf, float y,\n\tout surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n    float O = surf.c[9];\n\n    // zy -> x\n    // x -> y\n    slice.c[0] = (YY*y + YZ)*y + ZZ;\n    slice.c[1] = XX;\n    slice.c[2] = XY*y + ZX;\n    slice.c[3] = Y*y + Z;\n    slice.c[4] = X;\n    slice.c[5] = O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a projective line that goes through the origin and y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_perspective_plane(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n    slice[0] = (B*y + C)*y + A;\n    slice[1] = E*y + D;\n    slice[2] = F;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a xy plane that goes through z\n// return the bivariate quadratic that describes a slice of this surface\n// h(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\nvoid surface2x3_ortho_plane_z(in surface2x3 surf, float z,\n\tout surface2x2 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice.c[0] = A;\n    slice.c[1] = B;\n    slice.c[2] = D;\n    slice.c[3] = E*z + G;\n    slice.c[4] = F*z + H;\n    slice.c[5] = (C*z + I)*z + J;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a vertical line that goes through x\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_x(in surface2x2 surf, float x,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = YY;\n    slice[1] = XY*x + Y;\n    slice[2] = (XX*x + X)*x + O;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// and a horizontal line that goes through y\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x2_ortho_plane_y(in surface2x2 surf, float y,\n\tout surface2x1 slice) {\n    float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n    float X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n\n    slice[0] = XX;\n    slice[1] = XY*y + X;\n    slice[2] = (YY*y + Y)*y + O;\n}\n\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the coordinate of the inflection point\nvec2 surface2x2_center(in surface2x2 surf) {\n    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\n\tfloat f = 1.0/(4.0*A*B - C*C);\n    return vec2(\n\t\t(C*E - 2.0*B*D)*f,\n        (C*D - 2.0*A*E)*f);\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and a projective ray that goes through the origin and (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_perspective_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = (A*p.x + E)*p.x + (D*p.x + B*p.y + F)*p.y + C;\n    slice[1] = G*p.x + H*p.y + I;\n    slice[2] = J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// and an orthogonal ray that goes through (p.x p.y 1)\n// return the univariate quadratic that describes a slice of this surface\n// h(x) = A*x^2 + B*x + C\nvoid surface2x3_ortho_ray(in surface2x3 surf, vec2 p,\n\tout surface2x1 slice) {\n\tfloat A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];\n\tfloat D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];\n\tfloat G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];\n    float J = surf.c[9];\n\n    slice[0] = C;\n    slice[1] = E*p.x + F*p.y + I;\n    slice[2] = (A*p.x + G)*p.x + (D*p.x + B*p.y + H)*p.y + J;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_xy(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    ZZ *= 4.0;\n\tslice.c[0] = XX*ZZ - ZX*ZX;\n    slice.c[1] = YY*ZZ - YZ*YZ;\n    slice.c[2] = XY*ZZ - 2.0*ZX*YZ;\n    slice.c[3] = X*ZZ - 2.0*ZX*Z;\n    slice.c[4] = Y*ZZ - 2.0*YZ*Z;\n    slice.c[5] = O*ZZ - Z*Z;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal yz plane\nvoid surface2x3_project_ortho_yz(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    XX *= 4.0;\n\tslice.c[0] = YY*XX - XY*XY;\n    slice.c[1] = ZZ*XX - ZX*ZX;\n    slice.c[2] = YZ*XX - 2.0*XY*ZX;\n    slice.c[3] = Y*XX - 2.0*XY*X;\n    slice.c[4] = Z*XX - 2.0*ZX*X;\n    slice.c[5] = O*XX - X*X;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal zx plane\nvoid surface2x3_project_ortho_zx(in surface2x3 surf, out surface2x2 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tslice.c[0] = ZZ*YY - YZ*YZ;\n    slice.c[1] = XX*YY - XY*XY;\n    slice.c[2] = ZX*YY - 2.0*YZ*XY;\n    slice.c[3] = Z*YY - 2.0*YZ*Y;\n    slice.c[4] = X*YY - 2.0*XY*Y;\n    slice.c[5] = O*YY - Y*Y;\n}\n\n// for a bivariate quadratic\n// f(x,y) = A*x^2 + B*y^2 + C*x*y + D*x + E*y + F\n// return the slice of the line that describes the contour of the surface\n// observed from the orthogonal x plane\nvoid surface2x2_project_ortho_x(in surface2x2 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];\n\tfloat X = surf.c[3]; float Y = surf.c[4]; float O = surf.c[5];\n    YY *= 4.0;\n\tslice[0] = XX*YY - XY*XY;\n    slice[1] = X*YY - 2.0*XY*Y;\n    slice[2] = O*YY - Y*Y;\n}\n\n// for a second order surface\n// f(x,y,z) = A*x^2 + B*y^2 + C*z^2 + D*x*y + E*x*z + F*y*z + G*x + H*y + I*z + J\n// return the slice of the plane that describes the contour of the surface\n// observed from the orthogonal xy plane\nvoid surface2x3_project_ortho_z(in surface2x3 surf, out surface2x1 slice) {\n\tfloat XX = surf.c[0]; float YY = surf.c[1]; float ZZ = surf.c[2];\n\tfloat XY = surf.c[3]; float ZX = surf.c[4]; float YZ = surf.c[5];\n\tfloat X = surf.c[6]; float Y = surf.c[7]; float Z = surf.c[8];\n\tfloat O = surf.c[9];\n    YY *= 4.0;\n\tfloat NXX = ZZ*YY - YZ*YZ;\n    float NYY = (XX*YY - XY*XY)*4.0;\n    float NXY = ZX*YY - 2.0*YZ*XY;\n    float NY = X*YY - 2.0*XY*Y;\n\tslice[0] = NXX*NYY - NXY*NXY;\n    slice[1] = (Z*YY - 2.0*YZ*Y)*NYY - 2.0*NXY*NY;\n    slice[2] = (O*YY - Y*Y)*NYY - NY*NY;\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(float A, float B, float C) {\n    // (-b +- sqrt(b*b - 4.0*a*c)) / 2.0*a\n    float a_neg_rcp = -1.0/A;\n    float k = 0.5*B*a_neg_rcp;\n    float q = sqrt(k*k + C*a_neg_rcp);\n    return k + vec2(-q,q);\n}\n\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the near and far points that bound the function at f(x) = 0\nvec2 surface2x1_bounds(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return surface2x1_bounds(A, B, C);\n}\n\n// for a univariate quadratic\n// f(x) = A*x^2 + B*x + C\n// return the coordinate of the inflection point\nfloat surface2x1_center(in surface2x1 surf) {\n    float A = surf[0]; float B = surf[1]; float C = surf[2];\n    return -B / (2.0*A);\n}\n\nstruct bounds2x3 {\n    vec3 v0, v1;\n    vec3 eh0_0, eh0_1, eh1_0, eh1_1;\n    vec3 ev0_0, ev0_1, ev1_0, ev1_1;\n    vec3 c00_0, c01_0, c10_0, c11_0;\n    vec3 c00_1, c01_1, c10_1, c11_1;\n};\n\nbool in_wedge(vec2 p, vec2 u) {\n    return (p.x >= u[0]*p.y) && (p.x <= u[1]*p.y);\n}\nbool in_frustum(vec3 p, vec2 u, vec2 v) {\n    return in_wedge(p.xz, u) && in_wedge(p.yz, v);\n}\n\nvoid merge_plane_range(inout vec2 outer, vec2 p0, vec2 p1, vec2 u) {\n    outer[0] = in_wedge(p0, u)?min(outer[0], p0.y):outer[0];\n    outer[1] = in_wedge(p1, u)?max(outer[1], p1.y):outer[1];\n}\n\nvoid merge_corner_range(inout vec2 outer, inout vec2 inner, float z0, float z1) {\n    outer[0] = min(outer[0], z0);\n    outer[1] = max(outer[1], z1);\n    inner[0] = max(inner[0], (z0 == z0)?z0:infinity);\n    inner[1] = min(inner[1], (z1 == z1)?z1:-infinity);\n}\n\nvec4 compute_bounds(bounds2x3 bounds, vec2 u, vec2 v) {\n    vec2 outer = vec2(infinity, -infinity);\n    vec2 inner = vec2(-infinity, infinity);\n\n    outer[0] = in_frustum(bounds.v0, u, v)?min(outer[0], bounds.v0.z):outer[0];\n    outer[1] = in_frustum(bounds.v1, u, v)?max(outer[1], bounds.v1.z):outer[1];\n    \n    merge_corner_range(outer, inner, bounds.c00_0.z, bounds.c00_1.z);\n    merge_corner_range(outer, inner, bounds.c01_0.z, bounds.c01_1.z);\n    merge_corner_range(outer, inner, bounds.c10_0.z, bounds.c10_1.z);\n    merge_corner_range(outer, inner, bounds.c11_0.z, bounds.c11_1.z);\n    \n    merge_plane_range(outer, bounds.eh0_0.yz, bounds.eh0_1.yz, v);\n    merge_plane_range(outer, bounds.eh1_0.yz, bounds.eh1_1.yz, v);\n    merge_plane_range(outer, bounds.ev0_0.xz, bounds.ev0_1.xz, u);\n    merge_plane_range(outer, bounds.ev1_0.xz, bounds.ev1_1.xz, u);\n\n    return vec4(outer, inner);\n}\n\nvoid compute_bounding_points_compact(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n    float surf_c7_c7 = surf.c[7]*surf.c[7];\n    float surf_2x_c0 = 2.0*surf.c[0];\n    float surf_2x_c1 = 2.0*surf.c[1];\n    float surf_2x_c3 = 2.0*surf.c[3];\n    float surf_2x_c6 = 2.0*surf.c[6];\n    float surf_4x_c1 = 4.0*surf.c[1];\n    \n    {\n\t    float surf_4x_c0_c1_sub_c3_c3 = surf_2x_c0*surf_2x_c1 - surf.c[3]*surf.c[3];\n        \n        // extract contour of quadratic along z plane\n        float NXY = surf.c[4]*surf_4x_c1 - surf.c[5]*surf_2x_c3;\n        float NY = surf.c[6]*surf_4x_c1 - surf.c[7]*surf_2x_c3;\n        float NYY = surf_4x_c0_c1_sub_c3_c3*4.0;\n\n        // compute z bounds of volume\n        vec2 vz = surface2x1_bounds(\n        \t(surf.c[2]*surf_4x_c1 - surf.c[5]*surf.c[5])*NYY - NXY*NXY,\n        \t(surf.c[8]*surf_4x_c1 - 2.0*surf.c[5]*surf.c[7])*NYY - 2.0*NXY*NY,\n        \t(surf.c[9]*surf_4x_c1 - surf_c7_c7)*NYY - NY*NY);\n        // extract quadratic of plane at volume z bounds\n        float slice_z0_c3 = surf.c[4]*vz[0] + surf.c[6];\n        float slice_z0_c4 = surf.c[5]*vz[0] + surf.c[7];\n\n        float slice_z1_c3 = surf.c[4]*vz[1] + surf.c[6];\n        float slice_z1_c4 = surf.c[5]*vz[1] + surf.c[7];\n\n        // compute position of contact points at volume z bounds\n        float f = 1.0/surf_4x_c0_c1_sub_c3_c3;\n        bounds.v0 = vec3(\n            (surf.c[3]*slice_z0_c4 - surf_2x_c1*slice_z0_c3)*f,\n            (surf.c[3]*slice_z0_c3 - surf_2x_c0*slice_z0_c4)*f,\n        \tvz[0]);\n        bounds.v1 = vec3(\n            (surf.c[3]*slice_z1_c4 - surf_2x_c1*slice_z1_c3)*f,\n            (surf.c[3]*slice_z1_c3 - surf_2x_c0*slice_z1_c4)*f,\n        \tvz[1]);\n    }\n    \n    // compute z bounds of corner quadratics\n    // compute position of contact points at corner z bounds\n    {\n    \tfloat surf_2x_c7 = 2.0*surf.c[7];\n        float surf_c1_v0 = surf.c[1]*v[0];\n        float surf_c7_v0 = surf.c[7]*v[0];\n        float surf_c1_v1 = surf.c[1]*v[1];\n        float surf_c7_v1 = surf.c[7]*v[1];   \n        \n        // compute z bounds of plane contours    \n        // compute position of contact points at plane z bounds\n        float surf_2x_c1_neg_rcp = -1.0 / surf_2x_c1;\n\t    float surf_4x_c9_c1_sub_c7_c7 = surf.c[9]*surf_4x_c1 - surf_c7_c7;\n        \n        {\n            float slice_x0_c0 = (surf.c[0]*u[0] + surf.c[4])*u[0] + surf.c[2];\n            float slice_x0_c2 = surf.c[3]*u[0] + surf.c[5];\n            float slice_x0_c3 = surf.c[6]*u[0] + surf.c[8];\n\n            {\n                vec2 cx0y0 = surface2x1_bounds((surf_c1_v0 + slice_x0_c2)*v[0] + slice_x0_c0, surf_c7_v0 + slice_x0_c3, surf.c[9]);\n                bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n                bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\t\n            }\n            {\n                vec2 cx0y1 = surface2x1_bounds((surf_c1_v1 + slice_x0_c2)*v[1] + slice_x0_c0, surf_c7_v1 + slice_x0_c3, surf.c[9]);\n                bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n                bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n            }\n            {\n                vec2 ph0 = surface2x1_bounds(slice_x0_c0*surf_4x_c1 - slice_x0_c2*slice_x0_c2, slice_x0_c3*surf_4x_c1 - slice_x0_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);\n                bounds.eh0_0 = vec3(ph0[0] * u[0], (slice_x0_c2*ph0[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[0]);\n                bounds.eh0_1 = vec3(ph0[1] * u[0], (slice_x0_c2*ph0[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph0[1]);\n            }\n            \n        }\n        {\n            float slice_x1_c0 = (surf.c[0]*u[1] + surf.c[4])*u[1] + surf.c[2];\n            float slice_x1_c2 = surf.c[3]*u[1] + surf.c[5];\n            float slice_x1_c3 = surf.c[6]*u[1] + surf.c[8];\n\n            {\n                vec2 cx1y0 = surface2x1_bounds((surf_c1_v0 + slice_x1_c2)*v[0] + slice_x1_c0, surf_c7_v0 + slice_x1_c3, surf.c[9]);\n                bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n                bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n            }\n            {\n                vec2 cx1y1 = surface2x1_bounds((surf_c1_v1 + slice_x1_c2)*v[1] + slice_x1_c0, surf_c7_v1 + slice_x1_c3, surf.c[9]);\n                bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n                bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n            }\n            {\n                vec2 ph1 = surface2x1_bounds(slice_x1_c0*surf_4x_c1 - slice_x1_c2*slice_x1_c2, slice_x1_c3*surf_4x_c1 - slice_x1_c2*surf_2x_c7, surf_4x_c9_c1_sub_c7_c7);        \n                bounds.eh1_0 = vec3(ph1[0] * u[1], (slice_x1_c2*ph1[0] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[0]);\n                bounds.eh1_1 = vec3(ph1[1] * u[1], (slice_x1_c2*ph1[1] + surf.c[7]) * surf_2x_c1_neg_rcp, ph1[1]);\n            }\n            \n        }\n    }    \n    \n    {\n\t    float surf_4x_c0 = 4.0*surf.c[0];        \n    \tfloat surf_4x_c9_c0_sub_c6_c6 = surf.c[9]*surf_4x_c0 - surf.c[6]*surf.c[6];\n        \n        // compute z bounds of plane contours\n        // compute position of contact points at plane z bounds\n        float surf_2x_c0_neg_rcp = -1.0 / surf_2x_c0;\n        {\n            float slice_y0_c0 = (surf.c[1]*v[0] + surf.c[5])*v[0] + surf.c[2];\n            float slice_y0_c2 = surf.c[3]*v[0] + surf.c[4];\n            float slice_y0_c3 = surf.c[7]*v[0] + surf.c[8];\n            \n            vec2 pv0 = surface2x1_bounds(slice_y0_c0*surf_4x_c0 - slice_y0_c2*slice_y0_c2, slice_y0_c3*surf_4x_c0 - slice_y0_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev0_0 = vec3((slice_y0_c2*pv0[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[0] * v[0], pv0[0]);\n            bounds.ev0_1 = vec3((slice_y0_c2*pv0[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv0[1] * v[0], pv0[1]);\n        }\n        \n        {\n            float slice_y1_c0 = (surf.c[1]*v[1] + surf.c[5])*v[1] + surf.c[2];\n            float slice_y1_c2 = surf.c[3]*v[1] + surf.c[4];\n            float slice_y1_c3 = surf.c[7]*v[1] + surf.c[8];\n            \n            vec2 pv1 = surface2x1_bounds(slice_y1_c0*surf_4x_c0 - slice_y1_c2*slice_y1_c2, slice_y1_c3*surf_4x_c0 - slice_y1_c2*surf_2x_c6, surf_4x_c9_c0_sub_c6_c6);\n            bounds.ev1_0 = vec3((slice_y1_c2*pv1[0] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[0] * v[1], pv1[0]);\n            bounds.ev1_1 = vec3((slice_y1_c2*pv1[1] + surf.c[6]) * surf_2x_c0_neg_rcp, pv1[1] * v[1], pv1[1]);\n        }\n    }\n}\n\nvoid compute_bounding_points_clean(surface2x3 surf, vec2 u, vec2 v, out bounds2x3 bounds) {\n\n\n    surface2x1 contour_z;\n    // extract contour of quadratic along z plane\n    surface2x3_project_ortho_z(surf3, contour_z);\n    // compute z bounds of volume\n    vec2 vz = surface2x1_bounds(contour_z);\n    surface2x2 slice_z0;\n    surface2x2 slice_z1;\n    // extract quadratic of plane at volume z bounds\n    surface2x3_ortho_plane_z(surf3, vz[0], slice_z0);\n    surface2x3_ortho_plane_z(surf3, vz[1], slice_z1);\n    // compute position of contact points at volume z bounds\n    bounds.v0 = vec3(surface2x2_center(slice_z0),vz[0]);\n    bounds.v1 = vec3(surface2x2_center(slice_z1),vz[1]);\n\n    // extract quadratic at planes\n    surface2x2 slice_x0;\n    surface2x2 slice_x1;\n    surface2x2 slice_y0;\n    surface2x2 slice_y1;\n\tsurface2x3_perspective_plane_x(surf3, u[0], slice_x0);\n    surface2x3_perspective_plane_x(surf3, u[1], slice_x1);\n\tsurface2x3_perspective_plane_y(surf3, v[0], slice_y0);\n    surface2x3_perspective_plane_y(surf3, v[1], slice_y1);\n\n    surface2x1 contour_h0;\n    surface2x1 contour_h1;\n    surface2x1 contour_v0;\n    surface2x1 contour_v1;\n    // extract contour of quadratics at planes\n    surface2x2_project_ortho_x(slice_x0, contour_h0);\n    surface2x2_project_ortho_x(slice_x1, contour_h1);\n    surface2x2_project_ortho_x(slice_y0, contour_v0);\n    surface2x2_project_ortho_x(slice_y1, contour_v1);\n    // compute z bounds of plane contours\n    vec2 ph0 = surface2x1_bounds(contour_h0);\n    vec2 ph1 = surface2x1_bounds(contour_h1);\n    vec2 pv0 = surface2x1_bounds(contour_v0);\n    vec2 pv1 = surface2x1_bounds(contour_v1);\n\n\n    surface2x1 slice_h0z0;\n    surface2x1 slice_h0z1;\n    surface2x1 slice_h1z0;\n    surface2x1 slice_h1z1;\n    surface2x1 slice_v0z0;\n    surface2x1 slice_v0z1;\n    surface2x1 slice_v1z0;\n    surface2x1 slice_v1z1;\n\n    // extract quadratic of line at plane z bounds\n    surface2x2_ortho_plane_x(slice_x0, ph0[0], slice_h0z0);\n    surface2x2_ortho_plane_x(slice_x0, ph0[1], slice_h0z1);\n    surface2x2_ortho_plane_x(slice_x1, ph1[0], slice_h1z0);\n    surface2x2_ortho_plane_x(slice_x1, ph1[1], slice_h1z1);\n    surface2x2_ortho_plane_x(slice_y0, pv0[0], slice_v0z0);\n    surface2x2_ortho_plane_x(slice_y0, pv0[1], slice_v0z1);\n    surface2x2_ortho_plane_x(slice_y1, pv1[0], slice_v1z0);\n    surface2x2_ortho_plane_x(slice_y1, pv1[1], slice_v1z1);\n\n    // compute position of contact points at plane z bounds\n    bounds.eh0_0 = vec3(ph0[0] * u[0], surface2x1_center(slice_h0z0), ph0[0]);\n    bounds.eh1_0 = vec3(ph1[0] * u[1], surface2x1_center(slice_h1z0), ph1[0]);\n    bounds.ev0_0 = vec3(surface2x1_center(slice_v0z0), pv0[0] * vec2(v[0],1.0));\n    bounds.ev1_0 = vec3(surface2x1_center(slice_v1z0), pv1[0] * vec2(v[1],1.0));\n    bounds.eh0_1 = vec3(ph0[1] * u[0], surface2x1_center(slice_h0z1), ph0[1]);\n    bounds.eh1_1 = vec3(ph1[1] * u[1], surface2x1_center(slice_h1z1), ph1[1]);\n    bounds.ev0_1 = vec3(surface2x1_center(slice_v0z1), pv0[1] * vec2(v[0],1.0));\n    bounds.ev1_1 = vec3(surface2x1_center(slice_v1z1), pv1[1] * vec2(v[1],1.0));\n\n    // extract quadratic of corners\n    surface2x1 slice_x0y0;\n    surface2x1 slice_x0y1;\n    surface2x1 slice_x1y0;\n    surface2x1 slice_x1y1;\n\tsurface2x2_perspective_plane(slice_x0, v[0], slice_x0y0);\n    surface2x2_perspective_plane(slice_x0, v[1], slice_x0y1);\n\tsurface2x2_perspective_plane(slice_x1, v[0], slice_x1y0);\n    surface2x2_perspective_plane(slice_x1, v[1], slice_x1y1);\n\n    // compute z bounds of corner quadratics\n    vec2 cx0y0 = surface2x1_bounds(slice_x0y0);\n    vec2 cx0y1 = surface2x1_bounds(slice_x0y1);\n    vec2 cx1y0 = surface2x1_bounds(slice_x1y0);\n    vec2 cx1y1 = surface2x1_bounds(slice_x1y1);\n\n    // compute position of contact points at corner z bounds\n    bounds.c00_0 = vec3(u[0], v[0], 1.0) * cx0y0[0];\n    bounds.c01_0 = vec3(u[0], v[1], 1.0) * cx0y1[0];\n    bounds.c10_0 = vec3(u[1], v[0], 1.0) * cx1y0[0];\n    bounds.c11_0 = vec3(u[1], v[1], 1.0) * cx1y1[0];\n    bounds.c00_1 = vec3(u[0], v[0], 1.0) * cx0y0[1];\n    bounds.c01_1 = vec3(u[0], v[1], 1.0) * cx0y1[1];\n    bounds.c10_1 = vec3(u[1], v[0], 1.0) * cx1y0[1];\n    bounds.c11_1 = vec3(u[1], v[1], 1.0) * cx1y1[1];\n\n\n}\n\nvec2 lissajous(float t, float a, float b) {\n    return vec2(sin(a*t), sin(b*t));\n}\n\nvoid setup_globals(float t) {\n    // move the frustum around\n    vec2 frustum_center = lissajous(t*0.07, 2.0, 1.0)*0.1;\n    // vary the frustum aperture\n    vec2 frustum_half_size = mix(\n        min_frustum_half_size,\n\t\tmax_frustum_half_size,\n        cos(t*0.13)*0.5+0.5);\n\n    // transform our simplex a bit\n    vec2 plane_offset = lissajous(t*0.2, 5.0, 4.0)*0.3;\n    vec4 plane_rotation = versor(normalize(vec3(1.0)), t*0.2);\n    vec3 plane_normal = rotate(plane_rotation, vec3(0.0, 0.0, 1.0));\n    vec3 ellipsoid_size = vec3(1.0,3.0,1.0) * 0.3;\n    //plane_rotation = vec4(0.0,0.0,0.0,1.0);\n    transformed_quadric(\n        vec4(1.0 / (ellipsoid_size*ellipsoid_size) * vec3(1.0,1.0,1.0),-1.0),\n\t\tplane_rotation, vec3(plane_offset + vec2(0.0,0.0),1.0), surf3);\n\n}\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\nfloat AA;\nfloat AAINV;\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n#define save(name) Context name = _save();\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\nfloat distborder(float x) {\n\treturn 1.0 - clamp(x*400.0, 0.0, 1.0);\n}\n\nvoid paint() {\n    float t = iTime;\n    setup_globals(t);\n\n    //scale(0.3);\n\n    float rdot = AAINV*2.0;\n\n    vec2 ofs = vec2(0.05, -0.12);\n    if (iMouse.z > 0.5) {\n        ofs = get_query();\n    }\n\n    vec2 u = vec2(-1.0,1.0) * 0.1 + ofs.x;\n    vec2 v = vec2(-1.0,1.0) * 0.1 + ofs.y;\n\n    bounds2x3 bounds;\n    compute_bounding_points_compact(surf3, u, v, bounds);\n\n\tvec4 range = compute_bounds(bounds, u, v);\n\n    surface2x2 contour_zy;\n    surface2x3_project_ortho_yz(surf3, contour_zy);\n    surface2x2_swizzle_yx(contour_zy,contour_zy);\n\n#if 1\n    {\n        vec2 p = get_origin();\n        surface2x1 surf1;\n        surface2x3_perspective_ray(surf3, p, surf1);\n        vec2 d = surface2x1_bounds(surf1);\n        float d0 = d[0];\n\t\tfloat d1 = d[1];\n        vec3 normal0 = normalize(surface2x3_diff(surf3, vec3(p,d0)));\n        vec3 normal1 = normalize(surface2x3_diff(surf3, vec3(p,d1)));\n\n        if ((d0 > 0.0) && (d1 > d0)) {\n            vec3 pos0 = vec3(p,1.0) * d0;\n            vec3 pos1 = vec3(p,1.0) * d1;\n            vec3 color0 = (sin(d0*100.0)*0.5+0.5) * (normal0 * 0.5 + 0.5);\n            vec3 color1 = hsl(d1 * 10.0,0.5,0.9) * (normal1 * 0.5 + 0.5);\n\n#if 0\n            if (!in_wedge(pos0.yz, v)) {\n                color0 *= 0.3;\n            }\n#else\n            if ((pos0.z < range[0])||(pos0.z > range[1]))\n                color0 = color1;\n            if ((pos1.z < range[0])||(pos1.z > range[1]))\n                color1 = vec3(0.0, 0.0, 0.2);\n#endif\n\n            vec3 color = mix(color0, color1, 0.4);\n            if (pos0.z > range[2]) {\n                color *= vec3(0.2,0.2,1.0);\n            }\n#if 0\n            color = mix(color, vec3(1.0, 1.0, 1.0), distborder(length(pos0 - bounds.v0) - 0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.v1) - 0.01));\n\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.eh0_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.eh1_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.ev0_1)-0.01));\n            color = mix(color, vec3(1.0, 0.0, 0.0), distborder(length(pos1 - bounds.ev1_1)-0.01));\n\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.eh0_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.eh1_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.ev0_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.ev1_0)-0.02));\n\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c00_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c01_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c10_0)-0.02));\n            color = mix(color, vec3(1.0), distborder(length(pos0 - bounds.c11_0)-0.02));\n\n            //color = mix(color, vec3(1.0), distborder(abs(pos0.z - bounds.ev1_0.z)-0.005));\n#endif\n\n            color = clamp(color, vec3(0.0), vec3(1.0));\n            set_source_rgb(color);\n            clear();\n        } else {\n            set_source_rgb(vec3(0.0,0.0,0.2));\n            clear();\n        }\n    }\n#else\n    set_source_rgb(vec3(0.0));\n    clear();\n#endif\n\n\n    set_source_rgb(vec3(1.0));\n    set_line_width_px(0.5);\n\n    move_to(u[0],-1.0);\n    line_to(u[0],1.0);\n\tstroke();\n    move_to(u[1],-1.0);\n    line_to(u[1],1.0);\n\tstroke();\n    move_to(-2.0,v[0]);\n    line_to( 2.0,v[0]);\n\tstroke();\n    move_to(-2.0,v[1]);\n    line_to( 2.0,v[1]);\n\tstroke();\n\n    surface2x2 slice_x0;\n    surface2x2 slice_x1;\n\tsurface2x3_perspective_plane_x(surf3, u[0], slice_x0);\n    surface2x3_perspective_plane_x(surf3, u[1], slice_x1);\n\n    set_source_rgb(vec3(1.0));\n    set_line_width_px(1.3);\n    add_field(surface2x2_eval(contour_zy, get_origin())*0.01);\n    stroke();\n    add_field(surface2x2_eval(slice_x0, get_origin())*0.3);\n    stroke();\n    add_field(surface2x2_eval(slice_x1, get_origin())*0.3);\n    stroke();\n\n    move_to(0.0, 0.0);\n\tline_to(2.0,v[1]*2.0);\n    move_to(0.0, 0.0);\n\tline_to(2.0,v[0]*2.0);\n    stroke();\n\n#define DRAW_Z(N) move_to(N, v[0]*N); line_to(N, v[1]*N); stroke();\n    DRAW_Z(range[0]);\n    DRAW_Z(range[1]);\n    set_source_rgba(1.0,1.0,1.0,0.5);\n    DRAW_Z(range[2]);\n    DRAW_Z(range[3]);\n\n    set_source_rgb(hsl(0.06,1.0,0.6));\n    circle(bounds.v0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.25,1.0,0.6));\n    circle(bounds.eh0_0.zy, rdot * 2.0);\n    circle(bounds.eh1_0.zy, rdot * 2.0);\n    circle(bounds.ev0_0.zy, rdot * 2.0);\n    circle(bounds.ev1_0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.6,1.0,0.6));\n    circle(bounds.c00_0.zy, rdot * 2.0);\n    circle(bounds.c01_0.zy, rdot * 2.0);\n    circle(bounds.c10_0.zy, rdot * 2.0);\n    circle(bounds.c11_0.zy, rdot * 2.0);\n    fill();\n    set_source_rgb(hsl(0.06,1.0,0.6));\n    circle(bounds.v1.zy, rdot);\n    fill();\n    set_source_rgb(hsl(0.25,1.0,0.6));\n    circle(bounds.eh0_1.zy, rdot);\n    circle(bounds.eh1_1.zy, rdot);\n    circle(bounds.ev0_1.zy, rdot);\n    circle(bounds.ev1_1.zy, rdot);\n    fill();\n    set_source_rgb(hsl(0.6,1.0,0.6));\n    circle(bounds.c00_1.zy, rdot);\n    circle(bounds.c01_1.zy, rdot);\n    circle(bounds.c10_1.zy, rdot);\n    circle(bounds.c11_1.zy, rdot);\n    fill();\n\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = sqrt(_color);\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));\n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    c = clamp(c, vec4(0.0), vec4(1.0));\n    c.rgb = c.rgb*c.rgb;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\n    float m = ab.x*p.x/l;\n\tfloat n = ab.y*p.y/l;\n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n\n    vec2 r = vec2( ab.x*co, ab.y*si );\n\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n\n    init(fragCoord);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2cD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 549, 586, 586, 655], [657, 676, 700, 700, 732], [734, 785, 814, 814, 893], [895, 938, 962, 962, 1311], [1313, 1484, 1554, 1554, 1939], [1941, 2047, 2116, 2116, 2338], [2340, 2519, 2569, 2569, 2892], [2894, 3058, 3109, 3109, 3454], [3456, 3585, 3636, 3636, 3832], [3834, 4030, 4102, 4102, 4745], [4747, 4747, 4827, 4827, 4995], [4997, 5302, 5391, 5391, 5798], [5800, 6105, 6194, 6194, 6601], [6603, 6842, 6929, 6929, 7140], [7142, 7415, 7498, 7498, 7864], [7866, 8088, 8171, 8171, 8388], [8390, 8614, 8697, 8697, 8914], [8917, 9045, 9089, 9089, 9324], [9326, 9607, 9691, 9691, 10025], [10027, 10294, 10372, 10372, 10706], [10708, 10936, 11012, 11012, 11443], [11445, 11673, 11749, 11749, 12180], [12182, 12410, 12486, 12486, 12917], [12919, 13112, 13187, 13187, 13421], [13423, 13651, 13726, 13726, 14218], [14220, 14346, 14397, 14440, 14569], [14572, 14698, 14742, 14742, 14844], [14846, 14951, 14996, 14996, 15084], [15274, 15274, 15305, 15305, 15358], [15359, 15359, 15400, 15400, 15453], [15455, 15455, 15523, 15523, 15647], [15649, 15649, 15730, 15730, 15909], [15911, 15911, 15966, 15966, 16807], [16809, 16809, 16902, 16902, 23157], [23159, 23159, 23250, 23250, 27372], [27374, 27374, 27417, 27417, 27456], [27458, 27458, 27487, 27518, 28223], [34035, 34100, 34127, 34127, 34169], [34171, 34171, 34185, 34185, 39506], [39660, 39720, 39747, 39747, 39773], [39775, 39835, 39856, 39856, 39963], [39965, 39965, 40002, 40002, 40088], [40090, 40090, 40136, 40136, 40169], [40171, 40309, 40337, 40337, 40797], [40825, 40825, 40844, 40844, 40877], [40879, 40879, 40897, 40897, 40930], [40932, 40932, 40956, 40956, 41060], [41062, 41062, 41079, 41079, 41100], [41102, 41102, 41129, 41151, 41434], [41436, 41436, 41464, 41464, 41698], [41700, 41700, 41724, 41724, 41810], [41812, 41812, 41839, 41839, 42052], [42054, 42054, 42080, 42080, 42308], [42310, 42310, 42332, 42332, 42458], [42460, 42460, 42480, 42480, 42540], [42542, 42542, 42574, 42574, 42601], [42603, 42603, 42624, 42624, 42646], [42648, 42648, 42672, 42672, 42732], [42734, 42734, 42768, 42768, 42792], [42794, 42794, 42808, 42808, 42872], [42874, 42874, 42900, 42900, 42938], [42940, 42940, 42966, 42966, 42993], [42995, 42995, 43018, 43018, 43113], [43115, 43115, 43139, 43139, 43208], [43210, 43210, 43235, 43235, 43282], [43284, 43284, 43301, 43301, 43414], [43416, 43416, 43439, 43439, 43568], [43570, 43570, 43598, 43598, 43726], [43728, 43728, 43752, 43752, 43892], [43894, 43894, 43932, 43932, 44066], [44068, 44068, 44105, 44105, 44140], [44142, 44142, 44169, 44169, 44219], [44221, 44221, 44251, 44251, 44307], [44309, 44309, 44338, 44338, 44519], [44521, 44521, 44543, 44543, 44702], [44704, 44704, 44717, 44717, 44756], [44758, 44758, 44788, 44788, 44817], [44819, 44819, 44852, 44852, 44909], [44911, 44911, 44937, 44937, 44987], [44989, 44989, 45010, 45010, 45075], [45077, 45077, 45101, 45101, 45184], [45186, 45186, 45201, 45201, 45242], [45244, 45244, 45260, 45260, 45298], [45300, 45300, 45318, 45318, 45375], [45377, 45377, 45407, 45407, 45842], [45844, 45844, 45902, 45902, 45940], [45942, 45942, 45971, 45971, 46007], [46009, 46009, 46057, 46057, 46088], [46090, 46090, 46124, 46124, 46183], [46185, 46185, 46262, 46262, 46427], [46429, 46429, 46506, 46506, 46586], [46588, 46588, 46664, 46664, 46780], [46782, 46782, 46858, 46858, 46936], [46938, 46938, 46976, 46976, 47010], [47012, 47012, 47034, 47034, 47080], [47082, 47082, 47109, 47109, 47153], [47155, 47155, 47204, 47204, 47465], [47467, 47467, 47540, 47540, 47594], [47596, 47596, 47628, 47628, 47664], [47666, 47666, 47722, 47722, 47778], [47780, 47780, 47810, 47810, 47903], [47904, 47904, 47944, 47944, 47967], [47969, 48015, 48054, 48054, 49202], [49204, 49204, 49234, 49234, 49336], [49338, 49338, 49390, 49390, 49430], [49432, 49432, 49454, 49454, 49505], [49507, 49507, 49539, 49539, 49561], [49563, 49578, 49600, 49600, 49892], [49894, 49894, 49926, 49926, 49948], [49950, 49950, 49969, 49969, 50001], [50050, 50113, 50155, 50155, 50221], [50223, 50293, 50344, 50344, 50696], [50698, 50732, 50778, 50778, 51290], [51292, 51361, 51407, 51407, 51913], [51915, 51915, 51948, 51948, 52164], [52166, 52166, 52225, 52225, 52270], [52272, 52272, 52315, 52315, 52376], [52378, 52378, 52420, 52420, 52462], [52464, 52524, 52581, 52581, 52780]], "test": "untested"}
{"id": "Xt2cDt", "name": "Laserworld", "author": "DrLuke", "description": "Threw this together in one hour", "tags": ["grid", "laser", "vhs"], "likes": 22, "viewed": 2130, "published": "Public API", "date": "1510616193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under a Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n// Inspiration: http://kingsanda.tumblr.com/post/166772103767\n\nfloat notsosmoothstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0); \n    return mix(x*x*(3. - 2.*x), x, 0.6);\n}\n\n#define horiz(s, e, p) if(s.x < p.x && p.x <= e.x) return mix(s.y, e.y, notsosmoothstep(0., 1., (p.x - s.x) / (e.x - s.x)));\nfloat horizonHeight1(vec2 pos)\n{\n    horiz( vec2(-1, 0.1), vec2(-0.9, 0.3), pos );\n    horiz( vec2(-0.9, 0.3), vec2(-0.75, 0.5), pos );\n    horiz( vec2(-0.75, 0.5), vec2(-0.6, 0.2), pos );\n    horiz( vec2(-0.6, 0.2), vec2(-0.3, 0.25), pos );\n    horiz( vec2(-0.3, 0.25), vec2(-0., 0.2), pos );\n    horiz( vec2(-0., 0.2), vec2(.1, 0.3), pos );\n    horiz( vec2(.1, 0.3), vec2(.24, 0.32), pos );\n    horiz( vec2(.24, 0.32), vec2(.3, 0.3), pos );\n    horiz( vec2(.3, 0.3), vec2(.34, 0.32), pos );\n    horiz( vec2(.34, 0.32), vec2(.36, 0.31), pos );\n    horiz( vec2(.36, 0.31), vec2(.4, 0.27), pos );\n    horiz( vec2(.4, 0.27), vec2(.47, 0.23), pos );\n    horiz( vec2(.47, 0.23), vec2(.6, 0.15), pos );\n    horiz( vec2(.6, 0.15), vec2(.8, 0.3), pos );\n    horiz( vec2(.8, 0.3), vec2(1., 0.2), pos );\n}\n\nfloat horizonHeight2(vec2 pos)\n{\n    #define P21 vec2(-1, 0.1)\n    #define P22 vec2(-0.93, 0.03)\n    #define P23 vec2(-0.8, -0.3)\n    #define P24 vec2(-0.7, -0.35)\n    #define P25 vec2(-0.3, 0.05)\n    #define P26 vec2(-0.1, -0.05)\n    #define P27 vec2(-0.03, -0.02)\n    #define P28 vec2(-0., 0.07)\n    #define P29 vec2(0.05, 0.1)\n    #define P210 vec2(0.1, 0.14)\n    #define P211 vec2(0.25, 0.1)\n    #define P212 vec2(0.4, 0.24)\n    #define P213 vec2(0.5, 0.2)\n    #define P214 vec2(0.7, 0.3)\n    #define P215 vec2(0.8, 0.1)\n    #define P216 vec2(0.88, 0.14)\n    #define P217 vec2(1., -0.1)\n    \n    horiz( P21, P22, pos );\n\thoriz( P22, P23, pos );\n    horiz( P23, P24, pos );\n    horiz( P24, P25, pos );\n    horiz( P25, P26, pos );\n    horiz( P26, P27, pos );\n    horiz( P27, P28, pos );\n    horiz( P28, P29, pos );\n    horiz( P29, P210, pos );\n    horiz( P210, P211, pos );\n    horiz( P211, P212, pos );\n    horiz( P212, P213, pos );\n    horiz( P213, P214, pos );\n    horiz( P214, P215, pos );\n    horiz( P215, P216, pos );\n    horiz( P216, P217, pos );\n}\n\nfloat horizonHeight3(vec2 pos)\n{\n    #define P31 vec2(-1, -0.04)\n    #define P32 vec2(-0.93, -0.03)\n    #define P33 vec2(-0.8, 0.05)\n    #define P34 vec2(-0.7, 0.07)\n    #define P35 vec2(-0.6, 0.04)\n    #define P36 vec2(-0.4, -0.1)\n    #define P37 vec2(0.5, -0.1)\n    #define P38 vec2(0.72, 0.32)\n    #define P39 vec2(0.78, 0.32)\n    #define P310 vec2(0.81, 0.26)\n    #define P311 vec2(0.85, 0.3)\n    #define P312 vec2(0.92, 0.34)\n    #define P313 vec2(1., 0.4)\n\n    \n    horiz( P31, P32, pos );\n\thoriz( P32, P33, pos );\n    horiz( P33, P34, pos );\n    horiz( P34, P35, pos );\n    horiz( P35, P36, pos );\n    horiz( P36, P37, pos );\n    horiz( P37, P38, pos );\n    horiz( P38, P39, pos );\n    horiz( P39, P310, pos );\n    horiz( P310, P311, pos );\n    horiz( P311, P312, pos );\n    horiz( P312, P313, pos );\n\n}\n\n// Thanks to izutionix\nfloat grid(vec2 uv)\n{\n    #define VANTAGE vec2(0,-0.21)\n    uv = uv - VANTAGE;\n    float m = max(sign(-uv.y),0.); //mask\n    \n    uv /= 1.; //zoom\n    float d = -1./uv.y; //depth\n    vec2 pv = vec2(uv.x*d, d); //perspective\n    pv *= 1.4545; //scale\n    pv.y += iTime; //offset\n    \n\t// http://iquilezles.org/www/articles/filterableprocedurals/filterableprocedurals.htm\n    const float N = 16.;\n    vec2 w = fwidth(pv) + 0.001;\n    vec2 a = pv + 0.5*w;\n    vec2 b = pv - 0.5*w;\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (i.x + i.y - i.x*i.y)*m;\n}\n\nfloat gridAA(vec2 uv)\n{\n    #define Xsamps 2\n    #define Ysamps 2\n    #define Xoff (1./float(2*Xsamps + 1)*float(i))\n    #define Yoff (1./float(2*Ysamps + 1)*float(j))\n    #define PXSIZE ( (vec2(1) / iResolution.xy) * (iResolution.x/iResolution.y) )\n    \n    float v = 0.0;\n    for(int i=-Xsamps; i <= Xsamps; i++)\n    for(int j=-Ysamps; j <= Ysamps; j++)\n    {\n        v += grid(uv + vec2(Xoff, Yoff) * PXSIZE);\n    }\n    \n    return v / float((2*Xsamps + 1) * (2*Ysamps + 1));\n}\n\n\nfloat burst1(vec2 uv)\n{\n    return clamp(-uv.y+0.3-abs(uv.x*0.1), 0., 1.);\n}\n\nfloat burst2(vec2 uv)\n{\n    return clamp(-uv.y+0.8-abs(uv.x*0.1), 0., 1.);\n}\n\nfloat burst3(vec2 uv)\n{\n    return clamp(-uv.y+0.1+cos(uv.x*0.5), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvo = (fragCoord.xy * 2. / iResolution.xy) - vec2(1);\n\tvec2 uv = uvo * vec2(iResolution.x/iResolution.y, 1);\t// uv coordinates with corrected aspect ratio\n    \n    #define LASERCOL vec3(1., 0.14, 0.2)\n    \n    float bmask = 0.0;\n    #define sunmaskfeather (7. / iResolution.y)\n    float sunmask1 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight1(uvo)*0.8 + 0.15);\n    bmask += sunmask1 * burst1(uvo);\n    float sunmask2 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight2(uvo) - 0.42);\n    bmask += sunmask1 * sunmask2 * burst2(uvo);\n    float sunmask3 = smoothstep(-sunmaskfeather, sunmaskfeather, uvo.y - horizonHeight3(uvo) - 0.36);\n    bmask += sunmask1 * sunmask2 * sunmask3 * burst3(uvo);\n    \n    bmask *= 1.-texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r*0.4*pow((0.9-bmask*0.9), 2.);\n    \n    fragColor.rgb = bmask*LASERCOL;\n    \n    float g = gridAA(uv);\n    g *= 1.-texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy).r*0.1*pow((0.9-bmask*0.9), 2.);\n    fragColor.rgb += g*LASERCOL;\n    \n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2cDt.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[138, 201, 259, 259, 357], [484, 484, 516, 516, 1280], [1282, 1282, 1314, 1314, 2339], [2341, 2341, 2373, 2373, 3151], [3153, 3176, 3197, 3197, 3771], [3773, 3773, 3796, 3796, 4253], [4256, 4256, 4279, 4279, 4332], [4334, 4334, 4357, 4357, 4410], [4412, 4412, 4435, 4435, 4488], [4490, 4490, 4547, 4547, 5632]], "test": "untested"}
{"id": "Xt2cRc", "name": "Tutorial 2: Tiempo", "author": "aaecheve", "description": "Tutorial 2 CC7615", "tags": ["tutorial", "cc7615"], "likes": 0, "viewed": 58, "published": "Public", "date": "1509565748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Otra variable global util es iTime, que contiene el tiempo. Con esto\n//se puede hacer que el color resultante varíe seguna una función del tiempo\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2cRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 151, 208, 208, 298]], "test": "untested"}
{"id": "Xt2czt", "name": "Flickering Dots", "author": "chaosink", "description": "Flickering Dots. Very simple.", "tags": ["2d"], "likes": 10, "viewed": 517, "published": "Public API", "date": "1509794941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    float d = dot(uv, uv);\n    //float d = sqrt(dot(uv, uv));\n    fragColor = vec4(.5 + .5 * cos(d / 5. + iTime * 10.));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2czt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 225]], "test": "untested"}
{"id": "Xt2yW3", "name": "sinusoids", "author": "chillu", "description": "my first shader..", "tags": ["sinusoids"], "likes": 3, "viewed": 434, "published": "Public API", "date": "1510442686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv *= 2.0;\n\n    float t = iTime;\n    float r = 15.*(1.0+0.2*sin(5.*t));\n \n    float l1 = 1.0 - length(uv);\n    float l2 = 1.0 - length(uv + vec2(cos(t*2.5),sin(t)));\n    float l3 = 1.0 - length(uv + vec2(cos(t),-sin(1.25*t)));\n\n    float x = sin(r*l1)/2.+l2/2.0+l3/2.0;\n\n    float fw = 0.5*fwidth(x);\n\tfloat l = smoothstep(0.25 - fw, 0.25 + fw, x);\n\n    fragColor = vec4(l,l,l, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2yW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 544]], "test": "untested"}
{"id": "Xt2yzt", "name": "Noise Raymarching", "author": "Lucky4Luuk", "description": "Based on IQ's noise and raymarching shaders.", "tags": ["procedural", "noise"], "likes": 3, "viewed": 721, "published": "Public API", "date": "1509788719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#define AA 1   // make this 1 is your machine is too slow\n#define stepSize 0.5;\n\n//------------------------------------------------------------------\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n#if 1\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n#else\n    // correct distance\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n#endif\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat heightDisplacement(vec3 p)\n{\n    vec3 c = (p);\n    return (noise(c.xz));\n    return sin(20.0*c.x)*sin(20.0*c.y)*sin(20.0*c.z);\n}\n\nfloat opHeightDisplacement(vec3 p)\n{\n    float d1 = sdPlane(p);\n    float d2 = heightDisplacement(p);\n    return d1+d2;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    //vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t//                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    //res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    //res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\t//res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    //res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\t//res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\t//res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\t//res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\t//res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\t//res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\t//res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\t//res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\t//res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    //res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t//                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    //res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t//                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\t//res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n\t//res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    //res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    //res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n    \n    vec2 res = vec2(opHeightDisplacement(pos), 50.0);\n    res = opU(res, vec2(sdPlane(pos), 1.0));\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n#if 1\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (25.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>25.0 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*stepSize;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n        vec3 ta = vec3( -0.5, -0.4, 0.5 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2yzt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1417, 1487, 1545, 1545, 1683], [1685, 1685, 1711, 1711, 2109], [2111, 2111, 2136, 2136, 2151], [2153, 2153, 2188, 2188, 2214], [2216, 2216, 2247, 2247, 2338], [2340, 2340, 2383, 2383, 2443], [2445, 2445, 2490, 2490, 2532], [2534, 2534, 2567, 2567, 2622], [2624, 2624, 2660, 2660, 2902], [2904, 2904, 2956, 2956, 3070], [3072, 3072, 3115, 3115, 3356], [3358, 3358, 3394, 3394, 3697], [3699, 3699, 3735, 3735, 3834], [3836, 3836, 3874, 3874, 4043], [4045, 4045, 4117, 4117, 4332], [4334, 4334, 4401, 4440, 4812], [4814, 4814, 4839, 4839, 4876], [4878, 4878, 4903, 4903, 4961], [4963, 4963, 4988, 4988, 5053], [5055, 5055, 5090, 5090, 5161], [5163, 5163, 5198, 5198, 5269], [5271, 5271, 5308, 5308, 5361], [5363, 5433, 5466, 5466, 5492], [5494, 5494, 5524, 5524, 5557], [5559, 5559, 5589, 5589, 5618], [5620, 5620, 5644, 5644, 5776], [5778, 5778, 5812, 5812, 5912], [5914, 5914, 5950, 5950, 6035], [6037, 6107, 6132, 8280, 8411], [8413, 8413, 8453, 8453, 9083], [9086, 9086, 9160, 9160, 9420], [9422, 9422, 9454, 9454, 9893], [9895, 9895, 9937, 9937, 10236], [10238, 10238, 10277, 10277, 11848], [11850, 11850, 11902, 11902, 12079], [12081, 12081, 12138, 12138, 13107]], "test": "untested"}
{"id": "XtBcRt", "name": "Checker waves", "author": "CoyHot", "description": "Checker, Sinus and offset", "tags": ["procedural", "2d", "wave"], "likes": 0, "viewed": 76, "published": "Public", "date": "1509656102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t-------------\n\tChecker waves\n\t-------------\n\n    Just for playing a bit with sinus, uv offset and patterns repetition\n\n\tFrancois 'CoyHot' Grassard - 2017\n*/\n\n#define DispStrenght 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5)/vec2(iResolution.y / iResolution.x, 1);\n    \n    uv.y += sin(((uv.x+iTime)*0.75)*0.75);\n    float c = sin((uv.x-iTime)*20.0)/sin(uv.y*20.)*100.;\n\n\tfragColor = vec4(clamp(c,0.0,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 188, 245, 245, 479]], "test": "untested"}
{"id": "XtBcWd", "name": "Debris 1", "author": "lsdlive", "description": "While learning from these shaders: https://www.youtube.com/watch?v=Oa_zCThLXRw I experimented a little bit & make this shader.\nThere is multiple options to test & play with this one.", "tags": ["raymarch", "glitch"], "likes": 3, "viewed": 166, "published": "Public", "date": "1510517640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat sc(vec3 p) {\n\tp = abs(p);\n\tfloat da = max(p.x, p.y);\n\tfloat db = max(p.y, p.z);\n\tfloat dc = max(p.z, p.x);\n\treturn min(da, min(db, dc));\n}\n\nvec2 amod(vec2 p, float m) {\n\tfloat a = mod(atan(p.x, p.y), m) - m * .5;\n\treturn vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat map(vec3 p) {\n\tmat2 r = r2d(iTime);\n\n\tp.xy = abs(amod(p.xy, .785));\n    \n\tp.z = mod(p.z, 8.) - 4.;\n    \n    //p.y = mod(p.y, 2.) - 1.;\n\n\tfor (int i = 0; i < 5; i++) {\n\t\t\n        //p.xy*=r2d(.48);\n\n        p =  abs(reflect(p, normalize(vec3(.64, -.4, .7)))) -2.3;\n\n\n\t\tp.y = abs(p.y) - .1;\n\t}\n\n\n\treturn 1.7*sc(p) - .5;\n    //return .9*sc(p) - .5;\n    //return 1.1*sc(p) - .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n    // mode 1\n    //vec3 ro = vec3(0, 0, -iTime*10.), p;\n\tvec3 rd = normalize(vec3(uv * r2d(iTime*.6), -1));\n\t\n    // mode 2\n    vec3 ro = vec3(cos(iTime), sin(iTime), -iTime*10.), p;\n    //vec3 rd = normalize(vec3(uv, -1));\n\n\n\tp = ro;\n\tint ri;\n\tfor (int i = 0; i < 100; i++) {\n\t\tri = i;\n\t\tfloat d = map(p);\n\t\tif (d < .001) break;\n\t\tp += d * rd;\n\t}\n\n    // b&w simple render\n\t//fragColor = vec4(length(ro - p) * .1);\n\t\n    // colorful render\n    float it = float(ri) / 100.;\n    \n    //vec3 c = it*mix(vec3(.6, .2, .5), vec3(.2, .5, .5), length(uv.xy) )*5.;\n    vec3 c = it*mix(vec3(.5, .2, .2), vec3(.2, .5, .5), length(uv.xy) )*5.;\n    c = c + cos(1e3*uv.y) * .02;\n    \n\tfragColor = vec4(c, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 86], [89, 89, 107, 107, 233], [235, 235, 263, 263, 351], [353, 353, 372, 372, 734], [736, 736, 791, 791, 1579]], "test": "untested"}
{"id": "XtByDt", "name": "Wave Room", "author": "dr2", "description": "Dynamic art", "tags": ["waves"], "likes": 8, "viewed": 645, "published": "Public API", "date": "1510492545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wave Room\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qnBlk[2], bSize, vnBall;\nfloat dstFar, tCur, tWav;\nint idObj;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;  q.y -= bSize.y - 0.15;\n  d = PrSphDf (q, 0.15);\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = p;\n  q.z = abs (q.z) - bSize.z;\n  d = max (PrBoxDf (q, vec3 (bSize.xy - 0.1, 0.03)), - PrBox2Df (q.xy, bSize.xy - 0.15));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  q = p;\n  q.x = abs (q.x) - bSize.x;\n  d = max (PrBoxDf (q, vec3 (0.03, bSize.yz - 0.1)), - PrBox2Df (q.zy, bSize.zy - 0.15));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec2 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  dMin = dstFar;\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    qnBlk[0] = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qnBlk[1] = - sign (rd) * step (tp, tp.zxy) * step (tp, tp.yzx);\n  }\n  return vec2 (dMin, df);\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec3 p, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  rad = 0.2 * bSize.y;\n  p = vec3 (0., - bSize.y + 2. * rad, 0.);\n  u = ro - p;\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec2 p)\n{\n  vec3 vn;\n  vec2 e = vec2 (0.01, 0.);\n  p *= 0.4;\n  vn.xz = 0.2 * (WaveHt (p) - vec2 (WaveHt (p + e.xy), WaveHt (p + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, vnb, col, ltDirB;\n  vec2 dBlock, q;\n  float dstObj, dstBall, spec, glit;\n  tWav = 0.1 * tCur + 10.;\n  ltDirB = ltDir;\n  dstBall = BallHit (ro, rd);\n  if (dstBall < dstFar) {\n    ro += dstBall * rd;\n    rd = reflect (rd, vnBall);\n    ltDirB = reflect (ltDirB, vnBall);\n    ro += 0.01 * rd;\n  }\n  dBlock = BlkHit (ro, rd, bSize);\n  dstObj = ObjRay (ro, rd);\n  glit = 0.;\n  spec = 0.1;\n  if (dstObj < dBlock.y) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (1., 1., 0.9) * (0.6 - 0.4 * dot (rd, vn));\n    else if (idObj == 2) col = vec3 (0.3, 0.2, 0.);\n  } else {\n    vnb = qnBlk[1];\n    ro += rd * dBlock.y;\n    if (vnb.y > 0.) {\n      vn = vnb;\n      col = mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n         Fbm2 (vec2 (50., 5.) * ro.xz)) *\n         (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (10. * ro.x, 1.)));\n      col *= 0.6 + 0.4 * smoothstep (0.05, 0.15, length (ro.xz) / bSize.x);\n    } else if (vnb.y < 0.) {\n      col = vec3 (0.7, 0.7, 0.8) * (0.7 + 0.3 * smoothstep (0., 0.15, length (ro.xz) / bSize.x));\n      vn = VaryNf (50. * ro, vnb, 1.);\n    } else {\n      q = (abs (vnb.z) == 1.) ? ro.xy : ro.zy;\n      if (abs (q.x) > bSize.x - 0.15 || abs (q.y) > bSize.y - 0.15) {\n        col = vec3 (0.6, 0.6, 0.55);\n        vn = VaryNf (50. * ro, vnb, 1.);\n      } else {\n        col = vec3 (0.8, 0.6, 0.1);\n        glit = 1.;\n        if (abs (vnb.z) == 1.) {\n          vn = WaveNf (10. * q).xzy;\n          vn.z *= sign (vnb.z);\n        } else {\n          vn = WaveNf (10. * q).yxz;\n          vn.x *= sign (vnb.x);\n        }\n      }\n    }\n    if (glit > 0.) {\n      glit = 1000. * step (0.01, max (0., dot (vn, ltDirB))) *\n         pow (max (0., dot (ltDirB, reflect (rd, vn))), 16.) *\n         pow (1. - 0.6 * abs (dot (normalize (ltDirB - rd), VaryNf (1000. * ro, vn, 2.))), 8.);\n      col = glit * vec3 (1., 1., 0.5) + col * (0.2 + 0.8 * max (dot (vn, ltDirB), 0.));\n    } else {\n      col = col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.)) +\n         spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    }\n  }\n  return clamp (col, 0., 1.);  \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 5.;\n  bSize = vec3 (2., 1., 2.);\n  ro = vec3 (0., 0., -0.9 * bSize.z);\n  rd = normalize (vec3 (uv, 3.));\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.25 * pi, 0.25 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * rd;\n  ro = vuMat * ro;\n  ltDir = normalize (vec3 (0., -0.5, -1.));\n  ltDir = vuMat * ltDir;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 402, 424, 424, 925], [927, 927, 960, 960, 1135], [1137, 1137, 1158, 1158, 1360], [1362, 1362, 1406, 1406, 1910], [1912, 1912, 1946, 1946, 2289], [2291, 2291, 2314, 2314, 2837], [2839, 2839, 2861, 2861, 3029], [3031, 3031, 3066, 3066, 5174], [5176, 5176, 5232, 5232, 6091], [6093, 6093, 6125, 6125, 6225], [6227, 6227, 6260, 6260, 6349], [6351, 6351, 6384, 6384, 6411], [6445, 6445, 6469, 6469, 6529], [6531, 6531, 6555, 6555, 6685], [6687, 6687, 6712, 6712, 6898], [6900, 6900, 6921, 6921, 7076], [7078, 7078, 7107, 7107, 7319], [7321, 7321, 7360, 7360, 7544]], "test": "untested"}
{"id": "XtByRt", "name": "Pulse Color Waves", "author": "CoyHot", "description": "Playing with sinus and color", "tags": ["procedural", "2d"], "likes": 6, "viewed": 138, "published": "Public", "date": "1509650517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t--------------------------------\n\tAfter Effects / Pulse Effect\n\t--------------------------------\n\tFrancois 'CoyHot' Grassard - 2017\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n\tuv.y /= sin(((uv.x+iTime)*10.0)*0.5);\n\n\tvec4 p1 = vec4(0.0);\n \n\tp1.x = ((cos((uv.x+iTime/10.)*50.)/(uv.y*sin(iTime))/25.)*(sin((uv.x+iTime/10.)*50.)/uv.y*cos(iTime*7.)/25.));\n\tp1.y = ((cos((uv.x+iTime/9.)*50.)/(uv.y*sin(iTime))/20.)*(sin((uv.x+iTime/11.)*50.)/uv.y*cos(iTime*6.)/25.));\n\tp1.z = ((cos((uv.x+iTime/8.)*50.)/(uv.y*sin(iTime))/15.)*(sin((uv.x+iTime/12.)*50.)/uv.y*cos(iTime*5.)/25.));\n    \n\tfragColor = p1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 140, 197, 197, 725]], "test": "untested"}
{"id": "XtfBW7", "name": "globe (113 chars)", "author": "FabriceNeyret2", "description": "inspired by [url]https://www.shadertoy.com/view/XstXzs[/url]\nand [url]https://www.shadertoy.com/view/XsdXRl[/url]", "tags": ["short", "onetweet", "golf", "nan"], "likes": 4, "viewed": 434, "published": "Public API", "date": "1511996637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 u) {\n \tvec2 R = iResolution.xy,\n         U = 1.3*(u+u-R)/R.y;\n    O.rg = .02 / fract( 2.* acos( U / cos(  asin(U.yx) )) - iTime ) + .3; }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 169]], "test": "untested"}
{"id": "XtfBz4", "name": "Lightweight Lighthouse", "author": "dr2", "description": " Cannot hope to compete with the Canaletto-like detail and Turner-like atmospherics of the\n much-missed \"Tower of Light\" shader, hopefully soon to return, but here is a quick mashup based\n on stuff from some earlier shaders (mouseable).\n", "tags": ["voronoi", "raymarch", "ocean", "rocks", "architecture"], "likes": 14, "viewed": 1874, "published": "Public API", "date": "1511108659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Lightweight Lighthouse\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat dstFar, tCur, tWav, tCloud, bmAng, bmHt, twBase, twRad;\nint idObj;\nconst int idTwr = 1, idWfrm = 2, idTtop = 3, idFlr = 4, idLmp = 5, idBm = 6, idGrnd = 7;\nconst float pi = 3.14159;\n\n#define TOWER_DIAM  (twRad - (0.05 + 0.25 * (step (q.y, - twBase))) * (q.y + twBase))\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  vec3 q;\n  float dMin, d, a, r, h, db, dw, ww;\n  dMin = dstFar;\n  q = p;  q.y -= twBase + 4.;\n  r = TOWER_DIAM;\n  d = PrCylAnDf (q.xzy, r, 0.2, 8.);\n  dw = PrCylAnDf (q.xzy, r + 0.1, 0.3, 8.);\n  db = 6. - abs (q.y - 2.);\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (5. * a / (2. * pi) + 0.5) / 5.));\n  q.y = mod (q.y + 1.2, 3.) - 1.5;\n  ww = 0.5;\n  d = 0.9 * max (d, - max (min (PrBox2Df (q.zy, vec2 (ww)), length (vec2 (q.z, q.y - ww)) - ww), - db));\n  if (d < dMin) { dMin = d;  idObj = idTwr; }\n  dw = 0.9 * max (dw, max (- db, max (min (PrBox2Df (q.zy, vec2 (ww + 0.05)),\n     length (vec2 (q.z, q.y - ww - 0.05)) - ww - 0.05), - min (PrBox2Df (q.zy, vec2 (ww - 0.05)),\n     length (vec2 (q.z, q.y - ww + 0.05)) - ww + 0.05))));\n  if (dw < dMin) { dMin = dw;  idObj = idWfrm; }\n  q.y = mod (p.y - 5.5, 3.) - 1.5;\n  d = max (PrCylDf (q.xzy, twRad - 0.4, 0.05), - db);\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  q = p;  q.y -= bmHt;\n  d = PrCylAnDf (q.xzy, twRad - 0.5, 0.2, 1.);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (20. * a / (2. * pi) + 0.5) / 20.));\n  d = max (d, - PrBox2Df (q.zy, vec2 (0.3, 0.75)));\n  q = p;  q.y = abs (q.y - bmHt) - 1.1;\n  d = min (d, PrCylDf (q.xzy, twRad + 0.1, 0.1));\n  if (d < dMin) { dMin = d;  idObj = idTtop; }\n  q = p;  q.y -= bmHt;\n  q.xz = Rot2D (q.xz, bmAng);\n  d = PrCylAnDf (q, 0.8, 0.03, 0.21);\n  if (d < dMin) { dMin = d;  idObj = idLmp; }\n  d = PrCylDf (q, 0.77, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idBm; }\n  if (PrCylDf ((p + vec3 (0., -2., 0.)).xzy, 10., 2.) < dMin) {\n    vc = HexVor (0.5 * p.xz);\n    h = 1.5 * max (SmoothMin (0.6, SmoothMax (0., vc.x, 0.6), 0.3) *\n       (1. + vc.w) * (1. - dot (vc.yz, vc.yz)), 0.) + 3.;\n    d = 0.5 * (p.y - h * (1. - 0.01 * dot (p.xz, p.xz)));\n    if (d < dMin) { dMin = d;  idObj = idGrnd; }\n  }\n  return dMin;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;  q.y -= 8.;\n  d = PrCylDf (q.xzy, TOWER_DIAM, 8.);\n  q.y -= 9.;\n  d = min (d, PrCylDf (q.xzy, twRad - 0.5, 1.));\n  dMin = min (dMin, d);\n  \n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 TransObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (TransObjDf (p + e.xxx), TransObjDf (p + e.xyy), TransObjDf (p + e.yxy), TransObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, sd, a;\n  rd.y = abs (rd.y);\n  a = atan (rd.x, - rd.z);\n  if (rd.y < 0.02 * Fbm1 (32. * a) + 0.005) {\n     col = mix (0.5 * vec3 (0.4, 0.5, 0.7), vec3 (0.6, 0.4, 0.4),\n        0.5 + 0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) * (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    p = rd * (100. - ro.y) / rd.y;\n    p.xz += tCloud * vec2 (1.);\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    sunCol = vec3 (1., 0.8, 0.7) * pow (sd, 1024.) +\n       vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n       max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 0.5 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nfloat CylHit (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float bmCylRad, bmCylLen, d, a, b, w, srdz;\n  bmCylRad = 0.7;\n  bmCylLen = 50.;\n  ro.y -= bmHt;\n  ro.xz = Rot2D (ro.xz, bmAng);\n  rd.xz = Rot2D (rd.xz, bmAng);\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - bmCylRad * bmCylRad);\n  d = dstFar;\n  if (w > 0. && a > 0.) {\n    d = (- b - sqrt (w)) / a;\n    p = ro + d * rd;\n    if (abs (p.z) > bmCylLen) {\n      srdz = sign (rd.z) * ro.z + bmCylLen;\n      if (srdz < 0.) {\n        d = - srdz / abs (rd.z);\n        if (length (p.xy) > bmCylRad) d = dstFar;\n      } else d = dstFar;\n    }\n  }\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col, roo, rdo, vno, rob, rdb, rg;\n  float dstObj, dstWat, dstTransObj, dCylIn, a;\n  bool watRefl, winRefl, isBm;\n  HexVorInit ();\n  bmHt = 17.;\n  twBase = 4.;\n  twRad = 3.;\n  tWav = 0.2 * tCur;\n  tCloud = -0.05 * tCur;\n  bmAng = -0.5 * tCur;\n  winRefl = false;\n  watRefl = false;\n  isBm = false;\n  dCylIn = CylHit (ro, rd);\n  rob = ro;\n  rdb = rd;\n  dstObj = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstTransObj = TransObjRay (ro, rd);\n  if (dstWat < min (dstObj, dstFar)) {\n    watRefl = true;\n    ro += dstWat * rd;\n    vn = WaveNf (ro, dstWat);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstTransObj < min (dstFar, dstObj)) {\n    ro += rd * dstTransObj;\n    roo = ro;\n    rdo = rd;\n    vno = TransObjNf (ro);\n    winRefl = true;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idTwr) {\n      a = atan (ro.z, - ro.x) / (2. * pi);\n      if (ro.y > twBase) {\n        if (dot (normalize (ro.xz), vn.xz) > 0.9) {\n          col = vec3 (0.9, 0.7, 0.5);\n          col *= 0.5 + 0.5 * Fbm2 (vec2 (32. * a, 4. * ro.y));\n          rg = ShStagGrid (vec2 (a, ro.y + 0.05), vec2 (40., 6.));\n          col *= rg.y;\n          if (rg.x == 0.) {\n            vn.y += rg.z;\n            vn.xz *= sqrt (1. - vn.y * vn.y);\n          } else vn.xz = Rot2D (vn.xz, - rg.x);\n        } else col = vec3 (0.4, 0.3, 0.2);\n        vn = VaryNf (50. * ro, vn, 1.);\n      } else {\n        col = vec3 (1., 0.8, 0.2);\n        col *= 0.7 * (0.5 + 0.5 * Fbm2 (vec2 (64. * a, 4. * ro.y)));\n        vn = VaryNf (10. * ro, vn, 5.);\n      }\n    } else if (idObj == idGrnd) {\n      vc = HexVor (ro.xz);\n      vn = VaryNf (2. * ro, vn, 5.);\n      col = 0.7 * mix (vec3 (1., 0.7, 0.2), vec3 (0.9, 0.8, 0.5),\n         0.5 * Noisefv3 (8. * (1. + vc.w) * ro) + 0.5 * vc.w) * (0.7 + 0.3 * smoothstep (0., 0.4, ro.y));\n    } else if (idObj == idFlr) {\n      col = vec3 (0.5, 0.6, 0.3);\n    } else if (idObj == idWfrm) {\n      col = vec3 (0.6, 0.5, 0.4);\n      vn = VaryNf (50. * ro, vn, 1.);\n    } else if (idObj == idTtop) {\n      col = vec3 (0.8, 0.7, 0.6);\n      vn = VaryNf (50. * ro, vn, 1.);\n    } else if (idObj == idLmp) {\n      col = vec3 (0.5, 0.5, 0.6);\n    } else if (idObj == idBm) {\n      isBm = true;\n      col = vec3 (1., 1., 0.8) * abs (dot (rd, vn));\n    }\n    if (! isBm) {\n      col = col * (0.2 + 0.1 * max (dot (- normalize (sunDir.xz), normalize (vn.xz)), 0.) +\n         0.8 * max (dot (sunDir, vn), 0.)) + 0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n         if (winRefl) col = mix (col, 0.8 * BgCol (roo, reflect (rdo, vno)), smoothstep (0.5, 0.95,\n            1. - pow (abs (dot (- rdo, vno)), 5.)));\n    }\n  } else if (rd.y < 0.) {\n    watRefl = true;\n    dstWat = - ro.y / rd.y;\n    ro += dstWat * rd;\n    col = BgCol (ro, reflect (rd, WaveNf (ro, dstWat)));\n  } else col = BgCol (ro, rd);\n  if (watRefl) col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0., 0.05, 0.05),\n     smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.8 * col, 1. - pow (abs (rd.y), 4.));\n  if (dCylIn < min (dstObj, dstFar)) col = mix (col, vec3 (1., 1., 0.5),\n     0.3 * (1. - smoothstep (10., 45., length (rob + rdb * dCylIn - vec3 (0., 17., 0.)))));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 100.;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az -= 2.5 * pi * sin (0.003 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 5. - cos (2. * az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 7., -70.);\n  sunDir = normalize (vec3 (-1., 0.15, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfBz4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 896, 918, 918, 2791], [2793, 2793, 2820, 2820, 3030], [3032, 3032, 3065, 3065, 3242], [3244, 3244, 3282, 3282, 3463], [3465, 3465, 3486, 3486, 3688], [3690, 3690, 3716, 3716, 3938], [3940, 3940, 3971, 3971, 5295], [5297, 5297, 5331, 5331, 5685], [5687, 5687, 5710, 5710, 6233], [6235, 6235, 6266, 6266, 6470], [6472, 6472, 6505, 6505, 7113], [7115, 7115, 7150, 7150, 10463], [10465, 10465, 10521, 10521, 11402], [11404, 11404, 11437, 11437, 11526], [11528, 11528, 11570, 11570, 11621], [11623, 11623, 11676, 11676, 11737], [11787, 11787, 11811, 11811, 12041], [12043, 12043, 12067, 12067, 12127], [12129, 12129, 12149, 12149, 12369], [12371, 12371, 12393, 12393, 12989], [12991, 12991, 13036, 13036, 13139], [13141, 13141, 13186, 13186, 13224], [13226, 13226, 13256, 13256, 13314], [13348, 13348, 13372, 13372, 13432], [13434, 13434, 13458, 13458, 13511], [13513, 13513, 13537, 13537, 13667], [13669, 13669, 13693, 13693, 13913], [13915, 13915, 13940, 13940, 14086], [14088, 14088, 14113, 14113, 14299], [14301, 14301, 14326, 14326, 14551], [14553, 14553, 14575, 14575, 14729], [14731, 14731, 14752, 14752, 14907], [14909, 14909, 14938, 14938, 15154], [15156, 15156, 15195, 15195, 15375]], "test": "untested"}
{"id": "XtffDM", "name": "Immulsion Field", "author": "tsuhre", "description": "A simple wave/noise effect produced by taking emphasizing the midpoint of moving 3d noise", "tags": ["noise", "wave", "water", "fluid", "effect"], "likes": 11, "viewed": 310, "published": "Public", "date": "1511993695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = .2;\n    float rate = 5.0;\n    \n    float t = iTime/rate;\n    \n    float result = 0.0;\n    float result2 = 0.0;\n    float result3 = 0.0;\n    \n    //octaves\n    for (float i = 0.0; i < 1.0; i++){\n    \tresult += snoise(vec3((uv.x*2.0)/scale, (uv.y)/scale, t*2.0))/pow(2.0, i);\n        result2 += snoise(vec3((uv.x*4.0)/scale, (uv.y*2.0)/scale, t*2.0))/pow(2.0, i);\n        result3 += snoise(vec3((uv.x*8.0)/scale, (uv.y*4.0)/scale, t*2.0))/pow(2.0, i);\n        scale /= 2.0;\n    }\n    \n    //tweaking\n    result /= 2.0;\n    result = abs(result);\n    result = pow(result, .4);\n    result = 1.0 - result;\n    if (result < .8) result = pow(result, 4.0);\n    \n    result2 /= 2.0;\n    result2 = abs(result2);\n    result2 = pow(result2, .6);\n    result2 = 1.0 - result2;\n    if (result2 < .8) result2 = pow(result2, 4.0);\n    \n    result3 /= 2.0;\n    result3 = abs(result3);\n    result3 = pow(result3, .4);\n    result3 = 1.0 - result3;\n    if (result3 < .8) result3 = pow(result3, 4.0);\n    \n    result *= 2.0;\n    //result2 *= 2.0;\n    result3 *= 2.0;\n    \n    //power for coloring\n    float g = pow(result, 4.0);\n    float g2 = pow(result2, 4.0);\n    \n    fragColor = vec4(max(max(g2, result3), g), max(max(result3, 0.0), result), max(max(result, result2), 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtffDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2106, 2106, 3430]], "test": "untested"}
{"id": "XtjcDd", "name": "preAlpha Vector Field v:0.0.6", "author": "Chris_M_Thomasson", "description": "This experiment plays around with adding some Mandelbrot iterations before I iterate the actual vector field. There is press-and-drag capability. Check out the CT_N macro. It defines the n in n-ary of the field... Set at 14 here. Does it work for you?\n", "tags": ["2d", "fractal", "math", "space", "field", "dynamics", "vector", "art", "trigonometry"], "likes": 4, "viewed": 192, "published": "Public", "date": "1510624563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nPre-Alpha Vector Field by Chris M. Thomasson ver:0.0.6\nWith Mandelbrot Mutation\nThe code is basic, and the math can be streamlined.\nThis is a basic experiment, not thinking of sheer performance yet.\n\nCreate an attractor by clicking and dragging it around.\n\nThis has an experimental field line isolation method.\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 14\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    float eps = 0.00001;\n    vec2 g = vec2(eps, eps);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        if (mass == 0.0) mass = 0.00001;\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    float s = 1.0;\n    float t = iTime * .1;\n    vec2 jc = vec2(-.75 + abs(cos(t)) * 0.5, abs(sin(t)) * .5);\n    \n    // Augment z with some Mandelbrot iterations\n    for (int i = 0; i < 4; ++i)\n    {\n        z = ct_cmul(z, z);\n    \tz = z + c;\n    }\n\n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = 0.0;//cos(iTime * .25) * 3.14;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float blah = length(vn);\n    \n    if (blah < .01)\n    {\n        //return vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    float scale = float(CT_N);// + abs(cos(iTime * .5)) * 6.0;\n    \n    float color = mod(npi * scale, 1.0);\n    \n    //if (color < abs(sin(iTime * 5.0) * cos(iTime)) * .2 + .1)\n    if (color < .1)\n    {\n        color = 1.0 - color;\n    }\n    \n    else\n    {\n        color = 0.0;\n    }\n    \n    return vec4(\n        color + (abs(vn.x) * .1),\n        color + (abs(vn.y) * .1),\n        color + (abs(vn.x * vn.y) * .1),\n        1.0\n    );\n}\n\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    const int n = CT_N;\n    float scale = 1.0;\n    \n    float r = .5 + abs(sin(iTime * .5)) * 1.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28 + cos(iTime * .1) * 5.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle) * r, sin(angle) * r), \n            -1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cm = ct_plane2d_project(plane, vec2(iMouse));\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            1.6\n        );\n    }\n    \n    return ct_vpixel(c, c, 128, 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        -.5, \n        0.0, \n        1.3 //+ cos(iTime * .5) * abs(sin(iTime * .5))\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 520, 572, 572, 732], [735, 839, 891, 891, 1580], [1583, 1583, 1645, 1645, 1753], [1891, 1954, 2009, 2009, 2458], [2461, 2461, 2514, 2514, 2616], [2619, 2619, 2657, 2657, 2730], [2733, 2759, 2839, 2839, 3889], [3892, 3912, 3967, 3967, 4570], [4573, 4587, 4648, 4648, 4998]], "test": "untested"}
{"id": "XtjcW3", "name": "Starfield DOTs II", "author": "patu", "description": "upgrade of my https://www.shadertoy.com/view/XdlfRs", "tags": ["2d", "starfield", "hash", "dot"], "likes": 29, "viewed": 4245, "published": "Public API", "date": "1510364554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n \n\n\n*/\n\n\n// speed\n#define t (iTime * .6) \n\n// PI value\n#define PI 3.14159265\n\n// random\n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\n\n// rotate \n#define pR(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    vec2 uv = (fragCoord - .5 * iResolution.xy - .5) / iResolution.y;\n\n    uv *= 2.4; // FOV\n    \n    // camera\n    vec3 \n        vuv = vec3(sin(iTime * .3), 1., cos(iTime)), // up\n        ro = vec3(0., 0., 134.), // pos\n        vrp = vec3(5., sin(iTime) * 60., 20.); // look at\n    \n    vrp.xz * pR(iTime);\n    vrp.yz * pR(iTime * .2);\n    \n    vec3\n    \tvpn = normalize(vrp - ro),\n        u = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u  + uv.y * cross(vpn, u)\n        ); // ray direction\n    \n    vec3 sceneColor = vec3(0.0, 0., 0.3); // background color\n    \n    vec3 flareCol = vec3(0.); // flare color accumulator   \n    float flareIntensivity = 0.; // flare intensity accumulator\n\n    for (float k = 0.; k < 400.; k++) {\n        float r = H(vec2(k)) * 2. - 1.; // random\n\n        // 3d flare position, xyz\n        vec3 flarePos =  vec3(\n            H(vec2(k) * r) * 20. - 10.,\n            r * 8.,\n            (mod(sin(k / 200. * PI * 4.) * 15. - t * 13. * k * .007, 25.))\n        );\n\t\t\n        float v = max(0., abs(dot(normalize(flarePos), rd)));\n        \n        // main dot\n        flareIntensivity += pow(v, 30000.) * 4.;\n        \n        // dot glow\n        flareIntensivity += pow(v, 1e2) * .15; \n        \n        // fade far\n        flareIntensivity *= 1.- flarePos.z / 25.; \n        \n        // accumulate\n        flareCol += vec3(flareIntensivity) * (vec3(sin(r * 3.12 - k), r, cos(k) * 2.)) * .3; \n    }\n    \n    sceneColor += abs(flareCol);\n    \n    // go grayscale from screen center\n    sceneColor = mix(sceneColor, sceneColor.rrr * 1.4, length(uv) / 2.);\n    \n    // adjust contrast\n    fragColor.rgb = pow(sceneColor, vec3(1.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 249, 304, 304, 1993]], "test": "untested"}
{"id": "XtjyDK", "name": "Hypnotic Waves", "author": "AzazelN28", "description": "Hypnotic waves fx", "tags": ["2d", "waves"], "likes": 1, "viewed": 77, "published": "Public", "date": "1510144940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(0.5,0.5);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float d = distance(uv, center);\n\tfragColor = vec4(sin((iTime * 10.0) - d * PI * 64.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 249]], "test": "untested"}
{"id": "XtlBW4", "name": "algebraic curves", "author": "tale3d", "description": "Shape modelling, topic \"Implicit curves and surfaces\", part 1: implicit curves. \nThis example shows a curve defined in an implicit form. In this example you can see defining functions for circle and ellipse. ", "tags": ["curve", "implicit", "algebraic", "teachingmaterial"], "likes": 2, "viewed": 127, "published": "Public", "date": "1511873668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//defining a simple primitive - circle\nfloat circle(in vec2 position, in vec2 centre, in float radius)\n{\n    vec2 pc = position-centre;\n    return pc.x*pc.x + pc.y*pc.y - radius*radius;\n}\n\nfloat ellipse(in vec2 position, in vec2 centre, in float radius1, in float radius2)\n{\n    vec2 pc = position-centre;\n    return (pc.x*pc.x)/(radius1*radius1) + (pc.y*pc.y)/(radius2*radius2) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //taking fragment coordinates, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    //map fragment coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n\n    \n\t//time mapped to [0.5,1.5]- not used at the moment\n\tfloat time = 0.5+0.5*abs(sin(iTime));\n\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    \n    //setup parameters of the shape\n    vec2 circle_centre = vec2(0,0); //centre of the circle\n    float radius = time; //radius of the circle, note it is dynamic depending on time parameter\n\n    vec3 colour = vec3(1.0, 1.0, 1.0); //background colour\n\n    //find the function for circle\n    float function_value = circle(c, circle_centre, radius); \n    //the function for the implicit curve is 0 on the surface, here we are drawing points which are \"close\" to 0\n    float thickness = 0.01; //note that thickness is not in geometric sense, but in the function value\n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,0.0); //circle is drawn in black\n    \n    //repeat for ellipse\n    function_value = ellipse(c, circle_centre, 2.0-time, time); \n    if (abs(function_value) < thickness) colour = vec3(0.0,0.0,1.0); //ellipse is drawn in blue\n    \n\tfragColor = vec4(colour,1.0); //set the colour of the fragment\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 104, 104, 187], [189, 189, 274, 274, 387], [389, 389, 446, 493, 1758]], "test": "untested"}
{"id": "XtlfDn", "name": "Cloud Flight", "author": "Shane", "description": "Moving a camera through a cloud scene. It's rendered in a surreal, stylized fashion, and utilizes a relatively cheap construction process.", "tags": ["raymarching", "noise", "volume", "clouds", "camera", "sky"], "likes": 73, "viewed": 4514, "published": "Public API", "date": "1511782748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tCloud Flight\n\t------------\n\n\tYet another cloud shader. :) However, just to be a little different, this particular one\n\ttakes the camera through the clouds - as opposed to over or under. The scene is supposed \n\tto look a little artificial or cartoony, so I wouldn't take it too seriously. :)\n\n\tThere are plenty of realistic cloud shaders on Shadertoy, so I thought I'd do a stylized\n\tversion. Plus, I had to cheap out on everything, so realism wasn't exactly an option. :)\n\tThe colors and contrast have deliberately been exaggerated to give it more of a surreal \n\tfeel. The ramped up contrast also serves to allow the viewer to more easily discern the \n\tindividual cloud shapes. \n\n\tIn case anyone was wondering, the cloud shapes were emphasized by assigning a much higher \n\tweighting to the larger low frequency base layers. Giving the clouds a denser look was a \n\tstyle choice, but it's possible to make them fluffier and more traditional looking with \n\ta few tweaks here and there.\n\n\tOne of the things you figure out pretty quickly when doing this kind of thing is that when \n\tyou don't have enough iterations to work with, fake physics tend to work better than real\n\tphysics. For real shadows, you need to traverse toward the light several times. In this \n\texample, you're doing so just once, which is bordering on pathetic. :) Therefore, it's \n\tnecessary to darken the one-tap shadow value to give the impression that more shadowing \n\tis happening. However, you'll never produce a real shadow cast, no matter how hard you try.\n\n\tIt'd be nice to put up an example with volumetric shadowing, etc, but I don't think the\n\taverage GPU is quite fast enough yet. Having said that, I might see what I can come up\n\twith.\n\t\n\tBased on:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n\t// One of my favorite volumetric examples. This one has shadowing. So nice. Fast, all\n\t// things considered, but still requires a fast machine to run it properly.\n\tVolumetric Stanford Bunny - SebH\n\thttps://www.shadertoy.com/view/MdlyDs\n\n*/\n\n#define FAR 60.\n\n\n// A between cloud layers look, between the individual clouds, a more conventional fluffy cloud look,\n// or right through them. I prefer the latter arrangement, but it doesn't give a clear enough view.\n#define ARRANGEMENT 0 // 0, 1, 2 or 3: Layered, path (tunnel in disguise), fluffy layered, just cloud.\n\n// Standard 2D rotation formula - See Nimitz's comment.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Hash function. This particular one probably doesn't disperse things quite \n// as nicely as some of the others around, but it's compact, and seems to work.\n//\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat n3D( in vec3 p ){\n    \n    //return texture(iChannel1, p/24., 0.25).x;\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n/*\n// Textureless 3D Value Noise:\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value noise.\n//\n// By the way, a few people have managed to reduce the original down to this state, \n// but I haven't come across any who have taken it further. If you know of any, I'd\n// love to hear about it.\n//\n// I've tried to come up with some clever way to improve the randomization line\n// (h = mix(fract...), but so far, nothing's come to mind.\nfloat n3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*p*(p*(p * 6. - 15.) + 10.);\n    \n    // Even smoother, but this would have to be slower, surely?\n\t//vec3 p3 = p*p*p; p = ( 7. + ( p3 - 7. ) * p ) * p3;\t\n\t\n    // Cosinusoidal smoothing. OK, but I prefer other methods.\n    //p = .5 - .5*cos(p*3.14159);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n*/\n\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Straight path.\n    return vec2(sin(z*.075)*8., cos(z*.1)*.75*2.); // Windy path.\n    \n}\n\n// Distance function. Just some layered noise, and depending on the arrangement, some shapes\n// smoothy carved out.\nfloat map(vec3 p) {\n    \n    // Time factor.\n    vec3 t = vec3(1, .5, .25)*iTime;\n\n    \n    // Two base layers of low fregency noise to shape the clouds. It's been contracted in the Y\n    // direction, since a lot clouds seem to look that way.\n    float mainLayer = n3D(p*vec3(.4, 1, .4))*.66 + n3D(p*vec3(.4, 1, .4)*2.*.8)*.34 - .0;    \n    \n    // Three layers of higher frequency noise to add detail.\n    float detailLayer = n3D(p*3. + t)*.57 +  n3D(p*6.015 + t*2.)*.28 +  n3D(p*12.01 + t*4.)*.15 - .0;\n    // Two layers, if you're computer can't handle three.\n\t//float detailLayer = n3D(p*3. + t)*.8 +  n3D(p*12. + t*4.)*.2;\n\n    // Higher weighting is given to the base layers than the detailed ones.\n    float clouds = mainLayer*.84 + detailLayer*.16;\n    \n    \n    #if (ARRANGEMENT != 3)\n    // Mapping the hole or plane around the path.\n    p.xy -= path(p.z);\n    #endif\n    \n    \n    // Between cloud layers.\n    #if (ARRANGEMENT == 0) // Layered.\n    //return smax(tn, -abs(p.y) + 1.1 + (clouds - .5), .5) + (clouds - .5);\n    return smax(clouds, -length(p.xy*vec2(1./32., 1.)) + 1.1 + (clouds - .5), .5) + (clouds - .5);\n    #elif (ARRANGEMENT == 1) // Path - Tunnel in disguise.\n    // Mapping the hole around the path.\n    return smax((clouds - .25)*2., -smax(abs(p.x) - .5, abs(p.y) - .5, 1.), 2.);\n    #elif (ARRANGEMENT == 2) // Path - Tunnel in disguise.\n    // Between layers, but with fluffier clouds.\n    return smax(clouds - .075, -length(p.xy*vec2(1./32., 1.)) + 1.1 + (clouds - .5), .5) + (clouds - .5)*.35;\n    #else // The clouds only.\n    return (clouds - .25)*2.; \n    //return tn; // Fluffier, but blurrier.\n    #endif\n   \n   \n\n\n}\n\n\n// Less accurate 4 tap (3 extra taps, in this case) normal calculation. Good enough for this example.\nvec3 fNorm(in vec3 p, float d){\n    \n    // Note the large sampling distance.\n    vec2 e = vec2(.075, 0); \n\n    // Return the normal.\n    return normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy), d - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Subtle pixel blur.\n    //vec2 hv = mod(fragCoord, 2.);\n    //uv += (1. - step(hv, vec2(1))*2.)*1./iResolution.y;\n\n\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n \t\n    \t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.75; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.15));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/16.);\n    \n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Anyway, the hash below is used to\n    // at jitter to the jump off point (ray origin).\n    //    \n    // It's also used for some color based jittering inside the loop.\n    vec3 rnd = hash33(rd.yzx + fract(iTime));\n\n    // Local density, total density, and weighting factor.\n    float lDen = 0., td = 0., w = 0.;\n\n    // Closest surface distance, a second sample distance variable, and total ray distance \n    // travelled. Note the comparitively large jitter offset. Unfortunately, due to cost \n    // cutting (64 largish steps, it was  necessary to get rid of banding.\n    float d = 1., d2 = 0., t = dot(rnd, vec3(.333));\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n    \n    // Directional light. Don't quote me on it, but I think directional derivative lighting\n    // only works with unidirectional light... Thankfully, the light source is the cun which \n    // tends to be unidirectional anyway.\n    vec3 ld = normalize(vec3(-.2, .3, .8));\n    \n    \n    // Using the light position to produce a blueish sky and sun. Pretty standard.\n    vec3 sky = mix(vec3(1, 1, .9), vec3(.19, .35, .56), rd.y*0.5 + 0.5);\n    //sky = mix(sky, mix(vec3(1, .8, .7), vec3(.31, .52, .73), rd.y*0.5 + 0.5), .5);\n    \n    \n    // Sun position in the sky - Note that the sun has been cheated down a little lower for \n    // aesthetic purposes. All this is fake anyway.\n    vec3 fakeLd = normalize(vec3(-.2, .3, .8*1.5));\n    float sun = clamp(dot(fakeLd, rd), 0.0, 1.0);\n    \n    \n    \n    // Combining the clouds, sky and sun to produce the final color.\n    sky += vec3(1, .3, .05)*pow(sun, 5.)*.25; \n    sky += vec3(1, .4, .05)*pow(sun, 8.)*.35; \n    sky += vec3(1, .9, .7)*pow(sun, 128.)*.5; \n\n    // Ramping up the sky contrast a bit.\n    sky *= sqrt(sky); \n    \n    // I thought I'd mix in a tiny bit of sky color with the clouds here... It seemed like a\n    // good idea at the time. :)\n    vec3 cloudCol = mix(sky, vec3(1, .9, .8), .66);\n    \n\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n        \n        // Loop break conditions - If the ray hits the surface, the accumulated density maxes out,\n        // or if the total ray distance goes beyong the maximum, break.\n        if(d<.001*(1. + t*.125) || td>1. || t>FAR) break;\n\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        // On a side note, you could wrap the next few lines in an \"if\" statement to save a\n        // few extra \"map\" calls, etc. However, some cards hate branching, nesting, etc, so it\n        // could be a case of diminishing returns... Not sure what the right call is, so I'll \n        // leave it to the experts. :)\n        w = d<h? (1. - td)*(h - d) : 0.;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        //td += w*w*8. + 1./64.; // More transparent looking... kind of.\n        td += w + 1./64.; // Looks cleaner, but a little washed out.\n\n        \n       \n        // Lighting calculations.\n        // Standard diffuse calculation, using a more expensive four tap tetrahedral normal.\n        // However, this will work with point light and enables are normal-based lighting.\n        //float diff = max(dot(ld, fNorm(sp, d)), 0.)*2.;\n        \n        // Directional derivative-based diffuse calculation. Uses only two function taps,\n        // but only works with unidirectional light.\n        d2 = map(sp + ld*.1);\n        // Possibly quicker than the line above, but I feel it overcomplicates things... Maybe. \n        //d2 = d<h? map(sp + ld*.1) : d;\n        float diff = max(d2 - d, 0.)*20.; \n        //float diff = max(d2*d2 - d*d, 0.)*20.; // Slightly softer diffuse effect.\n        \n\n\n        // Accumulating the color. You can do this any way you like.\n        //\n        // Note that \"1. - d2\" is a very lame one-tap shadow value - Basically, you're traversing\n        // toward the light once. It's artificially darkened more by multiplying by \"d,\" etc, which\n        // was made up on the spot. It's not very accurate, but it's better than no shadowing at all.\n        // Also note, that diffuse light gives a shadowy feel, but is not shadowing.\n        col += w*max(d*d*(1. - d2)*3. - .05, 0.)*(diff*cloudCol*2. + vec3(.95, 1, 1.05))*2.5; // Darker, brooding.\n        // Other variations - Tweak them to suit your needs.\n        //col += w*d*(sqrt(diff)*vec3(1, .85, .7)*2. + 2.); // Whiter, softer, fluffier.\n        //col += w*d*((1. - exp(-diff*8.)*1.25)*vec3(1, .85, .7)*2. + 2.);\n        \n       \n        // Optional extra: Color-based jittering. Roughens up the clouds that hit the camera lens.\n        col *= .98 + fract(rnd*289. + t*41.13)*.04;\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t += max(d*.5, .05); //\n        //t += 0.25; // t += d*.5;// These also work - It depends what you're trying to achieve.\n\n    }\n    \n    // Clamp above zero... It might not need it, but just in case.\n    col = max(col, 0.);\n    \n    \n    // Postprocessing the cloud color just to more evenly match the background. Made up.\n    col *= mix(vec3(1), sky, .25);\n\n    \n    // Fogging out the volumetric substance. The fog blend is heavier than usual. It was a style\n    // choice - Not sure if was the right one though. :)\n    col = mix(col, sky, smoothstep(0., .85, t/FAR));\n    col = mix(col, sky*sky*2., 1. - 1./(1.+ t*t*.001));//\n \t//col += vec3(1, .4, .2)*pow(sun, 16.)*.25; \t\n    \n    // More postprocessing. Adding some very subtle fake warm highlights.\n    vec3 fCol = mix(pow(vec3(1.3, 1, 1)*col, vec3(1, 2, 10)), sky, .5);\n    col = mix(fCol, col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.1 + .9);\n    \n    \n    // If it were up to me, I'd be ramping up the contrast, but I figured it might be a little to\n    // broody for some. :)\n    //col *= sqrt(col)*1.5;\n \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .25)*.35 + .65;\n    // Colored variation.\n    col = mix(pow(min(vec3(1.5, 1, 1).zyx*col, 1.), vec3(1, 3, 16)), col, \n              pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5);\n \n    // Done.\n    fragColor = vec4(sqrt(min(col, 1.)), 1.0);\n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2484, 2540, 2560, 2560, 2618], [2620, 2669, 2707, 2707, 2802], [2804, 2965, 2985, 2985, 3089], [3091, 3437, 3460, 3513, 3681], [6110, 6210, 6232, 6274, 6347], [6349, 6465, 6484, 6509, 8123], [8126, 8228, 8259, 8305, 8451], [8453, 8453, 8509, 8542, 16873]], "test": "untested"}
{"id": "Xtlfz8", "name": "HelloCube", "author": "smkgames", "description": "my first cube :D", "tags": ["3d", "raymarching", "simple", "tutorial", "cube"], "likes": 4, "viewed": 491, "published": "Public API", "date": "1510995923", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Seyed Morteza Kamaly - SMK/2017\n\n//I could create this shader by helping this tutorial https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Constants.\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define PI 3.14159265359\n\n\nmat2 rotate(float a) { \n    return mat2( cos(a), sin(a), -sin(a), cos(a) );\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Function of distance.\nfloat map( vec3 p ) {\n    p += vec3(0,-1,0); \n    p.xz *= rotate(iTime); \n    return sdBox(p,vec3(1.1));\n   }\n\n// Gradient (numeric) function of the distance function.\nvec3 grad(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n\n    return vec3(map(p + q.yxx) - map(p - q.yxx),\n                map(p + q.xyx) - map(p - q.xyx),\n                map(p + q.xxy) - map(p - q.xxy));\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n\tvec3 n = normalize(grad(ro + t*rd));\n    return vec3(0.3, 0.8, 0.7)*pow(1.0-dot(-rd, n), 1.5);\n}\n\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Prepare the radius.\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n\n   \n    vec3 ro = vec3(0.0, 1.0, 3.0); // start of the radius.\n    vec3 rd = normalize(vec3(uv, -1.0)); // direction of the radius.\n    \n    // Loop do raymarcher.\n    float t = 0.0, d = EPS;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (d < EPS || t > FAR) break;\n        t += d;\n    }\n\n    // Shading.\n    vec3 col = d < EPS ? shade(ro, rd, t) : vec3(0.3, 0.6, 0.7)*(2.0-length(uv));\n    \n    // Post-processing. \n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtlfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 312, 334, 334, 389], [392, 392, 423, 423, 510], [512, 537, 558, 558, 646], [648, 705, 724, 724, 904], [906, 906, 945, 945, 1043], [1050, 1050, 1107, 1134, 1757]], "test": "untested"}
{"id": "XtlfzN", "name": "Poke-squish", "author": "HephaChronos", "description": "A friend challenges me two make my circle have 1 color on each half", "tags": ["circle"], "likes": 1, "viewed": 94, "published": "Public", "date": "1511198763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 pos, float r){\n\treturn smoothstep(r, r-.01, length(uv -pos) );\n}\n\nfloat band(float uv, float start, float end){\n   return smoothstep(start, start, uv)*(1.-smoothstep(end, end, uv) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    \n    float mask1 = circle(uv, vec2(uv.x*abs(-.7*sin(2.*iTime) ), -abs(.5*sin(2.*iTime) )+.2 ), .2);\n    float rect = band(uv.x, -1., 1.) * band(uv.y, -abs(.5*sin(2.*iTime) )+.2, 1.);\n    mask1 *= 1.-rect;\n    \n    float mask2 = circle(uv, vec2(uv.x*abs(-.7*sin(2.*iTime) ), -abs(.5*sin(2.*iTime) )+.2 ), .2);\n    rect = 1.0-band(uv.x, -1., 1.) * band(uv.y, -abs(.5*sin(2.*iTime) )+.2, 1.);\n    mask2 *= 1.-rect;\n    \n    vec3 c1 = vec3(1., 0., 0.) * mask2;\n    vec3 c2 = vec3(1., 1., 1.) * mask1;\n    \n    vec3 c = c1 + c2;\n\tfragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 91], [93, 93, 138, 138, 211], [213, 213, 270, 270, 939]], "test": "untested"}
{"id": "XtsBWN", "name": "Ocean? Electric Fog Maybe", "author": "tsuhre", "description": "another take on the slices of 3d noise effect", "tags": ["noise", "ocean", "fog", "simplex"], "likes": 16, "viewed": 356, "published": "Public", "date": "1511915726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = .2;\n    float rate = 5.0;\n    \n    float t = iTime/rate;\n    \n    float result = 0.0;\n    \n    //octaves\n    for (float i = 0.0; i < 5.0; i++){\n    \tresult += snoise(vec3((uv.x*2.0)/scale, (uv.y)/scale, t*2.0))/pow(2.0, i);\n        scale /= 2.0;\n    }\n    result = (result + 1.0)/4.0;\n    result += .5;\n    \n    result = pow(result, 2.0);\n    \n    \n    //powers for steeper curves\n    //float p1 = pow(fragCoord.y/iResolution.y, 1.7);\n    //float p2 = 8.0*(1.0 - p1);\n    //result = pow(result, 8.0 - p2);\n    \n    //power for coloring\n    float g = pow(result, 4.0);\n    fragColor = vec4(0, g, result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2106, 2106, 2777]], "test": "untested"}
{"id": "XtsfDH", "name": "Quartic roots", "author": "dahart", "description": "Just for fun & to get a feel for how bad it is, this is an attempt to use the analytic quartic formula for ray tracing quadratic curves. And... it's pretty bad. :) All the fuzzy dots are false hits due to numeric instability.", "tags": ["bezier", "quadratic", "quartic", "roots"], "likes": 1, "viewed": 126, "published": "Public", "date": "1511805475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float tau = 6.28318;\nconst float inf = 99999.0;\n\nconst bool curves = true;\nconst bool spheres = true;\n\nconst int curveLen = 15;\nvec3 pts[curveLen];\n\nfloat solveQuadratic(float a, float b, float c) \n{ \n    float x0, x1;\n    float discr = b * b - 4.0 * a * c; \n    if (discr < 0.0) return inf; \n    else if (discr == 0.0) x0 = x1 = - 0.5 * b / a; \n    else { \n        float q = (b > 0.0) ? \n            -0.5 * (b + sqrt(discr)) : \n            -0.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n    return (x0 >= 0.0 && x0 < x1) ? x0 : ((x1 >= 0.0) ? x1 : inf);\n}\n\nfloat sphereHit(vec3 sc, float sr, vec3 ro, vec3 rd) {\n    \n    float a = dot(rd, rd);\n    vec3 L = ro - sc;\n    float b = 2.0 * dot(rd, L);\n    //float c = dot(ro, ro) - 2.0 * dot(sc, ro) + dot(sc, sc) - sr * sr;\n    float c = dot(L, L) - sr * sr;\n    //return solveQuadratic(a, b, c);\n    float discrim = b*b - 4.0*a*c;\n\n    if (discrim < 0.0) return inf;\n    //return min(-b-sqrt(discrim)\n    return (-b - sqrt(discrim)) / (2.0 * a);\n}\n\nvec3 sphereNormal(vec3 sc, float sr, vec3 p) {\n    return normalize(p - sc);\n}\n\n\n// https://www.gamedev.net/forums/topic/451048-best-way-of-solving-a-polynomial-of-the-fourth-degree/\n//----------------------------------------------------------------------------\n// bool solveQuartic(double &a, double &b, double &c, double &d, double &e, double &root)\n// {\n//     // When a or (a and b) are magnitudes of order smaller than C,D,E\n//     // just ignore them entirely. \n//     if(a == 0.0 || abs(a/b) < 1.0e-6 || abs(a/c) < 1.0e-6)\n//         return solveCubic(b, c, d, e, root);\n\n//     // Uses Ferrari's Method\n//     double aa = a*a, aaa=aa*a, bb=b*b, bbb=bb*b;\n//     double alpha = -3.0*bb/(8.0*aa)   + c/a, alpha2 = alpha * alpha;\n//     double beta  =    bbb/(8.0*aaa) + b*c/(-2.0*aa) + d/a;\n//     double gamma = -3.0*bbb*b/(256.0*aaa*a) + c*bb/(16.0*aaa) + b*d/(-4.0*aa) + e/a;\n\n//     if(beta == 0.0)\n//     {\n//         root = b/(-4.0*a) + sqrt(0.5 * (-alpha + sqrt(alpha2 + 4.0*gamma)));\n//         return true;\n//     }\n//     else\n//     {\n//         std::complex<double> P = -alpha2/12.0 - gamma;\n//         std::complex<double> Q = -alpha2*alpha/108.0 + alpha*gamma/3.0 - beta*beta/8.0;\n//         std::complex<double> R = Q*0.5 + sqrt(Q*Q*0.25 + P*P*P/27.0);\n//         std::complex<double> U = pow(R, 1.0/3.0);\n//         std::complex<double> y = -5.0*alpha/6.0 - U;\n//         if(U != 0.0) y += P/(3.0*U);\n//         std::complex<double> W = sqrt(alpha + y + y);\n\n//         std::complex<double> aRoot;\n//         bool foundRealRoot = false;\n\n//         double firstPart = b/(-4.0*a);\n//         std::complex<double> secondPart = -3.0*alpha - 2.0*y;\n//         std::complex<double> thirdPart = 2.0*beta/W;\n\n//         aRoot = firstPart + 0.5 * (-W - sqrt(secondPart + thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0) \n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (-W + sqrt(secondPart + thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (W - sqrt(secondPart - thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         aRoot = firstPart + 0.5 * (W + sqrt(secondPart - thirdPart));\n//         if(abs(aRoot.imag()) < 1.0e-10 && aRoot.real() >= 0.0 &&\n//              (!foundRealRoot || aRoot.real() < root))\n//         {\n//             root = aRoot.real();\n//             foundRealRoot = true;\n//         }\n\n//         return foundRealRoot;\n//     }\n// }\n\n\n\nfloat qbHit(vec3 A3, vec3 B3, vec3 C3, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n    float drd = dot(rd, cam[2]);\n\n    vec3 Aro = A3 - ro;\n    float dA3 = dot(Aro, cam[2]);\n    float nrdA = dA3 / drd;    \n    vec3 At = A3 - rd * nrdA;\n    vec2 A = vec2(dot(At, cam[0]), dot(At, cam[1]));\n    \n    vec3 Bro = B3 - ro;\n    float dB3 = dot(Bro, cam[2]);\n    float nrdB = dB3 / drd;    \n    vec3 Bt = B3 - rd * nrdB;\n    vec2 B = vec2(dot(Bt, cam[0]), dot(Bt, cam[1]));\n    \n    vec3 Cro = C3 - ro;\n    float dC3 = dot(Cro, cam[2]);\n    float nrdC = dC3 / drd;    \n    vec3 Ct = C3 - rd * nrdC;\n    vec2 C = vec2(dot(Ct, cam[0]), dot(Ct, cam[1]));\n    \n#if 0\n    // debug draw the control points\n    if (length(A) < 1.5*r) return 0.0;\n    if (length(B) < 1.5*r) return 0.0;\n    if (length(C) < 1.5*r) return 0.0;\n#endif\n    \n#if 0\n    // This section is attempting to normalize all coords, to improve numeric stability\n    // It didn't work\n    \n    vec2 cpRoMin = min(min(A, B), C);\n    vec2 cpRoMax = max(max(A, B), C);\n    vec2 cpWidth = cpRoMax - cpRoMin;\n    float oneOverMaxWidth = 1.0 / max(cpWidth.x, cpWidth.y);\n    //oneOverMaxWidth *= 0.001;\n    \n    A *= oneOverMaxWidth;\n    B *= oneOverMaxWidth;\n    C *= oneOverMaxWidth;\n    r *= oneOverMaxWidth;\n#endif\n            \n#if 0\n    // This section is debug-drawing a sampled version of the curve\n    \n    for (float u = 0.0; u <= 1.0; u += r/2.0) {\n        float iu = 1.0 - u;\n\n        //vec3 x3 = iu*iu*A3 + u*iu*B3 + u*u*C3;\n        //if (dot(normalize(x3-ro), rd) > 0.9999) return 0.0;\n        \n        vec2 x = iu*iu*A + 2.0*u*iu*B + u*u*C;\n        if (length(x) < r) return 0.0;\n    }\n\n    return inf;\n#endif\n    \n    vec2 f = A + C - B;\n    vec2 g = B - 2.0 * A;\n    vec2 h = A;\n    \n    float a = dot(f, f);\n    float b = 2.0 * dot(f, g);\n    float c = 2.0 * dot(f, h) + dot(g, g);\n    float d = 2.0 * dot(g, h);\n    float e = dot(h, h) - r * r;\n    \n    float a2 = a * a;\n    float b2 = b * b;\n    float c2 = c * c;\n    float d2 = d * d;\n    float e2 = e * e;\n    \n#if 1\n    // This is the naive straightfoward computation of the discriminant\n    // this is numerically unstable, especially when tracing at angles\n    // near the plane of the curve\n    \n    float delta = \n        256.0 * a*a2 * e*e2 \n        - 192.0 * a2 * b * d * e2 \n        - 128.0 * a2 * c2 * e2\n        + 144.0 * a2 * c * d2 * e \n        - 27.0 * a2 * d2*d2\n        + 144.0 * a * b2 * c * e2\n        - 6.0 * a * b2 * d2 * e\n        - 80.0 * a * b * c2 * d * e\n        + 18.0 * a * b * c * d*d2\n    \t+ 16.0 * a * c2*c2 * e\n        - 4.0 * a * c*c2 * d2\n    \t- 27.0 * b2*b2 * e2\n    \t+ 18.0 * b*b2 * c * d * e\n        - 4.0 * b*b2 * d*d2\n    \t- 4.0 * b2 * c*c2 * e\n        + b2 * c2 * d2;\n#endif\n    \n#if 0\n    // this section is attempting to factor common parts of the expression\n    // to improve numeric stability\n    // It didn't work\n    \n    float delta = \n        \n        a2 * (\n            e2 * (\n                256.0 * a * e \n                - 192.0 * b * d \n                - 128.0 * c2\n            )\n        \t+ d2 * (\n                144.0 * c * e \n        \t\t- 27.0 * d2\n            )\n        )\n        \n        + a * (\n            6.0 * b2 * (\n                24.0 * c * e2\n        \t\t- d2 * e\n            )\n        \t+ 18.0 * b * c * d*d2\n    \t\t+ 4.0 * c2 * (\n                4.0 * c2 * e\n        \t\t- c * d2\n        \t\t- 20.0 * b * d * e // out of order\n            )\n        )\n        \n    \t+ b2 * (\n            b * (\n                -27.0 * b * e2\n                + 18.0 * c * d * e\n                - 4.0 * d*d2\n            )\n    \t\t- 4.0 * c*c2 * e\n        \t+ (c2 * d2)\n        );\n#endif    \n    \n    float P = 8.0 * a * c - 3.0 * b2;\n    float R = b*b2 + 8.0 * d * a2 - 4.0 * a * b * c;\n    float d0 = c2 - 3.0*b*d + 12.0*a*e;\n    float D = 64.0*a*a2*e - 16.0*a2*c2 + 16.0*a*b2*c - 16.0*a2*b*d - 3.0*b2*b2;\n    float d1 = 2.0 * c*c2 - 9.0*b*c*d + 27.0*b2*e + 27.0*a*d2*d2 - 72.0*a*c*e;\n\n    float p = P / (8.0 * a2);\n    float q = R / (8.0 * a*a2);\n    //float Q = pow(0.5 * (d1 + sqrt(d1*d1 - 4.0*d0*d0*d0)), 1.0/3.0);\n    float Q = pow(0.5 * (d1 + sqrt(-27.0*delta)), 1.0/3.0);\n    float S = 0.5 * sqrt( -2.0 * p / 3.0 + (1.0/(3.0*a))*(Q+d0/Q) );\n    \n    if (delta < 0.0) {\n        // 2 distinct real roots, 2 complex conjugate roots\n        float x = inf, xp;\n        float pre = -b / (4.0*a);\n        float dis1 = -4.0 * S*S - 2.0*p;\n        float dis2 = q/S;\n        if (dis1 + dis2 >= 0.0) {\n            xp = pre - S - 0.5 * sqrt(dis1 + dis2);\n            //if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n            xp = pre - S + 0.5 * sqrt(dis1 + dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n        }\n        if (dis1 - dis2 >= 0.0) {\n            xp = pre + S - 0.5 * sqrt(dis1 - dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n            xp = pre + S + 0.5 * sqrt(dis1 - dis2);\n//            if (xp > 0.0 && xp < x && xp < 1.0) x = xp;\n            if (xp < x) x = xp;\n        }\n        return 0.1;\n    }\n    \n        return inf;\n#if 0\n    else if (delta > 0.0) {\n        if (P < 0.0 && D < 0.0) {\n            // 4 real roots\n            return inf;//0.1;\n        }\n        else {\n            // all complex roots... ignore!\n            return inf;\n        }\n    }\n    else { // delta == 0.0\n        // ignore until needed\n        return inf;\n    }\n    \n    return inf;\n#endif\n}\n\nfloat qbCurveHit(vec3[curveLen] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n    float minT = inf;\n    vec3 a, c;\n    for (int i = 2; i < n; i++) {\n        a = 0.5 * (pts[i-2] + pts[i-1]);\n        c = 0.5 * (pts[i-1] + pts[i]);\n        float t = qbHit(a, pts[i-1], c, r, ro, rd, cam);\n        if (t >= 0.0 && t < minT) {\n            minT = t;\n            return minT;// debug -- bail early on first hit. remove when t is real\n        }\n    }\n    return minT;\n}\n\nvec3 trace1( mat3x3 cam, vec3 ro, vec3 rd, float time )\n{\n    vec3 color;\n    const int ns = 10;\n    float fns = float(ns);\n    float mint = 9999.0;\n    float sr = 1.0;\n\n    for (int i = 0; i < ns; i++) \n    {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 sc=vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                     d*sin(tau*fni+time*10.0*fni), \n                     d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n\n        float t = sphereHit(sc, sr, ro, rd);\n        if (t > mint) continue;\n        mint = t;\n        \n        vec3 hit = rd * t + ro;\n        vec3 normal = sphereNormal(sc, sr, hit);\n        \n        float dup    = 1.0 * dot(normal, cam[1]) + 0.0;\n        float ddown  = 1.0 * dot(normal, -cam[1]) + 0.0;\n        float dright = 1.0 * dot(normal, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(normal, -cam[2] ) + 0.0;\n        float z = mod(2.0 * /*length(hit)*/hit.z, 1.0);\n\n        vec3 refl = reflect(rd, normal);\n\n        color = vec3(dright, dup, dfwd);\n        //color = vec4(z, z, z);\n        \n        // specular\n        float spec = pow(dot(refl, cam[1]), 20.0);\n        if (spec > 0.0) color += vec3(spec, spec, spec);\n\n        //color = normal;\n        //float j = t/10.0; color = vec3(j, j, j);\n        //color = vec3(mod(hit.x, 1.0), mod(hit.y, 1.0), 0.0);\n    }\n\n    if (mint > 999.0)\n    {\n        color = vec3(0.0, 0.75+0.25*sin(iTime), 1.0);\n    }\n    return color;\n}\n\nvec3 trace0( mat3x3 cam, vec3 ro, vec3 rd, float time )\n{\n    vec3 color;\n    const int ns = 10;\n    float fns = float(ns);\n    float mint = 9999.0;\n    float sr = 1.0;\n\n    if (spheres) for (int i = 0; i < ns; i++) \n    {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 sc=vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                     d*sin(tau*fni+time*10.0*fni), \n                     d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n        \n        float t = sphereHit(sc, sr, ro, rd);\n        if (t > mint) continue;\n        mint = t;\n        \n        vec3 hit = rd * t + ro;\n        vec3 normal = sphereNormal(sc, sr, hit);\n        \n        float dup    = 1.0 * dot(normal, cam[1]) + 0.0;\n        float ddown  = 1.0 * dot(normal, -cam[1]) + 0.0;\n        float dright = 1.0 * dot(normal, cam[0]) + 0.0;\n        float dfwd   = 1.0 * dot(normal, -cam[2] ) + 0.0;\n        float z = mod(2.0 * /*length(hit)*/hit.z, 1.0);\n\n        vec3 refl = reflect(rd, normal);\n\n        color = vec3(dright, dup, dfwd);\n        //color = vec4(z, z, z);\n        color = 0.5 * color + 0.5 * trace1(cam, hit, -refl, time);\n        \n        // specular\n        float spec = pow(dot(refl, cam[1]), 20.0);\n        if (spec > 0.0) color += vec3(spec, spec, spec);\n\n        //color = normal;\n        //float j = t/10.0; color = vec3(j, j, j);\n        //color = vec3(mod(hit.x, 1.0), mod(hit.y, 1.0), 0.0);\n    }\n    \n    if (curves) {\n        float db = 0.0;\n        float dd = 1.0;\n                \n        for (int i = 0; i < curveLen; i++) {\n            float fi = float(i);\n            pts[i] = vec3(1.5 * sin(fi), fi*1.0 - 6.0, 1.5 * cos(fi));\n        }\n        \n        int i = 0;\n        for (float ox = -db; ox <= db + dd/2.0; ox += dd) {\n        for (float oy = -db; oy <= db + dd/2.0; oy += dd) {\n        for (float oz = -db; oz <= db + dd/2.0; oz += dd, i++) {\n#if 0\n            float qbt = qbHit(\n                vec3(-2.0+ox, -2.0+oy, 0.0+oz), \n                vec3(-1.0+ox, 2.0+oy+2.0*sin(10.0*tau*time+float(i)), 0.0+oz), \n                vec3(2.0+ox, -2.0+oy, 0.0+oz), \n                0.05, ro, rd, cam);\n#else\n            float qbt = qbCurveHit(pts, curveLen, 0.05, ro, rd, cam);\n            //float qbCurveHit(vec3[] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n#endif\n            if (qbt < mint) {\n                mint = qbt;\n                color = vec3(0.0, 0.0, 0.0);\n            }\n        }\n        }\n        }\n    }\n\n    if (mint > 999.0)\n    {\n        color = vec3(0.0, 0.75+0.25*sin(iTime), 1.0);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = (iMouse.z > 0.0) ? iMouse.x / iResolution.x :  iTime / 10.0;\n    vec3 ro = vec3(10.0*sin(tau * time), 0.0, 10.0*cos(tau * time));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 fwd   = normalize(lookat - ro);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rd = normalize(fwd + 0.5 * (uv.x * right + uv.y * up));\n    \n    fragColor = vec4(trace0(mat3x3(right, camup, fwd), ro, rd, time), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 206, 206, 592], [594, 594, 648, 648, 1032], [1034, 1034, 1080, 1080, 1112], [3894, 3944, 4023, 4023, 9414], [9416, 9416, 9500, 9500, 9884], [9886, 9886, 9943, 9943, 11380], [11382, 11382, 11439, 11439, 14001], [14003, 14003, 14060, 14060, 14672]], "test": "untested"}
{"id": "XtsfWH", "name": "Infinite road illusion", "author": "Otringal", "description": "A simple 3D faking of an infinitely-long running road using 2D functions.", "tags": ["2d", "3d", "illusion", "road", "infinite", "rolling"], "likes": 3, "viewed": 283, "published": "Public", "date": "1511790887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getAspectRatio()\n{\n    return iResolution.x / iResolution.y;\n}\n\nvec2 getUVCoords(in vec2 fragCoords)\n{\n    return ((fragCoords - 0.5) / (iResolution.xy - 1.0) - 0.5) * vec2(getAspectRatio(), 1.0);\n}\n\nvoid drawSky(in vec2 uvCoords, inout vec4 canvas)\n{\n    vec4 sky = vec4(1.0 - 1.4 * sqrt(uvCoords.y),\n                  \t0.5 - 3.7 * uvCoords.y,\n                  \t0.5 - 0.8 * uvCoords.y,\n                  \t1.0);\n    \n    canvas = clamp(sky, 0.0, 1.0); //needed due to sqrt() of negative values\n}\n\nvoid drawSun(in vec2 uvCoords, inout vec4 canvas)\n{\n    vec2 origin = vec2(0.0, 0.0);\n    float radius = 0.25;\n    float blurAmount = 0.4;\n    vec3 color = vec3(1.0, 1.0, 0.2);\n    origin.x *= getAspectRatio();\n    float color_amount = 1.0 - smoothstep(radius - blurAmount, radius + blurAmount, distance(origin, uvCoords));\n    canvas += vec4(color_amount * color, 0.0);\n}\n\nvoid drawRoad(in vec2 uvCoords, inout vec4 canvas)\n{\n    float s = step(0.0, uvCoords.y);\n    float t = mod(iTime, 60.0); //needed hack for long-running scenes\n    vec4 road = vec4(vec3(sign(sin(70.0 * pow(-uvCoords.y, 0.3) - 25.0 * t))), 1.0);\n    \n    road = clamp(road, 0.0, 1.0); //needed due to sqrt() of negative values\n    road *= vec4(2.0 * (0.5 + uvCoords.y),\n                 1.6 * (0.5 + uvCoords.y),\n                 1.8 * (0.5 + uvCoords.y),\n                 1.0);\n    canvas = mix(road, canvas, s);\n}\n\nvoid drawSidewalk(in vec2 uvCoords, inout vec4 canvas)\n{\n    float s = step(0.85 * (0.015 - uvCoords.y), abs(uvCoords.x) / getAspectRatio()) * step(0.0, -uvCoords.y);\n    vec4 sidewalk = vec4(0.8 * (0.5 + uvCoords.y),\n                 \t\t 0.6 * (0.5 + uvCoords.y),\n                 \t\t 1.3 * (0.5 + uvCoords.y),\n                 \t\t 1.0);\n    \n    canvas = mix(canvas, sidewalk, s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = getUVCoords(fragCoord);\n    \n    drawSky(uv, fragColor);\n    drawSun(uv, fragColor);\n    drawRoad(uv, fragColor);\n    drawSidewalk(uv, fragColor);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 68], [70, 70, 108, 108, 204], [206, 206, 257, 257, 502], [504, 504, 555, 555, 876], [878, 878, 930, 930, 1392], [1394, 1394, 1450, 1450, 1775], [1777, 1777, 1832, 1832, 1992]], "test": "untested"}
{"id": "XtsfWN", "name": "Yin_Yang", "author": "kalkas", "description": "Homework, 1st", "tags": ["homework", "nothingspecial"], "likes": 2, "viewed": 111, "published": "Public", "date": "1512039351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 currentCoords;\n\nstruct circle{\n    vec2 m_Center;\n    float m_Radius;\n};\n    \nbool IsInside(circle _circle){\n    float _magnitude = length(currentCoords.xy - _circle.m_Center);\n    return _magnitude <= _circle.m_Radius;\n}\nbool IsLeft(vec2 _line){\n    return cross(vec3(currentCoords, 0.0), vec3(_line, 0.0)).z >= 0.0;\n}\n\n\nvec2 Rotate(vec2 _vec, float _angle){\n    return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle)) * _vec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoords = fragCoord * 2.0 - iResolution.xy;\n    vec2 nResolution = iResolution.xy * 2.0;\n    vec2 upVector = vec2(0.0, 1.0);\n    float gradient = -1.0 * ((length(currentCoords) / (length(nResolution) / 2.0)) - 1.0);\n    \n    circle yinYang = circle(vec2(0.0, 0.0), 0.9 * nResolution.y / 2.0);\n    circle bigYin = circle(vec2(0.0, yinYang.m_Radius / 2.0), yinYang.m_Radius / 2.0);\n    circle smallYin = circle(bigYin.m_Center, bigYin.m_Radius * 0.3);\n    circle bigYang = circle(vec2(0.0, -yinYang.m_Radius / 2.0), yinYang.m_Radius / 2.0);\n    circle smallYang = circle(bigYang.m_Center, bigYang.m_Radius * 0.3);\n    \n    bigYin.m_Center = Rotate(bigYin.m_Center, -iTime);\n    smallYin.m_Center = Rotate(smallYin.m_Center, -iTime);\n    bigYang.m_Center = Rotate(bigYang.m_Center, -iTime);\n    smallYang.m_Center = Rotate(smallYang.m_Center, -iTime);\n    upVector = Rotate(upVector, -iTime);\n    \n    if(!IsInside(yinYang)){\n        fragColor = vec4(gradient, 0.0, 0.0, 1.0);\n    }else{\n        if((IsInside(bigYin) && !IsInside(smallYin)) ||\n           (!IsInside(bigYin) && !IsInside(bigYang) && IsLeft(upVector)) ||\n           IsInside(smallYang)){\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }else{\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 113, 113, 226], [227, 227, 251, 251, 324], [327, 327, 364, 364, 443], [445, 445, 502, 502, 1795]], "test": "untested"}
{"id": "XtsfzN", "name": "Basic 3D Shader", "author": "PeterTheGreat", "description": "First 3D Shadertoy!\n\nChange MOUSE_INPUT on line 7 to true to use the horizontal position of the cursor to change the number of points drawn between vertices.", "tags": ["3d", "dodecahedron"], "likes": 10, "viewed": 193, "published": "Public", "date": "1511298173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define PHI 1.61803398875\n#define EPSILON .0001\n//If MOUSE_INPUT is set to true, the x coordinate of the mouse determines the \n// number of points drawn between the verticies. If false, the number of points\n// will cyclically change over time.\n#define MOUSE_INPUT false\n\n#define DrawPoint(A,D,P,r) smoothstep( r, r - .01, length(cross(P-A, D)) / length(D) )\n#define DistToLine(A1,D1,A2,D2) abs( dot(A2 - A1, cross(D1, D2))) / length(cross(D1, D2))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int CUBE_SIZE = 20; \n\n    vec3 cube[] = vec3[](\n    \tvec3(.5, .5, .5),\n    \tvec3(.5, .5, -.5),\n    \tvec3(.5, -.5, .5),\n    \tvec3(.5, -.5, -.5),\n    \tvec3(-.5, .5, .5),\n    \tvec3(-.5, .5, -.5),\n    \tvec3(-.5, -.5, .5),\n    \tvec3(-.5, -.5, -.5),\n    \tvec3(0., .5 * PHI, .5 / PHI),\n    \tvec3(0., .5 * PHI, -.5 / PHI),\n    \tvec3(0., -.5 * PHI, .5 / PHI),\n    \tvec3(0., -.5 * PHI, -.5 / PHI),\n    \tvec3(.5 / PHI, 0, .5 * PHI),\n    \tvec3(.5 / PHI, 0, -.5 * PHI),\n    \tvec3(-.5 / PHI, 0, .5 * PHI),\n    \tvec3(-.5 / PHI, 0, -.5 * PHI),\n    \tvec3(.5 * PHI, .5 / PHI, 0),\n    \tvec3(.5 * PHI, -.5 / PHI, 0),\n    \tvec3(-.5 * PHI, .5 / PHI, 0),\n    \tvec3(-.5 * PHI, -.5 / PHI, 0)\n    );\n    \n\tvec2 uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 origin = 7. * vec3(2.5 * sin(t / 2.), 1.5 + sin(t / .8) / 2., -2.5 * sin(t / (PI / 3.)));\n    \n    vec3 cameraFocus = vec3(0.);\n    \n    float zoom = 5. + sin(t) / 3.;\n    \n    vec3 f = normalize(cameraFocus - origin);\n    vec3 r = vec3(f.z, 0., -f.x);\n    vec3 u = cross(f, r);\n    \n    vec3 center = origin + f * zoom;\n    vec3 i = center + uv.x * r + uv.y * u;\n    vec3 direction = i - origin;\n    \n    vec3 point = vec3(0. + cos(t), 0., 1. + sin(t));\n    \n    float radius = .03;\n    \n    float d = 0.;\n    \n    float numDots;\n    if (MOUSE_INPUT)\n        numDots = floor(iMouse.x * .06);\n    else\n        numDots = 26. + round(25. * sin(t / 5.));\n   \n    for (int i = 0; i < CUBE_SIZE; ++ i)\n        for (int j = 0; j < CUBE_SIZE; ++ j)\n            if (i != j && (abs(length(cube[i] - cube[j]) - 1. / PHI) < EPSILON) && DistToLine(origin, direction, cube[i], cube[j] - cube[i]) < radius)\n                for (float k = 0.; k < numDots; ++ k)\n                    if (d < 1.)\n                        d += DrawPoint(origin, direction, (k * cube[i] + (numDots - k) * cube[j]) / numDots, radius) / 15.;\n    \n    d += .25;\n    \n    uv *= 15. / zoom;\n    fragColor = vec4(vec3(d), 0.) / 2.;\n    \n    if (d > .3)\n    \tfragColor += d * vec4(uv,0.5+0.5*sin(iTime),1.0) / 2.;\n}", "image_inputs": [{"id": "MsjXzz", "previewfilepath": "https://soundcloud.com/omnitica/spacebard1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/omnitica/spacebard1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 472, 529, 529, 2593]], "test": "untested"}
{"id": "XtSyDd", "name": "Circle Function", "author": "HephaChronos", "description": "Learning how to code shaders.  I followed this https://www.youtube.com/watch?v=GgGBR4z8C9o tutorial and made something pretty cool", "tags": ["circle"], "likes": 1, "viewed": 107, "published": "Public", "date": "1510519598", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, float r, vec2 pos){\n    uv += pos;\n    \n    float d = length(uv);\n    \n    float c = smoothstep(r, r-.02, d);\n    return c;   \n}\n\n#define polar2xy(r,a) ( (r) * vec2( cos(a), sin(a) ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n    \n\tfloat mask = circle(uv, abs(.9*sin(.3*iTime)), vec2(0,0) );\n    \n    vec3 c = vec3(uv.x+.5, uv.y+.5, 0.5+0.5*sin(iTime));\n    \n    c *= mask;\n    \n    mask = circle( uv, .2, polar2xy( .1, 4.*iTime ) );\n    vec3 c2 = vec3(5., 2.+0.5*sin(2.37*iTime), 1.);\n    c2 *= mask;\n    \n    mask = circle( uv, .1, polar2xy( .1, 4.*iTime) );\n    c2 *= 1.-mask;\n    \n    mask = circle( uv, .1, polar2xy( .45, 4.*iTime ) );\n    c2 += mask;\n    \n    c *= mix(c, c2, .5);\n        \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 150], [208, 208, 265, 265, 830]], "test": "untested"}
{"id": "XtSyzt", "name": "Hypnotic checker", "author": "CoyHot", "description": "UV offsets, mirroring and distortion on a checker", "tags": ["2d", "checker"], "likes": 2, "viewed": 106, "published": "Public", "date": "1509659319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t----------------\n\tHypnotic checker\n\t----------------\n\n\tUV offsets, mirroring and distortion on a checker\n\n\tFrancois 'CoyHot' Grassard - 2017\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-0.5)/vec2(iResolution.y / iResolution.x, 1);\n    \n\tuv.x = uv.x*exp(uv.y*4.);\n\n\tif (uv.x>0.){uv.x = -uv.x;}\n\tif (uv.y>0.){uv.y = -uv.y;}\n\n\tuv.y += uv.x/5.;\n\n\n  fragColor = vec4(sin((atan(exp(abs(uv.x)*(-1.)),abs(uv.y))+iTime/10.+uv.x)*50.5)*(sin(uv.y*50.)*10.));    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 149, 206, 206, 523]], "test": "untested"}
{"id": "XtXBDM", "name": "johndp persistence test", "author": "johndp", "description": "persistence test", "tags": ["utility"], "likes": 0, "viewed": 393, "published": "Public API", "date": "1511987383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265359;\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nvec4 circle(vec2 p, vec2 center, float radius)\n{\n\treturn mix(vec4(1,1,1,0), vec4(1,0,0,1), smoothstep(radius + 0.005, radius - 0.005, length(p - center)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = uv;\n    vec2 dDim = vec2(120,68);  \n    vec2 PDxy = vec2(10.0,30.0)/dDim;\n    float m_fps = 2.0;\n    float d0 = round(fract(float(iFrame)/2.0/m_fps)+0.001);\n    float d1 = round(fract(float(iFrame-1)/2.0/m_fps)+0.001);\n    float v = 2.0;  \n    float p = 0.02;  \n    float w = 0.9;\n    float mag = 0.5;\n    vec2 parity = -sign(uv.x-0.5)*vec2(1.0,0.0);\t\n    vec2 dxdy = iMouse.xy/iResolution.xy-0.5;\n    float verg = -0.01+dxdy.x;    \n\n    if(true)\n        uv.x = fract(uv.x*2.0);\t\t\n      \tdDim = dDim*vec2(0.5,1.0);\t\n    \tp *= 2.0;\n    \n    uv.x += parity.x*verg;\n    uv -= 0.5;\n    \n    if(sin(2.0*pi/p*uv.x) > w)\n        fragColor = vec4(1,1,1,1);\n\telse\n\t\tfragColor = vec4(0,0,0,1);\n    \n    float r = 0.1*mag;\n    float s = 1.0;\n    float l = .02;\n    float d = -0.6;\n    float vOffset = -0.15*mag;\n    \n    if(circle(uv,vec2(0.0,-vOffset),r).x>0.5 && circle(uv,vec2(0.0,-vOffset),r).y<0.5){\n        if ( ( (cos(2.0*pi/l*(uv.x )) > d ) ) && ( abs( uv.y + vOffset) < .005) ){       \n            fragColor = 0.8*vec4(1,1,0,1);\n        }else{\n        \tfragColor = vec4(1,0,0,1);\n        }\n    }\n\n    float pos = s*fract(iTime*v/s)-0.5;\n    if(circle(uv,vec2(pos,vOffset),r).x>0.5 && circle(uv,vec2(pos,vOffset),r).y<0.5){\n        if ( ( (cos(2.0*pi/l*(uv.x - pos)) > d ) ) && ( abs( uv.y - vOffset ) < .005) ){       \n            fragColor = 0.8*vec4(1,1,0,1);\n        }else{\n        \tfragColor = vec4(1,0,0,1);\n        }\n    }\n    \n    uv += 0.5;\n    uv.x -= parity.x*verg;\n    if((1.0-uv.x)<PDxy.x && (uv.x)>0.0 && (uv.y)<PDxy.y && (uv.y)>0.0 && xy.x >0.5){\t\t\n        fragColor = vec4(d0,d0,d0,1.0);\n    }\n    /*if((uv.x)<2.0*PDxy.x && (uv.x)>PDxy.x && (uv.y)<PDxy.y && (uv.y)>0.0){\n        fragColor = vec4(d1,d1,d1,1.0);\n    }*/\n\n\n    float col = PrintInt( (uv-vec2(0.01,0.85))*20.0, iFrameRate );\n    fragColor += vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 173, 229, 229, 1319], [1321, 1321, 1378, 1378, 1690], [1692, 1692, 1740, 1740, 1849], [1851, 1851, 1908, 1908, 3807]], "test": "untested"}
{"id": "XtXBzN", "name": "Triangle Grid #", "author": "marian42", "description": "Triangles", "tags": ["2d"], "likes": 15, "viewed": 845, "published": "Public API", "date": "1511133157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst float period = 30.0;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    vec2 triangleCoords = floor(uv);\n    triangleCoords.x *= 2.0;\n    float mody = floor(mod(triangleCoords.y, 2.0));\n    vec2 local = vec2(fract(uv.x + mody * 0.5) - 0.5, fract(uv.y));\n    if (local.y > abs(local.x) * 2.0) {\n        triangleCoords.x += local.x < 0.0 ? 1.0 : -1.0;\n    }\n    if (local.x >= 0.0 && mody == 0.0) {\n        triangleCoords.x += 2.0;\n    }\n    return triangleCoords;\n}\n\nfloat getColor(vec2 uv) {\n    uv /= 40.0;\n    vec2 triangle = getTriangleCoords(uv);\n     \n    float angle = floor(6.0 * rand(triangle + 0.1)) / 3.0 * pi;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    float projected = dot(direction, uv);    \n    float progress = fract(iTime / period + rand(triangle + 0.2) + projected * 0.8 / period);\n    \n    return progress > 0.5 ? rand(triangle) : rand(triangle + 0.3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tconst float samples = 2.0;\n    float value = 0.0;\n    \n    for (float x = 0.0; x < 1.0; x += 1.0 / samples) {\n        for (float y = 0.0; y < 1.0; y += 1.0 / samples) {\n\t\t\tvalue += getColor(fragCoord + vec2(x, y));\n        }\n    }    \n    value /= pow(samples, 2.0);\n    \n    value *= 0.4;\n    \n\tfragColor = vec4(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 142, 162, 162, 232], [234, 234, 267, 267, 691], [693, 693, 718, 718, 1112], [1114, 1114, 1170, 1170, 1494]], "test": "untested"}
{"id": "XtXfWn", "name": "NURBS Rendering", "author": "fre3k", "description": "Shamelessely took this bezier shadertoy https://www.shadertoy.com/view/4tj3Dy and just used nurbs instead of loop/blinn.\nNo patent on this one :)\nhttp://jogamp.org/doc/gpunurbs2011/p70-santina.pdf", "tags": ["2d", "nurbs"], "likes": 6, "viewed": 1206, "published": "Public API", "date": "1511526759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nInfo on curves:\nhttp://jogamp.org/doc/gpunurbs2011/p70-santina.pdf\n\nImplem in jogl:\nhttps://github.com/sgothel/jogl/blob/master/src/jogl/classes/jogamp/graph/curve/opengl/shader/curverenderer01-pass1-curve_weight.glsl\n\nThanks to bezier curve shadertoys:\nhttps://www.shadertoy.com/view/4tj3Dy\n*/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g);\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(1.0,1.0,1.0);\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.0,-0.4);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(0.3,0.4);\n    vec2 C = vec2(1.0,-0.4);\n    float w0 = 1.;\n    float w1 = (sin(iTime)+1.)*0.5;\n    float w2 = 1.;\n\n    // Compute vectors\n    vec2 v0 = C - A;\n    vec2 v1 = B - A;\n    vec2 v2 = percent - A;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // NURBS calculations\n    float w = (1.0 - u - v);\n    vec2 rtex = u * vec2(0.0,0.0) + v * vec2(0.5,0.5) + w * vec2(1.0,0.0);\n    float nu = rtex.x;\n    float nv = rtex.y;\n\n    // Basic position\n    float pd = ( (w0 - 2.*w1 + w2)*nu*nu + 2.*(w1-w0)*nu + w0 );\n    float pos = nv - (w1 * nu * (1.- nu)) / pd ;\n\n    // Smooth interpolation, no aliasing\n    vec2 dtx = dFdx(rtex);\n    vec2 dty = dFdy(rtex);\n    float aph = 2.0 - 2.0*w1;\n    float gd = (aph*rtex.x*rtex.x + 2.0*rtex.x + 1.0)*(aph*rtex.x*rtex.x + 2.0*rtex.x + 1.0);\n    vec2 f = vec2((dtx.y - (w*dtx.x*(1.0 - 2.0*rtex.x))/gd), (dty.y - (w*dty.x*(1.0 - 2.0*rtex.x))/gd));\n    float a = clamp(0.5 - ( pos/length(f) ) * sign(w2), 0.0, 1.0);\n    color = vec3(mix(1.,0.5,a))*0.5;\n\n    // if it's outside the triangle, lighten it a bit\n    color += ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) ? 0.0 : 0.7;\n\n    // render control points\n    float dist = SDFCircle(percent, A);\n    dist = max(dist, 0.0);\n    dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n    color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    dist = SDFCircle(percent, B);\n    dist = max(dist, 0.0);\n    dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n    color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    dist = SDFCircle(percent, C);\n    dist = max(dist, 0.0);\n    dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n    color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n\n    fragColor = vec4(clamp(color,0.0,1.0),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 402, 453, 453, 622], [624, 704, 761, 761, 3196]], "test": "untested"}
