{"id": "3dcXWl", "name": "[phreax] kifs waves ", "author": "phreax", "description": "Experimenting with grid offsets", "tags": ["raymarching", "grid", "kifs"], "likes": 1, "viewed": 71, "published": "Public", "date": "1581631300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"[phreax] cube waves\" by phreax. https://shadertoy.com/view/Wd3SWl\n// 2019-11-06 22:43:34\n\nfloat tt, mat = 0., cy;\nvec2 id;\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat box(vec3 p, vec3 r) {\n\tp = abs(p) - r;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec2 repeat(inout vec2 p, vec2 s) {\n    vec2 id = floor(p/s-.5);\n   // p = (fract(p/s-.5)-.5)*s;\n    p = mod(p+.5*s, s)-.5*s;\n    return id;\n}\n\nfloat N(float x) {\n\treturn fract(sin(x*92856.957)*64556.549);\n}\n\nfloat N21(vec2 p) {\n\treturn fract(dot(p, vec2(N(p.x), N(p.y)))*8847.523);\n}\n\nvec3 kifs(vec3 p, float a) {\n    for(int i=0; i<3; i++) {\n    \tp.xz *= rot(sin(float(i)*.4+tt*a+a));\n        p.xz -= vec2(0.2, 0.4);\n        p.xz = abs(p.xz);\n    }\n    return p;\n}\n\nfloat map(vec3 p) {\n    id = repeat(p.xz, vec2(5.2));\n    float h = N21(id);\n    p.xz *= rot(tt*h);\n   \n    p = kifs(p, h);\n    //mat = id.x;\n    vec3 s = vec3(.6);\n\n    p.y += sin(length(id+vec2(1, -5.))*0.7+tt*2.)*1.5;\n    cy = p.y;\n    p.xy *= rot(h);\n  \n    return (box(p, s)-.1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    tt = iTime;\n\tvec3 ro = vec3(0, -10., -20),\n         rd = normalize(vec3(-uv, .7)),\n         l = normalize(vec3(0, -1, -4.));\n    rd.yz *=rot(.6);\n    \n    vec3 col,\n         bg = mix(vec3(.74, .91, .99), vec3(.1), -(uv.y-0.4));\n    \n    \n    \n    float i, t = 0.1, d=.01;\n    \n    vec3 p;\n    for(i=0.; i<100.; i++) {\n     \tp = ro + t*rd;\n    \td = map(p);\n        if(t < 0.001 || t > 90.) break;       \n\t\tt += d;\n    }\n    \n    vec2 e = vec2(.0005, -.0005);\n    if(d < 0.0001) {\n        \n        vec3 n = normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                           e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        float dif= max(dot(n, l), .0);\n        \n        \n        float sss = smoothstep(0., 1., map(p+l*.4));\n        vec3 al = mix(vec3(0.1, 0.6, 0.8)*.9, vec3(.1, 0, 1), p.y-cy);\n        col += al*.4 + 0.8*al*(dif+sss);\n        col = mix(col, bg, 0.5*(1.-exp(-.00002*t*t*t)));\n     \n    } else {\n         col = bg;\n    }\n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 154, 154, 203], [205, 205, 232, 232, 317], [319, 319, 354, 354, 461], [463, 463, 481, 481, 526], [528, 528, 547, 547, 603], [605, 605, 633, 633, 785], [787, 787, 806, 806, 1073], [1077, 1077, 1134, 1134, 2190]], "test": "untested"}
{"id": "3l3SzM", "name": "Sakura Fubuki (cherry blossoms)", "author": "whisky_shusuky", "description": "spring in japan", "tags": ["raymarching", "japan", "cineshader"], "likes": 4, "viewed": 9094, "published": "Public API", "date": "1580574469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://github.com/whisky-shusuky/glsl_storage/blob/master/glsl/sakurahubuki.glsl\nprecision highp float;\n\nconst float fluid_speed     = 208.0;  // Drives speed, higher number will make it slower.\nfloat gTime = 0.;\n\n// 回転行列\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n\tfloat k0 = length(p/r);\n\tfloat k1 = length(p/(r*r));\n\treturn k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sakura(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdEllipsoid(pos, vec3(.4,.6,.2)) /1.5;\n\tpos.xy *= 5.;\n\t//pos.yz *= rot(.);\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat cut = sdBox(pos  , vec3(1.,1.,1.));\n\tfloat result = min(-base,cut) *2.;\n\treturn result;\n}\n\nfloat sakura_set(vec3 pos) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y -= .1;\n\tfloat sakura1 = sakura(pos,2.);\n\tpos = pos_origin;\n\tpos .x += .35;\n\tpos .y += .15;\n\tpos.xy *=   rot(.9);\n\tfloat sakura2 = sakura(pos,2.);\n\tpos = pos_origin;\n\tpos .x -= .35;\n\tpos .y += .15;\n\tpos.xy *=   rot(-.9);\n\tfloat sakura3 = sakura(pos,2.);\t\n\tpos = pos_origin;\n\tpos .x += .225;\n\tpos .y += .6;\n\tpos.xy *=   rot(2.5);\n\tfloat sakura4 = sakura(pos,2.);\t\n\tpos = pos_origin;\n\tpos .x -= .225;\n\tpos .y += .6;\n\tpos.xy *=   rot(-2.5);\n\tfloat sakura5 = sakura(pos,2.);\t\n\tfloat result = max(max(max(max(sakura1,sakura2),sakura3),sakura4),sakura5);\n\treturn result;\n}\n\nfloat map(vec3 pos) {\n\tvec3 pos_origin = pos;\n\tfloat sakura_set1 = sakura_set(pos);\n\tpos.x +=sin(gTime);\n\tpos.y +=sin(gTime);\n\tpos.z +=sin(gTime);\n    pos.yz *= rot(sin(gTime * 2.)) * 2.;\n\tpos *= 1.5;\n\tfloat result =sakura_set1;\n\n\treturn result;\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat linearFog(float d, float start, float end) {\n\t// (end - d) / (end - start)と0の内最大値とそれと1の最小値を求める。\n\t// d がstart より前だと0,startより後だと１,間なら1~0に線形に変化する。\n\treturn clamp((end - d) / (end - start), 0.0, 1.0);\n}\n\nfloat expFog(float d, float density) {\n    return exp(-d * density);\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0.5, sin(iTime) * 2.  + 0.3 ,iTime * 2.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\n\tfloat t = 0.01;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\tro.xy  =ro.xy * rot(sin(iTime* .005)) * .1;\n\tro.yz  =ro.yz * rot(sin(iTime* .005)) * 0.05;\n\tray.xy  =ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz  =ray.yz * rot(sin(iTime * .03) * 5.);\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\tpos.xy = pos.xy  * rot(iTime);\n\t\t\n\t\tpos.yz = pos.yz  * rot(sin(iTime) /2.);\n\t\t\n\t\tfloat d = map(pos);\n\n\t\td = max(abs(d), 0.02);\n\t\tac += exp(-d*3.);\n\n\t\tt += d* 0.15;\n\t}\n\n    for(int i=1;i<140;i++)\n\t{\n\t\tvec2 newp=p + iTime*0.005;\n\t\tnewp.x+=0.9/float(i)*sin(float(i)*p.y+iTime/fluid_speed+0.3*float(i)) + sin(iTime)* 0.01; // + mouse.y/mouse_factor+mouse_offset;\n\t\tnewp.y+=0.85/float(i)*sin(float(i)*p.x+iTime/fluid_speed+0.3*float(i+10) + sin(iTime)* 0.01); // - mouse.x/mouse_factor+mouse_offset;\n\t\tp=newp;\n\t}\n    \n\tcol = vec3(ac * 0.04);\n\tvec3 finalColor = vec3 ( 0., 0., 0. );\n\n\tcol += smoothstep(0.5, 1.,sin(iTime)) * .15 * vec3 ( 1.0, 0.3, 0.5 );\n\tcol += smoothstep(0.5, 1.,cos(iTime)) * .15 * vec3 ( .0, 0.3, 1.0 );\n\n\tcol.z += + 0.54;\n\tcol.y = col.y * abs(sin(iTime) / 4.) + 0.540;\n\n\n\tfragColor = vec4(col ,1.0 -  t *  0.005);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3SzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 234, 253, 253, 310], [312, 312, 355, 355, 435], [437, 437, 468, 468, 553], [555, 555, 592, 592, 829], [831, 831, 859, 859, 1476], [1478, 1478, 1499, 1499, 1725], [1727, 1790, 1840, 2025, 2079], [2081, 2081, 2119, 2119, 2151], [2153, 2153, 2192, 2192, 2248], [2251, 2251, 2308, 2308, 3687]], "test": "untested"}
{"id": "3l3XDr", "name": "shad3r", "author": "xvart", "description": "was again a checker board, not anymore still", "tags": ["cineshader"], "likes": 2, "viewed": 9017, "published": "Public API", "date": "1580709639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n    float d = 0.0f;\n    int modular = 10;\n    float moveOffset = iTime/speedMultiplier;\n    \n\n    int uvY100 = int(round((uv.y + moveOffset) * 100.0));\n    int aStepY100 =  uvY100 % modular;\n   \n    float aStepY = (float(aStepY100)/float(modular - 1));\n    float dStepY = round(aStepY);\n\n    \n    int uvX100 = int(round((uv.x + moveOffset) * 100.0));\n    int aStepX100 =  uvX100 % modular;\n    float aStepX = (float(aStepX100)/float(modular - 1));\n    float dStepX = round(aStepX);\n    \n    \n    float dStepXY = dStepX * dStepY;\n    \n    col = vec3(dStepX,dStepX,dStepX);\n    \n    float blockHeight = dStepXY/2.0;\n    float xRipple = 0.5 * cos((uv.x + iTime/w1) * iTime/(w2*10.0));\n    // float yRipple = 0.5 * sin((uv.y + iTime/w2) * iTime/(w1*10.0));\n\tfloat yRipple = 0.5 * sin((iTime/(w1*100.0)));\n    \n    d = (xRipple + yRipple) * blockHeight;\n    // d = blockHeight * (1.0 - uv.x) * (1.0 - uv.y);\n    // d = blockHeight * (1.0 - length(uv - 0.5) * 2.0);\n    // d = blockHeight;\n    \n\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"shad3r\",\n\t\"description\": \"was again a checker board, not anymore still\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3XDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 1296]], "test": "untested"}
{"id": "3l3Xzf", "name": "Noise - wave - 2D : vector field", "author": "FabriceNeyret2", "description": "variant of Wave Noise - a simple wave based noise based on extremely simplified Gabor kernel. [url]https://shadertoy.com/view/tldSRj[/url]\n\nvector field +flownoise variant using complex Gabor (attention: div(V) != 0 ;-) ).", "tags": ["procedural", "2d", "noise", "velocity", "arrows"], "likes": 12, "viewed": 415, "published": "Public API", "date": "1581406493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// vector field variant of \"Noise - wave - 2D\" by iq. https://shadertoy.com/view/tldSRj\n\n// Fabrice's way to see it: 1 Gabor kernel at each cell center, overlapping neighbor cells\n// Here, complex Gabor instead of just the real part.\n\n#define CS(a) cos(a + vec2(0,33))\n\nvec2 g( vec2 n ) { return CS(n.x*n.y); }  // use better hash than n.x*n.y\n\nvec2 noise(vec2 p)\n{\n    const float kF = 3.1415927;\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.-2.*f);\n    float t = (mod(i.x+i.y,2.)*2.-1.) * iTime;       // checkered rotation ( flownoise )\n    return mix(mix(CS( t+ kF*dot(p,g(i+vec2(0,0)))), // Gabor kernel (and overlapping neighbors)\n               \t   CS(-t+ kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(CS(-t+ kF*dot(p,g(i+vec2(0,1)))),\n               \t   CS( t+ kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\n\nfloat f, scale = 24.,      // scale of noise\n      sampling = 7.;       // density of vectors\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n\t    uv = ( u - R/2. ) / R.y,\n\t     p = fract(scale*uv)*2.-1., n; // p = local centered coords in cells\n    \n    // left: 1-band noise\t\n\tif( uv.x<0. )\n\t{\n        n = noise( floor(scale*uv)/sampling ); // floor: optional (without = curvy)\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n        mat2 m = mat2(2); // mat2( 1.6,  1.2, -1.2,  1.6 ); // sqrt2 not floor-friendly ;-)\n#define N(uv,s) noise( floor(scale*uv/s)*s/sampling ); // floor: optional (without = curvy)\n\t\tn  = 0.5000*N( uv, 1.); uv = m*uv;\n\t\tn += 0.2500*N( uv, 2.); uv = m*uv;\n\t\tn += 0.1250*N( uv, 4.); uv = m*uv;\n\t\tn += 0.0625*N( uv, 8.); uv = m*uv;\n\t}\n\n    // --- display vector field \n    \n  //n = normalize(n);  // optional : for more dramatic vortices\n    float l = length(n),\n          x = (n.x*p.y-n.y*p.x) / l,\n          w = dot(n,p) / l;         // option: arrow points to vector dir\n    f = smoothstep(scale*3./R.y, 0., abs(x)+.05*w ); // display vector line\n    f *= smoothstep(3./R.y, 0., abs(w)- l ); // optional: show vector length\n\t\n\tO = vec4( f );\n    \n    O.x += smoothstep( 3./R.y, 0., abs(uv.x) );\t// separator\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Xzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 270, 288, 288, 310], [312, 345, 365, 365, 830], [905, 928, 966, 966, 2103]], "test": "untested"}
{"id": "3lcSRB", "name": "3D earth", "author": "cgjingling", "description": "简化了原版", "tags": ["3dearth"], "likes": 17, "viewed": 261, "published": "Public", "date": "1581169664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define mul(a, b) (a) * (b)\n\n\n\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nstruct hit_t {\n\tfloat t;\n\tint material_id;\n\tvec3 normal;\n\tvec3 origin;\n};\n\n\thit_t no_hit = hit_t (\n\tfloat(1e8 + 1e1), \n\t-1, \n\tvec3(0., 0., 0.),\n\tvec3(0., 0., 0.) \n);\n\n\nray_t get_primary_ray(\n\tin vec3  cam_local_point,\n\tinout vec3 cam_origin,\n\tinout vec3  cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = ray_t (\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t);\n\treturn r;\n}\n\nmat3 mat3_ident = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n\nmat2 rotate_2d(\n\tin float  angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat2(_cos, -_sin, _sin, _cos);\n}\n\nmat3 rotate_around_z(\n\tin float angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\nmat3 rotate_around_y(\n\tin  float  angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nmat3 rotate_around_x(\n\tin float  angle_degrees\n){\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n\nvec3 linear_to_srgb(\n\tin vec3  color\n){\n\tconst float p = 1. / 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\nvec3 srgb_to_linear(\n\tin vec3  color\n){\n\tconst float p = 2.2;\n\treturn vec3(pow(color.r, p), pow(color.g, p), pow(color.b, p));\n}\n\nfloat checkboard_pattern(\n\tin vec2  pos,\n\tin float scale\n){\n\tvec2 pattern = floor(pos * scale);\n\treturn mod(pattern.x + pattern.y, 2.0);\n}\n\nfloat band (\n\tin float start,\n\tin float peak,\n\tin float end,\n\tin float t\n){\n\treturn\n\tsmoothstep (start, peak, t) *\n\t(1. - smoothstep (peak, end, t));\n}\n\nvoid fast_orthonormal_basis(in vec3 n , out vec3 f , out vec3 r)\n{\n\tfloat a = 1. / (1. + n.z);\n\tfloat b = -n.x*n.y*a;\n\tf = vec3(1. - n.x*n.x*a, b, -n.x);\n\tr = vec3(b, 1. - n.y*n.y*a, -n.y);\n}\n\n\nvoid intersect_sphere(\n\tin ray_t ray,\n\tin sphere_t sphere,\n\tinout hit_t  hit\n){\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tif (tca < 0.) return;\n\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return;\n\n\tfloat thc = sqrt(radius2 - d2);\n\tfloat t0 = tca - thc;\n\tfloat t1 = tca + thc;\n\n\tif (t0 < 0.) t0 = t1;\n\tif (t0 > hit.t) return;\n\n\tvec3 impact = ray.origin + ray.direction * t0;\n\n\thit.t = t0;\n\thit.material_id = sphere.material;\n\thit.origin = impact;\n\thit.normal = (impact - sphere.origin) / sphere.radius;\n}\n\n\n\nstruct volume_sampler_t {\n\tvec3 origin; \n\tvec3 pos; \n\tfloat height;\n\n\tfloat coeff_absorb;\n\tfloat T; \n\n\tvec3 C; \n\tfloat alpha;\n};\n\nvolume_sampler_t begin_volume(\n\tin vec3 origin,\n\tin float coeff_absorb\n){\n\tvolume_sampler_t v = volume_sampler_t (\n\t\torigin, origin, 0.,\n\t\tcoeff_absorb, 1.,\n\t\tvec3(0., 0., 0.), 0.\n\t);\n\treturn v;\n}\n\nfloat illuminate_volume(\n\tinout volume_sampler_t  vol,\n\tin vec3 V,\n\tin vec3 L\n);\n\nvoid integrate_volume(\n\tinout volume_sampler_t  vol,\n\tin vec3 V,\n\tin vec3 L,\n\tin float density,\n\tin float dt\n){\n\n\tfloat T_i = exp(-vol.coeff_absorb * density * dt);\n\tvol.T *= T_i;\n\tvol.C += vol.T * illuminate_volume(vol, V, L) * density * dt;\n\tvol.alpha += (1. - T_i) * (1. - vol.alpha);\n}\n\n\n\n\nfloat hash(\n\tin float n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise_iq(\n\tin vec3 x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n\n}\n\n\nfloat fbm(in vec3 pos, in float  lacunarity, in float  init_gain, in float gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 4; i++) \n\t{\n\t\t t += noise_iq(p) * H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\n\nsphere_t planet = sphere_t (\n\tvec3(0, 0, 0), 1., 0\n);\n\n\nvec3 background(\n\tin ray_t eye\n){\n\n\tvec3 sun_color = vec3(1., .9, .55);\n\tfloat sun_amount = dot(eye.direction, vec3(0, 0, 1));\n\n\tvec3 sky = mix(\n\t\tvec3(.0, .05, .2),\n\t\tvec3(.15, .3, .4),\n\t\t1.0 - eye.direction.y);\n\tsky += sun_color * min(pow(sun_amount, 30.0) * 5.0, 1.0);\n\tsky += sun_color * min(pow(sun_amount, 10.0) * .6, 1.0);\n\n\treturn sky;\n\n}\n\n\n\nvoid setup_camera(\n\tinout vec3  eye,\n\tinout vec3 look_at\n){\n\n\teye = vec3(0, 0, -2.5);\n\tlook_at = vec3(0, 0, 2);\n\n}\n\n\nfloat fbm_clouds(in vec3  pos, in float  lacunarity, in float  init_gain, in float  gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 4; i++) \n\t{\n\t\t t += (abs(noise_iq(p) * 2. - 1.)) * H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\n\n\n\nvolume_sampler_t cloud;//构造函数\n\nfloat illuminate_volume(\n\tinout volume_sampler_t  cloud,\n\tin vec3  V,\n\tin vec3  L\n){\n\treturn exp(cloud.height) / 0.055;\n}\n\nvoid clouds_map(\n\tinout volume_sampler_t  cloud,\n\tin float  t_step\n){\n\tfloat dens = fbm_clouds(\n\t\tcloud.pos * 3.2343 + vec3(0.35, 13.35, 2.67),2.0276, 0.5, 0.5);\n\n\n\n\tdens *= smoothstep(0.29475675, 0.29475675 + 0.0335 , dens);\n\n\tdens *= band(0.2, 0.35, 0.65, cloud.height);\n\n\tintegrate_volume(cloud,\n\t\tcloud.pos, cloud.pos, \n\t\tdens, t_step);\n}\n\nvoid clouds_march(\n\tin ray_t eye,\n\tinout volume_sampler_t  cloud,\n\tin float  max_travel,\n\tin mat3  rot\n){\n\tconst int steps = 75;\n\tconst float t_step = (.4 * 4.) / float(steps);\n\tfloat t = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tif (t > max_travel || cloud.alpha >= 1.) return;\n\t\t\t\n\t\tvec3 o = cloud.origin + t * eye.direction;\n\t\tcloud.pos = mul(rot, o - planet.origin);\n\n\t\tcloud.height = (length(cloud.pos) - planet.radius) / .4;\n\t\tt += t_step;\n\t\tclouds_map(cloud, t_step);\n\t}\n}\n\nvoid clouds_shadow_march(\n\tin vec3  dir,\n\tinout volume_sampler_t  cloud,\n\tin mat3  rot\n){\n\tconst int steps = 5;\n\tconst float t_step = .4 / float(steps);\n\tfloat t = 0.;\n\n\tfor (int i = 0; i < steps; i++) {\n\t\tvec3 o = cloud.origin + t * dir;\n\t\tcloud.pos = mul(rot, o - planet.origin);\n\n\t\tcloud.height = (length(cloud.pos) - planet.radius) / .4;\n\t\tt += t_step;\n\t\tclouds_map(cloud, t_step);\n\t}\n}\n\n\n\nfloat fbm_terr(in vec3  pos, in float  lacunarity, in float  init_gain, in float  gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 3; i++) \n\t{\n\t\t t += noise_iq(p)* H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\nfloat fbm_terr_r(in vec3  pos, in float  lacunarity, in float  init_gain, in float  gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 3; i++) \n\t{\n\t\t t += (1. - abs(noise_iq(p) * 2. - 1.))* H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\n\n\nfloat fbm_terr_normals(in vec3 pos, in float  lacunarity, in float  init_gain, in float  gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 7; i++) \n\t{\n\t\t t += noise_iq(p)* H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\n\n\nfloat fbm_terr_r_normals(in vec3  pos, in float lacunarity, in float init_gain, in float gain) \n{ \n\tvec3 p = pos; \n\tfloat H = init_gain; \n\tfloat t = 0.; \n\tfor (int i = 0; i < 7; i++) \n\t{\n\t\t t += (1. - abs(noise_iq(p) * 2. - 1.))* H; \n\t\t p *= lacunarity; \n\t\t H *= gain; \n\t} \n\t\t return t; \n}\n\n\n\nvec2 sdf_terrain_map(in vec3  pos)\n{\n\tfloat h0 = fbm_terr(pos * 2.0987, 2.0244, .454, .454);\n\tfloat n0 = smoothstep(.35, 1., h0);\n\n\tfloat h1 = fbm_terr_r(pos * 1.50987 + vec3(1.9489, 2.435, .5483), 2.0244, .454, .454);\n\tfloat n1 = smoothstep(.6, 1., h1);\n\t\n\tfloat n = n0 + n1;\n\t\n\treturn vec2(length(pos) - planet.radius - n * .4, n / .4);\n}\n\nvec2 sdf_terrain_map_detail( in vec3  pos)\n{\n\tfloat h0 = fbm_terr_normals(pos * 2.0987, 2.0244, .454, .454);\n\tfloat n0 = smoothstep(0.35, 1., h0);\n\n\tfloat h1 = fbm_terr_r_normals(pos * 1.50987 + vec3(1.9489, 2.435, .5483), 2.0244, .454, .454);\n\tfloat n1 = smoothstep(.6, 1., h1);\n\n\tfloat n = n0 + n1;\n\n\treturn vec2(length(pos) - planet.radius - n * .4, n / .4);\n}\n\nvec3 sdf_terrain_normal( in vec3  p)\n{\n\n\tvec3 dt = vec3(0.001, 0, 0);\n    vec3 nn = normalize(vec3(sdf_terrain_map_detail(p + dt.xzz).x - sdf_terrain_map_detail(p - dt.xzz).x , sdf_terrain_map_detail(p + dt.zxz).x - sdf_terrain_map_detail(p - dt.zxz).x , sdf_terrain_map_detail(p + dt.zzx).x - sdf_terrain_map_detail(p - dt.zzx).x));\n\treturn nn;\n\n}\n\n\nvec3 setup_lights(\n\t in vec3  L,\n\t in vec3  normal\n){\n\tvec3 diffuse = vec3(0, 0, 0);\n\n\n\tvec3 c_L = vec3(7, 5, 3);\n\tdiffuse += max(0., dot(L, normal)) * c_L;\n\n\n\tfloat hemi = clamp(.25 + .5 * normal.y, .0, 1.);\n\tdiffuse += hemi * vec3(.4, .6, .8) * .2;\n\n\n\tfloat amb = clamp(.12 + .8 * max(0., dot(-L, normal)), 0., 1.);\n\tdiffuse += amb * vec3(.4, .5, .6);\n\n\treturn diffuse;\n}\n\nvec3 illuminate(\n\t in vec3  pos,\n\t in vec3  eye,\n\t in mat3  local_xform,\n\t in vec2  df\n){\n\n\tfloat h = df.y;\n\n\n\tvec3 w_normal = normalize(pos);\n\n\n\tvec3 normal = sdf_terrain_normal(pos);\n\tfloat N = dot(normal, w_normal);\n\n\tfloat s = smoothstep(.4, 1., h);\n\tvec3 rock = mix(\n\t\tvec3(.080, .050, .030), vec3(.600, .600, .600),\n\t\tsmoothstep(1. - .3*s, 1. - .2*s, N));\n\n\tvec3 grass = mix(\n\t\tvec3(.086, .132, .018), rock,\n\t\tsmoothstep(0.211, 0.351, h));\n\t\t\n\tvec3 shoreline = mix(\n\t\tvec3(.153, .172, .121), grass,\n\t\tsmoothstep(0.17, 0.211, h));\n\n\tvec3 water = mix(\n\t\tvec3(.015, .110, .455) / 2., vec3(.015, .110, .455),\n\t\tsmoothstep(0., 0.05, h));\n\n\n\tvec3 L = mul(local_xform, normalize(vec3(1, 1, 0)));\n\tshoreline *= setup_lights(L, normal);\n\tvec3 ocean = setup_lights(L, w_normal) * water;\n\n\t\n\treturn mix(\n\t\tocean, shoreline,\n\t\tsmoothstep(0.05, 0.17, h));\n}\n\n\nvec3 render(\n\t in ray_t  eye,\n\t in vec3  point_cam\n){\n\tmat3 rot_y = rotate_around_y(27.);\n\tmat3 rot = mul(rotate_around_x( iTime * -12.), rot_y);\n\tmat3 rot_cloud = mul(rotate_around_x( iTime * 8.), rot_y);\n    if (iMouse.z > 0.) {\n        rot = rotate_around_y(-iMouse.x);\n        rot_cloud = rotate_around_y(-iMouse.x);\n        rot = mul(rot, rotate_around_x(iMouse.y));\n        rot_cloud = mul(rot_cloud, rotate_around_x(iMouse.y));\n    }\n\n\tsphere_t atmosphere = planet;\n\tatmosphere.radius += .4;\n\n\thit_t hit = no_hit;\n\tintersect_sphere(eye, atmosphere, hit);\n\tif (hit.material_id < 0) {\n\t\treturn background(eye);\n\t}\n\n\tfloat t = 0.;\n\tvec2 df = vec2(1, .4);\n\tvec3 pos;\n\tfloat max_cld_ray_dist = (.4 * 4.);\n\t\n\tfor (int i = 0; i < 120; i++) {\n\t\tif (t > (.4 * 4.)) break;\n\t\t\n\t\tvec3 o = hit.origin + t * eye.direction;\n\t\tpos = mul(rot, o - planet.origin);\n\n\t\tdf = sdf_terrain_map(pos);\n\n\t\tif (df.x < 0.005) {\n\t\t\tmax_cld_ray_dist = t;\n\t\t\tbreak;\n\t\t}\n\n\t\tt += df.x * .4567;\n\t}\n\n\n\tcloud = begin_volume(hit.origin, 30.034);\n\tclouds_march(eye, cloud, max_cld_ray_dist, rot_cloud);\n\n\t\n\tif (df.x < 0.005) {\n\t\tvec3 c_terr = illuminate(pos, eye.direction, rot, df);\n\t\tvec3 c_cld = cloud.C;\n\t\tfloat alpha = cloud.alpha;\n\t\tfloat shadow = 1.;\n\n\n\t\tpos = mul(transpose(rot), pos);\n\t\tcloud = begin_volume(pos, 30.034);\n\t\tvec3 local_up = normalize(pos);\n\t\tclouds_shadow_march(local_up, cloud, rot_cloud);\n\t\tshadow = mix(.7, 1., step(cloud.alpha, 0.33));\n\n\n\t\treturn mix(c_terr * shadow, c_cld, alpha);\n\t} else {\n\t\treturn mix(background(eye), cloud.C, cloud.alpha);\n\t}\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n\n\tvec2 aspect_ratio = vec2(iResolution.x / iResolution.y, 1);\n\n\tvec3 color = vec3(0, 0, 0);\n\n\tvec3 eye, look_at;\n\tsetup_camera(eye, look_at);\n\n\tvec2 point_ndc = fragCoord.xy / iResolution.xy;\n\n\tvec3 point_cam = vec3(\n\t\t(2.0 * point_ndc - 1.0) * aspect_ratio * tan(radians(30.)),\n\t\t-1.0);\n\n\tray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n\tcolor += render(ray, point_cam);\n\n\tfragColor = vec4(linear_to_srgb(color), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 389, 490, 490, 741], [796, 796, 839, 839, 971], [973, 973, 1021, 1021, 1168], [1170, 1170, 1220, 1220, 1367], [1369, 1369, 1418, 1418, 1565], [1568, 1568, 1607, 1607, 1701], [1702, 1702, 1741, 1741, 1830], [1832, 1832, 1891, 1891, 1970], [1972, 1972, 2047, 2047, 2123], [2125, 2125, 2191, 2191, 2316], [2319, 2319, 2398, 2398, 2918], [3052, 3052, 3125, 3125, 3248], [3332, 3332, 3443, 3443, 3621], [3626, 3626, 3652, 3652, 3689], [3691, 3691, 3720, 3720, 4083], [4086, 4086, 4169, 4169, 4340], [4399, 4399, 4432, 4432, 4745], [4749, 4749, 4808, 4808, 4863], [4866, 4866, 4958, 4958, 5146], [5174, 5190, 5274, 5274, 5311], [5313, 5313, 5382, 5382, 5655], [5657, 5657, 5762, 5762, 6136], [6138, 6138, 6227, 6227, 6528], [6532, 6532, 6622, 6622, 6792], [6794, 6794, 6886, 6886, 7078], [7082, 7082, 7179, 7179, 7349], [7353, 7353, 7450, 7450, 7642], [7646, 7646, 7682, 7682, 7986], [7988, 7988, 8032, 8032, 8351], [8353, 8353, 8391, 8391, 8701], [8704, 8704, 8757, 8757, 9077], [9079, 9079, 9168, 9168, 9929], [9932, 9932, 9985, 9985, 11479], [11484, 11484, 11534, 11534, 11961]], "test": "untested"}
{"id": "3lcSW8", "name": "(  )", "author": "rotmoset", "description": "Description 2", "tags": ["trig"], "likes": 2, "viewed": 83, "published": "Public", "date": "1580814471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 p1, vec2 p2)\n{\n\tfloat dx = p1.x - p2.x;\n    float dy = p1.y - p2.y;\n    return sqrt(dx*dx + dy*dy);\n}\n\nfloat circles(vec2 p, float spacing, float radius)\n{\n\tint overlaps = 0;\n    float results[4];\n    float mx = mod(p.x, spacing);\n    float my = mod(p.y, spacing);\n    float d = dist(vec2(mx,my), vec2(0.0,0.0));\n    \n    if (d < radius)\n    {\n        results[overlaps++] = smoothstep(0.0,1.0,max(1.0 - d / radius, 0.0));\n    }\n    \n    mx = mod(p.x, -spacing);\n    my = mod(p.y, spacing);\n    d = dist(vec2(mx,my), vec2(0.0,0.0));\n    \n    if (d < radius)\n    {\n        results[overlaps++] = smoothstep(0.0,1.0,max(1.0 - d / radius, 0.0));\n        \n    }\n    \n    mx = mod(p.x, spacing);\n    my = mod(p.y, -spacing);\n    d = dist(vec2(mx,my), vec2(0.0,0.0));\n    \n    if (d < radius)\n    {\n        results[overlaps++] = smoothstep(0.0,1.0,max(1.0 - d / radius, 0.0));\n    }\n    \n    mx = mod(p.x, -spacing);\n    my = mod(p.y, -spacing);\n    d = dist(vec2(mx,my), vec2(0.0,0.0));\n    \n    if (d < radius)\n    {\n        results[overlaps++] = smoothstep(0.0,1.0,max(1.0 - d / radius, 0.0));\n    }\n    \n    float result = 0.0;\n    \n    for (int i=0;i<overlaps;i++)\n    {\n     \tif (results[i] > result)\n            result = results[i];\n    }\n    \n    return min(result, 1.0);\n}\n\nvec3 colorD(float d)\n{\n    vec3 c1 = texture(iChannel0, vec2(d,sin(d * 4.0 + iTime / 5.0) + 1.0) / 16.0).rgb;\n    vec3 c2 = texture(iChannel1, vec2(d,sin(d * 4.0 + iTime / 5.0) + 1.0) / 16.0).rgb;\n    return mix(c1,c2, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = vec4(0.08,0.25,0.5,1.0);\n    \n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float spacing = 1.1 + sin(iTime / 14.0 + 3.0);\n    float radius = 1.2 + cos(iTime / 19.0 + 3.0);\n\t\n    float d = circles(uv, spacing,radius);\n    if (d > 0.01)\n    {\n        fragColor.rgb = mix(fragColor.rgb, colorD(d), d);\n    }\n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 117], [119, 119, 171, 171, 1289], [1291, 1291, 1313, 1313, 1517], [1519, 1519, 1576, 1576, 1992]], "test": "untested"}
{"id": "3lcSWn", "name": "Motion Binding", "author": "anothergomes", "description": "Based on:\nhttps://michaelbach.de/ot/mot-motionBinding/index.html\n\nNeeds some smoothing...", "tags": ["illusion", "study"], "likes": 3, "viewed": 47, "published": "Public", "date": "1580699381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trying to replicate this effect:\n// https://twitter.com/Rainmaker1973/status/1223984952255176704\n\nfloat rectangle(vec2 uv, vec2 pos, vec2 size)\n{\n    size *= 0.5;\n    vec2 r = abs(uv - pos - size) - size;\n    \n    return step(max(r.x,r.y), .0);\n}\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y * .5;\n    uv *= rotate(iTime*.1);\n    \n    vec3 c = vec3(0);\n    float y = sin(iTime*3.)*.05;\n    float x = cos(iTime*3.)*.05;\n\n    float lines = rectangle(uv, vec2(-.15, .2+y), vec2(.3,.01));\n    lines += rectangle(uv, vec2(-.15, -.2+y), vec2(.3,.01));\n    lines += rectangle(uv, vec2(-.2+x, -.15), vec2(.01,.3));\n    lines += rectangle(uv, vec2(.19+x, -.15), vec2(.01,.3));\n    \n    float occluders = rectangle(uv, vec2(-.3, .1), vec2(.2,.2));\n    occluders += rectangle(uv, vec2(.1, .1), vec2(.2,.2));\n    occluders += rectangle(uv, vec2(-.3, -.3), vec2(.2,.2));\n    occluders += rectangle(uv, vec2(.1, -.3), vec2(.2,.2));\n\n    occluders = abs(sin(occluders*iTime*.2)*1.3);\n    c += lines + occluders;\n\n    fragColor = vec4(vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 148, 148, 249], [251, 251, 277, 277, 362], [364, 364, 421, 421, 1227]], "test": "untested"}
{"id": "3lcXDj", "name": "Monochrome Voronoi", "author": "taso69", "description": "Voronoi function from https://www.shadertoy.com/view/4sl3Dr", "tags": ["2d", "voronoi"], "likes": 3, "viewed": 111, "published": "Public", "date": "1582017731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash22( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233))) * vec2(245.587,437.585));\n}\n\nvec3 hsv2rgb(float h, float s, float v){\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = fragCoord.xy*2.0 - iResolution.xy;\n    p /= min(iResolution.x,iResolution.y);\n\n    p *= 3.0;\n    vec2 uv = fract(p) - 0.5;\n    vec2 id = floor(p);\n\n    float minDist = 100.0;\n    vec2 cid = vec2(0.0);\n    vec3 col = vec3(0.0);\n    vec2 res = vec2(8.0);\n    for(float i = -1.; i <= 1.; i++){\n        for(float j = -1.; j <= 1.; j++){\n            vec2 o = vec2(i,j);\n            vec2 n = hash22(id + o);\n            vec2 pos = o + sin(n*iTime)*0.3;\n            \n            float d = abs(uv.x - pos.x) + abs(uv.y - pos.y);\n           \n            if(d < res.x){\n                res.y = res.x;\n                res.x = d;\n                cid = id + o;\n            }else if(d < res.y){\n                res.y = d;\n                cid = id+o;\n            }  \n\n        } \n    }\n    minDist  = res.y -res.x;\n    //if(minDist < 0.3) minDist = smoothstep(0.3, 1., 1.-minDist)*.03;\n    col += vec3(minDist); \n    col += vec3(abs(sin(minDist*(10.0+5.0*cos(iTime)))));\n    float m = step(abs(sin(minDist*(10.0+5.0*cos(iTime)))),1.0);\n    //col += m*vec3(1.0,0.0,0.0);\n    //col += vec3(0.0,uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 101], [103, 103, 143, 143, 222], [224, 224, 280, 280, 1407]], "test": "untested"}
{"id": "3lcXR2", "name": "Apollonian-II-v3", "author": "jorge2017a1", "description": "Apollonian-II-v3", "tags": ["apollonianiiv3"], "likes": 2, "viewed": 86, "published": "Public", "date": "1581296096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map(vec3 ppp)\n{\n    vec3 p;\n    p=ppp;\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime*0.5;\n    \n    // Loop counter and variables.\n    float i=0., s,k;\n        s = 1.;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    //while(i++<6.) p *= k = 1.5/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n    \n    vec3 pp;\n    \n    while(i++<6.)\n     {\n      \n       \n\t\t\n         pp= mod(p - 1., 2.) - 1.;\n         p =pp;\n         \n         p*=dot(p,p);\n             \n         k = 1.0/dot(pp, p);\n         p *= k ;\n         s *= k;\n         \n     }\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n    \n    //return length(p)/s - .01; \n    \n    //return  vec3( length(p)/s - .01,k,s+k); \n    \n    float a1, a2,a3;\n    \n    a1= dot(p.xy,p.xy);\n    a2= dot(p.yz,p.yz);\n    a3= dot(p.zx,p.zx);\n    \n    //float d1 = sqrt( min( min( a1, a2 ), a3 ) ) - 0.02;\n    float d1 = sqrt( min( max( a1, a2 ), a3 ) ) - 0.012;\n    \n    \n    float d2 = abs(p.y);\n    float dmi = d2;\n    //float adr = 0.7*floor((0.5*p.y+0.5)*8.0);  //original\n    float adr = 0.7*fract((0.5*p.y+0.5)*8.0);\n    \n    \n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/s, adr, k*0.5 );\n    \n    \n}\n\n\n\nvec3 mapv( vec3 p )\n{\n\tfloat scale = 1.0;\n    \n    float orb = 10000.0;\n\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n        p -= sign(p)*0.054; // trick\n        \n        float r2 = dot(p,p);\n\t\t//float k = 0.95/r2;\n        float k = 0.985/r2;\n        \n\t\tp     *= k;\n\t\tscale *= k;\n\n        orb = min( orb, r2);\n\t}\n\n    //float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;\n    \n    float a1, a2,a3;\n    \n    a1= dot(p.xy,p.xy);\n    a2= dot(p.yz,p.yz);\n    a3= dot(p.zx,p.zx);\n    \n    //float d1 = sqrt( min( min( a1, a2 ), a3 ) ) - 0.02;\n    float d1 = sqrt( min( max( a1, a2 ), a3 ) ) - 0.012;\n    \n    \n    float d2 = abs(p.y);\n    float dmi = d2;\n    //float adr = 0.7*floor((0.5*p.y+0.5)*8.0);  //original\n    float adr = 0.7*fract((0.5*p.y+0.5)*8.0);\n    \n    \n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\n\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        //ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n        \n        ao += clamp( map( pos + nor*0.1+h  ).x*2.0, 0.0, 1.0 );\n        \n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n   // vec3 w = vec3(1.0);\n    \n   \n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n   \n   /* \n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) ;\n    \n */\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        //col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        //vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        \n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        \n        \n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 201, 221, 221, 1974], [1978, 1978, 1999, 1999, 2914], [2918, 2918, 2956, 2956, 3290], [3292, 3292, 3336, 3336, 3591], [3593, 3593, 3629, 3629, 3893], [3895, 3895, 3937, 3937, 4315], [4318, 4318, 4378, 4378, 4750], [4752, 4752, 4791, 4791, 5535], [5537, 5537, 5594, 5594, 6876], [6878, 6878, 6972, 6972, 7079]], "test": "untested"}
{"id": "3lcXWj", "name": "Voronoi Triangulation*", "author": "wyatt", "description": "How my recent simulations work.", "tags": ["voronoi", "triangulation"], "likes": 14, "viewed": 326, "published": "Public API", "date": "1581661774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define O 3.\nvec2 hash22(vec2 p) // Dave H\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 cell (vec2 u) {\n\tvec2 V = floor(u*O+0.5)/O;\n    vec2 h = hash22(V);\n    return V + h.x*vec2(cos(6.2*h.y+iTime),sin(6.2*h.y+iTime))/O;\n}\nfloat pie (vec2 p, vec2 a, vec2 b) {\n\tvec2 m = 0.5*(a+b); // midpoint\n    //if (length(a-b)<1e-3) return 1e3; // ignore self\n\treturn abs(dot(p-m,b-m)/dot(b-m,b-m)); // pojection\n}\nfloat line (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn (length(p-a-(b-a)*i));\n}\nvec2 cc (vec2 a, vec2 b, vec2 c) {\n    vec2 ab = 0.5*(a+b), ac = 0.5*(a+c);\n\tfloat m1 = (a.x-b.x)/(b.y-a.y), m2 = (a.x-c.x)/(c.y-a.y);\n    float b1 = ab.y-m1*ab.x, b2 = ac.y-m2*ac.x;\n    float x = (b1-b2)/(m2-m1);\n    return vec2(x,m1*x+b1);\n}\nfloat sg (vec2 p, vec2 a, vec2 b) {\n    float i = clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.);\n\treturn length(p-a-(b-a)*i);\n}\nfloat tri (vec2 U, vec2 a, vec2 aa, vec2 aaa) {\n    vec2 m = cc(a,aa,aaa);\n    float v = length(a-m), w = length(U-m);\n    return w-v;\n}\nvoid mainImage (out vec4 Q, vec2 U) {\n\tU = 2.*(U-0.5*R)/R.y;\n    vec2 V = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (length(c-U) < length(V-U))\n            V=c;\n    }\n    vec2 W = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (pie(U,V,c) < pie(U,V,W))\n            W=c;\n    }\n    vec2 Z = vec2(1e3);\n    for (int x = -3; x <= 3; x++)\n    for (int y = -3; y <= 3; y++) {\n\t\tvec2 c = cell(U+vec2(x,y)/O);\n        if (tri(U,V,W,c) < tri(U,V,W,Z))\n            Z=c;\n    }\n    \n    Q = 0.5+0.3*sin(30.*(tri(U,V,W,Z))+vec4(1,2,3,4));\n\tQ *= smoothstep(0.01,0.02,pie(U,W,V)*length(W-V));\n    Q += vec4(.5)*smoothstep(0.03,0.00,min(line(U,W,V),min(line(U,W,Z),line(U,V,Z))));\n    Q *= smoothstep(0.03,0.04,length(U-V));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 69, 69, 203], [204, 204, 224, 224, 344], [345, 345, 381, 381, 524], [525, 525, 562, 562, 649], [650, 650, 684, 684, 893], [894, 894, 929, 929, 1014], [1015, 1015, 1062, 1062, 1151], [1152, 1152, 1189, 1189, 2021]], "test": "untested"}
{"id": "3ldSRj", "name": "Brickwork patterns", "author": "mdv", "description": "Support for different patterns of Bricks.  -  Same code as my 'Bricks 2'   but with support for different layouts\n\nSet  'BRICK_PATTERN'  in code to compile different patterns.", "tags": ["procedural", "brick"], "likes": 4, "viewed": 98, "published": "Public", "date": "1581355185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------------------------------------------------------------------//  Brick wall with self-shadowing.\n//\n//  set BRICK_PATTERN   to select the pattern to compile  ( or add more patterns...)\n//\n//  The surface is seen as an array of tesselating rectangular cells. \n//  Each cell has a series of entries. Each entry represents a single brick (0,0)  to  shiftAndSizes[entry].zw  in the cell corner. \n//  shiftAndSizes[entry].xy  has the offset of the cell, for that entry  (cells effectively overlap per entry).\n//\n//  This enables the definition of different brick patterns.\n//  \n//  \n//  CELLSIZEU and CELLSIZEV are set for the pattern.  If we add to these, we space the cells out.\n//\n//  All code, feel free to use, abuse and improve...\n//\n//  'BRICK_PATTERN'   set this for a few simple patterns I set up - 0,1,2,3.  \n//   \n//--------------------------------------------------------------------------------------------------------------------------------------\n\n#define  USE_SHADOW \n#define  BRICK_PATTERN 3\n\n// LIGHT_DIRECTION:   y  is  negative as coming from ABOVE.\n//                    (  y close to 0  has numerical stability issues for shadow  (ie. light straight down).\n//                      producing sparkle on brick edges. )\n\nconst vec3   LIGHT_DIRECTION =  normalize(vec3(  0.917,  -0.62,  -0.4 ));  \nconst float  LIGHT_AMBIENT_INTENSITY = 0.5f;   \n\n // TODO:   have brick sizes per 'shiftAndSizes' entry.  More than one entry can have the same 'V' offset so should be easy\n //         to have mixed size bricks on one row.  This would make it possible to do herringbone etc.  \n \n#if BRICK_PATTERN == 0\t\t// regular brick\n\n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\n\tconst int maxLayers = 2;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,     BRICK_ULEN, BRICK_VLEN ),  \n      vec4( BRICK_ULEN + BRICK_UGAP, 0.5 * (BRICK_VLEN + BRICK_VGAP ),  BRICK_ULEN, BRICK_VLEN ) \n\t);\n  \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + 0.001;\n\tconst float  DepthOfBrick = 0.04439;\n\n#elif BRICK_PATTERN == 1      //  short and long alternate\n  \n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\tconst float BRICK_VLEN_SHORT = 0.11 ;\n\n\n\tconst float dispIn = (BRICK_VGAP + BRICK_VLEN_SHORT) * 0.5 ; \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,   BRICK_ULEN, BRICK_VLEN_SHORT), \n      vec4( 0, BRICK_VLEN_SHORT + BRICK_VGAP,  BRICK_ULEN, BRICK_VLEN ), \n      vec4( BRICK_ULEN + BRICK_UGAP,  dispIn,  BRICK_ULEN, BRICK_VLEN ) ,\n      vec4( BRICK_ULEN + BRICK_UGAP, dispIn + BRICK_VLEN  + BRICK_VGAP,    BRICK_ULEN, BRICK_VLEN_SHORT ) \n\t);\n \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + (BRICK_VLEN_SHORT + BRICK_VGAP ) + 0.001;\n\tconst float  DepthOfBrick = 0.04439;\n\n#elif BRICK_PATTERN == 2        // square cycle\n  \n\tconst float SCL = 0.8;\t// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n    \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0,                    BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ) \n\t);\n \n\tconst float CELLSIZEU  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001;\n\tconst float CELLSIZEV  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001; \n\tconst float  DepthOfBrick = 0.04439; \n\n#elif BRICK_PATTERN == 3        // square cycle staggered\n  \n\tconst float SCL = 0.65;// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n  \n\tconst float staggerU = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD);\n\tconst float staggerV = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD) * 0.5;\n\n\tconst int maxLayers = 8;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0, BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ),\n        \n      vec4( staggerU, staggerV, BRICK_SC, BRICK_SA   ), \n      vec4( staggerU, BRICK_SA + BRICK_SB + staggerV, BRICK_SA, BRICK_SC  ) , \n      vec4( staggerU + BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA + staggerV,   BRICK_SC, BRICK_SA  ) ,  \n      vec4( staggerU + BRICK_SC + BRICK_SB, staggerV,  BRICK_SA, BRICK_SC) \n\t);\n \n\tconst float CELLSIZEU  =  2.0 * (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\tconst float CELLSIZEV  =  (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\tconst float  DepthOfBrick = 0.035; \n #endif\n\n\nconst float  y0 =  -0.43;  \n\nconst float  xLo =  - 1.2; \nconst float  xHi =    1.56;\nconst float  zLo =    0.48;  //-2.0; \nconst float  zHi =    2.22;\n\n\n\t// colors per face. For testing\n\nconst vec3 colr0[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(1,0.5,0),  \n\tvec3(0.2,0.3,0.4),  \n\tvec3(1,0,0),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n); \nconst vec3 colr1[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(0.85,0.5 ,0.44 ), \n    vec3(1,0.5,0),  \n\tvec3(0.8,0.5,0.2),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n);   \n\nfloat  RECIP_CELLSIZEU = 1.0 / CELLSIZEU;\nfloat  RECIP_CELLSIZEV = 1.0 / CELLSIZEV;  \n\nconst float  y1 =  y0 - DepthOfBrick;\n\nconst vec4 boundsA = vec4(zLo, -zHi, xLo, -xHi );\nconst vec4 boundsB = vec4(-1.0, 1.0, -1.0, 1.0);\n\n\t// FPT limits, needed for ensuring numerical stability as ray axes approach alignment with the world space.\n    //  https://en.wikipedia.org/wiki/IEEE_754-1985\n\nconst float SMALLEST_POSITIVE_IEEE754_FPT =  intBitsToFloat(1); // ±2^−23 × 2^−126  are closest representable numbers to 0\nconst float BIGGEST_IEEE754_FPT = \tintBitsToFloat(0x7F7FFFFF);  \n\n// Fed up with typing  'clamp(..., 0.0, 1.0)'   when we know it will go to a saturate and\n// probably get it for free on the GPU.\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0.0, 1.0);\n} \nvec4 saturate(vec4 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat random2(vec2 st)\n{\n    // Quick random-ish used for determining a random scalar for a brick (for color, etc.)\n    //  modded from hash function at:    https://www.shadertoy.com/view/XlXcW4\n    //  ( taken one xor line,  good enough for this test! )\n     \n    uint  a = floatBitsToUint(st.x);\n    uint  b = floatBitsToUint(st.y);\n    \n    float h = float(((a>>8U)^b)*1103515245U) / float(0xffffffffU); \n    return h;              \n} \n\t\n\nint BrickWall( in vec3 ro, in vec3 rd,  out bool inShadow, out vec3 normal,  out vec2 idx,  inout vec3 posn)  \n{  \n    inShadow = false;\n    normal = vec3(0.0, -1.0, 0.0);\n    idx = vec2(0);\n    posn = vec3(0); \n     \n    float t0 =  ( -ro.y + y0) *  rd.y; \n    float t1 =  ( -ro.y + y1) *  rd.y;\n    \n    float sum = t0 + t1;\n    t0 = min(t0,t1);\n    \n    if( t0 < 0.0 )     // early out if intersection is behind camera\n        return 0;\t\t\n    \n    t1 = sum - t0;  \t\t\n    vec3  rd2 = rd * rd;  \n    vec3  intersect0 = ro * rd2.y + t0 * rd;\n    \n \t// NOTE:  if rd.y == 0  (ie. ray is coplanar, then  intersect0 == 0, and the bounds test passes, (if we had used the\n    // nieve approach, then  intersect0 would approach infinity as rd.y approaches 0, because we would be using 1/rd.y - \n    // but we multiply up by rd.y^2  to avoid divisions AND maintain the inequality tests.\n    //  (In the case of rd2.y very close to 0, then early out). \n    \n    if( rd2.y <  SMALLEST_POSITIVE_IEEE754_FPT )   // consider ray as coplanar,  rd2.y = y^2 so always +ve \n        return 0;\n    \n    \n    if( dot(saturate( boundsA * rd2.y + intersect0.zzxx * boundsB ), vec4(1.0)) !=  0.0 )\n    {\n         return 0;   \n    }\n    \n    float bestFaceCode = 4.0;\t\t// Default to Mortar\n    \n    float  recip_rd2y = 1.0 / rd2.y;    \n    intersect0 *= recip_rd2y;    // We have already checked that rd2.y >=  SMALLEST_POSITIVE_IEEE754_FPT,  above\n    \n    // Early out on brick face, no need to test anything else if ray intersects the main face of a brick. \n    \n    for( int layer = 0; layer < maxLayers; ++layer)\n    {\n        vec4 ss = shiftAndSizes[layer]; \n    \n        vec2 fufv   = floor((intersect0.xz - ss.xy ) * vec2(RECIP_CELLSIZEU, RECIP_CELLSIZEV)); \n    \tvec2 cellUV = fufv  * vec2(CELLSIZEU, CELLSIZEV) + ss.xy ; \n        \n        vec2 a = saturate( intersect0.xz - cellUV.xy -  ss.zw );\n        if ((a.x + a.y) == 0.0)  \n    \t{\n       \t \t // brick face \n            idx =  fufv + float(layer) ; \n            posn = intersect0;\n            return 3;\n    \t}\n    }\n        \n    // Deal with sides and ends of brick.\n     \n    float rdxrdz = rd.x * rd.z;\n    float rdxrdz2 = rdxrdz * rdxrdz; \n    vec2 C01 =  rdxrdz * rd.zx; \n    vec2  C4  = vec2(y0,y1) * rdxrdz2 ;  \n    \n    \n    // +/- 1 depending on half-space for each axis X, Z\n    \n    vec2 hsPlusMinus =  vec2 (  ( rd.x >= 0.0 ) ? 1.0 : -1.0 ,  ( rd.z >= 0.0 ) ? 1.0 : -1.0 );    \n    \n    float bestT = BIGGEST_IEEE754_FPT;  \n      \n    vec2  F01 = vec2(CELLSIZEU, CELLSIZEV) * C01 ; \n    vec2  D01 = -(vec2(CELLSIZEU,CELLSIZEV) + ro.xz ) * C01; \n    \n    float bestSy = 0.0;\n    vec2  fl2 =  vec2(CELLSIZEU, CELLSIZEV); \n    \n    float S1 =  ro.y * rdxrdz2;\n    vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    if( C01.x < 0.0 )\n        vecE0E1.xy = vec2(1.0, 0.0);\n    if( C01.y < 0.0 )\n        vecE0E1.zw = vec2(1.0, 0.0); \n    \n    vec4 C5 = vecE0E1 * C01.xxyy;\n    \n    for( int layer = 0; layer < maxLayers; ++layer)\n    {\n        vec4  ss = shiftAndSizes[layer]; \n         \n        vec4 sortOffset = C5 * ss.zzww; \n        \n        vec2 fufv = floor((intersect0.xz - ss.xy ) * vec2(RECIP_CELLSIZEU, RECIP_CELLSIZEV));  \n   \n    \tvec2 cellUV = fufv * vec2(CELLSIZEU, CELLSIZEV) + ss.xy ;\n       \n        vec2 currentIdx =  fufv  +  fl2 ;  \n        float dIdxV = currentIdx.y;\n          \n        vec2 dudvYstart = cellUV.y * C01.y + D01.y + sortOffset.zw; \n        \n        vec4 t;\n        t.xy = cellUV.x * C01.x + D01.x  + sortOffset.xy; \n        for( int u = 0; u < 3; u++ )\n        {  \n            currentIdx.y = dIdxV ;\n            currentIdx.x++; \n            t.zw  = dudvYstart;       \n            for(int v = 0; v  < 3; v++ )\n            {\n                //  s is an associated value for tv,  so that we know after ordering  tv, whether a line segment\n                //  crosses / intersects a cell   ( when s.x != s.y ).\n                               \n                currentIdx.y++;\n                \n        \t\tvec4 tv = t;\n                vec3 s =  vec3(0.0,0.0,1.0);\n                 \n                if(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }  \n      \n    \t\t\tfloat ds = s.x - s.y;\n                float p =  S1 + tv.y * rd.y;  \n                  \n    \t\t\tif( (  \n                     saturate(1.0 - ds*ds) + \n                     saturate( tv.y - bestT) +  \n                     saturate( p  - C4.x ) +  \n                     saturate( C4.y - p  )) == 0.0)\n            \t\t{  \n                  \t\tbestT = tv.y; \n                        bestSy =  s.y; \n                        idx =  currentIdx;    \n            \t\t}\n            \n                 t.zw += F01.y;\n            }\n            t.xy += F01.x; \n        }\n        fl2 += float(maxLayers); \n    } \n    \n    if( bestT != BIGGEST_IEEE754_FPT )\n    {\n\t\tnormal = vec3( hsPlusMinus.x * (1.0 -bestSy), 0.0, hsPlusMinus.y * bestSy  ) ;  \n        bestFaceCode = bestSy + 1.0;  \n    }\n\n    // Trim edge    \n    \n   if (bestFaceCode != 4.0)\n   {  \n        rd2.y = rdxrdz2;\n        t1 = bestT; \n   }\n    \n   vec3  coord = ro  * rd2.y + t1 * rd;  // ray intersection point multiplied by rd2.y,  ie. ray-direction 'y' squared\n    \n   if( dot(saturate( boundsA * rd2.y + coord.zzxx * boundsB ), vec4(1.0)) !=  0.0 )\n   {\n        return 0;   \n   } \n    \n   #if defined(USE_SHADOW)\n   \n    // If light source is from behind wall,  or behind a brick end or side, then always in shadow..\n    \n    bool  shadow = ((saturate( LIGHT_DIRECTION.y )  + saturate( -dot( normal.xz, LIGHT_DIRECTION.xz ))  ) != 0.0);\n    \n     // Otherwise examine adjacent cells for projecting the eye ray intersection point along the reverse light direction\n     // (Since all edges are vertical in the plane, we only need to detect the XZ ray crossing the brick area of a cell.\n    \n    if( !shadow)\n    { \n         float t0 =  ( y0 * rd2.y -coord.y ) ; \n         intersect0.xz = coord.xz - t0 * LIGHT_DIRECTION.xz; \n        \n         float rdxrdz = LIGHT_DIRECTION.x * LIGHT_DIRECTION.z; \n    \t vec2  C01    =  -rdxrdz * vec2( LIGHT_DIRECTION.z, LIGHT_DIRECTION.x); \n         float rdxrdz2   = rdxrdz * rdxrdz * rd2.y; \n         float G1 = rdxrdz2 * rd2.y;\n    \t vec2  C4  = vec2(y0,y1) * G1 ; \n     \n   \t     vec2 hsPlusMinus =  vec2 (  ( LIGHT_DIRECTION.x <= 0.0 ) ? 1.0 : -1.0 ,  ( LIGHT_DIRECTION.z <= 0.0 ) ? 1.0 : -1.0 );   \n      \n    \t vec2  D01 = -(vec2(CELLSIZEU, CELLSIZEV)  * rd2.y + coord.xz) * C01; \n         vec3  G0 = -LIGHT_DIRECTION * rd2.y;   //-ve to allow + in loop,  easier to mad\n         vec4  S0 = boundsA * G1;\n         vec3  S1 = coord * rdxrdz2;\n          \n        vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    \tif( C01.x < 0.0 )\n        \tvecE0E1.xy = vec2(1.0, 0.0);\n    \tif( C01.y < 0.0 )\n        \tvecE0E1.zw = vec2(1.0, 0.0); \n        \n         vec2  C23 = C01  * rd2.y;  \n    \t vec2  F10 = vec2(CELLSIZEU, CELLSIZEV) * C23 ;  \n         vec4  C5 = C23.xxyy * vecE0E1; \n        \n         intersect0 /= rd2.y;\n    \t for( int layer = 0; layer < maxLayers; ++layer)\n    \t {\n        \tvec4 ss = shiftAndSizes[layer];\n       \t\t  \n            vec4 sortOffset = C5 * ss.zzww;\n    \t\tfloat fu = (intersect0.x - ss.x ) * RECIP_CELLSIZEU;\n    \t\tfloat fv = (intersect0.z - ss.y ) * RECIP_CELLSIZEV; \n    \n    \t\tfloat cellU = floor(fu ) * CELLSIZEU + ss.x ;\n    \t\tfloat cellV = floor(fv ) * CELLSIZEV + ss.y ; \n            \n            vec2 dudvYstart = cellV * C23.y + D01.y + sortOffset.zw;\n\n            vec4 t ; \n            t.xy =  cellU * C23.x + D01.x  + sortOffset.xy;\n        \tfor( int u = 0; u < 3; u++ )\n        \t{   \n                t.zw  = dudvYstart; \n               \tfor(int v = 0; v  < 3; v++ )\n            \t{  \n        \t\t\tvec4 tv = t;  //  tv.x <=  tv.y,    tv.z <= tv.w\n                \tvec3 s =  vec3(0.0,0.0,1.0);\n                   \n                \tif(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }    \n                    \n                    float ds = s.x - s.y;\n                    vec3  p  = S1 + tv.y * G0;   \n                    vec4  a  = saturate( S0 + p.zzxx * boundsB ); \n                    \n                    // could break out as soon as shadow is true.  probably worth doing (wavefronts ? )\n                    \n                    shadow = shadow ||\n    \t\t\t\t   ( \n                         (saturate(1.0 - ds*ds) + \n                          saturate( -tv.y ) +  \n       \t\t\t\t      saturate(  p.y - C4.x ) +\n                          saturate(  C4.y - p.y ) +\n                          a.x + a.y + a.z + a.w               // using dot(a,vec4(1.0)) is not good on GCN chips.\n                         ) == 0.0\n                       ) ;\n                     \n                \tt.zw += F10.y;\n            \t}   \n            \tt.xy += F10.x;\n        \t} \n    \t}  \n    } \n    inShadow = shadow;\n    \n   #endif\n     \n   posn = coord / rd2.y;\n    \n   return int(bestFaceCode);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) *  vec2(iResolution.x/iResolution.y, 1.0);\n    \n\tvec3 ro;\n    ro.y = -0.2;\n  \n    vec2 maxSpan = vec2( xHi - xLo, zHi - zLo ) * 0.4; \n    \n    float pt = iTime;\n    ro.x = xLo + (  xHi - xLo) * 0.5 + sin(pt * 0.2) * maxSpan.x;\n    ro.z = zLo + (  zHi - zLo) * 0.5 + cos(pt * 0.2) * maxSpan.y;\n    float theta = 1.4 + iMouse.x * 0.01;\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 rotn;\n    rotn[0][0] = c;\n    rotn[0][1] = -s;\n    rotn[1][0] =  s;\n    rotn[1][1] = c;\n    \n    vec3 dirn = vec3(uv,1.0) ;\n    dirn.xz *= rotn; \n    \n    \t// Now do something more interesting....\n    bool inShadow = false;\n    vec3 normal = vec3(0); \n    vec3 posn = vec3(0); \n    \n    vec2 idx;   \n       \n    int faceCode = BrickWall( ro, normalize(dirn), inShadow, normal,  idx, posn);   \n        \n    float idCoeff = random2( idx.xy *  1.2341 ); \n    \n    \t// Apply the color,  simple dp lighting and darken if the point is in shadow,\n    \n    vec4  faceColor  =  vec4(  mix(colr0[faceCode], colr1[faceCode],idCoeff) , 1.0 );  \n    \t\t\t\t\t \n    if( faceCode != 0)\t\t// Do not light if not on wall surface \n    {\n   \t \tfloat intensity =  mix( LIGHT_AMBIENT_INTENSITY, 1.0, clamp(dot(normal, LIGHT_DIRECTION), 0.0, 1.0) ) ;\n   \t \tfaceColor.xyz *= intensity;\n    \tif(inShadow)\n    \t{\n       \t \tfaceColor.xyz *= 0.6;   \n   \t\t} \n    }  \n       \n    fragColor = faceColor; \n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6359, 6490, 6515, 6515, 6548], [6549, 6549, 6572, 6572, 6605], [6606, 6606, 6629, 6629, 6662], [6664, 6664, 6687, 6687, 6720], [6722, 6722, 6746, 6976, 7159], [7164, 7164, 7276, 7276, 16208], [16211, 16211, 16268, 16268, 17698]], "test": "untested"}
{"id": "3ldSW7", "name": "SH Naive solver", "author": "rubbish", "description": "Simple visualization of SH based on previous works, extended max band to 128 by refactoring naive implementation", "tags": ["solver", "spherical", "harmonics", "sh", "factorials"], "likes": 2, "viewed": 84, "published": "Public", "date": "1581095080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original source:  https://www.shadertoy.com/view/lsfXWH\n// \t--Created by inigo quilez - iq/2013\n//  --License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on Spherical harmonics solver by TimoKinnunen\n//  --https://www.shadertoy.com/view/3dKGWG\n// \n// Changes: \n//  - Turned back to the simplest naive equation, but surprisingly effective \n//  - Used approximated factorial to evaluate ALP\n//  - Support at most band 64 for full band visualisation (l=64, m=[-64, 64])\n//\t          at most band 128, order 0 for highest record.\n//    Seems factorial died after around 128!, probably caused by invalid exp()\n\nprecision highp float;\n\n// band\n#define L 32\n\n// order\n#define M 32\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n#define AUTOMATIC\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// control step length of marching\n#define MARCH_STEP\t\t\t\t0.05\n// control maximum marching depth\n#define MARCH_MAX_ITERATION     600\n\n// upper & lower bounds used by factorial approximation\n#define a0 0.833333333333333333   //            1 / 12\n#define a1 0.033333333333333333   //            1 / 30\n#define a2 0.252380952380952381   //           53 / 210\n#define a3 0.525606469002695418   //          195 / 371\n#define a4 1.011523068126841712   //        22999 / 22737\n#define a5 1.517473649153287398   //     29944523 / 19733142\n#define a6 2.269488974204959961   // 109535241009 / 48264275462\n#define SQRT2 1.4142135623 \t\t  // sqrt(2)\n#define INV_4PI 0.0795774715 \t  // 1 / (4 * pi)\n#define LOG_2PI 1.8378770664      // log(2 * pi)\n\n// look up table for first few factorials due to \n// limited precision of approximated factorial when input x is small\nconst float factorialLUT[11] = float[11](\n\t1.0,\n    1.0,\n    2.0,\n    6.0,\n    24.0,\n    120.0,\n    720.0,\n    5040.0,\n    40320.0,\n    362880.0,\n    3628800.0\n);\n\n// Stieltjes's continued fraction approximation based on: \n// \t\thttp://www.luschny.de/math/factorial/approx/SimpleCases.html\nfloat FactorialStieltjesNoExp(in int x)\n{\n\tif(x < 11) { return log(factorialLUT[x]); }\n\tfloat  Z = float(x) + 1.0;\n\treturn 0.5 * LOG_2PI + (Z - 0.5) * log(Z) - Z + \n\t\ta0/(Z + a1/(Z + a2/(Z + a3/(Z + a4/(Z + a5/(Z + a6/Z))))));\n}\n\n// K(l, m) * P(l, m)\n// Based on Spherical Harmonic Lighting: The Gritty Details by Robin Green, 2003\n//    http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\nfloat KP(in int l, in int m, in float x)\n{\n\tfloat f = 0.0;\n\tif(m > 0)\n\t{\n        float t1 = FactorialStieltjesNoExp(l - m);\n        float t2 = FactorialStieltjesNoExp(2 * m - 1);\n        float t3 = FactorialStieltjesNoExp(l + m);\n        float t4 = FactorialStieltjesNoExp(m - 1);\n        \n        f = pow(2.0, float(2 - 2 * m)) * exp(t1 + 2.0 * t2 - t3 - 2.0 * t4);\n\t}\n\telse\n\t{\n\t\tf = 1.0;\n\t}\n\t\n\t// kp <=> K(l, m) * (2m - 1)!!\n\tfloat kp = sqrt((2.0 * float(l) + 1.0) * INV_4PI * f); \n\t// (-1)^(m)\n\tfloat fact = 1.0 - 2.0 * mod(float(m), 2.0);\n\tfloat Pmm = fact * kp * pow(1.0 - x * x, float(m) / 2.0);\n    \n\tif(l == m){ return Pmm; }\n\n\tfloat Pmmp1 = x * (2.0 * float(m) + 1.0) * Pmm;\n\tif(l == m+1) { return float(Pmmp1); }\n\n\tfloat Pml = 0.0;\n\tfor (int ll = m+2; ll <= l; ++ll)\n\t{ \n\t\tPml = ( (2.0 * float(ll) - 1.0) * x * Pmmp1 - (float(ll) + float(m) - 1.0) * Pmm ) / float(ll - m);\n\t\tPmm = Pmmp1;\n\t\tPmmp1 = Pml;\n\t}\n\treturn Pml;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SHNaive(in int l, in int m, in vec3 s)\n{\n\tfloat phi = atan(s.z, s.x);\n\n\tif(m == 0)\n\t{\n\t\treturn KP(l, 0, s.y);\n\t}\n\telse if(m > 0)\n\t{\n        //s.y <=> cos(theta)\n\t\treturn SQRT2 * cos(float(m) * phi)  * KP(l, m, s.y);\n\t}\n\telse\n\t{\n\t\treturn SQRT2 * sin(-float(m) * phi) * KP(l, -m, s.y);\n\t}\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\n    int l = L;\n    int m = M;\n    #ifdef AUTOMATIC\n    int x = ((iFrame>>1)&0x7FF)/15;\n    int Y = int(floor(sqrt(0.25+float(2*x))-0.5));\n    int X = int(floor(float(x)-0.5*float(Y+Y*Y)));\n    l = Y+1;\n    m = X+1;\n    #endif\n\td=length(p00); n=p00/d; r = SHNaive(l, m, n ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 1.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<MARCH_MAX_ITERATION; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n        vec3 p = ro+rd*t ;\n\t    vec3 res = map(p);\n        h = res.x;\n\t\tm = res.yz;\n        t += h*MARCH_STEP;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    float turn = radians(360./256.)*float(iFrame&0xFF);\n    vec3  ro = vec3(2.0*sin(an+turn),2.0*sin(am),2.0*cos(an+turn)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.5,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldSW7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1966, 2091, 2132, 2132, 2319], [2321, 2507, 2549, 2549, 3437], [3439, 3500, 3546, 3546, 3794], [3796, 3796, 3819, 3819, 4366], [4368, 4368, 4410, 4410, 4794], [4796, 4796, 4828, 4828, 5052], [5054, 5054, 5111, 5125, 6828]], "test": "untested"}
{"id": "3ldXD2", "name": "thorn garden", "author": "mahalis", "description": "learning about iterated function systems. also gave antialiasing a shot, with dubious success.", "tags": ["fractal", "ifs"], "likes": 5, "viewed": 302, "published": "Public API", "date": "1581793340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// license: CC BY-NC https://creativecommons.org/licenses/by-nc/4.0/\n\n// set to 1 if the holes bother you\n#define TRYPOPHOBIA 0\n\n// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTet(vec3 p, float r) {\n    const vec3 c = normalize(vec3(1.,-1.,1.));\n    return max(max(max(dot(p, c.xxx) - r, dot(p, c.yyx) - r), dot(p, c.xyy) - r), dot(p, c.yxy) - r);\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// assumes normalized axis\nmat3 makeRotation(vec3 axis,float angle) {\n    \n    float c = cos(angle), s = sin(angle);\n    float mc = 1. - c;\n    float sz = s * axis.z;\n    float sy = s * axis.y;\n    float sx = s * axis.x;\n    float mx = mc * axis.x;\n    float my = mc * axis.y;\n    float mz = mc * axis.z;\n    \n    return mat3(c + mx * axis.x,\n                mx * axis.y - sz,\n                mx * axis.z + sy,\n                mx * axis.y + sz,\n                c + my * axis.y,\n                my * axis.z - sx,\n                mx * axis.z - sy,\n                my * axis.z + sx,\n                c + mz * axis.z);\n}\n\n// -----------------\n\nmat3 innerRotation;\n\nfloat d(vec3 position) {\n    position = rX(position, iTime * 0.13);\n    float fScale = 0.79 + sin(iTime * 0.9) * 0.013;\n    float accumulatedScale = 1.;\n    \n    for(int i = 0; i < 8; i++) {\n        position = abs(position);\n        position *= fScale;\n        accumulatedScale *= fScale;\n        position -= (0.0137 + 0.001 * sin(iTime * 0.6 + 1.));\n        position = innerRotation * position;\n    }\n    float cutoutAmount = pow(sin(iTime * 0.231), 4.);\n    #if TRYPOPHOBIA\n    float innerCutout = sdTet(-position,0.003 + cutoutAmount * 0.009);\n    #else\n    float innerCutout = sdSphere(position, 0.014 + cutoutAmount * 0.002);// sdSphere(position, 0.009 + cutoutAmount * 0.007);\n    #endif\n    float outerCrop = sdSphere(position, 0.021 + sin(iTime * 0.831 + 2.) * 0.003);\n    return opInt(opSub(sdTet(position, 0.01), innerCutout), outerCrop) / accumulatedScale;\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 70; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(1.0);\n}\n\n// ambient occlusion using iq’s technique from http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat occlusion(vec3 position, vec3 normal) {\n    const float aoStep = 0.04;\n    float aoAcc = 0.;\n    const float distanceScale = 0.005; // decrease for less attenuation of shadows\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float sampleDistance = aoStep * fi;\n        aoAcc += (sampleDistance - max(0.,d(position + normal * sampleDistance))) / exp2(fi * distanceScale);\n    }\n    return aoAcc;\n}\n\nvec3 palette(float v) {\n    v *= 4.;\n    return vec3(0.5) + 0.5 * cos(6.28318 * (v + vec3(0.0,0.333,0.667)));\n}\n\n// soft shadows also using iq’s technique — https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(vec3 origin, vec3 direction, float sharpness) {\n    const float maxDistance = 2.;\n    float amount = 1.;\n    float totalDistance = 0.;\n    for(int i = 0; i < 70; i++) {\n        float localDistance = d(origin);\n        amount = min(amount, 0.5 + 0.5 * localDistance / (sharpness * totalDistance));\n        if (localDistance < 0.) break;\n        origin += direction * max(0.002, localDistance);\n    }\n    \n    amount = max(amount, 0.);\n    return amount * amount * (3. - 2. * amount);\n    \n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.4, 1.0, 0.6)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    float nDotV = max(0., dot(normal, toEye));\n    const float diffuse = 1.;\n    float ambience = 0.1 + max(0., dot(normal, vec3(0.,-1.,0.))) * 0.4;\n    const float specular = 0.3;\n    float ao = (1.0 - occlusion(position, normal));\n    float fres = pow(1. - nDotV, 8.);\n    float shadowAmount = shadow(position + normal * 0.01, toLight, .5);\n    \n    vec3 color = vec3((ndotL * diffuse + pow(ndotH, 4.) * specular) * shadowAmount + ao * (ambience + fres)) * palette(nDotV * -0.5 + 0.6 + iTime * 0.03);\n    return color;\n}\n\n\n#define ANTIALIASING_SAMPLES 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, -0.04, 0.0);\n    vec3 cameraPosition = vec3(0.0, 0.2, 1.5) * 1.7;\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    innerRotation = makeRotation(normalize(vec3(1.,2.,-3.)), iTime * 0.122 + sin(iTime * 0.23) * 0.1);\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < ANTIALIASING_SAMPLES; i++) {\n        vec3 aaOffset = 0.002 * (cameraRight * float(i == 1 || i == 3) + cameraUp * float(i == 0 || i == 2));\n    \tvec4 marchResult = march(cameraPosition + aaOffset, rayDirection, 0.0001);\n    \tif (marchResult.w > 0.0) {\n    \t    color += vec3(0.0); // “sky” color\n    \t} else {\n    \t    vec3 position = marchResult.xyz;\n    \t    color += lightSurface(position, gradient(position, marchResult.w), -rayDirection);\n    \t}\n    }\n    color /= float(ANTIALIASING_SAMPLES);\n    color = pow(color, vec3(1.2)) * 1.5;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXD2.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[129, 140, 186, 186, 295], [297, 297, 328, 328, 417], [419, 419, 452, 452, 480], [482, 482, 512, 512, 663], [665, 665, 702, 702, 748], [750, 750, 783, 783, 810], [812, 812, 845, 845, 871], [873, 873, 906, 906, 932], [934, 934, 960, 960, 1099], [1101, 1101, 1127, 1127, 1267], [1269, 1269, 1295, 1295, 1434], [1436, 1463, 1505, 1505, 2051], [2053, 2096, 2120, 2120, 2965], [2967, 2967, 2999, 2999, 3125], [3127, 3127, 3176, 3176, 3611], [3613, 3723, 3768, 3768, 4147], [4149, 4149, 4172, 4172, 4260], [4262, 4370, 4430, 4430, 4872], [4874, 4874, 4933, 4933, 5639], [5674, 5674, 5731, 5731, 6959]], "test": "untested"}
{"id": "3ldXDf", "name": "Tonemapping ops but with ACES FT", "author": "DmitRex", "description": "original shadertoy - https://www.shadertoy.com/view/lslGzl\n\nFrom top to bottom:\nlinear,\nsimplified Reinhard operator,\nluma based Reinhard op.,\nwhite preserving luma based Reinhard op.,\nRomBinDaHouse\nACES Fitted.,\nUncharted 2 tone map", "tags": ["curves", "tonemapping", "filmic", "acesaces"], "likes": 7, "viewed": 202, "published": "Public", "date": "1581877130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nORIGINAL SHADERTOY - https://www.shadertoy.com/view/lslGzl\n\nI only replaced `filmicToneMapping` with `ACESFitted` from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nThis shader experiments the effect of different tone mapping operators.\nThis is still a work in progress.\n\nMore info:\nhttp://slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\nhttp://filmicgames.com/archives/75\nhttp://filmicgames.com/archives/183\nhttp://filmicgames.com/archives/190\nhttp://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3/\nhttp://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/\nhttp://renderwonk.com/publications/s2010-color-course/\n\n--\nZavie\n\n*/\n\nfloat gamma = 2.2;\n\nvec3 getBaseColor(int i)\n{\n\tif (i == 0) return vec3(1.0, 0.4, 0.0);\n\tif (i == 1) return vec3(0.4, 1.0, 0.0);\n\tif (i == 2) return vec3(0.0, 1.0, 0.4);\n\tif (i == 3) return vec3(0.0, 0.4, 1.0);\n\tif (i == 4) return vec3(0.4, 0.0, 1.0);\n\tif (i == 5) return vec3(1.0, 0.0, 0.4);\n\n\treturn vec3(1.);\n}\n\nvec3 getBaseColor()\n{\n\tfloat colorPerSecond = 0.5;\n\tint i = int(mod(colorPerSecond * iTime, 7.));\n\tint j = int(mod(float(i) + 1., 7.));\n\n\treturn mix(getBaseColor(i), getBaseColor(j), fract(colorPerSecond * iTime));\n}\n\nvec3 linearToneMapping(vec3 color)\n{\n\tfloat exposure = 1.;\n\tcolor = clamp(exposure * color, 0., 1.);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5;\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nconst mat3x3 ACESInputMat = mat3x3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3x3 ACESOutputMat = mat3x3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n  \tcolor = clamp(color, 0.0, 1.0);\n    \n    color = pow(color, vec3(1. / gamma));\n\n    return color;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 color = getBaseColor();\n\n\tfloat n = 8.;\n\tif (uv.x > 0.2)\n\t{\n\t\tif (uv.x < 0.6)\n\t\t\t// blacks\n\t\t\tcolor *= (2.5 * uv.x - 0.5);\n\t\telse\n\t\t\t// whites\n\t\t\tcolor *= 15.*(2.5 * uv.x - 1.5) + 1.;\n\n\t\tint i = int(n * (1. - uv.y));\n\t\tif (i == 1) color = linearToneMapping(color);\n\t\tif (i == 2) color = simpleReinhardToneMapping(color);\n\t\tif (i == 3) color = lumaBasedReinhardToneMapping(color);\n\t\tif (i == 4) color = whitePreservingLumaBasedReinhardToneMapping(color);\n\t\tif (i == 5) color = RomBinDaHouseToneMapping(color);\t\t\n\t\tif (i == 6) color = ACESFitted(color);\n\t\tif (i == 7) color = Uncharted2ToneMapping(color);\n\t}\n\n\tif (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n\t\tcolor = vec3(0.);\n\n\tfragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 735, 761, 761, 1028], [1030, 1030, 1051, 1051, 1246], [1248, 1248, 1284, 1284, 1404], [1406, 1406, 1450, 1450, 1573], [1575, 1575, 1622, 1622, 1811], [1813, 1813, 1875, 1875, 2113], [2115, 2115, 2158, 2158, 2263], [2265, 2265, 2301, 2301, 2441], [2576, 2758, 2785, 2785, 2914], [2916, 2916, 2945, 2945, 3201], [3203, 3203, 3243, 3243, 3655], [3657, 3657, 3714, 3714, 4469]], "test": "untested"}
{"id": "3ldXDM", "name": "moon321", "author": "mouver", "description": "moon", "tags": ["moon"], "likes": 3, "viewed": 101, "published": "Public", "date": "1581950474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a,b,t)\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur) {\n    float m = S(-blur, blur, p.y - yb);\n    m *= S(blur, -blur, p.y - yt);\n    \n    p.x = abs(p.x);\n    \n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= S(blur, -blur, p.x - w);\n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur) {\n    float m = TaperBox(uv, .03, .03, -.05, .25, blur);\n    m += TaperBox(uv, .2, .1, .25, .5, blur);\n    m += TaperBox(uv, .15, .05, .5, .75, blur);\n    m += TaperBox(uv, .1, .0, .75, 1., blur);\n    \n    float shadow = TaperBox(uv - vec2(.2, 0), .1, .5, .15, .25, blur);\n    shadow += TaperBox(uv + vec2(.25, 0), .1, .5, .45, .5, blur);\n    shadow += TaperBox(uv - vec2(.25, 0), .1, .5, .7, .75, blur);\n    \n    col -= shadow * .8;\n    return vec4(col, m);\n}\n\nfloat GetHeight(float x) {\n    return sin(x * .423) + sin(x) * .3;\n}\n\nvec4 Layer(vec2 uv, float blur) {\n    vec4 col = vec4(0);\n    float id = floor(uv.x);\n    float n = fract(sin(id * 234.12) * 5463.3) * 2. - 1.;\n    float x = n*.3;\n    float y = GetHeight(uv.x);\n    \n    float ground = S(blur, -blur, uv.y + y);\n    col += ground;\n    \n    y = GetHeight(id + .5 + x);\n    \n    uv.x = fract(uv.x) - .5;\n    vec4 tree = Tree((uv - vec2(x, -y)) * vec2(1., 1. + n * .2), vec3(1), blur);\n    \n    // col.rg = uv;\n    \n    col = mix(col, tree, tree.a);\n    col.a = max(ground, tree.a);\n    \n    return col;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(234.45, 765.34));\n    p += dot(p, p + 547.123);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n\tfloat t = iTime * .3;\n    \n    float blur = .005;\n    \n    float twinkle = dot(length(sin(uv + t)), length(cos(uv * vec2(22, 6.7) - t * 3.)));\n    twinkle = sin(twinkle * 10.) * .5 + .5;\n    float stars = pow(Hash21(uv), 100.) * twinkle;\n    vec4 col = vec4(stars);\n    \n    float moon = S(.01, -.01, length(uv-vec2(.4, .2)) - .15);\n    col *= 1. - moon;\n    moon *= S(-.01, .1, length(uv-vec2(.5, .25)) - .15);\n    col += moon;\n    \n    vec4 layer;\n    \n    for(float i = 0.; i < 1.; i += 1./10.) {\n        float scale = mix(30., 1., i);\n        //blur = mix(.1, .005, i);\n        layer = Layer(uv * scale + vec2(t + i * 100., i) - M, blur);\n        layer.rgb *= (1. - i) * vec3(.9, .9, 1.);\n        \n        col = mix(col, layer, layer.a);\n    }\n    \n    layer = Layer(uv + vec2(t, 1.) - M, .07);\n    col = mix(col, layer * .1, layer.a);\n\n    float thickness = 1./iResolution.y;\n    // if (abs(uv.x)<thickness) col.g = 1.;\n    // if (abs(uv.y)<thickness) col.r = 1.;\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 114, 114, 320], [322, 322, 364, 364, 823], [825, 825, 851, 851, 893], [895, 895, 928, 928, 1430], [1432, 1432, 1454, 1454, 1556], [1558, 1558, 1615, 1615, 2730]], "test": "untested"}
{"id": "3lKXDw", "name": "Ray March 4", "author": "baksej", "description": "ray march 4", "tags": ["raymarch"], "likes": 2, "viewed": 38, "published": "Public", "date": "1582855187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k) {\n \tfloat h = clamp(.5 + .5 * (b - a) / k, 0.0, 1.0);   \n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius){\n \treturn length(pos) - radius;   \n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y){\n \tfloat n = (v - a) / (b - a);\n \treturn x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\n\n\nfloat scene(vec3 pos){\n    \n    vec3 i = floor(pos / .2);\n    \n    vec3 pos1 = pos;\n    \n \tfloat s1 = sphere(pos1, .2);\n   \n    \n    vec3 pos2 = pos;\n    pos2.y += 30.0 + .1;\n    pos2.z -= 1.0;\n    float s2 = sphere(pos2, 30.0);\n    \n \n    return smin(s1, s2, .15);\n}\n\nvec3 estimateNormal(vec3 pos){\n    \n \treturn normalize(\n    vec3(\n        scene(pos - vec3(.001, .0, .0)) - scene(pos + vec3(.001, .0, .0)),\n        scene(pos - vec3(.0, .001, .0)) - scene(pos + vec3(.0, .001, .0)),\n        scene(pos - vec3(.0, .0, .001)) - scene(pos + vec3(.0, .0, .001))\n        \n    ));   \n}\n\n//https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    // these probably have pretty bad performance\n    // they are modified from iq's, but I made a lot of changes\n    // to explore how they work without worrying about speed\n\n// float jshadow( in vec3 light, in vec3 pos)\n// {\n//     float dist = distance(light, pos);\n//     vec3 dir = normalize(pos - light);\n    \n//     for( float t=.1; t<dist-.01; )\n//     {\n//         float h = scene(light + dir*t);\n//         if( h<0.001 )\n//             return 0.0;\n//         t += clamp(h, 0.01, 0.50);\n//     }\n//     return 1.0;\n// }\n\n float jsoftshadow( in vec3 light, in vec3 pos, float w )\n {\n     float dist = distance(light, pos);\n     vec3 dir = normalize(pos - light);\n    \n     float s = 1.0;\n     for( float t=.1; t<dist-.1; )\n     {\n         float h = scene(light + dir*t);\n         s = min( s, 0.5+0.5*h/(w*t) );\n         if( s<0.0 ) break;\n         t += clamp(h, 0.01, 0.50);\n     }\n     s = max(s,0.0);\n     \n     return s*s*(3.0-2.0*s); // smoothstep\n }\n\n\n\nvec3 lightOrigin = vec3(-.3, .6, -.3);\n\n\n\nvec3 trace(vec3 camOrigin, vec3 dir, out float totalDist) {\n \tconst int maxSteps = 1024;\n    vec3 ray = camOrigin;\n    totalDist = 0.0;\n    \n    // hacky near plane clipping\n    totalDist += .1;\n    ray += totalDist * dir;\n    \n    for(int i = 0; i < maxSteps; i++) {\n     \tfloat dist = scene(ray);\n        if (abs(dist) < .001) {\n            vec3 lightDir = normalize(ray - lightOrigin);\n            // this is not how falloff works!\n            float lightFalloff = 2.0 - pow(length(ray - lightOrigin) * .5, 2.);\n            float diffuse = clamp(dot(lightDir, estimateNormal(ray))* lightFalloff, 0., 1.) ;\n            \n            float s = jsoftshadow(lightOrigin, ray, .02);\n            diffuse *= s;\n            \n            vec3 ambient = vec3(.1, .1, .2);\n            return vec3(1.0, .8, .6)*diffuse + ambient;\n        \t   \n        }\n        totalDist += dist;\n        ray += dist * dir;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    \n{\n    lightOrigin = vec3(sin(iTime), .6, -.3);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 camOrigin = vec3(0.,.5,-3.);\n    vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n    vec3 dir = normalize(rayOrigin - camOrigin);\n    \n    pR(dir.yz, -.1);\n   \n    \n    float dist;\n    vec3 color = trace(camOrigin, dir, dist);\n\t\n    //float fog = clamp(map(dist, 10., 15., 1., 0.), 0.0, 1.0);\n    //color = mix(vec3(0.0), color, fog);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 77], [79, 79, 118, 118, 220], [222, 222, 259, 259, 295], [296, 296, 320, 320, 394], [396, 396, 451, 451, 510], [512, 512, 536, 536, 561], [564, 564, 586, 586, 831], [833, 833, 863, 863, 1144], [1528, 1743, 1802, 1802, 2174], [2220, 2220, 2279, 2279, 3151], [3153, 3153, 3215, 3215, 3836]], "test": "untested"}
{"id": "3lKXWW", "name": "Arco--MandelSponge-v0", "author": "jorge2017a1", "description": "Arco--MandelSponge-v0", "tags": ["arcomandelspongev0"], "likes": 0, "viewed": 56, "published": "Public", "date": "1582730520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n///--------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 tex(vec2 uv)\n{\n\treturn vec3(fract(sin(dot(floor(uv*32.0),vec2(5.364,6.357)))*357.536));\n}\n\n///--------------------------------------\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\n///-----------------------------------------------\nfloat map(vec3 p) \n{\n  \n  \n  float d;\n   \n   \td=999.9;\n  \n    \n   //p.x =mod(p.x,20.0)-15.0;\n    \n   float sdt1= sdTorus(p.yxz- vec3(0.0,3.0,4.5), vec2(4.5,1) );\n   float sdt2= sdTorus(p.xzy- vec3(-5.5,3.0,3.5), vec2(8.5,1) );\n   \n   float sdb1= sdBox(  p-vec3(2.5,0.0,3.0), vec3(2.0,7.0,1.0) );\n   float sdb2= sdBox(  p-vec3(-13.5,0.0,3.0), vec3(1.5,7.0,1.0) );\n    \n   float sdb3= sdBox(  p-vec3(-5.0,-5.0,3.0), vec3(10.0,12.0,2.5) ); \n   float diff1= differenceSDF(sdt2,sdb3);\n    \n   \n   d=unionSDF(d, diff1);\n\n   d=unionSDF(d, sdb1 );\n   d=unionSDF(d, sdb2 );\n    \n    \n  float s = 1.0;\n  for (int m = 0; m < 2; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.0 * abs(a);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n\n  return d;\n                                                              \n}\n//------------------------------------------------\n    \nfloat GetDist(vec3 p  ) {\t\n  \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n    vec3 pp;\n    pp=p;\n        \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n            \t\n          {\t\n              //cielo\n              res=vec2(res.x,6); \n          }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             //piso\n             res=vec2(res.x, 9);\n             \n         } \n     }\n\t\n    float tmpd;\n    tmpd= map(p);\n        \n    res=opU(res, vec2(tmpd ,8));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(85./255., 205./255., 252./255.);\n    }\n    \n    if(i== 1 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n        } \n    if(i== 2 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n        } \n    if(i== 3 )\n    {\n        return vec3(247./255., 168./255.,  184./255.); \n       } \n    if(i== 4 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        } \n    if(i== 5 )\n    {\n        return vec3(85./255., 205./255., 252./255.);\n        } \n    if(i== 6 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n    if(i== 12 )\n    {\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n        } \n     if(i== 13 )\n    {\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n        } \n     if(i== 14 )\n    {\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n        } \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n     if(i== 17 )\n    {\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n        } \n     if(i== 18 )\n    {\n        \treturn vec3(1.0,0.0,0.0);} \n     if(i== 19 )\n    {      \n     \treturn vec3(0.0,1.0,0.0);\n    } \n        \n     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    vec3 ro = vec3(-8.0,8.5,25.);\n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    \n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n \n   \n    \n    float dif = GetLight(p);   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    col =  ( vec3(dif)+colobj)/1.5;\n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 836, 858, 858, 2118], [2121, 2225, 2271, 2271, 2303], [2305, 2305, 2348, 2348, 2380], [2382, 2382, 2430, 2430, 2463], [2466, 2466, 2495, 2495, 2621], [2623, 2623, 2659, 2659, 2776], [2778, 2778, 2814, 2814, 2932], [2935, 2935, 2971, 2971, 3094], [3147, 3159, 3181, 3181, 3489], [3490, 3516, 3541, 3541, 3731], [3732, 3777, 3794, 3794, 3867], [3870, 3903, 3929, 3929, 4126], [4127, 4173, 4225, 4225, 4380], [4445, 4554, 4591, 4591, 4626], [4628, 4628, 4647, 4647, 4722], [4724, 4767, 4790, 4790, 4816], [4818, 4818, 4841, 4841, 4979], [4982, 4982, 5004, 5004, 5074], [5076, 5127, 5147, 5147, 5964], [5965, 6021, 6046, 6046, 6797], [6800, 6800, 6834, 6834, 7198], [7203, 7203, 7227, 7227, 7459], [7463, 7463, 7487, 7487, 7872], [7875, 7875, 7901, 7901, 8265], [8268, 8268, 8293, 8293, 8321], [8323, 8323, 8375, 8375, 8771], [8874, 8918, 8935, 8935, 9006], [9031, 9123, 9148, 9148, 9411], [9413, 9471, 9499, 9499, 11775], [11777, 11777, 11834, 11834, 12848]], "test": "untested"}
{"id": "3lKXzm", "name": "lost in spacetime.. v. 2.0", "author": "julianlumia", "description": ":octopusballoon:\ncoloring based on:  https://www.shadertoy.com/view/WlKXRW", "tags": ["space"], "likes": 19, "viewed": 306, "published": "Public", "date": "1582445233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,1./.2);\n t *=2.;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = .2;\n float modd = 2.1;\n float sqD = max(abs(t.y), abs(t.y));\n sqD +=1. + yid*0.0;\n float sqid = floor(sqD/modd);\n sqD = lmod(sqD, modd);  \n d = min(d, sqD);\n o +=  pal(.1, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*40.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n float dp = dot(p,p)*.6;\n p /= dp;\n p.xz*= Rot(cos(iTime*0.5));\n p.xy *=  Rot(cos(iTime*1.-0.2));\n p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n vec3 q = (text(p.xz, p)).xyz;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d =vec2(0.);\n vec3 q = p;\n float dp = dot(p,p)*.6;\n p /= dp;\n p.xz*= Rot(cos(iTime*0.5));\n p.xy *=  Rot(cos(iTime*1.-0.2));\n p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n//d = vec2(sdBox(p,vec3(1.1,1.1,0.4)) + sdBox(q,vec3(0.2,0.2,0.2)),1);\n d = vec2(sdBox(p,vec3(1.)) + sdBox(q,vec3(0.2,0.2,0.2)),1);\n\n    d.x *=1.;\n d.x =(((d.x*dp)/8.));\n g1 +=1./(.018+pow(abs(d.x),1.));\n d = condmin( d,d);\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<SURF_DIST||t.x>MAX_DIST) break;\n  t.x+=h.x*1.;\n  t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n// vec3 lightPos = vec3(sin(iTime)*2., cos(iTime)*2., 3);\n     vec3 lightPos = vec3(0.,0.,5);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(0, 0, 1.);\n ro.xy *= Rot(sin(iTime*.1)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n  if(d.y==1.) col += tex3D(p,n)*10.;\n }\n col*=g1*vec3(.00003);  \n float fog = 1. / (2. + d.x * d.x *4.);\n col *= vec3(fog); \n col+=g1*vec3(.00003);  \n col*= 2.; \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 272, 272, 339], [341, 341, 370, 370, 448], [469, 469, 510, 510, 874], [876, 876, 902, 902, 1482], [1484, 1484, 1520, 1520, 1808], [1810, 1810, 1848, 1848, 1915], [1928, 1928, 1950, 1950, 2463], [2465, 2465, 2501, 2501, 2694], [2696, 2696, 2719, 2719, 2903], [2906, 2906, 2930, 2988, 3182], [3184, 3184, 3226, 3226, 3380], [3384, 3384, 3441, 3441, 4117]], "test": "untested"}
{"id": "3ltSD4", "name": "Intro To ShaderToy (shapes)", "author": "Jim_Watson", "description": "Going through the Art of Code tutorials. Having a blast so far. ", "tags": ["2d"], "likes": 1, "viewed": 62, "published": "Public", "date": "1580952844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat BandEqual(float b, float w, float v, float blur)\n{\n    float band = smoothstep((b-w)+blur, b-blur, v);\n    band *= 1.-smoothstep(b+blur, (b+w)-blur, v);\n    return band;\n}\n\nfloat Band(float b, float e, float v, float blur)\n{\n    float band = smoothstep(b-blur, b, v);\n    band *= smoothstep(e+blur, e, v);\n    return band;\n}\n\nfloat SmileyFace(vec2 uv, vec2 p, float size)\n{\n    uv -= p; //  remaps the point you want it to be at to 0.\n    \t\t //  translation of the coordinate system\n    uv /= size; //  scaling coordinate system\n    \n    float mask = Circle(uv, vec2(0.), 0.4, 0.05);\n    \n    mask -= Circle(uv, vec2(-.15,0.15), 0.07, 0.01);\n    mask -= Circle(uv, vec2(.15,0.15), 0.07, 0.01);\n    \n    float mouth = Circle(uv, vec2(0.), 0.3, 0.02);\n    mouth *= 1.- Circle(uv, vec2(0., 0.05), 0.3, 0.02);\n    \n    mask *= 1. - clamp(mouth, 0., 1.);\n    return mask;\n}\n\nfloat Square(vec2 uv, float size, vec2 p, float blur)\n{\n    float mask = BandEqual(p.x, size, uv.x, blur);\n    mask *= BandEqual(p.y, size, uv.y, blur); \n    \n    return mask;\n}\n\nfloat Rect(float b1, float e1, float b2, float e2, float blur, vec2 uv)\n{\n    float mask = Band(b1, e1, uv.x, blur);\n    mask *= Band(b2, e2, uv.y, blur);\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float mask = 0.;\n    \n    float x = uv.x;\n    \n    float m = sin(t+x*8.)*0.1;\n        //(x-0.5)*(x+0.5);\n    m = m*m*4.;\n    float y = uv.y-m;\n        \n    mask = Rect(-0.5, 0.5,-0.1, 0.1, 0.02, vec2(x, y));\n        //Rect(-0.2+y*.2, 0.2-y*.2,-0.3, 0.3, 0.02, vec2(x, y)); \n        //Rect(-0.2, 0.2,-0.3, 0.3, 0.02, vec2(x, y));\n        //Square(uv, 0.2, vec2(0.), 0.);\n        //SmileyFace(uv, vec2(0., 0.), 0.5);\n    \n    vec3 col = vec3(0.);\n    \n    col = vec3(1., 1., 0.)*mask;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 141], [143, 143, 199, 199, 320], [322, 322, 373, 373, 473], [475, 475, 522, 522, 1017], [1019, 1019, 1074, 1074, 1196], [1198, 1198, 1271, 1271, 1371], [1373, 1373, 1430, 1480, 2152]], "test": "untested"}
{"id": "3ltSDS", "name": "Newton Fractal (Dual Complex)", "author": "fizzer", "description": "A remix of [url=https://www.shadertoy.com/view/Xd2GzR]this[/url] shader by IQ, adapting it to show the Newton fractal instead of a Mandelbrot.", "tags": ["fractal", "distance", "complex", "analytic", "dual", "newton"], "likes": 3, "viewed": 101, "published": "Public", "date": "1581629043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A small remix of IQ's dual complex number Mandelbrot: https://www.shadertoy.com/view/Xd2GzR\n//\n// Dual complex numbers allow for automatic differentiation of complex number functions\n// which is useful for computing a distance estimation. See IQ's shader for more information.\n//\n// This remix replaces the Mandelbrot orbit with the Newton-Raphson iteration on\n// the equation Z³ = 1 which has three roots, and starting values of Z will iterate\n// towards one of those roots. More here: https://en.wikipedia.org/wiki/Newton_fractal\n//\n// The calculated distance is the closest distance to the set of points which are\n// stationary under the iteration Z -> Z - (Z³ - 1) / (3Z²)\n//\n\n\n//-------------- dual complex numbers --------------\n\n// complex addition, and derivatives\nvec4 dcAdd( vec4 a, vec4 b )\n{\n    return a + b;\n}\n\n// complex multiplication, and derivatives\nvec4 dcMul( vec4 a, vec4 b )\n{\n    return vec4( a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x,\n                a.x*b.z + a.z*b.x - a.y*b.w - a.w*b.y,\n                a.x*b.w + a.w*b.x + a.z*b.y + a.y*b.z );\n}\n\n// complex squaring, and derivatives\nvec4 dcSqr( vec4 a )\n{\n    return vec4( a.x*a.x - a.y*a.y, \n                2.0*a.x*a.y,\n                2.0*(a.x*a.z - a.y*a.w),\n                2.0*(a.x*a.w + a.y*a.z) );\n}\n\n// Conjugate\nvec4 dcConj( vec4 a )\n{\n    return vec4(a.x, -a.y, a.z, -a.w);\n}\n\n// Multiplicative inverse\nvec4 dcInverse( vec4 a )\n{\n    // This can handily be found on the Wikipedia page:\n    // https://en.wikipedia.org/wiki/Dual-complex_number\n    float n = dot(a.xy, a.xy);\n    return vec4(a.x, -a.y, -a.z, -a.w) / n;\n}\n\n// Quotient\nvec4 dcDiv( vec4 a, vec4 b )\n{\n    return dcMul(a, dcInverse(b));\n}\n\nconst vec2 roots[3] = vec2[3](\n    vec2(1, 0),\n    vec2(-.5, .5 * sqrt(3.)),\n    vec2(-.5, -.5 * sqrt(3.))\n);\n\n//--------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n    float tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zo = pow( 0.5, 16.0*tz );\n\n    float co = 0.0;\n\n    // Note that I have put the zo scaling factor directly into the\n    // starting value of z here, since zo is also the rate of change of the coordinates\n    // of the rendered image.\n    vec4 z = vec4( .00214*100. + p.x * zo, .001202*100. + p.y * zo, zo, zo );\n\n    for( int i=0; i<256; i++ )\n    {\n        if(distance(z.xy, roots[0]) < .001 ||\n           distance(z.xy, roots[1]) < .001 ||\n           distance(z.xy, roots[2]) < .001)\n            break;\n\n        // Z -> Z - (Z³ - 1) / (3Z²)        \n        z = dcAdd(z, -dcDiv(dcMul(z, dcSqr(z)) - vec4(1, 0, 0, 0), dcMul(vec4(3, 0, 0, 0), dcSqr(z))));\n\n        co += 1.0;\n    }\n\n    // Find the closest root for colourpicking.\n\n    float cd = 1e9;\n    int ci = 0;\n    for(int i = 0; i < 3; ++i)\n    {\n        float d = distance(z.xy, roots[i]);\n        if(d < cd)\n        {\n            cd = d;\n            ci = i;\n        }\n    }\n\n    // distance\t\n    // d(c) = |Z|·log|Z|/|Z'|\n    float d = 0.0;\n    z.xy-=roots[ci];\n    if(co<256.) d = -sqrt( dot(z.xy,z.xy)/dot(z.zw,z.zw) )*log(dot(z.xy,z.xy));\n\n    float d2 = d;\n\n    // do some soft coloring based on distance\n    d = clamp( d * 1., 0.0, 1. );\n    d = pow( d, 1./4. );\n    vec3 col = vec3( d );\n\n    col *= ci == 0 ? vec3(1.0, 1., 0.05) : ci == 1 ? vec3(0.0, 1.0, 0.2) : vec3(0.5, 0.0, 1.0);\n\n    col = col * .8 + d * d * .1;\n    \n    // output color\n    fragColor = vec4( pow(col, vec3(1. / 2.2)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSDS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1820, 1857, 1887, 1887, 1907], [1909, 1952, 1982, 1982, 2168], [2170, 2207, 2229, 2229, 2381], [2383, 2396, 2419, 2419, 2460], [2462, 2488, 2514, 2627, 2704], [2706, 2718, 2748, 2748, 2785], [2898, 2952, 3009, 3009, 4647]], "test": "untested"}
{"id": "3ltSRN", "name": "CarlVitasaTest", "author": "bchap728", "description": "test2", "tags": ["test"], "likes": 0, "viewed": 140, "published": "Public API", "date": "1580511782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,8.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "3ltSWf", "name": "Studying Lines", "author": "wobbumash", "description": "I'm studying how to create shapes. I'm still not 100% sure of what is happening with the lines, I just fiddled around with some equations until I got an expected result. My main problem is understanding how to adjust width, but I'm getting there!", "tags": ["lines", "learning", "begginer"], "likes": 1, "viewed": 33, "published": "Public", "date": "1581865007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Grayscale(vec4 Color) {\n    \n\tfloat NormalizedColor = (Color.r + Color.g + Color.b) / 3.0;\n    \n    return vec4(vec3(NormalizedColor), 1.0);\n    \n}\n\nvec2 Rotate2D(vec2 UV, float Angle) {\n    \n\treturn vec2((UV.x * cos(Angle)) - (UV.y * sin(Angle)), (UV.x * sin(Angle)) + (UV.y * cos(Angle)));    \n    \n}\n\nvec3 HLine(vec2 UV, vec2 Position, float Width) {\n    \n\tfloat LeftRight = step((0.5 - (Width * 0.1)) + (-0.5 + Position.x), UV.x) * step((0.5 - (Width * 0.1)) - (-0.5 + Position.x), 1.0 - UV.x);\n    float TopBottom = step(Position.y, UV.y) * step(Position.y, 1.0 - UV.y);\n    \n    return vec3(LeftRight * TopBottom);\n\n}\n\nvec3 VLine(vec2 UV, vec2 Position, float Width) {\n    \n\tfloat LeftRight = step(Position.x, UV.x)* step(Position.x, 1.0 - UV.x);\n    float TopBottom = step((0.5 - (Width * 0.1)) + (-0.5 + Position.y), UV.y) * step((0.5 - (Width * 0.1)) - (-0.5 + Position.y), 1.0 - UV.y);\n    \n    return vec3(LeftRight * TopBottom);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 UV = fragCoord.xy / iResolution.xy;\n    \n    UV.x -= cos(iTime) * 0.05;\n    UV.y += sin(iTime) * 0.05;\n    \n    UV.x -= 0.5;\n    UV.y -= 0.5;\n    UV /= 1.25;\n    UV.x += 0.5;\n    UV.y += 0.5;\n    \n    UV.x += sin((UV.y * 3.141592) + iTime) * 0.025;\n    UV.y += sin((UV.x * 3.141592) + iTime) * 0.025;\n    \n    vec3 LineA = HLine(UV, vec2(0.1, 0.0), 0.25);\n    vec3 LineB = VLine(UV, vec2(0.0, 0.1), 0.25);\n    vec3 LineC = VLine(UV, vec2(0.0, 0.3), 0.25);\n    vec3 LineD = VLine(UV, vec2(0.0, 0.8), 0.25);\n    vec3 LineE = HLine(UV, vec2(0.4, 0.0), 0.25);\n    vec3 LineF = HLine(UV, vec2(0.9, 0.0), 0.25);\n    \n    vec3 Lines = 1.0 - (LineA + LineB + LineC + LineD + LineE + LineF);\n    \n    Lines *= (step(0.5, UV.x) * vec3(0.25, 0.5, 1.0)) + (step(0.5, 1.0 - UV.x) * vec3(0.0, 0.0, 1.0));\n    \n    fragColor = vec4(Lines, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 152], [154, 154, 191, 191, 307], [309, 309, 358, 358, 628], [630, 630, 679, 679, 952], [954, 954, 1011, 1011, 1862]], "test": "untested"}
{"id": "3ltSWs", "name": "approx of min/max", "author": "FabriceNeyret2", "description": "max() = L∞ norm. can be approx by L_big.\n-> many applications:\n- derivable -> ease analytical calculations and many iterative algorithms\n- like sRGB <-> flat color space, allows to replace op by + . Eg, MIPmap: https://shadertoy.com/results?query=minmax", "tags": ["optimization", "min", "smoothmin", "max", "smoothmax"], "likes": 2, "viewed": 266, "published": "Public API", "date": "1581962228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v)  smoothstep(2./R.y,0., v)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R;\n\n    float p = 15., // choose carefully: largest that doesn't cause overflow\n         x1 = U.x, x2 = U.x + iTime/6.,\n#if 0    // better for testing max possible p (artifacts near y=0 ).\n         v0 = .5+.5*cos(6.28*x1),\n         v1 = .5+.5*cos(6.28*x2),\n#else\n         v0 = .5+.3*cos(6.28*x1)     + .2*sin(6.28*x1*2.7),\n         v1 = .5+.2*cos(6.28*x2*1.3) - .3*sin(6.28*x2*3.1),\n#endif\n          m = pow( pow(v0,-p) + pow(v1,-p), -1./p), // approx min\n          M = pow( pow(v0, p) + pow(v1, p),  1./p); // approx Max\n         // quite like to_sRGB( Sum_i{ from_sRGB( C[i] ) } )\n    \n    O = S( U.y- vec4(m,M,0,0) );                    // draw yellow:pseudo-min, green:pseudo-max\n    \n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v0) ) );  // draw curves\n    O = mix( O, vec4(1,0,0,0), S( abs(U.y-v1) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 78, 78, 925]], "test": "untested"}
{"id": "3ltSzf", "name": "Cuarto chico-color-v2--II", "author": "jorge2017a1", "description": "Cuarto chico-color-v2--II", "tags": ["cuartochicocolorv2ii"], "likes": 1, "viewed": 61, "published": "Public", "date": "1581455943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Referencia https://www.shadertoy.com/view/wt3XzX\n//Modificado por: jorge flores p. *(jorge2017a1)\n\n#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 = 15; //9;\n\n\nfloat closeObj = 0.0;\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n////---------------------------------------------\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending( float sd,  vec4 a,  vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion( vec4 a,  vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter( vec4 a,  vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45( vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane( vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\n\nfloat sdSphere( vec3 p,  float s) {\n  return length(p) - s;\n}\n\n\nfloat sdBox( vec3 p,  vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\n\n/*float sdTorus( vec3 p,  vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n*/\n\nfloat sdCapsule( vec3 p,  vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(  vec3 p,  vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion( float a,  float b) {\n  return min(a, b);\n}\n\n\n// INTER\nfloat opInter( float a,  float b) {\n  return max(a, b);\n}\n\n\n// SUB\nfloat opSub( float a,  float b) {\n  return max(-b, a);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod( vec3 p,  vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n\n\n///------------------------------------------\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\n\n/*float sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n*/\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n\n//---------------------------------------------------\n\n////////////\n// HELPERS\n////////////\n\nfloat mapDistance( vec3 point) {\n  float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    vec3 p;\n    p=point; \n    \n    d=999.9;\n    float planeDist = p.y;\n   \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    res = opU(res, vec2(planeDist, 6));\n    \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.5));\n    float bxAtras = sdBox(p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.1));\n    \n    res = opU(res, vec2(bxInf, CInf));\n    \n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.45,0.8,0.4));\n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    float bxIzqVentana = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.11,0.30,0.25));\n    float bxDerVentana = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.11,0.55,0.25));\n    \n    \n    dif2=differenceSDF(bxIzq,bxIzqVentana);     \n    res = opU(res, vec2(dif2, CIzq));\n    \n    \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n    res = opU(res, vec2(dif1, CAtras));   \n  \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    res = opU(res, vec2(dif2, CSup));\n  \n    dif3=differenceSDF(bxDer,bxDerVentana);     \n    res = opU(res, vec2(dif3, CDer));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n    \nvec4 castRay( vec3 ro,  vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n    vec3 m =vec3(1.0);\n  //vec3 m = t > tmax ? vec3(-1.0) : mapDistance(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow( vec3 ro,  vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 32; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal( vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO( vec3 pos,  vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render( vec3 ro,  vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n  TObj Obj;  \n  Obj=mObj;\n    \n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 colorobj= getSphereColor(int( Obj.tipo));  \n      \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * colorobj;\n    lin += 1.20 * spe * colorobj * dif;\n    lin += 0.20 * amb * colorobj* occ;\n    lin += 0.30 * dom * colorobj* occ;\n    lin += 0.30 * bac * colorobj* occ;\n    lin += 0.40 * fre * colorobj* occ;\n\n    \n      col = (res.yzw * lin)/1.5;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n\nmat3 setCamera(  vec3 ro,  vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  //vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n \n // vec3 ro  =vec3(0.0,3.0,10.-cos(0.1 * time + 6.0 ));\n  vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));  \n    \n  vec3 ta = vec3(-0.5, 0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  \n        \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[793, 873, 922, 922, 1052], [1054, 1054, 1088, 1088, 1205], [1207, 1207, 1241, 1241, 1358], [1360, 1360, 1380, 1380, 1424], [1426, 1469, 1495, 1495, 1540], [1543, 1543, 1578, 1578, 1604], [1607, 1607, 1638, 1638, 1739], [1742, 1838, 1874, 1874, 1981], [1983, 1983, 2021, 2021, 2081], [2132, 2141, 2176, 2176, 2198], [2201, 2210, 2245, 2245, 2267], [2270, 2277, 2310, 2310, 2333], [2495, 2624, 2656, 2656, 2918], [2969, 2986, 3019, 3019, 3084], [3104, 3230, 3261, 3261, 3411], [3412, 3432, 3468, 3468, 3555], [3556, 3572, 3604, 3632, 3693], [3695, 3746, 3792, 3792, 3824], [3826, 3826, 3868, 3868, 3900], [3902, 3902, 3949, 3949, 3982], [3985, 3985, 4014, 4014, 4140], [4142, 4194, 4222, 4222, 5203], [5260, 5298, 5330, 5330, 6840], [6846, 6846, 6880, 6880, 7198], [7200, 7200, 7238, 7238, 7532], [7534, 7534, 7562, 7562, 7834], [7836, 7836, 7872, 7872, 8137], [8139, 8139, 8172, 8172, 9324], [9327, 9327, 9380, 9380, 9559], [9561, 9561, 9615, 9615, 10349]], "test": "untested"}
{"id": "3ltXDj", "name": "Squash and Stretch", "author": "JackSolace", "description": "Simple demonstration of the Principle of Squash and stretch in 3D.\n\nBounces are not simulated and better results can be achieved by maintaining constant volume\n\nThe PBR code is leftover from a previous shader (I just like how it looks).", "tags": ["ray", "animation", "march", "learn", "pbr", "stretch", "squash"], "likes": 3, "viewed": 83, "published": "Public", "date": "1581719622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Feb 2020\n//Simple demonstration of the Principle of Squash and Stretch in 3D.\n//Bounces are not simulated and better results can be achieved by maintaining constant volume\n//\n\n\n#define PI 3.14159265359\n#define AA 1\n#define LOOP_TIME 10.0\n#define GRAV -9.8\n//should probs calc this on the fly\n#define BTIME 0.5102 \n#define BALLSIZE 0.4\n\n//Ray hit struct\nstruct Hit {\n\tvec3 pos;\n    vec3 normal;\n    float mat;\n};\n   \n//ray struct\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n\n//geometric attenuation (or shadow factor)\nfloat geometric_attenuation(float roughness, float normal_look_angle, float normal_light_angle)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = normal_light_angle * sqrt(normal_look_angle * (normal_look_angle - normal_look_angle * r2) + r2);\n\tfloat gl = normal_look_angle * sqrt(normal_light_angle* (normal_light_angle - normal_light_angle * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\n//microfacets (minute roghness in the surface)\nfloat microfacet_distribution(float roughness, float normal_half_angle){\n\tfloat r2 = roughness * roughness;\n\tfloat d = (normal_half_angle * r2 - normal_half_angle) * normal_half_angle + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\n//Fresnel Reflection coefficient (vector)\nvec3 fresnel_vec(vec3 specular_color,float look_light_angle) {\n\treturn specular_color + (1.0 - specular_color) * pow((1.0 - look_light_angle),5.0);\n}\n\n//Fresnel Reflection coefficient (scalar)\nfloat fresnel_scalar(float f0, float f90, float look_half_angle) {\n    return f0 + (f90 - f0) * pow(1.0 - look_half_angle, 5.0);\n}\n\nfloat Burley(float linearRoughness, float normal_look_vector, float normal_light_angle, float light_half_angle) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * light_half_angle * light_half_angle;\n    float lightScatter = fresnel_scalar(1.0, f90, normal_light_angle);\n    float viewScatter  = fresnel_scalar(1.0, f90, normal_look_vector);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 spherical_harmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 dfg_karis(float roughness, float normal_look_angle) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * normal_look_angle)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//From IQ ellipsoid approximation\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 pos, vec3 c, float r) {\n\treturn length(pos - c) - r;\n}\n\n//distance to plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\n//Animation code\n//-------------------------------------------------------------------------------------\nvec3 Animate_Sphere(){//stateless animation (perfectly elastic)\n    vec3 pos = vec3(0.0,0.0,0.0);//start\n\tfloat time = mod(iTime+8.0*BTIME,LOOP_TIME);//Ten second loop (I've added an offset to this example)\n    pos.x = mix(-2.0,2.0,time/LOOP_TIME);//x velocity is constant so x postion is linear\n    float ytime = mod(time,2.0*BTIME);//each bounce takes 1.0204 seconds\n    pos.y = 5.0*ytime + 0.5*GRAV*ytime*ytime;//analytic bounce (no energy loss)\n    \n    \n    //as a side not you can get the ball to bounce in any direction by adding a rotation here\n    return pos;\n}\n\nvoid Animate_Ball(out vec3 pos, out vec3 sqst, out mat2 rotate){//stateless animation\n    float time = mod(iTime,LOOP_TIME);//Ten second loop\n    pos.x = mix(-2.0,2.0,time/LOOP_TIME);//x velocity is constant so x postion is linear\n    float ytime = mod(time,2.0*BTIME);//each bounce takes 1.0204 seconds by default\n    pos.y = 5.0*ytime + 0.5*GRAV*ytime*ytime;//analytic bounce (no energy loss)\n    float vel = 5.0 + GRAV*ytime; //derivative of position with respect to time is velocity\n    \n    //The following lines set up the interpolation between the squash and stretch based on where we are in the bounce arc\n\tfloat stime = BTIME/3.0;\n    float sint = 1.0;\n    if (ytime < stime) {\n    \tsint = ytime/stime;\n    }\n    if (ytime > (2.0*BTIME - stime)) {\n    \tsint = (2.0*BTIME - ytime)/stime;\n    }\n    //init squash and stretch values\n    float stretch = 1.0 + pow(vel,2.0)*0.05; //squash and stretch need not be linearly proportional to velocity (sometimes exponential is better looking)\n    float squash = 1.0 + pow(vel,2.0)*0.025; //play with these values for more/less cartoonish effect\n    //mix the two vectors to get bouncy effect\n    //the squash should be applied negatively to the x component here but it makes it difficult to contact the ground\n    sqst = mix(vec3(1.0,squash,squash),vec3(stretch,1.0 - stretch*0.12,1.0 - stretch*0.12), sint);\n    \n    float theta = atan(vel,0.8);//angle of the 2d velocity vector\n    rotate = mat2(vec2(cos(theta),-sin(theta)),vec2(sin(theta),cos(theta)));//2D rotation matrix\n}\n//-------------------------------------------------------------------------------------\n\n\n//PB Rendering Code\n//-------------------------------------------------------------------------------------\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\n//x  index is distance, y index is material type (sometimes other meta info)\nvec2 map_the_world(in vec3 p)\n{\n    vec3 b_center = vec3(0.0);\n    vec3 b_squash = vec3(1.0);\n    mat2 b_rotate = mat2(vec2(1.0,0.0),vec2(0.0,1.0));\n    Animate_Ball(b_center,b_squash, b_rotate);\n    \n    vec3 sp_center = Animate_Sphere();\n    //perform inverse transformation to point before applying to sdf\n    vec3 ball_point = p - b_center;\n    ball_point.xy = b_rotate*ball_point.xy;\n    \n    \n    float to_sphere = sdSphere(p, sp_center ,BALLSIZE);\n\tfloat to_ball = sdEllipsoid( ball_point, b_squash*BALLSIZE );\n    float to_plane = sdPlane (p, vec4(0.0,1.0,0.0,0.4));\n    if (to_ball < to_plane && to_ball < to_sphere) {\n    \treturn vec2(to_ball, 1.0);\n    }else if (to_sphere < to_plane){\n    \treturn vec2(to_sphere, 1.0);\n    }else{\n    \treturn vec2(to_plane, 2.0);\n    }\n\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ).x );  \n}\n\n//Basic RayMarch\nHit march_ray(Ray ray, float tmax) {\n\tfloat t = 0.0;//current depth\n    float m = 0.0;\n    vec3 pos = vec3(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        pos = ray.origin + t*ray.direction;\n        //get dist to nearest surface\n        vec2 h = map_the_world(pos);\n        m = h.y;\n        //if we hit something break\n        if( h.x<0.0001) break;\n        if( t > tmax){m = 0.0; break;}\n        //step forward\n        t += h.x*0.9;\n    }\n    return Hit(pos, calculate_normal(pos), m);\n}\n\nvec3 render_ray(Ray ray) {\n\t// init \"sky\" color\n    vec3 color = vec3(0.5, 0.8, 1.0) * (1.0 + ray.direction.y) * 0.8;\n\n    // raytrace\n    Hit result = march_ray(ray,8.0);\n\n    vec3 light_pos = vec3(10.0);\n    vec3 light_dir = normalize(result.pos - light_pos);\n    vec3 look = -ray.direction;//vector to camera\n    \n    if (result.mat > 0.999){//hit someting\n       \n        vec3 half_vec = normalize(look - light_dir);\n        \n        //important angles\n        float normal_look_angle = clamp(dot(result.normal, look),0.0,1.0);\n        float normal_light_angle = clamp(dot(result.normal, normalize(light_pos)), 0.0,1.0);\n        float look_light_angle = clamp(dot(look, normalize(light_pos)), 0.0,1.0);\n        float normal_half_angle = clamp(dot(result.normal, half_vec), 0.0,1.0);\n        float look_half_angle = clamp(dot(look,half_vec), 0.0,1.0);\n        float light_half_angle = clamp(dot(normalize(light_pos),half_vec), 0.0,1.0);\n        \n        //material constants (play with these)\n        float metallic = 0.0; \n        float reflect_intensity = 1.0;\n        float specular_intensity = 2.5;\n        float roughness = 0.0;\n   \t\t\n        vec3 base_color = vec3(0.0);\n        //shadow check ray\n        Ray shadow_ray = Ray(result.pos+0.01*light_pos, normalize(light_pos));\n       \t//Ray Trace shadow\n        Hit shadow = march_ray(shadow_ray, 8.0);\n            \n        if (result.mat > 1.999) {//plane (play with theses values)\n            //checkerboard\n            base_color = 0.4 + mod(floor(6.0 * result.pos.z) + floor(6.0 * result.pos.x), 2.0)*vec3(0.5);\n            roughness = 0.1;//play with this\n        }else{//sphere (play with these values)\n        \tbase_color = vec3(0.2,0.2,0.2);//sphere color\n            roughness = 0.3;//play with this\n        }\n        \n        \n        \n        float linear_roughness = roughness*roughness;\n        //init specular color\n        vec3 specular_initial = 0.04 * (1.0 - metallic) + base_color*metallic;\n        //init diffuse color\n        vec3 diffuse_initial = (1.0 - metallic) * base_color;\n        // Cook-Torrance\n        vec3 specular = (microfacet_distribution(linear_roughness,normal_half_angle) \n            \t\t* geometric_attenuation(linear_roughness, normal_look_angle, normal_light_angle))\n            \t\t* fresnel_vec(specular_initial,light_half_angle); \n       \t//This is the wierd one (lots of different solutions dpending on what you read)\n        vec3 diffuse = diffuse_initial * Burley(linear_roughness, normal_look_angle, normal_light_angle, light_half_angle);\n        \n        //combine\n        color = diffuse + specular;\n\n        //alter combo by shadows and light angle\n        color *= (specular_intensity * clamp( 1.0 - shadow.mat, 0.0, 1.0) * normal_light_angle);\n        //Reflection Check\n        vec3 ref_dir = reflect(ray.direction, result.normal);\n       \tRay reflected_ray = Ray(result.pos + 0.03*ref_dir,ref_dir);\n        Hit reflected = march_ray(reflected_ray,8.0);\n        \n        \n        //reflected Diffuse calculation\n        vec3 reflected_diffuse = spherical_harmonics(result.normal) * (1.0/PI);\n        //reflected Specular initial\n        vec3 reflected_specular = vec3(0.65, 0.85, 1.0) + reflected_ray.direction.y * 0.8;\n        //what did the reflect hit?\n        if (reflected.mat > 0.999) {\n            if (reflected.mat > 1.999) {\n                //reflected onto the gorund\n            \treflected_specular = 0.4 + mod(floor(6.0 * reflected.pos.z) + floor(6.0 * reflected.pos.x), 2.0)*vec3(0.5);\n            }else{\n                //reflected onto the sphere\n            \treflected_specular = vec3(0.2,0.2,0.2);\n            }\n        }\n        \n        //how to combine the diffuse and specular reflections\n        vec2 dfg = dfg_karis(roughness, normal_look_angle);\n        vec3 spec_color = specular_initial * dfg.x + dfg.y;\n        vec3 reflected_combo = diffuse_initial * reflected_diffuse + reflected_specular * spec_color; \n        //combine 1st and second bounces\n        color += reflected_combo*reflect_intensity;\n        \n    }\n\n    // gamma color calculation    \n    return color;\n}\n\n//-------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n//Camera + Ray Setup\n//----------------------------------------------------------------------\n    // camera movement\t\n\tfloat an = 0.5*(PI);\n\tvec3 ray_origin = vec3( 2.5*cos(an), 0.4, 2.5*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize total color\n    vec3 total = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    #else  \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.0*ww );\n    \n    Ray ray = Ray(ray_origin, ray_direction);\n    \n//Render Fragment\n//----------------------------------------------------------------------\n    \n\ttotal += render_ray(ray);\n        \n    #if AA>1\n    }\n    total /= float(AA*AA);\n    #endif\n\n    total = pow(total, vec3(1.0/2.2));\n    \n\tfragColor = vec4( total, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 536, 633, 633, 928], [930, 977, 1049, 1049, 1196], [1198, 1240, 1302, 1302, 1389], [1391, 1433, 1499, 1499, 1563], [1565, 1565, 1678, 1735, 2014], [2016, 2016, 2056, 2140, 2498], [2500, 2500, 2558, 2615, 2889], [2891, 2925, 2962, 2962, 3045], [3047, 3047, 3090, 3090, 3121], [3123, 3143, 3176, 3176, 3207], [3210, 3315, 3337, 3378, 3885], [3887, 3887, 3951, 3972, 5415], [5506, 5865, 5896, 5896, 6648], [6651, 6700, 6737, 6737, 7017], [7019, 7036, 7072, 7072, 7527], [7529, 7529, 7555, 7576, 11635], [11637, 11725, 11782, 11905, 13018]], "test": "untested"}
{"id": "3ltXRM", "name": "(my first) domain warp", "author": "aodnawg", "description": "I tried domain warping. ", "tags": ["fbm"], "likes": 1, "viewed": 106, "published": "Public", "date": "1580730559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n#define NUM_OCTAVES 10\n\nfloat fbm ( in vec2 _st) {\n    float t = 1.;\n    float v = 0.;\n    float a = 0.5;\n    vec2 shift = vec2(120.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(vec3(_st, t));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec2 addfbm(vec2 uv) {\n    return uv + vec2(fbm(uv), fbm(uv+vec2(314.433623, 234.62324)));\n}\n\nvec3 makeImg(vec2 uv) {\n    vec2 noiseUv = addfbm(uv);\n    noiseUv.x += iTime*.1;\n    noiseUv = addfbm(noiseUv);\n    noiseUv = addfbm(noiseUv);\n    noiseUv = addfbm(noiseUv);\n    noiseUv.x += iTime*.1;\n    noiseUv = addfbm(noiseUv);\n\n    float m = fbm(noiseUv*5.);\n    vec3 col = vec3(pow(m, 4.));\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = makeImg(uv);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 216, 243, 243, 625], [627, 627, 649, 649, 694], [695, 695, 715, 715, 760], [761, 761, 779, 779, 818], [820, 820, 840, 840, 1331], [1357, 1357, 1383, 1383, 1746], [1748, 1748, 1770, 1770, 1840], [1842, 1842, 1865, 1865, 2158], [2160, 2160, 2217, 2267, 2435]], "test": "untested"}
{"id": "3ltXzB", "name": "sohere defoirmation", "author": "antoinefortin", "description": "34rregtr", "tags": ["333"], "likes": 6, "viewed": 231, "published": "Public API", "date": "1581239086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdElipsoid(vec3 pos, vec3 rad)\n{\n\tfloat k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    \n    return k0 *(k0 - 1.0) / k1;\n    \n    \n}   \n\nvec2 rotate(vec2 pos, float angle)\n{\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,s,-s,c) * pos;\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n    \nfloat sdSphere(vec3 pos, vec3 r)\n{\n\treturn 1.0;\n}\n\n \n\nfloat shape(vec3 p)\n{\n\n    vec3 res = vec3(1.0,-1., -1.);\n\tvec3 q = p;\n   \tq.y -=5.5;\n    q.xz = rotate(q.xz, iTime *.5);\n    q.yx = rotate(q.yx, iTime *1.25);\n    float rad = 5.0 + .5 * sin(q.z - iTime * 5.)\n        * cos(q.x + 2.0 * 1.5) \n        * (sin(q.z * 3.5) + cos(q.y * 1.5) ); // base\n  \n     // q.x = mod(q.x + .5, 1.0) - .5;\n    float d = length(q) - rad;\n    \n    \n    d *= .25;\n    \n    res = vec3(d, 1.0, res.z);\n    return res.x; // the distance;\n    \n}\n\n\n\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n\tfloat d = shape(q);\n    \n    \n    // Floor\n    float d2 = pos.y - (-0.95);\n    float ret = min(d, d2);\n    \n        \n    \n    return ret;\n}\n\n\n\n    \n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t//vec3 ro = vec3(0.0 + iTime * 3.,4.5 + sin(iTime),12.5 + iTime * 5.);\n    \n    \n    vec3 ro = vec3(1.,  4., 15.);\n    vec3 rd = normalize(vec3(p, -1.5));\n\t\n    \n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    \n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 sunPosition = vec3(sin(iTime),  1. + cos(iTime),0.9);\n       \tvec3 sundir = normalize(sunPosition);\n     \tvec3 mate = vec3(0.18);\n        \n\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n        \n        col = mate * vec3(t * 0.5, t * 0.25, 1.0) * sundif * sun_sha;\n        col += mate * vec3(0.75, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.75, 0.3, 0.2) * bou_dif;\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltXzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 158], [163, 163, 199, 199, 291], [295, 295, 340, 340, 431], [438, 438, 472, 472, 487], [492, 492, 513, 513, 961], [966, 966, 987, 987, 1151], [1161, 1161, 1194, 1194, 1497], [1499, 1499, 1526, 1526, 1738], [1740, 1740, 1797, 1847, 2971]], "test": "untested"}
{"id": "3lV3Dw", "name": "SquaresCirclesShapesRays", "author": "woh", "description": "it is squares", "tags": ["squares"], "likes": 0, "viewed": 48, "published": "Public", "date": "1580567011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define maxSteps 2000\n#define maxDist 2000.\n#define surfDist .00001\n\n//Distance Estimator\nfloat GetDist (vec3 p) {\n    vec4 s = vec4(sin(iTime),1,cos(iTime) + 6.,1);\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist = p.y + sin(iTime*2.) + .3;\n    \n    return min(sphereDist, planeDist);\n}\n\n//Ray Marcher\nfloat RayMarch (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > maxDist || dS < surfDist) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 cameraPosition = vec3(0, 1, 0);\n    vec3 cameraRay = vec3(normalize(vec3(uv.x, uv.y, 1)));\n    \n    vec3 light = vec3(-1, 2, 1);\n    \n    fragColor = vec4(vec3(RayMarch(cameraPosition, cameraRay)/10.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lV3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 90, 114, 114, 305], [307, 321, 356, 356, 577], [579, 579, 636, 687, 991]], "test": "untested"}
{"id": "3lVSWm", "name": "Capsule SpongeV2", "author": "jorge2017a1", "description": "Capsule SpongeV1", "tags": ["capsulespongev1"], "likes": 3, "viewed": 69, "published": "Public", "date": "1582861549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge flores.p --2019-dic-07\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n\nfloat DE(vec3 p){\n    \n    \n\tfloat d;\n    p.xyz =p.zyx;\n    float distToCapsule = dsCapsule(vec3(-0.0,0.0,0.0), vec3(2.0,1.0,0.1), 1.0, p);    \n    \n    d=distToCapsule;\n    \n    float s = 1.;\n    \n    \n    for(int i = 0;i<5;i++){\n        p *= 3.;\n    \ts*=3.;\n    \tfloat d2 = cylUnion(p) / s;\n        \n        \n        float d3=sdBox(p, vec3(2.0,1.0,2.5));\n    \n            \n        //float m = texelFetch(iChannel0, ivec2(32, 0), 0).x * 2. - 1.;\n        float m =  - 1.;\n        \n    \td = max(d,m*d2);\n   \t \tp = mod(p+1. , 2.) - 1.; \t\n    }\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .05;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    vec3 ro = vec3(0.0, 0.5, -1.5+ 1.0*cos(time)+time*1.1)*2.5;\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 323, 350, 350, 381], [383, 383, 414, 414, 505], [508, 508, 531, 531, 668], [670, 670, 700, 700, 837], [840, 887, 956, 1035, 1076], [1078, 1078, 1160, 1160, 1391], [1393, 1393, 1453, 1453, 1594], [1595, 1644, 1661, 1661, 2201], [2203, 2203, 2232, 2232, 2420], [2422, 2422, 2463, 2463, 2639], [2641, 2641, 2682, 2682, 2834], [2836, 2836, 2857, 2857, 2987], [2989, 2989, 3016, 3016, 3266], [3268, 3268, 3325, 3325, 3789]], "test": "untested"}
{"id": "3lVSWw", "name": "Nautilus: The Book", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\".\nSource explains how to view all the scenes, but the compile time will be longer.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 11, "viewed": 243, "published": "Public API", "date": "1582846163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Nautilus: The Book\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"\n\n// For complete book, change ALL_PG from 0 to 1 -- probably longer compile time.\n// Mouse-x overrides autopaging, mouse-y vertical view direction.\n\n#define ALL_PG   0    // = 0/1 for short/full version\n#define ISBOOK   1    // = 1 for book format\n\n#if ! ALL_PG      // single page selection for faster compilation (not with book)\n#define IPAGE  1  // (for short book set = 1, else 1...6)\n#if IPAGE == 4 || IPAGE == 5\n#define UNWAT  1\n#else\n#define UNWAT  0\n#endif\n#if IPAGE == 5 || IPAGE == 6\n#define INCAVE 1\n#else\n#define INCAVE 0\n#endif\n#endif\n#if ! ALL_PG && IPAGE == 3\n#define ISDARK 1\n#else\n#define ISDARK 0\n#endif\n#if ! ALL_PG && IPAGE == 1\n#define INENV 0\n#else\n#define INENV 1\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, sunDir, sbPos, ltDirEx, qHit, pgSize;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl, dstFarEx, tpBook, phsTurn, idPage;\nint idObj;\nconst int nPage = 6;\nbool inCave, unWat, isDark, bmOn, inEnv;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14, idGrnd = 15;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\n#if ALL_PG || INCAVE\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\n#endif\n\n#if ALL_PG || UNWAT\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q;\n  float ht, wAmp;\n  q = 0.2 * p;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    ht += wAmp * Noisefv2 (q);\n    q *= qRot;\n    wAmp *= 0.5;\n  }\n  return ht - 8.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.x + 1.5 * Fbm2 (0.5 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.x + 1.9 * Fbm2 (0.3 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e = vec2 (0.002, 0.);\n  float h;\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.07);\n}\n\n#endif\n\n#if ALL_PG || ! (UNWAT || INCAVE)\n\nfloat WaveHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, ht;\n  wFreq = 0.4;\n  wAmp = 0.1;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (8.));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyHrzCol (vec3 rd)\n{\n  vec3 col, clCol, mDir, vn;\n  vec2 q;\n  float a, f, fd, ff, smd, mRad, ts;\n  a = atan (rd.z, rd.x);\n  if (rd.y < 0.02 * Fbm1 (32. * a) - 0.02) {\n    col = vec3 (0.22, 0.3, 0.33) * (0.8 + 0.2 * Fbm2 (64. * vec2 (a, rd.y)));\n    if (isDark) col *= 0.5;\n  } else {\n    if (isDark) {\n      mDir = normalize (vec3 (0.6, 0.05, 1.));\n      mRad = 0.015;\n      col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n      smd = dot (rd, mDir);\n      ts = smd * smd - 1. + mRad * mRad;\n      if (ts > 0.) {\n        ts = smd - sqrt (ts);\n        if (ts > 0.) {\n          vn = normalize ((ts * rd - mDir) / mRad);\n          col += vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (-0.77, -0.4, 0.5), vn) *\n             (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n        }\n      } else col += StarPat (rd, 6.);\n    } else {\n      smd = max (dot (rd, sunDir), 0.);\n      q = vec2 (0.05 * tCur + 2. * rd.xz / rd.y);\n      ff = Fbm2 (q);\n      f = smoothstep (0.2, 0.8, ff);\n      fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n      clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n         smoothstep (0., 0.05, abs (fd)));\n      col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n      col += 0.1 * pow (smd, 16.) + 0.2 * pow (smd, 256.);\n    }\n  }\n  return col;\n}\n\n#endif\n\n#if ALL_PG || ! UNWAT\n\nfloat WakeFac (vec3 p)\n{\n  vec2 tw;\n  tw = Rot2D (p.xz - sbPos.xz, sbRot);\n  tw.y += 6.5;\n  return (1. - smoothstep (0.3, 0.6, abs (tw.x) + 0.1 * tw.y)) * clamp (1. - 2. * tw.y, 0., 0.2) *\n     smoothstep (-5., -2., tw.y);\n}\n\n#endif\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = (isDark || unWat || inCave) ? vec4 (0.5, 0.4, 0.3, -1.) : vec4 (0.4, 0.4, 0.5, 0.1);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n    if (isDark) col4.rgb *= 0.5;\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, vno, vnb, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;\n  vec2 lbDist, ws;\n  float dstObj, dstObjO, dstCave, dstGrnd, dstWat, sh, atten, wkFac, s;\n  bool waterRefl;\n  dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n  if (inEnv && inCave) {\n    dstCave = CaveRay (ro, rd);\n    if (dstCave < min (dstObj, dstFar)) {\n      dstObj = dstCave;\n      idObj = idCav;\n    }\n  }\n#endif\n#if ALL_PG || UNWAT  \n  if (inEnv && unWat) {\n    dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n    if (dstGrnd < min (dstObj, dstFar)) {\n      dstObj = dstGrnd;\n      idObj = idGrnd;\n    }\n  }\n#endif\n  sh = 1.;\n  atten = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  if (inEnv && unWat) {\n#if ALL_PG || UNWAT  \n    if (dstObj < dstFar) {\n      if (idObj == idGrnd) {\n        ro += dstObj * rd;\n        col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),\n           0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +\n           0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));\n        vn = GrndNf (ro);\n        vno = vec3 (0., 1., 0.);\n        if (vn.y > 0.85) {\n          vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));\n          vn = vn4.xyz;\n          col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);\n        }\n        vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));\n        ws = ro.xz - sbPos.xz;\n        ws = Rot2D (ws, sbRot);\n        sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -\n           vec2 (0., clamp (ws.y, - sbLen, sbLen))) -\n           1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *\n           (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));\n#if ALL_PG || INCAVE\n        if (inCave) sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), \n           0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));\n#endif\n        col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n      } else if (idObj == idCav) {\n#if ALL_PG || INCAVE\n        ro += dstObj * rd;\n        vn = CaveNf (ro);\n        vno = vn;\n        col = vec3 (0.4, 0.4, 0.4);\n        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));\n        vn = VaryNf (ro, vn, 12.);\n        col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +\n           0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));\n        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));\n#endif\n      } else {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        vno = vn;\n        col4 = NautColN (ro, vn);\n        sh = ObjSShadow (ro, vec3 (0., 1., 0.));\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));\n          col *= vec3 (0.7, 0.9, 1.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      }\n      col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);\n    } else {\n      col = UnwCol (rd) + WatShd (rd);\n    }\n#endif\n  } else if (! inEnv || inEnv && ! unWat) {\n#if ALL_PG || ! UNWAT\n    roo = ro;\n    dstObjO = dstObj;\n    bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n    waterRefl = false;\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {\n        dstWat = - ro.y / rd.y;\n        waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);\n      } else {\n        dstWat = dstFar;\n      }\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      dstWat = WaveRay (ro, rd);\n      waterRefl = (dstWat < min (dstFar, dstObj));\n#endif\n    }\n    if (waterRefl) {\n      ro += dstWat * rd;\n      row = ro;\n#if ALL_PG || INCAVE\n      if (inCave) vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);\n#endif\n#if ALL_PG || ! INCAVE\n      if (! inCave) vnw = WaveNf (ro, dstWat);\n#endif\n      wkFac = WakeFac (row);\n      if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n#if ALL_PG || INCAVE\n      if (inCave) {\n        dstCave = CaveRay (ro, rd);\n        if (dstCave < min (dstObj, dstFar)) {\n          dstObj = dstCave;\n          idObj = idCav;\n        }\n      }\n#endif\n      if (bmOn) {\n        rob[1] = ro;\n        rdb[1] = rd;\n      }\n    }\n    if (inEnv && inCave) {\n#if ALL_PG || INCAVE\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        ltVec = roo + ltPos - ro;\n        s = length (ltVec);\n        atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));\n        ltVec /= s;\n        if (idObj == idCav) {\n          vn = CaveNf (ro);\n          col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),\n             smoothstep (0.5, 0.8, vn.y)), 0.5);\n          sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));\n          vn = VaryNf (ro, vn, 12.);\n        } else {\n          vn = ObjNf (ro);\n          col4 = NautColN (ro, vn);\n          sh = ObjSShadow (ro, ltVec);\n        }\n        if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n        else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;\n      } else col = bgCol;\n      if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);\n#endif\n    } else if (inEnv && ! inCave) {\n#if ALL_PG || ! INCAVE\n      if (dstObj < min (dstWat, dstFar)) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        sh = isDark ? 1. : ObjSShadow (ro, sunDir);\n        if (col4.a >= 0.) {\n          col = col4.rgb * (0.3 + 0.2 * max (- dot (vn, sunDir), 0.) +\n             0.7 * sh * max (dot (vn, sunDir), 0.)) +\n             col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n        } else {\n          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n        }\n      } else {\n        col = SkyHrzCol (rd);\n      }\n      if (waterRefl) col *= 0.6;\n      if (isDark) col *= 0.8;\n#endif\n    } else if (! inEnv) {\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = NautColN (ro, vn);\n        col4.rgb = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);\n#if ISBOOK\n        col4.rgb *= vec3 (0.8, 0.8, 0.85);\n#else\n        col4.rgb *= mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));\n#endif\n      if (col4.a < 0.) col4.a = 0.2;\n        s = max (dot (vn, sunDir), 0.);\n        col = col4.rgb * (0.2 + 0.8 * s * s) +\n           2. * col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n      } else {\n        col = vec3 (0., 0., 0.5);\n      }\n    }\n#if ALL_PG || ! UNWAT\n    if (inEnv && waterRefl && wkFac > 0.) {\n      s = Fbm3 (16. * row);\n      if (inCave) col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n      else col = mix (col, vec3 (0.9), 8. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n    }\n#endif\n#if ALL_PG || ! UNWAT && ! INCAVE\n    if (inEnv && waterRefl && ! inCave) {\n      col = mix (col, vec3 (0.7), pow (clamp (2.8 * WaveHt (row.xz) +\n         0.5 * Fbm3 (32. * row), 0., 1.), 8.));\n    }\n#endif\n#endif\n  }\n  if (inEnv && bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    if (unWat) {\n#if ALL_PG || UNWAT\n      vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);\n      if (lbDist.x < min (dstObj, dstFar))\n         col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));\n#endif\n    }\n    if (! unWat) {\n#if ALL_PG || ! UNWAT\n      if (lbDist.x < min (min (dstObjO, dstWat), dstFar))\n         col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));\n      if (waterRefl) {\n        lbDist = LBeamRay (rob[1], rdb[1]);\n        if (lbDist.x < min (min (dstObj, dstWat), dstFar))\n           col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));\n      }\n#endif\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, s, dVu, tVuCyc;\n  uv = fCoord;\n#if ISBOOK\n  tCur += 30. * idPage;\n#endif\n#if ALL_PG\n#if ! ISBOOK\n  tVuCyc = 20.;\n  idPage = floor (mod (tCur / tVuCyc, 6.)) + 1.;\n#endif\n  unWat = (idPage == 4. || idPage == 5.);\n  inCave = (idPage == 5. || idPage == 6.);\n  isDark = (idPage == 3.);\n  inEnv = (idPage >= 2.);\n#elif ISBOOK && ! ALL_PG\n  unWat = false;\n  inCave = false;\n  isDark = (idPage == 3. || idPage == 5.);\n  inEnv = (idPage >= 2.);\n#else\n  unWat = (UNWAT == 1);\n  inCave = (INCAVE == 1);\n  isDark = (ISDARK == 1);\n  inEnv = (INENV == 1);\n#endif\n  cvSize = 7.;\n  if (inEnv) {\n    bmOn = isDark || unWat || inCave;\n  } else {\n    bmOn = false;\n    isDark = false;\n  }\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  if (inEnv && inCave) {\n    fpF = TrackPathCv (t + 0.1);\n    fpB = TrackPathCv (t - 0.1);\n    sbPos = 0.5 * (fpF + fpB);\n    sbPos.y = 0.09;\n    vd = fpF - fpB;\n    sbRot = atan (vd.x, vd.z);\n  } else if (inEnv && ! inCave) {\n    sbPos = vec3 (0., 0.09, t);\n    if (! unWat) sbPos.y = 0.1 - 0.5 * (1. + sin (0.1 * 2. * pi * tCur));\n    sbRot = 0.;\n  } else if (! inEnv) {\n    sbPos = vec3 (0.);\n    sbRot = -0.25 * pi;\n  }\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  s = unWat ? 1. : -1.;\n  if (inEnv && inCave) {\n    dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n    t += 20. * dVu;\n    fpF = TrackPathCv (t + 0.1 * sign (dVu));\n    fpB = TrackPathCv (t - 0.1 * sign (dVu));\n    ro = 0.5 * (fpF + fpB);\n    ro.x += 2. * s * (1. - abs (dVu));\n    ro.y = 2. + 2. * (1. - abs (dVu));\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 50. * cvSize;\n    zmFac = 1.4;\n  } else if (inEnv && ! inCave) {\n    ro.xz = sbPos.xz + 24. * sin (0.01 * s * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    ro.y = unWat ? -2. : 2.;\n    vd = sbPos - ro;\n    vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = unWat ? 2. : 4.;\n  } else if (! inEnv) {\n#if ISBOOK\n    ro = vec3 (0., 8., 24.);\n    vd = sbPos + vec3 (-1., 0., 0.) - ro;\n    vuMat = StdVuMat (atan (vd.y, length (vd.xz)), atan (vd.x, vd.z));\n    dstFar = 100.;\n    zmFac = 6.;\n#else\n    az += 0.05 * pi * tCur;\n    el -= 0.1 * pi * sin (0.04 * pi * tCur);\n    vuMat = StdVuMat (el, az);\n    dstFar = 60.;\n    zmFac = 5.;\n    ro = vuMat * vec3 (0., 0., -24.);\n#endif\n  }\n  ltPos = vuMat * vec3 (0., 1., 1.);\n  if (inEnv) {\n    sunDir = normalize (vec3 (1., 3., -1.));\n  } else {\n#if ISBOOK\n    sunDir = normalize (vec3 (-0.1, 0.4, 1.));\n#else\n    sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#endif\n  }\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  if (inEnv && unWat) {\n#if ISBOOK\n    uv *= vec2 (pgSize.z  / pgSize.x, 1.);\n#else\n    uv *= vec2 (9./16., 1./0.85);\n#endif\n    col *= 1. - 0.8 * smoothstep (0.9, 1., length (uv));\n  }\n  fCol = col;\n}\n\n#if ISBOOK\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, bc, thFac, nRing, y, s, w;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  nRing = 3.;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  s = mod (nRing, 2.);\n  w = pgSize.z / nRing;\n  bc = q.z;\n  bc = mod (bc + s * w, 2. * w) - w;\n  for (int k = VAR_ZERO; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    y = q.y + np * thFac * pgSize.y * phsTurn;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, y), -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    d = hRad - length (vec2 (q.x - rRad, bc));\n    q.x -= pgSize.x - hOff + rRad;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), d);\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = bc;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (3.2, 0.011, 1.8);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = (idPage > 1.) ? vec3 (0.8, 0.8, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz)) :\n         vec3 (0.1, 0.1, 0.6);\n      col4 = vec4 (c, 0.2);\n      s = pgSize.xz - abs (qHit.xz);\n      if (qHit.y > 0.) {\n        w = qHit.xz / pgSize.z;\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (idPage > 1. && min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#endif\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n#if ISBOOK\n  tpBook = max (0.35 * tCur - 1., 0.);\n  az = 0.;\n  el = -0.5 * pi;\n#endif\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n#if ISBOOK\n    tpBook = - clamp (1.05 * mPtr.x + 0.45, 0., 1.);\n    msEl = 0.5 * pi * mPtr.y * smoothstep (0.1, 0.15, abs (mPtr.y));\n#else\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n#endif\n  }\n#if ISBOOK\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (3.2, 0., -20.);\n  zmFac = 9.5;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n  ro = vuMat * ro;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ExShowScene (ro, rd);\n#else\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n#endif\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVSWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[178, 2153, 2181, 2181, 2280], [10076, 10076, 10099, 10099, 12980], [12982, 12982, 13004, 13004, 13164], [13166, 13166, 13199, 13199, 13382], [13384, 13384, 13405, 13405, 13660], [13662, 13662, 13699, 13699, 13940], [13942, 13942, 13965, 13965, 14301], [14303, 14303, 14337, 14337, 14559], [14561, 14561, 14584, 14584, 14843], [14845, 14845, 14884, 14884, 17613], [17615, 17615, 17650, 17650, 25915], [25917, 25917, 25962, 25962, 29008], [32338, 32338, 32394, 32394, 33343], [33345, 33345, 33378, 33378, 33467], [33469, 33469, 33515, 33515, 33562], [33564, 33564, 33597, 33597, 33624], [33626, 33626, 33668, 33668, 33719], [33721, 33721, 33780, 33780, 33911], [33913, 33913, 33966, 33966, 34027], [34029, 34029, 34075, 34075, 34132], [34134, 34134, 34156, 34156, 34194], [34196, 34196, 34232, 34232, 34438], [34440, 34440, 34485, 34485, 34588], [34590, 34590, 34647, 34647, 34730], [34732, 34732, 34762, 34762, 34875], [34909, 34909, 34933, 34933, 34986], [34988, 34988, 35012, 35012, 35124], [35126, 35126, 35150, 35150, 35213], [35215, 35215, 35239, 35239, 35358], [35360, 35360, 35385, 35385, 35571], [35573, 35573, 35598, 35598, 35823], [35825, 35825, 35850, 35850, 36171], [36173, 36173, 36198, 36198, 36344], [36346, 36346, 36368, 36368, 36522], [36524, 36524, 36545, 36545, 36700], [36702, 36702, 36723, 36723, 36878], [36880, 36880, 36909, 36909, 37121], [37123, 37123, 37162, 37162, 37347]], "test": "untested"}
{"id": "3lVXWh", "name": "Colour waves", "author": "nturton", "description": "Simple waves of moving colours.", "tags": ["simple"], "likes": 1, "viewed": 89, "published": "Public", "date": "1582655267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime*vec3(1.0, sqrt(2.), sqrt(3.)) +\n                             xy.x*vec3(4.0, -2.0, -2.0) +\n                             xy.y*vec3(0.0, sqrt(12.0), -sqrt(12.0)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 378]], "test": "untested"}
{"id": "3lVXzD", "name": "//by evvvvil_", "author": "foran", "description": "//by evvvvil_", "tags": ["byevvvvil"], "likes": 2, "viewed": 84, "published": "Public", "date": "1582306660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by evvvvil_\nvec2 z,v,e=vec2(.0035,0035);\nfloat t,tt,bb,g,g2,td,noise,texNoi;\nvec3 np,bp,pp,po,no,ld,al;\nvec4 c=vec4(3.14,17.,19.,.51);\nfloat smin(float a,float b,float h){\nfloat k=clamp((a-b)/h*.5+.5,0.,1.);\nreturn mix(a,b,k)-k*(1.-k)*h;}\nfloat smax(float d1,float d2,float k){\nfloat h=clamp(.5-.5*(d2+d1)/k,0.,1.);\nreturn mix(d2,-d1,h)+k*h*(1.-h);}\nfloat bo(vec3 p,vec3 r){\np=abs(p)-r;\nreturn max(max(p.x,p.y),p.z);}\nmat2 r2(float r){\nreturn mat2(cos(r),sin(r),-sin(r),cos(r));}    \n\nfloat hash1(vec2 p)\n{\n    p=50.*fract(p*.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat hash1(float n)\n{\n    return fract(n*17.*fract(n*.3183099));\n}\n\nfloat noi(in vec3 x)\n{\n    vec3 p=floor(x);\n    vec3 w=fract(x);\n    vec3 u=w*w*w*(w*(w*6.-15.)+10.);\n    float n=p.x+317.*p.y+157.*p.z;\n    float a=hash1(n+0.);\n    float b=hash1(n+1.);\n    float c=hash1(n+317.);\n    float d=hash1(n+318.);\n    float e=hash1(n+157.);\n    float f=hash1(n+158.);\n    float g=hash1(n+474.);\n    float h=hash1(n+475.);\n    float k0=a;\n    float k1=b-a;\n    float k2=c-a;\n    float k3=e-a;\n    float k4=a-b-c+d;\n    float k5=a-c-e+g;\n    float k6=a-b-e+f;\n    float k7=-a+b+c-d+e-f-g+h;\n    return-1.+2.*(k0+k1*u.x+k2*u.y+k3*u.z+k4*u.x*u.y+k5*u.y*u.z+k6*u.z*u.x+k7*u.x*u.y*u.z);\n}\n\nfloat gn(vec3 m)\n{float fi,n=0.;\nfor(int i=2;i<5;i++)\nfi=float(i),n+=1./fi*noi(m*fi);\nreturn n;}\n//-------------\nvec2 column( vec3 p ){\npp=abs(p+vec3(0,-16.,0))-vec3(0,6.,0);\nvec2 h,t=vec2(length(pp)-2.2,.6); \nt.x=abs(t.x)-.3;\nt.x=max(t.x,-pp.y);\nh=vec2(length(pp)-2.2,3.);\nh.x=abs(h.x)-.1;\nh.x=max(h.x,-pp.y-.5);\npp.xz*=r2(1.2+sin(p.y)*.5);\nh.x=min(h.x,bo(abs(abs(pp)-vec3(.5,0.,.6))-vec3(1,0,.3),vec3(.2,10.,.15)));\nt=t.x<h.x?t:h;\n//----------\nh=vec2(bo(abs(abs(pp)-vec3(.5,0.,.6))-vec3(1.,0.,.3),vec3(.3,10.,.01)),6.);g+=.1/(.1+h.x*h.x*(500.-sin(p.y*.5+tt*2.)*499.));\nt=t.x<h.x?t:h;\nh=vec2(length(p.xz+texNoi*2.5+noi(p*.2+vec3(0.,tt*2.,0.)))-.5,5.);\ng2+=.1/(.1+h.x*h.x*(.5-sin(p.y*.5+tt*2.)*.4));\nt=t.x<h.x?t:h;\nt.x*=.85;\nreturn t;}\n    vec2 mp( vec3 p )\n    {\n        float texNoi=texture(iChannel1,.5*vec2(p.y,dot(p.xz,vec2(.7)))).r*.0002;\n        td=noi(p*.2+1.5)*3.-noi(p*2.-.5)*.1-noi(p*.05)*2.+\n        noi(p*.03)*5.-noi(p*.5)+texNoi;\n        float ripple=sin(length(sin(p.x*.2))-1.+tt*10.)*5.;\n        pp=p+td;\n        bb=sin(p.x*.1)*1.5-sin(p.x*30.)*.01;\n        pp.y-=bb;\n        vec2 h,t=vec2(pp.y+5.,5.);\n                \nt.x=smin(t.x,length(abs(pp.xz+noi(p*1.5)*.2)-vec2(6.,6.))\n-(1.1-sin(p.y*.2)+sin(p.y*30.)*.052),3.);\nt.x=smin(t.x,length(abs(pp.xy+noi(p*1.5)*.2-vec2(0.,3.))-vec2(12.,0.))\n-(1.1-sin(p.z*.2)),13.);\n        t.x*=.55;\n        h=column(p+vec3(-3.-1.,5.,-4));\n        t=t.x<h.x?t:h;\n        return t;\n    }\n    \nvec2 tr(vec3 ro,vec3 rd)\n{\nvec2 h,t=vec2(.1);\nfor(int i=0;i<128;i++){\nh=mp(ro+rd*t.x);\nif(h.x<.0001||t.x>90.)break;\nt.x+=h.x;\nt.y=h.y;\n}\nif(t.x>90.)t.y=-.5;\nreturn t;\n}\n\n#define a(d)clamp(mp(po*no*d).x/d,0.,1.)\n#define s(d)smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv-=.5;\n    uv/=vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime*.2,62.83);\n    vec3 ro=vec3(cos(c.x*tt*c.w)*c.z, c.y, sin(c.x*tt*c.w)*c.z);\n    vec3 cw=normalize(vec3(0)-ro);\n    vec3 cu=normalize(cross(cw,vec3(0,1,0)));\n    vec3 cv=normalize(cross(cu,cw));\n    vec3 rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.091)-length(uv)*.09;\n    ld=vec3(.2,.3,-.4);\n    z=tr(ro,rd);\n    t=z.x;\n    if(z.y>-.10){//WE HIT SOMETHING \n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy).x+\n        e.yyx*mp(po+e.yyx).x+\n        e.yxy*mp(po+e.yxy).x+\n        e.xxx*mp(po+e.xxx).x);\n        al=mix(vec3(1.),vec3(.1,.3,.4),.5+.5*sin(td*10.)-bb);\n        if(z.y>5.)al=vec3(1.);\n        float dif=max(2.,dot(no,ld));\n        float fr=pow(1.+dot(no,rd),4.);\n        float sp=pow(max(dot(reflect(-ld,no),-rd),0.),20.);\n        co=mix(sp+al*(a(.1)*a(.3)+.2)*(dif*s(2.)),fo,min(fr,.4));\n        co=mix(fo,co,exp(-.0001*t*t*t));\n    }\n    fragColor=vec4(pow(co+g*.1+g2*.2*vec3(0.,.2,.3),vec3(.45)),1);\n    }", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 173, 173, 240], [241, 241, 279, 279, 351], [352, 352, 376, 376, 419], [420, 420, 437, 437, 481], [487, 487, 508, 508, 576], [577, 577, 599, 599, 644], [646, 646, 668, 668, 1255], [1257, 1257, 1275, 1275, 1353], [1354, 1370, 1392, 1392, 1992], [1997, 1997, 2020, 2020, 2693], [2699, 2699, 2725, 2725, 2867], [2956, 2956, 3010, 3010, 4103]], "test": "untested"}
{"id": "3lyXDm", "name": "[TWITCH] Mandelbox Sweeper", "author": "evvvvil", "description": "Mandelbox Sweeper - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["fractal", "terrain", "mandelbrot", "mandelbulb", "demoscene", "particles", "beam", "glow", "mandelbox", "starfield", "twitch", "improv"], "likes": 113, "viewed": 5422, "published": "Public", "date": "1582827650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mandelbox Sweeper - Result of an improvised live coding session on Twitch\n// Thankx to crundle, jeyko aka wrighter and alkama for the hive mind\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Make your friends believe that you have a bowl of limes by painting a bowl of lemons green\" - Viz\n\nvec2 z,v,e=vec2(.000035,-.000035);float t,tt,b,g,g2,bb; vec3 np,bp,pp,po,no,al,ld;//global vars. The city of Norwich, pronounced \"shit-hole\", will be the butt of today's jokes. \nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function // Norwich is the capital of middle class England and home to 142000 boring cyclists.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function // People from Norwich actually live in London, they can be found near Bethnal Green, pricing out the locals with their East-Anglian petro Dollars.\nvec2 fb( vec3 p, float m)\n{ \n  p.y+=bb*.05; //Make those pesky blue lines dash at the top of the fractal. Racing like art students offended by the lack of houmous served on Norwich university campuses.\n  vec2 h,t=vec2(bo(p,vec3(5,1,3)),3); //Blue box base, East Anglia's finest shape since Allan Partridge's striped ties.\n  t.x=max(t.x,-(length(p)-2.5)); //Dig fucking hole in box base, because sanctions against the city of Norwich for breeding hipsters should be debated in parliament.\n  t.x=max(abs(t.x)-.2,(p.y-0.4));  //Onion trick + cut that shit with horizontal plane . \n  h=vec2(bo(p,vec3(5,1,3)),6);  //Another fucking box this time white. Nothing exciting, neither here nor in Norwich. \n  h.x=max(h.x,-(length(p)-2.5)); //Dig another fucking hole, this time in the white box. \n  h.x=max(abs(h.x)-.1,(p.y-0.5)); //Onion trick + cut that shit with horizontal plane.\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(p+vec3(0,0.4,0),vec3(5.4,0.4,3.4)),m); //Blue or orange box, material ID passwed in fb function call\n  h.x=max(h.x,-(length(p)-2.5)); //Bored of all this digging hole bullshit but had to be this way with the onion trick fucking with my drilling rig\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(p)-2.,m); //Finally, stick a ball in the hole (that's what she said)\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  t.x*=0.7; return t; //Tweak distance field to avoid artifact and return the whole shit\n}\nvec2 mp( vec3 p )\n{ \n  pp=bp=p; //Setup bullshit new postions pp and bp based on p,  \n  bp.yz=p.yz*=r2(sin(pp.x*.3-tt*.5)*.4); //add twist along z axis (due to line below bullshit x axis will become z axis. I know, dumb as fuck, but not as dumb as a vegetarian sausage)\n  p.yz*=r2(1.57);//This is some real bullshit, whoever thought it was a good fucking idea to rotate the whole fucking thing rather than flip variables in fb, is a fucking bell-end... Ah, yes, that would be me.\n  b=sin(pp.x*.2+tt); //Setup animation variable used all over the shop, you gotta punch the math in if you wanna wiggle\n  bb=cos(pp.x*.2+tt); //Setup animation variable used all over the shop, the opposite of above, sort of\n  p.x=mod(p.x-tt*2.,10.)-5.; //Modulo along z axis (x is now z, yeah I know, still dumb as fuck, but not as dumb as giving 2.5k fines to the homeless. Yeah I'm looking at you, Oxford, you cruel bastard.\n  vec4 np=vec4(p*.4,.4); //make new position np a vec4 for fractal so we can track the scale changes in the .w scalar and reuse that shit later to spank the distance field into shape to avoid artifact \n  for(int i=0;i<4;i++){ //\"Less is more\" when it comes to iterations, same could be said about prison time.\n    np.xyz=abs(np.xyz)-vec3(1,1.2,0); //Kaleidoscopic mandelbullshit\n    np.xyz = 2.*clamp(np.xyz, -vec3(0), vec3(2,0.,4.3+bb)) - np.xyz; //Adding the box in \"mandelbox\", thgankx to alkama for the help there\n    np=np*(1.3)/clamp(dot(np.xyz,np.xyz),0.1,.92); //each iter with scale and clamp the mess into beauty. Bit like rhinoplasty, but without the black eyes\n  }  \n  vec2 h,t=fb(abs(np.xyz)-vec3(2,0,0),5.);//Fuck it we still gonna abs symetry kaleidoscope that shit one more time for more details\n  t.x/=np.w; //Yeah that's where the trick is to render fractal without artifact by tweaking domain using the .w scaling scalar \n  t.x=max(t.x,bo(p,vec3(5,5,10))); //Contain the fractal within a box, cuts the sides a bit\n  np*=0.5; np.yz*=r2(.785); np.yz+=2.5; //reuse np fractal positions to create another bigger orange fractal on the side\n  h=fb(abs(np.xyz)-vec3(0,4.5,0),7.); //np on line above was scaled, rotated and shifted a bit, once again another abs symetry to increase amount of geom\n  h.x=max(h.x,-bo(p,vec3(20,5,5))); //remove inside bits of bigger orange fractal\n  h.x/=np.w*1.5; //Again trik to render fractal without artifact reusing .w scaling scalar\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(np.xyz,vec3(0.0,b*20.,0.0)),6); //Mega glowy light sweeper is here broski, time to take your pants off and indulge.\n  h.x/=np.w*1.5; //Since we're using fractal position np again but this itme inside box, still we have to do the scaling scalar trick again to improve rendering\n  g2+=0.1/(0.1*h.x*h.x*(1000.-b*998.)); //Balkhan's super sick glow trick, with my added sweep along z axis hot sauce. Things are getting too fucking spicy for the pepper!\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(0.6*bp.y+sin(p.y*5.)*0.03,6); //Make a terrain out of a frilled horizontal plane, resue bp position to get the twist as well\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(cos(bp.xyz*.6+vec3(tt,tt,0)))+0.003,6); //Make it fucking rain sparkly little fucking particles. Because everything looks better when sprinkled with glitter, even Norwich city centre.\n  g+=0.1/(0.1*h.x*h.x*4000.); //Make the particle glow and pack the glow with that 4000\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>40.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  vec3 ro=mix(vec3(1),vec3(-0.5,1,-1),ceil(sin(tt*.5)))*vec3(10,2.8+0.75*smoothstep(-1.5,1.5,1.5*cos(tt+0.2)),cos(tt*0.3)*3.1),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.4,-.3)); //ld=light direction\n  co=fo=vec3(.1,.2,.3)-length(uv)*.1-rd.y*.2; //background is blueish with vignette and subtle vertical gradient based on ray direction y axis. It's dark like the heart of people from Norwich.\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(0.1,0.2,.4),vec3(0.1,0.4,.7),.5+0.5*sin(bp.y*7.)); //al=albedo=base color, by default it's a mix between blue/turquoise and darker blue. mix is done by reusing bp in a sin, weird I know but not as weird as Norwich's suburban dogging scene\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=mix(vec3(1,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*7.)); //Material ID 7 gives us greadient orange -> red colour, again mixing between colours by reusing bp in a sin\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //Sp=specular, stolen from Shane, below you will find: mix(vec3(.8),vec3(1),abs(rd))*al is a sick trick by crundle to tweak colour depending on ray direction\n    co=mix(sp+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(2.)),fo,min(fr,.2)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0003*t*t*t)); //Fog soften things, but it won't stop failed art students from becoming dictators.\n  }\n  fragColor = vec4(pow(co+g*.2+g2*mix(vec3(1.,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*3.)),vec3(0.65)),1);// Naive gamma correction and glow applied at the end\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[443, 539, 563, 563, 604], [605, 716, 733, 733, 776], [777, 943, 970, 970, 2445], [2446, 2446, 2465, 2465, 5986], [5987, 5987, 6069, 6069, 6832], [6922, 6922, 7051, 7051, 10041]], "test": "untested"}
{"id": "3lyXzz", "name": "Motion Loop #003", "author": "lsdlive", "description": "A small one, just to practice patterns.", "tags": ["2d", "loop", "motion", "ease"], "likes": 5, "viewed": 371, "published": "Public API", "date": "1582036063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #003\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_003.fs\n\nWith the help of: https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n\n*/\n\n#define bpm 120.\n#define speed .25\n#define cross_height .1\n#define cross_width .4\n#define circle_radius .25\n#define circle_stroke .2\n\n#define AA 5.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat bridge(float mask, float sdf, float w) {\n    mask *= 1. - stroke(sdf, w * 2.);\n    return mask + stroke(sdf, w);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t1 = fract(time * .25);// sliding\n    float t2 = fract(time);// rotation\n    t2 = easeInOutQuad(t2);\n    \n    uv *= r2d(pi * .25);\n    vec2 uv1 = fract((uv + t1) * 4.) - .5;\n    vec2 uv2 = fract(((uv-vec2(t1, 0)) * 4.)+.5) - .5;\n\n    // layer1 - cross\n    float mask = fill(rect(uv1 * r2d(t2 * pi), vec2(cross_height, cross_width)));\n    mask += fill(rect(uv1 * r2d(t2 * pi), vec2(cross_width, cross_height)));\n    \n    // layer2 - circle\n    mask = bridge(mask, circle(uv2, circle_radius), circle_stroke) ;\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXzz.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[514, 640, 659, 659, 725], [727, 727, 748, 748, 805], [807, 940, 976, 976, 1048], [1050, 1050, 1096, 1096, 1170], [1172, 1172, 1208, 1208, 1239], [1241, 1241, 1272, 1272, 1355], [1357, 1357, 1387, 1387, 1510], [1512, 1512, 1569, 1569, 2288]], "test": "untested"}
{"id": "3t3XDr", "name": "sha1er", "author": "xvart", "description": "was a checker board, not anymore.\n\nhttps://cineshader.com/view/3t3XDr", "tags": ["cineshader"], "likes": 3, "viewed": 5055, "published": "Public API", "date": "1580709529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n\tfloat modular = 10.0f;\n    float moveOffset = iTime/speedMultiplier;  \n    \n    float w = 100./modular/iResolution.y;\n    vec2 aStep =fract(((uv + moveOffset) * 100.) / modular),\n         dStep = smoothstep(-w,w,abs(aStep-.5)-.25);\n    \n    float dStepXY = dStep.x * dStep.y;\n    \n    col = vec3(dStepXY,dStepXY,dStepXY);\n       \n    float blockHeight = dStepXY/2.0;\n\n    fragColor = vec4(col, blockHeight);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"sha1er\",\n\t\"description\": \"was a checker board, not anymore. Improved by Fabrice Neyret\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 685]], "test": "untested"}
{"id": "3t3XRB", "name": "被隔離: 武漢市 ", "author": "zproxy", "description": "Sub sole vanitas, Supra solem veritas", "tags": ["2d", "animation", "loop", "flag", "biohazard"], "likes": 3, "viewed": 88, "published": "Public", "date": "1581170537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// either \n//WebGL2: Hardware accelerated\n// or restart browser\n//Hardware accelerated but at reduced performance\n//Unknown Error: ERROR: 0:? : '' : syntax error\n//INVALID_VALUE: shaderSource: string not ASCII\n\n\n// https://www.shadertoy.com/view/wdK3zm\n\nvec3 Star(vec2 uv,vec2 pos,float angle,float scale) \n{\n    uv -=pos;\n    uv *=mat2(sin(radians(angle) + vec4(1,0,2,1)*1.5707));\n    uv /=scale;\n    float a = mod(atan(uv.x,-uv.y),2.*0.6283185)-0.6283185;\n    vec2 preuv = length(uv) * vec2(cos(a),sin(a))*1.23606794;\n    preuv.y = abs(preuv.y);\n    preuv.x -= 0.5;\n    float value = -(0.3467647*preuv.x+preuv.y)*25.534033;//0.2467647,15.534033;\n    return vec3(clamp(value,0.,1.));\n}\n\n// https://www.shadertoy.com/view/4lVfW3\n#define S(x,r) smoothstep( 2e2/R.y, 0., length(vec2(x-l*cos(a),l*sin(a))) -r )//\n#define xmainImage( O, u )                                       \\\n    vec2  R = iResolution.xy * 0.5,                                   \\\n          U = u+u - R;                                          \\\n    float l = length(U)*30./R.y,  /* .955 = 3/pi  1.05 = pi/3 */\\\n          a = ( mod( .955*atan(U.y,U.x)-.5, 2.) - 1. ) *1.05,   \\\n          c = S(15.5,10.5);                                     \\\n    O.r = max( 0., S(12.,15.) - S(,3.) - c                      \\\n                   - max( 0., 1. - (abs(a)-.1)*R.y*.1 )         \\\n             ) + S(,14.) - S(,10.5)                             \\\n               + S(15.,9.) - c                                 \n\n// https://www.shadertoy.com/view/MtKXzV\nvec2 rot( vec2 p, float l ){\n\tvec2 r;\n\tfloat sl= sin(l), cl= cos(l);\n\tr.x= cl*p.x - sl*p.y;\n\tr.y= sl*p.x + cl*p.y;\n\treturn r;\n}\n\nvoid emainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 p= uv;\n\n\tvec3 r= vec3(0.0);\n\n\tfloat at= atan(p.x,p.y);\n\n\tfloat rad= 0.8 * 0.45;\n\n\trad -= 0.06*abs(cos(at*4.0));\n\n\tvec2 ph= rot(p,0.125*3.141592);\n\tvec2 ph2= rot(p,0.375*3.141592);\n\n\tif( length(uv) < rad && \n       // border size\n       0.005 < min( min( abs(ph.x), abs(ph.y) ), min( abs(ph2.x), abs(ph2.y) ) ) ){\n\t\tif( mod( at -0.125*3.141592, 0.5*3.141592) < 0.25*3.141592 )\n\t\t\tr= vec3(0.7);\n\t\telse\n\t\t\tr= vec3(0.5,0.05,0.05);\n\t}\n\n\tfragColor = vec4(r, 1.0);\n}\n\n              \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 colorGold = vec3(255.0,222.0,0.0)/255.0;\n    vec3 colorRed = vec3(222.0,41.0,16.0)/255.0;\n    \n    float ratio = 1.5;\n    float bInRatio = float(fragCoord.x>0.5*(iResolution.x-iResolution.y*ratio) &&fragCoord.x<iResolution.x-0.5*(iResolution.x-iResolution.y*ratio) );//\n    float preUVx = (fragCoord.x-0.5*(iResolution.x-iResolution.y*ratio))/(iResolution.y*ratio)*30.0;\n    float preUVy = (fragCoord.y)/iResolution.y*20.0;\n    vec2 uv = vec2(preUVx,20.0-preUVy);\n    \n    //BG Color\n    vec3 colorBG = colorRed;\n    \n    //pos1,x:5/30,y:5/20\n    \n    // should we remove stars?\n    float cycle = mod( iTime  / (4.0*atan(1.0)), 18.0);\n\n    vec3 colorSTAR0 = Star(uv,vec2(5,5),180.0,6.0);\n    vec3 colorSTAR = vec3(0.0);\n\n    // big star\n    if (cycle < 14.0) colorSTAR = Star(uv,vec2(5,5),180.0,6.0);\n\n    // show 322 in this cycle?\n    if (cycle < 12.0) colorSTAR = max(Star(uv,vec2(10,2),58.0,2.0),colorSTAR);\n    if (cycle < 10.0) colorSTAR = max(Star(uv,vec2(12,4),91.0,2.0),colorSTAR);\n    if (cycle < 8.0) colorSTAR = max(Star(uv,vec2(12,7),180.0,2.0),colorSTAR);\n    // remove mid cycle/pandemic?\n    if (cycle < 6.0) colorSTAR = max(Star(uv,vec2(10,9),58.0,2.0),colorSTAR);\n    \n    float mask = float(colorSTAR.x>0.0);\n    // Output to screen\n    \n    // float cycle = (iTime - 3.14 / 4.0) / 3.14;\n    //float cycle = mod( iTime  / 3.14, 10.0);\n    \n    //if (cos(iTime * 0.5)>0.0)\n    \n    float irare = 3.5;\n    \n    if (\n        (cycle > 15.5 && cycle < (2.0 + 15.5)) || \n        (cycle > irare && cycle < (2.0 + irare)))\n    {\n        // flicker colorSTAR ?\n        \n        if (cycle > (irare + 0.5))\n        {\n        float small = 1.0/6.0;\n        float strobe = mod( cycle , small*2.0);\n        \n        if (strobe < small)\n        mask *= 0.5; // offmode\n        }\n        \n     emainImage(fragColor,fragCoord);\n    }\n    else\n    {\n     xmainImage(fragColor,fragCoord + vec2(-iResolution.x * 0.25, -iResolution.x*0.125));\n    }    \n    \n    // 5.5 should invert colors?\n    \n    fragColor =  vec4(mix(\n        \n        // 一些動畫\n        max(0.01,0.99 + sin(iTime  )) * fragColor.rgb,\n        \n        \n        //max(0.0,0.99 + sin(iTime)) *\n        colorRed*1.175,mask),1.0)*bInRatio;//*bInRatio   clamp to standard size or not\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 254, 308, 308, 686], [688, 1646, 1704, 1704, 2271], [2288, 2288, 2345, 2345, 4620]], "test": "untested"}
{"id": "3t3XRS", "name": "Alien Tech 2", "author": "Kali", "description": "Based on 2D Mandelbox fractal. ", "tags": ["2d", "fractal", "mandelbox"], "likes": 17, "viewed": 295, "published": "Public", "date": "1581185425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define aa 3\n\nmat2 rot(float a) {\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 fractal(vec2 p) {\n    float c=cos(iTime*.1);\n    p.x+=smoothstep(.5,1.,abs(c))*sign(c)*2.;\n    p*=.4;\n    p.y+=iTime*.05+1.5;\n\tfloat v=(floor(mod(p.y,10.))+smoothstep(.9,1.,fract(p.y)))*.1;\n    p=abs(.5-fract(p*.5));\n    vec2 m=vec2(100.);\n    float s=100.,t=s;\n    for (int i=0; i<10; i++) {\n\t\tp=abs(p+2.)-abs(p-2.)-p;\n        p.x-=3.;\n        p=p*2.5/clamp(dot(p,p),.2,1.)-1.5-v;\n        m=min(m,abs(p));\n        s=min(s,length(p*p*p)*.1);\n\t\tt=min(t,length(p));\n    }\n    s=1.-abs(.5-fract(s))*2.;\n    t=pow(max(0.,1.-t),2.);\n    s-=mod(p.x*.7+1.,16.)*.05;\n    m*=rot(-iTime+p.y*.1);\n    m=normalize(abs(m));\n\treturn vec3(m*m*3.,1.)*smoothstep(0.,3.,atan(m.x,m.y))+.3-s*s*s*10.+t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    uv.x*=sqrt(1.+uv.y);\n    uv.y*=sqrt(1.5+uv.y);\n    vec3 col = vec3(0.);    \n    for (int i=-aa; i<aa; i++) {\n        for (int j=-aa; j<aa; j++) {\n    \t\tcol+=fractal(uv+vec2(i,j)*1./iResolution.xy/float(aa));\n        }\n    }    \n    col*=(1.3-abs(uv.x))*vec3(1.,.7,.4)/float(aa*aa)*.15*smoothstep(0.,1.,iTime);\n\tcol*=max(0.2,1.-uv.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 33, 33, 99], [101, 101, 123, 123, 790], [792, 792, 849, 849, 1279]], "test": "untested"}
{"id": "3t3XWl", "name": "Circle Chaos", "author": "adkaros", "description": "Chaos, complete chaos.", "tags": ["circles", "time", "generative", "looping"], "likes": 4, "viewed": 69, "published": "Public", "date": "1581908829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 st, in float x, in float y){\n    return distance(st,vec2(x, y)) * 5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord/iResolution.xy;\n\n    float c1 = circle(st, 0.1, 0.3);\n    float c2 = circle(st, 0.5, 0.5);\n    float c3 = circle(st, 0.8, 0.6);    \n    \n    vec3 color = vec3((c1+c2) * abs(fract(sin(c2*iTime*50.0)*1.0)));\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3XWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 93], [95, 95, 152, 152, 415]], "test": "untested"}
{"id": "3tcSWj", "name": "The marshmallow cloud machine", "author": "42yeah", "description": "Seems fun to be in there!", "tags": ["marshmallowy"], "likes": 1, "viewed": 66, "published": "Public", "date": "1581659126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n\nvec2 skew(vec2 uv, float deg) {\n    return vec2(uv.x + cos(uv.y), uv.y);\n}\n\nvec2 rot2d(vec2 uv, float deg) {\n    return vec2(cos(deg) * uv.x - sin(deg) * uv.y,\n                sin(deg) * uv.x + cos(deg) * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    vec2 p = uv * 3.0;\n\n    float l = length(p + sin(iTime));\n    p = rot2d(p, iTime * 0.5);\n    p = rot2d(p, l * 0.6);\n    p = skew(p, l * 2.0 + 0.5);\n\n    vec2 f = fract(p);\n    f = rot2d(f, l * 2.0);\n    vec3 blueness = mix(vec3(0.2, 0.4, 0.7), vec3(1.0, 1.0, 1.0), length(f));\n\n    // Output to screen\n    fragColor = vec4(blueness, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 55, 55, 98], [100, 100, 132, 132, 237], [239, 239, 296, 346, 817]], "test": "untested"}
{"id": "3tcXWX", "name": "Digital Heartbeat", "author": "elijahlucian", "description": "idkwtfimdoing", "tags": ["test"], "likes": 2, "viewed": 212, "published": "Public API", "date": "1582181161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dankSin(float v,float x,float t){\n  return sin(v*x+t)*.5+.5;\n}\n\nfloat nsin(float v){\n  return sin(v)*.5+.5;\n}\n\nfloat ncos(float v){\n  return cos(v)*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  \n  float t=iTime*.3;\n  float u=uv.x;\n  float v=uv.y;\n  float PI=3.14;\n  float TAU=PI*2.;\n  float mult=5.5;\n  \n  // VARS\n  float su=dankSin(u,TAU*mult,0.);\n  float sv=dankSin(v,TAU*mult,0.);\n  \n  float d=distance(uv,vec2(.5,.5));\n  float du=distance(u,.5);\n  float dv=distance(v,.5);\n    \n  // SHAPES\n\n  float waves=mod(\n    distance(\n      su*sin(.05*t*TAU+nsin(v*10.+t+u*3.)*2.),\n      su+sin(.05*t*3.+cos(u*10.+t*2.))\n    ),\n    .4\n  );\n\n\n  vec3 circles = vec3(distance(9. * du * d, sin(v)));\n  //circles = mod(t - circles * circles * 15., 1); \n  vec3 shape = mod(t - 2. * circles * circles,1.) + circles * waves;\n//  shape = mod(t - shape * shape * 15., 1.);\n    \n  // COLORS\n  float r=1.;\n  float g=.2;\n  float b=.5;\n  \n  vec3 color=vec3(u*r,g,b);\n    \n  vec3 final = color * shape * 5.;\n    \n  fragColor=vec4(final,1.);\n  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 68], [70, 70, 90, 90, 115], [117, 117, 137, 137, 162], [165, 165, 222, 222, 1093]], "test": "untested"}
{"id": "3tdSDj", "name": "Segment - distance 2D", "author": "iq", "description": "Distance to a line segment. Tutorial on how to derive the code and why it works: [url]https://www.youtube.com/watch?v=PMltMdi1Wzg[/url]. Mouse click and drag to see unbounding sphere", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 13, "viewed": 2928, "published": "Public API", "date": "1581746600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    \n\tfloat d = udSegment( p, v1, v2 ) - th;\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = udSegment(m, v1, v2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSDj.jpg", "access": "shaders20k", "license": "mit", "functions": [[1216, 1377, 1429, 1429, 1552], [1554, 1554, 1611, 1611, 2440]], "test": "untested"}
{"id": "3tdSW2", "name": "Blood moon", "author": "Dijkstra", "description": "Attempt at making a dynamic sky full of stars and a cloud", "tags": ["noise", "cloud", "moon"], "likes": 11, "viewed": 188, "published": "Public", "date": "1581721821", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand21(vec2 uv){\n \tuv = fract(uv*vec2(267.665, 393.725));\n \tuv += dot(uv, uv + 93.89872);\n \treturn fract(uv.x*uv.y);\n}\n\nfloat smoothrand2(vec2 uv, float size){\n    vec2 lv = smoothstep(0.,1., fract(uv*size));\n    vec2 id = floor(uv*size);\n    \n    float bl = rand21(id + vec2(0.,0.));\n    float br = rand21(id + vec2(1.,0.));\n    float tl = rand21(id + vec2(0.,1.));\n    float tr = rand21(id + vec2(1.,1.));\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float c = mix(b, t, lv.y);\n    \n    return c;\n}\n\nfloat smootherrand2(vec2 uv, float size){\n    float total = smoothrand2(uv, size);\n    total += smoothrand2(uv, size*2.)/4.;\n    total += smoothrand2(uv, size*4.)/8.;\n    total += smoothrand2(uv, size*8.)/16.;\n    total += smoothrand2(uv, size*16.)/32.;\n \treturn total;\n}\n\nfloat cloud2(vec2 uv){\n\tvec2 uv2 = uv;\n\tuv2.x+=iTime*.03;\n\tuv2.x = mod(uv2.x+10.,300.);\n\tfloat color = smootherrand2(uv2, 10.)*1.5;\n\n\tfloat d = 1.-length(uv)+.3;\n\td = pow(d, 10.);\n\td = clamp(d, 0.,1.);\n\tcolor *= d;\n\t\n\tfloat min = .2;\n\tfloat h = clamp((1.+min)-length(uv.y),0.,1.);\n\th = pow(h, 10.);\n\tclamp(h, 0.,1.);\n\tcolor *= h;\n\t\n\treturn color * .9;\n}\n\nfloat star(vec2 uv, vec2 id){\n\t\n\tfloat d = length(uv);\n\tfloat rand = rand21(id);\n\tfloat o = (.003/d) * rand;\n\tfloat r2 = id.x -id.y *id.x;\n\to += sin(r2+iTime)*.015;\n\to *= smoothstep(.4,.1,d);\n\treturn o;\n}\n\nfloat skyFullOfStars(vec2 uv){\n\tuv*= 10.;\n\tvec2 gv = fract(uv)-.5;\n\tvec2 id = floor(uv);\n\tfloat col = 0.;\n\tfor(int i=-1;i<=1;++i){\n\t\tfor(int j=-1;j<=1;++j){\n\t\t\tvec2 offset = vec2(i,j);\n\t\t\tfloat rand = rand21(id+offset);\n\t\t\tcol += star(gv-offset - vec2(rand-.5, fract(rand*10.)-.5), id+offset);\n\t\t}\n\t}\n\treturn col;\n}\n\nvec3 backSun(vec2 uv){\n\tvec3 color = vec3(skyFullOfStars(uv));\n\tfloat tmp = clamp((1.- length(uv*2.5)), 0., 1.);\n\tcolor = clamp(color - tmp , 0., 1.);\n\n\tif(length(uv) < .3){\n\t\tcolor = mix(vec3(.94, .29, .26),vec3(.99, .63, .38), 1.-(uv.y+.3)/.6); // color sun original\n\t\t//color = mix(vec3(0.5, 0.,0.),vec3(.86, .07, .23), 1.-(uv.y+.3)/.6); // gregoire color\n\t}\n\n\telse{\n\t\tfloat x = 1.3-length(uv);\n\t\tx = pow(x, 25.); \n\t\tcolor += x * vec3(.84,.16,.16);\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*= iResolution.x/iResolution.y;\n    vec3 color = backSun(uv);\n    float alpha = clamp(cloud2(vec2(uv.x, uv.y+.2)), 0., 1.);\n    alpha = clamp(alpha-.01, 0.,1.);\n    vec3 cloudColor = mix(vec3(.15,.14,.32), vec3(.94, .29, .56), (uv.y+.3)*3.); // original\n    //vec3 cloudColor = vec3(.0,.0,.5);\n\n    color = cloudColor*alpha + (1. - alpha)*color;\n    //color = vec3(uv.y+.1)*3.;\n    //color = vec3(skyFullOfStars(uv));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 124], [126, 126, 165, 165, 531], [533, 533, 574, 574, 804], [806, 806, 828, 828, 1159], [1161, 1161, 1190, 1190, 1365], [1367, 1367, 1397, 1397, 1682], [1684, 1684, 1706, 1706, 2155], [2157, 2157, 2214, 2214, 2727]], "test": "untested"}
{"id": "3tdSWj", "name": "Mercoeur", "author": "JulesFouchy", "description": "coeur", "tags": ["coeur"], "likes": 1, "viewed": 243, "published": "Public API", "date": "1581761992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float heartSDF(vec2 uv){\n  \tfloat x = uv.x; float y = uv.y;\n    \n  \t//             L'ÉQUATION EST LÀ\n    \n    //     | | | | | | | | | | | | | | | | | |\n    //     v v v v v v v v v v v v v v v v v v\n\treturn pow(x*x + y*y - 1., 3.) - x*x*y*y*y;\n}\n\nfloat rand(vec2 id){\n  \tvec2 r = fract(id * vec2(127.34, 456.21));  \n \tr += dot(r, r+475.32);\n    return fract(r.x*r.y);\n}\n\nvec3 rand3(vec2 id){\n    return vec3(rand(id), rand(id*714.62), rand(id*164397.241));\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat singlePuls(vec2 id, float phase){\n    float puls = 2.2 + 1.7*rand(id);\n    float s = 0.5*pow(sin(puls*(iTime + phase) + rand(id)*15.), 2.0);\n    return smin(s, 0., 32.);\n}\n\nfloat heartbeatPuls(vec2 id) {\n    return (singlePuls(id, 0.)\n         +  singlePuls(id, 0.35)) *0.5;\n}\n\nfloat heart(vec2 uv, vec2 id){\n    uv += 0.6* (rand(id)-0.5);\n    uv *= 2.8 * (1. + 4.*heartbeatPuls(id));\n    \n    float margin = 0.00001;\n    return smoothstep(margin, -margin, heartSDF(uv)) - smoothstep(margin, -margin, heartSDF(uv*1.14));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 heartCol = vec3(1.0, 0.2, 0.8);\n    vec3 backCol  = vec3(1.0, 0.65, 0.92);\n    //vec3 backCol  = vec3(255, 237, 110)/255.;\n    //vec3 backCol  = vec3(182, 196, 250)/255.;\n    //vec3 backCol  = vec3(255, 194, 89)/255.;\n    \n    vec2 uv = fragCoord/iResolution.y - vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n   \tuv *= 4.;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    float t = 0.;\n    vec3 col = vec3(0.);\n    for (float x = -1.; x < 1.5; x+=1.){\n        for (float y = -1.; y < 1.5; y+=1.){\n            vec2 off = vec2(x, y);\n            float h = heart(gv - off, id + off);\n            t += h;\n            if (h>0.5)\n                col = heartCol + (rand3(id+off)-0.5)*vec3(0.3, 0.5, 0.5);\n        }\n    }\n    //t = min(t, 1.);\n    //col = t * heartCol + (1.-t) * backCol;\n    \n    if (t < 0.5)\n        col = backCol;\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 248], [250, 250, 270, 270, 372], [374, 374, 394, 394, 461], [463, 463, 502, 502, 576], [578, 578, 617, 617, 755], [757, 757, 787, 787, 860], [862, 862, 892, 892, 1106], [1108, 1108, 1165, 1165, 2056]], "test": "untested"}
{"id": "3tdXDl", "name": "Running Stickfigure", "author": "pyBlob", "description": "Plitch ... Platch ...", "tags": ["walk"], "likes": 2, "viewed": 59, "published": "Public API", "date": "1581961262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = radians(180.);\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-k*a)+exp(-k*b))/k;\n}\nmat3 Tx(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat3(1,0,0, 0,c,-s, 0,s,c);\n}\nmat3 Ty(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat3(c,0,s, 0,1,0, -s,0,c);\n}\nfloat sphere(vec3 x, float r)\n{\n    return length(x) - r;\n}\nfloat square(vec3 x, float r)\n{\n    return length(vec3(max(vec2(0.), abs(x.xz)-r), x.y));\n}\nfloat cube(vec3 x, float r)\n{\n    return length(max(vec3(0.), abs(x)-r));\n}\nfloat capsule(vec3 x, vec3 b, float r)\n{\n    vec3 m = b / 2.;\n    vec3 n = normalize(b);\n    float l = length(b - m);\n    x -= m;\n    return length(vec4(cross(x, n), max(0., abs(dot(x, n))-l))) - r;\n}\nstruct Arm\n{\n    float a, b;\n};\nstruct Body\n{\n    vec3 x;\n    vec4 rippleLeft, rippleRight;\n    Arm legLeft, legRight;\n    Arm armLeft, armRight;\n    float y;\n    float headY;\n};\nfloat arm(vec3 x, Arm joints)\n{\n    float r = 1e8;\n    x -= vec3(0.1,0,0);\n    x = x * Tx(-joints.a);\n    r = min(r, capsule(x, vec3(.20, -.20, 0), .1));\n    x -= vec3(.20, -.20, 0);\n    x = x * Tx(-joints.b);\n    r = min(r, capsule(x, vec3(.05, -.35, 0), .1));\n    x -= vec3(.05, -.35, 0);\n    return r;\n}\nfloat leg(vec3 x, Arm joints)\n{\n    float r = 1e8;\n    x = x * Tx(-joints.a);\n    r = min(r, capsule(x, vec3(.15, -.45, 0), .1));\n    x -= vec3(.15, -.45, 0);\n    x = x * Tx(-joints.b);\n    r = min(r, capsule(x, vec3(.05, -.45, 0), .1));\n    x -= vec3(.05, -.45, 0);\n    r = min(r, sphere(x, .1));\n    return r;\n}\nvec3 mirror(vec3 x)\n{\n\treturn vec3(-x.x, x.yz);\n}\nvoid figure(inout float r, vec3 x, Body joints)\n{\n    x.y -= joints.y;\n    vec3 hip = vec3(0, 1., 0);\n    vec3 neck = vec3(0, 1.45, 0);\n    vec3 head = vec3(0, 1.80 + joints.headY, 0);\n    vec2 arms = vec2(\n    \tarm(mirror(x - neck), joints.armLeft),\n    \tarm(x - neck, joints.armRight)\n    );\n    vec2 legs = vec2(\n        leg(mirror(x - hip), joints.legLeft),\n    \tleg(x - hip, joints.legRight)\n\t);\n    float c = capsule(x - hip, neck-hip, .1);\n    float b = smin(min(arms.x, arms.y), c, 15.);\n    r = min(r, smin(min(legs.x, legs.y), b, 25.));\n    r = min(r, sphere(x-head, .15));\n}\nfloat fade(float p)\n{\n    float c = cos(p * pi);\n    return c*c;\n}\nvoid walkHeight(out float y, float t0)\n{\n    \tfloat t = fract(t0);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; y += f * +0.2f;\n        f = fade(t - 0.20); w += f; y += f * +0.0f;\n        f = fade(t - 0.40); w += f; y += f * +0.0f;\n        f = fade(t - 0.60); w += f; y += f * +0.0f;\n        f = fade(t - 0.80); w += f; y += f * +0.0f;\n        y /= w;\n}\nvoid walkCycle(out Arm arm, out Arm leg, float phase, float t0)\n{\n    {\n    \tfloat t = fract(t0 + phase);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; leg.a += f * +1.5f; leg.b += f * -1.7f;\n        f = fade(t - 0.20); w += f; leg.a += f * +0.0f; leg.b += f * -0.0f;\n        f = fade(t - 0.40); w += f; leg.a += f * -1.5f; leg.b += f * +0.5f;\n        f = fade(t - 0.60); w += f; leg.a += f * +0.0f; leg.b += f * -0.9f;\n        f = fade(t - 0.80); w += f; leg.a += f * +0.0f; leg.b += f * -0.0f;\n        leg.a /= w;\n        leg.b /= w;\n    }\n    {\n    \tfloat t = fract(t0 + phase + .5);\n        float f, w = 1e-10;\n        f = fade(t - 0.00); w += f; arm.a += f * +1.0f; arm.b += f * +0.5f;\n        f = fade(t - 0.20); w += f; arm.a += f * -0.0f; arm.b += f * -0.0f;\n        f = fade(t - 0.40); w += f; arm.a += f * -1.0f; arm.b += f * -0.5f;\n        f = fade(t - 0.60); w += f; arm.a += f * +0.0f; arm.b += f * -0.0f;\n        f = fade(t - 0.80); w += f; arm.a += f * +0.0f; arm.b += f * -0.0f;\n        arm.a /= w;\n        arm.b /= w;\n    }\n}\nfloat rounded_square(vec3 x, float r)\n{\n    vec3 y = vec3(x.x, 0, x.z);\n    return length(vec2(x.y, max(0., square(y, r) - .1)));\n}\nfloat tile(vec3 x)\n{\n    float r = 1e8;\n    r = min(r, rounded_square(x, .7));\n    r = min(r, rounded_square(x - vec3(0,-.05,0), .75));\n    return r;\n}\nfloat rippleHeight(vec3 x, vec4 ripple)\n{\n    float l = length(x.xz-ripple.xz);\n    float t = ripple.w;\n    float source = 1. - exp(-pow(l*10.,2.));\n    float front = exp(-pow(l*3.-t*5.,2.));\n    float falloff = 1./(1.+l*l) * (1. - smoothstep(.5, 1., t));\n\treturn .02*sin(l*40.) * source * front * falloff;\n}\nfloat scene(vec3 x, Body joints)\n{\n    float r = 1e8;\n    float scale = 1.;\n    vec3 gx = vec3(x - -joints.x);\n    gx.z = mod(gx.z, 2.2);\n    for (float i=-1. ; i<=1. ; i+=1.)\n    {\n        float ripple = 0.;\n        ripple += rippleHeight(x, joints.rippleLeft);\n    \tripple += rippleHeight(x, joints.rippleRight);\n    \tr = min(r, tile(gx - vec3(0,ripple,2.2*i)));\n    }\n    figure(r, x, joints);\n    return r / scale;\n}\n#define saw(x) abs(fract((x)/2.)*2.-1.)\n#define R iResolution\nvec4 zview(float z)\n{\n\tz = log(z) * 10.;\n    return vec4(saw(z*4.), saw(z*2.), saw(z*1.), 1.);\n}\nvec3 getNormal(vec3 p, Body joints){\n\tvec2 t = vec2(0.0002, 0);\n\treturn normalize(\n    \tscene(p, joints) - vec3(\n        \tscene(p - t.xyy, joints),\n        \tscene(p - t.yxy, joints),\n        \tscene(p - t.yyx, joints)\n        )\n    );\n}\nvec4 crotate(vec4 c, float t)\n{\n    vec4 c2 = c;\n    c2.xyz *= Ty(t);\n    return mix(c, c2, .5);\n}\nvoid mainImage( out vec4 C, in vec2 o )\n{\n    vec2 uv = (o-R.xy/2.)/R.y;\n    float t = iTime * .1;\n    t = -2.0;\n    vec3 dx = normalize(vec3(uv,-1)) * Tx(-.35) * Ty(t);\n    vec3 x = vec3(-2,3,5) * Ty(t);\n    float z = 0.;\n    Body joints;\n    int i=0;\n    {\n        float t = iTime;\n        float v = 2.2;\n        joints.x = vec3(0, 0, -.3-v * t);\n        {\n            float rt = t + .0;\n            joints.rippleLeft = vec4(-0.20, 0, -.3 + v * fract(rt), rt-floor(rt));\n        }\n        {\n            float rt = t + .5;\n            joints.rippleRight = vec4(0.20, 0, -.3 + v * fract(rt), rt-floor(rt));\n        }\n        walkHeight(joints.y, t * 2.);\n        walkCycle(joints.armLeft, joints.legLeft, .0f, t);\n        walkCycle(joints.armRight, joints.legRight, .5f, t);\n        float y1;\n        walkHeight(y1, t * 2. - .1);\n        joints.headY = (y1 - joints.y) * .5;\n    }\n    bool found = true;\n    for ( ; i<100 ; ++i)\n    {\n        float r = scene(x+dx*z, joints);\n        if (z > 100.)\n        {\n            found = false;\n            break;\n        }\n        if (r<z*1e-3 || z > 100.)\n            break;\n        z += r * .5;\n    }\n    C = pow(texture(iChannel0, (dx * Ty(-.5)).xy).zyxw, vec4(1.5))*.3;\n    if (found)\n    {\n        vec3 p = x+dx*z;\n        vec3 normal = getNormal(p, joints);\n        //C = vec4(.5+.5*normal, 1.);\n        vec4 M = vec4(1);\n        if (p.y <= .1)\n        {\n            vec3 pg = p + joints.x;\n            M = crotate(texture(iChannel1, pg.xz), dot(pg.xz, vec2(.5, -.3)));\n        }\n        if (p.y <= -.025)\n            M = vec4(1,1,1, .2);\n        M.xyz *= vec3(.05 + .9 * max(0.,normal.y));\n        M.xyz *= exp(-.2*(z-6.));\n        C = mix(C, M, M.w);\n    }\n    C = sqrt(C);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 71, 71, 113], [114, 114, 132, 132, 203], [204, 204, 222, 222, 293], [294, 294, 325, 325, 353], [354, 354, 385, 385, 445], [446, 446, 475, 475, 521], [522, 522, 562, 562, 722], [902, 902, 933, 933, 1208], [1209, 1209, 1240, 1240, 1522], [1523, 1523, 1544, 1544, 1572], [1573, 1573, 1622, 1622, 2158], [2159, 2159, 2180, 2180, 2225], [2226, 2226, 2266, 2266, 2598], [2599, 2599, 2664, 2664, 3659], [3660, 3660, 3699, 3699, 3791], [3792, 3792, 3812, 3812, 3943], [3944, 3944, 3985, 3985, 4252], [4253, 4253, 4287, 4287, 4673], [4736, 4736, 4757, 4757, 4832], [4833, 4833, 4869, 4869, 5068], [5069, 5069, 5100, 5100, 5167], [5168, 5168, 5209, 5209, 6892]], "test": "untested"}
{"id": "3tdXzS", "name": "Mandelbrot Set RGF", "author": "DaMastaCoda", "description": "first try at glsl\nsimple mandelbrot", "tags": ["mandelbrot"], "likes": 0, "viewed": 33, "published": "Public", "date": "1581220167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0f)/iResolution.x*4.0f;\n    vec2 z = uv;\n    for(int i = 0; i < 5000; i++) {\n        z.xy = vec2(z.x*z.x-z.y*z.y,z.x*z.y*2.0f) + uv;\n    }\n\n    // Time varying pixel color\n\tvec3 col = hsv2rgb(vec3((length(z)+iTime)/10.0f,1.0f,1.0f) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 250, 300, 634]], "test": "untested"}
{"id": "3tGSDR", "name": "Glow kifs tunnel", "author": "rodgzilla", "description": "Ray marching tunnel kifs", "tags": ["raymarching", "tunnel", "kifs"], "likes": 4, "viewed": 272, "published": "Public API", "date": "1582480002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time .5 * iTime\n#define ZPOS -50. + 300. * (floor(time * .5) + smoothstep(.0, .1, fract(time * .5)))\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nvec3 kifs(vec3 p, float s, float r, float it, float tmin, float tmax, float shift) {\n    float t = shift + floor(time * .5) + smoothstep(tmin, tmax, fract(time * .5));\n    \n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .7);\n        p.yz *= rot2d(t * .8 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n\n\treturn p;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    float basez = p.z / 50.;\n    p.xy *= rot2d(p.z / 30.);\n    p = rep(p, vec3(40.));\n\tp = kifs(p, 3., .7, 3., .8, 1., basez);\n\tp = kifs(p, 3., .7, 2., .6, .8, basez);\n    float d = 1000.;\n  \tfloat obj = 3000.;\n    vec3 base = vec3(1, 0, 0);\n    float ttube = floor(time * .5) + smoothstep(.2, .4, fract(time * .5));\n    float tshift = floor(time * .5) + smoothstep(.4, .6, fract(time * .5));\n    float ntube = 6. + 3. * sin(ttube);\n    for (float i = 0.; i < ntube; i++) {\n        float angle = i * 2. * PI / ntube;\n        vec3 shift = vec3(1., 0, 0);\n        shift.xy *= rot2d(tshift * PI);\n        vec3 a = vec3(0) + shift;\n        vec3 b = vec3(2. * cos(angle), 2. * sin(angle), 0);\n        obj = min(obj, tube(p, a, b, .3));\n    }\n    d = min(d, obj);\n    \n    \n    at += .1 / (.1 + d);\n  \n    return d;\n}\n\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .02 * at * vec3(0, 1., 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(0, 0, ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n\n//    float dif = light(p);\n//  \tvec3 col = vec3(dif);\n    \n \tvec3 col = .2 * glow;\n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 154, 154, 219], [221, 221, 249, 249, 275], [277, 277, 322, 322, 479], [481, 481, 507, 507, 555], [557, 557, 641, 641, 905], [922, 922, 941, 941, 1753], [1783, 1783, 1811, 1811, 2055], [2057, 2057, 2078, 2078, 2225], [2227, 2227, 2248, 2248, 2474], [2477, 2477, 2534, 2534, 2918]], "test": "untested"}
{"id": "3tGSDW", "name": "testetst", "author": "lukeacret", "description": "testets", "tags": ["cine"], "likes": 4, "viewed": 222, "published": "Public API", "date": "1582665007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Luke Acret\",\n\t\"description\": \"Creative Director\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]], "test": "untested"}
{"id": "3tGSzm", "name": "MyDistortionv2", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 4, "viewed": 225, "published": "Public API", "date": "1582387110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nvec2 rand(vec2 uv, float seed){\n    seed += 0.01313;\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y * seed)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y * seed)  * 561.5453);\n    return uv;\n}\n\nvec2 cont_rand(vec2 uv, float seed){ // continueous\n    uv += vec2(0.141, 0.123);\n    return vec2(rand_func(seed, rand(uv.x * uv.y * uv.x)), rand_func(seed, rand(uv.x * uv.y * uv.y)));\n}\n\nvec2 uvtransform(vec2 uv, float strength, float seed){ // continueous\n    float clsz = 0.2; // cellsize\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    //vec2 A = mix(rand(nwuv + vec2(0., 0.)  , seed), rand(nwuv + vec2(clsz, 0.)  , seed), (uv - nwuv).x / clsz);\n    //vec2 B = mix(rand(nwuv + vec2(0., clsz), seed), rand(nwuv + vec2(clsz, clsz), seed), (uv - nwuv).x / clsz);\n    //vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    vec2 A = nwuv + vec2(0., 0.) * clsz;\n    A = cont_rand(A, seed);\n    vec2 B = nwuv + vec2(1., 0.) * clsz;\n    B = cont_rand(B, seed);\n    vec2 C = nwuv + vec2(0., 1.) * clsz;\n    C = cont_rand(C, seed);\n    vec2 D = nwuv + vec2(1., 1.) * clsz;\n    D = cont_rand(D, seed);\n    vec2 AB = mix(A, B, (uv - nwuv).x / clsz);\n    vec2 CD = mix(C, D, (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 ans = mix(AB, CD, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nvec2 distortion(vec2 uv, float strength, int power, float seed){\n    for (int i = 0; i < power; i++){\n        uv = uvtransform(uv, strength, seed);\n    }\n    return uv;\n}\n\nvec4 something(vec2 uv){\n    vec2 ans = uvtransform(uv + vec2(0., iTime / 20.), 0.7, iTime);\n    if (abs(ans.y - 0.5 - iTime / 20.) < 0.1){\n        float f = 1. - smoothstep(0., 0.2, abs(ans.y - 0.5 - iTime / 20.));\n        return vec4(f);\n        //return vec4(1.);\n    }\n    return vec4(0.);\n    //ans = (uv - nwuv) / clsz;\n    return vec4(ans, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(rand(uv), .0, .1);\n    fragColor = vec4((distortion(uv, 0.1, 5, iTime / 50.) - uv) / 0.2 + vec2(0.5), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 112], [114, 114, 151, 166, 344], [346, 346, 377, 377, 697], [699, 699, 735, 750, 885], [887, 887, 941, 956, 1994], [1996, 1996, 2060, 2060, 2166], [2168, 2168, 2192, 2192, 2525], [2527, 2527, 2584, 2634, 2940]], "test": "untested"}
{"id": "3tGXzW", "name": "大龙猫 - Quicky#022", "author": "totetmatt", "description": "Trying to create shader \"friendly\" with the portrait format of instagram story (1080x1920)", "tags": ["instagram", "quickly"], "likes": 6, "viewed": 284, "published": "Public API", "date": "1582239227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    uv  = abs(uv);\n      vec2 uuv= uv;\n      uv=uv*  (length(1.-uv)-.1*uv.x)*2.;\n    uv = (2.*uv+.1)-(.5*uv-.1);\n      uv *=r(iTime*.1);\n    vec2 id = floor(uv*10.);\n    uv*=r(length(fract(uuv))-(floor(atan(uuv.x+.05,uuv.y+.05)*3.1415)));    \n\n    uv = fract(uv*10.)-.5;\n    uv = abs(uv);\n    vec3 col  = vec3(0.,0.,0.0);\n\n     float t =  mix(0.45+(.654211-length(uv)),0.45+(.654211-length(uv))* (sign(sin(.1*iTime-length(id)))*.5 +.5),sin(floor(iTime*.5)+pow(fract(iTime*.5),4.))+1.); \n    uv.x >= t|| uv.y >= t  ? col=vec3(cos(1.66*iTime-length(id)*length(1.-uuv)),sin(-1.66*iTime+(length(id))),length(uv-length(uuv*.1))) : vec3(0.1) ;\n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 59], [60, 60, 115, 115, 861]], "test": "untested"}
{"id": "3tKSWw", "name": "[phreax] the children", "author": "phreax", "description": "Attempt to animate an artwork of my friend", "tags": ["raymarching"], "likes": 9, "viewed": 140, "published": "Public", "date": "1582843843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n * phreax 2020\n\n * Attempt to animate an artwork of my friend Martin.\n*/\n\n#define PI 3.141592\n#define TAU PI*2.\n#define SIN(x) (sin(x)*.5+.5)\n\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n\n#define BEND .8     \n#define COUNT 10.\n#define DISTORT 0.0\n\nvec3[] palette = vec3[](vec3(1.0, .2, 0), vec3(.0, .9, .4), vec3(.1, .7, .9), vec3(1, .9, 0));\nfloat tt, fid, id;\nint mat;\nvec3 inter;\n\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat hash11(float x) {\n\treturn fract(sin(437765.44*x)*345.63);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(2434.423,23.34)))*3228324.345);\n}\n\n\nvec2 kalei(vec2 uv) { \n\n    float n = 4.;\n    float r = TAU/n;\n    \n    for(float i=0.; i<n; i++) {     \n    \tuv = abs(uv);\n        uv.x -= .2*i+.2;\n    \tuv *= rot(r*i-.09*tt);\n    }\n    \n    uv = abs(uv) - (sin(.15*tt)+1.2);\n\n    return uv;\n}\n\n// Draw a triangle\nfloat triangle(vec2 uv) {\n    \n  int N = 3;\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  float d = cos(floor(.5+a/r)*r-a)*length(uv);\n\n  return 1.0-smoothstep(.5,.6, d);\n}\n\n\n// Draw a hollow frame\nfloat triangle_frame(vec2 uv, float r) {\n    \n    float d;\n    d += triangle(uv);\n    d -= triangle(uv/(1.-r));\n    return d;\n    \n}\n\nvec3 spiral(vec2 uv, float i) {  \n    uv *= rot(i*3.14+tt);\n    uv += DISTORT*sin(vec2(5)*uv.yx);\n\treturn triangle_frame(uv, .04)*hue(i+tt*.2);\n}\n\n// From my Electric Sheep: https://www.shadertoy.com/view/wlV3zy\nvec3 dream( vec2 uv )\n{\n\n    vec3 col = vec3(0);\n    tt = iTime;\n    \n    uv *= 5.;\n    uv = kalei(uv);\n\n    float s = 1./COUNT;\n\t\n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        vec2 UV = uv;\n        col += spiral(UV*z, i)*3.;\n    }\n    col +=  0.5/(abs(uv.x)+abs(uv.y))*(.8+.2*hue(.2*tt)); \n \n    return col;\n}\n\nvec2 moda(vec2 p, float repetitions, float offs, out float id) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2. +offs;\n    id = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n    if (abs(id) >= (repetitions/2.)) id = abs(id);\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n  p = abs(p);\n  return max(p.x-s.x, p.y-s.y);\n}\n\nfloat bo(vec3 p, vec3 s) {\n\tvec3 q = abs(p) - s;   \n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n// single leaf shape\nfloat leaf(vec2 uv, float r, float cp) {\n\n    float f = uv.y < 0. ? 1.2 : .7;\n    float  rp = uv.y < 0. ? 2.3 : 1.8;\n    float x = length(vec2(uv.x, pow(uv.y * f, cp)));\n    float y = r - pow(uv.y * f, rp);\n    float v = smoothstep(x, x + 16. / iResolution.y, y);\n    v *= pow(length(uv-vec2(.1, -.25))+.5,1.3); // bit of 3d look\n    return clamp(0., 1.5, v);\n}\n\nvec2 repeat(vec2 p, vec2 s, out vec2 id) {\n\tid = floor(p*s);\n    return fract(p*s)-.5;\n}\n\nfloat repeat(float p, float s, out float id) {\n\tid = floor(p*s);\n    return fract(p*s)-.5;  \n}\n\n// blinking dots\nfloat dots(vec2 uv, float r, float s) {\n    uv.x *= s;\n    \n    float did;\n\tuv.y = repeat(uv.y, s, did);\n\n    float d = length(uv) - r;\n    return smoothstep(16./iResolution.y, 0., d)*SIN(-tt*4.+did*.9);\n}\n\n// From shadertoy user curena: https://www.shadertoy.com/view/Mlj3zc\nvec2 inversion(vec2 p) {\n\n    vec2 bp = p;\n    float r    = sqrt(length( p ));\n   \n    bp.y += 0.4*(p.x*p.x)-.03;\n    return normalize(p)/(r*0.05) \n              + vec2(1.,-sign(bp.y)*4.5*tt);\n}\n\nvec3 leaf_pattern(vec2 uv, vec2 off) {\n\tvec2 id;\n    uv = repeat(uv, vec2(.14), id);\n    uv *= 1.2;\n    id += off;\n    float h = hash21(id);\n    uv *= rot(h*.4*sin(tt));\n    vec3 col = vec3(0);\n    col += leaf(uv-vec2(.3, 0), .2, 8.)*palette[int(4.*SIN(id.x*8.+mod(id.y, 4.)))];\n    // blinking leafs\n    col *= mix(1., 3., step(.6, SIN(id.x*.3+mod(id.y, 5.)+tt*.5)*h));\n    col += leaf(uv+vec2(.3, 0), .2, 8.)*palette[int(4.*SIN(id.x*8.-4.+mod(id.y, 4.)))];\n    return col;\n}\n\nvec3 overlay(vec3 c1, vec3 c2) {\n    return mix(c1, c2, (1.-step(dot(c2, vec3(1)), 0.))); \n}\n\nvec3 leaf_layers(vec2 uv) {\n    vec2 uvb = uv;\n    uv = inversion(uv);\n    uv += sin(uv.yy*vec2(0.5, 0.24))*.2;\n    \n    uv.y *= sign(uvb.y);\n\tvec3 c1 = leaf_pattern(uv, vec2(0));\n    vec3 c2 =leaf_pattern(uv+vec2(.1, 2.2), vec2(3,3)); \n    vec3 c3 =leaf_pattern(uv+vec2(2.3, 4.24), vec2(4,4));\n    vec3 c4 =leaf_pattern(uv+vec2(1.9, 1.3), vec2(6,2));\n    \n    return overlay(c1*.7, overlay(c2*.8, overlay(c3*.9, c4)))*1.-pow(length(uvb)+.4, 4.);          \n}\n\nfloat mask_texture(vec2 p) {\n    vec2 bp = p;\n    float d = box(p-vec2(0, .4), vec2(.02, .9));\n    p.x = abs(p.x);\n    d = min(d, box(p-vec2(0.3, .65), vec2(.09, .03)));\n    d = min(d, box(p-vec2(0.33, .5), vec2(.12, .03)));\n    d = min(d, box(p-vec2(0.36, .35), vec2(.14, .03)));\n    d = max(d, -box(p*rot(.3)-vec2(0.58, .4), vec2(.03, .26)));\n    d = min(d, box(p-vec2(0.25, -.05), vec2(.03, .25)));\n    d = min(d, box(p-vec2(0.36, -.33), vec2(.14, .03)));\n    d = min(d, box(p*rot(-.25)-vec2(0.35-sin((p.y-.02)*2.6)*.25, -.5), vec2(.02, .3)));\n    float c = smoothstep(0., 5./iResolution.y, d);\n\n    d = length(p-vec2(0, -.7)) -.2;\n    c *=  smoothstep(0., 5./iResolution.y, abs(d-.01)-.02);\n    return c;\n}\n\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat mask(vec3 p) {\n\n    vec3 bp = p;\n    \n    p.y /= 1.5;\n    p.z *= 1.5;\n\n    float d = length(p) - .8;\n\n    float b = box(abs(bp)-vec3(0.7, 0, 0), vec3(.2, .2, 1.));\n    d = max(max(d, -p.z), -b);\n    return d*.64;\n}\n\n// capped cylinder\nfloat cylc( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 transform_mask(vec3 p) {\n    p.xz = moda(p.xz,12., tt*.8, id);\n    p.y += .3*sin(tt*sin(id*14.523)*5.);\n    p.x = abs(p.x)-3.8;\n    p.xz *= rot(PI*1.5);\n    return p;\n    \n}\n\nvec3 transform_box1(vec3 p) {\n    vec3 bp = p;\n    p.x = abs(p.x) - 1.5;\n    p.x += sin(p.y*.2+PI*.5)*5.-5.;\n    p.x += sin(p.y*2.-PI/2.)*.4;\n    p.xz *= rot(bp.y*PI*.2-tt);\n    return p;\n}\n\n\nvec3 transform_box2(vec3 p) {\n    p.x = abs(p.x)-5.;\n    p.xy += .01*(p.z*p.z)-.3;\n    return p;\n}\n\n\nfloat map(vec3 p) {\n \tvec3 mp = transform_mask(p);\n    \n    vec3 pc = p;\n    vec3 pb1 = p;\n    vec3 pb2 = p;\n    float m = mask(mp);\n    \n\n    pb1 = transform_box1(pb1);\n\n\tpb2 = transform_box2(pb2);\n  \n    float b = box(pb1, vec3(.2, 9., .2))-.1;\n    float b2 = box(pb2, vec3(.1, .1, 100))-.1;\n\n\n    mat = m < b ? 0 : 1 ;\n    mat = b2 < m ? 2 : mat ;\n\n    inter = b < b2 ? pb1 : pb2;\n    \n    pc += vec3(0, -4.5, 0);\n    \n \n    pc.yz *= rot(-.5);\n    vec3 pf = pc;\n\n    pc.yz *= rot(PI*.5);\n\n    float c=  cylc(pc, 1.5, .2); \n    float ci = cylc(pc, 1.4, .3);\n    float cd = cylc(pc+vec3(0., -.3, -.1), 1.5, .1);\n    c = max(c, -ci);\n\n    pf.xy = moda(pf.xy, 7., 0., fid);\n    pf.x = abs(pf.x) - 3.4*SIN(tt*.5);\n    \n    float f = box(pf-vec3(0, 0, fid/200.), vec3(1.9,1.9, .1))*.6;\n    \n    f = min(max(c, -ci), max(f, ci));\n    if(f < b && f < m) mat = 3;\n    inter = f < b ? pc : inter;\n    float d = min(min(min(m, b), b2), f);\n    \n\tmat = cd < d ? 4 : mat;\n    d = min(d, cd);\n    return d;\n    \n\n}\n\n\nfloat ldist(vec2 p, float m) {\n\treturn pow(pow(p.x, m)+pow(p.y, m), 1./m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = iTime;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 ro = vec3(0, 0, -16),\n         rd = normalize(vec3(uv,.7)),\n         lp = vec3(-1., 1., -8.);\n    vec3 col;\n    float i, t, d = 0.1;\n\n\n    vec3 p = ro;\n    \n    for(i=0.; i<50.; i++) {\n    \n        d = map(p);\n        \n        if(d < 0.001 || t > 40.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    vec3 base_color;\n    int cmat  = mat;\n    bool no_dream = cmat == 4 && fract(tt/(8.*PI)) < .5;\n    \n    if(d < 0.001 && p.z < 3.3 && !no_dream) {\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 50.);\n        float sss = smoothstep(0.0, 1.0, map(p + l*0.4));\n        \n\t\tfloat fr = pow(1.+dot(n, rd), 2.);\n\n        float sssf = .2;\n    \n        if(cmat == 0 && p.z < 0.) {\n            base_color = vec3(1);   \n            p = transform_mask(p);\n       \t\tbase_color *= mask_texture(p.xy);\n        \n            if(mod(id, 2.) == 0.) {\n          \t    base_color = 1.-base_color;\n       \t    }\n        } else if(cmat == 1){\n            p = transform_box1(p);\n            base_color = vec3(.01+dots(p.xy, .3, 2.));\n        } else if( mat == 2) {\n            p = transform_box2(p);\n\n           base_color = vec3(dots(p.yz, .15, 1.2));\n        } else if (cmat ==3){\n        \tbase_color = vec3(.6);\n            sssf = .5;\n        }\n        col += base_color*dif+.5*spe+sssf*sss;\n        col *= 1.3;\n        \n        if(cmat == 4 && fract(tt/(8.*PI)) > .5) {\n            col = dream(inter.xz);\n        }\n\n\n    } else {\n\t\n      // Background is a pseudo 3d torus\n      col = leaf_layers(uv)*.6;\n      col += 1.5*pow((1.-ldist(abs(uv), .8)), 10.);\n      \n    }\n    \n\t//col = vec3(dots(uv));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSWw.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 467, 486, 486, 533], [535, 535, 558, 558, 600], [602, 602, 624, 624, 691], [694, 694, 715, 715, 937], [939, 958, 983, 983, 1145], [1148, 1171, 1211, 1211, 1303], [1305, 1305, 1336, 1336, 1450], [1452, 1517, 1540, 1540, 1860], [1862, 1862, 1926, 1926, 2152], [2154, 2154, 2181, 2181, 2229], [2231, 2231, 2257, 2257, 2351], [2353, 2374, 2414, 2414, 2735], [2737, 2737, 2779, 2779, 2825], [2827, 2827, 2873, 2873, 2921], [2923, 2940, 2979, 2979, 3145], [3147, 3216, 3240, 3240, 3410], [3412, 3412, 3450, 3450, 3888], [3890, 3890, 3922, 3922, 3982], [3984, 3984, 4011, 4011, 4442], [4444, 4444, 4472, 4472, 5154], [5157, 5157, 5184, 5184, 5285], [5288, 5288, 5308, 5308, 5508], [5510, 5529, 5569, 5569, 5676], [5678, 5678, 5707, 5707, 5856], [5858, 5858, 5887, 5887, 6047], [6050, 6050, 6079, 6079, 6148], [6151, 6151, 6170, 6170, 7154], [7157, 7157, 7187, 7187, 7233], [7235, 7235, 7292, 7292, 9281]], "test": "untested"}
{"id": "3tKSzz", "name": "Simple Plane", "author": "gigatron", "description": "Textured floor , based the guy of UBISOFT live code, and add fx by me ; ", "tags": ["raymarch", "texture"], "likes": 3, "viewed": 103, "published": "Public", "date": "1582075574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple plane textured floor with fract etc ..\n// Gigatron FR\n//\nfloat Plan(vec3 pos, vec3 dir)\n{\n    return pos.y / dir.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy *2.-1. ;\n   \n    vec2 uv2 = fragCoord/iResolution.xy;\n    \n    vec3 tx2 = texture(iChannel1,uv2).xyz ;\n    \n\tvec3 pos = vec3(0.0, 2.0+sin(iTime), 1.0-iTime*2.5);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \t\n    \n    float d =  Plan(pos, dir );\n    pos += d * dir;\n    \n    vec3 col = vec3(dir)+sin(iTime*2.0)*0.5+0.5;\n    uv  =  vec2(fract(pos.x),fract(pos.z)) ;\n    \n    \n    if(uv2.y>0.5)   fragColor  = vec4(tx2*col, 1.0);  \n   \n     vec3 tx = texture(iChannel0,1.-uv).xyz ;\n      \n    \n    if(uv2.y<0.48)   {\n        \n        fragColor  = vec4(tx, 1.0);  \n    // cut edge ; \n   \t\t float bord = 0.96;\n\n\t\tif ( uv.x < - bord || uv.x > bord || uv.y < - bord || uv.y > bord ) {\n\n\t\t    \tfragColor = vec4( vec3(dir+sin(iTime)*0.5+0.5),1.0 ) *3.0;\n\t\n\t\t}\n    \n                     }\n     \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 99, 99, 127], [130, 130, 187, 237, 1064]], "test": "untested"}
{"id": "3tKXzw", "name": "大龙猫 - Quicky#023", "author": "totetmatt", "description": "I don't know why I need to go far in time to get the effect.", "tags": ["instagram", "quicky"], "likes": 12, "viewed": 330, "published": "Public API", "date": "1582418147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r(float a) {\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat xor(float a,float b) {\n    return a*(1.-b) +b*(1.-a);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float realTime = iTime + 5500.; // Yeah, effect works far in time\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 uuv = uv;\n    uv *=length(cos(uv*2.8));\n    float z= (cos(realTime*.1)*.5+1.);\n    uv*=r(cos(realTime)*.1)*z;\n    \n    \n    float aid = atan(uv.x,uv.y)*4.;\n    uv=12.*abs(uv*r(aid+fract(length(uv*4.)+aid*.25) ));\n    uv.x = sin(floor(uv.x)+-realTime*.5*cos(realTime*.25)*.005)*.5+.5;\n    uv.x = xor(uv.x,cos(floor(uv.y)+realTime*.5*sin(realTime*.25)*.005)*.5+.5);\n    vec3 col = vec3(uv.x);\n   \n    float flash = smoothstep(.5,1.,col).r;\n     col =col* 0.10/(length(uuv)-(.03*z+floor(cos(aid*4.+flash))*.005)) ;\n    col = mix(vec3(.1,.0,.1),vec3(.1 , .1 +flash*.5,1.-(1.-flash)*.5 ),col);\n    //col = ;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 75], [76, 76, 104, 104, 137], [138, 138, 193, 193, 972]], "test": "untested"}
{"id": "3ttSDB", "name": "Show Business", "author": "hanabi", "description": "work in progress", "tags": ["rain"], "likes": 1, "viewed": 161, "published": "Public API", "date": "1581630980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat rand1(in float f)\n{\n    return fract(sin(f)*100000.0);\n}\n\nfloat random(in vec2 _st)\n{\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float fFrame = float(iFrame);\n    \n    fragColor = vec4(hsb2rgb(vec3(0.7, 0.6, uv.y / 1.4)), 1.0);    \n    \n    float WIDTH = iResolution.x / 4.;\n    for (float i = 0.; i < WIDTH; i++) {\n        // radius of a ball\n        float r = 10.;\n        float hspace = iResolution.x / WIDTH;\n        // some dancing, some horizontal space\n        float x = iResolution.x / 60.0 * sin(PI / 180. * fFrame) + hspace * i - hspace  * rand1(i);\n        float movement = fFrame * iResolution.y / 360.;\n        // movement, some vertical space\n        float y = movement + iResolution.y * rand1(i);\n        \t  y = mod(-abs(y), iResolution.y + r);\n\n        vec2 ball = vec2(x, y);\n        vec2 ballDist = fragCoord - ball;\n\n        fragColor = mix(fragColor, vec4(hsb2rgb(vec3(0.20, .9, .9)), 1.0),\n                        1.-smoothstep(\n                            ball.y / 10., ball.y / 2.,\n                            dot(ballDist, ballDist)));\n    }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 60, 60, 97], [99, 99, 126, 126, 202], [204, 278, 306, 306, 538], [541, 541, 598, 598, 1583]], "test": "untested"}
{"id": "3ttSRS", "name": "大龙猫 - Валентины Соёмбо", "author": "totetmatt", "description": "Soyombo with special change for Valentine's Day.", "tags": ["valentine", "soyombo"], "likes": 0, "viewed": 193, "published": "Public API", "date": "1581664367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Source : \n -  https://www.shadertoy.com/view/XsdyWr for the Rose Code\n -  https://www.shadertoy.com/view/Msc3WB inspiration for yin yang\n -  https://www.shadertoy.com/view/Msc3WB for the basic shape code\n -  Diverse HBHS Stream from Flopine (https://www.twitch.tv/flopine) for some GLSL tricks and the Ray March framework\n*/\n\n#define ITER 64.\n#define dtime pow(fract(iTime*.654),1.)+floor(iTime*.654)\n#define ttime sin(iTime*.8) *pow(cos(pow(iTime*.8,.125)),2.)\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// 2D matrix Rotation\n\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n// Using a shadertoy \n// https://www.shadertoy.com/view/XsdyWr\n///\nmat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n        c.y      ,  0.0, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    );\n} \nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\nfloat ratio = 7.;\n    p*=ratio+cos(fract(iTime))* sin(fract(iTime)*2.) ;\n    s/=1.5;\n    p = p * vec3(0.8, 1.5, 0.6) + vec3(0.1, 0.0, 0.0)*ratio;\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region)/16.;\n}\nfloat flower(vec3 p) {\np.xy*=r(PI);\np.yz*=r(PI/12.);\np.xz*=r(iTime*.33);\n float ratio = .8;\n p*=ratio;\n \n float d = 1000., s = 2.0;\n    mat3 r = rotationXY(vec2(0.01, PI2 * 0.618034));\n    r = r * mat3(1.08,0.,max(0.0,sin(dtime)*.2) ,0.0,0.995,max(0.0,cos(dtime)*.1), 0.0,max(0.0,cos(dtime)*.1),1.08);\n    for (int i = 0; i < 24; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.001, 0.0);\n        s *= 1.05;\n    }\n    return d/ratio;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n/// Basic Shape & Operation\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(247.34, 961.21324));\n  p += dot(p, p + 21.87);\n  return fract(p.x * p.y);\n}\n/////////////////////\n// Scene Shape\nfloat moon(vec3 pos) {\npos .xz*=r(-iTime+PI/2.);\nfloat visible = sdCappedCylinder(pos.xyz,vec3(0.,.0,-.1),vec3(.0,.0,.1),.4);\nfloat remove = sdCappedCylinder(pos.xyz-vec3(0.,.2,.0),vec3(0.,.0,-.2),vec3(.0,.0,.2),.5);\n    return max(visible,-remove);\n    return mix(remove,visible,sin(iTime));\n}\n\n\n\n\n\n\nfloat yin(vec3 pos, float p){\n       pos.xy *= r(p);\n   \n\n   float q = pos.y >0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : 1. ;\n   float r = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.3 );\n   float t = sdCappedCylinder(pos.xyz-vec3(-0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.3 );\n   float v = sdCappedCylinder(pos.xyz-vec3(0.30,0.0,.0),vec3(0.,0.0,-.2),vec3(0.0,0.0,.2), 0.1 );\n  \n   return max(-v,max(-t,min(r,q)));\n}\nfloat yinyang(vec3 pos) {\n        float ratio = 2.7;\n        pos *=ratio;\n      pos.xy *= r(PI/2.);\n        pos .zy*=r(tan(sin(iTime))*.25);\n       pos .xz*=r(tan(cos(iTime*.45))*.25);\n     return min(\n       yin(pos+vec3(.0,-.05,.0),0.),\n       yin(pos+vec3(.0,+.05,.0),PI)\n    )/ratio;\n}\nfloat flame(vec3 pos) {\n\n     float ratio = 2.5;\n    pos.y -=1.6;\n    pos*=2.5;\n    float q = pos.y <0. ? sdCappedCylinder(pos.xyz-vec3(0.,0.0,.0),vec3(0.,0.0,-.1),vec3(0.0,0.0,.1), 0.6 ) : ratio;\n    float f = pos.y >0. ? sdRoundCone(abs(pos)-vec3(0.4+(sin(pos.y*12.+iTime)+1.)*.04,0.,0.),.1,.01,.5)  : ratio ;\n    float central_flame = pos.y > 0. ? sdRoundCone(pos-vec3(-0.025+(sin(PI/2.+pos.y*12.+iTime*.7)+1.)*.04,0.,0.),.1,.01,.8) : ratio ;\n    return opSmoothUnion(q,opSmoothUnion(central_flame,f,0.5),0.25)/ratio ;\n    return min(q,min(central_flame,f))/ratio;\n\n}\n\nfloat sideBox(vec3 pos) {\n  pos.x = abs(pos.x);\n  pos = pos-vec3(.6,.0,.0);\n  pos.xz *= r(pow(sin(pos.y*2.*PI),2.)+iTime*.1);\n return sdBox(pos,vec3(0.16,0.6,0.1));\n}\n\nfloat backflower( in vec3 p, in float c, in vec3 l )\n{\n    p*=.5;\n      vec3 id = round(p/c);\n     p.x += .25+sign(sin(4.*id.z))*sin(iTime*.16);\n   \n    p.y -= .25+sign(cos(4.*id.z))*cos(iTime*.23);\n    \n   \n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    \n    q.zx*=r(iTime*.2+length(p.xz));\n   \n    return flower(q);\n}\n\nvec2 SDF(vec3 pos) {\n     vec3 ppos = pos;\n         pos.xz*=r(cos(iTime*.9)*.2);\n      pos.yz*=r(cos(iTime*.78)*.1);\n      \n    float sideBox =sideBox(pos);\n    \n    vec3 pos_tri = pos;\n    pos_tri.xy *= r(3.141592);\n    pos_tri.xy *= vec2(.5,1.3);\n    \n    float triangle = sdTriPrism(pos_tri+vec3(0.,.67,.0),vec2(0.2,0.1));\n    float box = sdBox(pos-vec3(.0,.29,.0),vec3(0.35,0.05,0.1));\n    float box2 = sdBox(pos-vec3(.0,-.29,.0),vec3(0.35,0.05,0.1));\n    \n    float triange2 = sdTriPrism(pos_tri+vec3(0.,-.6,.0),vec2(0.2,0.1));\n    float moon = moon(pos-vec3(.0,1.05,.0));\n    \n    float yy= yinyang(pos);\n    float fl = flame(pos);\n    float flow   = flower( (pos.xzy)+vec3(.0,-.01,-1.08));\n   \n    float flowrz = backflower(pos.xzy+vec3(0.,-10.,0.),1.,vec3(4.,.1,4.));\n    \n   float dist = min(fl,min(yy,min(moon,min(min(box,box2),min(min(triange2,triangle),min(sideBox,flowrz))))));\n    dist = min(dist,flow);\n   if(dist == flow && pos.y > .75) { // A DIRTY TRICK TO REMOVE BUG\n    \treturn vec2(dist,1.0);\n   } else if (dist == flowrz){\n   \t\treturn vec2(dist,2.0);\n   } else {\n       \treturn vec2(dist,0.0);\n   }\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.61,-3.); // Were we start \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.3,.6); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n  \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n      \n      float f = position.z > 0.1 ? 1.9:1.; // Speedup for background\n     \n     position += _distance.x*f * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n  }\n  \n  if(hit) { \n     color = vec3(1.-shad*.766); // Yeah no real lighting here, I like the render as it is\n    if(part == 0.){\n     color = mix(vec3(1.0,0.1,.0), vec3(.9,.9,0.1)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     } else if(part== 1.) {\n        color = mix(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.4)+vec3(0.,0.,length(uv)), color)*(1.-shad);\n        color-=max(0.,sin(iTime*1.3))*vec3(.0,.3,.6);\n    } else if(part ==2.) {\n    \tcolor = mix(vec3(.0,.3,.6), vec3(.0,.3,.6), color)*(1.75-shad);   \n        \n    }\n     \n  } \n \n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 752, 768, 768, 839], [840, 907, 938, 938, 1127], [1129, 1129, 1160, 1160, 1186], [1188, 1188, 1219, 1219, 1245], [1247, 1247, 1278, 1278, 1305], [1307, 1307, 1339, 1339, 1958], [1959, 1959, 1981, 1981, 2433], [2435, 2625, 2677, 2677, 2776], [2777, 2777, 2812, 2812, 2907], [2911, 2911, 2946, 2946, 2970], [2972, 2972, 3029, 3029, 3365], [3366, 3366, 3402, 3402, 3752], [3753, 3753, 3811, 3811, 4075], [4077, 4077, 4099, 4099, 4196], [4197, 4234, 4256, 4256, 4528], [4535, 4535, 4564, 4564, 5042], [5043, 5043, 5068, 5068, 5332], [5333, 5333, 5356, 5356, 5903], [5905, 5905, 5930, 5930, 6071], [6073, 6073, 6127, 6127, 6390], [6392, 6392, 6412, 6412, 7514], [7516, 7533, 7588, 7588, 9099]], "test": "untested"}
{"id": "3ttSW4", "name": "2 graphics from single geometry", "author": "dmitrykolesnikovich", "description": "here I develop my style of writing shaders in OOP way.\nthis shader demonstrates that 2 different graphics (circle and ring) that are build from 1 geometry of ring.\nand a little bit animation for fun\nto stop animation uncomment 14th line `#define time 0.`", "tags": ["circle", "glsl", "oop"], "likes": 1, "viewed": 209, "published": "Public API", "date": "1580949881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThe idea here is to demonstrate that like in SQL tables are designed in order to\nplays nicely with specific queries in GLSL geometry is also designed specifically\nto further graphics procedure to use in.\n\nI mean that circle graphics is based on ring geometry not circle geometry.\n\nSo, in real life geometry and graphics are tight coupled unfortunately\n(https://en.wikipedia.org/wiki/Loose_coupling)\n*/\n\n/*support*/\n\n// #define time 0.\n#define time iTime\n#define RED vec3(1, 0, 0)\n#define BLUE vec3(0, 0, 1)\n#define BOUNCE1 abs(sin(time * 3.))\n#define BOUNCE2 abs(sin(time * 10.))\nvec2 normalization(vec2 p) { return (2. * p - iResolution.xy)/ iResolution.y; }\n\n/*objects*/\n\n// below is Circle constructor that defines new circle instance in following steps:\n//   origin in Cartesian\n//   converts Cartesian to polar \n//   geometry in polar \n//   graphics in polar \n//   coloring \n//   one to one mapping to instance without post-production effects\nvec3 Circle(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .3;\n    float antialiasing = .05 + BOUNCE1 * .4;\n    p -= origin;\t\t\t\t       // define origin in Cartesian cs\t\n    float polarCoordinate = length(p); // transform Cartesian cs to polar cs\n    \n    // define ring geometry in polar cs by mapping [0..Inf] to [radius..radius * 1.025]\n    float ringGeometry = smoothstep(radius, radius * (1. + antialiasing), polarCoordinate); \n    \n    // \"graphics query\" as I call it that defines circle graphics based on ring geometry\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    \n    vec3 coloring = smoothCircleGraphics * color; \n    \n    vec3 instance = coloring; // no post-production effects\n    return instance; // the nice little thing here is that I semantically return new instance of object like it's not glsl function but real constructor in real programming language\n}\n\nvec3 Ring(vec2 p, vec3 color) \n{\n\tvec2 origin = vec2(0);\n    float radius = .4 + BOUNCE2 * .02;\n    p -= origin;\t\t\t\t       \n    float polarCoordinate = length(p); \n    float ringGeometryOutside = smoothstep(radius, radius * 1.05, polarCoordinate); \n    float ringGeometryInside = 1. - smoothstep(radius * 0.95, radius, polarCoordinate); \n    float ringGeometry = ringGeometryInside + ringGeometryOutside;\n    vec3 smoothCircleGraphics = vec3(1. - ringGeometry);\n    vec3 coloring = smoothCircleGraphics * color; \n    vec3 instance = coloring;\n    return instance;\n}\n\n/*canvas*/\n\nvoid mainImage(out vec4 canvas, in vec2 pixel)\n{\n\n    vec2 p = normalization(pixel); // normalization\n    canvas = vec4(0); // init\t\n    canvas += vec4(Circle(p, RED), 1); // append Circle\n    canvas += vec4(Ring(p, BLUE), 1); // append Ring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 583, 611, 611, 662], [677, 951, 985, 985, 1857], [1859, 1859, 1891, 1891, 2424], [2426, 2438, 2486, 2486, 2681]], "test": "untested"}
{"id": "3ttSWX", "name": "Segment - parametrization", "author": "iq", "description": "Space parametrization of a segment (capsule), so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 11, "viewed": 426, "published": "Public API", "date": "1581855624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a segment, or can maybe also call it\n// \"capsule\" coordinates.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paSegment( in vec2 p, vec2 a, vec2 b, float r, float band ) \n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    vec2 pb = p-b;\n    \n    float f = dot(pa,ba)/dot(ba,ba);\n    float h = clamp(f, 0.0, 1.0 );\n    float d = length(pa-h*ba) - r;\n    \n    float ra = band*round(d/band);\n    \n    float lba = length(ba);\n   \n    float l = 0.0;\n    if( f<0.0 )\n    {\n        l = (r+ra)*atan(dot(pa,ba),cro(pa,ba));\n    }\n    else if( f>1.0 )\n    {\n        \n        l = lba + (r+ra)*atan(dot(pb,ba),cro(pb,ba));\n    }\n    else\n    {\n        if( cro(pa,ba)<0.0 )\n        {\n            l = lba*2.0 + 3.1415927*(r+ra) - f*lba;\n        }\n        else\n        {\n        \tl = f*lba;\n        }\n    }\n    \n    return vec4( d-ra, l, lba*2.0+6.283185*(r+ra), d );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n\n    // animate segment\n    float id = floor((iTime+0.1)/5.0);\n    vec2  pa = 0.7*cos( vec2(3,2) + id*1.0);\n    vec2  pb = 0.7*cos( vec2(6,1) + id*1.7);\n    float ra = 0.15 + 0.05*sin(id*0.2);\n\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paSegment(uv,pa,pb,ra,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSWX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1367, 1450, 1475, 1475, 1494], [1495, 1495, 1528, 1528, 1554], [1556, 1660, 1727, 1727, 2402], [2405, 2405, 2462, 2498, 3664]], "test": "untested"}
{"id": "3ttSzX", "name": "The Nautilus, Part 4", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 4 of a series", "tags": ["model", "submarine", "sciencefiction", "verne"], "likes": 8, "viewed": 217, "published": "Public API", "date": "1581442601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The Nautilus, Part 4\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot;\nint idObj;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idBase = 20;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  q = p;\n  q.y -= -2.;\n  d = PrRoundBoxDf (q, vec3 (1.5, 0.05, 4.), 0.05);\n  q.y -= 0.3;\n  q.z = abs (q.z) - 2.5;\n  d = min (d, PrRoundBoxDf (q, vec3 (1.5, 0.3, 0.03), 0.05));\n  DMIN (idBase);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.4, 0.4, 0.5, 0.1);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj != idBase) {\n      col4 = NautColN (ro, vn);\n      col4.rgb = pow (Maxv3 (col4.rgb), 0.7) * mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));\n      if (col4.a < 0.) col4.a = 0.2;\n    } else {\n      col4 = vec4 (0.4, 0.1, 0., 0.2) * (0.3 + 0.7 * Fbm2 (vec2 (1., 4.) * ro.xz));\n    }\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else {\n    col = vec3 (0., 0., 0.5);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  sbPos = vec3 (-0.5, 0., 0.);\n  sbRot = 0.5 * pi;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.05 * pi * tCur;\n    el -= 0.1 * pi * sin (0.04 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  dstFar = 60.;\n  zmFac = 5.;\n  ro = vuMat * vec3 (0., 0., -24.);\n  sunDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttSzX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1037, 1060, 1060, 3941], [3943, 3943, 3965, 3965, 4328], [4330, 4330, 4363, 4363, 4546], [4548, 4548, 4569, 4569, 4824], [4826, 4826, 4863, 4863, 5104], [5106, 5106, 5145, 5145, 7783], [7785, 7785, 7820, 7820, 8603], [8620, 8620, 8676, 8676, 9798], [9800, 9800, 9833, 9833, 9922], [9924, 9924, 9970, 9970, 10017], [10019, 10019, 10052, 10052, 10079], [10081, 10081, 10123, 10123, 10174], [10176, 10176, 10235, 10235, 10366], [10368, 10368, 10421, 10421, 10482], [10484, 10484, 10506, 10506, 10544], [10546, 10546, 10582, 10582, 10788], [10790, 10790, 10835, 10835, 10938], [10940, 10940, 10997, 10997, 11080], [11082, 11082, 11112, 11112, 11225], [11259, 11259, 11283, 11283, 11413], [11415, 11415, 11439, 11439, 11659], [11661, 11661, 11686, 11686, 11872], [11874, 11874, 11899, 11899, 12124], [12126, 12126, 12147, 12147, 12302], [12304, 12304, 12325, 12325, 12480], [12482, 12482, 12511, 12511, 12723], [12725, 12725, 12764, 12764, 12949]], "test": "untested"}
{"id": "3ttXDS", "name": "fn frac 3", "author": "anttikan", "description": "Composition using a randomly generated function that maps x, y, and time to color values. The fractional approach demonstrated here (https://www.shadertoy.com/view/lsl3RH) is used.", "tags": ["2d", "abstract"], "likes": 2, "viewed": 187, "published": "Public API", "date": "1581624447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat proc(vec2 p, float iTime){\n    float x = p.x;\n    float y = p.y;\n    return (log(abs((pow((sqrt(pow(sign((sqrt(pow(((noise((sqrt(pow(((x)+(x)),2.0)+pow(((x)-(sin(iTime/0.966987073505152 + 0.6111521249421139))),2.0))),(sin(iTime/0.4363697787300387 + 0.12117539940795363)))/ (abs(noise((sin(iTime/0.5158599562708615 + 0.16600295224153383)),sin(((sin(iTime/0.6756154310519074 + 0.21928104695785633))-(y)))))+0.0001))/ (abs(pow((sqrt(abs(abs((sin(iTime/0.10046810537438944 + 0.16472793169855549))) - floor(abs((sin(iTime/0.06664122762711977 + 0.15718604023595528))))))*sqrt(abs((sin(iTime/0.4570874330557644 + 0.8750506328606864))))),3.0))+0.0001)),2.0)+pow((x),2.0)))),2.0)+pow(((sin((((pow((sin(iTime/0.9411628721004033 + 0.7970329359978641)),2.0)*pow((x),3.0))/ (abs((x))+0.0001))+(y)))-((sqrt(pow(sin(sin(((y)*(y)))),2.0)+pow((abs(noise((x),(y))) - floor(abs(noise((x),(y))))-sqrt(abs(sign((sin(iTime/0.31979339437329113 + 0.6727109187652756)))))),2.0)))-(y)))*pow(((x)+cos(sign(sqrt(abs((sqrt(pow((y),2.0)+pow((y),2.0)))))))),3.0)),2.0))),3.0)+((sqrt(pow(noise(log(abs(pow(log(abs((((y)+(sin(iTime/0.6262793977377104 + 0.19748571464784503)))-(sqrt(pow(((y)/ (abs((x))+0.0001)),2.0)+pow(((x)/ (abs((x))+0.0001)),2.0)))))+0.0001),2.0))+0.0001),sin(sin(((y)+(y))))),2.0)+pow(((sin(iTime/0.16396662366658754 + 0.27674858164238003))-sqrt(abs(((sqrt(pow(((sin(iTime/0.2834978288486667 + 0.5743516223794598))+(sin(iTime/0.15568232361922707 + 0.7840086800987247))),2.0)+pow(sqrt(abs((x))),2.0)))*(sin((sqrt(pow(((y)+(y)),2.0)+pow(pow((y),3.0),2.0))))/ (abs(((sqrt(pow(abs((sin(iTime/0.21214125730436129 + 0.15950010259741676))) - floor(abs((sin(iTime/0.23599852758426532 + 0.8305195272596266)))),2.0)+pow(sign((y)),2.0)))-sign((y))))+0.0001)))))),2.0)))*abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.09431146868556373 + 0.24818217157847644)))/ (abs(sqrt(abs((sin(iTime/0.037376425340919894 + 0.43268205672704463)))))+0.0001))))),3.0))) - floor(abs(sin(pow(cos(sin(sin((((y)-(sin(iTime/0.27702937544993445 + 0.797806488383189)))/ (abs(sqrt(abs((sin(iTime/0.7390386126490491 + 0.7347386838432937)))))+0.0001))))),3.0)))))))+0.0001)+(sqrt(pow(sin((y)),2.0)+pow(pow(exp(((abs(((sin(iTime/0.14356340742759954 + 0.7790959326773577))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.6612596860985003 + 0.11710398818870238))),2.0))),2.0),2.0))+0.0001))) - floor(abs(((sin(iTime/0.4870341755973422 + 0.6541018216662755))/ (abs(pow(pow((sqrt(pow(((x)+(y)),2.0)+pow(sin((sin(iTime/0.825267914962508 + 0.027399235966053315))),2.0))),2.0),2.0))+0.0001))))/ (abs(sign((sin(iTime/0.4859768935419986 + 0.23220255975823956))))+0.0001))/ (abs(sin((log(abs((sin(iTime/0.670649400313476 + 0.8547119247089336)))+0.0001)/ (abs(cos(cos(cos((y)))))+0.0001))))+0.0001))),3.0),2.0))));\n}\n\nfloat pixelfunc(float x, float y, float iTime) {\n\tvec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*proc( p, iTime )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*proc( p, iTime )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*proc( p, iTime )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*proc( p, iTime )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*proc( p, iTime ));\n    return f/0.96875;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2+12.0;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.1,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.25,0.4,0.95)*(nor.y*0.5+0.5) + vec3(0.9,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 105], [107, 107, 140, 140, 522], [525, 525, 557, 557, 3293], [3295, 3295, 3343, 3343, 3753], [3756, 3756, 3828, 3828, 3912], [3914, 3914, 3971, 3971, 4997]], "test": "untested"}
{"id": "3ttXWX", "name": "Kitty Spiral ⚙", "author": "HaleyHalcyon", "description": "nyan", "tags": ["spiral"], "likes": 2, "viewed": 140, "published": "Public", "date": "1581854686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float nyan(float theta)\n{\n    float mimi = 0.7 - abs(theta);\n    return 1. - 0.45 * max(\n        1.0 - 2.5 * abs(mimi)\n      , 0.\n    );\n}\n\nfloat fn(float x)\n{\n    return max(0.0, (sin(x) + 0.3) * 0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.14159265;\n    const float HF_PI = PI / 2.;\n    const float speed = 5.;\n    const vec3 color1 = vec3(1.0, 0.5, 0.7);\n    const vec3 color2 = vec3(1.0, 0.8, 0.3);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float distRaw = uv.x * uv.x + uv.y * uv.y;\n    float angle = atan(uv.x, uv.y);\n    float distance = log(distRaw);\n    float distNyan = log(distRaw * nyan(angle));\n    \n   \n    float c1 = fn(distance * 2.0 + iTime * speed + angle * 2.0 + PI);\n    float c2 = fn(distNyan * 5.0 + iTime * speed * -2. + PI);\n\n    // Output to screen\n    fragColor = vec4(\n\t\tc1 * color1[0] + c2 * color2[0],\n\t\tc1 * color1[1] + c2 * color2[1],\n\t\tc1 * color1[2] + c2 * color2[2],\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 138], [140, 140, 159, 159, 204], [206, 206, 263, 263, 1151]], "test": "untested"}
{"id": "3ttXzS", "name": "Julia Set RGF", "author": "DaMastaCoda", "description": "Simple Julia shader. \nFirst try at glsl.\nmodification of the Mandelbrot shader", "tags": ["mandelbrotimaginarycomplex"], "likes": 0, "viewed": 49, "published": "Public", "date": "1581218813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0f)/iResolution.x*4.0f;\n    vec2 z = uv;\n    vec2 mouse = iMouse.xy;\n    if(iFrame == 0 || length(iMouse.xy) == 0.0f) {\n        mouse = vec2(0.5f, 0.5f)*iResolution.xy;\n    }\n    for(int i = 0; i < 1000; i++) {\n        z.xy = vec2(z.x*z.x-z.y*z.y,z.x*z.y*2.0f) + (mouse - iResolution.xy/1.6f)/iResolution.xy*4.0f;\n    }\n\n    // Time varying pixel color\n\tvec3 col = hsv2rgb(vec3((length(z)+iTime)/10.0f,1.0f,1.0f) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 250, 300, 815]], "test": "untested"}
{"id": "3tVSDR", "name": "Damier_Test", "author": "Chloe_Bt", "description": "damier, colors", "tags": [], "likes": 0, "viewed": 59, "published": "Public", "date": "1582538618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;    \n    float modulo = 0.25;\n    vec2 m = floor( 2.*fract(uv/modulo) );\n    float value = float(m.x!=m.y);    \n\tvec3 col = value-0.5*cos(-iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n\n}\n\n\n  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 368]], "test": "untested"}
{"id": "3tVSWD", "name": "fix point Mandelbrot", "author": "FabriceNeyret2", "description": "Right: computed with floating points\nLeft: Computed with fix points: see #FIX to test 4 methods. (#4 is best, thanks rory618 ! ) \n\nHow to zoom deeper in Mandelbrot (without implementing longints / longfloats) ?", "tags": ["mandelbrot", "int", "fixpoint"], "likes": 10, "viewed": 323, "published": "Public API", "date": "1582739767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int FPP(int a, int b){    // used by FIX=4 (thanks rory618 !)\n    int aH = a>>16,  aL = a & 0xFFFF,\n        bH = b>>16,  bL = b & 0xFFFF,\n       ppH = aH * bH,\n       ppL = aH * bL + aL * bH;\n    return (ppH<<7) + (ppL>>9);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = (2.*u-R) / R.y,\n         C = vec2(-.74502,.1860105) + U / exp2(iTime);\n    \n    float i = 0.;\n    if (u.x < R.x/2.) {    // --- left: fix point version\n#define FIX 4              //   <- choose method 0-3\n        \n#if FIX==1                 //   method 1\n        #define M 0x2000   // unit: 0x2000 (better) - 0x5800 (deeper)\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {  // post-reduce by M = scale\n            z = ( ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) +M/2) / M + c;\n            if ( z.x*z.x + z.y*z.y > 4*M*M ) break; \n        }\n#elif FIX==2               //   method 2\n        #define S 0x2000   // sqrt(unit)\n        #define M (S*S)    // unit\n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = (z + S/2 ) / S;  // pre-reduce by S = sqrt(scale)\n            z = ivec2( z.x*z.x - z.y*z.y, 2*z.x*z.y) + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#elif FIX==3               //   method 3\n        #define S 0x300    // sqrt(unit)   \n        #define M (S*S)    // unit \n        ivec2 z = ivec2(0), s,\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            s = (z + S/2 ) / S;  // pre/pos-reduce by S = sqrt(scale)\n            z = (ivec2( s.x*z.x - s.y*z.y, s.x*z.y+s.y*z.x) +S/2)/S + c;\n            s = (z + S/2 ) / S;\n           if ( s.x*s.x + s.y*s.y > 4*M ) break; \n        }\n#else // FIX==4            //   method 4\n        #define M 0x02000000 // unit\n        ivec2 z = ivec2(0),\n              c = ivec2(C *float(M));\n        for (; i < 150.; i++) {\n            z = ivec2( FPP(z.x,z.x) - FPP(z.y,z.y), 2*FPP(z.x,z.y) ) + c;\n           if ( FPP(z.x,z.x) + FPP(z.y,z.y) > 4*M ) break; \n        }\n#endif\n    }\n    else {                  // --- right: floating point version\n        vec2 z = vec2(0),\n             c = vec2(C);\n        for (; i < 150.; i++) {\n            z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n            if ( z.x*z.x + z.y*z.y > 4. ) break; \n        }\n    }\n    \n                            // --- coloring  scheme\n  //O = vec4(.5+.5*sin(i/4.));\n    O =  (1.-i/150.)\n        *( .6 + .6 * cos( 6.3*i/25.  + vec4(0,23,21,0)  )); // hue https://www.shadertoy.com/view/ll2cDc\n\n    if (int(u-R/2.)==0) O++; // O=vec4(1,0,0,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 61, 225], [227, 227, 265, 265, 2656]], "test": "untested"}
{"id": "3tySDW", "name": "Neon Panning Corridor", "author": "mosaic", "description": "Started with https://www.shadertoy.com/view/3lVXWh and modified from there", "tags": ["2d"], "likes": 1, "viewed": 72, "published": "Public", "date": "1582676256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    \nvec2 uv=xy;\n    \n    xy.y +=0.008*sin(100.*uv.y+iTime); //optional ripple effect\n    xy*=.46;\n    xy.x-=.05;\n    //xy.x-=.3;\n    xy.y+=.15;\n    xy.y=abs(xy.y);\n    xy+=.1;//+sin(iTime)/20.;\n    vec3 col = 0.5 + 0.5*cos(iTime*4. +\n                             xy.x*vec3(0.0, -2.0, -2.0)/\n                             xy.y*vec3(0.0, sqrt(12.0), -sqrt(12.0)));\n    col=col*vec3(.2,.9,.1);//less colorful\n    // Output to screen\n    fragColor = vec4(col,1.0);\n  fragColor+=(hash42(uv*1e3+iTime*.2)-.5)*.2;  // optional film grain effect from https://www.shadertoy.com/view/tdy3DD\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tySDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 169], [172, 172, 229, 229, 879]], "test": "untested"}
{"id": "3tyXDW", "name": "Warping Fur", "author": "oddlama", "description": "Warping lines based on fbm", "tags": ["procedural", "2d", "fbm", "warp"], "likes": 9, "viewed": 309, "published": "Public API", "date": "1582673074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMIT License\n\nCopyright (c) 2020 oddlama\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\n\n// SETTINGS\n\n// Adjusts the animation speed\nconst float time_speed = 0.3;\n// grid pixel dimensions\nconst vec2 grid_size = vec2(30.0);\n// length of line (CAREFUL DONT go > 6, this is O(n^2) !! )\nconst float line_len_factor = 4.0;\n// Thickness of lines\nconst float line_width = 4.6;\n\n// PRE-COMPUTED CONSTANTS, DON'T CHANGE\n\nconst ivec2 grid_neighborhood = ivec2(int(line_len_factor) - 1);\nconst float line_width_antialias = 1.0;\nconst float line_bounding_width = line_width + line_width_antialias;\n\n\n\n////////////////////////////////////////////////// NOISE FUNCTIONS\n\nfloat random (in vec2 x) {\n    return fract(sin(dot(x.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(in vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\n////////////////////////////////////////////////// Helpers\n\nvec2 nearest_grid_pos(vec2 frag_coord) {\n    return round(frag_coord / grid_size) * grid_size;\n}\n\nvec2 screenToUniform(vec2 x) {\n    return x * vec2(1. / iResolution.x);\n}\n\nfloat fbm_warp(vec2 x, out vec2 q, out vec2 r) {\n    q = vec2(fbm(x + vec2(0.0, 0.0)),\n             fbm(x + vec2(5.2, 1.3)));\n\n   \tfloat t = (iTime + 29.) * time_speed;\n    r = vec2(fbm(x + 4.0 * q + vec2(1.7, 9.2) + .15 * t),\n             fbm(x + 4.0 * q + vec2(8.3, 2.8) + .12 * t));\n    return fbm(x + 4.0 * r);\n}\n\n\n////////////////////////////////////////////////// VECTOR FIELDS\n// f = vectorfield at screen pos, f_color = color at screen pos\n\nfloat f(vec2 x, out vec2 y) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float k = fbm_warp(x, q, r);\n    r = (r + vec2(-.5)) * 2.;\n    y = grid_size * line_len_factor * r;\n    return k;\n}\n\nvec3 f_color(vec2 x) {\n    x = screenToUniform(x);\n    vec2 q, r;\n    float f = fbm_warp(x * 2., q, r);\n    \n    vec3 col = vec3(0.0);\n    col = mix( vec3(0.4,0.2,0.2), vec3(1.5,0.4,0.1), f );\n    col = mix( col, vec3(0.1,0.6,0.9), dot(r,r) );\n    col = mix( col, vec3(0.2,1.19,1.09), 0.5*q.y*q.y );\n    col *= (1. + q.x * q.x * q.x);\n    col = mix( col, vec3(0.0,1.39,1.49), 0.3*smoothstep(1.2,1.3,abs(r.y)+abs(r.x)) );\n    col *= f * 2.0;\n    return col;\n}\n\n\n////////////////////////////////////////////////// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 frag_coord) {    \n    vec3 col = vec3(0.0);\n    \n    // Any pixel can be occluded by multiple lines. Only lines from neighboring\n    // grid anchors will be considered.\n    float active_lines = 0.0;\n    for (int i = -grid_neighborhood.x; i <= grid_neighborhood.x; ++i) {\n        for (int j = -grid_neighborhood.y; j <= grid_neighborhood.y; ++j) {\n    \t\t// Beginning of the line is at the nearest grid anchor\n\t    \tvec2 line_a = nearest_grid_pos(frag_coord + grid_size * vec2(i, j));\n            // End of the line is the beginning but offset by the value of\n            // our vector field at that position\n            vec2 x;\n            float k = f(line_a, x);\n            vec2 line_b = line_a + x;\n            \n            vec2 line_dir = normalize(x);\n            // Project pixel coord to the line\n            float px_proj = dot(line_dir, frag_coord);\n            // la will always be <= lb. (To proof simply replace line_b with line_a + line_dir, solve inequality)\n            // Informal: The projected point x on d is always <= the projected point (x + d) on d.\n            float la_proj = dot(line_dir, line_a);\n            float lb_proj = dot(line_dir, line_b);\n            // We account for the line width by subtracting from la and adding to lb.\n            float la_proj_w = la_proj - line_width;\n            float lb_proj_w = lb_proj + line_width;\n            \n            // Check if projected point is on line\n            if (la_proj_w < px_proj && px_proj < lb_proj_w) {\n                // Calculate distance to line segment on this local axis\n                float dx = distance(px_proj, clamp(px_proj, la_proj, lb_proj));\n                \n                // Now do the projection on the perpendicular axis to get the distance on\n                // the axis perpendicular to the line\n                vec2 perp = line_dir.yx * vec2(1, -1);\n                float px_proj_perp = dot(perp, frag_coord);\n                float la_proj_perp = dot(perp, line_a);\n                \n                // Distance is easier here, as the line is infinitely small, so we don't need clamping.\n                float dy = distance(la_proj_perp, px_proj_perp);\n\n                // Calculate distance from line segment given distances on local axis\n                float dist = length(vec2(dx, dy));\n                if (dist < line_bounding_width) {\n                    // alpha is the relative position of px in the line\n                    float alpha = smoothstep(la_proj, lb_proj, px_proj);\n                    \n                    //vec3 c = mix(col_a, col_b, alpha);\n                    vec3 c = f_color(frag_coord);\n                    \n                    // Line gets lighter at the very end (alpha), but influenced by vector field (k).\n                    // Also add antialiasing to the line edge\n                    float blend = alpha * (.2 + k * 2.) * (1. - smoothstep(line_width, line_bounding_width, dist));\n                    // Blend with previously calculated factor, also make shorter darker everywhere\n                    float len_f = length(x) / (length(grid_size) * line_len_factor);\n                    c *= blend * 1.3 * len_f * (.7 + len_f);\n                    \n                    // Blend color with max\n                    col = max(col, c);\n                }\n            }\n    \t}\n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyXDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[1573, 1641, 1667, 1667, 1742], [1744, 1744, 1769, 1769, 2108], [2132, 2132, 2154, 2154, 2451], [2454, 2514, 2554, 2554, 2610], [2612, 2612, 2642, 2642, 2685], [2687, 2687, 2735, 2735, 3003], [3006, 3136, 3165, 3165, 3328], [3330, 3330, 3352, 3352, 3788], [3791, 3848, 3904, 3904, 7271]], "test": "untested"}
{"id": "4tcfW4", "name": "Torus_thingy_22", "author": "balkhan", "description": "bottom text", "tags": ["3d", "raymarching", "gears", "torus"], "likes": 11, "viewed": 145, "published": "Public", "date": "1582688714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p) {vec2 ap = abs(p); return max(ap.x, ap.y);}\nfloat\tmylength(vec3 p) {vec3 ap = abs(p); return max(ap.x, max(ap.y, ap.z));}\nvec2\tmodA (vec2 p, float count);\n\nvec3\tret_col, h;\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t15.\n\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n#define TRANSLUCENCY\n//#define CHAOS_LINK\n//#define NOGEARS // Real performance gain, no more blue gears though\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = vec3(uv, -1.);\n    vec3\tpos = vec3(.0, .0, 6.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    vec3 rp =p;\n    rotate(p.xz, 1.57-.125*iTime);\n    vec2 q = vec2(length(p.xy)-2., p.z);\n    var = atan(p.x,p.y) ;float id, var1;\n    var1 = atan(q.x, q.y)*-3.;\n    rotate(q, var*-9.+ var1 +iTime*-2.);\n    var1 = atan(q.x, q.y)*1.;\n    q = abs(q)-.25;//var;\n    id = (var1*10.)/10.;\n    //var = 1.*dot(q.x, p.z-0.)*10.+iTime*.0;\n    \n    #ifdef CHAOS_LINK\n    q -= .25;\n    rotate(q, var1*5.+iTime*-1.+id*.5*.0);\n    q.x = abs(q.x)-.1252503;\n        rotate(q, var1*-7.+iTime*-1.+id*.5*0.0);\n    q.x = abs(q.x)-.12503;\n        rotate(q, var1*7.+iTime*-.5+id*.5*0.0);\n    q.x = abs(q.x)-.12503;\n    #endif\n\n    float var2 = sin(var*7.+id*1.+iTime*-0.)-1.;\n    ret_col = 1.-vec3(.5-var2*.5*.0-id/30., .5+id/20., .3+var2*.5*.0+id/25.);\n    ret_col = vec3(\n\t    cos(id/2.+0.00+iTime)\n        ,\n        cos(id/2.+1.04+iTime)\n        ,\n        cos(id/2.+2.08+iTime)\n    );\n    //ret_col=abs(ret_col);\n    mind = mylength(q)-.15-.1*var2;\n    mind = abs(mind)-.0051;\n    mind = abs(mind)-.0051;\n    mind = abs(mind)-.0051;\n    #ifdef TRANSLUCENCY\n    mind = abs(mind)+.001;\n    #endif\n    ret_col = vec3(1.8, .2, .2)+ret_col;\n    h += ret_col*vec3(1.)*.25/(.201+(mind-var2*0.)*(mind-var2*0.) );\n    if (mind <= E*5000.)\n    h += (1.-ret_col)*vec3(1.)*.005/(.0071001+(mind-var2*.0)*(mind-var2*.0)*.00051);\n\n    #ifndef NOGEARS\n    float b;\n    p = rp;\n    rotate(p.xz, 1.57+iTime*.25);\n    rotate(p.xy, 1.57+iTime*.10);\n\tp.xz = modA(p.xz, 5.);\n    p.yx = modA(p.yx, 8.);\n    p.y -= 7.;\n    p.xz = modA(p.xz, 5.);\n    p.x -= 1.2;\n    rotate(p.yz, 1.57+iTime*1.0);\n    p.zy = modA(p.zy, 10.);\n    p.z -= .50;\n    p.xy = modA(p.xy, 20.);\n    p.x -= .25;\n    b = mylength(p)-.152525;\n    b = abs(b)-0.001;\n    b = abs(b)+0.0420751;\n    mind = min(mind, b);\n    h += vec3(.1, .232, .413)*.25/(.00810071001+(b)*(b)*10.);\n    #endif\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*.2; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n    }\n    return dist;\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    //idd = 3.14*floor((a-an*.5)*count)/count;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcfW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 187, 211, 211, 253], [254, 254, 278, 278, 331], [505, 597, 640, 640, 893], [895, 895, 916, 916, 2795], [2797, 2797, 2829, 2829, 3178], [3180, 3194, 3234, 3234, 3309], [3311, 3311, 3344, 3344, 3522]], "test": "untested"}
{"id": "ll3yzB", "name": "Worley Noise Relax", "author": "fscur", "description": "worley noise studies", "tags": ["worley2d"], "likes": 0, "viewed": 68, "published": "Public", "date": "1582687828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE3 vec3(123.34, 234.34, 345.65)\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat worley_noise_2(vec2 uv, float t) {\n    vec2 f = fract(uv)-.5;\t\n    vec2 id = floor(uv);\n    float min_dist = 8.0;\n    \n    for(float y = -1.0; y <= 1.0; ++y) \n    {\n        for(float x = -1.0; x <= 1.0; ++x) \n        {\n            vec2 offset = vec2(x, y);\n            vec2 rand = hash22(id + offset);\n            vec2 p = offset + sin(rand * t) * 0.5;\n            vec2 r = f-p;\n            \n            float d = dot(r,r);\n\n            if (d < min_dist)\n                min_dist = d;\n        }\n    }\n    \n    return sqrt(min_dist);\n}\n\nfloat worley_fbm(vec2 uv, float t, float scale, float amplitude, float octaves) {\n    \n    float f = 0.0;\n    \n    for (float i = 0.0; i < octaves; i++)\n    {\n        f += worley_noise_2(uv * scale, t) * amplitude;\n        amplitude *= .5;\n        scale *= 2.;\n    }\n    \n    return f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv -= vec2(iTime*0.0055, iTime*0.003);\n    \n    vec3 sky_color = vec3(0.17, 0.31, 0.8);\n    vec3 clouds_color = vec3(1.0);\n    \n    float speed = iTime * 0.0262 + 150.0;\n    float scale = 2.2;\n    float amplitude = sin(iTime*0.15)*0.4+1.2; //[.8 .. 1.6]\n    float octaves = 16.0;\n    float w = worley_fbm(uv, speed, scale, amplitude, octaves);\n    float f = 1.0 - min(w, 1.0);\n    \n    fragColor = vec4(mix(sky_color, clouds_color, f), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 163, 163, 281], [283, 283, 323, 323, 823], [825, 825, 906, 906, 1112], [1116, 1116, 1173, 1173, 1707]], "test": "untested"}
{"id": "tl3XD4", "name": "Moekkistorm2020", "author": "el_visio", "description": "Anti-aliased 2d SDF proto", "tags": ["sdf", "amiga"], "likes": 3, "viewed": 152, "published": "Public", "date": "1580930328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.1415926538\n#define TAU 6.2831853076\n#define AA_THRESHOLD 0.1\n\nfloat sdf_circle(vec2 pos, vec2 circle_pos, float circle_r) {\n\treturn length(pos - circle_pos) - circle_r;\n}\n\nfloat sdf_donut(vec2 pos, vec2 donut_pos, float donut_r, float donut_width) {\n\treturn max(sdf_circle(pos, donut_pos, donut_r + donut_width),\n              -sdf_circle(pos, donut_pos, donut_r - donut_width));    \n}\n\nfloat sdf_plane(vec2 pos, vec2 plane_pos, float angle) {\n    pos -= plane_pos;\n    return (sin(angle) * pos.y - cos(angle) * pos.x);\n}\n\nfloat sdf_arc(vec2 pos, vec2 arc_pos, float r, float width, float angle_a, float angle_b)\n{\n    float donut1 = sdf_donut(pos, arc_pos, r, 0.14);\n    float donut2 = sdf_donut(pos, arc_pos, r * 1.5, 0.15);\n    float donut3 = sdf_donut(pos, arc_pos, r * 2.0, 0.16);\n    float donut = min(min(donut1, donut2),donut3);\n\tfloat corner;\n    \n    if (mod(angle_b - angle_a, TAU) < PI) {\n        corner = min(sdf_plane(pos, arc_pos, angle_a),\n                    -sdf_plane(pos, arc_pos, angle_b));\n    } else {\n        corner = max(sdf_plane(pos, arc_pos, angle_a),\n                    -sdf_plane(pos, arc_pos, angle_b));\n    }\n    \n    corner += AA_THRESHOLD * (mod(angle_b - angle_a, TAU) / TAU);\n    \n    return max(donut, -corner);\n}\n\nfloat map_color(float in_value, float threshold) {\n\treturn clamp (in_value / threshold, 0.0, 1.0);\n}\n\nfloat get_depth(vec2 pos)\n{\n    pos *= 0.5;\n   \tvec2 delta = vec2(sin(iTime * 0.4), cos(-iTime*0.4) * 0.4) - pos;\n   \tvec2 delta2 = vec2(sin(-iTime * 1.5)*0.5, cos(-iTime*0.3)) - pos;\n    return 1.0-length(delta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.yy;\n    vec2 orig_uv = uv;\n    \n    uv = mod(uv * 10.0, 2.0) - vec2(1.0,1.0);\n\n    vec2 pos1 = vec2(0.0,0.0);\n\n    \n    float _time = mod(iTime, TAU * 2.0);\n\n    float weight = get_depth(orig_uv);\n\n    vec3 xy_0 = vec3(orig_uv, get_depth(orig_uv));\n    vec3 xy_1 = vec3(orig_uv + vec2(0.1,0.0), get_depth(orig_uv + vec2(0.1,0.0)));\n    vec3 xy_2 = vec3(orig_uv + vec2(0.0,0.1), get_depth(orig_uv + vec2(0.0,0.1)));\n    \n    vec3 normal = cross(xy_1 - xy_0, xy_2 - xy_0);\n    \n    float angle = atan(-normal.x, -normal.y);\n    float weight_normal = weight * 0.5 + 0.5;\n    pos1 += vec2(normal.x, normal.y)*5.0;\n    float distance = sdf_arc(uv, pos1, 0.15 + 0.35 * weight, 0.6 - weight * 0.3, angle - PI * weight_normal, angle + PI * weight_normal);    \n    \n\tfloat shade = map_color(-distance, AA_THRESHOLD);\n\n    fragColor = vec4(shade, shade, 0.0,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 137, 137, 184], [186, 186, 263, 263, 399], [401, 401, 457, 457, 535], [537, 537, 628, 628, 1265], [1267, 1267, 1317, 1317, 1367], [1369, 1369, 1396, 1396, 1584], [1586, 1586, 1643, 1643, 2562]], "test": "untested"}
{"id": "tl3XDj", "name": "Four Black Squares", "author": "lsdlive", "description": "A motion design exercice I tried to solve with shaders and simple cue/easing.\nhttp://www.movecraft.com/wnm205-module-02/\n\nEach animation is 2 seconds long and tries to describe these 5 words:\n1. Bold\n2. Playful\n3. Nervous\n4. Witful\n5. Ordered", "tags": ["2d", "motion", "design", "easing"], "likes": 7, "viewed": 301, "published": "Public API", "date": "1581697083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nFour Black Squares.\n\nA motion design exercice I tried to solve with shaders and simple cue/easing.\nhttp://www.movecraft.com/wnm205-module-02/\n\nEach animation is 2 seconds long and tries to describe these 5 words:\n1. Bold\n2. Playful\n3. Nervous\n4. Witful\n5. Ordered\n\n\nWith the help of:\nhttps://thebookofshaders.com/examples/?chapter=motionToolKit\n\n*/\n\n#define AA 3.\n\n#define pi 3.141592\n#define time iTime\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0., 1.);\n}\n\nfloat tri(float x) {\n    return abs(mod((x + .5) * 2., 2.) - 1.);\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t * t;\n    } else {\n        return .5 * ((t -= 2.) * t * t + 2.);\n    }\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\nfloat easeInExpo(float t) {\n    return (t == 0.) ? 0. : pow(2., 10. * (t - 1.));\n}\n\nfloat bold(vec2 uv) {\n    uv *= 1.3;\n    float t1 = linearstep(.5, 1., fract(time*.5));\n    float t2 = linearstep(0., .8, fract(time*.5));\n    t2 = easeInExpo(t2);\n    t1 = easeInOutExpo(t1);\n    \n    // alternative\n    /*\n    float s1 = mix(.1, .3, t1);\n    float offs = mix(.2, .4, t1);//.2\n    float alpha = mix(.5, 1., t1);\n    float mask = fill(rect(uv+vec2(0, .2), vec2(s1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.1)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.1)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.1)));\n\t*/\n    \n    float s1 = mix(.05, .3, t1);\n    float offs = mix(.7, .42, t2);//.2\n    float alpha = mix(.5, 1., t1);\n    float mask = fill(rect(uv+vec2(0, .2), vec2(s1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.12)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.12)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.12)));\n    \n    return mask;\n}\n\nfloat playful(vec2 uv) {\n    float t1 = fract(time);\n    //t1 = easeInOutQuad(t1);\n    \n    float alpha = mix(.5, .8, tri(t1));;\n    \n    vec2 south = vec2(0, .3);\n    vec2 east = vec2(.3, 0);\n    vec2 north = vec2(0, -.3);\n    vec2 west = vec2(-.3, 0);\n    \n    \n    vec2 pos1 = mix(south, east, t1);\n    vec2 pos2 = mix(east, north, t1);\n    vec2 pos3 = mix(north, west, t1);\n    vec2 pos4 = mix(west, south, t1);\n    \n    float mask = fill(rect((uv-pos1)*r2d(t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos2)*r2d(-t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos3)*r2d(t1*pi), vec2(.1))) * alpha;\n    mask += fill(rect((uv-pos4)*r2d(-t1*pi), vec2(.1))) * alpha;\n    \n    return mask;\n}\n\nfloat nervous(vec2 uv) {\n    float t1 = fract(time*.5);\n    t1 = easeInOutQuad((t1));\n    \n    float offs = mix(.5, .25, t1);\n    float alpha = .5;\n    float shake = sin(time*30.*pi)*.01;\n    float mask = fill(rect(uv+vec2(shake, .2), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(offs, .2), vec2(.12)));\n    mask += fill(rect(uv-vec2(0, -.2 + offs), vec2(.12)));\n    mask += fill(rect(uv-vec2(offs, -.2), vec2(.12)));\n    \n    return mask;\n}\n\nfloat wistful(vec2 uv) {\n    float t1 = fract(time*.5);\n    t1 = easeInOutQuad(t1);\n    \n    float dx = mix(0., .3, t1);\n    \n    float alpha = mix(1., 0., t1);\n    float mask = 0.;\n    mask += fill(rect(uv+vec2(dx, -.37), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(-dx, -.12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(dx, .12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(-dx, .37), vec2(.1))) * alpha;\n    return mask;\n}\n\nfloat ordered(vec2 uv) {\n    float t1 = fract(time);\n    t1 = easeInOutExpo(t1);\n    \n    if(fract(time*.5) < .5)\n    \tuv.x += mix(.4, 0., t1);\n    else\n    \tuv.x += mix(0., -.4, t1);\n    \n    float alpha = 1.;//mix(1., 0., t1);\n    float mask = 0.;\n    mask += fill(rect(uv+vec2(0, -.37), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, -.12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, .12), vec2(.1))) * alpha;\n    mask += fill(rect(uv+vec2(0, .37), vec2(.1))) * alpha;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float t1 = fract(time*.1);\n    float mask = 0.;\n    if(t1 < 2./10.)\n        mask = bold(uv);\n    else if(t1 < 4./10.)\n        mask = playful(uv);\n\telse if(t1 < 6./10.)\n        mask = nervous(uv);\n    else if(t1 < 8./10.)\n        mask = wistful(uv);\n\telse\n        mask = ordered(uv);\n        \n\t\n    //mask = bold(uv);\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, 1. - mask);\n    \n    col += .05 * texture(iChannel0, uv).r * texture(iChannel1, uv).r;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XDj.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[430, 556, 575, 575, 641], [643, 643, 664, 664, 721], [723, 723, 754, 754, 836], [838, 838, 889, 889, 946], [948, 948, 968, 968, 1015], [1017, 1075, 1105, 1105, 1299], [1301, 1301, 1331, 1331, 1454], [1456, 1456, 1487, 1487, 1611], [1613, 1613, 1641, 1641, 1674], [1676, 1676, 1703, 1703, 1723], [1725, 1725, 1752, 1752, 1807], [1809, 1809, 1830, 1830, 2735], [2737, 2737, 2761, 2761, 3444], [3446, 3446, 3470, 3470, 3892], [3894, 3894, 3918, 3918, 4338], [4340, 4340, 4364, 4364, 4846], [4848, 4848, 4905, 4905, 5484]], "test": "untested"}
{"id": "tl3XRM", "name": "neon updated", "author": "tezza321", "description": "an update for my own use of the neon heart by Alro", "tags": ["heart", "nean"], "likes": 3, "viewed": 332, "published": "Public API", "date": "1580602971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define POINT_COUNT 10\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.6;\nconst float len = 0.40;\nconst float scale = 0.015;\nfloat intensity = 1.2;\nfloat radius = 0.03;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(22.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 10000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos,3.1);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 0.1*vec3(smoothstep(0.040, 0.021, dist));\n    //Pink glow\n    col += glow * vec3(0.94,0.14,0.4);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 0.0);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 0.1*vec3(smoothstep(1.015, 1.07, dist));\n    //Blue glow\n    col += glow * vec3(0.0,0.23,0.56);\n        \n    //Tone mapping\n    col = 0.9 - exp(-col);\n\n    //Output to screen\n    fragColor = vec4(col,0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 252, 301, 301, 1577], [1580, 1627, 1658, 1658, 1811], [1813, 1853, 1910, 1910, 1952], [1954, 1954, 2004, 2004, 2500], [2502, 2502, 2558, 2558, 3461]], "test": "untested"}
{"id": "tl3XRX", "name": "simple-mix", "author": "feefi", "description": "mixture  sdf of 2 shapes", "tags": ["mix"], "likes": 5, "viewed": 263, "published": "Public", "date": "1581415898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n    float t = iTime*3.;\n    \n    \n    float circle = length(uv) - 0.23;\n    float rect =  max(abs(uv.x),abs(uv.y)) - 0.1;\n    \n    //interpolate weight (0,1) 0: circle, 1: rect\n    float w = -sin(t+sin(t+sin(t)))*0.5+0.5; \n\n    float f = circle*(1.-w)+ w*rect; //linear lerp\n    \n    \n    f = smoothstep(0.0,-0.01,f) - smoothstep(-0.01,-0.02,f);    \n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 579]], "test": "untested"}
{"id": "tl3XWB", "name": "black sun ", "author": "aodnawg", "description": "I learned ray marching..!", "tags": ["raymarch"], "likes": 5, "viewed": 136, "published": "Public", "date": "1581603004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 10\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\nfloat fbm ( in vec2 _st) {\n    float t = 1.;\n    float v = 0.;\n    float a = 0.5;\n    vec2 shift = vec2(120.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec2 addfbm(vec2 uv) {\n    return uv + vec2(fbm(uv), fbm(uv+vec2(314.433623, 234.62324)));\n}\n\nvec3 makeFbm(vec2 uv) {\n    vec2 noiseUv = addfbm(uv);\n    noiseUv.x += iTime*.1;\n    noiseUv = addfbm(noiseUv);\n    noiseUv = addfbm(noiseUv);\n    noiseUv = addfbm(noiseUv);\n    noiseUv.x += iTime*.1;\n    noiseUv = addfbm(noiseUv);\n\n    float m = fbm(noiseUv*5.);\n    vec3 col = vec3(pow(m, 4.));\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0,0,0);\n    float z = 1.;\n    vec3 rd = normalize(vec3(uv, z)-ro);\n    \n    float t=0.;\n    float step;\n    \n    for(int i=0; i<128; i++){\n        vec3 p = ro + rd*t;\n        \n        float r = makeFbm(p.xy).x*2.;\n        float dS = length(p-vec3(0,0,3))-1.+r;\n        dS = max(abs(dS), 0.02);\n\n        step = float(i);\n        if (t > 100. || dS < 0.01) break;\n        t += dS;\n    }\n    \n    col = vec3(pow(step/128., 1. + sin(iTime)*.5+.5));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 52, 52, 160], [162, 240, 267, 267, 649], [653, 653, 679, 679, 1033], [1035, 1035, 1057, 1057, 1127], [1129, 1129, 1152, 1152, 1445], [1447, 1447, 1504, 1504, 2125]], "test": "untested"}
{"id": "tl3XWN", "name": "Pacman Ghost", "author": "hanabi", "description": "cheap thrills", "tags": ["pacman"], "likes": 2, "viewed": 233, "published": "Public API", "date": "1580938964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 center = iResolution.xy / 2.;\n    float r = iResolution.y / 4.;\n\n    fragColor = vec4(0.35, 0.9, 1, 1);\n    \n    // round part\n    if (distance(fragCoord, center) < r && fragCoord.y > center.y - 1.)\n        fragColor = vec4(.9, 0, 0, 1);\n    // rectangle part\n    float r2 = r / 1.5;\n    float r_bottom = center.y - r2;\n    if (distance(fragCoord.x, center.x) < r && fragCoord.y > r_bottom && fragCoord.y < center.y + 1.)\n        fragColor = vec4(.9, 0, 0, 1);\n    // flappy part\n    if (distance(fragCoord.x, center.x) < r && fragCoord.y < r_bottom) {\n\t\tif (fragCoord.y > (r_bottom - r2)\n            + r2 * 0.25 * sin(M_PI / 180. * (float(iFrame * 5) - (fragCoord.x - center.x) * 5.)))\n        \tfragColor = vec4(.9, 0, 0, 1);\n    }\n    \n    // eyes\n    vec2 eye_pos_1 = center;\n    eye_pos_1.y += r / 4.;\n    eye_pos_1.x -= r - r / 3. - r / 100.;\n    vec2 eye_pos_2 = eye_pos_1;\n    eye_pos_2.y -= r / 1.8;\n    if (distance(fragCoord, eye_pos_1) + distance(fragCoord, eye_pos_2) <\n        distance(eye_pos_1, eye_pos_2) + r / 4.)\n        fragColor = vec4(1);\n    if (distance(fragCoord, eye_pos_2 - vec2(r/12.,-r/6. + 5. * sin(M_PI / 180. * float(iFrame)))) < r / 6.)\n        fragColor = vec4(0, 0, 1, 1);\n    \n    eye_pos_1 = center;\n    eye_pos_1.y += r / 4.;\n    eye_pos_2 = eye_pos_1;\n    eye_pos_2.y -= r / 1.8;\n    if (distance(fragCoord, eye_pos_1) + distance(fragCoord, eye_pos_2) <\n        distance(eye_pos_1, eye_pos_2) + r / 4.)\n        fragColor = vec4(1);\n    if (distance(fragCoord, eye_pos_2 - vec2(r/12.,-r/6. + 5. * sin(M_PI / 180. * float(iFrame)))) < r / 6.)\n        fragColor = vec4(0, 0, 1, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 1779]], "test": "untested"}
{"id": "tl3XzB", "name": "Apollonian-II-v2", "author": "jorge2017a1", "description": "Apollonian-II-v2", "tags": ["apollonianiiv2"], "likes": 4, "viewed": 88, "published": "Public", "date": "1581198267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Referencia \n//iQ  y Shane\n//por Jorge F.p (jorge2017a1)\n\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map(vec3 p)\n{\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime*0.5;\n    \n    // Loop counter and variables.\n    float i=0., s,k;\n        s = 1.;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    \n    \n    while(i++<6.) p *= k = 1.0/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n    \n    \n    \n    float a1, a2,a3;\n    \n    a1= dot(p.xy,p.xy);\n    a2= dot(p.yz,p.yz);\n    a3= dot(p.zx,p.zx);\n    \n    \n    float d1 = sqrt( min( max( a1, a2 ), a3 ) ) - 0.012;\n    \n    \n    float d2 = abs(p.y);\n    float dmi = d2;\n    \n    float adr = 0.7*fract((0.5*p.y+0.5)*8.0);\n    \n    \n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/s, adr, k*0.5 );\n    \n    \n}\n\n\n\n\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        //vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        \n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        \n        \n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3XzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[186, 261, 279, 398, 1586], [1592, 1592, 1630, 1630, 1964], [1966, 1966, 2010, 2010, 2265], [2267, 2267, 2303, 2303, 2567], [2569, 2569, 2611, 2611, 2905], [2908, 2908, 2968, 2968, 3146], [3148, 3148, 3187, 3187, 3929], [3931, 3931, 3988, 3988, 5270], [5272, 5272, 5366, 5366, 5473]], "test": "untested"}
{"id": "tlcSD4", "name": "Jellyfish form for 3dprint", "author": "cabbibo", "description": "form only", "tags": ["jellyfish"], "likes": 3, "viewed": 102, "published": "Public", "date": "1580927714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 2000;\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               \t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX , in float mouseY )\n{\n    float an = 0.3 + 10.0*mouseY;\n    float anY =  mouseX * 6.;\n\tcamPos = vec3(3.5*sin(an),20. * sin(anY),3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat dot2(in vec2 v ) {return dot(v,v);}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec3 opTwist(  in vec3 p )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    pos.x += sin( pos.y) * .2;\n    pos.z += cos( pos.y * .8) * .3;\n    \n    float res = sdSphere( pos - vec3(0.,1.,0.) , .8);\n    res = opSmoothSubtraction(  sdBox( pos , vec3(10.,1.,10.)),res ,.3);\n    res = opSmoothSubtraction(  sdSphere( pos - vec3(0.,.8,0.) , .7),res ,.3);\n    \n    res = opSmoothUnion( sdTorus(pos-vec3(0.,1.2,0.),vec2(1. , .01)),res ,.5);\n    res = opSmoothUnion( sdTorus(pos-vec3(0.,1.,0.),vec2(1.2 , .07)),res ,.2);\n    res += .03 * noise( pos * 10. );\n    \n    res -= .01 * noise( pos * 3. );\n    \n    \n    // Top Tubes\n    vec3 p2 = pos;\n    float degree = atan( p2.x , p2.z );\n    \n    float ogD = degree;\n    \n    float l = length( p2.xz );\n    \n    float segments = 20.;\n    float which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 10. + which * 2. + iTime * which * .1) * .02;\n    res = opSmoothUnion( .1 * sdVerticalCapsule( p2 - vec3(0.,-(.1 + sin( 6.*which * 3.14159 / segments)),1.2),1.2 + sin(  6.*which* 3.14159 / segments), .05),res ,.1);\n   \t\n   \n    \n    // lil bumppies\n    \n    p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    l = length( p2.xz );\n    \n    segments = 10.;\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    res = opSmoothSubtraction( sdSphere( p2 - vec3(0.,1.2,.98),.03),res ,.2);\n   \t\n    \n    \n    // top dimples\n     p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    l = length( p2.xz );\n    \n    segments = 2.;\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    res = opSmoothSubtraction( sdSphere( p2 - vec3(0.,1.8,.4),.2),res ,.15);\n   \t\n       \n    // long tenkz\n    \n        p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    \n    l = length( p2.xz );\n     segments = 6.;\n    which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 3. + which * 2. + iTime * which * .1) * .02;\n    res = opSmoothUnion( .04 * noise( pos * 5. ) * p2.y + sdVerticalCapsule( p2 - vec3(0.,-(2.1 + sin( 6.*which * 3.14159 / segments)),.6 - .1*p2.y),3.2 + sin(  6.*which* 3.14159 / segments), .1 * max(-p2.y * .3,1.)),res ,.03);\n   \t\n    \n    float pluemVal =  .4 * noise( pos * 5. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.4*-pos.y) );\n   \tpluemVal = opSmoothUnion( .2 * noise( pos * 8. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.5*-pos.y) ),pluemVal ,.03);\n   \tpluemVal = opSmoothUnion( .1 * noise( pos * 9. ) + sdVerticalCapsule( pos - vec3(0.,-7.,0.), 8., .4  * max(.5,.6*-pos.y) ),pluemVal ,.03);\n   \t \n    // long tenkz\n    \n    p2 = pos;\n    degree = atan( p2.x , p2.z );\n    \n    ogD = degree;\n    \n    \n    l = length( p2.xz );\n     segments = 6.;\n    which = floor((degree - 3.14159  / (segments*2.)) / ( 3.14159 / segments)- 3.14159  / (segments * 2.));\n    degree = mod( degree - 3.14159  / (segments * 2.) , 3.14159  / segments );\n    degree -= 3.14159  / (segments * 2.);\n \n    \n    p2.x = l * sin( degree );\n    p2.z = l * cos( degree );\n    \n    p2.x += sin( p2.y * 3. + which * 2. + iTime * which * .1) * .02;\n    \n    float extras = sdVerticalCapsule( p2 - vec3(0.,-8.,-.2*p2.y),8.2,.05 * max(-p2.y * .5,1.));\n    pluemVal = opSmoothSubtraction(  extras, pluemVal ,.3);\n    pluemVal = opSmoothUnion(  extras, pluemVal ,.01);\n   \tpluemVal = opSmoothUnion( sdVerticalCapsule(pos- vec3(0.,-1.,0.), 2.,.2),pluemVal,.2);\n    pluemVal = opSmoothSubtraction( sdVerticalCapsule(pos- vec3(0.,-10.,0.), 2.,1.2),pluemVal,.6);\n    \n    res = opSmoothUnion( res , pluemVal , .1 );\n    \n    return vec2(res,1.);\n    \n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.yx + 2.0*fragCoord.yx)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x ,m.y);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n       col = norm * .5 + .5;\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 337, 360, 360, 399], [401, 401, 424, 493, 864], [867, 898, 962, 962, 1140], [1142, 1142, 1243, 1243, 1397], [1400, 1400, 1431, 1431, 1469], [1474, 1547, 1570, 1570, 1676], [1678, 1678, 1701, 1701, 1807], [1809, 1809, 1832, 1832, 1941], [1944, 1944, 1970, 1970, 2039], [2041, 2041, 2074, 2074, 2139], [2145, 2145, 2197, 2197, 2296], [2298, 2298, 2356, 2356, 2456], [2458, 2458, 2517, 2517, 2616], [2619, 2619, 2656, 2656, 2739], [2741, 2741, 2765, 2765, 2782], [2783, 2783, 2807, 2807, 2824], [2825, 2825, 2884, 2884, 3197], [3199, 3199, 3234, 3234, 3258], [3260, 3260, 3291, 3291, 3378], [3380, 3380, 3433, 3433, 3492], [3494, 3494, 3522, 3522, 3702], [3706, 3790, 3811, 3811, 8132], [8134, 8134, 8182, 8182, 8649], [8653, 8766, 8797, 8797, 9023], [9026, 9026, 9063, 9063, 9195], [9197, 9197, 9254, 9254, 10059]], "test": "untested"}
{"id": "tlcSRs", "name": "My first 3D demo", "author": "pspupsp", "description": "It' s just my first demo:)", "tags": ["3d"], "likes": 1, "viewed": 49, "published": "Public", "date": "1581524075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord.st / iResolution.st;\n\t     uv = uv * 2.0 - 1.0;\n\n\tfloat aspectRatio = iResolution.s / iResolution.t;\n\tuv.x *= aspectRatio;\n\t\n\tvec2 screenCentre = vec2(0.0);\n\tfloat camToScreenDistance = 1.0;\n\t\n\tvec2 centreToUV = uv - screenCentre;\n\tvec3 camToUV = vec3(centreToUV, camToScreenDistance);\n\tvec3 camToCentre = vec3(0.0, 0.0, camToScreenDistance);\n\t\n\tvec3 normCamToUV = normalize(camToUV);\n\tvec3 normCamToCentre = normalize(camToCentre);\n\t\n\n\t//vec3 sphereCentre = vec3(sin(iTime) * 2.0 - 1.0, cos(iTime) * 2.0 - 1.0, 3.0 + (sin(iTime * 10.0) * 2.0 - 1.0) * 0.5);\n    vec3 sphereCentre = vec3(sin(iTime * 5.0), cos(iTime * 5.0), 1.0 + (cos(iTime * 10.0) + 1.0) * 2.0);\n\tfloat sphereRadius = 1.0;\n\n\n\n\n\tvec3 posInScreen = vec3(uv, 0.0);\n\tvec3 pos = vec3(uv, -camToScreenDistance);\n\n\tfloat avaliable = 0.0;\n\tfloat depthMap = 1.0;\n\n\tconst int samp = 64;\n\tfloat stepLength = 0.1;\n\tfor(int i = 0; i <= samp; i++)\n\t{\n\t\tpos += normCamToUV * stepLength;\n\t\tfloat map = Sphere(sphereCentre - pos, sphereRadius);\n\n\t\tif(map < 0.02)\n\t\t{\n\t\t\tavaliable = 1.0;\n\t\t\tdepthMap += length(pos - posInScreen) / (float(samp) * stepLength) - 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdepthMap = clamp(depthMap, 0.0, 1.0);\n\n\tfragColor = vec4(vec3(depthMap), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 60], [62, 62, 119, 119, 1356]], "test": "untested"}
{"id": "tlcSWf", "name": "petal 2 (117 chars)", "author": "FabriceNeyret2", "description": "inspired and golfed from [url]https://shadertoy.com/view/wtcSDX[/url]", "tags": ["2d", "onetweet", "golf"], "likes": 3, "viewed": 204, "published": "Public API", "date": "1581837209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired and golfed from https://shadertoy.com/view/wtcSDX\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R  = iResolution.xy, U  = u+u - R ;\n    O += abs( cos( 3.* atan(U.y,U.x) -iTime )) - length(U)/R.y *vec4(1,.8,.6,0);\n} \n/*\n\n\n\n\n\n// --- 113 chars: antialiased petals\n\n#define mainImage(O,u)                        \\\n    vec2 R  = iResolution.xy, U  = u+u - R ;  \\\n    O += ( abs( R.x = cos( 3.* atan(U.y,U.x) )) - length(U)/R.y ) / fwidth(R.x) /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 99, 99, 227]], "test": "untested"}
{"id": "tlcXD7", "name": "Panspermia Incoming", "author": "dr2", "description": "The invasion is coming", "tags": ["symmetry", "virus"], "likes": 9, "viewed": 282, "published": "Public API", "date": "1581070859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Panspermia Incoming\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // optional antialising\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec4 qrHit;\nvec3 ltDir, bGrid, cId, obRnd, obDisp;\nvec2 obRotCs[2];\nfloat tCur, dstFar;\nbool cOcc;\nconst float pi = 3.14159;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\nvec3 SymCom (vec3 p, vec2 cs, vec2 w)\n{\n  vec2 f;\n  float a;\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    f.y = dot (p.yz, vec2 (cs.x, - cs.y));\n    if (f.y > 0.) {\n      f.x = dot (p.yz, cs.yx);\n      p.yz = vec2 (dot (f, vec2 (cs.y, - cs.x)), dot (f, cs));\n    }\n    if (j < 3) p.xy = Rot2Cs (p.xy, w);\n  }\n  return vec3 (p.xy, - p.z);\n}\n\nvec3 IcosSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * acos (sqrt (5.) / 3.));\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), vec2 (cs.x, - cs.y));\n  return SymCom (p, cs, CosSin (-2. * pi / 3.));\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * atan (2.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), cs);\n  p.xy = Rot2Cs (p.xy, CosSin (- pi / 10.));\n  return SymCom (p, cs, CosSin (-2. * pi / 5.));\n}\n\nvoid ObjState ()\n{\n  obRnd = Hashv3v3 (cId);\n  obDisp = bGrid * (cId + 0.5) + (0.1 + 0.05 * bGrid.x * obRnd.x) *\n     vec3 (CosSin (obRnd.z * tCur + obRnd.x), 0.).xzy;\n  obRotCs[0] = CosSin ((obRnd.y - 0.5) * 0.7 * tCur );\n  obRotCs[1] = CosSin ((obRnd.z - 0.5) * 0.7 * tCur);\n  cOcc = (obRnd.x * step (2., length (cId.xz)) > 0.7);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, q1, q2;\n  float d, d1, d2, ds, r1, r2, len, s;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.xz = Rot2Cs (p.xz, obRotCs[0]);\n    p.xy = Rot2Cs (p.xy, obRotCs[1]);\n    len = 0.3;\n    q1 = IcosSym (p);\n    q1.z += 0.18 + len;\n    s = 0.5 * (1. - q1.z / len);\n    r1 = 0.03 * (1. + 5. * s * s);\n    d1 = PrCylAnDf (q1, r1, 0.016 * (1. - 0.7 * s), len);\n    q2 = DodecSym (p);\n    q2.z += 0.18 + len;\n    s = 0.5 * (1. - q2.z / len);\n    r2 = 0.03 * (1. + 5. * s * s);\n    d2 = PrCylAnDf (q2, r2, 0.016 * (1. - 0.7 * s), len);\n    if (d1 < d2) {\n      d = d1;\n      qrHit = vec4 (q1, r1);\n    } else {\n      d = d2;\n      qrHit = vec4 (q2, r2);\n    }\n    q = p;\n    ds = PrSphDf (q, 0.2);\n    if (ds < d) {\n      d = SmoothMin (d, ds, 0.02);\n      qrHit = vec4 (q, 0.);\n    }\n    d *= 0.8;\n  }\n  return d;\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += 0.2 * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 220; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  cIdP = vec3 (-999.);\n  for (int j = 0; j < 20; j ++) {\n    p = ObjCell (ro + d * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 2.) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 3.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return 1.5 * mix (vec3 (0.25, 0.6, 1.), vec3 (0., 0.4, 0.3), 0.5 * (1. - rd.y)) *\n     (0.8 + 0.2 * rd.y) * (1. + 0.25 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, p;\n  float dstObj, sh;\n  bGrid = vec3 (2.);\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    p = ObjCell (ro);\n    ObjState ();\n    vn = ObjNf (p);\n    if (length (p - obDisp) > 0.21) col = (length (qrHit.xy) < qrHit.w) ?\n       vec3 (1., 0.4, 0.4) * (0.6 + 0.4 * smoothstep (-0.1, 0.1, sin (15. * atan (qrHit.y, qrHit.x)))) :\n       vec3 (0.4, 1., 0.4) * (0.6 + 0.4 * smoothstep (-0.1, 0.1, sin (15. * 2. * pi * qrHit.z)));\n    else col = vec3 (1., 1., 0.4);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 0.3 + 0.7 * smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.6 * pi * mPtr.y;\n  } else {\n    az = 0.02 * pi * tCur;\n    el = 0.1 * pi + 0.2 * pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.5);\n  ltDir = vuMat * normalize (vec3 (1., 1., -2.));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 4.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 645, 684, 684, 997], [999, 999, 1022, 1022, 1191], [1193, 1193, 1217, 1217, 1402], [1404, 1404, 1422, 1422, 1737], [1739, 1739, 1761, 1761, 2580], [2582, 2582, 2605, 2605, 2735], [2737, 2737, 2770, 2770, 3335], [3337, 3337, 3358, 3358, 3606], [3608, 3608, 3645, 3645, 4003], [4005, 4005, 4027, 4027, 4431], [4433, 4433, 4468, 4468, 5355], [5357, 5357, 5410, 5410, 6396], [6398, 6398, 6431, 6431, 6458], [6460, 6460, 6513, 6513, 6574], [6576, 6576, 6598, 6598, 6636], [6638, 6638, 6683, 6683, 6786], [6788, 6788, 6824, 6824, 7030], [7032, 7032, 7062, 7062, 7120], [7122, 7122, 7153, 7153, 7217], [7251, 7251, 7275, 7275, 7335], [7337, 7337, 7361, 7361, 7479]], "test": "untested"}
{"id": "tlcXD8", "name": "Motion Loop #001", "author": "lsdlive", "description": "Back to shaders.\nCritique & Comments are welcome.", "tags": ["2d", "loop", "motion", "ease"], "likes": 8, "viewed": 339, "published": "Public API", "date": "1580843755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nMotion Loop #001\n\nCheckout the ISF port: https://github.com/theotime/isf_shaders/blob/master/shaders/motiongraphics_001.fs\n\nWith the help of https://thebookofshaders.com/examples/?chapter=motionToolKit\nWith the help of Flopine, FabriceNeyret2, Pixel Spirit Deck.\n\n*/\n\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\n#define bpm 120.\n#define speed .5\n#define ring_base_sz .0125\n#define ring_base_width .1\n\n#define AA 3.\n\n#define pi 3.141592\n#define time (speed*(bpm/60.)*iTime)\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d) {\n    return 1. - smoothstep(0., AA / iResolution.x, d);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat flip(float value, float percent) {\n\treturn mix(value, 1. - value, percent);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064320\nfloat easeInOutExpo(float t) {\n    if (t == 0. || t == 1.) {\n        return t;\n    }\n    if ((t *= 2.) < 1.) {\n        return .5 * exp2(10. * (t - 1.));\n    } else {\n        return .5 * (-exp2(-10. * (t - 1.)) + 2.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t;\n    } else {\n        return -.5 * ((t - 1.) * (t - 3.) - 1.);\n    }\n}\n\n// not used, but can be\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.) < 1.) {\n        return .5 * t * t * t;\n    } else {\n        return .5 * ((t -= 2.) * t * t + 2.);\n    }\n}\n\n// https://thebookofshaders.com/edit.php?log=160909064528\n/*float ring(vec2 p, float radius, float width) {\n  \treturn abs(length(p) - radius * 0.5) - width;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // rotation animation\n    float t = easeInOutExpo(fract(time));\n    uv *= r2d((pi / 2.) * (floor(time) + t));\n    \n    // ring size animation\n    float offs = .5;\n\tt = easeInOutExpo(fract(time + offs));\n    float anim_sz = .125 + .125 * sin(pi * .75 + pi * (floor(time + offs) + t));\n    \n    // old solution for anti-aliasing\n    /*\n\tfloat ring = ring(uv, ring_base_sz + anim_sz, ring_base_width);\n    float eps = abs(ring); // sharpen around the ring\n    float sdf = (2. * smoothstep(-eps, eps, uv.x) - 1.) * ring;\n    float mask = smoothedge(sdf, 3.); // cut sdf + AA\n\t*/\n    \n    // Better solution from pixel spirit deck\n    // pixelspiritdeck.com\n    float mask = flip(stroke(circle(uv, ring_base_sz + anim_sz), ring_base_width), fill(uv.x));\n    \n    vec3 col = mix(col1, col2, mask);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcXD8.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[294, 582, 601, 601, 667], [669, 669, 690, 690, 747], [749, 882, 918, 918, 990], [992, 992, 1032, 1032, 1075], [1077, 1077, 1113, 1113, 1144], [1146, 1204, 1234, 1234, 1428], [1430, 1454, 1484, 1484, 1607], [1609, 1633, 1664, 1664, 1788], [1790, 1952, 2009, 2009, 2913]], "test": "untested"}
{"id": "tldSDn", "name": "Noise Comparison", "author": "JackSolace", "description": "Comparision of value and gradient noise with their fractal counterparts. ", "tags": ["procedural", "noise", "gradient", "value", "learn"], "likes": 6, "viewed": 79, "published": "Public", "date": "1580783902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Feb 2020\n//Comparision of value and gradient noise with their fractal counterparts. \n//prep for procedural generation\n\nint NUM_OCTAVES = 5;//play with this\n\n//\t3D Value Noise \n//\tfrom Stefan Gustavson\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat vnoise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\t\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//\tClassic Perlin 3D Noise (The OG gradient noise)\n//\tfrom Stefan Gustavson\n//\tImproving Noise, Ken Perlin http://mrl.nyu.edu/~perlin/paper445.pdf\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n//math is wack take a vector calc class lol\nfloat gnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//fractal value noise\nfloat fvbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * vnoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//fractal gradient noise\nfloat fgbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;//play with this\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * gnoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 index = vec3(uv.x*16.0,uv.y*16.0, iTime);//play with the 16.0 here\n    \n    float noise_value = 0.0;\n    \n    if (uv.x < 0.5) {\n        if (uv.y > 0.5){//value noise bottom left\n    \t\tnoise_value = vnoise(index);\n        }else{//fractal value noise bottom left\n        \tnoise_value = fvbm(index);\n        }\n       \t\n    }else {\n        if (uv.y > 0.5){//gradient noise top right\n    \t\tnoise_value = gnoise(index);\n        }else{//fractal value noise bottom right\n        \tnoise_value = fgbm(index);\n        }\n        noise_value = 0.5 - noise_value;//invert (there are better ways of doing this)\n    }\n    \n    fragColor = vec4(noise_value,noise_value,noise_value, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 213, 235, 235, 280], [281, 281, 301, 301, 346], [347, 347, 365, 365, 404], [405, 405, 426, 426, 918], [920, 1067, 1088, 1088, 1125], [1126, 1126, 1153, 1153, 1201], [1202, 1202, 1221, 1221, 1257], [1259, 1303, 1324, 1324, 3596], [3598, 3620, 3640, 3640, 3811], [3813, 3838, 3858, 3858, 4045], [4047, 4047, 4104, 4154, 4877]], "test": "untested"}
{"id": "tldSRj", "name": "Noise - wave - 2D", "author": "iq", "description": "Wave Noise - a simple wave based noise based on extremely simplified Gabor kernel. Performs similar to Garient Noise, but slower than Value Noise. It provides however some flexibility in the look, and is infinitely derivable.", "tags": ["procedural", "2d", "noise"], "likes": 24, "viewed": 1583, "published": "Public API", "date": "1581369413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A wave based noise, similar to gabor and all its variants but much\n// simplified, originially explored in shadertoy by user robobo1221\n// in this shader: https://www.shadertoy.com/view/wttSRj\n//\n// It is comparable in speed to traditional gradient noise (if the\n// architecture supports fast sin/cos, like GPUs do anyways), but\n// slower than value noise of course. The advantage is that it's\n// infinitely derivable. It can also be easily animated by moving\n// the waves over time or rotating the gradients, which is fun.\n//\n// But the main advantage is that it can generate a wromy look, as\n// in robobo1221's original shader, by changing the kF constant in \n// line 45 to be closer to 6\n\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\n\n\n\n// You should replace this hash by one that you like and meets\n// your needs. This one is here just as example and should not\n// be used in production.\nvec2 g( vec2 n ) { return sin(n.x*n.y*vec2(12,17)+vec2(1,2)); }\n//vec2 g( vec2 n ) { return sin(n.x*n.y+vec2(0,1.571)); } // if you want the gradients to lay on a circle\n\nfloat noise(vec2 p)\n{\n    const float kF = 2.0;  // make 6 to see worms\n    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(kF*dot(p,g(i+vec2(0,0)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,0)))),f.x),\n               mix(sin(kF*dot(p,g(i+vec2(0,1)))),\n               \t   sin(kF*dot(p,g(i+vec2(1,1)))),f.x),f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\n    float f = 0.0;\n\t\n    // left: noise\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 24.0*uv + iTime*4.0 );\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        uv += iTime*4.0/3.0;\n        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSRj.jpg", "access": "shaders20k", "license": "mit", "functions": [[2510, 2662, 2680, 2680, 2725], [2726, 2833, 2854, 2854, 3194], [3196, 3196, 3253, 3253, 3857]], "test": "untested"}
{"id": "tldSWH", "name": "Coming Alive", "author": "NinaFranziska", "description": "static but alive, mesmerizing and alienating", "tags": ["cineshader"], "likes": 2, "viewed": 5126, "published": "Public API", "date": "1580894026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n   uv -= vec2(0.5,0.5); //we make the whole thing black\n   uv *= -0.05; //we remap the coordinates to become between -1 and 1\n float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*1000.0)*cos(angle+distance*iTime - iTime)*100.0;\n\n   fragColor = vec4(color, color, color, color); \n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Coming Alive\",\n\t\"description\": \"static but alive, mesmerizing and alienating\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 484]], "test": "untested"}
{"id": "tldSzS", "name": "Polygon Analytic Motion Blur", "author": "fizzer", "description": "Motion blur of a closed, concave, and non-self-intersecting polygon based on ray intersection. The self-intersecting case is more costly and can be found [url=https://www.shadertoy.com/view/tltXRS]here[/url].", "tags": ["motionblur", "analytic", "polygon"], "likes": 11, "viewed": 174, "published": "Public", "date": "1581259246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Analytic Linear Motion Blur Series:\n//\n// Self-Intersecting Polygon (XOR Rule) - https://www.shadertoy.com/view/tltXRS\n// Concave Polygon - https://www.shadertoy.com/view/tldSzS\n// Square - https://www.shadertoy.com/view/wtcSzB\n// Checkerboard - https://www.shadertoy.com/view/tlcXRX\n//\n\nconst int numPolygonCorners = 20;\n\nvec2 screenToPolygonTransform(vec2 p, float t)\n{\n    float a = t * 4.;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return m * (p - vec2(cos(t * 14.)*.5, 0.));\n}\n\nvec2 polygonCorner(int i)\n{\n    const float thd = acos(-1.) * 2. / float(numPolygonCorners);\n    float r = .5 + cos(float(i) * thd * 4.) * .3;\n    return vec2(cos(float(i) * thd), sin(float(i) * thd)) * r;\n}\n\nfloat integratePolygon(vec2 sa, vec2 sb)\n{\n    vec2 sd = sb - sa;\n    float sum = 0.;\n    int e = 0;\n    \n    vec2 pa = polygonCorner(0);\n    \n    for(int i = 1; i <= numPolygonCorners; ++i)\n    {\n        vec2 pb = polygonCorner(i);\n        vec2 d = pb - pa;\n        vec2 n = vec2(d.y, -d.x);\n        float dotsdn = dot(sd, n);\n        float t = dot(pa - sa, n) / dotsdn;\n        float u = dot(sa + sd * t - pa, d);\n        \n        if(u > 0. && u <= dot(d, d))\n        {\n            if(t > 0. && t <= 1.)\n                sum += t * sign(dotsdn);\n            \n            if(t > 1.)\n                e ^= 1;\n        }\n        \n        pa = pb;\n    }\n    \n    if(e != 0)\n        sum += 1.;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\n    float t = iTime;\n    \n    vec3 col = vec3(1. / 9.);\n\n\tvec2 uv0 = screenToPolygonTransform(uv, t);\n\tvec2 uv1 = screenToPolygonTransform(uv, t - 1. / 30.);\n\n\tfloat sum = integratePolygon(uv0, uv1);\n\n    col = mix(col, vec3(.9), sum);\n    \n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 329, 377, 377, 501], [503, 503, 530, 530, 710], [712, 712, 754, 754, 1422], [1424, 1424, 1481, 1481, 1847]], "test": "untested"}
{"id": "tldXDn", "name": "Otherworldly Allure", "author": "ChutneyPot", "description": "This was my first shader on Shadertoy. Learning about raymarching and SDFs, I decided to create a shader iteratively to apply the knowledge. \n\n\n", "tags": ["raymarching", "sdf"], "likes": 2, "viewed": 133, "published": "Public", "date": "1580834996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Otherworldly Allure, February 2020\n// by Tito Morab - ChutneyPot\n// https://www.shadertoy.com/view/tldXDn\n//--------------------------------------------------------------------------\n#define EPSILON 0.001\n#define GAMMA 2.2\n\n#define CAM_POS vec3(1.0, 0.0, -1.0)\n#define CAM_LOOKAT vec3(0.0, 0.0, 0.0)\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n\n#define BASE_COLOR_MULTIPLIER 0.2;\n#define MAX_SHININESS 32.0\n\n#define SUN_DIR vec3(0.6, 0.9, -0.4)\n#define SUN_COLOR vec3(1.0, 0.8, 0.6)\n#define SUN_INTENSITY 10.0\n\n#define SAND_COLOR vec3(0.7, 0.7, 0.5)\n#define STRUCTURE_COLOR vec3(0.53, 0.27, 0.18)\n\n#define SKY_LIGHT_COLOR vec3(0.0, 0.1, 0.3)\n#define SKY_LIGHT_INTENSITY 1.0\n\n#define BOUNCE_LIGHT_COLOR vec3(0.8, 0.6, 0.4)\n#define BOUNCE_LIGHT_INTENSITY 1.0\n\n#define SKY_COLOR vec3(0.1, 0.9, 1.0)\n#define SPECULAR_COLOR vec3(0.8, 0.8, 0.8)\n#define SHADOW_COLOR vec3(0.25, 0.16, 0.1)\n\nvec3 xSymOp(vec3 pos)\n{\n    return vec3(abs(pos.x), pos.yz);\n}\n\nvec3 zSymOp(vec3 pos)\n{\n    return vec3(pos.xy, abs(pos.z));\n}\n\nvec3 xzSymOp(vec3 pos)\n{\n    return vec3(abs(pos.x), pos.y, abs(pos.z));\n}\n \n\nmat2 rotOp(float angle)\n{\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return rot;\n}\n    \nvec2 minOp(vec2 obj1, vec2 obj2)\n{\n    vec2 min;\n    \n    if(obj1.x <= obj2.x)\n    {\n        min = obj1;\n    }\n    else\n    {\n        min = obj2;\n    }\n    \n    return min;    \n}\n\nvec2 maxOp(vec2 obj1, vec2 obj2)\n{\n    vec2 max;\n    \n    if(obj1.x >= obj2.x)\n    {\n        max = obj1;\n    }\n    else\n    {\n        max = obj2;\n    }\n    \n    return max;    \n}\n\nfloat sMin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - (k * h * (1.0 - h));\n}\n\nfloat planeSDF(vec3 pos, vec3 up)\n{\n    float dist = dot(normalize(up), pos);\n    return dist;\n}\n\nfloat sphereSDF(vec3 pos, float radius)\n{\n    float dist = length(pos) - radius;\n    return dist;\n}\n\nfloat boxSDF(vec3 pos, vec3 size)\n{\n    float dist = length(max(abs(pos) - size, 0.0));\n    return dist;\n}\n\nfloat vertCapsuleSDF(vec3 pos, float height, float radius)\n{\n    pos.y -= clamp(pos.y, 0.0, height);\n    float dist = length(pos) - radius;\n    return dist;\n}\n\nfloat capCylinderSDF(vec3 pos, float height, float radius)\n{\n    vec2 d = abs(vec2(length(pos.xz), pos.y)) - vec2(radius, height);\n    float dist = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return dist;\n}\n\nfloat pillarSDF(vec3 pos, vec3 size, float rounding)\n{\n    float pillarDist = boxSDF(pos, size) - rounding;\n    float baseDist = capCylinderSDF(pos - vec3(0.0, -0.28, 0.0), 0.03, 0.08);\n    \n    float topDist = capCylinderSDF(pos - vec3(0.0, 0.31, 0.0), 0.03, 0.08); \n    float dist = min(pillarDist, min(baseDist, topDist));\n\n    vec3 r = pos;\n    vec3 sym = xzSymOp(r);\n    vec3 c = sym - vec3(0.06, -0.2, 0.06);\n    float carvingDist = vertCapsuleSDF(c, 0.4, 0.03);\n    \n    r.xz *= rotOp(40.0);\n    sym = xzSymOp(r);\n    c = sym - vec3(0.06, -0.2, 0.06);\n    float carvingDist2 = vertCapsuleSDF(c, 0.4, 0.03);\n    carvingDist = min(carvingDist, carvingDist2);\n    \n    return max(dist, -carvingDist);\n}\n\nvec2 structureSDF(vec3 pos)\n{\n    vec3 sym = xzSymOp(pos - vec3(0.0, 0.0, 0.0));\n    vec3 cen = sym - vec3(0.7, 0.0, 0.25);\n    float pillarSet1Dist = pillarSDF(cen, vec3(0.01, 0.3, 0.01), 0.05);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 1.0));\n    cen = sym - vec3(0.7, 0.0, 0.25);\n    float pillarSet2Dist = pillarSDF(cen, vec3(0.01, 0.3, 0.01), 0.05);\n    \n    float damageDist = vertCapsuleSDF(pos - vec3(0.66, 0.1, 0.2), 0.4, 0.15);\n    pillarSet1Dist = max(pillarSet1Dist, -damageDist);\n    \n    float pillarDist = min(pillarSet1Dist, pillarSet2Dist);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 2.5));\n    float pyrDist = dot(normalize(vec3(0.1, 0.1, 0.1)), sym - 0.3);\n        \n    float plate1Dist = boxSDF(pos - vec3(0.0, -0.2, 2.5), vec3(1.1, 0.25, 1.1));\n    float plate2Dist = boxSDF(pos - vec3(0.0, 0.3, 2.5), vec3(1.1, 0.2, 1.1));\n    float plate3Dist = boxSDF(pos - vec3(0.0, 0.8, 2.5), vec3(1.1, 0.25, 1.1));\n      \n    pyrDist = min(min(max(pyrDist, plate1Dist), max(pyrDist, plate2Dist)), max(pyrDist, plate3Dist));\n    \n    float strucDist = min(pillarDist, pyrDist);\n    vec2 struc = vec2(strucDist, 2.0);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 0.5));\n    float pathDist = boxSDF(sym - vec3(0.0, -0.3, 0.0), vec3(0.2, 0.01, 1.0));\n    vec2 path = vec2(pathDist, 3.0);\n    \n    vec2 obj = minOp(struc, path);\n    return obj;\n}\n\nfloat dunes(vec3 pos)\n{\n    float waves = (sin(pos.z + 1.2) * 0.2) - 0.2 + (cos(pos.x + 0.7) * 0.2) - 0.11;\n    \n    float dunes1 = max(min(sin(pos.z  - 2.2), cos(pos.x * 0.5 - 3.0)), 0.0);\n    float dunes2 = max(min(sin(pos.x - 1.5), cos(pos.z * 0.2 - 1.0)), 0.0);\n    \n    return max(max(dunes1, dunes2), waves);\n}\n\nvec2 sceneSDF(vec3 pos)\n{\n    float face1Dist = sphereSDF(pos - vec3(-0.2, 1.3, 2.5), 0.3); \n    float face2Dist = sphereSDF(pos - vec3(0.2, 1.3, 2.5), 0.3);\n    float faceDist = max(face1Dist, face2Dist);\n    \n    float ballDist = sphereSDF(pos - vec3(0.0, 1.3, 2.5), 0.16);\n\tfaceDist = max(faceDist, -ballDist);\n    vec2 face = vec2(faceDist, 4.0);\n    \n    float planeDist = planeSDF(pos - vec3(0.0, -0.3, 0.0), vec3(0.0, 1.0, 0.0)) - dunes(pos);\n    vec2 plane = vec2(planeDist, 1.0);\n    \n    vec2 struc = structureSDF(pos);\n    vec2 scene = minOp(minOp(plane, struc), face);\n    \n    return mix(scene, plane, round(sin(iTime * 0.5 + 1.0) * 0.5 + 0.5));\n    //return minOp(plane, scene);\n}\n\nvec2 rayMarch(vec3 rayOrig, vec3 rayDir)\n{\n    float t = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrig + t * rayDir;\n        \n        vec2 dist = sceneSDF(pos);\n        \n        if(dist.x < EPSILON)\n        {\n            id = dist.y;\n            break;\n        }\n        \n        t += dist.x;\n        \n        \n        if(t > MAX_DIST)\n            break;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 normal = normalize(vec3(sceneSDF(pos + e.xyy).x - sceneSDF(pos - e.xyy).x,\n                       sceneSDF(pos + e.yxy).x - sceneSDF(pos - e.yxy).x,\n                       sceneSDF(pos + e.yyx).x - sceneSDF(pos - e.yyx).x));\n        \n    return normal;\n}\n\nvec3 getLighting(vec3 pos, vec3 viewDir, float specIntensity, float shininess)\n{   \n    vec3 normal = getNormal(pos);\n    \n    float nDotL = clamp(dot(normal, SUN_DIR), 0.0, 1.0);\n    vec3 sunCol = SUN_COLOR * nDotL;\n    sunCol *= SUN_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    nDotL = clamp(dot(normal, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5, 0.0, 1.0);\n    vec3 skyCol = SKY_LIGHT_COLOR * nDotL;\n    skyCol *= SKY_LIGHT_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    nDotL = clamp(dot(normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5, 0.0, 1.0);\n    vec3 bounceCol = BOUNCE_LIGHT_COLOR * nDotL;\n    bounceCol *= BOUNCE_LIGHT_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    //vec3 reflectDir = reflect(SUN_DIR, normal);\n    vec3 halfwayDir = normalize(SUN_DIR + viewDir);\n    float power = shininess * MAX_SHININESS;\n    float spec = pow(max(dot(halfwayDir, viewDir), 0.0), power);\n    vec3 specCol = spec * specIntensity * SPECULAR_COLOR;\n    \n    float dist = rayMarch(pos + normal * 0.001, SUN_DIR).x;\n    if(dist < length(SUN_DIR))\n    {\n        return sunCol * SHADOW_COLOR + skyCol + bounceCol;\n    }\n    \n    return sunCol + skyCol + bounceCol + specCol; \n}\n\nvec3 getRayDir(vec3 pos, vec3 lookAt, vec2 uv, float fov)\n{  \n    float z = 1.0 / tan((radians(fov) / 2.0));\n    \n    vec3 zDir = normalize(lookAt - pos);\n    vec3 xDir = normalize(cross(vec3(0.0, 1.0, 0.0), zDir));\n    vec3 yDir = normalize(cross(zDir, xDir));\n    \n    vec3 rayDir = normalize(vec3(uv.x * xDir + uv.y * yDir + z * zDir));\n    return rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angle = 0.0;//10.0 * iMouse.x / iResolution.x;\n    vec3 rayOrig = CAM_POS * vec3(-sin(angle), 1.0, cos(angle));\n    vec3 rayDir = getRayDir(rayOrig, CAM_LOOKAT, uv, 60.0);\n    vec3 viewDir = normalize(CAM_LOOKAT - rayOrig);\n    \n    vec3 col = mix(SKY_COLOR, vec3(0.9, 0.9, 0.9), 1. - sqrt(rayDir.y));\n    \n    vec2 dist = rayMarch(rayOrig, rayDir);\n    \n    if(dist.x < MAX_DIST)\n    {\n        vec3 pos = rayOrig + dist.x * rayDir;   \n  \n        if(dist.y < 1.5)\n        {\n            col = SAND_COLOR * getLighting(pos, viewDir, 0.2, 1.0);// * (texture(iChannel0, vec2(pos.x * 4.0, pos.z * 4.0)).x - 0.07) * 2.0;\n        }\n        else if(dist.y < 2.5)\n        {\n            col = STRUCTURE_COLOR * getLighting(pos, viewDir, 1.0, 0.1) * texture(iChannel1, vec2(pos.y, pos.z)).xyz;\n        }\n        else\n        {\n            col = STRUCTURE_COLOR * getLighting(pos, viewDir, 1.0, 0.1) * texture(iChannel1, vec2(pos.x * 8.0, pos.z * 16.0)).xyz;\n        }\n\n        col = pow(col, vec3(1.0 / GAMMA));\n        //col = getNormal(pos);\n    }\n    \n    col *= smoothstep(0.0, 1.0, 1.0 - length(uv.x * uv.y) + sin(iTime));\n    //col = texture(iChannel2, rayDir).xyz;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 888, 911, 911, 950], [952, 952, 975, 975, 1014], [1016, 1016, 1040, 1040, 1090], [1094, 1094, 1119, 1119, 1207], [1213, 1213, 1247, 1247, 1391], [1393, 1393, 1427, 1427, 1571], [1573, 1573, 1612, 1612, 1717], [1719, 1719, 1754, 1754, 1815], [1817, 1817, 1858, 1858, 1916], [1918, 1918, 1953, 1953, 2024], [2026, 2026, 2086, 2086, 2184], [2186, 2186, 2246, 2246, 2396], [2398, 2398, 2452, 2452, 3104], [3106, 3106, 3135, 3135, 4459], [4461, 4461, 4484, 4484, 4777], [4779, 4779, 4804, 4804, 5473], [5475, 5475, 5517, 5517, 5922], [5924, 5924, 5950, 5950, 6247], [6249, 6249, 6329, 6329, 7395], [7397, 7397, 7456, 7456, 7757], [7759, 7759, 7816, 7816, 9096]], "test": "untested"}
{"id": "tldXWS", "name": "hsbrotate", "author": "NY", "description": "a", "tags": ["2d"], "likes": 1, "viewed": 67, "published": "Public", "date": "1581640213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0. , 4., 2.), 6.) - 3.) - 1., 0., 1. );\n    rgb = rgb * rgb * (3. - 2. * rgb);\n    return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n\nmat2 zrotate(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // 0.0を原点に -0.5〜0.5にする\n    vec2 toCenter = vec2(0.5) - uv;\n    // 回転\n    toCenter *= zrotate(iTime);\n    \n    // 原点からの距離 \n    float radius = length(toCenter);\n    // 0〜1.0にする\n    radius *= 2.;\n    \n     // 原点のX軸とUVのラジアンを算出\n    float angle = atan(toCenter.y,toCenter.x);\n    // ラジアン(-π〜π)をπ * 2で割ることで-0.5〜0.5にする\n    angle /= TWO_PI;\n    // 0.0〜1.0に\n    angle += 0.5;\n    \n    // 極座標系作成\n    vec3 hsb = vec3(angle, radius, 1.);   \n    // hsbからrgbに変換\n    vec3 color = hsb2rgb(hsb);\n\n    // Output to screen\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 220], [223, 223, 246, 246, 312], [315, 315, 372, 422, 1133]], "test": "untested"}
{"id": "tldXzl", "name": "Hue rotate spiral ⚙", "author": "HaleyHalcyon", "description": "spiral", "tags": ["spiral"], "likes": 2, "viewed": 118, "published": "Public", "date": "1581560686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fn(float x, float thres)\n{\n    float n = abs(sin(x * 2. * 3.14159265));\n    return step(thres, (n - 0.5) * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float P = 4.;\n    float time = mod(iTime, P);\n    const float PI = 3.14159265;\n    const float PI_3 = PI / 3.;\n    float hue = time / P * PI;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    //float distance = length(uv);\n    //float distance = pow(sqrt(uv.x*uv.x+uv.y*uv.y), 1./3.);\n    float distance = log(uv.x*uv.x+uv.y*uv.y) / 2.;\n    float angle = atan(uv.y, uv.x) / PI / 2.;\n    \n    // Time varying pixel color\n    float thres1 = 0.4 * sin(time * 2. * PI / P) + 0.5;\n    float thres2 = 0.4 * cos(time * 2. * PI / P) + 0.5;\n    float c1 = fn(distance * 0.2 + 2. * angle + time, thres1);\n    float c2 = fn(distance * 0.9 + angle - time, thres2);\n    \n    // Flashing\n    const float flashIntvl = P / 6.;\n    const float flashPow = 1.1;\n    float f1 = max(0., 1. - mod(time, flashIntvl) * 6.);\n    float f2 = max(0., 1. - mod(time + flashIntvl * 0.5, flashIntvl) * 6.);\n\tc1 += f1 * flashPow; c2 += f2 * flashPow;\n\n    // Output to screen\n    fragColor = vec4(\n        abs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)),\n        abs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)),\n        abs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue)),\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 119], [121, 121, 178, 178, 1537]], "test": "untested"}
{"id": "tldXzN", "name": "Stars TAlex", "author": "talex", "description": "Free Code Camp", "tags": ["freecodecamp"], "likes": 2, "viewed": 66, "published": "Public", "date": "1582884705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rotate(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare){\n\tfloat d = length(uv);\n    float m = .05/d;\n         \n    float rays = max(0., 1.-abs(uv.x * uv.y * 1000.));\n   \tm += rays * flare;\n    uv *= Rotate(3.1415/4.);\n    rays = max(0., 1.-abs(uv.x * uv.y * 1000.));\n   \tm += rays*.3 * flare;\n    \n    return m;\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tuv *= 3.;\n    \n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    for(int y=-1;y<=1;y++){\n    \tfor(int x=-1;x<=1;x++){\n            vec2 offs = vec2(x,y);\n        \tfloat n = Hash21(id+offs);\n    \t\tcol += Star(gv-offs-vec2(n,fract(n*34.))+.5, abs(sin(iTime)));    \n        }\n    }\n    \n\t\n    //if (gv.x>.48 || gv.y>.48) col.r=1.0;\n   \n    \n    fragColor = vec4(col,1.0);\n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 81], [83, 83, 116, 116, 373], [375, 375, 397, 397, 488], [490, 490, 547, 547, 1032]], "test": "untested"}
{"id": "tlGXRz", "name": "Dth Str", "author": "amausagi", "description": "from angle of victims", "tags": ["cineshader"], "likes": 5, "viewed": 16064, "published": "Public API", "date": "1582048197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \t\t\n    float t =  -iTime * 3. + 5000. +  sin(iTime / 3.) * 5.;\n    \n    float dist = distance(uv, vec2(0., 0.)) * .6;\n    float maxDist = .5;\n    vec4 color;\n               \n    float expDist = dist * dist * dist;\n    float strength = (sin(expDist * 100.)+1.)/2.;\n    float height = (sin(t * strength)+1.)/2.;\n    float alpha = 1. - expDist / (maxDist * maxDist * maxDist) + (1. - height) * -0.014  ;\n    color = vec4(.9,.9,.9, 9.) * height - (1. - alpha) * 0.652;\n    color.a = alpha;\n    if(dist > maxDist) color = vec4(.1,.1,.1, 0.);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 709]], "test": "untested"}
{"id": "tlGXzz", "name": "EditDSF BlobForest", "author": "clark_eagling", "description": "change ray direction number to negative to look up / rotate t'other way", "tags": ["editsdf"], "likes": 5, "viewed": 131, "published": "Public", "date": "1582055031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_118 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_119 = vec4(sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec3(0.2,0.4,0.8)) * 1.0, vec3(0.5,0.5,1.0));\nvec4 tmpComb_337 = opUnionRound(tmpPrim_118, tmpPrim_119, 1.0);\nvec4 tmpPrim_120 = vec4(sdEllipsoid(pMod((mat4(0.5548762679100037,0.5650126934051514,-0.5693203210830688,0.0,-0.6958704590797424,0.6833863854408264,4.5188969011178415e-8,0.0,0.39891016483306885,0.4061973989009857,0.7919134497642517,0.0,-0.4681593179702759,-0.47671157121658325,0.4803459942340851,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,4.72,4.98)), vec3(0.2,0.4,0.8)) * 1.0253025730826635, vec3(1.0,0.5,0.7999999999999998));\nvec4 tmpComb_338 = tmpComb_337;\nvec4 tmpComb_339 = opUnionRound(tmpComb_338, tmpPrim_120, 1.0);\nvec4 tmpPrim_121 = vec4(sdSphere(pMod((mat4(0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.8155362010002136,-0.3699759840965271,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.98,4.98,5.23)), 0.4) * 1.2088253498077393, vec3(0.5,1.0,0.5499999999999998));\nvec4 tmpComb_340 = tmpComb_339;\nvec4 tmpComb_341 = opUnionRound(tmpComb_340, tmpPrim_121, 1.0);\nvec4 tmpPrim_122 = vec4(sdEllipsoid(pMod((mat4(1.0305591821670532,-0.6961436867713928,0.5479406118392944,0.0,0.7607165575027466,1.1261518001556396,-1.2500748880484025e-8,0.0,-0.45405444502830505,0.30671417713165283,1.243651270866394,0.0,-1.5283113718032837,-1.0519088506698608,-0.298557311296463,1.0) * vec4(point, 1.0)).xyz, vec3(5.1000000000000005,5.1000000000000005,5.3)), vec3(0.2,0.4,0.33)) * 0.7358299267032258, vec3(0.5,0.97,1.0));\nvec4 tmpComb_342 = tmpComb_341;\nvec4 tmpComb_343 = opUnionRound(tmpComb_342, tmpPrim_122, 0.97);\nvec4 tmpPrim_123 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.5729847550392151,-1.037184238433838,-1.7758475542068481,1.0) * vec4(point, 1.0)).xyz, vec3(4.72,4.72,4.8500000000000005)), 0.26) * 1.0, vec3(0.96,0.5,1.0));\nvec4 tmpComb_344 = tmpComb_343;\nvec4 tmpComb_345 = opUnionRound(tmpComb_344, tmpPrim_123, 1.17);\nvec4 tmpPrim_124 = vec4(sdEllipsoid(pMod((mat4(0.6799264550209045,-0.62980717420578,-0.47884735465049744,0.0,0.37898901104927063,0.813499391078949,-0.5318251252174377,0.0,0.6944921016693115,0.17266610264778137,0.759024977684021,0.0,2.51404070854187,-1.3622883558273315,0.8606699705123901,1.0) * vec4(point, 1.0)).xyz, vec3(5.62,5.68,5.62)), vec3(0.3,0.19,0.18)) * 0.9585952476652823, vec3(0.00341093750000002,0.0840605312499999,0.37));\nvec4 tmpComb_346 = tmpComb_345;\nvec4 tmpComb_347 = opUnionRound(tmpComb_346, tmpPrim_124, 2.08);\nvec4 tmpPrim_125 = vec4(sdTorus(pMod((mat4(-0.20544157922267914,-0.9786693453788757,0.0,0.0,0.9786693453788757,-0.20544157922267914,0.0,0.0,0.0,0.0,1.0,0.0,-0.972653865814209,3.1288809776306152,-3.057844400405884,1.0) * vec4(point, 1.0)).xyz, vec3(5.36,5.42,5.68)), vec2(0.4,0.05)) * 1.000000026423471, vec3(0.31778906250000005,0.91,0.51914078125));\nvec4 tmpComb_348 = tmpComb_347;\nvec4 tmpComb_349 = opUnionRound(tmpComb_348, tmpPrim_125, 2.08);\nreturn tmpComb_349;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_350 = opUnionRound(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec3(0.2,0.4,0.8)) * 1.0, 1.0);\nfloat tmpComb_351 = tmpComb_350;\nfloat tmpComb_352 = opUnionRound(tmpComb_351, sdEllipsoid(pMod((mat4(0.5548762679100037,0.5650126934051514,-0.5693203210830688,0.0,-0.6958704590797424,0.6833863854408264,4.5188969011178415e-8,0.0,0.39891016483306885,0.4061973989009857,0.7919134497642517,0.0,-0.4681593179702759,-0.47671157121658325,0.4803459942340851,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,4.72,4.98)), vec3(0.2,0.4,0.8)) * 1.0253025730826635, 1.0);\nfloat tmpComb_353 = tmpComb_352;\nfloat tmpComb_354 = opUnionRound(tmpComb_353, sdSphere(pMod((mat4(0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.8155362010002136,-0.3699759840965271,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.98,4.98,5.23)), 0.4) * 1.2088253498077393, 1.0);\nfloat tmpComb_355 = tmpComb_354;\nfloat tmpComb_356 = opUnionRound(tmpComb_355, sdEllipsoid(pMod((mat4(1.0305591821670532,-0.6961436867713928,0.5479406118392944,0.0,0.7607165575027466,1.1261518001556396,-1.2500748880484025e-8,0.0,-0.45405444502830505,0.30671417713165283,1.243651270866394,0.0,-1.5283113718032837,-1.0519088506698608,-0.298557311296463,1.0) * vec4(point, 1.0)).xyz, vec3(5.1000000000000005,5.1000000000000005,5.3)), vec3(0.2,0.4,0.33)) * 0.7358299267032258, 0.97);\nfloat tmpComb_357 = tmpComb_356;\nfloat tmpComb_358 = opUnionRound(tmpComb_357, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.5729847550392151,-1.037184238433838,-1.7758475542068481,1.0) * vec4(point, 1.0)).xyz, vec3(4.72,4.72,4.8500000000000005)), 0.26) * 1.0, 1.17);\nfloat tmpComb_359 = tmpComb_358;\nfloat tmpComb_360 = opUnionRound(tmpComb_359, sdEllipsoid(pMod((mat4(0.6799264550209045,-0.62980717420578,-0.47884735465049744,0.0,0.37898901104927063,0.813499391078949,-0.5318251252174377,0.0,0.6944921016693115,0.17266610264778137,0.759024977684021,0.0,2.51404070854187,-1.3622883558273315,0.8606699705123901,1.0) * vec4(point, 1.0)).xyz, vec3(5.62,5.68,5.62)), vec3(0.3,0.19,0.18)) * 0.9585952476652823, 2.08);\nfloat tmpComb_361 = tmpComb_360;\nfloat tmpComb_362 = opUnionRound(tmpComb_361, sdTorus(pMod((mat4(-0.20544157922267914,-0.9786693453788757,0.0,0.0,0.9786693453788757,-0.20544157922267914,0.0,0.0,0.0,0.0,1.0,0.0,-0.972653865814209,3.1288809776306152,-3.057844400405884,1.0) * vec4(point, 1.0)).xyz, vec3(5.36,5.42,5.68)), vec2(0.4,0.05)) * 1.000000026423471, 2.08);\nreturn tmpComb_362;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 32; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 6.0 + iTime;\n\tfloat supersin = sin(2.3) + cos(0.7);\n    \n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.2 + 4.5 * cos(0.1 * time + supersin * mo.x), 1.0 + 2.0 * mo.y, 0.3 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.3, -0.8, 0.8);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, tan(-0.3));\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, -1.1));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 411, 484, 484, 614], [616, 616, 666, 666, 783], [785, 785, 835, 835, 952], [954, 954, 982, 982, 1026], [1028, 1071, 1105, 1105, 1150], [1152, 1152, 1203, 1203, 1229], [1231, 1231, 1278, 1278, 1379], [1381, 1381, 1430, 1430, 1486], [1488, 1488, 1540, 1540, 1647], [1649, 1649, 1703, 1703, 1763], [1814, 1823, 1874, 1874, 1896], [1897, 1897, 1945, 1945, 1977], [1979, 1988, 2039, 2039, 2061], [2062, 2062, 2110, 2110, 2142], [2144, 2151, 2200, 2200, 2223], [2224, 2224, 2270, 2383, 2423], [2511, 2551, 2625, 2625, 2704], [2705, 2705, 2776, 2776, 2838], [2840, 2855, 2929, 2929, 3019], [3020, 3020, 3091, 3091, 3153], [3155, 3168, 3240, 3240, 3275], [3276, 3276, 3345, 3345, 3397], [3472, 3489, 3565, 3565, 3615], [3616, 3616, 3689, 3689, 3753], [3755, 3772, 3848, 3848, 3898], [3899, 3899, 3972, 3972, 4036], [4038, 4053, 4127, 4127, 4164], [4165, 4165, 4236, 4236, 4290], [4362, 4379, 4456, 4456, 5175], [5176, 5176, 5249, 5249, 5314], [5316, 5331, 5401, 5401, 6091], [6092, 6092, 6163, 6163, 6215], [6217, 6234, 6310, 6310, 6346], [6347, 6347, 6420, 6420, 6484], [6486, 6568, 6643, 6643, 6769], [6770, 6770, 6842, 6842, 6906], [6908, 6924, 6999, 6999, 7038], [7039, 7039, 7111, 7111, 7178], [7180, 7194, 7267, 7267, 7305], [7306, 7306, 7376, 7376, 7431], [7433, 7476, 7524, 7524, 7786], [7788, 7825, 7869, 7869, 11207], [11209, 11209, 11249, 11249, 13997], [14003, 14003, 14053, 14053, 14351], [14353, 14353, 14407, 14407, 14701], [14703, 14703, 14739, 14739, 15011], [15013, 15013, 15065, 15065, 15330], [15332, 15332, 15381, 15381, 16518]], "test": "untested"}
{"id": "tlKSDR", "name": "basic-paredes--", "author": "jorge2017a1", "description": "basic-paredes--", "tags": ["basicparedes"], "likes": 0, "viewed": 42, "published": "Public", "date": "1582552078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         {  res=vec2(res.x, 9);  } \n     }\n\t\n    float  sd1= sdBox(  p-vec3(0,1.0,0.0), vec3(2.0,14.,100.0) );\n    float  sd2= sdBox(  p-vec3(10.,1.0,0.0), vec3(2.0,14.,100.0) );\n    \n    //segundo nivel de paredes\n    float  sd3= sdBox(  p-vec3(0.0,1.0,250.0), vec3(2.0+2.0*cos(iTime),14.,150.0) );\n    float  sd4= sdBox(  p-vec3(10.,1.0,250.0), vec3(2.0+2.0*cos(iTime),14.,150.0) );\n       \n    \n    res= opU(res, vec2(sd1,13));\n    res= opU(res, vec2(sd2,13));\n    res= opU(res, vec2(sd3,14));\n    res= opU(res, vec2(sd4,14));\n    \n    res= opU(res, vec2(1.0,8));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        \n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        \n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        \n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 1.*iMouse.x/iResolution.x;\n  \n    float zoom = 2.15;\n    \n    \n    \n      \n    vec3 ro = vec3(5, 6.+3.0*sin(iTime), 0.+iTime);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 1));\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n   \n    float dif = GetLight(p);\n    mObj.dist =d;\n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n    col =  ( vec3(dif)+colobj*1.25)/1.5;\n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [784, 838, 860, 860, 2120], [2123, 2178, 2224, 2224, 2256], [2258, 2258, 2301, 2301, 2333], [2335, 2335, 2383, 2383, 2416], [2419, 2419, 2448, 2448, 2574], [2576, 2576, 2612, 2612, 2729], [2731, 2731, 2767, 2767, 2885], [2888, 2888, 2924, 2924, 3047], [3100, 3112, 3134, 3134, 3442], [3443, 3469, 3494, 3494, 3684], [3685, 3730, 3747, 3747, 3820], [3823, 3856, 3882, 3882, 4079], [4080, 4126, 4178, 4178, 4333], [4398, 4507, 4544, 4544, 4579], [4589, 4589, 4614, 4614, 5659], [5662, 5662, 5696, 5696, 6085], [6090, 6090, 6114, 6114, 6346], [6350, 6350, 6374, 6374, 6759], [6763, 6763, 6788, 6788, 6816], [6916, 6960, 6977, 6977, 7048], [7073, 7165, 7190, 7190, 7453], [7455, 7514, 7542, 7542, 9131], [9135, 9135, 9192, 9192, 9912]], "test": "untested"}
{"id": "tlKSDz", "name": "Chaosflux Background", "author": "NinjaKoala", "description": "Background video for Chaosflux Infobeamer  (www.chaosflux.de/en/) (info-beamer.com/)\nIn the rendered version gaussian blur is added with an ffmpeg filter\nLoops in 60 seconds", "tags": ["2d", "bezier", "svg", "chaosflux"], "likes": 1, "viewed": 152, "published": "Public API", "date": "1582556959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The logo is generated with a script from svg (see https://www.shadertoy.com/view/Wtt3Wl)\n\n#define ZERO min(0,iFrame)\n\nfloat border;\n\n//hash functions from https://www.shadertoy.com/view/4djSRW\n\nvec2 hash21(float p)\n{\n\tvec2 p2  = fract(p * vec2(5.3983, 5.4427));\n\tp2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tfor(int i=ZERO;i<3;i++){\n\t\tt=params[i];\n\t\tfor(int j=ZERO;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n\telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[26] p=vec2[](vec2(-0.10513741178015773,0.18225451483640648),\n\t                  vec2(-0.11508189293211292,0.16479023569220425),\n\t                  vec2(-0.11508189293211292,0.16479023569220425),\n\t                  vec2(-0.05226020912336337,0.1277696341578051),\n\t                  vec2(-0.03668564162604742,0.07191650538101095),\n\t                  vec2(-0.020574983549088138,0.014140812609831214),\n\t                  vec2(-0.03874981615009546,-0.05058622819157852),\n\t                  vec2(-0.005903441805151979,-0.12697315364094866),\n\t                  vec2(0.011146458769719193,-0.16662410194662905),\n\t                  vec2(0.04289724510756864,-0.18487622572225562),\n\t                  vec2(0.06947080013727487,-0.19243802290398837),\n\t                  vec2(0.09604435516698105,-0.2000000000000005),\n\t                  vec2(0.1185958365136935,-0.19763880499136252),\n\t                  vec2(0.1185958365136935,-0.19763880499136252),\n\t                  vec2(0.11652259430994151,-0.17764439132975135),\n\t                  vec2(0.11652259430994151,-0.17764439132975135),\n\t                  vec2(0.09767716721368143,-0.1795680348098153),\n\t                  vec2(0.07498770960575862,-0.17311127113486824),\n\t                  vec2(0.05229823400640781,-0.16665468737420056),\n\t                  vec2(0.026955562522236406,-0.15254508989192175),\n\t                  vec2(0.012544806526930286,-0.11903173732874979),\n\t                  vec2(-0.017530186242764697,-0.04908970121185751),\n\t                  vec2(0.0007400549008424999,0.01254785157611735),\n\t                  vec2(-0.017323788580930685,0.07732796709008026),\n\t                  vec2(-0.03592372264234721,0.14403064659842876),\n\t                  vec2(-0.10513741178015773,0.18225451483640648));\n\n\tivec2[2] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(13,14));\n\n\tivec4[8] c_bez=ivec4[](ivec4(1,2,3,4),\n\t                       ivec4(4,5,6,7),\n\t                       ivec4(7,8,9,10),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(14,15,16,17),\n\t                       ivec4(17,18,19,20),\n\t                       ivec4(20,21,22,23),\n\t                       ivec4(23,24,25,0));\n\n\tif(all(lessThan(uv,vec2(0.1185958365136935,0.18225451483640648)+border/2.)) && all(greaterThan(uv,vec2(-0.11508189293211292,-0.2000000000000005)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path1_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[20] p=vec2[](vec2(0.1157846758911721,0.10522871377931982),\n\t                  vec2(0.1157846758911721,0.10522871377931982),\n\t                  vec2(0.07492137521078111,0.09615221827560297),\n\t                  vec2(0.0326445959822444,0.07536006469717456),\n\t                  vec2(-0.009632165254864348,0.05456791111874716),\n\t                  vec2(-0.055505466920286024,0.021423562743529884),\n\t                  vec2(-0.06061566216776037,-0.029355623513178133),\n\t                  vec2(-0.0700863318671821,-0.12346428544120289),\n\t                  vec2(-0.019045622213296524,-0.18474254941233453),\n\t                  vec2(-0.019045622213296524,-0.18474254941233453),\n\t                  vec2(-0.0036545133071348183,-0.1718462938333055),\n\t                  vec2(-0.0036545133071348183,-0.1718462938333055),\n\t                  vec2(-0.04929437619446233,-0.11754204709166494),\n\t                  vec2(-0.040621266497577364,-0.0313586091906533),\n\t                  vec2(-0.03665957204689839,0.008008254467156873),\n\t                  vec2(0.0017859865667003067,0.037784607523743366),\n\t                  vec2(0.041534898197753835,0.05733355342846704),\n\t                  vec2(0.08128379183737937,0.07688249933319072),\n\t                  vec2(0.12017710311921934,0.0856207559908058),\n\t                  vec2(0.12017712111064728,0.0856207559908058));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(19,0));\n\n\tivec4[6] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(3,4,5,6),\n\t                       ivec4(6,7,8,9),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19));\n\n\tif(all(lessThan(uv,vec2(0.12017712111064728,0.10522871377931982)+border/2.)) && all(greaterThan(uv,vec2(-0.0700863318671821,-0.18474254941233453)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path2_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[32] p=vec2[](vec2(0.10956498526277197,0.19999999999999948),\n\t                  vec2(0.10956498526277197,0.19999999999999948),\n\t                  vec2(0.037350325937207385,0.17016751368810307),\n\t                  vec2(0.017323779585216685,0.09714660450028534),\n\t                  vec2(0.007738234618116232,0.06219573684118168),\n\t                  vec2(0.007829828977983476,0.038356375105080734),\n\t                  vec2(0.007906382504055958,0.01646638459106055),\n\t                  vec2(0.007983745644387759,-0.005423785837239025),\n\t                  vec2(0.008066506213114787,-0.02529927615987463),\n\t                  vec2(-0.0010893314880125555,-0.05669413807791444),\n\t                  vec2(-0.009436958261236469,-0.08531688077215802),\n\t                  vec2(-0.03893978763817994,-0.11694311245407363),\n\t                  vec2(-0.0668002155373075,-0.14029112829192678),\n\t                  vec2(-0.0946606254450071,-0.16363896421550156),\n\t                  vec2(-0.12017712111064728,-0.17901479839930393),\n\t                  vec2(-0.12017712111064728,-0.17901479839930393),\n\t                  vec2(-0.10981096586531387,-0.19623313472296214),\n\t                  vec2(-0.10981096586531387,-0.19623313472296214),\n\t                  vec2(-0.08302986891895385,-0.18012001182036896),\n\t                  vec2(-0.05386887667370899,-0.1556820752752355),\n\t                  vec2(-0.02470786643703615,-0.13124431864438244),\n\t                  vec2(0.0075665963951476066,-0.09878454410396154),\n\t                  vec2(0.018202265030826132,-0.06231645932295521),\n\t                  vec2(0.028029452867181538,-0.028620673680024494),\n\t                  vec2(0.02804769617515748,-0.005384744438511793),\n\t                  vec2(0.02797105269194502,0.016536551160200502),\n\t                  vec2(0.027893689551613216,0.0384578467589128),\n\t                  vec2(0.027741482070867428,0.059099771913672515),\n\t                  vec2(0.03672078788061441,0.09184057255920483),\n\t                  vec2(0.053824069022314486,0.15420264015210025),\n\t                  vec2(0.11736594249669793,0.18144633989136022),\n\t                  vec2(0.11736596048812586,0.18144633989136022));\n\n\tivec2[2] seg=ivec2[](ivec2(15,16),\n\t                     ivec2(31,0));\n\n\tivec4[10] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31));\n\n\tif(all(lessThan(uv,vec2(0.11736596048812586,0.19999999999999948)+border/2.)) && all(greaterThan(uv,vec2(-0.12017712111064728,-0.19623313472296214)-border/2.))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<10;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat logo_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.12017712111064728,0.2)+border/2.)) && all(greaterThan(uv,vec2(-0.12017712111064728,-0.2)-border/2.))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path1_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path2_dis_sq(uv));\n\t}\n\n\treturn dis_sq;\n}\n\nfloat logo_dis(vec2 uv){\n\tfloat dis_sq=logo_dis_sq(uv);\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\treturn dis;\n}\n\nmat2 rot(float t){\n\treturn mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\n\tborder=2./iResolution.y;\n\n\tconst vec3 bg_col=vec3(0);\n\n\tvec3 color=bg_col;\n\n\tconst float pi=3.14159265358979;\n\n\tconst vec3 logo_color_dark=vec3(.185);\n\tconst vec3 logo_color_light=vec3(1);\n\n\tfloat dis_sq=1e38;\n\n\tconst vec2 grid_size=vec2(.2,.2);\n\n\tconst float loop_time=60.;\n\n\tfloat t0 = iTime;\n\tfloat t1 = mod(t0/loop_time*2.*pi,2.*pi);\n\tfloat t2 = .4*cos(t1);\n\n\tfloat zoom1=4.*exp(-1.3+.3*sin(t1));\n\tfloat z_val=(1.-(1.+.2*cos(t1))*uv.y+.2*sin(t1)*uv.x);\n\tzoom1/=z_val;\n\n\tconst float zoom2=4.;\n\n\tuv*=rot(t2);\n\n\tuv*=zoom1;\n\tborder*=zoom1;\n\n\tfloat veil=.875+.125*sin(mod(32.*uv.y+8.*uv.x,2.*pi));\n\tveil*=.875+.125*cos(mod(2.*uv.x+1.*uv.y,2.*pi));\n\n\tvec2 cell_index=floor(uv/grid_size+.5);\n\tvec2 cur_midpoint=cell_index*grid_size;\n\tuv-=cur_midpoint;\n\n\tif( mod(cell_index.x+cell_index.y,2.) == 0.){\n\t\tuv*=rot(pi/2.);\n\t}\n\n\tconst float light_speed=.1;\n\tconst int num_lights=7;\n\n\tvec3 logo_color=logo_color_dark;\n\tfor(int i=0;i<num_lights;i++){\n\t\tif(floor(.5+(hash21(1.4+floor(mod(t0*light_speed+float(i)/float(num_lights),loop_time*light_speed))+hash11(float(i)))*vec2(20.,11.)-vec2(11.,2.))) == cell_index){\n\t\t\t//fade in and out\n\t\t\t//float fade_param=smoothstep(0.,1.,1.-2.*abs(fract(t0*light_speed)-.5));\n\t\t\t//only fade in\n\t\t\tfloat fade_param=smoothstep(0.,.25,fract(t0*light_speed+float(i)/float(num_lights)));\n\t\t\tlogo_color=mix(logo_color_dark,logo_color_light,fade_param);\n\t\t}\n\t}\n\n\tuv*=zoom2;\n\tborder*=zoom2;\n\n\tfloat dis=logo_dis(uv);\n\n\tcolor=mix(logo_color,color,smoothstep(-border/2.,border/2., dis));\n\tcolor*=veil;\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 196, 218, 218, 383], [385, 385, 408, 408, 493], [495, 616, 665, 700, 880], [882, 967, 1010, 1010, 2019], [2021, 2021, 2102, 2121, 2296], [2298, 2298, 2376, 2376, 2806], [2808, 2831, 2856, 2856, 2875], [2877, 2877, 2924, 2924, 3035], [3037, 3037, 3085, 3085, 3355], [3357, 3357, 3428, 3428, 4292], [4294, 4294, 4322, 4322, 7164], [7166, 7166, 7194, 7194, 9546], [9548, 9548, 9576, 9576, 12931], [12933, 12933, 12960, 12960, 13250], [13252, 13252, 13276, 13276, 13366], [13368, 13368, 13386, 13386, 13432], [13434, 13434, 13490, 13490, 15125]], "test": "untested"}
{"id": "tlKSWw", "name": "StrangeFoam", "author": "olli666", "description": "Foam of colourful bubbles.", "tags": ["foam"], "likes": 1, "viewed": 73, "published": "Public", "date": "1582891390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// strange foam of coloured bubbles. wonderfully wasteful calculation.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float timeScale = iTime * 0.1;\n    \n    fragColor = vec4(0.2,0.4,0.8,0.0);\n    // draw N bubbles. use fragColor.a channel to plot only the highest bubble.\n    for (float i = 0.0 ; i < 50.0; i ++) {\n        // bubble's coordinate\n        vec2 ax = vec2(0.9+0.7*cos(timeScale+i*23.0), 0.7+0.6*sin(timeScale+i*17.0));       \n        \n        // current pixel \"height\" vs. the given bubble\n\t    vec2 uv = fragCoord/iResolution.y - ax;\n        float sizeScale = 5.0 + 5.0*(1.0+cos(5.0*(timeScale + i)));\n        float height = 1.0 - sizeScale*(uv.x*uv.x + uv.y*uv.y);\n        \n        if (height > fragColor.a) {\n            // highest bubble so far, colorize & apply\n\t\t\tfragColor = height*vec4(                \n                0.6+0.4*cos(i+timeScale), \n                0.6+0.4*sin(i+timeScale), \n                0.8+0.4*(sin(3.0*i)+cos(2.0*i)),\n                1.0\n            );\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 128, 128, 1053]], "test": "untested"}
{"id": "tlKXRW", "name": "fast compofiller", "author": "eimink", "description": "super fast compofiller for fast effect compo at assembly winter 2020. 3rd place.", "tags": ["voronoi", "fast", "scanlines"], "likes": 1, "viewed": 113, "published": "Public", "date": "1582362851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand () {\n    return fract(sin(iTime)*1e7);\n}\n\nvec2 hash( vec2 p )\n{\n\t// Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n\treturn o;\n}\n\nfloat hash12(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 voro(in vec2 x)\n{\n\t// Tomasz Dobrowolski's fast voronoi with 3x3 scan as in https://www.shadertoy.com/view/llG3zy\n\tvec2 n = floor(x);\n\tvec2 f = fract(x);\n\tvec2 mr;\n\tfloat md = 8.0;\n\tfor( int j=-1; j <= 1; j++)\n\tfor( int i=-1; i <= 1; i++)\n\t{\n\t\tvec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n        o = 0.5 + 0.5*sin( iTime + 2.2831*o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n\t}\n\tmd = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 p = (fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec2 st = vec2(atan(p.x,p.y),length(p));\n\tp = vec2(st.x/0.2831+.5+(2.1*iTime),st.y);\n\tvec3 c = voro(6.*p*atan(iTime*0.01));\n\tvec3 col = c.x*3.*(sin(c.x)+.9)*vec3(p.y,c.x,sin(p.x));\n    vec4 fc = vec4(col,1.0);\n    float scanline = sin( uv.y * 1200.0 * rand())/30.0;\n    float v = iTime*0.152;\n    vec2 n = (fragCoord.xy * v + iTime * 1500. + 50.0);\n\tfc *= 1. - scanline - 0.1*hash12(n);\n    float vegDist = length(( 0.5 , 0.5 ) - uv);\n    fc *= 0.9 - vegDist * 0.6;\n    if (iTime > 60.) // Time limit for Fast Effect compo\n    {\n        fragColor = vec4(0.,0.,0.,0.);\n    }\n    else fragColor = fc;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 15, 15, 51], [53, 53, 74, 141, 310], [312, 312, 333, 333, 399], [401, 401, 423, 519, 1249], [1251, 1251, 1308, 1308, 2013]], "test": "untested"}
{"id": "tlKXzm", "name": "my first raymarched scene", "author": "maksy", "description": "My first raymarched scene", "tags": ["raymarching"], "likes": 2, "viewed": 270, "published": "Public API", "date": "1582485268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Obj {\n\tint type;\n    float d;\n};\n\nstruct Ray {\n\tObj hitObj;\n    vec3 hitPos;\n    // travelled distance along the ray\n    float t;\n};\n    \nfloat sdSphere(vec3 p, float r) {\n\treturn length(p)-r;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 1.95;\n}\n\nObj SDF(vec3 pos) {\n\n    float d0 = sdPlane(pos);\n    float d1 = sdSphere(pos-vec3(1, .2, 1), 2.2);\n\n    Obj obj = Obj(1, d1);\n\n    if (d0 < d1) {\n      obj = Obj(0, d0);\n    }\n\n    return obj;\n  }\n\n// Raymarching loop\nRay castRay(vec3 rayOrigin, vec3 rayDir) {\n\n    float tmax = 180.0;\n    float t = 0.0;\n\n    Obj hitObj = Obj(-1, t);\n    vec3 hitPos = vec3(0);\n\n    for (int i = 0; i < 500; i++) {\n\n      vec3 p = rayOrigin + t*rayDir;\n      Obj res = SDF(p);\n\n      if (res.d < 0.01) {\n        hitObj = res;\n        hitPos = p;\n        break;\n      } else if (res.d > tmax) {\n        break;\n      }\n      t += res.d;\n    }\n\n\treturn Ray(hitObj, hitPos, t);\n}\n\nvec3 calcNormal(vec3 pos) {\n\n\t// Center sample\n    float c = SDF(pos).d;\n\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3(SDF(pos + eps_zero.xyy).d, SDF(pos + eps_zero.yxy).d,\n                          SDF(pos + eps_zero.yyx).d) - c);\n}\n\n// Calculates Lambertian reflection\nvec3 calculateLightning(vec3 pos, vec3 lightDir, vec3 surfaceColor) {\n\n\t// L is vector from surface point to light, N is surface normal. N and L must be normalized!\n    vec3 L = normalize(lightDir);\n\n    vec3 N = calcNormal(pos);\n\n    float NoL = max(dot(N, L), 0.0);\n    vec3 directional = vec3(1.80,1.27,0.99) * NoL;\n\n    vec3 diffuse = surfaceColor * directional;\n\n    return diffuse;\n}\n\n// Analytically box-filtered checkerboard by iq\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n\n    // xor pattern\n\treturn 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 texCoords(in vec3 pos) {\n\n    const vec4 sc0 = vec4(1.0, 1.3, 1.0, 0.5);\n    vec3 q = normalize(pos - sc0.xyz);\n    vec2 matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n\n    return 12.0*matuv;\n}\n\nvec3 floorColor(in vec3 p) {\n   \n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n    return f * vec3(.8)+0.03;\n}\n\nvec3 fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering) {\n\t\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0.001, 0.001, 0.001), vec3(0.6, 0.6, 0.6), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\n// Value noise from the Art of Code\nfloat generateNoise(vec2 p) {\n\treturn fract(sin(p.x*100.+p.y*6574.)*5647. );\n}\n\nfloat smoothNoise(vec2 uv) {\n \n    vec2 lv = fract(uv*1.0);\n    vec2 id = floor(uv*1.0);\n\n    lv = lv*lv*(3.-2.*lv);\n\n    float bl = generateNoise(id);\n    float br = generateNoise(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = generateNoise(id + vec2(0,1));\n    float tr = generateNoise(id + vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat turbulence(vec2 uv) {\n\n    float c = smoothNoise(uv*4.0);\n    c += smoothNoise(uv*8.0) * 0.5;\n    c += smoothNoise(uv*16.0) * 0.25;\n    c += smoothNoise(uv*32.0) * 0.125;\n    c += smoothNoise(uv*65.0) * 0.0625;\n\n    return c / 5.0;\n}\n\nvec3 render(in vec3 camPos, in vec3 rayDir, out bool rayHitObj, in vec2 uv, in mat3 camMat) {\n\n    vec3 col;\n\n    vec3 lightDir = vec3(0.8, 0.4, -0.5);\n    vec3 sunDir = camMat * lightDir;\n\t    \n    rayHitObj = false;\n \n    Ray ray = castRay(camPos, rayDir);\n \n    // no objects were hit by the ray -> skydome\n    if (ray.hitObj.type == -1) {\n\n        //Sun\n        vec3 sun1 = vec3(1, 0.0, 0.0);\n        vec3 sun2 = vec3(0.268, 0.243, 0.007);\n\n        float sun_weight = smoothstep(0.0, .9, sin(uv.y)*1.1);\n        vec3 sunCol = mix(sun1, sun2, sun_weight);\n\n        // the sun is rendered only if the light is coming from the visible sky\n        if (sunDir.z > 0.0) {\n\n          \tif ((uv.x - sunDir.x*2.2) * (uv.x - sunDir.x*2.2) +\n                (uv.y - sunDir.y+0.2) * (uv.y - sunDir.y+0.2) <= 0.1) {\n\n            \tsunCol *= turbulence(uv)*1.9;\n            \treturn sunCol;\n        \t}\n       \t}\n\n\t\tvec3 sky_col = vec3(rayDir.y*0.5+0.01);\n\t\tcol = vec3(rayDir.y*0.5+0.01);\n       \t// add clouds\n       \tcol *= turbulence(uv);\n       \treturn col;\n    }\n\n    // ray hit the floor plane\n    else if (ray.hitObj.type == 0) {\n    \tcol = floorColor(ray.hitPos);\n\n    \t//vec3 lightDir = vec3(0.8, 0.4, -.5);\n    \tcol = calculateLightning(ray.hitPos, lightDir, col)*0.3;\n\n    \t// Add shadows\n    \tfloat shadow = 0.0;\n    \tvec3 L = normalize(lightDir);\n    \tvec3 N = calcNormal(ray.hitPos);\n    \tvec3 shadowRayOrigin = ray.hitPos + N * 0.01;\n    \tvec3 shadowRayDir = L;\n\n    \tRay shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n    \tif (shadowRayIntersection.hitObj.type == 1) {\n            col *= 0.01;\n        } else {\n        \n      \t// Add fog for floor attenuation\n      \tfloat fogExtintion = 0.035;\n     \tfloat fogInscattering = .1;\n        lightDir *= 0.8;\n      \tcol = fog(col, ray.t, rayDir, lightDir, fogExtintion, fogInscattering);\n        }\n    }\n\n    // sphere\n    else if (ray.hitObj.type == 1) {\n\n      vec2 uvw = texCoords(ray.hitPos) - uv;\n\n      vec2 ddx_uv = dFdx( uvw );\n      vec2 ddy_uv = dFdy( uvw );\n      col = vec3(checkersTextureGradBox(uvw, ddx_uv, ddy_uv));\n\n      // apply anti alias only to the sphere \n      rayHitObj = true;\n\n      // add lightning\n      vec3 surfaceCol = vec3(0.6, 0.0, 0.0);\n      vec3 lightDir = vec3(0.8, 0.4, -1.0);\n      col += calculateLightning(ray.hitPos, lightDir, surfaceCol);\n\n      // add small amount of light to the backside of the sphere\n      col += surfaceCol*0.4;\n    }\n\n     return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec3 camPos = vec3(30.0*sin(iTime*0.5), 2.0, 30.0*cos(iTime*0.5));\n    vec3 camTar = vec3(-0.2, 2.0, -0.2);\n\n    mat3 camMat = lookAt(camPos, camTar, 0.0);\n\n    vec3 col = vec3(0.0);\n    \n    // MSAA anti aliasing\n    bool msaa = true;\n\n    bool rayHitObj = false;\n    if (msaa) {\n    \tconst float AA_size = 2.0;\n    \tfloat count = 0.0;\n      \tfor (float aaY = 0.0; aaY < AA_size; aaY++) {\n        \tfor (float aaX = 0.0; aaX < AA_size; aaX++) {\n\n\t\t\t\tvec2 offset = ((fragCoord.xy + vec2(aaX, aaY) / AA_size) - iResolution.xy*0.5)/iResolution.y;\n          \t\tvec3 rayDir = normalize(camMat * vec3(offset.xy, 2.0));\n\n          \t\tcol += render(camPos, rayDir, rayHitObj, offset, camMat);\n\n          \t\t\n          \t\tcount += 1.0;\n          \t\tif (!rayHitObj) {\n            \t\tbreak;\n          \t\t}\n        \t}\n      \t}\n      col /= count;\n   \n    } else {\n\t\tbool rayHitObj = false;\n    \tvec3 rayDir = normalize(camMat * vec3(uv.xy, 2.0));\n    \tcol = render(camPos, rayDir, rayHitObj, uv, camMat);\n    }\n    \n    // gamma\n\tcol = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 178, 178, 201], [203, 203, 226, 226, 248], [250, 250, 269, 269, 447], [449, 469, 511, 511, 910], [912, 912, 939, 958, 1218], [1220, 1256, 1325, 1420, 1645], [1647, 1695, 1762, 1784, 2001], [2003, 2003, 2032, 2032, 2203], [2205, 2205, 2233, 2233, 2330], [2332, 2332, 2426, 2426, 2665], [2667, 2703, 2732, 2732, 2781], [2783, 2783, 2811, 2811, 3170], [3172, 3172, 3199, 3199, 3411], [3413, 3413, 3506, 3506, 5880], [5882, 5882, 5933, 5933, 6137], [6139, 6139, 6194, 6194, 7334]], "test": "untested"}
{"id": "tltSDB", "name": "Penrose Infinite Zoom", "author": "rory618", "description": "Zooming infinitely using periodicity of the \"Sun\" penrose tiling", "tags": ["2d", "tiling"], "likes": 8, "viewed": 148, "published": "Public", "date": "1581655672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define R iResolution\n#define pi 3.14159\n#define tao 6.28318\n#define phi 1.6180339\n#define rot20(x) cos((x)*tao/20. - vec2(0,pi/2.))\n\nfloat sdLine(vec2 uv, vec2 a, vec2 abn){\n    vec2 x = uv-a;\n    vec2 r = abn.yx*vec2(-1,1);\n    return dot(r, x - abn * dot(x, abn));\n}\n\nfloat penrose(vec2 uv){\n    int type = 0;\n    \n    float angle = atan(uv.y,uv.x);\n    angle = mod(angle + tao/10.,tao/5.) - tao/10.;\n    angle = abs(angle);\n    uv = length(uv) * cos(angle - vec2(0,pi/2.));\n    float r = 0.;\n    if(sdLine(uv, rot20(2.), rot20(6.)) > 0. ){\n    \n        for(int i = 0; i < 16; i++){\n            float d0 = sdLine(uv, vec2(1./phi,0), rot20(8.) );\n            float d1 = sdLine(uv, vec2(1./phi,0), rot20(3.) );\n            float d2 = sdLine(uv, rot20(2.), rot20(9.));\n            float d3 = sdLine(uv, rot20(2.), rot20(4.));\n\n            if(d0 > 0.){\n                type = 1;\n                uv.y = d0 * phi;\n                uv.x = d1 * phi;\n            } else {\n                type = 0;\n                uv.x = d2 * phi;\n                uv.y = abs(d3) * phi;\n            }\n            \n    \t\tr += float(type) / pow(1.2,float(i)) / 6.;\n        }\n    \n    }\n    return r;\n}\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    float s = 2./R.y;\n    vec2 uv0 = (i*2.-R.xy)/R.y / pow(1.6180339, mod(iTime,4.))/2.2;\n    vec2 uv1 = (i*2.-R.xy)/R.y / pow(1.6180339, 4.+ mod(iTime,4.))/2.2;\n    o = vec4(.5+.5*sin(vec4(8,5,12,0)*(iTime/1e2 + mix(penrose(uv1),penrose(uv0),  mod(iTime,4.)/4. ))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 175, 175, 270], [272, 272, 295, 295, 1175], [1177, 1177, 1218, 1218, 1488]], "test": "untested"}
{"id": "tltSR2", "name": "distorted stripes", "author": "C_H", "description": "\"Stolen\" from Étienne Jacob\nCheck out [url]https://necessarydisorder.wordpress.com/2017/09/02/animated-stripes-gifs-from-scalar-fields/[/url]", "tags": ["stripes"], "likes": 3, "viewed": 134, "published": "Public", "date": "1581371335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TWO_PI 6.28318\n\n// Perlin Noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tfor (int i = 0; i<=res; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat n = pNoise(uv, 2);\n    float v = (sin((iTime + uv.x * 20. + uv.y * 20. + n * smoothstep(.5, -.5, length(uv)) * 200.) * TWO_PI) + 1.) / 2.;\n    vec3 col = vec3(smoothstep(-1., 1., (v-.65)/fwidth(v) ));\n    col.b = .65;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 130, 149, 149, 217], [219, 219, 252, 252, 583], [585, 585, 615, 615, 849], [851, 851, 908, 908, 1225]], "test": "untested"}
{"id": "tltSWr", "name": "I heart Fourier", "author": "harry7557558", "description": "As a beginner to Fourier series, inspired by a picture on my religion teacher's slide. ", "tags": ["heart", "fourier", "love"], "likes": 35, "viewed": 293, "published": "Public", "date": "1580886017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 path[18];\nvec2 a[10], b[10];  // 10 = int(18 / 2) + 1\nvoid init() {\n\t// manual point set\n\tpath[0] = vec2(1.0137, 0.3967);\n\tpath[1] = vec2(0.5626, 0.5417);\n\tpath[2] = vec2(0.3414, -0.0639);\n\tpath[3] = vec2(0.1158, 0.6121);\n\tpath[4] = vec2(-0.7459, 0.7070);\n\tpath[5] = vec2(-0.8443, 0.1465);\n\tpath[6] = vec2(-0.3618, 0.1444);\n\tpath[7] = vec2(-0.1585, 0.4285);\n\tpath[8] = vec2(-0.3173, 0.3743);\n\tpath[9] = vec2(-0.4706, -0.2456);\n\tpath[10] = vec2(-0.7936, -0.3968);\n\tpath[11] = vec2(-0.5655, -0.1589);\n\tpath[12] = vec2(0.2119, -0.6991);\n\tpath[13] = vec2(0.2968, -0.9548);\n\tpath[14] = vec2(0.3969, -0.4136);\n\tpath[15] = vec2(0.7119, 0.0779);\n\tpath[16] = vec2(0.6283, 0.2814);\n\tpath[17] = vec2(0.7057, -0.0209);\n\n\t// calculate Fourier coefficients, b[0] is always zero\n\tfloat t, dt;\n\tfor (int k = 0; k < 10; k++) {\n\t\ta[k] = vec2(0.), b[k] = vec2(0.);\n\t\tt = 0.0, dt = 6.283185 * float(k) / 18.;\n\t\tfor (int i = 0; i < 18; i++, t += dt)\n\t\t\ta[k] += path[i] * cos(t), b[k] += path[i] * sin(t);\n\t\ta[k] = a[k] * (2.0 / 18.), b[k] = b[k] * (2.0 / 18.);\n\t}\n\ta[0] = a[0] * 0.5;\n}\n\nvec2 eval(float t) {\n\tvec2 r = a[0];\n    float c0 = cos(t), s0 = sin(t), c = c0, s = s0, c1;\n    for (int k = 1; k < 10; k++) {\n        r += a[k] * c + b[k] * s;\n        c1 = c, c = c * c0 - s * s0, s = c1 * s0 + s * c0;\n    }\n\treturn r;\n}\n\n\n// an improvement of iq's https://www.shadertoy.com/view/Xlf3zl\nfloat sdSqSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn dot(q, q);\n}\nfloat sd(vec2 p) {\n\tfloat o = sin(0.5*iTime); o = .04 + .005*o*o;  // path offset\n\tfloat o2 = (o + .02)*(o + .02);\n\tfloat t_max = 6.3*min(1.5*fract(0.15*iTime), 1.0);\n\tvec2 a = eval(0.0), b, c;\n\tfloat dt = 0.05, t = dt;\n\tfloat d = 1e8, dd;\n\twhile (t < t_max) {\n\t\tb = eval(t);\n\t\tdd = sdSqSegment(p, a, b);\n\t\tif (dd < o2) {  // more accurate and doesn't reduce much speed\n\t\t\tc = eval(t - 0.5*dt);\n\t\t\tdd = min(sdSqSegment(p, a, c), sdSqSegment(p, c, b));\n\t\t}\n\t\td = min(d, dd);\n\t\tdt = clamp(0.026*length(a - p) / length(a - b), 0.02, 0.1);\n\t\tt += dt;\n\t\ta = b;\n\t}\n\td = min(d, sdSqSegment(p, a, eval(t_max))); \t// add this line to eliminate gaps\n\td = min(sqrt(d), abs(length(p) - 0.15));\n\treturn d - o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinit();\n\tvec2 p = 5.0 * (fragCoord - 0.5*iResolution.xy) / length(iResolution.xy);\n\tfloat d = sd(p - vec2(-.1, .08));\n\n    // modified from iq's sdf visualizing function\n\tvec3 col = d > 0. ? vec3(1.0, 0.3, 0.5) : vec3(0.3, 1.5, 2.7);\n\tcol *= 1.0 - 0.9*exp(-6.*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.*d - 3.0*iTime);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 59, 72, 93, 1069], [1071, 1071, 1091, 1091, 1310], [1313, 1377, 1429, 1429, 1544], [1545, 1545, 1563, 1563, 2243], [2245, 2245, 2300, 2300, 2709]], "test": "untested"}
{"id": "tltSWs", "name": "Basic Fractal Zero", "author": "PauloFalcao", "description": "A very very simple fractal, just shift, mirror, rotate and scale space ;)\n\nThis a more elegant way to do my old \"basic fractal\" - https://www.shadertoy.com/view/Mss3Wf ", "tags": ["2d", "fractal"], "likes": 14, "viewed": 624, "published": "Public API", "date": "1581982370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Basic Fractal Zero by @paulofalcao\n\nconst int maxIterations=6;\n\n//generic rotation formula\nmat2 rot(float a){\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n    vec2 R=iResolution.xy,uv=(fragCoord-0.5*R)/R.x;\n    \n\t//global zoom\n\tuv*=sin(iTime)*0.5+1.5;\n    \n\t//shift, mirror, rotate and scale 6 times...\n\tfor(int i=0;i<maxIterations;i++){\n        uv*=2.1;          //<-Scale\n        uv*=rot(iTime);   //<-Rotate\n\t\tuv=abs(uv);       //<-Mirror\n        uv-=0.5;          //<-Shift\n\t}\n\n\t//draw a circle\n\tfragColor=vec4(length(uv)<0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 93, 111, 111, 175], [177, 177, 233, 252, 631]], "test": "untested"}
{"id": "tltXDj", "name": "mirrorballs", "author": "yonatan", "description": "just a small reflection test", "tags": ["reflection"], "likes": 6, "viewed": 138, "published": "Public", "date": "1581774958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float EPS = 0.0001;\n    const int MAX_STEPS = 200;\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0,cos(iTime)*2.,iTime/3.14*4.);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    vec3 col;\n    vec3 p;\n    float d, t = 0.;\n    int i;\n    for(i=0; i<MAX_STEPS; i++) {\n        p = ro+rd*t;\n        p.xz = mod(p.xz + 2., 4.) - 2.;\n        float dSphere = length(p) - 1.25;\n        if(dSphere < EPS) {\n            t = EPS*2.; // so this branch isn't triggered on the next iteration\n            ro = p;\n            rd = reflect(rd, normalize(p));\n        }\n        t += dSphere;\n    }\n    fragColor = vec4((rd.y > 0. ? vec3(.5,.7,.9) : vec3(.9,.7,.5)) * (1.5 - abs(rd.y)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 801]], "test": "untested"}
{"id": "tltXDN", "name": "Infinite Icing Donut", "author": "xjorma", "description": "Homer Simpson dream !\nInspired by Matt Taylor https://www.instagram.com/p/BuWBEloHiSw/\nUse the mouse to turn around.", "tags": ["donut", "reproduction", "cineshader", "timhorton", "icing", "dunkin", "sugarrush"], "likes": 14, "viewed": 2452, "published": "Public API", "date": "1581198893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n\nconst float\tlayerThickness\t= 0.02;\nconst int\tnbLayers \t\t= 7;\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n\nvec2 minVecSelect(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nvec2 map(in vec3 p)\n{\n    float slide = iTime / 1.;\n    float fr = fract(slide);\n    int   fl = int(floor(slide));    \n    vec2  vd = vec2(100., -1.);\n    float cnoise = noise(p * 2. + iTime / 8.) / 3.;\n    float o = 100.0f;\n    for( int i = 0; i < nbLayers; i++)\n    {\n        float m = mod(float(i + fl), float(nbLayers));\n        float r = 0.6 - m * layerThickness + ( 1. - fr) * layerThickness;\n        float d = sdTorus( p, vec2(1, r)) ;\n        d = d - layerThickness / 2.;\n        float o =  - 4. * fract( (iTime + float(i)) / float(nbLayers));\n        float n = 1.5 + p.x  + o + cnoise;\n\t\td = max(d, n);\n \t\tvd = minVecSelect(vec2(d, float(i)), vd);        \n    }   \n    return vd;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy*h).x + \n                      k.yyx * map(p + k.yyx*h).x + \n                      k.yxy * map(p + k.yxy*h).x + \n                      k.xxx * map(p + k.xxx*h).x );\n}\n\n// From IQ\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/12.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return saturate(1.0 - 4. * occ);    \n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float t = 0.5;\n    float d;\n    float m = 0.;\n    for( int i=0; i<1024; i++ )\n    {\n        vec3\tp = ro + t*rd;\n        vec2\th = map(p);\n        t += h.x*0.7;\n        d = dot(t*rd,cd);\n        m = h.y;\n        if( abs(h.x)<0.0001 || d>dist ) break;\n    }\n\n    vec3 col = vec3(0.3);\n\n    if( d<dist )\n    {\n        vec3 light = vec3(0.,4.,2.);\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 v = normalize(ro-p);\n        vec3 l = normalize(light-p);\n        vec3 h = normalize(l+v);\n        \n        vec3 diffcol = normalize(vec3(1. + sin(m * 0.7 + 1.3) / 2., 1. + sin(m * 1.3 + 4.45) / 2., 1. + sin(m * 1.9 + 2.3) / 2.)); \n        vec3 speccol = vec3(1.,1.,1.);\n        vec3 ambcol = diffcol;\n\t\tfloat ao = calcAO(p, n);\n        \n        col = saturate(dot(n,l)) * diffcol;\n        col+= pow(saturate(dot(n,h)),40.) * speccol * 0.5;\n        col+= 0.2 * ambcol;\n        col*= ao;\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + iTime*.1;\n        float phi\t= radians(45.) + radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.7*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3(0, -0.2, 0);\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2],20.);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.8);\n    tot = pow(tot, vec3(1./2.2));\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 225, 258, 258, 313], [316, 316, 341, 341, 370], [373, 373, 408, 408, 434], [436, 436, 459, 459, 498], [500, 500, 526, 526, 931], [933, 933, 954, 954, 1623], [1626, 1626, 1651, 1651, 1919], [1921, 1932, 1974, 1974, 2266], [2269, 2269, 2318, 2318, 3249], [3251, 3251, 3329, 3329, 3401], [3403, 3403, 3445, 3445, 3609], [3611, 3611, 3655, 3655, 3754], [3756, 3756, 3796, 3796, 3866], [3868, 3868, 3925, 3925, 5161]], "test": "untested"}
{"id": "tltXRM", "name": "Simple sunflower", "author": "sdclibbery", "description": "tin", "tags": ["clouds", "flower"], "likes": 1, "viewed": 62, "published": "Public", "date": "1580669313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat sqr (float x) { return x*x; }\n\nvec4 middle_seeds (vec2 uv) {\n    float x = length(sin(length(uv*400.0)))\n        + sqr(sqr(length(sin(uv*175.0))/1.5));\n    return vec4(0.25-0.1*x, 0.2-0.05*x, 0.15-0.03*x, 1.0);\n}\n\nvec4 seeds (vec2 uv) {\n    float x = length(sin(length(uv*230.0)))\n        + sqr(sqr(length(sin(uv*137.0))/1.5));\n    return vec4(0.2-0.1*x, 0.2-0.05*x, 0.15-0.05*x, 1.0);\n}\n\nvec4 petals (vec2 uv, float offset) {\n    float x = sin(offset + atan(uv.x, uv.y)*20.0);\n    return vec4(0.9+0.1*x, 0.825+0.175*x, 0, 1.0);\n}\n\nvec4 stem (float uvx) {\n    float x = cos(uvx*45.0);\n    return vec4(sqr(x)*0.3, 0.4+x*0.6, sqr(x)*0.3, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vscale = 1.0/iResolution.y;\n    vec2 uvs = fragCoord*vscale;\n    vec2 ctr = vec2(0.5*iResolution.x/iResolution.y, 0.56);\n    vec2 uv = uvs - ctr;\n\n    if (length(uv) < 0.08) {\n\t    fragColor = middle_seeds(uv);\n    } else if (length(uv) < 0.2+length(sin(atan(uv.x, uv.y)*40.0))*0.01*fbm_9(uv*3.0)) {\n\t    fragColor = seeds(uv);\n    } else if (length(uv) < length(sin(atan(uv.x, uv.y)*5.0))*0.38) {\n\t    fragColor = petals(uv, 0.0);\n    } else if (length(uv) < length(sin(1.0+atan(uv.x, uv.y)*5.0))*0.4) {\n\t    fragColor = petals(uv, 1.0);\n    } else if (length(uv) < length(sin(2.0+atan(uv.x, uv.y)*5.0))*0.42) {\n\t    fragColor = petals(uv, 2.0);\n    } else if (length(uv.x) < 0.03 && uv.y < 0.0) {\n\t    fragColor = stem(uv.x);\n    } else {\n        float x = fbm_9(-iTime/10.0 + uv);\n\t    fragColor = vec4(0.6+0.4*x, 0.7+0.3*x, 1.0 ,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 100], [102, 102, 128, 128, 441], [518, 518, 544, 544, 757], [759, 759, 780, 780, 794], [796, 796, 825, 825, 977], [979, 979, 1001, 1001, 1152], [1154, 1154, 1191, 1191, 1295], [1297, 1297, 1320, 1320, 1408], [1410, 1410, 1467, 1467, 2324]], "test": "untested"}
{"id": "tltXRS", "name": "Polygon Analytic Motion Blur 2", "author": "fizzer", "description": "This is a more complicated variant of my [url=https://www.shadertoy.com/view/tldSzS]previous shader[/url] which does analytic motionblur. This one accounts for self-intersection of the polygon (it uses the XOR rule).", "tags": ["motionblur", "analytic", "polygon"], "likes": 8, "viewed": 288, "published": "Public", "date": "1581260914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Analytic Linear Motion Blur Series:\n//\n// Self-Intersecting Polygon (XOR Rule) - https://www.shadertoy.com/view/tltXRS\n// Concave Polygon - https://www.shadertoy.com/view/tldSzS\n// Square - https://www.shadertoy.com/view/wtcSzB\n// Checkerboard - https://www.shadertoy.com/view/tlcXRX\n//\n\nconst int numPolygonCorners = 5;\n\nvec2 screenToPolygonTransform(vec2 p, float t)\n{\n    float a = t * 4.;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return m * (p - vec2(cos(t * 14.)*.5, 0.));\n}\n\nvec2 polygonCorner(int i)\n{\n    const float thd = acos(-1.) * 4. / float(numPolygonCorners);\n    float r = .8;\n    return vec2(cos(float(i) * thd), sin(float(i) * thd)) * r;\n}\n\nfloat integratePolygon(vec2 sa, vec2 sb)\n{\n    vec2 sd = sb - sa;\n    float sum = 0.;\n    int e = 0;\n    \n    float ts[numPolygonCorners];\n\n    int endPointInOut = 0;\n    int startPointInOut = 0;\n\n    vec2 pa = polygonCorner(0);\n    for(int i = 1; i <= numPolygonCorners; ++i)\n    {\n        vec2 pb = polygonCorner(i);\n        vec2 d = pb - pa;\n        vec2 n = vec2(d.y, -d.x);\n        \n        float dotsdn = dot(sd, n);\n        float t = dot(pa - sa, n) / dotsdn;\n        float u = dot(sa + sd * t - pa, d);\n        \n        ts[i - 1] = -1.;\n        \n        if(u > 0. && u <= dot(d, d))\n        {\n            if(t > 0. && t <= 1.)\n                ts[i - 1] = t;\n            if(t > 1.)\n                endPointInOut ^= 1;\n            if(t < 0.)\n                startPointInOut ^= 1;\n        }\n        \n        pa = pb;\n    }\n    \n    // The signs of the intersection distances to be added together\n    // unfortunately are order-dependent. So all intersections are needed first\n    // and then their relative order defines the sign.\n    for(int i = 0; i < numPolygonCorners; ++i)\n    {\n        int e = 0;\n        float ti = ts[i];\n        \n        for(int j = 0; j < numPolygonCorners; ++j)\n        {\n            float tj = ts[j];\n            \n            if(tj > 0. && tj < ti)\n            \te ^= 1;\n        }\n        \n        if(ts[i] > 0.)\n            sum += e != 0 ? ts[i] : -ts[i];\n    }\n    \n    if(startPointInOut != 0)\n        sum = -sum;\n\n    if(endPointInOut != 0)\n        sum += 1.;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\n    float t = iTime;\n    \n    vec3 col = vec3(1. / 9.);\n\n\tvec2 uv0 = screenToPolygonTransform(uv, t);\n\tvec2 uv1 = screenToPolygonTransform(uv, t - 1. / 30.);\n\n\tfloat sum = integratePolygon(uv0, uv1);\n\n    col = mix(col, vec3(.9), sum);\n    \n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 328, 376, 376, 500], [502, 502, 529, 529, 677], [679, 679, 721, 721, 2197], [2199, 2199, 2256, 2256, 2622]], "test": "untested"}
{"id": "tltXWM", "name": "Procgen Planet", "author": "kchnkrml", "description": "Procedural generation of a gas-like planet using fbm / domain warping.", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 53, "viewed": 2682, "published": "Public API", "date": "1581113273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltXWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1058, 1132, 1153, 1153, 1220], [1222, 1222, 1243, 1243, 1826], [1828, 1828, 1847, 1847, 2023], [2025, 2295, 2318, 2318, 2334], [2335, 2335, 2365, 2365, 2396], [2398, 2473, 2529, 2529, 2803], [2805, 2837, 2858, 2858, 2896], [2898, 2898, 2937, 2974, 5512], [5514, 5514, 5570, 5570, 6056]], "test": "untested"}
{"id": "tlVSDz", "name": "tp TNCY", "author": "Silith", "description": "z", "tags": ["sphere"], "likes": 1, "viewed": 40, "published": "Public", "date": "1582904711", "time_retrieved": "2021-10-01T00:00:00", "image_code": " const float EPSILON=1e-3;\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n    \nstruct Material{\n  vec4 color;\n  bool emet;\n  bool reflet;\n        \n};\n    \nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n    \nstruct Object{\n    Sphere sphere;\n    Material material;\n};\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nbool intersect_sphere(in Ray R, in Sphere S,out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nObject objs[6];\n\nvoid init_scene(){\n    float cx = cos(iTime*2.0)*2.0;\n    float cy = sin(iTime*2.0)*2.0;\n    float dx = cx+cos(iTime*3.0)*0.5;\n    float dy = cy+sin(iTime*3.0)*0.5;\n    float kx = cx+sin(iTime*2.0)*0.4;\n    float ky = cy+cos(iTime*2.0)*0.4;\n    float kz = cos(iTime*2.0)*0.5;\n    float px = cos(iTime*7.0)*0.5;\n    float py = sin(iTime*7.0)*0.5;\n    \n    objs[0] = Object(Sphere(vec3(0.0, 0.0, 0.0), 0.4),\n                     Material(vec4(0.8,0.8,0.8,1.0),false,true));\n    objs[1]=Object(Sphere(vec3(cx, cy, 0.0), 0.2),\n                   Material(vec4(1.0,0.0,0.0,1.0),false,false));\n    objs[2]=Object(Sphere(vec3(dx, dy, 0.0), 0.1),\n                  Material(vec4(0.0,1.0,0.0,1.0),false,false));\n    objs[3]=Object(Sphere(vec3(kx,ky,kz),0.1),\n                   Material(vec4(1.0,1.0,0.0,1.0),false,false));\n    objs[4]=Object(Sphere(vec3(-5.0,5.0,5.0),0.5),\n                   Material(vec4(1.0,1.0,1.0,1.0),true,false));\n    objs[5]=Object(Sphere(vec3(px,py,.5),0.02),\n                   Material(vec4(1.0,0.0,0.5,1.0),true,false));\n}\n\nbool shadow(in Ray R) {\n   for(int i=0; i<objs.length(); ++i) {\n        float t;\n        if(\n          !objs[i].material.emet &&\n          intersect_sphere(R, objs[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec4 lighting(in vec3 P, in vec3 N, in Material material){\n    if (material.emet == true){\n        return material.color;\n    }\n    vec4 result = vec4(0.0,0.0,0.0,0.0);\n    \n    for (int i=0; i<objs.length(); i++){\n        if(objs[i].material.emet == true){\n            Ray R2 = Ray(P, objs[i].sphere.Center);\n            if(!shadow(R2)){\n                vec3 E = objs[i].sphere.Center-P;\n                float lamb = max(0.0, dot(E,N) /length(E));\n                result += lamb * material.color * objs[i].material.color;\n            }\n         }\n    }\n    return vec4(result.x,result.y,result.z,1.0);\n    \n}\nvec4 raytrace(in Material m, in Ray R, out vec3 P, out vec3 N)\n{\n  float t = 1e30;\n  vec4 color = lighting(P,N,m);\n    for (int i=0; i<objs.length(); i++){\n        float ti;\n        if( intersect_sphere(R, objs[i].sphere, ti) && ti < t && ti > 0.0 && ti > 1e-6){\n            t = ti;\n            P = R.Origin + 1e-3 * R.Dir;\n         \tN = normalize(P - objs[i].sphere.Center);\n            vec3 E = objs[i].sphere.Center-P;\n            float lamb = max(0.0, dot(E,N) /length(E));\n         \tcolor =lighting(P,N,objs[i].material)*0.9;   \n        }\n    }\n  return color;\n    \n}\n\nvoid mainImage(\n   out vec4 col,in vec2 coord\n) {     \n    \n\tfloat centrex = iResolution.x/2.0;\n\tfloat centrey = iResolution.y/2.0;\n\t   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, coord);\n  \n   \n   col = vec4(0.0, 0.9, 0.8, 1.0);\n   init_scene();\n    \n    float t =1e30;\n    vec3 P;\n    vec3 N;\n    Material material;\n    for (int i=0; i<objs.length();++i){\n        float ti;\n        if( intersect_sphere(R,objs[i].sphere,ti) && ti<t){\n         t =ti;\n         P = R.Origin + t*R.Dir;\n         N = normalize(P - objs[i].sphere.Center);\n         material = objs[i].material;\n            \n        }\n        \n        \n    }\n    if (t != 1e30){\n        if(material.reflet==true){\n             Ray R2 = Ray(P,-2.0*dot(N,R.Dir)*N + R.Dir);\n            col = raytrace(material,R2,P,N);\n        }else{\n        col = lighting(P,N,material);\n        }\n        \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 449, 449, 747], [749, 749, 786, 786, 883], [885, 885, 943, 943, 1209], [1228, 1228, 1246, 1246, 2271], [2273, 2273, 2296, 2296, 2557], [2559, 2559, 2617, 2617, 3168], [3169, 3169, 3233, 3233, 3741], [3743, 3743, 3792, 3792, 4683]], "test": "untested"}
{"id": "tlySDm", "name": "Rainbow Squares", "author": "mrbrowning", "description": "Striated rainbow diagonal square pattern.", "tags": ["color", "pattern"], "likes": 6, "viewed": 112, "published": "Public", "date": "1582837687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nvec3 xs[6];\n\nmat2 rotm(float angle) {\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec3 color(float loc) {\n    vec3 result = vec3(0.0);\n    for (int i = 0; i < 6; ++i) {\n        float fi = float(i);\n        float inSection = step(fi, loc) - step(fi + 1.0, loc);\n        vec3 inverted = 1.0 - xs[i];\n        \n        vec3 stepColor = mix(xs[i], sqrt(inverted), mod(iTime * 1.0 + fi / 6.0, 1.0) * inSection);\n        result += stepColor * (step(fi - 0.1, loc) - step(fi + 0.1, loc));\n    }\n\n    return result;\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return rotm(angle) * (uv - 0.5) + 0.5;\n}\n\nvec3 pattern(vec2 uv) {\n    vec2 sv = vec2(uv.x, 1.0 - uv.y) * 6.0;\n    \n    float mi = min(sv.x, sv.y);\n    float moat = 0.0;\n    for (int i = 0; i < 6; ++i) {\n        float fi = float(i);\n        moat += smoothstep(fi - 0.04, fi + 0.04, mi) - smoothstep(fi + 0.06, fi + 0.14, mi);\n    }\n    moat = clamp(moat, 0.0, 1.0);\n    \n    vec2 iv = floor(sv);\n    vec2 fv = fract(sv);\n\treturn color(min(iv.x, iv.y)) * (1.0 - moat);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    xs[0] = vec3(0.92, 0.0, 0.0);\n\txs[1] = vec3(1.0, 0.5, 0.0);\n\txs[2] = vec3(1.0, 0.9, 0.0);\n\txs[3] = vec3(0.0, 0.5, 0.1);\n\txs[4] = vec3(0.25, 0.4, 0.95);\n\txs[5] = vec3(0.5, 0.0, 0.5);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mv = iMouse.xy / iResolution.xy;\n    vec2 cv = mv - 0.5;\n    \n    float compensation = -atan(-0.5, -0.5 * iResolution.x / iResolution.y) - PI / 4.0;\n\n    float angle = -atan(cv.y, cv.x * iResolution.x / iResolution.y) - compensation;\n    float d = length(cv);\n    \n    vec2 sv = rot(uv, angle);\n    float scale = 2.0 + 8.0 * d;\n    sv *= scale;\n    \n    vec2 iv = floor(sv);\n    vec2 fv = fract(sv);\n\n\tfragColor = vec4(pattern(fv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 59, 59, 124], [126, 126, 149, 149, 552], [554, 554, 586, 586, 631], [633, 633, 656, 656, 1059], [1061, 1061, 1117, 1117, 1847]], "test": "untested"}
{"id": "tlySzm", "name": "Chromatic Resonance", "author": "PixelPhil", "description": "A quick experiment with colors and music.\n\nMusic : Lightning Moment - DJ Okawari (feat. fox capture plan)", "tags": ["spectrum", "visualization", "music", "colors", "vj", "sines"], "likes": 40, "viewed": 1444, "published": "Public API", "date": "1582412922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Chromatic Resonance by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MUSIC_REACTION 0.2\n\n#define S(a, b, c) smoothstep(a, b, c)\n#define sat(a) clamp(a, 0.0, 1.0)\n\n#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat CosineInterpolate(float y1, float y2, float t)\n{\n   float mu = (1.0 -cos(t * pi)) * 0.5;\n   return (y1 * (1.0 - mu) + y2 * mu);\n}\n\n// A 2d Noise (Cosine interpolation is more plasing for this effect)\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    return CosineInterpolate(CosineInterpolate(c00, c10, diff.x), CosineInterpolate(c01, c11, diff.x), diff.y);\n}\n\nfloat LineNoise(float x, float t)\n{\n    float n = Noise2(vec2(x * 0.6, t * 0.2));\n    //n += Noise2(vec2(x * 0.8, t * 0.2 + 34.8)) * 0.5;\n    //n += Noise2(vec2(x * 1.2, t * 0.3 + 56.8)) * 0.25;\n    \n    return n - (1.0) * 0.5;\n}\n\n\nfloat line(vec2 uv, float t, float scroll)\n{\n    \n    float ax = abs(uv.x);\n    uv.y *= 0.5 + ax * ax * 0.3; \n    \n        \n    uv.x += iTime * scroll;\n    \n    float n1 = LineNoise(uv.x, t);\n    \n    \n    float n2 = LineNoise(uv.x + 0.5, t + 10.0) * 2.0;\n    \n    float ay = abs(uv.y - n1);\n    float lum = S(0.02, 0.00, ay) * 1.5;\n    lum += S(1.5, 0.00, ay) * 0.1;\n    \n   \n    float r = (uv.y - n1) / (n2 - n1);\n    float h = sat(1.0 - r);\n    if (r > 0.0) lum = max(lum, h * h * 0.7);\n    \n    return lum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n    float xWave = fragCoord.x / iResolution.x;\n    \n    float wave = texture(iChannel0, vec2(xWave * 0.2, 1.0)).r * sin(iTime * 0.2 ) * MUSIC_REACTION;\n    float wave1 = texture(iChannel0, vec2(xWave * 0.2 + 0.2, 1.0)).r * sin(iTime * 0.2 + 0.5) * MUSIC_REACTION;\n    float wave2 = texture(iChannel0, vec2(xWave * 0.2 + 0.4, 1.0)).r * sin(iTime * 0.2 + 1.0) * MUSIC_REACTION;\n    float wave3 = texture(iChannel0, vec2(xWave * 0.2 + 0.6, 1.0)).r * sin(iTime * 0.2 + 1.5) * MUSIC_REACTION;\n    float wave4 = texture(iChannel0, vec2(xWave * 0.2 + 0.8, 1.0)).r * sin(iTime * 0.2 + 2.0) * MUSIC_REACTION;\n    \n  //  fragColor = vec4(lum, lum, lum, 1.0); return;\n    \n\n    float lum = line(uv * vec2(2.0, 1.0)+  vec2(0.0, wave), iTime * 0.3, 0.1) * 0.6;\n    lum += line(uv * vec2(1.5, 0.9) +  vec2(0.33, wave1), iTime * 0.5 + 45.0, 0.15) * 0.5;\n    lum += line(uv * vec2(1.3, 1.2) +  vec2(0.66, wave2), iTime * 0.4 + 67.3, 0.2) * 0.3;\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave3), iTime * 0.77 + 1235.45, 0.23) * 0.43;\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave4), iTime * 0.77 + 456.45, 0.3) * 0.25;\n  \n    \n    float ax = abs(uv.x);\n    \n    lum += ax * ax * 0.05;\n  \n\n    vec3 col;\n    \n    float x = uv.x * 1.2 + iTime * 0.2;\n    \n    vec3 hue = (sin(vec3(x, x + pi2 * 0.33, x + pi2 * 0.66)) + vec3(1.0)) * 0.7;\n    \n\n    // overlay mix\n    float thres = 0.7;\n    if (lum < thres)\n        col = hue * lum / thres;\n    else\n        col = vec3(1.0) - (vec3(1.0 - (lum - thres)) * (vec3(1.0) - hue));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XtSGRw", "previewfilepath": "https://soundcloud.com/brella-n-i/lightning-moment-feat-fox", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/brella-n-i/lightning-moment-feat-fox", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlySzm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[358, 385, 403, 459, 635], [638, 638, 692, 692, 773], [775, 844, 867, 867, 1215], [1217, 1217, 1252, 1252, 1446], [1449, 1449, 1493, 1493, 1961], [1963, 1963, 2020, 2070, 3723]], "test": "untested"}
{"id": "tlyXzW", "name": "P6m with interlaced ribbons (2)", "author": "curena", "description": "Copy of previous shader ([url]https://www.shadertoy.com/view/WlyXRz[/url]) which was broken because of a shadertoy bug (I cannot repair it). Exactly this islamic star pattern can be found on the \"Reales Alcázares\" palace in Seville and in Granada mosque.", "tags": ["p6mm", "p6m", "symmetrygroups", "wallpapergroups", "islamicstarpattern"], "likes": 15, "viewed": 229, "published": "Public", "date": "1582288417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----------------------------------------------------------------------------------\n//\n// Carlos Ureña, Apr,2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\nconst int   n_aa  = 3 ;\nconst float pi    = 3.1415927 ;\nconst float xfrec = 3.0 ;\n\n// ----------------------------------------------------------------\n// ISLAMIC STAR PATTERN related functions\n\n\n// parameters and pre-calculated constants\nconst float\n    sqr2       = 1.41421356237, // square root of 2\n    sqr3       = 1.73205080756, // square root of 3.0\n    sqr2_inv   = 1.0/sqr2 ,\n    sqr3_inv   = 1.0/sqr3 ,\n    cos30      = 0.86602540378, // cos(30 degrees)\n    sin30      = 0.50000000000, // sin(30 degrees)\n    l          = 5.5,          // length of triangle in NDC (mind --> 1.0)\n    l_inv      = 1.0/l ,       // length inverse\n    line_w     = 0.03,         // line width for basic symmetry lines render\n    sw         = 0.020 ;       // stripes half width for islamic star pattern\n\nconst vec2\n    u        = 1.0*vec2( 1.0, 0.0  ) ,          // grid basis: U vector\n    v        = 0.5*vec2( 1.0, sqr3 ) ,          // grid basis: V vector\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,     // dual grid basis: U vector\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,     // dual grid basis: V vector\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ;      // triangle center\n\n\n// -----------------------------------------------------------------------------------\n// point orbit transformation parameters\nint\n    nMirrorOdd = 0 ,\n    nMirror    = 0 ,\n\tnGridX     = 0 ,\n    nGridY     = 0 ;\n\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through 'v1' and 'v2'\n// (only for points to right of the line from v1 to v2)\n//\nvec2 Mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       nMirrorOdd = 1-nMirrorOdd ;\n       nMirror = nMirror+1 ;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to line through 'v1' and 'v2'\n\nfloat SignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n// -------------------------------------------------------------------\n// un-normalized signed distance to line\n\nfloat UnSignedDistance( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           un = vec2( s.y, -s.x ) ;\n    return dot(p-v1,un) ;\n}\n// -------------------------------------------------------------------\n// Signed perpendicular distance from 'p' to polyline from 'v1'\n// to 'v2' then to 'v3'\n\nfloat DoubleSignedDistance( vec2 p, vec2 v1, vec2 v2, vec2 v3 )\n{\n\n    vec2  dir1 = v2 + normalize(v1-v2),\n          dir3 = v2 + normalize(v3-v2);\n    vec2  vm   = 0.5*(dir1+dir3) ;\n    float dm   = UnSignedDistance( p, v2, vm ) ;\n\n    if ( dm >= 0.0 )\n   \t\treturn SignedDistance( p, v1, v2 ) ;\n   \telse\n        return SignedDistance( p, v2, v3 ) ;\n}\n// -------------------------------------------------------------------------------\n// Takes 'p0' to the group's fundamental region, returns its coordinates in that region\n\nvec2 p6mm_ToFundamental( vec2 p0 )\n{\n    nMirrorOdd = 0 ;\n    nMirror    = 0 ;\n\n    // p1 = fragment coords. in the grid reference frame\n\n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n\n    // p2 = fragment coords in the translated grid reference frame\n\n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n\n    nGridX = int(p1.x-p2.x) ; // largest integer g.e. to p1.x\n    nGridY = int(p1.y-p2.y) ; // largest integer g.e. to p2.x\n\n    // p3 = barycentric coords in the translated triangle\n    // (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n\n    vec2 p3 = Mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n\n    // p4 = p3, but expressed back in cartesian coordinates\n\n    vec2 p4 = p3.x*u + p3.y*v ;\n\n    // p7 = mirror around the three lines through the barycenter, perp. to edges.\n\n    vec2 p5 = Mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = Mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = Mirror( p6, tri_cen, vec2(0.0,0.0) );\n\n    return p7 ;\n}\n\n// --------------------------------------------------------------------\n// A possible distance function\n\nfloat DistanceFunc( float d )\n{\n   return 1.0-smoothstep( line_w*0.5, line_w*1.5, d );\n}\n\n// -------------------------------------------------------------------------------\n// Point color for basic symmetry lines in (r,g,b)\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n\n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );\n\n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n\n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n\n    return res ;\n}\n\n// ---------------------------------------------------------------------\n// Stripe half width for star pattern\n\nvec4 Stripe( float d )\n{\n   if ( d > sw*0.85 )\n     return vec4( 0.0,0.0,0.0,1.0 );\n   else\n     return vec4(1.0,1.0,1.0,1.0)  ;\n}\n\n// ---------------------------------------------------------------------\n// Color for islamic star pattern\n\nvec4 p6mm_pattern( vec2 p )\n{\n    vec2 pf = p6mm_ToFundamental( p );\n\n    //return p6mm_SimmetryLines( p ) ;\n    vec2 c  = tri_cen ;\n\n    // constants defining the stripes\n    float\n        f   = 0.30 ,\n        fs1 = 0.14 ,\n        s1  = fs1*c.x,\n        s2  = 0.5*s1 ;\n\n    // stripes vertexes\n    vec2\n        // upper strip\n        u1 = vec2( f*c.x, 0.0 ) ,\n        u2 = vec2( c.x, (1.0-f)*c.y ),\n\n        // lower strip\n        l1 = vec2( c.x, s1+s2 ),\n        l2 = vec2( c.x-s2, s1 ),\n        l3 = vec2( sqr3*s1, s1 ),\n\n        // right strip\n        r1 = vec2( c.x-s1, (1.0-fs1)*c.y ),\n        r2 = vec2( c.x-s1, s2 ) ,\n        r3 = vec2( c.x-s1-s2, 0.0 ),\n\n    \t// origin star strip\n        mm = vec2( s1*(sqr3-1.0/3.0), s1*(1.0-sqr3_inv) );\n\n    // signed and unsigned distances to stripes:\n\n    float\n        d1s = SignedDistance( pf, u1, u2 ) ,\n        d2s = DoubleSignedDistance( pf, l1, l2, l3 ) ,\n        d3s = DoubleSignedDistance( pf, r1, r2, r3 ) ,\n        d4s = DoubleSignedDistance( pf, u1, mm, l3 ) ,\n        d1  = abs( d1s ),\n        d2  = abs( d2s ),\n        d3  = abs( d3s ),\n        d4  = abs( d4s );\n\n\n    // stripes inclusion\n    bool in1, in2, in3, in4 ;\n\n    if ( nMirrorOdd == 0 )\n    {\n        in1 = (d1 < sw) && ! (d2 < sw) && ! (d4 < sw);\n        in2 = (d2 < sw) && ! (d3 < sw);\n        in3 = (d3 < sw) && ! (d1 < sw);\n\n        in4 = (d4 < sw) && ! (d2 < sw);\n    }\n    else\n    {\n        in1 = (d1 < sw) && ! (d3 < sw) ;\n        in2 = (d2 < sw) && ! (d1 < sw) && ! (d4 < sw);;\n        in3 = (d3 < sw) && ! (d2 < sw);\n\n        in4 = (d4 < sw) && ! (d1 < sw);\n    }\n\n    vec4 col ;\n\n    // compute final color\n\n    if ( in1 )\n        col = Stripe( d1 ) ;\n    else if ( in2 )\n        col = Stripe( d2 ) ;\n    else if ( in3 )\n        col = Stripe( d3 ) ;\n    else if ( in4 )\n        col = Stripe( d4 ) ;\n    else if ( d2s < 0.0 && d3s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.0, 1.0 ) ;\n    else if ( d1s < 0.0 && d2s < 0.0 || d1s <0.0 && d3s < 0.0 )\n        col = vec4( 0.1, 0.1, 0.1, 1.0 );\n    else if ( d1s < 0.0 || d2s < 0.0 )\n        col = vec4( 0.0, 0.4, 0.9, 1.0 );\n    else\n        col = vec4( 0.6, 0.0, 0.0, 1.0 ) ;\n\n    return col ;\n}\n//-------------------------------------------------------------------------------------\nbool lastInFundamental()\n{\n \treturn nGridX ==0  && nGridY == 0 && nMirrorOdd == 0 && nMirror == 0  ;\n}\n//-------------------------------------------------------------------------------------\n// returns the (time dependent) pattern color evaluated at a point 'p'\n\nvec4 p6mm_patterns_sum_time_dep( vec2 p )\n{\n\n    const float t   = 30.0 ; // time units for each rotation (period)\n    float       a   = (iTime*2.0*pi)/t,\n                ca  = cos(a),\n                sa  = sin(a),\n                s   = 3.5 + 3.0*sin( iTime/2.0 );\n    mat2        rot = mat2( ca, -sa, sa, ca );\n    vec2        d   = 0.001*vec2( iTime, 0.2*iTime );\n\n    return p6mm_pattern( s*rot*(d+p) );\n}\n//-------------------------------------------------------------------------------------\n// returns a fixed (not time dependent) pattern color evaluated at a point 'p'\n\nvec4 p6mm_patterns_sum_fixed( vec2 p )\n{\n    return p6mm_pattern( 2.0*p );\n}\n\n//-------------------------------------------------------------------------------------\nvec4 AA_pixel_color( in vec2 pixel_coords )\n{\n    vec4        sum    = vec4( 0.0, 0.0, 0.0, 1.0 );\n    const float n      = float(n_aa);\n    const vec2  c      = vec2( 0.5, 0.5 );\n    float       scale  = xfrec/iResolution.x ;\n\n    for( int i = 0 ; i < n_aa ; i++ )\n    for( int j = 0 ; j < n_aa ; j++ )\n    {\n       vec2 samplep = pixel_coords + 1.0001*(c+vec2(i,j)/n) ;\n       sum = sum + p6mm_patterns_sum_time_dep( scale*(samplep-0.5*iResolution.xy) ); \n       //sum = sum + p6mm_patterns_sum_fixed( scale*(samplep-0.5*iResolution.xy) );\n    }\n    return sum/(n*n);\n}\n\n//-------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AA_pixel_color( fragCoord ) ;\n    //fragColor = p6mm_pattern( 0.001*fragCoord );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyXzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1682, 1890, 1931, 1931, 2179], [2180, 2324, 2374, 2374, 2468], [2469, 2582, 2634, 2634, 2719], [2720, 2880, 2945, 2945, 3230], [3231, 3403, 3439, 3439, 4388], [4390, 4495, 4526, 4526, 4583], [4585, 4720, 4759, 4759, 5084], [5086, 5198, 5222, 5222, 5328], [5330, 5438, 5467, 5467, 7610], [7611, 7699, 7725, 7725, 7801], [7802, 7962, 8005, 8005, 8370], [8371, 8539, 8579, 8579, 8615], [8617, 8705, 8750, 8750, 9276], [9278, 9366, 9423, 9423, 9522]], "test": "untested"}
{"id": "tt3SWB", "name": "[TWITCH] Pounding Aldebaran", "author": "evvvvil", "description": "Pounding Aldebaran\nResult of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["noise", "terrain", "demoscene", "light", "particles", "planet", "landscape", "glow", "ripple", "point", "core", "twitch", "improv", "interstellar"], "likes": 38, "viewed": 1909, "published": "Public API", "date": "1581608706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Pounding Aldebaran - Result of an improvised live coding session on Twitch\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"People who do not know how to laugh are always pompous and self-conceited.\" - William Makepeace Thackeray\n\nvec2 z,v,e=vec2(.0035,-.0035); float t,tt,bb,b,b2,g,g2,td,cn,texNoi; vec3 pp,po,no,ld,al,lp; //global vars: same old garbage, just like any Coldplay album.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function, yeah I know it's boring but then so is sitting next to you at a Wedding.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like the meaningless chat we're gonna have at that wedding.\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} // Smooth merge - Merging geometry softly. Bit like a wedding actually, you know, being an excuse for two people eventually physically merging.\nfloat noi(vec3 p){ // Noise function. I don't really understand any of this, I was so bored at that wedding that I spent all my neurones on halucinagenics, so much so I even forgot how to spell halucinogenics\n  vec3 f=floor(p),s=vec3(7,157,113); \n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nvec2 pounder( vec3 p )\n{ //Phallic symbol incoming, why be subtle when you can litterally fuck a planet's core? You're just not ambitious enough broski: I once fucked the sea.\n  pp=abs(p+vec3(0,-6.,0))-vec3(0,5.+bb,0); //make new position pp out of p for the half spheres, abs symetry along y and animate. Give it some serious pumping action (that's what she said)\n  vec2 h,t=vec2(length(pp)-2.2,6.); //WHITE SPHERE soon to be slashed in half, just like public services funding under Boris Johnson.\n  t.x=abs(t.x)-.3; //Onion trick to make the sphere hollow, carving holes basically, this time with math rather than the smallest part of your body.\n  t.x=max(t.x,-pp.y); //Slash sphere in half and reveal it hollow, just like those brexit promises. \n  h=vec2(length(pp)-2.2,3.); //BLACK SPHERE soon to be slashed in half, just like the UK's international reputation under Boris Johnson.\n  h.x=abs(h.x)-.1; //Onion trick to make the sphere hollow, with smaller radius so it creates edge.\n  h.x=max(h.x,-pp.y-.5); //Slash sphere in half and reveal it as a hollow, just like those brexit promises. \n  pp.xz*=r2(1.2+sin(p.y*(1.-0.07*bb))*.5); // reusing pp as new position for splines, rotate and twist a bit.\n  h.x=min(h.x,bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.2,20.0,0.15))); //BLACK SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  t=t.x<h.x?t:h; //Merge all geometries from both black and white materials. There is an interratial sex joke to be made here but I'm too scared of offended millenials.\n  t.x=max(t.x,-(length(p.xz)-1.)); //HOLE IN MIDDLE, digs hole through both half spheres, letting the blue core through it. Noone will hear you scream in space but there is still time for sexual inuendos \n  h=vec2(bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.3,20.0,0.01)),6.); //GLOW SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  g+=0.1/(0.1+h.x*h.x*(150.-sin(p.y*0.5+tt*2.)*149.)); //First glow, making the splines above glow and sweeping the glow along Y axis. It's like building fireworks but without the fun of burning things.\n  t=t.x<h.x?t:h; //Merge the glow splines with the rest. Like putting fairy lights around your room to pretend you are not the twisted fucker your neighbour knows you are.\n  h=vec2(  length(p.xz+texNoi*2.5)-(.5+0.2*sin(p.y*2.+tt*2.)),5.); //BLUE CORE, inifinte cylinder with bit of displacement along y and reusing texNoi for crunchy effect.\n  g2+=0.1/(0.1+h.x*h.x*(5.-sin(p.y*0.5+tt*2.-0.5)*4.9)); //Second glow, making blue core glow and sweeping along y axis with a bit of an offset so it comes in a little after white.\n  t=t.x<h.x?t:h; t.x*=0.9; //Merge the core with rest and tweak distance field a bit to avoid artifact (t.x*=0.9)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nfloat texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return f*.45+.05;\n}// We miss you on Twitch Luna... Sending some love.\nvec2 mp( vec3 p )\n{ \n  texNoi=texNoise(0.35*vec2(p.y,dot(p.xz,vec2(.7))))*.2; //texture based noise with naive triplanar uvs, adds really nice tiny crunchy details hard to recreate with a 3d noise function\n  td=noi(p*.2+1.5)*4.-noi(p*2.-.5)*.1-noi(p*.05)*2.+noi(p*.03)*5.-noi(p*.5)+texNoi; //td = terain displacement = a whole bunch of noise calls at different scales to create natural terrain. Bit like jamming your fingers in the socket and getting out an expensive haircut.\n  float ripple=sin(5.*(length((p.xz+vec2(2,2))*.7)-(0.2))-tt*10.)*0.5*b2; //Ripple motion for the pounding.\n  pp=p+td;//Make new position pp for terrain and add all the noise to displace it.\n  pp.y-=sin(p.x*.1)-sin(p.x*30.)*0.01; //Bit more displacement for the terrain and a subtl frill along the x axis\n  vec2 h,t=vec2(pp.y+5.+ripple,5.); //Create base terrain from a displaced plane\n  cn=noi(p*1.5+ripple)*.2; //To make terrain more interesting than plane we gonna add some displaced infinite cylinders, but we need to tweak them even more with more noise. It's like seeing Autechre live, but as if it's wasn't fucked up enough, you also took some acid.\n  t.x=smin(t.x,length(abs(pp.xz+cn)-vec2(5,5))-(1.1+ripple*.2-sin(p.y*.2)+sin(p.y*30.)*0.02),3.); //Add some vertical infinite tweaked out cylinder and do smooth merge with terrain. It's like genetrification, it's ok because hipsters are actually \"nice guys\".\n  t.x=smin(t.x,length(abs(pp.xy+cn-vec2(0,3))-vec2(12,0))-(1.1+ripple*.2-sin(p.z*.2)),13.); //More infinite cylinders this time horizontal. Making caves makes me feel like a man... I miss the days of slaying sabre tooth tigers to impress the ladies.\n  t.x*=0.55; //Remove the atrifact, fix me beautiful, baby.\n  h=pounder(p+vec3(2,5,2)); //MAKE IT POUND! Yeah could have been boring but then we have major earth pounding action, who doesn't love pumping hey? Even Donald Trump is a fan.\n  t=t.x<h.x?t:h; // Ah yeah make it pound but we gotta merge the columns with the rest, while retaining material IDs. It's like international diplomacy, everyone wants war, but let's have some tea and discuss these borders.\n  h=vec2(length(cos((p*.3-td*.2)+vec3(0,tt*1.,0))),6.); //MAKE IT SNOW! I know winter is finished but I live in England were it's always bleak and we like it like this. Yeah you can keep your sunshine, Europe!\n  g+=0.1/(0.1+h.x*h.x*400.); //Yeah make them little snow particles glow, it might lift the mood a bit, we sort of miss the European sunshine since Brexit.\n  t=t.x<h.x?t:h; //Add particles to rest, like sprinkling glitter over your dick to make up for its lack of girth.\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started there were no craft beer shops and boating shoes were for sailors.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft (get distance to geom)\n    if(h.x<.0001||t.x>40.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime+32.,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some life you've lived, Steve.\n  b=clamp(sin(tt*2.-1.4),0.,1.),b2=clamp(sin(tt*2.-2.2),0.,1.),bb=smoothstep(0.,1.,b); //some global animation variables. Because cranking automatons is almost as fun as maturbation, my friends.\n  vec3 ro=mix(vec3(-2.-cos(tt*.4)*5.,5.,-17.+sin(tt*.2+1.)*-3.),vec3(cos(tt*.2)*3.,sin(tt*.4)*5.+6.,-12),ceil(sin(tt*.5))),//Ro=ray origin=camera position We bild camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0,cos(tt*.1)*5.,0)-ro), //cw camera forward?      \n  cu=normalize(cross(cw,vec3(0,1,0))), \t\t//cv camera up??\n  cv=normalize(cross(cu,cw)), \t\t\t\t//cu camera left vector??? Not sure broh, too busy burning fossil fuels and maximizing my carbon footprint.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,lp; //rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  lp=vec3(2,5,2);//POINT LIGHT position is where the pounder is to create fake illumination from the core... Area lights I will do the day after I give up drinking, I promise.\n  co=fo=vec3(.1)-length(uv)*.09-rd.y*.07; //background is grey with vignette and subtle vertical gradient based on ray direction y axis. It's grey like the heart of people from Birmingham.\n  z=tr(ro,rd);t=z.x;//Trace the trace in the loop de loop. Aka sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(1),vec3(0.0,.2,.3),min(td*.4+0.1*abs(sin(pp*1.)),1.)); //by default albedo is mix between white and blue but the mix is done with noise of terrain so give really nice details in hues of blue\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    ld=normalize(lp-po);   //Point light direction shit, get light dir from light pos.\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    attn=1.0-pow(min(1.0,length(lp-po)/20.),4.0), //Point light attenuation\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from Shane, who is \"da man\"\n    co=attn*mix(sp+al*(a(.1)*a(.3)+.2)*(dif+(z.y==5.?s(0.8):0.)),fo,fr);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=clamp(mix(fo,co,exp(-.0001*t*t*t)),0.,1.);//Fog soften things, but it won't stop hipsters from gentrifying the north of England.\n  }  \n  fragColor = vec4(pow(co+g*0.1+g2*0.20*vec3(0.0,.2,.3),vec3(0.45)),1);// Naive gamma correction\n} //Thank you and good night brooooooski", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3SWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 457, 481, 481, 522], [523, 622, 639, 639, 682], [683, 784, 820, 820, 885], [886, 1030, 1048, 1238, 1458], [1459, 1459, 1483, 1634, 4224], [4225, 4336, 4360, 4360, 4558], [4558, 4610, 4629, 4629, 7209], [7210, 7210, 7292, 7292, 8059], [8149, 8149, 8278, 8278, 11494]], "test": "untested"}
{"id": "tt3XDn", "name": "FWA logo", "author": "edankwan", "description": "Trace the FWA logo with capsule sdf. View this shader at [url]https://cineshader.com/view/tt3XDn[/url]", "tags": ["cineshader"], "likes": 11, "viewed": 89965, "published": "Public API", "date": "1580840342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float fwaD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \nfwaD = min(fwaD, sdCapsule(p, vec3(-2.1975012, 0, 0.0), vec3(-1.1325011999999999, 0, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-1.7825011499999996, -0.44249114999999994, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.9700012499999998, 0.42000885000000004, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.5375011499999998, -0.44249114999999994, 0.0), vec3(-0.9700012499999998, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.10000124999999968, 0.42000885000000004, 0.0), vec3(-0.5375011499999998, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.3274987500000003, -0.44249114999999994, 0.0), vec3(-0.10000124999999968, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.7749988500000001, 0.42000885000000004, 0.0), vec3(0.3274987500000003, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, 0.42000885000000004, 0.0), vec3(0.7749988500000001, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, -0.41249115, 0.0), vec3(1.7774988, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424987500000003, -0.41249115, 0.0), vec3(1.7774988, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424741500000001, -0.012491100000000017, 0.0), vec3(0.9424987500000003, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(2.2149741000000005, -0.015, 0.0), vec3(0.9424741500000001, -0.012491100000000017, 0.0), thickness));\n\t\n    res.x = fwaD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n\tvec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n\tvec3 rayDir = normalize(target - rayOri);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n    vec2 res;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tres = map(p);\n        depth += res.x;\n\t\tif (res.x < 1e-5) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(50.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"FWA logo\",\n\t\"description\": \"Trace the FWA logo with capsule sdf.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 177, 177, 280], [282, 282, 331, 331, 467], [468, 468, 499, 499, 586], [588, 588, 640, 640, 761], [763, 763, 800, 800, 883], [885, 885, 903, 903, 2938], [2940, 2940, 2970, 2970, 3260], [3262, 3262, 3292, 3292, 3376], [3378, 3378, 3435, 3435, 4742]], "test": "untested"}
{"id": "tt3XR2", "name": "Moiré Spiral", "author": "rotmoset", "description": "Click at different points in the shader to see different patterns appear from this basic spiral", "tags": ["moire"], "likes": 1, "viewed": 82, "published": "Public", "date": "1581340659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat dist(vec2 p1, vec2 p2)\n{\n\tfloat dx = p1.x - p2.x;\n    float dy = p1.y - p2.y;\n    return sqrt(dx*dx + dy*dy);\n}\n\n#define PI 3.14159\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n\t\n    uv.x *= iResolution.x / iResolution.y;\n    \n   \tfragColor = vec4(0.0);\n    \n    float angle = atan(uv.y /1.0,uv.x) + PI;\n    \n    float d = dist(uv, vec2(0.0,0.0));\n    \n    float S = abs((iMouse.xy / iResolution.xy - 0.5).x);\n    \n    angle += pow(1.0 + S * 160.0,1.0+d) * PI - iTime/0.51;\n    \n    \n    uv = vec2(cos(angle), sin(angle));\n    \n\n    if(uv.y > 0.2)\n        fragColor = mix(vec4(0.0,0.0,0.0,0.0), vec4(0.0,0.0,1.0,0.0), 0.8);\n    \n    if (uv.y < -0.2)\n        fragColor = mix(vec4(0.0,0.0,0.0,0.0), vec4(0.0,1.0,0.0,0.0), 0.8);\n\n    \n    fragColor /= sqrt(0.1+d/2.0) / 0.5;\n        \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 118], [141, 141, 198, 248, 913]], "test": "untested"}
{"id": "tt3XWH", "name": "Mindf*ck", "author": "julianlumia", "description": ":octopusballoon:", "tags": ["cubes"], "likes": 11, "viewed": 124, "published": "Public", "date": "1580853336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float EPSILON = 0.001;\nconst float MAX_DIST = 100.0;\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nconst float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\n\n\nfloat dMengerSponge(vec3 p) \n{\n float d = sdBox(p, vec3(0.79));\n float itt = 1.3;\n float one_third = 1. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\n\n\nfloat GetDist(vec3 p){\n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n float dm1;\n float d;  \n d=1.0;           \n dm1=dMengerSponge(p-vec3(-0.,-0.,0.0));\n d=min(d, dm1);\n return d;\n}\n\nvec3 GetNormal(vec3 p) {\n float d = GetDist(p);\n vec2 e = vec2(.001, 0);  \n vec3 n = d - vec3(\n GetDist(p-e.xyy),\n GetDist(p-e.yxy),\n GetDist(p-e.yyx));   \n return normalize(n);\n}\n\nvec3 cameraPath(float t) {\n t *= PI *.5 ;\n float t2 =  cos(t)+0.;\n float c = cos(t*2.);\n float x = 0.;\n float y = 0.;\n float z= 0.;   \n if (t2<0.){\n x = 1. /1. + 2. +c;\n };       \n if (t2>0.){\n y = 1. /1. + 2. +c;\n };\n vec3 xyz =vec3(x,y,z);\n return xyz;\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n vec2 xy = fragCoord - size / 2.0;\n float z = size.y / tan(radians(fieldOfView) / 2.);\n return normalize(vec3(xy, -z));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n float dO=0.1;\n for(int i=0; i<64; i++) {\n vec3 p = ro + rd*dO;\n float dS = GetDist(p);\n dO += dS*1.;\n if(dO>100. || dS<0.001) break;\n } \n return dO;\n}\n\nmat4 viewMatrixRIGHT() \n{\n return mat4(\n vec4(1, 0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0,0, 1, 0),\n vec4(0, 0, 0, 1)\n );\n}\n\nmat4 viewMatrixDOWN() \n{\n return mat4(\n vec4(0, 0, 1, 0),\n vec4(1,0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0, 0, 1, 0)\n );\n}\n\nmat4 viewMatrixLEFT() \n{\n return mat4(\n vec4(1, 0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0,0, -1, 0),\n vec4(0, 0, 0, -1)\n );\n}\n\nmat4 viewMatrixUP() \n{\n return mat4(\n vec4(0,1, 0, 0),\n vec4(0, 0, 1,0),\n vec4(-1,0, 0,0),\n vec4(0, 0,0,1)\n );\n}\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = cameraPath(t);\n vec3 lightPos1 = vec3(cameraPos-vec3(0,1.,0.3));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);\n float dif1 = clamp(dot(n1, l1), 0., 1.);\n float d1 = RayMarch(p+n1*SURF_DIST*1., l1);\n if(d1<length(lightPos1-p)) dif1 *= 1.;  \n return (dif1)/1.0;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n float t = iTime * 0.3;\n vec2 res = iResolution.xy;\n vec2 frag = fragCoord.xy;\n vec2 uv = frag / res;\n vec3 rayDir;\n vec3 worldDir;    \n vec3 eye;\n vec4 fout;\n vec3  ro;  \n if( uv.x < 0.25)\n {\n  vec3 col;\n  frag = fragCoord.xy;\n  res = vec2(res.x *  .25, res.y);       \n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  vec3  ro = ( viewMatrixRIGHT() * vec4(rayDir,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 2.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+.8)); \n  fout = vec4(col,1.0);\n }\n else if(  uv.x > 0.25 && uv.x < 0.5 )\n {\n  vec3 col;\n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  0.25, res.y);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd = ( viewMatrixDOWN() * vec4(rd,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);  \n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);         \n } \n else if(  uv.x > 0.5 && uv.x < .75 )\n {\n  vec3 col;\n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  0.25, res.y);\n   vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));    \n  rd = ( viewMatrixLEFT() * vec4(rd,0.) ).xyz;     \n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;  \n  float dif = GetLightPos(p, ro);  \n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);\n }\n else if(  uv.x > 0.75 && uv.x < 1. )\n {\n  vec3 col;\n  float s = mod(iTime *0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  .25, res.y);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));       \n  rd = ( viewMatrixUP() * vec4(rd,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);\n }\n fragColor = vec4(fout);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 202, 202, 272], [307, 307, 338, 338, 391], [394, 394, 427, 427, 524], [526, 526, 560, 560, 691], [695, 695, 725, 725, 977], [981, 981, 1003, 1003, 1176], [1178, 1178, 1202, 1202, 1357], [1359, 1359, 1385, 1385, 1615], [1617, 1617, 1681, 1681, 1803], [1805, 1805, 1839, 1839, 1991], [1993, 1993, 2018, 2018, 2112], [2114, 2114, 2138, 2138, 2232], [2234, 2234, 2258, 2258, 2354], [2356, 2356, 2378, 2378, 2468], [2471, 2471, 2509, 2509, 2873], [2875, 2875, 2894, 2894, 2961], [2964, 2964, 3021, 3021, 6239]], "test": "untested"}
{"id": "tt3XWX", "name": "heart3♡♡♡", "author": "HaleyHalcyon", "description": "luvluv", "tags": ["spiral"], "likes": 1, "viewed": 161, "published": "Public", "date": "1581819347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n// this function makes the heart shape\nfloat distCustom(float x, float y)\n{\n    float n = -0.5 * abs(x) + y;\n    return log(\n        x * x + 1.5 * n * n\n    );\n}\n\nfloat fn(float x)\n{\n    return max(0.0, (sin(x * PI * 2.) + 0.4) * 0.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float speed = 3.0; //loop length\n    const vec3 color1 = vec3(1.0, 0.5, 0.8);\n    const vec3 color2 = vec3(0.3, 0.8, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    float distance = distCustom(uv.x, uv.y);\n    // float angle = atan(uv.y, uv.x);\n    \n    // Time varying pixel color\n    float c1 = 1.-fn(distance * 1.0 + iTime / speed + PI);\n    float c2 = fn(distance * 1.0 + iTime / speed * -2. + PI);\n\n    // Output to screen\n    fragColor = vec4(\n\t\tc1 * color1 + c2 * color2,\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3XWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 61, 97, 97, 183], [185, 185, 204, 204, 259], [261, 261, 318, 318, 1018]], "test": "untested"}
{"id": "tt3Xz7", "name": "KIFS experiments 7", "author": "rodgzilla", "description": "A slight modification on https://www.shadertoy.com/view/ttdXzN by smoothsteping the rotation speed.", "tags": ["kifs", "spikingrotation"], "likes": 1, "viewed": 207, "published": "Public API", "date": "1580638938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define ZPOS -50.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * cos(time * tempo) + .5;\n}\n\nvec3 palette(float x) {\n\n    vec3 a = vec3(1., .7, .7);\n    vec3 b = vec3(.8, 1., 1.);\n    vec3 c = vec3(1., .8, 1.);\n    vec3 d = vec3(1., 1., 1.);\n\n    return a + b * sin(2. * PI * (c + x * d));\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float it, float s, float tf, float ss) {\n    float t = tf * time;\n    t = floor(ss * t) + smoothstep(0., .8, fract(ss * t));\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(tf * t);\n        p.yz *= rot2d(tf * t + i);\n        p = abs(p);\n        p -= s;\n        s *= .8;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float d = 1000.;\n    vec3 pk1 = kifs(p, 2., 2., .5, 1.); \n    vec3 pk2 = kifs(pk1, 4., 1.5, .3, 2.);\n    vec3 pk3 = kifs(pk2, 8., 1.3, .2, .5);\n    \n    float sph1 = sph(pk1, 1.);\n    float sph2 = sph(pk2, 1.);\n    float sph3 = sph(pk3, 1.);\n  \td = min(d,\n            mix(\n                mix(\n                \tsph1, \n\t                sph2, \n    \t            wave(1.)\n       \t\t    ),\n                sph3,\n                wave(.3)\n        )\n    );   \n//    d = min(d, sph1);\n\n    return d;\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n        \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .001 || ds > 100.) {\n            break;\n        }\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 lp = vec3(2, 2, ZPOS);\n    vec3 n = normal(p);\n    vec3 tl = normalize(lp - p);\n    float dif = dot(tl, n);\n    float dl = rm(p + .01 * n, tl);\n    \n    if (dl < length(lp - p)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n  \tcol = dif * palette(.5 * cos(length(p) / 20. + .5) + p.z / 5.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Xz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 86, 86, 128], [130, 130, 153, 153, 328], [330, 330, 351, 351, 419], [421, 421, 479, 479, 747], [749, 749, 777, 777, 805], [807, 807, 826, 826, 1322], [1324, 1324, 1352, 1352, 1592], [1594, 1594, 1614, 1614, 1785], [1787, 1787, 1808, 1808, 2042], [2044, 2044, 2101, 2101, 2528]], "test": "untested"}
{"id": "ttcSD4", "name": "[TWITCH] The reaper's gallows", "author": "evvvvil", "description": "\"Les potences de la faucheuse\" (The reaper's gallows)\nResult of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["clouds", "demoscene", "light", "landscape", "tree", "fresnel", "point", "death", "twitch", "improv", "gloomy", "desolate", "reaper", "gallow"], "likes": 11, "viewed": 656, "published": "Public API", "date": "1581091586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Les potences de la faucheuse\" (The reaper's gallows)\n// Result of an improvised live coding session on Twitch\n\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Managing Grimsby Town Football Club makes me feel like Mary Poppins!\" - Ian Holloway, comical genius and current manager of Grimsby Town FC\n\n// ABRASIVE COMMENTS ARE BACK BY POPULAR DEMAND! (good to hear)\n// Those offended by swearing or shit jokes can go sit on a bag of sharp & pointy dicks!\n\nvec2 z,v,e=vec2(.035,-.035);float t,tt,g,bz,by,bb,tn;vec3 po,no,ld,al,np,bp,pp; //global vars: same old garbage brought to you in less that 3 characters\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive, because all you need is a box, a sphere, some sudafed pills and a fire proof trailer\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function, whether it's meth or pasta sauce, there ain't no cooking without stirring\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} // \"Smoothing out the merge\" just like when corporations takeover small companies but only fire the working class. (adds geomtry together with smooth blend)\nfloat smax(float d1,float d2,float k){float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);return mix(d2,-d1,h)+k*h*(1.0-h);}// \"Smoothing out the gape\" helps ease the pain of getting fucked by corporation above. (removes geometry from another with smooth blend)\nfloat noi(vec3 p){ // Noise function. Just like your manhood, it is rather small. (easy I know but I'm clutching at straws at this point. Wait... \"clutching at straws\"... Talking about your dick again? haha, get it?)\n  vec3 f=floor(p),s=vec3(7,157,113); //I don't really understand any of this, I'm too busy buying expensive vaporizers and pretenting to be that one hot girl match on your tinder\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat branch(vec3 p,float s,float y){ // we make trees out of branches, just like god made hipsters out of spite for the 90s\n  float t=length(p.xz)-0.6+y;//Make a branch out of an infinite cylinder (length(p.xz)-radius gives you a cylinder innit)\n  t=max(t,bo(p,vec3(10,s,10)));//Crop out the infinite cylinder into normal cylinder. Yeah, I could use a cylinder primitive function, but no I didn't memorize it. Some paths are best not taken drunk, such as cylinders.\n  return t;//No matter the scale, this branch is always bigger than your dick (ALWAYS end on a penis joke. Try it at your next family reunion...)\n}\nvec2 tree(vec3 p){ //Make tree with new position bp by pushing it in a loop. Then at different iterations moving, rotating, splitting. No joke on this line. This is a serious thing, unlike Manchester United football club.\n  bp=abs(p*.4-vec3(0,-7,10))-vec3(12,0,4); // Create new position bp to stick in da loop, we already abs symetery clone it to make 4 trees and shift the whole fucking thing a bit to be \"snug around the hole\" (thats' what she said)\n  vec2 h=vec2(1000,3); //setup the tree shape in vec2 to pass material id 3 = black colour. h.x should be, like me, and at all times, pretty fucking high.\n  for(int i=0;i<6;i++){ //loop da loop each iteration making new branch  and turning bit if i>1 then splitting as well. Nothing crazy clever just some pseudo fractal bullshit, but at least it's desolate.\n    h.x=min(h.x,branch(bp,2.3,p.y*.016)); //Draw one branch each iter 2.3 is length of branch\n    bp.y-=2.3; //2.3 is lngth of branch, fuck knows how i got there but this is prob to shift rotation axis point or branch center point\n    if(i>1) bp.x=abs(bp.x); //After second branch we start splitting, much like a good religious schism but without the drama of secatarian massacres\n    bp.xy*=r2(-0.2-float(i)*.1); //rotate exponentially each iteration. Look at me using big words like \"exponentionally\" without actually understanding them. Just like at my wedding bruv: completely fucking winging it.\n    bp.yz*=r2(0.1); bp.xz*=r2(0.1+float(i)*0.7); //Couple more rotates to make it more random tree-like, twisteroo the fuckeroo basically\n    bp.y-=2.2; //2.2 is length of branch little smaller to remove lines due to noise and junction shifting but still fuck knows how i got there but this is prob to shift rotation axis point or branch center point\n  }\n  return h;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}// We miss you on Twitch Luna... Sending some love.\nvec2 mp( vec3 p )\n{\n  p.z=mod(p.z+tt*10.,200.)-100.;  // Make it all infinite & moving forward, one liner desolate trains are go. Easier than convincing your flatmate it wasn't you singing \"Hit me baby one more time\" in the shower\n  tn=texNoise(0.07*vec2(p.z,dot(p.xy,vec2(.5)))).r;//Texture based noise to add layer of really nice detail to overall 3d noise from function which we gonna add to overall position, bare with me homeboy\n  pp=p; // remember the position at this point before adding the noise, in hindsight should have done it other way round but hey, hindsight is a bitch and you're still looking at my fake pic on tinder. Reality is also a bitch, I agree.\n  p+=noi(p)*.5+noi(p*.5)*.5+noi(p*.1)*4.+tn*.8+noi(p*0.05)*7.; //Adding all sorts of 3d noise from noise function the key is to add noise calls at different scales to make it natural terrain /rock like. The final touch is the texture based noise which costs but adds details tricky to recreate with just 3d noise\n  np=p;np.y*=0.7; //TERRAIN: we create a new position np based on noised out p for the three spheres (mountains) on the left hand side of terrain. What's better than a couple of balls? A trio of dangly frippy balls my friend.\n  np.xz-=vec2(60,20)+sin(p.z)*.4; // shift whole group of dangly balls, it's like teabagging but with numbers instead of your tongue (less fun, I know)\n  by=sin(p.y*.3-.5); //\"by\" is to deform balls along the y axis with sin, simple subtle displacement shit, unlike ageing which is a more complex displacement problem and cannot be avoided. Gravity is a bitch\n  vec2 h,t=vec2(length(np)-(15.-1.2*by),5); //Draw first ball on left. Don't worry, more balls incoming, we'll take it way past inuendo.\n  np-=vec3(-5,-7,20.); //shift the second ball back right and up a bit. With numbers I said, and just like when British people kiss: no tongues! (yeah the french are always right when it comes to love making)\n  t.x=smin(length(np)-(13.-1.*by),t.x,5.);//One more ball because we all are born with two, whether it's tits or balls.\n  np-=vec3(-10,4,20);//Shift again the last ball, this time with your tongue. Numbers ain't never gonna get you laid, no matter what the academia tries to prove.\n  t.x=smin(length(np)-(15.-1.6*by),t.x,5.); //third ball, yeah my virility complex is pushing me over the edge, a third ball is required. I should consider making babies, instagram could do with more posers.\n  bb=by-sin(p.z*.25);//Combo both \"by\" y-axis displacement and a new z-axis displacement into one variable bb to apply to all terrain objects.\n  t.x=smin(length(p+vec3(20,90,-30))-(80.-bb),t.x,5.); //Another sphere this time in the middle, ready to be pounded into a hole. What a slut!\n  t.x=smin(t.x,p.y+55.,25.); //We add an overall plane to the terrain to merge all the spheres together into a sexy surface, one so sexy that you might give up your innocence only just to touch it\n  t.x=smax(length(p.xz-vec2(-5,15))-(20.-bb),t.x,15.); //Dig a fucking hole into the terrain for the cave hole thing, smooth that shit out so that it doesn't hurt\n  t.x=smin(length(p+vec3(80,50,-100))-(80.-bb),t.x,5.); //one more Sphere mountain, right at back this time\n  t.x=smin(length(abs(p+vec3(0,65,-50))-vec3(70,0,0))-(55.-bb),t.x,5.); //Couple of mounts on the side of the hole. Man do i even need to make a dirty joke here? re-read the sentence, it's filthy. This shader is disgusting I'm not sure what you're still doing here.\n  t.x*=0.45; //Helps remove the artifact due to too much disortion. Yeah, I know, it's a bit much 0.45, I ain't gonna lie. But it looks shit otherwise and you should really have a decent gpu... Despite living at your parents, you're not a student anymore.\n  h=tree(p); t=t.x<h.x?t:h; //Yeah we make fucking trees. I know I couldn't make my children better looking but at least I can make desolate trees.\n  pp-=vec3(1,-5,40)+tn;//GALLOWS start here \"pp\" is gonna be the gallows' position of the gallows. \"Gallows start here\" good name for a post-brexit punk album.\n  pp.xz*=r2(2.5); //yeah we rotate gallows a bit because they ain't nuttin' like facing death head on\n  h=vec2(bo(pp,vec3(1.5,16,1.5)),3); //First tall box for gallows, like the excitement of laying the first stone of a cathedral, but it's for killing people, i know i know, still exciting.\n  h.x=min(h.x,bo(pp+vec3(0,-15,-5.5),vec3(1.5,1.5,7))); //Long box at top of gallows, pointing forward even though clearly, the only moving you're gonna do is dangling from the noose!\n  pp-=vec3(0,11,5); bp=pp;bp.yz*=r2(-0.788); //make new \"bp\" position and rotate that 45 degrees to make the underside 45 degree bit of gallows, \n  h.x=0.7*min(h.x,bo(bp,vec3(1.,1.,6))); //draw the underside of gallows call it the final piece to the reaper's christmas stocking\n  t=t.x<h.x?t:h; //Merge gallows and terrain together while retaining material ID (colour), like a company rebrand but with more colours and without \"Judgemental Jenny\" getting fired\n  pp-=vec3(0,-5,6.5)+tn+sin(p.y*30.)*0.02+sin(p.y*.1+tt)*(1.-abs(sin(p.y*.05))); // position for the rope, we make it sway with sin but taper out the influence so it is not moving at top, using this: (1.-abs(sin(p.y*.05))\n  h=vec2(0.7*bo(pp,vec3(0.2,10,0.2)),6); //ROPE: we draw the rope, has a bit of displacement to make it ropey, unlike your mad uncle who is a ropey geezer by default.\n  t=t.x<h.x?t:h; //Merge rope + gallows + terrain while retaining material ID. Like having sex with someone of different skin colour but the babies come out two tone as they retain material ID\n  h=vec2(0.3*length(p-vec3(-5,-60,15)-sin(p.z))-5.,6); //GLOWY CORE, \"Push a sphere inside the hole and make it glow!\" said the porn producer with a clipboard to the 2 bemused performers...\n  h.x=min(h.x,length(pp+vec3(0,10,0))); //DANGLY LITTLE GLOW SPHERE AT END OF ROPE: Because an actual bell-end wasn't subtle enough...\n  g+=0.1/(0.1+h.x*h.x*(.2-0.02*abs(sin(p.y*.2+tt*5.)))); //MAKE IT GLOW! Glow trick from Balkhan via Flopine & lsdLive. Big up Balkhan, flopine and lsdLive. Push object distance field into global \"g\" variable like this and add at the end see line 127\n  t=t.x<h.x?t:h; //Merge glowy bits with rest... Hey when you finally move out of your parents house, don't forget to retain material-fucking-ID, yeah?\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started there were no craft beer shops and boating shoes were for sailors.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft (get distance to geom)\n    if(h.x<.001||t.x>500.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>500.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime*1.25,56.4)+81.75; //MAin time variable, it's modulo'ed to avoid ugly artifact. Holding time in my hand: playing god is nearly as good as this crystal meth bag\n  vec3 ro=vec3(sin(tt*.1+0.9)*5.,7,-20)*mix(vec3(1),vec3(-3,-2,2),ceil(sin(tt*.5))),//Ro=ray origin=camera position\n  cw=normalize(vec3(0,cos(tt*.1)*5.,0)-ro), //cw camera forward?      \n  cu=normalize(cross(cw,vec3(0,1,0))), \t\t//cv camera up??\n  cv=normalize(cross(cu,cw)), \t\t\t\t//cu camera left vector??? Not sure broh, just like Greta Thunberg, I didn't go to school.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,lp; //rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  lp=vec3(0); lp.z=mod(lp.z-tt*10.,200.)-100.; //MODULO'ed POINT LIGHT. Best trick of this shader: make light pos modulo on z axis and to stop it from suddendly shifting pos, we make a light switch using sin of trime (line 120)\n  lp+=vec3(0,-20,15); //\"Stick the point light inside the hole!\" shouted the porn producer again, still holding his clipboard, to the even more baffled performers\n  v=vec2(abs(atan(rd.y-1.1,rd.x)),rd.z+tt*0.04); //Background spherical UVs to create cheap fake pseudo volumterics. Nice cheap dirty trick this, bit like your mad uncle trying to steal ice cream from kids.\n  co=fo=vec3(.1)+texNoise(0.4*v).r*.2-length(uv)*.14; //YA YA we make some pseudo cloud from noise texture function call. It's like reinventing the steam engine but without having to hang out with boring engineering nerds.\n  z=tr(ro,rd);t=z.x;//Trace the trace in the loop de loop. Aka sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you during your last bar fight\n    po=ro+rd*t; //Get da ray pos    \n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I ponder how likeable Holly Willoughby really is.\n    al=vec3(.7); //by default albedo is greyish\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    ld=normalize(lp-po);   //Point light direction shit \n    float ll=length(lp-po), attn=1.0-pow(min(1.0,ll/(100.*abs(sin(tt/6.3662)))),4.0); //abs(sin(tt/6.3662)) is light Switch - 6.3662 = 20/PI + 200/15 * PI * 0.01\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from Shane\n    co=mix(sp*.5+al*(a(.1)*a(1.)+0.1)*(dif+s(.4)),fo,min(fr,.4))*attn; //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0000005*t*t*t));//Fog soften things, and makes pseudo volumetrics, still though it won't save your marriage. Fucking your partner will.\n  }  \n  fragColor = vec4(pow(co+g*.1,vec3(0.45)),1);// Naive gamma correction, naive yes, but very small... LIKE YOUR DICK! (Told you to always end on a dick joke, no matter how cheap it is)\n} //Thank you and good night brooooooski", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[605, 678, 702, 702, 743], [744, 846, 863, 863, 906], [907, 1000, 1036, 1036, 1101], [1102, 1259, 1297, 1297, 1370], [1370, 1508, 1526, 1724, 2085], [2086, 2086, 2123, 2210, 2700], [2701, 2701, 2719, 2922, 4482], [4483, 4594, 4617, 4617, 4821], [4821, 4873, 4892, 4892, 11121], [11122, 11122, 11204, 11204, 11972], [12062, 12062, 12191, 12191, 15401]], "test": "untested"}
{"id": "ttcSzl", "name": "Spiral Colors", "author": "ferhatico", "description": "Shader sample.", "tags": ["beatycolor"], "likes": 1, "viewed": 85, "published": "Public", "date": "1581602144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 color=vec3(0.0);\n    \n    float aci=atan(-uv.y+0.5,uv.x-0.5)*0.1;\n    float uzun=length(uv-vec2(0.5,0.5));\n    color.r +=sin(uzun*50.0+aci*40.0+sin(iTime)*3.0);\n    color.g +=cos(uzun*50.0+aci*30.0+cos(iTime));\n    color.b +=tan(uzun*50.0+aci*30.0+cos(iTime));\n    \n    \n    \n \n\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 421]], "test": "untested"}
{"id": "ttcXD2", "name": "Multi-sampling Motion blur 3D", "author": "winlandiano", "description": "A moving ball in 3D space. Motion blurred by averaging the multi-sampling of past 24 frames.", "tags": ["motionblur", "multisampling"], "likes": 5, "viewed": 147, "published": "Public", "date": "1581711084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Ridge/winlandiano\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A moving ball in 3D space. Motion blurred by averaging the multi-sampling of past 24 frames.\n\n#define BACKGROUND vec3(0, 0.17, 0.19)\n#define SAMPLE_COUNT 24.\n#define DIRECTIONAL_LIGHT_TYPE 51\n\n#define INF 10000000000.0f\n#define PI 3.141592653589793\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n};\n\nstruct LightSource {\n    vec3 position;\n    float intensity;\n    vec3 color;\n    int type;\n};\n    \nstruct Intersection {\n    vec4 P;\n    vec3 N;\n    vec3 V;\n};\n\nfloat SphereIntersect(Ray r, vec3 center, float radius) {\n    // geometric method\n    vec3 L = center - r.origin;\n    float d = length(L);\n    float d2 = d * d;\n    float cos_theta = dot(normalize(L), r.direction);\n    float cos_theta2 = cos_theta * cos_theta;\n    if (cos_theta <= 0.) {\n        return INF;\n    }\n    float sin_theta2 = 1. - cos_theta2;\n    float r2 = radius * radius;\n    float intersect_half2 = r2 - d2 * sin_theta2;\n    if (intersect_half2 < 0.) {\n        return INF;\n    }\n    float center_project_dist = d * cos_theta;\n    float intersect_half = sqrt(intersect_half2);\n    float t0 = center_project_dist - intersect_half;\n    if (t0 < 0.) {\n        return center_project_dist + intersect_half;\n    } else {\n        return t0;\n    }\n}\n\n// ----------------  shading technics  ----------------\nvec3 Lambertian(vec3 N, LightSource light) {\n    return clamp(light.color * light.intensity * dot(N, -light.position), 0., 1.) + vec3(0.1);\n}\n\n// ----------------  shading technics ends  ----------------\nvec3 Render(Ray r, float time, LightSource light) {\n    vec3 col = vec3(0);\n\n    float angle = PI * cos(time) * 4.;\n    vec3 center = vec3(cos(angle), 0, 3. + sin(angle));\n    const float radius = 0.5;\n\n    float t_min = SphereIntersect(r, center, radius);\n\n    // only directional light\n    if (t_min < INF) {\n        vec4 P = vec4(r.origin + r.direction * t_min, 1.);\n        vec3 N = normalize(P.xyz - center);\n        col += Lambertian(N, light);\n    } else {\n        col = BACKGROUND;\n    }\n    return col;\n}\n\nCamera camera;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // Setup scene\n    LightSource light = LightSource(normalize(vec3(-1, -1, 1)), 1., vec3(1, 1, 1), DIRECTIONAL_LIGHT_TYPE);\n    camera = Camera(vec3(0, 0, 0));\n\n    Ray r = Ray(camera.position, normalize(vec3(uv, 1)));\n\tvec3 col = vec3(0);\n    float dt = iTimeDelta / 10.;\n    for (float time = iTime - dt * SAMPLE_COUNT; time <= iTime; time += dt) {\n        col += Render(r, time, light);\n    }\n    col /= SAMPLE_COUNT;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcXD2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1083, 1590, 1647, 1671, 2345], [2347, 2403, 2447, 2447, 2544], [2546, 2607, 2658, 2658, 3120], [3138, 3138, 3193, 3243, 3767]], "test": "untested"}
{"id": "ttcXRB", "name": "Messed up starfield", "author": "nucleomancer", "description": "I followed Matthijs description. (https://www.youtube.com/watch?v=rvDo9LvfoVE&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=31)\nBut I clearly messed up somewhere. Don't know exactly what went wrong. But it must have its features for someone.", "tags": ["zoom", "space", "stars", "martijn"], "likes": 6, "viewed": 153, "published": "Public", "date": "1581194107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_LAYERS 10.\nmat2 Rotate(float angle) {\n\tfloat s = sin(angle*3.14159265/180.), c = cos(angle*3.14159265/180.);\n    return mat2(c,-s,s,c);\n}\n\n// Returns a psuedo random number.\nfloat Hash21(vec2 p) {\n    vec2 result = fract(p*vec2(123.456, 427.123));\n    result += dot(p, p+.12)*0.023;\n    return fract(result.x*result.y);\n}\n\nfloat Star(vec2 uv, float flare, float r) {\n    float d = length(uv);\n    float result = .01/d; //smoothstep(0.2, .05, d);\n    \n    if (flare>0.) {\n    for (float x=0.;x<2.;x++) {\n        uv *= Rotate(x*(237.*r));\n        float rays2 = max(0.0, 1.-abs(uv.x*uv.y*1500.));    \n        result += rays2*.1*flare;\n    }\n    }\n    \n    result *= smoothstep(1.0, 0.2, d);\n    \n    return result;\n}\n\nvec3 StarLayer(vec2 uv) {\n    // Time varying pixel color\n    vec3 result = vec3(0);\n    \n    vec2 grid_uv = fract(uv)-0.5;\n    vec2 id = floor(uv); // Identify each square.\n    \n    for (int y=-1;y<=1;y++) {\n        for (int x=-1;x<=1;x++) {\n            vec2 offset = vec2(x,y);\n            vec2 local_id = id+offset;\n            float n = Hash21(local_id)-0.5;\n            float size = 5.*(fract(n*1247.238));\n            vec3 color = (sin( vec3(.7,.3,.9) * fract(n*222.112)*347.)*.5)+.5;\n            color *= vec3(1.,0.5,1.+size/5.);\n\t\t    result += color*Star(grid_uv-offset-vec2(n,fract(n*34.)-.5), smoothstep(0.8, 1., size), 17.*(fract(n*873.43)-0.2))*size;            \n        }\n    }\n\treturn result;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*.5;\n    // Zoom out\n    uv *= 3.;\n\n//    if (grid_uv.x>0.49 || grid_uv.y>0.49) {\n//        col.r = 1.;\n//    }\n//    col.rg += id*0.4;\n//    col.rg = grid_uv;\n//    col += Hash21(id);\n    vec3 col = vec3(0);\n    uv *= Rotate(6.*t);\n    \n    for (float i=0.; i<=1. ; i+=1./NUM_LAYERS) {\n//    float i = 1.;\n        float depth = fract(i*t);\n        float scale = mix(20., 0.15, depth);\n        float fade = depth;\n    \tcol += StarLayer(uv*(scale-(i*7.1232)))*fade;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 49, 49, 149], [151, 186, 208, 208, 333], [335, 335, 378, 378, 725], [727, 727, 752, 784, 1440], [1442, 1442, 1499, 1549, 2160]], "test": "untested"}
{"id": "ttcXWX", "name": "Box - parametrization", "author": "iq", "description": "Space parametrization of a rounded box, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are slightly distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 16, "viewed": 645, "published": "Public API", "date": "1581855631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a rounded box. Or could also be called\n// \"rounded box\" coordinates.\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat msign( in float x ) { return (x<0.0)?-1.0:1.0; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paBox( in vec2 p, \n            in vec2 b, in float r, \n            in float s )\n{\n    vec2 q = abs(p)-b;\n        \n    float l = b.x+b.y + 1.570796*r;\n    \n    float k1 = min(max(q.x,q.y),0.0) + length(max(q,0.0))-r;\n    float k2 = ((q.x>0.0)?atan(q.y,q.x):1.570796);\n    float k3 = 3.0 + 2.0*msign(min(p.x,-p.y)) - msign(p.x);\n    float k4 = msign(p.x*p.y);\n    float k5 = r*k2+max(-q.x,0.0);\n    \n    float ra = s*round(k1/s);\n    \n    float l2 = l + 1.570796*ra;\n\n    return vec4(k1-ra,\n                k3*l2+k4*(b.y+((q.y>0.0)?k5+k2*ra:q.y)),\n                4.0*l2,\n                k1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n\n    // animate segment\n    float id = floor((iTime+0.1)/3.0);\n    vec2  si = vec2(0.35,0.15) + 0.1*cos( vec2(1,2) + id*vec2(3,1) );\n    float ra = 0.15 + 0.05*sin(id*0.2);\n    \n    // distance and parametrization    \n    const float band = 0.1;\n    vec4 b = paBox( p, si, ra, band );\n\n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/band)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/band+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    // circles\n    if( d>-band*0.5 )\n    {\n\tvec2 q = b.xy;\n    q.y *= floor(b.z/band)*(band/b.z);  // optional - ensure periodicity, but break physicallity\n    q.y -= iTime*0.1;                   // animate circles\n    \n    vec2 uv = fract(q/band+0.5)-0.5;    // draw circles\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcXWX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1176, 1259, 1286, 1286, 1313], [1315, 1419, 1505, 1505, 2016], [2018, 2018, 2075, 2104, 3227]], "test": "untested"}
{"id": "ttdSW7", "name": "Rolling Shutter Affect", "author": "funnbot", "description": "Rolling shutter affect.", "tags": ["shutter", "rolling"], "likes": 2, "viewed": 57, "published": "Public", "date": "1581123067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RES 10.\n#define DELAY 50.\n#define SPH_RAD 80.\n#define ROT_RAD 100.\n#define SPEED 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float grad = DELAY*floor(RES*(1.0 - uv.y))*1.0/RES;\n    vec2 coord = (fragCoord - iResolution.xy*0.5) + ROT_RAD*vec2(cos(SPEED*iTime+grad), sin(SPEED*iTime+grad));\n    float sphere = step(coord.x * coord.x + coord.y * coord.y, SPH_RAD * SPH_RAD);\n    \n\n    // Output to screen\n    fragColor = vec4(sphere*uv,0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdSW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 152, 202, 564]], "test": "untested"}
{"id": "ttdXWj", "name": "shader(h')art", "author": "ordiology", "description": "This Valentine's Day heart is my first shader project. It uses the circle from the Book of Shaders' Pixel Spirit Deck and the first chapters of the Book of Shaders as well as the concept of building a heart by @The_ArtOfCode.", "tags": ["heart", "valentine", "shaderart"], "likes": 1, "viewed": 69, "published": "Public", "date": "1581742487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Dr Ord (@ordiology)\n// Title: shader(h')art\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//\n// This Valentine's Day heart art project uses the circle from \n// the Book of Shaders' Pixel Spirit Deck as well as knowledge\n// gained from the first chapters of the Book of Shaders and \n// the concept of building a heart manipulating a circle from\n// @The_ArtOfCode's \"Making a Heart in ShaderToy\" YouTube video.\n//\n// Please feel free to use the concepts and code but reference\n// the relevant sources appropriately.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TAU 6.28318530718\n\nuniform vec2 u_resolution; // Canvas size (width,height)\nuniform float u_time; // Time in seconds since load\n\nvec3 colorA = vec3(0.8000000, 0.0000000, 0.5058824);\nvec3 colorB = vec3(0.3686275, 0.9019608, 0.7686275);\n\n// 08 circleSDF (from @bookofshaders Pixel Spirit Deck)\nfloat circleSDF(vec2 st){\n    return length(st - 0.5)*2.0;\n}\n\n// Shader(h')art heart (uses concept from @The_ArtOfCode)\n// Deps 08\nfloat heart(vec2 st){\n    st.y *= 1.;\n    st.y -= sqrt(abs(st.x-0.5))*0.5-0.1;\n    float r = circleSDF(st);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = vec3(0.0);\n    vec2 st = fragCoord.xy/\n              iResolution.xy;\n\n    float t = iTime;\n\n    // Shader(h')art\n    float size = .64;\n    float blur = 0.005;\n    for (int i = 1; i < 28; i++){\n        color += smoothstep(size -= blur, size -= blur, length(heart(st)));\n        color -= smoothstep(size -= blur, size -= blur, length(heart(st)));\n    }\n\n    // Mix the two colors in y-space\n    vec3 colorC = mix(colorA, colorB, sin(st.y));\n    vec3 colorD = mix(colorB, colorA, sin(st.y));\n\n    // Oscillate the colours over the heart fragment\n    color = mix(colorC, colorD, sin(t)*(color-0.5)+ 0.5);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXWj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[840, 896, 921, 921, 956], [958, 1027, 1048, 1048, 1150], [1152, 1152, 1209, 1209, 1862]], "test": "untested"}
{"id": "ttdXzN", "name": "KIFS experiments 6", "author": "rodgzilla", "description": "Applying KIFS recursively and mixing different recursion depth space.", "tags": ["raymarching", "kifs", "recursion"], "likes": 1, "viewed": 265, "published": "Public API", "date": "1580564033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define ZPOS -50.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * cos(time * tempo) + .5;\n}\n\nvec3 palette(float x) {\n\n    vec3 a = vec3(1., .7, .7);\n    vec3 b = vec3(.8, 1., 1.);\n    vec3 c = vec3(1., .8, 1.);\n    vec3 d = vec3(1., 1., 1.);\n\n    return a + b * sin(2. * PI * (c + x * d));\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float it, float s, float tf) {\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(tf * time);\n        p.yz *= rot2d(tf * time + i);\n        p = abs(p);\n        p -= s;\n        s *= .8;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    float d = 1000.;\n    vec3 pk1 = kifs(p, 2., 2., .5); \n    vec3 pk2 = kifs(pk1, 4., 1.5, .3);\n    vec3 pk3 = kifs(pk2, 8., 1.3, .2);\n    \n    float sph1 = sph(pk1, 1.);\n    float sph2 = sph(pk2, 1.);\n    float sph3 = sph(pk3, 1.);\n  \td = min(d,\n            mix(\n                mix(\n                \tsph1, \n\t                sph2, \n    \t            wave(1.)\n       \t\t    ),\n                sph3,\n                wave(.3)\n        )\n    );   \n\n    return d;\n}\n\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n        \n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .001 || ds > 100.) {\n            break;\n        }\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p) {\n\tvec3 lp = vec3(2, 2, ZPOS);\n    vec3 n = normal(p);\n    vec3 tl = normalize(lp - p);\n    float dif = dot(tl, n);\n    float dl = rm(p + .01 * n, tl);\n    \n    if (dl < length(lp - p)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n  \tcol = dif * palette(.5 * cos(length(p) / 20. + .5) + p.z / 5.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 86, 86, 128], [130, 130, 153, 153, 328], [330, 330, 351, 351, 419], [421, 421, 469, 469, 659], [661, 661, 689, 689, 717], [719, 719, 738, 738, 1198], [1200, 1200, 1228, 1228, 1468], [1470, 1470, 1490, 1490, 1661], [1663, 1663, 1684, 1684, 1918], [1920, 1920, 1977, 1977, 2404]], "test": "untested"}
{"id": "ttG3Rt", "name": "sierpinski triangle generator", "author": "DolfinShark", "description": "generate the sierpinski triangle", "tags": ["fractal"], "likes": 2, "viewed": 283, "published": "Public API", "date": "1580557682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926536;\nconst float tau = 6.2831853071;\nconst float sqrt3 = 1.7320508076;\n\n\nfloat distToTriangle(in vec2 p) {\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1. / sqrt3;\n    \n    if(p.x + sqrt3* p.y > 0.)\n        p = vec2(p.x - sqrt3 * p.y, -sqrt3 * p.x - p.y) * .5;\n    \n    p.x -= clamp(p.x, -2., 0.);\n    \n    return -length(p) * sign(p.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float angle = tau / 3.;\n    angle = tau / (3. + sin(iTime * 0.1));\n    \n    uv *= 3.;\n    for(int i = 0; i < 4; i++) {\n        uv *= 2.;\n        uv.x = abs(uv.x);\n        \n        vec2 n = vec2(cos(angle), sin(angle));\n        uv -= 2. * n * min(0., dot(uv, n));\n        \n        uv.y -= 2. * tan(pi / 6.);\n    }\n    \n    float d = distToTriangle(uv);\n    d = smoothstep(1. / iResolution.y, 0., d);\n\n    fragColor = vec4(d, d, d, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttG3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 132, 132, 361], [364, 364, 418, 418, 929]], "test": "untested"}
{"id": "ttGSW1", "name": "Other 2D Wave Shader", "author": "Clipsey", "description": "An other simple 2D wave shader", "tags": ["2d"], "likes": 3, "viewed": 102, "published": "Public", "date": "1582585936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float genWave(float x) {\n\treturn (\n        (\n            sin(\n                (x/70.0)+\n                (iTime)\n            ) * 30.0\n        ) * (sin(iTime)/2.0)\n    ) + (\n        sin(iTime)*30.0\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float halfPoint = iResolution.y/2.0;\n    float waveStep = iResolution.y/8.0;\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n\tfloat waveHeightX = genWave(fragCoord.x);\n\tfloat waveHeightY = genWave(fragCoord.x+(iResolution.x/8.0));\n\tfloat waveHeightZ = genWave(fragCoord.x);\n\n\tfloat waveHeightA = halfPoint+waveHeightX;\n\tfloat waveHeightB = (halfPoint-waveStep)+waveHeightY;\n\tfloat waveHeightC = (halfPoint-(waveStep*2.0))+waveHeightZ;\n\n    if (fragCoord.y < waveHeightC) {\n\t\tfragColor = vec4(uv.y+0.2, uv.y+0.2, uv.y+0.5, 1.0);\n    } else if (fragCoord.y < waveHeightB) {\n\t\tfragColor = vec4(uv.y, uv.y, uv.y+0.4, 1.0);\n    } else if (fragCoord.y < waveHeightA) {\n\t\tfragColor = vec4(uv.y-0.2, uv.y-0.2, uv.y+0.2, 1.0);\n    } else {\n\t\tfragColor = vec4(0.4, 0.4, 0.8, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 204], [206, 206, 263, 263, 1039]], "test": "untested"}
{"id": "ttGSzh", "name": "Blue Effect", "author": "Zefraine", "description": "asdasd", "tags": ["blue"], "likes": 3, "viewed": 46, "published": "Public", "date": "1582168322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(3,3,3);\n\tcol.r = sin(iTime*uv.x);\n    //col.g = cos(iTime*uv.y);\n    col.g = tan(uv.y+uv.x*iTime*50.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 361]], "test": "untested"}
{"id": "ttGSzR", "name": "King Crown", "author": "kuyuri_iroha", "description": "hazy", "tags": ["3d", "raymarch"], "likes": 4, "viewed": 106, "published": "Public", "date": "1582297611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LOOP_MAX 216\n#define EPS 1e-4\n#define HORIZONTAL_AA 1\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sim(x, y) (abs(x - y) < EPS)\n\nconst float PI = acos(-1.0);\nconst float PI2 = PI * 2.0;\n\nvec2 uv = vec2(0.0, 0.0);\nconst vec3 dLight = normalize(vec3(0.2, 0.1, -0.5));\nconst vec3 pLight = vec3(0.0, 0.0, 0.6);\n\n// https://thebookofshaders.com/10/?lan=jp\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860\nmat2 rot(float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + PI/r;\n    float n = PI2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat cappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 repLim2(vec3 p, vec3 c, vec3 l)\n{\n    return p - c * clamp(round(p / c), -l, l);\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nfloat centerMap(vec3 p) {\n    vec3 centerP = p + vec3(0.0, -0.04, -0.6);\n\n    centerP.xz = centerP.xz * rot(iTime * PI * -0.4);\n    centerP.xz = centerP.xz * rot(PI * 4.0 * centerP.y);\n    centerP.xz = pmod(centerP.xz, 8.0) * 0.1;\n    centerP.z -= 0.05 * (1.8 - abs(centerP.y) / 0.1) * 0.1;\n    \n    return box(centerP, vec3(0.001, 0.2, 0.001));\n}\n\nfloat coreMap(vec3 p) {\n    vec3 coreP = p + vec3(0.0, -0.04, -0.6);\n    \n    coreP.xz = coreP.xz * rot(iTime * PI * 0.2);\n    \n    return octahedron(coreP, 0.05);\n}\n\nfloat map(vec3 p) {\n    vec2 seedP = p.xz;\n    seedP += vec2(EPS, 0.5);\n    vec2 seed = vec2(floor(seedP.x), floor(seedP.y + EPS));\n    \n    vec3 sphereP = p;\n    float sphereC = 0.6;\n    sphereP.xz += vec2(sphereC * 0.5, -0.3);\n    sphereP = repLim2(vec3(sphereP), vec3(sphereC, 0.0, 1.0), vec3(1.0, 1.0, 3.0));\n    sphereP.y -= mod(iTime * 0.6 - random(seed) * 5.0, 3.0);\n    sphereP.y += 0.5;\n    \n    vec3 pillarP = p;\n    float pillarC = 0.8;\n    pillarP.z -= 0.3;\n    pillarP.x = abs(pillarP.x) - 0.7;\n    pillarP.z = mod(pillarP.z + 0.5 * pillarC, pillarC) - 0.5 * pillarC - 0.2;\n    \n    vec3 dentP = pillarP;\n    dentP.y -= 0.94;\n    dentP.xz = pmod(dentP.xz, 20.0);\n    dentP.z -= 0.1;\n\n    float sphereDE = sphere(sphereP, 0.05);\n    float pillarDE = cappedCylinder(pillarP, 0.1, 1.1);\n    float dentDE = box(dentP, vec3(0.004, 1.1, 0.01));\n    float planeDE = dot(p, vec3(0.0, 1.0, 0.0)) + 0.2;\n    \n    float milk = fOpUnionRound(sphereDE, planeDE, 0.07);\n    float pillars = fOpUnionStairs(planeDE, max(-dentDE, pillarDE), 0.07, 5.0);\n    float center = min(centerMap(p), coreMap(p));\n    return min(min(milk, pillars), center);\n}\n\nvec3 norm(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS, 0.0, 0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3(0.0, -EPS, 0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3(0.0, 0.0, -EPS))\n    \t));\n}\n\nfloat fog(float depth) {\n    float density = 0.6;\n    return 1.0 - saturate(1.0 / exp(pow(density * depth, 2.0)));\n}\n\nfloat ao(vec3 p, vec3 n, float amp, float len) {\n\tfloat amt = 0.0;\n    for(int i = 0; i < 4; i++) {\n    \tp = p + len * n;\n        amt += amp * saturate(map(p) / len);\n        amp *= 0.5;\n        len += 0.02;\n    }\n    return amt;\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softShadow(vec3 p, vec3 light) {\n    float minDist = 1e-6;\n    float maxDist = 10.0;\n    \n    float sharpness = 35.0;\n    \n    float s = 1.0;\n    float ph = 1e20;\n    float dist = minDist;\n    for(int i = 0; i < 32; i++) {\n    \tfloat st = centerMap(p + light * dist);\n        \n        float y = (i == 0) ? 0.0 : st * st / (2.0 * ph);\n        float d = sqrt(st * st - y * y);\n        s = min(s, sharpness * d / max(0.0, dist - y));\n        \n        ph = st;\n        dist += st;\n        \n        if(s < 1e-6 || maxDist < dist) {\n        \tbreak;\n        }\n    }\n    \n    return 1.0 - max(s, 0.0);\n}\n\nvec3 objMat(vec3 rp) {\n    vec3 no = norm(rp);\n    vec3 dpl = normalize(pLight - rp);\n    float ipl = distance(pLight, rp);\n    \n    vec3 albedo = vec3(0.4);\n    float pDiff = saturate(dot(dpl, no)) * (1.0 / (ipl * 1.5));\n    float shadow = softShadow(rp, dpl);\n    float a = ao(rp, no, 0.5, 0.01) * 0.7 + 0.5;\n    return (albedo + pDiff * 0.2) * a * (mix(0.6, 0.5, shadow) * (1.0 / (ipl * 3.0)));\n}\n\nvec3 centerMat(vec3 rp) {\n\tvec3 no = norm(rp);\n    vec3 invDLight = dLight * -1.0;\n    vec3 dpl = normalize(pLight - rp);\n    float ipl = distance(pLight, rp);\n    \n    vec3 albedo = vec3(0.15);\n    float dif = saturate(dot(invDLight, no));\n    float pDiff = saturate(dot(dpl, no)) * (1.0 / ipl);\n    float a = ao(rp, no, 1.8, 0.07) * 0.8 + 0.5;\n    return (albedo + dif * pDiff * 2.0) * (1.0 - a);\n}\n\nvec3 coreMat(vec3 rp) {\n\tvec3 no = norm(rp);\n    vec3 invDLight = dLight * -1.0;\n    \n    vec3 albedo = vec3(1.3);\n    float dif = saturate(dot(invDLight, no));\n    return albedo + dif;\n}\n\nvec3 skyMat() {\n    return mix(vec3(0.13), vec3(0.0), uv.y * 0.5);\n}\n\nvec3 march(vec3 ro, vec3 rd, out vec3 rp, out float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    for(int i = 0; i < LOOP_MAX; i++) {\n        rp = ro + rd * depth;\n        float dist = map(rp);\n        \n        if(abs(dist) < EPS) {\n            if(sim(dist, centerMap(rp))) {\n                col = centerMat(rp);\n            }\n            else if(sim(dist, coreMap(rp))) {\n                col = coreMat(rp);\n            }\n            else {\n                col = objMat(rp);\n            }\n            break;\n        }\n        else {\n        \tcol = skyMat();\n        }\n        \n        depth += dist;\n    }\n    return col;\n}\n\nvec3 render(vec2 p) {\n    float fov = 80.0 * 0.5 * PI / 180.0;\n    vec3 cp = vec3(0.0, 0.01, -0.7);\n    vec3 cd = normalize(vec3(0.0) - cp);\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cs, cd));\n    float td = 1.0 / tan(fov / 2.0);\n    \n    vec3 ro = cp;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * td);\n    vec3 rp = vec3(0.0);\n    \n    vec3 col = vec3(0.0);\n    float depth = 1.0;\n    col += march(ro, rd, rp, depth);\n    \n    return mix(col, skyMat(), fog(depth));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3(0.0);\n    for(int x = 0; x < HORIZONTAL_AA; x++)\n    {\n        vec2 delta = vec2(float(x - HORIZONTAL_AA / 2), 0.0) * 1e-3;\n        col += render(uv + delta);\n    }\n\n    fragColor = vec4(col / float(HORIZONTAL_AA), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 361, 385, 385, 492], [494, 553, 572, 572, 638], [640, 640, 668, 668, 775], [777, 848, 881, 881, 905], [907, 907, 957, 957, 1064], [1066, 1066, 1104, 1104, 1153], [1155, 1155, 1184, 1184, 1271], [1273, 1273, 1309, 1309, 1362], [1364, 1395, 1443, 1443, 1528], [1530, 1626, 1684, 1684, 1795], [1797, 1797, 1822, 1822, 2144], [2146, 2146, 2169, 2169, 2311], [2313, 2313, 2332, 2332, 3457], [3459, 3459, 3478, 3478, 3725], [3727, 3727, 3751, 3751, 3843], [3845, 3845, 3893, 3893, 4076], [4078, 4119, 4157, 4157, 4720], [4722, 4722, 4744, 4744, 5121], [5123, 5123, 5148, 5148, 5523], [5525, 5525, 5548, 5548, 5712], [5714, 5714, 5729, 5729, 5782], [5784, 5784, 5844, 5844, 6422], [6424, 6424, 6445, 6445, 6943], [6946, 6946, 7003, 7003, 7335]], "test": "untested"}
{"id": "ttGXDh", "name": "Scrolling 2D \"Waves\"", "author": "Clipsey", "description": "Simple 2D waves, quickly hacked together utilizing the simplex noise function which was found here: https://www.shadertoy.com/view/4tSGDy\n", "tags": ["2d"], "likes": 4, "viewed": 105, "published": "Public", "date": "1582584288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Utilizing simplex noise function from https://www.shadertoy.com/view/4tSGDy\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n// Some simple 2d scrolling \"waves\"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat pos = fragCoord.x/120.0;\n\tfloat posOct = fragCoord.x/100.0;\n\tfloat timeStep = iTime/10.0;\n\n\t// Create lines by using the simplex noise\n    float noiseA = simplex3D(vec3(pos+timeStep, pos, timeStep));\n    float noiseB = simplex3D(vec3(-(posOct+timeStep), posOct, -timeStep));\n\n\t// Scale the noise to be more approriate\n    float scaledNoiseA = (noiseA+1.0)/2.0;\n    float scaledNoiseB = (noiseB+1.0)/2.0;\n\n\t// Get the noise with the octaves applied\n\tfloat octNoise = scaledNoiseA*scaledNoiseB;\n\n    fragColor = vec4(octNoise, octNoise, octNoise+0.2, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 102, 102, 183], [185, 185, 210, 210, 2335], [2337, 2373, 2430, 2430, 2994]], "test": "untested"}
{"id": "tttSzs", "name": "Menger Sponge Raytraced", "author": "phi16", "description": "raytracing menger sponge by tree traversal / cyclic camera motion (simply a loop)", "tags": ["raytrace"], "likes": 11, "viewed": 429, "published": "Public API", "date": "1581597651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 dmin(vec4 x, float y, vec3 n) {\n\tif(x.w < 0.0) return vec4(n,y);\n    else if(y < 0.0) return x;\n    return x.w < y ? x : vec4(n,y);\n}\nfloat square(vec3 p, vec3 v) {\n    if(p.z < 0.0 || v.z > 0.0) return -1.0;\n    float t = - p.z / v.z;\n    vec3 c = p + v * t;\n    if(abs(c.x) < 1.0 && abs(c.y) < 1.0) return t;\n    else return -1.0;\n}\nvec4 cube(vec3 p, vec3 v, float flip) {\n\tvec4 dist = vec4(-1);\n    vec3 u = vec3(0,0,1) * flip;\n    dist = dmin(dist, square(p.xyz-u,v.xyz), vec3(0,0,1));\n    dist = dmin(dist, square(p.zxy-u,v.zxy), vec3(0,1,0));\n    dist = dmin(dist, square(p.yzx-u,v.yzx), vec3(1,0,0));\n    dist = dmin(dist, square(-p.xyz-u,-v.xyz), vec3(0,0,-1));\n    dist = dmin(dist, square(-p.zxy-u,-v.zxy), vec3(0,-1,0));\n    dist = dmin(dist, square(-p.yzx-u,-v.yzx), vec3(-1,0,0));\n    return dist;\n}\n\nvec3 scene(vec3 p, vec3 v) {\n    vec3 empty = vec3(0.1);\n    vec4 t;\n    int count = 0;\n    ivec3 l = ivec3(0);\n    bool hole = false;\n    if(abs(p.x) < 1. && abs(p.y) < 1. && abs(p.z) < 1.) {\n        for(int i=0;i<18;i++) {\n            vec3 c = p;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), 0, 2);\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n            ivec3 u = e;\n            hole = false;\n            if(u.x == 1 && u.y == 1) hole = true;\n            if(u.y == 1 && u.z == 1) hole = true;\n            if(u.z == 1 && u.x == 1) hole = true;\n            if(hole) break;\n        }\n    }\n    for(int i=0;i<18;i++) {\n        if(!hole) {\n            t = cube(p,v,1.);\n            if(t.w < 0.) return empty;\n            vec3 c = p + v * t.w;\n            ivec3 e = clamp(ivec3(c * 3. / 2. + 1.5), ivec3(0), ivec3(2));\n            l = l * 3 + e;\n            vec3 o = vec3(e - 1) * 2.0 / 3.0;\n            p = (p - o) * 3.0;\n            count++;\n        } else {\n            t = cube(p,v,-1.);\n            if(t.w < 0.) return empty;\n            for(int j=0;j<10;j++) {\n                ivec3 e = (l%3+3)%3;\n                bool up = false;\n                if(t.x < -0.5 && e.x == 2) up = true;\n                if(t.y < -0.5 && e.y == 2) up = true;\n                if(t.z < -0.5 && e.z == 2) up = true;\n                if(t.x > 0.5 && e.x == 0) up = true;\n                if(t.y > 0.5 && e.y == 0) up = true;\n                if(t.z > 0.5 && e.z == 0) up = true;\n                if(up) {\n                    vec3 o = vec3(e - 1) * 2.0 / 3.0;\n                    p = p / 3.0 + o;\n                    l /= 3;\n                    count--;\n                    if(count == 0) return empty;\n                } else break;\n            }\n            l -= ivec3(t.xyz);\n            p += t.xyz * 2.;\n        }\n        ivec3 u = l%3;\n        hole = false;\n        if(u.x == 1 && u.y == 1) hole = true;\n        if(u.y == 1 && u.z == 1) hole = true;\n        if(u.z == 1 && u.x == 1) hole = true;\n        if(count >= 7) break;\n    }\n    vec3 wp = (p+v*t.w) / pow(3.,7.); // what\n    vec3 lv = normalize(vec3(-1,2,-0.5));\n    return (wp*0.3+0.7) * (normalize(t.xyz)*0.3+0.7) * (dot(t.xyz,lv)*0.5+0.5);\n}\n\nvec3 image(vec2 uv) {\n    vec3 dir = normalize(vec3(uv*0.7,-1));\n    float vignetting = pow(mix(-dir.z,1.,0.5),10.0)*3.0;\n    float gt = iTime/2.;\n    \n    // Uniform Catmull-Rom spline\n    vec3 p0 = vec3(0,5,2);\n    vec3 p1 = vec3(0,0,1);\n    vec3 p2 = vec3(0,1./3.,-2./3.);\n    vec3 p3 = vec3(0,8./9.,-5./9.);\n    float t = fract(gt);\n    float a = 0.0;\n    float t0 = 0.;\n    float t1 = pow(distance(p0,p1),a) + t0;\n    float t2 = pow(distance(p1,p2),a) + t1;\n    float t3 = pow(distance(p2,p3),a) + t2;\n    float tt = mix(t1,t2,t);\n    vec3 a1 = ((t1-tt)*p0 + (tt-t0)*p1) / (t1-t0);\n    vec3 a2 = ((t2-tt)*p1 + (tt-t1)*p2) / (t2-t1);\n    vec3 a3 = ((t3-tt)*p2 + (tt-t2)*p3) / (t3-t2);\n    vec3 b1 = ((t2-tt)*a1 + (tt-t0)*a2) / (t2-t0);\n    vec3 b2 = ((t3-tt)*a2 + (tt-t1)*a3) / (t3-t1);\n    vec3 c  = ((t2-tt)*b1 + (tt-t1)*b2) / (t2-t1);\n    vec3 eye = c;\n    float r = t*3.1415926535/2. - 0.1;\n    dir.yz *= mat2(cos(r),-sin(r),sin(r),cos(r));\n   \n    float m = floor(gt)*3.1415926535/2.;\n    eye.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    dir.yz *= mat2(cos(m),-sin(m),sin(m),cos(m));\n    return scene(eye,dir) * vignetting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y*2.;\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++) {\n        for(int j=0;j<2;j++) {\n            col += image(uv + vec2(i,j)/iResolution.y/2.) / 4.;\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 138], [139, 139, 169, 169, 339], [340, 340, 379, 379, 817], [819, 819, 847, 847, 3088], [3090, 3090, 3111, 3111, 4225], [4227, 4227, 4284, 4284, 4541]], "test": "untested"}
{"id": "tttXRB", "name": "Triangle Waves", "author": "xjorma", "description": "Triangle waves, lunch break shader.\nhttps://twitter.com/InfinityLoopGIF/status/1217908945421066240\n", "tags": ["2d", "hypnotic", "reproduction", "illuminati"], "likes": 19, "viewed": 418, "published": "Public API", "date": "1581355828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define TAU radians(360.)\n\n//#define AUDIOREACT\n\nconst float nbCircle = 13.; \n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat udTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ab = b - a; vec2 pa = a - p;\n  vec2 bc = c - b; vec2 pb = b - p;\n  vec2 ca = a - c; vec2 pc = c - p;\n    \n  float d0 = dot(perp(ab), pa);\n  float d1 = dot(perp(bc), pb);\n  float d2 = dot(perp(ca), pc);\n    \n  return min(min(d0, d1), d2);\n}\n\nfloat sdfTriangle(vec2 p)\n{\n    float radius = 1.2;\n    float angle = iTime * 0.8;\n    vec2 a = rotate( angle, radius);\n    vec2 b = rotate( TAU / 3. + angle, radius);\n    vec2 c = rotate( 2. * TAU / 3. + angle, radius);\n    \n    return udTriangle(p, a, b, c);\n}\n\nfloat radFilter(float v)\n{\n    return smoothstep(100. / iResolution.y, 0., abs(v-1.));\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(0., 0.5, v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tangle = atan(p.y, p.x);\n    float \tl = length(p) * nbCircle;\n    float\tcircleId = floor(l);\n    #ifdef AUDIOREACT\n    float\ts = texture(iChannel0, vec2(0.5, 1. - circleId / nbCircle)).x;\n    #else\n    float\ts = 0.6;    \n    #endif\n    float\tmodCircleId = mod(circleId, 2.);\n    float d = sdfTriangle(p);\n    d = distFilter(d);\n    float speed = mix(0.1, -0.1, modCircleId);\n    l+= sin((angle - iTime * speed) * circleId * 5.) * 0.5 * d * s;\n    l = fract(l) * 2.;\n    float\tt = min(l, 2. - l);\n    t = radFilter(t); \n    fragColor = vec4(vec3(pow(t,1./2.2)),1.);\n}", "image_inputs": [{"id": "XtjGRD", "previewfilepath": "https://soundcloud.com/acidgecko/warhawk-rob-hubbard-remix-acidgecko", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/acidgecko/warhawk-rob-hubbard-remix-acidgecko", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXRB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[140, 192, 232, 232, 284], [286, 286, 305, 305, 335], [337, 337, 389, 389, 636], [638, 638, 665, 665, 900], [902, 902, 928, 928, 990], [992, 992, 1019, 1019, 1056], [1059, 1059, 1116, 1116, 1753]], "test": "untested"}
{"id": "tttXWf", "name": "Moai Statue", "author": "Del", "description": "a very poor Moai head", "tags": ["raymarch", "sdf", "island", "poor", "moai", "easter"], "likes": 6, "viewed": 250, "published": "Public API", "date": "1581915974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A very badly modelled Moai statue :) - Del 16/02/2020\n\n#define AA 2\n#define PI\t\t3.1415926\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat mouth (in vec3 p)\n{\n    vec3 mouthpos = p-vec3(0.0,-0.4,0.10);\t\n    float body = length (mouthpos);\n    float size = 0.15;\n\tbody = max (body - size,  -body);\n\tfloat Angle = PI * ( 0.1 * abs(sin (iTime*3.0)));\n\tfloat mouthT = dot (mouthpos, vec3 (0.0, -cos (Angle), sin (Angle)));\n\tAngle *= 2.4;\n\tfloat mouthB = dot (mouthpos, vec3 (0.0, cos (Angle), sin (Angle)));\n    return max (body, min (mouthT, mouthB));\n}\nfloat ear (in vec3 p)\n{\n    p.y += 0.15;\n    p.z -= 0.02;\n    float d1 =  sdCone(p, vec3(0.22,-0.2,0.0), vec3(0.19,0.2,0.0), 0.02,0.01 );\n    float d2 =  sdCone(p, vec3(-0.22,-0.2,0.0), vec3(-0.19,0.2,0.0), 0.02,0.01 );\n    return min(d1,d2);\n}\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nfloat map( in vec3 pos )\n{\n    \n\t//pos.xz *= rotate(sin(iTime+pos.y));\n    pos.x = mod(pos.x,0.6)-0.3;\n    \n    pos.y -= 0.2;\n    float d1 =  sdCone(pos, vec3(0.0,-0.5,0.0), vec3(0.0,0.2,0.0), 0.225, 0.16 );\n    float d7 = mouth(pos);\n    d1 = smin(d1,d7,0.15);\n    float d3 = sdBox(pos+vec3(0.0,0.15,-0.4),vec3(0.2,0.15,0.3));\n    d1 = opSmoothSubtraction(d3,d1,0.025);\t\t// box cutout\n    vec3 q = pos+vec3(0.0,0.0,-0.08);\t//-vec3(0.0,0.0,-0.1);\n    float d2 =  sdCone(q, vec3(0.0,0.0,0.04), vec3(0.0,-0.3,0.105), 0.1*0.4, 0.1*0.9 );\n    d1 = smin(d1,d2,0.045);\n\tfloat d4 = sdBox(pos+vec3(0.0,0.1,0.15),vec3(0.2,0.5,0.1));\n    d1 = opSmoothSubtraction(d4,d1,0.09);\t\t// box cutout\n    \n    float ep = ear(pos);\n    d1 = smin(ep,d1,0.05);\n    \n    return d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n//    vec\n     // camera movement\t\n    float an = sin(iTime)*0.8;\n    an+=3.14*0.5;\n    float y = 0.0;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*2.0;\n        y-=1.0;\n    }\n    \n\tvec3 ro = vec3( 1.0*cos(an), y, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 8.0;\n        float t = 0.0;\n        for( int i=0; i<80;i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.6,0.4,0.4*abs(sin(uv.x*0.1+iTime)))*1.0-abs(uv.y*0.5);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            vec3 ambcol = vec3(0.4,0.3,0.3)*amb;\n            col = ambcol + vec3(0.6,0.55,0.85)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 146, 146, 245], [247, 247, 305, 305, 405], [406, 406, 449, 449, 471], [473, 473, 531, 531, 1091], [1092, 1092, 1133, 1133, 1217], [1218, 1218, 1249, 1249, 1336], [1337, 1337, 1362, 1362, 1754], [1755, 1755, 1778, 1778, 1999], [2001, 2001, 2023, 2023, 2090], [2091, 2091, 2117, 2161, 2850], [2852, 2852, 2884, 2884, 3123], [3130, 3130, 3187, 3187, 5081]], "test": "untested"}
{"id": "ttVSRz", "name": "Office Hell", "author": "bitless", "description": "The Eights circle of Hell, Bolgia Four.\nA place for those sinners who have fun with shaders during working hours.\n(My cell is #42LZYCDR, welcome)", "tags": ["2d", "distortion", "isometric", "labyrinth"], "likes": 33, "viewed": 260, "published": "Public", "date": "1582118289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Office Hell\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n\n\n//\t\t\t\t _____      ___    ___                        __  __          ___    ___      \n//\t\t\t\t/\\  __`\\  /'___\\ /'___\\ __                   /\\ \\/\\ \\        /\\_ \\  /\\_ \\     \n//\t\t\t\t\\ \\ \\/\\ \\/\\ \\__//\\ \\__//\\_\\    ___     __    \\ \\ \\_\\ \\     __\\//\\ \\ \\//\\ \\    \n//\t\t\t\t \\ \\ \\ \\ \\ \\ ,__\\ \\ ,__\\/\\ \\  /'___\\ /'__`\\   \\ \\  _  \\  /'__`\\\\ \\ \\  \\ \\ \\   \n//\t\t\t\t  \\ \\ \\_\\ \\ \\ \\_/\\ \\ \\_/\\ \\ \\/\\ \\__//\\  __/    \\ \\ \\ \\ \\/\\  __/ \\_\\ \\_ \\_\\ \\_ \n//\t\t\t\t   \\ \\_____\\ \\_\\  \\ \\_\\  \\ \\_\\ \\____\\ \\____\\    \\ \\_\\ \\_\\ \\____\\/\\____\\/\\____\\\n//\t\t\t\t    \\/_____/\\/_/   \\/_/   \\/_/\\/____/\\/____/     \\/_/\\/_/\\/____/\\/____/\\/____/\n//                                                                              \n//\t\t\t\tThe Eights circle of Hell, Bolgia Four.\n//\t\t\t\tA place for those sinners who have fun with shaders during working hours.\n//\t\t\t\t(My cell is #42LZYCDR, welcome)                                                                              \n\n\nfloat WT = 0.08333333; //wall thickness\nfloat WH = 0.33333333; //wall height\nfloat DS = 0.33333333; //door size\nfloat sm; //smoothing\nfloat l = 5.; \n#define WF (WT+WH)\n#define CLR .1 //Colorness\n#define LT .02 //Line thickness\n#define LS .01 //Line thickness\n#define FloorColor vec3(.52,.52,.52)\n#define WallColor vec3(.8,.8,.7)\n#define LineColor vec3(.1,.1,.1)\n#define lx lc+vec2(lc.y,0.)\n#define ly lc+vec2(0.,lc.x)\n#define SinPro .12 //count of sinners \n#define PI 3.1415926\n#define hue(v) (.6 +.6*cos(2.*PI*(v)+vec3(0,-2.*PI/3.,2.*PI/3.)))  \n#define hash2(p) (fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453))\n\n\nfloat bx (vec2 lc, float l, float r, float d, float u, float w)\n{\n    vec2 c = vec2((r-l)/2.+l,(u-d)/2.+d)\n         ,s = vec2(r,u)-c;\n    return smoothstep (s.x-w+sm,s.x-w, abs(lc.x-c.x))*smoothstep (s.y-w+sm,s.y-w, abs(lc.y-c.y));\n}\n\nvec4 SolidWall (vec2 lc, bool s, vec3 h) {\n    vec3 r;\n    float a = bx(lc+vec2(lc.y,0.),0.,1.,0.,WH+WT,0.);\n\n    r = mix (LineColor, mix(WallColor,h,CLR), bx(lc+vec2(lc.y,0.),0.,1.1,0.,WH+LS,LT)*(s?1.:.7));\n    r = mix (r, WallColor,bx(lc+vec2(lc.y,0.),0.,1.1,WH,WF,LT))\n        * (1.-.4*smoothstep(.1,.0,lc.y))                             \n        * (s?1.-.35*smoothstep(.4,0.,lc.x+lc.y)*smoothstep(WH+sm,WH,lc.y):1.);\n    return vec4(r,a);\n}\n\nvec4 DoorWall (vec2 lc, bool s, vec3 h) {\n    float WS = (1.-DS-WT)/2.;\n    float a = (bx(lx,0.,WS+WT,0.,WF,0.)*bx(lc,0.,WS,0.,WF,0.)\n            +bx(lx,1.-WS-WT,1.,0.,WF,0.)*bx(lc,1.-WS-WF,1.,0.,WF,0.))\n            *(1.-bx(lx,WS+WT,1.-WS-WT,0.,1.,0.));\n\n    vec3 r = mix (LineColor, mix(WallColor,h,CLR),bx(lx,-.1,WS,0.,WH+LS,LT)*(s?1.:.7) //1\n                            +bx(lx,1.-WS-WT,1.1,0.,WH+LS,LT)*(s?1.:.7)); //4\n    r = mix (r, WallColor,bx(lc,-.1,WS-WH,WH,WF,LT)  //2\n                            +bx(ly,WS-WH-LS,WS,WS-LS,WS+WT,LT)  //3\n                            +bx(lc,1.-WS-WF,1.1,WH,WF,LT)) //5\n        * (1.-.4*smoothstep(.1,.0,lc.y))                            \n        * (s?1.-.35*smoothstep(.4,.0,lc.x+lc.y)*smoothstep(WH+sm,WH,lc.y):1.);\n    return vec4(r,a);\n}\n\n\nvec4 NbrWall (vec2 lc, bool s, vec3 h) {\n    float a = bx(lx,1.-WF,1.,0.,WF,0.)*smoothstep(1.-WF-sm,1.-WF,lc.x);\n    vec3 r = mix (LineColor, WallColor,bx(lc,1.-WF,1.-WH,-.1,1.,LT)); //1\n    r = mix (r, mix(WallColor,h,CLR),bx(ly,1.-WH-LS,1.,-.1,1.,LT)*(s?1.-.4*smoothstep(.4,0.,1.-lc.x-lc.y):.7)); //2\n    r = mix (r, WallColor,bx(lc,0.,1.,WH,WF,LT))       //3\n        * (1.-.4*smoothstep(.1,.0,1.-lc.x));\n    return vec4(r,a);\n}\n\nvec4 NbrDrWall (vec2 lc, bool s, vec3 h) {\n    float WS = (1.-DS-WT)/2.;\n    float a = bx(lx,1.-WS-WT+LS,1.,0.,WH+LT*.95,0.)*smoothstep(1.-WF-sm,1.-WF,lc.x);\n    vec3 r = mix (LineColor, WallColor,bx(lc,1.-WF,1.-WH,WH-WS,1.,LT) //1\n                                        +bx(lx,1.-WS-WT,1.-WS+LS,-.1,WH-WS+LS,LT)); //2\n    r = mix (r, mix(WallColor,h,CLR),bx(ly,1.-WH-LS,1.,1.-WS,1.,LT)*(s?1.-.4*smoothstep(.4,.0,1.-lc.x-lc.y):.7)) //3\n        * (1.-.4*smoothstep(.1,.0,1.-lc.x));\n    return vec4(r,a);\n}\n\nivec2 CellType(vec2 fr) {\n    float t = floor(hash2(fr)*2.);\n    return ivec2(t, mod(t+1.,2.));    \n}\n\nvec4 InnerWall(int t, vec2 lc, bool s, vec3 h) {\n    return (t ==0)? SolidWall (lc, s, h)\n                    :DoorWall (lc, s, h);\n}\n\nvec4 OuterWall(int t, vec2 lc, bool s, vec3 h) {\n    return (t==0)? NbrWall (lc, s, h)\n                    :NbrDrWall (lc, s, h);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b )\n{\n    vec2 pa = p-a\n        ,ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa-ba*h);\n}\n\nfloat NoiseSin(float x, float a, float f, float t ){\n    float y = sin(a * f);\n    t = .075*(iTime*t);\n    y += sin(x*f*2.1 + t)*4.5\n        + sin(x*f*10.72 + t*1.121)*.50;\n    y *= a*.06;\n    return y;\n}\n\nvec4 Sinner(vec2 fr, vec2 lc, float a){\n    vec3 res;\n\n    if (hash2(fr.yx) < SinPro) {\n        float r = hash2(fr);\n        float s = 3.;\n\n        lc = lc*vec2(s*1.3,s)+vec2(-2,-2.7)+vec2(NoiseSin(lc.x,.1,40.,50.))*smoothstep(2.,0.,l);\n        lc.x += hash2(vec2(iTime))*0.25*smoothstep(2.,0.,l);\n        vec2 df = .5*sin( iTime*(r+.5) + vec2(4.,2.5) + (r+.5)*5.)*smoothstep(0.,3.,l);\n\n        float f,sh;\n \n        lc += df;\n        \n        sh = (smoothstep(.5,.0,length(lc*vec2(1.,1.4)+vec2(0.,01.25)))+smoothstep(.9,.0,length(lc*vec2(1.,1.4)+vec2(-0.4321,01.25))))*a*.65;\n        \n        f = length(lc+vec2(0.,-.1))-.05; //head\n        f = min(f,sdLine(lc,vec2(0.,-.16),vec2(0.,-.5))-.07);//body\n        f = min(f,sdLine(lc,vec2(-.08,-.16),vec2(-.25,-.5)));//left hand\n        f = min(f,sdLine(lc,vec2(.08,-.16),vec2(.25,-.5)));//right hand\n        f = min(f,sdLine(lc,vec2(-.07,-.5),vec2(-.08,-.9)));//left leg\n        f = min(f,sdLine(lc,vec2(.07,-.5),vec2(.08,-.9)));//right leg\n        \n        res = mix(LineColor,vec3(.8,.7,.7),smoothstep(.05+sm*2.,.05,f)*a);\n        \n        a = max(sh,smoothstep(.1+sm*2.,.1,f)*a);\n    }    else a = 0.;\n        return vec4(res,a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 g)\n{\n\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)/r.y\n    \t,C = vec2(sin(iTime/20.),cos(iTime/20.))*5. //camera shift\n        ,CCell = (C * mat2(1,-1.5,1,1.5)*2.); //central cell \n\n    vec3 Res ;\n    float lg = 5.;\n    \n    for (int i = -3; i<4; i++) //distance from central cell to closes sinner\n        for (int j = -3; j <4; j++)\n            if (hash2((floor(CCell)+vec2(i,j)).yx) < SinPro) \n            {\n                lg = min (lg, length(CCell-floor(CCell+vec2(i,j))));\n            }\n\n    uv += uv * pow(length(uv),2.)*.1*smoothstep(5.,0.,lg); //camera distortion\n    vec2 rc = uv * (smoothstep(0.,5.,lg)/2.5+.25) + C; //rectangle coords\n    vec2 ic = rc * mat2(1,-1.5,1,1.5);    //isometric coords\n\n    ic *= 2.;\n    sm = fwidth(length(ic))*.8; //smoothness\n\n    vec2 fr = floor(ic); //cell number\n    vec2 lc = fract(ic);//local cell coordinates\n    \n    vec2 tc = abs(lc-vec2(.5)+vec2(WT,-WT));\n    Res = mix(FloorColor,hue (hash2(fr)),CLR*smoothstep(WT/2.,WT/2.+sm,lc.y)*smoothstep(1.-WT/2.,1.-WT/2.-sm,lc.x)); //floor color\n    Res += floor(mod(max(tc.x,tc.y)*(1.-WT)*38.,2.))*.05;//floor texture\n\n    l = length(CCell-ic)+(4.*smoothstep(0.,5.,lg));\n\n    WH = WH + (NoiseSin(ic.x,.25,2.,200.)+NoiseSin(ic.y,.25,2.,200.))*(smoothstep(2.,0.,l)); //wall height waves\n//    WT = WT + abs((NoiseSin(ic.x,.25,.1,20.)+NoiseSin(ic.y,.25,.1,20.)))*(smoothstep(2.,0.,l));//*(smoothstep(2.,0.,l)); //wall thickness waves\n    DS = DS + (sin(iTime*10.+ic.y*5.))*.2*(smoothstep(2.,0.,l)); //door size waves\n\n    float f,m,m1; //floor shadow and wall masks\n    vec4 cr;\n    ivec2 t = CellType(fr);\n    \n    f = smoothstep(0.,sm,1.-lc.y);\n    f*= 1.-.5*smoothstep(.1,0.,1.-lc.y);\n    f = (CellType(fr+vec2(0.,1.)).y == 0) ?\n        max(f,smoothstep (DS/2.,DS/2.-sm,abs(lc.x-.5+WT/2.))) \n        :f;\n\n    f*= 1.-.5*smoothstep(.1+WT,WT,1.-lc.x);\n    f = (t.x == 0) ?\n        max(f,smoothstep (DS/2.,DS/2.-sm,abs(lc.y-.5-WT/2.)))\n        :f;\n\n    f *= max(1.-smoothstep(WF,WT,lc.y)*.5,smoothstep (DS/2.+(.5-abs(.5-lc.y))*.5,DS/2.-.01,abs(lc.x-.5-lc.y*.5+WT/2.)));\n    Res *= f;\n\n    f = smoothstep(0.,sm,lc.x);\n    f *= 1.-.5*smoothstep(WH+WT,0.,lc.x);\n    f = (CellType(fr+vec2(-1.,0.)).x == 0) ?\n        max(f,smoothstep (DS/2.+(.5-abs(.5-lc.x))*.5,DS/2.-.01,abs(lc.y-.5-lc.x*.5-WT/2.)))\n        :f;\n\n    Res *= f;\n\n    vec3 h;\n\n    h = hue(hash2(fr+vec2(0,-1)));\n    Res = mix(Res,h,smoothstep(WT/2.+sm,WT/2.,lc.y)*CLR);\n\n    cr = InnerWall(t.x, lc, true, h);\n    Res = mix(Res, cr.xyz, cr.a);\n    \n    m = cr.a;\n\n    h = hue(hash2(fr+vec2(1,0)));\n    Res = mix(Res,h,smoothstep(1.-WT/2.-sm,1.-WT/2.,lc.x)*CLR);\n\n    cr = InnerWall(t.y, 1.-lc.yx, false, h);\n    Res = mix(Res, cr.xyz, cr.a);\n    m = max(m, cr.a);\n\n    h = hue(hash2(fr+vec2(1,-1)));\n    t = CellType(fr+vec2(0,-1));\n    cr = OuterWall(t.y, lc, false, h);\n    Res = mix(Res, cr.xyz, cr.a);\n    m1 = cr.a;\n\n    t = CellType(fr+vec2(1,0));\n    cr = OuterWall(t.x, 1.-lc.yx, true, h);\n    Res = mix(Res, cr.xyz, cr.a);\n    m1 = max(m1,cr.a);\n    \n    lc = fract(rc*vec2(2.,3.) + vec2(0.,.5));\n    lc = (mod(fr.x+fr.y,2.) != 0.)? lc = fract(rc*vec2(2.,3.) + vec2(.5,-.0)) : lc;\n        \n    m = 1. - m;\n    m1 = 1. - m1;\n                \n    vec4 s = Sinner (fr, lc,m);\n    Res = mix(Res, s.xyz,s.a);\n    s = Sinner (fr+vec2(1,0), lc+vec2 (-.5,.5),m1);\n    Res = mix(Res, s.xyz,s.a);\n    s = Sinner (fr+vec2(0,-1), lc+vec2 (.5,.5),m1);\n    Res = mix(Res, s.xyz,s.a);\n    s = Sinner (fr+vec2(1,-1), lc+vec2 (.0,1.),1.);\n    Res = mix(Res, s.xyz,s.a);\n    \n    Res *= 1.-.5*smoothstep (3.5/l, 5./l, length(ic - CCell));\n    vec3 Res1 = vec3(max(max(Res.r,Res.g),Res.b),0.,0.);\n    Res = mix (Res1,Res,smoothstep(0.,3.,lg));\n\n    fragColor = vec4(Res,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1266, 1865, 1930, 1930, 2098], [2100, 2100, 2142, 2142, 2544], [2546, 2546, 2587, 2587, 3327], [3330, 3330, 3370, 3370, 3760], [3762, 3762, 3804, 3804, 4267], [4269, 4269, 4294, 4294, 4370], [4372, 4372, 4420, 4420, 4505], [4507, 4507, 4555, 4555, 4638], [4640, 4640, 4677, 4677, 4796], [4798, 4798, 4850, 4850, 5002], [5004, 5004, 5043, 5043, 6185], [6187, 6187, 6234, 6234, 9949]], "test": "untested"}
{"id": "ttVXDw", "name": "Light and Darkness", "author": "Kali", "description": "For Meli - Music by me ", "tags": [], "likes": 22, "viewed": 372, "published": "Public", "date": "1582899418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t (iTime*.15)\n#define steps 50.\n#define scale 2.5\n\nvec2 sphere(vec3 p, vec3 rd, float r){\n\tfloat b = dot( -p, rd ),\n\tinner = b*b - dot(p,p) + r*r;\n\treturn inner < 0. ?  vec2(-1.) : vec2(b - sqrt(inner), b + sqrt(inner));\n}\n\n\n\nfloat formula(vec3 p) {\n    p*=scale;\n    float m=100.;\n    for (int i=0; i<7; i++) {\n    \tp=abs(p)/dot(p,p)-1.;\n        vec3 ap=abs(p);\n        m=min(min(ap.z,min(ap.x,ap.y)),m);\n    }\n    m=pow(max(0.,1.-m),250.);\n    return m*2.+dot(p,p)*.05+.1;\n}\n\nvoid mainImage( out vec4 o, vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;  \n\tuv.x*=iResolution.x/iResolution.y;\n    float distorig=1.3+sin(t*1.35435);    \n    vec3 ro = -vec3(0.,0., 2.),\n\t     rd =normalize(vec3(uv,1.)),\n\t     v = vec3(0), p;\n    vec2 tt;\n    vec2 m=iMouse.xy/iResolution.xy*3.14;\n    if (iMouse.z<.1) m=vec2(t*.3);\n    float c,s;\n    mat2 rot;\n    c=cos(-m.x),s=sin(-m.x);\n    rot = mat2(c,-s,s,c);    \n    ro.xz*=rot;\n    rd.xz*=rot;\n    ro.yz*=rot;\n    rd.yz*=rot;\n\n    float st=1.5/steps;\n\tfor (float i=5.; i<steps; i++) {\n\t\tfloat d=i*st;\n        tt = sphere(ro, rd, d);\n\t\tp = ro+rd*tt.x;\n\t\tv+=formula(p)*step(0.,tt.x)*smoothstep(0.,distorig,distorig-tt.x+.4);\n\t\tp = ro+rd*tt.y;\n\t\tv+=formula(p)*step(0.,tt.x)*smoothstep(0.,distorig,distorig-tt.y+.4);\n\t}\n\n\to.xyz = vec3(1.,.95,.9)*v*.1*smoothstep(0.,8.,iTime);\n}", "image_inputs": [{"id": "MtB3Rm", "previewfilepath": "https://soundcloud.com/pablo-andrioli/philemonic-espero-que-entiendas", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pablo-andrioli/philemonic-espero-que-entiendas", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 97, 97, 230], [234, 234, 257, 257, 484], [486, 486, 532, 532, 1336]], "test": "untested"}
{"id": "ttySzz", "name": "Protean Clouds (alow down", "author": "Onan", "description": "Fork of https://www.shadertoy.com/view/3l23Rh by the genius nimitz\n\nAdded a timeScaling variable (line 33) to speed up/slow down the shader.", "tags": ["procedural", "3d", "fast", "volumetric"], "likes": 9, "viewed": 480, "published": "Public API", "date": "1582051734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Edited by Onan\n// added timeScaling Variable for speeding up/slowing down\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\nfloat timeScaling = 0.2;\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime*timeScaling)*(0.1 + prm1*0.05) + iTime*timeScaling*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*timeScaling*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*timeScaling*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime*timeScaling)*0.5,sin(iTime*timeScaling*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*timeScaling*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttySzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[304, 1209, 1230, 1230, 1282], [1394, 1394, 1413, 1413, 1430], [1431, 1431, 1483, 1483, 1527], [1592, 1592, 1611, 1611, 1662], [1664, 1664, 1682, 1682, 2245], [2247, 2247, 2298, 2298, 3332], [3334, 3334, 3356, 3356, 3471], [3473, 3546, 3592, 3592, 3938], [3940, 3940, 3997, 3997, 5142]], "test": "untested"}
{"id": "ttyXDW", "name": "Spirogragh", "author": "foez", "description": "inspired from this video https://www.youtube.com/watch?v=klHUOS76AbM", "tags": ["2d", "spirograph"], "likes": 2, "viewed": 71, "published": "Public", "date": "1582712611", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define N 20\n#define PI 3.14\n\nfloat dLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    \n    float t = dot(pa, ba)/dot(ba, ba);\n    t = clamp(t, 0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = dLine(p, a, b);\n    return smoothstep(.006, 0., d);\n}\n\n\nvec3 getCol(vec2 uv)\n{\n    vec3 col = vec3(0);\n    float time = iTime;\n    vec2 p[N];\n    float r = .5;\n    p[0] = vec2(0, r);\n    \n    vec3 c1 = vec3(1, 0, 0);\n    vec3 c2 = vec3(1);\n    \n    for(int i=0;i<N;i++) {\n        float theta = float(i)*2.*PI/float(N) + sign(sin(time+sin(time+sin(time)))*sin(time*3.));\n        float c = cos(theta);\n        float s = sin(theta);\n        p[i] = r*vec2(c, s);\n    }\n    \n    vec3 b = vec3(1, 0, 0);\n    vec3 red = vec3(0,0,1);\n    for(int i=0;i<N;i++) {\n        col += red*Line(uv, p[i], p[i]);\n    }\n    \n    \n    int pa = (N/2)%N;\n    float d1 = 100000.;\n    for(int i=0;i<N/2;i++){\n        d1 = min(d1, dLine(uv, p[pa], p[i]));\n        pa = (pa+1)%N;\n        d1 = min(d1, dLine(uv, p[pa], p[i]));\n        pa = (pa+1)%N;\n    }\n    \n    pa = (0);\n    float d2 = 100000.;\n    float spr = mix(200., 1000., fract(time));\n    \n    float circle = length(uv) - r;\n    col += c1*(1./(spr*d1));\n    \n    float mask = step(0., -circle)*(1.-smoothstep(0.01, 0., d1));\n    \n    for(int i=N/2;i<N;i++){\n        d2 = min(d2, dLine(uv, p[pa], p[i]));\n        pa = (pa+1)%N;\n        d2 = min(d2, dLine(uv, p[pa], p[i]));\n        pa = (pa+1)%N;\n    }\n    \n    col += (mask)*c2*(1./(spr*d2));\n   \treturn col;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 1. -2. * uv;\n    uv.x *= iResolution.x/iResolution.y;\n    uv /= 1.5;\n    // Time varying pixel color\n    vec3 col = getCol(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 69, 69, 207], [209, 209, 245, 245, 313], [316, 316, 338, 338, 1555], [1557, 1557, 1614, 1664, 1900]], "test": "untested"}
{"id": "ttyXRw", "name": "Capsule tunnel", "author": "rodgzilla", "description": "Travel through capsule land.", "tags": ["glow", "capsule"], "likes": 3, "viewed": 229, "published": "Public API", "date": "1582389752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time .4 * iTime\n#define ZPOS -30. + 20. * time\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n  p.xy *= rot2d(sin(3. * time) * sin(p.z / 15.));\n  p.xz *= rot2d(sin(.01 * time) * PI);\n  p = rep(p, vec3(5, 5, 5));\n  float d = 5000.;\n  vec3 a1 = vec3(-2, 0, 0);\n  vec3 b1 = vec3(2, 0, 0);\n  vec3 a2 = vec3(0, -2, 0);\n  vec3 b2 = vec3(0, 2, 0);\n  vec3 a3 = vec3(0, 0, -3.);\n  vec3 b3 = vec3(0, 0, 3.);\n  float t = floor(time * .5) + smoothstep(.3, .6, fract(time * .5));\n  a1.xy *= rot2d(t);\n  b1.xy *= rot2d(t);\n  a2.xy *= rot2d(t);\n  b2.xy *= rot2d(t);\n  d = min(d, tube(p, a1, b1, .5));\n  d = min(d, tube(p, a2, b2, .5));\n  d = min(d, tube(p, a3, b3, .5));\n  \n  float t_wave = floor(time) + fract(time);\n  float wave = .5 * sin(t_wave) + .5;\n  vec3 shift = vec3(.2 * sin(time), 0, 0);\n  d = min(d, sph(p + shift, 1.));\n  \n  at += .1 / (.1 + d);\n  \n  return d;\n}\n\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .02 * at * vec3(0, 1., 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(0, 0, ZPOS);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + 2. * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n//  \tfloat dif = light(p);\n  \n//    vec3 col = .2 * dif * glow;\n    vec3 col = .2 * glow;\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 100, 100, 165], [167, 167, 195, 195, 221], [223, 223, 268, 268, 425], [427, 427, 453, 453, 501], [518, 518, 537, 537, 1304], [1334, 1334, 1362, 1362, 1606], [1608, 1608, 1629, 1629, 1776], [1778, 1778, 1799, 1799, 2024], [2027, 2027, 2084, 2084, 2472]], "test": "untested"}
{"id": "wl2Xzt", "name": "asddfsadfsdfsa", "author": "lennyjpg", "description": "adsdsfdsfdfs", "tags": ["asddfsdsfdfsa"], "likes": 3, "viewed": 210, "published": "Public API", "date": "1582583669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvec3 colors[8] = vec3[]( \n    vec3( 1.0, 0.2, 0.0 ),\n    vec3( 0.1, 0.2, 0.3 ),\n    vec3( 0.1, 0.1, 0.0 ),\n    vec3( 0.4, 0.9, 0.8 ),\n    vec3( 1.0, 1.0, 0.9 ),\n    vec3( 0.4, 0.2, 1.0 ),\n    vec3( 0.6, 1.0, 0.9 ),\n    vec3( 1.0, 0.1, 0.2 ));\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rot = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    \n    \nrot += iTime*0.1;\n    \n    float z = sin(iTime*0.2)+1.5;\n    uv*=z;\n    \n    uv -= vec2(0.5);\n//    uv = rotate2d( sin(iTime*0.1)*PI ) * uv;\n    uv = rotate2d( rot ) * uv;\n uv += vec2(0.5);\n    \n \tuv+= 999.999;\n      //  uv.y+=sin(uv.x*5.3)*0.5;\n\n    \n    uv.x+=iTime*0.1;\n    float t = 9999. + iTime * 0.2;\n   //t += 0.1*(sin(t*11.5)+1.0);\n    vec2 foo = uv;\n    \n   // foo.y+=sin(foo.x*4.0);\n    foo.x += sin(t+5.73+foo.x*1.1)*2.13;\n    foo.x -= cos(t-8.73-foo.x*5.1)*.14;\n\n        //t+= sin(foo.x*61.6)*.2;\n\n    float res = 17.0;\n    foo.x = floor(foo.x*res) / (res-1.0);\n    \n   // foo.y += sin(foo.x*32.156) * t;\n    t*= sin(foo.x*1.6)* 2.2;\n    foo.y += t;\n    \n    float n = rand(vec2(112.5,floor(foo.y*.1)))*43.01;\n    float m = rand(vec2(24.2,floor(foo.y)))*0.28;\n  \n    if(m>0.03) m+= n;\n   // n = min(n,m);\n//    foo.y = floor(fract(foo.y*n)+0.5);\n    foo.y = mod(foo.y+m,0.43);\n   // vec3 cc = colors[int(foo.y*8.0 )];\n    vec3 aa = colors[int(foo.y*6.0 )];\n    vec3 bb = colors[int(foo.y*6.0+.9 )];\n    vec3 cc = mix(aa,bb,foo.y*9.);\n\n    \n    /*\n    float e = rand(foo);\n    vec2 p = uv;\n\n    p.y+=uv.y;\n    \n    float a = fract(p.y*20.0*e);\n    a= floor(a+0.5);\n    \n    vec2 u = fract(p *20.0);\n    float k = length(u-0.5);\n    k = smoothstep(0.0,0.2,k);\n    \n    float s = sin(uv.x);\n    */\n    vec3 ca= vec3(1.0,0.3,0.1);\n    vec3 cb= vec3(1,1,0.4);\n    vec3 c = mix(ca, cb, foo.y);\n    \n    vec3 rgb = hsb2rgb(vec3(foo.y,1.0,1.0));\n    \n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2Xzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 100, 126, 126, 358], [606, 606, 634, 634, 720], [722, 722, 742, 742, 814], [834, 834, 891, 891, 2433]], "test": "untested"}
{"id": "wl33W7", "name": "3D-Fractals", "author": "a1pha1", "description": "Some 3D fractal distance function", "tags": ["raymarching", "fractals"], "likes": 3, "viewed": 100, "published": "Public", "date": "1581322637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void rotateX(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.y = c*z.y + s*z.z;\n\tz.z = c*z.z - s*z.y;\n}\n\nvoid rotateY(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.z = c*z.z + s*z.x;\n\tz.x = c*z.x - s*z.z;\n}\n\nvoid rotateZ(inout vec3 z, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tz.x = c*z.x + s*z.y;\n\tz.y = c*z.y - s*z.x;\n}\n\nvoid distort(inout vec3 z, float s)\n{\n\tfloat nx, ny, nz;\n\tfloat y = z.y;\n\tny = sin(z.z);\n\tnz = z.x*0.9;\n\tnx = y;\n\tz = mix(z, vec3(ny, nz, nx), s);\n\t//z = max(z,-z);\n}\n\nvoid shrink(inout vec3 z, float shrink)\n{\n\tz = z*shrink;\n}\n\nvoid scaleAround(inout vec3 z, vec3 offset, float scale)\n{\n\tz = z*scale - offset*(scale-1.0);\n}\n\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\n\nvoid sphereFold(inout vec3 z, float minR, float maxR) {\n\tfloat r2 = dot(z.xyz, z.xyz);\n\tz *= max(maxR / max(minR, r2), 1.0);\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\nvoid absFold(inout vec3 z, vec3 c) {\n\tz.xyz = abs(z.xyz - c) + c;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvoid mengerFold(inout vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.141 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nconst float ITERATIONS = 15.;\nconst float EPSILON = 0.001;\n\nfloat map(vec3 z)\n{\n    shrink(z, 0.1);\n    planeFold(z, vec3(-1.0, 0.0, 0.0), -1.0);\n    \n    for(float n = 0.; n < ITERATIONS; n++) \n    {\n        sphereFold(z, 0.1, 1.2);\n        planeFold(z, vec3(0.0, 1.0, 0.0), -1.0);\n        planeFold(z, vec3(0.0, 0.0, 1.0), -1.0);\n        mengerFold(z);\n        scaleAround(z, vec3(1.0, 1.0, 1.0), 2.0);\n        rotateX(z,-0.1+sin(iTime*0.4)*0.1);\n        rotateZ(z,-0.048+sin(iTime*0.77)*0.1);\n        //rotateY(z, sin(iTime*0.2)*0.05);\n        sphereFold(z, 0.2, 1.7);\n   }\n   return (length(z)) * pow(2., -ITERATIONS);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),map(pos+e.yxy)-map(pos-e.yxy),map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nconst float PI = 3.141;\nconst float PHI = 1.618;\n\nfloat hash1(float f)\n{\n  return fract(sin(f*234.345)*83457.32);   \n}\n\nvec3 nextVec( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float pre, float dis)\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<int(pre); i++ )\n    {\n        vec3 ap = nextVec( float(i), pre );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*dis)*(32.0/dis), 0.0, 1.0 );\n    }\n\tao /= pre;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float disO = 0.;\n    \n    for(int i = 0; i < 100000; i++)\n    {\n    \tvec3 pos = ro+rd*disO;\n        float d = map(pos);\n        disO += d;\n        \n        if(d < EPSILON)\n            return disO;\n        if(disO > 200.)\n            break;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AA = 2.;\n    \n    vec3 tot = vec3(0.);\n\n    for(float ax = 0.; ax < AA; ax++)\n    {\n        for(float ay = 0.; ay < AA; ay++)\n        {\n\t\t\tvec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.y)+vec2(ax / (iResolution.x*AA), ay / (iResolution.y*AA));\n           // uv = abs(uv);\n\n            float w = 0.;\n            float dis = iTime-38.;\n            vec3 ro = vec3(10., dis, dis);\n\n            vec3 ta = ro+vec3(0., 0.785398, 0.785398);\n            vec3 f = normalize(ta-ro);\n            vec3 r = normalize(cross(vec3(0.,1., 0.), f));\n            vec3 u = normalize(cross(f, r));\n            float zoom = 1.;\n            vec3 rd = normalize(f*zoom+r*uv.x+u*uv.y);\n\n            vec3 col = vec3(0.);\n\n            float d = march(ro, rd);\n            if(d > 0.)\n            {\n                vec3 pos = ro+rd*d;\n                vec3 nor = calcNormal(pos);\n                vec3 lDir = normalize(u);\n                vec3 base = vec3(0.9);\n                float dif = diffuse(nor, lDir, 1.);\n                float ao1 = calcAO(pos, nor, 64., 1.5);\n                float ao2 = calcAO(pos, nor, 32.,EPSILON * 50.);\n                vec3 ref = normalize(lDir - (2.*dot(nor, lDir)*nor));\n                float spec = clamp(dot(normalize(pos-ro), ref), 0., 1.);\n                spec = pow(spec, 30.);\n\n                vec3 mat = mix(vec3(2., 0.4, 0.3), vec3(0.9), ao2*ao2*ao2);\n\n                col = vec3(mat*ao1*mix(dif, 1., 0.2)*0.8);\n                col += spec*0.1;\n                col *= 2.6*exp(d*-0.07);\n            }\n            tot+=col;\n        }\n    }\n    tot /= AA*AA;\n    tot = pow( tot, vec3(1.0,1.0,1.4) ) + vec3(0.0,0.02,0.12);\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    fragColor =vec4(pow(tot,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl33W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 121], [123, 123, 160, 160, 244], [246, 246, 283, 283, 367], [369, 369, 406, 406, 535], [537, 537, 578, 578, 595], [597, 597, 655, 655, 692], [694, 694, 741, 741, 792], [794, 794, 849, 849, 920], [922, 922, 958, 958, 1004], [1006, 1006, 1042, 1042, 1073], [1074, 1074, 1109, 1109, 1201], [1202, 1202, 1233, 1233, 1385], [1387, 1387, 1425, 1425, 1467], [1468, 1468, 1514, 1514, 1617], [1679, 1679, 1698, 1698, 2243], [2245, 2245, 2272, 2272, 2425], [2477, 2477, 2499, 2499, 2545], [2547, 2547, 2581, 2581, 2757], [2759, 2759, 2822, 2822, 3106], [3109, 3109, 3140, 3140, 3408], [3410, 3410, 3467, 3467, 5259]], "test": "untested"}
{"id": "Wl3GR4", "name": "Secret Box", "author": "Plento", "description": "Not the effect I was going for but sorta cool. Not really optimized so it might be slow.", "tags": ["3d", "glass", "oops"], "likes": 5, "viewed": 248, "published": "Public API", "date": "1581671952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plento\nvec2 R;\n\n#define FAR 32.\n\nconst float pi = 3.14159;\n\nmat2 rot(float a){return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opsub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat minDist = 999.;\nfloat mat = -1.0;\n\nvoid cd(float tDist, float m, out float tmat){\n\tif(tDist <minDist){\n\t\tminDist = tDist;\n\t\tmat = m;\n\t\ttmat = m;\n\t}\n}\n\nconst vec3 gd = vec3(1.4, 0.5, 0.5);\n\nfloat frame(vec3 p){\n    float d = sdBox(p, gd+.05);\n    d = opsub(sdBox(p, vec3(gd.x-.05, gd.y-.05, gd.z + 1.)),d );\n    d = opsub(sdBox(p, vec3(gd.x+1., gd.y-.05, gd.z -.05)),d );\n    d = opsub(sdBox(p, vec3(gd.x-.05, gd.y+1., gd.z -.05)),d );\n    \n    return d;\n}\n\nvec2 map(vec3 rp){\n    float d = 999.;\n    float hmat = 0.;\n    \n \tvec3 p0 = rp - vec3(0.0, 0.0, 3.0);\n    vec3 p1 = rp - vec3(0.0, 0.0, 3.0);\n    \n    p0.xy *= rot(iTime*.4);\n    p0.xz *= rot(iTime*.3);\n    p0.yz *= rot(-sin(iTime)*.2);\n    \n    d = min(d, abs(sdBox(p0, gd)) - 0.005);\n    cd(d, 0., hmat);\n    \n    d = min(d, frame(p0));\n    cd(d, 2., hmat);\n    \n    d = min(d, length(p1)-.1);\n    cd(d, 1., hmat);     \n    \n    rp.xy *= rot(iTime);\n    vec3 p2 = rp - vec3(.3*sin(iTime*2.), 0.0,3. + .3*cos(iTime*2.) );\n    d = min(d, length(p2)-.05);\n    \n    \n    cd(d, 3., hmat); \n    \n    return vec2(d, hmat);\n}\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy).x + \n        e.yyx * map(pos + e.yyx).x + \n        e.yxy * map(pos + e.yxy).x + \n        e.xxx * map(pos + e.xxx).x);\n}\n\nvec2 march(vec3 rd, vec3 ro){\n \tfloat t = 0.;   \n    vec2 d = vec2(0);\n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d.x) < 0.002)break;\n        if(t > FAR){t = FAR;break;}\n        t += d.x * 0.9;\n    }   \n    \n    return vec2(t, d.y);\n}\nvec3 color(vec3 p, vec3 rd, vec3 n, float t, float m){\n    vec3 lp = vec3(0., 4.0, -5.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float lgd = length(lp - p);\n    float faloff = 1.-exp(-(4. / lgd));\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 32.);\n    float dom = smoothstep(-0.2, 0.2, ref.y);\n    float dif = max(dot(n, ld), .0);\n    \n    vec3 col = vec3(0);    \n    vec3 lig = vec3(0);\n    \n    \n    if(t < FAR){\n    \tif(m == 0.)col = vec3(0.2, 0.3, 0.3);\n    \tif(m == 1.)col = vec3(1.0, 0., 0.);\n    \tif(m == 2.)col = vec3(.01);\n    \tif(m == 3.)col = vec3(0., 0.4, 1.);\n    \n    \tlig += .15*dom*vec3(0.4,0.6,1.3)*dom;\n    \tlig += 2.*dif*vec3(1., 1., 1.) * faloff;\n    \tcol *= lig;\n    \tcol += vec3(0.85, 0.83, 0.85) * spec * .2;\n    }\n    else col = vec3(.2);\n    \n\treturn col;   \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n   \n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.5));\n    vec3 ro = vec3(0);\n    \n    vec2 t = march(rd, ro);\n    vec3 p = ro+rd*t.x;\n    vec3 n = normal(p);\n    \n    vec3 col = vec3(0);\n    \n    float na = 0.;\n    \n    vec3 acol = vec3(0);\n    vec3 bcol = vec3(0);\n    vec3 ccol = vec3(0);\n    \n    col = color(p, rd, n, t.x, t.y);\n    na++;\n    \n    if(t.y == 0.){\n        minDist = 999.;\n        mat = -1.;\n        \n        p -= n*.18;\n        \n        rd = refract(rd, n, .5);\n        \n        vec2 t2 = march(rd, p);\n    \tvec3 p2 = p+rd*t2.x;\n    \tvec3 n2 = normal(p2);   \n        \n        col += color(p2, rd, n2, t2.x, t2.y);\n        na++;\n        \n        /*\n        if(t2.y == 0.){\n            minDist = 999.;\n        \tmat = -1.;\n        \tcol.b+=.1;\n            p2 -= n2*.1;\n            \n            rd = refract(rd, n2, .93);\n            \n            vec2 t3 = march(rd, p2);\n    \t\tvec3 p3 = p2+rd*t3.x;\n    \t\tvec3 n3 = normal(p3);\n            \n            col += color(p3, rd, n3, t3.x, t3.y);\n            na++;\n           \n        } \n*/\n    }\n    col /= na;\n    \n    \n    \n    vec2 v = u / R;\n    v *=  1. - v.yx;\n    float vig = v.x*v.y * 15.; \n    vig = pow(vig, .35); \n    col *= vig;\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3GR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 81, 81, 127], [129, 129, 159, 159, 246], [248, 248, 283, 283, 305], [348, 348, 394, 394, 462], [502, 502, 522, 522, 768], [770, 770, 788, 788, 1390], [1391, 1391, 1418, 1418, 1627], [1629, 1629, 1658, 1658, 1912], [1913, 1913, 1967, 1967, 2758], [2760, 2760, 2800, 2800, 4164]], "test": "untested"}
{"id": "wl3SDf", "name": "parametric polar Plotter", "author": "hazenn", "description": "dqzdqzvedqsdv", "tags": ["polarcoordinates"], "likes": 2, "viewed": 47, "published": "Public", "date": "1581842881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.1415926535897932384626433;\nconst int steps = 20;\n\nfloat f(float a,float t){\n    return 0.45*cos(0.01*sin(0.2*t)*PI*a+0.1*t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    float r = length(uv);\n    // theta in ]-pi,pi[\n    float theta0 = 2. * atan(uv.y / (uv.x + r));\n    \n    float min_d= 10000.;\n    \n    float theta = theta0;\n    for (int i = 0; i < steps; i++){\n        min_d = min(min_d, abs(r - f(theta,iTime)));\n            \n            \n    \ttheta += 2.*PI;\n    }\n    theta = theta0;\n    for (int i = 0; i < steps; i++){\n        min_d = min(min_d, abs(r - f(theta,iTime)));\n            \n            \n    \ttheta -= 2.*PI;\n    }\n    col += smoothstep(0.002,0.0025,min_d);\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3SDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 95, 95, 146], [147, 147, 204, 254, 940]], "test": "untested"}
{"id": "wl3Sz2", "name": "Plane Grid AA", "author": "spalmer", "description": "draws an analytically antialiased grid plane.\ncan compare methods split-window using mouse click.", "tags": ["grid", "antialias", "plane", "splitscreen"], "likes": 3, "viewed": 238, "published": "Public", "date": "1581342993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// derived from https://shadertoy.com/view/3tVGRz\n// see also https://shadertoy.com/view/wt3Sz2\n\n// a simple testbed for rendering an antialiased grid plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\n// thicker than .5 makes squares, not grids\nfloat gridThickness = .1; //.2; //.25; //.02; //.4; //\n\nconst vec3 Cfill = vec3(1.,1.,.9); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 Cgrid = vec3(0.,0.,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n   // btw fwidth totally works too\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n//    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// well, after all the resituating it's not very optimal\n// perhaps I should make a nice centered inset one instead,\n// as reference, so the filtered ones won't have to futz \n// with the zero crossing edge so much\nfloat gridSimple(vec2 p)\n{\n\tvec2 g = step(gridThickness, fract(gridThickness*.5-p));\n\treturn 1.-g.x*g.y;\n}\n\nfloat gridUnfiltered(vec2 p)\n{\n    p -= .5*gridThickness; // center\n    return step(1.-gridThickness, max(fract(p.x),fract(p.y)));\n}\n\nfloat gridAASimple(vec2 p)\n{\n    vec2 f = fract(p);\n    float g = min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2. - gridThickness\n    , x = step(g, 0.) //gridUnfiltered(p)\n    , w = fwidth(p.x) + fwidth(p.y)\n    , r = 2.*iResolution.y\n    , l = r*abs(g) / (1. + 1.*r*w) // can try different functions, divisor controls fade rate with distance\n    // up close, should blend toward 0.5, but\n    // far away should blend toward gridThickness, maybe sqrt'd?\n    , s = sqrt(gridThickness) //gridThickness*gridThickness //gridThickness //\n    , t = mix(.5, s, min(w, 1.));\n    return mix(t, x, clamp(l, 0., 1.));\n}\n// still not happy with how it fades out too soon,\n// but at least it's basically working.  Better than the others.\nfloat gridSmooth(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (gridThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = sqrt(gridThickness);\n    return smoothstep(.5-w*s,.5+w, max(q.x, q.y));\n}\n\n// the half sqrt(gridThickness) bias is fairly tricky; \n// honestly I shouldn't need to involve smoothstep at all here, hold on\n// meh, still not working worth a dern, maybe someday\nfloat gridSmoothLinear(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (gridThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = gridThickness;\n    return clamp((max(q.x, q.y) - .5-w*s) / (w*(s+1.)), 0., 1.);\n}\n\n// working better now\nfloat gridExp(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    float g = min(f.x, f.y);\n    g = max(0., g - .5*gridThickness);\n    g = exp2(-fadePower*g);\n    float s = sqrt(gridThickness);\n    return mix(g, s, exp2(-.02 / filterWidth2(p)));    \n}\n\n// for ilyaev\nfloat gridPow(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*gridThickness);\n    f = pow(f, vec2(fadePower));\n    float g = f.x+f.y; //max(f.x, f.y); //\n    float s = sqrt(gridThickness);\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));    \n}\n\n// originally from https://shadertoy.com/view/WlVGDh\n// this is just not the way to do grids, blurs\n// the corners too much, but it sort of works:\nfloat gridSine(vec2 p)\n{\n    p *= 3.1415927;\n    float g = sin(p.x) * sin(p.y); // grid texture\n    g *= g; g = max(0., 1. - g);\n    g = pow(g, 8./gridThickness);\n    float s = .75*sqrt(gridThickness); // HACK idk\n    g = mix(g, s, min(1., 1.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// similar but with parabola - still just wrong at corners\nfloat gridPara(vec2 p)\n{\n    vec2 q = fract(p);\n    q = max(vec2(0), .5 - gridThickness*.5 - abs(.5 - q));\n    q *= 1.-q; q = 4.*q;\n    float g = 1.-q.x*q.y;\n    g = pow(g, 1./gridThickness);\n    float s = sqrt(gridThickness);\n    g = mix(g, s, min(1., 4.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return gridAASimple(uv);\n    return gridSmooth(uv);\n    return gridPow(uv);\n    return gridSine(uv);\n    return gridExp(uv);\n    return gridPara(uv);\n    return gridSmoothLinear(uv);\n//    return gridSimple(uv);\n//    return gridUnfiltered(uv);\n}\n\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n//    return gridSimple(uv);\n    return gridUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. :\n    \trp.y / -rd.y;\n}\n\n\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y; // cs is a cosine,sine pair representing angle of rotation\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1, 0);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = p.x - iMouse.x;\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float gridline = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(Cfill, Cgrid, gridline); // colorize\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n\n\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3Sz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 620, 649, 649, 727], [729, 729, 758, 758, 846], [850, 1048, 1078, 1078, 1167], [1169, 1383, 1409, 1409, 1489], [1491, 1491, 1521, 1521, 1623], [1625, 1625, 1653, 1653, 2230], [2231, 2347, 2373, 2373, 2593], [2595, 2777, 2809, 2809, 3037], [3039, 3061, 3084, 3084, 3355], [3357, 3371, 3394, 3394, 3694], [3696, 3843, 3867, 3867, 4146], [4148, 4207, 4231, 4231, 4523], [4525, 4564, 4587, 4587, 4838], [4840, 4878, 4901, 4930, 4963], [4994, 5007, 5044, 5044, 5118], [5121, 5121, 5154, 5154, 5304], [5306, 5306, 5345, 5345, 5400], [5403, 5403, 5427, 5427, 5628], [5631, 5631, 5670, 5693, 6730]], "test": "untested"}
{"id": "Wl3XDB", "name": "warmwave", "author": "rotmoset", "description": "Playing with polars & line", "tags": ["polar"], "likes": 0, "viewed": 44, "published": "Public", "date": "1581588070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat line(vec2 p, vec2 a,vec2 b, float width, float blur) { // --- distance to segment with caps\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    float d = length(p - b * h);                      // dist to segment\n    \n    return smoothstep(width-blur, width+blur, d);\n}\n\n\n#define PI 3.14159\n\nvec4 rays(vec2 uv)\n{\n    vec4 c = vec4(0.0);\n    uv.y += sin(uv.x*uv.x * 5.0) / 4.0;\n    \n    float armLength = 0.05 + (sin(iTime / 4.0) + 1.0) / 8.0;\n    \n    \n    vec2 pc = vec2(atan(uv.x,uv.y),sqrt(length(uv)));\n    \n    pc.y += 0.1+(sin(iTime*0.1+pc.x*50.0 ) + 1.0) / 4.0;\n    \n    vec4 rays = vec4(1.0-line(pc, vec2(-PI/3.0,armLength), vec2(PI / 3.0,armLength), 0.5, 0.02), 0.0,0.0,0.0);\n    \n\n   \trays.g += smoothstep(0.4,0.0,length(uv)) * rays.r;\n    \n    rays *= smoothstep(0.025,0.05,length(uv));\n    \n    c += rays;  \n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 c = vec4(0);\n    \n    c.b = 0.4;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n\tc += rays(vec2(uv.x/2.0, uv.y/2.0 +0.13));\n    \n    fragColor = c;\n    \n    \n    \n    fragColor *= pow(smoothstep(-0.8,-0.0,uv.y), 0.8);\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3XDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 61, 98, 321], [344, 344, 364, 364, 892], [894, 894, 951, 951, 1317]], "test": "untested"}
{"id": "Wl3XRM", "name": "Red Round Sphere", "author": "hanabi", "description": "simple sphere imitation", "tags": ["redsphere"], "likes": 0, "viewed": 200, "published": "Public API", "date": "1580570360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n         // = vec2(iResolution.x/iResolution.y, 1.) - 2.0 * fragCoord /iResolution.y;\n    \t // = vec2(1., 1.) - 2.0 * fragCoord /iResolution.xy;\n    vec3 pos = vec3(xy, sqrt(1. - dot(xy, xy)));\n          // = vec3(xy, sqrt(1. - pow(length(xy), 2.0)));\n    vec3 lightPos = normalize(vec3(cos(iTime), sin(iTime), 1.));\n    float l = dot(lightPos, pos);\n    fragColor = l * vec4(1., 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3XRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 518]], "test": "untested"}
{"id": "wl3XW8", "name": "Doodling with Valden", "author": "Flopine", "description": "Here is a doodle I made to practice and prepare the visuals for Valden concert, which happened at the mini cookie party in february\nGo check his music! https://soundcloud.com/valden_music", "tags": ["raymarching", "glow", "hexagongrid", "concert"], "likes": 13, "viewed": 499, "published": "Public", "date": "1580838192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define hr vec2(1., sqrt(3.))\n#define PI 3.141592\n#define TAU (2.*PI)\n#define time (iTime*0.5)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,18.4)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat hd (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(hr)));\n}\n\nvec4 hgrid (vec2 uv,float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv,hr)-hr*0.5;\n    vec2 gb = mod(uv-hr*0.5,hr)-hr*0.5;\n    vec2 guv = (dot(ga,ga)< dot(gb,gb))? ga: gb;\n    \n    vec2 gid = uv-guv;\n    \n    guv.y = 0.5-hd(guv);\n    \n    return vec4(guv,gid);\n}\n\nfloat hexf (vec2 uv)\n{\n    float det = 3.;\n    float speed = 0.5;\n    float d = 0.;\n    for (float i=0.; i<3.; i++)\n    {\n        float ratio = i/5.;\n        uv *= rot(TAU/(5.));\n    \tuv = (mod(i,2.) == 0.) ? vec2(uv.x+iTime*speed,uv.y) : vec2(uv.x,uv.y+iTime*speed);\n        d += step(hgrid(uv, det).y,0.03);\n        speed -= 0.1;\n        det ++;\n    }\n    return d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat fractal (vec3 p)\n{\n    float size = 1.;\n    float d = box(p,vec3(size));\n    for (float i=0.; i<5.; i++)\n    {\n        float ratio = i/5.;\n        p.yz *= rot(time);\n        mo(p.xz, vec2(2.+ratio));\n        mo(p.xy, vec2(0.5+ratio));\n        p.xy *= rot(time+ratio);\n        size -= ratio*1.5;\n        d= stmin(d,box(p,vec3(size)),1., 4.);\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float d = fractal(p);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float mask = step(0.3, abs(sin(length(uv)-PI*time))+0.01);\n    float fx = clamp(mix(1.-hexf(uv), hexf(uv), mask),0.,1.);\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.,0.,-10.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7+dither*0.1;\n        p += d*rd;\n    }\n    \n    col = vec3(0.1,length(uv*0.5),0.7)*g1*0.2;\n    col *= (1.-fx);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 408, 431, 431, 481], [483, 483, 503, 503, 547], [549, 549, 581, 581, 628], [630, 630, 680, 680, 784], [786, 786, 806, 806, 872], [874, 874, 909, 909, 1140], [1142, 1142, 1164, 1164, 1511], [1513, 1513, 1541, 1541, 1628], [1630, 1630, 1654, 1654, 1998], [2015, 2015, 2035, 2035, 2102], [2104, 2104, 2161, 2161, 2865]], "test": "untested"}
{"id": "wl3XWB", "name": "noise_00_ants", "author": "johannprell", "description": "Animated noise similar to TV ants.", "tags": ["noise"], "likes": 2, "viewed": 70, "published": "Public", "date": "1582016420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RESOLUTION 64.\n#define SPEED 1.\n\nfloat random(vec2 v) {\n\treturn fract(sin(dot(v.xy, vec2(37.8479, 84.1047))) * 23479.34593785 + fract(iTime*SPEED));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 noiseUV = uv*RESOLUTION;\n    noiseUV = floor(noiseUV);\n\n    vec3 col = vec3(random(noiseUV));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 63, 63, 158], [160, 160, 217, 217, 395]], "test": "untested"}
{"id": "wl3XWM", "name": "complexify simplify complexify", "author": "jes5199", "description": ":D", "tags": ["2d", "moire"], "likes": 2, "viewed": 69, "published": "Public", "date": "1581036836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv;\n  \n    uv = vec2(0.5 * 3.14159, 0.5 * 3.14159) + (vec2(iResolution.x / 2.0, iResolution.y / 2.0) - fragCoord.xy) / (8.0);\n    \n    float v = 25.;\n    float s = 1.5;\n    float t = cos(iTime / 15.);\n    float value = sin(uv.x) * cos(uv.y) * ((s+v) - t * v);\n    float color = sin(value) * 3.0;\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.5;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, med,1.0);\n    } else {\n      fragColor = vec4(min(0.5, med / 2.0), high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 601]], "test": "untested"}
{"id": "wl3XWN", "name": "Tracing Warm Light", "author": "enci", "description": "Simple Monte Carlo path tracing. The BRDF is very fake for now.", "tags": ["pathtracing"], "likes": 24, "viewed": 405, "published": "Public", "date": "1580939323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FLT_MAX 1000000000.0\n#define EPSILON 0.001\n#define SLOPE_EPSILON 0.008\n#define SAMPLES 64\n#define BOUNCES 4\n#define COSINE_SAMPLING 1\n\n#define MAT_WHITE           0\n#define MAT_LIGHT           1\n#define MAT_PIXEL           2\n#define MAT_NOISE           3\n#define MAT_STRIPES         4\n#define MAT_ROUGH           5\n#define MAT_WET             6\n#define MAT_PULSE           7\n#define MAT_MIRROR          8\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Simplex Noise\n////////////////////////////////////////////////////////////////////////////////\n\nfloat randFancy(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat rand3D(in vec3 co)\n{\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n//\tSimplex 3D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nfloat snoise(in vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n//\tSimplex 4D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n}\n\nstruct Intersection\n{\n    float distance;\n    int objectID;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 color;\n    float emmisive;\n    float roughness;\n};\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n    int material;    \n};\n\nstruct Box\n{\n    vec3 origin;\n    vec3 extent;\n    int material;    \n};\n\nstruct Camera\n{\n    vec3 origin;\n\tvec3 lowerLeftCorner;\n\tvec3 horizontal;\n\tvec3 vertical;\n};\n\n// From Lighthouse\nuint WangHash(inout uint s)\n{\n    s = (s ^ uint(61)) ^ (s >> 16);\n    s *= uint(9);\n    s = s ^ (s >> 4);\n    s *= uint(0x27d4eb2d);\n    s = s ^ (s >> 15);\n    return s;\n}\n\nuint RandomInt(inout uint s)\n{\n    s ^= s << 13;\n    s ^= s >> 17;\n    s ^= s << 5;\n    return s;\n}\n\nfloat RandomFloat(inout uint s)\n{\n    //return float(RandomInt(s)) * 2.3283064365387e-10;    \n    return fract(float(RandomInt(s)) / 3141.592653);\n}\n\nvec3 RandomVec3(inout uint s)\n{\n    vec3 v = vec3(\n        (RandomFloat(s) - 0.5f) * 2.0,\n        (RandomFloat(s) - 0.5f) * 2.0,\n        (RandomFloat(s) - 0.5f) * 2.0);\n    return v;\n}\n\nvec3 RandomUnitSphere(inout uint s)\n{\n    vec3 v = vec3(1.0);\n    for(int i = 0; i < 16; i++)\n\t{\n        v = RandomVec3(s);\n        if(length(v) <= 1.0)\n            break;\n\t}    \n    //return v;\n    return normalize(v);\n}\n\n#define SPHERE_COUNT 11\nconst Sphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](\n\t  Sphere(vec3(0.0, 2.0, 0.0), 2.0, MAT_STRIPES)                     // Big middle\n\t, Sphere(vec3(3.0, 1.0, 0.0), 1.0, MAT_ROUGH)            \n    , Sphere(vec3(0.0, 0.5, 2.6), 0.5, MAT_PULSE)                       \n    , Sphere(vec3(0.0, 1.0, -4.0), 1.0, MAT_MIRROR)\n    , Sphere(vec3(-3.0, 0.7, 0.0), 0.7, MAT_WHITE)\n    , Sphere(vec3(0.0, -10000.0, 0.0), 10000.0, MAT_WET)              // Bottom\n    , Sphere(vec3(0.0, 10009.0, 0.0), 10000.0, MAT_WHITE)               // Top\n    , Sphere(vec3(10009.0, 0.0, 0.0), 10000.0, MAT_PIXEL)               // Side\n    , Sphere(vec3(-10009.0, 0.0, 0.0), 10000.0, MAT_NOISE)              // Side\n    , Sphere(vec3(0.0, 0.0, 10009.0), 10000.0, MAT_WHITE)               // Side\n    , Sphere(vec3(0.0, 0.0, -10009.0), 10000.0, MAT_WHITE)              // Side    \n);\n\nconst vec3 background = vec3(1.0f, 0.96, 0.92);\n\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    // compute basis from normal\n    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n    // (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nfloat sphereTest(in Ray ray, in Sphere sphere)\n{\n    float t = -1.0;\n\tvec3 rc = ray.origin - sphere.origin;\n\tfloat c = dot(rc, rc) - (sphere.radius * sphere.radius);\n\tfloat b = dot(ray.direction, rc);\n\tfloat d = b*b - c;\n    if(d > 0.0)\n    {\n\t    t = -b - sqrt(abs(d));\n        return t;\n\t    float st = step(0.0, min(t,d));\n    } else  \n    {\n        return -1.0;\n    }\n}\n\nIntersection intersect(in Ray ray)\n{\n    float minD = FLT_MAX;\n    Intersection intersection;\n    for(int i = 0; i < SPHERE_COUNT; i++)\n    {\n        Sphere s = spheres[i];\n        float t = sphereTest(ray, s);\n        if(t > 0.0 && t < minD)\n        {\n            minD = t;\n            intersection.distance = t;\n            intersection.objectID = i;\n        }\n    }\n    return intersection;\n}\n\nvec3 getNormal(in vec3 position, in int objectID)\n{\n    Sphere s = spheres[objectID];\n    return normalize(position - s.origin);\n}\n\nMaterial getMaterial(in vec3 position, in int objectID)\n{\n    int mat = spheres[objectID].material;\n    switch(mat)\n    {\n        case MAT_WHITE :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 1.0);\n        }\n        case MAT_LIGHT :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 1.0, 1.0);\n        }\n        case MAT_PIXEL :\n          {\n            if(rand3D(round(position + vec3(iTime * 6.0, 0.0, 0.0))) > 0.70)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.05);\n        }                \n        case MAT_NOISE : \n        {\n            //if(abs(snoise(position + vec3(iTime * 1.0, 0.0, 0.0))) < 0.01)\n            //if(rand3D(round(position * 5.0 + vec3(iTime * 6.0, 0.0, 0.0))) > 0.70)\n            if(sin((position.y - position.z + iTime * 2.9) * 4.0) < 0.0)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.85);\n        }\n        case MAT_STRIPES :\n        {\n            if(sin((position.y + position.z + iTime * 0.9) * 12.0) < 0.0)\n                return Material(vec3(1.20, 1.0, 1.0), 1.0, 1.0);\n            else\n                return Material(vec3(1.0, 1.0, 1.0), 0.0, 1.0);\n        }\n        case MAT_ROUGH :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.5);\n        }\n        case MAT_WET :\n        {\n            float noiz = abs(pow(snoise(position), 2.0));\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, noiz);            \n        }\n        case MAT_PULSE :\n        {\n            float v = pow(max(sin(iTime * 10.9), 0.0), 3.0);\n            return Material(vec3(v, v, v), 2.0, 1.0);            \n        }\n        case MAT_MIRROR :\n        {\n            return Material(vec3(1.0, 1.0, 1.0), 0.0, 0.0);\n        }\n            break;\n    }\n}\n\nvec3 getBackground(in vec3 direction)\n{\n    return vec3(0.9, 0.85, 1.0);\n}\n\nCamera MakeCamera(  in vec3 origin,\n                    in vec3 lookAt,\n                    in vec3 up,\n\t                float fov,\n\t                float aspect)\n{\n    Camera camera;\n    vec3 u, v, w;\n\tfloat theta = radians(fov);\n\tfloat halfHeight = tan(theta * 0.5f);\n\tfloat halfWidth = aspect * halfHeight;\n\tw = normalize(origin - lookAt);\n\tu = normalize(cross(normalize(up), w));\n\tv = normalize(cross(w, u));\n    camera.origin = origin;\n\tcamera.lowerLeftCorner =  origin - halfWidth * u - halfHeight * v - w;\n\tcamera.horizontal = 2.0f * halfWidth * u;\n\tcamera.vertical = 2.0f * halfHeight * v;\n    return camera;\n}\n\nRay MakeRay(in Camera camera,float s, float t)\n{\n    vec3 direction = camera.lowerLeftCorner + s * camera.horizontal + (1.0f -  t) * camera.vertical - camera.origin;\n    direction = normalize(direction);\n\treturn Ray(camera.origin, direction);\n}\n\nvec3 lightDirection()\n{\n    float x = sin(0.5 * 5.0);\n    float y = 1.0;\n    float z = cos(0.5 * 5.0) - 3.0;\n    return normalize(vec3(x, y, z));\n}\n\nfloat sphereTest(   vec3 ray,\n                    vec3 dir,\n                    vec3 center,\n                    float radius,\n                    out vec3 normal,\n                    out float t)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tt = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n    vec3 pos = ray + dir * t;\n    normal = pos - center;\n    normal = normalize(normal);\n    return mix(-1.0, t, st);\n}\n\nvec3 applyLighting(in vec3 position, in vec3 normal, int objectID)\n{\n    return vec3(0.0);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    return vec3(max(dot(normal, light), 0.0));\n}\n\nvec3 getBRDFRay(in vec3 position, in vec3 normal, in vec3 incident, int objectID, inout uint seed)\n{    \n    vec3 ref = reflect(incident, normal);\n    Sphere sphere = spheres[objectID];\n    Material material = getMaterial(position, objectID);\n    vec3 offset = mix(ref, normal, material.roughness);\n    //return normalize(RandomUnitSphere(seed) * material.roughness + offset);\n    return normalize(RandomUnitSphere(seed) * material.roughness + ref);\n}\n\nvec3 GetHemisphereVector(in vec3 normal, inout uint seed)\n{\n    vec3 r = RandomUnitSphere(seed);\n    if(dot(normal, r) < 0.0)\n        return -r;\n    return r;\n}\n\n// create light paths iteratively\nvec3 rendererCalculateColor(Ray ray, in int bounces, uint seed)\n{\n    vec3 accumulator = vec3(0.0);  // accumulator - should get brighter\n    vec3 mask = vec3(1.0);  // mask - should get darker\n\n    for( int i = 0; i < bounces; i++)\n    {\n        // intersect scene\n        Intersection intersection = intersect(ray);\n        \n        // if nothing found, return background color or break\n        if(intersection.distance <= 0.0) \n            break;\n        \n        // get position and normal at the intersection point\n        vec3 pos = ray.origin + ray.direction * intersection.distance;\n        vec3 normal = getNormal(pos, intersection.objectID);\n        \n        // get color for the surface\n        Material material = getMaterial(pos, intersection.objectID);\n\n        // compute direct lighting\n        vec3 emmisive = material.emmisive * material.color;\n\n        // prepare ray for indirect lighting gathering        \n#ifdef COSINE_SAMPLING\n        vec3 dir = getBRDFRay(pos, normal, ray.direction, intersection.objectID, seed);        \n#else   \n        vec3 dir = GetHemisphereVector(normal, seed);     \n#endif\n        ray.direction = dir;\n        float ND = max(dot(ray.direction, normal), 0.0);\n        ray.origin = pos + normal * (1.0 - pow(ND, 2.0)) * SLOPE_EPSILON;\n\n        // surface * lighting\n#ifdef COSINE_SAMPLING\n        mask *= material.color;\n#else   \n        mask *= material.color * ND * (3.14 / 2.0);             \n#endif\n\n        accumulator += mask * emmisive;\n    }\n\n    return accumulator;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float width = iResolution.x;\n    float height = iResolution.y;\n    \n    float cx = sin(iTime * 1.0) * 10.0;\n    float cy = 1.0;\n    float cz = cos(iTime * 1.0) * 10.0; \n\n    Camera camera = MakeCamera(\n        vec3(cx, cy, cz),\n        vec3(0.0, 2.0, 0.0),\n        vec3(0.0, 0.1, 0.0),\n        60.0, 1.6);\n\n    vec3 sa = hash( uvec3(x, y, iTime * 60.0) );\n    uint seed = (uint(x) + uint(y) * uint(width)) ^ uint(iTime * 10000000.0);\n    seed = WangHash(seed);\n\n    vec3 color = vec3(0.0);\n    for( int i = 0; i < SAMPLES; i++)\n    {\n        float xs = x + RandomFloat(seed) + 0.5;\n        float ys = y + RandomFloat(seed) + 0.5;\n        Ray ray = MakeRay(camera, xs / width, 1.0 - (ys / height));\n        color += rendererCalculateColor(ray, BOUNCES, seed);\n        seed += uint(hash(float(i)) * 100.0);\n    }\n    color /= float(SAMPLES);\n\n    fragColor = vec4(pow(color, vec3(0.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 595, 621, 621, 820], [822, 822, 848, 848, 930], [932, 932, 953, 953, 990], [991, 991, 1018, 1018, 1066], [1067, 1067, 1086, 1086, 1122], [1123, 1123, 1142, 1142, 1178], [1180, 1233, 1258, 1258, 3088], [3089, 3142, 3165, 3165, 3209], [3210, 3210, 3239, 3239, 3287], [3289, 3289, 3318, 3318, 3578], [4021, 4040, 4069, 4069, 4211], [4213, 4213, 4243, 4243, 4312], [4314, 4314, 4347, 4407, 4462], [4464, 4464, 4495, 4495, 4648], [4650, 4650, 4687, 4687, 4871], [5839, 5849, 5871, 5871, 5999], [6001, 6001, 6025, 6025, 6068], [6070, 6070, 6121, 6308, 6635], [6637, 6637, 6685, 6685, 7010], [7012, 7012, 7048, 7048, 7407], [7409, 7409, 7460, 7460, 7539], [7541, 7541, 7598, 7598, 9438], [9440, 9440, 9479, 9479, 9514], [9516, 9516, 9680, 9680, 10134], [10136, 10136, 10184, 10184, 10380], [10382, 10382, 10405, 10405, 10529], [10531, 10531, 10729, 10729, 11016], [11018, 11018, 11086, 11086, 11206], [11208, 11208, 11308, 11308, 11659], [11661, 11661, 11720, 11720, 11821], [11823, 11857, 11922, 11922, 13378], [13380, 13380, 13436, 13436, 14388]], "test": "untested"}
{"id": "wl3XWs", "name": "Blue noise vs Bayer dithering", "author": "Suslik", "description": "This shader compares dithering quality using either blue noise or bayer matrices on moving objects. Note that even  though blue noise has somewhat superior quality of dithering compared to bayer noise, it has a very perceptible moving pattern.", "tags": ["dithering", "bluenoise", "bayermatrices"], "likes": 10, "viewed": 382, "published": "Public", "date": "1581941031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float RaySphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n\tfloat scale = -1.0;\n\n\tfloat a = dot(rayDir, rayDir);\n\tvec3 delta = rayStart - sphereCenter;\n\tfloat b = 2.0 * dot (delta, rayDir);\n\tfloat c = dot(sphereCenter, sphereCenter) + dot(rayStart, rayStart) - 2.0 * dot(rayStart, sphereCenter) - sphereRadius * sphereRadius;\n\tfloat disc = b * b - 4.0 * a * c;\n\tif (disc > 0.0)\n\t{\n\t\tfloat sqrtDisc = sqrt(disc);\n\n\t\tscale = (-b - sqrtDisc) / (2.0 * a);\n\t}\n\treturn scale;\n}\n\nfloat RaytraceScene(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenters[2], vec3 lightPos)\n{\n    for(int i = 0; i < 2; i++)\n    {\n        float hitScale = RaySphereIntersection(rayOrigin, rayDir, sphereCenters[i], iResolution.x * 0.14);\n        if(hitScale < 0.0)\n            continue;\n        vec3 hitPoint = rayOrigin + rayDir * hitScale;\n        vec3 normal = normalize(hitPoint - sphereCenters[i]);\n        \n        float diffuse = max(0.0, dot(normal, -normalize(hitPoint - lightPos)));\n        return diffuse * 0.8 + 0.2;\n    }\n    return 0.1;\n}\n\nfloat GetBayerDither(float grayscale, ivec2 pixelCoord)\n{    \n    //use this for 2x2 bayer test\n    /*int bayerMatrix4[4] = int[4](0, 2, 3, 1);\n    int pixelIndex4 = (pixelCoord.x % 2) + (pixelCoord.y % 2) * 2;\n    return grayscale > (float(bayerMatrix4[pixelIndex4]) + 0.5) / 4.0 ? 1.0 : 0.0;*/\n\n    //use this for 8x8 bayer test\n    /*vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / 8.0; //8 is the texture size\n    return textureLod(iChannel0, fract(uv), 0.0).x < grayscale ? 1.0 : 0.0; //8x8 creates more artifacts on moving objects than 4x4*/\n    \n    //this is the default 4x4 bayer\n    int bayerMatrix16[16] = int[16](0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n    int pixelIndex16 = (pixelCoord.x % 4) + (pixelCoord.y % 4) * 4;\n    return grayscale > (float(bayerMatrix16[pixelIndex16]) + 0.5) / 16.0 ? 1.0 : 0.0;\n}\n\nfloat GetBlueNoiseDither(float grayscale, ivec2 pixelCoord)\n{\n    vec2 uv = (vec2(pixelCoord) + vec2(0.5)) / 1024.0; //1024 is the texture size\n    float blueNoiseValue = textureLod(iChannel1, fract(uv), 0.0).x;\n    //blueNoiseValue = sin(blueNoiseValue * 2.0 * 3.141592 + iTime) * 0.5 + 0.5;\n    return blueNoiseValue < grayscale ? 1.0 : 0.0;\n}\n\nfloat GetPixelColor(vec2 pixelCoord)\n{\n    float xPos = mix(iResolution.x * 0.2, iResolution.x * 0.8, sin(iTime) * 0.5 + 0.5);\n    float yPos = sin(iTime * 3.0) * 0.05 * iResolution.y * 0.0;\n    vec3 sphereCenters[2];\n    sphereCenters[0] = vec3(xPos, iResolution.y * 0.25 + yPos, 0.0);\n    sphereCenters[1] = vec3(xPos, iResolution.y * 0.75 - yPos, 0.0);\n    \n    vec3 lightPos = vec3(iResolution.x * (1.5), iResolution.y * 0.5, -1.5 * iResolution.x);\n    \n    vec3 rayOrigin = vec3(iResolution.x * 0.5, iResolution.y * 0.5, -iResolution.x);\n    vec3 rayDst = vec3(pixelCoord.xy, 0.0);\n    vec3 rayDir = normalize(rayDst - rayOrigin);\n    vec3 normals[2];\n\t\n    float grayscale = RaytraceScene(rayOrigin, rayDir, sphereCenters, lightPos);\n    float ditherColor = 0.0;\n    if(pixelCoord.y > iResolution.y * 0.5)\n    {\n        ditherColor = GetBayerDither(grayscale, ivec2(pixelCoord));\n    }else\n    {\n        ditherColor = GetBlueNoiseDither(grayscale, ivec2(pixelCoord));\n    }\n    //ditherColor = grayscale; //use for test without dithering\n    return ditherColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float linearColor = 0.0;\n    if(sin(iTime) * 0.5 + 0.5 > abs(fragCoord.y / iResolution.y - 0.5) * 2.0)\n    {\n        linearColor = GetPixelColor(fragCoord.xy);\n    }else\n    {\n        ivec2 offset;\n        float sumColor = 0.0f;\n        float sumWeight = 0.0f;\n        for(int x = -2; x < 2; x++)\n        {\n            for(int y = -2; y < 2; y++)\n            {\n                sumColor += GetPixelColor(fragCoord.xy + vec2(x, y));\n                sumWeight += 1.0;\n            }\n        }\n        linearColor = sumColor / sumWeight;\n    }\n    fragColor = vec4(pow(vec3(linearColor), vec3(1.0 / 2.2)), 1.0); //linear->srgb manual conversion as shadertoy does not support actual srgb\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 96, 96, 509], [511, 511, 599, 599, 1058], [1060, 1060, 1117, 1643, 1890], [1892, 1892, 1953, 1953, 2237], [2239, 2239, 2277, 2277, 3308], [3309, 3309, 3366, 3416, 4109]], "test": "untested"}
{"id": "WlcSD8", "name": "Golden Section Zoom", "author": "fizzer", "description": "I saw an animated GIF somewhere that shows an endless loop zooming into \"squared rectangles\", which I guessed must be arranged in a configuration based on the golden ratio so I went and tried it.", "tags": ["zoom", "phi", "infinite", "goldenratio"], "likes": 14, "viewed": 271, "published": "Public", "date": "1580826600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// For this to work, it needs a rectangle which can be split into a square and another rectangle\n// with the same edge-length ratios, such as x:1 where 1 / (x - 1) == x or (x - 1) == 1 / x\n// and the golden ratio satisfies this equation.\n\n// This variant by FabriceNeyret2 does it \"the other way around\" and draws boxes outwards from the center\n// by placing the boxes on a golden spiral path: https://www.shadertoy.com/view/3llGD7\n\nconst float phi = (sqrt(5.) + 1.) / 2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    // Jittered time value for cheap motionblur\n    float t = iTime + texelFetch(iChannel0, ivec2(fragCoord.xy) & 1023, 0).r / 60.;\n    \n    vec2 pp = vec2(pow(phi - 1., 4.), pow(phi - 1., 3.));\n    \n    // Calculate the limit point of nested transformations for zooming in to    \n    vec2 zc = vec2(1., pp.y) / (1. - pp.x);\n    \n    uv -= .5 * vec2(iResolution.x / iResolution.y, 1);\n    uv += vec2(cos(t / 3.), sin(t / 2.)) * .1;\n    \n    float a = t;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    // Exponential scaling transform, for a seamless (self-similar) zooming animation.\n    float scale = pow(pp.x, 1. + fract(t));\n    \n    uv = m * uv * scale + zc;\n\n    vec3 c = vec3(0);\n\n    // Repeatedly subdivide pixelspace into a square and rectangle with edge lengths in ratio 1:(phi-1)\n    // Note that such a rectangle has the same shape as a rectangle with ratio 1:phi\n    for(int i = 0; i < 32; ++i)\n    {\n        float j = float(i) + floor(t) * 4.;\n        if(uv.x < 1.)\n        {\n            // Pixel is inside this square. Pick a colour and break out.\n            c = sin(vec3(j, j * 2., j * 3.)) * .5 + .5;\n            break;\n        }\n        // Pixel is inside the rectangle, so continue subdividing.\n        uv = (uv - vec2(1., 1.)).yx * vec2(-1, 1) * phi;\n    }\n    \n    fragColor.rgb = sqrt(c);\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 474, 531, 531, 1923]], "test": "untested"}
{"id": "wlcSDf", "name": "3d Chessboard", "author": "6502", "description": "First experiment", "tags": ["3dchessboard"], "likes": 2, "viewed": 58, "published": "Public", "date": "1581843966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0., 0., 0., 1.0);\n    float ksq = 8.2 / iResolution.y,\n          x0 = (iResolution.x - 8.0/ksq)*0.5,\n          y0 = (iResolution.y - 8.0/ksq)*0.5,\n          fx = (fragCoord.x - x0) * ksq - 4.0,\n          fy = (fragCoord.y - y0) * ksq - 4.0,\n          c = cos(iTime*0.3), s = sin(iTime*0.1),\n          z = 1.2 / (1.8 - fragCoord.y / iResolution.y),\n          rx = 4.0 + z*(fx*c + fy*s),\n          ry = 4.0 + z*(fy*c - fx*s);\n    int ix = int(floor(rx));\n    int iy = int(floor(ry));\n    if (ix >= 0 && ix < 8 && iy >= 0 && iy < 8) {\n        vec4 n = texture(iChannel0, vec2(rx, ry)*0.25)*0.3-0.1;\n        if (ix+iy != (ix + iy)/2*2) {\n            fragColor = (n+vec4(0.7, 0.8, 0.9, 1.0))*(1.7-z);\n        } else {\n            fragColor = (n+vec4(0.5, 0.6, 0.7, 1.0))*(1.7-z);\n        }\n    }\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 871]], "test": "untested"}
{"id": "wlcSWf", "name": "petal 3 (139 chars)", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/wtcSDX[/url]", "tags": ["2d", "onetweet", "golf"], "likes": 5, "viewed": 235, "published": "Public API", "date": "1581837689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/wtcSDX\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R  = iResolution.xy, U  = u+u - R ;\n    O += .5 + ( R.x = sin( 30.*( abs( cos( 3.* atan(U.y,U.x) -iTime )) - length(U)/R.y +iTime ) ) ) / fwidth(R.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 86, 86, 248]], "test": "untested"}
{"id": "wlcXD2", "name": "Box - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a box. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "box"], "likes": 5, "viewed": 1166, "published": "Public API", "date": "1581747055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a box. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\n\n// Other Box functions\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n//\n// Intersection:     https://www.shadertoy.com/view/ld23DV\n// Occlusion:        https://www.shadertoy.com/view/4sSXDV\n// Occlusion:        https://www.shadertoy.com/view/4djXDy\n// Density:          https://www.shadertoy.com/view/Ml3GR8\n// Fake soft shadow: https://www.shadertoy.com/view/WslGz4\n// Gradient:         https://www.shadertoy.com/view/wlcXD2\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // corner radious\n    float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgBox(p,vec2(0.8,0.3));\n    float d = dg.x-ra;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXD2.jpg", "access": "shaders20k", "license": "mit", "functions": [[2583, 2678, 2715, 2715, 2976], [2979, 2979, 3036, 3036, 3709]], "test": "untested"}
{"id": "WlcXDN", "name": "Voronoi Variations", "author": "gressettd", "description": "Flexible voronoi function. Not all combos work. Red dot = distance metric. Green dot = data index (f1,f2, etc). Blue dot = invert or not.\n", "tags": ["voronoi", "worley"], "likes": 5, "viewed": 84, "published": "Public", "date": "1580919535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WORLEY_EUCLIDIAN 0\n#define WORLEY_MANHATTAN 1\n#define WORLEY_CHEBYSHEV 2\n#define WORLEY_TRIANGULAR 3\n#define WORLEY_8THDEG 4\n#define WORLEY_SINE 5\n#define WORLEY_MINK4 6\n#define WORLEY_MINK05 7\n#define WORLEY_QUAD 8\n\n\nuint BaseHash(uvec2 p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4 * ((h32 << 17) | (h32 >> (32 - 17))); \n\th32 = PRIME32_2 * (h32 ^ (h32 >> 15));\n\th32 = PRIME32_3 * (h32 ^ (h32 >> 13));\n\treturn h32 ^ (h32 >> 16);\n}\n\nvec2 Hash22(uvec2 x)\n{\n\tuint n = BaseHash(x);\n\tuvec2 rz = uvec2(n, n * 48271U);\n\treturn vec2((rz.xy >> 1) & uvec2(0x7fffffffU, 0x7fffffffU)) / float(0x7fffffff);\n}\n\n\nvec2 Random2DVector2(vec2 p)\n{\n\treturn Hash22(uvec2(floatBitsToUint(p.x),floatBitsToUint(p.y)));\n}\n\nfloat RootN(float x, float y)\n{\n    return pow(x, (1.0 / y));\n}\n\nfloat Length2P8(vec2 p)\n{\n    float d = pow(p.x,8.0) + pow(p.y,8.0);\n    return RootN(d, 8.0);\n}\n\nfloat Map(float value, float old_lo, float old_hi, float new_lo, float new_hi)\n{\n    float old_range = old_hi - old_lo;\n    float new_range = new_hi - new_lo;\n    return (((value - old_lo) * new_range) / old_range) + new_lo;\n}\n\nfloat DistanceByMetric(vec2 p, vec2 o, vec2 r, int distanceMetric)\n{\n\tfloat d = 0.0;\n\tswitch (distanceMetric)\n\t{\n\tcase WORLEY_EUCLIDIAN:\n\t\td = length(r); // euclidian\n\t\tbreak;\n\n\tcase WORLEY_MANHATTAN:\n\t\td = abs(r.x) + abs(r.y);  // manhattan\n\t\tbreak;\n\n\tcase WORLEY_CHEBYSHEV:\n\t\td = max(abs(r.x), abs(r.y)); // chebyshev\n\t\tbreak;\n\n\tcase WORLEY_TRIANGULAR:\n\t\td = max(abs(r.x)*0.866025 + r.y*0.5, -r.y); // triangular xy plane\n\t\tbreak;\n\n\tcase WORLEY_8THDEG:\n\t\td = Length2P8(r); // 8th degree len.\n\t\tbreak;\n        \n    case WORLEY_SINE:\n        d = length(r) + (1.0 + sin(16.0*length(r))) * 0.5;\n        break;\n        \n    case WORLEY_MINK4:\n        d = sqrt(sqrt(dot(r * r, r * r)));\n        break;\n        \n    case WORLEY_MINK05:\n        d = sqrt(sqrt(abs(r.x))+sqrt(abs(r.y)) );\n        break;\n        \n    case WORLEY_QUAD:\n        d = r.x*r.x+r.y*r.y+r.x*r.y;\n        break;\n\n\t\n\t}\n\n\treturn d;\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(3.14159 * 2.0 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nvoid WorleyNoise2D(\n    vec2 p, \n    int distanceMetric, \n    bool invert, \n    float falloff,\n    out vec4 cca, \n    out vec4 ccb, out vec4 ccc)\n{\n\n\tvec2 n = floor(p);\n\tvec2 nf = fract(p);\n\tvec2 h = step(0.5, nf) - 2.0;\n\tn += h; \n\tnf -= h;\n\n\tvec4 f = vec4(8.0, 8.0, 8.0, 8.0);\n\tvec2 mg, mr;\n\tfloat res = 0.0;\n\n\tfor(int j=0; j<=3; j++)\n\tfor (int i=0; i<=3; i++)\n\t{\n\t\tvec2 g = vec2(float(i), float(j));\n\t\tvec2 o = Random2DVector2(n + g);\n\t\tvec2 r = g + o - nf;\n\n\t\tfloat d = DistanceByMetric(p, o, r, distanceMetric);\n        \n        res += 1.0 / pow(d, falloff);\n\n\t\tif (d < f.x)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = f.y;\n\t\t\tf.y = f.x;\n\t\t\tf.x = d;\n\t\t\tmr = r;\n\t\t\tmg = g;\n\t\t}\n\t\telse if (d < f.y)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = f.y;\n\t\t\tf.y = d;\n\n\t\t}\n\t\telse if (d < f.z)\n\t\t{\n\t\t\tf.w = f.z;\n\t\t\tf.z = d;\n\n\t\t}\n\t\telse if (d < f.w)\n\t\t{\n\t\t\tf.w = d;\n\t\t}\n\n\t\t\n\n\t}\n\n\t// distance to borders\n\n\tfloat minDist = 8.0;\n\tfor (int j = 0; j <= 3; j++)\n\t\tfor (int i = 0; i <= 3; i++)\n\t\t{\n\t\t\tvec2 g = vec2(float(i), float(j));\n\t\t\tvec2 o = Random2DVector2(n + g);\n\t\t\tvec2 r = g + o - nf;\n\n\t\t\tif (dot(mr - r, mr - r) > 0.00001)\n\t\t\t{\n\t\t\t\tfloat dist = dot(0.5*(mr + r), normalize(r - mr));\n\t\t\t\tminDist = min(minDist, dist);\n\t\t\t}\n\t\t}\n\n    float v;\n    \n\t// f1\n\tcca.x = invert ? 1.0 - f.x : f.x;\n\n\t// f2\n\tcca.y = invert ? 1.0 - f.y : f.y;\n\n\t// f3\n\tcca.z = invert ? 1.0 - f.z : f.z;\n\n\t// f4\n    v= clamp(max(0.5,16.0 * (f.y-f.x)), 0.0, 1.0);\n    v = minDist < (falloff/50.0) ? (1.0 - minDist) : 0.0; // 1.0: 0.0;\n\tcca.w = invert ? 1.0 - v: v;\n\n\t\n\t// f2 - f1\n\tv = f.y - f.x;\n\tccb.x = invert ? 1.0 - v : v;\n\n\t// f1 + f2\n\tv = f.x + f.y;\n\tccb.y = invert ? 1.0 - v : v;\n\n\t// (f1 + f2 + f3 + f4) / 4\n\tv = (f.x + f.y + f.z + f.w) * 0.25;\n\tccb.z = invert ? 1.0 - v : v;\n\n\t// border distance\n\tccb.w = minDist;\n    \n    // f4\n    ccc.x = invert ? 1.0 - f.w : f.w;\n\n    // rounded\n\tv = 1.0 / (1.0 / (f.y - f.x) + 1.0 / (f.z - f.x));\n\tccc.y = invert ? 1.0 - v : v;\n\n    // f2^2 - f1^2\n\tv = (f.y*f.y) - (f.x*f.x);\n\tccc.z = invert ? 1.0 - v : v;\n\n    // smoothed\n\tv = pow(1.0 / res, 0.5 / falloff);\n\tccc.w = invert ? 1.0 - v : v;\n\n\t\n}\n\nvec4 MapColor(float intensity, int pallette)\n{\n    vec4 retval;\n    \n    switch(pallette)\n    {\n        case 0: retval = vec4(intensity); break;\n        case 1: \n        {\n            vec4 bias = vec4(0.000, 0.500, 0.500, 1.0);\n            vec4 scale = vec4(0.000, 0.500, 0.500, 1.0);\n            vec4 freq = vec4(0.000, 0.500, 0.333, 1.0);\n            vec4 phase = vec4(0.000, 0.500, 0.667, 1.0);\n  \n    \t\tvec4 col = ComputeWaveGradientRGB(intensity,bias,scale,freq,phase);\n    \t\tretval =  vec4(col.xyz, 1.0);\n        }\n        break;\n        \n        case 2: retval = vec4(clamp(vec3(3.0, 3.0, 4.0) * intensity - vec3(0.0, 1.0, 3.0), 0.0, 1.0),1.0); break;\n\n    }\n    \n    return retval;\n}\n\nbool InsideCount(vec2 px, int count, vec2 tl)\n{\n    bool rv = false;\n    \n    float md = 9999.0;\n    for(int i =0; i < count; i++)\n    {\n        vec2 c = vec2(tl.x + (float(i) * 20.0), tl.y);\n        float d = length(px-c);\n        md = min(d, md);\n    }\n    \n    rv = md < 8.0;\n    \n    return rv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n\tfloat maxRes = max(res.x, res.y);\n\tvec2 pos = vec2(fragCoord.x,fragCoord.y);\n    vec2 p = (2.0 * pos - res) / min(res.x, res.y);\n    \n    float scale = Map( (sin(iTime * 0.4)+1.0) * 30.0, 0.0,60.0,1.0,4.0);\n    vec2 translate = vec2(iTime * 0.33);\n    \n    p *= scale;\n    p += translate;\n        \n    int metric = 0; // 0 - 6 \n    int data = 0;   // 0 - 7 change every 6s\n    bool invert = false; // change every 3s\n    \n    int tScale = 1;\n    int iSec = int(floor(iTime)) / tScale;\n    \n    invert = (iSec / 3) % 2 == 1;\n    data = (iSec / 6) % 12;\n    metric = (iSec / 72) % 9;\n    \n    \n    vec4 cca, ccb, ccc;\n    WorleyNoise2D(p, metric, invert, Map(sin(iTime * 3.0), -1.0, 1.0, 2.0, 8.0), cca, ccb, ccc);\n    \n    float value= 0.0;\n    switch(data)\n    {\n        // data index (GREEN)\n        case 0:value = cca.x; break; // f1\n        case 1:value = cca.y; break; // f2\n        case 2:value = cca.z; break; // f3\n        case 3:value = cca.w; break; // f4\n        case 4:value = ccb.x; break; // f2-f1\n        case 5:value = ccb.y; break; // f1+f2\n        case 6:value = ccb.z; break; // (f1+f2+f3+f4)/4\n        case 7:value = ccb.w; break; // border distance\n        case 8:value = ccc.x; break; // f4\n        case 9:value = ccc.y; break; // rounded\n        case 10:value= ccc.z; break; // f2^2 - f1^2\n        case 11:value= ccc.w; break; // smoothed\n    }\n    \n    vec4 col = MapColor(value, 1);\n    \n    // invert: blue. 2 = true, 1 = false\n    if(InsideCount(pos, invert ? 2: 1, vec2(40.0,40.0))) col = vec4(0.0,0.0,1.0,1.0); \n    else\n    // data: green. cc index\n    if(InsideCount(pos, data + 1, vec2(40.0,60.0))) col = vec4(0.0,1.0,0.0,1.0);\n    else\n    // metric: red. \n    if(InsideCount(pos, metric + 1, vec2(40.0,80.0))) col = vec4(1.0,0.0,0.0,1.0);\n    \n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 250, 250, 582], [584, 584, 606, 606, 747], [750, 750, 780, 780, 848], [850, 850, 881, 881, 913], [915, 915, 940, 940, 1011], [1013, 1013, 1093, 1093, 1239], [1241, 1241, 1309, 1309, 2139], [2141, 2141, 2225, 2225, 2338], [2340, 2340, 2487, 2487, 4412], [4414, 4414, 4460, 4460, 5105], [5107, 5107, 5154, 5154, 5407], [5410, 5410, 5467, 5467, 7348]], "test": "untested"}
{"id": "WlcXR2", "name": "Apollonian-II-v4", "author": "jorge2017a1", "description": "Apollonian-II-v4", "tags": ["apollonianiiv4"], "likes": 1, "viewed": 90, "published": "Public", "date": "1581296103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map(vec3 ppp)\n{\n    vec3 p;\n    p=ppp;\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime*0.5;\n    \n    // Loop counter and variables.\n    float i=0., s,k;\n        s = 1.;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    //while(i++<6.) p *= k = 1.5/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n    \n    vec3 pp;\n    \n    while(i++<6.)\n     {\n      \n       \n\t\t\n         pp= mod(p - 1., 2.) - 1.;\n         p =pp;\n \n         k = 1.0/dot(pp, p);\n         p *= k ;\n         s *= k;\n         \n     }\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n    \n    //return length(p)/s - .01; \n    \n    //return  vec3( length(p)/s - .01,k,s+k); \n    \n    float a1, a2,a3;\n    \n    a1= dot(p.xy,p.xy);\n    a2= dot(p.yz,p.yz);\n    a3= dot(p.zx,p.zx);\n    \n    //float d1 = sqrt( min( min( a1, a2 ), a3 ) ) - 0.02;\n   // float d1 = sqrt( min( max( a1, a2 ), a3 ) ) - 0.012;\n    //float d1 = sqrt( min( min( a1, a2 ), a3 ) ) - 0.061;\n    float d1 = sqrt( min( min( a1, a2 ), a3 ) ) - 0.11;\n    \n    float d2 = abs(p.y);\n    float dmi = d2;\n \n    float adr = 0.7*fract((0.5*p.y+0.5)*8.0);\n    \n    \n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/s, adr, k*0.5 );\n    \n    \n}\n\n\n\n\n\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        //ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n        \n        ao += clamp( map( pos + nor*0.1+h  ).x*2.0, 0.0, 1.0 );\n        \n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n   \n    \n \n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n   \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n       \n        \n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        //vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        \n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        \n        \n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcXR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 201, 221, 221, 1984], [1991, 1991, 2029, 2029, 2363], [2365, 2365, 2409, 2409, 2664], [2666, 2666, 2702, 2702, 2966], [2968, 2968, 3010, 3010, 3388], [3391, 3391, 3451, 3451, 3644], [3646, 3646, 3685, 3685, 4390], [4392, 4392, 4449, 4449, 5731], [5733, 5733, 5827, 5827, 5934]], "test": "untested"}
{"id": "wlcXWM", "name": "Smooth gradation with falloff", "author": "saki7", "description": "Two-point based, 'perceptually linear' gradation; features compensation for Chevreul Illusion and Mach bands.\n\nBase interpolation algo could be any function which returns value in range [0.0-1.0].\n\nhttps://www.desmos.com/calculator/h514fpsc8v", "tags": ["gradient", "hermite", "gradation", "lanczos"], "likes": 2, "viewed": 96, "published": "Public", "date": "1581039797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: CC0\n\nconst float PI = 3.1415926535897932384626433832795;\n\nconst vec2 pt_a = vec2(0.3 * 640.0, 0.3 * 360.0);\nconst vec2 pt_b = vec2(0.6 * 640.0, 0.75 * 360.0);\n\nconst vec3 col_a = vec3(0.0, 1.0, 0.0);\nconst vec3 col_b = vec3(0.0, 0.0, 1.0);\n\n\nvec4 from_linear(vec4 rgb_l)\n{\n    bvec4 cutoff = lessThan(rgb_l, vec4(0.0031308));\n    vec4 higher = vec4(1.055) * pow(rgb_l, vec4(1.0/2.4)) - vec4(0.055);\n    vec4 lower = rgb_l * vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n// sinc, normalized\nfloat sincn(float x)\n{\n    return sin(PI * x) / (PI * x);\n}\n\nfloat lanczos(float x, float n)\n{\n    return sincn(x) * sincn(x / n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 direction = pt_b - pt_a; // constant\n    float len2 = dot(direction, direction); // constant; length(direction)^2\n\n    float t = dot(fragCoord - pt_a, direction) / len2;\n    \n    float falloff = abs(mod(iTime, 2.0) - 1.0);\n    float perc = pow(t, pow(1.0 - falloff + 0.5, 2.0));\n\n    //perc = smoothstep(0.0, 1.0, perc);\n    perc = clamp(1.0 - pow(lanczos(clamp(perc, 0.001, 1.0), 1.0), 1.2), 0.0, 1.0);\n    \n    fragColor = from_linear(vec4(mix(col_a, col_b, perc), 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXWM.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 254, 284, 284, 490], [492, 512, 534, 534, 571], [573, 573, 606, 606, 644], [646, 646, 701, 701, 1186]], "test": "untested"}
{"id": "wlcXzB", "name": "Disc-Vector Output Noise", "author": "KdotJPG", "description": "Noise with an output range that is roughly circular / disc-shaped, rather than 1D[-1,1]. Some parts of the colorization demo are borrowed from https://www.shadertoy.com/view/Wt3XzS by FabriceNeyret2", "tags": ["noise"], "likes": 9, "viewed": 145, "published": "Public", "date": "1581199514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////// K.jpg's Smooth Re-oriented 8-Point BCC Noise (OpenSimplex 2, Smooth Version) //////////////////\n///////////////////////// Modified to output a 2D vector instead of a standard 1D value. /////////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec2 bccNoisePart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    vec4 hashesRaw = permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0));\n    hashes = mod(hashesRaw, 48.0);\n    vec4 outDirHashes = mod(floor(hashesRaw / 48.0), 6.0);\n    vec4 outDirAngles = outDirHashes / 6.0 * 3.14159 * 2.0; // You could easily create more than 6 output base directions, with a wider-ranged hash\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    vec4 extrapolationsP = extrapolations * sin(outDirAngles);\n    vec4 extrapolationsQ = extrapolations * cos(outDirAngles);\n    \n    // Return it all as a vec4\n    return vec2(dot(aaaa, extrapolationsP), dot(aaaa, extrapolationsQ));\n   \n}\n\n// Classic \"Simplex\" noise lattice orientation.\nvec2 bccNoise_XYZ(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    X = dot(X, vec3(2.0/3.0)) - X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec2 bccNoise_PlaneFirst(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n// Borrowed from https://www.shadertoy.com/view/Wt3XzS by FabriceNeyret2\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y);\n    uv *= 10.0;\n    \n    // Input point\n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386);\n    \n    // Evaluate noise\n    vec2 noiseResult = bccNoise_PlaneFirst(X);\n    \n    float phi = atan(noiseResult.y, noiseResult.x);\n    vec3 col = hsv2rgb(vec3(phi/(2.*3.14159), .8, .8));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 278, 300, 300, 337], [339, 401, 424, 472, 1443], [1445, 1490, 1517, 1517, 3202], [3204, 3252, 3279, 3335, 3426], [3428, 3579, 3613, 3669, 3990], [4074, 4147, 4169, 4169, 4338], [4340, 4340, 4395, 4466, 4876]], "test": "untested"}
{"id": "wlcXzs", "name": "Mandelbrot \"doubles\" copy", "author": "malie77", "description": "crazy", "tags": ["doubleprecision"], "likes": 0, "viewed": 85, "published": "Public", "date": "1581534342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// webgl mandelbrot shader test\n// by Franc[e]sco\n// adapted by TekF\n\n// my work & home PCs get very different results, so toggle some things\n// it seems to be caused by the precision of the pan value\n#if (1)\n\t// Work PC (GeForce GTX 770)\n\tconst vec4 pan = vec4(-0.31750109, 0.48999993, 0.00000000000000588, .0);\n\tconst float period = 175.0; // higher quality results at this position, so can zoom closer\n#else\n\t//Home PC (Radeon HD 7700)\n\tconst vec4 pan = vec4(-0.3175011, 0.49, .00000000011, .0);\n\tconst float period = 142.0;\n#endif\n\n//const vec4 pan = vec4(-0.300853, 0.441, 0.00000000000000032, -0.0000000000238951); // does anyone have a good point to zoom on?\n//const vec4 pan = vec4(-0.3151, 0.445, 0, -.000000013);\n\n#define aspectRatio (iResolution.x / iResolution.y)\nconst int maxIterations = 2024;\nconst vec3 colourPhase = vec3(5,7,11)/200.0;\nconst vec3 colourPhaseStart = vec3(0.3);\n\nconst float initialZoom = 3.5;\n\n\nvec2 DoubleMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\t// c = a*b\n\t// (c.y+c.x) = (a.x+a.y)*(b.x+b.y);\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n\t// if we add it to the big, it might lose precision in the middle of the number\n\t// which would be as bad as a float, so:\n\n// trying out some ideas to make the \"doubles\" more robust:\n\t\n// try to add it to c.x, and detect how much underflowed to add to c.y\n// I don't expect this will work, because the compiler will optimise it out\n/*c.x = l+r;\nfloat rf = c.x-l; // the part of r that actually made it after rounding.\nr = r - rf;\nc.y += r;*/\n// note that a.x*b.x already underflows, so using the full precision will make that a more serious problem.\n// => need upper & lower halfs of .x's... uh...\n\nc.x = l;\nc.y += r;\n\n/*\nThis introduces more errors!\ncould try taking the difference between c.x and c.x+r, and that remainder is the value to add to c.y\n// do something more robust, otherwise the vals can both lose too much precision\n\tfloat cp = log2(abs(c.x));\n\tfloat rp = log2(abs(r));\n\tconst float precis = 20.0;\n\tif ( rp > cp-precis )\n\t{\n\t\t// chop rp up into 2 bits, put the bigger bits in the top val\n\t\tfloat cut = exp2(cp-precis);\n\t\tfloat r2 = fract(r/cut)*cut;\n\t\tc.y += r2;\n\t\tc.x += r-r2;\n\t}\n\telse\n\t{\n\t\tc.y += r;\n\t}\n*/\n\treturn c;\n}\n\nvec3 fractal( vec2 pos ) {\n\t\n\t// randomly tweaked the calculations for semi-constant zooming\n\t// I don't really know what I'm doing here, but it works\n\tfloat T = abs(fract((iTime/period)*.5+.5)*2.0-1.0001)*period; // using exactly 1.0 breaks it, I don't know why\n\tfloat zoom = pow(initialZoom, (-T + initialZoom + 1.0) / 5.0);\n\n\tvec4 Z = vec4(0), C = vec4(0);\n\tint iterations;\n\tbool ignore = false;\n\t\n\t// convert to texels, center the set on screen and apply zoom\n\tvec2 pixel;\n\tpixel = (pos / iResolution.xy - 0.5) * zoom; \n\tpixel.y /= aspectRatio; // fix aspect ratio\n\n\tfloat a = iTime*.05 + sin(iTime)*0.05;\n\tpixel = pixel*cos(a)+vec2(1,-1)*sin(a)*pixel.yx;\n\n// to see the limit of floats, set xy instead of zw here!\t\n\tC.zw = pixel;\n\t\n\tC -= pan;\n\t\n\tfor (int i = 0; i < maxIterations; i++) {\n\t\tif (ignore)\n\t\t\tbreak;\n\t\t\n\t\t// complex number operations\n\t\t// Z = Z*Z + C\n\t\tvec4 Z2;\n\t\t//Z.x * Z.x - Z.y * Z.y, \n\t\tZ2.xz = DoubleMul(Z.xz,Z.xz) - DoubleMul(Z.yw,Z.yw);\n\t\tZ2.yw = 2.0*DoubleMul(Z.xz,Z.yw);\n\t\tZ = Z2 + C; // apply panning\n\t\t\n\t\t// stop immediately if the point is outside a radius of 2 from (0,0) (the bounds of the mandelbrot set)\n\t\t//if ( dot((DoubleMul(Z.xz,Z.xz) + DoubleMul(Z.yw,Z.yw)),vec2(1)) > 4.0 ) // smooth\n\t\tif ( max(abs(dot(Z.xz,vec2(1))),abs(dot(Z.yw,vec2(1)))) > 2.0 ) // scallops\n\t\t\tignore = true;\n\t\t\n\t\titerations = i;\n\t}\n\t\n\t//return pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(2.2));\n\t// return pow(sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5,vec3(1.5));\n\t//return 1.0-abs(sin(colourPhase.xyz * float(iterations) + colourPhaseStart));//*.5+.5;\n    return sin(colourPhase.xyz * float(iterations) + colourPhaseStart)*.5+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//fragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\n\t// anti-aliasing\n\tfragColor.rgb  = fractal( fragCoord.xy + vec2(0,0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.0) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.0,.5) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.5,.5) );\n\tfragColor.rgb /= 4.0;\n\t\n/*\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.25) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.25,.75) );\n\tfragColor.rgb += fractal( fragCoord.xy + vec2(.75,.75) );\n\tfragColor.rgb /= 8.0;*/\n\t\n\tfragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n\n\tfragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[536, 928, 962, 962, 2278], [2280, 2280, 2306, 2430, 3979], [3982, 3982, 4039, 4115, 4705]], "test": "untested"}
{"id": "WldSR2", "name": "mandelbrot - test", "author": "ciroluiro", "description": "the mandelbrot set", "tags": ["math", "mandelbrot", "fractals"], "likes": 0, "viewed": 52, "published": "Public", "date": "1581366092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 500\n#define MAX_RAD 2.\n\n\nvec2 mult( vec2 a, vec2 b) {\n \t\n    vec2 result;\n    result = vec2(a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y);\n    return result;\n    \n}\n\nfloat norm( vec2 num ){\n    \n    float norma = pow(num.x,2.) + pow(num.y,2.);\n    norma = sqrt(norma);\n    return norma;\n}\n\nvec2 mandelbrot( vec2 carry, vec2 num){\n    \n    vec2 next = mult(carry, carry) + num;\n    return next;\n}    \n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //no se estaria usando\n    //float speed = 5.*(iMouse.y/iResolution.y)+1.0;//medio raro\n    float ratio = iResolution.x/iResolution.y;\n    //float scale = pow(2.,1.-mod(iTime,20.));\n    float scale = pow(2.,1.-mod(iTime,3.*5.465));\n    \n    vec2 center = vec2(-1.786448,0.);\n    vec2 leftCorner = vec2(center.x-ratio*scale,center.y+scale);\n    vec2 rightCorner = vec2(ratio*scale + center.x,center.y-scale);\n    \n    vec2 st = fragCoord/iResolution.xy*(rightCorner - leftCorner) + leftCorner;\n    \n    vec2 num = vec2(0.,0.);\n    \n    int i = 0;\n    while(i<ITERS && norm(num)<MAX_RAD) {\n        num = mandelbrot(num, st);\n        i++;\n    }\n    \n    vec3 color = hsb2rgb(vec3(mod(0.7+smoothstep(0.1,0.9,float(i)/float(ITERS)),1.)\n                              ,0.9\n                              ,smoothstep(-0.5,0.7,0.5+float(i)/float(ITERS))));\n    color = vec3(step(MAX_RAD, norm(num)))*color;\n    \n    fragColor = vec4(color,1.);\n}\n\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 67, 67, 165], [167, 167, 190, 190, 289], [291, 291, 330, 330, 396], [402, 402, 428, 428, 858], [860, 860, 886, 886, 1118], [1121, 1121, 1178, 1270, 2118]], "test": "untested"}
{"id": "wldSRN", "name": "Practise | The Drive Home", "author": "Tilmut", "description": "learning from the tutorial: https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos", "tags": ["rain"], "likes": 6, "viewed": 108, "published": "Public", "date": "1580555439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x, y, t) smoothstep(x, y, t)\nfloat N(float t) {\n\treturn fract(sin(t*3456.)*6547.);//fract取小数部分,N函数取随机数\n}\nvec4 N14(float t){\n    return fract(sin(t*vec4(123.,1024.,3456.,9576.))*vec4(6547.,345.,7585.,3212.));\n}\n\nstruct ray {\n\tvec3 o, d;   \n};\n    \nray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n\tray cam;\n    cam.o = camPos;\n    \n    vec3 f = normalize(lookAt-cam.o);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = cam.o + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    cam.d = normalize(i-cam.o);\n    \n    return cam;\n} \n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nfloat DistRay(ray r, vec3 p) {\n\treturn length(p-ClosestPoint(r, p));\n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur) {//散焦模糊\n\tfloat d = DistRay(r, p);\n    \n    size *= length(p);\n    float c = S(size, size*(1.-blur), d);\n    c *= mix(.7, 1., S(size*.8, size, d));\n    return c;\n}\n\nvec3 Streetlights(ray r, float t) {\n    float side = step(r.d.x, 0.);//step返回1或0，比较两值大小\n    r.d.x = abs(r.d.x);//镜像\n    float s = 1./10.; // 0.1\n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        float ti = fract(t+i+side*s*.5);//镜像两边进程各差一半\n    \tvec3 p = vec3(2.,2.,100.-ti*100.);\n    \tm += Bokeh(r, p, .05, .1)*ti*ti*ti;\n    }\n    \n    return vec3(1., .7, .3)*m;\n}\nvec3 Envlights(ray r, float t) {\n    float side = step(r.d.x, 0.);\n    r.d.x = abs(r.d.x);\n    float s = 1./10.; // 0.1\n    vec3 c=vec3(0.);\n    \n    for(float i=0.; i<1.; i+=s) {\n        float ti = fract(t+i+side*s*.5);\n        vec4 n=N14(i+side*100.);\n        \n        float fade=ti*ti*ti;\n        float occlusion=sin(ti*6.28*10.*n.x)*.5+.5;//遮挡\n        fade=occlusion;\n        \n        float x=mix(2.5,10.,n.x);\n        float y=mix(.1,1.5,n.y);\n    \tvec3 p = vec3(x,y,50.-ti*50.);\n        vec3 col=n.wzy;\n    \tc += Bokeh(r, p, .05, .1)*fade*col*.5;;\n    }\n    \n    return c;\n}\n\n\n\nvec3 Headlights(ray r, float t) {\n    \n    t *= 2.;\n    \n    float w1 = .25;\n    float w2 = w1*1.2;\n    \n    float s = 1./30.; // 0.1\n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        \n        float n = N(i);\n        \n        if(n>.1) continue;\n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        \n    \tm += Bokeh(r, vec3(-1.-w1,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(-1.+w1,.15, z), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(-1.-w2,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(-1.+w2,.15, z), size, .1)*fade;\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(-1.-w2, -.15, z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(-1.+w2, -.15, z), size*3., 1.)*fade;\n        \n        m += ref*focus;\n    }\n    \n    return vec3(.9, .9, 1.)*m;\n}\n\nvec3 Taillights(ray r, float t) {\n    \n    t *= .25;\n    \n    float w1 = .25;\n    float w2 = w1*1.2;\n    \n    float s = 1./15.; \n    float m = 0.;\n    for(float i=0.; i<1.; i+=s) {\n        \n        float n = N(i); // 0 - 1\n        \n        if(n>.5) continue;\n        \n        // n = 0 - 0.5\n        \n        float lane = step(.25, n); // 0 1\n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        \n        float laneShift = S(1., .96, ti);\n        float x = 1.5 - lane * laneShift;\n        \n        float blink = step(0., sin(t*1000.))*7.*lane*step(.96, ti);\n        \n    \tm += Bokeh(r, vec3(x-w1,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(x+w1,.15, z), size, .1)*fade;\n        \n        m += Bokeh(r, vec3(x-w2,.15, z), size, .1)*fade;\n        m += Bokeh(r, vec3(x+w2,.15, z), size, .1)*fade*(1.+blink);\n        \n        float ref = 0.;\n        ref += Bokeh(r, vec3(x-w2, -.15, z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(x+w2, -.15, z), size*3., 1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;\n    }\n    \n    return vec3(1., .1, .03)*m;\n}\nvec2 Rain(vec2 uv, float t){\n    t*=40.;\n    //uv*=3.;\n    vec2 a=vec2(3.,1.);\n    vec2 st=uv*a;//另一组uv\n    vec2 id=floor(st);\n    st.y+=t*.22;//网格排列下降，使看不出雨滴上升\n    \n    float n=fract(sin(id.x*716.34)*768.34);\n    st.y+=n;//列随机上下排布，让雨滴不平行落下\n    uv.y+=n;//使随机数不会抵消，雨滴不会在同一高度\n    id=floor(st);\n    st=fract(st)-0.5;\n    \n    t+=fract(sin(id.x*76.34+id.y*1457.3)*768.63)*6.283;//使各个雨滴不同时落下;\n    float y=-sin(t+sin(t+sin(t)*0.5))*.43;//缓慢落下又快速上升，0.43使其不离开边缘\n    vec2 p1=vec2(0.,y);//只做y轴运动\n    vec2 o1=(st-p1)/a;//st/a恢复圆形，-p1为运动\n    float d=length(o1);\n    \n    float m1=S(.07,.0,d);//遮罩，即雨滴形状\n    \n    vec2 o2=(fract(uv*a.x*vec2(1.,2.))-.5)/vec2(1.,2.);//从三个小雨滴变成六个再恢复圆形\n    d=length(o2);\n    \n    float m2=S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y);//拖尾的雨滴，第一个s雨滴越往下越大，第二个s跟随大雨滴后面 \n    return vec2(m1*o1*30.+m2*o2*10.);//乘以偏移量\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float t = iTime*.05+m.x;\n    \n    vec3 camPos = vec3(.5, 0.2, 0.);\n    vec3 lookAt = vec3(.5, 0.2, 1.);\n    \n    vec2 rainDistort=Rain(uv*5.,t)*.5;\n    rainDistort+=Rain(uv*7.,t)*.5;\n    \n    uv.x+=sin(uv.y*70.)*.003;\n    uv.y+=sin(uv.x*170.)*.001;\n    \n    ray r = GetRay(uv-rainDistort*.5, camPos, lookAt, 2.);\n \n    \n    \n    vec3 col = Streetlights(r, t);\n    col += Headlights(r, t);\n    col += Taillights(r, t);\n    col += Envlights(r,t);\n    \n    col += (r.d.y+.25)*vec3(.2,.1,.5);//天空渐变\n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 57, 57, 136], [137, 137, 155, 155, 241], [279, 279, 338, 338, 608], [611, 611, 645, 698, 747], [749, 749, 779, 779, 819], [821, 821, 873, 887, 1042], [1044, 1044, 1079, 1079, 1462], [1463, 1463, 1495, 1495, 2046], [2050, 2050, 2083, 2083, 2989], [2991, 2991, 3024, 3024, 4201], [4202, 4202, 4230, 4230, 5321], [5323, 5323, 5380, 5380, 6073]], "test": "untested"}
{"id": "WldSRs", "name": "fn psych 2", "author": "anttikan", "description": "Composition using a randomly generated function mapping x, y, and time to color values. Here also a noise function and simple lighting is implemented, as shown here: https://www.shadertoy.com/view/lsl3RH", "tags": ["2d", "abstract"], "likes": 5, "viewed": 259, "published": "Public API", "date": "1581543480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat noise( float x, float y )\n{\n    \n    vec2 p = vec2(x,y);\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat pixelfunc(float x, float y, float iTime) {\n    return (sqrt(pow(sin(((((y)-(log(abs((sqrt(abs(((((y)*(x))-pow((x),2.0))-(noise((x),(y))+((y)*(x))))))*sin(pow(exp((y)),3.0))))+0.0001)-noise(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0)))) - floor(abs((sqrt(pow(pow(pow(pow((y),2.0),2.0),2.0),2.0)+pow((y),2.0))))),(sin(iTime/0.9034435963811109 + 0.20637479410149906)))))/ (abs(exp((sin(iTime/0.8529278085443219 + 0.8213404700193889))))+0.0001))*(sqrt(abs((sqrt(pow(pow(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.9995009860820951 + 0.6881438036038101)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.26979193952694613 + 0.3785319489160377)),3.0))))))) - floor(abs(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.22226978701805833 + 0.24191002823528662)),3.0))))) - floor(abs((sign(log(abs((x))+0.0001))*sqrt(abs(pow((sin(iTime/0.5739308110903445 + 0.45896373432699944)),3.0)))))))),2.0),2.0)+pow((sin(iTime/0.7264469109570366 + 0.08679412060619152)),2.0)))))/ (abs((sqrt(pow(sin((y)),2.0)+pow(sin(cos((sqrt(pow((sign((sin((x))*log(abs((sin(iTime/0.9613027990997718 + 0.6659919369591429)))+0.0001)))/ (abs(noise((sin(iTime/0.6989492096617616 + 0.36615005376399967)),pow(((sin(iTime/0.71852557018322 + 0.1619393542530836))+(x)),2.0)))+0.0001)),2.0)+pow((sin(iTime/0.6209043266540595 + 0.8417751048573665)),2.0))))),2.0))))+0.0001)))),2.0)+pow(sin(pow(noise((sqrt(abs((sqrt(pow(pow(((sin(iTime/0.3462935766066413 + 0.3097821178771951))*sin(pow(((y)+(y)),2.0))),2.0),2.0)+pow((log(abs(noise((sqrt(pow(abs((x)) - floor(abs((x))),2.0)+pow(((x)*(y)),2.0))),(x)))+0.0001)/ (abs(((y)/ (abs(noise((((sin(iTime/0.7866078460146608 + 0.2681747389535367))*(y))/ (abs(abs((sin(iTime/0.3774955185871607 + 0.7938241880557342))) - floor(abs((sin(iTime/0.6122868317852803 + 0.6912683134142241)))))+0.0001)),sqrt(abs(abs((x)) - floor(abs((x)))))))+0.0001)))+0.0001)),2.0)))))/ (abs(pow((sqrt(pow((sign((x))/ (abs(cos(cos(abs(cos((x))) - floor(abs(cos((x)))))))+0.0001)),2.0)+pow(noise(sqrt(abs(exp(sin(sign((x)))))),sqrt(abs(exp(pow(sin((y)),2.0))))),2.0))),3.0))+0.0001)),((sin((pow((sqrt(pow((sin(iTime/0.6991922402347979 + 0.21404984070124788)),2.0)+pow(abs(((x)/ (abs((x))+0.0001))) - floor(abs(((x)/ (abs((x))+0.0001)))),2.0))),3.0)/ (abs(sqrt(abs(log(abs((y))+0.0001))))+0.0001)))/ (abs((((sqrt(pow(((sin(iTime/0.26754650486706133 + 0.12570778401332916))-abs(((sin(iTime/0.12503305278658794 + 0.01130819450429632))/ (abs((x))+0.0001))) - floor(abs(((sin(iTime/0.2653499101486092 + 0.00871470719699241))/ (abs((x))+0.0001))))),2.0)+pow(sin(sin(((x)-(sin(iTime/0.10483245318883472 + 0.600138486042491))))),2.0)))+sign(abs((y)) - floor(abs((y)))))-(sin(sin(sin(exp((sin(iTime/0.9940380440346446 + 0.5464411881844877))))))/ (abs(sign(((sqrt(pow((sin(iTime/0.6341745666062364 + 0.8531862440589704)),2.0)+pow(exp((y)),2.0)))-(x))))+0.0001))))+0.0001))*sin(pow((sqrt(pow(sin(sin(cos(((y)+(x))))),2.0)+pow((y),2.0))),3.0)))),2.0)),2.0)));\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    \n        \n    float x = p.x*(0.4 + 0.2*cos(iTime*0.1 + 10.0)) + sin(iTime*0.12 + 10.0);\n    float y = (0.4+0.2*cos(iTime*0.1 + 10.0))*p.y; // p.y*0.2; //\n    float t = iTime*0.2;\n    \n    float shade = pixelfunc(x, y, t);\n    float mapped_shade = map(shade,-3.0, 3.0, 0.0, 1.0);\n    \n    \n    vec3 col = mix( vec3(0.1,0.6,0.8), vec3(0.2,0.3,0.5), mapped_shade );\n    col = vec3(mapped_shade) - vec3(0.1, 0.1, 0.2);\n    \n    \n    \n    \n \tvec3 nor = normalize( vec3( pixelfunc(x+e,y,t)-shade, \n                                2.0*e,\n                                pixelfunc(x,y+e,t)-shade ) );\n\n    vec3 lig = normalize( vec3( 0.8, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.65,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.65,0.30,0.2)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n\n    \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 76, 76, 105], [107, 107, 140, 140, 522], [525, 525, 573, 573, 3521], [3524, 3524, 3596, 3596, 3680], [3682, 3682, 3739, 3739, 4762]], "test": "untested"}
{"id": "wldSWH", "name": "Coming Alive II", "author": "NinaFranziska", "description": "static but alive, mesmerizing and alienating", "tags": ["cineshader"], "likes": 3, "viewed": 8931, "published": "Public API", "date": "1580894197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n   uv -= vec2(0.5,0.5); //we make the whole thing black\n   uv *= 2.0; //we remap the coordinates to become between -1 and 1\n float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\n   fragColor = vec4(color, color, color, color); \n}\n\n\n//trippy 1\n  /* float distance = sin(length(uv));\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0); \n\n//real beautiful trippy\n  float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0); \n\n\n//trippy variation (using *iTime-iTime) (for instagram)\n    \n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n   fragColor = vec4(color, color, color, 1.0); \n\n//crazy trippy (when multiplying time with a high number - you get many cycles/arms\n   float distance = length(uv);\n   float angle = atan(uv.y,uv.x);\n    \n   float color = sin(angle+distance*20.0*iTime)*cos(angle+distance*iTime)*6.0;\n   fragColor = color*vec4(1.0, 1.0, 1.0, 1.0);\n}\n\n\n//trippy in colours\n   float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\tfloat color2 =  sin(angle+distance*10.0*iTime)\n   fragColor = vec4(color, color2, 1.0, 1.0); \n\n//trippy in rainbow colours\n    float color = sin(angle+distance*10.0)*cos(angle+distance*iTime - iTime)*6.0;\n\tfloat color2 =  sin(angle+distance*10.0+iTime)*cos(angle+distance*iTime - iTime);\n    float color3 =  sin(angle+distance*10.0+iTime)*cos(angle+distance*iTime)*3.0;\n   fragColor = vec4(color, color2, color3, 1.0); \n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldSWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 478]], "test": "untested"}
{"id": "WldSWj", "name": "clamp ray to box", "author": "FabriceNeyret2", "description": "draw ray Red-Green by dragging the mouse.\ndraw ray Pink-Cyan clamped to box", "tags": ["tuto", "clamp", "short"], "likes": 7, "viewed": 251, "published": "Public API", "date": "1581713266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v) smoothstep( s*1.5/R.y, 0., v ) // for antialiasing\n\nfloat line(vec2 p, vec2 a,vec2 b) { // draw line. https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O;\n    float s = 3.;                                    // number of grid rows\n    vec2 R = iResolution.xy, V, P0,P1,\n         U = s*u/R.y,\n        M0 = iMouse.z > 0. ? s*iMouse.zw/R.y : s* .5*R/R.y, \n         M = iMouse.z > 0. ? s*iMouse.xy/R.y : s*(.5+.4*cos(iTime+vec2(0,11))),\n        F0 = fract(M0)*2. - 1.,                      // mouse0 cell local coords\n         D = normalize(M-M0);                        // ray direction\n    \n    O.ra += S( length(M0-U) -.07 );                  // draw mouse from, to\n    O.ga += S( length(M -U) -.07 );                  // ( 2 dots + line )\n    if (M0.x>0.) O += (1.-O.a)* S( line(U,M0,M) );   // NB: lines blended behind dots\n    \n    // compute intersection M0+s.kD  with box [-1,1]²  (s = + or - )\n#define box(s) (  V = ( sign(D) - s F0 ) / D,  \\\n                  M0 + s min(V.x,V.y) *D/2.    )\n                 // NB: if D[i] = 0., should use V[1-i]\n    P0 = box(+);                                     // forward box intersection\n    P1 = box(-);                                     // backward box intersection\n    O.bga += S( length(P0-U) -.04 ),\n    O.bra += S( length(P1-U) -.04 ),                 // draw ( 2 dots + line )\n    O.b   += (1.-O.a)* S( line(U,P0,P1) -.015 );\n\n    V = S(abs(fract(U+.5)-.5));                      // draw grid\n    O += (1.-O.a)* .5* max(V.x,V.y);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 100, 152, 323], [325, 325, 363, 363, 1707]], "test": "untested"}
{"id": "WldSWX", "name": "Circle - parametrization", "author": "iq", "description": "Space parametrization of a circle, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url]", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 17, "viewed": 455, "published": "Public API", "date": "1581855617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a circle.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paCircle( in vec2 p, float r, float band ) \n{\n    float d = length(p) - r;\n    float ra = band*round(d/band);\n    float l = (r+ra)*(atan(p.x,p.y)+3.1415927);\n    return vec4( d-ra, l, 6.283185*(r+ra), d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    const float ra = 0.5 ;\n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paCircle(uv,ra,bandSize);\n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += smoothstep(0.004, 0.002, abs(d));\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.01,0.04,abs(l-0.35));\n    col *= 0.1 + 0.9*smoothstep(0.10,0.11,l);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSWX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1314, 1398, 1423, 1423, 1442], [1443, 1443, 1476, 1476, 1502], [1504, 1608, 1658, 1658, 1820], [1822, 1822, 1879, 1915, 2896]], "test": "untested"}
{"id": "WldSzS", "name": "volume-light", "author": "bitnenfer", "description": "Small test inspired by the GDC talk about INSIDE rendering.\nUse mouse horizontal movement to control scene rotation and vertical movement to control light position.", "tags": ["volume", "raymarch", "light"], "likes": 26, "viewed": 251, "published": "Public", "date": "1581217624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define USE_NOISE 1\n#define USE_BLUE_NOISE 1\n\nfloat gSeed = 0.0;\nvec2 gUV;\n\nfloat hash( float n )\n{\n    return fract(sin(n + gSeed)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(gUV, vec2(12.9898, 78.233)) * (gSeed += 1.0)) * 43758.5453));\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 pr = p;\n    pr.yz *= rot(1.6);\n    float a = min(min(length(p + vec3(0.0, 0.5, 0.0)) - 0.7, sdTorus(pr + vec3(0.0, 1.0, 2.0), vec2(1.0, 0.4))), p.y + 1.0);\n    float b = box(p + vec3(0.0, 0.0, -3.0), vec3(200.0, 200.0, 0.3));\n    b = max(b, -box(p + vec3(0.0, -3.0, 0.0), vec3(1.0, 3.5, 20.0)));\n    b = max(b, -box(p + vec3(0.0, -3.0, 0.0), vec3(2.0, 1.0, 20.0)));\n    return min(a, b);\n}\n\nvec3 norm(vec3 p)\n{\n    const vec2 e = vec2(0.0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx) - map(p - e.yxx),\n        map(p + e.xyx) - map(p - e.xyx),\n        map(p + e.xxy) - map(p - e.xxy)\n    ));\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    gUV = uv;\n    gSeed = 0.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool useMouseCtrl = iMouse.z > 0.0;\n    \n    float mx = 1.4 * sin(iTime * 0.2);\n    float my = 0.24;\n    \n    if (useMouseCtrl)\n    {\n\t    mx = (iMouse.x / iResolution.x * 2.0 - 1.0);\n    \tmy = 0.1 + (iMouse.y / iResolution.y);\n    }\n    \n    vec3 l = vec3(0.0, my, 1.0);\n    vec3 ro = vec3(0.0, 3.0, -20.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.2, 4.0));\n    \n    ro.xz *= rot(mx);\n    rd.xz *= rot(mx);\n    \n    // moon rendering\n    float lt = 0.0;\n    float moonGlow = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n       \n        float ld = (length((ro + rd * lt) - (l * 50.0)) - 0.2);\n        moonGlow += 4.0/(0.1+pow(ld,2.0));\n        if (ld < 0.1) \n        {\n            color += 1.0;\n            break;\n        }\n        lt += ld;\n        \n    }\n    color += vec3(0.01) * moonGlow;\n    \n    float t = 0.0;\n    \n    for (int i = 0; i < 300; ++i)\n    {\n        float d = map(ro + rd * t);\n        if (d < 0.01)\n        {\n            break;\n        }\n        t += d;\n        if (t > 100.0) break;\n    }\n    \n    // lambert reflectance\n    if (t < 100.0)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = norm(p);\n        vec3 v = normalize(ro - p);\n        vec3 h = normalize(v + l);\n        #if 1\n        float NdotH = dot(n, h) * 0.5 + 0.5;\n        float NdotL = dot(n, l) * 0.5 + 0.5;\n        #else\n        float NdotH = max(dot(n, h),0.0);\n        float NdotL = max(dot(n, l),0.0);        \n        #endif\n        vec3 checkerP = p * 1.0;\n        float checker = 0.5+mod(floor(checkerP.x) + floor(checkerP.y) + floor(checkerP.z), 2.0);\n        float sh = 1.0;\n    \n        // hard shadows \n        #if 1\n        vec3 srd = l;\n        vec3 sro = p + srd * 0.1;\n        float st = 0.0;\n        for (int i = 0; i < 64; ++i)\n        {\n            float d = map(sro + srd * st);\n            if (d < 0.001)\n            {\n                sh = 0.0;\n                break;\n            }\n            st += d;\n            if (st > 100.0) break;\n        }\n        #endif\n        vec3 checkerColor = vec3(0.1) + checker * vec3(0.1);\n        color = checkerColor + vec3(0.6, 0.6, 1.0) * (NdotL*sh) + pow(NdotH * sh, 10.0)*0.1;\n        color = mix(color, vec3(0.0), clamp(t / 40.0, 0.0, 1.0));\n    }\n    \n    // volumetric light\n    #if 1\n    {    \n        vec3 lc = vec3(0.0);\n        float t1 = 0.0;\n        for (int i = 0; i < 150; ++i)\n        {\n            vec3 o = ro + rd * t1;\n            float t2 = 0.0;\n            for (int j = 0; j < 60; ++j)\n            {\n                float d = map(o + l * t2);\n                if (d < 0.01)\n                {\n                    break;\n                }\n                t2 += d;\n                if (t2 > 100.0)\n                {\n                    lc += 0.4;\n                    break;\n                }\n            }\n            #if USE_NOISE\n            #if USE_BLUE_NOISE\n            t1 += 0.1 + (texture(iChannel0, (o + l * t2).xz).r) * 0.2;\n            #else\n            t1 += 0.1 + random() * 0.2;\n            #endif\n            #else\n            t1 += 0.2;\n            #endif\n            if (t1 > t) break;\n        }\n        color += clamp(lc / 100.0, 0.0, 0.1) * (vec3(0.1, 0.1, 0.2) * 10.0);\n    }\n    #endif\n        \n    fragColor = vec4(acesFilm(color), 1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 99, 99, 146], [148, 148, 164, 164, 259], [261, 261, 280, 280, 346], [348, 348, 381, 381, 446], [448, 448, 475, 475, 570], [572, 572, 591, 591, 990], [992, 992, 1011, 1011, 1207], [1209, 1209, 1238, 1238, 1442], [1445, 1445, 1500, 1500, 4905]], "test": "untested"}
{"id": "WldSzX", "name": "Wireframe Trails", "author": "fizzer", "description": "Using bilinear patches to create trails of wireframe edges through piecewise-linear motions.", "tags": ["blur", "wireframe", "bilinear", "trails"], "likes": 22, "viewed": 420, "published": "Public", "date": "1581450597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray intersection test with bilinear surface defined by 4 points\nbool traceBilinearPatch(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd,\n                        inout vec3 outs, inout vec3 outt, inout vec3 outuvi)\n{\n    vec3 va = pc - pa;\n    vec3 vb = (pd - pc) - (pb - pa);\n    vec3 vd = ro - pa;\n    vec3 vc = pa - pb;\n\n    // Note that the coefficients are in reverse order here. Solving this\n    // equation gives 1 / x and avoids a divide-by-zero case for coplanar controlpoints\n    // by switching that case to c = 0 instead of a = 0, thus putting the denominator\n    // in the solution as -b instead of 0.\n    // Thanks to IQ for this trick!\n    \n    float c = dot(cross(vb, vc), rd);\n    float b = dot(cross(va, vc) + cross(vb, vd), rd);\n    float a = dot(cross(va, vd), rd);\n\n    float desc = b * b - 4. * a * c;\n\n    if(desc < 0.0)\n        return false;\n\n    // Put PA at the origin of the coordinate system\n\n    ro -=pa;\n\n    pc = va;\n\n    pd -= pa;\n    pb -= pa;\n    pa -= pa;\n\n    float i;\n    float u, v;\n\n    // Solve for U at each intersection point, which are two quadratics\n\n    float u0 = (2. * a) / (-b - sqrt(desc));\n    float u1 = (2. * a) / (-b + sqrt(desc));\n\n    vec3 pu0 = pb * u0;\n    vec3 pu1 = pb * u1;\n\n    // Solve for V at each intersection point, geometrically\n\n    vec3 vv0 = mix(pc, pd, u0) - pu0;\n    vec3 m20 = ro - pu0 - vv0 * dot(vv0, ro - pu0) / dot(vv0, vv0);\n\n    vec3 vv1 = mix(pc, pd, u1) - pu1;\n    vec3 m21 = ro - pu1 - vv1 * dot(vv1, ro - pu1) / dot(vv1, vv1);\n\n\n    float v0, v1;\n\n    {\n        vec3 n = cross(va + vb * u0, vd + vc * u0);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu0 - ro, m);\n        float db = dot(pc + (pd - pc) * u0 - ro, m);\n\n        v0 = da / (da - db);\n    }\n\n    {\n        vec3 n = cross(va + vb * u1, vd + vc * u1);\n        vec3 m = cross(n, rd);\n\n        float da = dot(pu1 - ro, m);\n        float db = dot(pc + (pd - pc) * u1 - ro, m);\n\n        v1 = da / (da - db);\n    }\n\n    // Solve for the ray intersection distance at each intersection point\n\n    float da20 = dot(ro - pu0, m20);\n    float db20 = dot((ro + rd) - pu0, m20);\n    float i0 = da20 / (da20 - db20);\n\n    float da21 = dot(ro - pu1, m21);\n    float db21 = dot((ro + rd) - pu1, m21);\n    float i1 = da21 / (da21 - db21);\n\n    // Resolve which valid intersection point is nearest to ray origin\n\n    if(u0 < 0. || u0 > 1. || i0 < 0. || v0 < 0. || v0 > 1.)\n    {\n        u = u1;\n        v = v1;\n        i = i1;\n    }\n    else if(u1 < 0. || u1 > 1. || i1 < 0. || v1 < 0. || v1 > 1.)\n    {\n        u = u0;\n        v = v0;\n        i = i0;\n    }\n    else\n    {\n        u = mix(u0, u1, step(i1, i0));\n        v = mix(v0, v1, step(i1, i0));\n        i = min(i0, i1);\n    }\n\n    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)\n        return false;\n\n    outuvi = vec3(u, v, i);\n\n    // Surface differentials in worldspace\n    outs = pb * u - mix(pc, pd, u);\n    outt = pc * v - mix(pb, pd, v);\n\n    return true;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nvec3 transformPoint(vec3 p, float t)\n{\n    mat3 m = rotX(cos(t) * 3.) * rotY(sin(t / 2.) * 3.) * rotZ(sin(t / 3.) * 3.);\n    return m * p * (1. + cos(t * .7) * .2);\n}\n\nvec3 colourRamp(float x)\n{\n    return clamp(1. - sin((1. - x) * vec3(.5,9.5,3.5).brg * .7), 0., 1.5) * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Set up primary ray\n\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n\n    vec3 col = vec3(0.01);\n        \n    float dt = 1. / 6.;\n    \n    float t0 = iTime - dt * 2.;\n    float t1 = iTime - dt;\n    float t2 = iTime;\n        \n    // 12 edges of the cube\n    \n\tfor(int axis = 0; axis < 3; ++axis)\n    {\n        for(int i = 0; i < 4; ++i)\n        {\n            vec3 p0, p1;\n            \n            p0[(axis + 1) % 3] = float(i & 1) * 2. - 1.;\n            p0[(axis + 2) % 3] = float((i / 2) & 1) * 2. - 1.;\n            \n            p1 = p0;\n\n            p0[axis] = -1.;\n            p1[axis] = +1.;\n\n\t\t    vec3 s, t, uvi;\n            vec3 pa, pb, pc, pd;\n\n            pa = transformPoint(p0, t0);\n            pb = transformPoint(p0, t1);\n            pc = transformPoint(p1, t0);\n            pd = transformPoint(p1, t1);\n\n            if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n                col += colourRamp(uvi.x * .5);\n            \n            pa = transformPoint(p0, t1);\n            pb = transformPoint(p0, t2);\n            pc = transformPoint(p1, t1);\n            pd = transformPoint(p1, t2);\n\n            if(traceBilinearPatch(ro, rd, pa, pb, pc, pd, s, t, uvi))\n                col += colourRamp(.5 + uvi.x * .5);\n        }\n    }\n\n    //col=vec3(0);\n\tvec3 s, t, uvi;\n    //if(traceBilinearPatch(ro, rd, vec3(-1,-1,0),vec3(+1,-1,0),vec3(-1,+1,0),vec3(+1,+1,0), s, t, uvi))\n      //  col=vec3(1);\n\n    fragColor.rgb = col * .9;\n\n    // Gamma correction\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n    fragColor.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 223, 223, 2968], [2970, 2970, 2990, 2990, 3094], [3096, 3096, 3116, 3116, 3220], [3222, 3222, 3242, 3242, 3346], [3348, 3348, 3386, 3386, 3514], [3516, 3516, 3542, 3542, 3623], [3625, 3625, 3682, 3682, 5387]], "test": "untested"}
{"id": "WldXDM", "name": "Noise sphere", "author": "benj_carrier", "description": "Ray marching ", "tags": ["raymarching", "noise"], "likes": 3, "viewed": 244, "published": "Public API", "date": "1581091209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 u_lPos ;\nvec3 u_transform ;\nvec2 u_scale ;\n\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat map_the_world(in vec3 p)\n{\n    // float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n    float displacement = cnoise(p+u_transform);\n    float sphere_0 = distance_from_sphere(p, vec3(0.0), u_scale.x);\n\n    return sphere_0 + displacement;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec4 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        float distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = calculate_normal(current_position);\n\n            vec3 light_position = u_lPos;\n\n            vec3 direction_to_light = normalize(current_position - light_position);\n\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n            vec3 rockon = vec3(1.0, 1.0, 1.0) * diffuse_intensity;\n            return vec4(rockon, 1.0);\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec4(0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n     u_lPos = vec3(7.3, -5, 3);\n\t u_transform = vec3(0,1, iTime);\n\t u_scale = vec2(1.6,1);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 camera_position = vec3(-3.0, -4.0, -7.0);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv, 1.0);\n\n    vec4 shaded_color = ray_march(ro, rd);\n\n    // Output to screen\n    fragColor =shaded_color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 104, 125, 125, 162], [163, 163, 190, 190, 238], [239, 239, 258, 258, 294], [296, 296, 317, 317, 2589], [2591, 2591, 2650, 2650, 2682], [2684, 2684, 2716, 2801, 2956], [2958, 2958, 2992, 2992, 3420], [3422, 3422, 3462, 3462, 4467], [4471, 4471, 4528, 4528, 4932]], "test": "untested"}
{"id": "wldXDX", "name": "window memory", "author": "jiaolyulu1", "description": "try to create a window, basically just drawing lines and light like on a canvas", "tags": ["2d", "city", "window", "curtain"], "likes": 10, "viewed": 206, "published": "Public", "date": "1581901446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\nmat2 rot(float m){\n\treturn mat2(cos(m),-sin(m),sin(m),-cos(m));\n}\n\nfloat box(vec2 uv,vec2 r, float blur){\n\tfloat d=length(max(abs(uv)-r,0.));\n    d= S(blur,-blur,d);\n    return d;\n}\n\nfloat strips(vec2 st){\n\tfloat strip=box(st,vec2(0.003,0.5),0.015);\n    strip+=box(st-vec2(0.,0.47),vec2(0.25,0.008),0.015);\n    strip+=box(st-vec2(0.,0.31),vec2(0.25,0.004),0.015);\n    strip+=box(st-vec2(0.,0.29),vec2(0.25,0.004),0.015);\n    strip+=box(st-vec2(0.,0.00),vec2(0.25,0.004),0.015);\n    strip+=box(st-vec2(0.,-0.29),vec2(0.25,0.004),0.015);\n    return strip;\n}\n\nfloat curtain (vec2 uv, float blur)\n{\n\tvec2 st2=uv;\n    st2.x=abs(st2.x);\n    st2.x+=(0.25+0.0*sin(iTime))*2.*(st2.y+0.5)*abs(st2.x);\n    st2.y=sin(st2.x*60.+iTime/1.+1000.5*texture(iChannel0,st2/200.).r)*0.01+st2.y+0.05*texture(iChannel0,st2/200.+iTime/400.).r;\n    float d2= box(st2-vec2(0.17,0.),vec2(0.12-0.01*sin(iTime),0.49),blur)*(0.6+0.4*texture(iChannel0,st2*20.).r*(2.*sin(st2.x*50.+iTime/1.)+1.0))*(sin(st2.x*500.+iTime/1.)*0.05+1.0);\n    return d2;\n\n}\nfloat monster(vec2 uv){\n    float d;\n    uv*=2.;\n    uv.y-=10.*fract(iTime/30.)-0.5;\n    float dist= length(uv*rot(1.2)-vec2(-0.1,0.12));\n    d=S(0.2,0.13,dist);\n    dist= length(vec2(uv.x+0.8*uv.y,0.3*sin(iTime*2.)*uv.x+0.7*uv.y+1.5*uv.y*uv.y));\n    d+=S(0.1,0.03,dist);\n    dist= length(vec2(0.2*uv.x+0.1*sin(iTime*3.)*uv.y-0.1,0.1*uv.x+0.7*uv.y+1.5*uv.y*uv.y));\n    d+=S(0.1,0.03,dist);\n    dist= length(vec2(0.5*uv.x-0.87*uv.y-0.6,-0.1*uv.x-0.7*uv.y+1.5*uv.y+0.2));\n    d+=S(0.1,0.03,dist);\n    d=clamp(d,0.,1.);\n    return d;\n\n\n}\nvec3 windowColor(vec2 uv){\n    float t = 0.1*iTime;\n    \n    vec4 c,col;\n    col = vec4 (0.7);\n   \n    col+=vec4(1.,1.,0.7,1.)*(0.10/length(uv+vec2(0.7*sin(2.*t),0.1*cos(t))));\n    col+=vec4(0.7,0.7,1.,1.)*(0.10/length(uv+vec2(0.,0.3)+vec2(0.7*sin(1.*t),0.1*cos(3.*t))));\n    col= clamp(col,0.,2.);\n    float x=texture(iChannel0,uv/200.).r;\n    col-=vec4(-0.1)+vec4(0.5*sin(uv.x*uv.y*100.),0.5*cos(uv.y*uv.y*100.),0.,1.)*monster(vec2(-uv.y+0.3,-uv.x));\n    col= clamp(col,0.,2.);\n    col-=vec4(2.7)*box(uv-vec2(0.2,-0.3),vec2(0.1,0.3),0.1);\n    col-=vec4(2.0)*box(uv-vec2(-0.2,-0.4),vec2(0.05,0.2),0.1);\n    col-=vec4(0.4)*box(uv-vec2(-0.1,-0.3),vec2(0.002,0.5),0.02);\n    \n    return col.rgb;\n\n}\n\nvec3 window(vec2 uv){\n    vec2 st=uv;\n    st.y+=0.05;\n    float d= box(st,vec2(0.2,0.44),0.1);\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0.01);\n    col=mix(col,vec3(1.),0.2*(1.-box(uv,vec2(0.7,0.5),0.05))*abs(uv.x));\n    //col*=S(0.01,-0.01,uv.x+uv.y);\n    //col*=texture(iChannel0,uv*1.).r;\n    col=mix(col,windowColor(uv),d);\n    float strip=strips(st);\n    col=mix(col,vec3(0.0),0.8*strip);\n    st=abs(st);\n    //st*=rot(3.14/4.);\n    //col= vec3(1./length())/10.;\n    float d2=curtain(uv*vec2(0.8,0.9),0.05);\n    d2+=curtain(uv*vec2(1.2,0.9),0.03)/2.;\n    d2+=curtain(uv*vec2(1.05,0.9),0.02)/4.;\n    d2*=S(0.5,0.35,uv.y);\n\tcol=mix(col,vec3(0.8),0.7*d2)*1.3;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    //uv*=1.1;\n\tvec3 col=window(uv);\n    //col+=window(uv-vec2(0.9,0.))/3.;\n    //col+=window(uv-vec2(-0.9,0.));\n    //col=vec3(monster(uv));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 53, 53, 100], [102, 102, 140, 140, 216], [218, 218, 240, 240, 590], [592, 592, 629, 629, 1055], [1056, 1056, 1079, 1079, 1590], [1591, 1591, 1617, 1617, 2287], [2289, 2289, 2310, 2310, 2985], [2987, 2987, 3044, 3094, 3353]], "test": "untested"}
{"id": "wldXRB", "name": "kifs tunnel", "author": "rodgzilla", "description": "kifs tunnel with glow.", "tags": ["raymarching", "tunnel", "kifs"], "likes": 2, "viewed": 286, "published": "Public API", "date": "1581268767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time .5 * iTime\n//#define ZPOS -30.\n#define ZPOS -30. + 30. * time\n#define XPOS 0.\n#define YPOS 0.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float tf1, float tf2, float s, float r) {\n    float tr1 = floor(time) + smoothstep(0., .5, fract(time));\n\tfloat tr2 = floor(time) + smoothstep(.5, 1., fract(time));\n    for (float i = 0.; i < 6.; i++) {\n        p.xy *= rot2d(tf1 * tr1);\n        p.yz *= rot2d(tf2 * tr2 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, vec3 c) {\n\treturn length(p.xy - c.xy) - c.z;   \n}\n\nvec3 rep(vec3 p, vec3 r) {\n    vec3 q = mod(p, r) - .5 * r;\n    \n    return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p.xy *= rot2d(p.z / 100.);\n    p = rep(p, vec3(35.));\n    p.xy *= rot2d(sin(p.z * .2));\n    float d = 500.;\n    \n    vec3 pk = kifs(p, .5, .3, 3., .7);\n    float obj = max(\n        // repeated shape interpolates between cylinder and box\n        mix(\n            cylinder(pk, vec3(.1, .05, .1)),\n            box(pk, vec3(.2)),\n          \t.5 * sin(time * .6) + .5  \n        ),\n        // Intersection with a big sphere or box to\n        // prevent the shape going to infinity\n        mix(\n            sphere(p, 12.),\n            box(p, vec3(10)),\n            .5 * sin(2. * time) + .5\n        )\n    );\n\n    d = min(d, obj);\n\tat += .1 / (.2 + abs(d));\n        \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float swave = .5 * sin(.7 * time) + .5;\n    float d = 0.;\n\n    // The glow color interpolates between blue and red\n    vec3 glowCol = mix(\n        vec3(0., 0., .5),\n        vec3(.5, 0., 0.),\n        swave\n    );\n    \n    for (int i = 0; i < 60; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        glow += 0.002 * at * glowCol;\n        d += ds;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n\n    return n;\n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(XPOS, YPOS, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n     \tdif *= .1;   \n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 col = vec3(0);\n    vec3 ro = vec3(XPOS, YPOS, ZPOS);\n//    ro.x -= step(10. * time;\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n    vec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    col = .2 * dif + glow * vec3(sin(p.z / 10.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 131, 152, 152, 223], [225, 225, 284, 284, 596], [598, 598, 629, 629, 657], [659, 659, 688, 688, 775], [777, 777, 809, 809, 849], [851, 851, 877, 877, 931], [948, 948, 967, 967, 1644], [1667, 1667, 1695, 1695, 2174], [2176, 2176, 2197, 2197, 2361], [2363, 2363, 2384, 2384, 2643], [2645, 2645, 2702, 2702, 3145]], "test": "untested"}
{"id": "WldXRM", "name": "Swirly Thing 234234", "author": "dandymcgee", "description": "desc", "tags": ["tag"], "likes": 0, "viewed": 31, "published": "Public", "date": "1580647537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvec4 circle_gradient(vec2 uv, vec2 pos, float rad) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(vec3(length(pos - uv)/rad), 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV coordinate of current fragment\n    vec2 uv = fragCoord.xy;\n    \n    // This would be the center of your berry texture (probably vec2(0.5) for a normal full-size texture)\n\tvec2 center = iResolution.xy * 0.5;\n    \n    // IGNORE: Radius of berry circle\n\tfloat rad = 0.25 * iResolution.x; \n    // IGNORE: Gray background layer\n\tvec4 layer1 = vec4(vec3(0.7), 1.0);\n\t// IGNORE: Draw berry circle\n    vec4 layer2 = vec4(0.7, 0.0, 0.0, circle_gradient(uv, center, rad).a);\n\n    // Pestle radius (arbitrary constant, just play with it)\n    float pestle_aoe_radius = 60.0;\n    \n    // The rotating center point of the pestle (0.7 is arbitrary constant, how far from center of berries to rotate around)\n    vec2 pestle = vec2(center.x+cos(iTime)*rad*0.7, center.y-sin(iTime)*rad*0.7);\n    \n    // Calculates gradient (optional, would allow to form a dimple in the mesh by offsetting Y values based on how black it is)\n    vec4 layer3 = vec4(0.7, 0.0, 0.0, 1.0) * circle_gradient(uv, pestle, pestle_aoe_radius);\n    \n\t// IGNORE: Blend the layers\n\tfragColor = mix(mix(layer1, layer2, layer2.a), layer3, layer3.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 132, 132, 251], [253, 253, 310, 351, 1423]], "test": "untested"}
{"id": "WldXRS", "name": "super funky lines", "author": "domorin", "description": "super funky lines", "tags": ["lines", "funky", "super"], "likes": 2, "viewed": 140, "published": "Public", "date": "1581210019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LINE_FUNKINESS 23.23\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 makeLine(vec2 uv, vec2 r_uv, float row_id, float scale, float i, float n)\n{    \n    float direction = sign(n * 2. - 1.);\n\n    vec2 current_uv = vec2(r_uv);\n    \n    current_uv.y += sin(r_uv.x + iTime * direction * 2.23 * n + row_id * 2.3623) * LINE_FUNKINESS * n * (sin(iTime + n * 80.932) * 0.5 + 0.5) * (sin(iTime) * 0.5 + 0.5);\n\n\n    vec3 current_col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4) + row_id * 23.61232);   \n    return scale / pow(abs(current_uv.y - i * 2.), (1.5 + n*2.) * (1. + sin(iTime + 3.14159*0.5) * 0.5)) * current_col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float rows = 25.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y += iTime * 0.05;\n    \n    float a = iTime * 0.1;// + length(uv) * 3.141592653589 * sin(iTime * 0.12316);\n    float s = sin(a);\n    float c = cos(a);\n        \n    uv *= mat2(c, -s, s, c);\n    \n    \n    uv.x *= iResolution.x / iResolution.y;;\n    \n    uv.y *= rows;\n\n    float row_id = floor(uv.y);\n    vec2 r_uv = vec2(uv.x, fract(uv.y));\n    r_uv = r_uv * 2.0 - 1.0;   \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) * c;   \n\n    \n    float mag = 0.005 * rows;\n\tvec3 col = vec3(0.0);\n    for(float i = -rows; i <= rows; i++)\n    {                \n        float current_row_id = row_id + i;\n        float n = Hash21(vec2(current_row_id, mag));\n        col += makeLine(uv, r_uv, current_row_id, mag + sin(iTime * 0.5 + n * 6.1412) * 0.1, i, n);\n    }\n    \n    for(float i = -rows; i <= rows; i++)\n    {\n        float current_row_id = row_id + i;\n        float n = Hash21(vec2(current_row_id, mag * 0.1));\n        col += makeLine(uv, r_uv, current_row_id, mag * 0.1 + sin(iTime * 0.5 + n * 14.6875) * 0.01, i, n);\n    }\n    \n    for(float i = -rows; i <= rows; i++)\n    {\n        float current_row_id = row_id + i;\n        float n = Hash21(vec2(current_row_id, mag * 0.05));\n        col += makeLine(uv, r_uv, current_row_id, mag * 0.05 + sin(iTime * 0.5 + n * 23.78563) * 0.01, i, n);\n    }\n\n\n    \n\n\n    float power = 2.0;\n    col = vec3(pow(col.x, power), pow(col.y, power), pow(col.z, power));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 53, 53, 147], [149, 149, 229, 229, 695], [699, 699, 756, 756, 2382]], "test": "untested"}
{"id": "WldXW4", "name": "Japanese flag", "author": "l0lcube", "description": "i made this by accident. it kind of looks like the japanese battle flag", "tags": ["flag", "japan", "accidental"], "likes": 2, "viewed": 212, "published": "Public API", "date": "1580949411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 res = iResolution;\n    vec3 crimsonRed = vec3(0.73725490196, 0., 0.17647058823);\n   \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/min(res.x, res.y);\n    \n    vec3 col = vec3(1.,1.,1.);\n    \n    float r = 0.4 + 2.* smoothstep(0.0,0.1,sin(atan(uv.y, uv.x)*16. - iTime*3.));\n\n    col *= crimsonRed + smoothstep(r, r+0.01, length(uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 436]], "test": "untested"}
{"id": "wldXWB", "name": "Wedge - distance 2D", "author": "iq", "description": "Distance to a wedge. Use the mouse to move the apex.", "tags": ["2d", "distancefield", "sdf", "primitive"], "likes": 4, "viewed": 203, "published": "Public API", "date": "1581656656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a wedge.  Use the mouse to move the apex.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdWedge( in vec2 q, in vec2 a, in vec2 c, in vec2 b )\n{\n    q -= c, a -= c, b -= c;\n\n    return \n    // distance\n    sqrt(min( dot2(q-a*clamp(dot(q,a)/dot(a,a),0.0,1.0)),\n              dot2(q-b*clamp(dot(q,b)/dot(b,b),0.0,1.0)) )) * \n    // sign                                  \n    sign(max( cro2(a,q),\n              cro2(q,b) ));\n}\n\nvec2 cossin( in float r )\n{\n    return vec2(cos(r),sin(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float t = 1.0 + 0.1*iTime;\n\tvec2 a = cossin(0.0*t) * 0.5;\n\tvec2 b = cossin(1.0*t) * 0.5;\n\tvec2 c = cossin(2.0*t) * 0.5;\n    \n    // Make sure our geometry has the right winding order.\n    // This line of code would never exist in reality since the\n    // right winding order can be ensured at modeling/editing\n    // time - it doesn't need to happen at runtime.\n    if( cro2(a-b,c-b)>0.0 ) { vec2 tmp=a;a=c;c=tmp; }\n    \n    // distance\n    float d = sdWedge(p,a,b,c);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdWedge(m, a,b,c);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXWB.jpg", "access": "shaders20k", "license": "mit", "functions": [[1136, 1294, 1319, 1319, 1338], [1339, 1339, 1375, 1375, 1403], [1405, 1405, 1466, 1466, 1745], [1747, 1747, 1774, 1774, 1808], [1810, 1810, 1867, 1903, 3006]], "test": "untested"}
{"id": "wldXWr", "name": "Corona Virus", "author": "BigWIngs", "description": "Use mouse to move. See comments.", "tags": ["coronavirus"], "likes": 54, "viewed": 2221, "published": "Public API", "date": "1580802117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Corona Virus\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Music: Xerxes - early-morning-crystals\n//\n// This effect depicts my idea of what a virus could\n// look like taking a huge artistic license. I started making what\n// I imagine to be a lipid bilayer and then realized.. a virus\n// doesn't have one! So then I just figured I'd make it look 'mean'\n// \n// At first I tried using sphere coordinates but they distort too \n// much and have poles, so I ended up with projected cubemap\n// coordinates instead. I think the function WorldToCube below\n// is extremely usefull if you want to bend stuff around a sphere\n// without too much distortion.\n//\n// As usual, the code could be a lot better and cleaner but I figure\n// that by the time its all clean, I've lost interest and the world\n// has moved on. Better ship it while its hot ;)\n//\n// uncomment the MODEL define to see once particle by itself\n// you can change the amount of particles by changing the\n// FILLED_CELLS define\n\n\n//#define MODEL\n#define FILLED_CELLS .3\n\n#define PI 3.1415\n#define TAU 6.2831\n\n#define MAX_STEPS 400\n#define MAX_DIST 40.\n#define SURF_DIST .01\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat N31(vec3 p) {\n\tvec3 a = fract(vec3(p) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a + 79.76);\n    return fract(a.x * a.y * a.z);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec3 SphereCoord(vec3 p) {\n\tfloat x = atan(p.x, p.z);\n    float y = atan(length(p.xz), p.y);\n    \n    return vec3(x/TAU, length(p), 2.*y/TAU);\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    // mattz' distortion correction\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n       \n    return st;\n}\n\nfloat Lipid(vec3 p, float twist, float scale) {\n    vec3 n = sin(p*20.)*.2;\n    p *= scale;\n    \n\tp.xz*=Rot(p.y*.3*twist);\n    p.x = abs(p.x);\n    \n    float d = length(p+n)-2.;\n    \n    float y = p.y*.025;\n    float r = .05*scale;\n    float s = length(p.xz-vec2(1.5,0))-r+max(.4,p.y);\n    d = smin(d, s*.9,.4);\n    \n    return d/scale;\n}\n\nfloat sdTentacle(vec3 p) {\n    float offs = sin(p.x*50.)*sin(p.y*30.)*sin(p.z*20.);\n    \n    p.x += sin(p.y*10.+iTime)*.02;\n    p.y *= .2;\n    \n    float d = sdCapsule(p, vec3(0,0.1,0), vec3(0,.8,0), .04);\n    \n    p.xz = abs(p.xz);\n    \n    d = min(d, sdCapsule(p, vec3(0,.8,0), vec3(.1,.9,.1), .01));\n    d += offs*.01;\n    \n    return d;\n}\n\n\nfloat Particle(vec3 p, float scale, float amount) {  \n    float t = iTime;\n \n    vec3 st = WorldToCube(p);\n    vec3 cPos = vec3(st.x, length(p), st.y);\n    vec3 tPos = cPos;\n    \n    vec3 size = vec3(.05);\n  \t\n    cPos.xz *= scale;\n    vec2 uv = fract(cPos.xz)-.5;\n    vec2 id = floor(cPos.xz);\n    \n    uv = fract(cPos.xz)-.5;\n    id = floor(cPos.xz);\n    \n    \n    float n = N21(id);\n    \n    t = (t+st.z+n*123.32)*1.3;\n    float wobble = sin(t)+sin(1.3*t)*.4;\n    wobble /= 1.4;\n    \n    wobble *= wobble*wobble;\n    \n    wobble = wobble*amount/scale;\n    vec3 ccPos = vec3(uv.x, cPos.y, uv.y);\n    vec3 sPos = vec3(0, 3.5+wobble, .0);\n    \n    vec3 pos = ccPos-sPos;\n    \n    pos.y *= scale/2.;\n   \n    float r = 16./scale;\n    r/=sPos.y; // account for height\n    float d = length(pos)-r;\n    d = Lipid(pos, n, 10.)/scale;\n    \n    d = min(d, length(p)-.2*scale);\t// inside blocker\n    \n    \n    float tent = sdTentacle(tPos);\n    d = min(d, tent);\n    \n    return d;\n}\n\nfloat dCell(vec3 p, float size) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    \n    return max(0., size - d);\n}\n\nfloat GetDist(vec3 p) {\n\tfloat t = iTime;\n    \n    float scale=8.;\n    \n    #ifndef MODEL\n    p.z += t;\n    vec3 id = floor(p/10.);\n    p = mod(p, vec3(10))-5.;\n    float n = N21(id.xz);\n    p.xz *= Rot(t*.2*(n-.5));\n    p.yz *= Rot(t*.2*(N21(id.zx)-.5));\n    scale = mix(4., 16., N21(id.xz));//mod(id.x+id.y+id.z, 8.)*2.;\n    \n    n = N31(id);\n    if(n>FILLED_CELLS) {\t\t\t// skip certain cells\n        return dCell(p, 5.)+.1;\n    }\n    #endif\n    \n   \n    \n    p += sin(p.x+t)*.1+sin(p.y*p.z+t)*.05;\n    \n   \n    float surf = sin(scale+t*.2)*.5+.5;\n    surf *= surf;\n    surf *= 4.;\n    surf += 2.;\n    float d = Particle(p, scale, surf);\n    \n    p.xz *= Rot(.78+t*.08);\n    p.zy *= Rot(.5);\n    \n    d = smin(d, Particle(p, scale, surf), .02);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float cone = .0005;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST+dO*cone) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    if(m.x<-0.45&&m.y<-.45) m += .5;\n    \n    float t = iTime;\n    \n    vec3 col = vec3(0);\n    \n    #ifdef MODEL\n    vec3 ro = vec3(0, 0, -7);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,0,0), vec3(0,1,0), .5);\n    //ro += 3.;\n    #else\n    vec3 ro = vec3(0, 0, -1);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    \n    vec3 up = vec3(0,1,0);\n    up.xy *= Rot(sin(t*.1));\n    vec3 rd = R(uv, ro, vec3(0,0,0), up, .5);\n    \n    ro.x += 5.;\n    ro.xy *= Rot(t*.1);\n    ro.xy -= 5.;\n    #endif\n    \n    float d = RayMarch(ro, rd);\n    \n    float bg = rd.y*.5+.3;\n    float poleDist = length(rd.xz);\n    float poleMask = smoothstep(.5, 0., poleDist);\n    bg += sign(rd.y)*poleMask;\n    \n    float a = atan(rd.x, rd.z);\n    bg += (sin(a*5.+t+rd.y*2.)+sin(a*7.-t+rd.y*2.))*.2;\n    float rays = (sin(a*5.+t*2.+rd.y*2.)*sin(a*37.-t+rd.y*2.))*.5+.5;\n    bg *= mix(1., rays, .25*poleDist*(sin(t*.1)*.5+.5));//*poleDist*poleDist*.25;\n    col += bg;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n   \n    \tvec3 n = GetNormal(p);\n       \n        #ifndef MODEL\n        p = mod(p, vec3(10))-5.;\n        #endif\n        \n        float s = dot(n, normalize(p))-.4;\n        float f = -dot(rd, n);\n        \n        col += dot(n,-rd)*.5+.5;\n    \t//col += (1.-f*f)*s*1.5;\n        \n        col *= 0.;\n        float r = 3.7;\n        float ao = smoothstep(r*.8, r, length(p));\n        col += (n.y*.5+.5)*ao*2.;\n        //col *= 2.;\n        col *= smoothstep(-1., 6., p.y);\n        \n        //col += n*.5+.5;\n    }\n    \n    col = mix(col, vec3(bg), smoothstep(0., 40., d));\n    \n    //col *= vec3(1., .9, .8);\n    //col = 1.-col;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ltBGzD", "previewfilepath": "https://soundcloud.com/spiral-trax/xerxes-early-morning-crystals", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/spiral-trax/xerxes-early-morning-crystals", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1089, 1236, 1255, 1255, 1331], [1333, 1333, 1374, 1374, 1465], [1467, 1467, 1517, 1517, 1685], [1687, 1687, 1706, 1706, 1831], [1833, 1833, 1852, 1852, 1987], [1989, 1989, 2015, 2015, 2133], [2135, 2237, 2263, 2263, 2653], [2655, 2655, 2702, 2702, 2993], [2995, 2995, 3021, 3021, 3337], [3340, 3340, 3391, 3391, 4314], [4316, 4316, 4349, 4349, 4441], [4443, 4443, 4466, 4466, 5214], [5216, 5216, 5250, 5250, 5497], [5499, 5499, 5523, 5523, 5713], [5716, 5716, 5767, 5767, 5953], [5957, 5957, 6014, 6014, 7904]], "test": "untested"}
{"id": "WldXz7", "name": "Ellipse Code Golf", "author": "BeardThings", "description": "Simple ellipse code golf sketch", "tags": ["code", "ellipse", "onetweet", "golf"], "likes": 1, "viewed": 284, "published": "Public API", "date": "1580664149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, vec2 f )\n{\n    vec2 v=f/iResolution.xy*2.-1.,a=.4*vec2(sin(iTime),cos(iTime));\n    c=vec4(distance(v,a)+distance(v,-a)<.84);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 154]], "test": "untested"}
{"id": "wldXzf", "name": "Kaleidoscope of 42yeah", "author": "42yeah", "description": "This was an accident. But it looks good!", "tags": ["kaleidoscope"], "likes": 1, "viewed": 86, "published": "Public", "date": "1581488727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 uv) {\n    return fract(sin(dot(uv, vec2(13.1251, 824.1231))) * 1000000.0);\n}\n\nvec2 rot2d(vec2 uv, float deg) {\n    return vec2(cos(deg) * uv.x - sin(deg) * uv.y, sin(deg) * uv.x + cos(deg) * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord / iResolution.xy;\n\n\tfloat aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    uv = rot2d(uv, iTime * 0.3);\n    for (int i = 0; i < 10; i++) {\n        uv = abs(uv) - 0.15;\n        uv = rot2d(uv, iTime * 0.3);\n    }\n    \n    float l = length(uv);\n    if (l < (sin(iTime * 0.3) * 0.5 + 0.5) * 0.1 + 0.05) {\n        l = 1.0;\n    }\n\n    // Output to screen\n    fragColor = vec4(l, l, 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 94], [96, 96, 128, 128, 217], [219, 219, 276, 326, 772]], "test": "untested"}
{"id": "wlGGRD", "name": "by the water", "author": "zxxuan1001", "description": "water, sky, nice sunshine, and stuff.", "tags": ["reflection", "water", "transparent"], "likes": 10, "viewed": 428, "published": "Public API", "date": "1581150332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.0001\n#define SUN_COLOR vec3(1.2, 1.1, 0.8) \n#define SUN_POS vec3(500.0, 160.0, 400.0)\n#define SUN_DIR vec3(0.0,0.8,0.0)\n#define SUN_GLOW vec3(1.2,0.6,0.3)\n#define SKY_COLOR vec3(0.5,0.7,1.0)\n#define OCEAN_COLOR vec3(0.04, 0.2, 0.6)\n#define CLOUD_COLOR vec3(1.0)\n#define MAX_STEP 60\n#define MAX_DIST 30.0\n#define AA 1\n\nfloat noise(in vec2 uv) {\n    return texture(iChannel0, uv/64.0).r;\n}\n\nfloat smoothNoise(in vec2 uv) {\n    vec2 luv = fract(uv); //range from 0.0 to 1.0\n    vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n    luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n    \n    //get values from the cordinates of a square\n    float bl = noise(id);\n    float br = noise(id + vec2(1.0, 0.0));\n    float tl = noise(id + vec2(0.0, 1.0));\n    float tr = noise(id + vec2(1.0, 1.0));\n    \n    float b = mix(bl, br, luv.x); //interpolate between bl and br\n    float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n    \n    return mix(b, t, luv.y);\n}\n\nfloat fbm4(in vec2 uv) {\n    float amp = 0.5;\n    float f = 2.0;\n    float h = 0.0;\n    float a = 0.0;\n    for (int i = 0; i < 4; i++){\n        h += amp * smoothNoise(uv*f);\n        a += amp;\n        amp *= 0.5;\n        f *= 2.0;\n    }\n    \n    h /= a;\n    return h;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat displacement (vec3 p) \n{\n    return sin(-p.y*0.8);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nconst vec3 SCALE = vec3(18.0, 12.0, 15.0);\nvec4 stuff(vec3 p) {\n    float t = sin(iTime*0.5 + p.x * 0.22 + p.z * 0.13 + p.y * 0.15);\n    p = p - vec3(6.0, 0.8+t*t, 6.0);\n    //vec3 q = p - SCALE * clamp(round(p/SCALE), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    //vec2 id = vec2(floor(q.x/5.0 - 2.5),floor(q.z/5.0 - 2.5));\n    //float fid = id.x*13.3 + id.y*5.7;\n    //float wr = 1.2+0.5*sin(fid);\n    \n    float wr = 1.2;\n    float d = sphereSDF(p, wr) + displacement(p);\n    d *= 0.5;\n    return vec4(d, 3.0, 0.0, 1.0);\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nfloat wave(in vec3 p) \n{\n    float t = iTime * 0.5;\n    float hi = 0.0;\n    hi += 0.15*smoothNoise(vec2(p.x*3.0 + t, p.z*2.5 + t));\n    hi += 0.13*smoothNoise(vec2(p.x*2.2 - 1.5*t, 0.0));\n    hi += 0.11*smoothNoise(vec2(p.x*2.2 - t, p.z*3.2 - t));\n    //hi += 0.001*texture(iChannel0, p.xz*3.0).r;\n    return hi;\n}\n\nvec4 water(in vec3 p, float h) {\n    \n    float hi = wave(p);\n    h += 0.15*hi;\n    float d = p.y - h;\n    return vec4(d, 1.0, 1.0, 0.0);\n}\n\nvec2 rot2D(in vec2 xy, float d)\n{\n    float c = cos(d);\n    float s = sin(d);\n    return vec2(xy.x * c - xy.y * s, xy.x * s + xy.y * c);\n}\n\nvec4 land(in vec3 p, float h) {\n    float hi = 0.0;\n    float wave = 0.8*sin(-p.x*0.1) + 0.8*sin(-p.z*0.17);\n    \n    vec2 xy = rot2D(p.xz, -0.8); \n    //hi += 0.005*smoothNoise(vec2(xy.x*17.37, xy.y*5.5)); //a bit of a sand pattern\n    \n    h += wave ;\n    h += hi;\n    h -= 0.008*texture(iChannel1, p.xz*0.7).r; \n    float d = p.y - h;\n    return vec4(d, 2.0, 0.0, 0.0);\n}\n\nvec4 map(in vec3 p) {\n    vec4 res = vec4(0.0); //distance, material, reflect, refract\n    //p.z -= 1.5;\n    vec4 d0 = land(p, -0.5);\n    vec4 d1 = stuff(p);\n    vec4 d2 = water(p, -0.4);\n    res = sdUnion(d0, d1);\n    res = sdUnion(res, d2); \n    \n    return res;\n}\n\nfloat castRayB(in vec3 ro, in vec3 rd) {\n   float t = 0.01;\n   for ( int i = 0; i < 30; ++i )\n   {\n       vec3 pos = ro + t * rd;\n       vec4 h = stuff( pos );\n       if ( h.x < EPSILON) return t;\n       t += h.x;\n       if (t > MAX_DIST) return MAX_DIST;\n   } \n   return MAX_DIST;\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd)\n{\n   float t = 0.01;\n   vec3 m = vec3(0.0);\n   float tMax = MAX_DIST;\n\n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t * rd;\n       vec4 h = map( pos );\n       m = h.yzw;\n       if ( h.x < EPSILON * t ||  t > tMax)\n       {\n           break;\n       }\n       t += h.x;\n   } \n    \n   if ( t>tMax )\n   {\n       m = vec3(-1.0);\n   }\n   return vec4(t,m);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n\nvec3 sky2D(vec3 skyColor, vec3 cloudColor, vec2 uv) {\n    vec3 col = vec3(0.0);\n    float t = iTime * 0.1;\n    float n1 = fbm4(vec2(uv.x + t, uv.y - t));\n    col = mix( skyColor, cloudColor, smoothstep(0.2, 0.8, n1));\n    return col;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.8;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcSky(vec3 ro, vec3 rd) {\n    //from IQ.\n    const float SC = 1e5;\n    //Trace out to a distant XZ plane.\n    float dist = (SC - ro.y)/rd.y; \n    vec2 p = (ro + dist*rd).xz;\n    \n    vec3 sunDir = normalize(SUN_POS - ro);\n    float sun = max(dot(sunDir, rd), 0.0);\n    float core = smoothstep(0.98, 1.0, sun);\n    \n    vec3 skyCol = vec3(0.0);\n    vec3 cloudCol = CLOUD_COLOR;\n    \n    \n    skyCol += 0.5*SUN_COLOR*pow(core, 64.0);\n    skyCol += 0.8*SUN_GLOW*pow(sun, 32.0);\n    skyCol += mix(SUN_GLOW, SKY_COLOR, 2.0*abs(rd.y));//horizontal brightness\n       \n    skyCol = sky2D(skyCol, cloudCol, p*1.2/SC);\n    float grad = smoothstep(0.0, 0.1, rd.y);\n    skyCol = mix(SUN_GLOW, skyCol, grad);\n    return skyCol;\n}\n\nvec3 calcLighting(in vec3 ro, in vec3 rd, in vec4 hit) {\n    vec3 outCol = vec3(0.0);\n    vec3 hitPoint = ro + hit.x * rd;\n    vec3 sunDir = normalize(SUN_POS - ro);\n    vec3 nor = getNormal(hitPoint);\n    \n    // draw water color \n    vec3 waterCol = vec3(0.0);\n    \n    // water reflection\n    vec3 refDir = normalize(reflect(rd, nor));\n    vec3 reflectCol = calcSky(hitPoint, refDir);\n    \n    // water specular\n    vec3 H = normalize(sunDir - rd);\n    float RN = max(dot(H, nor), 0.0);\n    float spec = 0.8*pow(RN, 32.0);\n    vec3 specCol = (SUN_COLOR + SUN_GLOW) * spec; \n    \n    // water flare \n    float rnd = 2.0*noise(vec2(hitPoint.x * 3.4738, hitPoint.z * 7.7319));\n    rnd *= 1.0-exp(-0.2*hit.x);\n    specCol +=  rnd * spec;\n     \n    // water diffuse \n    float diff = max(dot(sunDir, nor), 0.0); \n    vec3 diffCol = SUN_COLOR  * OCEAN_COLOR;\n    \n    // fresnel\n    float fresnel = 1.0 - max(dot(nor,-rd),0.0);\n    fresnel = pow(fresnel,3.0);\n    waterCol = mix(diffCol, specCol + reflectCol, fresnel); \n    \n    // land\n    vec3 landDiff = SUN_GLOW * diff;\n    \n    //refract \n    float refractRatio = 0.75;\n    vec3 refractDir = normalize(refract(rd, nor, refractRatio));\n    vec3 refractCol = calcSky(hitPoint, refractDir);\n    \n    //reflect\n    float t = castRayB(hitPoint, refDir);\n    if (t < MAX_DIST) {\n        waterCol *= vec3(1.0, 0.92, 0.92); //fake reflection\n    }\n    \n    \n    if (hit.y == 1.0) {\n        outCol = waterCol;\n    } else {\n        // wet area\n        float w0 = smoothstep(-0.3, -0.15-0.1*rnd, hitPoint.y);\n        outCol = mix(landDiff*0.5, landDiff, w0);\n\n        float w1 = smoothstep(-0.4, -0.2, hitPoint.y);\n        outCol = mix(waterCol, outCol, w1);\n    }  \n    \n    outCol = mix(outCol, refractCol , hit.w);\n    return outCol;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5; // translate to the center of the screen\n    uv.x *= iResolution.x / iResolution.y; // restore aspect ratio\n    vec2 mouse = vec2(0.0);\n    mouse = iMouse.xy/iResolution.xy;\n   \n    //define camera\n    float t = iTime * 0.1;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(cos(mouse.x * 6.28 + t), mouse.y*2.0, sin(mouse.x * 6.28 + t));\n    mat3 cam = getCamera(ro, ta, 0.0);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    rd = normalize(rd);\n    vec3 bgCol = calcSky(ro, rd);\n \tvec3 outCol = vec3(0.0);\n    outCol = bgCol;\n    \n    vec4 hit = castRay(ro, rd);\n    vec3 pos = ro + hit.x * rd;\n    vec3 nor = getNormal(pos);\n    \n    if (hit.x < MAX_DIST) {\n        outCol = calcLighting(ro, rd, hit);\n        // fog\n        outCol = mix( outCol, SUN_GLOW, 1.0 - exp( -0.008 * hit.x * hit.x ) );\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixCol = vec3(0.0);\n    vec2 offset = vec2(0.0);\n    \n#if AA>1\n    for (float y = 0.0; y < float(AA); ++y)\n    {\n        for (float x = 0.0; x < float(AA); ++x)\n        {\n            offset = -0.5 + vec2(x, y) / float(AA);\n\n        \tpixCol += render(fragCoord+offset);\n        }\n    }\n    pixCol /= float(AA*AA);\n#else\n    pixCol += render(fragCoord);\n#endif\n    \n    // tone mapping\n   \t//float exposure = 1.0;\n    //pixCol = 1.0 - exp(-pixCol * exposure);\n    \n    // gamma\n    pixCol = pow( pixCol, vec3(0.4546));\n    \n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    pixCol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.3);\n    fragColor = vec4(pixCol, 1.0);\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 361, 361, 405], [407, 407, 438, 438, 988], [990, 990, 1014, 1014, 1258], [1260, 1260, 1311, 1311, 1411], [1413, 1413, 1443, 1443, 1471], [1473, 1473, 1507, 1507, 1535], [1580, 1580, 1600, 1600, 2064], [2066, 2066, 2098, 2098, 2131], [2133, 2133, 2157, 2157, 2447], [2449, 2449, 2481, 2481, 2588], [2590, 2590, 2623, 2623, 2728], [2730, 2730, 2761, 2761, 3104], [3106, 3106, 3127, 3127, 3372], [3374, 3374, 3414, 3414, 3657], [3659, 3659, 3697, 3697, 4069], [4071, 4071, 4095, 4095, 4386], [4389, 4389, 4442, 4442, 4624], [4626, 4626, 4674, 4674, 4957], [4959, 4959, 4991, 5006, 5682], [5684, 5684, 5740, 5740, 7464], [7466, 7466, 7518, 7518, 7696], [7698, 7698, 7730, 7730, 8619], [8621, 8621, 8678, 8678, 9383]], "test": "untested"}
{"id": "WlGSRw", "name": "MyDistortionv1", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 1, "viewed": 176, "published": "Public API", "date": "1582362336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x){\n    return fract(sin(x * 100.) * 43758.5453);\n}\n\nvec2 rand(vec2 uv){\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y)  * 561.5453);\n    return uv;\n}\n\nvec2 uvtransform(vec2 uv, float strength){\n    float clsz = 0.5; // cellsize\n    //vec2 nwuv = float(int(uv / clsz)) * clsz;\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    vec2 A = mix(rand(nwuv + vec2(0., 0.)  ), rand(nwuv + vec2(clsz, 0.)  ), (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 B = mix(rand(nwuv + vec2(0., clsz)), rand(nwuv + vec2(clsz, clsz)), (uv - nwuv).x / clsz);\n    vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nvec2 distortion(vec2 uv, float strength, int power){\n    for (int i = 0; i < power; i++){\n        uv = uvtransform(uv, strength);\n    }\n    return uv;\n}\n\nvec4 something(vec2 uv){\n    vec2 ans = uvtransform(uv + vec2(0., iTime / 20.), 0.7);\n    if (abs(ans.y - 0.5 - iTime / 20.) < 0.1){\n        float f = 1. - smoothstep(0., 0.2, abs(ans.y - 0.5 - iTime / 20.));\n        return vec4(f);\n        return vec4(1.);\n    }\n    return vec4(0.);\n    //ans = (uv - nwuv) / clsz;\n    return vec4(ans, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.y += iTime / 2.;\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(rand(uv), .0, .1);\n    fragColor = vec4(distortion(uv, 0.1, 100) - vec2(0., iTime / 2.), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 68], [70, 70, 89, 89, 374], [376, 376, 418, 418, 1054], [1056, 1056, 1108, 1108, 1208], [1210, 1210, 1234, 1234, 1558], [1560, 1560, 1617, 1667, 1979]], "test": "untested"}
{"id": "WlGSRz", "name": "Smooth gradientyness", "author": "Bupeldox", "description": "It uses 3 points to get the colour and smoothes the gradients betweeen", "tags": ["smooth"], "likes": 0, "viewed": 66, "published": "Public", "date": "1582022215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\n\nfloat counter = 0.0;\nvec2 grain(vec2 inp){\n    float fuzzSize = 0.02;\n    float offsetTime = iTime+20.0;\n    counter+=(((inp.x*offsetTime*iResolution.x)-100.0)*(inp.y*offsetTime*iResolution.y));\n    inp.x+= sin(mod(counter,6.2436346))*fuzzSize;\n    counter+=(((inp.x*offsetTime*iResolution.x)-100.0)*(inp.y*offsetTime*iResolution.y));\n    inp.y+=sin(mod(counter,6.2436346))*fuzzSize;\n    return inp;\n}\n\n\nfloat isin(float inp){\n    return ((sin(inp)+1.0)*0.5);\n}\n\nfloat icos(float inp){\n    return ((cos(inp)+1.0)*0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = grain(uv);\n    \n    vec2[] points = vec2[](\n        vec2(isin(iTime),0.5),\n        vec2(icos(iTime*0.25),icos(iTime*0.5)),\n        vec2(0.9,icos(iTime*0.25))\n    );\n    \n     vec3 color = vec3(10);\n    \n    color.x = length(points[0]-uv);\n    color.y = length(points[1]-uv);\n    color.z = length(points[2]-uv);\n   \t\n    \n    \n    \n    \n    fragColor = vec4(color,1);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 63, 63, 422], [425, 425, 447, 447, 482], [484, 484, 506, 506, 541], [544, 544, 601, 601, 1024]], "test": "untested"}
{"id": "wlGSz1", "name": "Imprisoned", "author": "haptix", "description": "Experimenting with some concepts I'm learning", "tags": ["raymarched"], "likes": 1, "viewed": 152, "published": "Public API", "date": "1582176382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float glow = 0.;  //GLOW baby\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nvec3 twist(vec3 pos)\n{\n    float c = sin(.1 * pos.x + iTime * cos(iTime*.001));\n    float s = cos(.1 * pos.x + iTime * cos(iTime*.001));\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.zy, pos.x);\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat hollowBox(vec3 pos, float radius)\n{\n    return differenceSDF(box(pos, vec3(radius)), sphere(pos, radius*1.3));\n}\n\nfloat distfunc(vec3 pos, float radius)\n{\n    float hollowB = hollowBox(twist(pos), radius);\n    float sphereB = sphere(pos, radius*0.8);\n    float shape = unionSDF(hollowB, sphereB);\n    glow += 0.1 / (0.1 + shape*shape);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(20. * sin(iTime*.5), 20. * cos(iTime*.5), 14.);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 100.0;\n    const float EPSILON = 0.002;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    float radius = 10.;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos, radius);\n        totalDist += dist;\n        pos += dist * rayDir*.5;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx, radius) - distfunc(pos - eps.yxx, radius),\n            distfunc(pos + eps.xyx, radius) - distfunc(pos - eps.xyx, radius),\n            distfunc(pos + eps.xxy, radius) - distfunc(pos - eps.xxy, radius)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal * 0.9));\n        float specular = pow(diffuse, 100.0);\n\t\t\n        vec3 color = vec3(.2*sin(iTime*0.2) + 0.45,\n                          .2*cos(iTime*0.3) + 0.45,\n                          .2*sin(iTime*0.7) + 0.45) * (diffuse + specular) / (1. + totalDist * 0.05);\n\n\n        fragColor = vec4(color + glow*.015, 1.0);\n    }\n    else\n        fragColor = vec4(0.) + glow*.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 31, 69, 69, 104], [106, 106, 138, 138, 186], [188, 188, 210, 210, 395], [397, 397, 439, 439, 471], [473, 473, 520, 520, 553], [555, 555, 596, 596, 673], [675, 675, 715, 715, 916], [918, 918, 975, 975, 2746]], "test": "untested"}
{"id": "wlGSzm", "name": "lost in spacetime..", "author": "julianlumia", "description": ":octopusballoon:\ncoloring based on:  https://www.shadertoy.com/view/WlKXRW", "tags": ["space"], "likes": 8, "viewed": 201, "published": "Public", "date": "1582402456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 pA = vec3(0);\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\n\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,1./.2);\n t *=2.;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = .2;\n float modd = 2.1;\n float sqD = max(abs(t.x), abs(t.y));\n sqD +=.5 + yid*0.4;\n float sqid = floor(sqD/modd);\n sqD = lmod(sqD, modd);  \n d = min(d, sqD);\n o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*10.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n float dp = dot(p,p)*.6;\n p /= dp;\n p.xz*= Rot(cos(iTime*0.5));\n p.xy *=  Rot(cos(iTime*1.-0.2));\n p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n vec3 q = (text(p.xz, p)).xyz;\n return q;\n}\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat g1;\n\nvec2 GetDist(vec3 p) {\n vec2 d =vec2(0.);\n vec3 q = p;\n float dp = dot(p,p)*.6;\n p /= dp;\n p.xz*= Rot(cos(iTime*0.5));\n p.xy *=  Rot(cos(iTime*1.-0.2));\n p = rotate( ( vec3(cos(p.xyz*.5+iTime*.5) ) ), 120.)*p-3.;\n p.xy=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).xy;\n p.xy*= Rot((1.));\n d = vec2(sdBox(p,vec3(1.)) + sdBox(q,vec3(0.2)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/8.));\n g1 +=1./(.018+pow(abs(d.x),1.));\n d = condmin( d,d);\n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<100; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<SURF_DIST||t.x>MAX_DIST) break;\n  t.x+=h.x;t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n// vec3 lightPos = vec3(sin(iTime)*2., cos(iTime)*2., 3);\n     vec3 lightPos = vec3(0.,0.,0);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(0, 0, 1.1);\n ro.xy *= Rot(sin(iTime*.1)*6.2831);\n ro.xz *= Rot(sin(iTime*0.2)*6.2831);\n vec3 rd = R(uv, ro, vec3(0,0,0), 1.2);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(1,0,cos(iTime*2.)+.5);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n  if(d.y==1.) col += tex3D(p,n)*5.;\n }\n col*=g1*vec3(.00005);  \n col+=g1*vec3(-.0001);  \n float fog = 2. / (1. + d.x * d.x *10.);\n col *= vec3(fog); \n col+=g1*vec3(.000002);  \n col*= 5.; \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 272, 272, 339], [341, 341, 370, 370, 448], [469, 469, 510, 510, 874], [876, 876, 902, 902, 1483], [1485, 1485, 1521, 1521, 1809], [1811, 1811, 1849, 1849, 1916], [1929, 1929, 1951, 1951, 2381], [2383, 2383, 2419, 2419, 2600], [2602, 2602, 2625, 2625, 2809], [2812, 2812, 2836, 2894, 3088], [3090, 3090, 3132, 3132, 3286], [3290, 3290, 3347, 3347, 4051]], "test": "untested"}
{"id": "WlGSzy", "name": "movingcross", "author": "NY", "description": "aa", "tags": ["2d"], "likes": 1, "viewed": 107, "published": "Public", "date": "1582947473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 brickTile(vec2 st, float zoom)\n{\n    // 拡大\n    st *= zoom;\n    // 座標と原点のラジアン\n    float radian = atan(st.y,st.x);\n    //縦横どちらを動かすか　\n    float isMoveLine = step(0.499999,(fract(iTime)));\n    // modとfloorを奇数行と偶数行を0と1に\n    // isMoveLineで停止する時間を作る\n    vec2 f = (floor(mod(st,2.))* 2. -1. ) * iTime;\n    st.x +=  f.y * isMoveLine * 2.;\n    st.y +=  f.x * (mod(isMoveLine + 1.,2.)) * 2.;\n    return fract(st);\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = brickTile(uv,5.);\n\n   vec3 col = vec3(smoothstep(0.29,0.3, length(uv - 0.5)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 51, 499], [503, 503, 560, 610, 800]], "test": "untested"}
{"id": "wlGXzz", "name": "大龙猫 - Nvidia", "author": "totetmatt", "description": "nvidia", "tags": ["nvidia"], "likes": 7, "viewed": 294, "published": "Public API", "date": "1582059223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ITER 92.\n#define dtime pow(fract(iTime*.25),.5)+floor(iTime*.25)\n#define ttime sin(iTime) *pow(cos(pow(iTime,.125)),2)\nmat2 r(float a){return mat2(cos(a),sin(a),\n                           -sin(a),cos(a));}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\nfloat sdBox (vec3 p, vec3 corner)\n{ \n    vec3 q = abs(p)-corner;\n    return  min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)); \n}\n\n\n// SDF Sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// Global SDF\n// This represent our \"scene\" with the objects\n\n\nfloat fig(vec3 pos, float x,float b) {\n pos.y-=0.4;\n      pos.y +=cos(abs(pos.x))*.5*(b);\n      float sideBox =sdBox(pos,vec3(1.9*x,0.1-cos(abs(pos.x))*.05,0.4));\n      return sideBox;\n}\nvec2 SDF(vec3 pos) {\n   pos.y+=.5;\n   float c = 15.;\n      vec3 ppos = pos;\n      \n     vec3 id = floor(pos);\n      ppos.xy *=r(ppos.z*.006*sin(dtime));\n     pos = mod(ppos+0.5*c,c)-0.5*c;\n  \n   \n     pos.x*=1.4; \n     pos.yz  *=r(sin(iTime+pos.x*.5)*.4);\n     pos.xz  *=r(cos(iTime+pos.x*.5)*.4);\n \n\n   float dist = min(fig(pos+vec3(-.2,-0.4,.0),0.7,1.5),\n                min(fig(pos,1.,1.2),\n                    fig((-pos)+vec3(-.2,+1.1,.0),1./1.1,1.21))\n   \n   );\n   dist = min(dist,fig((-pos)+vec3(-.17,+.69,.0),0.5,1.21));\n\n   float labox = sdBox(pos-vec3(0.,.5,.0),vec3(2.3,.99,.29));\n  \n   \n   //dist = max(labox , -dist*cos(pos.x+dtime) );\n   dist = max(labox , -dist*sin(pos.x));\n      \n   return vec2(dist,0.0);\n  \n  }\n\n// Compute a normal from a vec3.\nvec3 get_normal(vec3 p) \n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(\n             vec3(\n                  SDF(p+eps.xyy).x - SDF(p-eps.xyy).x, // Diff in X\n                  SDF(p+eps.yxy).x - SDF(p-eps.yxy).x, // Diff in Y\n                  SDF(p+eps.yyx).x - SDF(p-eps.yyx).x  // Diff in Z\n             )\n            );  // Math Vector\n  }\n  \n// Lighting, here my limit of the knowledge\nfloat diffuse_directional(vec3 n,vec3 l){\n        \n    float a =  max(0.,dot(n,normalize(l))); // realistic lighting\n    float b =  dot(n,normalize(l))*.5+.5;   // less realistic lighting\n    return (b+a)/2. ; \n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n  \n  // Initialization of the Ray Marching algorithm\n  vec3 ray_origin = vec3(.01,.01,-8); // Were we start \n \n  vec3 ray_direction = normalize(vec3(uv,1.)); // going forward\n  \n  ray_direction.xz *=r(cos(iTime*.5)*.1);\n  vec3 position = ray_origin ; \n  \n  vec3 color = vec3(.0,.0,.0); // By default, everything will be black\n  \n  bool hit = false; \n  \n  float shad = 0.;\n  float part = 0.;\n  \n  \n  for(float i=0.; i<ITER; ++i) { // We iterate the ray\n \n    vec2 _distance = SDF(position); // Find the closest distance from the current position\n    if(_distance.x <0.0001) { // If we are close enough, it's a hit, we put the shad and break the loop\n        shad = i / ITER;\n        hit = true;\n        break;\n     }\n     part = _distance.y;\n     position += _distance.x * ray_direction; // Otherwise we conditnue the marching, updating the ray position\n   \n  }\n  \n  if(hit) { // If there is a hit we want to perfom some coloring\n  \n    // I don't really understand here, just some lighting effect to get a good rendering\n    vec3 n = get_normal(position);  \n    vec3 l = vec3(0.01+sin(iTime)*10.,-1.5+cos(iTime)*10.,-5.);\n    \n     color =  vec3(diffuse_directional(n,l)); // light diffuse\n   \n    \n      // Using the mix method toget some color\n      if(part == 0.){\n            vec3 color1 = mix(vec3(.1,0.1,0.1), vec3(0.0,0.9,0.2), color)*(1.-shad); \n             vec3 color2 = mix(vec3(.7,0.7,0.), vec3(0.0,0.5,0.6), color)*(1.6-shad); \n             color = mix(color1,color2,smoothstep(-0.5,0.9,sin(-iTime+length(uv)-2.*10.)));\n     } else {\n        color = mix(vec3(.9,0.9,0.9), vec3(0.9,0.0,0.2)+vec3(0.,0.,length(uv)), color)*(1.-shad); \n     }\n  } \n \n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 144, 144, 215], [217, 381, 416, 416, 511], [514, 528, 563, 563, 587], [589, 589, 646, 646, 982], [983, 983, 1019, 1019, 1369], [1371, 1434, 1472, 1472, 1620], [1621, 1621, 1641, 1641, 2349], [2351, 2384, 2410, 2410, 2734], [2738, 2782, 2823, 2823, 2994], [2996, 3013, 3068, 3068, 4823]], "test": "untested"}
{"id": "wlKSR1", "name": "Doodling - A l'ancienne", "author": "Flopine", "description": "A small doodle I did with my old style/tricks. Sometimes it feels good to go back a bit ^^ ", "tags": ["raymarching", "tunnel", "orange"], "likes": 10, "viewed": 190, "published": "Public", "date": "1582221311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define ITER 64.\n#define st (iTime*0.5)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,65.14)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz, p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat bid;\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float per = 7.;\n    bid = floor(p.z/per);\n    p.z = mod(p.z, per)-per*0.5;\n    float anim = (mod(bid,2.)==0.) ? bid+st : bid-st; \n    p.xy *= rot(anim);\n    p.xz *= rot(PI/2.);\n    mo(p.yz, vec2(2.));\n    mo(p.xz, vec2(1.));\n    p.x -= sin(iTime)*0.6;\n    float d = max( \n        \tabs(\n        \tmax(\n                -max(-sc(p, .3), box(p, vec3(1.))),\n            \tbox(p,vec3(1.5,1.5,0.5))\n            \t)\n    \t\t   )\n        \t-0.04,\n        \tabs(p.z)-0.4\n        \t\t);\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dith = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-7.+iTime),\n        p=ro,\n    \trd = normalize (vec3(uv,1.)),\n        col = vec3(0.);\n        \n    float shad =0.;\n    bool hit = false;\n    \n    for (float i=0.;i<ITER;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.8+dith*0.15;\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        float glow = (mod(bid,2.) == 0.) ? g1*0.2 : shad*0.5;\n        col = vec3(0.8,0.3,0.1)*glow;\n    \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 393, 416, 416, 467], [469, 469, 489, 489, 532], [534, 534, 566, 566, 613], [615, 615, 643, 643, 730], [732, 732, 761, 761, 781], [783, 783, 811, 811, 892], [920, 920, 940, 940, 1454], [1456, 1456, 1513, 1513, 2199]], "test": "untested"}
{"id": "WlKSWR", "name": "SmoothMin", "author": "thisisjohnbrown", "description": "Testing smoothmin", "tags": ["smooth"], "likes": 2, "viewed": 46, "published": "Public", "date": "1582825591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t * ab;\n    float d = length(p-c) - r;\n    \n    return d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5* (b-a/k), 0., 1.);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6, 1.5);\n    \n    float s1 = length(p - vec3(0, 1, 6) + (vec3(sin(iTime), 0, cos(iTime)) * 1.5)) - .5;\n    float s2 = length(p - vec3(0, 1, 6) + (vec3(sin(-iTime * 1.7), 0, cos(-iTime * 1.7)) * .5)) - .5;\n    float planeDist = p.y;\n    \n    //float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), .2);\n    float td = sdTorus(p - vec3(0, 1, 6), vec2(1.5, .25));\n    \n    vec3 bp = p - vec3(-1, 1, 6);\n    bp.xz *= Rot(iTime);\n    float bd = sdBox(bp, vec3(1));\n    \n    float d = smin(s1, s2, .7);\n    //d = min(d, planeDist);\n    d = smin(d, td, .7);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    return normalize(n);\n        \n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 3.);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n * SURF_DIST * 10., l);\n    if (d < length(lightPos - p)) dif *= .4;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .6, 1.0));\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 96, 96, 138], [140, 140, 171, 171, 244], [246, 246, 296, 296, 492], [494, 494, 513, 513, 589], [591, 591, 630, 630, 726], [728, 728, 751, 751, 1342], [1344, 1344, 1378, 1378, 1604], [1606, 1606, 1630, 1630, 1827], [1829, 1829, 1853, 1853, 2172], [2174, 2174, 2231, 2231, 2560]], "test": "untested"}
{"id": "WlKSzw", "name": "Funky light experiments", "author": "rodgzilla", "description": "Adding some kind of glow at each step of the ray marching with a direct path to a light source. I am not sure it's the correct way to do this effect. Could someone tell me what algorithm to look for ?", "tags": ["raymarching", "light"], "likes": 2, "viewed": 228, "published": "Public API", "date": "1582414809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define ZPOS -30.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat wave(float t, float a) {\n    return a * (.5 * sin(time) + .5);\n}\n\nvec3 kifs(vec3 p, float r, float s, float tf, float it) {\n    float t = tf * time;\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .6);\n        p.yz *= rot2d(t * .7 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p, 1.3, .7, 1., 4.);\n//    p.xz *= rot2d(time);\n//\tfloat d = p.y + 1.;\n  \tfloat d = 500.;  \n    float obj = sph(p, 1.);\n\tobj = max(obj, -tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), .5));\n    d = min(d, obj);\n    \n    at += .2 / (.1 + pow(d, 3.));\n    \n    return d;\n}\n\nfloat secondary_light(vec3 p) {\n    vec3 lp = vec3(0, 0, 0);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n\n    float d = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p_rm = p + d * tln;\n        float ds = map(p_rm);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds;\n    }\n    \n    if (d < length(tl)) {\n        return 0.;\n    }\n    \n    \n    return 1.;\n}\n\nvec3 glow = vec3(0, 0, 0);\nvec3 glow2 = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * 1.;\n    glow += .0002 * at * vec3(.5, 0., 0.);\n      \n    float sec_light = secondary_light(p);\n    glow2 += (.05 + wave(2.3, .1)) * sec_light * vec3(0., 0., 1.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(2, 5, ZPOS);\n//  lp.xz *= rot2d(time);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n//    uv *= sin(time);\n//    uv *= rot2d(sin(time) * PI);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n    \n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n//  \tfloat dif = light(p);\n  \t\n//    vec3 col = .2 * dif * glow;\n//  \tvec3 col = vec3(dif) + glow2 + glow;\n  \tvec3 col = glow2 + glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 82, 82, 147], [149, 149, 177, 177, 203], [205, 205, 235, 235, 275], [277, 277, 334, 334, 542], [544, 544, 589, 589, 746], [748, 748, 774, 774, 822], [839, 839, 858, 858, 1134], [1136, 1136, 1167, 1167, 1556], [1613, 1613, 1641, 1641, 2004], [2006, 2006, 2027, 2027, 2174], [2176, 2176, 2197, 2197, 2449], [2452, 2452, 2509, 2509, 3006]], "test": "untested"}
{"id": "wlKXzh", "name": "Riemann's Zeta Function", "author": "mla", "description": "Riemann's Zeta Function\n\nDerived from Justaway's [url]https://www.shadertoy.com/view/4lcBDs[/url], but computing the log of the Gamma function to avoid overflow.\n\nUse the mouse to move around (and see code header for other controls).", "tags": ["domain", "gamma", "zeta", "log"], "likes": 8, "viewed": 316, "published": "Public API", "date": "1582220208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Riemann zeta function using reflection.\n// Original by Justaway: https://www.shadertoy.com/view/4lcBDs\n// Use log gamma function to avoid overflow\n//\n// Method: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\n//\n// Also optimize log sin and log cos:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\n//\n// Grid lines at Re(z) = 10n, Im(z) = 0.5 (the critical line)\n//\n// Seems accurate up to about Re(z) = 50 or so, then the reflection starts\n// to be misaligned and the purported roots come away from the critical line.\n//\n// <mouse> to move\n// g: show grid\n// r: don't do the reflection\n// x: show log gamma instead of zeta\n// z: zoomed view\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\nconst float LOG2 = 0.6931471805599453;\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n  return cexp(cmul(z2,clog(z1)));\n}\n\nvec2 cpow(int n, vec2 z2) {\n  return cpow(vec2(n,0),z2);\n}\n\nvec2 cpow(float x, vec2 z2) {\n  return cpow(vec2(x,0),z2);\n}\n\nvec2 csin(vec2 z) {\n    return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\nvec2 ccos(vec2 z){\n  z += vec2(0.5*PI,0);\n  return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\n// Approximations to log(sin(z)) and log(cos(z)) from David Young:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\nvec2 clogsin(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(1.5*pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(0.5*pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(sin(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(1.5*PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(0.5*PI+x, 2.0*PI) - PI);\n  else return clog(csin(z));\n}\n\nvec2 clogcos(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(cos(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(PI+x, 2.0*PI) - PI);\n  else return clog(ccos(z));\n}\n\n// Lanczos approximation for Gamma function\n// See Numerical Recipes\nconst float[8] p = float[](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 cloggammaR(vec2 z) {\n  z -= vec2(1,0);\n  vec2 x = vec2(-1.9007e-13,0); // 0.99999999999980993 - 1\n  vec2 pval;\n  int N = 8;\n  // Add smallest first for hopefully increased accuracy.\n  for (int i = N-1; i >= 0; i--) {\n    x += p[i]*cinv(z+vec2(float(i+1),0));\n  }\n  x += vec2(1,0);\n  vec2 t = z + vec2(float(N)-0.5,0);\n  // Original non-log function\n  //return cmul(cmul(cmul(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  vec2 a = vec2(0.5*LOG2PI,0);\n  vec2 b = cmul(clog(t),z+vec2(0.5,0));\n  vec2 c = -t;\n  vec2 y = a+b+c+clog(x);\n  return y;\n}\n\nvec2 cloggammaL(vec2 z) {\n  vec2 a = vec2(LOGPI,0);\n  vec2 b = clogsin(PI*z);\n  vec2 c = cloggammaR(vec2(1,0)-z);\n  vec2 y = a-b-c;\n  return y;\n}\n\nvec2 cloggamma(vec2 z) {\n  if(z.x > 0.0) return cloggammaR(z);\n  else return cloggammaL(z);\n}\n    \nvec2 zeta(vec2 s) {\n  const int N = 20;\n  const float[N] ek = float[N](\n    1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*cinv(cpow(float(i), s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = 1.0;\n  for(int i = N + 1; i <= 2 * N; i++) {\n    sum2 += a*ek[i - N - 1]*cinv(cpow(float(i),s));\n    a = -a;\n  }\n  sum2 = sum2/1048576.0; // 2**N\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\nvec3 gradient(float theta) {\n    vec3 color = vec3(0);\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec3 plotDomain(vec2 z) {\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1), rgb, c.y);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 offset = vec2(3.0*iTime,0);\n    if (iMouse.x > 0.0) {\n      offset = -(2.0*iMouse.xy - iResolution.xy)/iResolution.x*100.0;\n    }\n    float zoom = 10.0;\n    if (keypress(CHAR_Z)) zoom = 2.0;\n    vec2 z = (zoom*uv + offset).yx; // Scale and shift\n    vec2 z0 = z; // Starting value of z\n    if (keypress(CHAR_X)) {\n        z = cloggamma(z);\n    } else if (keypress(CHAR_R) || z.x > 0.0){\n      z = zeta(z);\n    } else {\n      // Reflection\n      vec2 temp = zeta(vec2(1,0)-z);\n      temp = clog(temp);\n      temp -= cloggamma(z)+vec2(LOG2,0);\n      temp += LOG2PI*z;\n      temp -= clogcos(0.5*PI*z);\n      temp = cexp(temp);\n      z = temp;\n    }\n    vec3 color = plotDomain(z);\n    //color = hsv2rgb(vec3(atan(z.y,z.x)/(2.0*PI),1,1));\n    //float k = log(length(z));\n    //k = max(k,1.0/k);\n    //color = hsv2rgb(vec3(k,1,1));\n    if (keypress(CHAR_G)) {\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.x-0.5)));\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.y-10.0*round(z0.y/10.0))));\n    }\n    fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1070, 1099, 1099, 1141], [1143, 1143, 1162, 1162, 1198], [1200, 1200, 1229, 1229, 1259], [1261, 1261, 1280, 1340, 1396], [1398, 1398, 1417, 1417, 1484], [1486, 1486, 1515, 1515, 1551], [1553, 1553, 1580, 1580, 1611], [1613, 1613, 1642, 1642, 1673], [1675, 1675, 1694, 1694, 1775], [1777, 1777, 1795, 1795, 1897], [1899, 2082, 2104, 2104, 2583], [2585, 2585, 2607, 2607, 3070], [3072, 3357, 3382, 3382, 3924], [3926, 3926, 3951, 3951, 4071], [4073, 4073, 4097, 4097, 4166], [4172, 4172, 4191, 4191, 4911], [4913, 4913, 4941, 4941, 5780], [5782, 5782, 5807, 5807, 5925], [5927, 5927, 5954, 5954, 6128], [6130, 6130, 6154, 6154, 6215], [6310, 6310, 6363, 6363, 7486]], "test": "untested"}
{"id": "wlKXzw", "name": "noname", "author": "zhangwei199807", "description": "describe", "tags": ["1", "1"], "likes": 2, "viewed": 173, "published": "Public API", "date": "1582458742", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n    float t = iTime*3.;\n    \n    \n    float circle = length(uv) - 0.23;\n    float rect =  max(abs(uv.x),abs(uv.y)) - 0.1;\n    \n    //interpolate weight (0,1) 0: circle, 1: rect\n    float w = -sin(t+sin(t+sin(t)))*0.5+0.5; \n\n    float f = circle*(1.-w)+ w*rect; //linear lerp\n    \n    \n    f = smoothstep(0.0,-0.01,f) - smoothstep(-0.01,-0.02,f);    \n    vec3 col = vec3(f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 579]], "test": "untested"}
{"id": "WltSDM", "name": "how to render a black hole -p2", "author": "feefi", "description": "how to render a black hole, part2 - ray marching with gravity", "tags": ["raymarching"], "likes": 4, "viewed": 260, "published": "Public", "date": "1581086664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 black_hole_pos = vec3(0.0,0,1.5); \t\t//黑洞的位置\nfloat event_horizon_radius = 0.3;\t\t//黑洞的事件视界半径\nfloat HitTest(vec3 p){\n\treturn length(p) - event_horizon_radius;\n}\nvec3 GetBg(vec3 p)\n{\n    return smoothstep(vec3(0),vec3(1.),fract(p*1.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //映射到0~1之间\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.  - 1.;\t\n    uv.x *= iResolution.x / iResolution.y;\t\n\tvec3 eye = vec3(0.,0.,-2);    //eye or camera postion 相机位置\n    vec3 sd = vec3(uv.x,uv.y,-1); //screen coord 屏幕坐标\n    vec3 ray_dir = normalize( sd - eye);//ray direction 射线方向\n    \n    vec3 col = vec3(0.);\n    \n\tfloat hitbh = 0.;\n    \n    const int maxStep = 400;//光线最大步进数\n    float st = 0.;      \n    vec3 p = sd;\n    vec3 v = ray_dir;\n    float dt = 0.01;\n    float GM = 0.8;   \n    vec3 cp = black_hole_pos + 2.*vec3(1.5*sin(iTime),sin(1.31*iTime),0.);\n    for(int i = 0;i<maxStep;++i)\n    {\n       \t//F = G * M * m / r^2;\n    \t//a = F/m\n    \t//v = v + a * dt;\n    \t//p = p + v * dt;\n        p += v * dt;\n        vec3 relP = p - cp; //黑洞相对原点的位置       \n        float r2 = dot(relP,relP);\n        vec3 a = GM/r2 * normalize(-relP); //加速度的方向朝向黑洞，为-relP\n        v += a * dt;        \n        float hit = HitTest(relP); //hit表示距物体的最小距离\n\t\thitbh = step(hit,0.);   \n        if(hitbh > 0.5)break;\n    }\n    col = GetBg(p)*(1.-hitbh);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 125, 147, 147, 191], [192, 192, 212, 212, 267], [268, 268, 325, 350, 1516]], "test": "untested"}
{"id": "wltSRN", "name": "Sine & Cosine on Grid Paper", "author": "Neebz", "description": "Learning how to display math functions with shaders.\n\nI'm very new to shaders so feedback is very welcome :)", "tags": ["grid", "sine", "graph", "cosine"], "likes": 4, "viewed": 77, "published": "Public", "date": "1580569616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define amplitude .5\n#define frequency 2.\n#define speed 2.\n\nvec3 DrawAxis(vec2 uv){\n    vec3 axis = vec3(0);   \n    \n    vec2 uvs = fract(uv * 10. * 5.);    \n    vec2 absUv = abs(uvs);\n    if (absUv.x < .1 || absUv.x > .9) axis = vec3(.1);\n    if (absUv.y < .1 || absUv.y > .9) axis = vec3(.1);\n    \n    vec2 uvm = fract(uv * 5.);\n    absUv = abs(uvm);\n    if (absUv.x < .01 || absUv.x > .99) axis = vec3(.5);\n    if (absUv.y < .01 || absUv.y > .99) axis = vec3(.5);\n    \n    if (abs(uv.x) < .005) axis = vec3(1.);\n    if (abs(uv.y) < .005) axis = vec3(1.);\n   \n    return axis;\n}\n\nfloat Line(float n, float pw, float a){\n    return smoothstep(n - pw/iResolution.x, n, a) - smoothstep(n, n  + pw/iResolution.x, a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy) - .5;\n    uv.x *= iResolution.x/iResolution.y;    \n    \n    vec3 col = vec3(.8,.95,1.);\n    col += DrawAxis(uv);\n    col *= .5;\n    \n    float y = uv.x;  \n    \n    float sine = sin(y * PI * frequency + iTime * speed) * amplitude;\n    float sinCurve = Line(sine, 5., uv.y);\n    \n    float cosine = cos(y * PI * frequency + iTime * speed) * amplitude;\n    float cosCurve = Line(cosine, 5., uv.y );\n    \n    col += vec3(sinCurve * .2, sinCurve * .35, sinCurve * .5);\n    col += vec3(cosCurve * .5, cosCurve * .15, cosCurve * .2); \n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 108, 108, 605], [607, 607, 646, 646, 741], [744, 744, 801, 801, 1409]], "test": "untested"}
{"id": "wltSRS", "name": "大龙猫 - Quicky#006 - Cineshader", "author": "totetmatt", "description": "Cineshader version\nhttps://cineshader.com/view/wltSRS", "tags": ["cineshader"], "likes": 6, "viewed": 9165, "published": "Public API", "date": "1581244325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// /!\\ move everything fast and flashy #define time tan(iTime*16.)\n#define time iTime\n#define clock time/5.\n#define ttime floor(time) + pow(fract(time),sin(iTime*1.333)*.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    vec2 uuv = uv;\n    uv.x += tan(abs(uv.x)*5.);\n    \n    float d = fract(10.*uv.x+clock);\n    d = smoothstep(0.2,0.10,d);\n    \n    float p = tan(uv.x+time);\n    vec3 col = mix(vec3(0.1,0.1,0.1),vec3(p*0.1+step(.1,abs(cos(clock*2.))*uv.x),p*0.9,0.1+step(1.,sin(clock)*sin(clock)*abs(uv.x))),d);\n    \n    fragColor = vec4(\n        col,\n        d*sin(ttime+1.-floor(length(floor(uuv*10.)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 174, 231, 231, 691]], "test": "untested"}
{"id": "WltSRX", "name": "Cloud Impression", "author": "ruojake", "description": "Playing around with domain warping. A blending oversight(?) resulted in a super fluid painterly look which pleases me greatly.", "tags": ["fbm", "warping", "artistic"], "likes": 10, "viewed": 207, "published": "Public", "date": "1581457639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (C) Kristian Sivonen 2020\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(11.21, 13.0092)) * (p.x * .87 - p.y + 31.43)) * 233.1);\n}\n\nconst vec2 o = vec2(1.,0.);\n\nfloat noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = smoothstep(0., 1., p - pi);\n    return mix(\n        mix(hash(pi), \t   hash(pi+o), pf.x), \n        mix(hash(pi+o.yx), hash(pi+o.xx), pf.x), \n        pf.y);\n}\n\nfloat fbm(vec2 p)\n{\n\treturn (noise(p) * 8. + noise(p * 2.) * 4. + noise(p * 4.) * 2. + noise(p * 8.) * .5) / 7.25 - 1.;\n}\n\nvec2 fbm2(vec2 p)\n{\n    float a = fbm(p) * 3.1415927;\n\treturn sin(vec2(a + 1.5707963, a)) * .4;\n}\n\nfloat h(vec2 p, float t)\n{\n\tfloat t0 = t * .01;\n    float t1 = t * -.025;\n    float t2 = t * .035;\n    return fbm(t0 + p - fbm2(t1 + p + fbm2(t2 + p)));\n}\n\nvec3 h3d(vec2 p, float t)\n{\n\treturn vec3(p * .25, smoothstep(-1., 1., h(p, t)));\n}\n\nconst vec3 lightDir = vec3(.44022545316, -.88045090632, -.176090181264);\nconst vec3 light = vec3(1., .95, .9);\nconst vec3 shade = vec3(.3, .325, .5);\n\nvec4 clouds(vec2 uv, float t, float a)\n{\n    vec3 p = h3d(uv, t);\n    float alpha = smoothstep(.4, .8, p.z - a);\n    vec2 eps = vec2(.01 + p.z * .2, 0.);\n    vec3 n = normalize(cross(h3d(uv + eps.yx, t) - p, h3d(uv + eps, t) - p));\n    float l = dot(n, lightDir);\n    return vec4(mix(shade, light, \n              smoothstep(-1., 1., l)),alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y * 3.;\n    \n    float t = iTime;\n    vec4 col = vec4(0.);\n    vec3 fog = vec3(.05, .2, .4);\n    for (float i = .0; i < 1. && col.w < 1.; i += .066)\n    {\n    \tuv += 10.;\n        vec4 c = clouds(uv * (1. + i * 5.) + iTime * .05 * (1. - i), t, .2 - sin(i * 3.1415927) * .2);\n        c.xyz = mix(c.xyz, fog, i * (2. - i));\n        col.xyz = mix(c.xyz, col.xyz, col.w);\n        col.w = clamp(c.w + col.w, 0., 1.);\n    }\n    col.xyz = mix(fog * .7, col.xyz, col.w);\n    col.w = 1.;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 50, 50, 141], [172, 172, 193, 193, 388], [390, 390, 409, 409, 511], [513, 513, 532, 532, 610], [612, 612, 638, 638, 766], [768, 768, 795, 795, 850], [1003, 1003, 1043, 1043, 1349], [1351, 1351, 1408, 1408, 1945]], "test": "untested"}
{"id": "WltSWB", "name": "Simiancraft Nebula v2", "author": "the_simian", "description": "Another test for the simiancraft.com backdrop but with the values greatly increased", "tags": ["test", "nebula"], "likes": 5, "viewed": 168, "published": "Public", "date": "1581628332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SIMIANCRAFT Deadlights V2 'Deadlights nebula'\n// backdrop animation for https://simiancraft.com/\n// Jesse Harlin, 2020\n// MIT lisence\n// Exactly like the last one but cranked way way up with changes to speed/glow etc.\n\n#define STARFIELD_LAYERS_COUNT 12.0\n\nfloat PI = 3.1415;\nfloat MIN_DIVIDE = 64.0;\nfloat MAX_DIVIDE = .01;\n\n\nmat2 Rotate(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c,-s, s, c); //this rotates the thing.\n}\n\nfloat Star(vec2 uv, float flaresize, float rotAngle, float randomN){\n\n\tfloat d = length(uv);\n\t//Star core\n\tfloat starcore = 0.05/d;\n\tuv *= Rotate(-2.0 * PI * rotAngle);\n\tfloat flareMax = 1.0;\n\n\t//flares\n\tfloat starflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n\tstarcore += starflares * flaresize;\n\tuv *= Rotate(PI * 0.25);\n\tstarflares = max(0.0, flareMax - abs(uv.x * uv.y * 3000.0));\n\tstarcore += starflares * 0.3 * flaresize;\n\t//light can't go forever, fade it concentrically.\n\tstarcore *= smoothstep(1.0, 0.05, d);\n\treturn starcore;\n}\n\nfloat PseudoRandomizer(vec2 p){\n\t//its not really random, but it looks random.\n\tp = fract(p*vec2(123.45, 345.67));\n\tp+= dot(p, p+45.32);\n\treturn (fract(p.x * p.y));\n}\n\nvec3 StarFieldLayer(vec2 uv, float rotAngle){\n\tvec3 col = vec3(0);\n\n\tvec2 gv = fract(uv) -0.5;\n\tvec2 id = floor(uv);\n\t\n\tfloat deltaTimeTwinkle = iTime * 0.35;\n\n\t// this loop goes over the neighbors and includes adjacent cell information.\n\t// so the stars are not 'clipped'.\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\tvec2 offset = vec2(x, y);\n\n\t\t\t//randomize X and Y\n\t\t\tfloat randomN = PseudoRandomizer(id + offset); // rand in 0 to 1.\n\t\t\tfloat randoX = randomN - 0.5;\n\t\t\tfloat randoY = fract(randomN * 45.0) - 0.5;\n\t\t\tvec2 randomPosition = gv - offset - vec2(randoX, randoY);\n\t\t\t//uses the fract 'trick' to get random sizes\n\t\t\tfloat size = fract(randomN * 1356.33);\n\t\t\tfloat flareSwitch = smoothstep(0.9, 1.0, size);\n\t\t\t//the actual star.\n\t\t\tfloat star = Star(randomPosition, flareSwitch, rotAngle, randomN);\n\t\t\t\n\t\t\t//fract trick random colors.\n\t\t\tfloat randomStarColorSeed = fract(randomN * 2150.0) * (3.0 * PI) * deltaTimeTwinkle;\n\t\t\tvec3 color = sin(vec3(0.7, 0.3, 0.9) * randomStarColorSeed);\n\n\t\t\t//compress\n\t\t\tcolor = color * (0.4 * sin(deltaTimeTwinkle)) + 0.6;\n\t\t\t//filter\n\t\t\tcolor = color * vec3(1, 0.1,  0.9 + size);\n\t\t\tfloat dimByDensity = 15.0/STARFIELD_LAYERS_COUNT;\n\t\t\tcol += star * size * color * dimByDensity;\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n\t//Normalize the mouse also\n\t//vec2 Mouser = (iMouse.xy - iResolution.xy * 0.5)/iResolution.y;\n\tfloat deltaTime = iTime * 0.01;\n\n\n\t//uv += uv + vec2(3.1, 0);\n    vec3 col = vec3(0.0);\n\t\n    float rotAngle = deltaTime * 0.09;\n\t\n\n\tfor(float i=0.0; i < 1.0; i += (1.0/STARFIELD_LAYERS_COUNT)){\n\t\tfloat layerDepth = fract(i + deltaTime);\n\t\tfloat layerScale = mix(MIN_DIVIDE,MAX_DIVIDE,layerDepth);\n\t\tfloat layerFader = layerDepth * smoothstep(0.1, 1.1, layerDepth);\n\t\tfloat layerOffset = i * (3430.00 + fract(i));\n\t\tmat2 layerRot = Rotate(rotAngle * i * -10.0);\n\t\tuv *= layerRot;\n\t\tvec2 starfieldUv = uv * layerScale + layerOffset;\n\t\tcol += StarFieldLayer(starfieldUv, rotAngle) * layerFader;\n\t}\n\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltSWB.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 329, 354, 354, 454], [456, 456, 524, 524, 1004], [1006, 1006, 1037, 1084, 1172], [1174, 1174, 1219, 1219, 2449], [2451, 2451, 2508, 2559, 3373]], "test": "untested"}
{"id": "wltSWH", "name": "The Nautilus, Part 3", "author": "dr2", "description": "From Jules Verne's \"20K Leagues Under The Seas\"; part 3 of a series.", "tags": ["submarine", "sciencefiction", "verne"], "likes": 9, "viewed": 276, "published": "Public API", "date": "1580894782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The Nautilus, Part 3\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// From Jules Verne's \"20K Leagues Under The Seas\"; part 3 of a series.\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, sbPos;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, cvSize, msAz, msEl;\nint idObj;\nbool bmOn;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idCav = 14;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPathCv (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrackPathCv (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = CaveDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + d * rd));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CaveDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 16; j ++) {\n    h = CaveDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nfloat WakeFac (vec3 p)\n{\n  vec2 tw;\n  tw = Rot2D (p.xz - sbPos.xz, sbRot);\n  tw.y += 6.5;\n  return (1. - smoothstep (0.3, 0.6, abs (tw.x) + 0.1 * tw.y)) * clamp (1. - 2. * tw.y, 0., 0.2) *\n     smoothstep (-5., -2., tw.y);\n}\n\nfloat NautDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  d = PrCylDf (p, 2.3, sbLen + 2.);\n  dMin = d;\n  if (d < 0.1) dMin = NautDf (p);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.02, h);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec2 LBeamDf (vec3 p)\n{\n  vec3 q;\n  float d, bz;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, 2.35);\n  q.yz = Rot2D (q.yz, -0.04 * pi);\n  q.xz = Rot2D (q.xz, 0.01 * pi);\n  bz = q.z / 20.;\n  d = length (q.xy) - 0.08 * (1. + 3. * bz);\n  d = 0.9 * max (d, - min (20. * (1. - bz), q.z));\n  return vec2 (d, bz);\n}\n\nvec2 LBeamRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 d2;\n  float dHit;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d2 = LBeamDf (ro + dHit * rd);\n    dHit += d2.x;\n    if (d2.x < 0.001 || dHit > dstFar) break;\n  }\n  return vec2 (dHit, d2.y);\n}\n\nvec3 LBeamNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = LBeamDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx))).x;\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 NautColN (vec3 p, inout vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p -= sbPos;\n  p.xz = Rot2D (p.xz, sbRot);\n  vn.xz = Rot2D (vn.xz, sbRot);\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.5, 0.4, 0.3, -1.);\n  }\n  if (col4.a >= 0.) {\n    vn = VaryNf (32. * p, vn, 0.5);\n    col4.rgb *= 0.5;\n  }\n  vn.xz = Rot2D (vn.xz, - sbRot);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;\n  vec2 lbDist;\n  float dstObj, dstObjO, dstCave, dstWat, sh, atten, wkFac, s;\n  bool waterRefl;\n  dstObj = ObjRay (ro, rd);\n  dstCave = CaveRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar)) {\n    dstObj = dstCave;\n    idObj = idCav;\n  }\n  sh = 1.;\n  atten = 1.;\n  if (bmOn) {\n    rob[0] = ro;\n    rdb[0] = rd;\n  }\n  roo = ro;\n  dstObjO = dstObj;\n  bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);\n  waterRefl = false;\n  if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {\n    dstWat = - ro.y / rd.y;\n    waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);\n  } else {\n    dstWat = dstFar;\n  }\n  if (waterRefl) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);\n    wkFac = WakeFac (row);\n    if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstCave = CaveRay (ro, rd);\n    if (dstCave < min (dstObj, dstFar)) {\n      dstObj = dstCave;\n      idObj = idCav;\n    }\n    if (bmOn) {\n      rob[1] = ro;\n      rdb[1] = rd;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    ltVec = roo + ltPos - ro;\n    s = length (ltVec);\n    atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));\n    ltVec /= s;\n    if (idObj == idCav) {\n      vn = CaveNf (ro);\n      col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),\n         smoothstep (0.5, 0.8, vn.y)), 0.5);\n      sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));\n      vn = VaryNf (ro, vn, 12.);\n    } else {\n      vn = ObjNf (ro);\n      col4 = NautColN (ro, vn);\n      sh = ObjSShadow (ro, ltVec);\n    }\n    if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n    else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n    col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;\n  } else col = bgCol;\n  if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);\n  if (waterRefl && wkFac > 0.) {\n    s = Fbm3 (16. * row);\n    col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));\n  }\n  if (bmOn) {\n    lbDist = LBeamRay (rob[0], rdb[0]);\n    if (lbDist.x < min (min (dstObjO, dstWat), dstFar))\n       col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));\n    if (waterRefl) {\n      lbDist = LBeamRay (rob[1], rdb[1]);\n      if (lbDist.x < min (min (dstObj, dstWat), dstFar))\n         col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid ExMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 col, ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, dVu;\n  uv = fCoord;\n  cvSize = 7.;\n  bmOn = true;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  t = 3. * tCur;\n  az = 0.;\n  el = 0.;\n  fpF = TrackPathCv (t + 0.1);\n  fpB = TrackPathCv (t - 0.1);\n  sbPos = 0.5 * (fpF + fpB);\n  sbPos.y = 0.09;\n  vd = fpF - fpB;\n  sbRot = atan (vd.x, vd.z);\n  az += (msAz > -999.) ? msAz : 0.;\n  el += (msEl > -999.) ? msEl : 0.;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  t += 20. * dVu;\n  fpF = TrackPathCv (t + 0.1 * sign (dVu));\n  fpB = TrackPathCv (t - 0.1 * sign (dVu));\n  ro = 0.5 * (fpF + fpB);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = sbPos - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  dstFar = 50. * cvSize;\n  zmFac = 1.4;\n  ltPos = vuMat * vec3 (0., 1., 1.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fCol = col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  msAz = -999.;\n  msEl = -999.;\n  if (mPtr.z > 0.) {\n    msAz = 2. * pi * mPtr.x;\n    msEl = 0.5 * pi * mPtr.y;\n  }\n  if (abs (uv.y) < 0.85) ExMain (col, uv);\n  else col = vec3 (0.05);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);\n  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (i.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltSWH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[128, 1282, 1310, 1310, 1409], [1411, 1411, 1434, 1434, 1695], [1697, 1697, 1731, 1731, 1936], [1938, 1938, 1971, 1971, 2162], [2164, 2164, 2186, 2186, 2442], [2444, 2444, 2482, 2482, 2728], [2730, 2730, 2754, 2754, 2954], [2956, 2956, 2979, 2979, 5860], [5862, 5862, 5884, 5884, 6044], [6046, 6046, 6079, 6079, 6262], [6264, 6264, 6285, 6285, 6540], [6542, 6542, 6579, 6579, 6820], [6822, 6822, 6845, 6845, 7181], [7183, 7183, 7217, 7217, 7439], [7441, 7441, 7464, 7464, 7723], [7725, 7725, 7764, 7764, 10423], [10425, 10425, 10460, 10460, 13175], [13177, 13177, 13222, 13222, 14216], [14218, 14218, 14274, 14274, 14747], [14749, 14749, 14782, 14782, 14871], [14873, 14873, 14919, 14919, 14966], [14968, 14968, 15001, 15001, 15028], [15030, 15030, 15072, 15072, 15123], [15125, 15125, 15184, 15184, 15315], [15317, 15317, 15370, 15370, 15431], [15433, 15433, 15479, 15479, 15536], [15538, 15538, 15560, 15560, 15598], [15600, 15600, 15636, 15636, 15842], [15844, 15844, 15889, 15889, 15992], [15994, 15994, 16051, 16051, 16134], [16136, 16136, 16166, 16166, 16279], [16313, 16313, 16337, 16337, 16390], [16392, 16392, 16416, 16416, 16546], [16548, 16548, 16572, 16572, 16635], [16637, 16637, 16661, 16661, 16881], [16883, 16883, 16908, 16908, 17094], [17096, 17096, 17121, 17121, 17346], [17348, 17348, 17373, 17373, 17694], [17696, 17696, 17721, 17721, 17867], [17869, 17869, 17891, 17891, 18045], [18047, 18047, 18068, 18068, 18223], [18225, 18225, 18246, 18246, 18401], [18403, 18403, 18432, 18432, 18644], [18646, 18646, 18685, 18685, 18870]], "test": "untested"}
{"id": "wltXDl", "name": "Portable CubeFace(Index/Coord)", "author": "Wunkolo", "description": "Something I made a while ago when implementing a solution to have reflection samples against a proprietary video format.\nThis is portable equivalent of AMD's `cubeFace(Index/Coord)AMD` functions.", "tags": ["reflection", "sphere", "cubemap", "environment"], "likes": 5, "viewed": 141, "published": "Public", "date": "1581980655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float OpUnion( float OperandA, float OperandB)\n{\n\treturn min( OperandA, OperandB );\n}\n\nfloat OpSUnion( float OperandA, float OperandB, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (OperandB-OperandA) / k, 0.0, 1.0 );\n    return mix( OperandB, OperandA, h ) - k * h * (1.0 - h);\n}\n\nfloat OpSubtract( float OperandA, float OperandB)\n{\n\treturn max( OperandA, -OperandB );\n}\n\nfloat OPIntersection( float OperandA, float OperandB)\n{\n\treturn max( OperandA, OperandB );\n}\n\nfloat Box( vec3 QueryPoint, vec3 Bounds )\n{\n\tvec3 d = abs(QueryPoint) - (Bounds / 2.0);\n\tfloat InsideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat OutsideDistance = length(max(d, 0.0));\n\treturn InsideDistance + OutsideDistance;\n}\n\nfloat Sphere( vec3 QueryPoint, float Radius )\n{\n\treturn length(QueryPoint) - Radius;\n}\n\nvec3 Translate( vec3 Translation, vec3 Point )\n{\n\treturn (mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\tvec4(-Translation, 1.0)\n\t) * vec4(Point,1.0)).xyz;\n}\n\nfloat QueryScene( vec3 QueryPoint, float Time )\n{\n\tfloat Distance = Sphere(\n\t\t(Translate( vec3(0.0,0.0,1.0),QueryPoint)).xyz,1.0\n\t);\n    Distance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(0.0,sin(iTime) * 2.0,1.0),QueryPoint),0.5),\n        0.1\n    );\n    Distance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(0.7,-0.7,0.25),QueryPoint),0.25),\n        0.1\n    );\n\tDistance = OpSUnion(\n        Distance,\n        Sphere(Translate(vec3(-1.1,0.3,1),QueryPoint),0.3),\n        0.4\n    );\n\treturn Distance;\n}\n\nconst int MaxSteps = 64;\nconst float EPSILON = 0.001;\nfloat MarchScene( vec3 Origin, vec3 Direction, float Time )\n{\n\tfloat Distance = 0.0;\n\tfor( int i = 0; i < MaxSteps; ++i )\n\t{\n\t\tfloat CurDistance = QueryScene(\n\t\t\tOrigin + Direction * Distance, Time\n\t\t);\n\t\tif( CurDistance < EPSILON ) // Hit\n\t\t{\n\t\t\treturn Distance;\n\t\t}\n\t\tDistance += CurDistance;\n\t}\n\treturn -1.0;\n}\n\n// Estimated gradient\nvec3 GradientScene( vec3 QueryPoint, float Time)\n{\n\tconst vec2 EPSILON3 = vec2(EPSILON,0);\n\treturn normalize(\n\t\tvec3(\n\t\t\tQueryScene( QueryPoint + EPSILON3.xyy, Time ) - QueryScene( QueryPoint - EPSILON3.xyy, Time ),\n\t\t\tQueryScene( QueryPoint + EPSILON3.yxy, Time ) - QueryScene( QueryPoint - EPSILON3.yxy, Time ),\n\t\t\tQueryScene( QueryPoint + EPSILON3.yyx, Time ) - QueryScene( QueryPoint - EPSILON3.yyx, Time )\n\t\t)\n\t);\n}\n\nmat4 LookAt(vec3 Eye, vec3 Center, vec3 Up)\n{\n\tvec3 f = normalize( Center - Eye );\n\tvec3 s = normalize( cross( f, Up) );\n\tvec3 u = cross( s, f );\n\treturn mat4(\n\t\tvec4(  s, 0.0 ),\n\t\tvec4(  u, 0.0 ),\n\t\tvec4( -f, 0.0 ),\n\t\tvec4( 0.0, 0.0, 0.0, 1.0)\n\t);\n}\n\nvec3 RayDirection(float FieldOfView, vec2 Size, vec2 FragCoord)\n{\n    vec2 XY = FragCoord - Size / 2.0;\n    float Z = Size.y / tan(radians(FieldOfView) / 2.0);\n    return normalize(vec3(XY, -Z));\n}\n\n// returns <FaceIndex, FaceUV.x, FaceUV.y>\nuvec3 CubeFaceIndex( vec3 Direction )\n{\n\tvec3 absDir = abs(Direction);\n\tfloat maxAxis = max( absDir.x, max( absDir.y, absDir.z ) );\n\n\t//////// Determine cubemap face index\n\t// the face with the largest magnetude selects the face\n\t// ( x, x, x ) x is \"1\" where the element is the max axis value\n\t// it is possible for multple of these values to be true\n\t// ex:\n\t//     (0.0,0.5,0.5) is (0,1,1)\n\t//     (0.5,0.5,0.5) is (1,1,1)\n\t//     (0.5,0.0,0.5) is (1,0,1)\n\t// but this gets fixed up later with a modulo\n\tbvec3 maxChecks = equal( absDir, vec3(maxAxis) );\n\n\t// Produces 0, 2, or 4\n\tuint FaceIndex = uint(\n\t\tdot(vec3(0.0,2.0,4.0), vec3(maxChecks))\n\t);\n\tFaceIndex = FaceIndex % 6u + ( (FaceIndex / 6u) * 4u );\n\t//    Used to fixup multiple-true-axis case ^\n\n\t// Increment face index, if direction is negative\n\t// Tips the index over to 1, 3, 5 if needed\n\t// Extracts sign bit and places it in the LSB\n\tFaceIndex |= floatBitsToUint(Direction[FaceIndex / 2u]) >> 31u;\n\n\t// Now that we have the face index, this is where things get\n\t// fast and \"weird looking\" using parallel SWAR methods that\n\t// propagate binary decision-making into fast bit-manipulation\n\t// (https://en.wikipedia.org/wiki/SWAR)\n\t//           Gray  | Bin                          | Gray & Bin\n\t// 0:        0b000 | 0b000 (  -z,  -y)            | 0b000\n\t// 1:        0b001 | 0b001 (   z,  -y) ( flip x ) | 0b001\n\t// 2:        0b011 | 0b010 (   x,   z)            | 0b010\n\t// 3:        0b010 | 0b011 (   x,  -z) ( flip y ) | 0b010\n\t// 4:        0b110 | 0b100 (   x,  -y)            | 0b100\n\t// 5:        0b111 | 0b101 (  -x,  -y) ( flip x ) | 0b101\n\t//   Use -z or x^  |    ^^ Flip on odd            |     ^ Flip X or Y\n\t//                 |    Use -y or z\n\n\tuint FaceIndexGray = FaceIndex ^ (FaceIndex >> 1u);\n\n\t// Determines which axis to sample from\n    //vec2 FaceUV = vec2(0.0, 0.0);\n\tvec2 FaceUV = vec2(\n        mix(-Direction.z, Direction.x, bool((FaceIndexGray >> 1) & 1u)),\n\t\tmix(-Direction.y, Direction.z, bool((FaceIndex     >> 1) & 1u))\n    );\n\n\t// Determines which axis to flip\n\tFaceUV[\n\t\t\t((FaceIndexGray & FaceIndex) >> 1) & 1u // Flip X or Y\n\t] *= vec2(1.0, -1.0)[FaceIndex & 1u];// Flip on odd\n\n\t// Map from [-1,1] to [0,1]\n\t// This is the UV within the face\n\tFaceUV =  FaceUV * (0.5 / maxAxis) + 0.5;\n    return uvec3(FaceIndex, floatBitsToUint(FaceUV));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 Eye = vec3( 7.0 * cos(iTime), 7.0 * sin(iTime), 3.0);\n    vec3 Center = vec3( 0.0,0.0, 1.0 );\n    mat4 CameraToWorld = LookAt(\n        Eye,\n        Center,\n        vec3( 0.0, 0.0, 1.0 )  // Up\n    );\n    vec3 Color = vec3(0.025);\n    vec3 ViewDir = RayDirection(45.0, iResolution.xy, gl_FragCoord.xy);\n\n    vec3 WorldDir = (\n        CameraToWorld * vec4( ViewDir , 0.0)\n    ).xyz;\n\n    float Distance = MarchScene(\n        Eye, WorldDir, iTime\n    );\n    \n    const vec3 CubeFaces[3] = vec3[3](\n        vec3( 1.00,  0.00,  0.00 ),\n        vec3( 0.00,  1.00,  0.00 ),\n        vec3( 0.00,  0.00,  1.00 )\n\t);\n    \n    if( Distance >= 0.0 )\n    {\n        vec3 WorldPoint = Eye + WorldDir * Distance;\n        vec3 WorldGradient = GradientScene( WorldPoint, iTime );\n        uvec3 CubemapLookup = CubeFaceIndex(WorldGradient);\n        vec3 CurColor = vec3(\n            uintBitsToFloat(CubemapLookup).yz, 1.0\n        );\n        CurColor = mix(CurColor, CubeFaces[CubemapLookup.x >> 1],pow(cos(iTime * 0.25),2.0));\n        Color = CurColor;\n    }\n    Color = pow( Color, vec3(0.4545));\n    fragColor = vec4( Color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 85], [87, 87, 146, 146, 279], [281, 281, 332, 332, 370], [372, 372, 427, 427, 464], [466, 466, 509, 509, 702], [704, 704, 751, 751, 790], [792, 792, 840, 840, 976], [978, 978, 1027, 1027, 1511], [1567, 1567, 1628, 1628, 1880], [1882, 1904, 1954, 1954, 2324], [2326, 2326, 2371, 2371, 2576], [2578, 2578, 2643, 2643, 2775], [2777, 2820, 2859, 2859, 5158], [5160, 5160, 5217, 5217, 6339]], "test": "untested"}
{"id": "WltXR7", "name": "Day 45 - Isometric", "author": "jeyko", "description": "Wrote an isometric engine.\nIf you would like to use it, you can fill up the sdMain() function with your code.\nThe sdIso() function is where the repetition magic happens, it's a heavy read.", "tags": ["isometric", "mdtmjvm"], "likes": 4, "viewed": 273, "published": "Public API", "date": "1580670666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define iTime 0.5*(iTime + 1.*pi/2.)\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\n\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\n\nfloat sdRuby(vec3 p, vec3 s){\n\tp = abs(p) - s*0.9;\n    float d = max(p.x, max(p.y, p.z));\n\t//p = abs(p);\n    //p.xy *= rot(0.125*pi);\n    d = max(d, dot(p.xz + s.xz*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.zy*0.5, normalize(vec2(1))));\n    //d = max(d, dot(p.yz + s.yz*0.5, normalize(vec2(1))));\n    \n    return d;\n\n\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    \n    \n    \n    //p.xz *= rot(0. + iTime);\n    \n    d = sdBox(p, vec3(0.51));\n    //p.zy *= rot(-0.2565*pi );\n    //p.xy *= rot(-0.25*pi);\n    \n    #define tau (2.*pi)\n    float T = 7.*iTime/tau;\n    \n    \n    \n    vec3 s = vec3(0.5 + sin(iTime)*0.7);\n    \n    if(mod(floor(iTime/tau), 2.) == 1.){\n        for(int i = 0; i < 4; i++){\n            p = abs(p);\n\n            p.xy  *= rot(1.5*pi + sin(iTime)*0. + idD.x*pi);\n            p.xz *= rot(0.99);\n            //p.x -= 0.02;\n        }\n    \ts = vec3(0.5 + sin(iTime)*0.35);\n    }\n    //p = abs(p);\n    \n    d = min(d, sdOcta(p, s, idD));\n    \n    //d = max(d, -sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    //d = min(d, sdOcta(p, vec3(0.4 + sin(iTime)*0.5), idD));\n    \n    \n    \n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    p.x += 0.5;\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    \n    d.x = min(d.x, sdIso(p, id));\n    \n    d.x *= 0.55;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 280 ;i++){\n    \td = map(p);\n        glow += exp(-d.x*6.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n        vec3 n =-getNormal(p);\n        n.g*=0.4;\n        \n    \tcol += 0.8 + n*0.5;\n    \t\n    } else {\n    \n    }\n    \n    \n    col += glow*0.02;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    \n    \n    col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltXR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 371, 371, 423], [426, 426, 459, 459, 546], [548, 548, 586, 586, 845], [847, 847, 876, 876, 1184], [1185, 1185, 1216, 1216, 1984], [1997, 1997, 2026, 2026, 3355], [3357, 3357, 3374, 3374, 3575], [3577, 3577, 3651, 3651, 3903], [3905, 3905, 3928, 3928, 4067], [4069, 4069, 4117, 4117, 4312], [4313, 4313, 4370, 4370, 4607], [4609, 4609, 4666, 4666, 5416]], "test": "untested"}
{"id": "wltXWM", "name": "DIZZY PLASTIC HAZARD", "author": "jes5199", "description": "XD", "tags": ["2d", "plasma", "hexagonal", "plastic"], "likes": 4, "viewed": 139, "published": "Public", "date": "1581113280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv;\n  \n    uv = (vec2(iResolution.x / 2.0, iResolution.y / 2.0) - fragCoord.xy) / (20.1);\n\n    float s = 1.0;\n\tfloat b = 2./3. * uv.y / s;\n\tfloat r = (sqrt(3.)/3. * uv.x - uv.y/3. ) / s;\n\tfloat g = -(sqrt(3.)/3. * uv.x + uv.y/3. ) / s;  \n    \n        \n    float v = 25.;\n    float st = 5.;\n    float t = 5.5;\n   \n    float triSize = 3.14159;\n    float tri = sign(mod(floor(r / triSize) + floor(g / triSize) + floor(b / triSize), 2.) * 2. - 1.) ;\n    \n    float value = cos(r + sin(iTime / 2.) * 3.14159) * cos(g + sin(iTime) * 3.14159) * cos(b + sin(iTime / 3.) * 3.14159) * tri * ((st) + t);\n    float color = sin(value) * 3.0;\n    \n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.5;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, med,1.0);\n    } else {\n      fragColor = vec4(min(0.5, med / 2.0), high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltXWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 939]], "test": "untested"}
{"id": "wlV3WK", "name": "2D8Circle", "author": "NY", "description": "a", "tags": ["2d"], "likes": 2, "viewed": 122, "published": "Public", "date": "1580791859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat heart(vec2 st)\n{\n    // 位置とか形の調整\n    st = (st - vec2(0., 0.)) * vec2(2.1, 2.8);\n\n    return pow(st.x, 2.) +\n              pow(st.y - sqrt(abs(st.x)), 2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float size = 0.01;\n     uv -= 0.5; \n    float circleDist = 0.;\n     float heratDist = 0.;\n\t\n    float dist = 0.;\n    for(float j = 0.; j < 5.;j++){\n        for(float i = 1.; i < 40.; i++){\n            vec2 pos = vec2(sin(iTime + i ) * cos(j),sin(2. * iTime +  i ))* cos(j) * 0.3 * sin(iTime);\n            circleDist = step(distance(pos, uv),size);\n            heratDist = step(heart(uv + pos),size);\n            dist += mix(heratDist, circleDist,sin(iTime ));\n        }\n    }\n   \n    uv = vec2(dist,dist);\n    uv.x = fract(uv . x * 0.3);\n\n    \n    // Time varying pixel color\n   vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= dist;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlV3WK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 88], [91, 91, 113, 145, 269], [272, 272, 329, 379, 1129]], "test": "untested"}
{"id": "WlVSDw", "name": "[wip] simple raymarching", "author": "takumifukasawa", "description": "[wip] simple raymarching", "tags": ["test"], "likes": 1, "viewed": 35, "published": "Public", "date": "1582853571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPS .0001\n#define NORMAL_EPS .0001\n\nconst float stopThreshold = .0001;\n\nfloat scene(vec3 p) {\n    return length(p) - 1.;\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy) - scene(p - e.xyy),\n            scene(p + e.yxy) - scene(p - e.yxy),\n            scene(p + e.yyx) - scene(p - e.yyx)\n        )\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(\n        cos(iTime) * 5.,\n        0.,\n        sin(iTime) * 5.\n    );\n    vec3 target = vec3(0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    for(int i = 0; i < 64; i++) {\n    \tdist = scene(ro + rd * depth);\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += dist;\n    }\n    \n    // no hit\n    if(dist >= stopThreshold) {\n    \tfragColor = vec4(vec3(0.), 1.);\n        return;\n    }\n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position);\n    \n    // directional lighting\n    vec3 lightPos = vec3(-1., 1., 1.);\n    float lambert = max(0., dot(normal, normalize(lightPos)));\n\tcolor += lambert * vec3(1.);    \n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 102, 102, 131], [133, 133, 162, 162, 323], [325, 325, 349, 349, 581], [583, 583, 638, 638, 1592]], "test": "untested"}
{"id": "WlVSR1", "name": "Marching of Boxes", "author": "nodo", "description": "Practice timeline control", "tags": ["raymarch"], "likes": 6, "viewed": 305, "published": "Public API", "date": "1582511972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nconst float pi = acos(-1.);\nfloat sum = 0.0;\nfloat modid;\n\n///parameter\nfloat ss;\nfloat distotion;\nfloat diff;\nfloat speed;\nfloat proliferation;\nfloat scanning;\nfloat ly;\nvec3 ro, target;\nfloat fov;\nfloat concentrationline;\nfloat waveintensity;\n///\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*pi/2.0 : atan(y, x);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeline(float time){\n    \n\tfloat t = 0.0;\n\n    speed = 50.0;\n\n    \n    t = tl(time,1.0,1.0);\n    ly = mix(0.0,50.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    diff = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    proliferation = mix(28.0,0.0,eio(t));\n    waveintensity = mix(0.0,10.0,eio(t));\n    \n    t = tl(time,0.5,4.0);\n    ro.x += sin(-2.0*pi*t)*70.0;\n    ro.z += sin(1.0*pi*t)*140.0;\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(1.0,3.0,eio(t));\n    concentrationline = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(fov,1.0,eio(t));\n    concentrationline = mix(concentrationline,0.0,eio(t));\n\n    t = tl(time,1.0,1.0);\n    diff = mix(diff,0.0,eio(t));\n\tproliferation = mix(proliferation,28.0,eio(t));\n\tly = mix(ly,0.0,eio(t));\n    waveintensity = mix(waveintensity,0.0,eio(t));\n\n\n   \n    \n    ro.z  += iTime*speed;\n    target = vec3(0.0,0.0,60.0+iTime*speed);\n}\n\n\n\nfloat map(vec3 p){\n\n    if(abs(p.z-iTime*speed-70.0) < 30.0 - proliferation && abs(p.x) < 30.0 - proliferation){\n        modid = floor(((p.x)/3.0))*floor(((p.z)/3.0));\n\t\tp.y -= 35.*diff - texture(iChannel0,vec2(modid/100.0)).r*70.0*diff;\n\t\tp.xz = mod(p.xz,3.0) - 1.5;\n    }  \n    \n    return sdBox(p,vec3(2.0));\n}\n\n//https://qiita.com/edo_m18/items/37d8773a5295bc6aba3d\nfloat hexDist(vec2 p)\n{\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    \n    return max(c, p.x);\n}\n\nvec4 hex2d(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - r * 0.5, r) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    vec2 id = gv - uv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    \n    return vec4(x, y, id);\n}\n\nfloat wallmap(vec3 p){   \n    p = -abs(p);\n    p.y += 250.5;\n    return sdPlane(p, vec4(0, 1, 0, 1));\n}\n\n\nvec4 tracewall(vec3 ro,vec3 rd){\n    vec3 rPos = ro;\n    float depth=0.0;\n    vec3 col = vec3(.0);\n    float d;\n    \n\tfor(int i = 0 ; i < 99;i++){\n        d = wallmap(rPos);\n        if(d < 0.001){\n            col = vec3(float(i)/9.0);\n            col = vec3(0.1-hex2d(rPos.xz*0.02).g);\n            col *= exp(col.r*5.0)*5.0;\n            \n            break;\n     \t} \n        \n        depth += d;\n        rPos = ro + rd * depth;\n    }\n    \n    \n    float time = iTime * 2.5;\n    float wavy = pow(sin(length(rPos.xz - target.xz)*0.004 - time), 5.0) + 0.1;\n    //waveintensity = 10.0;\n    wavy *= waveintensity;\n    \n    col = vec3(col *wavy)*vec3(0.0,0.6,0.3);\n    \n    return vec4(col,depth);\n }\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.01;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeline(mod(iTime,17.0));\n    \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    \n    mat3 c = camera(ro, target, 0.0);\n    vec3 rd = c * normalize(vec3(uv, fov));\n    \n\n    vec3 lightPos = target;\n    vec3 lightPos2 = target;\n    vec3 lightPos3 = target;\n    \n    \n    vec3 an = vec3(0.0,ly,0.0);\n    an.xy *= rot(iTime*2.0);\n\n    lightPos2 += an;\n    lightPos3 -= an;\n  \n\n    vec3 col = vec3(0.0);\n    vec3 rPos = ro;\n    float depth = 0.0;\n    float mat;\n    float l2min = 99.0;\n    float l3min = 99.0;\n\n    for(int i = 0 ; i < 225;i++){\n        mat = map(rPos);\n        \n        if(mat < 0.001){\n            col = vec3(1.0-float(i)/250.);\n            break;\n        }\n        \n        if(depth > 500.0){\n            depth = 400.0;\n            break;\n        }\n        \n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        depth += min(min((step(0.0,rd.x)-fract(rPos.x))/rd.x, (step(0.0,rd.z)-fract(rPos.z))/rd.z)+0.01,mat);\n        rPos = ro + rd * depth;\n        \n        l2min = min(l2min,length(lightPos2 - rPos)/3.5);\n        l3min = min(l3min,length(lightPos3 - rPos)/3.5);\n\n    }\n    \n    l2min *= step(0.5,l2min);\n    l3min *= step(0.5,l3min);\n\n    vec4 backcol = tracewall(ro,rd);\n    \n    vec3 n = getNormal(rPos);\n    vec3 r = normalize(reflect(rd,n));\n        \n    ///light1\n    vec3 lv = lightPos - rPos;\n    vec3 ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a = max(1.0-(length(lv)/20.5),0.0)*1.5;\n    float d = max(dot(ld,n),0.);\n    float s = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    ///light2\n    lv = lightPos2 - rPos;\n    ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a2 = max(1.0-(length(lv)/25.5),0.0)*3.5;\n    float d2 = max(dot(ld,n),0.);\n    float s2 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc2 = vec3(a2+d2+s2)*vec3(1.0,0.0,0.0);\n    \n    \n    ///light3\n    lv = lightPos3 - rPos;\n    ld = normalize(lv);\n\n    float a3 = max(1.0-(length(lv)/25.5),0.0)*1.5;\n    float d3 = max(dot(ld,n),0.);\n    float s3 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc3 = vec3(a3+d3+s3)*vec3(0.0,1.0,0.0);\n  \n    \n    \n    float _Threshold = 0.1;\n    vec3 glow = max(abs(dot(rd, n)-_Threshold), 0.0)*vec3(0.1,0.5,0.6);\n    vec3 grid = vec3(step(2.9,mod(rPos,3.0)));\n    float k = 10.;\n    vec3 gridd = max(grid.x,max(grid.y,grid.z))*vec3(0.1,0.5,0.8);\n        \n    col = vec3(d+s+a)+lc2+lc3;\n\n    col *= glow;\n    gridd *= exp(k*sin(length(rPos)))/exp(k);\n    col += 5.0*gridd;\n        \n    depth *= 10.0;\n    \n    vec3 bgc = vec3(0.0,0.3,0.3);\n    //bgc = vec3(1.0);\n    if(depth > 1000.){\n        col = vec3(bgc);\n    }\n    \n    \n    //https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\n    float f = exp2Fog(backcol.a, 0.0014);\n    //backcol.rgb = mix(vec3(0.2,0.5,0.8), backcol.rgb, f);\n    backcol.rgb = mix(bgc, backcol.rgb, f);\n\n\n    if(depth > backcol.a){\n        col = backcol.rgb;\n    }\n    //  col = backcol.rgb;\n    col += max((1.0 - l2min)*vec3(1.0,0.0,0.0),0.0);\n    col += max((1.0 - l3min)*vec3(0.0,0.0,1.0),0.0);\n\n    \n    //ネガポジ反転//\n    //col = vec3(1.0) - col;\n    \n    \n    // zoom line  http://sayachang-bot.hateblo.jp/entry/2019/02/09/200303    \n    float t = length(uv)*0.07 - 0.05;\n    \n    float rr = length(uv);\n    rr = 0.8 * rr - 0.8;\n\n    a = atan2(uv.y, uv.x);\n    a = abs(cos(70. * a) + sin(30. * a));\n\n    d = a - rr;\n    float nn = smoothstep(0.1, 0.4, clamp(d, 0.0, 1.0));\n    \n    col += max((.5 - nn)*t*concentrationline,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 274, 292, 292, 354], [356, 356, 393, 393, 446], [449, 449, 480, 480, 567], [569, 569, 600, 600, 634], [637, 637, 685, 685, 822], [824, 824, 844, 844, 978], [980, 980, 1006, 1006, 1882], [1886, 1886, 1904, 1904, 2199], [2201, 2256, 2279, 2279, 2380], [2382, 2382, 2403, 2403, 2699], [2701, 2701, 2723, 2723, 2804], [2807, 2807, 2839, 2839, 3500], [3503, 3503, 3526, 3526, 3789], [3791, 3791, 3830, 3830, 3886], [3888, 3888, 3930, 3930, 4120], [4122, 4122, 4179, 4179, 7757]], "test": "untested"}
{"id": "WlVSRm", "name": "test-dif-cubos", "author": "jorge2017a1", "description": "test-dif-cubos", "tags": ["testdifcubos"], "likes": 1, "viewed": 40, "published": "Public", "date": "1582426164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n//---------------------------------------------------\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n///-----------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n// Create infinite copies of an object -  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n\n    \nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 9);\n             \n         } \n     }\n\t\n    \n    \n    p.x = mod(p.x , 12.0);\n    p.z = mod(p.z , 11.0)+0.5;\n    \n    float  sd1= sdBox(  p-vec3(0,1.1,0.0), vec3(9.0,9.,7.0) );\n    float  sd2= sdBox(  p-vec3(0,0.5,0.0), vec3(12.0,9.5,12.0) );\n    float  sd3= sdBox(  p-vec3(0,0.0,0.0), vec3(12.0,0.5,12.0) );\n    \n   \n    float  d1= differenceSDF(sd2, sd1);\n    res= opU(res, vec2(d1,14));\n    res= opU(res, vec2(sd3,13));\n    res= opU(res, vec2(1.0,8));\n    \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n\n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 1.*iMouse.x/iResolution.x;\n  \n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    vec3 ro = vec3(5.+ 15.0*sin( iTime),15.5,20.+10.*cos(iTime));\n    \n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n   \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    float d = RayMarch(ro, rd);\n    \n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n   \n    float dif = GetLight(p);\n    mObj.dist =d;\n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj*1.25)/1.5;\n\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [784, 838, 860, 860, 2120], [2123, 2178, 2224, 2224, 2256], [2258, 2258, 2301, 2301, 2333], [2335, 2335, 2383, 2383, 2416], [2419, 2419, 2448, 2448, 2574], [2576, 2576, 2612, 2612, 2729], [2731, 2731, 2767, 2767, 2885], [2888, 2888, 2924, 2924, 3047], [3100, 3112, 3134, 3134, 3442], [3443, 3469, 3494, 3494, 3684], [3685, 3730, 3747, 3747, 3820], [3823, 3856, 3882, 3882, 4079], [4080, 4126, 4178, 4178, 4333], [4398, 4507, 4544, 4544, 4579], [4589, 4589, 4614, 4614, 5634], [5637, 5637, 5671, 5671, 6060], [6065, 6065, 6089, 6089, 6321], [6325, 6325, 6349, 6349, 6734], [6738, 6738, 6763, 6763, 6791], [6891, 6935, 6952, 6952, 7023], [7048, 7140, 7165, 7165, 7428], [7430, 7489, 7517, 7517, 9400], [9404, 9404, 9461, 9461, 10490]], "test": "untested"}
{"id": "WlVSWm", "name": "Ray March 5", "author": "baksej", "description": "Ray March 5", "tags": ["raymarch"], "likes": 7, "viewed": 107, "published": "Public", "date": "1582861174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, - p.x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y) {\n    float n = (v - a) / (b - a);\n    return x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\n\n\nfloat scene(vec3 pos) {\n    \n    vec3 i = floor(pos / 0.5);\n    \n    vec3 pos1 = pos;\n    pos1.xz = mod(pos1.xz, 0.5) - 0.25;\n    pos1.y += .1 + sin(iTime + random(i.xz) * 6.2) * .1;\n    float s1 = sphere(pos1, 0.05);\n    \n    vec3 pos1b = pos;\n    pos1b.xz = mod(pos1b.xz, 0.5) - 0.25;\n    pos1b.y += .1 + sin(iTime + random(i.xz) * 6.2) * .2;\n    pos1b.x +=  sin(iTime + random(i.xz+1.0) * 6.2) * .05;\n    pos1b.z +=  sin(iTime + random(i.xz+2.0) * 6.2) * .05;\n    float s1b = sphere(pos1b, 0.02);\n    \n    s1 = smin(s1, s1b, .15);\n    \n    \n    \n    vec3 pos2 = pos;\n    pos2.y += 300.0 + 0.1;\n    pos2.z -= 1.0;\n    float s2 = sphere(pos2, 300.0);\n    \n    return smin(s1, s2, 0.15);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    \n    return normalize(\n        vec3(\n            scene(pos - vec3(0.001, 0.0, 0.0)) - scene(pos + vec3(0.001, 0.0, 0.0)),\n            scene(pos - vec3(0.0, 0.001, 0.0)) - scene(pos + vec3(0.0, 0.001, 0.0)),\n            scene(pos - vec3(0.0, 0.0, 0.001)) - scene(pos + vec3(0.0, 0.0, 0.001))\n            \n        ));\n    }\n    \n    //https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    // these probably have pretty bad performance\n    // they are modified from iq's, but I made a lot of changes\n    // to explore how they work without worrying about speed\n\n    // float jshadow( in vec3 light, in vec3 pos)\n    // {\n        //     float dist = distance(light, pos);\n        //     vec3 dir = normalize(pos - light);\n        \n        //     for( float t=.1; t<dist-.01; )\n        //     {\n            //         float h = scene(light + dir*t);\n            //         if( h<0.001 )\n            //             return 0.0;\n            //         t += clamp(h, 0.01, 0.50);\n        //     }\n        //     return 1.0;\n    // }\n    \n    float jsoftshadow(in vec3 light, in vec3 pos, float w)\n    {\n        float dist = distance(light, pos);\n        vec3 dir = normalize(pos - light);\n        \n        float s = 1.0;\n        for(float t = 0.1; t < dist - 0.1; )\n        {\n            float h = scene(light + dir * t);\n            s = min(s, 0.5 + 0.5 * h / (w * t));\n            if (s < 0.0)break;\n            t += clamp(h, 0.01, 0.50);\n        }\n        s = max(s, 0.0);\n        \n        return s * s*(3.0 - 2.0 * s); // smoothstep\n    }\n    \n    vec3 lightOrigin = vec3(-0.3, 0.6, - 0.3);\n    \n    vec3 trace(vec3 camOrigin, vec3 dir, out float totalDist) {\n        const int maxSteps = 1024;\n        vec3 ray = camOrigin;\n        totalDist = 0.0;\n        \n        // hacky near plane clipping\n        totalDist += 0.1;\n        ray += totalDist * dir;\n        \n        for(int i = 0; i < maxSteps; i ++ ) {\n            float dist = scene(ray);\n            if (abs(dist) < 0.001) {\n                vec3 lightDir = normalize(ray - lightOrigin);\n                // this is not how falloff works!\n                float lightFalloff = 2.0 - pow(length(ray - lightOrigin) * 0.5, 2.0);\n                float diffuse = clamp(dot(lightDir, estimateNormal(ray)) * lightFalloff, 0.0, 1.0);\n                \n                float s = jsoftshadow(lightOrigin, ray, 0.02);\n                diffuse *= s;\n                \n                vec3 ambient = vec3(0.1, 0.1, 0.2);\n                return vec3(1.0, 0.8, 0.6) * diffuse + ambient;\n                \n            }\n            totalDist += dist;\n            ray += dist * dir;\n        }\n        \n        return vec3(0.0);\n    }\n    \n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    \n    {\n        lightOrigin = vec3(sin(iTime * 0.7), 0.5, cos(iTime * 0.7));\n        \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n        uv = uv * 2.0 - 1.0;\n        uv.y /= iResolution.x / iResolution.y;\n        \n        vec3 camOrigin = vec3(0.0, 0.5, - 3.0);\n        vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n        \n        \n        vec3 color = vec3(0.0);\n        float passes = 1.;\n        float blur = .00;\n        for (float pass = 0.; pass < passes; pass++){\n        \tcamOrigin.x += random(rayOrigin.xy + pass/passes) * blur;\n        \tcamOrigin.y += random(rayOrigin.xy + pass/passes - 1.0) * blur;\n        \n        \tvec3 dir = normalize(rayOrigin - camOrigin);\n        \n        \tpR(dir.yz, - 0.1);\n        \n        \tfloat dist;\n        \tvec3 c = trace(camOrigin, dir, dist);\n        \n        \tfloat fog = clamp(map(dist, 6.0, 7.0, 1.0, 0.0), 0.0, 1.0);\n        \tc = mix(vec3(0.0), c, fog);\n        \tcolor += c;\n        \n        }\n        \n        // Output to screen\n        \n        fragColor = vec4(color / passes, 1.0);\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 82], [84, 84, 123, 123, 226], [228, 228, 266, 266, 301], [302, 302, 325, 325, 401], [403, 403, 459, 459, 522], [524, 524, 548, 548, 573], [576, 576, 599, 599, 1265], [1267, 1267, 1298, 1298, 1624], [2052, 2350, 2410, 2410, 2850], [2912, 2912, 2971, 2971, 3979], [3989, 3989, 4053, 4053, 5161]], "test": "untested"}
{"id": "WlVXDz", "name": "GridCircs", "author": "Arseny", "description": "2d", "tags": ["2d"], "likes": 3, "viewed": 228, "published": "Public API", "date": "1582554073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\nfloat circDist(vec2 cent, float r, vec2 pxpos){\n    return length(cent - pxpos) - r;\n}\n\nvec3 makeLine(vec2 A, vec2 B){\n    vec3 ans;\n    ans.x = A.y - B.y;\n    ans.y = B.x - A.x;\n    ans.z = -(ans.x * A.x + ans.y * A.y);\n    return ans;\n}\n\nvec2 lineIntersection(vec3 A, vec3 B){\n    return \n        vec2(\n            (B.z * A.y - A.z * B.y) / (A.x * B.y - B.x * A.y), \n            (B.z * A.x - A.z * B.x) / -(A.x * B.y - B.x * A.y) \n        );\n}\n\nfloat lineDist(vec3 L, vec2 A){\n    return (L.x * A.x + L.y * A.y + L.z) / sqrt(L.x * L.x + L.y * L.y);\n}\n\nvec2 circCent(vec2 A, vec2 B, vec2 C){\n    float dst = lineDist(makeLine(A, B), C);\n    dst = floor(dst / 0.0001) * 0.0001;\n    if (abs(dst + 0.0001) < 0.001){\n        dst += 0.0001;\n        return (A + B) / 2. + normalize((B - A)) * rot(pi / 2.) * sign(dst) * 100.;\n    }\n    return lineIntersection(\n        makeLine((A + B) / 2., (A + B) / 2. + (B - A) * rot(pi / 2.)), \n        makeLine((C + B) / 2., (C + B) / 2. + (B - C) * rot(pi / 2.))\n    );\n}\n\nfloat circDist(vec2 A, vec2 B, vec2 C, vec2 pxpos){\n   \tvec2 cen = circCent(A, B, C);\n    return circDist(cen, length(A - cen), pxpos) * sign(lineDist(makeLine(A, B), C));\n}\n\nfloat rand(float x){\n    x += 0.0007;\n    x = floor(x / 0.001) * 0.001;\n    return fract(sin(x) * 43758.553);\n}\n\nfloat rand_func(float x, float seed){ // from 0 to 1\n    const float freq = 20.;\n    float block = floor(x * freq);\n    float A = rand(block + seed);\n    float B = rand(block + 1. + seed);\n    return mix(A, B, x * freq - block);\n}\n\nfloat thisrand(vec2 v, float seed){\n    return rand_func(rand_func(v.x, v.y), seed);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\n    // Time varying pixel color\n    col.xy = uv.xy;\n    float cellsz = 0.1;\n    vec2 gv = (fract(uv / cellsz) - 0.5) * 2.;\n    vec2 fv = floor(uv / cellsz);\n    col.xy = gv;\n    col.xy = vec2(0.);\n    if ((fv.x + fv.y) / 2. - floor((fv.x + fv.y) / 2.) < 0.01){\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\t\n                circDist(\n                    vec2(1., 1.), \n                    vec2(-num * nowsgn, num * nowsgn), \n                    vec2(-1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.b = 1.;\n        //col.rg = gv+1.;\n    } else {\n        float sgn = 1.;\n        float lastsgn = 1.;\n        vec2 lastcent = vec2(1., -1.);\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime)) < 2.){\n        if (thisrand(fv, floor(iTime)) < 0.5){\n            //cent = vec2(-1., 1.);\n            sgn = -1.;\n        }\n        //if (rand(fv.x) + rand(fv.y) + 2. * rand(floor(iTime - 1.)) < 2.){\n        if (thisrand(fv, floor(iTime - 1.)) < 0.5){\n            //cent = vec2(-1., 1.);\n            lastsgn = -1.;\n        }\n        float num = 2. * inversesqrt(2.) - 1.;\n        float nowsgn = mix(lastsgn, sgn, fract(iTime));\n        col.r = 1. - smoothstep(\n            -0.1,\n            0.1,\n           \t\n                circDist(\n                    vec2(-1., 1.), \n                    vec2(num * nowsgn, num * nowsgn), \n                    vec2(1., -1.),\n                    //vec2(1., -1.),\n                    //cent,\n                    //2.,\n                    gv\n                )\n            \n        );\n        float anothermul = (mod(fv.x, 2.) - 0.5) * 2.;\n        if (anothermul > 0.){\n            col.r = 1. - col.r;\n        }\n        //col.g = 1.;\n    }\n    /*if (length(uv) < 0.01){\n        col = vec3(1.);\n    }*/\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 119, 119, 158], [160, 160, 190, 190, 310], [312, 312, 350, 350, 517], [519, 519, 550, 550, 624], [626, 626, 664, 664, 1078], [1080, 1080, 1131, 1131, 1253], [1255, 1255, 1275, 1275, 1366], [1368, 1368, 1405, 1420, 1598], [1600, 1600, 1635, 1635, 1686], [1688, 1688, 1745, 1795, 4561]], "test": "untested"}
{"id": "wlVXzW", "name": "Turbulent Chaos", "author": "Randomi", "description": "12 lines of code, 12 cups of coffee", "tags": ["distortion", "turbulence", "flow", "assembly", "chaostheory", "assemblywinter", "fasteffect"], "likes": 4, "viewed": 195, "published": "Public", "date": "1582321290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Gotta go fast af\n    float time2k = iTime*2.0-5.0;\n    \n    //Normalize to the middle of the screen, -0.5 -> 0.5\n    vec2 uv = fragCoord/iResolution.xy-vec2(0.5);\n    \n    //Norm so that the primary distortions are round. Large effect on the shape of distortions\n    float norm = dot(uv,uv)*0.05-0.4; \n    \n    /*The amount of times the distortion patterns are calculated, higher detail = more detail(Wow!). \n\t>25 gives quickly a headache, the amount of detail could be compared to a fractal: the more detail\n    you compute for the swirlies, the deeper you could zoom to have a clear pattern. Also, time-variance \n    gives an interesting effect, for example 17 + int(round(x.*sin/cos(time2k))) */\n    int detail = 17;\n\n    /*Where the \"magic\" happens. A time varying vector, from which sin & cos components are subtracted or added\n    This creates the swirly effect they have with some math-fuckery\n    Varying these parameters changes the distortion completely*/\n    vec3 magic = sin(time2k*1.5*norm*vec3(0.2,0.29,0.33));\n    for(int i = 0; i < detail; i++){\n        //Playing around with these parameters has the biggest impact on the created distortions and their formation\n        //Especially changing the vector components changes to flow of waves\n     \tmagic += sin(magic.yzx-uv.yxy*norm*float(i)*float(i)-0.1);\n        magic += cos(magic.yxz-uv.xyx*norm*float(i)*float(i)+0.1);\n    }    \n    //Take the x-component of the vector. Other components also give interesting patterns, and they also have some weird symmetries\n    float value = magic.x*0.45;\n    \n    //Mainly for adding contrast\n    value -= smoothstep(0.5,0.5,norm*0.4)*1.2-0.6;\n    \n    //Choose the colors, time-based variance also adds an interesting effect here\n    fragColor = vec4(vec3(0.0,value/4.5,value/2.0),1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 80, 1863]], "test": "untested"}
{"id": "Wly3Dz", "name": "RayMarching 2 spheres 1 torus", "author": "GrisWoldDiablo", "description": "raymarching 2 spheres and a torus", "tags": ["raymarching"], "likes": 1, "viewed": 50, "published": "Public", "date": "1580853704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p){\n\tvec4 s = vec4(0.+sin(iTime),1,6,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    vec4 s2 = vec4(1,1,4.*sin(iTime)+4.,1);\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    vec4 s3 = vec4(-2,1,6,.5);\n    float sphereDist3 = length(p-s3.xyz)-s3.w;     \n    float planeDist = p.y;\n    float d = min(sphereDist, planeDist);\n    d = min(sphereDist2, d);\n    d = min(d, sphereDist2);\n    d = min(d, sphereDist3);\n    p.z -= 3.;\n    p.y -= abs(1. *sin(iTime) *.5);\n    \n    //p.y += 1.;\n    d = min(d,length(vec2(length(p.xz)-.5,p.y)) - .1);\n    d = min(d, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for(int i = 0; i<MAX_STEPS;i++){\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n\t\n\treturn dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec2 M){\n\tvec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n\n    float dif = clamp(dot(n, l),0.,1.);\n\tfloat d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    M.y *= cos(M.y);//2.;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.,1.,0);\n    ro.xy += M;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd * d;\n\n    float dif = GetLight(p, M);\n    vec3 n = GetNormal(p);\n    col.rb = n.rg;\n    col.r += dif;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wly3Dz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 671], [673, 673, 707, 707, 907], [909, 909, 932, 932, 1121], [1123, 1123, 1154, 1154, 1444], [1447, 1447, 1504, 1504, 1945]], "test": "untested"}
{"id": "wlySDm", "name": "Astral Projection (Modern)", "author": "vikitux", "description": "Just tune ", "tags": ["projection", "animationcpu"], "likes": 4, "viewed": 260, "published": "Public API", "date": "1582833939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/WtKSWD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2019 Created by Animation CPU Experiments https://twitter.com/animationcpu\n\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p,a,b);\nfloat m =smoothstep(0.04,0.007,distLine(p,a,b));\n\nfloat d2 = length(a-b);\n  m *= smoothstep(0.6- .1/(length(p)), .3 , d2)*.2 + smoothstep(.0122,.00121,abs(d2-.75)) ;//* (.25/length((p-a)+(p-b)));\n  return m;\n}\nfloat n21(vec2 p){\n  p = fract(p*vec2(123.213,853.4264));\n  p += dot(p,p+6.65);\n  return fract(p.x*p.y);\n\n}\nvec2 n22(vec2 p){\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n    vec2 n = n22(id+offset)*iTime;\n    return offset+sin(n)*.4;\n}\nmat2 r(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat layer(vec2 uv, out vec3 attr){\n\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    vec2 gridPos[9];\n    int ppos = 0;\n    for(int y = -1; y<=1; y++) {\n        for(int x = -1; x<=1; x++) {\n            gridPos[ppos++] = getPos(id,vec2(x,y));\n            \n           \n        }\n    }\n    attr = vec3(0.);\n    for(int i=0;i<9;i++){\n        float l0 = line(gv,gridPos[4],gridPos[i]);\n//        m+=line(gv,gridPos[4],gridPos[i]);\n        \n        vec2 jj = (gridPos[i] - gv)*12.;\n        float sparkle = 1./length(dot(jj,jj));\n        m+=sparkle*(sin(iTime+ fract(gridPos[i].x) *10.)*.5+.5);\n        m += l0;\n        attr.x = float(i)/8.*(l0*10.)*(gridPos[i].x-gridPos[i].y+1.);\n\n\n    }\n     m+=line(gv,gridPos[1],gridPos[3]);\n     m+=line(gv,gridPos[1],gridPos[5]);\n     m+=line(gv,gridPos[7],gridPos[3]);\n     m+=line(gv,gridPos[7],gridPos[5]);\n     return m ;\n}\n\n\n#define ttime floor(iTime*.5) + pow(fract(iTime*.5),.5)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) -.5;\n \n      \n     float m = 0.;\n      //uv*=exp(length(uv)*.2);\n      uv*=.75;\n      uv*=r(atan(uv.x,uv.y)*2.*1.5);\n      uv*=r(cos(length(uv)*3.1415));\n      uv*=r(-iTime*.1);\n      uv=-abs(uv);\n\n     uv*=2.;\n  \n      //uv.x+=-iTime*.0001;   \n      float t = iTime*.0025;\n    \n      vec3 col = vec3(0.);\n     for( float i=0.; i<1.; i+= (1./5.) ) {\n          float z = fract(i+t);\n  \n          float size = mix(8.+sin(i*3.1415*(sin(iTime)*.5+1.5)+ttime)*8.,2.,z);\n          float fade = smoothstep(.0,.4,z) * smoothstep(1.,.6,z);\n         uv*=r(t*sin(i*10.));\n\n          vec3 col1;\n\n          m += layer(uv*size+i*20., col1) * fade ;\n          \n          col1 = col1.xxx*pal( col1.x+iTime*0.1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n          vec3 base = mix(vec3(.75+sin(ttime+length(uv*4.))*.1,.2,.6),vec3(.1,.2,.6),vec3(sin(i*4.5)*.5+.5,0.+m*1.,i*2.));\n          col += vec3(m)*base;\n//          col += vec3(m)*base + col1*fade;//*base*0.1;\n          col += col1; //*base*fade*0.1;\n\n//          col.b=0.;\n//          col.g=0.;\n     }\n \n\n    //if(gv.x>.47 || gv.y >.47) col.r = 1.;\n    fragColor = vec4(col,1.0);\n\n//    fragColor.rgb = fragColor.bbr;\n//    fragColor.rgb = fragColor.rgb;\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySDm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 216, 256, 256, 374], [375, 375, 410, 410, 647], [648, 648, 666, 666, 755], [756, 756, 773, 773, 827], [829, 829, 864, 864, 930], [931, 931, 947, 947, 1006], [1008, 1008, 1076, 1076, 1119], [1121, 1121, 1157, 1157, 2010], [2069, 2069, 2124, 2124, 3475]], "test": "untested"}
{"id": "WlySzD", "name": "hypnotize and stuff", "author": "elijahlucian", "description": "can't you see?", "tags": ["no", "hyp", "tize"], "likes": 6, "viewed": 345, "published": "Public API", "date": "1582255614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tfloat t = iTime * 2.1;\n    vec2 uv = fragCoord/iResolution.y*2.;\n  float u=uv.x;\n  float v=uv.y;\n  \n  float l=length(uv-vec2(1.,1.));\n  float d=distance(sin(t+uv),vec2(sin(l*10.+sin(u)+t),cos(l*5.)));\n \n  float circles=sin(dot(sin(t)+10.,l*10.));\n  \n  float shape=circles-d;\n  \n  vec3 color=vec3(u,v,u*v+sin(t*3.)*.5+.5);\n  \n  vec3 col=vec3(shape+color*.6);\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlySzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 454]], "test": "untested"}
{"id": "wlyXDh", "name": "Simple Gear Monochromatic", "author": "Istalri", "description": "A simple gear shader. If you have any advice, feel free to comment. ", "tags": ["gears", "white", "gear", "shape", "black", "primitive", "student"], "likes": 5, "viewed": 258, "published": "Public", "date": "1582585582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//properties\nfloat sphereSize = 0.5;\nfloat innerRadius = 0.1;\nfloat gearCenterSize = 0.1;\nfloat theetSize = 0.2;\nfloat theetNumber = 10.0;\nfloat squareSize = 0.04;\nfloat speed = -1.0;\nfloat padding = 0.005;\nfloat backgroundIntensity = 0.1;\nfloat pi = 3.14159265359;\nfloat degToRad = 0.01745329251;\n\n// Make a rotation matrice from an angle in radians\nmat2x2 Rotation(float angle)\n{\n    mat2x2 rot = mat2x2(cos(angle), -sin(angle),\n                        sin(angle), cos(angle));\n    return rot;\n}\n\n//Create a square shape and center it in the center of the screen\nfloat Square(vec2 squareUV, vec2 offset, float sizeX, float sizeY, float rotation)\n{\n    float screenRatio = iResolution.x / iResolution.y;\n    mat2x2 rot = Rotation(rotation);\n    \n    squareUV -= vec2(screenRatio * 0.5,0.5);\n    squareUV = rot * squareUV;\n    squareUV += vec2(screenRatio * 0.5,0.5);\n    \n    squareUV -= offset;\n    squareUV = abs(squareUV - vec2(screenRatio *0.5,0.5));\n        \n    return smoothstep(sizeX + padding , sizeX, squareUV.x) * smoothstep(sizeY + padding , sizeY, squareUV.y);\n    //return clamp( min( sizeX - squareUV.x, sizeY - squareUV.y) / fwidth(squareUV.x) + 0.5, 0.0, 1.0);\n}\n\n//Create a sphere at the center of the screen\nfloat Sphere(float radius, vec2 sphericalUV)\n{\n    float sphere = length(sphericalUV);\n    return smoothstep(radius + padding,radius,sphere);\n}\n\n//Place a bunch of square around the center of the screen and orient them\nfloat Theet(float numberTheet, float offset, vec2 resizeUV, float squareSize)\n{\n    float square = 0.0;\n    for(int i = 0; i < int(numberTheet); i++)\n    {\n        float segment = 360.0 / numberTheet;\n        float rotation = segment * float(i);\n        rotation *= degToRad;\n        \n        square += Square(resizeUV, vec2(offset,0.0), squareSize, squareSize, rotation);\n    } \n    return square;\n}\n\n\nfloat Gear(vec2 uv, vec2 offset, float size, float speed, float numberTheet, float supportNumber, float theetSize, float timeOffset)\n{\n    float screenRatio = iResolution.x / iResolution.y;\n    \n    \n    //Make base UV  \n    uv *= size;\n    uv -= (size - 1.0) * 0.5;\n    \n    \n    vec2 sphericalUV = -1. + 2. * uv;        \n    vec2 resizeUV = uv;\n    resizeUV.x *= screenRatio;\n    sphericalUV.x *= screenRatio;\n    resizeUV -= offset * 0.5;\n\n    //Make uv Rotate\n    mat2x2 rot = Rotation((iTime + timeOffset) * speed);\n    resizeUV -= vec2(screenRatio * 0.5,0.5);\n    resizeUV = rot * resizeUV;\n    resizeUV += vec2(screenRatio * 0.5,0.5);\n    \n    sphericalUV -= offset;\n    \n    //Create two annulus, one for the exterior and one for the interior\n    float gearCenter = Sphere(gearCenterSize, sphericalUV);\n    float innerCircle = Sphere(sphereSize - innerRadius, sphericalUV);\n    float gearHole = Sphere(gearCenterSize * 0.5, sphericalUV);\n    float sphere = Sphere(sphereSize, sphericalUV);\n    sphere -= innerCircle;\n    sphere += gearCenter;\n    sphere -= gearHole * (supportNumber + 1.0) * 5.0;\n    \n    //Create Theets\n    float square = Theet(numberTheet, sphereSize * 0.5 + theetSize * 0.5, resizeUV, theetSize);\n    \n    //Add theets to the gear\n    float gear = square + sphere;\n    \n    //Add support line for the gear\n    float support = 0.0;\n    for(int i = 0; i < int(supportNumber); i++)\n    {\n        float segment = 180.0 / supportNumber;\n        support += Square(resizeUV, vec2(0.0,0.0), innerRadius * 0.2, sphereSize * 0.45, segment * float(i) * degToRad);\n    }\n    gear += support;    \n    \n    //Clamp the result between 0 and 1\n    gear = clamp(gear,0.0,1.0);\n    return gear;\n}\n\n\n//\n//Compute image\n//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Base UV\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float screenRatio = iResolution.x / iResolution.y;\n    \n    //Generate Gears and create a composition\n    //Composition 1\n    float gear = Gear(uv, vec2(0.0,0.0), 1.0, -1.0, theetNumber, 3.0, squareSize, 0.0);\n    //Composition 2\n    vec2 comp2Offset = vec2(1.3,-1.5);\n    float comp2Size = 1.6;\n    \n    gear += Gear(uv, vec2(0.0,0.0) + comp2Offset, 1.0 * comp2Size, -1.0, theetNumber, 1.0, squareSize, 0.0);\n    gear += Gear(uv, vec2(1.7,0.0) + comp2Offset * 2.0, 2.0 * comp2Size, 2.0, theetNumber * 0.5, 2.0, squareSize * 1.8, 0.0);\n    gear += Gear(uv, vec2(1.2,0.8) + comp2Offset, 1.0 * comp2Size, -1.0, theetNumber, 4.0, squareSize, 0.45);  \n    gear += Gear(uv, vec2(-1.7,0.0) + comp2Offset * 2.0, 2.0 * comp2Size, 2.0, theetNumber * 0.5, 2.0, squareSize * 1.8, 0.3); \n    \n    //Composition 3\n    vec2 comp3Offset = vec2(-2.5,1);\n    float comp3Size = 1.6;\n    \n    gear += Gear(uv, vec2(0.0,0.0) + comp3Offset, 1.0 * comp3Size, -1.0, theetNumber, 2.0, squareSize, 0.0);\n    gear += Gear(uv, vec2(-0.5,-1.66) + comp3Offset * 2.0, 2.0 * comp3Size, 2.0, theetNumber * 0.5, 3.0, squareSize * 2.0, 0.35);\n    gear += Gear(uv, vec2(1.45,0.95) + comp3Offset * 2.0, 2.0 * comp3Size, 2.0, theetNumber * 0.5, 1.0, squareSize * 2.0, 0.25);\n    gear += Gear(uv, vec2(2.65,0.95) + comp3Offset * 2.0, 2.0 * comp3Size, -2.0, theetNumber * 0.5, 4.0, squareSize * 2.0, 0.25);\n    \n    //Composition4\n    float background = 0.0;\n    int number = 4;\n    for(int i = 0; i < (number*number); i++)\n    {\n        vec2 comp4Offset = vec2(-0.55 + 2.2*float(i%number),0.55 + 2.2*float(i/number));\n        comp4Offset -= vec2(2.2*float(number-1),2.2*float(number-1))*0.5;\n        float comp4Size = 2.25;\n        \n        background += Gear(uv, vec2(0.0,0.0) + comp4Offset, 1.0 * comp4Size, -1.0, theetNumber, 1.0, squareSize, 0.0);\n        background += Gear(uv, vec2(0.0,-1.1) + comp4Offset, 1.0 * comp4Size, 1.0, theetNumber, 2.0, squareSize, 0.3);\n        background += Gear(uv, vec2(1.1,0.0) + comp4Offset, 1.0 * comp4Size, 1.0, theetNumber, 4.0, squareSize, 0.3);\n        background += Gear(uv, vec2(1.1,-1.1) + comp4Offset, 1.0 * comp4Size, -1.0, theetNumber, 3.0, squareSize, 0.0);\n    }\n    background = clamp(background, 0.0, 1.0);\n    \n    gear += background * backgroundIntensity;\n    gear = clamp(gear, 0.0, 1.0);\n    //Show Gear\n    fragColor = vec4(gear,gear,gear, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 351, 381, 381, 497], [499, 565, 649, 649, 1180], [1182, 1228, 1274, 1274, 1371], [1373, 1447, 1526, 1526, 1847], [1850, 1850, 1984, 1984, 3557], [3560, 3582, 3637, 3651, 6069]], "test": "untested"}
{"id": "wlyXWz", "name": "thebookofshaders-matrix", "author": "enigmawxy", "description": "matrix part for the book of shaders", "tags": ["color", "shader", "matrix"], "likes": 0, "viewed": 57, "published": "Public", "date": "1582521990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 0\n#define PI 3.14159265359\n\n// YUV to RGB matrix\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,\n                    1.0, -0.39465, -0.58060,\n                    1.0, 2.03211, 0.0);\n\n// RGB to YUV matrix\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722,\n                    -0.09991, -0.33609, 0.43600,\n                    0.615, -0.5586, -0.05639);\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat mycross(in vec2 _st, float _size){\n    return  box(_st, vec2(_size,_size/4.)) +\n            box(_st, vec2(_size/4.,_size));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *=iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    if(AA==0) {\n        // To move the cross we move the space\n    \tvec2 translate = vec2(cos(iTime),sin(iTime));\n    \tst += translate*0.25;\n\n    \t// Show the coordinates of the space on the background\n    \tcolor = vec3(st.x,st.y,.3);\n\n    \t// Add the shape on the foreground\n    \tcolor += vec3(mycross(st,0.3));\n    }\n    if(AA==1) {\n        // move space from the center to the vec2(0.0)\n    \tst -= vec2(0.5);\n    \t// rotate the space\n    \tst = rotate2d( sin(iTime)*PI ) * st;\n    \t// move it back to the original place\n    \tst += vec2(0.5);\n\n    \t// Show the coordinates of the space on the background\n    \t// color = vec3(st.x,st.y,0.0);\n\n    \t// Add the shape on the foreground\n    \tcolor += vec3(mycross(st,0.4));\n    }\n    if(AA==2) {\n        st -= vec2(0.5);\n        st = scale( vec2(sin(iTime)+1.0) ) * st;\n        st += vec2(0.5);\n\n        // Show the coordinates of the space on the background\n        color = vec3(st.x,st.y,0.0);\n\n        // Add the shape on the foreground\n        color += vec3(mycross(st,0.2));\n    }\n    \n    if(AA==3) {\n        // UV values goes from -1 to 1\n    \t// So we need to remap st (0.0 to 1.0)\n    \tst -= 0.5;  // becomes -0.5 to 0.5\n    \tst *= 2.0;  // becomes -1.0 to 1.0\n        \n    \t// we pass st as the y & z values of\n    \t// a three dimensional vector to be\n    \t// properly multiply by a 3x3 matrix\n    \tcolor = yuv2rgb * vec3(0.6, st.x, st.y);\n    }\n    \n    if(AA==4) {\n        // UV values goes from -1 to 1\n    \t// So we need to remap st (0.0 to 1.0)\n    \tst -= 0.5;  // becomes -0.5 to 0.5\n    \tst *= 2.0;  // becomes -1.0 to 1.0\n\n        st *= rotate2d(sin(iTime)*PI/3.);\n        \n    \t// we pass st as the y & z values of\n    \t// a three dimensional vector to be\n    \t// properly multiply by a 3x3 matrix\n    \tcolor = yuv2rgb * vec3(0.6, st.x, st.y);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 347, 371, 371, 434], [436, 436, 464, 464, 550], [552, 552, 590, 590, 857], [859, 859, 899, 899, 990], [992, 992, 1049, 1049, 3011]], "test": "untested"}
{"id": "WsXSDH", "name": "Cheeseburger V2", "author": "Xor", "description": "Version 2 of the [url=https://www.shadertoy.com/view/Wsf3D7]\"cheeseburger\" shader[/url]. This code is not designed to be readable, sorry!", "tags": ["cheese", "tomato", "plate", "cheeseburger", "burger", "lettuce"], "likes": 17, "viewed": 530, "published": "Public", "date": "1580928837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Cheeseburger V2\" by Xor (@XorDev)\n\n\tThis is a revision of my original \"Cheeseburger\" shader: https://www.shadertoy.com/view/Wsf3D7\n\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n\n//Anti-Aliasing level. Use 2, 3 or 4 for better quality.\n#define AA 1.\n\nvec3 dir = normalize(vec3(-4,1,3));\n\nfloat soft(float a, float b, float n)\n{\n \treturn log(exp(a*n)+exp(b*n))/n;   \n}\nvec3 hash(vec3 p)\n{\n \treturn fract(sin(p*mat3(45.32,32.42,-41.55,65.35,-43.42,51.55,45.32,29.82,-41.45))*vec3(142.83,253.36,188.64));\n}\nvec3 value(vec3 p)\n{\n    vec3 f = floor(p);\n    vec3 s = p-f;\n    s *= s*(3.-s-s);\n    const vec2 o = vec2(0,1);\n    \n    return mix(mix(mix(hash(f+o.xxx),hash(f+o.yxx),s.x),\n        \t\t   mix(hash(f+o.xyx),hash(f+o.yyx),s.x),s.y),\n               mix(mix(hash(f+o.xxy),hash(f+o.yxy),s.x),\n                   mix(hash(f+o.xyy),hash(f+o.yyy),s.x),s.y),s.z);\n}\nfloat worley(vec3 p)\n{\n    float d = 1.;\n    for(int x = -1;x<=1;x++)\n    for(int y = -1;y<=1;y++)\n    for(int z = -1;z<=1;z++)\n    {\n    \tvec3 f = floor(p+vec3(x,y,z));\n        vec3 v = p-f-hash(f);\n        d = soft(d,dot(v,v),-6.);\n    }\n    return d;\n}\nfloat seed(vec3 p)\n{\n    float d = 1.;\n    for(int x = -1;x<=1;x++)\n    for(int y = -1;y<=1;y++)\n    {\n    \tvec3 f = floor(vec3(p.xy,0)+vec3(x,y,0));\n        vec3 h = hash(f)*vec3(1,1,63);\n        vec3 v = mat3(cos(h.z),sin(h.z),0,sin(h.z),-cos(h.z),0,0,0,1)*(p-f-h*.9)*vec3(1.7,1,0);\n        d = min(d,dot(v,v)+step(9.,length(f+.6))+step(p.z,2.));\n    }\n    return max(.05-d,0.);\n}\nfloat cheese(vec3 p)\n{\n    p.z += -.27+.03*p.x*p.x+.1*soft(dot(p.xy,p.xy)-3.5,0.,10.);\n \treturn (length(max(abs(p)-vec3(1.6,1.6,0),0.))-.02)*.8;\n}\nfloat model(vec3 p)\n{\n    float d = length(p)-2.5;\n    float m = soft(length(p.xy)-3.,pow(p.z-soft(d,0.,20.)*.7+1.1,2.)-.01,10.);\n    m = min(m,soft(p.z+1.2,-abs(mod(p.y+3.,4.)-2.),12.));\n    if (d<.1)\n    {\n    \tvec3 c = vec3(p.xy,max(p.z-.35,0.)*1.6);\n    \tfloat b = soft(length(c+.05*sin(c.yzx*2.))*.6-1.15,.41-abs(p.z+.15)-.02*c.x*c.x,40.);\n        m = min(m,soft(b,-1.-p.z,20.));\n    \tm = min(m,soft(length(p.xy+.1*sin(c.yx*2.))-2.1,pow(p.z-.03+.03*p.x*p.x,2.)-.04,12.));\n    \tm = min(m,soft(length(p)-1.9,abs(p.z+.4-.03*p.y*p.y)-.1,80.));\n    \tm = min(m,cheese(p));\n        vec3 r = value(p/dot(p,p)*vec3(14,14,1))-.5;\n        vec3 l = p+vec3(0,0,.46)+vec3(0,0,length(p.xy)-1.8)*.3*cos(r.x*5.-r.y*5.);\n    \tm = min(m,soft(length(l)-2.1-.4*r.z,abs(l.z)-.02,28.)*.8);\n        \n        float s = .2*seed(p*5.);\n        return m-s;\n    }\n\treturn min(d,m);\n}\nfloat bump(vec3 p)\n{\n    float b = .007*max(1.-1.5*abs(p.z),0.)*worley(p*18.);\n          b += .001*(worley(p*30.)+.5*worley(p*70.))*step(-.99,p.z-max(length(p.xy)-2.,0.));\n \treturn model(p)+b*step(.01,cheese(p));\n}\nvec3 normal(vec3 p)\n{\n\tvec3 n = vec3(-1,1,0)*.001;\n    return normalize(bump(p+n.xyy)*n.xyy+bump(p+n.yxy)*n.yxy+bump(p+n.yyx)*n.yyx+bump(p+n.xxx)*n.xxx);\n}\n\nfloat light(vec3 p,vec3 n)\n{\n    float d = pow(2.-1.*dot(n,dir),-1.);\n    d /= (1.-min(dot(dir,p),0.)*exp(.6-length(cross(dir,p))));\n    \n    float a = .5+.5*model(p+n*.05)/.05;\n    a *= .6+.4*model(p+n*.1)/.1;\n    a *= .7+.3*model(p+n*.2)/.2;\n    return  d*a;\n}\nvec3 Tex(vec3 p,vec3 r)\n{\n    vec3 Rad = value(p/dot(p,p)*vec3(14,14,.2))-.5;\n    vec3 l = p+vec3(0,0,.46)+vec3(0,0,length(p.xy)-1.8)*.3*cos(Rad.x*5.-Rad.y*5.);\n   \n    float t = max(length(p)-1.9,abs(p.z+.4-.03*p.y*p.y)-.1);\n    \n    vec3 n = normal(p);\n    float w = worley(p*11.)*(.05+.95*smoothstep(.7,.4,abs(p.z+.04)))*(abs(n.z)*.7+.3);\n    \n \tfloat m = abs(p.z-.03+.03*p.x*p.x)-.3;\n    float d = light(p,n);\n    float s = max(dot(reflect(r,n),dir),0.);\n    float f = length(p.xy);\n    \n    vec3 b = vec3(1,.635,.32)+.8*smoothstep(.9,.4,abs(p.z+.1)+.4*w)+.4*s*s+vec3(.7+.3*s*s*s)*seed(p*5.)/.1;\n    vec3 c = mix(b,vec3(.7,.4,.2)-.6*w+.6*s*s*s,step(m,-.08));\n    c = mix(c,vec3(.5,.8,.2)-.4*w+.6*s,step(abs(l.z),.04));\n    c = mix(c,vec3(1,.6,.1)+.6*s*s,step(cheese(p),.002));\n    c = mix(c,vec3(1,.2,.1)+s*s,step(t,.001));\n    c = mix(c,vec3(1.5+.3*smoothstep(.03,.04,abs(f-2.6)))+s*s*s*s,step(p.z-max(f-2.,0.),-.99));\n    c = mix(c,pow(texture(iChannel0,p.xy/3.).rgb,vec3(1,.9,1.2))*.7+.1,step(p.z,-1.18));\n    \n    return c*d;\n}\nvoid mainImage( out vec4 Color, in vec2 Coord)\n{\n    vec2 a = vec2(iTime*.1,.2*cos(iTime*.1)+1.8);\n    vec3 x = vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y)),\n         y = normalize(cross(x,vec3(0,0,-1))),\n    \t z = normalize(cross(x,y));\n    \n    mat3 m = mat3(x,y,z);\n    \n    vec3 c = vec3(0);\n    \n    for(float i = 0.;i<AA;i++)\n    for(float j = 0.;j<AA;j++)\n    {\n        vec4 p = vec4(m*vec3(-6,0,2.*cos(a.y)+.2),0);\n        vec3 r = m*vec3(1,(vec2(i,j)/AA+Coord-.5*iResolution.xy)/iResolution.y);\n        for(int I = 0;I<800;I++)\n        {\n            float s = model(p.xyz);\n            p += vec4(r,1)*s;\n            if ((p.w>20.) || (s<.001)) break;\n        }\n    \tc += mix(Tex(p.xyz,r),vec3(.9)+.1*dot(dir,r),smoothstep(.5,1.,length(p.xyz)/10.));\n    }\n    Color = vec4(c/AA/AA,1);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXSDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[228, 337, 376, 376, 416], [417, 417, 436, 436, 552], [553, 553, 573, 573, 909], [910, 910, 932, 932, 1165], [1166, 1166, 1186, 1186, 1548], [1549, 1549, 1571, 1571, 1695], [1696, 1696, 1717, 1717, 2555], [2556, 2556, 2576, 2576, 2770], [2771, 2771, 2792, 2792, 2926], [2928, 2928, 2956, 2956, 3190], [3191, 3191, 3216, 3216, 4226], [4227, 4227, 4275, 4275, 5026]], "test": "untested"}
{"id": "Wt3SDj", "name": "Gold Rings", "author": "kstyler", "description": "Gold rings, rotating around a sphere.", "tags": ["noise", "raymarch", "ring", "gold"], "likes": 3, "viewed": 219, "published": "Public API", "date": "1581662383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int mat = 0;\nfloat epsi = 0.001;\n\nfloat random(vec2 p){\n\n    vec3 p3  = fract(vec3(p.xyy) * .10031);\n    p3 += dot(p3, p3.yyx + 33.33);\n    return fract((p3.x + p3.y) );\n}\nfloat noise(vec2 uv){\n\n    vec2 id = floor(uv*8.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*8.));\n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n    \n}\n\nfloat octaves(vec2 uv,int octs){\n\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<octs+1;i++){\n        f+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n   \n    return f;\n}\nmat2 rot(float a){\n    return mat2(sin(a),-cos(a),cos(a),sin(a));\n}\nfloat sdSphere(vec3 p){\n    return length(p)-1.;\n}\nfloat sdRCyl( vec3 p, float ra, float rb, float h ){\n  \n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRing(vec3 p,float size,mat2 rotate){\n    p.zy*=rotate;\n    float or =  sdRCyl(p,size,0.,0.4);\n    float ir =  sdRCyl(p,size+0.1,0.,0.3);\n    return (max(-or,ir));\n}\nfloat sdRing2(vec3 p,float size,mat2 rotate){\n    p.xy*=rotate;\n    float or =  sdRCyl(p,size,0.,0.4);\n    float ir =  sdRCyl(p,size+0.1,0.,0.3);\n    return (max(-or,ir));\n}\n\nfloat map(vec3 p){\n\n    float sphere = sdSphere(p);\n   \n \n    \n    float ring = sdRing(p,0.85,rot(iTime));\n    float ring2 = sdRing2(p,0.65,rot(iTime));\n    float ring3 = sdRing(p,1.1,rot(-iTime));\n     //p.y+=(sin(length(p.xz*0.9)-iTime*3.)*.5);\n          float plane = p.y +3.5;\n    \n    float best = min(min(min(min(sphere,plane),ring),ring2),ring3);\n    if(best == sphere){\n        mat = 1;\n    } else if(best == plane){\n        mat = 2;\n    } else if(best == ring || best == ring2||best == ring3 ) {\n        mat = 3;\n    }else{mat = 4;}\n    return best;\n}\nvec3 normal(vec3 p){\n    vec2 e = vec2(epsi,0);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                        map(p+e.yxy)-map(p-e.yxy),\n                        map(p+e.yyx)-map(p-e.yyx)));\n}\n\nfloat tr(vec3 ro,vec3 rd){\n    float tot = 0.;\n    float dst = 0.;\n    for(int i = 0; i< 180; i++){\n        dst = map(ro+rd*tot);\n        tot+=dst;\n        if(dst <epsi||tot>180.)break;\n    }\n    \n    if(dst >epsi){\n        mat = 0;\n    }\n    return tot;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5* iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(2,-1.5,-9);\n    vec3 rd = normalize(vec3(uv,1));\n    ro.zy*=rot(2.1);\n    rd.zy*=rot(2.1);\n    ro.zx*=rot(iTime);\n    rd.zx*=rot(iTime);\n    vec3 color = vec3(1);\n    \n    for(int i =0;i<7;i++){\n        vec3 p = (ro+rd*tr(ro,rd));\n       \n      \n        if(mat == 0){\n        \n          \n            uv.x+=iTime/60.;\n            uv.x*=0.7;\n            color *= vec3(octaves(uv,9)+0.5);\n     \n            \n           \n        }if(mat == 1){\n         vec3 n = normal(p);\n           float fresnel = pow(1.-dot(- rd,n),5.);\n            color*= fresnel;\n               ro = p+1.;\n                rd = reflect(rd,n);\n        }\n        if(mat == 2){\n         vec3 n = normal(p);\n            color*= vec3(0.25,0.3,0.3);\n              ro = p+1.;\n            rd = reflect(rd,n);\n        }\n        if(mat ==3){\n         vec3 n = normal(p);\n            color *= vec3(0.9,0.7,0.3);\n               ro = p+1.;\n        rd = reflect(rd,n);\n        }\n \n    }\n\n   \n    fragColor = vec4((color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 55, 55, 171], [172, 172, 193, 193, 535], [537, 537, 569, 569, 728], [729, 729, 747, 747, 796], [797, 797, 820, 820, 847], [848, 848, 900, 900, 1023], [1024, 1024, 1068, 1068, 1196], [1197, 1197, 1242, 1242, 1370], [1372, 1372, 1390, 1390, 1932], [1933, 1933, 1953, 1953, 2139], [2141, 2141, 2167, 2167, 2397], [2400, 2400, 2454, 2454, 3520]], "test": "untested"}
{"id": "wt3SDr", "name": "Polar reflected circle", "author": "pixelplayer14", "description": "A circle of circles of cut-off circles", "tags": ["2d", "polar"], "likes": 1, "viewed": 149, "published": "Public", "date": "1580742461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14159;\n\nvec2 PolarToUv(vec2 polar)\n{\n    return vec2(polar.y*cos(polar.x),polar.y*sin(polar.x));\n}\n\nvec2 UvToPolar(vec2 uv)\n{\n    return vec2(atan(uv.y,uv.x),length(uv));\n}\n\n\nvec2 Rotate(vec2 uv, vec2 origin, float deg)\n{\n    deg = -radians(deg);\n    vec2 centered = uv-origin;\n    return origin + vec2(centered.x*cos(deg)-centered.y*sin(deg),\n                         centered.x*sin(deg)+centered.y*cos(deg));\n}\n\nfloat CircleSDF(vec2 uv, vec2 pos, float radius)\n{\n    return length(uv-pos)-radius;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n \tvec2 circlePos = vec2(0.3,0.1);\n    uv/=1.2;\n    uv = Rotate(uv,vec2(0),45.0*iTime);\n    \n    vec2 polar = UvToPolar(uv);\n    polar.x = mod(polar.x,PI/5.0); \n    uv = PolarToUv(polar);\n    float dist = floor(CircleSDF(uv,circlePos,0.3))+1.0;\n  \tint n = 0;\n    while( n <2)\n    {\n        if(dist<=0.0)\n        {\n            uv = (uv-circlePos)*5.0;\n            vec2 polar = UvToPolar(uv);\n            polar.x = mod(polar.x,PI/3.0); \n            uv = PolarToUv(polar);\n            dist = floor(CircleSDF(uv,vec2(0.3,0.1),0.2))+1.0;\n        }\n        n++;\n    }\n\n        \n    vec3 col = vec3(0.0,dist,0.0);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 49, 49, 111], [113, 113, 138, 138, 185], [188, 188, 234, 234, 425], [427, 427, 477, 477, 513], [516, 516, 573, 573, 1325]], "test": "untested"}
{"id": "Wt3SR7", "name": "LazyBalls", "author": "hanabi", "description": "Metaballs try...", "tags": ["metaballs"], "likes": 0, "viewed": 200, "published": "Public API", "date": "1580586516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ball {\n\tvec2 pos;\n    vec2 speed;\n    float s;\n    vec4 color;\n};\n\nvoid move(inout Ball box, float fFrame) {\n    float xPos = box.pos.x + box.speed.x * fFrame;\n    box.pos.x = mod(xPos, iResolution.x);\n    float tx = floor(mod(xPos / iResolution.x, 2.0));\n    box.pos.x = ((1. - tx) * box.pos.x) + (tx * (iResolution.x - box.pos.x));\n    \n    float yPos = box.pos.y + box.speed.y * fFrame;\n    box.pos.y = mod(yPos, iResolution.y);\n    float ty = floor(mod(yPos / iResolution.y, 2.0));\n    box.pos.y = ((1. - ty) * box.pos.y) + (ty * (iResolution.y - box.pos.y));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fFrame = float(iFrame) / 1.;\n    \n    Ball[] balls = Ball[](\n        Ball(\n            iResolution.xy / 2.,\n            vec2(-3., 2),\n            8.,\n            vec4(1., 0., 0., 1.)\n        ),\n        Ball(\n            iResolution.xy / 3.,\n            vec2(-2.3, -1.3 * iResolution.x / iResolution.y),\n            8.,\n            vec4(1., 0., 0., 1.)\n        ),\n        Ball(\n            iResolution.xy / 4.,\n            vec2(1.5, -1.9 * iResolution.y / iResolution.x),\n            8.,\n            vec4(1., 0., 0., 1.)\n        )\n    );\n    \n    fragColor = vec4(0., 0., 0., 1.0);\n    \n    for (int i = 0; i < balls.length(); i++) {\n        Ball ball = balls[i];\n    \tmove(ball, fFrame);\n        float d = distance(fragCoord, ball.pos);\n        float f = inversesqrt(d) * ball.s;\n        f = smoothstep(0.75, 1., f);\n        fragColor += f * ball.color;\n    }\n\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3SR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 115, 115, 572], [578, 578, 635, 635, 1531]], "test": "untested"}
{"id": "wt3SWj", "name": "shader_02", "author": "monodnb", "description": "i want it bw", "tags": ["cineshader"], "likes": 4, "viewed": 8986, "published": "Public API", "date": "1581685910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.876 + 1.284*(d2-d1)/k, 0.112, 2.616 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 0.480;\n\tfor (int i = 0; i < 16; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 1.073) - 1.020) * 1.152;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.024\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 0.368) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 0.0 );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"shader2\",\n\t\"description\": \"sure\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 160], [162, 162, 197, 197, 221], [224, 224, 243, 243, 587], [589, 589, 619, 619, 901], [903, 903, 960, 960, 1659]], "test": "untested"}
{"id": "wt3Sz2", "name": "Plane Stripe AA", "author": "spalmer", "description": "draws an analytically antialiased striped plane. WIP\ncan compare methods split-window using mouse click.", "tags": ["antialias", "plane", "stripe", "splitscreen"], "likes": 4, "viewed": 74, "published": "Public", "date": "1581342980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// derived from https://shadertoy.com/view/3tVGRz\n// see also https://shadertoy.com/view/wl3Sz2\n\n// a simple testbed for rendering an antialiased striped plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\n// probably should stay below .5 though, or may as well reverse the colors!\nconst float stripeThickness = .2; //.1; //.25; //.02; //\n\nconst vec3 Cfill = vec3(1.,1.,.9); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 Cstripe = vec3(0.,0.,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n   // btw fwidth totally works too\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n//    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// exp2 filters return 1 when should blur completely out\n// g is a positive distance to an edge to be smoothed\n// something wrong with one side though; sign/bias problem?\nfloat smoothGrid(float x, float s, float g, float w)\n{\n    return mix(x, s, exp2(-g / w));    \n}\n\nfloat smoothCheck(float x, float g, float w)\n{\n    return mix(x, .5, exp2(-g / w));    //smoothGrid(x, .5, g, w); //\n}\n\n// basically a 1D checkerboard because gridThickness is always .5\nfloat stripeThickUnfiltered(vec2 p)\n{\n    return float(int(floor(p.x))&1);\n}\n\n// it's simple because it uses simple tent function\n// and simple fwidth with relatively simple rational function inlined\nfloat stripeThickAASimple(vec2 p)\n{\n    vec2 f = fract(p); //p - floor(p); //\n    float x = stripeThickUnfiltered(p)\n    , g = min(f.x, 1.-f.x) * 2. //1.-2.* abs(f.x-.5) //\n    , w = fwidth(p.x) // + fwidth(p.y) //max(fwidth(p.x), fwidth(p.y)) //\n    , r = 2.*iResolution.y\n    , l = r*g / (1. + r*w); // can try different functions\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n// somewhat filtered thick stripes \nfloat stripeThickFade(vec2 p)\n{\n    float x = stripeThickUnfiltered(p);\n    vec2 f = fract(p);\n    float g = f.x * (1. - f.x) * 4.; // parabola\n    return smoothCheck(x, .125 * g, filterWidth1(p.x));\n}\n\n\nfloat stripeThinUnfiltered2(vec2 p)\n{\n    return step(.5-.5*stripeThickness, abs(fract(p.x)-.5));\n}\n\nfloat stripeThinUnfiltered(vec2 p)\n{\n    p -= .5*stripeThickness; // center\n    return step(1.-stripeThickness, fract(p.x));\n}\n\nfloat stripeAASimple(vec2 p)\n{\n    vec2 f = fract(p);\n    float g = min(f.x, 1.-f.x) * 2. - stripeThickness\n    , x = step(g, 0.) //stripeThinUnfiltered(p)\n    , w = fwidth(p.x)\n    , r = 2.*iResolution.y\n    , l = r*abs(g) / (1. + r*w) // can try different functions\n    // up close, should blend toward 0.5,\n    // but far away should blend toward stripeThickness!\n    , t = mix(.5, stripeThickness, min(w, 1.));\n    return mix(t, x, clamp(l, 0., 1.));\n}\n\nfloat stripeSmooth(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (stripeThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = stripeThickness;\n    return smoothstep(.5-w*s,.5+w, q.x);\n}\n\n// the half stripeThickness bias is fairly tricky; \n// honestly I shouldn't need to involve smoothstep at all here, hold on\n// meh, still not working worth a dern, maybe someday\nfloat stripeLinear(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (stripeThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = stripeThickness;\n    return clamp((q.x - .5-w*s) / (w*(s+1.)), 0., 1.);\n}\n\n// filtered thin stripes! finally something half-decent.  PITA!\nfloat stripeThinFade(vec2 p)\n{\n    float x = stripeThinUnfiltered(p);\n    vec2 f = fract(p);\n    float g = max(0., .5 - abs(f.x - .5) - .5 * stripeThickness);\n    //g = pow(g, 1. + 1.5 * abs(stripeThickness - .5));\n    float s = stripeThickness;\n    return smoothGrid(x, s, .125 * g, filterWidth1(p.x)); // lame, really; just fades out    \n}\n\n// FIXME all these using filterWidth2 are probably wrong or overly complex\n// since we really just want the pixel's rate of change over the\n// x dimension of the grid, perpendicular to the stripes.\n\nfloat stripeExp(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    float g = f.x;\n    g = max(0., g - .5*stripeThickness);\n    g = exp2(-fadePower*g);\n    float s = stripeThickness;\n    return mix(g, s, exp2(-.02 / filterWidth2(p)));    \n}\n\nfloat stripePow(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*stripeThickness);\n    f = pow(f, vec2(fadePower));\n    float g = f.x;\n    float s = stripeThickness;\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));    \n}\n\n// originally from https://shadertoy.com/view/WlVGDh\n// this is just not the way to do grids, blurs\n// the corners too much, but it sort of works:\nfloat stripeSine(vec2 p)\n{\n    p *= 3.1415927;\n    float g = sin(p.x); // grid texture\n    g *= g; g = max(0., 1. - g);\n    g = pow(g, 8./stripeThickness);\n    float s = stripeThickness;\n    g = mix(g, s, min(1., 1.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// similar but with parabola - still just wrong at corners\nfloat stripePara(vec2 p)\n{\n    vec2 q = fract(p);\n    q = max(vec2(0), .5 - stripeThickness*.5 - abs(.5 - q));\n    q *= 1.-q; q = 4.*q;\n    float g = 1.-q.x; //*q.y;\n    g = pow(g, 1./stripeThickness);\n    float s = stripeThickness;\n    g = mix(g, s, min(1., 4.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return stripeAASimple(uv);\n    return stripeSmooth(uv);\n    return stripePow(uv);\n    return stripePara(uv);\n    return stripeExp(uv);\n    return stripeSine(uv);\n    return stripeLinear(uv);\n///    return stripeThinFade(uv); // borked\n    return stripeThickAASimple(uv);\n    return stripeThickFade(uv);\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n    return stripeThinUnfiltered(uv);\n    return stripeThickUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. :\n    \trp.y / -rd.y;\n}\n\n\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y; // cs is a cosine,sine pair representing angle of rotation\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1, 0);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = p.x - iMouse.x;\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float stripes = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(Cfill, Cstripe, stripes); // colorize\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n\n// clever; I broke it anyway.\n// from a Dave Hoskins bresenham shader\n//\tvec2 g2 = step(1., mod(q, R/1./float(grid)));\n//\tg *= g2.x*g2.y;\n// aliased gridlines but otherwise nice.\n\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3Sz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 658, 687, 687, 765], [767, 767, 796, 796, 884], [888, 1086, 1116, 1116, 1205], [1207, 1378, 1432, 1432, 1474], [1476, 1476, 1522, 1522, 1594], [1596, 1662, 1699, 1699, 1738], [1740, 1862, 1897, 1897, 2237], [2239, 2275, 2306, 2306, 2476], [2479, 2479, 2516, 2516, 2578], [2580, 2580, 2616, 2616, 2706], [2708, 2708, 2738, 2738, 3164], [3166, 3166, 3194, 3194, 3402], [3404, 3582, 3610, 3610, 3832], [3834, 3898, 3928, 3928, 4239], [4241, 4440, 4465, 4465, 4724], [4726, 4726, 4751, 4751, 5025], [5027, 5174, 5200, 5200, 5450], [5452, 5511, 5537, 5537, 5833], [5835, 5874, 5897, 5897, 6206], [6207, 6245, 6268, 6268, 6345], [6376, 6389, 6426, 6426, 6500], [6503, 6503, 6536, 6536, 6686], [6688, 6688, 6727, 6727, 6782], [6785, 6785, 6809, 6809, 7010], [7014, 7014, 7053, 7076, 8113]], "test": "untested"}
{"id": "Wt3XDr", "name": "sha2er", "author": "xvart", "description": "was a checker board, not anymore again", "tags": ["cineshader"], "likes": 2, "viewed": 4500, "published": "Public API", "date": "1580709591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float w1 = 41.0;\n    float w2 = 23.0;\n    float speedMultiplier = 18.0f;\n    \n    vec3 col = vec3(0.0f,0.0f,0.0f);\n    float d = 0.0f;\n    int modular = 10;\n    float moveOffset = iTime/speedMultiplier;\n    \n\n    int uvY100 = int(round((uv.y + moveOffset) * 100.0));\n    //int aStepY100 =  uvY100 % modular;\n    int aStepY100 =  uvY100 % modular + int(round(iTime/100.0));\n    float aStepY = (float(aStepY100)/float(modular - 1));\n    float dStepY = round(aStepY);\n\n    \n    int uvX100 = int(round((uv.x + moveOffset) * 100.0));\n    int aStepX100 =  uvX100 % modular;\n    float aStepX = (float(aStepX100)/float(modular - 1));\n    float dStepX = round(aStepX);\n    \n    \n    float dStepXY = dStepX * dStepY;\n    \n    col = vec3(dStepXY,dStepXY,dStepXY);\n    \n    float blockHeight = dStepXY/2.0;\n    float xRipple = 0.5 * cos((uv.x + iTime/w1) * iTime/(w2*10.0));\n    //float yRipple = 0.5 * sin((uv.y + iTime/w2) * iTime/(w1*10.0));\n\tfloat yRipple = 0.5 * sin((iTime/(w1*200.0)));\n    d = (xRipple + yRipple) * blockHeight / 5.0;\n    \n\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"sha2er\",\n\t\"description\": \"was a checker board, not anymore again\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3XDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 1227]], "test": "untested"}
{"id": "wt3XW4", "name": "Super Hexagon (Bonus Stage)", "author": "cook1ee", "description": "Shader inspired by the game \"Super Hexagon\" (last stage). Hope you like it :)\nYou can control the arrow with your mouse.", "tags": ["game", "superhexagon"], "likes": 3, "viewed": 315, "published": "Public API", "date": "1580924541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHAPE(N) cos(round(a / (pi * 2. / float(N))) * (pi * 2. / float(N)) - a) * dist\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535;\n    \n    float rot = mod(iTime, 5.) > 4.5 ? (pi * 4. * (mod(iTime, 5.) - 4.5)) : 0.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = 3. * 2. * (uv - vec2(.5, .5));\n    coord.x *= iResolution.x / iResolution.y;\n    float a = mod(atan(coord.y, coord.x) + rot, pi * 2.);\n    float dist = length(coord);\n\tfloat r = pi * 2. / float(6);\n    \n    vec3 col = vec3(0.);\n    \n    float ma = mod(atan(iMouse.y - iResolution.y / 2.,\n                       (iMouse.x - iResolution.x / 2.)), pi * 2.);\n    float pw = 0.1 - (dist - 1.5) * 0.75;\n    if(dist > 1.5 && dist < 1.65 && ma > a - pw / 2. && ma < a + pw / 2.)\n    {\n        col = vec3(1.);\n    }\n    \n    float cOff = 0.1 * sin(iTime * pi * 2.);\n    \n    for(int i = 0; i < 5; i++)\n    {\n        float spd = 3.;\n        float spawn_spd = .6;\n    \tif(SHAPE(6) > .8 + spd - spd / spawn_spd * mod(iTime, spawn_spd) + float(i) * spd \n           && SHAPE(6) < 1. + spd - spd / spawn_spd * mod(iTime, spawn_spd) + float(i) * spd)\n    \t{\n            int num = i + int(floor(iTime / spawn_spd));\n            for(int j = 1; j <= 6; j++)\n            {\n                float sine = sin(float(num) * float(j) * 100.);\n                \n                int all_white = 1;\n                for(int s = 1; s <= 6; s++)\n            \t{\n                    if(sine < .5)\n                    {\n                    \tall_white = 0;\n                    }\n                }\n                \n                int seg = int(floor((a + r * 0.5) / r));\n                if(a < r / 2.) seg = 6;\n                int clear_seg = 1 + int(round(2.5 + 2.5 * sin(float(num) * 100.)));\n                if(seg == j && sine < .5)\n                {\n                    if(j != clear_seg && all_white == 0)\n                    {\n        \t\t\t\tcol = vec3(1.);\n                    }\n                }\n            }\n    \t}\n    }\n    if(SHAPE(6) > .8 + cOff && SHAPE(6) < 1. + cOff)\n    {\n        col = vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 146, 146, 2161]], "test": "untested"}
{"id": "wt3XWM", "name": "pink and purple wallpaper", "author": "jes5199", "description": ":D", "tags": ["2d", "moire"], "likes": 2, "viewed": 70, "published": "Public", "date": "1581036114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv;\n  \n    uv = vec2(0.5 * 3.14159, 0.5 * 3.14159) + (vec2(iResolution.x / 2.0, iResolution.y / 2.0) - fragCoord.xy) / (8.0);\n    \n    float value = sin(uv.x) * cos(uv.y) * iTime * 6.0;\n    float color = sin(value) * 3.0;\n\n    float low = abs(color);\n    float med = abs(color) - 1.0;\n    float high = abs(color) - 2.5;\n    if(color > 0.0) {\n\t  fragColor = vec4(med, high, med,1.0);\n    } else {\n      fragColor = vec4(min(0.5, med / 2.0), high, med,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 527]], "test": "untested"}
{"id": "Wt3Xz7", "name": "Simple Ellipse", "author": "hanabi", "description": "Ellipse", "tags": ["ellipse"], "likes": 1, "viewed": 230, "published": "Public API", "date": "1580591645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float fFrame = float(iFrame) / 100.;\n    vec2 center = vec2(iResolution) / 2.;\n    vec2 diff = vec2(cos(fFrame), sin(fFrame)) * iResolution.y / 2.2;\n    vec2 pos1 = center - diff;\n\tvec2 pos2 = center + diff;\n\n    fragColor = vec4(0, 0, 0, 1);\n    if ((distance(fragCoord, pos1) + distance(fragCoord, pos2)) < distance(pos1, pos2) + 20.)\n        fragColor.r = 1.;\n    \n    if (distance(fragCoord, pos1) < 3. || distance(fragCoord, pos2) < 3.)\n        fragColor.bg = vec2(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Xz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 538]], "test": "untested"}
{"id": "wt3XzB", "name": "Apollonian-II-v1", "author": "jorge2017a1", "description": "Apollonian-II-v1", "tags": ["apollonianiiv1"], "likes": 4, "viewed": 137, "published": "Public", "date": "1581198246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Referencia \n//iQ  y Shane\n//por Jorge F.p (jorge2017a1)\n    \n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map(vec3 p)\n{\n    \n    // Moving the scene itself forward, as opposed to the camera.\n    // IQ does it in one of his small examples.\n    p.z += iTime*0.5;\n    \n    // Loop counter and variables.\n    float i=0., s,k;\n        s = 1.0;\n\n\t// Repeat Apollonian distance field. It's just a few fractal related \n    // operations. Break up space, distort it, repeat, etc. More iterations\n    // would be nicer, but this function is called a hundred times, so I've\n    // used the minimum to give just enough intricate detail.\n    while(i++<6.) p *= k = 1.5/dot(p = mod(p - 1., 2.) - 1., p), s *= k;\n    \n   \n\t\t\n\t// Render numerous little spheres, spread out to fill in the \n    // repeat Apollonian lattice-like structure you see.\n    //\n    // Note the \".01\" at the end. Most people make do without it, but\n    // I like the tiny spheres to have a touch more volume, especially\n    // when using low iterations.\n   \n    \n    float a1, a2,a3;\n    \n    a1= dot(p.xy,p.xy);\n    a2= dot(p.yz,p.yz);\n    a3= dot(p.zx,p.zx);\n    \n      float d1 = sqrt( min( max( a1, a2 ), a3 ) ) - 0.012;\n    \n    \n    float d2 = abs(p.y);\n    float dmi = d2;\n    \n    float adr = 0.7*fract((0.5*p.y+0.5)*8.0);\n    \n    \n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/s, adr, k*0.5 );\n    \n    \n}\n\n\n\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        //vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        \n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        \n        \n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[192, 267, 285, 404, 1583], [1588, 1588, 1626, 1626, 1960], [1962, 1962, 2006, 2006, 2261], [2263, 2263, 2299, 2299, 2563], [2565, 2565, 2607, 2607, 2901], [2904, 2904, 2964, 2964, 3142], [3144, 3144, 3183, 3183, 3925], [3927, 3927, 3984, 3984, 5266], [5268, 5268, 5362, 5362, 5469]], "test": "untested"}
{"id": "wt3XzX", "name": "EditSDF fun", "author": "clark_eagling", "description": "okay", "tags": ["geometry"], "likes": 1, "viewed": 141, "published": "Public", "date": "1581426797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_23 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_24 = vec4(sdBox(pMod((mat4(1.2150225639343262,-1.0912714004516602,0.0,0.0,1.0912714004516602,1.2150225639343262,0.0,0.0,0.0,0.0,1.6331419944763184,0.0,0.0,0.0,-0.13284632563591003,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec4(0.2,0.4,0.8,0.1)) * 0.6123165844274281, vec3(0.5,0.5,1.0));\nvec4 tmpComb_29 = opUnionStairs(tmpPrim_23, tmpPrim_24, vec2(0.3,3.0));\nvec4 tmpPrim_25 = vec4(sdSphere(pMod((mat4(0.43648678064346313,0.0,0.0,0.0,0.0,0.43648678064346313,0.0,0.0,0.0,0.0,0.43648678064346313,0.0,-1.445962905883789,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(2.22,1.58,3.89)), 0.4) * 2.291020154953003, vec3(1.0,0.5,0.71));\nvec4 tmpComb_30 = tmpComb_29;\nvec4 tmpComb_31 = opUnionStairs(tmpComb_30, tmpPrim_25, vec2(0.68,5.44));\nreturn tmpComb_31;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_32 = opUnionStairs(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdBox(pMod((mat4(1.2150225639343262,-1.0912714004516602,0.0,0.0,1.0912714004516602,1.2150225639343262,0.0,0.0,0.0,0.0,1.6331419944763184,0.0,0.0,0.0,-0.13284632563591003,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec4(0.2,0.4,0.8,0.1)) * 0.6123165844274281, vec2(0.3,3.0));\nfloat tmpComb_33 = tmpComb_32;\nfloat tmpComb_34 = opUnionStairs(tmpComb_33, sdSphere(pMod((mat4(0.43648678064346313,0.0,0.0,0.0,0.0,0.43648678064346313,0.0,0.0,0.0,0.0,0.43648678064346313,0.0,-1.445962905883789,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(2.22,1.58,3.89)), 0.4) * 2.291020154953003, vec2(0.68,5.44));\nreturn tmpComb_34;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 32; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n", "image_inputs": [{"id": "4sX3zn", "previewfilepath": "/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 431, 504, 504, 634], [636, 636, 686, 686, 803], [805, 805, 855, 855, 972], [974, 974, 1002, 1002, 1046], [1048, 1091, 1125, 1125, 1170], [1172, 1172, 1223, 1223, 1249], [1251, 1251, 1298, 1298, 1399], [1401, 1401, 1450, 1450, 1506], [1508, 1508, 1560, 1560, 1667], [1669, 1669, 1723, 1723, 1783], [1834, 1843, 1894, 1894, 1916], [1917, 1917, 1965, 1965, 1997], [1999, 2008, 2059, 2059, 2081], [2082, 2082, 2130, 2130, 2162], [2164, 2171, 2220, 2220, 2243], [2244, 2244, 2290, 2403, 2443], [2531, 2571, 2645, 2645, 2724], [2725, 2725, 2796, 2796, 2858], [2860, 2875, 2949, 2949, 3039], [3040, 3040, 3111, 3111, 3173], [3175, 3188, 3260, 3260, 3295], [3296, 3296, 3365, 3365, 3417], [3492, 3509, 3585, 3585, 3635], [3636, 3636, 3709, 3709, 3773], [3775, 3792, 3868, 3868, 3918], [3919, 3919, 3992, 3992, 4056], [4058, 4073, 4147, 4147, 4184], [4185, 4185, 4256, 4256, 4310], [4382, 4399, 4476, 4476, 5195], [5196, 5196, 5269, 5269, 5334], [5336, 5351, 5421, 5421, 6111], [6112, 6112, 6183, 6183, 6235], [6237, 6254, 6330, 6330, 6366], [6367, 6367, 6440, 6440, 6504], [6506, 6588, 6663, 6663, 6789], [6790, 6790, 6862, 6862, 6926], [6928, 6944, 7019, 7019, 7058], [7059, 7059, 7131, 7131, 7198], [7200, 7214, 7287, 7287, 7325], [7326, 7326, 7396, 7396, 7451], [7453, 7496, 7544, 7544, 7806], [7808, 7845, 7889, 7889, 8918], [8920, 8920, 8960, 8960, 9770], [9776, 9776, 9826, 9826, 10124], [10126, 10126, 10180, 10180, 10474], [10476, 10476, 10512, 10512, 10784], [10786, 10786, 10838, 10838, 11103], [11105, 11105, 11154, 11154, 12291]], "test": "untested"}
{"id": "WtBXz1", "name": "tie-dye sunburst", "author": "hypothete", "description": "A simple tie-dye rainbow explosion", "tags": ["colors", "threshold", "tiedye", "sunburst"], "likes": 4, "viewed": 93, "published": "Public", "date": "1581062452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nvec3 palette(float l) {\n    float m = 2.0*PI * l;\n\treturn vec3(\n    \tcos(m),\n        cos(m + 2.0 * PI / 3.0),\n        cos(m + 4.0 * PI / 3.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    //uv += vec2(0.0, -1.5);\n    float th = atan(uv.y, uv.x);\n    float baseLength = length(uv);\n    vec2 wavy = vec2(\n        sin(th * 19.0 + iTime),\n        cos(th * 23.0 + iTime)\n    );\n    float waveScale = max(0.01, baseLength * 0.2);\n    wavy *= waveScale;\n    float f = length(uv + wavy);\n    f -= iTime / 10.0;\n    f = floor(8.0 * f)/8.0;\n\n    vec3 col = palette(f);\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 43, 43, 170], [172, 172, 229, 279, 813]], "test": "untested"}
{"id": "wtcSD8", "name": "Chaos Window", "author": "bignobody", "description": "I watched this Numberphile video on The Feigenbaum Constant ( https://www.youtube.com/watch?v=ETrYE4MdoLQ ) which talks about the Logistic Map equation. I wanted to try and make something pretty with it and this is what I came up with.", "tags": ["chaos", "logisticmap"], "likes": 4, "viewed": 93, "published": "Public", "date": "1580840687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat logmap(float l, float v)\n{\n\treturn l*v*((1.0)-v);   \n}\n\nfloat iterate(vec2 uv, float toff)\n{\n\tint maxI = 128;\n    int i = 0;\n    float le = 0.0;\n    float x = uv.x;\n    while (i < maxI)\n    {\n\t\tx = logmap( 2.5+sin(iTime+toff), x+uv.y);\n        le = x;\n        if (le < 0.0001)\n        {\n            return le;\n        }\n        i ++;\n    }\n    return le;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y;\n\tuv *= 2.6;\n    float off = (sin(iTime)*0.5+0.5)*0.1;\n\tvec3 col = vec3(pow(iterate(abs(uv),-off),4.0),pow(iterate(abs(uv),0.0),4.0),pow(iterate(abs(uv),off),4.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 33, 33, 61], [63, 63, 99, 99, 363], [365, 365, 422, 422, 678]], "test": "untested"}
{"id": "wtcSDf", "name": "Polygon - parametrization", "author": "iq", "description": "Space parametrization of a polygon, so you can map things to its exterior (say, other SDFs that you want to stamp). Note how the circles are barely distorted. See [url=https://www.shadertoy.com/playlist/XclfRs]more shape parametrizations[/url].", "tags": ["2d", "sdf", "parametrization", "coordinats"], "likes": 24, "viewed": 580, "published": "Public API", "date": "1581855637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Space parametrization of a polygon. It only works for convex\n// polygons, has some problems, and I still need to optimize it.\n//\n// It shows a global coordinate system were things stretch at the\n// sides BUT coodinates are global and physical, and also a local\n// coordinate system that is a regular grid full of circles).\n\n\n// List of all shape parametrizations: https://www.shadertoy.com/playlist/XclfRs\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x*b.y-a.y*b.x; }\n\n// https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2 p, vec2 verts[5], in float r ) \n{\n    const int num = verts.length();\n\tfloat s = 1.0;\n    float d = length(p-verts[0]);\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[i];\n        vec2 b = verts[(i+1)%num];\n       \n        vec2  pa = p-a;\n        vec2  ba = b-a;\n        float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        d = min(d,length( pa - ba*h ));\n        \n        bvec3 cond = bvec3( p.y>=a.y, p.y<b.y, ba.x*pa.y>ba.y*pa.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*d-r;\n}\n\nfloat angle( in vec2 a, in vec2 b )\n{\n    float n = atan(dot(a,b),cro(a,b));\n    if( n<0.0 )n+=6.283185;\n    return n;\n}\n    \n// x = local dist\n// y = local perimeter dist\n// z = total local perimeter\n// w = global distance (sdf)\nvec4 paPoly( in vec2 p, vec2 verts[5], float r, float band ) \n{\n    const int num = verts.length();\n\n    float od = sdPoly( p, verts, r );\n    \n    float ra = band*round(od/band);\n    \n    float d = length(p-verts[0])-ra;\n    float l = 0.0;\n    float t = 0.0;\n    for( int i=0; i<num; i++ )\n    {\n        vec2 a = verts[ i       ];\n        vec2 b = verts[(i+1)%num];\n        vec2 c = verts[(i+2)%num];\n            \n        vec2  pa1 = p-a; vec2 ba1 = b-a;\n        vec2  pa2 = p-b; vec2 ba2 = c-b;\n        float h1 = dot(pa1,ba1)/dot(ba1,ba1);\n        float h2 = dot(pa2,ba2)/dot(ba2,ba2);\n        float tmp = length( pa1 - ba1*clamp(h1,0.0,1.0) ) - (r+ra);\n        \n        float lba = length(ba1);\n        \n        if( tmp<d || ((i==num-1) && cro(ba1,pa1)>0.0) )\n        {\n            d = min(d,tmp);\n            if( h1>=0.0 && h1<=1.0 )\n            {\n                l = t + h1*lba;\n            }\n            else if( h1>1.0 && h2<0.0)\n            {\n                l = t+lba;\n                l += (r+ra)*angle(ba1,pa2);\n            }\n        }\n        t += lba+(r+ra)*angle(ba1,vec2(-ba2.y,ba2.x));\n    }\n    \n    return vec4(d,l,t,od);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    // animate polygon\n    float id = floor((iTime+0.1)/3.0);\n    vec2 kVerts[5];\n    for( int i=0; i<5; i++ )\n    {\n        kVerts[i] = 0.75*cos( float(i)*vec2(1.1,1.3) + vec2(0,2) + id*11.0 );\n    }\n    \n    const float bandSize = 0.15;\n    \n    // distance\n    vec4 b = paPoly(uv,kVerts,0.15,bandSize);\n\n    \n    \n    // base color\n    float d = b.w;\n    vec3 col = vec3(1.0,0.68,0.35) + vec3(-0.35,0.15,0.6)*step(d,0.0);\n    col *= 1.0 - 0.6*exp(-64.0*abs(d));\n    col *= 1.0-smoothstep(0.47,0.50,abs(fract(d/bandSize)-0.5));\n\tcol *= 0.9 + 0.2*smoothstep(0.26,0.24,abs(fract(0.5*d/bandSize+0.25)-0.5));\n    col += 1.0-smoothstep(0.0, 0.005, abs(d)-0.003);\n\n    \n    if( d>-bandSize*0.5 )\n    {\n   \n\tvec2 q = b.xy;\n    // optional - ensure periodicity, but break physicallity\n    q.y *= floor(b.z/bandSize)*(bandSize/b.z);\n    \n    // animate circles\n    q.y -= iTime*0.1;\n    \n    // draw circles\n    vec2 uv = fract(q/bandSize+0.5)-0.5;\n        \n    float l = length(uv);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,abs(l-0.35)-0.03);\n    col *= 0.1 + 0.9*smoothstep(0.0,0.02,l-0.10);\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSDf.jpg", "access": "shaders20k", "license": "mit", "functions": [[1406, 1489, 1514, 1514, 1533], [1534, 1534, 1567, 1567, 1593], [1595, 1636, 1691, 1691, 2194], [2196, 2196, 2233, 2233, 2316], [2322, 2426, 2489, 2489, 3567], [3574, 3574, 3631, 3667, 4861]], "test": "untested"}
{"id": "wtcSRX", "name": "Brick patterns + varying heights", "author": "mdv", "description": "Procedural brick surface,  patterned brick layout,  self-shadowing,  varying brick heights.\nModified code from my 'Brick Patterns' to support different height bricks on the surface,  rather than a single height.", "tags": ["procedural", "shadow", "pattern", "brick"], "likes": 3, "viewed": 113, "published": "Public", "date": "1582062546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------------------------------------------------------------------//  Brick wall with self-shadowing.\n//\n//  set BRICK_PATTERN   to select the pattern to compile  ( or add more patterns...)\n//\n//  The surface is seen as an array of tesselating rectangular cells. \n//  Each cell has a series of entries. Each entry represents a single brick (0,0)  to  shiftAndSizes[entry].zw  in the cell corner. \n//  shiftAndSizes[entry].xy  has the offset of the cell, for that entry  (cells effectively overlap per entry).\n//\n//  This enables the definition of different brick patterns.\n//  \n//  \n//  CELLSIZEU and CELLSIZEV are set for the pattern.  If we add to these, we space the cells out.\n//\n//  All code, feel free to use, abuse and improve...\n//\n//  'BRICK_PATTERN'   set this for a few simple patterns I set up - 0,1,2,3.  \n//--------------------------------------------------------------------------------------------------------------------------------------\n\n#define  USE_SHADOW \n#define  BRICK_PATTERN 3\n\n// LIGHT_DIRECTION:   y  is  negative as coming from ABOVE.\n//                    (  y close to 0  has numerical stability issues for shadow  (ie. light straight down).\n//                      producing sparkle on brick edges. )\n\nconst vec3   LIGHT_DIRECTION =  normalize(vec3(  0.917,  -0.62,  -0.4 ));  \nconst float  LIGHT_AMBIENT_INTENSITY = 0.5f;   \n\n // TODO:   have brick sizes per 'shiftAndSizes' entry.  More than one entry can have the same 'V' offset so should be easy\n //         to have mixed size bricks on one row.  This would make it possible to do herringbone etc.  \n \n#if BRICK_PATTERN == 0\t\t// regular brick\n\n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\n\tconst int maxLayers = 2;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,     BRICK_ULEN, BRICK_VLEN ),  \n      vec4( BRICK_ULEN + BRICK_UGAP, 0.5 * (BRICK_VLEN + BRICK_VGAP ),  BRICK_ULEN, BRICK_VLEN ) \n\t);\n    const float brickDepth[maxLayers] = float[]\n    (\n        0.013, 0.057\n    );\n  \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + 0.001;\n\t\n \n\tconst float  y1 = -0.47439;\n\n#elif BRICK_PATTERN == 1      //  short and long alternate\n  \n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\tconst float BRICK_VLEN_SHORT = 0.11 ;\n\n\n\tconst float dispIn = (BRICK_VGAP + BRICK_VLEN_SHORT) * 0.5 ; \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,   BRICK_ULEN, BRICK_VLEN_SHORT), \n      vec4( 0, BRICK_VLEN_SHORT + BRICK_VGAP,  BRICK_ULEN, BRICK_VLEN ), \n      vec4( BRICK_ULEN + BRICK_UGAP,  dispIn,  BRICK_ULEN, BRICK_VLEN ) ,\n      vec4( BRICK_ULEN + BRICK_UGAP, dispIn + BRICK_VLEN  + BRICK_VGAP,    BRICK_ULEN, BRICK_VLEN_SHORT ) \n\t);\n \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + (BRICK_VLEN_SHORT + BRICK_VGAP ) + 0.001;\n\n  \tconst float brickDepth[maxLayers] = float[]\n    (\n         0.03, 0.023, 0.033, 0.021\n    );\n\tconst float  y1 = -0.47439;\n\n#elif BRICK_PATTERN == 2        // square cycle\n  \n\tconst float SCL = 0.8;\t// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n    \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0,                    BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ) \n\t);\n \n\tconst float CELLSIZEU  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001;\n\tconst float CELLSIZEV  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001; \n\tconst float  DepthOfBrick = 0.04439; \n\n\tconst float brickDepth[maxLayers] = float[]\n    (\n         0.04, 0.033, 0.043, 0.030\n    );\n\tconst float  y1 = -0.47439;\n\n#elif BRICK_PATTERN == 3        // square cycle staggered\n  \n\tconst float SCL = 0.65;// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n  \n\tconst float staggerU = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD);\n\tconst float staggerV = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD) * 0.5;\n\n\tconst int maxLayers = 8;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0, BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ),\n        \n      vec4( staggerU, staggerV, BRICK_SC, BRICK_SA   ), \n      vec4( staggerU, BRICK_SA + BRICK_SB + staggerV, BRICK_SA, BRICK_SC  ) , \n      vec4( staggerU + BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA + staggerV,   BRICK_SC, BRICK_SA  ) ,  \n      vec4( staggerU + BRICK_SC + BRICK_SB, staggerV,  BRICK_SA, BRICK_SC) \n\t);\n \n    const float brickDepth[maxLayers] = float[]\n    (\n        0.013, 0.047, 0.033, 0.027, 0.043, 0.019, 0.051, 0.041\n    );\n \n\n\tconst float CELLSIZEU  =  2.0 * (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\tconst float CELLSIZEV  =  (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\t \n\tconst float  y1 = -0.47439;\n #endif\n\n  \n\nconst float  xLo =  - 1.2; \nconst float  xHi =    1.56;\nconst float  zLo =    0.48;  //-2.0; \nconst float  zHi =    2.22;\n\n\t// Depth of brick from mortar\n\n\n\n\t// colors per face. For testing\n\nconst vec3 colr0[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(1,0.5,0),  \n\tvec3(0.2,0.3,0.4),  \n\tvec3(1,0,0),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n); \nconst vec3 colr1[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(0.85,0.5 ,0.44 ), \n    vec3(1,0.5,0),  \n\tvec3(0.8,0.5,0.2),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n);   \n\nfloat  RECIP_CELLSIZEU = 1.0 / CELLSIZEU;\nfloat  RECIP_CELLSIZEV = 1.0 / CELLSIZEV;  \n\n//const float  y1 =  y0 - DepthOfBrick;\n\nconst vec4 boundsA = vec4(zLo, -zHi, xLo, -xHi );\nconst vec4 boundsB = vec4(-1.0, 1.0, -1.0, 1.0);\n\n\t//  FPT limits, needed for ensuring numerical stability as ray axes approach alignment with the world space.\n    //  https://en.wikipedia.org/wiki/IEEE_754-1985\n\nconst float SMALLEST_POSITIVE_IEEE754_FPT =  intBitsToFloat(1); // ±2^−23 × 2^−126  are closest representable numbers to 0\nconst float BIGGEST_IEEE754_FPT = \tintBitsToFloat(0x7F7FFFFF);  \n\n// Fed up with typing  'clamp(..., 0.0, 1.0)'   when we know it will go to a saturate and\n// probably get it for free on the GPU.\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0.0, 1.0);\n} \nvec4 saturate(vec4 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat random2(vec2 st)\n{\n    // Quick random-ish used for determining a random scalar for a brick (for color, etc.)\n    //  modded from hash function at:    https://www.shadertoy.com/view/XlXcW4\n    //  ( taken one xor line,  good enough for this test! )\n     \n    uint  a = floatBitsToUint(st.x);\n    uint  b = floatBitsToUint(st.y);\n    \n    float h = float(((a>>8U)^b)*1103515245U) / float(0xffffffffU); \n    return h;              \n} \n\t\n\nint BrickWall( in vec3 ro,  vec3 rd,  out bool inShadow, out vec3 normal,  out vec2 idx,  inout vec3 posn)  \n{ \n    vec3 iSect[maxLayers];\n    \n    inShadow = false;\n    normal = vec3(0.0, -1.0, 0.0);\n    idx = vec2(0);\n    posn = vec3(0); \n      \n    \n \t// NOTE:  if rd.y == 0  (ie. ray is coplanar, then  intersect0 == 0, and the bounds test passes, (if we had used the\n    // nieve approach, then  intersect0 would approach infinity as rd.y approaches 0, because we would be using 1/rd.y - \n    // but we multiply up by rd.y^2  to avoid divisions AND maintain the inequality tests.\n    //  (In the case of rd2.y very close to 0, then early out). \n    vec3  rd2 = rd * rd;  \n    if( rd2.y <  SMALLEST_POSITIVE_IEEE754_FPT )   // consider ray as coplanar,  rd2.y = y^2 so always +ve \n        return 0; \n    \n   \n    float bestFaceCode = 4.0;\t\t// Default to Mortar\n    \n    float  recip_rd2y = 1.0 / rd2.y;    \n      \n    float rdxrdz = rd.x * rd.z;\n    float rdxrdz2 = rdxrdz * rdxrdz; \n    vec2 C01 =  rdxrdz * rd.zx; \n    float C6  =  rdxrdz2 * recip_rd2y; \n    \n    // +/- 1 depending on half-space for each axis X, Z\n    \n    vec2 hsPlusMinus =  vec2 (  ( rd.x >= 0.0 ) ? 1.0 : -1.0 ,  ( rd.z >= 0.0 ) ? 1.0 : -1.0 );    \n    \n    float bestT = BIGGEST_IEEE754_FPT;  \n    float topFaceT =   0.0;  \n    \n    vec2  F01 = vec2(CELLSIZEU, CELLSIZEV) * C01 ; \n    vec2  D01 = -(vec2(CELLSIZEU,CELLSIZEV) + ro.xz ) * C01; \n    \n    float bestSy = 0.0;\n    vec2  fl2 =  vec2(CELLSIZEU, CELLSIZEV); \n    \n    float S1 =  ro.y * rdxrdz2;\n    vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    if( C01.x < 0.0 )\n        vecE0E1.xy = vec2(1.0, 0.0);\n    if( C01.y < 0.0 )\n        vecE0E1.zw = vec2(1.0, 0.0); \n    \n    vec4 C5 = vecE0E1 * C01.xxyy; \n    \n    \n    for( int layer = 0; layer < maxLayers; ++layer)\n    {\n        vec4 ss = shiftAndSizes[layer]; \n    \n        float y0 = y1 + brickDepth[layer];\n        float t0 =  ( -ro.y + y0) *  rd.y; \n   \t    float t1 =  ( -ro.y + y1) *  rd.y;\n    \n    \tfloat sum = t0 + t1;\n   \t    t0 = min(t0,t1); \n    \tif( t0 < 0.0 )     // early out if intersection is behind camera\n        \treturn 0;\t \n   \t    t1 = sum - t0;  \t\t\n      \n        vec3  intersect0 = ro * rd2.y + t0 * rd;\n        if( dot(saturate( boundsA * rd2.y + intersect0.zzxx * boundsB ), vec4(1.0)) ==  0.0 )\n        {\n \t\t \n        \tintersect0 *= recip_rd2y;    // We have already checked that rd2.y >=  SMALLEST_POSITIVE_IEEE754_FPT,  above\n \t\t\tiSect[layer] = intersect0;\n            \n \t\t\tvec2 fufv   = floor((intersect0.xz - ss.xy ) * vec2(RECIP_CELLSIZEU, RECIP_CELLSIZEV)); \n\t\t\tvec2 cellUV = fufv  * vec2(CELLSIZEU, CELLSIZEV) + ss.xy ; \n        \n            vec2 currentIdx =  fufv  + float(layer); \n            \n        \tvec2 a = saturate( intersect0.xz - cellUV.xy -  ss.zw );\n        \tif ((a.x + a.y) == 0.0)  \n    \t\t{\n       \t \t \t// brick face \n                float temp =  t0 * C6;    // convert parametric * rd2.y to  parametric * rdxrdz2  to match the multiplied parametrics\n                \t\t\t\t\t\t  // used for the vertical end/\n                if( temp < bestT )\n                {\n                    topFaceT = temp;\n                    bestT = temp;\n            \t\tidx =   currentIdx; \n            \t\tposn = intersect0; \n                }\n    \t\t} \n         \n       \t \tvec4 sortOffset = C5 * ss.zzww; \n         \n        \tvec2  C4  = vec2(y0,y1) * rdxrdz2 ;  \n                  \n     \t    \n       \t    float dIdxV = currentIdx.y;\n          \n            vec2 dudvYstart = cellUV.y * C01.y + D01.y + sortOffset.zw; \n        \n       \t    vec4 t;\n       \t    t.xy = cellUV.x * C01.x + D01.x  + sortOffset.xy; \n        \tfor( int u = 0; u < 3; u++ )\n        \t{  \n         \t   \tcurrentIdx.y = dIdxV ;\n         \t  \tcurrentIdx.x++; \n    \t        t.zw  = dudvYstart;       \n   \t         \tfor(int v = 0; v  < 3; v++ )\n    \t        {\n                \t//  s is an associated value for tv,  so that we know after ordering  tv, whether a line segment\n                \t//  crosses / intersects a cell   ( when s.x != s.y ).\n                               \n                \tcurrentIdx.y++;\n                \n        \t\t\tvec4 tv = t;\n                \tvec3 s =  vec3(0.0,0.0,1.0);\n                 \n\t                if(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }  \n      \n    \t\t\t\tfloat ds = s.x - s.y;\n                \tfloat p =  S1 + tv.y * rd.y;  \n                  \n    \t\t\t\tif( (  \n                     saturate(1.0 - ds*ds) + \n                     saturate( tv.y - bestT) +  \n                     saturate( p  - C4.x ) +  \n                     saturate( C4.y - p  )) == 0.0)\n            \t\t{  \n                  \t\tbestT = tv.y; \n                        bestSy =  s.y; \n                        idx =  currentIdx; \n            \t\t}\n            \n                 \tt.zw += F01.y;\n            \t}\n            \tt.xy += F01.x; \n        \t}\n        \tfl2 += float(maxLayers); \n    \t} \n    }\n    \n    if( bestT == topFaceT)\n    { \n        bestFaceCode = 3.0;  \n    }\n    else\n    if( bestT != BIGGEST_IEEE754_FPT )\n    {\n\t\tnormal = vec3( hsPlusMinus.x * (1.0 -bestSy), 0.0, hsPlusMinus.y * bestSy  ) ;  \n        bestFaceCode = bestSy + 1.0;  \n    }\n\n    // Trim edge    \n   float t1 =  ( -ro.y + y1) *  rd.y;\n   if (bestFaceCode != 4.0)\n   {  \n        rd2.y = rdxrdz2;\n        t1 = bestT; \n   }\n    \n   vec3  coord = ro  * rd2.y + t1 * rd;  // ray intersection point multiplied by rd2.y,  ie. ray-direction 'y' squared\n    \n   if( dot(saturate( boundsA * rd2.y + coord.zzxx * boundsB ), vec4(1.0)) !=  0.0 )\n   {\n        return 0;   \n   } \n    \n   #if defined(USE_SHADOW)\n   \n    // If light source is from behind wall,  or behind a brick end or side, then always in shadow..\n    \n    bool  shadow = ((saturate( LIGHT_DIRECTION.y )  + saturate( -dot( normal.xz, LIGHT_DIRECTION.xz ))  ) != 0.0);\n    \n     // Otherwise examine adjacent cells for projecting the eye ray intersection point along the reverse light direction\n     // (Since all edges are vertical in the plane, we only need to detect the XZ ray crossing the brick area of a cell.\n    \n    if( !shadow)\n    {  \n         float rdxrdz = LIGHT_DIRECTION.x * LIGHT_DIRECTION.z; \n    \t vec2  C01    =  -rdxrdz * vec2( LIGHT_DIRECTION.z, LIGHT_DIRECTION.x); \n         float rdxrdz2   = rdxrdz * rdxrdz * rd2.y; \n         float G1 = rdxrdz2 * rd2.y; \n     \n   \t     vec2 hsPlusMinus =  vec2 (  ( LIGHT_DIRECTION.x <= 0.0 ) ? 1.0 : -1.0 ,  ( LIGHT_DIRECTION.z <= 0.0 ) ? 1.0 : -1.0 );   \n      \n    \t vec2  D01 = -(vec2(CELLSIZEU, CELLSIZEV)  * rd2.y + coord.xz) * C01; \n         vec3  G0 = -LIGHT_DIRECTION * rd2.y;   //-ve to allow + in loop,  easier to mad\n         vec4  S0 = boundsA * G1;\n         vec3  S1 = coord * rdxrdz2;\n          \n        vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    \tif( C01.x < 0.0 )\n        \tvecE0E1.xy = vec2(1.0, 0.0);\n    \tif( C01.y < 0.0 )\n        \tvecE0E1.zw = vec2(1.0, 0.0); \n        \n         vec2  C23 = C01  * rd2.y;  \n    \t vec2  F10 = vec2(CELLSIZEU, CELLSIZEV) * C23 ;  \n         vec4  C5 = C23.xxyy * vecE0E1; \n         \n    \t for( int layer = 0; layer < maxLayers; ++layer)\n    \t {\n        \tvec4 ss = shiftAndSizes[layer];\n       \t\t  \n            vec3 intersect0 = iSect[layer];\n    \t\tfloat y0 = y1 + brickDepth[layer];\n             \n            float t0 =  ( y0 * rd2.y -coord.y ) ; \n        \tintersect0.xz = coord.xz - t0 * LIGHT_DIRECTION.xz; \n    \t \tvec2  C4  = vec2(y0,y1) * G1 ; \n         \tintersect0 /= rd2.y; \n             \n            vec4 sortOffset = C5 * ss.zzww;\n    \t\tfloat fu = (intersect0.x - ss.x ) * RECIP_CELLSIZEU;\n    \t\tfloat fv = (intersect0.z - ss.y ) * RECIP_CELLSIZEV; \n    \n    \t\tfloat cellU = floor(fu ) * CELLSIZEU + ss.x ;\n    \t\tfloat cellV = floor(fv ) * CELLSIZEV + ss.y ; \n            \n            vec2 dudvYstart = cellV * C23.y + D01.y + sortOffset.zw;\n\n            vec4 t ; \n            t.xy =  cellU * C23.x + D01.x  + sortOffset.xy;\n        \tfor( int u = 0; u < 3; u++ )\n        \t{   \n                t.zw  = dudvYstart; \n               \tfor(int v = 0; v  < 3; v++ )\n            \t{  \n        \t\t\tvec4 tv = t;  //  tv.x <=  tv.y,    tv.z <= tv.w\n                \tvec3 s =  vec3(0.0,0.0,1.0);\n                   \n                \tif(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }    \n                    \n                    float ds = s.x - s.y;\n                    vec3  p  = S1 + tv.y * G0;   \n                    vec4  a  = saturate( S0 + p.zzxx * boundsB ); \n                    \n                    // could break out as soon as shadow is true.  probably worth doing (wavefronts ? )\n                    \n                    shadow = shadow ||\n    \t\t\t\t   ( \n                         (saturate(1.0 - ds*ds) + \n                          saturate( -tv.y ) +  \n       \t\t\t\t      saturate(  p.y - C4.x ) +\n                          saturate(  C4.y - p.y ) +\n                          a.x + a.y + a.z + a.w               // using dot(a,vec4(1.0)) is not good on GCN chips.\n                         ) == 0.0\n                       ) ;\n                     \n                \tt.zw += F10.y;\n            \t}   \n            \tt.xy += F10.x;\n        \t} \n    \t}  \n    } \n    inShadow = shadow;\n    \n   #endif\n     \n   posn = coord / rd2.y;\n    \n   return int(bestFaceCode);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) *  vec2(iResolution.x/iResolution.y, 1.0);\n    \n\tvec3 ro;\n    ro.y = -0.2;\n  \n    vec2 maxSpan = vec2( xHi - xLo, zHi - zLo ) * 0.4; \n    \n    float pt = iTime;\n    ro.x = xLo + (  xHi - xLo) * 0.5 + sin(pt * 0.2) * maxSpan.x;\n    ro.z = zLo + (  zHi - zLo) * 0.5 + cos(pt * 0.2) * maxSpan.y;\n    float theta = 1.4 + iMouse.x * 0.01;\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 rotn;\n    rotn[0][0] = c;\n    rotn[0][1] = -s;\n    rotn[1][0] =  s;\n    rotn[1][1] = c;\n    \n    vec3 dirn = normalize(vec3(uv,1.0));\n    dirn.xz *= rotn; \n    \n    \t// Now do something more interesting....\n    bool inShadow = false;\n    vec3 normal = vec3(0); \n    vec3 posn = vec3(0); \n    \n    vec2 idx;   \n       \n    int faceCode = BrickWall( ro, normalize(dirn), inShadow, normal,  idx, posn);   \n        \n    float idCoeff = random2( idx.xy *  1.2341 ); \n    \n    \t// Apply the color,  simple dp lighting and darken if the point is in shadow,\n    \n    vec4  faceColor  =  vec4(  mix(colr0[faceCode], colr1[faceCode],idCoeff) , 1.0 );  \n    \t\t\t\t\t \n    if( faceCode != 0)\t\t// Do not light if not on wall surface \n    {\n   \t \tfloat intensity =  mix( LIGHT_AMBIENT_INTENSITY, 1.0, clamp(dot(normal, LIGHT_DIRECTION), 0.0, 1.0) ) ;\n   \t \tfaceColor.xyz *= intensity;\n    \tif(inShadow)\n    \t{\n       \t \tfaceColor.xyz *= 0.6;   \n   \t\t} \n    }  \n       \n    fragColor = faceColor; \n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6772, 6903, 6928, 6928, 6961], [6962, 6962, 6985, 6985, 7018], [7019, 7019, 7042, 7042, 7075], [7077, 7077, 7100, 7100, 7133], [7135, 7135, 7159, 7389, 7572], [7577, 7577, 7687, 7687, 16999], [17002, 17002, 17059, 17059, 18499]], "test": "untested"}
{"id": "wtcSW2", "name": "(p,q) Torus Knot", "author": "arifr123", "description": "(p,q)-torus knot renderer using gradient descent and raymarching.\n\nhttps://en.wikipedia.org/wiki/Torus_knot\n\n\"The (p,q)-torus knot winds q times around a circle in the interior of the torus, and p times around its axis of rotational symmetry.\"", "tags": ["raymarching", "gradientdescent", "torusknot"], "likes": 14, "viewed": 205, "published": "Public", "date": "1581953144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433\n\nfloat sq(vec3 x)\n{\n    return dot(x, x);\n}\nfloat sq(vec2 x)\n{\n    return dot(x, x);\n}\nfloat sq(float x)\n{\n    return x*x;\n}\nint sq(int x)\n{\n    return x*x;\n}\n\nvec2 sic(float t)\n{\n    return vec2(cos(t), sin(t));\n}\n\nstruct TorusKnotParameters\n{\n    float kp;\n    float kq;\n    float r1;\n    float r2;\n    float r3;\n};\n\nvec3 torusKnot(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);\n}\nvec3 torusKnotDerivative(float t, TorusKnotParameters tkp)\n{\n    vec2 sicXY = sic(tkp.kp * t);\n    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);\n    \n    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;\n    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;\n    \n    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);\n}\n\nfloat torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return sq(torusKnot(t, tkp) - p);\n}\nfloat torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)\n{\n    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));\n}\n\nfloat minimizeDistance(float t, vec3 p, TorusKnotParameters tkp)\n{\n    float lerningRate = 0.01/max(tkp.kq,tkp.kp);\n\tconst int maxIterations = 30;\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        float dt = torusKnotSqDistanceDerivative(t, p, tkp);\n        \n        if(abs(dt) < 0.001)\n            break;\n        \n        t -= lerningRate*dt;\n    }\n    \n    return t;\n}\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\nfloat torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //|d| = 1\n    \n    //a^2 = c^2 - b^2\n    //a^2 = c^2 - (b/c * c)^2\n    //a^2 = c^2 - (cos() * c)^2\n    \n    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));\n}\nfloat torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)\n{\n    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n    //  ⇓\n\t//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);\n\t//  ⇓\n    \n    vec3 tk = torusKnot(t, tkp);\n    vec3 tkd = torusKnotDerivative(t, tkp);\n        \n    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));\n    //  ⇓\n    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));\n    //  ⇓\n    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));\n}\n\nvec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)\n{\n    int sections = 3*int(max(tkp.kq,tkp.kp));\n    float sectionLength = 2.*PI/float(sections);\n    \n    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);\n    const int maxIterations = 100;//50\n    \n    float minDist;\n    float bestT;\n    bool found = false;\n    \n    for(int j = 0; j < sections; j++)\n    {\n        float t = sectionLength * float(j);\n        bool failed = false;\n        \n        for(int i = 0; i < maxIterations; i++)\n        {\n            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);\n            \n            if(abs(dt) < 0.1)break;\n            \n            t -= lerningRate*dt;\n            \n            \n            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))\n            {\n                failed = true;\n                break;\n            }\n        }\n        if(failed)continue;\n        \n        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);\n        \n        if(lineSqDist <= sq(tkp.r3))\n        {\n            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);\n\n            if(!found || distAlongD < minDist)\n            {\n                minDist = distAlongD;\n                bestT = t;\n            }\n            \n            found = true;\n        }\n    }\n    \n    return vec3(bestT, minDist, found ? 1. : 0.);\n}\n\nfloat dot01(vec3 a, vec3 b)// [-1, 1] => [0 ,1]\n{\n    return (dot(a, b) + 1.)/2.;\n}\n\nRay intersect(Ray ray, TorusKnotParameters tkp)\n{\n    const int maxIterations = 50;\n    \n    vec3 res = firstTorusKnotLineSqDistanceMinimumInside(ray, tkp);\n    \n    if(res[2] < 0.5)\n    {\n        return Ray(vec3(0), vec3(0));\n    }\n    \n    float t = res[0];\n    vec3 p = ray.ro + res[1] * ray.rd;\n\n    for(int i = 0; i < maxIterations; i++)\n    {\n        t = minimizeDistance(t, p, tkp);\n        float d = sqrt(torusKnotSqDistance(t, p, tkp)) - tkp.r3;\n        p += d * ray.rd;\n\n        if(abs(d) < 0.01)break;\n    }\n\n    vec3 normal = normalize(torusKnot(t, tkp) - p);\n    \n    return Ray(p, normal);\n}\n\nint gcd(ivec2 v)\n{\n    while(v.x != v.y)\n    {\n        if(v.x > v.y)\n            v.x -= v.y;\n        else\n            v.y -= v.x;\n    }\n    \n    return v.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n\n    vec2 angles = /*false &&*/ iMouse.z > 0.5 ? PI*(2.*iMouse.xy/iResolution.xy - 1.) : sic(0.5*iTime);\n    vec2 sic0 = sic(angles[0]);\n    vec2 sic1 = sic(angles[1]);\n    \n    vec3 f = vec3(sic1.x * sic0, -sic1.y);\n    vec3 u = vec3(sic1.y * sic0, sic1.x);\n    vec3 r = -cross(u, f);\n    \n    vec3 ro = -10.*f;\n    \n    float zoom = 1.;\n    \n    ////////////////////////////////////The torus knot parameters//////////////////////////////////////////\n    float kp = 3., kq = 5., r1 = 2., r2 = 1., r3 = 0.2 + 0.3*(sin(iTime)+1.)/2.;//Change kp and kq!\n    // p and q are flipped. The parameters: 'lerningRate', 'maxIterations' and 'sections' also may need to be changed.\n    \n    /*\n    ivec2 kpkq = ivec2(10.*iMouse.xy/iResolution.xy) + 1;\n    kpkq /= gcd(kpkq);\n    \n    kp = float(kpkq.x);\n    kq = float(kpkq.y);\n\t*/\n    \n    TorusKnotParameters tkp = TorusKnotParameters(kp, kq, r1, r2, r3);\n    \n    vec3 rd = normalize(zoom * f + uv.x*r + uv.y*u);\n    \n    \n    Ray lr = intersect(Ray(ro, rd), tkp);\n    \n    vec3 col;\n    \n    if(sq(lr.rd) < 0.5)\n    {\n        col = vec3(0);\n    }\n    else\n    {\n        //reflections\n        for(int i = 0; i < 0; i++)\n        {\n            Ray nr = intersect(lr, tkp);\n            if(sq(nr.rd) < 0.5)\n                break;\n\n            nr.ro -= 0.01*nr.rd;\n            lr = nr;\n        }\n        \n        float offset = 2.*iTime;\n\n        vec2 sicRZ = sic(0.);\n\n        vec3 redLight = vec3(sicRZ.x * sic(offset), sicRZ.y);\n        vec3 blueLight = vec3(sicRZ.x * sic(2.*PI/3. + offset), sicRZ.y);\n        vec3 greenLight = vec3(sicRZ.x * sic(2.*2.*PI/3. + offset), sicRZ.y);\n\n        col = vec3(dot01(lr.rd, -redLight), dot01(lr.rd, -blueLight), dot01(lr.rd, -greenLight));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 58, 58, 82], [83, 83, 101, 101, 125], [126, 126, 145, 145, 163], [164, 164, 179, 179, 197], [199, 199, 218, 218, 253], [358, 358, 408, 408, 544], [545, 545, 605, 605, 867], [869, 869, 938, 938, 978], [979, 979, 1058, 1058, 1131], [1133, 1133, 1199, 1199, 1515], [1556, 1556, 1630, 1733, 1834], [1835, 1835, 1919, 2247, 2651], [2653, 2653, 2735, 2735, 4043], [4045, 4045, 4094, 4094, 4128], [4130, 4130, 4179, 4179, 4735], [4737, 4737, 4755, 4755, 4895], [4897, 4897, 4954, 4954, 6799]], "test": "untested"}
{"id": "WtcSW4", "name": "Day 48", "author": "jeyko", "description": "just fyi the code is not very tidy.", "tags": ["mdtmjvm"], "likes": 20, "viewed": 630, "published": "Public API", "date": "1580921230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 glow = vec3(0);\n    \n#define iTime (iTime + 10.)\n#define mx (iTime*0.9 + 20.*iMouse.x/iResolution.x)\n#define my (20.*iMouse.y/iResolution.x)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n#define dmin(a, b) a.x < b.x ? a : b\n#define pmod(a,x) mod(a,x) - x*0.5\n\nvec3 path(float z){\n    z *= 0.4;\n\treturn vec3(\n    \tsin(z + cos(z)*0.6),\n    \tcos(z + sin(z*0.8)*0.5),\n    \t0.\n    )*1.;\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1)/k,0.,1.);\n    return mix(d2, d1, h) - k*h*(1. - h);  \n}\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n\nfloat modu;\nfloat moduB;\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\tp -= path(p.z);\n    vec2 n = normalize(p.xy);\n    #define modDist 1.\n    #define tunnW 0.7\n    #define pipeW 0.04\n    \n    vec3 g = p;\n    p.z = pmod(p.z, modDist);\n    \n    vec3 o = p;\n    //p.xy *= rot(0.4 + p.z*(0.1 + sin(iTime*0.1) )+ iTime*0.3);\n    vec2 pC = vec2(atan(p.y,p.x), length(p.xy));\n    \n    vec3 q = vec3(pC, p.z);\n\n    \n    // hex\n    //vec4 hc = HexCoords(vec2(pC.x, z)*20.);\n    vec4 hc = HexCoords(vec2(pC.x, p.z*2.)*1.);\n    \n    float dHex = hc.y - 0.1 + sin(o.z)*0.06;\n    dHex = max(dHex, -length(o.xy*1.) + tunnW*0.6);\n    //dHex = max(dHex, length(o.xy*1.) - tunnW*0.97);\n    //d = dmin(d, vec2(dHex, 2.));    \n    \n    q.y -= tunnW*1.;\n    \n    q.x = pmod(q.x*4.,1.);\n    q.z = pmod(q.z,0.2);\n        \n    // pipes\n    float dPipes = min(length(q.xy) - pipeW,length(q.zy) - pipeW );\n    \n    // dots\n    #define pi acos(-1.)\n    q = vec3(pC, g.z);\n    q.z = pmod(q.z, 0.14);\n    \n    q.x = pmod(q.x*3.*pi + 0.5, 1.);\n    \n    q.y -= tunnW*0.9;\n    q.y *= 15.;\n    q.z *= 8.;\n    float dDots = length(q) - 0.4;\n    //dDots *= 0.7;\n    \n    \n    // mod\n    float mm = sin(iTime*0.5 + g.z*0.5 + p.z);\n    modu = (mm/sqrt(0.02 + mm*mm ))*0.5 + 0.5;\n    float mmB = sin(iTime*1.25 + g.z*0.25 + p.z*0.8 + p.y);\n    moduB = (mmB/sqrt(0.01 + mmB*mmB ))*0.5 + 0.5;\n    //moduB = 1. - moduB;\n    moduB *= 0.16;\n    //modu = 1.;\n    \n    // thing\n    dPipes = mix(dPipes,dDots,moduB*0.7  + 0.);\n    \n    float dThing = mix(\n    \tdHex, dPipes, modu*1. + 0.3\n    );\n    d = dmin(d, vec2(dThing, 2.));\n    \n    // tunnel\n    float dTunn = -length(o.xy*1.) + tunnW;\n    dTunn = max(length(o.xy*1.) - tunnW - 0.02, dTunn);\n    dTunn = max(dTunn, -dThing);\n    d = dmin(d, vec2(dTunn, 10.));\n    \n    \n    \n    d.x *= 0.14;\n\treturn d;\n}\n\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\thit = false;\n    p = ro;\n    t = 0.;\n    vec2 d;\n    for(int i = 0; i < 200; i++){\n    \td = map(p);\n        if (d.y < 10.){\n            glow += mix(\n                mix(\n                    exp(-d.x*5.)*pal(1.3,0.7,vec3(1.8+modu*0.5,0.4,0.8), 3.9 +modu*0.2 + sin(p.z)*0.5,2. + t*0.1)*2.,\n                    exp(-d.x*0.01)*pal(2.8,1.4,vec3(5.8,2.4+modu*0.2,0.8+ sin(p.y + iTime)*.09), 6.9 +modu*0.2 + sin(p.z)*.5,0.5 + t*0.5)*2.,\n                    moduB\n                ),exp(-d.x*20.)*pal(0.8,0.7,vec3(1.8+modu*0.5,0.4,0.8), 3.9 +modu*0.2 + sin(p.z)*0.5,1.9 - t*0.1)*2.\n                , 1. - modu\n            );\n        \t\n        \n        } else {\n        \tglow += exp(-d.x*2.)*pal(0.2,1.9,vec3(1.8,0.4,0.8), 5.6 ,2.- t*0.1)*0.4;\n        }\n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        t += d.x;;\n    \tp = ro + rd*t;\n    }\n\treturn d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 1. - dot(uv,uv)*0.2;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    ro.z += mx;\n    ro += path(ro.z);\n    vec3 lookAt = ro + vec3(0,0,4);\n    lookAt += path(lookAt.z);\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    float t; bool hit;\n    vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    if(hit){\n        //vec3 N = getNormal\n\t\tcol += 0.04;\n    }\n        \n    col *= 0.4;\n    col = pow(col,vec3(0.45));\n    \n    col += glow*0.011;\n    uv *= 0.8;\n    col *= 1. - dot(uv,uv);\n    //col *= 1. - t*0.2;    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 287, 287, 391], [392, 392, 442, 442, 540], [541, 595, 618, 618, 715], [718, 718, 743, 743, 1006], [1085, 1085, 1102, 1102, 2874], [2876, 2876, 2946, 2946, 3833], [3835, 3835, 3877, 3877, 4031], [4032, 4032, 4089, 4089, 4723]], "test": "untested"}
{"id": "wtcSzB", "name": "Squares Analytic Motion Blur ", "author": "fizzer", "description": "Analytic (linear) motion blur of a square. It is pretty much based on the same idea as IQ's motion-blurred discs (see [url]https://www.shadertoy.com/view/MdSGDm[/url])", "tags": ["motionblur", "square", "analytic"], "likes": 14, "viewed": 321, "published": "Public", "date": "1581201750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Analytic Linear Motion Blur Series:\n//\n// Self-Intersecting Polygon (XOR Rule) - https://www.shadertoy.com/view/tltXRS\n// Concave Polygon - https://www.shadertoy.com/view/tldSzS\n// Square - https://www.shadertoy.com/view/wtcSzB\n// Checkerboard - https://www.shadertoy.com/view/tlcXRX\n//\n\nvec2 screenToSquareTransform(vec2 p, float t, float i)\n{\n    float a = t * 2. + cos(t + i) + i / 3.;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec2 o = vec2(cos(t * 2. * 2. + i * 5.5) / 2., sin(t * 2.9 * 2. + i * 1.27) * .25);\n    o.y += cos(t / 4. + i) * .1;\n    return m * (p - o) * (3. + sin(t - i) * 1.5) * 8.;\n}\n\nfloat integrateSquare(vec2 pa, vec2 pb)\n{\n    vec2 d = pb - pa, sd = sign(d);\n    \n    vec2 t0 = (-sd - pa) / d;\n    vec2 t1 = (+sd - pa) / d;\n    \n    vec2 i = clamp(vec2(max(t0.x, t0.y), min(t1.x, t1.y)), 0., 1.);\n    \n    return max(0., i.y - i.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    float t = iTime;\n    \n    vec3 col = vec3(1. / 9.);\n\n  \tfor(int i = 0; i < 15; ++i)\n    {\n        vec2 pa = screenToSquareTransform(uv, t, float(i));\n        vec2 pb = screenToSquareTransform(uv, t - 1. / 30., float(i));\n\n        float is = integrateSquare(pa, pb);\n\n        col = mix(col, mix(vec3(1, .5, .1), vec3(1), fract(float(i) * 1.629)), is);\n    }\n    \n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 294, 350, 350, 624], [626, 626, 667, 667, 879], [881, 881, 938, 938, 1424]], "test": "untested"}
{"id": "WtcSzl", "name": "The Mandelbrot Set", "author": "42yeah", "description": "Zoomed in too much.\n\nhttps://frame.42yeah.casa/2020/02/12/mandelbrot-set.html", "tags": ["mandelbrot"], "likes": 2, "viewed": 342, "published": "Public API", "date": "1581499147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float julia(vec2 uv, vec2 c) {\n    int i;\n    for (i = 0; i < 100; i++) {\n        uv = vec2(uv.x * uv.x - uv.y * uv.y + c.x,\n                  2.0 * uv.x * uv.y + c.y);\n        if (length(uv) > 100.0) {\n            break;\n        }\n    }\n    return float(i) / 100.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    uv *= pow(0.5, -1.0 + 30.0 * (0.5 + 0.5 * sin(iTime * 0.20 - (3.14159265))));\n    uv += vec2(-0.51, -0.61351); // From iq\n    float f = julia(vec2(0.0, 0.0), uv);\n    \n    // Output to screen\n    fragColor = vec4((1.0 - uv) * pow(f, 0.5), f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 268], [271, 271, 328, 378, 759]], "test": "untested"}
{"id": "WtcXD8", "name": "Day 47 - Isometric 2", "author": "jeyko", "description": "If you would like to the isometric framework, fill the sdMain(vec3 p, vec2 idD) function.\n", "tags": ["isometric", "mdtmjvm"], "likes": 31, "viewed": 713, "published": "Public API", "date": "1580826115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Day 45 - Isometric\" by jeyko. https://shadertoy.com/view/WltXR7\n// 2020-02-04 12:31:12\n\nvec3 glow = vec3(0);\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define pmod(p, x) mod(p, x) - x*0.5\n#define pi acos(-1.)\n\n#define modDist vec2(1.42,1.)\n\n#define xOffs 0.71\n#define yOffs 0.7\n\n#define ZOOM 5.\n#define mx (50.*iMouse.x/iResolution.x)\n#define my (-iTime + 50.*iMouse.y/iResolution.x)\nfloat sdBox(vec3 p, vec3 r){\n\tp = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\nfloat sdBoxIQ( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOcta(vec3 p, vec3 s, vec2 id){\n\tp = abs(p) - s;\n    float d = max(p.x, max(p.y, p.z));\n    \n    d =  dot(p.xz + s.zx*0.5, normalize(vec2(1)));\n    \n    d = max(d, dot(p.xy + s.xy*0.5, normalize(vec2(1))));\n    \n    d = max(d, dot(p.yz + s.xy*0.5, normalize(vec2(1))));\n    \n    return d;\n}\nfloat sdMain(vec3 p, vec2 idD){\n\tfloat d = 10e6;\n    vec3 q = p;\n    float steps = 5.;\n    float m = sin(iTime + idD.x + idD.y*4.);\n    for(float i = 0.; i < steps; i++){\n    \td = min(d,sdBoxIQ(p, vec3(0.51 - 0.5*i/steps)) - .02);\t\n        p.y -= 0.25 + m*0.15;\n    }\n    \n    vec3 s = vec3(0.77);\n    \n    d = max(d, -max(sdOcta(q, s, idD), q.y - 0.5));\n\treturn d;\n}\n\n\nvec2 id;\n\nfloat sdIso(vec3 p, vec2 id){\n\tfloat d = 10e6;\n    //p.z -= 0.;\n    vec3 q = p;\n    \n    // ME\n    p.x -= id.y*xOffs;\n    p.y += id.y*yOffs;\n    p.xz = pmod(p.xz, modDist);\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, id));\n    \n    vec2 idD = id;\n    \n    // BOTTOM\n    p = q;\n    idD.y += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0,0. - id.y), vec2(modDist.x,modDist.y*3.));\n    \n    if (p.x > 0.){\n        idD.x -= 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n\n    // RIGHT\n    p = q;\n    idD = id;\n    idD.x -= 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // LEFT\n    p = q;\n    idD = id;\n    idD.x += 1.;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(modDist.x*1.- idD.x*modDist.x*1.,0), vec2(modDist.x*3.,modDist.y));\n    p.xy *= rot(pi*.25);\n    d = min(d, sdMain(p, idD));\n    \n    // TOP\n    idD = id;\n    idD.y -= 1.;\n    p = q;\n    p.x -= idD.y*xOffs;\n    p.y += idD.y*yOffs;\n    p.xz = pmod(p.xz + vec2(0.,-1. - id.y), vec2(modDist.x,modDist.y*3.));\n    if (p.x < 0.){\n      idD.x += 1.;\n    }\n    p.xy *= rot(pi*0.25);\n    d = min(d, sdMain(p, idD));\n    \n    \n\treturn d;\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n    id = floor(p.xz/modDist);\n    id.x = floor((p.x - modDist.x*0.5*id.y)/modDist.x);\n    d.x = min(d.x, sdIso(p, id));\n    d.x *= 0.7;\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tp = ro;\n    vec2 d;\n    hit = false;\n    for(int i = 0; i < 100 ;i++){\n    \td = map(p);\n        //glow += exp(-d.x*60.);\n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n        if(t > 10.){\n        \t//hit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n\n\treturn d;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.0001,0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro );\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    ro -= ZOOM*dir;\n\treturn dir + right*uv.x + up*uv.y;\n}\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    \n    ro += right*uv.x*ZOOM;\n    ro += up*uv.y*ZOOM;\n \treturn rd;\n\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.4, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 quv = uv;\n    uv.xy *= rot(0.7);\n    vec3 col = vec3(0.0);\n    vec3 lookAt = vec3(0,-1,-2);\n    \n    \n    vec3 ro = vec3(0,8,0);\n   \n    vec3 rd = getRdIsometric(ro, lookAt, uv); \n    //vec3 rd = getRd(ro, lookAt, uv); \n        \n    vec3 p;\n    \n    //ro.x += mx;\n    ro.z += my;\n    ro.y -= my*0.65;\n    //ro += rd*5.4;\n    \n    float t = 0.; bool hit;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    vec3 l = normalize(vec3(1.9,1.,.7));\n    \n    if (hit){\n        vec3 n = getNormal(p);\n        n.y *= -1.;\n        n.g*=0.4;\n        n.xy *= rot(0.2 + sin(iTime)*0.2 + uv.x*0.6);\n        float s = calcSoftshadow(p,l,0.01,2.4, 0);\n    \tcol += 0.5 + n*0.6;\n        \n        col = clamp(col, 0., 1.);\n\n        \n        col *= s;\n    \t\n    } else {\n    \tcol = mix(\n            vec3(0.8,0.1,0.1)*1.9,\n            vec3(0.4,0.6,0.5)*1.7,    \n\t\t\tabs(sin(iTime*0.5))\n                 );\n        ;\n        col.xy *= rot(0.1 - uv.x*0.3);\n    }\n    \n    \n    //col -= glow*0.01;\n    \n    col = max(col, 0.);\n    \n    col = clamp(col, 0., 1.);\n    //col = pow(col, vec3(0.45));\n    col = pow(col, vec3(0.7));\n    \n    \n    //col = pow(col, vec3(1.7));\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 406, 434, 434, 486], [487, 487, 520, 520, 607], [609, 609, 647, 647, 906], [907, 907, 938, 938, 1274], [1287, 1287, 1316, 1316, 2645], [2647, 2647, 2664, 2664, 2838], [2840, 2840, 2914, 2914, 3242], [3244, 3244, 3267, 3267, 3406], [3408, 3408, 3456, 3456, 3651], [3652, 3652, 3709, 3709, 3946], [3947, 3947, 4040, 4040, 4858], [4860, 4860, 4917, 4917, 6174]], "test": "untested"}
{"id": "wtcXDB", "name": "Emerald", "author": "Flopine", "description": "A small doodle I made... for fun!", "tags": ["raymarching", "crystal"], "likes": 3, "viewed": 118, "published": "Public", "date": "1581615508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define ITER 64.\n#define BPM (110./60.)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash11 (float x)\n{return fract(sin(x)*1245.5);}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat plane (vec3 p, vec3 n, float d)\n{return dot (p,normalize(n)) + d;}\n\nfloat cut_planes(vec3 p)\n{\n    p = abs(p)-0.7;\n    \n    mo(p.xz, vec2(0.8,1.));   \n    mo(p.yz, vec2(0.6,0.4));\n    mo(p.xy, vec2(0.05)); \n    return plane(p, vec3(0.5,0.8,0.7), 0.);\n}\n\nfloat SDF (vec3 p)\n{\n    p.y += sin(iTime)*0.1;\n    p.xz *= rot(iTime*0.2);\n\n    return max(cut_planes(p),box(p,vec3(1.)));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n)\n{\n    vec3 h = normalize(l-rd);\n    float dotNH = dot(h, n);\n    return pow(max(dotNH,0.), 10.);\n}\n\nfloat fresnel (vec3 rd, vec3 n, float p)\n{return pow(clamp(1.-dot(-rd,n),0.,1.), p);}\n\nfloat lighting (vec3 n, vec3 l)\n{return max(dot(n,l),0.);}\n\nvec3 palette (float t)\n{\n    vec3 a,b = vec3(0.7);\n    vec3 c = vec3(.5);\n    vec3 d = vec3(0.,0.8,0.2);\n    return a+b*cos(TAU*(c*t+d));\n}\n\nvec3 background (vec2 uv, float detail)\n{\n    vec2 uu = uv;\n    \n    uv.y *= detail; \n    float horizon_id = floor(uv.y)-0.5;\n    uv.y = fract(uv.y)-0.5;\n    \n    float m1 = smoothstep(0.05, 0.01,abs(uv.y)-(1.-abs(uv.x)*0.2)*(1./(detail*8.)));\n    float m2 = step(uv.x+hash11(horizon_id)*2.,0.5+exp(-fract(iTime*BPM)));\n    float horizon_m = clamp(m1*m2,0.,1.);\n    \n    uv = uu;\n    uv.x *= detail;\n    float vertical_id = floor(uv.x)-0.5;\n    uv.x = fract(uv.x)-0.5;\n    \n    float m3 = smoothstep(0.05, 0.01,abs(uv.x)-(1.-abs(uv.y))*(1./(detail*7.)));\n    float m4 = step(uv.y+hash11(vertical_id)*2.,0.5+exp(-fract(iTime*BPM)));\n    float vertical_m = clamp(m3*m4,0.,1.);\n    \n    float end_m = clamp(horizon_m + vertical_m,0.,1.);\n    \n\treturn vec3(.98)*(1.-end_m)\n        +vec3(hash11(horizon_id),hash11(horizon_id)*0.8,0.9)*(horizon_m)\n        + vec3(hash11(vertical_id)*0.2,0.8,hash11(vertical_id))*(vertical_m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0.001,0.001,-2.1),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(-1.5,-1.,-2.5)),\n        col = background(abs(uv)-0.2, 5.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d * rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = palette(clamp(dot(-rd,n),0.,1.));\n        col += lighting(n,l);\n        col += spec(rd,n,l)*0.8;\n        col += fresnel(rd, n, 4.);\n        \n        col *= (1.-shad);\n    }\n    \n\t// vignetting (from iq)\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.2);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 393, 413, 413, 456], [458, 458, 482, 482, 511], [513, 513, 545, 545, 592], [594, 594, 622, 622, 707], [709, 709, 748, 748, 781], [783, 783, 809, 809, 967], [969, 969, 989, 989, 1094], [1096, 1096, 1119, 1119, 1233], [1235, 1235, 1273, 1273, 1370], [1372, 1372, 1414, 1414, 1457], [1459, 1459, 1492, 1492, 1517], [1519, 1519, 1543, 1543, 1658], [1660, 1660, 1701, 1701, 2581], [2583, 2583, 2640, 2640, 3585]], "test": "untested"}
{"id": "WtcXDX", "name": "大龙猫 - Quicky#021", "author": "totetmatt", "description": "Vector mountains ! ", "tags": ["quicky"], "likes": 1, "viewed": 217, "published": "Public API", "date": "1581792945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define ttime floor(iTime*.2) + pow(fract(iTime*.2),1.25)\n\nmat2 r(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));  }\n\n\nvec3 fig(vec2 uv, float p) {\n    float d =abs(atan(uv.x,uv.y))+3.141592;\n    return floor(p*vec3(d)/(3.141592*2.))/p;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    \n    uv *=r(3.14*.85);\n    \n    uv*=4.;\n    vec3 a = fig(uv*r(3.1415/4.+cos(iTime)*.1)+vec2(0.5,0.5),10.+sin(ttime));\n    vec3 b = fig((uv*r(3.1415*4.+sin(iTime)*.1))-vec2(0.5,0.5),10.+cos(ttime));\n    \n     vec3 c = fig(uv*r(3.1415*4.+sin(iTime)*.1)+vec2(0.5,0.5),10.+cos(ttime));\n    vec3 d = fig((uv*r(3.1415/4.+cos(iTime))*.1)-vec2(0.5,0.5),10.+sin(ttime));\n    \n    vec3 kk = smoothstep(0.69,.75+sin(iTime)*.01,(b+a+c+d)/4.);\n    kk = mix(vec3(0.9),vec3(0.1,0.2,0.3),kk);\n    fragColor = vec4(kk,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 76, 76, 122], [125, 125, 153, 153, 244], [245, 245, 300, 300, 876]], "test": "untested"}
{"id": "wtcXRs", "name": "AangHead", "author": "samhattangady", "description": "Felt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.", "tags": ["characteraang"], "likes": 11, "viewed": 296, "published": "Public API", "date": "1581525942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nFelt like doing some character that I know. Thought Aang would be a\ngood fit. No hair... And the arrow would be fun to figure out.\n*/\nfloat PI = 3.14159;\nvec3 rotate3D(vec3 point, vec3 rotation) {\n    vec3 r = rotation;\n\tmat3 rz = mat3(cos(r.z), -sin(r.z), 0,\n                   sin(r.z),  cos(r.z), 0,\n                   0,         0,        1);\n    mat3 ry = mat3( cos(r.y), 0, sin(r.y),\n                    0       , 1, 0       ,\n                   -sin(r.y), 0, cos(r.y));\n    mat3 rx = mat3(1, 0       , 0        ,\n                   0, cos(r.x), -sin(r.x),\n                   0, sin(r.x),  cos(r.x));\n    return rx * ry * rz * point;\n}\nfloat sdfSphere(vec3 position, vec3 center, float radius) {\n    return distance(position, center) - radius;\n}\nfloat sdfEllipsoid(vec3 position, vec3 center, vec3 radii) {\n    position -= center;\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfEllipsoidRotated(vec3 position, vec3 center, vec3 radii, vec3 rotation) {\n\tposition -= center;\n    position = rotate3D(position, rotation);\n    float k0 = length(position/radii);\n    float k1 = length(position/(radii*radii));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdfPlane( vec3 position, vec4 n ) {\n    return dot(position, normalize(n.xyz)) + n.w;\n}\nfloat sdfRoundBoxRotated(vec3 position, vec3 center, vec3 box, vec3 rotation, float radius) {\n    position -= center;\n    position = rotate3D(position, rotation);\n    vec3 q = abs(position) - box;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\nfloat dot2(vec2 v) {\n\treturn dot(v, v);\n}\nvec3 bendSpaceZ (vec3 position, float degree) {\n    //position = rotate3D(position, vec3(0.0, PI/2.0, 0.0));\n    float k = degree;\n    float c = cos(k*position.y);\n    float s = sin(k*position.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = m*position.xy;\n    return vec3(q, position.z);\n}\nvec4 sdfJoint3DSphere(vec3 position, vec3 start, vec3 rotation, float len, float angle, float thickness) {\n    vec3 p = position;\n    float l = len;\n    float a = angle;\n    float w = thickness;\n    p -= start;\n    p = rotate3D(p, rotation);\n\n    if( abs(a)<0.001 ) {\n        return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    }\n\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    p.x -= ra;\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n               (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n               (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n               p.z );\n}\nfloat smin(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat smax(float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n}\n\nvec2 aangHead(vec3 position) {\n\tvec3 symPosX = vec3(abs(position.x), position.yz);\n    float material = 1.0;\n    float d, d1, d2;\n\n    // Basic head sphere\n    d = sdfEllipsoid(position, vec3(0.0), vec3(0.4, 0.5, 0.5));\n    // basic jaw\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.3, -0.1), vec3(0.08, 0.2, 0.20),\n                            vec3(0.0), 0.2);\n    d2 = sdfRoundBoxRotated(position, vec3(0.0, -0.90, 0.1), vec3(0.5, 0.8, 0.3),\n                            vec3(PI/2.5, 0.0, 0.0), 0.0);\n    d1 = smax(d1, -d2, 0.3);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.30, -0.56, -0.40), vec3(0.38, 0.45, 0.08),\n                            vec3(-0.6, -1.3, -0.2), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.15);\n    d2 = sdfRoundBoxRotated(symPosX, vec3(0.35, -0.56, -0.50), vec3(0.58, 0.53, 0.18),\n                            vec3(-0.0, -1.1, -0.0), 0.0);\n    //d1 = smin(d1, d2, 0.1);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.1);\n    // sculpt head\n    d1 = sdfRoundBoxRotated(symPosX, vec3(0.51, 0.0, 0.0), vec3(0.07, 1.0, 1.0),\n                            vec3(0.0, 0.0, -0.1), 0.01);\n    d = smax(d, -d1, 0.1);\n    // ears\n    d1 = sdfEllipsoidRotated(symPosX, vec3(0.38, -0.15, 0.1), vec3(0.12, 0.15, 0.03),\n                             vec3(-0.3, -PI/9.9,- 0.3));\n    d2 = sdfSphere(symPosX, vec3(0.43, -0.15, 0.1), 0.001);\n    d1 = smax(d1, -d2, 0.1);\n    d = smin(d, d1, 0.01);\n\n    // eye sockets\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.04, -0.57), vec3(0.2, 0.1, 0.1),\n                            vec3(PI/4.0, 0.0, -0.0), 0.01);\n    d = smax(d, -d1, 0.2);\n    // nose\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.12, -0.45), vec3(0.005, 0.12, 0.05),\n                            vec3(0.7, 0.0, 0.0), 0.02);\n    d = smin(d, d1, 0.1);\n    d1 = sdfRoundBoxRotated(position, vec3(0.0, -0.22, -0.53), vec3(0.05, 0.005, 0.05),\n                            vec3(0.0, PI/4.0, 0.0), 0.0);\n    d = smin(d, d1, 0.1);\n    // mouth\n    d1 = sdfEllipsoid(vec3(symPosX.x, symPosX.y-4.9*pow(symPosX.x, 2.3), symPosX.z),\n                      vec3(0.0, -0.42, -0.5), vec3(0.15, 0.07, 0.6));\n    d = smax(d, -d1, 0.01);\n    d1 = sdfSphere(position, vec3(0.0, -0.42, -0.35), 0.13);\n    if (d1 < d) {\n        material = 6.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.36, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfJoint3DSphere(position, vec3(0.08, -0.47, -0.45),\n                          vec3(PI/2.0, -PI/1.4, 0.0),\n                          0.2, PI/4.0, 0.01).x;\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    // cheeks\n    d1 = sdfSphere(symPosX, vec3(0.2, -0.22, -0.35), 0.05);\n    d = smin(d, d1, 0.2);\n    // eyes\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.35), 0.11);\n    if (d1 < d) {\n        material = 2.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.41), 0.06);\n    if (d1 < d) {\n        material = 3.0;\n    }\n    d = smin(d, d1, 0.01);\n    d1 = sdfSphere(symPosX, vec3(0.15, -0.07, -0.445), 0.03);\n    if (d1 < d) {\n        material = 4.0;\n    }\n    d = smin(d, d1, 0.01);\n    // eye brows\n    d1 = sdfJoint3DSphere(symPosX, vec3(0.1, 0.13+0.01*sign(position.x), -0.455),\n                          vec3(0.0, -0.9, -PI/3.2),\n                          0.2, 0.9, 0.01).x;\n    if (d1 < d) {\n        material = 5.0;\n    }\n    d = smin(d, d1, 0.01);\n\n    return vec2(d, material);\n}\n\nint calculateArrow(vec3 position) {\n    // To calculate the arrow, we take the origin as 0. If facing back (z=1)\n    // is 0, we trace a circle on the yz plane, and calculate the angle made\n    // we use that to calculate the stem of the arrow, and the position of the\n    // pointyhead.\n    if (abs(position.x) > 0.20) {\n        return 0;\n    }\n    float angle = atan(position.y, position.z);\n    float maxAngle = PI-0.2;\n    float arrowAngle = PI/6.0;\n    if (-PI/2.0 < angle && angle < maxAngle) {\n        // pointy head\n        if (angle > maxAngle-arrowAngle) {\n            float rem = (angle-(maxAngle-arrowAngle)) / arrowAngle;\n            rem = -1.0 * (rem-1.0);\n            if (abs(position.x) < 0.20*rem) {\n                return 1;\n            }\n        } else if (abs(position.x) < 0.11) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvec4 distanceField(vec3 position) {\n\tvec2 d = aangHead(position);\n    return vec4(d, 0.0, 0.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    // We calculate the normal by finding the gradient of the field at the\n    // point that we are interested in. We can find the gradient by getting\n    // the difference in field at that point and a point slighttly away from it.\n    const float h = 0.0001;\n    return normalize( vec3(\n        \t\t\t       -distanceField(p).x+ distanceField(p+vec3(h,0.0,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,h,0.0)).x,\n                           -distanceField(p).x+ distanceField(p+vec3(0.0,0.0,h)).x\n    \t\t\t\t ));\n}\n\nvec4 raymarch(vec3 direction, vec3 start) {\n    // We need to cast out a ray in the given direction, and see which is\n    // the closest object that we hit. We then move forward by that distance,\n    // and continue the same process. We terminate when we hit an object\n    // (distance is very small) or at some predefined distance.\n    float far = 15.0;\n    vec3 pos = start;\n    float d = 0.0;\n    vec4 obj = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<100; i++) {\n    \tobj = distanceField(pos);\n        float dist = obj.x;\n        pos += dist*direction;\n        d += dist;\n        if (dist < 0.01) {\n        \tbreak;\n        }\n        if (d > far) {\n        \tbreak;\n        }\n    }\n    return vec4(d, obj.yzw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalise and set center to origin.\n    vec2 p = fragCoord/iResolution.xy;\n    p -= 0.5;\n    p.y *= iResolution.y/iResolution.x;\n\n    float mouseX = ((iMouse.x/iResolution.x)-0.5) * 2.0 * 3.14159/2.0;\n    mouseX = -0.3;\n    mouseX = 0.4*sin(iTime/3.6);\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 planePosition = vec3(p, 1.0) + cameraPosition;\n\n    mat2 camRotate = mat2(cos(mouseX), -sin(mouseX), sin(mouseX), cos(mouseX));\n    cameraPosition.xz = camRotate * cameraPosition.xz;\n    planePosition.xz = camRotate * planePosition.xz;\n\n    float yRotate = 0.1;\n    yRotate = 0.2*sin(iTime/4.2);\n    camRotate = mat2(cos(yRotate), -sin(yRotate), sin(yRotate), cos(yRotate));\n    cameraPosition.yz = camRotate * cameraPosition.yz;\n    planePosition.yz = camRotate * planePosition.yz;\n\n    vec3 lookingDirection = (planePosition - cameraPosition);\n\n    // This was fun to sort out, but is it the best way?\n    float lightTime = iTime/3.0;\n    float multiplier = -1.0 + (step(-0.0, sin(lightTime*3.14159)) *2.0);\n    float parabola = (4.0 * fract(lightTime) * (1.0-fract(lightTime)));\n    float lightX = multiplier*parabola *-1.2;\n    vec3 lightPoint = normalize(vec3(lightX, 1.0, -1.0));\n    vec3 lightFacing = lightPoint - vec3(0.0);\n    // lightFacing = vec3(1.0, 1.0, -0.3) - vec3(0.0);\n\n    // raymarch to check for colissions.\n    vec4 obj = raymarch(lookingDirection, planePosition);\n    float dist = obj.x;\n    vec3 color = vec3(0.01);\n    if (dist < 15.0) {\n        vec3 normal = calcNormal(planePosition+ dist*lookingDirection);\n        int arrow = calculateArrow(planePosition+ dist*lookingDirection);\n        float light = dot(lightFacing, normal);\n        light = max(light, 0.0);\n        if (obj.y < 1.5) {\n            // skin\n        \tcolor = vec3(0.505, 0.205, 0.105);\n            color += 0.3* smoothstep(0.1, 1.0, light);\n            if (arrow==1) {\n        \t    color = vec3(0.21, 0.21, 0.31);\n                color += 0.1* smoothstep(0.1, 1.0, light);\n            }\n        } else if (obj.y < 2.5) {\n            //eyes\n        \tcolor = vec3(0.75, 0.75, 0.85);\n            color += 0.1 * smoothstep(0.5, 1.0, light);\n        } else if (obj.y < 3.5) {\n        \tcolor = vec3(0.21, 0.21, 0.31);\n            color += 0.7 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 4.5) {\n        \tcolor = vec3(0.01);\n            color += 0.5 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 5.5) {\n            // eyebrows\n        \tcolor = vec3(0.05, 0.02, 0.01);\n            color += 0.05 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        } else if (obj.y < 6.5) {\n            // mouth\n        \tcolor = vec3(0.15, 0.02, 0.01);\n            color += 0.1 * smoothstep(0.4, 1.0, pow(light, 5.0));\n        }\n    }\n    // gamma correction\n    color = pow( color, vec3(1.0/2.2) );\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 157, 199, 199, 644], [645, 645, 704, 704, 754], [755, 755, 815, 815, 954], [955, 955, 1037, 1037, 1218], [1219, 1219, 1260, 1260, 1312], [1313, 1313, 1406, 1406, 1584], [1585, 1585, 1605, 1605, 1626], [1627, 1627, 1674, 1735, 1916], [1917, 1917, 2023, 2023, 2686], [2687, 2687, 2728, 2728, 2804], [2805, 2805, 2846, 2846, 2922], [2924, 2924, 2954, 2954, 6528], [6530, 6530, 6565, 6817, 7385], [7387, 7387, 7422, 7422, 7484], [7486, 7486, 7511, 7743, 8056], [8058, 8058, 8101, 8390, 8774], [8776, 8776, 8833, 8876, 11697]], "test": "untested"}
{"id": "wtcXWr", "name": "Plexus with triangles", "author": "latitude", "description": "Fork of \"The Universe Within\" (https://www.shadertoy.com/view/lscczl) by BigWIngs (https://www.shadertoy.com/user/BigWIngs)\n\nUsed triangles distance function (https://www.shadertoy.com/view/XsXSz4) by iq (https://www.shadertoy.com/user/iq)", "tags": ["plexustriangles"], "likes": 27, "viewed": 961, "published": "Public", "date": "1580814930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\n\tfloat d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\n\tvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    \tfor(float x = -1.0; x <= 1.0; x++){\n        \tp[i++] = getPos(id, vec2(x, y));\n    \t}    \n    }\n    \n    \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    \tm += line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n        \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n        \n        for(int yi= i + 1; yi < 9; yi++){\n    \t\tfor(int zi= yi + 1; zi < 9; zi++){\n                \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n                \n                if((len1 + len2 + len3) < 2.8){\n                \tm += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    \t\t}\n    \t}\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.0;\n    float t = iTime * 0.1;\n    \n    float gradient = uv.y;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n        \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n    \n    \n    vec3 base = sin(t * 5.0 * vec3(0.345, 0.456, 0.567)) * 0.4 + 0.6;\n    vec3 col = m * base;\n    \n    col -= gradient * base;\n    \n    //vec2 gv = fract(uv) - 0.5;\n    //if(gv.x > 0.48 || gv.y > 0.48){\n    //\tcol = vec3(1.0, 0.0, 0.0);\n    //}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcXWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 79, 79, 208], [210, 210, 245, 245, 418], [420, 420, 488, 488, 1097], [1099, 1099, 1146, 1146, 1326], [1328, 1328, 1346, 1346, 1443], [1445, 1445, 1462, 1462, 1515], [1517, 1517, 1551, 1551, 1626], [1628, 1628, 1649, 1649, 2743], [2745, 2745, 2802, 2802, 3587]], "test": "untested"}
{"id": "WtcXWX", "name": "Grid glow experiment", "author": "rodgzilla", "description": "glow on grid experiment", "tags": ["raymarching", "glow"], "likes": 3, "viewed": 260, "published": "Public API", "date": "1581785555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time .7 * iTime\n#define ZPOS -10.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * sin(time * tempo) + .5;\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c); \n}\n\nvec3 kifs(vec3 p) {\n    float s = 1.;\n//    float t = floor(time) + smoothstep(.0, 1., fract(time));\n  \tfloat t = time * .3;\n    for (float i = 0.; i < 1.; i++) {\n        p.xy *= rot2d(t);\n        p.yz *= rot2d(.9 * t + i * .7);\n        p = abs(p);\n        p -= s;\n//        s *= .6 + .2 * sin(time / 1.5);\n        s *= .7;\n    }\n    \n    return p;\n}\n\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n//    t = clamp(t, 0., 1.);\n    vec3 c = a + ab * t;\n    \n    return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n    vec3 q = mod(p, r) - .5 * r;\n    \n    return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n//    p.xy *= rot2d(cos(time) * sin(p.z / 3.));\n    vec3 rawP = p;\n//    p = kifs(p);\n    p = rep(p, vec3(1. + wave(.65), 2. + wave(.6), 1.5 + wave(.7)));\n    \n    float d = 5000.;\n\n//    d = min(d, sphere(p, 1.));\n    d = min(d, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), .1));\n    d = min(d, tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), .1));\n    d = min(d, tube(p, vec3(0, 0, 2), vec3(0, 0, -2), .1));\n//    d = max(d, -sphere(rawP, 10.));\n    \n    at += .05 / (.1 + 5. * d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < 0.01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds * .5;\n//        glow += .015 * at * vec3(.8, .5 * sin(time / 1.) + .5, .5 * cos(time / 5.) + .5);\n        glow += .001 * at * vec3(.8, wave(.5) * cos(.1 * p.z), 0);\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    ));\n  \n   return n;                 \n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(0, 0, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n\tvec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    vec3 col = dif * glow;\n//    vec3 col = vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcXWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 91, 91, 133], [135, 135, 156, 156, 228], [230, 230, 249, 249, 580], [583, 583, 614, 614, 642], [644, 644, 689, 689, 862], [864, 864, 890, 890, 944], [961, 961, 980, 1028, 1470], [1493, 1493, 1521, 1521, 1930], [1932, 1932, 1952, 1952, 2137], [2139, 2139, 2160, 2160, 2412], [2414, 2414, 2471, 2471, 2879]], "test": "untested"}
{"id": "WtdSD7", "name": "pattern of scales", "author": "jiaolyulu1", "description": "I tried to build scale like shape usinguv grids. Actutally the inspiration is Art of Code's video of teaching how to make hexagonal tiling. https://www.shadertoy.com/view/3sSGWt", "tags": ["2d", "pattern", "scale", "wallpaper"], "likes": 5, "viewed": 121, "published": "Public", "date": "1581103531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//inspired by https://www.shadertoy.com/view/3sSGWt\n//which is made by Art of Code, teaching about how to make hexagonal tiling\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n\t\n    uv *=8.;\n    \n   // uv.y+=0.01*sin(fract(212.*uv.y)*231.);\n    vec2 offset = vec2(1.7,1.);\n    //creating 2 grid that offset with each other\n    vec2 st1 = mod(uv,offset)-vec2(0.5*offset.x,0.);\n    vec2 st2 = mod(uv+0.5*vec2(offset.x,-offset.y),offset)-vec2(0.5*offset.x,0.);\n    st1.x=abs(st1.x);\n    st2.x=abs(st2.x);\n    float a= length(st1);\n    float b= length(st2);\n    vec2 gv;//this will record the vector which grid this pixel belongs to\n    vec2 st;//this will translate the Cartesian coordinate system into polor coordinate system\n    int i=0;\n    float r=1.;\n    \n    st1.x*=0.5*abs(sin(iTime*1.5))+0.5;\n    st2.x*=-0.5*abs(sin(iTime*1.5))+1.1;\n    \n    //the grid is now created and distinguished\n    if (b>r){\n    \tgv=vec2(atan(st1.y,st1.x),a);\n        st= st1;\n    }\n    else{ \n        if (atan(st2.y,st2.x)<3.14/6.||((a<r)&&(st2.y<0.5)))\n        {\n            gv=vec2(atan(st1.y,st1.x),a);\n            st=st1;\n        }\n        else{\n        \tgv=vec2(atan(st2.y,st2.x),b);\n            i=1;\n            st=st2;\n        }\n    }\n    \n    //try to figure out the mouse position and its belonging grid id\n    vec2 mouse =(iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 mid= floor(mouse/offset);\n    vec2 id= floor((uv)/offset);\n    if (i==1){\n        mid = floor((mouse)/offset-0.5)+vec2(0.5);\n    \tid =floor((uv)/offset-0.5)+vec2(0.5);\n    }\n    \n    id-=mouse;\n    \n    //applying color onto the grid\n    vec4 col = 1.0*texture(iChannel0,vec2(gv.x,gv.y*5.)-vec2(0.,0.3*iTime)+id*3.7)+0.05+(id.x+id.y)*0.05;\n    float s=fract(id.x)-0.2;\n    col*=vec4(0.6+s*0.5,0.6+s*0.3,0.7-s*0.3,1.)*1.2*sqrt(abs(sin(0.1*iTime))*smoothstep(0.5,1.0,gv.x)+1.4*abs(cos(0.1*iTime))*smoothstep(0.0,0.6,gv.y))+.3;\n\t\n    \n    //if you want to see the grid, uncomment the following sentence\n    // col=vec4(id*0.2+0.5,0.,1.);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 129, 186, 236, 2174]], "test": "untested"}
{"id": "WtdSDj", "name": "Segment - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "segment"], "likes": 5, "viewed": 689, "published": "Public API", "date": "1581747052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a segment. Probably faster than\n// central differences or automatic differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    \n    return vec3(d,q/d);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        vec2 v1 = 0.8*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n        vec2 v2 = 0.8*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n        float th = 0.15*(0.5+0.5*sin(iTime*1.2+2.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgSegment(p,v1,v2);\n        float d = dg.x - th;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSDj.jpg", "access": "shaders20k", "license": "mit", "functions": [[1399, 1494, 1546, 1546, 1719], [1735, 1735, 1792, 1792, 3025]], "test": "untested"}
{"id": "WtdSDs", "name": "2D Rounded Rectangle", "author": "amine_sebastian", "description": "This was based on a number of other examples I found on this website. I required a shader for drawing a GUI and figured I'd share it with others who might be looking! The location represents the bottom left of the rectangle.", "tags": ["2d", "square", "rectangle", "quad", "rounded"], "likes": 1, "viewed": 1359, "published": "Public", "date": "1581978652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat roundedBoxSDF(vec2 CenterPosition, vec2 Size, float Radius) {\n    return length(max(abs(CenterPosition)-Size+Radius,0.0))-Radius;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // The pixel space scale of the rectangle.\n    vec2 size = vec2(300.0f, 300.0f);\n    \n    // the pixel space location of the rectangle.\n    vec2 location = iMouse.xy;\n\n    // How soft the edges should be (in pixels). Higher values could be used to simulate a drop shadow.\n    float edgeSoftness  = 1.0f;\n    \n    // The radius of the corners (in pixels).\n    float radius = (sin(iTime) + 1.0f) * 30.0f;\n    \n    // Calculate distance to edge.   \n    float distance \t\t= roundedBoxSDF(fragCoord.xy - location - (size/2.0f), size / 2.0f, radius);\n    \n    // Smooth the result (free antialiasing).\n    float smoothedAlpha =  1.0f-smoothstep(0.0f, edgeSoftness * 2.0f,distance);\n    \n    // Return the resultant shape.\n    vec4 quadColor\t\t= mix(vec4(1.0f, 1.0f, 1.0f, 1.0f), vec4(0.0f, 0.2f, 1.0f, smoothedAlpha), smoothedAlpha);\n    \n    // Apply a drop shadow effect.\n    float shadowSoftness = 30.0f;\n    vec2 shadowOffset \t = vec2(0.0f, 10.0f);\n    float shadowDistance = roundedBoxSDF(fragCoord.xy - location + shadowOffset - (size/2.0f), size / 2.0f, radius);\n    float shadowAlpha \t = 1.0f-smoothstep(-shadowSoftness, shadowSoftness, shadowDistance);\n    vec4 shadowColor \t = vec4(0.4f, 0.4f, 0.4f, 1.0f);\n    fragColor \t\t\t = mix(quadColor, shadowColor, shadowAlpha - smoothedAlpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 146, 146, 216], [217, 217, 274, 321, 1567]], "test": "untested"}
{"id": "wtdSR2", "name": "Sun noise", "author": "JackSolace", "description": "Simple sun texture combining multiple types of noise\n\ncould do a smoothing run after to remove the discontinuities (voronoi lines)", "tags": ["procedural", "voronoi", "noise", "sun", "gradient", "learn"], "likes": 2, "viewed": 92, "published": "Public", "date": "1581372345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Carter S. Feb 2020\n//Simple sun texture combining multiple types of noise\n\n\n#define NUM_OCTAVES 8\n\n//\tClassic Perlin 3D Noise (The OG gradient noise)\n//\tfrom Stefan Gustavson\n//\tImproving Noise, Ken Perlin http://mrl.nyu.edu/~perlin/paper445.pdf\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n//math is wack take a vector calc class lol\nfloat gnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//fractal gradient noise\nfloat fgbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;//play with this\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * gnoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat voronoi( in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2  f = fract( x );\n\n    float res = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j);\n        vec2 coords = p+b;\n        vec2  r = vec2( b )  + (0.5 + 2.0*fgbm(vec3(coords.x,coords.y,0.4 + mod(iTime/15.0,0.5)))) - f;\n        float d = dot( r, r );\n\n        res = min( res, d );\n    }\n    return sqrt( res );\n}\n\n//ad hoc noise combination\nfloat combine_noise(float v, float g) {\n\tfloat res = 1.0 - v;\n    g = (1.0 - g)*1.5;\n    res *= 1.0/g;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //get both noises\n    float voronoi_value = voronoi(8.0*uv);\n    float grad_noise = gnoise(vec3(16.0*uv,iTime/5.0));\n    \n    //shape the noise values to get sun surface effect\n    float shaped_value = combine_noise(voronoi_value, grad_noise);\n    \n    //color mapping\n\tvec3 col = vec3(shaped_value / 3.0 + 0.65, shaped_value / 2.0 + 0.3,0.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 248, 269, 269, 306], [307, 307, 334, 334, 382], [383, 383, 402, 402, 438], [440, 484, 505, 505, 2777], [2779, 2804, 2824, 2824, 3011], [3013, 3013, 3040, 3040, 3433], [3435, 3462, 3501, 3501, 3587], [3589, 3589, 3646, 3696, 4147]], "test": "untested"}
{"id": "wtdSWn", "name": "My Curl Noise", "author": "DonKarlssonSan", "description": "curl", "tags": ["noise", "curl"], "likes": 6, "viewed": 191, "published": "Public", "date": "1580844744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simplex 2D noise\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvec2 curl(vec2 source)\n{\n\tfloat eps = 1.0; \n    float n1, n2, a, b;\n    \n\tn1 = snoise(source + vec2(0, eps)); \n    n2 = snoise(source - vec2(0, eps)); \n    a = (n1 - n2)/(2.0 * eps);\n    \n\tn1 = snoise(source + vec2(eps, 0)); \n    n2 = snoise(source - vec2(eps, 0)); \n    b = (n1 - n2)/(2.0 * eps);\n    \n\tvec2 curl = vec2(a, -b); \n    \n    return curl;\n}\n\nvec3 curl3(float x, float y, float z) {\n\tfloat eps = 1.0; \n    float n1, n2, a, b; \n    vec3 curl;\n    \n\tn1 = snoise(vec3(x, y + eps, z)); \n    n2 = snoise(vec3(x, y - eps, z)); \n    a = (n1 - n2)/(2.0 * eps);\n\tn1 = snoise(vec3(x, y, z + eps)); \n    n2 = snoise(vec3(x, y, z - eps)); \n    b = (n1 - n2)/(2.0 * eps);\n\tcurl.x = a - b;\n    \n\tn1 = snoise(vec3(x, y, z + eps)); \n    n2 = snoise(vec3(x, y, z - eps)); \n    a = (n1 - n2)/(2.0 * eps);\n\tn1 = snoise(vec3(x + eps, y, z)); \n    n2 = snoise(vec3(x + eps, y, z)); \n    b = (n1 - n2)/(2.0 * eps);\n\tcurl.y = a - b;\n    \n\tn1 = snoise(vec3(x + eps, y, z)); \n    n2 = snoise(vec3(x - eps, y, z)); \n    a = (n1 - n2)/(2.0 * eps);\n\tn1 = snoise(vec3(x, y + eps, z)); \n    n2 = snoise(vec3(x, y - eps, z)); \n    b = (n1 - n2)/(2.0 * eps);\n\tcurl.z = a - b; \n    \n    return curl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //uv += sin(iTime / 10.0);\n    float x = snoise(uv * 2.0);\n    float y = snoise(uv * 3.0 + 1000.0);\n    float z = snoise(uv * 5.0 + 8000.0);\n     \n\tvec3 c = curl3(x + iTime / 10.0, y + iTime / 10.0, z + iTime / 10.0);\n\t//vec2 c = curl(vec2(uv.x + iTime / 10.0, uv.y - iTime / 10.0));\n\t\n    fragColor = vec4(c.x, c.y, c.z, 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 116, 116, 155], [157, 157, 178, 178, 998], [1001, 1055, 1076, 1076, 1125], [1127, 1127, 1149, 1149, 1189], [1191, 1191, 1218, 1218, 1266], [1268, 1268, 1289, 1289, 3139], [3142, 3142, 3166, 3166, 3495], [3497, 3497, 3536, 3536, 4322], [4324, 4324, 4381, 4431, 4897]], "test": "untested"}
{"id": "wtdSWs", "name": "Basic Fractal Zero Sin", "author": "PauloFalcao", "description": "Sin Distortion makes everything more beautiful... :D\nA variation of https://www.shadertoy.com/view/tltSWs\n", "tags": ["2d", "fractal"], "likes": 6, "viewed": 256, "published": "Public API", "date": "1581984779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Basic Fractal Sin by @paulofalcao\n\nconst int maxIterations=8;\n\n//generic rotation formula\nvec2 rot(vec2 uv,float a){\n    float c=cos(a);float s=sin(a);\n    return uv*mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t//normalize stuff\n\tvec2 uv=iResolution.xy;uv=-.5*(uv-2.0*fragCoord.xy)/uv.x;\n\n\t//global zoom\n\tuv*=sin(iTime)*2.5+5.5;\n\n\t//shift, mirror, rotate and scale 6 times...\n\tfor(int i=0;i<maxIterations;i++){\n        uv*=1.5;                        //<-Scale\n        uv=rot(uv,iTime);               //<-Rotate\n        uv+=sin(uv*sin(iTime)*8.0)*0.1; //<-Sin Distortion\n\t\tuv=abs(uv);                     //<-Mirror\n        uv-=0.5;                        //<-Shift\n\t}\n\n\t//draw a circle\n\tfloat c=length(uv)>0.2?0.0:1.0;\t\n\n\tfragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 92, 118, 118, 185], [187, 187, 243, 262, 787]], "test": "untested"}
{"id": "wtdSzB", "name": "Inversion", "author": "mariandev", "description": "https://www.youtube.com/watch?v=bJOuzqu3MUQ&t=1637s", "tags": ["inversion"], "likes": 1, "viewed": 63, "published": "Public", "date": "1581271960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Invert(vec2 point, vec2 center, float radius) {\n\tvec2 v = point - center;\n    float iLen = length(v);\n    float nLen = radius * radius / iLen;\n    float pLen = nLen / iLen;\n    vec2 invertedPoint = center + v * pLen;\n    \n    return invertedPoint;\n}\n\nfloat circle(vec2 uv) {\n\tfloat len = length(uv);\n    \n    float m = .1;\n    float M = .09;\n    \n    return smoothstep(m, M, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec2 iuv = Invert(uv, vec2(0), .25);\n    \n    vec2 offs = vec2(0, sin(iTime*.5)*.5);\n    \n    col.x = circle(uv + offs);\n    col.y = circle(iuv + offs);\n    \n    //col.xy = mix(uv, iuv, sin(iTime)*.5+.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 254], [256, 256, 279, 279, 387], [389, 389, 446, 496, 891]], "test": "untested"}
{"id": "wtdSzX", "name": "Minimal Hexagonal Shader/Grid", "author": "leftofzen", "description": "Based on https://www.shadertoy.com/view/Xljczw, but actually a minimal example; no superfluous shading or colouring. See that shader for more info.", "tags": ["hexagonalgrid"], "likes": 9, "viewed": 816, "published": "Public API", "date": "1581469312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define FLAT_TOP_HEXAGON\n\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 s = vec2(1.7320508, 1);\n#else\nconst vec2 s = vec2(1, 1.7320508);\n#endif\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453);\n}\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p)\n{    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, s*.5), p.y); // Hexagon.\n    #else\n    return max(dot(p, s*.5), p.x); // Hexagon.\n    #endif    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p)\n{    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Aspect correct screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, translating, then converting it to a hexagonal grid cell coordinate and\n    // a unique coordinate ID. The resultant vector contains everything you need to produce a\n    // pretty pattern, so what you do from here is up to you.\n    vec4 h = getHex(u*5. + s.yx*iTime/2.);\n    \n    // The beauty of working with hexagonal centers is that the relative edge distance will simply \n    // be the value of the 2D isofield for a hexagon.\n    float eDist = hex(h.xy); // Edge distance.\n\n    // Initiate the background to a white color, putting in some dark borders.\n    vec3 col = mix(vec3(1.), vec3(0), smoothstep(0., .03, eDist - .5 + .04));    \n    fragColor = vec4(col, 1);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdSzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 316, 338, 338, 404], [406, 735, 757, 757, 931], [933, 1625, 1646, 2025, 2863], [2865, 2865, 2920, 2962, 3715]], "test": "untested"}
{"id": "WtdXRB", "name": "Procgen Planet With IQ's Color1", "author": "soundmasteraj", "description": "Procedural generation of a gas-like planet using fbm / domain warping. + Inigo's pallete color(t) = a + b ⋅ cos[ 2π(c⋅t+d)]", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 20, "viewed": 494, "published": "Public API", "date": "1581237102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Procgen Planet\" by kchnkrml. https://shadertoy.com/view/tltXWM\n// 2020-02-09 06:37:49\n\n// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n//#define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift; // 1.618\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    vec3 a = vec3(0.5, .25+(sin(iTime*.1)-.25+.25), 0.5)*.5;\n    vec3 b = vec3(0.5, 0.5, 0.5)*.5;\n    vec3 c = vec3(1.0, 1.0, 1.0)*.5;\n\tvec3 d = vec3(0.00, 0.33, 0.67)*.5;\n    \n    // iq's palette http://iquilezles.org/www/articles/palettes/palettes.htm\n    // Signature == palette(iTime, vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    // iq's rainbow\n\t// palette( a=vec3(0.5, 0.5, 0.5), b=vec3(0.5, 0.5, 0.5), c=vec3(1.0, 1.0, 1.0), d=vec3(0.00, 0.33, 0.67))\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top =  palette(iTime *  .11 ,  a,  b, c,  d )*.5;\n    vec3 col_bot =  palette(iTime *  .115,  a,  b, c,  d )*.5;\n    vec3 col_mid1 = palette(iTime * .1135,  a,  b, c,  d )*.33;\n    vec3 col_mid2 = palette(iTime *-.1135,  d,  c, b,  a )*.33;\n    vec3 col_mid3 = palette(iTime *-.114 ,  c,  d, c,  b )*.33;\n    \n\t// original colors    \n    // vec3 col_top = vec3(0.0, 0.5, 0.0);\n\t// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n\t// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n\t// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n\t// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1156, 1230, 1251, 1251, 1318], [1320, 1320, 1341, 1341, 1924], [1926, 1926, 1945, 1945, 2130], [2132, 2402, 2425, 2425, 2441], [2442, 2442, 2472, 2472, 2503], [2505, 2580, 2636, 2636, 2910], [2912, 2944, 2965, 2965, 3003], [3005, 3044, 3116, 3116, 3159], [3161, 3161, 3200, 3237, 6590], [6592, 6592, 6648, 6648, 7134]], "test": "untested"}
{"id": "WtdXRS", "name": "Rotating Point Teapot", "author": "BitsnBobs", "description": "Saw the shader by Zeppelin7 https://www.shadertoy.com/view/ldGBRd\nAdditional: excel parsed .obj vertices makes this a simple copy past to any model I guess\n301 points", "tags": ["points", "teapot", "vertex"], "likes": 5, "viewed": 126, "published": "Public", "date": "1581209008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/ldGBRd\n// excel parsed .obj vertices makes this a simple copy past to any model I guess\n\n\nfloat distLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nfloat drawPoint(vec3 ro, vec3 rd, vec3 p) {\n    p -= .5; // move cube to center of screen\n    float d = distLine(ro, rd, p);\n    d = smoothstep(.01, .001, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(iTime), 2., -3.*cos(iTime)); // ray origin\n    \n    vec3 lookAt = vec3(0.);\n    \n    float zoom = 1.3;\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro; // ray dir.\n    \n    float t = iTime;\n    \n    float d = 0.;\n    \n   d += drawPoint(ro, rd, vec3(\t\t\t\t0.2964\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2491\t,\t0.6011\t,\t0.1796\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2457\t,\t0.6230\t,\t0.1776\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2925\t,\t0.6230\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2562\t,\t0.6230\t,\t0.1837\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3045\t,\t0.6230\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2708\t,\t0.6011\t,\t0.1923\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3215\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1239\t,\t0.6011\t,\t0.3048\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1219\t,\t0.6230\t,\t0.3014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1281\t,\t0.6230\t,\t0.3118\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1367\t,\t0.6011\t,\t0.3265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t0.3521\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6230\t,\t0.3481\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6230\t,\t0.3602\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t0.3771\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2424\t,\t0.6011\t,\t0.3048\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2334\t,\t0.6230\t,\t0.3014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2369\t,\t0.6230\t,\t0.3118\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2451\t,\t0.6011\t,\t0.3265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3626\t,\t0.6011\t,\t0.1796\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3557\t,\t0.6230\t,\t0.1776\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3648\t,\t0.6230\t,\t0.1837\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3793\t,\t0.6011\t,\t0.1923\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4049\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4009\t,\t0.6230\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4130\t,\t0.6230\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4299\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3576\t,\t0.6011\t,\t-0.1768\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3542\t,\t0.6230\t,\t-0.1747\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3646\t,\t0.6230\t,\t-0.1809\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3793\t,\t0.6011\t,\t-0.1895\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2324\t,\t0.6011\t,\t-0.3019\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2304\t,\t0.6230\t,\t-0.2985\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2365\t,\t0.6230\t,\t-0.3090\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2451\t,\t0.6011\t,\t-0.3236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t-0.3492\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6230\t,\t-0.3453\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6230\t,\t-0.3573\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t-0.3743\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1239\t,\t0.6011\t,\t-0.3019\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1219\t,\t0.6230\t,\t-0.2985\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1281\t,\t0.6230\t,\t-0.3090\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1367\t,\t0.6011\t,\t-0.3236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2491\t,\t0.6011\t,\t-0.1768\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2457\t,\t0.6230\t,\t-0.1747\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2562\t,\t0.6230\t,\t-0.1809\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2708\t,\t0.6011\t,\t-0.1895\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3230\t,\t0.4703\t,\t0.2230\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3817\t,\t0.4703\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3631\t,\t0.3437\t,\t0.2465\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.4281\t,\t0.3437\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3792\t,\t0.2254\t,\t0.2560\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.4467\t,\t0.2254\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1673\t,\t0.4703\t,\t0.3786\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1909\t,\t0.3437\t,\t0.4188\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2003\t,\t0.2254\t,\t0.4348\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.4703\t,\t0.4374\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.3437\t,\t0.4838\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.2254\t,\t0.5024\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2758\t,\t0.4703\t,\t0.3786\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2994\t,\t0.3437\t,\t0.4188\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3088\t,\t0.2254\t,\t0.4348\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4315\t,\t0.4703\t,\t0.2230\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4716\t,\t0.3437\t,\t0.2465\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4876\t,\t0.2254\t,\t0.2560\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4902\t,\t0.4703\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5366\t,\t0.3437\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5552\t,\t0.2254\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4315\t,\t0.4703\t,\t-0.2201\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4716\t,\t0.3437\t,\t-0.2437\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4876\t,\t0.2254\t,\t-0.2531\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2758\t,\t0.4703\t,\t-0.3758\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2994\t,\t0.3437\t,\t-0.4159\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3088\t,\t0.2254\t,\t-0.4320\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.4703\t,\t-0.4346\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.3437\t,\t-0.4809\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.2254\t,\t-0.4995\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1673\t,\t0.4703\t,\t-0.3758\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1909\t,\t0.3437\t,\t-0.4159\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2003\t,\t0.2254\t,\t-0.4320\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3230\t,\t0.4703\t,\t-0.2201\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3631\t,\t0.3437\t,\t-0.2437\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3792\t,\t0.2254\t,\t-0.2531\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3511\t,\t0.1308\t,\t0.2395\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.4142\t,\t0.1308\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2989\t,\t0.0696\t,\t0.2088\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3539\t,\t0.0696\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2708\t,\t0.0376\t,\t0.1923\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3215\t,\t0.0376\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1838\t,\t0.1308\t,\t0.4067\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1532\t,\t0.0696\t,\t0.3546\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1367\t,\t0.0376\t,\t0.3265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.1308\t,\t0.4699\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0696\t,\t0.4096\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0376\t,\t0.3771\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2923\t,\t0.1308\t,\t0.4067\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2616\t,\t0.0696\t,\t0.3546\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2451\t,\t0.0376\t,\t0.3265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4595\t,\t0.1308\t,\t0.2395\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4074\t,\t0.0696\t,\t0.2088\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3793\t,\t0.0376\t,\t0.1923\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5227\t,\t0.1308\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4624\t,\t0.0696\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4299\t,\t0.0376\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4595\t,\t0.1308\t,\t-0.2366\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4074\t,\t0.0696\t,\t-0.2060\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3793\t,\t0.0376\t,\t-0.1895\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2923\t,\t0.1308\t,\t-0.4039\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2616\t,\t0.0696\t,\t-0.3517\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2451\t,\t0.0376\t,\t-0.3236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.1308\t,\t-0.4670\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0696\t,\t-0.4067\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0376\t,\t-0.3743\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1838\t,\t0.1308\t,\t-0.4039\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1532\t,\t0.0696\t,\t-0.3517\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1367\t,\t0.0376\t,\t-0.3236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3511\t,\t0.1308\t,\t-0.2366\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2989\t,\t0.0696\t,\t-0.2060\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2708\t,\t0.0376\t,\t-0.1895\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2552\t,\t0.0195\t,\t0.1831\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3034\t,\t0.0195\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1673\t,\t0.0056\t,\t0.1315\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2018\t,\t0.0056\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0000\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1275\t,\t0.0195\t,\t0.3108\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0759\t,\t0.0056\t,\t0.2229\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0195\t,\t0.3590\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0056\t,\t0.2575\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2360\t,\t0.0195\t,\t0.3108\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1843\t,\t0.0056\t,\t0.2229\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3636\t,\t0.0195\t,\t0.1831\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2758\t,\t0.0056\t,\t0.1315\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4118\t,\t0.0195\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3103\t,\t0.0056\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3636\t,\t0.0195\t,\t-0.1803\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2758\t,\t0.0056\t,\t-0.1287\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2360\t,\t0.0195\t,\t-0.3080\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1843\t,\t0.0056\t,\t-0.2201\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0195\t,\t-0.3562\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.0056\t,\t-0.2546\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1275\t,\t0.0195\t,\t-0.3080\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0759\t,\t0.0056\t,\t-0.2201\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2552\t,\t0.0195\t,\t-0.1803\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1673\t,\t0.0056\t,\t-0.1287\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4550\t,\t0.5072\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4485\t,\t0.5218\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6132\t,\t0.5192\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6043\t,\t0.5051\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7151\t,\t0.5008\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6980\t,\t0.4905\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7500\t,\t0.4508\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7305\t,\t0.4508\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4364\t,\t0.5489\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6298\t,\t0.5453\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7468\t,\t0.5199\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7861\t,\t0.4508\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4299\t,\t0.5635\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6387\t,\t0.5594\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7639\t,\t0.5301\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.8056\t,\t0.4508\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4364\t,\t0.5489\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6298\t,\t0.5453\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7468\t,\t0.5199\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7861\t,\t0.4508\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.4485\t,\t0.5218\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6132\t,\t0.5192\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7151\t,\t0.5008\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7500\t,\t0.4508\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7292\t,\t0.3699\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7129\t,\t0.3799\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6637\t,\t0.2819\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6563\t,\t0.2964\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5487\t,\t0.2059\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7596\t,\t0.3515\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6776\t,\t0.2552\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5366\t,\t0.1698\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7759\t,\t0.3416\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6850\t,\t0.2407\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5301\t,\t0.1503\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7596\t,\t0.3515\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6776\t,\t0.2552\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5366\t,\t0.1698\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.7292\t,\t0.3699\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.6637\t,\t0.2819\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.5487\t,\t0.2059\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.3569\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.3033\t,\t0.1116\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5317\t,\t0.3693\t,\t0.0939\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5144\t,\t0.4035\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5843\t,\t0.4916\t,\t0.0609\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5626\t,\t0.5044\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6610\t,\t0.6011\t,\t0.0432\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6220\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.2038\t,\t0.1116\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5639\t,\t0.3056\t,\t0.0939\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6245\t,\t0.4678\t,\t0.0609\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7333\t,\t0.6011\t,\t0.0432\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.1503\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5812\t,\t0.2713\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6461\t,\t0.4550\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7723\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.2038\t,\t-0.1088\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5639\t,\t0.3056\t,\t-0.0910\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6245\t,\t0.4678\t,\t-0.0581\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7333\t,\t0.6011\t,\t-0.0403\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.3715\t,\t0.3033\t,\t-0.1088\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5317\t,\t0.3693\t,\t-0.0910\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.5843\t,\t0.4916\t,\t-0.0581\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6610\t,\t0.6011\t,\t-0.0403\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6866\t,\t0.6147\t,\t0.0388\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6452\t,\t0.6136\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6927\t,\t0.6150\t,\t0.0308\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6573\t,\t0.6136\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6730\t,\t0.6011\t,\t0.0265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6471\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7634\t,\t0.6167\t,\t0.0388\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7586\t,\t0.6175\t,\t0.0308\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7213\t,\t0.6011\t,\t0.0265\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.8047\t,\t0.6178\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7941\t,\t0.6188\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7472\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7634\t,\t0.6167\t,\t-0.0360\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7586\t,\t0.6175\t,\t-0.0279\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.7213\t,\t0.6011\t,\t-0.0236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6866\t,\t0.6147\t,\t-0.0360\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6927\t,\t0.6150\t,\t-0.0279\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.6730\t,\t0.6011\t,\t-0.0236\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0245\t,\t0.7681\t,\t0.0477\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0367\t,\t0.7681\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.7890\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0029\t,\t0.7222\t,\t0.0316\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0051\t,\t0.7222\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0109\t,\t0.6762\t,\t0.0269\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0041\t,\t0.6762\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0079\t,\t0.7681\t,\t0.0801\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0240\t,\t0.7222\t,\t0.0528\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0288\t,\t0.6762\t,\t0.0448\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.7681\t,\t0.0923\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.7222\t,\t0.0608\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6762\t,\t0.0515\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1005\t,\t0.7681\t,\t0.0801\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0845\t,\t0.7222\t,\t0.0528\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0797\t,\t0.6762\t,\t0.0448\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1329\t,\t0.7681\t,\t0.0477\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1056\t,\t0.7222\t,\t0.0316\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0976\t,\t0.6762\t,\t0.0269\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1451\t,\t0.7681\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1136\t,\t0.7222\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1043\t,\t0.6762\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1329\t,\t0.7681\t,\t-0.0449\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1056\t,\t0.7222\t,\t-0.0288\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0976\t,\t0.6762\t,\t-0.0240\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1005\t,\t0.7681\t,\t-0.0773\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0845\t,\t0.7222\t,\t-0.0500\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0797\t,\t0.6762\t,\t-0.0419\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.7681\t,\t-0.0895\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.7222\t,\t-0.0579\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6762\t,\t-0.0487\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0079\t,\t0.7681\t,\t-0.0773\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0240\t,\t0.7222\t,\t-0.0500\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0288\t,\t0.6762\t,\t-0.0419\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0245\t,\t0.7681\t,\t-0.0449\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0029\t,\t0.7222\t,\t-0.0288\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0109\t,\t0.6762\t,\t-0.0240\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0702\t,\t0.6484\t,\t0.0745\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0895\t,\t0.6484\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1753\t,\t0.6289\t,\t0.1362\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2111\t,\t0.6289\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2275\t,\t0.6011\t,\t0.1669\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2714\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0188\t,\t0.6484\t,\t0.1258\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0806\t,\t0.6289\t,\t0.2310\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1112\t,\t0.6011\t,\t0.2831\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6484\t,\t0.1452\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6289\t,\t0.2667\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t0.3270\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1273\t,\t0.6484\t,\t0.1258\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1891\t,\t0.6289\t,\t0.2310\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2197\t,\t0.6011\t,\t0.2831\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1786\t,\t0.6484\t,\t0.0745\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2838\t,\t0.6289\t,\t0.1362\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3359\t,\t0.6011\t,\t0.1669\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1980\t,\t0.6484\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3195\t,\t0.6289\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3798\t,\t0.6011\t,\t0.0014\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1786\t,\t0.6484\t,\t-0.0716\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2838\t,\t0.6289\t,\t-0.1334\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.3359\t,\t0.6011\t,\t-0.1640\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1273\t,\t0.6484\t,\t-0.1230\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.1891\t,\t0.6289\t,\t-0.2281\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.2197\t,\t0.6011\t,\t-0.2803\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6484\t,\t-0.1424\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6289\t,\t-0.2639\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t-0.0542\t,\t0.6011\t,\t-0.3242\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0188\t,\t0.6484\t,\t-0.1230\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0806\t,\t0.6289\t,\t-0.2281\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1112\t,\t0.6011\t,\t-0.2803\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.0702\t,\t0.6484\t,\t-0.0716\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.1753\t,\t0.6289\t,\t-0.1334\t));\nd += drawPoint(ro, rd, vec3(\t\t\t\t0.2275\t,\t0.6011\t,\t-0.1640\t));\n\n    \n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 133, 175, 175, 226], [228, 228, 271, 271, 402], [404, 404, 461, 461, 19638]], "test": "untested"}
{"id": "wtdXz4", "name": "Stellar magnetic field (short)", "author": "FabriceNeyret2", "description": "Shortened version of  \"Stellar magnetic field\" by tdhooper. [url]https://shadertoy.com/view/3lc3WN[/url]\nAt first for me to better understand ( via holistic view of equations gathered in one window ).\n\nRemaining questions in [...] in comments\n", "tags": ["field", "magnetic"], "likes": 3, "viewed": 266, "published": "Public API", "date": "1580547115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shortened version of \"Stellar magnetic field\" by tdhooper. https://shadertoy.com/view/3lc3WN\n// Even shorter version: https://www.shadertoy.com/view/ttdSRN\n\n#define SC(a)    vec2( sin(a), cos(a) )\n#define H(n)   ( fract(sin(n) * 4e5 )*2. - 1. )\n#define R        iResolution.xy\n\nfloat Velocity(vec2 p) {            // --- adding complex poles. returns Arg(result)\n  \tvec2  f; // , V = vec2(0);      //    [ how is this a \"velocity\" ? is it holomorphic ]\n  \tfloat j = 0., N = 15.;\n  \tfor (float i=0.,s=-1.; i < N; i++, s=-s )\n        f  = p - SC( 6.28 * ( i +  H(i/N)/2. + H(i+1.)*(iTime+23.78e3) ) / N ),\n        j += s* atan(f.x, f.y);\n     // V -= s* f/dot(f,f);\n    return j;                       // CORRECT_STREAMLINES\n  //return atan(V.x, V.y);\n}\n\n// --- [ what kind of derivative is this ? looks like an extension of ||complex derivative|| ]\n //    [ is Velocity not holomorphic ?  And why this stange FD pattern ? ]\n#define L(i,j)       length( SC(a) - SC( Velocity( p + vec2(i,j) *2./R.x ) ) )\n#define Derivative(a, p)   ( L(0,1) + L(1,0) + L(1,1) + L(1,-1) ) / 4.\n\nvoid mainImage( out vec4 O, vec2 U )      // --------------------------\n{\n    vec2  p = 3.* (2.*U - R) / R.x;\n    float s = 1./30.,                                   // 1./ number or radial iso lines\n          a = Velocity(p),\n          d = Derivative(a, p); // very close to below without wrap glitch :\n       // d = fwidth(a/6.28);  if (d>.5) d--; d*=1.2;   // trying to kill the glitch\n   // vec2 D = abs(vec2(dFdx(a/6.28),dFdy(a/6.28)));    // done !\n   // d = 1.6*length(D-step(.5,D));\n    \n    a = abs( mod( a/6.28, s ) *2. -s );                 // isolines\n    a = clamp( a/d - R.x/2e3 ,0.,1.);\n  //a = mod( a/6.28 , s ) ;                             // isolines\n  //a = clamp( 2.*min(a,s-a)/d - R.x/2e3 ,0.,1.);\n    d = length(p) - 1.;                                 // central disk\n    a = mix( 1.-a, a, clamp(d/fwidth(d),0.,1.)) ;\n    O = vec4( pow( a , 1./2.2 ) );                      // to sRGB\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 281, 305, 365, 754], [756, 1077, 1150, 1150, 1987]], "test": "untested"}
{"id": "WtdXz7", "name": "Normals and Lighting", "author": "HenriPK", "description": "An SDF scene with normals applied!", "tags": ["sdf", "lighting", "normals"], "likes": 4, "viewed": 58, "published": "Public", "date": "1580662419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#version 400 core\n\nuniform float time;\nuniform vec2 resolution;\n\n/* Default is pointing X+ in rectangular coordinates.\n\nIncreasing X rotates the screen clockwise,\n  Y rotates the screen upwards,\n    Z rotates the screen to the right.*/\nvec3 camera_rotation;\n\nconst float min_step = 0.001;\nconst int max_stepc = 300;\n\nvec3 raymarch (vec2 uv, vec3 camera_scale);\nfloat ssdf (vec3 p);\nvec3 vecFloor (vec3 inv);\nvec3 ssnormal (vec3 p);\nvec3 rotate3d(vec3 vector, vec3 rotations);\nfloat smin(float a, float b, float k);\nfloat smax(float m, float n, float k);\n\nvec2 mouseuv;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mouseuv = iMouse.xy / iResolution.xy - .5;\n   \n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec3 col = raymarch(uv - .5, vec3(1.6, 0.9, 1.0));\n\n  fragColor = vec4(col, 1.0);\n}\n\nvec3 raymarch (vec3 origin, vec3 ray)\n{\n  float dist; vec3 cray;\n\n  for(int steps = 0; steps < max_stepc; steps++)\n  {\n    float sdist = ssdf((cray));\n    dist += sdist;\n    cray = origin + (dist * ray);\n      \n    cray -=vec3(-2.2, -2.2, -2.2);\n      cray = rotate3d(cray, vec3(0.0, mouseuv.y*3.0, mouseuv.x*4.0));\n\tcray +=vec3(-2.2, -2.2, -2.2);\n\n    if(sdist <= min_step)\n    {\n      vec3 normal = ssnormal(cray);\n      vec3 light = (vec3(0.0, 0.0, 3.0));\n      vec3 lrdir = normalize(light - cray);\n      //return 1.0 - normal;\n      return  vec3(0.4, 0.4, 0.5)*(0.1 + 0.9 * dot(normal, lrdir));\n    }\n  }\n\n  return -vec3(ray);\n}\n\nvec3 raymarch (vec2 uv, vec3 camera_scale)\n{\n  vec3 ray = rotate3d(normalize(vec3(1.0, camera_scale.xy * uv)), vec3(0.0, .6, 3.95));\n  float dist; vec3 cray;\n\n  for(int steps = 0; steps < max_stepc; steps++)\n  {\n    float sdist = ssdf((cray));\n    dist += sdist;\n    cray = vec3(-0.0, -0.0, 0.0) + (dist * ray);\n      \n    cray += 2.2;\n      //cray = rotate3d(cray, vec3(0.0, mouseuv.y*3.0, mouseuv.x*4.0));\n\t\tcray = rotate3d(cray, vec3(0.0, 0.0, iTime));\n\tcray -= 2.2;\n\n    \n      \n    if(sdist <= min_step)\n    {\n      vec3 normal = ssnormal(cray);\n      vec3 light = (vec3(0.0, 0.0, 3.0));\n      vec3 lrdir = normalize(light - cray);\n      //return normal*0.5 + 0.5;\n      return  mix(vec3(0.4, 0.4, 0.5)*(0.1 + 0.9 * dot(normal, lrdir)), mix(vec3(0.4, 0.4, 0.5), raymarch(cray, reflect(ray, normal)),0.5), 0.8);\n    }\n  }\n\n  return -vec3(ray);\n}\n\nfloat ssdf (vec3 p) {\n\n  vec4 object = vec4(-2.2, -2.2, -2.2, 1.0);\n\n  float cd = distance(p.x, object.x) - object.w/2.;\n        cd = smax(cd, distance(p.y, object.y) - object.w/2., 0.3);\n        cd = smax(cd, distance(p.z, object.z) - object.w/2., 0.3);\n\n  //return (length(object.xyz - p) - object.w/2.);\n  //return cd;\n  vec3 d = (object.xyz - p);\n            d.x += 0.7*sin(iTime*2.);\n            \n  return smin(cd, (length(d) - object.w/2.*1.2), 0.5);\n    \n  //return smax(cd, -(length(object.xyz - p) - object.w/2. * 0.8 + 0.1 * sin(iTime)), 0.3);\n}\n\nvec3 ssnormal(vec3 p) {\n    return normalize(vec3(\n        ssdf(vec3(p.x + min_step, p.y, p.z)) - ssdf(vec3(p.x - min_step, p.y, p.z)),\n        ssdf(vec3(p.x, p.y + min_step, p.z)) - ssdf(vec3(p.x, p.y - min_step, p.z)),\n        ssdf(vec3(p.x, p.y, p.z  + min_step)) - ssdf(vec3(p.x, p.y, p.z - min_step))\n    ));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate3d(vec3 vector, vec3 rotations) {\n\n  mat4 rx = rotationMatrix(vec3(1.0, 0.0, 0.0), rotations.x);\n  mat4 ry = rotationMatrix(vec3(0.0, -1.0, 0.0), rotations.y);\n  mat4 rz = rotationMatrix(vec3(0.0, 0.0, -1.0), rotations.z);\n\n  return (rz * ry * rx * vec4(vector, 1.0)).xyz;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n\t\n    return vec3(smin(a.x, b.x, k), smin(a.y, b.y, k), smin(a.z, b.z, k));\n}\n\nfloat smax(float m, float n, float k) {\n    \n    float a = -m;\n    float b = -n;\n    \n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return -(mix(a, b, h) - k*h*(1.0-h));\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n\t\n    return vec3(smax(a.x, b.x, k), smax(a.y, b.y, k), smax(a.z, b.z, k));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 572, 629, 629, 808], [810, 810, 849, 849, 1443], [1445, 1445, 1489, 1489, 2294], [2296, 2296, 2317, 2317, 2851], [2853, 2853, 2876, 2876, 3168], [3170, 3170, 3215, 3215, 3839], [3841, 3841, 3885, 3885, 4126], [4128, 4128, 4167, 4167, 4258], [4260, 4260, 4296, 4296, 4374], [4376, 4376, 4415, 4415, 4555], [4557, 4557, 4593, 4593, 4671]], "test": "untested"}
{"id": "WtdXzM", "name": "japanese traditional textile pt1", "author": "yasuo", "description": "japanese traditional textile pack part1", "tags": ["textile"], "likes": 7, "viewed": 292, "published": "Public API", "date": "1580652610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 textile1(vec2 p, vec3 col, vec3 rhcol) {\n    vec2 size = vec2(0.04,0.1);\n    float rh = sdRhombus(p,size);\n    col = mix(col, rhcol,S(rh,-0.01));\n    \n    rh = sdRhombus((p+vec2(0.1,0.06))*Rot(radians(-65.0)),size);\n    col = mix(col, rhcol,S(rh,-0.01));      \n    \n    rh = sdRhombus((p+vec2(-0.1,0.06))*Rot(radians(65.0)),size);\n    col = mix(col, rhcol,S(rh,-0.01));   \n    return col;\n}\n\nvec3 jpTraditionalTex1(vec2 p, vec3 col, vec3 rhcol) {\n    vec2 pref = p;\n    \n    float scale = 1.5;\n    p*=scale;\n    p.x = mod(p.x,0.42)-0.21;\n    p.y = mod(p.y,0.22)-0.11;\n\n\tp.y = abs(p.y);\n    p.y -= 0.11;\n    col = textile1(p,col,rhcol);\n    \n    p = pref;\n    p*=scale;\n    p.x -= 0.21;\n    p.x = mod(p.x,0.42)-0.21;\n    p.y = mod(p.y,0.44)-0.22;\n    p.y = abs(p.y);\n    p.y -= 0.11;\n\tfloat rh = sdRhombus(p,vec2(0.04,0.1));\n    col = mix(col, rhcol,S(rh,-0.01));\n    \n    return col;\n}\n\nvec3 textile2(vec2 p, vec3 col, vec3 bcol){\nfloat bsize = 0.15;\n    p *= Rot(radians(45.0));\n    float b = dBox2d(p,vec2(bsize));\n    p = abs(p);\n    p.x -= 0.067;\n    p.y -= 0.067;\n    float b2 = dBox2d(p,vec2(bsize/3.0));\n    b = max(-b2,b);\n    col = mix(col, bcol,S(b,-0.01));\n    return col;\n}\n\nvec3 jpTraditionalTex2(vec2 p, vec3 col, vec3 bcol) {\n    vec2 pref = p;\n\n    float scale = 1.5;\n    p*=scale;\n    \n    p = mod(p,0.45)-0.225;\n    col = textile2(p,col,bcol);\n    \n    p = pref;\n    p*=scale;\n    p -= 0.225;\n    p = mod(p,0.45)-0.225;\n    col = textile2(p,col,bcol);\n    \n    return col;\n}\n\nvec3 jpTraditionalTex3(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    p.x = mod(p.x,0.25)-(0.25*0.5);\n    p.y = mod(p.y,0.26)-(0.26*0.5);\n    \n    float r = 0.15;\n    p = abs(p);\n    p.x -= 0.06;\n    p.y -= 0.065;\n    \n    float c = sdVesica(p*Rot(radians(-45.0)),r-0.02,r*0.63);\n    col = mix(col, ccol,S(c,0.0));\n    \n    return col;\n}\n\nvec3 textile4(vec2 p, vec3 col, vec3 ccol){\n    float r = 0.16;\n    \n    float c =sdPie(p,vec2(0.16,0.1),r);\n    c = max(-(length(p)-0.05),c);\n    col = mix(col, ccol,S(c,0.0)); \n    c =sdPie(p,vec2(0.16,0.1),r-0.02);\n    c = max(-(length(p)-0.075),c);\n    col = mix(col, vec3(1.0),S(c,0.0)); \n    c =sdPie(p,vec2(0.16,0.1),r-0.037);\n    c = max(-(length(p)-0.095),c);\n    col = mix(col, ccol,S(c,0.0)); \n    c = length(p-vec2(0.0,0.015))-0.02;\n    col = mix(col, vec3(1.0),S(c,0.0)); \n    return col;\n}\n\nvec3 jpTraditionalTex4(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    p.x = mod(p.x,0.4)-(0.2);\n    p.y = mod(p.y,0.18)-(0.09);\n    p.y +=0.085;\n    col = textile4(p,col,ccol);\n    p= pref;\n    \n    p.x += 0.2;\n    p.y -=0.085;\n    p.x = mod(p.x,0.4)-(0.2);\n    p.y = mod(p.y,0.18)-(0.09);\n    p.y +=0.085;\n    col = textile4(p,col,ccol);\n    return col;\n}\n\nvec3 textile5(vec2 p, vec3 col, vec3 ccol){\n    vec2 pref = p;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    float c = sdEllipse(p,vec2(0.04,0.06));\n    float c2 = sdEllipse((p-vec2(-0.02,-0.01))*Rot(radians(-10.0)),vec2(0.04,0.05));\n    float c3 = sdEllipse((p-vec2(0.02,-0.01))*Rot(radians(10.0)),vec2(0.04,0.05));\n    c = min(c, min(c2,c3));\n    c = max(-(length(p-vec2(0.0,-0.05))-0.04),c);\n\tcol = mix(col, ccol,S(c,0.0));\n    p = pref;\n    \n    p.x = abs(p.x);\n    p.x -= 0.13;\n    c = sdEllipse(p,vec2(0.09,0.03));\n    c2 = sdEllipse((p-vec2(-0.015,-0.015))*Rot(radians(15.0)),vec2(0.07,0.04));\n    c3 = sdEllipse((p-vec2(-0.015,0.015))*Rot(radians(-15.0)),vec2(0.07,0.04));\n    float c4 = sdEllipse(p-vec2(-0.05,0.0),vec2(0.07,0.025));\n    c = min(c, min(c2,c3));\n    c = max(-c4,c);\n    col = mix(col, ccol,S(c,0.0));\n    p = pref;\n    \n    col = mix(col, ccol,S(length(p)-0.03,0.0));\n    \n    p = abs(p);\n    \n    float b = dBox2d(p-vec2(0.0,0.23),vec2(0.05,0.045));\n    float b2 = dBox2d(p-vec2(0.35,0.0),vec2(0.05,0.045));\n    b = min(b,b2);\n    col = mix(col, ccol,S(abs(b)-0.003,0.0));\n    \n    float l = sdLine(p,vec2(0.05,0.185),vec2(0.3,0.045));\n    float l2 = sdLine(p,vec2(0.05,0.205),vec2(0.325,0.048));\n    float l3 = sdLine(p,vec2(0.05,0.225),vec2(0.355,0.048));\n    l = min(l,min(l2,l3));\n    col = mix(col, ccol,S(l-0.002,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex5(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    float scale = 1.5;\n    p*=scale;\n    \n    p.x = mod(p.x,0.7)-0.35;\n    p.y = mod(p.y,0.46)-0.23;\n    col = textile5(p,col,ccol);\n    p = pref;\n    \n    p*=scale;\n    p.x -= 0.35;\n    p.y -= 0.23;\n    p.x = mod(p.x,0.7)-0.35;\n    p.y = mod(p.y,0.46)-0.23;\n    col = textile5(p,col,ccol);\n    \n    return col;\n}\n\nvec3 textile6(vec2 p, vec3 col, vec3 ccol){\n\tfloat n = 5.0;\n    float deg = 360.0/n;\n    float startRad = radians(180.0);\n    for(float i = 0.0; i<n; i+=1.0) {\n        float rad = radians(deg*i)+startRad;\n        mat2 rot = Rot(rad);\n        float dist = 0.15;\n        float x = sin(rad)*dist;\n        float y = cos(rad)*dist;\n\n        float v = sdVesica((p+vec2(x,y))*rot,0.14,0.075);\n\t\t\n        dist = 0.07;\n        x = sin(rad)*dist;\n        y = cos(rad)*dist;\n        float e = sdEllipse((((p+vec2(x,y)))*rot),vec2(0.015,0.07));\n        v = max(-e,v);\n        col = mix(col, ccol,S(v,0.0));\n    }\n    \n    float c = length(p)-0.03;\n    col = mix(col, ccol,S(c,0.0));\n    return col;\n}\n\nvec3 textile6RepeatBg(vec2 p, vec3 col, vec3 ccol){\n    float scale = 1.5;\n    p*=scale;\n    p.x = mod(p.x,0.9)-0.45;\n    p.y = mod(p.y,0.54)-0.275;\n    col = textile6(p,col,ccol);\n    return col;\n}\n\nvec3 jpTraditionalTex6(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n\n    col = textile6RepeatBg(p,col,ccol);\n    \n    p.x -= 0.9;\n    p.y -= 0.54;\n    col = textile6RepeatBg(p,col,ccol);\n    \n    return col;\n}\n\nfloat leaf(vec2 p) {\n\tfloat c = length(p)-0.1;\n    p.x *= 0.8;\n    p.y *= 0.6;\n    float c2  = length(p-vec2(0.06,0.05))-0.08;\n    c = max(-c2,c);\n    return c;\n}\n\nvec3 textile7(vec2 p, vec3 col, vec3 ccol){\n    float n = 5.0;\n    float deg = 360.0/n;\n    float startRad = radians(180.0);\n    float ld = 1.0;\n    for(float i = 0.0; i<n; i+=1.0) {\n        float rad = radians(deg*i)+startRad;\n        mat2 rot = Rot(rad);\n        float dist = 0.11;\n        float x = sin(rad)*dist;\n        float y = cos(rad)*dist;\n\n       \tfloat l = leaf((p+vec2(x,y))*rot);\n        ld = min(ld,l);\n    }\n\n    ld = max(-( length(p)-0.05),ld);\n    col = mix(col, ccol,S(ld,0.0));\n    float c = length(p)-0.02;\n    ld = min(c,ld);\n    col = mix(col, ccol,S(ld,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex7(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n   \tfloat scale = 1.5;\n    p*=scale;\n    \n    p.x = mod(p.x,0.8)-0.4;\n    p.y = mod(p.y,0.5)-0.25;\n    col = textile7(p, col, ccol);\n    p = pref;\n    \n    p*=scale;\n    p.x -= 0.4;\n    p.y -= 0.25;\n\tp.x = mod(p.x,0.8)-0.4;\n    p.y = mod(p.y,0.5)-0.25;\n    col = textile7(p, col, ccol);\n    return col;\n}\n\nvec3 textile8(vec2 p, vec3 col, vec3 ccol){\n    float b = sdBox(p*Rot(radians(45.0)),vec2(0.05))-0.05;\n    b = max(-(length(p)-0.03),b);\n    col = mix(col, ccol,S(b,0.0));\n    return col;\n}\n\nvec3 jpTraditionalTex8(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n    p = mod(p,0.3)-0.15;\n    col = textile8(p,col,ccol);\n    p = pref;\n    \n    p -= 0.15;\n    p = mod(p,0.3)-0.15;\n    col = textile8(p,col,ccol);\n    return col;\n}\n\nvec3 textile9(vec2 p, vec3 col, vec3 ccol){\n    float b = dBox2d(p,vec2(0.1));\n    p.x = abs(p.x);\n    p.x-=0.04;\n    float b2 = dBox2d(p,vec2(0.02,0.11));\n    b = max(-b2,b);\n    col = mix(col, ccol,S(b,0.0));\n    return col;\n}\n\nvec3 textile9RepeatBg(vec2 p, vec3 col, vec3 ccol) {\n\tvec2 pref = p;\n    p.x = mod(p.x,0.45)-0.225;\n\tp.y = mod(p.y,0.45)-0.225;\n    col = textile9(p,col,ccol);\n    p = pref;\n    \n    p.y -= 0.225;\n    p.x = mod(p.x,0.45)-0.225;\n    p.y = mod(p.y,0.45)-0.225;\n    col = textile9(p*Rot(radians(90.0)),col,ccol);\n    return col;\n}\n\nvec3 jpTraditionalTex9(vec2 p, vec3 col, vec3 ccol) {\n    vec2 pref = p;\n    col = textile9RepeatBg(p,col,ccol);\n    p -= 0.225;\n    col = textile9RepeatBg(p,col,ccol);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.8,0.9,1.0);\n\tvec3 baseCol = vec3(0.0,0.3,0.5);\n    \n    uv.y -= iTime*0.1;\n    \n    float ratio = 1.0;\n    float ntextile = 9.0;\n    float scene = mod(iTime,ratio*ntextile);\n    if(scene<ratio) {\n        col = jpTraditionalTex1(uv,col,baseCol);\n    } else if(scene>=ratio && scene<ratio*2.0){\n        col = jpTraditionalTex2(uv,col,baseCol);\n    } else if(scene>=ratio*2.0 && scene<ratio*3.0){\n        col = jpTraditionalTex3(uv,col,baseCol);\n    } else if(scene>=ratio*3.0 && scene<ratio*4.0){\n        col = jpTraditionalTex4(uv,col,baseCol);\n    } else if(scene>=ratio*4.0 && scene<ratio*5.0){\n        col = jpTraditionalTex5(uv,col,baseCol);\n    } else if(scene>=ratio*5.0 && scene<ratio*6.0){\n        col = jpTraditionalTex6(uv,col,baseCol);\n    } else if(scene>=ratio*6.0 && scene<ratio*7.0){\n        col = jpTraditionalTex7(uv,col,baseCol);\n    } else if(scene>=ratio*7.0 && scene<ratio*8.0){\n        col = jpTraditionalTex8(uv,col,baseCol);\n    } else if(scene>=ratio*8.0 && scene<ratio*9.0){\n        col = jpTraditionalTex9(uv,col,baseCol);\n    }\n    \n    /*\n    col = vec3(0.8,0.9,1.0);\n    col = jpTraditionalTex6(uv,col,vec3(0.0,0.3,0.5));\n\t*/\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 274, 303, 303, 331], [333, 333, 363, 363, 413], [415, 415, 452, 452, 536], [538, 538, 587, 587, 761], [763, 763, 805, 805, 962], [964, 964, 1006, 1006, 1201], [1203, 1203, 1245, 1245, 2267], [2269, 2269, 2318, 2318, 2437], [2439, 2439, 2484, 2484, 2834], [2836, 2836, 2890, 2890, 3329], [3331, 3331, 3374, 3374, 3629], [3631, 3631, 3684, 3684, 3936], [3938, 3938, 3991, 3991, 4283], [4285, 4285, 4328, 4328, 4788], [4790, 4790, 4843, 4843, 5154], [5156, 5156, 5199, 5199, 6519], [6521, 6521, 6574, 6574, 6908], [6910, 6910, 6953, 6953, 7598], [7600, 7600, 7651, 7651, 7798], [7800, 7800, 7853, 7853, 8014], [8016, 8016, 8036, 8036, 8178], [8180, 8180, 8223, 8223, 8781], [8783, 8783, 8836, 8836, 9160], [9162, 9162, 9205, 9205, 9351], [9353, 9353, 9406, 9406, 9591], [9593, 9593, 9636, 9636, 9821], [9823, 9823, 9875, 9875, 10150], [10152, 10152, 10205, 10205, 10338], [10340, 10340, 10397, 10397, 11675]], "test": "untested"}
{"id": "wtdXzN", "name": "jupiterCloud-cloud", "author": "feefi", "description": "simple cloud with multiple layer noise", "tags": ["noise", "cloud"], "likes": 13, "viewed": 244, "published": "Public", "date": "1582452438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p){\n    float v  = dot(p,vec2(123.2,45.1));\n    return fract(sin(v)*438.545312);\n}\n\nfloat Noise(vec2 p){\n    vec2 f = fract(p);\n    vec2 id = floor(p);\n    float a = N21(id);\n    float b = N21(id + vec2(1.,0.));\n    float c = N21(id + vec2(0.,1.));\n    float d = N21(id + vec2(1.,1.));\n    f = smoothstep(vec2(0.0),vec2(1.0),f);\n    return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);\n}\nfloat fbm(vec2 p){\n    float n = Noise(p*4.-vec2(iTime*0.1,0));\n    n += Noise(p*8.+vec2(iTime*0.3,0))*0.5;\n    n+= Noise(p*16.-vec2(iTime*0.5,0))*0.25;\n\tn+= Noise(p*32.+vec2(iTime*0.8,0))*0.125;\n    n+= Noise(p*62.-vec2(iTime*2.,0))*0.0625;\n    return (n/2.);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a),s = sin(a);\n    return mat2(c,-s,s,c);\n}\nconst float pi = 3.1415926;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    float l1 = fbm(uv+1.);\n    float l2 = fbm(rot(pi/2.)*uv+l1);\n    \n    float l3 = fbm(uv+vec2(l1,l2));\n    \n    vec3 col = vec3(0.);\n    col = mix(vec3(1.),vec3(0.985,0.800,0.714),1.-l1);\n    col = mix(col,vec3(1.30,.009,0.047),l2);\n\tcol = mix(col,vec3(0.1,0.1,0.1),l3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 97], [99, 99, 119, 119, 392], [393, 393, 411, 411, 655], [657, 657, 676, 676, 738], [767, 767, 824, 874, 1246]], "test": "untested"}
{"id": "wtdXzS", "name": "Techno Core", "author": "Kali", "description": "Mandelbox fractal distorting distance field with volumetric rendering.", "tags": ["fractal", "music", "visualizer"], "likes": 13, "viewed": 368, "published": "Public", "date": "1581263582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float det = .001;\nvec3 objcol=vec3(0.);\nfloat snd;\n\n\nmat2 rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat fractal(vec3 p) {\n    vec3 c = p;\n    float m = 100.;\n    for(int i = 0; i < 10; i++) {\n\t\tp=abs(p + 1.) - abs( p - 1.) - p;\n        p=p / clamp(dot(p,p), 0.1, 1.) - c;\n    \tm=min(m, abs(length(p) - 3.5));\n    }\n    m = max(0., 1. - m);\n    objcol = abs(p) * .6;\n    return m * m * (.2+snd);\n}\n\nfloat de(vec3 p) {\n    p.yz *= rot(iTime);\n    p.xz *= rot(.2);\n    float f = fractal(p);\n\tfloat d = length(p) - 3.5 + f * 1.5 - snd * 3.;\n    d = min(d, length(p.xy) - .25);\n\td = min(d, length(p.yz) - .25);\n\td = min(d, length(p.xz) - .25);\n    return (d - f * .5) * .5;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 col = vec3(0.), p;\n    float td = 0., d;\n    for (int i = 0; i < 150; i++) {\n    \tp = from + td * dir;    \n\t\td = de(p);\n        td += max(det, abs(d));\n\t\tif (td > 20.) break;\n        col += objcol * exp(-.005 * td * td);\n    }\n    vec3 rescol = col * .01 * (.3 + snd * 1.5);\n    return rescol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    snd = texture(iChannel0,vec2(.15)).r;\n    vec2 p = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = normalize(vec3(p, .7));\n    float t = iTime*.5;\n    vec3 from = vec3(sin(t) * 2., 0., -10.);\n    from.xz *= rot(t);\n    dir.xz *= rot(t);\n\tdet += max(0. ,5. - iTime)*.02;\n    vec3 col = march(from, dir);\n    col += pow(abs(.5 - fract(dir.x * 20.)) * 2., 10.) * .2;\n    col += pow(abs(.5 - fract(dir.y * 20.)) * 2., 10.) * .2;\n    float spec = pow(texture(iChannel0, vec2(floor(dir.x*20.)/20. * .5 + .5, .1)).r,2.);\n\tvec2 sq = abs(.5-fract(dir.xy*20.));\n    col+=abs(1.-length(max(vec2(0.),abs(sq.xy)-.1)))*step(dir.y+.4,spec)*length(fract(dir.xy*10.))*.4;\n    col=max(col, vec3(.5, .2, 0.) - smoothstep(0.,.03,abs(dir.y - spec + .35)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xt2GzW", "previewfilepath": "https://soundcloud.com/trippycode/doktorklein-storm?in=trippycode/sets/hyped-trippy-code-tracks-free", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/trippycode/doktorklein-storm?in=trippycode/sets/hyped-trippy-code-tracks-free", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 72, 72, 135], [137, 137, 160, 160, 435], [437, 437, 455, 455, 709], [711, 711, 744, 744, 1046], [1048, 1048, 1105, 1105, 1943]], "test": "untested"}
{"id": "wtfXDj", "name": "Checkerboard Floor", "author": "ddoodm", "description": "Just a simple test of trying to make a checkerboard floor!", "tags": ["grid", "checkerboard"], "likes": 2, "viewed": 230, "published": "Public API", "date": "1581208482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INFINITY 100.0\n#define EPSILON 0.01\n#define PRECIS 32\n#define AA 8\n#define PI 3.14159\n\nstruct HIT\n{\n    vec3 point;\n    float dist;\n};\n\nfloat plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat world(in vec3 p, in float t)\n{\n    float plane1 = plane(p);\n    \n    return plane1;\n}\n\nHIT trace(in vec3 ro, in vec3 rd, in float t)\n{\n    vec3 p = ro;\n    for(int i=0; i<PRECIS; i++)\n    {\n        float d = world(p,t);\n        \n        if(d >= INFINITY)\n            return HIT(p, INFINITY);\n        \n        p += rd * d;\n        \n        if(d <= EPSILON)\n            break;\n    }\n    \n    return HIT(p, length(p-ro));\n}\n\nvec3 material(in vec3 p)\n{\n    const float SIZE = 0.5;\n    bool inx = mod(p.x*SIZE, 1.0) > 0.5;\n    bool inz = mod(p.z*SIZE, 1.0) > 0.5;\n    bool ing = inx ^^ inz;\n    \n    return vec3(0.4) * (ing ? 1.2 : 1.0);\n}\n\nvec3 image(in vec2 uv, in float t)\n{\n    float tt = 2.0*sin(t*0.9);\n    \n\tvec3 ro = vec3(cos(tt)*15.0, 10.0, 9.0*-sin(tt));\n    vec3 ta = vec3(0., 0., 0.);\n    vec3 up = normalize(vec3(0.5+0.5*sin(t), 1., 0.));\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw,up));\n    vec3 cv = normalize(cross(cu,cw));\n    mat3 cam = mat3(cu,cv,cw);\n\tvec3 rd = cam * normalize(vec3(uv, 2.0));\n\t\n\tHIT hit = trace(ro, rd, t);\n\tfloat d = hit.dist;\n    vec3 p = hit.point;\n    \n    vec3 ambient = vec3(0.025,0.05,0.1);\n    \n\tif(d < INFINITY)\n\t{\n        vec3 albedo = material(p);\n        \n        float diff = 1.0;\n        \n        float fog = smoothstep(0.0, 1.0, d*0.015);\n        \n\t    vec3 pc = ambient + albedo*diff - fog;\n\t\tpc = max(ambient, pc);\n        \n\t    return clamp(pc, 0., 1.);\n\t}\n    else\n    {\n        return ambient;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UV and aspect correct\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Offset UV to -1...1\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = vec3(0.);\n    \n    for(int m=0; m<AA; m++)\n        for(int n=0; n<AA; n++)\n        {\n            // AA offset\n            vec2 o = vec2(float(m),float(n)) / float(AA) / iResolution.xy * 2.0;\n            vec2 ouv = uv+o;\n            \n            // Motion blur time-offset\n            float t = iTime - texture(iChannel0, ouv+vec2(m,n)/float(AA)).r * .03;\n\n            // Capture image\n\t\t\tc += image(ouv, t);\n        }\n\n    // Output to screen\n    c /= float(AA * AA);\n    //c = pow(c,vec3(0.8));\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfXDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 165, 165, 183], [185, 185, 221, 221, 276], [278, 278, 325, 325, 611], [613, 613, 639, 639, 825], [827, 827, 863, 863, 1667], [1669, 1669, 1726, 1765, 2449]], "test": "untested"}
{"id": "wtGGRt", "name": "Colorful Metaballs", "author": "a1pha1", "description": "wobbling metaballs", "tags": ["wobble"], "likes": 5, "viewed": 102, "published": "Public", "date": "1581322607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash2(vec2 val)\n{\n    return fract(cos(val.x*12.45252)*55346.325+sin(val.y)*43758.5453123);\n}\n\nfloat poly(float x, float a, float b, float c, float d)\n{\n    return a*x*x*x+b*x*x+c*x+d;\n}\n\nfloat cubic(float x, float A, float B, float C, float D)\n{\n    float d = B;\n    float c = (C-A)/2.;\n    float a = (D-B)/2. - 2.*C + c + 2.*d;\n    float b = C - a - c - d;\n    \n    return poly(x, a, b, c, d);\n}\n\nfloat bicubic(vec2 p, mat4 data)\n{\n    float A = cubic(p.y, data[0][0], data[0][1], data[0][2], data[0][3]);\n    float B = cubic(p.y, data[1][0], data[1][1], data[1][2], data[1][3]);\n    float C = cubic(p.y, data[2][0], data[2][1], data[2][2], data[2][3]);\n    float D = cubic(p.y, data[3][0], data[3][1], data[3][2], data[3][3]);\n\treturn cubic(p.x, A, B, C, D);\n}\n\nfloat bicubicNoise(vec2 p)\n{\n    vec2 pos = floor(p);\n    vec2 dpos = p-pos;\n   \n    mat4 dat;\n    dat[0] = vec4(hash2(pos+vec2(-1., -1.)), hash2(pos+vec2(-1., 0.)),hash2(pos+vec2(-1., 1.)),hash2(pos+vec2(-1., 2.)));\n    dat[1] = vec4(hash2(pos+vec2(0., -1.)), hash2(pos+vec2(0., 0.)),hash2(pos+vec2(0., 1.)),hash2(pos+vec2(0., 2.)));\n    dat[2] = vec4(hash2(pos+vec2(1., -1.)), hash2(pos+vec2(1., 0.)),hash2(pos+vec2(1., 1.)),hash2(pos+vec2(1., 2.)));\n    dat[3] = vec4(hash2(pos+vec2(2., -1.)), hash2(pos+vec2(2., 0.)),hash2(pos+vec2(2., 1.)),hash2(pos+vec2(2., 2.)));\n\n    return bicubic(dpos, dat);\n}\n\nfloat noise(vec2 p)\n{\n    p *= 4.;\n    float H = 0.9;\n    float G = pow(2., -H);\n    float a = 1.;\n    float f = 1.;\n    float t = 0.;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        t += a * bicubicNoise(p*f);\n        a *= G;\n        f *= 2.;\n    }\n    return t*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float w = 0.5;\n    \n    vec3 sum = vec3(0.);\n    \n    for(float i = 0.; i < 10.; i++)\n    {\n        vec2 npos = vec2(cos(iTime*w), sin(iTime*w))+i*vec2(330., 73.);\n    \tfloat x = noise(npos)-0.5;\n    \tfloat y = noise(npos+vec2(100.,20.))-0.5;\n        vec2 vec = (uv-vec2(x,y));\n        vec3 rgb = vec3(noise(npos+vec2(7., 3.)), noise(npos+vec2(2.,10.)), noise(npos+vec2(12., 17.)));\n    \tsum += rgb / pow(vec.x*vec.x+vec.y*vec.y, 0.8);\n    }\n    col = vec3(sum/100.);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 99], [101, 101, 158, 158, 192], [194, 194, 252, 252, 403], [405, 405, 439, 439, 769], [771, 771, 799, 799, 1375], [1377, 1377, 1398, 1398, 1648], [1651, 1651, 1708, 1708, 2331]], "test": "untested"}
{"id": "WtGSDW", "name": "Logistic maq", "author": "maqflp", "description": "r in (-2:-1)\nhttps://en.wikipedia.org/wiki/Logistic_map", "tags": ["test", "chaos", "modelling"], "likes": 5, "viewed": 126, "published": "Public", "date": "1582670055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// v2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=1.0+0.07*sin(iTime*0.3);\n    float y=0.5;\n\tfloat y0=-2.0;//2.4;\n\tfloat w=1.0;//1.6;\n    float r=y0+w*(uv.x);\n    float col=0.0;\n    #define N 305\n    float dc = 40.0/float(N);\n    for(int i=0; i<N; i++)\n    {\n    \ty = r*y*(1.0-y);        \n       \tif( abs(y - uv.y) < 0.002)\n    \t\tcol += dc;\n    }\n    fragColor = vec4(vec3(col),1.0);\n}\n\n/*\n// v1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=1.0+0.1*sin(iTime*0.2);\n    float x=0.6+0.4*sin(iTime*0.2);\n    //float x=0.5;\n\tfloat x0=-2.0;//2.4;\n\tfloat w=1.0;//1.6;\n    float r=x0+w*(uv.x);\n    vec3 col;\n    #define N 505\n    for(int i=0; i<N; i++)\n    {\n    \tx = r*x*(1.0-x);\n        \n       \tif( abs(x - uv.y) < 0.002)\n    \t\tcol += vec3(1.0)/float(N/40);\n    }\n    fragColor = vec4(col,1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 63, 63, 447]], "test": "untested"}
{"id": "wtGSRm", "name": "Vegan honey", "author": "rodgzilla", "description": "Recursive KIFS with glow", "tags": ["kifs", "recursion"], "likes": 4, "viewed": 255, "published": "Public API", "date": "1582394193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define ZPOS -130.\n\nfloat PI = acos(-1.);\n\nmat2 rot2d(float a) {\n  float c = cos(a), s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat wave(float t, float a) {\n    return a * (.5 * sin(time) + .5);\n}\n\nvec3 kifs(vec3 p, float r, float s, float tf, float it) {\n    float t = tf * time;\n    for (float i = 0.; i < it; i++) {\n        p.xy *= rot2d(t * .6);\n        p.yz *= rot2d(t * .7 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  t = clamp(t, 0., 1.);\n  vec3 c = a + ab * t;\n  \n  return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n  vec3 q = mod(p, r) - .5 * r;\n  \n  return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n    p = kifs(p, .8, 3., .5, 2.);\n    p = kifs(p, .5, 2. + length(p) * .3, .5, 4.);\n    float d = 5000.;\n    \n    float obj = tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), 1.);\n\tobj = min(obj, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), 1.));\n\tobj = min(obj, tube(p, vec3(0, 0, -2), vec3(0, 0, 2), 1.));\n    obj = max(obj, sph(p, 2.));\n    obj = mix(obj, sph(p, 1.), wave(1., 1.));\n    d = min(d, obj);\n    \n    at += .05 / (.2 + d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0, 0, 0);\nfloat rm(vec3 ro, vec3 rd) {\n  float d = 0.;\n  \n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + d * rd;\n    float ds = map(p);\n    \n    if (ds < 0.01 || ds > 100.) {\n      break;\n    }\n    \n    d += ds * .8;\n    glow += .002 * at * vec3(.5, .3 + wave(.5, .4), 0.);\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0.01, 0);\n  \n  vec3 n = map(p) - vec3(\n    map(p - e.xyy),\n    map(p - e.yxy),\n    map(p - e.yyx)\n  );\n  \n  return normalize(n);\n}\n\nfloat light(vec3 p) {\n  vec3 lp = vec3(2, 5, ZPOS);\n//  lp.xz *= rot2d(time);\n  vec3 tl = lp - p;\n  vec3 tln = normalize(tl);\n  vec3 n = normal(p);\n  float dif = dot(n, tln);\n  float d = rm(p + .01 * n, tln);\n  \n  if (d < length(tl)) {\n    dif *= .1;\n  }\n  \n  return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    uv *= .5 + wave(1., .5);\n//    uv *= sin(time);\n//    uv *= rot2d(sin(time) * PI);\n\n\tvec3 ro = vec3(0, 0, ZPOS);\n  \tvec3 rd = normalize(vec3(uv, 1.));\n    \n  \tfloat d = rm(ro, rd);\n  \tvec3 p = ro + d * rd;\n  \tfloat dif = light(p);\n  \t\n//    vec3 col = .2 * dif * glow;\n  \tvec3 col = glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 83, 83, 148], [150, 150, 178, 178, 204], [206, 206, 236, 236, 276], [278, 278, 335, 335, 543], [545, 545, 590, 590, 747], [749, 749, 775, 775, 823], [840, 840, 859, 859, 1301], [1330, 1330, 1358, 1358, 1619], [1621, 1621, 1642, 1642, 1789], [1791, 1791, 1812, 1812, 2064], [2067, 2067, 2124, 2124, 2598]], "test": "untested"}
{"id": "wtGSz1", "name": "embers", "author": "LucasWilson", "description": "weird problem where they all line up sometimes that i can't figure out other than that its ok i guess", "tags": ["particles", "trails", "embers"], "likes": 8, "viewed": 218, "published": "Public", "date": "1582173208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRID_SCALE vec2(10.,1.)\n#define PARTICLE_SWAY_SCALE 1.\n#define PARTICLE_SIZE_SCALE .6\n#define PARTICLE_SPEED_SCALE 1.4\n\nfloat r21(vec2 p) {\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 4558.5453);\n}\n\nvec2 r22(vec2 p) {\n    float f = r21(p);\n    return vec2( f, floor(f)+fract(fract(f)*100.) );\n}\n\nfloat column(vec2 p) {\n    return floor(p.x);\n}\n\nvec2 cell_to_screen(vec2 cell_pos, float column_id) {\n    return vec2(column_id + cell_pos.x/10., cell_pos.y);\n}\n\nvec3 column_paint(float column_id, vec2 cell_pos, float offs, float depth) {\n    vec3 col;\n    \n    for (float i=1.;i<=20.;i++) {\n        float transparency_scale = (10.-depth)/10.;\n        \n        float scale = (20.3-i)/20. * PARTICLE_SIZE_SCALE;\n        \n        float time = mix(iTime,iTime*(1.-transparency_scale),.5) * PARTICLE_SPEED_SCALE  -.005*i + depth*1125.634;\n        \n        float offsY = time + column_id;\n        float randY = 5. + r21(vec2(column_id)+.6); \n\n        vec2 fake_dot_pos = vec2(.5 + PARTICLE_SWAY_SCALE * cos(time+column_id*23.+depth*12546.325346345673457),mod(offsY + randY,1.));\n\n        col += smoothstep(.007*scale,0.,distance(cell_to_screen(cell_pos, column_id),vec2(offs*.1,0)+cell_to_screen(fake_dot_pos,column_id)));\n        col += vec3(1.,.7,0.) * .5 * smoothstep(.015*scale,0.,distance(cell_to_screen(cell_pos, column_id),vec2(offs*.1,0)+cell_to_screen(fake_dot_pos,column_id)));\n    \n    }\n    \n    return col;\n}\n\nvec3 layer(float depth, vec2 uv) {\n    vec3 col;\n    vec2 p = uv.xy * GRID_SCALE;\n    vec2 cell_pos = mod(p,1.);\n   \n    float column_id = column(p);\n    \n    col += column_paint(column_id-1.+depth*22., cell_pos,-1.,depth);\n    col += column_paint(column_id+depth*22., cell_pos, 0.,depth);\n    col += column_paint(column_id+1.+depth*22., cell_pos,1., depth);\n    \n    return col*depth/10.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col;\n    \n    col += vec3(0.,.35,1.)*.125;\n    col += vec3(1.,.4,.1) * (1.-uv.y) * (.3 + .02*cos(iTime*15.));\n    col += vec3(1.,.4,.1) * .01*cos(iTime*23.+2.3);\n    \n    for (float x = 1.; x<10.; x++) {\n    \tcol += layer(x, uv);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 147, 147, 214], [216, 216, 234, 234, 311], [313, 313, 335, 335, 360], [362, 362, 415, 415, 474], [476, 476, 552, 552, 1430], [1432, 1432, 1466, 1466, 1823], [1825, 1825, 1882, 1932, 2277]], "test": "untested"}
{"id": "wtGSzw", "name": "JoyStick with Flag", "author": "icaroleles1", "description": "My own version of the Logo of a brazilian game dev group.", "tags": ["raymarch"], "likes": 2, "viewed": 141, "published": "Public", "date": "1582424178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14\nvec3 lightPos = vec3(2, 7, 4);\nstruct mat{\n    \n    \n vec3 diffuseColor;\n vec3 specularColor;\n float spec;\n    \n    \n};\n    vec3 baseCubePos = vec3(0,.0,1);\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//iq's SDFs\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat addCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat addCube(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.))-.08;\n}\n\nfloat addSphere(vec3 p,vec3 spherePos, float r){\n    \n   float sphereDistance = length(p - spherePos.xyz)-r;   \n    \n    return sphereDistance;\n}\n\n\nvec2 opUnion(vec2 r1, vec2 r2){\n    return r1.x < r2.x ? r1 : r2;\n}\n\nvec2 mapScene(vec3 p){\n    vec2 res;\n\n    vec3 spherePos = vec3(0,3.8,1);\n    float sphere = addSphere(p,spherePos,.6);\n    res = vec2(sphere,1.0);\n    \n    float baseCube = addCube(p-baseCubePos,vec3(2.1,.5,2.1))-.2;\n   \tres = opUnion(res,vec2(baseCube,3.0));\n    \n    vec3 polePos = baseCubePos + vec3(0,2,0);\n    float pole = addCylinder(p-polePos,.3,1.2);\n    res = opUnion(res,vec2(pole,7.0));\n    \n    vec3 buttomPos = p -baseCubePos + vec3(-1.39,-.6,-1.2);\n   // buttom.yz *=Rot(2000.*1.57);\n    float prisma = sdRoundedCylinder( buttomPos,.35,.35,.01);\n    res = opUnion(res,vec2(prisma,4.));\n    \n    \n    \n        vec3 flagPos = p - baseCubePos + vec3(-1.8,-4.6,.6);\n\tvec3 uv = flagPos;\n       //Wave from https://www.shadertoy.com/view/3lyGRd\n         float w = sin((uv.x - uv.y*uv.y - iTime * 2.75 + sin(4.5 * uv.x + 4.5 * uv.y) * PI * .3)\n                  * PI * .6); \n              p.xy *= 1. + (.036 - .036 * w);\n        uv *= 1. + (.036 - .036 * w);\n\n   float flag = addCube(uv,vec3(1.7,.7,.001))*.4;\n    res = opUnion(res,vec2(flag,5.));\n    \n    res = opUnion(res,vec2(p.y,1.1));\n    \n    return res;\n}\n\n\nvec2 rayMarch(vec3 ro,vec3 rd){\n    float dO = 0.;\n    vec2 d;\n    for(int i=0;i<100;i++){\n     vec3 p = ro + rd*dO;\n        d = mapScene(p);\n        \n\n        dO+=d.x;\n        if(d.x >20.0|| d.x<.01)\n            break;\n\n    }\n        float id=d.y;\n        float dist = dO;\n    \n    return vec2(dist,id);\n}\n    \nvec3 getNormal(vec3 p){\n    \n    vec2 d = mapScene(p);\n    \n    vec2 e= vec2(.01,.0);\n    \n    vec3 normal = d.x -vec3(mapScene(p-e.xyy).x,\n                          mapScene(p-e.yxy).x,\n                          mapScene(p-e.yyx).x);\n    \n      \n    return normalize(normal);\n}    \n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 18;\n    const float delta = 1.5;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - mapScene(p + n*d).x);\n        weight *= 0.6;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec3 shadeScene(vec3 p,vec3 ro,vec3 uv,float geometry){\n    \n\n    \n    vec3 lightDir = normalize(lightPos-p);\n    vec3 normal = getNormal(p);\n    \n    \n    float dist = distance(lightPos,p);\n    float diff = clamp(dot(normal, lightDir), 0., 1.);\n    float d = rayMarch(p+normal*0.02*2., lightDir).x;\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    \n    vec3 eff = vec3(0);\n    vec3 viewDir = normalize(uv-ro);\n    vec3 reflectDir = reflect(-lightDir,normal);\n    vec3 ambient = vec3(.1,.2,.4);\n\n    mat material;\n    \n    if(geometry==-1.0){\n        material.diffuseColor = vec3(0.,.3,.3);\n        material.specularColor = vec3(1);\n        material.spec = .0;\n }\n    else   if(geometry==1.0){\n        \n        material.diffuseColor = vec3(.0,.1,.9);\n        material.specularColor = vec3(1.0);\n        material.spec = 128.0;\n       if(p.z>.88){\n       eff.rg+= .04/length(p.x-.1) ;\n       eff *= .07/length(p.z-1.654)*2.4*eff.r;\n       eff *= .9/length(p.y-3.932)*vec3(.2,.1,.87);\n       }      \n       // eff*=.04/length(p.y);\n  \n\t\t\t\n    }\n   \n    else   if(geometry==1.1){\n \n        material.diffuseColor = vec3(0.4);\n        material.specularColor = vec3(1.0);\n        material.spec = 4.0;\n  \n\t\t\t\n    }\n    \n    else   if(geometry==7.0){\n        \n        material.diffuseColor = vec3(.0,.1,.9);\n        material.specularColor = vec3(.1,.1,.7);\n        material.spec = 128.0;\n         \n  \n\t\t\t\n    }\n  \n    else if(geometry == 3.0){\n       \n        material.diffuseColor = vec3(0.114,.4,.8);\n        material.specularColor = vec3(1);\n        material.spec = 2.;\n         //eff.b+= .57/length(p.x+.55)*eff.g;\n          \n\t\n        \n    }\n      \n    \n   \telse if(geometry ==4.0 ){\n        material.diffuseColor = vec3(1,.9,.0);\n        material.specularColor = vec3(.5,.1,.9);\n        material.spec = 4.;\n  \n    }\n      \n    else if(geometry ==5.0 ){\n        \n      \n        material.specularColor = vec3(.6);\n        material.spec = 2.;\n          \n       \n\n          if(abs(p.y)>4.700000000001){\n           material.diffuseColor= vec3(12,11,0);   \n          }\n          else{\n                         material.diffuseColor= vec3(0,1,0);   \n\n          }\n                \n    }\n     \n    else if(geometry ==6.0 ){\n        \n        material.diffuseColor = vec3(.0,.1,.1);\n        material.specularColor = vec3(.6);\n        material.spec = 4.;\n        \n        \n    }\n    \n    else if(geometry ==7.0 ){\n        \n        material.diffuseColor = vec3(.1,.3,.3);\n        material.specularColor = vec3(.6);\n        material.spec = 256.;\n   \n    }\n    \n    else{\n        \n         material.diffuseColor = vec3(0);\n        material.specularColor = vec3(.6);\n        material.spec = 2.;\n    \t}\n    \n    \n    float itensity = max(dot(viewDir,reflectDir),.0);\n    \n    \n   float spec = pow(itensity,material.spec);\n\n\tdist*=dist;\n    material.diffuseColor*=diff * 1./(dist*.012);\n    material.specularColor*=spec*1./(dist*.012  +.1);\n    \n    float ao = pow(ambientOcclusion(p,normal),2.0);\n    vec3 col =  (material.diffuseColor + material.specularColor) + ambient+  eff ;\n    \n\treturn col*ao;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#define suncolor vec3(0.7,0.6,0.9)\nvec3 sky(vec3 rd, vec3 sky){\n    float sa=max(dot(rd ,sky),0.0);\n    float v=pow(1.0-(rd.y+.3),8.0);\n    vec3 s=mix(vec3(0.7,0.8,0.9),vec3(0.3,0.3,.8),v);\n        s=s+suncolor*sa*sa*0.6;\n        s=s+suncolor*min(pow(sa,32.0),0.3);\n    return clamp(s,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=1.8;\n    vec3 col =vec3(0);\n\n    vec3 ro = vec3(5,5,3.1);\n\tvec3 sun=normalize(vec3(0.08,0.5-0.25,.1));\n\n    ro.xz*=Rot( (iTime*.3));\n   ;\n    vec3 ta = baseCubePos +vec3(0,1.4,0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 rd = ca *normalize(vec3(uv,1.0));\n    \n    vec2 scene = rayMarch(ro,rd);\n    vec3 point = ro + rd*scene.x;\n    vec3 color   = sky(rd,vec3(0,5,0));\n    \n    if(scene.x<=20. && scene.x>.01)\n            color = shadeScene(point,ro,rd,scene.y);  \n\t\n\n    col+= color;\n\n    // Output to screen\n    float GAMMA = 2.2;\n\n    col = pow(col,vec3(GAMMA));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 194, 194, 270], [272, 284, 348, 348, 465], [466, 466, 513, 513, 620], [621, 621, 654, 654, 685], [687, 687, 717, 717, 760], [762, 762, 810, 810, 907], [910, 910, 941, 941, 977], [979, 979, 1001, 1001, 2100], [2103, 2103, 2134, 2134, 2409], [2415, 2415, 2438, 2438, 2693], [2699, 2699, 2739, 2739, 3040], [3042, 3042, 3097, 3097, 6125], [6127, 6127, 6179, 6179, 6356], [6393, 6393, 6421, 6421, 6654], [6657, 6657, 6714, 6764, 7469]], "test": "untested"}
{"id": "WtGXDm", "name": "Weird Aliens", "author": "SomMusic", "description": "#Alien #HelloWorld", "tags": [], "likes": 3, "viewed": 65, "published": "Public", "date": "1582814609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n    xy.x = xy.x / iResolution.x;\n\txy.y = xy.y / iResolution.y; \n    \n    float x = xy.x;\n    \n    float value = 0.9;\n    vec4 solidRed = vec4(1.0,sin(iTime),0.0,1.0);\n    vec4 solidGreen =vec4(0.0,1.0,0.0,1.0);\n    vec4 solidBlack =vec4(0.0,0.0,0.0,1.0);\n    vec4 solidYellow =vec4(sin(iTime),0.0,0.0,1.0);\n    \n    // Output to screen\n    \n    //Belgique\n    //fragColor = solidBlack;\n    //if (xy.x > 0.333) fragColor = solidYellow;\n    //if (xy.x > (0.666)) fragColor = solidRed;\n    \n    //Degradé\n    //fragColor = vec4(xy.x, (1.0 - xy.x),0.0 + xy.y,1.0);\n    \n    \n    //Droite Degradée\n    //float greyScale = smoothstep(xy.y-0.3*xy.y,xy.y, xy.x) - smoothstep(xy.y,xy.y+0.3*xy.y, xy.x); \n    //fragColor = vec4(greyScale,greyScale,greyScale, 1.0);\n    \n    float a = iTime*10.0;\n    float b = xy.x*xy.y*10.0;\n\tfloat val = a - (b * floor(a/b));\n    float greyScale = smoothstep(val,val+0.1, xy.x); \n    fragColor = vec4(greyScale,greyScale,greyScale, 1.0);\n    \n    vec4 mask = vec4(1.,1.,1.,1.);\n    mask = vec4(1.-sin(iTime*4.),sin(iTime*4.),.0,1.);\n    mask *= 1.-x;\n    mask *= x;\n    mask += .5;\n    fragColor = fragColor * mask;\n    \n    //if (val <= 0.4) fragColor = (solidRed + solidYellow)/2.0;\n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1305]], "test": "untested"}
{"id": "WtGXRw", "name": "Vector waves", "author": "avin", "description": "visual experiment", "tags": ["2d", "wave", "simplex", "vector"], "likes": 30, "viewed": 460, "published": "Public API", "date": "1582363105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 50.\n#define COL1 vec3(32, 43, 51) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 1. / min(iResolution.x, iResolution.y) * SIZE\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n\n    uv.y = uv.y * SIZE;\n    float yid = floor(uv.y);\n    uv.y = fract(uv.y) - .5;\n\n    float mask = 0.;\n\n    for (float ofs = -1.; ofs <= 1.; ofs += 1.) {\n        vec2 iuv = uv + vec2(0., ofs);\n\n        float iid = yid - ofs;\n\n        float fx = snoise(vec3(uv.x * 10. + iid * 100., iid, iTime));\n        float fx2 = snoise(vec3(uv.x * 10. + (iid - 1.) * 100., (iid - 1.), iTime));\n\n        float m = SS(abs(iuv.y + fx), .35);\n        mask = max(mask, m * (fx2 + iuv.y + .5));\n    }\n\n    mask = smoothstep(0., 1., mask * .75);\n\n    vec3 col = mix(COL1, COL2, mask);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 263, 263, 430], [432, 432, 454, 454, 1100], [1102, 1102, 1157, 1157, 1828]], "test": "untested"}
{"id": "WtGXWm", "name": "Echeveria II", "author": "tdhooper", "description": "This time I'm distributing leaves on a hemisphere. Using brute-force AO as the usual approach looks bad with this model; it's slow so you can toggle it with the define\n\n[url=https://media.giphy.com/media/Y0mfLzgzBIfgmCqyqF/source.gif]GIF version[/url]", "tags": ["plant", "succulent"], "likes": 150, "viewed": 6391, "published": "Public API", "date": "1582809862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define AA 3\n#define AO\n//#define GIF\n\n// voronoi - adapted from iq https://www.shadertoy.com/view/ldl3W8\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi( in vec2 x )\n{\n    vec2 cell = floor(x);\n\n    float d = 1e12;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n        vec2 pos = hash2( cell + offset );\n        vec2 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n\n    return d;\n}\n\n// HG_SDF \n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n// Modelling\n\nfloat time;\nbool lightingPass;\nmat3 modelMat;\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n};\n\nModel leaf(vec3 p, vec3 cellData) {\n    //cellData = vec3(0,0,.1);\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    //cell.x = 0.;\n    //cell.y = .1;\n    //cellTime = .2;\n\n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    // orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n    len = pow(len, .33);\n    float llen = len;\n\n\n    if (cellTime > 0.) {\n\n        // wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        // wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,.4));\n        float wedge2 = -dot(p, n);\n        wedge2 = max(wedge2, dot(p, n * vec3(1,1,-1)));\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len / 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - .05;\n        d2 = max(d2, top);\n        \n        float d3 = smax(d2, wedge, .05);\n        float d4 = smax(d2, wedge2, .05);\n        wedges = smin(wedge, wedge2, .01);\n        d3 = smin(d3, d4, .01);\n        d = d3;\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz / len;\n        return Model(d, p, uv, cell, wedges, slice, len);\n    }\n\n\treturn Model(d, p, vec2(0), vec2(0), 0., 0., 0.);\n}\n\nvec3 calcAlbedo(Model model) {    \n    vec3 col = vec3(.15,.15,.4);\n\n\tvec3 p = model.p;\n    float len = model.len;\n    vec2 cell = model.cell;\n    float wedges = model.wedges;\n    float slice = model.slice;\n    vec2 uv = model.uv;\n    \n    float v = voronoi((uv+4.)*30.);\n    float v2 = voronoi((uv+4.)*4.+cell.x);\n\n    col = mix(col, vec3(.125,.2,.4), 1.-v2);\n    float tip = length(p - vec3(0,.2,len*.9));\n\n    tip = smoothstep(.5, .0, tip);\n    tip *= smoothstep(.07, .0, abs(slice+.01));\n    tip *= smoothstep(-.2, .0, wedges);\n    tip = pow(tip, 1.5);\n    col = mix(col, vec3(1,.2,.5), tip);\n\n    float vs = 1.-uv.y*1.;\n    vs *= smoothstep(.0, -.1, wedges);\n    vs *= smoothstep(.0, .05, abs(slice));\n    v = smoothstep(vs + .1, vs - .5, v*1.5);\n    col = mix(col, vec3(.05,.05,.2), v*v2);\n\n    col *= mix(vec3(1), vec3(.5,5.,1.8), smoothstep(.2, 1.8, cell.y) * .75);\n  \n    return col;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t\n) {\n\n    float sz = maxBloomOffset + PI / 2.;\n\n    cell = transform * cell;\n\n    // Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    // Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch / sz / stretchStart;\n    cell.y = max(cell.y, .5/stretchStart); // clamp, not sure why this magic number\n    cell.y /= stretch / sz / stretchStart;\n    cell = transform * cell;\n\n    // Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    // calculate cell time\n    float y = cell.y * (stretch / sz);\n    float cellAppearTime = (stretchStart - y) / (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n\tphyllotaxis = mRot * mScale;\n}\n\nModel bloom(vec3 p, float t) {\n\n    p.y -= .05;\n\n    vec2 move = vec2(0, t);\n    float stretchStart = .25;\n    float stretchEnd = 1.;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI / 2.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n\n\tModel res = Model(1e12, p, vec2(0), vec2(0), 0., 0., 0.);\n    //res.d = length(p) - 1.; return res;\n\n    // compile speed optim from IQ\n    for( int m=min(iFrame,0); m<3; m++ )\n    for( int n=min(iFrame,0); n<3; n++ )\n    {\n    \tres = opU(res, leaf(p, calcCellData(cell, vec2(m, n) - 1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t)));\n    }\n\n    return res;\n}\n\nModel map(vec3 p) {\n    p *= modelMat;\n    float t;\n    \n    float bound = length(p) - 1.3;\n    if (bound > .01 && ! lightingPass) {\n\t\treturn Model(bound, p, vec2(0), vec2(0), 0., 0., 0.);\n    }\n\n    pR(p.xy, time * -PI);\n\n    vec3 pp = p;\n    \n    float side = sign(p.y);\n    p.y = abs(p.y);\n\tp.z *= side;\n\n    t = time + .5 * side;\n    t = sin(t * PI - PI/2.) * .5 + .5;\n    pR(p.xz, time * PI);\n    Model model = bloom(p, t);\n    \n    if (abs(p.y) < .34) {\n        p = pp;\n    \tside *= -1.;\n        p.yz *= side;\n        t = time + .5 * side;\n    \tt = sin(t * PI - PI/2.) * .5 + .5;\n        pR(p.xz, time * PI);\n        Model model2 = bloom(p, t);\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/3dyXzD\nvec3 randDir( vec3 n, vec2 seed ) {\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n    vec3  vv = cross( uu, n );\n    \n    float ra = sqrt(seed.y);\n    float rx = ra*cos(6.2831*seed.x); \n    float ry = ra*sin(6.2831*seed.x);\n    float rz = sqrt( 1.0-seed.y );\n    vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nfloat hitLength(vec3 pos, vec3 dir, float maxDist) {\n    float len = 0.;\n    const int steps = 15;\n    float dist = maxDist / float(steps);\n    vec3 rayPos;\n    for (int i = 0; i < steps; i++) {\n        len += dist;\n        dist = map(pos + dir * len).d;\n        if (abs(dist) < .001) {\n            break;\n        }\n        if (len > maxDist) {\n            len = maxDist;\n            break;\n        }\n    }\n    return len / maxDist;\n}\n\nfloat calcAO(vec3 pos, vec3 nor, vec2 seed, float maxDist) {\n    float len = 0.;\n    const float SAMPLES = 3.;\n    for (float x = 0.; x < SAMPLES; x++)\n    for (float y = 0.; y < SAMPLES; y++)\n    {\n        vec2 s = seed + vec2(x, y) / SAMPLES;\n        s = hash2(s);\n        vec3 dir = randDir(nor, s);\n        len += hitLength(pos, dir, maxDist);\n    }\n\n    len /= SAMPLES * SAMPLES;\n    return len;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nmat3 rotX(float a) {\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a) {\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a) {\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nfloat pat(vec2 uv) {\n    vec2 p = vec2(atan(uv.x/uv.y), log(length(uv)));\n   \n   \tp *= phyllotaxis;\n    p = p * 4.;\n    \n    p -= vec2(0,8) * time;\n\n    p = mod(p, 1.);\n    float d = length(p - .5) - .1;\n    float fw = fwidth(d);\n\n    d = abs(d) - .01;\n    d /= fw;\n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime / 4., 1.) + .35;\n    time = mTime;\n    \n    calcPhyllotaxis();\n    modelMat = rotZ(-.9) * rotX(.05) * rotY(-1.1);\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    // time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n        vec3 camPos = vec3(0,0,-2.6);\n        #ifdef GIF\n        \tcamPos.z = -2.8;\n       \t#endif\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-.05,0), 0.);\n        vec3 rayDirection = normalize( camMat * vec3(p.xy,1.8) );\n\n        vec3 rayPosition = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        Model model;\n\n        lightingPass = false;\n        \n        for (int i = 0; i < 300; i++) {\n            rayLength += dist;\n            rayPosition = camPos + rayDirection * rayLength;\n            model = map(rayPosition);\n            dist = model.d;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 5.) {\n                bg = true;\n                break;\n            }\n        }\n        \n        lightingPass = true;\n        \n        col = vec3(.4,.4,1);\n        #ifndef GIF\n        \tcol = mix(col, vec3(.0,1.5,1.5)*1.5, (1.-pat(p))*.5);\n        \tcol = mix(col, vec3(.63,.7,1), smoothstep(2.5, .5, length(p)));\n        #else\n        \tcol = mix(col, vec3(.63,.7,1), .95);\n        #endif\n        col *= vec3(.9,1.,1.);\n        col += .1;\n        \n        //bg = true;\n        \n        if ( ! bg) {\n\n            vec3 pos = rayPosition;\n            vec3 rd = rayDirection;\n            vec2 seed = hash2(p + time);\n            \n            #ifndef AA\n            \tseed *= .0000001;\n            #endif\n            \n            vec3  nor = calcNormal(pos);\n            \n            float occ = 1.;\n            #ifdef AO\n            \tocc = calcAO(pos, nor, seed, .85);\n            \tocc = clamp(pow(occ*1.25, 1.5), 0., 1.);\n            #endif\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            vec3 lin = vec3(0);\n            lin += 1.70 * amb * vec3(1.30,1.00,0.70) * occ;\n            lin += 0.90 * amb * vec3(0.30,0.80,1.30);\n            lin += 1.00 * fre * vec3(1.00,1.00,1.00) * occ;\n\n\n            vec3 albedo = calcAlbedo(model);\n            col = albedo * lin;\n            \n            //col *= mix(vec3(1), vec3(.0,.5,.7)*.5, 1.-occ);\n\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    col = tot;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 109, 131, 131, 224], [226, 226, 254, 254, 555], [557, 636, 668, 668, 713], [715, 715, 753, 753, 864], [866, 866, 905, 905, 936], [938, 938, 988, 988, 1031], [1033, 1033, 1074, 1074, 1118], [1121, 1301, 1336, 1367, 3061], [3063, 3063, 3093, 3093, 3957], [3959, 3959, 4157, 4157, 4906], [4908, 4908, 4937, 4937, 5009], [5029, 5029, 5053, 5053, 5310], [5312, 5312, 5342, 5342, 6162], [6164, 6164, 6183, 6183, 6877], [6879, 6948, 6974, 6974, 7175], [7177, 7218, 7253, 7253, 7565], [7567, 7567, 7619, 7619, 8001], [8003, 8003, 8063, 8063, 8405], [8407, 8407, 8471, 8471, 8649], [8651, 8651, 8671, 8671, 8732], [8734, 8734, 8754, 8754, 8815], [8817, 8817, 8837, 8837, 8898], [8900, 8900, 8920, 8920, 9212], [9214, 9214, 9269, 9269, 12226]], "test": "untested"}
{"id": "wtGXz1", "name": "Rect with highlight", "author": "masanoriyoshii", "description": "test rect with highlight", "tags": ["test"], "likes": 0, "viewed": 54, "published": "Public", "date": "1582178346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv_center = uv - 0.5;\n    uv_center.y *= iResolution.y / iResolution.x;\n    \n    vec2 uv_center_abs = abs(uv_center);\n    float dist_max = max(uv_center_abs.x, uv_center_abs.y);\n    \n    float size = 0.2;\n    float highlight = 0.001;\n    float grad = 0.02;\n        \n    \n    float inner = smoothstep(size - highlight - grad, size - highlight, dist_max);\n    float outer = smoothstep(size + highlight + grad, size + highlight, dist_max);\n\n    \n    float val = inner * outer;\n    \n    vec3 col0 = vec3(1, 0, 0);\n    vec3 col1 = vec3(0, 1, 0);\n    vec3 colMix = mix(col0, col1, sin(uv.y * 5. + iTime * .5) * 0.5 + 0.5);\n    \n    vec3 col = mix(colMix, vec3(1.), val);\n    \n    float blink = 1. - step(sin(iTime * 2.), -0.9) * (sin(iTime * 50.) * 0.5 + 0.5);\n    \n    \n    col = col * val * blink;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 121, 1031]], "test": "untested"}
{"id": "wtKGDK", "name": "Koi Fish", "author": "Hec", "description": "Made this for a lil art jam", "tags": ["2d", "distancefield", "sdf", "fish"], "likes": 21, "viewed": 320, "published": "Public", "date": "1580966019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265359f\n#define PI2 6.28318530718f\n\nconst int FISH_COUNT = 12;\nconst float INV_FISH_COUNT = 1.0f / float(FISH_COUNT);\nconst vec3 BASE_COLOR = vec3(1.0f, 1.0f, 1.0f);\nconst vec4 BACKGROUND_COLOR = vec4(0.0f, 0.5f, 0.7f, 0.0f);\n\n\nstruct FishData\n{\n\tvec4  color;\n    float sdf;\n};\n\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat nsin(float a)\n{\n\treturn sin(a) * 0.5f + 0.5f;\n}\n\nfloat osin(float a)\n{\n\treturn (max(-0.3f, sin(a)) + 0.4f) / 1.4f;\n}\n\nfloat st(float sdf, float scale)\n{\n\tfloat w = (1.0f / iResolution.y) * scale;\n\treturn smoothstep(w, 0.0f, sdf);\n}\n\nfloat st(float sdf)\n{\n\tfloat w = (1.0f / iResolution.y) * 1.6f;\n\treturn smoothstep(w, 0.0f, sdf);\n}\n\nfloat circle(vec2 uv, float radius)\n{\n\treturn length(uv) - radius; \n}\n\nfloat edge(vec2 uv, vec2 a, vec2 b, vec2 center)\n{    \n    vec2 ab = normalize(b - a);\n    vec2 normal = vec2(ab.y, -ab.x);\n    vec2 middle =  a + ab * distance(a, b) * 0.5f;\n    vec2 cm = normalize(middle - center);\n    \n    float flip = dot(normal, normalize(cm));\n    float angle = atan(ab.y, ab.x);\n    \n    float x = cos(angle);\n    float y = sin(angle);\n    \n    uv = (uv - middle) * mat2(x, y, y, -x);\n    \n    return uv.y * -flip;\n}\n\n\nfloat triangle(vec2 uv, vec2 a, vec2 b, vec2 c, float roundness)\n{    \n    vec2 center = (a + b + c) * 0.3333333f;\n    \n\tfloat edge1 = edge(uv, a, b, center);\n    float edge2 = edge(uv, b, c, center);\n    float edge3 = edge(uv, c, a, center);\n    \n    return smin(edge1, smin(edge2, edge3, roundness), roundness) * -1.0f;\n}\n\nfloat circlePattern(vec2 uv, vec2 a, vec2 b, int count, float rOffset)\n{\n    float invCount = 1.0f / float(count);\n    \n    float maxSize = 0.03f;\n    float minSize = 0.01f;\n    \n    float maxOffset =  0.04f;\n    float minOffset = -0.04f;\n    \n    float maxRound = 0.03f;\n    float minRound = 0.0f;\n    \n    float dist = distance(a, b);\n    \n    vec2 ab = normalize(b - a);\n    \n    vec2 right = vec2(ab.y, -ab.x);\n    \n    float sdf = 1.0f;\n    \n    for(int i = 0; i < count; ++i)\n    {\n        float alpha = float(i) * invCount;\n    \tfloat rand = texture(iChannel0, vec2(alpha + rOffset)).r;\n        \n\t\tfloat size   = mix(minSize,   maxSize,   rand);\n        float offset = mix(minOffset, maxOffset, rand);\n        float roundness = mix(minRound, maxRound, rand);\n\n        \n        vec2 p = a + ab * dist * alpha + right * offset;\n        \n        sdf = smin(sdf, circle(uv - p, size), roundness);\n        \n    }\n    \n    return (sdf);\n}\n\nFishData fish(vec2 uv, float size, float depth, float rand)\n{    \n    \n    float x = uv.x * 6.0f;\n    uv.y += sin(x - iTime) * 0.015f;\n    \n    float roundness = size * 0.2f;\n    \n    // Tail ----------------\n    \n    float tailW = size * 3.f;\n    \n    float tailMinHeight = size * 0.1f;\n    float tailMaxHeight = size * 0.7f;\n    \n    float tailH1 =  mix(tailMinHeight, tailMaxHeight, osin(x - iTime));\n    float tailH2 = -mix(tailMinHeight, tailMaxHeight, osin(x - iTime + PI));\n      \n    float tail = triangle(uv, vec2(0.0f), vec2(tailW, tailH1), vec2(tailW, tailH2), roundness);\n    \t\n    \n    // Fins ----------------\n    \n    float finSize = size * 1.5f;\n    \n    float finMoveR = mix(0.0f, size * 0.3f, nsin(x - iTime));\n    float finMoveL = mix(0.0f, size * 0.3f, nsin(x - iTime + PI * 0.8f));\n    \n    float fins = triangle(uv, vec2(-finSize, 0.0f), vec2(finMoveR, finSize), vec2(finMoveL, -finSize), roundness);\n    \n    // Eyes ----------------\n    \n    float eyeRadius = size * 0.1f;\n    float eyeX = size * 1.6f;\n    float eyeY = size * 0.7f;\n    \n    float eyeR = circle(uv + vec2(eyeX,  eyeY), eyeRadius);\n    float eyeL = circle(uv + vec2(eyeX, -eyeY), eyeRadius);\n    \n    float eyes =  st(-min(eyeR, eyeL), 0.5);\n    \n    // Body ----------------\n    \n    uv.y = uv.y * (uv.x + 0.6f) * 2.0f;\n    uv.x *= 0.5f;\n        \n\tfloat body = circle(uv, size);\n    \n    \n    float sdf = smin(body, tail, roundness);\n\tsdf = min(sdf, eyes);\t\n    float bte = sdf;\n        \n    sdf =  smin(sdf, fins, roundness);\n    \n    float mask = st(sdf);\n    float finsMask = (mask - st(bte));\n    float bodyMask = st(body);\n    \n    float patternMask = circlePattern(vec2(uv.x * 1.6f, uv.y), vec2(0.05f, rand * 0.1f), vec2(-0.2f, -rand * 0.1f), 5, rand);\n    \n    patternMask = smin(patternMask, circlePattern( vec2(uv.x * 1.6f, uv.y), vec2(rand * 0.1f, -0.1f), vec2(-rand * 0.2f, 0.1f), 10, rand), 0.03f);\n\tpatternMask = st(patternMask, 1.0f);\n\n    vec3 eyeColor  = vec3(0.0f);\n    vec3 bodyColor = mask * BASE_COLOR;\n    vec3 patternColor = vec3(1.0f,  rand * 0.5f, 0.0f);\n    vec3 finColor  = patternColor * 0.2f + 0.7f;\n\n    \n    bodyColor = mix(bodyColor, patternColor, min(patternMask, bodyMask ));\n\n    \n    \n   \tvec3 color = mix(bodyColor, finColor, finsMask);\n    color = mix(eyeColor, color, eyes);\n\n    \n    color.rgb = mix(BACKGROUND_COLOR.rgb, color.rgb, depth);\n\n    return FishData(vec4(color, mask), sdf); \n}\n\nFishData movingFish(vec2 uv, float speed, float rotation, float scale, float depth, float rand)\n{\n       \n    float time = iTime * speed;\n    \n    float x = cos(rotation);\n    float y = sin(rotation);\n    \n    uv *= mat2(x, y, y, -x); \n    uv = (fract(uv + vec2(time * 0.025f, sin(time) * 0.001f + 0.5f)) - 0.5) * scale;\n    \n    \n    return fish(uv, 0.1f, depth, rand);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.y /= iResolution.x / iResolution.y;    \n    \n    float mask = 1.0f; \n    \n    float maxSize = 2.0f;\n    float minSize = 3.5f;\n    \n    float maxSpeed = 2.5f;\n    float minSpeed = 0.5f;\n    \n    float maxOffset = 0.3f;\n    float minOffset = -0.3f;\n    \n    float minDepth = 0.5f;\n    float maxDepth = 0.9f;\n    \n    vec4 color = BACKGROUND_COLOR;\n    \n    float flip = -1.0f;\n    \n    for(int i = 0; i < FISH_COUNT; ++i)\n    {\n        flip *= -1.0f;\n        \n    \tfloat alpha = float(i) * INV_FISH_COUNT;\n        float rand = texture(iChannel0, vec2(alpha)).r;\n        \n        float speed  = mix(minSpeed, maxSpeed, alpha);\n        float size   = mix(minSize, maxSize, alpha);\n        float rot    = mix(PI2, 0.0f, alpha) * flip;\n        float offset = mix(minOffset, maxOffset, rand) * flip;\n        float depth  = mix(minDepth, maxDepth, alpha);\n        \n        FishData fish = movingFish(uv + offset, speed, rot, size, depth, rand);\n        \n                \n        float fishShadow = smoothstep(0.013f, 0.0f, fish.sdf);\n        \n        color.rgb = mix(color.rgb, vec3(0.0f), fishShadow * color.a * 0.2f);\n        color.rgb = mix(color.rgb, fish.color.rgb, fish.color.a);\n        \n        color.a = max(fish.color.a, color.a);\n    }\n   \n\n    fragColor = vec4(color.rgb, 1.0f);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 356, 397, 397, 490], [492, 492, 513, 513, 545], [547, 547, 568, 568, 614], [616, 616, 650, 650, 729], [731, 731, 752, 752, 830], [832, 832, 869, 869, 901], [903, 903, 953, 953, 1343], [1346, 1346, 1412, 1412, 1669], [1671, 1671, 1743, 1743, 2610], [2612, 2612, 2673, 2673, 5031], [5033, 5033, 5130, 5130, 5405], [5409, 5409, 5466, 5466, 6804]], "test": "untested"}
{"id": "WtKSDh", "name": "Mandelbrot sphere", "author": "nturton", "description": "A Mandelbrot set on a sphere.", "tags": ["fractal", "simple", "sphere"], "likes": 3, "viewed": 81, "published": "Public", "date": "1582655254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 oc = sph.xyz-ro;\n    float b = dot(rd, oc);\n    float d2 = dot(oc,oc) - b*b;\n    float h2 = sph.w*sph.w-d2;\n    if (h2 <= 0.0) {\n        return -1.0;\n    }\n    return b - sqrt(h2);\n}\n\nint mandelbrot(vec2 z, vec2 c)\n{\n    int i;\n    for(i=0; i<50; i++) {\n        if (z.x*z.x+z.y*z.y >= 4.0)\n            return i;\n        z = vec2(z.x*z.x - z.y*z.y + c.x, 2.*z.x*z.y + c.y);\n    }\n    return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(xy, 4.0));\n    vec4 sph = vec4(0.0, 0.0, 5.0, 1.0);\n    vec3 illum = normalize(vec3(1.0, 2.0, -2.0));\n\n    mat3 rot = mat3( \n        vec3(+cos(iTime),  0.0, +sin(iTime)),\n        vec3(+0.0,        +1.0, 0.0),\n        vec3(-sin(iTime),  0.0, +cos(iTime))\n    );\n\n    vec3 col = vec3(float(0.0));\n    float d_sph = sphere(ro, rd, sph);\n    if (d_sph >= 0.0) {\n        vec3 n = normalize(ro + d_sph*rd - sph.xyz);\n        vec2 z = vec2(0.0);\n        vec3 c3 = rot*n-vec3(0.0,0.0,0.0);\n        vec2 c = 1.0*c3.xy/c3.z;\n        int i = mandelbrot(z, c);\n        vec3 m_col = vec3(0.0, 0.0, 0.0);\n        if (i >= 0) {\n            m_col = 0.5-0.5*cos(vec3(1.0,2.0,3.0)*float(i));\n        }\n        float b0 = clamp(dot(illum, n),0.0,1.0);\n        vec3 reflect = illum - 2.*n*dot(n,illum);\n        float b1 = pow(clamp(dot(reflect,rd),0.0,1.0), 5.0);\n        col = m_col*(0.3+b0*0.3)+b1*0.4;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 234], [236, 236, 268, 268, 447], [449, 449, 506, 506, 1601]], "test": "untested"}
{"id": "WtKSDm", "name": "scanline spark", "author": "Carandiru", "description": "prototype scanline", "tags": ["scanline"], "likes": 3, "viewed": 325, "published": "Public API", "date": "1582890231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WtSBRz\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_MIN_ONE (GOLDEN_RATIO - 1.0)\n#define GOOD_COLOR (vec3(0.8, 0.2, 1.0))\n\n#define LINE (0.01666f)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float t_second = fract(iTime);\n    \n    float x_spark = 1.0f - \n                                ((uv.y - abs(uv.y - t_second) \n                                 / mod(t_second, (GOLDEN_RATIO_MIN_ONE * 0.1f * t_second) \n                                       / (GOLDEN_RATIO_MIN_ONE * t_second))) * 0.5f + 0.5f );\n    \n    float y_scanline = smoothstep(0.0f, 0.666f, abs(uv.y - t_second));\n    \n    float scanline = LINE / ((LINE*0.666f) + (x_spark * 0.0666f) + y_scanline * GOLDEN_RATIO_MIN_ONE);\n    \n\n    fragColor = vec4(vec3(0.5f, 0.5f, 1.0f) * GOOD_COLOR * scanline, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSDm.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[37, 491, 548, 548, 1175]], "test": "untested"}
{"id": "wtKSDw", "name": "Color Grating", "author": "iandol", "description": "For Psychtoolbox procedural stimuli useful for psychophysical measurements of color perception, you can change between sin and square wave, while blending two colors against a base color. \n\nTry to change sigma from -1.0 to 0.0 and 0.2 to see its effect.", "tags": ["psychtoolbox", "psychophysics"], "likes": 1, "viewed": 60, "published": "Public", "date": "1582895945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//code for shadertoy.com\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /////////////////////////////////////--VARIABLES\n    // In PTB variables will come from the MATLAB \n    // calling code via the vertex shader.\n    // See http://psychtoolbox.org/docs/ProceduralShadingAPI\n    //\n\t//\n\t//base color to blend from\n\tvec3 baseColor = vec3( 0.5, 0.5, 0.5 );\n\t//first color\n\tvec3 color1 = vec3( 1.0, 0.0, 0.0 );\n\t//second color\n\tvec3 color2 = vec3( 0.0, 1.0, 0.0 );\n\t//grating frequency\n\tfloat frequency = 0.08;\n    //grating phase, here varies using playback time\n\tfloat phase = -iTime*4.0;\n\t// sigma < 0.0  = sinewave grating \n\t// sigma == 0.0 = squarewave grating no smoothing\n\t// sigma > 0.0  = squarewave grating with smoothing in sigma pixels\n\tfloat sigma = -1.0;\n\t//contrast between 0 <-> 1\n\tfloat contrast = 1.0;\n    // the centre of the viewport\n    vec2 center = vec2(iResolution[0]/2.0, iResolution[1]/2.0);\n    // the radius of a circular aperture\n    float radius = iResolution[1]/2.05;\n\n    ////////////////////////////////////--CODE\n    // The actual drawing code...\n    //\n    \n\t// if a pixel is outside the radius, drop it\n    if ( radius > 0.0 ) {\n        float dist = distance( fragCoord.xy, center );\n        if ( dist > radius ) discard;\n    }\n    \n    //create our sinusoid in -1 to 1 range\n\tfloat sv = sin( fragCoord.x * frequency + phase );\n\n\t//if sigma >= 0, we want a squarewave grating, step or smoothstep does this depending on sigma value\n\tif ( sigma == 0.0 ) {\n\t\tsv = step( sigma, sv ); //converts into 0-1 range\n\t}\n\telse if ( sigma > 0.0 ) {\n\t\tsv = smoothstep( -sigma, sigma, sv ); //converts into 0-1 range\n\t}\n\telse {\n\t\tsv = (sv + 1.0) / 2.0; //simply get sv into 0 - 1 range (preserving sinusoid);\n\t}\n\n    // start to mix our colors\n\tvec3 colorA = color1.rgb;\n\tvec3 colorB = color2.rgb;\n\tif ( contrast < 1.0 ) { //blend our colours from base colour if contrast < 1\n\t\tcolorA = mix( baseColor, color1.rgb, contrast );\n\t\tcolorB = mix( baseColor, color2.rgb, contrast );\n\t}\n\n\t// and then mix our two colors using sv (our position in the grating)\n\tvec3 colorOut = mix( colorA, colorB, sv );\n    \n    // this normalises the color range to a generic 2.2 gamma\n    colorOut = pow( colorOut, vec3( 1./2.2 ) );\n\t\n\t// off to the display, byebye little pixel!\n\tfragColor = vec4( colorOut, 1.0 ); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 82, 329, 2331]], "test": "untested"}
{"id": "WtKSWD", "name": "大龙猫 - Astral Projection", "author": "totetmatt", "description": "What is the dot product for astral projection ?", "tags": ["instagram", "quicky"], "likes": 15, "viewed": 603, "published": "Public API", "date": "1582737622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p,a,b);\nfloat m =smoothstep(0.04,0.007,distLine(p,a,b));\n\nfloat d2 = length(a-b);\n  m *= smoothstep(0.6- .1/(length(p)), .3 , d2)*.2 + smoothstep(.0122,.00121,abs(d2-.75)) ;//* (.25/length((p-a)+(p-b)));\n  return m;\n}\nfloat n21(vec2 p){\n  p = fract(p*vec2(123.213,853.4264));\n  p += dot(p,p+6.65);\n  return fract(p.x*p.y);\n\n}\nvec2 n22(vec2 p){\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\nvec2 getPos(vec2 id, vec2 offset) {\n    vec2 n = n22(id+offset)*iTime;\n    return offset+sin(n)*.4;\n}\nmat2 r(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\nfloat layer(vec2 uv){\n\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    vec2 gridPos[9];\n    int ppos = 0;\n    for(int y = -1; y<=1; y++) {\n        for(int x = -1; x<=1; x++) {\n            gridPos[ppos++] = getPos(id,vec2(x,y));\n            \n           \n        }\n    }\n    for(int i=0;i<9;i++){\n        m+=line(gv,gridPos[4],gridPos[i]);\n        \n        vec2 jj = (gridPos[i] - gv)*12.;\n        float sparkle = 1./length(dot(jj,jj));\n        m+=sparkle*(sin(iTime+ fract(gridPos[i].x) *10.)*.5+.5);\n    }\n     m+=line(gv,gridPos[1],gridPos[3]);\n     m+=line(gv,gridPos[1],gridPos[5]);\n     m+=line(gv,gridPos[7],gridPos[3]);\n     m+=line(gv,gridPos[7],gridPos[5]);\n     return m ;\n}\n#define ttime floor(iTime*.5) + pow(fract(iTime*.5),.5)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) -.5;\n \n      \n     float m = 0.;\n      //uv*=exp(length(uv)*.2);\n      uv*=.75;\n      uv*=r(atan(uv.x,uv.y)*2.*1.5);\n      uv*=r(cos(length(uv)*3.1415));\n      uv*=r(-iTime*.1);\n      uv=-abs(uv);\n\n     uv*=2.;\n  \n      //uv.x+=-iTime*.0001;   \n      float t = iTime*.0025;\n    \n      vec3 col = vec3(0.);\n     for( float i=0.; i<1.; i+= (1./5.) ) {\n          float z = fract(i+t);\n  \n          float size = mix(8.+sin(i*3.1415*(sin(iTime)*.5+1.5)+ttime)*8.,2.,z);\n          float fade = smoothstep(.0,.4,z) * smoothstep(1.,.6,z);\n         uv*=r(t*sin(i*10.));\n                             \n          m += layer(uv*size+i*20.) * fade ;\n          vec3 base = mix(vec3(.75+sin(ttime+length(uv*4.))*.1,.2,.6),vec3(.1,.2,.6),vec3(sin(i*4.5)*.5+.5,0.+m*1.,i*2.));\n          col += vec3(m)*base;\n     }\n \n\n    //if(gv.x>.47 || gv.y >.47) col.r = 1.;\n    fragColor = vec4(col,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 159], [160, 160, 195, 195, 432], [433, 433, 451, 451, 540], [541, 541, 558, 558, 612], [614, 614, 649, 649, 715], [716, 716, 732, 732, 791], [792, 792, 813, 813, 1503], [1560, 1560, 1615, 1615, 2611]], "test": "untested"}
{"id": "WtKSWh", "name": "Broccoplasma", "author": "FreeFull", "description": "Messing around with stacked sine waves.", "tags": ["2d", "fractal", "fbm"], "likes": 4, "viewed": 59, "published": "Public", "date": "1582606414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROT (iTime/50.0)\n\nconst float tau = atan(1.0)*8.0;\n\n// http://iquilezles.org/www/articles/palettes/palettes.htm\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 color(float t) {\n    t = mod(t, 1.0);\n    return palette(t, vec3(0.5), vec3(0.5), vec3(1.0, 0.7, 0.4), vec3(0.00, 0.15, 0.20));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    uv.x += iTime/100.0;\n    \n    vec3 col = vec3(sin(uv.x) + sin(uv.y));\n    for(int i=0; i<6; i++) {\n        float fi = float(i);\n        uv *= 3.0;\n        uv *= mat2(cos(fi*ROT), -sin(fi*ROT), sin(fi*ROT), cos(fi*ROT));\n        col += (distance(sin(uv.x + cos(uv.y*10.0)/10.0 + iTime),cos(uv.y + cos(uv.x*10.0)/10.0)))/\n            \tpow(1.85, fi);\n    }\n    col += 0.8;\n    col *= col;\n    col = color(col.x/35.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 159, 231, 231, 274], [277, 277, 298, 298, 411], [413, 413, 470, 521, 1051]], "test": "untested"}
{"id": "wtKSWW", "name": "Mandelbrot, Fixed vs Float", "author": "ockiller", "description": "Left : computed with 32 bit fixed point arithmetic\nRight : computed with 32 bit floating point arithmetic", "tags": ["mandelbrot", "fixedpoint"], "likes": 5, "viewed": 245, "published": "Public API", "date": "1582755521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Number of bits reserved for the fractional part\n#define SHIFT 28u\n\nint   initFixed(float x) {return int(x * float(1u << SHIFT));}\nivec2 initFixed(vec2  v) {return ivec2(initFixed(v.x), initFixed(v.y));}\n\n// Fixed point squaring\nint squareFixed(int a) {\n    uint ua = uint(abs(a));\n    uint ah = ua >> 16u;\n    uint al = ua & 0xFFFFu;\n    return int((ah * ah << 32u - SHIFT) + (ah * al >> SHIFT - 17u) + (al * al >> SHIFT));\n}\nivec2 squareFixed(ivec2 v) {return ivec2(squareFixed(v.x), squareFixed(v.y));}\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    float whiteLine = (0.5 * sin(iTime) + 0.5) * iResolution.x;\n    vec2 U = (2.0 * u - iResolution.xy) / iResolution.y;\n    float zoom = 8e-7;\n    vec2 Coord = vec2(-0.743644, 0.1318255);\n    float maxIters = 3072.0, nbIters = 0.0;\n    \n    if (u.x < whiteLine) {\n        // Fixed point version\n\t    ivec2 C = initFixed(U * zoom) + initFixed(Coord); // more precise doing that way\n        ivec2 Z = C;\n\n        // Check divergence against a square (not circle) of size 4\n        // Numbers can be kept smaller and we can be more aggressive with SHIFT, before getting overflows\n        while (nbIters < maxIters && all(lessThan(abs(Z), initFixed(vec2(2))))) {\n            ivec2 Z2 = squareFixed(Z);\n            Z = ivec2(Z2.x, squareFixed(Z.x + Z.y) - Z2.x) - Z2.yy + C;\n            nbIters++;\n        }\n    } else {\n        // Floating point version\n\t    vec2 C = U * zoom + Coord;\n        vec2 Z = C;\n\n        while (nbIters < maxIters && all(lessThan(abs(Z), vec2(2)))) {\n            Z = vec2(Z.x * Z.x - Z.y * Z.y, 2.0 * Z.x * Z.y) + C;\n            nbIters++;\n        }\n    }\n\n    // Coloring\n    float t = nbIters / maxIters;\n    O.rgb = nbIters < maxIters ? -0.5 * cos(6.2831853 * (t + vec3(-0.1, 0.0, 0.1))) + 0.5 : vec3(0.0);\n        \n    if (abs(u.x - whiteLine) < 1.0)\n    \tO.rgb = vec3(1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 96, 96, 132], [133, 133, 159, 159, 205], [207, 231, 255, 255, 428], [429, 429, 457, 457, 507], [509, 509, 548, 548, 1853]], "test": "untested"}
{"id": "wtKSzD", "name": "Underwater world", "author": "maksy", "description": "Underwater world", "tags": ["voronoi", "terrain", "caustics", "underwater", "godray"], "likes": 5, "viewed": 367, "published": "Public API", "date": "1582846567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Resources:\n * https://www.shadertoy.com/view/4ljXWh\n * https://www.youtube.com/watch?v=l-07BXzNdPw\n */\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 100.0\n#define SURF_DIST .001\n\n#define GROUND 0\n#define WATER 1\n\nstruct Obj {\n\tint type;\n    float dist;\n    vec3 hitPos;\n};\n\n//2D signed hash function:\nvec2 Hash2(vec2 P) {\n\treturn 1.-2.*fract(cos(P.x*vec2(91.52,-74.27)+P.y*vec2(-39.07,09.78))*939.24);\n}\n\n//2D Simplex gradient noise.\nfloat Simplex(vec2 P) {\n    //Skewing and \"unskewing\" constants as decribed here: https://en.wikipedia.org/wiki/Simplex_noise\n    #define S (sqrt(.75)-.5)\n\t#define G (.5-inversesqrt(12.))\n   \n    //Calculate simplex cells.\n    vec2 N = P+S*(P.x+P.y);\n    vec2 F = floor(N);\n    vec2 T = vec2(1,0)+vec2(-1,1)*step(N.x-F.x,N.y-F.y);\n    \n    //Distance to the nearest cells.\n    vec2 A = F   -G*(F.x+F.y)-P;\n    vec2 B = F+T -G*(F.x+F.y)-G-P;\n    vec2 C = F+1.-G*(F.x+F.y)-G-G-P;\n    \n    //Calculate weights and apply quintic smoothing.\n    vec3 I = max(.5-vec3(dot(A,A),dot(B,B),dot(C,C)),0.);\n    I = I*I*I*(6.*I*I,-15.*I+10.);\n    I /= dot(I,vec3(1));\n    \n    //Add up the gradients.\n    return .5+(dot(Hash2(F),A)*I.x+\n        \t   dot(Hash2(F+T),B)*I.y+\n        \t   dot(Hash2(F+1.),C)*I.z);\n}\n\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves, float octaveWeight) {\n    \n    float h = 0.; // height\n    float m = 0.4; // octave multiplier\n    \n    for (int i = 0; i < octaves; i++) {\n\t\th += octaveWeight * Simplex(uv * m);\n        octaveWeight *= .4;\n        m *= 2.0;\t         \n    }\n    return h;\n}\n\nObj getDist(vec3 p) {\t\n       \n    // distance to the ground\n    float height = fbm(vec2(p.x, p.z), 2, 0.4); \n    height = fbm(vec2(p.x, p.z), 6, 1.5);\n    float planeDist = p.y - height-3.;\n   \n    Obj obj = Obj(GROUND, planeDist, p);\n\n    return obj;\n}\n\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.0;\n    \n    Obj hitObj = Obj(WATER, t, ro + rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        hitObj = getDist(p);      \n        t += hitObj.dist;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(WATER, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.dist) < SURF_DIST * (1.0+t)) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.dist = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = getDist(p).dist;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.01, 0.);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n    \n    // compute the light vector and its normal   \n    lightPos.xz += vec2(sin(iTime*0.5), cos(iTime*0.5))*1.4;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = getNormal(p);\n    \n    // calculate diffuse lightning\n    // dot product gives values between -1 to 1 hence the range\n    // is clamped to 0 to 1\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    return dif;\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// ############################\n// # CAUSTICS \n// ############################\nvec2 N22(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);\n}\n\nfloat voronoi(vec2 p) {\n\n    // divide the screen into a grid\n    p *= 3.;\n    // this is the id of a grid cell. X and y go from -3 to 3.\n    vec2 id = floor(p);     \n    // Coordinates inside a grid cell\n    vec2 gv = fract(p);\n    \n    float minDist = 9.;\n    \n    // loop through 9 grid cells around the point and check \n    // which is the closest cell\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            // multiply because gv goes from -0.5 to .0.5\n            vec2 p = .5+0.5*sin(n*iTime*4.);\n      \n            vec2 r = offset + p - gv;\n            float d = dot(r, r);\n            \n            if (d < minDist) {\n            \tminDist = d;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\n// creates fake caustics with voronoi patterns and fBMs\nfloat caustics(vec2 p) {\n    float v = 0.0;\n    float a = 0.4;\n    for (int i = 0; i<3; i++) {\n        v += voronoi(p)*a;\n        p *= 2.0;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nfloat godRays(vec3 rayDir) {\n \t\n    vec3 col = vec3(0.);\n    float y = rayDir.y * 0.5 + 0.5;\n    \n    float a = atan(rayDir.x, rayDir.z);\n    \n    float rays = sin(a*28.+iTime) * sin(a*27.-iTime) * sin(a*22.);\n    rays = max(0., rays);\n    // cut the lower part of the rays\n    rays *= smoothstep(0.2, 1., y);\n    // decrease brightness\n    rays *= smoothstep(.7, 0., y);\n    \n    return rays+0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 GROUND_COLOR = vec3(0.25);\n    vec3 HORIZON_COLOR = vec3(0.0, 0.05, 0.2);\n    vec3 LIGHT_DIR = vec3(1, 5, -4);\n    \n    // camera\n    vec3 camPos = vec3(3.0*sin(iTime*0.25), 7.0, -1.*iTime);\n    camPos = vec3(10.0*sin(iTime*0.2), 7., -9.);\n    //camPos = vec3(3., 6., -9.);\n    \n    vec3 camTarg = vec3(1., 4., 4.);\n    mat3 camMat = lookAt(camPos, camTarg, 0.0);\n    vec3 rayDir = normalize(camMat * vec3(uv.xy, 1.0));\n   \n    vec3 col = vec3(1.0);\n    \n    Obj hitObj = rayMarch(camPos, rayDir);\n   \t\n    if (hitObj.type == WATER) {\n    \n      col = mix(vec3(1.), HORIZON_COLOR, pow(1.0 - pow(rayDir.y, 4.), 50.0));\n    \n    } else if (hitObj.type == GROUND) {\n      \n        float dif = getLight(hitObj.hitPos, LIGHT_DIR) * hitObj.hitPos.y * 0.26;\n        col = vec3(dif);\n                     \n        float caust = caustics(uv)*3.5;       \n        col *= clamp(caust, 0.5, 1.);       \n        \n        // Use Beer's law for calculating attenuation\n\t\tvec3 attenuation = exp(-vec3(0.3, 0.15, 0.08)*hitObj.dist);\n        col = mix(HORIZON_COLOR, col, attenuation);\n    }\n    \n    float godRay = godRays(rayDir);\n  \n    vec3 lightColor = mix(vec3(1.), col, 1.0 - uv.y);\n    vec3 finalColor = mix(col, lightColor, godRay);\n    \n    col = pow(finalColor,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKSzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 317, 337, 337, 419], [421, 450, 473, 575, 1246], [1249, 1485, 1541, 1541, 1776], [1778, 1778, 1799, 1838, 2032], [2034, 2034, 2066, 2066, 2736], [2738, 2738, 2763, 2763, 3021], [3023, 3023, 3062, 3117, 3440], [3442, 3500, 3556, 3556, 3782], [3784, 3863, 3881, 3881, 3979], [3981, 3981, 4004, 4042, 4804], [4806, 4862, 4886, 4886, 5041], [5043, 5043, 5094, 5094, 5298], [5300, 5300, 5328, 5328, 5699], [5701, 5701, 5758, 5838, 7213]], "test": "untested"}
{"id": "WtKXDw", "name": "Business Card Raytracer", "author": "mla", "description": "Just so no one else has to do this...\n\nPort of Andrew Kensler's Business Card Shader, as dissected by Fabien Sanglard: [url]http://fabiensanglard.net/rayTracing_back_of_business_card/index.php[/url]\n\nJust 4 rays cast per pixel.\n", "tags": ["businesscard"], "likes": 13, "viewed": 348, "published": "Public API", "date": "1582897240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int[] G=int[](74895,74897,74897,74895,74881,74881,55438,128,128); int s;float R(\n){s*=2654289789; return float(s)/4294967296.0;} int T(vec3 o,vec3 d,out float t, \nout vec3 n){t=1e9;int m=0; float p=-o.z/d.z; if(0.01<p)t=p,n=vec3(0,0,1),m=1;for\n(int k=17;bool(k--);)for(int j=9;bool(j--);)if(bool(G[j]&1<<k)){vec3 p=o+vec3(-k\n,0,-j-4); float b=dot(p,d),c=dot(p,p)-1.0,q=b*b-c; if(q>0.0){ float s=-b-sqrt(q)\n; if(s<t&&s>.01) t=s,n=normalize(p+d*t),m=2;}} return m;} vec3 S(vec3 o,vec3 d){\nvec3 c=vec3(0);float a=1.;for(int k=0;k<3;k++){float t;vec3 n; int m=T(o,d,t,n);\nif(m==0) return vec3(0.7,0.6,1.0)*pow(1.0-d.z,4.); vec3 h=o+d*t,l=normalize(vec3\n(9.0+R(),9.0+R(),16.0)+-h),r=d+n*(dot(n,d)*-2.0); float b=dot(l,n); if(b<0.0||T(\nh,l,t,n)!=0)b=0.0; float p=pow(dot(l,r)*float(b>0.),99.); if(bool(m&1)){h=h*0.2;\nreturn((int(ceil(h.x)+ceil(h.y))&1)!=0?vec3(3,1,1):vec3(3))*(b*0.2+0.1);}c+=vec3\n(p)*a,a*=0.5,o=h,d=r;} return c;}void mainImage(out vec4 O,vec2 C) {vec3 o=15.0*\nvec3(sin(iTime),cos(iTime),0.8+.7*cos(.321*iTime)),g=normalize(vec3(9,0,5)-o),a=\nnormalize(cross(vec3(0,0,1),g))*.002,b=normalize(cross(g,a))*.002,c=(a+b)*-256.+\ng;s=int(1000.*C.x+C.y); vec2 q=vec2(0.6*iResolution.x-C.x,C.y)*512./iResolution.\ny;vec3 p=vec3(13); for(int r=4;bool(r--);){vec3 t=(a*(R()-.5)+b*(R()-.5))*50.0;p\n+=S(o+t,normalize(-t+(a*(R()+q.x)+b*(q.y+R())+c)*16.0))*56.0;}O=vec4(p/255.,0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 83, 83, 128], [129, 129, 175, 175, 463], [464, 464, 486, 486, 925], [925, 925, 960, 960, 1377]], "test": "untested"}
{"id": "WtKXRh", "name": "02 Simple Shapes", "author": "waffles", "description": "Examples of simple shapes", "tags": ["shadertoy", "shapes"], "likes": 0, "viewed": 68, "published": "Public", "date": "1582187104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed under Creative Commons CC0: https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// More 2D shapes here: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nmat2 rotateZ(float angleDeg)\n{\n  // \"radians — convert a quantity in degrees to radians\"\n  float angleRad = radians(angleDeg);\n  // http://mathworld.wolfram.com/RotationMatrix.html\n  mat2 rot = mat2(vec2(cos(angleRad), sin(angleRad)), vec2(-sin(angleRad), cos(angleRad)));\n  return rot;\n}\n\nfloat circle(vec2 coord, float size)\n{\n  // \"length — calculate the length of a vector\"\n  return length(coord)-size;\n}\n\nfloat rect(vec2 p, vec2 b)\n{\n    /*\n    // \"Traditional\" CPU way-of-working could look something like this\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width; x++) {\n            plotPixel(positionX + x, positionY + y);\n        }\n    }\n\n\t// GPU way-of-working would then be like\n\tif (positionX >= x && positionX < x+width\n\t\t&& positionY >= y && positionY < y+height) {\n\t\tplotPixel(positionX, positionY);\n\t}\n    */\n\n  // \"abs — return the absolute value of the parameter\"\n  vec2 d = abs(p) - b;\n  // \"min — return the lesser of two values\"\n  // \"max — return the greater of two values\"\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Note that IQ provides much more efficient way to do this\n// however this is to illustrate that more complex shapes\n// can be created from simpler shapes\nfloat xcross(vec2 p, vec2 b)\n{\n  p *= rotateZ(45.0);\n  float dist = rect(p, b);\n\n  p *= rotateZ(90.0);\n  dist = min(dist, rect(p, b));\n\n  return dist;\n}\n\nfloat triangle(vec2 p, vec2 h)\n{\n  // https://en.wikipedia.org/wiki/Steiner_tree_problem\n  // \"sqrt — return the square root of the parameter\"\n  float steinerRatio = sqrt(3.0)/2.0;\n  return max(-h.y,max(abs(p).x*steinerRatio-p.y*0.5,p.y)-h.x*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup coordinates here\n    // \"uv\" refers to UV mapping https://en.wikipedia.org/wiki/UV_mapping\n    // just think UV as normalized coordinates in the screen\n    // where x is 0.0 - 1.0 and y is 0.0 - 1.0\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspectRatio = vec2(iResolution.x/iResolution.y, -1.0);\n    vec2 coord = aspectRatio * (uv - 0.5);\n\n    // define shapes\n    // \"d\" is for distance.\n    // Shape is drawn in later part, when the value is negative :-)\n    float d = triangle(coord + vec2(0.4,-0.03), vec2(0.12));\n    \n    d = min(d,\n        // Circle with a hole\n        max(circle(coord + vec2(0.12,0.0), 0.1),\n        -circle(coord + vec2(0.12,0.0), 0.08))\n    );\n    d = min(d, xcross(coord + vec2(-0.13,0.0), vec2(0.04,0.1)));\n    d = min(d, rect(coord + vec2(-0.4,0.0), vec2(0.09)));\n    \n    d = min(d, xcross(coord + vec2(-0.13,0.0), vec2(0.04,0.1)));\n\t\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Apply shapes\n    // \" sign returns -1.0 if x is less than 0.0, 0.0 if x is equal to 0.0, and +1.0 if x is greater than 0.0. \"\n    col = sign(d)*col;\n    vec3 shapeColor = vec3(1.0,0.0,0.0);\n    if (uv.y > 0.5) {\n      //antialiased version\n      // \"mix — linearly interpolate between two values\"\n      // \"smoothstep performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where a threshold function with a smooth transition is desired.\"\n      col = mix(col, shapeColor, 1.0-smoothstep(0.0,0.003,d));\n    } else {\n      //not antialiased version\n      col = mix(col, shapeColor, d > 0.0 ? 0.0 : 1.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXRh.jpg", "access": "shaders20k", "license": "cc0-1.0 OR openssl-ssleay OR apache-2.0", "functions": [[104, 205, 235, 295, 495], [497, 497, 535, 586, 617], [619, 619, 647, 1112, 1285], [1287, 1443, 1473, 1473, 1595], [1597, 1597, 1629, 1741, 1848], [1850, 1850, 1907, 2119, 3584]], "test": "untested"}
{"id": "WtKXRm", "name": "diffraction visualization", "author": "theinventor13", "description": "just a quickie", "tags": ["thing"], "likes": 2, "viewed": 58, "published": "Public", "date": "1582430283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = (iResolution.x/iResolution.y);\n    vec2 uv = fragCoord/iResolution.y;\n    float spread = iMouse.x / (2.0f * iResolution.x);\n    vec2 p1 = vec2(spread * scale, 0.5f);\n    vec2 p2 = vec2((1.0f-spread) * scale, 0.5f);\n    float dist = 100.0f * (iMouse.y / iResolution.y);\n    if(iMouse.xy == vec2(0)){\n        dist = 100.0f;\n    }\n    float d1 = length(uv - p1) * dist;\n    float d2 = length(uv - p2) * dist;\n    float freq = 10.0f;\n    float phase = 0.0f;\n    float sum = sin(-freq*iTime + phase + d1) + sin(-freq*iTime + phase + d2);\n    sum = sum + 2.0f;\n    sum = sum / 4.0f;\n    sum *= sum;\n    vec3 col;\n    col.r = sum;\n    \n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 813]], "test": "untested"}
{"id": "wtKXRW", "name": "Product of chance", "author": "suraimu752", "description": "Not what I wanted to do.", "tags": ["raymarching"], "likes": 3, "viewed": 70, "published": "Public", "date": "1582313272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdBox(vec3 p, vec3 size){\n    return length(max(abs(p) - size, 0.)) - .05;\n}\n\nfloat grid(vec3 p){\n    // return length(vec3(2.5) - abs(p)) - .5;\n    float r = abs(p.z - 2.5);\n    if(r < 0.001){\n        // r = 100.;\n    }\n    return r;\n}\n\nvec3 trans(vec3 p){\n    float m = 5.;\n    vec3 q = mod(p, m) - m * .5;\n    q.x += (rand(floor(p.yz * .2)) * 2. - 1.) * .4;\n    q.y += (rand(floor(p.zx * .2)) * 2. - 1.) * .4;\n    q.z += (rand((floor(p.xz * .2) + floor(p.yy * .2)) * .01) * 2. - 1.) * 3.9;\n    // q.y += (rand(floor(p.xz * .2)) * 2. - 1.) * .4;\n    return q;\n}\n\nfloat dist(vec3 p){\n    return sdBox(trans(p), vec3(1.8, 1.8, .5));\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        dist(p + vec3(d, 0., 0.)) - dist(p + vec3(-d, 0., 0.)),\n        dist(p + vec3(0., d, 0.)) - dist(p + vec3(0., -d, 0.)),\n        dist(p + vec3(0., 0., d)) - dist(p + vec3(0., 0., -d))\n    ));\n}\n\nvec3 rotateX(vec3 p, float th){\n    return p * mat3(\n        1, 0, 0,\n        0, cos(th), -sin(th),\n        0, sin(th), cos(th)\n    );\n}\nvec3 rotateY(vec3 p, float th){\n    return p * mat3(\n        cos(th), 0, sin(th),\n        0, 1, 0,\n        -sin(th), 0, cos(th)\n    );\n}\nvec3 rotateZ(vec3 p, float th){\n    return p * mat3(\n        cos(th), -sin(th), 0,\n        sin(th), cos(th), 0,\n        0, 0, 1\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 lightDir = normalize(vec3(.3, .5, -1.5));\n\n    vec3 col = vec3(0.);\n\n    vec3 screen = vec3(uv, 0.), cpos = vec3(0, 0, -.3);\n    vec3 v = normalize(screen - cpos), p = cpos;\n    \n    p += vec3(0., 0., iTime);\n\n    float d;\n\n    for(int i = 0; i < 2000; i++){\n        d = dist(p) * .2;\n        p += v * d;\n        if(d < 0.001) {\n            vec3 normal = getNormal(p);\n            col = vec3(1.) * max(0., dot(normal, lightDir));\n            break;\n        }\n    }\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 94], [96, 96, 127, 127, 178], [180, 180, 199, 246, 338], [340, 340, 359, 359, 665], [667, 667, 686, 686, 736], [738, 738, 761, 761, 1010], [1012, 1012, 1043, 1043, 1148], [1149, 1149, 1180, 1180, 1285], [1286, 1286, 1317, 1317, 1422], [1424, 1424, 1478, 1478, 2072]], "test": "untested"}
{"id": "WtKXRz", "name": "Shaderplayer default shader", "author": "ttg", "description": "Default shader of [url=https://shaderplayer.com/]Shaderplayer[/url].  It's also meant as a very basic tutorial.  Is this a good compromise between having a somewhat interesting animation and still being short and understandable?", "tags": ["simple", "demo"], "likes": 5, "viewed": 302, "published": "Public API", "date": "1582092924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragData, in vec2 fragCoord ) {\n\n  // Always initialize all variables\n  fragData = vec4(0.);\n\n  // Start all black\n  vec3 color = vec3(0.);\n\n  // A coordinate system for a 2D drawing, centered in frame, preserving aspect\n  vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n\n  // A soft circle\n  color = mix(color, vec3(.2), clamp( 4.-5.*length(uv), 0., 1.));\n\n  // Various sines\n  for (float i=0.; i<8.; i++) {\n    float h = i*.6;\n    float k = exp2(i/8.);\n    vec3 c = pow(.5+.5*cos(h-vec3(0,1,2)*2.094),vec3(2.));\n    color += .2*c*max( 0., 1.-2.*abs( sin(k*uv.x+iTime/k)*k - uv.y )/k );\n  }\n\n  // Convert to Gamma=2.2 and output to screen\n  fragData = vec4(pow(color, vec3(1./2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 94, 726]], "test": "untested"}
{"id": "wtKXzR", "name": "Alien Fuel", "author": "Arseny", "description": "Provide distorded electrycity field", "tags": ["2d", "plasma", "glow"], "likes": 4, "viewed": 297, "published": "Public API", "date": "1582365425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n\nvec2 rand(vec2 uv){\n    uv.x += 0.0004;\n    uv.y += 0.0007;\n    uv.x = floor(uv.x / 0.001) * 0.001;\n    uv.y = floor(uv.y / 0.001) * 0.001;\n    uv += vec2(13., 63.);\n    uv.x = fract(sin(uv.x * 10. * uv.y * uv.y)  * 438.5453);\n    uv.y = fract(cos(uv.x * uv.x * 10. * uv.y)  * 561.5453);\n    return uv;\n}\n\nvec2 uvtransform(vec2 uv, float strength){\n    float clsz = 0.01; // cellsize\n    //vec2 nwuv = float(int(uv / clsz)) * clsz;\n    int X = int(uv.x / clsz);\n    int Y = int(uv.y / clsz);\n    vec2 nwuv = vec2(float(X), float(Y)) * clsz;\n    vec2 A = mix(rand(nwuv + vec2(0., 0.)  ), rand(nwuv + vec2(clsz, 0.)  ), (uv - nwuv).x / clsz);\n    /*vec2 A = mix(\n        rand(vec2(float(X), float(Y))), \n        rand(vec2(float(X + 1), float(Y))), \n        (uv - nwuv).x / clsz\n    );*/\n    vec2 B = mix(rand(nwuv + vec2(0., clsz)), rand(nwuv + vec2(clsz, clsz)), (uv - nwuv).x / clsz);\n    vec2 ans = mix(A, B, (uv - nwuv).y / clsz);\n    return uv + (ans - vec2(0.5)) * 2. * strength;\n}\n\nconst float freq = 120.;\n\nfloat rand(float x){\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat f(float x){\n    x *= 100.;\n    return (2. + sin(x / 10.)) / (2. + cos(x / 10.)) / 20.;\n}\n\nfloat g(float x){\n    x *= 80.;\n    return pow(\n        (2. + sin(x / 10.)) / (2. + cos(x / 20.))\n    \t, 2.) /\n        2. / 40.;\n}\n\nfloat strange_func(float x){\n    float maxx = pow((exp(1.) - 1.), 0.1);\n    x *= maxx;\n    return (exp(1.) * log(pow(x, 10.) + 1.) / (pow(x, 10.) + 1.)) / \n           (exp(1.) * log(pow(maxx, 10.) + 1.) / (pow(maxx, 10.) + 1.));\n}\n\nfloat res(float x, float t){\n    //x /= iResolution.x;\n    return mix(f(x - 20. * t) + g(x + 30. * t), f(-20. * t) + g(30. * t), strange_func(abs(x - 0.5) * 2.));\n}\n\nvec4 grad(float x){\n    //vec3 col = vec3(200., 0., 200.) / 256.;\n    vec3 col = vec3(68., 27., 85.) / 256.;\n    float cntrblur = 0.005;\n    float bordblur = 0.05;\n    if (abs(x) < cntrblur){\n    \treturn vec4(mix(vec3(1.), col, abs(x) / cntrblur), 1.);\n    } else {\n        return vec4(mix(col, vec3(0.), (abs(x) - cntrblur) / bordblur), 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv = uvtransform(uv, 0.01);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float t = iTime / 100.;\n    \n    /*fragColor = vec4(\n    \tvec3(sign(mix(A, B, uv.x * 20. - floor(uv.x * 20.)) / 5. - uv.y)),\n        1.\n    );*/\n    \n    vec2 cent = vec2(iResolution.x / iResolution.y / 2., 0.5);\n    float r = 0.1;\n    vec2 cn = uv - cent;\n    float ag = (atan(cn.y, cn.x) + pi) / pi / 2.;// + iTime / 1000.;\n    float y = length(cn) - r;\n    \n    float outr = 0.3;\n    \n    float block = floor(ag * freq);\n    float timeShift = floor(iTime * 8.) * 0.3;\n    float A = rand(block + timeShift);\n    float B = rand(mod(block + 1., freq) + timeShift);\n    \n    if (length(cn) < outr){\n        fragColor = vec4(vec3(\n            1. - smoothstep(-0.01, 0.01, y - res(ag, t))\n        ), 1.);\n    } else {\n        if (res(ag, t) > 0.1){\n            fragColor = grad(mix(A, B, ag * freq - block) / 20. - y + outr);\n        }\n    }\n    \n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    /*fragColor = vec4(vec3(\n        smoothstep(-0.01, 0.01, uv.y - res(uv.x, t))\n    ), 1.);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 326], [328, 328, 370, 370, 1007], [1035, 1035, 1055, 1055, 1096], [1098, 1098, 1115, 1115, 1192], [1194, 1194, 1211, 1211, 1324], [1326, 1326, 1354, 1354, 1556], [1558, 1558, 1586, 1612, 1722], [1724, 1724, 1743, 1789, 2074], [2076, 2076, 2133, 2183, 3348]], "test": "untested"}
{"id": "WttSD2", "name": "Laughing smile", "author": "henrmota", "description": "A basic shader", "tags": ["smile"], "likes": 2, "viewed": 40, "published": "Public", "date": "1581725959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float drawRectangle(vec2 uv, vec2 p, float width, float height) {\n    float halfWidth = width / 2.0;\n    float halfHeight = height/2.0;\n    p.x -= halfWidth;\n    p.y -= halfHeight;\n    \n\tfloat horizontal = smoothstep(p.x, p.x+0.01, uv.x) - smoothstep(p.x + width, p.x + width + 0.01, uv.x); \n    float vertical = smoothstep(p.y, p.y+0.01, uv.y) - smoothstep(p.y + height, p.y + height + 0.01, uv.y); \n      \n    \n    return horizontal * vertical;\n    \n}\n\nfloat drawCircle(vec2 uv, vec2 p, float radius, bool onHalf) {\n    float dist = length(p - uv);\n    \n    float circle = smoothstep(radius, radius - 0.01, dist);\n    if(onHalf) {\n      p.y -= radius/2.0;\n      return circle * drawRectangle(uv, p, radius * 2., radius);\n    }\n    \n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x /iResolution.y;\n    float eye1 = drawCircle(uv, vec2(0.1, 0.1), 0.05, false);\n    float eye2 = drawCircle(uv, vec2(-0.1, 0.1), 0.05, false);\n    float mouth = drawCircle(uv, vec2(0., -0.05), 0.1 + 0.1 * abs(cos(iTime)), true);\n    float circle = drawCircle(uv, vec2(0, 0), 0.3, false);\n    circle = max(0., circle - eye1 - eye2 - mouth);\n    \n    // Time varying pixel color\n    vec3 col = vec3(1., 1., 0.) * circle;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 453], [455, 455, 517, 517, 754], [756, 756, 813, 863, 1416]], "test": "untested"}
{"id": "WttSDN", "name": "Mandelbrot Set - Simple", "author": "Chidvilas", "description": "Simple shader to visualize Mandelbrot set.", "tags": ["mandelbrot", "juliaset", "mandelbrotset"], "likes": 1, "viewed": 65, "published": "Public", "date": "1580971236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 c = vec2((uv.x * 2.0 - 1.5) * iResolution.x/iResolution.y, (uv.y * 2.0 - 1.0));\n\n    // Mandelbrot formula\n    vec2 z = c;\n    float iterations = 0.0;\n    float maxIterations = 2000.0;\n    const int maxii = 2000;\n\n    for (int i = 0; i < maxii; i++) {\n        float t = 2.0 * z.x * z.y + c.y;\n        z.x = z.x * z.x - z.y * z.y + c.x;\n        z.y = t;\n\n        if (z.x * z.x + z.y * z.y > 4.0) {\n            break;\n        }\n\n        iterations += 1.0;\n    }\n\n    if (iterations >= maxIterations) {\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = vec4(col*iterations,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 131, 872]], "test": "untested"}
{"id": "WttSR7", "name": "differenceSDF", "author": "jorge2017a1", "description": "differenceSDF", "tags": ["differencesdf"], "likes": 0, "viewed": 40, "published": "Public", "date": "1580653850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n};\n    \n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n//---------------------------------------------------\nfloat fbm(vec2 Oldp)\n{\n    float _scale = 0.58;\n    vec2 p;\n    p = Oldp * vec2(_scale);\n    float _value = -0.7;//sin(iTime*0.5);\n    float _frequency = 8.58;\n    float _amplitude = 2.18;\n\tfloat _power = 0.3;\n    vec2 i = floor(p * _frequency);\n    vec2 f = fract(p * _frequency);\n    vec2 t = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    vec2 a = i + vec2(0.0, 0.0);\n    vec2 b = i + vec2(1.0, 0.0);\n    vec2 c = i + vec2(0.0, 1.0);\n    vec2 d = i + vec2(1.0, 1.0);\n    \n    a = -1.0 + 2.0 * fract(sin(vec2(dot(a, vec2(127.1, 311.7)), dot(a, vec2(269.5, 183.3)))) * 43758.5453123);\n    b = -1.0 + 2.0 * fract(sin(vec2(dot(b, vec2(127.1, 311.7)), dot(b, vec2(269.5, 183.3)))) * 43758.5453123);\n    c = -1.0 + 2.0 * fract(sin(vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)))) * 43758.5453123);\n    d = -1.0 + 2.0 * fract(sin(vec2(dot(d, vec2(127.1, 311.7)), dot(d, vec2(269.5, 183.3)))) * 43758.5453123);\n    \n    float A = dot(a, f - vec2(0.0, 0.0));\n    float B = dot(b, f - vec2(1.0, 0.0));\n    float C = dot(c, f - vec2(0.0, 1.0));\n    float D = dot(d, f - vec2(1.0, 1.0));\n    \n    float noise = (mix(mix(A, B, t.x), mix(C, D, t.x), t.y));\n    _value += _amplitude * noise;\n    _value = clamp(_value, -1.0, 1.0);\n    return pow(_value * 0.5 + 0.5, _power);\n}\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +sa, +1.0);\n}\n\nvec2 rot(vec2 p,float r)\n{\n   vec2 ret;\n   ret.x=p.x*cos(r)-p.y*sin(r);\n   ret.y=p.x*sin(r)+p.y*cos(r);\n   return ret;\n}\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n///----------------------\nfloat floorTex(vec3 rp) {\n    rp.x += iTime * -2.0;\n    vec2 m = mod(rp.xz, 4.0) - 2.0;\n    if (m.x * m.y > 0.0) {\n        return 0.8 + noise(rp * 4.0) * 0.16;\n    }\n    return 0.2 + noise((rp + 0.3) * 3.0) * 0.1;\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n\n//-------------------------------------------------------------\n\nfloat GetDist(vec3 p  ) {\t\n\n \t\n    \n    float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n    float planeDist = p.y;\n    \n   vec3 pp;\n    pp=p;\n    \n \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    \n     if (res.x < planeDist)\n      { res.x = res.x;     \t} \n    else\n        { \n          res.x = planeDist;\n        if (planeDist > 0.5 )\n          { res=vec2(res.x,8); }\n        else\n         { \n            //res=vec2(res.x, 9);\n             \n             res=vec2(res.x, 13);\n             \n         } \n     }\n\t\n    \n   \n     float sdb1=sdBox(p, vec3(15.5,15.0,5.0));\n    float sdc1 =sdCylinder( p-vec3(0.5,0.0,5.5), vec2(1.0,17.0) );\n    float sdc2 =sdCylinder( p-vec3(2.5,0.0,3.5), vec2(2.0,17.0) );\n    float sdc3 =sdCylinder( p-vec3(4.5,0.0,4.0), vec2(1.5,17.0) );\n    float sdc4 =sdCylinder( p-vec3(-1.5,0.0,4.5), vec2(1.2,17.0) );\n    float sdc5 =sdCylinder( p-vec3(-4.0,0.0,3.5), vec2(2.2,17.0) );\n    float sdc6 =sdCylinder( p-vec3(-8.0,0.0,3.5), vec2(3.2,17.0) );\n    float sdc7 =sdCylinder( p-vec3(-10.0,0.0,3.5), vec2(4.2,17.0) );\n    float sdc8 =sdCylinder( p-vec3(11.5,0.0,4.0), vec2(4.5,17.0) );\n     dif1= differenceSDF(sdb1 , sdc1);\n     dif1= differenceSDF(dif1 , sdc2);\n     dif1= differenceSDF(dif1 , sdc3);\n     dif1= differenceSDF(dif1 , sdc4);\n     dif1= differenceSDF(dif1 , sdc5);\n     dif1= differenceSDF(dif1 , sdc6);\n     dif1= differenceSDF(dif1 , sdc7);\n     dif1= differenceSDF(dif1 , sdc8);\n    \n    res=opU(res, vec2(dif1,8.0));\n        \n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n       \n        \n\t\t\n        \n    }\n    \n    return dO;\n}\n\n\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 10, 7);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(sin(iTime), cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat GetLightv2(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //Determine movement of light ex. shadow and light direction and diffusion\n    lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\nvec3 calcLuz(vec3 p, vec3 origin, vec3 l, vec3 n )\n{\n    \n    vec3 idiffuse=vec3(0.8);\n    vec3 ispecular=vec3(0.7);\n    vec3 lightcolor=vec3(0.7,0.8,0.5);\n    \n    vec3 v = normalize(origin-p);\n\tvec3 h = normalize(l+v);\n\tfloat NdotL = saturate(dot(n,l));\n\tfloat NdotH = saturate(dot(n,h));\n\tvec3 diffuse = NdotL*idiffuse;\n\tvec3 spec = 0.18 * pow(NdotH,40.0) * ispecular;\n\tvec3 color;\n\t\n    color = (diffuse+spec) * lightcolor;\n    return  color;\n}\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n     case 12:\n        vec3 tmp;\n        tmp =glpRoRd;\n        \n        tmp=rotate_x(tmp,90.0);\n        \n        return  vec3(0.8, 1.0, 0.4) * floorTex(tmp); \n     case 13:\n        float d = 0.0;\n\t\t\t// checkerboard function that returns 0 or 1\n\t\t\td = mod(floor(glpRoRd.x)+floor(glpRoRd.z),2.0);\n\t\t\t// vary between red (0) and yellow (1)\n\t\treturn vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n     case 14:\n        \t// checkerboard hack\n\t\t\tvec2 cb = floor(glpRoRd.xz);\n\t\t\tfloat cb2 = mod(cb.x + cb.y, 2.0);\n        \treturn vec3(0.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n       case 15:\n    \t\treturn vec3(1.0,0.0,1.);\n       case 16:\n    \t\treturn vec3(1.0,1.0,0.0);\n     \n        case 17:\n        \tfloat tmps;\n        \ttmps=fbm(gres2);\n        \treturn  vec3(tmps );\n       case 18:\n        \treturn vec3(1.0,0.0,0.0);\n       case 19:\n        \treturn vec3(0.0,1.0,0.0);\n        \n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n   \n     vec2 pp = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float an = 10.*iMouse.x/iResolution.x;\n    float yt = iTime *1.2; // 5.*iMouse.y/iResolution.y;\n    float zoom = 2.15;\n    \n    \n    vec3 ta = vec3(5.,1.95,-10.);\n    //vec3 ro = vec3(-5.,0.5,-80.+iTime);\n    vec3 ro = vec3(-5.,6.5,30.);\n    \n    \n\tro = get_mouse(ro);\n    \n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross(ww,vec3(0.,1.,0.)));\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 rd = normalize( pp.x*uu + pp.y*vv + 1.8*ww );\n    \n    float stime = iTime * 0.3;\n\n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n \n\n    vec3 rLuz=vec3(0.5, 3.5, 4.5);\n    vec3 rLuz3=vec3(5.5, 1.5, -4.5);\n    \n   \n\n    float d = RayMarch(ro, rd);\n    //mObj.dist =d;\n    Obj=mObj;\n    \n  \n    \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    vec3 pluz=(rLuz + rd * d );\n    vec3 pluz3=(rLuz3 + rd * d );\n   \n    \n    float dif = GetLight(p);\n\n    float dif2 = abs(1.0- GetLightv2(pluz));\n    float dif3 = abs(1.0- GetLightv2(pluz3));\n    \n   \n    mObj.dist =d;\n        \n       \n    vec3 colobj;\n    \n    colobj=getSphereColor(int( Obj.tipo));\n \n\n    col =  ( vec3(dif)+colobj)/1.5;\n    \n    \n    fragColor = vec4(col,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 362, 395, 395, 460], [461, 479, 515, 515, 584], [585, 600, 631, 631, 781], [782, 802, 838, 838, 925], [926, 942, 974, 1002, 1063], [1065, 1065, 1101, 1101, 1204], [1207, 1261, 1283, 1283, 2543], [2548, 2548, 2594, 2594, 2626], [2628, 2628, 2671, 2671, 2703], [2705, 2705, 2753, 2753, 2786], [2789, 2789, 2818, 2818, 2944], [2946, 2946, 2982, 2982, 3099], [3101, 3101, 3137, 3137, 3255], [3257, 3257, 3293, 3293, 3416], [3418, 3418, 3444, 3444, 3538], [3589, 3601, 3623, 3623, 3931], [3932, 3958, 3983, 3983, 4173], [4176, 4176, 4228, 4228, 4383], [4396, 4461, 4486, 4486, 6046], [6049, 6049, 6083, 6083, 6472], [6477, 6477, 6501, 6501, 6733], [6737, 6737, 6761, 6761, 7147], [7150, 7150, 7176, 7176, 7540], [7543, 7543, 7568, 7568, 7596], [7598, 7598, 7650, 7650, 8046], [8149, 8193, 8210, 8210, 8281], [8306, 8398, 8423, 8423, 8686], [8688, 8747, 8775, 8775, 10658], [10662, 10662, 10719, 10719, 12054]], "test": "untested"}
{"id": "WttSRB", "name": "MandelBrot and Julia SideBySide", "author": "DaMastaCoda", "description": "Drag mouse over the left image and observer the right", "tags": ["rgf"], "likes": 3, "viewed": 53, "published": "Public", "date": "1581224625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat mandel(vec2 pos, vec2 c) {\n\n    vec2 z = pos;\n    for(int i = 0; i < 1000; i++) {\n        z.xy = vec2(z.x*z.x-z.y*z.y,z.x*z.y*2.0f) + c;\n    }\n    \n    return length(z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = fragCoord/iResolution.x;\n\tvec3 col = vec3(0.0f,0.0f,0.0f);\n    vec2 uv = (fragCoord-vec2(iResolution.x/4.0f,iResolution.y/2.0f))/iResolution.x*8.0f;\n    if(u.x < 0.5) {\n        uv.x += -1.0f;\n        col = hsv2rgb(vec3((mandel(uv,uv)+iTime)/10.0f,1.0f,1.0f));\n    } else {\n        uv.x += -4.0f;\n        vec2 mouse = (iMouse.xy-vec2(iResolution.x/4.0f,iResolution.y/2.0f))/iResolution.x*8.0f;\n        mouse.x += -1.0f;\n\n        col = hsv2rgb(vec3((mandel(uv,mouse)+iTime)/10.0f,1.0f,1.0f));\n    }\n    \n    fragColor = vec4(col,1.0);\n  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttSRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 191], [193, 193, 225, 225, 370], [372, 372, 429, 479, 1030]], "test": "untested"}
{"id": "wttSRS", "name": "grid of poles (pseudo phasor no)", "author": "FabriceNeyret2", "description": "artificials phasor noise with no discont.\nMouse.y: grid scale  Mouse.x: jitter scale\nSettle poles at nodes of square grid so that phasor angle does 1 turn around node (in checkered direction).\nHue = phasor (i.e. phase offset in the regular oscillation)\n", "tags": ["noise", "interpolation", "phasor"], "likes": 6, "viewed": 371, "published": "Public API", "date": "1581249538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// interp from triangle sides : see https://www.desmos.com/calculator/anchdwvynw\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         V = u/R.y,\n         M = iMouse.xy/R,\n         U = V * (iMouse.x < 10. ? 5. : 20.*M.y),\n         F = fract(U)*2.-1.,     // coords in tile in [-1,1]²\n         I = mod(floor(U),2.);   // tile id in checker pattern\n\n    float n = iMouse.x < 10. ? 10. : 20.*M.x,      // noise scale\n          x = F.x, y = F.y, k=0., X,Y,Z, a,c, v, s = sqrt(2.);\n                                                // --- settle phase at edges\n#if 1                   // checker : 2pi turn around nodes\n    a = I==vec2(0) ? abs(y) > abs(x) ? 4. : 0.  // phase along diagonals\n                   : I.y==0. ? I.x : 3.-I.x;\n    c = abs(y) < abs(x) ? I.y==0. ?  .5 : 2.5   // phase along tile border\n                        : I.x==0. ? 3.5 : 1.5;\n    a /= 4.; c /= 4.;\n#else                   // no checker : 8pi turn around nodes\n    float S = I.x==I.y ? 1. : 0.;\n    a =  abs(y) > abs(x) ? S : 1.-S;            // phase along diagonals\n    c = .5;                                     // phase along tile border\n#endif\n                                                // --- get triangle coordinates\n    if ( abs(y) > abs(x) ) k=x,x=y,y=k;         // wrap to first quadrant (right triangle in tile)\n    x = abs(x), \n    X = (x-y)/s, Y = (x+y)/s, Z = 1.-x;         // coords in triangle\n    float A = Y*Z, B=X*Z, C=X*Y;                // --- interp within triangle\n    v = ( a*A + a*B + c*C ) / (A+B+C) ;\n\n    v += 1.*texture(iChannel0,(n*V+.5*0.)/iChannelResolution[0].x).x; // global perturbations\n    O = hue(v); //return;\n    // v = .5+.5*sin(30.*6.28*v);               // display isolines\n    \n    v = .5 + .5* sin( 150.* dot(V-.5, cos(.1*iTime+vec2(0,11))) + 6.28*v ); // phasor\n    \n    O *= vec4(v);\n\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttSRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 189, 227, 227, 1947]], "test": "untested"}
{"id": "wttSWX", "name": "Length(gv)-rad and atan Static", "author": "soundmasteraj", "description": "Martijn mentioned iq's sdf, got intertwined with a color calculation; pretty accident, more of a standing wave", "tags": ["radial", "distance", "distance", "tangential"], "likes": 2, "viewed": 244, "published": "Public API", "date": "1581878211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Length(gv)-rad and atan gv\" by soundmasteraj. https://shadertoy.com/view/WtdXDf\n// 2020-02-16 18:36:05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y+.5;\n\tvec2 gv = vec2(uv.x * 5., -.25 + uv.y * 5.);\n    float rad = .25 +.01 -cos(iTime)*.25+.25;\n    float dist = length(gv*rad)-rad;\n\n    vec3 col =atan(gv.x*uv.x*.5, gv.y*rad) + .618 *cos(iTime+dist+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 116, 173, 223, 553]], "test": "untested"}
{"id": "wttXD7", "name": "Heart Demo", "author": "17dpn01", "description": "Heart shader demo for FemmeHack 2020. \nBasecode borrowed from https://www.shadertoy.com/user/iq heart shader at https://www.shadertoy.com/view/4lK3Rc.", "tags": ["heart"], "likes": 2, "viewed": 66, "published": "Public", "date": "1581178685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat heartShape(vec3 p, float rad) {\n    // TODO 1: Change this to a heart SDF function\n    \n    //float result = length(p) - rad;\n\n    //return result;\n    \n    \n    float z = p.z * (2.0 - p.y / 15.0);\n    float y = 1.3 * p.y - abs(p.x) * sqrt(1.0 - abs(p.x));\n    vec3 p2 = vec3(p.x, y, p.z);\n    return length(p2) - rad;\n}\n\n// TODO 2.1: Write function to call heartShape with animated radius\n\n// SDF for the scene\nfloat sceneSDF(vec3 samplePoint) {\n\n    // we want to make the sphere bigger\n    // we will do this by \n    //samplePoint *= vec3(sin(iTime), 1.0, cos(iTime));\n    float result = heartShape(samplePoint, 0.2 * abs(sin(PI * iTime * 0.5 + samplePoint.y * 0.1)) + 0.6);\n    return result;\n}\n\n\n// get shortest distance to surface using ray marching\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        // TODO 2.1: Call animated radius version of SDF instead of heartShape\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        //float dist = heartShape(eye + depth * marchingDirection, 0.5);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n\n        // SPHERE CASTING! :D\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}           \n\n/////// ******** SHADER STUFF ******** ///////\n/////// don't worry about all of this! ///////\n/////// this is all to make the heart  ///////\n/////// shiny. if you want to know     ///////\n/////// more about this, ask or pop me ///////\n/////// an email!\t\t\t\t\t   ///////\n\n// estimate normal using SDF gradient\nvec3 estimateNormal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy * heartShape(pos + e.xyy, 0.7 ) +\n\t\t\t\t\t  e.yyx * heartShape( pos + e.yyx, 0.7 ) + \n\t\t\t\t\t  e.yxy * heartShape( pos + e.yxy, 0.7 ) + \n\t\t\t\t\t  e.xxx * heartShape( pos + e.xxx, 0.7 ));\n}\n\nvec2 map( vec3 q )\n{\n    q *= 100.0;\n\n    vec2 res = vec2( q.y, 2.0 );\n\n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    d = d/3.0;\n    if( d<res.x ) res = vec2( d, 1.0 );\n    \n    res.x /= 100.0;\n    return res;\n}\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 kk;\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.01 + ap*0.2 ).x*20.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\n/////////////////////////////////////////////////\n//////////////// end of shader ! ////////////////\n/////////////////////////////////////////////////\n\n\n/////////////// main function ///////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 eye = vec3(0, 0, 5.0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n\n    float an = 0.2*(iTime+2.0);\n    float u = gl_FragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = gl_FragCoord.y * 2.0 / iResolution.y - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 rayOrigin = (right * u * aspect + up * v - eye);\n    vec3 rayDirection = normalize(cross(right, up));\n\n    float dist = shortestDistanceToSurface(rayOrigin, rayDirection, MIN_DIST, MAX_DIST);\n    \n    // if our ray didn't hit anything, \n    if (dist >= MAX_DIST - 2.0 * EPSILON) {\n        // TODO 3: Change background from white to color gradiant\n        //fragColor = vec4(1.0);\n\t\t//return;\n        \n        // blue\n        vec4 col1 = vec4(0.25, 0.3, 0.8, 1.0);\n\n        // yellow\n        vec4 col2 = vec4(1.2, 0.77, 0.5, 1.0);\n\n        fragColor = mix(col2, col1, v * 0.5);\n\t\treturn;\n    }\n    \n    vec3 position = rayOrigin + dist * rayDirection;\n    vec3 normal = estimateNormal(position);\n    vec3 ref = reflect(rayDirection, normal);\n    float fre = clamp(1.0 + dot(normal, rayDirection), 0.0, 1.0);\n    float occ = calcAO(position, normal); \n    occ = occ*occ;\n    // OPTIONAL TODO: change object color \n    vec3 col = vec3(0.9,0.05,0.01);\n    col = col*0.72 + 0.2*fre*vec3(1.0,0.8,0.2);\n            \n    vec3 lin  = 4.0*vec3(0.7,0.80,1.00)*(0.5+0.5*normal.y)*occ;\n    lin += 0.5*fre*vec3(1.0,1.0,1.00)*(0.6+0.4*occ);\n    //col = col * lin;\n    col += smoothstep(0.0,0.4,ref.y)*(0.06+0.94*pow(fre,5.0))*occ;\n\n    col = pow(col,vec3(0.4545));\n    col = clamp(col,0.0,1.0);\n    //col -= 0.5; //+ 0.8*pow(16.0*u*v*(1.0-u)*(1.0-v),0.2);\n    \n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 246, 362, 535], [606, 627, 661, 786, 913], [916, 971, 1062, 1062, 1551], [1833, 1871, 1902, 1902, 2155], [2157, 2157, 2177, 2177, 2665], [2667, 2667, 2703, 2703, 2879], [2881, 2881, 2905, 2905, 2947], [2949, 2949, 2991, 2991, 3284], [3438, 3488, 3545, 3545, 5224]], "test": "untested"}
{"id": "wttXDl", "name": "Palace of Mind", "author": "butadiene", "description": "IFS", "tags": ["raymarchingcineshader"], "likes": 9, "viewed": 16143, "published": "Public API", "date": "1581980540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 p,float r) {\n    mat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n    return m*p;\n}\n\nfloat cube(vec3 p,vec3 s) {\n    vec3 q = abs(p);\n    vec3 m = max(s - q,0.0);\n    return length(max(q - s,0.0)) - min(min(m.x,m.y),m.z);\n}\n\n\nfloat hasira(vec3 p,vec3 s) {\n    vec2 q = abs(p.xy);\n    vec2 m = max(s.xy - q.xy,vec2(0.0,0.0));\n    return length(max(q.xy - s.xy,0.0)) - min(m.x,m.y);\n}\n\nfloat closs(vec3 p,vec3 s) {\n    float d1 = hasira(p,s);\n    float d2 = hasira(p.yzx,s.yzx);\n    float d3 = hasira(p.zxy,s.zxy);\n    return min(min(d1,d2),d3);\n}\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat dist(vec3 p) {\n    float k = 1.2;\n    vec3 sxyz = floor((p.xyz - 0.5 * k) / k) * k;\n    float sz = rand(sxyz.xz);\n    float t = iTime*0.05+50.0;\n    p.xy = rot(p.xy, t*sign(sz-0.5) * (sz * 0.5 + 0.7));\n    p.z += t*sign(sz - 0.5)*(sz*0.5+0.7);\n    p = mod(p, k) - 0.5*k;\n    float s = 7.0;\n    p *= s;\n    p.yz = rot(p.yz, 0.76);\n    for (int i = 0; i < 4; i++) {\n        p = abs(p) - 0.4+(0.25+0.1*sz)*sin(t*(0.5+sz));\n        p.xy = rot(p.xy, t*(0.7+sz));\n        p.yz = rot(p.yz, 1.3*t+sz);\n    }\n\n    float d1 = closs(p,vec3(0.06,0.06,0.06));\n\n    return d1/s;\n}\n\nvec3 gn(vec3 p) {\n\n    const float h = 0.001;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * dist(p + k.xyy * h) +\n                     k.yyx * dist(p + k.yyx * h) +\n                     k.yxy * dist(p + k.yxy * h) +\n                     k.xxx * dist(p + k.xxx * h));\n\n}\nvec3 light(vec3 p,vec3 view) {\n    vec3 normal = gn(p);\n    float vn = clamp(dot(-view, normal),0.0,1.0);\n    vec3 ld = normalize(vec3(-1,0.9*sin(iTime*0.5)-0.1,0));\n    float NdotL = max(dot(ld, normal), 0.0);\n    vec3 R = normalize(-ld + NdotL * normal * 2.0);\n    float spec = pow(max(dot(-view, R), 0.0), 20.0) * clamp(sign(NdotL),0.0,1.0);\n    vec3 col = vec3(1, 1, 1) * (pow(vn,2.0)*0.9 +spec * 0.3);\n    float  k = 0.5;\n    float ks = 0.9;\n    vec2 sxz = floor((p.xz - 0.5 * ks) / ks) * ks;\n    float sx = rand(sxz);\n    float sy = rand(sxz+100.1);\n    float emissive = clamp(0.001/abs((mod(abs(p.y*sx+p.x*sy)+iTime*sign(sx-0.5)*0.4, k) - 0.5 * k)),0.0,1.0);\n    return clamp(col * vec3(0.3,0.5,0.9)*0.7 +emissive*vec3(0.2,0.2,1.0),0.0,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n    vec3 tn = iTime*vec3(0.0,0.0,1.0)*0.3;\n    float tk = iTime*0.3;\n    vec3 ro = vec3(1.*cos(tk),0.2*sin(tk),1.*sin(tk))+tn;\n    vec3 ta = vec3(0.0,0.0,0.0)+tn;\n    vec3 cdir = normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side = cross(cdir,up);\n    up = cross(side,cdir);\n    float fov = 1.3;\n    vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n    float d = 0.0;\n    float t = 0.1;\n    float far = 18.;\n    float near = t;\n    float hit = 0.0001;\n    for(int i =0;i<100;i++){\n      d = dist(ro+rd*t);\n      t += d;\n      if (hit>d) break;\n    }\n\tvec3 bcol = vec3(0.1, 0.1, 0.8);\n    vec3 col = light(ro + rd * t, rd);\n\n    col = mix(bcol, col, pow(clamp((far - t) / (far - near), 0.0, 1.0),2.0));\n\n   \tcol.x = pow(col.x,2.2);\n    col.y = pow(col.y,2.2);\n    col.z = pow(col.z,2.2);\n\tcol *= 2.0;\n    fragColor = vec4(col,1.1-t);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 93], [95, 95, 122, 122, 233], [236, 236, 265, 265, 392], [394, 394, 422, 422, 555], [556, 556, 577, 577, 650], [652, 652, 674, 674, 988], [990, 990, 1010, 1010, 1562], [1564, 1564, 1581, 1581, 1852], [1853, 1853, 1883, 1883, 2603], [2607, 2607, 2664, 2664, 3576]], "test": "untested"}
{"id": "wttXRB", "name": "Hexagons everywhere", "author": "Lokirbourg", "description": "This is the result of 2 days practicing shaders by watching the Art Of Code tutorials on YouTube. I tried to mix the Starfield tutorial with hexagons creation. And I also wanted to make those hexes react to the sound.", "tags": ["hexagons", "audioreact"], "likes": 2, "viewed": 140, "published": "Public", "date": "1581267137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Music: Lilith's Club by Noisia (Devil May Cry OST)*/\n\nfloat fft = 0.0;\n\nmat2 Rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat DrawHex(vec2 p)\n{;\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1.0, 1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nfloat Hash21(vec2 p)\n{\n\tp = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 HexesLayer(vec2 uv)\n{\n\tvec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) - 0.5; //tiling and making the middle of each tile the origin\n\tvec2 id = floor(uv);\n    \n    for (int y = -1; y <= 1; ++y)\n    {\n    \tfor (int x = -1; x <= 1; ++x)\n        {\n        \tvec2 offs = vec2(x, y);\n            float rand = Hash21(id + offs);\n            float hex = smoothstep(clamp(fft, 0.3, 1.0), 0.1, DrawHex(gv-offs- vec2(rand, fract(rand * 40.0)) + 0.5));\n        \tvec3 color = (sin(vec3(0.2, 0.3, 0.9) * fract(rand * 6531.3) * 532.4) * 0.5 + 0.5);\n            \n           \tcol += hex * color;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tuv *= 5.0;\n    \n    // read frequency data from first row of texture\n    //change the first value of the vec2 to influence the blinking effect\n    fft  = texture(iChannel0, vec2(0.01, 0.0)).x;\n    \n    float t = iTime * 0.2;\n    \n    uv *= Rot(sin(t * 2.0));\n\tvec3 col = vec3(0);\n    \n    float LayerCount = 1.7;\n    \n    for (float i = 0.0; i < 1.0; i+= 1.0 / LayerCount)\n    {\n        float depth = fract(i + t);\n        float scale = mix(5., 0.5, depth);\n    \tcol += HexesLayer(uv * scale + (i * 1000.0)) * (depth * smoothstep(1.0, 0.96, depth));\n    }\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xl2GzW", "previewfilepath": "https://soundcloud.com/noisia/liliths-club", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/noisia/liliths-club", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttXRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 93, 93, 166], [168, 168, 191, 191, 292], [294, 294, 316, 316, 413], [415, 415, 441, 441, 1038], [1040, 1040, 1097, 1147, 1829]], "test": "untested"}
{"id": "WttXWf", "name": "Light  Pillar", "author": "aodnawg", "description": "inspired: \n\n- https://neort.io/art/bk5brjk3p9f1nni4gddg\n- https://www.shadertoy.com/view/wl2GWG\n", "tags": ["raymarch"], "likes": 3, "viewed": 102, "published": "Public", "date": "1581866656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n\treturn mat2(\n    \tcos(a), sin(a), -sin(a), cos(a)\n    );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    \n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(vec3 p) {\n    vec3 pos = vec3(0,0,10);\n    pos = pos-p;\n    pos = abs(pos) - 2.;\n    \n   \tfor(int i=0; i<10; i++) {\n \t  \tpos = abs(pos) - 3.;\n        pos.xz *= rot(iTime*.1);\n\t}\n    \n    pos.xz *= rot(iTime);\n    pos.xz *= 1.+sin(p.y+iTime)*.5+sin(p.y+iTime*2.14)*.2+.3;\n    pos.xz *= rot(p.y);\n    // pos.yz *= rot(iTime);\n    return sdRoundBox(pos, vec3(1.,10000.,1.), .2);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 lookat = vec3(0,-8.,3)+vec3(sin(iTime*.1)+sin(iTime*.1+21.14)*.2,0,0);\n    vec3 ro = vec3(0);\n\n    vec3 forward = normalize(lookat-ro);\n    vec3 right = cross(forward, vec3(0,1,0));\n    vec3 up = cross(forward, right);\n    float z = 1.5;\n    vec3 center = ro + forward*z;\n    vec3 i = center + up*uv.y + right*uv.x;\n    \n    vec3 rd = normalize(i-ro);\n    \n    \n    // vec3 rd = vec3(vec3(uv,z)-ro);\n    // vec3 rd = normalize(target-ro)+vec3(uv,0.);\n\t\n    vec3 p = vec3(0.);\n    float t,c;\n\n    for(int i=0; i<1000; i++) {\n        p = ro+t*rd;\n        float d = map(p);\n        d = max(0.02 + (exp(5.*sin(iTime * 0.3))/exp(5.))*0.1, abs(d));\n        if(d<0.01) {\n            col = vec3(1.);\n        \tbreak;\n       \t}\n        if(t>100000.) {\n        \tbreak;\n        }\n\t\tt += d;\n        c += 1./400.;\n    }\n    \n    col = vec3(pow(c,3.5));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 79], [81, 81, 126, 126, 222], [224, 224, 243, 243, 612], [614, 614, 671, 671, 1637]], "test": "untested"}
{"id": "WttXWH", "name": "teleport door", "author": "feiss", "description": "Shader used in Hello webXR for teleport doors, using this texture:\nhttps://github.com/MozillaReality/hello-webxr/blob/3615324865b8a2aace5a31a2f4d366c287040e78/assets/doorfx.png\n\nHello WebXR demo: https://mixedreality.mozilla.org/hello-webxr/", "tags": ["stars", "hello", "door", "teleport", "webxr"], "likes": 5, "viewed": 140, "published": "Public", "date": "1580868486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  float t = iTime;\n  uv = uv * 2.0 - 1.0;\n  vec2 puv = vec2(length(uv.xy), atan(uv.x, uv.y));\n  vec4 col = texture(iChannel0, vec2(log(puv.x) - t / 5.0, puv.y / 3.1415926 )) * vec4(0.1, 0.1, 0.9, 1.0);\n  float glow = (1.0 - puv.x) * (0.5 + (sin(t * 3.) + 2.0 ) / 4.0);\n  // blue glow\n  col += vec4(118.0/255.0, 144.0/255.0, 219.0/255.0, 1.0) * (0.4 + glow * 1.0);\n  // white glow\n  col += vec4(0.2) * smoothstep(0.0, 2.0, glow * glow);\n    fragColor = col;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 606]], "test": "untested"}
{"id": "WttXzS", "name": "Sum&Product duality", "author": "DanYeaD", "description": "groovy", "tags": ["fractal"], "likes": 3, "viewed": 75, "published": "Public", "date": "1581219341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 MyFunc (vec3 stuff)\n{\n    mat3 sum = mat3(stuff.x + stuff, stuff.y + stuff, stuff.z + stuff);\n    mat3 product = mat3(stuff.x * stuff, stuff.y * stuff, stuff.z * stuff);\n    vec2 matchNum = vec2(0.0);\n    for(int x = 0; x < 3; x++)\n    {\n\t\tfor(int y = 0; y < 3; y++)\n    \t{\n            float match_s = sum[x][y];\n            float match_p = product[x][y];\n        \tfor(int x1 = 0; x1 < 3; x1++)\n    \t\t{\n            \tfor(int y1 = 0; y1 < 3; y1++)\n    \t\t\t{\n        \t\t\tint myYead = 2;\n                    if (abs(match_s - product[x1][y1]) < 0.1)\n                    {\n                        matchNum.x++;\n                    }\n                    if (abs(match_p - sum[x1][y1]) < 0.1)\n                    {\n                        matchNum.y++;\n                    }\n    }\n    }\n            matchNum--;\n    }\n    }\n    return matchNum * matchNum;\n    \n}\n\nvec3 spectrum(float x) {\n    float pi = 3.14159;\n    x = x * 2.1 - 0.555;\n    vec4 v = vec4(clamp(x, -.6, 0.6), clamp(x, 0.05, 1.05), clamp(x, 0.65, 1.55), clamp(x, 1.16, 1.55));\n    v += vec4(0.0, -0.55, -1.1, -1.35);\n    v *= vec4(0.8, 1.0, 1.1, 2.5);\n    v = (cos(v * v * pi * 4.) * 0.5 + 0.5);\n    v.r += v.a * 0.5;\n    return v.rgb;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    \n    vec2 col = MyFunc(vec3(uv *3.0-0.5,sin(iTime * 1.0 ) * 1.0 + 1.0));\n\n    // Output to screen\n    fragColor = vec4(spectrum(abs(col.x + col.y) * 0.005), 1.0);\n    \n    \n}\n\n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 857], [859, 859, 883, 883, 1198], [1199, 1199, 1256, 1306, 1557]], "test": "untested"}
{"id": "WtVSDw", "name": "Ray March 3.", "author": "baksej", "description": "Ray March 3", "tags": ["raymarch"], "likes": 3, "viewed": 74, "published": "Public", "date": "1582850375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k) {\n \tfloat h = clamp(.5 + .5 * (b - a) / k, 0.0, 1.0);   \n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius){\n \treturn length(pos) - radius;   \n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat map(float v, float a, float b, float x, float y){\n \tfloat n = (v - a) / (b - a);\n \treturn x + n * (y - x);\n}\nfloat scene(vec3 pos){\n    \n    vec3 i = floor(pos / .2);\n    \n    \n    vec3 pos1 = pos;\n    pos1 = mod(pos1, .2) - .1;\n    \n     pos1.x += random(i.xz) * .05;\n     \n    \n    \n \tfloat s1 = sphere(pos1, .05);\n    \n  \n    \n\n    \n    \n    vec3 pos2 = pos;\n \t\n    \n    pos2.y += random(i.xz) + iTime * .3 * random(i.xz);\n    \n    \n    \n    pos2 = mod(pos2, .2) - .1;\n    \n    \n    \n    \n    float s2 = sphere(pos2, .02);\n    \n    return smin(s1, s2, .05);\n}\n\nvec3 estimateNormal(vec3 pos){\n    \n \treturn normalize(\n    vec3(\n        scene(pos - vec3(.001, .0, .0)) - scene(pos + vec3(.001, .0, .0)),\n        scene(pos - vec3(.0, .001, .0)) - scene(pos + vec3(.0, .001, .0)),\n        scene(pos - vec3(.0, .0, .001)) - scene(pos + vec3(.0, .0, .001))\n        \n    ));   \n}\n\n\nvec3 light_dir = vec3(.0, -1.0, 1.0);\n\nvec3 trace(vec3 camOrigin, vec3 dir, out float totalDist) {\n \tvec3 ray = camOrigin;\n    totalDist = 0.0;\n    \n    // hacky near plane clipping\n    totalDist += .1;\n    ray += totalDist * dir;\n    \n    for(int i = 0; i < 128; i++) {\n     \tfloat dist = scene(ray);\n        if (abs(dist) < .001) {\n            float diffuse = dot(light_dir, estimateNormal(ray));\n            vec3 ambient = vec3(.2, .2, .2);\n            return vec3(diffuse * .5) + ambient;\n        \t   \n        }\n        totalDist += dist;\n        ray += dist * dir;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec3 camOrigin = vec3(0.,0.,-3.);\n    camOrigin.x += sin(iTime * .1) * .5;\n    camOrigin.z += iTime * .4;\n    vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n    vec3 dir = normalize(rayOrigin - camOrigin);\n    pR(dir.xz, sin(iTime) * .08);\n    pR(dir.xy, sin(iTime) * .09);\n    pR(dir.zy, sin(iTime) * .10);\n    \n    float dist = 0.;\n    vec3 color = trace(camOrigin, dir, dist);\n\t\n    color = mix(vec3(0.0), color, clamp(map(dist, 2., 3.5, 1., 0.), 0.0, 1.0));\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 77], [79, 79, 118, 118, 220], [222, 222, 259, 259, 295], [296, 296, 320, 320, 427], [430, 430, 485, 485, 544], [545, 545, 567, 567, 998], [1000, 1000, 1030, 1030, 1311], [1353, 1353, 1412, 1412, 1918], [1920, 1920, 1977, 2027, 2676]], "test": "untested"}
{"id": "wtVSWh", "name": "Caterpillar_after AOC_Tutorial", "author": "JohnnyRainbow81", "description": "First public Shader here. Maybe they will get less unspectacular some day.", "tags": ["raymarching", "blacknwhite"], "likes": 1, "viewed": 65, "published": "Public", "date": "1582638779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Sphere(vec3 p, float radius) {\n\treturn length(p)-radius;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat GetDist(vec3 p) {\n    float time = iTime*.4;\n    float d;\n    vec3 p2 = p;\n    float floorDist = p2.y+(sin(p.z+sin(iTime)))*cos(p2.x)*.1+length(p)*.1;\n    d = floorDist;\n    for(int i = 0; i < 15; i++) {\n        float size = float(i)*.1;\n\t\tfloat sphereDist= Sphere(p-vec3(sin(time*6.)*.4,cos(time*6.)*5.+2.,-80.+fract(-time*.15)*180.), size);\n    \td = smin(sphereDist, d, .8);\n        time +=.04;\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    for(int i = 0; i < 100; i++) {\n    \tfloat step = GetDist(ro + rd*d);\n        d += step*.5;\n        if(abs(d) < 0.0001 || d > 140.) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = d - vec3(GetDist(p-e.xyy),\n                           GetDist(p-e.yxy),\n                           GetDist(p-e.yyx));\n    normal = normalize(normal);\n    return normal;\n}\n\nfloat GetLight(vec3 p){\n\tvec3 light = vec3(1.,7.,7.);\n    vec3 normal = GetNormal(p);\n    vec3 lightVec = normalize(light-p);\n    float dif = max(0., dot(normal, lightVec))*(1.-max(0.,length(light-p)*.02));\n    float shadow = RayMarch(p+normal*.002, lightVec);\n    if(shadow < length(light-p)) dif *=clamp(shadow*.2, 0.,1.);\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse -= .5;\n    vec3 col = vec3(0.);\n   \n    vec3 ro = vec3(4.*cos(mouse.x*6.),1.+mouse.y,4.*sin(mouse.x*6.));\n    vec3 lookAt = vec3(0.,1.,3.);\n    float zoom = 1.;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right,forward));\n    vec3 center = ro + forward * zoom;\n    vec3 intersect = center + right*uv.x + up*uv.y;\n    vec3 rd = intersect - ro;\n    \n    float d = RayMarch(ro, rd);\n    float dif = GetLight(ro + rd *d);\n    // Time varying pixel color\n    col = vec3(dif);\n\t//col = vec3(st, 1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVSWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 64], [66, 66, 107, 107, 191], [193, 193, 216, 216, 617], [619, 619, 653, 653, 832], [834, 834, 858, 858, 1100], [1102, 1102, 1125, 1125, 1444], [1446, 1446, 1503, 1553, 2362]], "test": "untested"}
{"id": "WtVSWw", "name": "Procedural biome map with clouds", "author": "jarble", "description": "Another modification of my fractal biome generator.", "tags": ["procedural", "fractal", "biome"], "likes": 2, "viewed": 261, "published": "Public API", "date": "1582845900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 8.0;\n\nconst float GREEN = 0.0;\nconst float BLUE = 1.0;\nconst float GRAY = 2.0;\nconst float YELLOW = 3.0;\nconst float RED = 5.0;\nconst float WHITE = 6.0;\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tfloat num_colors = 3.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33+iTime/100000.0);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n\n\nfloat magnify(vec2 fragCoord,float mag){\n\treturn hash12(floor(fragCoord/pow(2.0,mag)));\n}\n\nbool is_above(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord,mag) == color;\n}\nbool is_surrounded_by(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        && magnify(fragCoord+vec2(1,0),mag) == color\n        && magnify(fragCoord-vec2(0,1),mag) == color\n        && magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\nbool is_next_to(vec2 fragCoord,float mag,float color){\n\treturn magnify(fragCoord+vec2(0,1),mag) == color\n        || magnify(fragCoord+vec2(1,0),mag) == color\n        || magnify(fragCoord-vec2(0,1),mag) == color\n        || magnify(fragCoord-vec2(1,0),mag) == color;\n}\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nfloat iterations(float color1,in vec2 fragCoord,float mag){\n    float mag1 = 0.0;\n    while(mag1 < mag){\n    bool modified = true;\n    if(color1 == GREEN && is_next_to(fragCoord,mag1,BLUE)){\n    \tcolor1 = BLUE;\n    }\n    else if(color1 == BLUE && is_next_to(fragCoord,mag1,GRAY)){\n        if(mag1 > 5.0){\n        \tcolor1 = YELLOW;\n        }\n        else{\n        \tcolor1 = GRAY;\n        }\n    }\n    else if(color1 == GRAY && is_next_to(fragCoord,mag1,GREEN)){\n        color1 = GREEN;\n    }\n    else if(color1 == YELLOW && is_next_to(fragCoord,mag1,GRAY)){\n        color1 = GREEN;\n    }\n    else if(color1 == GRAY && is_next_to(fragCoord,mag1,BLUE) && is_next_to(fragCoord,mag1,GRAY)){\n        color1 = WHITE;\n    }\n    \n    mag1 += 1.0;\n    }\n    return color1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = fragCoord + iTime*vec2(50.0,0.0);\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    color1 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(get_color(color1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 278, 300, 300, 539], [542, 542, 582, 582, 631], [633, 633, 685, 685, 728], [729, 729, 789, 789, 1001], [1003, 1003, 1057, 1057, 1269], [1272, 1272, 1300, 1300, 1714], [1716, 1716, 1775, 1775, 2479], [2481, 2481, 2538, 2538, 2822]], "test": "untested"}
{"id": "WtVSzh", "name": "04 3D Raymarching metaballs", "author": "waffles", "description": "Example of simple raymarching", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 64, "published": "Public", "date": "1582191311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed under Creative Commons CC0: https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// For more shapes and raymarching knowledge: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.xy*2.0f-1.0f;\n\n    // initial background color\n    vec4 color = vec4(0.0f,0.0f,0.0f,0.0f);\n    // palette\n    vec3 color1 = vec3(1.0f, 1.0f, 1.0f);\n    vec3 color2 = vec3(0.4f, 0.4f, 0.4f);\n\n    float metaStickyness = 0.4f;\n    float sphereSize = 0.3f;\n\n    vec3 spheres[5];\n    spheres[0].x = cos(time)*0.5f+0.2f;\n    spheres[0].y = sin(time)*0.8f+0.3f;\n    spheres[0].z = sin(time)*0.5f;\n    spheres[1].x = sin(time)*0.5f-0.5f;\n    spheres[1].y = cos(time)*0.5f-0.25f;\n    spheres[1].z = sin(time)+0.5f;\n    spheres[2].x = cos(time)*0.5f-0.5f;\n    spheres[2].y = sin(time)*0.7f-0.25f;\n    spheres[2].z = cos(time)*0.6f+0.3f;\n    spheres[3].x = cos(time)*0.8f;\n    spheres[3].y = sin(time)*0.4f;\n    spheres[3].z = cos(time)*0.8f;\n    spheres[4].x = sin(time)*0.9f;\n    spheres[4].y = sin(time)*0.9f;\n    spheres[4].z = sin(time)*0.2f;\n\n    vec3 cameraEye = vec3(0.0f,0.0f,-2.5f);\n    vec3 cameraUp = vec3(0.0f,1.0f,0.0f);\n    vec3 cameraRight = vec3(1.0f,0.0f,0.0f);\n\n    vec3 cameraTarget = normalize(cross(cameraRight, cameraUp) + cameraRight*uv.x + cameraUp*uv.y);\n\n    float rayHitThreshold = 0.01f;\n    float zFar = 5.0f;\n    float rayDistance = 0.0f;\n    int rayMaxSteps = 30;\n    for(int i = 0; i < rayMaxSteps; i++)\n    {\n        vec3 rayPosition = cameraEye+cameraTarget*rayDistance;\n\n        float distanceToSolid = 0.0f;\n\n        for(int i = 0; i < spheres.length(); i++)\n        {\n            float sa = length(rayPosition+spheres[i])-sphereSize;\n            if (i == 0)\n            {\n                distanceToSolid = sa;\n            }\n            else\n            {\n                //metaball glue\n                float h = clamp(0.5f+0.5f*(sa-distanceToSolid)/metaStickyness,0.0f,1.0f);\n                distanceToSolid = mix(sa,distanceToSolid,h)-metaStickyness*h*(1.0f-h);\n            }\n        }\n\n        if (rayDistance > zFar)\n        {\n            break;\n        }\n        else if (distanceToSolid < rayHitThreshold)\n        {\n            vec3 n = rayPosition;\n\n            float percent = abs((n.r+n.g+n.b)/3.0f);\n            color = vec4(mix(color1, color2, percent/0.5f), 1.0f);\n\n            break;\n        }\n\n        rayDistance += distanceToSolid;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVSzh.jpg", "access": "shaders20k", "license": "cc0-1.0 OR openssl-ssleay OR apache-2.0", "functions": [[104, 223, 280, 280, 2547]], "test": "untested"}
{"id": "WtVXDW", "name": "moving holes", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "short"], "likes": 2, "viewed": 262, "published": "Public API", "date": "1582736761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C(q) t = max(t, 2.-length(mod(q.xy+4.,6.)-4.))\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    mat2  R = mat2( sin(1.1+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),     // ray direction\n          p = 23./q, a;                        // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                  // rotation\n        t-=t,\n        a = abs(q),  \n        t = max(t, max(max(a.x,a.y),a.z) -4. ),// cube \n        q.y -= iTime,\n        C(q.xy),\n        C(q.zy-vec2(0,3)),\n        p += t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 92, 92, 696]], "test": "untested"}
{"id": "WtyGzV", "name": "first attempt at rendering water", "author": "maksy", "description": "first attempt at rendering water\n\nUPDATE: Added caustics\nUPDATE: Added fog for atmosphere", "tags": ["water"], "likes": 4, "viewed": 525, "published": "Public API", "date": "1580670082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Resources:\n * https://www.shadertoy.com/view/llsXD2\n * https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n * https://medium.com/@evanwallace/rendering-realtime-caustics-i\n * https://www.shadertoy.com/view/MttBRS\n * https://www.shadertoy.com/view/MldfDn\n */\n\n#define PI 3.141592\n#define MAX_STEPS 250\n#define MAX_DIST 250.0\n#define SURF_DIST .001\n\n#define WATER 0\n#define SKY 1\n\n#define LIGHT_POS vec3(0, 5, 25)\n\nstruct Obj {\n\tint type;\n    float d;\n    vec3 hitPos;\n};\n    \nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value noise from the book of shader\nfloat noise(in vec2 uv) {\n     \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n/*\n * Fractal Brownian Motion adds different iterations of noise (octaves) \n * by incrementing the frequencies in regular steps and decrease the amplitude \n * of the noise. It makes the noise more granular and add more fine details.\n*/\nfloat fbm(in vec2 uv, int octaves) {\n    \n    // Initial values\n    float value = 0.0;\n    float amplitude = .1;\n    float frequency = 0.;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// --- analytically triangle-filtered checkerboard by iq ---\nvec3 pri(in vec3 x) {    \n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri(in vec3 p, in vec3 ddx, in vec3 ddy) {\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.1 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec3 floorColor(in vec3 pos) {\n\n\tvec3 uvw = 1.2 * pos;\n\n\t// calc texture sampling footprint\t\t\n\tvec3 ddx_uvw = dFdx( uvw ); \n    vec3 ddy_uvw = dFdy( uvw );\n    vec3 color = vec3(checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw));\n  \n    return color;\n}\n\nObj getDistance(vec3 p) {\t\n       \n    float height = fbm(vec2(p.x, p.z) + (iTime/3.), 2);\n    float waterDist = p.y - height;\n    \n    Obj obj = Obj(WATER, waterDist, p);\n    \n    return obj;\n}\n\n// Basic raymarching loop\nObj rayMarch(vec3 ro, vec3 rd) {\n\t\n    float t = 0.;\n    \n    Obj hitObj = Obj(SKY, t, ro + rd);\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \t\n        vec3 p = ro + rd*t;\n        \n        hitObj = getDistance(p);\n        t += hitObj.d*0.35;\n        \n        // the ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) {\n        \thitObj = Obj(SKY, t, p);\n            break;\n        }\n\n        // the ray has marched close enough to an object\n        if (abs(hitObj.d) < SURF_DIST) {\n            hitObj = Obj(hitObj.type, t, p);\n        \tbreak;\n        }\n        \n        hitObj.d = t;\n    }\n    \n    return hitObj;\n}\n\nvec3 getWaterNormal(vec3 p) {\n\tfloat d = getDistance(p).d;\n    \n    // use offset samples to compute normal\n    vec2 e = vec2(.5, 0);\n    vec3 n = d - vec3(\n        getDistance(p-e.xyy).d,\n        getDistance(p-e.yxy).d,\n        getDistance(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\n// calculates the intersection of the given plane and ray\nvec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {\n    \n    vec3 planeNormal = vec3(0, 1, 0);\n    \n\tfloat a = dot(dir, planeNormal);\n   \n    float distToPlane = dot(ori-planePos, planeNormal);\n    vec3 intersectPt = ori + dir*abs(distToPlane/a);\n    \n    return intersectPt;\n}\n\n// calculates specular lighting\nfloat specular(vec3 n, vec3 l, vec3 rd, float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(rd, n), l),0.0), s) * nrm;\n}\n\nvec3 getSkyColor(vec3 rd, vec3 light) {\n    \n    vec3 col = vec3(0.4);\n   \t// sun\n   \tfloat sundot = clamp(dot(rd, normalize(light)),0.0,1.0);\n   \t// sun scatter\n\tcol += 0.6*vec3(1.0,0.7,0.3) * pow(sundot, 8.0);\n   \tcol += 0.25*vec3(1.0,0.7,0.4) * pow(sundot, 5.0);\n\tcol += 0.25*vec3(1.0,0.8,0.6) * pow(sundot, 64.0);\n\tcol += 0.2*vec3(1.0,0.8,0.6) * pow(sundot, 512.0);\n    \n    return col;\n}\n\nvec3 getWaterColor(vec3 p, vec3 n, vec3 rd, vec3 distToP) {  \n    \n    // Fresnel is an exponential that gets bigger when the angle between the water\n    // surface normal and camera ray is smaller. It is used to calculate \n    // the amount of reflected vs. refracted light.\n    float fresnel = 1.0 - max(dot(n, -rd), 0.0);\n    fresnel = fresnel*fresnel*fresnel * 0.25;                        \n        \n    // Bounces the camera ray towards the sky and gets its color\n    vec3 reflected = getSkyColor(reflect(rd, n), normalize(LIGHT_POS));    \n    \n    // Calculates refraction effect based on angle between the light and surface normal \n     vec3 refractDir = refract(rd, n, 1.0/1.3);\n     vec3 refractedPos = intersectPlane(p, refractDir, vec3(0.0, -1.0, 0.0));\n    // floor color at the position hit by the refracted ray\n    vec3 refracted = floorColor(refractedPos);\n    \n    // Blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted, reflected, fresnel);\n    \n  \t// Add specular hilight\n    color += vec3(specular(n, normalize(LIGHT_POS), rd, 100.0));    \n    \n    return color;\n}\n\nfloat caustics(vec3 waterHitPos, vec3 lightPos) {\n    \n    vec3 ray = normalize(waterHitPos - lightPos);\n    \n    // Calculate the intersection of the light and the non-deformed water plane\n    vec3 surfacePlaneNormal = vec3(0.0, 1.0, 0.0);    \n    vec3 planePos = vec3(0, 0, 0);\n        \n    vec3 surfacePlaneHitPos = rayMarch(lightPos, ray).hitPos;\n    float height = fbm(vec2(surfacePlaneHitPos.x, surfacePlaneHitPos.z) + (iTime/3.), 2);\n    surfacePlaneHitPos += vec3(0., height, 0.);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    vec3 refractDir = refract(ray, surfacePlaneNormal, 1.0/1.3);   \n    vec3 bottomPlanePos = vec3(0.0, 1.0, 0.0);\n    vec3 beforePos = intersectPlane(surfacePlaneHitPos, refractDir, bottomPlanePos);\n  \tbeforePos += surfacePlaneHitPos;\n    \n  \t// Calculate the intersection of the light and deformed water surface\n    vec3 deformedPlaneHitPos = rayMarch(lightPos, ray).hitPos;\n   \tvec3 normal = getWaterNormal(deformedPlaneHitPos);\n    \n    // Calculate the intersection of the refracted ray and bottom plane   \n    refractDir = refract(ray, normal, 1.0/1.3);\n    vec3 afterPos = intersectPlane(deformedPlaneHitPos, refractDir, bottomPlanePos);\n    afterPos += deformedPlaneHitPos;\n       \n    float beforeArea = length(dFdx(beforePos)) * length(dFdy(beforePos));\n    float afterArea = length(dFdx(afterPos)) * length(dFdy(afterPos));\n    return max(beforeArea / afterArea, .001);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n   \n    vec3 col = vec3(.05, .25, 0.5);   \n       \n    // camera\n    vec3 ro = vec3(.5, 2, -8);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    Obj hitObj = rayMarch(ro, rd);   \n       \n    if (hitObj.type == SKY) {\n\n\t\tcol = getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.));\n        \n    } else if (hitObj.type == WATER) {\n    \n   \t\tvec3 normal = getWaterNormal(hitObj.hitPos);       \n        col += getWaterColor(hitObj.hitPos, normal, rd, hitObj.hitPos - ro)*0.6;\n    \tcol *= caustics(hitObj.hitPos, LIGHT_POS);\n        float fogAmount = pow(1.0 - pow(rd.y,2.0), 200.0);\n        col = mix(col, getSkyColor(rd, LIGHT_POS-vec3(0., 3, 0.)), fogAmount);     \n    }\n        \t\n    col = pow(col,vec3(.454545));\n \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 540, 561, 561, 643], [645, 684, 709, 709, 1097], [1099, 1335, 1371, 1398, 1652], [1654, 1715, 1736, 1736, 1812], [1814, 1814, 1881, 1881, 2104], [2106, 2106, 2136, 2136, 2354], [2356, 2356, 2381, 2381, 2550], [2552, 2578, 2610, 2610, 3263], [3265, 3265, 3294, 3294, 3550], [3552, 3610, 3666, 3666, 3892], [3894, 3926, 3976, 3976, 4080], [4082, 4082, 4121, 4121, 4474], [4476, 4476, 4535, 4751, 5615], [5617, 5617, 5666, 5666, 7068], [7070, 7070, 7125, 7205, 8002]], "test": "untested"}
{"id": "WtySRG", "name": "Randomness Testing", "author": "Jim_Watson", "description": "random", "tags": ["random"], "likes": 3, "viewed": 78, "published": "Public", "date": "1582926341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.129, 76.128)))*4567.987);\n}\n\nfloat remap(float v, float l0, float h0, float l1, float h1)\n{\n    return l0+(v-l1)*(h1-l1)/(h0-l0);\n}\n\nfloat lineRand(vec2 uv, float r)\n{\n    uv.x *= r;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float rr = remap(r, 0., 20., 0., 1.);\n    \n    float frac = fract(rr*456123.);\n    //float tm = remap(frac, 0., 1., 0., 2.);\n    if(frac < 0.5)\n    {\n        uv.x -= iTime*(-frac*2.);\n    }\n    else\n    {\n        uv.x -= iTime*(frac*10.);\n    }\n    \n    \n    vec2 stuv = uv*vec2(20., 1.);\n    \n    vec2 pos = floor(stuv);\n    \n    float mult = round(pow(random(pos), 10.));\n    \n    //mult = tm;\n    \n    return mult;\n}\n\nfloat lineReveal(vec2 uv, float ca, float num)\n{\n    float rd = mix(0., 1., step(1.-uv.y, num/ca));\n    float n = mix(0., 1., step(1.-uv.y, num-1./ca));\n    \n    return rd-n;\n}\nfloat rowReveal(vec2 uv, float ca, float num)\n{\n    float line = lineReveal(uv, ca, num);\n    float line2 = lineReveal(uv, ca, num-1.);\n    \n    \n    line-= line2;\n    line *= 1.-uv.x*fract(1.-iTime*10.);\n    \n    return line;\n}\nfloat fill(vec2 uv, float ca, float num)\n{\n    float fill = 0.;\n    fill += step(1.-uv.y, num/ca);\n    \n    return fill;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    int numLines = 70;\n    \n    vec3 col = vec3(1.);\n    \n    float top = lineRand(uv, 2.);\n    float bottom = lineRand(uv, 10.);\n    \n    float sl = 1./float(numLines);\n    \n    float premult = 0.;\n    \n    float line = 0.;\n    \n    for (int i = 0; i < numLines+1; i++)\n    {\n        //while(fract(iTime)< 1.)\n        //{\n            float lo = mix(0., 1., fract(iTime)*1.-uv.x);\n            premult = mix(premult, lineRand(uv, float(i)), step(uv.y, 1.-(float(i)*sl)));\n\n\n            float q = 0.;\n        \n        \tlo = lineReveal(uv, float(numLines), float(i));\n\n            line = lo;\n            //line = lo;\n\n            /*while(q < 1.)\n            {\n                line = mix(0., premult, iTime*q);\n                q+= 0.1;\n            }*/\n        //}\n    }\n    \n    float lineCol = 0.;\n    \n    for (int j = 0; j < numLines+1; j++)\n    {\n        \n        lineCol += rowReveal(uv, float(numLines), float(j));\n    }\n    \n    float f = fract(iTime * .05)*float(numLines+1);\n    float frame = clamp(f, 0., float(numLines+1));\n    \n    lineCol += rowReveal(uv, float(numLines), round(frame));\n    lineCol += fill(uv, float(numLines), round(frame));\n    \n    \n    col *= mix(0., premult, lineCol);\n    \n    //col = mix(col*top, col*bottom, 1.- step(uv.y, 0.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtySRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 88], [90, 90, 152, 152, 192], [194, 194, 228, 228, 720], [722, 722, 770, 770, 898], [899, 899, 946, 946, 1127], [1128, 1128, 1170, 1170, 1250], [1252, 1252, 1309, 1359, 2768]], "test": "untested"}
{"id": "wtySWw", "name": "Attempt at doing something fun", "author": "FlyingDoe", "description": "fun I guess", "tags": ["funiguess"], "likes": 7, "viewed": 89, "published": "Public", "date": "1582820222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 colWhi = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 colCya = vec4(0.0, 1.0, 1.0, 1.0);\nvec4 colOra = vec4(1.0, 0.5, 0.0, 1.0);\nvec4 colRed = vec4(1.0, 0.5, 0.0, 1.0);\n\nfloat plot(vec2 coord, float y, float thickness){\n    return  smoothstep( y-thickness, y, coord.y)       \n    - smoothstep( y, y+thickness, coord.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // =================\n    //        BASE\n    // =================\n    vec2 coord = fragCoord.xy; \n\tvec2 xy = coord / iResolution.xy;\n\n\tvec2 center = vec2(0.5, 0.5);\n    \n    // =================\n    //     CALCULUS\n    // =================\n    \n    //white tube\n    float y = sin((coord.x - iTime/20.0)*40.0) / 5.0 + 0.5; \n    float i = cos((coord.x - iTime/20.0)*40.0) + 1.5;\n    float movingSine1 = plot(xy, y, 0.01) * i;\n    \n    // Cyan clouds\n    y = cos((coord.x - iTime/40.0)*90.0)/13.0 + 0.5;\n    i = - cos((coord.x + iTime/20.0)*40.0) + 1.5;\n    float movingSine2 = plot(xy, y, 0.08) * i;\n    \n    // Orange bolts\n    y = cos((coord.x + iTime/40.0)*10000.0)/30.0 + 0.5; \n    float movingSine3 = plot(xy, y, 0.01);\n    \n    // Orange back\n    y = sin((coord.x - iTime/20.0)) / 2.5 + 0.5; \n    i = - cos((coord.x - iTime/20.0)*40.0) * 2.0;\n    float movingSine4 = plot(xy, y, 0.01) * i;\n\n\t// =================\n    //       OUTPUT\n    // =================\n    fragColor = colWhi * movingSine1 + colCya * movingSine2 + colOra * movingSine3 + colRed * movingSine4;\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtySWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 210, 210, 312], [315, 315, 372, 441, 1446]], "test": "untested"}
{"id": "wtySz1", "name": "01 Shadertoy WebGL 2.0 bootstrap", "author": "waffles", "description": "This example illustrates all the shader code under the hood of shadertoy.com website\n\nAll the code here is copy-pasted from shadertoy.com website's source code. Shadertoy holds the copyrights.\n", "tags": ["example", "shadertoy", "bootstrap"], "likes": 0, "viewed": 36, "published": "Public", "date": "1582177014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the code here is copy-pasted\n// from shadertoy.com website's source code.\n// Shadertoy holds the copyrights\n\n/*\n// Vertex Shader (WebGL 2.0 /w OpenGL ES 3.0)\n\n#version 300 es\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\nprecision mediump sampler3D;\n#endif\n\nlayout(location = 0) in vec2 pos;\n\nvoid main() {\n    gl_Position = vec4(pos.xy,0.0,1.0);\n}\n*/\n\n/*\n// Fragment Shader (WebGL 2.0 /w OpenGL ES 3.0)\n\n#version 300 es\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\nprecision mediump sampler3D;\n#endif\n\n#define HW_PERFORMANCE 1\n\nuniform vec3      iResolution;\nuniform float     iTime; \nuniform float     iChannelTime[4]; \nuniform vec4      iMouse; \nuniform vec4      iDate; \nuniform float     iSampleRate; \nuniform vec3      iChannelResolution[4]; \nuniform int       iFrame; \nuniform float     iTimeDelta; \nuniform float     iFrameRate;\n\nstruct Channel;\n{\n    vec3  resolution;\n    float time;\n};\nuniform Channel iChannel[4];\n\nuniform sampler2D iChannel0;\nuniform sampler2D iChannel1;\nuniform sampler2D iChannel2;\nuniform sampler2D iChannel3;\n\nvoid mainImage( out vec4 c,  in vec2 f );\n\nout vec4 outColor;\nvoid main( void ) {\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    mainImage( color, gl_FragCoord.xy );\n    color.w = 1.0;\n    outColor = color;\n}\n*/\n\n// Here's the part of the code that you can modify:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtySz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1286, 1339, 1396, 1446, 1633]], "test": "untested"}
{"id": "wtyXRG", "name": "Reflection of a stripy room", "author": "bencoder", "description": "Playing with reflections", "tags": ["reflection", "sdf"], "likes": 13, "viewed": 145, "published": "Public", "date": "1582982601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CLOSE_D 0.01\n#define MAX_D 100.\n#define MAX_ITER 100\n#define REFL_BOUNCES 4\n\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat hex( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xz -= 2.0*min(dot(k.xy, p.xz), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xz-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.z-h.x),\n       p.y-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat room(vec3 p) {\n    p.y -= 12.1;\n    return 0.1-sdBox(p, vec3(12));      \n}\n\n//returns the vec2 with the lower x component\n//used to handle distance in x and object id in y\nvec2 xmin(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat hit = 0.;\nfloat objectNearCount=0.;\nfloat sdf(vec3 p) {\n    vec2 room = vec2(room(p), 0);\n    float hexagon = hex(p-vec3(0,1.5,0),vec2(1.5,1.5));\n    float spheres = min(\n        min(\n            sphere(p-vec3(4,2.+sin(iTime),0),1.),\n            sphere(p-vec3(-4,2.+sin(iTime+3.14),0),1.)\n        ),\n        min(\n            sphere(p-vec3(0,2.+sin(iTime+3.14/2.),4),1.),\n            sphere(p-vec3(0,2.+sin(-iTime+3.14*1.5),-4),1.)\n        )\n    );\n    vec2 objects = vec2(\n        min(hexagon,spheres),\n    \t1\t//object id\n    );\n    \n    vec2 res = xmin(\n        room,\n        objects\n    );\n    hit = res.y;\n    objectNearCount += hit;\n    return res.x;\n}\n\nfloat rm(vec3 ro, vec3 rd, float max_d) {\n    float td=0.;\n    for(int i=0;i<MAX_ITER;i++) {\n        float d = sdf(ro+rd*td);\n        td += d;\n        if (abs(d) < CLOSE_D || td > max_d) break;\n    }\n    return td;\n}\n\nvec3 norm(vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(sdf(p) - vec3(\n        sdf(p - e.xyy),\n        sdf(p - e.yxy),\n        sdf(p - e.yyx)));\n}\n\nfloat light(vec3 p, vec3 rd) {\n    float originalONC = objectNearCount;\n    vec3 n = norm(p);\n\n    int b=0;\n    //If we hit something reflective (object id 1) and up to REFL_BOUNCES bounces:\n    while (hit == 1. && b++<REFL_BOUNCES) {\t\n        rd = reflect(rd, n); //get a new ray direction\n        p+=n*CLOSE_D*2.;     //pull out of the surface a bit so we're no longer intersecting\n        p = p+rd*rm(p, rd, MAX_D);  //raymarch from the old position to the next hit\n        n = norm(p);\n    }\n    \n    vec3 lp = vec3(5,10,-5);\n    vec3 ld = normalize(lp-p);\n    float l = dot(n,ld);\n    \n    float baseColor = .1+.9*smoothstep(-.05,.05,sin((p.y+p.x)*2.));\n    //reset the counter for how many iterations we are closer to the objects than the room\n    objectNearCount = 0.;\n    float max_d = length(lp-p);\n    float lm = rm(p+n*CLOSE_D*2.,ld, max_d);\n    if (lm < max_d) {\n        l *= 0.1;\n    }\n   \tl *= 1. * smoothstep(50.,10.,objectNearCount); //smooth shadows\n    //l += (1.-l)*smoothstep(20.,30.,originalONC); //glow around the objects\n    return l * baseColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.) / iResolution.y;\n\n    vec3 ro = vec3(0,4.,-8);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    rd.yz *= rot(0.25);\n    if (iMouse.w < .5) {\n        ro.zx *= rot(iTime*0.1);\n        rd.zx *= rot(iTime*0.1);\n    } else {\n        ro.yz *= rot(-.5+(iMouse.y/iResolution.y) * 3.14/2.);\n        rd.yz *= rot(-.5+(iMouse.y/iResolution.y) * 3.14/2.);\n        ro.zx *= rot(iMouse.x/iResolution.x * 6.2);\n        rd.zx *= rot(iMouse.x/iResolution.x * 6.2);\n    }\n    objectNearCount = 0.;\n\tfloat d = rm(ro,rd, MAX_D);\n    \n    vec3 col = vec3(light(ro+rd*d, rd));\n    \n    col *= smoothstep(100.,50.,d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 104, 104, 162], [164, 164, 195, 195, 282], [284, 284, 315, 315, 343], [345, 345, 374, 374, 647], [649, 649, 669, 669, 729], [731, 827, 854, 854, 886], [930, 930, 949, 949, 1550], [1552, 1552, 1593, 1593, 1768], [1770, 1770, 1789, 1789, 1928], [1930, 1930, 1960, 1960, 3001], [3003, 3003, 3060, 3060, 3731]], "test": "untested"}
{"id": "WtyXzR", "name": "noise_01_staticWaves", "author": "johannprell", "description": "Noise shader with waves and static.", "tags": ["noise"], "likes": 1, "viewed": 101, "published": "Public", "date": "1582018605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RESOLUTION 64.\n#define NOISESPEED 1.\n#define NOISEBLEND 0.4\n#define WAVESPEED 10.\n#define WAVELENGTH 5.\n\nfloat random(vec2 v) {\n\treturn fract(sin(dot(v.xy, vec2(37.8479, 84.1047))) * 23479.34593785 + fract(iTime*NOISESPEED));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    \n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 noiseUV = uv*RESOLUTION;\n    noiseUV = floor(noiseUV);\n\n    vec3 waveCol = vec3(sin(noiseUV.y/WAVELENGTH+t*WAVESPEED)*.5+.5);\n    vec3 noiseCol = vec3(random(noiseUV));\n    \n    vec3 col = mix(waveCol, noiseCol, NOISEBLEND);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 135, 135, 235], [237, 237, 294, 294, 629]], "test": "untested"}
{"id": "wtyXzw", "name": "Skullhead ", "author": "CyrilGhys", "description": "Skullhead using sphere tracing\n\nI thought we could upload custom textures D:", "tags": ["spheretracing"], "likes": 2, "viewed": 186, "published": "Public API", "date": "1582424418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* @source SDF functions from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n* @source 2D Texture Mapping method from https://www.shadertoy.com/view/MssGRl (user : https://www.shadertoy.com/user/asalga)\n*/\n\n#define PI 3.141592658\n#define MAX_STEPS 200\n#define MAX_DIST 10.\n#define SURF_DIST 0.1\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opUnion( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 ) { \n    return max(-d1,d2); \n}\n\nfloat distanceTree(vec3 pos) {\n    float res = MAX_DIST;\n    \n    float skullhead = sdSphere(pos-vec3(  0.,   0., 5.), 2. );\n    float leftEye \t= sdSphere(pos-vec3(-0.45, 0.15, 1.04), 2.+cos(iTime-130.)/300.);\n    float rightEye \t= sdSphere(pos-vec3( 0.45, 0.15, 1.04), 2.+cos(iTime+130.)/300.);\n    res = opSubtraction(leftEye, skullhead);\n    res = opSubtraction(rightEye, res);\n    float skullheadErase = sdSphere(pos-vec3(0., -10, 5.), 10. );\n    res = opSubtraction(skullheadErase, res);\n    \n    float tooth = MAX_DIST;\n    tooth = opUnion( tooth, sdBox(pos-vec3(-0.20, -0.4, 3.1), vec3(0.05)) );\n    tooth = opUnion( tooth, sdBox(pos-vec3(-0.05, -0.4, 3.1), vec3(0.05)) );\n    tooth = opUnion( tooth, sdBox(pos-vec3( 0.05, -0.4, 3.1), vec3(0.05)) );\n    tooth = opUnion( tooth, sdBox(pos-vec3( 0.20, -0.4, 3.1), vec3(0.05)) );\n    res = opUnion(res, tooth);\n    \n    return res;\n}\n\nvec3 GetNormal (vec3 p) {\n    float epsilon = 0.00001;\n    \n    float dpx = (distanceTree(vec3(p.x+epsilon,p.y,p.z)) - distanceTree(vec3(p.x-epsilon,p.y,p.z))) / (2.*epsilon);\n    float dpy = (distanceTree(vec3(p.x,p.y+epsilon,p.z)) - distanceTree(vec3(p.x,p.y-epsilon,p.z))) / (2.*epsilon);\n    float dpz = (distanceTree(vec3(p.x,p.y,p.z+epsilon)) - distanceTree(vec3(p.x,p.y,p.z-epsilon))) / (2.*epsilon);\n    \n    return normalize(vec3(dpx, dpy, dpz));\n}\n\nvec4 TextureMapping(vec3 n) {\n    vec3 northVector = vec3(0, 1, 0);\n\tvec3 eastVector  = vec3(1, 0, 0);\n\t\t\n\tfloat lat = acos(dot(northVector, n));\n\tfloat v = lat / PI;\n\tfloat u;\n\t\t\n\tfloat lon = (acos( dot( n, eastVector) / sin(lat))) / (2.0 * PI);\n\tif(dot(cross(northVector, eastVector), n) > 0.0){\n\t\tu = lon;\n\t}\n\telse{\n\t\tu = 1.0 - lon;\n\t}\n\n\tu -= iTime / 10.0;\n    \n    return texture(iChannel0, vec2(u, v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Init\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // put the origin in the middle\n    vec3 finalColor = vec3(0.);\n    \n    // Setup Sphere Tracing\n    vec3 ro = vec3(0., 0., -2.); // ray origin\n    ro.xz += vec2(sin(iTime) / 3., cos(iTime) / 3.);\n    vec3 rd = normalize(vec3(uv, 1.) - ro); // ray direction\n    \n    // Main loop of the sphere tracing\n  \tfloat d = 0.;\n    vec3 p;\n    int i;\n    for(i=0; i < MAX_STEPS; i++) {\n      p = ro + rd*d;\n      d = distanceTree(p);\n      if(d>MAX_DIST || d<SURF_DIST) break;\n    }\n    \n    // If we hit something\n    if (i < MAX_STEPS) {\n        vec3 normal = GetNormal(p);\n        \n    \t// Diffuse Lighting\n        vec3 diffuseLightPos = vec3(3., 3., 1.);\n        vec3 diffuseLightDir = normalize(diffuseLightPos - p);\n        float diffuseLightFalloff = dot(diffuseLightDir, normal);\n        \n        // Specular Lighting\n        vec3 specularLightPos = vec3(0., 50., 1.);\n        // specularLightPos.xz += vec2(sin(iTime), cos(iTime)) * 20.;\n        vec3 specularLightDir = normalize(specularLightPos - p);\n        vec3 viewDir = normalize(ro - p);\n        vec3 viewReflec = reflect(-viewDir, normal);\n        float specularLightFalloff = dot(specularLightDir, normal);\n\n        // Color\n        vec3 ambientColor = vec3(0.2);\n        vec3 diffuseColor = vec3(0.5, 0.7, 0.3);\n        vec3 specularColor = vec3(1., 1.0, 1.0);\n        \n        // Texture\n        vec4 t = TextureMapping(normal);\n        \n        finalColor = ambientColor\n            + max(diffuseLightFalloff, 0.) * diffuseColor\n            + max(specularLightFalloff, 0.) * specularColor\n            * t.xyz;\n    } else {\n        // Manage background color here\n        vec4 flag = texture(iChannel1, (uv+1.)*0.5);  \n        \n        vec3 mask = vec3(sin(2.*uv.x - 0.5*uv.y - iTime) + 1.) * 0.5;\n        \n        vec3 normal = vec3(0., 0., -1.);\n        \n    \t// Diffuse Lighting\n        vec3 diffuseLightPos = vec3(3.,1., -2.);\n        vec3 diffuseLightDir = normalize(diffuseLightPos - vec3(uv, 0.));\n        float diffuseLightFalloff = dot(diffuseLightDir, normal);\n        \n        finalColor = vec3(flag) * diffuseLightFalloff * mask;\n    }\n    \n    fragColor = vec4(finalColor, 1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 319, 354, 354, 378], [380, 380, 409, 409, 496], [498, 498, 535, 535, 557], [559, 559, 602, 602, 630], [632, 632, 662, 662, 1519], [1521, 1521, 1546, 1546, 1978], [1980, 1980, 2009, 2009, 2389], [2391, 2391, 2448, 2465, 4678]], "test": "untested"}
{"id": "wtyXzz", "name": "Infinitely Repeating Spheres", "author": "MyGoodSir", "description": "this was a learning experience :D", "tags": ["raymarching", "fractal", "infinite", "phongillumination"], "likes": 0, "viewed": 52, "published": "Public", "date": "1582071473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n *Shader written by Joseph Adrian\n *2/18/2020\n *\n *My objective here was just to learn more about ray marching, GLSL, and implicit geometry\n *As it turns out, this method of rendering can do some nifty stuff.\n *\n */\n\nconst int MAX_STEPS = 250;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.0;\nconst float EPSILON = 0.0001;\n\n\n//performs modulus division on a global 3D position vector and returns its position relative to the center of it's local subspace\n//(the effect is similar to subdividing all of 3D space into regular chunks and making them all copies of the chunk centered about\n//the origin, however the actual operation that takes place below just translates a vector based on the remainder when it is \n//divided bt the nearest multiple of a given displacement vector) ****i think**** i might be totally thinking about it wrong\nvec3 repeat( vec3 pos, float offset )\n{\n    return mod(pos + offset * 0.5, offset) - offset * 0.5;\n}\n\n//signed distance function for a sphere\nfloat sphereSDF(vec3 pos, float rad)\n{\n    return length(repeat(pos, 3.0)) - rad;\n}\n\n//signed distance function for a box\nfloat boxSDF(vec3 pos, vec3 lwh)\n{\n    vec3 x = abs(pos) - lwh;\n    return length(max(x,0.0)) + min(max(x.x,max(x.y,x.z)),0.0);\n}\n\n//signed distance function for the combination of all objects in the scene\nfloat sceneSDF(vec3 pos)\n{\n    //vec3 lwh = vec3(0.20, 0.15, 0.45);\n    return sphereSDF(pos, 0.5);\n}\n\n//returns the shortest distance from the camera to the closest surface\nfloat sd2s(vec3 cam, vec3 marchDirection, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = sceneSDF(cam + depth * marchDirection);\n        if(dist < EPSILON){\n            return depth;\n        }\n        depth+=dist;\n        if(depth >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//returns the direction vector for the ray that extends from this pixel\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan( radians(fov) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\n//estimate surface normal using the gradient of the signed distance function\nvec3 approxNormal(vec3 p)\n{\n    return normalize(vec3(\n        \t\t\tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n                    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n                    sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n        \t\t\t));\n\n}\n/**\n * cDiff = diffuse color\n * cSpec = specular color\n * cAmb = ambient color\n * a = alpha\n * lPos = light position\n * nct = intensity of light\n *\n *returns the shade of color that a light contributes to the surface at a given position\n *\n */\nvec3 phongLightContrib(vec3 cDiff, vec3 cSpec, float a, vec3 pos, \n                       vec3 camPos, vec3 lPos, vec3 nct) {\n    \n    vec3 normal = approxNormal(pos);\n    vec3 light = normalize(lPos - pos);\n    vec3 view = normalize(camPos - pos);\n    vec3 reflection = normalize(reflect(-light, normal));\n    \n    float dotLN = dot(light, normal);\n    float dotRV = dot(reflection, view);\n    \n    //if dotLN is less than 0 then there is no light on this part of the surface\n    if(dotLN < 0.0){\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    //light reflecting away from camera, so only apply diffuse lighting\n    if(dotRV < 0.0){\n        return nct * (cDiff * dotLN);\n    }\n    return nct * (cDiff * dotLN + cSpec * pow(dotRV, a));\n    \n    \n}\n\n//calculates frag color after light sources are accounted for\nvec3 phongLighting(vec3 cAmb, vec3 cDiff, vec3 cSpec, float a, vec3 pos, vec3 camPos){\n    \n    const vec3 AL = 0.5 * vec3(1.0, 1.0, 1.0);//AL = Ambient Light\n    vec3 color = AL * cAmb;\n    \n    vec3 pL1 = vec3(4.0 * sin(iTime),//light 1 position\n                    2.0,\n                    4.0 * cos(iTime));\n    vec3 nctL1 = vec3(0.4, 0.4, 0.4);//light 1 intensity\n    \n    color += phongLightContrib(cDiff, cSpec, a, pos, camPos, pL1, nctL1);\n    \n    \n    vec3 pL2 = vec3(2.0 * sin(0.37 * iTime),//light 2 position\n                    2.0 * cos(0.37 * iTime),\n                    2.0);\n    vec3 nctL2 = vec3(0.4, 0.4, 0.4); //light 2 intensity\n    \n    color += phongLightContrib(cDiff, cSpec, a, pos, camPos, pL2, nctL2);\n    \n    return color;\n}\n\n\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float fov = 90.0;\n    \n    vec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n\tvec3 cam = vec3(0.0, 0.0, 5.0);\n    float dist = sd2s(cam, dir, MIN_DIST, MAX_DIST);\n    \n    //case if ray does not hit a surface\n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    vec3 point = cam + dist * dir;\n    vec3 cAmb = vec3(0.3, 0.3, 0.5);\n    vec3 cDiff = vec3(0.2, 0.2, 0.8);\n    vec3 cSpec = vec3(1.0, 1.0, 1.0);\n    float alpha = 10.0;\n    \n    vec3 color = phongLighting(cAmb, cDiff, cSpec, alpha, point, cam);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 850, 889, 889, 950], [952, 992, 1030, 1030, 1075], [1077, 1114, 1148, 1148, 1243], [1245, 1320, 1346, 1387, 1421], [1423, 1494, 1561, 1561, 1861], [1863, 1935, 1992, 1992, 2116], [2118, 2195, 2222, 2222, 2566], [2567, 2811, 2936, 2936, 3562], [3564, 3626, 3712, 3712, 4379], [4382, 4398, 4455, 4455, 5077]], "test": "untested"}
{"id": "XdG3Rt", "name": "Boring Basic Mandelbrot", "author": "Xerophyte", "description": "A basic float-only mandelbrot renderer. Nothing special, it just seemed like I should have one.", "tags": ["mandelbrot"], "likes": 3, "viewed": 64, "published": "Public", "date": "1581184413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Maximum number of iterations of the Mandelbrot sequence to check before deciding if a point is in the set.\n// Has a high impact on both performance and accuracy.\nconst int MAX_ITER = 666;\n\n// Point on which the zoom is centered\nconst vec2 REGION_MID = vec2(-0.774472, 0.124979);\n\n// Zoom extremes\nconst float ZOOM_MIN  = 0.2;\nconst float ZOOM_MAX  = 50000.0;\n\n// Total time in seconds for the entire zoom loop\nconst float ZOOM_TIME = 50.0;\n\n// Colors used for the iteration count color cycle. Can use arbitrarily many.\nconst int NUM_COLORS = 3;\nvec4 COLORS[NUM_COLORS] = vec4[](\n    vec4(255.0, 237.0, 130.0, 255.0) / 255.0,\n    vec4(253.0, 143.0, 19.4,  255.0) / 255.0,\n    vec4(179.0, 29.0,  0.43,  255.0) / 255.0);\n\n// Colors used for the interior of the set\nvec4 INTERIOR_COLOR = vec4(0.1, 0.1, 0.1, 1.0);\n\n// Supersampling offsets used when rendering. This 16 sample pattern taken from:\n// http://docs.microsoft.com/en-us/windows/win32/api/d3d11/ne-d3d11-d3d11_standard_multisample_quality_levels\nconst int NUM_SAMPLES = 16;\nvec2 SAMPLE_OFFSETS[NUM_SAMPLES] = vec2[](\n    vec2( 1.0, 1.0) / 16.0,\n    vec2(-1.0,-3.0) / 16.0,\n    vec2(-3.0, 2.0) / 16.0,\n    vec2( 4.0,-1.0) / 16.0,\n    \n    vec2(-5.0,-2.0) / 16.0,\n    vec2( 2.0, 5.0) / 16.0,\n    vec2( 5.0, 3.0) / 16.0,\n    vec2( 3.0,-5.0) / 16.0,\n    \n    vec2(-2.0, 6.0) / 16.0,\n    vec2( 0.0,-7.0) / 16.0,\n    vec2(-4.0,-6.0) / 16.0,\n    vec2(-6.0, 4.0) / 16.0,\n    \n    vec2(-8.0, 0.0) / 16.0,\n    vec2( 7.0,-4.0) / 16.0,\n    vec2( 6.0, 7.0) / 16.0,\n    vec2(-7.0,-8.0) / 16.0);\n\n\n// compute c0 * c1 for complex numbers c0, c1\nvec2 cmul(in vec2 c0, in vec2 c1) {\n    float r = c0.x * c1.x - c0.y * c1.y;\n    float i = c0.x * c1.y + c0.y * c1.x;\n    return vec2(r, i);\n}\n\n// compute c * c for a complex number c\nvec2 csqr(in vec2 c) {\n    float r = c.x * c.x - c.y * c.y;\n    float i = 2.0 * c.x * c.y;\n    return vec2(r, i);\n}\n\n// compute x * x for a float x\nfloat sqr(in float x) {\n\treturn x * x;   \n}\n\n// compute abs(c) * abs(c) for a complex number c\nfloat lengthsq(in vec2 c) {\n    return dot(c, c);\n}\n\n// Compute the next iteration of a Mandelbrot sequence from the previous value and the constant c\nvec2 iteration(in vec2 prev, in vec2 c) {\n    return csqr(prev) + c;\n}\n\n// True if a point c is in the main cardioid, else false\nbool inCardioid(in vec2 c) {\n    float tmp = c.x - 0.25;\n    float q = sqr(tmp) + sqr(c.y);\n    \n    return q * (q + tmp) < 0.25 * sqr(c.y);\n}\n\n\n// True if a point c is in the 2nd order bulb, else false\nbool in2Bulb(vec2 c) {    \n    return sqr(c.x + 1.0) + sqr(c.y) < (1.0 / 16.0);\n}\n\n\n// Compute the Mandelbrot normalized escape iteration count for a point on the complex plane.\n// Returns 0 for points that are estimated to be in the set\nfloat normIterCount(vec2 c) {\n    // If the point is in the main cardioid or 2nd order bulb then we can exit early.\n    if (inCardioid(c) || in2Bulb(c)) {\n        return 0.0;\n    }\n    \n    // Otherwise, see if and when the Mandelbrot sequence escapes for c.\n    vec2 z = c;\n    for (int i = 1 ; i < MAX_ITER ; ++i) {\n        float zsq = lengthsq(z);\n        \n\t\t// Escape is guaranteed if abs(z) > threshold on an iteration. A threshold of 2 is \n        // sufficient for testing if a point escapes, but with normalized iteration count the\n        // interpolation between iterations can only be estimated well with a larger threshold.\n        const float THRESHOLD = 256.0;\n        if (zsq > THRESHOLD * THRESHOLD) {\n            // The normalized iteration count formula following iq's fast version for\n            // a threshold of 256.\n            //\n            // Generally, given a THRESHOLD = 2^p, the fast version is\n            // return float(i) - log2(log2(zsq)) + log2(p) + 1\n        \treturn float(i) - log2(log2(zsq)) + 4.0;\n        }\n        z = iteration(z, c);\n    }\n    \n    // The sequence did not escape for our iteration max. Treat as part of the set.\n    return 0.0;\n}\n\n// Convert from screen space fragment coordinates to a complex number.\nvec2 screenToComplex(vec2 fragCoord, float time) {    \n    // Weight is two smoothstep splines that blend from 0 to 1 and back over the specified time period.\n    float normTime = 2.0 * fract(time / ZOOM_TIME);\n    float weight = normTime > 1.0 ? 2.0 - normTime : normTime;\n    weight = smoothstep(0.0, 1.0, weight);\n    \n    // Do the interpolation in log space so the zoom rate appears constant.\n    // Blend between the log min/max zoom values, then transform back to real zoom coefficient.\n\tconst float LOG_ZOOM_MIN = log(ZOOM_MIN);\n    const float LOG_ZOOM_MAX = log(ZOOM_MAX);\n    float logZoom = mix(LOG_ZOOM_MIN, LOG_ZOOM_MAX, weight);    \n    float zoom = exp(logZoom);\n    \n    // Scale the render region by the zoom value and transform fragCoord to a complex number.\n\tfloat regionSize = 1.0 / zoom;\n    float scale = regionSize / iResolution.y;\n    vec2 c = fragCoord.xy * scale;    \n    c = c + REGION_MID - 0.5 * regionSize;\n    \n    return c;\n}\n\n// Compute a color value from a normalized iteration count.\nvec4 computeColor(float iter) {\n    // If a part of the set, use the interior color.\n    if (iter == 0.0) {\n    \treturn INTERIOR_COLOR;   \n    }\n    \n    // Else use a blend between the colors of the cycle. I take the log of the iteration count because I\n    // like how it makes the areas closer to the set where iterations change rapidly look less busy and\n    // aliased. Most renderers do not do this.\n    float ifloor;\n    float imod = modf(log2(iter), ifloor);    \n    int ix = int(ifloor);\n    vec4 color = mix(COLORS[ix % NUM_COLORS], COLORS[(ix + 1) % NUM_COLORS], imod);\n    \n    return color;\n}\n\n// Sample the mandelbrot colorization at a point in screen space.\nvec4 sampleMandelbrot(vec2 fragCoord, float time) {\n    // Convert screen position to a complex number c\n\tvec2 c = screenToComplex(fragCoord, time);\n    \n    // Compute the normalized iteration count for the Mandelbrot sequence for c \n    float iter = normIterCount(c);\n    \n    // Color according to the normalized iteration count.\n\treturn computeColor(iter);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 color = vec4(0.0);\n    \n    // Sample N points around the pixel according to the hardcoded supersample offsets.\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        color += sampleMandelbrot(fragCoord + SAMPLE_OFFSETS[i], iTime);\n    }\n    \n    // Average the color samples.\n\tfragColor = color / float(NUM_SAMPLES);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdG3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1542, 1588, 1623, 1623, 1730], [1732, 1772, 1794, 1794, 1887], [1889, 1920, 1943, 1943, 1963], [1965, 2015, 2042, 2042, 2066], [2068, 2166, 2207, 2207, 2236], [2238, 2295, 2323, 2323, 2437], [2440, 2498, 2520, 2520, 2579], [2582, 2736, 2765, 2851, 3925], [3927, 3998, 4048, 4156, 4956], [4958, 5018, 5049, 5102, 5623], [5625, 5691, 5742, 5795, 6053], [6056, 6056, 6111, 6111, 6437]], "test": "untested"}
