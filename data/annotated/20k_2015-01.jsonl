{"id": "4lf3DM", "name": "[2TC 15] Lights Attraction", "author": "aiekick", "description": "Lights", "tags": ["lights", "2tc15"], "likes": 16, "viewed": 1569, "date": "1422309946", "time_retrieved": "2024-06-20T18:15:37.410323", "image_code": "void mainImage( out vec4 f, in vec2 p )\n{\n    float \n        e = iTime*.3+5.,\n        m = 0.,\n        y;\n    \n    vec2 \n        s = iResolution.xy,\n\t\tv = 2.*(2.*p.xy-s)/s.y;\n    \n    for(float i=0.;i<3e2;i++)\n    {\n       \ty = 6.28*i/3e2;\n        \n        s = v - fract((e+492.87)*sin(i*695.58))*e * vec2(cos(y), sin(y));\n        \n        m += 2e-3/dot(s,s);\n        \n    }\n    \n    f = \n            mix(\n                vec4(m), \n                texture(iChannel0, v/5.), \n                clamp(m, 0., .5)\n            );\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 523]]}
{"id": "4lf3DN", "name": "point in polygon", "author": "public_int_i", "description": "just trying stuff", "tags": ["2d", "polygon", "in", "point"], "likes": 3, "viewed": 246, "date": "1422287395", "time_retrieved": "2024-06-20T18:15:37.411968", "image_code": "\n\n\nbool inTri(vec2 verts[3], vec2 point) {\n  bool hit = false;\n    \n  for (int i = 0; i < 3; i++) {\n      vec2 vI = verts[i];\n      vec2 vJ = verts[int(mod(float(i)+2.0,3.0))];\n  \t  if ( ((vI.y > point.y) != (vJ.y > point.y)) && (point.x < (vJ.x-vI.x) * (point.y-vI.y) / (vJ.y-vI.y) + vI.x) ) {\n         hit = !hit;\n      }\n  }\n  return hit;\n}\n\n\n\nbool inQuad(vec2 verts[4], vec2 point) {\n  bool hit = false;\n    \n  for (int i = 0; i < 4; i++) {\n      vec2 vI = verts[i];\n      vec2 vJ = verts[int(mod(float(i)+3.0,4.0))];\n  \t  if ( ((vI.y > point.y) != (vJ.y > point.y)) && (point.x < (vJ.x-vI.x) * (point.y-vI.y) / (vJ.y-vI.y) + vI.x) ) {\n         hit = !hit;\n      }\n  }\n  return hit;\n}\n\n\nbool inPentagon(vec2 verts[5], vec2 point) {\n  bool hit = false;\n    \n  for (int i = 0; i < 5; i++) {\n      vec2 vI = verts[i];\n      vec2 vJ = verts[int(mod(float(i)+4.0,5.0))];\n  \t  if ( ((vI.y > point.y) != (vJ.y > point.y)) && (point.x < (vJ.x-vI.x) * (point.y-vI.y) / (vJ.y-vI.y) + vI.x) ) {\n         hit = !hit;\n      }\n  }\n  return hit;\n}\n\nbool inHexagon(vec2 verts[6], vec2 point) {\n  bool hit = false;\n    \n  for (int i = 0; i < 6; i++) {\n      vec2 vI = verts[i];\n      vec2 vJ = verts[int(mod(float(i)+5.0,6.0))];\n  \t  if ( ((vI.y > point.y) != (vJ.y > point.y)) && (point.x < (vJ.x-vI.x) * (point.y-vI.y) / (vJ.y-vI.y) + vI.x) ) {\n         hit = !hit;\n      }\n  }\n  return hit;\n}\n\nbool inHeptagon(vec2 verts[7], vec2 point) {\n  bool hit = false;\n    \n  for (int i = 0; i < 7; i++) {\n      vec2 vI = verts[i];\n      vec2 vJ = verts[int(mod(float(i)+6.0,7.0))];\n  \t  if ( ((vI.y > point.y) != (vJ.y > point.y)) && (point.x < (vJ.x-vI.x) * (point.y-vI.y) / (vJ.y-vI.y) + vI.x) ) {\n         hit = !hit;\n      }\n  }\n  return hit;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 vs[3];\n    vs[0] = vec2(sin(iTime)*0.2+0.5,0.2);\n    vs[1] = vec2(0.5,0.8);\n    vs[2] = vec2(sin(iTime)*-0.2+0.5,0.2);\n    \n    if (inTri(vs,uv)) {\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[3, 3, 42, 42, 343], [347, 347, 387, 387, 688], [691, 691, 735, 735, 1036], [1038, 1038, 1081, 1081, 1382], [1384, 1384, 1428, 1428, 1729], [1734, 1734, 1791, 1791, 2094]]}
{"id": "4lf3WN", "name": "[2TC 15] Complex Power Color", "author": "MichaelPohoreski", "description": "Based on \"Complex Power\" by CÃ©lestin Marot\nhttps://www.shadertoy.com/view/XtlGD8\n", "tags": ["procedural", "2d", "chromatic", "colorwheel"], "likes": 2, "viewed": 195, "date": "1421955731", "time_retrieved": "2024-06-20T18:15:37.629999", "image_code": "// [2TC 15] Complex Power Color\n// Heavily inlined, optimized, and minifined by Michael Pohoreski 2015\n// Chars: 271\n//\n// Based on the excellent \"Complex Power\" by CÃ©lestin Marot\n// https://www.shadertoy.com/view/XtlGD8\n//   Please mention my name (CÃ©lestin Marot) if you want to use that color wheel\n//   cause it took me some time to find the write way to do it ^^\n//\n// For an alternate color wheel using Hue2RGB see my shader:\n// https://www.shadertoy.com/view/XtfGDN\n//\n// For a fun variation:\n//    float t = 2.*cos(iTime)+2.,\n//    fragColor = vec4( m/length(m)*.1*t/length(c),1.);\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    float t = cos(iTime)+2., // Original\n          P = 3.1415962; // The alt. is too verbose: 4.*atan(1.);\n    vec2  c = 2.*w/iResolution.xy - 1.;\n    float s = 1./3.,\n          a = mod((atan(c.y,c.x)+P)*t/P,2.) - 1.,\n          b =      abs(a + s)- 1.,\n          d = 1. - abs(a - s)    ;\n    vec3  m = 1. - vec3(abs(a), abs(b), abs(d));\n    f = vec4( m/length(m)*exp(-pow(length(c),t))*2., 1. ); // Original `exp(-pow(length(c),t)` looks nicer :-)\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 596, 637, 637, 1087]]}
{"id": "4lfGWr", "name": "Bidirectional path tracer 2", "author": "reinder", "description": "My second try of creating a bidirectional path tracer. I really should read those articles :( (all weights of the paths are guessed)\nThe shader shows a scene with indirect lighting, using a bidirectional path tracer and a classical path tracer.", "tags": ["lighting", "indirect", "tracer", "path", "bidirectional"], "likes": 53, "viewed": 7146, "date": "1420563049", "time_retrieved": "2024-06-20T18:15:39.611973", "image_code": "// Bidirectional path tracer 2. Created by Reinder Nijhoff 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4lfGWr\n//\n\n#define eps 0.00001\n#define LIGHTPATHLENGTH 2\n#define EYEPATHLENGTH 3\n#define SAMPLES 8\n\n#define SHOWSPLITLINE\n#define FULLBOX\n\n#define DOF\n#define ANIMATENOISE\n#define MOTIONBLUR\n\n#define MOTIONBLURFPS 12.\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*200.\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection(inout float seed) {\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\n\tvec3 dr = randomSphereDirection(seed);\n\treturn dot(dr,n) * dr;\n}\n\n//-----------------------------------------------------\n// light\n//-----------------------------------------------------\n\nconst vec4 lightSphere = vec4( 3.0,7.5,2.5, .5 );\nvec4 movingSphere;\n\nvoid initMovingSphere( float time ) {\n\tmovingSphere = vec4( 1.+abs(1.0*sin(time*1.3)), 1.+abs(2.0*sin(time)), 7.-abs(6.*cos(time*0.4)), 1.0);\n}\n\nvec3 sampleLight( const in vec3 ro, inout float seed ) {\n    vec3 n = randomSphereDirection(seed) * lightSphere.w;\n    return lightSphere.xyz + n;\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x && ro.z+rd.z*t < 5.5 ) { res = vec2( t, 1. ); normal = vec3( 0.,-1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, movingSphere             ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, movingSphere ); }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 5. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, movingSphere            );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n#ifdef FULLBOX    \n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<dist && ro.z+rd.z*t < 5.5 ) { return true; }\n#endif\n    return false; // optimisation: other planes don't cast shadows in this scene\n}\n\n//-----------------------------------------------------\n// materials\n//-----------------------------------------------------\n\nvec3 matColor( const in float mat ) {\n\tvec3 nor = vec3(0., 0.95, 0.);\n\t\n\tif( mat<3.5 ) nor = REDCOLOR;\n    if( mat<2.5 ) nor = GREENCOLOR;\n\tif( mat<1.5 ) nor = WHITECOLOR;\n\tif( mat<0.5 ) nor = LIGHTCOLOR;\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\nbool matIsSpecular( const in float mat ) {\n    return mat > 4.5;\n}\n\nbool matIsLight( const in float mat ) {\n    return mat < 0.5;\n}\n\n//-----------------------------------------------------\n// brdf\n//-----------------------------------------------------\n\nvec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {\n    specularBounce = false;\n    \n    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );\n    if(  !matIsSpecular( m ) ) {\n        return r;\n    } else {\n        specularBounce = true;\n        \n        float n1, n2, ndotr = dot(rd,n);\n        \n        if( ndotr > 0. ) {\n            n1 = 1./1.5; n2 = 1.;\n            n = -n;\n        } else {\n            n2 = 1./1.5; n1 = 1.;\n        }\n                \n        float r0 = (n1-n2)/(n1+n2); r0 *= r0;\n\t\tfloat fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);\n        \n        vec3 ref = refract( rd, n, n2/n1 );        \n        if( ref == vec3(0) || hash1(seed) < fresnel || m > 6.5 ) {\n            ref = reflect( rd, n );\n        }\n        \n        return ref; // normalize( ref + 0.1 * r );\n\t}\n}\n\n//-----------------------------------------------------\n// lightpath\n//-----------------------------------------------------\n\nstruct LightPathNode {\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n};\n\nLightPathNode lpNodes[LIGHTPATHLENGTH];\n\nvoid constructLightPath( inout float seed ) {\n    vec3 ro = randomSphereDirection( seed );\n    vec3 rd = cosWeightedRandomHemisphereDirection( ro, seed );\n    ro = lightSphere.xyz - ro*lightSphere.w;\n    vec3 color = LIGHTCOLOR;\n \n    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\n    }\n    \n    bool specularBounce;\n    float w = 0.;\n    \n    for( int i=0; i<LIGHTPATHLENGTH; i++ ) {\n\t\tvec3 normal;\n        vec2 res = intersect( ro, rd, normal );\n        \n        if( res.y > 0.5 && dot( rd, normal ) < 0. ) {\n            ro = ro + rd*res.x;            \n            color *= matColor( res.y );\n            \n            lpNodes[i].position = ro;\n            if( !matIsSpecular( res.y ) ) lpNodes[i].color = color;// * clamp( dot( normal, -rd ), 0., 1.);\n            lpNodes[i].normal = normal;\n            \n            rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\n        } else break;\n    }\n}\n\n//-----------------------------------------------------\n// eyepath\n//-----------------------------------------------------\n\nfloat getWeightForPath( int e, int l ) {\n    return float(e + l + 2);\n}\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool bidirectTrace, inout float seed ) {\n    vec3 tcol = vec3(0.);\n    vec3 fcol  = vec3(1.);\n    \n    bool specularBounce = true; \n\tint jdiff = 0;\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) {\n            return tcol;\n        }\n        \n        if( matIsLight( res.y ) ) {\n            if( bidirectTrace ) {\n            \tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\n            } else {\n               tcol += fcol*LIGHTCOLOR;\n            }\n            return tcol; // the light has no diffuse component, therefore we can return col\n        }\n        \n        ro = ro + res.x * rd;   \n        vec3 rdi = rd;\n        rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\n            \n        if(!specularBounce || dot(rd,normal) < 0.) {  \n        \tfcol *= matColor( res.y );\n        }\n        \n        if( bidirectTrace  ) {\n\t\t    vec3 ld = sampleLight( ro, seed ) - ro;       \n            \n            // path of (j+1) eyepath-nodes, and 1 lightpath-node ( = direct light sampling )\n            vec3 nld = normalize(ld);\n            if( !specularBounce &&  !intersectShadow( ro, nld, length(ld)) ) {\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w / dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\n                float weight = 2. * (1. - cos_a_max);\n\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.))\n                    / getWeightForPath(jdiff,-1);\n            }\n\n            \n            if( !matIsSpecular( res.y ) ) {\n                for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n                    // path of (j+1) eyepath-nodes, and i+2 lightpath-nodes.\n                    vec3 lp = lpNodes[i].position - ro;\n                    vec3 lpn = normalize( lp );\n                    vec3 lc = lpNodes[i].color;\n\n                    if( !intersectShadow(ro, lpn, length(lp)) ) {\n                        // weight for going from (j+1)th eyepath-node to (i+2)th lightpath-node\n                        \n                        // IS THIS CORRECT ???\n                        \n                        float weight = \n                                 clamp( dot( lpn, normal ), 0.0, 1.) \n                               * clamp( dot( -lpn, lpNodes[i].normal ), 0., 1.)\n                               * clamp(1. / dot(lp, lp), 0., 1.)\n                            ;\n\n                        tcol += lc * fcol * weight / getWeightForPath(jdiff,i);\n                    }\n                }\n            }\n        }\n        \n        if( !specularBounce) jdiff++; else jdiff = 0;\n    }  \n    \n    return tcol;\n}\n\n//-----------------------------------------------------\n// main\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\n    bool bidirectTrace = fragCoord.x < splitCoord;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef ANIMATENOISE\n    float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n#else\n    float seed = p.x + p.y * 3.43121412313;\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n    \n    for( int a=0; a<SAMPLES; a++ ) {\n\n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n#ifdef DOF\n\t    vec3 fp = ro + rd * 12.0;\n   \t\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\n    \trd = normalize( fp - rof );\n#else\n        vec3 rof = ro;\n#endif        \n        \n#ifdef MOTIONBLUR\n        initMovingSphere( iTime + hash1(seed) / MOTIONBLURFPS );\n#else\n        initMovingSphere( iTime );        \n#endif\n        \n        if( bidirectTrace ) {\n            constructLightPath( seed );\n        }\n        \n        col = traceEyePath( rof, rd, bidirectTrace, seed );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot /= float(SAMPLES);\n    \n#ifdef SHOWSPLITLINE\n\tif (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\ttot.x = 1.0;\n\t}\n#endif\n    \n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lfGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 612, 643, 643, 695], [697, 697, 727, 727, 813], [815, 815, 845, 845, 955], [957, 1104, 1146, 1146, 1180], [1182, 1182, 1236, 1236, 1482], [1484, 1484, 1524, 1524, 1546], [1548, 1548, 1601, 1601, 1663], [1665, 1787, 1864, 1864, 2174], [2176, 2176, 2222, 2222, 2366], [2368, 2368, 2434, 2434, 2500], [2502, 2694, 2731, 2731, 2837], [2839, 2839, 2895, 2895, 2987], [2989, 3111, 3172, 3172, 4363], [4365, 4365, 4428, 4428, 4846], [4848, 4974, 5011, 5011, 5211], [5213, 5213, 5255, 5255, 5279], [5281, 5281, 5320, 5320, 5344], [5346, 5467, 5578, 5578, 6328], [6330, 6576, 6621, 6621, 7558], [7560, 7684, 7724, 7724, 7755], [7757, 7757, 7849, 7849, 10500], [10502, 10623, 10680, 10680, 12687]]}
{"id": "4ll3D7", "name": "volumetric light show", "author": "public_int_i", "description": "light show", "tags": ["3d", "ray", "light", "volumetric", "march", "show"], "likes": 4, "viewed": 277, "date": "1422665324", "time_retrieved": "2024-06-20T18:15:41.066589", "image_code": "\n\n#define MAX_STEP 64\n#define EPILSON 0.05\n#define NORMAL_EPILSON 0.0001\n\n\n\n\nconst float viewDist = 40.0;\n\nconst float lightDist = 20.0;\nvec4 lightColor;\nvec3 lightPos;\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\n\n\n//distance functions\n//take from iq's site http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sphere(in vec3 p, in float radius) {//signed\n    return length(p)-radius;\n}\nvec3 sphereNormal(in vec3 p, in float radius) {\n    return normalize(vec3(\n        sphere(vec3(p.x+NORMAL_EPILSON,p.y,p.z),radius)-sphere(vec3(p.x-NORMAL_EPILSON,p.y,p.z),radius),\n        \n\t\tsphere(vec3(p.x,p.y+NORMAL_EPILSON,p.z),radius)-sphere(vec3(p.x,p.y-NORMAL_EPILSON,p.z),radius),\n        \n        sphere(vec3(p.x,p.y,p.z+NORMAL_EPILSON),radius)-sphere(vec3(p.x,p.y,p.z-NORMAL_EPILSON),radius)\n        ));\n}\n\nfloat roundBox(in vec3 p, in vec3 boxExt, in float round) {//unsigned\n    return length(max(abs(p)-boxExt,0.0))-round;\n}\nvec3 roundBoxNormal(in vec3 p, in vec3 boxExt, in float round) {\n    return normalize(vec3(\n        roundBox(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt, round)-roundBox(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt,round),\n        \n\t\troundBox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt, round)-roundBox(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt,round),\n        \n        roundBox(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt, round)-roundBox(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt,round)\n        ));\n}\n\nfloat box(in vec3 p, in vec3 boxExt) {//unsigned\n    return length(max(abs(p)-boxExt,0.0));\n}\nvec3 boxNormal(in vec3 p, in vec3 boxExt) {\n    return normalize(vec3(\n        box(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt)-box(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt),\n        \n\t\tbox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt)-box(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt),\n        \n        box(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt)-box(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt)\n        ));\n}\n\n\nfloat raySphere(in vec3 p, in vec3 dir, in float sphereRad) {\n    \n    float c = dot(p, p) - (sphereRad*sphereRad);\n    float b = dot(dir, p);\n\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    \n    if (!(d < 0.0 || t < 0.0)) {\n        return t;\n    } else {\n    \treturn 0.0;\n    }\n    \n}\n\n\n\n//scene functions \n\nconst vec3 boxPos = vec3(0.0,-4.0,0.0);\nconst vec3 boxExt = vec3(1.0);\n\nvoid scene(in vec3 rayPos, out int hitId, out float hitDist) {\n    float db;\n    \n    //floor\n\thitId = 0;\n    hitDist = abs(rayPos.y+10.0);\n\n    //x+ wall\n    db = abs(rayPos.x+15.0);\n    if (db < hitDist) {\n        hitId = 1;\n        hitDist = db;\n    }\n    \n    //x- wall\n    db = abs(rayPos.x-15.0);\n    if (db < hitDist) {\n        hitId = 2;\n        hitDist = db;\n    }\n    \n    //z+ wall\n    db = abs(rayPos.z+15.0);\n    if (db < hitDist) {\n        hitId = 3;\n        hitDist = db;\n    }\n    \n    //z- wall\n    db = abs(rayPos.z-15.0);\n    if (db < hitDist) {\n        hitId = 4;\n        hitDist = db;\n    }\n    \n    //cube\n    db = box(rayPos-boxPos,boxExt);\n    if (db < hitDist) {\n        hitId = 5;\n        hitDist = db;\n    }\n}\n\n\n\nvoid trace(in vec3 rayStartPos, in vec3 rayStartDir, in float maxDist, out int hitId, out float hitDist) {\n    \n    float s = 0.0,db;\n    vec3 rayPos;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        //get new ray pos\n        rayPos = rayStartPos+rayStartDir*s;\n        \n\t\tscene(rayPos,hitId,hitDist);\n        \n        if (hitDist < EPILSON) {\n            hitDist = s;\n            return;\n        }\n        \n\n        s += hitDist;\n        if (s >= maxDist) {\n            break;\n        }\n    }\n    \n    hitDist = maxDist;\n    hitId = -1;//hit id is -1 if nothing is hit\n}\n\n\n\n#define msamp texture(iChannel0,(mod(lightVec.xz,0.5))*0.4).x\n\n\n//LIGHT VOLUMES\n\n\n#define LIGHT_PRECISION 0.2\n#define MAX_LIGHT_STEPS 64\n#define LIGHT_AM 0.05\n#define SHADOW_AM 0.05\n\n\nvec4 traceLightSphere(in vec3 rayStart, in vec3 rayDir, in vec3 end, in vec3 pos, in float rad) {\n    float traceSphere = raySphere(rayStart-pos,rayDir,rad);\n    \n    float endLen = length(rayStart-end);\n    if (traceSphere == 0.0 || endLen < traceSphere) {\n        return vec4(0.0);\n    }\n    \n    float sum = 0.0;\n    vec3 rayPos = rayStart+rayDir*traceSphere;\n    vec3 lightVec;\n        \n    int hitId;\n    float hitDist,atten;\n    \n    for (int i = 0; i < MAX_LIGHT_STEPS; i++) {\n        lightVec = rayPos-pos;\n        atten = length(lightVec);\n        lightVec = normalize(lightVec);\n        trace(rayPos,-lightVec,atten,hitId,hitDist);\n        \n        atten = 1.0-atten/rad;\n        \n        if (hitId == -1) {\n            sum += msamp*LIGHT_AM*atten;\n        } else {\n            sum -= SHADOW_AM*atten;\n        }\n        \n        rayPos += rayDir*LIGHT_PRECISION;\n        if (length(rayStart-rayPos) > endLen || length(pos-rayPos) > rad) {\n            break;\n        }\n    }\n    \n    return vec4(max(0.0,sum))*lightColor;\n}\n\n\n\n\n//main\n\n#define lti max(0.0,dot(lightVec,norm))*atten*lightColor\n\nconst vec2 cameraMoveSpeed = vec2(0.1,0.1);\nconst vec3 cameraMoveDistance = vec3(14.0,4.0,14.0);\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //calculate camera\n    cameraPosition = vec3(sin(iTime*cameraMoveSpeed.x)*cameraMoveDistance.x,\n                          cameraMoveDistance.y,\n                          cos(iTime*cameraMoveSpeed.y)*cameraMoveDistance.z);\n    cameraDirection = normalize(-cameraPosition);\n\n    \n    lightPos = vec3(sin(iTime)*5.0,\n                    -4.0,\n                    cos(iTime)*5.0);\n    lightColor = vec4(sin(iTime)*0.5+0.5,\n                      cos(iTime)*0.5+0.5,\n                      sin(iTime*1.4)*0.4+0.4,\n                      1.0);\n                    \n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    //cameraUp = cross(cameraRight,cameraDirection);\n   \n   \n        \n  \tvec3 rayStartDir = normalize((cUv.x*cameraRight +\n                  \t\t\t\tcUv.y*cameraUp +\n        \t\t  \t\t\t\tcameraPosition + cameraDirection)-cameraPosition);\n    vec3 rayStartPos = cameraPosition;\n    \n    \n\n    //scene\n    \n    int hitId;\n    float hitDist;\n    trace(rayStartPos,rayStartDir,viewDist,hitId,hitDist);\n    \n    if (hitId == -1) {\n        return;\n    }\n    \n    vec3 hitPos = rayStartPos+rayStartDir*hitDist;\n    vec3 lightVec = lightPos-hitPos;\n    lightVec = normalize(lightVec);\n    float atten = max(0.0,1.0-length(lightVec)/lightDist);\n    \n    \n    //volumetric light sphere\n    fragColor = traceLightSphere(rayStartPos,rayStartDir,hitPos,lightPos,12.0);\n    \n    \n    //walls\n    if (hitId < 5) {\n        vec3 norm;\n        \n        if (hitId == 0) {\n            norm = vec3(0.0,1.0,0.0);\n        } else {\n            if (hitId == 1) {\n                norm = vec3(1.0,0.0,0.0);\n            } else {\n                if (hitId == 2) {\n                    norm = vec3(-1.0,0.0,0.0);\n                } else {\n                    if (hitId == 3) {\n                    \tnorm = vec3(0.0,0.0,1.0);\n                    } else {\n                        if (hitId == 4) {\n                            norm = vec3(0.0,0.0,-1.0);\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        fragColor += vec4(0.2)*lightColor+\n            \t\tmsamp*atten*lti*vec4(0.8);\n        \n        return;\n    }\n    \n    //cube\n    vec3 norm = boxNormal(hitPos-boxPos,boxExt);\n    fragColor += vec4(0.2)*lightColor+\n            msamp*atten*lti*vec4(0.6);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[257, 372, 414, 422, 453], [454, 454, 501, 501, 868], [870, 870, 929, 939, 990], [991, 991, 1055, 1055, 1476], [1478, 1478, 1516, 1526, 1571], [1572, 1572, 1615, 1615, 1967], [1970, 1970, 2031, 2031, 2268], [2272, 2364, 2426, 2426, 3100], [3104, 3104, 3210, 3210, 3680], [3748, 3868, 3965, 3965, 4900], [4905, 5108, 5165, 5193, 7588]]}
{"id": "4ll3D8", "name": "Alien Grass", "author": "Kecho", "description": "A good milestone mastering the art of modulus and repetition, only using 3 fin models and trying to proceduralize randomness.\nSuggestions are welcome.\nMy next shader will be green grass + normals + lighting perhaps?\n", "tags": ["raymarching", "fog", "modulus", "creepy"], "likes": 15, "viewed": 607, "date": "1422224511", "time_retrieved": "2024-06-20T18:15:41.072676", "image_code": "/**\n'Alien Grass' by Kleber Garcia (c) 2015\n**/\n\nvec3 FIN_EXTENDS1 = vec3(0.07, 1.9, 0.001);\nvec3 FIN_EXTENDS2 = vec3(0.04, 1.7, 0.001);\nvec3 FIN_EXTENDS3 = vec3(0.07, 1.6, 0.001);\n\nvec3 REP_B_BP1 = vec3(0.1216, 0.14, 14.27);\nvec3 REP_B_BP2 = vec3(0.116, 0.04, 10.27);\nvec3 REP_B_BP3 = vec3(0.126, 0.04, 8.27);\n\nvec2 C_CO1 = vec2(1.2, 0.00);\nvec2 C_CO2 = vec2(1.4, 0.03);\nvec2 C_CO3 = vec2(0.7, 0.03);\n\n\n\nvec2 sincos(float t)\n{\n    return vec2(sin(t), cos(t));\n}\n\nvec3 fin(in vec3 p, in vec3 offset, vec3 FIN_EXTENDS, vec3 REP_B_BP,vec2 C_CO)\n{\n    float REP = REP_B_BP.x;\n    float FIN_BEND = REP_B_BP.y;\n    float FIN_BEND_POW = REP_B_BP.z;\n    vec3 FIN_O =  vec3(0.0,0.0,0.0);  \n    float FIN_CURVATURE = C_CO.x;\n    float FIN_CURVE_OFFSET =  C_CO.y;\n    vec2 ids = mod(floor(p / REP).xz, 220.0)/220.0;\n    vec3 mp = mod(p, REP) - 0.5*REP;\n    p = vec3(mp.x,p.y,mp.z) + offset * sin(350.0*ids.x*ids.y);\n    \n    vec3 finOrigin = FIN_O;\n    vec2 sc = sincos(300.0*ids.x + 550.0*ids.y);\n    \n    p -= finOrigin;\n    p = vec3(p.x*sc.x + p.z*sc.y,p.y,p.x*sc.y - p.z*sc.x);\n    p += finOrigin;\n\n    \n    vec3 pRel = p - finOrigin;\n    vec3 finWarped = FIN_EXTENDS;\n\tfloat t = clamp(0.5*((clamp(pRel.y, -FIN_EXTENDS.y+FIN_CURVE_OFFSET, FIN_EXTENDS.y+FIN_CURVE_OFFSET) / FIN_EXTENDS.y) + 1.0),0.0,1.0);\n   \tfinWarped.x = finWarped.x - FIN_EXTENDS.x * pow(t,FIN_CURVATURE);\n    pRel = (p) - finOrigin + vec3(0.0,0.0,0.0+pow(t,FIN_BEND_POW)*FIN_BEND);\n    vec3 distVec = max(abs(pRel) - finWarped, 0.0);\n    float j = (abs(pRel.x) / finWarped.x);\n    return vec3(length(distVec), 1.0, j*clamp(t-0.5,0.0,1.0));\n}\n\nvec3 minOp(in vec3 val1, in vec3 val2)\n{\n    return val1.x < val2.x ? val1 : val2;\n}\n\nvec3 ground(in vec3 p)\n{\n    return vec3(p.y,1.0,0.01);\n}\n\nvec3 bump(in vec3 p)\n{\n    return vec3(0,0.6*sin(p.x)*cos(p.z) + 0.4*cos(0.7*p.z), 0.0);\n}\n\nvec3 scene(in vec3 p)\n{\n    return minOp(\n        \tminOp(\n                minOp(\n                    fin(p, vec3(0,0,0),FIN_EXTENDS1,REP_B_BP1,C_CO1), \n                    fin(p, vec3(0.215,0.0,0.2),FIN_EXTENDS2,REP_B_BP2,C_CO2)), \n                \tfin(p, vec3(0.03,0.0,0.2),FIN_EXTENDS3,REP_B_BP3,C_CO3)),\n        \t\tground(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 p = vec3(2.0 * uv - 1.0, 0.0) ;\n\tvec3 po = vec3(0,0,1.0);\n    p.x *= iResolution.y/iResolution.x;\n    \n    vec3 pd = normalize(p - po);\n    \n    vec2 sc = sincos(0.9);   \n    //pd = vec3(pd.x*sc.x + pd.z*sc.y,p.y,pd.x*sc.y - pd.z*sc.x);\n    pd = vec3(pd.x,pd.y*sc.x + pd.z*sc.y,pd.z*sc.x - pd.y*sc.y);\n    \n \n\tpo += vec3(0.1*iTime,2.9,-0.3*iTime);\n    \n    float t = 0.0;\n    vec3 dm = vec3(0,0,0);\n    for (int i = 0; i < 120; ++i)\n    {\n        vec3 np = po + t * pd;\n        vec3 s = scene(np + bump(np));\n       \tif (s.x < 0.001)\n        {\n            dm = s;\n        }\n       \tt += s.x;\n    }\n    vec3 col = vec3(0,0,0);\n    if (dm.y == 1.0)\n    {\n        col = dm.zzz;\n    }\n    col += pow(-(t*pd).z/10.0, 1.7); //quick fog to hide aliasing\n    col = clamp(col, 0.0, 1.0);\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 405, 427, 427, 462], [464, 464, 544, 544, 1605], [1607, 1607, 1647, 1647, 1691], [1693, 1693, 1717, 1717, 1750], [1752, 1752, 1774, 1774, 1842], [1844, 1844, 1867, 1867, 2174], [2176, 2176, 2233, 2233, 3103]]}
{"id": "4ll3DM", "name": "dynamic ray crossing", "author": "danjinxiangsi", "description": "This is a dynamic ray crossing effect created by Xiao Wu. \nThis shader is inspired by blue ray crossing shader effect.\nEveryone is welcome to use, modify and add on this effect.", "tags": ["2d", "ray", "crossing"], "likes": 4, "viewed": 1165, "date": "1422494403", "time_retrieved": "2024-06-20T18:15:41.072676", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time= sin(iTime)*.5;\n\tvec2 position = (fragCoord.yx/iResolution.yx) - 0.5;\n\t\n\tfloat px = 0.2 * (position.x+0.8);\n\tfloat py = 2.0 / (500.0 * abs(position.y - px)*time);\n    py += 2.0 / (500.0 * abs(position.y + px)*time);\n\n    \n\tpy += (1.+time)/length(25.*length(position - vec2(0, position.y)));\n\t\n\tpy += (1.+time)/length(25.*length(position - vec2(position.x, 0)));\n\n\n\tfragColor = vec4( py,  0.3 * py, 0.3 *py, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 494]]}
{"id": "4ll3Dn", "name": "knighty's dragon in 3d", "author": "eiffie", "description": "3d dragon ifs from Knighty's code found here:\n[url=https://www.shadertoy.com/view/MsBXW3]https://www.shadertoy.com/view/MsBXW3[/url]", "tags": ["dragon", "indexedsearch"], "likes": 4, "viewed": 822, "date": "1420909375", "time_retrieved": "2024-06-20T18:15:41.909154", "image_code": "//this is an attempted 3d version of knighty's excellent dragon ifs indexed DE\n\n//original at: https://www.shadertoy.com/view/MsBXW3\n////////////////////////////////////////////////////////////////////////////////\n// Distance estimation for dragon IFS. by knighty (nov. 2014).\n////////////////////////////////////////////////////////////////////////////////\n\n//play with these to see how they effect speed/accuracy...\n#define DEPTH 9\n#define REFINEMENT_STEPS 36\n\n\n#define time iTime\n#define size iResolution\n\n#define ITER_NUM pow(2., float(DEPTH))\n//Bounding radius to bailout. must be >1. higher values -> more accurate but slower (try 1000)\n//for raymarching a value of 2 or 4 is enought in principle. A vuale of 1 (when REFINE_DE is undefined) will show the bounding circle and its transformations\n//I found 1.5 (with a slider) to be the fastest trade off between DE speed and March speed - eiffie\n#define BR2BO 1.5\n\nmat3 rmx1,rmx2;//the scaled rotations are in these matrices - eiffie\nconst vec3  A0   = vec3(1.,-1., 0.);//1st IFS's transformation similatrity\nvec3  F0   = vec3(-1.,0.,0.);//fixed point of 1st IFS's transformation.\nvec3  T0; //Translation term Computed in ComputeBC().\nconst float scl0 = length(A0);//scale factor of the 1st IFS's \n\n//2nd IFS's transformation.\nvec3  A1   = vec3(-1.,-1.,0.);\nvec3  F1   = vec3(1.,0.,0.);\nvec3  T1;\n#define scl1 length(A1)\n\nfloat Findex=0.;//mapping of IFS point to [0,1[\nfloat minFindex=0.;//for colouring\nfloat BR;//Computed in ComputeBC(). Bounding circle radius. The smaller, the better (that is faster) but it have to cover the fractal (actually it have to cover it's images under the transforms)\nfloat BO;//Computed in ComputeBC(). Bailout value. it should be = (BR*s)^2 where s>1. bigger s give more accurate results but is slower.\n\nmat3 matRight(vec3 rt){//like a scaled lookat matrix given the right hand dir - eiffie\n\tfloat r=length(rt);\n\trt=normalize(rt);\n\tvec3 up=normalize(cross(vec3(0.0,0.0,1.0),rt));\n\treturn r*mat3(rt,up,cross(rt,up));\n}\nvec3 Cmult(vec3 a, vec3 b){\n\treturn b*matRight(a);//i couldn't think of a better way to do the scaled rotation :( - eiffie\n} \n\n//Compute bounding circle\nvoid ComputeBC(){\n    //Compute bounding circle center w.r.t. fixed points\n    float ss0=length(vec3(1.,0.,0.)-A0);\n    float ss1=length(vec3(1.,0.,0.)-A1);\n    float s= ss1*(1.-scl0)/(ss0*(1.-scl1)+ss1*(1.-scl0));\n    vec3 C=F0+s*(F1-F0);\n    //Translate the IFS in order to center the bounding circle at (0,0)\n    F0-=C;\n    F1-=C;\n    //Pre-compute translations terms\n    T0 = Cmult(vec3(1.,0.,0.)-A0,F0);\n    T1 = Cmult(vec3(1.,0.,0.)-A1,F1);\n    //Bounding circle radius\n    BR = -ss0*length(F0)/(1.-scl0);\n    //\n    BO = BR*BR*BR2BO;\n\trmx1=matRight(A0);rmx2=matRight(A1);//compute the scaled rotation mats - eiffie\n}\nvoid SetupDragon(float t){\n    vec3 rot=vec3(cos(t*0.3)*vec2(cos(t),sin(t)),sin(t*0.3));\n\t//vec3 rot=vec3(vec2(cos(t),sin(t)),0.0);\n    A1=Cmult(rot,A0);\n    ComputeBC();\n}\n//Computes distance to the point in the IFS which index is the current index.\n//lastDist is a given DE. If at some level the computed distance is bigger than lastDist\n//that means the current index point is not the nearest so we bail out and discard all\n//children of the current index point.\n//We also use a static Bail out value to speed things up a little while accepting less accurate DE.\n\nfloat dragonSample(vec3 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tfloat l2=dot(p,p);\n\t\t//float temp=BR+lastDist*dd;//this is to avoid computing length (sqrt)\n\t\t//if(l2>0.001+temp*temp || l2>BO) break;//since BO is so tight this didn't seem to help?? - eiffie\n\t\tif(l2>BO) break;\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tq*=2.;\n\t\tfloat sgn=floor(q); q=fract(q); j*=.5;\n\t\tif(sgn==0.){p=p*rmx1+T0;dd*=scl0;}\n\t\telse {p=p*rmx2+T1;dd*=scl1;}\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j/ITER_NUM );\n\tfloat d=(length(p)-BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nfloat DE(vec3 p){\n\tFindex=0.0;\n\t//Get an estimate. not necessary, but it's faster this way.\n\tfloat d=length(p)+0.5;\n\t//refine the DE\n\tfor(int i=0; i<REFINEMENT_STEPS; i++){//experiment: try other values\n\t// In principle max number of iteration should be ITER_NUM but we actually\n\t//do much less iterations. Maybe less than O(DEPTH^2). Depends also on scl.\n\t\td=dragonSample(p,d);\n\t\tif(Findex>=1.) break;\n\t}\n\treturn d;\n}\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 fc){\n\treturn 0.5+0.5*rnd(fc);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tSetupDragon(time);\n\tvec3 ro=vec3(0.0,0.0,3.0);\n\tvec3 rd=lookat(-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,1.0));\n\tfloat t=DE(ro)*rndStart(fragCoord.xy),d=0.0,dm=100.0,tm,px=1.0/size.y;\n\tfor(int i=0;i<32;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>6.0 || d<px)break;\n\t}\n\tvec3 col=vec3(0.5+0.5*rd.y);\n\tif(dm<px*4.0){\n\t\tro+=rd*tm;\n\t\tvec2 e=vec2(0.5*px,0.0);\n\t\tvec3 N=normalize(vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx))-vec3(DE(ro-e.xxx*0.577)));\n\t\tvec3 L=normalize(vec3(0.4,0.7,-0.2));\n\t\tcol=0.75+0.25*sin(vec3(15.,6.5,3.25)*minFindex);\n\t\tcol*=(0.5+0.5*dot(N,L));\n\t}\n\tfragColor = vec4(col,1.0);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1393, 1793, 1816, 1879, 2006], [2007, 2007, 2034, 2034, 2131], [2134, 2160, 2177, 2234, 2783], [2784, 2784, 2810, 2810, 2956], [2957, 3351, 3394, 3394, 4198], [4200, 4200, 4217, 4217, 4618], [4619, 4619, 4637, 4637, 4692], [4693, 4693, 4717, 4717, 4744], [4745, 4745, 4766, 4766, 4866], [4868, 4868, 4925, 4925, 5548]]}
{"id": "4llGDH", "name": "[2TC 15] Metasin", "author": "poljere", "description": "Metaballs moving through a lovely sin in 252 chars.", "tags": ["2d", "metaballs", "sin", "2tc15"], "likes": 5, "viewed": 1609, "date": "1422171887", "time_retrieved": "2024-06-20T18:15:41.909154", "image_code": "void mainImage( out vec4 f, vec2 w )\n{\n\tvec4 q = vec4(w,iTime*.15,1.) / iResolution.xyzx;\n    for(float i=1.; i<30.; i++)\n        q.w += smoothstep( .15, .0, length(q.xy - vec2(i/30. + sin(i + q.z), .5 + .3 * sin(q.x * 9. * sin(q.z) + q.z))));\n    f = vec4(1. - q.w) * 4.*sqrt(q.x*q.y*(1.-q.x)*(1.-q.y));\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4llGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 38, 38, 306]]}
{"id": "4llGWM", "name": "Supershape 3D", "author": "eiffie", "description": "I just wanted to see what it looks like but actually this method works ok-ish. If anyone knows of a DE for these things let me know - or if you spot improvements!!", "tags": ["3d", "superformula", "supershape"], "likes": 69, "viewed": 4838, "date": "1422458071", "time_retrieved": "2024-06-20T18:15:42.533422", "image_code": "//SuperShape 3d by eiffie based on mickdermack's 2d formula\n\n#define time iTime\n#define size iResolution\n\nvec4 S1,S2;//m,n1,n2,n3\n\n//from mickdermack https://www.shadertoy.com/view/MdXXDB\nfloat SuperFormula(float phi, float a, float b, float m, float n1, float n2, float n3){\n\treturn pow((pow(abs(cos(m*phi/4.0)/a),n2) + pow(abs(sin(m*phi/4.0)/b), n3)), -(1.0/n1));\n}\nfloat SuperShape3D(in vec3 p){\n\tfloat d=length(p);//the distance to the center of the shape\n\tfloat sn=p.z/d;//the sine of rho (the angle between z and xy)\n\tfloat phi=atan(p.y,p.x),rho=asin(sn);//the angles to feed the formula\n\tfloat r1=SuperFormula(phi,0.75+0.25*sin(time),1.0,S1.x,S1.y,S1.z,S1.w);\n\tfloat r2=SuperFormula(rho,1.0,1.0,S2.x,S2.y,S2.z,S2.w);//the radii\n\t//vec3 np=r2*vec3(r1*cos(rho)*vec2(cos(phi),sin(phi)),sin(rho));//reconstituted point\n\t//d-=length(np);//the distance to this point\n\td-=r2*sqrt(r1*r1*(1.0-sn*sn)+sn*sn);//same as above but optimized a bit\n\treturn d;\n\n}\nfloat DDE(in vec3 p, in vec3 rd){\n\tfloat d=SuperShape3D(p),s=d*0.5;\n\tfloat dr=(d-SuperShape3D(p+rd*s))/s;\n\treturn d/(1.0+max(dr,0.0));\n}\n\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 fragCoord){\n\treturn 0.5+0.5*rnd(fragCoord.xy+vec2(time*217.0));\n}\nfloat shadao(vec3 ro, vec3 rd, float px,vec2 fragCoord){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=2.0*px*rndStart(fragCoord);\n\tfor(int i=0;i<12;i++){\n\t\td=max(px,DDE(ro+rd*t,rd)*1.5);\n\t\tt+=d;\n\t\tres=min(res,d/t+t*0.1);\n\t}\n\treturn res;\n}\nvec3 Sky(vec3 rd){//what sky??\n\treturn vec3(0.5+0.5*rd.y);\n}\nvec3 L;\n#define SE SuperShape3D\nvec3 Color(vec3 ro, vec3 rd, float t, float px, vec3 col, bool bFill, vec2 fragCoord){\n\tro+=rd*t;\n\tfloat d=SE(ro);\n\tvec2 e=vec2(px*t,0.0);\n\tvec3 dn=vec3(SE(ro-e.xyy),SE(ro-e.yxy),SE(ro-e.yyx));\n\tvec3 dp=vec3(SE(ro+e.xyy),SE(ro+e.yxy),SE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\tvec3 R=reflect(rd,N);\n\tvec3 lc=vec3(1.0,0.9,0.8),sc=sqrt(abs(sin(ro))),rc=Sky(R);\n\tfloat sh=clamp(shadao(ro,L,px*t,fragCoord)+0.2,0.0,1.0);\n\tsh=sh*(0.5+0.5*dot(N,L))*exp(-t*0.125);\n\tvec3 scol=sh*lc*(sc+rc*pow(max(0.0,dot(R,L)),4.0));\n\tif(bFill)d*=0.02;\n\tcol=mix(scol,col,clamp(d/(px*t),0.0,1.0));\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec4 Setup(float t){\n\tt=mod(t,8.0);\n\tif(t<1.0)return vec4(6.75,3.0,4.0,17.0);\n\tif(t<2.0)return vec4(12.0,15.0,20.0,3.0);\n\tif(t<3.0)return vec4(5.0,2.0,6.0,6.0);\n\tif(t<4.0)return vec4(4.0,1.0,1.0,1.0);\n\tif(t<5.0)return vec4(8.0,1.0,1.0,8.0);\n\tif(t<6.0)return vec4(2.0,2.0,2.0,2.0);\n\tif(t<7.0)return vec4(5.0,1.0,1.0,1.0);\n\treturn vec4(3.0,4.5,10.0,10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat px=1.0/size.y;\n\tL=normalize(vec3(0.4,0.8,-0.6));\n\tfloat tim=time;\n\t\n\tvec3 ro=vec3(cos(tim),0.4,sin(tim))*5.0;\n\tvec3 rd=lookat(vec3(-0.1)-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,3.0));\n\t\n\ttim*=0.7;\n\tS1=mix(Setup(tim-1.0),Setup(tim),smoothstep(0.0,1.0,fract(tim)*2.0));\n\ttim=tim*0.9+2.5;\n\tS2=mix(Setup(tim-1.0),Setup(tim),smoothstep(0.0,1.0,fract(tim)*2.0));\n\n\tfloat t=DDE(ro,rd)*rndStart(fragCoord),d=0.0,od=10.0;\n\tvec2 edge=vec2(-1.0);\n\tbool bGrab=false;\n\tvec3 col=Sky(rd);\n\tfor(int i=0;i<64;i++){\n\t\tt+=d;\n\t\td=DDE(ro+rd*t,rd);\n\t\tif(d>od){\n\t\t\tif(bGrab && od<px*t && edge.x<0.0){\n\t\t\t\tedge=vec2(edge.y,t-od);\n\t\t\t\tbGrab=false;\n\t\t\t}\n\t\t}else bGrab=true;\n\t\tod=d;\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tbool bFill=false;\n\td*=0.02;\n\tif(d<px*t && t<1000.0){\n\t\tif(edge.x>0.0)edge=edge.yx;\n\t\tedge=vec2(edge.y,t);\n\t\tbFill=true;\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tif(edge.y>0.0)col=Color(ro,rd,edge.y,px,col,bFill,fragCoord);\n\t\tedge=edge.yx;\n\t\tbFill=false;\n\t}\n\tfragColor = vec4(2.0*col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4llGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[131, 188, 275, 275, 367], [368, 368, 398, 398, 954], [955, 955, 988, 988, 1091], [1093, 1093, 1111, 1111, 1166], [1167, 1167, 1198, 1198, 1252], [1253, 1253, 1309, 1338, 1494], [1495, 1495, 1513, 1525, 1555], [1588, 1588, 1674, 1674, 2206], [2207, 2207, 2228, 2228, 2328], [2330, 2330, 2350, 2350, 2685], [2687, 2687, 2744, 2744, 3736]]}
{"id": "4llGz7", "name": "Fractal Flame", "author": "daeken", "description": "Realtime fractal flame experiment.", "tags": ["flame", "shaderforth"], "likes": 1, "viewed": 223, "date": "1420239605", "time_retrieved": "2024-06-20T18:15:42.963855", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\n: rand ( x:float -> float )\n\tx 123 * 17 + sin x 69 * 49 + sin *\n;\n\niResolution frag->position 3 * =p\n\n[\n\t[ [ 1 0 0 ] 1 3 / [ .2 time * 1.2 .7 ] [ .3 .12 .1 ] { } ] ( Linear )\n\t[ [ 0 1 0 ] 1 3 / [ .3 1.7 .4 ] [ .6 .5 time * .34 ] { sin } ] ( Sinusoidal )\n\t[ [ 0 0 1 ] 1 3 / [ .7 .4 .8 ] [ .17 time * .2 .2 ] { !length / } ] ( Spherical )\n] =>funcs\n\n10 =>runs\n\n[ 0 0 0 0 ] =hist\n\n{ ( i )\n\t[ time p .x + i float * rand time 17 * p .y + p .x + i float * rand ] =P\n\t[ 0 0 0 ] =C\n\n\t50 =>iters\n\t{\n\t\tP .x P length * rand abs funcs size * floor =ci\n\t\t\t[ funcs enumerate /{ ( [ i [ color weight xvars yvars block ] ] ) [ ci i ==\n\t\t\t\t{\n\t\t\t\t\t[\n\t\t\t\t\t\tP .x xvars .x * P .y xvars .y * + xvars .z +\n\t\t\t\t\t\tP .x yvars .x * P .y yvars .y * + yvars .z +\n\t\t\t\t\t] *block =P\n\t\t\t\t\tC color + 2 / =C\n\t\t\t\t}\n\t\t\t] } /flatten flatten ]\n\t\tcond\n\t\t{\n\t\t\t[ hist .x 1 + hist .yzw C + 2 / ] =hist\n\t\t} P p - length 1 hist .x 10 * / .001 + < when\n\t} iters times\n} runs times\n\nhist .yzw ->fragcolor\n*/\n\nfloat rand(float x) {\n\treturn sin(x * 123. + 17.) * sin(x * 69. + 49.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 P;\n\tvec3 C;\n\tvec4 hist;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) * 3.;\n\thist = vec4(0., 0., 0., 0.);\n\tfor(int temp_5 = 0; temp_5 < 10; ++temp_5) {\n\t\tP = vec2(rand((iTime + p.x) * float(temp_5)), rand((iTime * 17. + p.y + p.x) * float(temp_5)));\n\t\tC = vec3(0., 0., 0.);\n\t\tfor(int temp_6 = 0; temp_6 < 50; ++temp_6) {\n\t\t\tfloat ci = floor(abs(rand(P.x * length(P))) * 3.);\n\t\t\tif(ci == 0.) {\n\t\t\t\tP = vec2(P.x * vec3(.2 * iTime, 1.2, .7).x + P.y * vec3(.2 * iTime, 1.2, .7).y + vec3(.2 * iTime, 1.2, .7).z, P.x * .3 + P.y * .12 + .1);\n\t\t\t\tC = (C + vec3(1., 0., 0.)) / 2.;\n\t\t\t} else if(ci == 1.) {\n\t\t\t\tP = sin(vec2(P.x * .3 + P.y * 1.7 + .4, P.x * vec3(.6, .5 * iTime, .34).x + P.y * vec3(.6, .5 * iTime, .34).y + vec3(.6, .5 * iTime, .34).z));\n\t\t\t\tC = (C + vec3(0., 1., 0.)) / 2.;\n\t\t\t} else if(ci == 2.) {\n\t\t\t\tP = vec2(P.x * .7 + P.y * .4 + .8, P.x * vec3(.17 * iTime, .2, .2).x + P.y * vec3(.17 * iTime, .2, .2).y + vec3(.17 * iTime, .2, .2).z) / length(vec2(P.x * .7 + P.y * .4 + .8, P.x * vec3(.17 * iTime, .2, .2).x + P.y * vec3(.17 * iTime, .2, .2).y + vec3(.17 * iTime, .2, .2).z));\n\t\t\t\tC = (C + vec3(0., 0., 1.)) / 2.;\n\t\t\t}\n\t\t\tif(length(P - p) < (1. / (hist.x * 10.) + .001)) {\n\t\t\t\thist = vec4(hist.x + 1., (hist.yzw + C) / 2.);\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = vec4(hist.yzw, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4llGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1110, 1131, 1131, 1183], [1184, 1184, 1241, 1241, 2578]]}
{"id": "4ls3DH", "name": "Flaming Sphere", "author": "dr2", "description": "Just a great ball of fire.", "tags": ["fire", "landscape", "flight"], "likes": 3, "viewed": 925, "date": "1421742394", "time_retrieved": "2024-06-20T18:15:42.976638", "image_code": "// \"Flaming Sphere\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nmat3 flMat;\nvec3 qHit, qnHit, flPos, fBallPos, sunDir;\nfloat tCur, fBallRad;\nconst float dstFar = 180.;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n  vec3 col;\n  col = sbCol + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float sd, w, f;\n  col = SkyBg (rd);\n  sd = max (dot (rd, sunDir), 0.);\n  rd.y = abs (rd.y);\n  ro.x += 0.5 * tCur;\n  p = 0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz);\n  w = 0.8;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += w * Noisefv2 (p);\n    w *= 0.5;\n    p *= 2.;\n  }\n  col += 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.35 * t) * sin (0.12 * t) * cos (0.1 * t) +\n     26. * sin (0.032 * t), 1. + 3. * sin (0.21 * t) * sin (1. + 0.23 * t),\n     10. * t);\n}\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q, t, ta, v;\n  float wAmp, pRough, ht;\n  wAmp = 2.;\n  pRough = 1.;\n  q = p * 0.1;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    ht += (v.x + v.y) * wAmp;\n    q *= 1.5 * qRot;\n    wAmp *= 0.25;\n    pRough = 0.6 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) {\n    h = - b - sqrt (d);\n    qHit = ro + h * rd;\n    qnHit = (qHit - p) / s;\n  }\n  return h;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fr, f;\n  p = ro + dHit * rd - fBallPos;\n  dp = (fBallRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 4. * p;   q.y -= 5. * tCur;\n    f = Fbm3 (q);\n    q = 7. * p;   q.y -= 9. * tCur;\n    f += Fbm3 (q);\n    s = length (p);\n    fr = max (1. - 0.9 * s / fBallRad, 0.);\n    g += max (0.15 * fr * (f - 0.55), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 flmCol, col, vn;\n  float dstHit, dstGrnd, dstFbHit, fIntens, f;\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  fIntens = (dstFbHit < dstFar) ? FBallLum (ro, rd, dstFbHit) : 0.;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = VaryNf (1.2 * ro, GrndNf (ro, dstHit), 1.);\n    col = (mix (vec3 (0.2, 0.4, 0.1), vec3 (0., 0.5, 0.),\n       clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.))) *\n       (0.1 + max (0., max (dot (vn, sunDir), 0.))) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n  } else col = SkyCol (ro, rd);\n  if (dstFbHit < dstFar) {\n    ro += rd * dstFbHit;\n    rd = reflect (rd, qnHit);\n    col = 0.9 * col + 0.08 + 0.25 * max (dot (qnHit, sunDir), 0.) * (1. +\n       4. * pow (max (0., dot (sunDir, rd)), 128.));\n  }\n  f = clamp (0.7 * fIntens, 0., 1.);\n  f *= f;\n  flmCol = 1.5 * (0.7 + 0.3 * Noiseff (20. * tCur)) *\n     mix (vec3 (1., 0.1, 0.1), vec3 (1., 1., 0.5), f * f);\n  col = mix (col, flmCol, min (1.2 * fIntens * fIntens, 1.));\n  if (dstFbHit < dstFar) {\n    dstGrnd = GrndRay (ro, rd);\n    col = mix (col, ((dstGrnd < dstFar) ? vec3 (0.1, 0.3, 0.1) :\n       SkyCol (ro, rd)), pow (1. - abs (dot (rd, qnHit)), 3.));\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float vy, dt;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi, 0.2 * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  flPos.y += 7.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd, col;\n  fBallRad = 3.;\n  sunDir = normalize (vec3 (1.));\n  fBallPos = TrackPath (tCur + 5. + 4. * sin (0.5 * tCur));\n  fBallPos.y += 9.;\n  FlyerPM (tCur);\n  ro = flPos;\n  ro.y += 2.;\n  rd = normalize (vec3 (uv, 3.)) * flMat;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ls3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 269, 293, 293, 343], [345, 345, 369, 369, 416], [418, 418, 442, 442, 681], [683, 683, 708, 708, 838], [840, 840, 865, 865, 1044], [1046, 1046, 1072, 1072, 1366], [1368, 1368, 1389, 1389, 1649], [1651, 1651, 1680, 1680, 1882], [1884, 1884, 1923, 1923, 2130], [2237, 2237, 2259, 2259, 2385], [2387, 2387, 2419, 2419, 2858], [2860, 2860, 2886, 2886, 3050], [3052, 3052, 3075, 3075, 3516], [3518, 3518, 3552, 3552, 4089], [4091, 4091, 4122, 4122, 4295], [4297, 4297, 4349, 4349, 4568], [4570, 4570, 4617, 4617, 5048], [5050, 5050, 5085, 5085, 6455], [6457, 6457, 6481, 6481, 7128], [7130, 7130, 7187, 7187, 7596]]}
{"id": "4ls3DN", "name": "AtanTex", "author": "zevanrosser", "description": "...", "tags": ["blackandwhite"], "likes": 0, "viewed": 147, "date": "1422164186", "time_retrieved": "2024-06-20T18:15:42.976638", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    \n    float lines = atan(uv.y - 0.5,uv.x - 0.1);\n    lines += atan(uv.y - 0.75,uv.x - 0.5);\n    lines += atan(uv.y + 0.8,uv.x - 0.5);\n    lines += atan(uv.x - 0.5,uv.y - 0.5);\n    lines += atan(uv.x - 0.8,uv.y - 0.6);\n    lines += atan(uv.y - 0.85, 1.0-uv.x - 0.2);\n    \n    lines /= 5.0;\n    \n    float allLines = cos((lines + iTime * 0.5));\n    \n    uv.y /= (iResolution.x)/iResolution.y;\t \n    \n    float circs = smoothstep(0.0, 0.5, length(uv - vec2(0.1, 0.25)));\n    circs += smoothstep(0.0, 0.2, distance(uv , vec2(0.8, 0.3)));\n    \n    float c = acos(distance(cos(circs * 1.5), allLines));\n    \n\tfragColor = vec4(c * 0.8,c * 0.9, c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ls3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 755]]}
{"id": "4lsGD7", "name": "Pigs attack", "author": "gaz", "description": "3d", "tags": ["raymarching"], "likes": 7, "viewed": 260, "date": "1422542377", "time_retrieved": "2024-06-20T18:15:42.977635", "image_code": "vec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat dePig(in vec3 p)\n{   \n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length(abs(p.zx) - vec2(0.4, 0.4))) * (1.0 - step(0.0, p.y));\n    p.y +=  -0.2 * smoothstep(0.15, 0.0, length(abs(p.zx - vec2(0.4,0.0)) - vec2(0.0, 0.4))) * step(0.0, p.y);    \n    p.z += -0.15 * smoothstep( 0.4, 0.3, length(p.yx)) * step(0.0, p.z);\n    p.z +=  0.15 * smoothstep( 0.1, 0.0, length(abs(p.yx) - vec2(0.0, 0.15))) * step(0.0, p.z);\n    p.z +=   0.1 * smoothstep( 0.1, 0.0, length(abs(p.yx - vec2(0.4,0.0)) - vec2(0.0, 0.3))) * step(0.0, p.z);\n    p.z +=  0.15 * smoothstep( 0.1, 0.0, length(p.yx - vec2(0.35,0.0))) * (1.0 - step(0.0, p.z));\n    return 0.6 * (length(p) - 1.0);\n}\n\nfloat map1(in vec3 p)\n{   \n    p.z -= iTime*2.0;\n    p.xy = rotate(p.xy, p.z * 0.1);\n    p.xy = rotate(p.xy, iTime * 0.2);\n    p.z = mod(p.z, 4.0) - 2.0;\n    p.xy = rotate(p.xy, iTime * 0.2);\n    p.xy = abs(p.xy) - vec2(2.0);\n    p.xy = rotate(p.xy, iTime * -0.5);\n    return dePig(p);\n}\n\nfloat map2(in vec3 p)\n{\n \treturn length(p - vec3(0.0, 0.0, -50.0)) - 20.0;\n}\n\nfloat map(in vec3 p)\n{\n    return min(map1(p), map2(p));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i <256; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, cos(iTime * 0.05)*0.3);\n    p.zx = rotate(p.zx, sin(iTime * 0.1)*0.2);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.0,0.0,0.2)*(1.0+p.y);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        float dep = exp(-0.001 * pos.z * pos.z);\n        if (map1(pos) < map2(pos))\n        {\n            col = vec3(0.8, 0.5, 0.5) * dif * dep;\n        } else {\n            col = vec3(1.0, 0.9, 0.2) * dif * dif * dif;\n        }\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 87], [89, 89, 113, 113, 750], [752, 752, 775, 775, 1039], [1041, 1041, 1064, 1064, 1117], [1119, 1119, 1141, 1141, 1177], [1179, 1179, 1207, 1207, 1375], [1377, 1377, 1414, 1414, 1708], [1710, 1710, 1737, 1737, 1848], [1850, 1850, 1907, 1907, 2619]]}
{"id": "4lsGWM", "name": "Fizzer's tree 2", "author": "rcread", "description": "Fizzer's tree 2", "tags": ["2d"], "likes": 2, "viewed": 108, "date": "1422474118", "time_retrieved": "2024-06-20T18:15:42.979629", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tplaying with fizzer's crazy tree -- https://www.shadertoy.com/view/XlfGW7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3(fragCoord.xy,0.) / iResolution.y;\n    float m = mod( iTime * 10., 400. );\n    for( float i = 0. ; i < 400. ; ++i ) {\n        if ( i > m ) break;\n        p = reflect( p, p.yxz ) * 1.01;\n    } \n\tfragColor=vec4( 1. - p.y * p.y, 1. - p.x * p.x, 1. - p.z * p.z, 0 );\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 207, 264, 264, 543]]}
{"id": "4lX3W7", "name": "psychedelic tunnel", "author": "StanRee", "description": "Another play on IQ's tunnel", "tags": ["tunnel"], "likes": 2, "viewed": 604, "date": "1422332286", "time_retrieved": "2024-06-20T18:15:43.388016", "image_code": "\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\n\nvec3 Hue(float a){\nvec3 K = vec3(3,2,1)/3.;\nreturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);\n}\n\n\n#define Time (iTime * .06) \n\nvec3 HSVtoRGB(vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    \n    \n    // modified distance metric. Usually distance = (xÂ² + yÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:\n    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    float exp = 1.0;\n    float crayStationsCoef = 1.01; \n    p.x +=  sin(pow(Time,.5))*crayStationsCoef*2.0;\n   //p.y +=  cos(Time)*crayStationsCoef*10.0;\n    float a = atan(p.y,p.x) + Time * sin(Time)*.002 + iMouse.x * .0001;\n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(Time)*crayStationsCoef;\n    a += pow(r,.50); \n    \n       \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2( 0.5/r + 0.5*Time + iMouse.y,                    a/3.1416 );\n\n    r -= sin(Time)*.05;\n    // fecth color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    col = HSVtoRGB(vec3(col.r, 1.0, 1.0)); \n\t\n    col.r *= (sin(uv.x*5.0)*.7 + 1.0) * .9;\n    \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[203, 255, 273, 273, 367], [399, 399, 424, 424, 487], [490, 490, 547, 598, 1848]]}
{"id": "4lX3WN", "name": "[2TC 15] Monochrome Monopole Log", "author": "MichaelPohoreski", "description": "A monopole with the Log pattern", "tags": ["2d", "trigonometry"], "likes": 3, "viewed": 139, "date": "1421946373", "time_retrieved": "2024-06-20T18:15:43.563845", "image_code": "// [2TC 15] Monochrome Monopole Log\n// Copyleft {c} 2015 Michael Pohoreski\n// Chars: 136 // 1 Tweet! Will there be a 2016 [1TC] :-)\n\n/*\n// Original: 252 chars\n#define F(x) (log(x))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv     = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n    float angle  = atan(uv.y,uv.x);\n    float twist  = fract( 12.*angle + 0.5*iTime - 120.0*12.*F(length(uv)));\n    float color  = float(twist > 0.5);\n    fragColor = vec4( color, color, color, 1.0 );\n}\n*/\n\n// Minified\n// Hard-Coded log\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = 2.*w/iResolution.xy - 1.;\n    f = vec4( fract( atan(p.y,p.x) + .5*iTime - 1440.*log(length(p)) ) > .5 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[504, 534, 575, 575, 695]]}
{"id": "4lXGD7", "name": "[2TC 15] Invaders 277c", "author": "iapafoto", "description": "cga invaders", "tags": ["2tweets", "invaders", "asciiart", "2tc15", "codegolf"], "likes": 47, "viewed": 2076, "date": "1422373616", "time_retrieved": "2024-06-20T18:15:43.563845", "image_code": "\n\n\n                ////                    ////         \n                ////                    ////\n                    ////            ////         \n                    void            ////\n                mainImage(out vec4 o,vec2 d)\n                {vec2 t=vec2(iTime,2.),v=cos\n            (t);float   w=length(d=d    ////////\n            /*////*/    /iResolution    .y-.9-v)\n        ,k=25.;int y=int(mod(k/w+ k*t,9.));o=exp(-k*\n        abs(w+v.x))+cos(vec4 (y,d,1))*w*w*floor(mod(\n        (y>3    ?35552534e8:56869384.)/exp2(    vec4    \n        (y*7    +int(abs(mod(k*(atan(d.x,d.y    )+v)\n        ,13.    )-6.                    ))))    ,2.)\n        ) ;}    ////                    ////    ////\n                    ////////    ////////   \n                    ////////    ////////   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Created by sebastien durand - 2015 \n// License Creative Commons Attribution-NonCommercial\n// ShareAlike 3.0 Unported License\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 172, 255, 255, 662]]}
{"id": "4lXGDr", "name": "Test of \"bleeding\" color", "author": "predatiti", "description": "With this try show what is color \"bleeding\". Very bright object (wall and wardrobe) spread color in zone without direct light (shadow). Try to construct a better scene.", "tags": ["pathtracerwithdi"], "likes": 9, "viewed": 361, "date": "1420570681", "time_retrieved": "2024-06-20T18:15:46.133717", "image_code": "const float t = 16.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;\nfloat f0, f1,f2,f3;\nvec2 cw = vec2(-0.4,0.1);\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-2.0, -1.2, -2.0);//room\n   \tbox0.max = vec3( 2.0,  1.2,  2.0);\n    \n    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(sinr, h+0.1,cosr,    0.123);//albastru\n    \n    vec3 center = vec3(0.8,-0.8,-1.6); \n    cylinder[0].c = vec3( 0.55,0.0, 0.25) + center;\n    cylinder[0].r = 0.04;\n    cylinder[0].h = 0.4;\n    \n    cylinder[1].c = vec3( 0.55,0.0,-0.25) + center;\n    cylinder[1].r = 0.04;\n    cylinder[1].h = 0.4;\n    \n    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;\n    cylinder[2].r = 0.04;\n    cylinder[2].h = 0.4;\n    \n    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;\n    cylinder[3].r = 0.04;\n    cylinder[3].h = 0.4;\n\n   \tcenter = vec3(-1.55,-0.2, 0.5);\n    cub = vec3(0.0, 0.0, 0.0) + center;//corp dulap\n    lcub = vec3(0.4, 1.0, 0.8);    \n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n   \tcub = vec3(0.5, 0.0, +0.0) + center;//fanta\n   \tlcub = vec3(0.12, 0.98, 0.01);\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n   \tcub = vec3(0.02, 0.99, 0.0) + center;//plafon\n   \tlcub = vec3(0.43, 0.015, 0.85);\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;   \n    \n   \tcub = vec3( 0.380, 0.0, 0.385) + center;//oglinda dreapta\n   \tlcub = vec3(0.03, 0.77, 0.18);    \n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n   \tcub = vec3(0.385, 0.0, -0.385) + center;//oglinda stanga\n   \tlcub = vec3(0.03, 0.77, 0.18);\n   \tboxe[4].min = cub - lcub;\n   \tboxe[4].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[5].min = cub - lcub;\n   \tboxe[5].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, -0.06) + center;//maner stanga\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[6].min = cub - lcub;\n   \tboxe[6].max = cub + lcub;\n\n   /*\tcub = vec3(0.0, 0.0, 0.0) + center;//bbox\n   \tlcub = vec3(0.47, 1.2, 0.87);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;*/\n//dulap\n\n//birou\n\tcenter = vec3(0.8,-0.8,-1.6);\n   \tcub = vec3( 0.0, 0.4, 0.0) + center;//tablie\n   \tlcub = vec3(0.65, 0.015, 0.35);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;\n\n//scaun\n   \tcub = vec3(-0.0, 0.1, 0.5) + center;//tablie\n   \tlcub = vec3(0.25, 0.015, 0.25);\n   \tboxe[8].min = cub - lcub;\n   \tboxe[8].max = cub + lcub;\n\n   \tcub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[9].min = cub - lcub;\n   \tboxe[9].max = cub + lcub;\n\n   \tcub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[10].min = cub - lcub;\n   \tboxe[10].max = cub + lcub;\n\n   \tcub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[11].min = cub - lcub;\n   \tboxe[11].max = cub + lcub;\n\n   \tcub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[12].min = cub - lcub;\n   \tboxe[12].max = cub + lcub;\n\n   \tcub = vec3(-0.0, 0.6,  0.74) + center;//spatar\n   \tlcub = vec3(0.25, 0.10, 0.01);\n   \tboxe[13].min = cub - lcub;\n   \tboxe[13].max = cub + lcub;\n    \n    cub = vec3(-0.4,-0.87,  1.9) ;//calorifer\n   \tlcub = vec3(0.55, 0.3, 0.06);\n   \tboxe[14].min = cub - lcub;\n   \tboxe[14].max = cub + lcub;\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \t/*float tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}\n   \ttSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\t*/\n    \n    \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    tcyl = iCylinder(ro, rd, cylinder[3]);\n\tif(tcyl<t) {t = tcyl; i = 13;}\n    \n\tvec2 tboxc = intersectCube(ro, rd, boxe[0]); \n    if(tboxc.x>0.0 && tboxc.x<tboxc.y && tboxc.x < t) {t = tboxc.x; i = 20;}\n    vec2 tboxf = intersectCube(ro, rd, boxe[1]); \n    //if(tboxf.x>0.0 && tboxf.x<tboxf.y && tboxf.x < t) {t = tboxf.x; i = 21;}\n    vec2 tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}\n    tbox = intersectCube(ro, rd, boxe[4]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}\n    tbox = intersectCube(ro, rd, boxe[5]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 25;}    \n    tbox = intersectCube(ro, rd, boxe[6]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 26;} \n\n    float t1 = 200000.0;\n    float t2 = 200000.0;  \n    if(tboxf.x>0.0 && tboxf.x<tboxf.y) {t1 = tboxf.y; t2=tboxf.x;}\n    if(t1>t && t2<t && i==20) {t=t1; i=21;}\n\n    tbox = intersectCube(ro, rd, boxe[7]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}\n    tbox = intersectCube(ro, rd, boxe[8]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}\n    tbox = intersectCube(ro, rd, boxe[9]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}\n    tbox = intersectCube(ro, rd, boxe[10]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}\n    tbox = intersectCube(ro, rd, boxe[11]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}\n    tbox = intersectCube(ro, rd, boxe[12]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}\n    tbox = intersectCube(ro, rd, boxe[13]); \n\tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}\n    \n    tbox = intersectCube(ro, rd, boxe[14]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(abs(normal.x)>0.0)\n        { \n            mcol.xyz = vec3(0.95,0.95,0.95);\n            mref = vec2(0.0,1.0);\n        } \n         else if(normal.y>0.0)\n        {\n            vec3 tcol = texture(iChannel1,1.0-(hit.xz-vec2(1.5,1.5))/3.5).xyz;\n            float s = tcol.y+0.1;//-d\n            s = pow(s,3.0)*0.75+0.01;\n            mref = vec2((s*0.5+0.1),pow(1.0-s,2.0));\n            mcol.xyz = vec3(0.9);//tcol+0.4;\n        } \n        else if(abs(normal.z)>0.0)\n        {\n            mcol.xyz = vec3(0.95,0.15,0.19);\n            mref = vec2(0.0,1.0);\n            \n            if(normal.z<0.0)\n\t\t\t{\n            \t//cw = vec2(-0.4,0.1);\n            \tif(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+cw)) ||\n               \t\tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+cw)))\n               \t\tmcol = vec4(vec3(1.1),2.0);\n\t\t\t}\n        }\n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==13) {normal = normalforCylinder(hit, cylinder[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==22) {normal = normalForCube(hit, boxe[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==23) {normal = normalForCube(hit, boxe[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==24) {normal = normalForCube(hit, boxe[4]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==25) {normal = normalForCube(hit, boxe[5]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==26) {normal = normalForCube(hit, boxe[6]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==27) {normal = normalForCube(hit, boxe[7]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.8,0.8);}\n        else if(id==28) {normal = normalForCube(hit, boxe[8]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==29) {normal = normalForCube(hit, boxe[9]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==30) {normal = normalForCube(hit, boxe[10]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==31) {normal = normalForCube(hit, boxe[11]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==32) {normal = normalForCube(hit, boxe[12]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==33) {normal = normalForCube(hit, boxe[13]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==34) {normal = normalForCube(hit, boxe[14]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.05,3.8);}\n        \n        if(id>19 && id<23)//material for dulap\n        {\n            vec2 uv = hit.yz;\n            uv = abs(normal.y) > 0.0 ? hit.zx : uv;\n            uv = abs(normal.z) > 0.0 ? hit.yx : uv; \n            mcol.xyz = texture(iChannel1,1.0-(uv - vec2(1.5,-1.0))/vec2(5.5,0.5)).xyz - vec3(0.35,0.2,0.2);\n            mref = vec2(0.0,0.2);// transparent, glossines\n            mcol.xyz = vec3(0.1,0.99,0.1);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id>26 && id<34)//masa scaun\n        {\n            mcol.xyz = vec3(0.9);\n            mref = vec2(0.0,0.7);// transparent, glossines\n            //if(id==27) mcol.xyz = vec3(0.9,0.9,0.9);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id==34)//calorifer\n        {\n            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);\n            mref = vec2(0.0,0.0);\n        }\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n   //vec3 toLight = (lightf-hit);\n   //float sqdist = dot(toLight,toLight);\n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);// sqrt(sqdist);\n      float sh = 1000.0;//distance(lightf,hit);\n      intersectscene(hit + normal * 0.0001, L, sh, id, false);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        //rnd.x = 1.0/6.0 * ( float(i) + rnd.x );\n        col *= mcol.xyz;\n        if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*2.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            //if(tm==1) color += col * 1.5;\n            break;\n        }\n\t\ttm = -1;\n        if(rnd.x>abs(mref.x))//diffuse\n        {\n        \trd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \ttm = 0;   \n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0);\n           // color += col * 0.1;\n            \n            bool isLight = false;\n         \t//vec3 rnd3 = vec3(rand2(),rand2().x) *2.0 -1.0;\n            rnd = rand2()*2.0-1.0;\n            //cw = vec2(-0.4,0.1);\n         \tvec3 lightf = vec3(cw,2.2) + vec3(rnd.x*0.65,rnd.y * 0.6,0.0);\n         \tvec3 dl = directLight(hit, normal, lightf, vec3(0.9,0.9,0.9), isLight);\n            float nd = max(0.0,dot(lightf,vec3(0.0,0.0,1.0)))+max(0.0,dot(lightf,normal));\n         \tcolor += col * dl*5.0 *nd;\n         \tif(isLight) break;\n        }       \n        else \n        {\n            vec3 nrd = reflect(rd,normal); tm = 1;//reflect\n       \t\t/*if(mref.x<0.0)//refract\n            {\n                //if(id==30)\n                    //if(dot(rd,normal)>0.0) normal = -normal;\n            \tvec3 ior=vec3(1.0,1.52,1.0/1.12); tm = 2;\n           \t \tvec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n           \t \tvec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            \tif(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               \t\tnrd=refr;\n            }*/\n            rd = cosPowDir(nrd, mref.y*1.0);\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4lXGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[337, 530, 543, 631, 807], [809, 809, 872, 978, 1299], [1301, 1301, 1342, 1374, 1662], [1664, 1664, 1717, 1717, 2021], [2023, 2023, 2063, 2063, 2463], [2465, 2465, 2521, 2521, 2949], [2953, 2953, 2995, 2995, 3062], [3065, 3065, 3119, 3119, 3629], [3631, 3631, 3683, 3683, 3836], [3838, 3838, 3856, 3856, 7374], [7376, 7376, 7452, 7452, 10108], [10110, 10110, 10235, 10235, 14973], [14975, 14975, 15052, 15052, 15606], [15608, 15608, 15641, 15641, 18154], [18156, 18156, 18213, 18213, 19520]]}
{"id": "4tf3W7", "name": "Fizzer's tree", "author": "rcread", "description": "fizzer's tree", "tags": ["2d"], "likes": 1, "viewed": 114, "date": "1422334000", "time_retrieved": "2024-06-20T18:15:46.139924", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\tplaying with fizzer's crazy tree -- https://www.shadertoy.com/view/XlfGW7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 p = vec3(fragCoord,1.) / iResolution.y;\n    float m = mod( iTime * 4., 80. );\n    for( float i = 0. ; i < 80. ; ++i ) {\n        if ( i > m ) break;\n        p = reflect( p, p.yxz ) * 1.1;\n    } \n\tfragColor=vec4( 1. - p.y * p.y, 1. - p.x * p.x, 1. - p.z * p.z, 0 );\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tf3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 207, 264, 264, 536]]}
{"id": "4tf3WH", "name": "Crash Crystal 1", "author": "janneasdf", "description": "Crystal from Crash Bandicoot games", "tags": ["3d", "raytracing"], "likes": 2, "viewed": 1454, "date": "1422724737", "time_retrieved": "2024-06-20T18:15:47.818664", "image_code": "// Shader parameters\nfloat crystalScale = 0.1;\n\n// Material types\nconst int OBJECT_NONE = 0;\nconst int OBJECT_CRYSTAL = 1;\nconst int OBJECT_ICE = 2;\n\n// Helper variables and functions\nconst float INF = 1e10;\nbool debug = false;\nconst float PI = 3.14159265359;\n\nfloat perlin(vec2 coords, int octaves, float gain, float freq, float amplitude)\n{\n    float p = 0.0;\n    const int max_octaves = 20;\n    for (int i = 0; i < max_octaves; ++i)\n    {\n        if (i >= octaves)\n            break;\n        p += texture(iChannel0, vec2(coords.x * freq, coords.y * freq)).r * amplitude;\n        amplitude *= gain;\n        freq *= 1.0 / gain;\n    }\n    return p;   \n}\n\n// Shader initialization\nvec3 crystal[24 * 3];\nvec3 cv[14];\nvoid initCrystalGeometry()\n{\n    cv[0] = vec3(0.401617, 0.465089, -0.401617);\n\tcv[1] = vec3(-0.401617, 0.465089, 0.401617);\n\tcv[2] = vec3(1.000000, 5.081155, -0.999999);\n\tcv[3] = vec3(0.999999, 5.081155, 1.000001);\n\tcv[4] = vec3(-1.000000, 5.081155, 1.000000);\n\tcv[5] = vec3(-1.000000, 5.081155, -1.000000);\n\tcv[6] = vec3(0.401617, 0.465089, 0.401617);\n\tcv[7] = vec3(-0.401617, 0.465089, -0.401618);\n\tcv[8] = vec3(0.000000, -0.11153, -0.000000);\n\tcv[9] = vec3(0.000000, 6.290121, -1.166347);\n\tcv[10] = vec3(1.163836, 6.290121, 0.000001);\n\tcv[11] = vec3(-0.000000, 6.290121, 1.166347);\n\tcv[12] = vec3(-1.163836, 6.290121, 0.000000);\n\tcv[13] = vec3(-0.000000, 8.061562, 0.000000);\n    \n    crystal[0] = cv[10]; crystal[1] = cv[11]; crystal[2] = cv[3]; \n    crystal[3] = cv[10]; crystal[4] = cv[2]; crystal[5] = cv[9]; \n    crystal[6] = cv[9]; crystal[7] = cv[5]; crystal[8] = cv[12]; \n    crystal[9] = cv[11]; crystal[10] = cv[12]; crystal[11] = cv[4]; \n    crystal[12] = cv[5]; crystal[13] = cv[7]; crystal[14] = cv[12]; \n    crystal[15] = cv[11]; crystal[16] = cv[6]; crystal[17] = cv[3]; \n    crystal[18] = cv[10]; crystal[19] = cv[3]; crystal[20] = cv[6]; \n    crystal[21] = cv[2]; crystal[22] = cv[10]; crystal[23] = cv[0]; \n    crystal[24] = cv[2]; crystal[25] = cv[0]; crystal[26] = cv[9]; \n    crystal[27] = cv[9]; crystal[28] = cv[7]; crystal[29] = cv[5]; \n    crystal[30] = cv[1]; crystal[31] = cv[7]; crystal[32] = cv[8]; \n    crystal[33] = cv[6]; crystal[34] = cv[1]; crystal[35] = cv[8]; \n    crystal[36] = cv[7]; crystal[37] = cv[0]; crystal[38] = cv[8]; \n    crystal[39] = cv[0]; crystal[40] = cv[6]; crystal[41] = cv[8]; \n    crystal[42] = cv[12]; crystal[43] = cv[11]; crystal[44] = cv[13]; \n    crystal[45] = cv[11]; crystal[46] = cv[10]; crystal[47] = cv[13]; \n    crystal[48] = cv[9]; crystal[49] = cv[12]; crystal[50] = cv[13]; \n    crystal[51] = cv[10]; crystal[52] = cv[9]; crystal[53] = cv[13]; \n    crystal[54] = cv[7]; crystal[55] = cv[1]; crystal[56] = cv[12]; \n    crystal[57] = cv[12]; crystal[58] = cv[1]; crystal[59] = cv[4]; \n    crystal[60] = cv[11]; crystal[61] = cv[4]; crystal[62] = cv[1]; \n    crystal[63] = cv[1]; crystal[64] = cv[6]; crystal[65] = cv[11]; \n    crystal[66] = cv[0]; crystal[67] = cv[10]; crystal[68] = cv[6]; \n    crystal[69] = cv[0]; crystal[70] = cv[7]; crystal[71] = cv[9];\n    \n    for (int i = 0; i < 24; ++i)\n    {\n        crystal[i*3] = crystalScale * crystal[i*3];\n        crystal[i*3+1] = crystalScale * crystal[i*3+1];\n        crystal[i*3+2] = crystalScale * crystal[i*3+2];\n    }\n}\n\nstruct RayHit\n{\n\tfloat t;\n    vec3 rayDir;\n    vec3 n;\n    vec2 uv;\n    float mirror;\t// mirroring factor\n    int material;\n};\n    \nstruct TriangleHit\n{\n\tfloat t;\n    vec2 uv;\n    vec3 n;\n};\n\n// (Slightly modified) GLSL ray-triangle intersection code \n// from http://undernones.blogspot.fi/2010/12/gpu-ray-tracing-with-glsl.html\nTriangleHit intersectTriangle(vec3 rayPos, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2)\n{\n    TriangleHit hit;\n    vec3 u, v, n; // triangle vectors\n    vec3 w0, w;  // ray vectors\n    float r, a, b; // params to calc ray-plane intersect\n\n    // get triangle edge vectors and plane normal\n    u = v1 - v0;\n    v = v2 - v0;\n    n = cross(u, v);\n\n    w0 = rayPos - v0;\n    a = -dot(n, w0);\n    b = dot(n, rayDir);\n    if (abs(b) < 1e-5)\n    {\n        // ray is parallel to triangle plane, and thus can never intersect.\n        hit.t = INF;\n        return hit;\n    }\n\n    // get intersect point of ray with triangle plane\n    r = a / b;\n    if (r < 0.0)\n    {\n        hit.t = INF;\n        return hit; // ray goes away from triangle.\n    }\n\n    vec3 I = rayPos + r * rayDir;\n    float uu, uv, vv, wu, wv, D;\n    uu = dot(u, u);\n    uv = dot(u, v);\n    vv = dot(v, v);\n    w = I - v0;\n    wu = dot(w, u);\n    wv = dot(w, v);\n    D = uv * uv - uu * vv;\n\n    // get and test parametric coords\n    float s, t;\n    s = (uv * wv - vv * wu) / D;\n    if (s < 0.0 || s > 1.0)\n    {\n        hit.t = INF;\n        return hit;\n    }\n    t = (uv * wu - uu * wv) / D;\n    if (t < 0.0 || (s + t) > 1.0)\n    {\n        hit.t = INF;\n        return hit;\n    }\n\n    hit.uv = vec2(s, t);\n    hit.n = n;\n    hit.t = (r > 1e-5) ? r : INF;\n    return hit;\n}\n\nTriangleHit intersectPlane(vec3 rayPos, vec3 rayDir, vec3 planeNormal, vec3 planePoint)\n{\n    TriangleHit hit;\n    float nl = dot(planeNormal, rayDir);\n    if (abs(nl) < 0.001)\n        hit.t = INF;\n    else\n        hit.t = dot(planePoint - rayPos, planeNormal) / nl;\n    return hit;\n}\n\n// Shader specific functions\nRayHit traceRay(vec3 rayPos, vec3 rayDir)\n{\n    RayHit hit;\n    hit.rayDir = rayDir;\n    hit.mirror = 0.0;\n    TriangleHit triHit;\n    hit.material = OBJECT_NONE;\n    float tMin = INF;\n    float t;\n    \n    // Trace the ice\n    vec3 planeNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 planePoint = vec3(0.0, 0.0, 0.0);\t// any point on the plane\n    triHit = intersectPlane(rayPos, rayDir, planeNormal, planePoint);\n    vec3 p = rayPos + triHit.t * rayDir;\n    if (triHit.t >= 0.0 && triHit.t < tMin && abs(p.x) < 0.8 && abs(p.z) < 0.8)\n    {\n    \ttMin = triHit.t;\n        hit.uv = (rayPos + triHit.t * rayDir).xz; // todo: account for plane_n != 0,1,0\n        hit.n = planeNormal;\n        hit.material = OBJECT_ICE;\n        hit.mirror = 0.5;\n    }\n    \n    // Trace crystal triangles\n    for (int i = 0; i < 24; ++i)\n    {\n        triHit = intersectTriangle(rayPos, rayDir, crystal[i*3], crystal[i*3+1], crystal[i*3+2]);\n        if (triHit.t < tMin)\n        {\n        \ttMin = triHit.t;\n            hit.uv = triHit.uv;\n            hit.n = triHit.n;\n            hit.mirror = 0.0;\n            hit.material = OBJECT_CRYSTAL;\n        }\n    }\n    hit.n = normalize(hit.n);\n    hit.t = tMin;\n    return hit;\n}\n\nfloat uvDistanceFromEdge(vec2 uv)\n{\n\treturn min(uv.x, min(uv.y, 1.0 - uv.x - uv.y));\n}\n\nvec3 shadeCrystal(RayHit hit)\n{\n    vec3 c = vec3(0.5, 0.1, 0.3) * 1.25;\n    float nl = max(dot(hit.n, -hit.rayDir), 0.0);\n    c = nl * c;\n    \n    return c;\n}\n\nvec3 shadeIce(RayHit hit)\n{\n    vec3 c;\n\tvec3 blue = vec3(0.2, 0.4, 0.86) * 1.85;\n    \n    // Create the procedural texture\n    c = blue;\n    float angle = PI / 6.0;\n    vec2 coords = hit.uv;\n    coords.x = cos(angle) * coords.x - sin(angle) * coords.y;\n    coords.y = sin(angle) * coords.x + cos(angle) * coords.y;\n    coords = vec2(5.0 * coords.x, 1.4 * coords.y);\n    float p = perlin(coords, 6, 0.5, 1.0 / 256.0, 0.5);\n    p += perlin(coords, 10, 0.5, 1.0 / 256.0, 0.5);\n    p *= 0.5;\n    c *= p;\n    c *= 2.5;\n    c += 0.2;\n    float nl = max(dot(hit.n, -hit.rayDir), 0.0);\n    c = nl * c;\n    \n    return c;\n}\n\nvec3 shadeMaterial(RayHit hit)\n{\n    vec3 shade;\n    if (hit.material == OBJECT_NONE)\n    {\n    \tshade = vec3(0.0, 0.0, 0.0);\n    }\n    else if (hit.material == OBJECT_CRYSTAL)\n    {\n    \tshade = shadeCrystal(hit); \t   \n    }\n    else if (hit.material == OBJECT_ICE)\n    {\n        shade = shadeIce(hit);\n    }\n    return shade;\n}\n\nfloat distPointRay(vec3 p, vec3 rayPos, vec3 rayDir)\n{\n    return length(cross(rayDir, p - rayPos));\n}\n\nvec3 getColor(vec3 rayPos, vec3 rayDir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 origRayPos = rayPos;\n    vec3 origRayDir = rayDir;\n    RayHit hit = traceRay(rayPos, rayDir);\n    float mirror = hit.mirror;\n    vec3 shade = shadeMaterial(hit);\n    color += shade;\n    if (hit.material == OBJECT_ICE)\n    {\n        rayPos = rayPos + hit.t * rayDir;\n        rayPos += 0.001 * hit.n;\n        rayDir = reflect(rayDir, hit.n);\n        hit = traceRay(rayPos, rayDir);\n        shade = shadeMaterial(hit);\n        color *= 1.0;\n        color += 0.8 * shade;\n    }\n    // Glow\n    float glow = 0.0;\n    float d;\n    float a = 100.0;\n    float b = 10.0;\n    float c = 10.0;\n    float g;\n    for (int i = 0; i < 14; ++i)\n    {\n        d = distPointRay(crystalScale * cv[i], origRayPos, origRayDir);\n        g = 1.0 / (a*d*d + b*d + c);\n        glow += g;\n    }\n    color += glow * vec3(0.5, 0.1, 0.3);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    uv -= .5;\n    uv.x *= aspect;\n    \n    float time = iTime;\n    float camDistance = 1.2;\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) camDistance = 1.5;\n    float camSpeed = 0.4;\n    vec3 camDir = normalize(vec3(sin(time * camSpeed), -0.3, cos(time * camSpeed)));\n    vec3 camTarget = vec3(0.0, 0.4, 0.0);\n    vec3 camPos = camTarget - camDir * camDistance;\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    \n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    initCrystalGeometry();\n    \n    vec3 c;\n    c = getColor(rayPos, rayDir);\n    \n    if (debug)\t// Debug activated during getColor\n    {\n        if (fract(iTime * 4.0) < 0.5)\n        \tc = vec3(0.0);\n        else\n        \tc = vec3(1.0);\n    }\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tf3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[150, 261, 342, 342, 653], [655, 715, 743, 743, 3260], [3454, 3591, 3675, 3675, 4914], [4916, 4916, 5005, 5005, 5200], [5202, 5231, 5274, 5274, 6436], [6438, 6438, 6473, 6473, 6524], [6526, 6526, 6557, 6557, 6685], [6687, 6687, 6714, 6714, 7302], [7304, 7304, 7336, 7336, 7633], [7635, 7635, 7689, 7689, 7737], [7739, 7739, 7780, 7780, 8661], [8664, 8664, 8721, 8721, 9705]]}
{"id": "4tfGD4", "name": "[2TC 15] Rotating Spiral", "author": "MichaelPohoreski", "description": "Rotating spiral in WebGL from StackOverflow converted to ShaderToy\nCleaned up, minified, and optimized!", "tags": ["procedural", "2d"], "likes": 7, "viewed": 548, "date": "1421916124", "time_retrieved": "2024-06-20T18:15:48.194472", "image_code": "// [2TC 15] Rotating Spiral // Characters: 175\n// http://stackoverflow.com/questions/4638317/how-to-implement-this-rotating-spiral-in-webgl\n// Converted to ShaderToy by Michael Pohoreski 2015\n// Cleaned up and slightly optimized, additional tips by yakoudbz\n\n// For fun/better precision replace log() with a different function\n// that has less discontinuity when 0.0 < length(uv) < 0.1\n// i.e.\n#define F(x) (log(x))\n//#define F(x) (x <= 0.1 ? 10.*x : log(x))\n\n// Other fun functions:\n//#define F(x) 0.5*x\n//#define F(x) (x)\n//#define F(x) pow(x,1.414213562373095)\n//#define F(x) pow(x,2.0)\n//#define F(x) pow(x,10.0)\n//#define F(x) pow(x,42.0) // Yup 42 :-)\n\n// Angles are: 15, 30, 120 degrees\n// To see how this is built ...\n//    float angle  = degrees(atan(uv.y,uv.x));\n//    float twist  = angle;\n//    float twist  = mod( angle, 30.0);\n//    float twist  = mod( angle + 30.0*iTime, 30.0);\n//    float twist  = mod( angle + 30.0*iTime - 120.0*(length(uv)), 30.0);\n//    float twist  = mod( angle + 30.0*iTime - 120.0*F(length(uv)), 30.0);\n//    float color  = float(twist > 15.0);\n//\n// If we use a normalized Tau angle, we can factor out the 30 degrees; these are equivalent:\n//    const float PI = 3.14159265358979323846264;\n//    float angle  = atan(uv.y,uv.x) * 6./PI; // convert Radians to NormalizedTau\n//    float twist = fract( angle );\n//    float twist = fract( angle + iTime );\n//    float twist = fract( angle + iTime - 4.0*length(uv));\n//    float twist = fract( angle + iTime - 4.0*F(length(uv)));\n//    float color  = float(twist > 0.5);\n//\n// Cleaned up original code:\n//    vec2  uv     = 2.0*fragCoord.xy/iResolution.xy - 1.0;\n//    float angle  = degrees(atan(uv.y,uv.x));\n//    float twist  = mod( angle + 30.0*iTime - 120.0*F(length(uv)), 30.0);\n//    float color  = float(twist > 15.0);\n//    fragColor = vec4( color, color, color, 1.0 );\n//\n// Note: yakoudbz provided this further optimized version for the case of:\n//    #define F(x) 0.5*x\n//    void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n//        vec2  p = 2.*fragCoord.xy/iResolution.xy-1.;\n//        float d = length(p);\n//        fragColor = vec4(vec3(sin(9.*(atan(p.y,p.x)-d+iTime))*smoothstep(.0,.1,d)+.5),1.);\n//    }\n//\n// Minified:\n//   p    = uv coordinates\n//   6/PI = 1.90985931710274\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = 2.*w/iResolution.xy-1.;\n    f = vec4(vec3(float(fract(atan(p.y,p.x)*1.909859 + iTime - 4.*F(length(p))) > 0.5)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[659, 2290, 2331, 2331, 2464]]}
{"id": "4tfGD8", "name": "underwater love", "author": "bergi", "description": "Humans tend to like watching these things in the winter sometimes.\nDedicated to Katta :D", "tags": ["raymarching", "fractal", "kaliset", "duckball", "findingnemo"], "likes": 16, "viewed": 2786, "date": "1421280553", "time_retrieved": "2024-06-20T18:15:49.176353", "image_code": "/*  No there is no actual love going on,\n    except the love for numbers.\n\n    Another nice island in the absdot world\n    https://www.shadertoy.com/view/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n    Liked the feeling of the scene, so here it is (aGPL3).\n    Does the usual ray marching, while using the surface normal\n    to shade the pixels regardless of a hit or not.\n    Together with the right fog this makes all the \n    low precission almost realtime rendering glitches\n    fit the holiday atmosphere perfectly well.\n\n    Path generation is the tricky part here.\n    Anyone? \n\n    bergi \n*/\n\n// PATH 1 and 2 are two short predefined paths \n// they are near to a spot where i really would like to take my girlfriend once..\n// 3 is 'through the whole thing' - unchecked and unbounded\n// and noise and artefacts and all but some really cool parts in between\n// trust me! already at 8458 seconds ;)\n// it's helpful to reduce NUM_ITER then because many parts are impossible to\n// raytrace adequately for higher iterations\n// especially these blue dots are quite frequent at places (just had them at ~8730)\n// they appear more frequent with higher iterations and make a good star texture otherwise \n// but here they are impossible objects with very high distance although just next to the camera..\n// amazing..\n#define PATH 1\t\t\t\t// 1-3\n#define NUM_ITER 32\t\t\t// very depended value\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 50\n#define PRECISSION 0.2\n#define FOG_DIST 0.1\n// 3 coordinates to navigate through the sets\n// be careful! this is probably where arthur dent lost fenchurch.\n#define MAGIC_PARAM vec3(-.5, -.4, -1.5)\n\n// shader-local global animation time\n#define sec (iTime / 10.)\n\n// kali set\n// position range depending on parameters\n// but usually at least +/- 0.01 to 2.0 or even (even much) larger\n// check the camera path's in main(), it's tiny!\nfloat duckball_s(in vec3 p) \n{\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) / mag + MAGIC_PARAM;\n\t}\n\treturn mag;\n}\n\n\n// ---- canonical shader magic ----\n\n// well, what is the set?\n// divide inside from outside\nfloat scene_d(in vec3 p)\n{\n\t// numbers might look a bit off\n\t// but work for the renderer below\n\treturn duckball_s(p)*0.01-0.004;\n}\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 scene_color(in vec3 p)\n{\n\tvec3 ambcol = vec3(0.9,0.5,0.1);\n    \t// lighting\n\tfloat dull = max(0., dot(vec3(1.), scene_n(p)));\n\treturn ambcol * (0.3+0.7*dull);\n}\n\nvec3 sky_color(in vec3 dir)\n{\n\tvec3 c1 = vec3(0.3,0.4,0.7),\n\t\t c2 = vec3(0.2,0.6,0.9),\n\t\t c3 = vec3(0.0,0.3,0.5);\n    \t// some fade across y [-1,1]\n\treturn mix(mix(c1, c2, smoothstep(-1., .5, dir.y)),\n\t\t\t\tc3, smoothstep(.5, .1, dir.y));\n}\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n#if PATH == 3\n        // increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n#endif\n\n\t//\tif (d < 0.001)\n\t//\t\tbreak;\n\n\t\tt += d * PRECISSION;\n\t}\n\t\n\treturn mix(scene_color(p), sky_color(dir), t/FOG_DIST);\n}\n\n\n\n\n// ---------- helper --------\n\n// cubic interpolation from a to b using the respective derivatives ad and bd\nvec3 spline_d(float t, in vec3 a, in vec3 ad, in vec3 b, in vec3 bd)\n{\n    float tq2 = t * t,\n          tq3 = tq2 * t,\n          tr1 = 2. * tq3 - 3. * tq2 + 1.,\n          tr2 = tq3 - 2.*tq2 + t;\n    return tr1 * a + tr2 * ad + (tq3-tq2) * bd + (1. - tr1) * b;\n}\n\n// attempt to smoothly connect 4 points\nvec3 spline(float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return spline_d(t, a, normalize(c-a), d, normalize(d-b));\n}\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= float(iResolution.x) / float(iResolution.y);\n    \n\t// ray direction (cheap sphere section)\n\tvec3 dir = normalize(vec3(uv, 1.5));\n\n\t// position & look-at\n#if PATH == 1\n\tvec3 pos = vec3(\n\t\t\t2.48   + 0.01*cos(sec*2.),\n        \t-0.56  + 0.07*sin(sec-.05),// + 0.02*sin(sec*2.+2.),\n        \t-1.5   + 0.1*sin(sec)\n    \t\t);\n    \n\tdir.xz = rotate(dir.xz, sec * 0.3);\n\tdir.xy = rotate(dir.xy, 1.);\n    \n#elif PATH == 2\n    // 4 predefined points\n    vec3 p_0 = vec3(2.47  , -0.56, -1.62);\n    vec3 p_1 = vec3(2.474 , -0.56, -1.6);\n    vec3 p_2 = vec3(2.49 ,  -0.55, -1.5);\n    vec3 p_3 = vec3(2.473 , -0.51, -1.38);\n\n    float t = .5 + .5 * sin(sec);\n    vec3 pos = spline(t, p_0, p_1, p_2, p_3);\n\n    dir.xy = rotate(dir.xy, sec);\n    dir.xz = rotate(dir.xz, sec*0.7);\n\n#else \n    // PATH == 3\n\n    vec3 pos = vec3(1., 1. + sin(sec/21.), sin(sec/20.));\n    dir.xy = rotate(dir.xy, sec*0.7 + sin(sec*0.41));\n    dir.xz = rotate(dir.xz, sec*0.6);\n\n#endif\n    \n    // run\n\tvec3 col = traceRay(pos, dir);\n  \n   \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "agpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1705, 1875, 1905, 1905, 2028], [2068, 2124, 2150, 2219, 2255], [2257, 2257, 2282, 2282, 2483], [2485, 2485, 2514, 2514, 2650], [2652, 2652, 2681, 2681, 2890], [2892, 2892, 2933, 2933, 3285], [3321, 3399, 3469, 3469, 3660], [3662, 3702, 3768, 3768, 3832], [3834, 3834, 3867, 3867, 3956], [3960, 3960, 4017, 4017, 5113]]}
{"id": "4tfGRS", "name": "DumbTest", "author": "jplorandi", "description": "Just a test", "tags": ["test"], "likes": 0, "viewed": 1031, "date": "1422722123", "time_retrieved": "2024-06-20T18:15:49.176353", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 147]]}
{"id": "4tfGWn", "name": "Planet Orbits 2", "author": "TheJimJames40", "description": "A simulation of planet orbits.\nclick and drag to change the orbits.\nit is even slower than the first one (https://www.shadertoy.com/view/lllGR7).", "tags": ["simulation", "planet", "orbit"], "likes": 2, "viewed": 278, "date": "1420470338", "time_retrieved": "2024-06-20T18:15:49.182442", "image_code": "#define Iterations 256\n#define Speed 10.0\n#define FPS 60.0\n#define Planets 6\n//#define StarMovement\n\nstruct Particle {\n\tvec2  pos;\n    vec2  vel;\n    float mass;\n};\n\nconst float delta = 1.0/(FPS/Speed);\n\nParticle particles[Planets];\n    \nfloat grav(Particle p1, Particle p2){\n\tvec2 d = p1.pos-p2.pos;\n    return p1.mass * p2.mass / (d.x*d.x+d.y*d.y);\n}\n\nParticle updateParticle(Particle p){\n    vec2 acc = vec2(0.);\n    for(int i = 0; i < Planets; i++){\n    \tParticle po = particles[i];\n    \tacc += (po.pos - p.pos) * grav(p,po);\n    }\n    p.vel += acc / p.mass * delta;\n    p.pos += p.vel * delta;\n    return p;\n}\n\nvec3 hash3(const float n) {\n\treturn fract(sin(n)*vec3(36.5453123,43.1459123,11234.3490423));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //TODO: change uvs\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    uv *= 150.0;\n    vec2 muv = (2.0*iMouse.xy-iResolution.xy) / iResolution.x;\n    muv *= 150.0;\n    \n    vec2 muv2 = (2.0*abs(iMouse.zw)-iResolution.xy) / iResolution.x;\n    muv2 *= 150.0;\n    \n\n    if(dot(iMouse.xy,iMouse.xy) < 10.){\n        muv2 = vec2(20.0,20.0);\n        muv = muv2 + vec2(0.0,30.0);\n    }\n    \n    \n    float time = mod(iTime*Speed,delta*float(Iterations));\n    float timen    = floor((iTime*Speed)/(delta*float(Iterations)));\n\n    //maybe not\n    for(int i = 0; i < Planets; i++){\n        particles[i] = Particle(vec2(float(i*150/Planets),0.) , vec2(0.,10.*sin(hash3(timen+float(i))*6.28)), 1. + 100./exp(float(i+1)));\n    }\n    particles[1].pos = muv2;\n    particles[1].vel = (muv-muv2)/4.;\n    \n    vec3  color = vec3(0.);\n    float n     = 0.0;\n    for(int i = 0; i < Iterations; i++){\n    \tfor(int i = 0; i < Planets; i++){\n            #ifndef StarMovement\n            \tif(i != 0)\n            #endif\n            particles[i] = updateParticle(particles[i]);\n            \n            vec2 toUV = particles[i].pos - uv;\n            if(dot(toUV,toUV) < particles[i].mass*(0.1+pow(n/time,n))) {\n                color = (hash3(float(i+15124)));\n            }\n    \t}\n        \n        n += delta;\n        if(n > time) break;\n    }\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[77, 238, 275, 275, 352], [354, 354, 390, 390, 614], [616, 616, 643, 643, 710], [712, 712, 769, 792, 2143]]}
{"id": "4tfGWr", "name": "render a star shape", "author": "stebi", "description": "render a star shape", "tags": ["2d", "star", "shape"], "likes": 11, "viewed": 1996, "date": "1420622838", "time_retrieved": "2024-06-20T18:15:49.576469", "image_code": "// Parameters to play with:\nconst float segments = 5.0;\nconst float indent = 0.08;\nconst float softness = 0.6;\n\n// constants\nconst float pi = 3.141592654;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    // vec2 q = p - vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    vec2 q = p - vec2(0.5, 0.5);\n    q *= normalize(iResolution).xy; // maintain aspect ratio\n\n    // Rotation\n    float startAngle = iTime * 0.7;\n\n/*    mat4 RotationMatrix = mat4( cos( startAngle ), -sin( startAngle ), 0.0, 0.0,\n\t\t\t    sin( startAngle ),  cos( startAngle ), 0.0, 0.0,\n\t\t\t             0.0,           0.0, 1.0, 0.0,\n\t\t\t\t     0.0,           0.0, 0.0, 1.0 );    \n    q = (RotationMatrix * vec4(q, 0.0, 1.0)).xy;*/\n\n    mat2 RotationMatrix = mat2( \n        cos( startAngle ), -sin( startAngle ),\n\t\tsin( startAngle ),  cos( startAngle )\n    );\n    q = RotationMatrix * q;\n    \n    float distance = length(q);\n    float progress = (sin(iTime) + 1.0) / 2.0;\n    \n    vec4 col;\n    col = texture( iChannel0, q).xyzw;\n\n    \n    float angle = (atan(q.y, q.x) + pi) / (2.0 * pi); // 0-1\n    \n    float segment = angle * segments;\n    \n    \n    float segmentI = floor(segment);\n    float segmentF = fract(segment);\n        \n    angle = (segmentI + 0.5) / segments;\n    if (segmentF > 0.5) {\n\t\tcol *= vec4(1.0, .9, 0.6, 1.0);\n        angle -= indent;\n    } else\n    {\n\t\tcol *= vec4(1.0, 0.5, 0.5, 1.0);\n        angle += indent;\n    }\n    angle *= 2.0 * pi;\n\n\tvec2 outline;\n\toutline.y = sin(angle);\n    outline.x = cos(angle);\n\n\t// Distance Point/Line (Hessische Normalform)\n\tdistance = abs(dot(outline, q));\n    \n    col *= smoothstep(progress, progress + softness * progress, distance * 6.0);\n\n    // vec4 starcol = texture( iChannel1, (RotationMatrix * vec4(q, 0.0, 1.0)).xy).xyzw; \n    vec4 starcol = texture( iChannel1, (RotationMatrix * q).xy).xyzw; \n    starcol = mix(starcol, vec4(2.0, 2.0, 1.0, 1.0), 0.5);\n    col = mix(starcol, col, col.w);\n    fragColor = vec4((col));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[112, 156, 213, 213, 2019]]}
{"id": "4tl3W8", "name": "[2TC 15]2 Tweets Challenge", "author": "nimitz", "description": "Take up the two tweets challenge, just label your shaders with [2TC 15] at the beginning, the only rule is that the shader must be 280 chars or less.", "tags": ["2d", "challenge", "short", "compo", "tweet"], "likes": 57, "viewed": 2968, "date": "1421682422", "time_retrieved": "2024-06-20T18:15:49.812782", "image_code": "// 2 Tweets Challenge by nimitz 2015 (twitter: @stormoid)\n// https://www.shadertoy.com/view/4tl3W8\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\nThe rules:\n\t-Label your shaders with [2TC 15]\n\t-280 Chars or less (as counted by shadertoy)\n\t-Submissions end Feb 2 2015 (2 weeks)\n\t-You can use all the shadertoy uniforms (textures, audio, input, time, etc..)\n\t-You can use macros as much as you want\n \t-You can have as many entries as you like\n  \t-Don't expect any sort of large prize\n*/\nvoid mainImage( out vec4 f, in vec2 w ){\n    vec4 p = vec4(w,0.,1.)/iResolution.y - vec4(.9,.5,0,0), c=p-p;\n\tfloat t=iTime,r=length(p.xy+=sin(t+sin(t*.8))*.4),a=atan(p.y,p.x);\n\tfor (float i = 0.;i<60.;i++)\n        c = c*.98 + (sin(i+vec4(5,3,2,1))*.5+.5)*smoothstep(.99, 1., sin(log(r+i*.05)-t-i+sin(a +=t*.01)));\n    f = c*r;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[236, 578, 618, 618, 906]]}
{"id": "4tl3WN", "name": "It's raining again", "author": "digorydoo", "description": "Drip drip drip", "tags": ["fake", "water", "rain", "drip"], "likes": 26, "viewed": 903, "date": "1422136600", "time_retrieved": "2024-06-20T18:15:49.812782", "image_code": "#define NUM_DRIPS 20\n\nfloat Seed;\n\nvoid srand (float t)\n{\n    Seed = 0.5 + (sin (t*59.0) + sin (t*73.0) + sin (t*97.0))/6.0;\n}\n    \nfloat rand()\n{\n    Seed = 0.25 + 0.5*Seed + 0.25*sin (12345.0 * Seed);\n    return Seed;\n}\n\nvec2 dripPos (float fTime, out float fAge)\n{\n    float t = floor (fTime*0.1);\n    srand (t);\n    fAge = fTime*0.1 - t;\n    return vec2 (rand(), rand());\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vRel = fragCoord.xy / iResolution.xy;\n\n    float t = iTime;\n    float fStep = 123.456;\n    float fHeight = 0.0;\n    \n    for (int i = 0; i < NUM_DRIPS; i++)\n    {\n        float fAge;\n        vec2 vRnd = dripPos (t, fAge);\n\n        // float fDx = vRel.x - vRnd.x;\n        // float fDy = vRel.y - vRnd.y;\n        // float fD2 = fDx*fDx + fDy*fDy;\n        // float fD = sqrt (fD2);\n        \n        // the above, simpler:\n        vec2 vD = vec2 (vRel - vRnd);\n        float fD = sqrt (dot (vD, vD));\n\n        float fDa = 10.0 * (fD - fAge + 0.6);\n\n        fHeight += (1.0 - fAge) \n            * max (0.0, 1.0 - (fDa*fDa))\n            * sin (fD*150.0 - fAge*80.0);\n        \n        t += fStep;\n    }\n\n    vRel.y -= sign (fHeight) * fHeight*fHeight;\n    vec4 vTex = texture (iChannel0, vRel);\n\n    if (fHeight < 0.0)\n    {\n        float p = -fHeight*0.8;\n        float q = 1.0 - p;\n        vTex.b = p + q*vTex.b;\n        p = -fHeight*0.3;\n        q = 1.0 - p;\n        vTex.g = p + q*vTex.g;\n    }\n    \n    fragColor = vTex; \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[35, 35, 57, 57, 126], [132, 132, 146, 146, 221], [223, 223, 267, 267, 377], [379, 379, 436, 436, 1464]]}
{"id": "4tl3zn", "name": "[js4kintro 2014]Volume", "author": "FMS_Cat", "description": "for #js4kintro 2014\nhttp://jp.wgld.org/js4kintro/\nmengel sponge mutation", "tags": ["3d", "fractal"], "likes": 12, "viewed": 532, "date": "1420630652", "time_retrieved": "2024-06-20T18:15:49.812782", "image_code": "/*\na\tparam\nb\tparam\t\tbar\nc\titer\t\tcross\nd\tdist\t\tvec2\ne\nf\tdistFunc\tfloat\ng\tgetNorm\nh\t\t\t\tfractal theta\ni\nj\tcamC-camP\nk\nl\trayL\t\tclamp\nm\nn\no\np\trayP\t\tcamP\nq\nr\tres\t\t\treturn\ns\t\t\t\tcamS\nt\ttime\t\tvec3\nu\tuv\t\t\tcamU\nv\t0,1\t\t\treverb\nw\tray\t\t\tfractal power\nx\tno\ny\tno\nz\tno\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define t iTime\n#define r iResolution.xy\n#define L(i) clamp(i,0.,1.)\n#define F float\n#define D vec2\n#define T vec3\n#define R return\n#define v D(0,1)\n\nF B(D a,D b)\n{\n    D d=abs(a)-b;\n    R min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nF C(T a,D b)\n{\n    R min(B(a.xy,b),min(B(a.yz,b),B(a.zx,b)));\n}\n\nF f(T a)\n{\n    F b=0.;\n    for(F c=0.;c<7.;c+=1.)\n    {\n        F H=c*(t*.002);\n        a.xy=mat2(cos(H),-sin(H),sin(H),cos(H))*a.xy;\n        F W=pow(1.6,c*.7);\n        b=max(b,-C(mod(a+.15/W,.6/W)-.15/W,D(.1/W)));\n    }\n    R b;\n}\n\nT g(T a,F b)\n{\n\tD d=v*b;\n\tR normalize(T(\n\t\tf(a+d.yxx)-f(a-d.yxx),\n\t\tf(a+d.xyx)-f(a-d.xyx),\n\t\tf(a+d.xxy)-f(a-d.xxy)\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tD u=(fragCoord.xy*2.-r)/r.x;\n\tT P=T(sin(-t*.04),cos(t*.04),0.)*-.35+v.yyx*.3,\n\t\tj=normalize(v.yxx-P),\n\t\tS=cross(j,v.xyx),\n\t\tU=cross(S,j),\n\t\tw=normalize(S*u.x+U*u.y+j),\n        p=P;\n\t\n\tF d=0.,l=0.;\n    for(int i=0;i<99;i++){\n        d=f(p);\n        l+=d;\n        p=P+w*l;\n    }\n\t\n    d=pow(l*.9,2.);\n\tfragColor=vec4((dot(-w,g(p,1E-4))*max(1.-d*.2,0.)+L(d*.2))*((d+L((1.-dot(g(p,1E-4),g(p,1E-3)))*8.+.1)*pow(.7,mod(t,9.)))*T(.2,.3,.6)+T(.1))*(1.-pow(1E-7,t*.04))*(1.3-length(u)*.7),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 452, 466, 466, 532], [534, 534, 548, 548, 597], [599, 599, 609, 609, 830], [832, 832, 846, 846, 953], [955, 955, 1012, 1012, 1500]]}
{"id": "4tlGDM", "name": "Canyon Roller", "author": "dr2", "description": "Our brave flyers are back with new wings.", "tags": ["raymarching", "flight"], "likes": 18, "viewed": 848, "date": "1422483240", "time_retrieved": "2024-06-20T18:15:49.830980", "image_code": "// \"Canyon Roller\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nint idObj, idObjGrp;\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, qHit, qHitTransObj, sunDir;\nfloat fusLen, flameLen, tCur;\nconst float dstFar = 150.;\nconst int idCkp = 11, idFus = 12, idEng = 13, idWngI = 14, idWngO = 15,\n   idTlf = 16, idRfl = 17;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.1, 0.2, 0.5);\n  vec3 col;\n  col = sbCol + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 10. * tCur;\n    vec2 p = 0.02 * (rd.xz * (150. - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.3, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (1.), cloudFac);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t), 1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float u;\n  u = max (abs (p.x - TrackPath (p.y).x) - 2.5, 0.);\n  u *= u;\n  return SmoothMin ((0.2 + 0.003 * u) * u, 12., 1.) +\n     0.5 * Noisefv2 (0.6 * p) + 4. * Fbm2 (0.1 * p) - 3.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.3, 0.25, 0.25), gCol2 = vec3 (0.1, 0.1, 0.1),\n     gCol3 = vec3 (0.3, 0.3, 0.1), gCol4 = vec3 (0., 0.5, 0.);\n  vec3 col, wCol, bCol;\n  float cSpec;\n  wCol = mix (gCol1, gCol2, clamp (1.4 * (Noisefv2 (p.xy +\n     vec2 (0., 0.3 * sin (0.14 * p.z)) *\n     vec2 (2., 7.3)) + Noisefv2 (p.zy * vec2 (3., 6.3))) - 1., 0., 1.));\n  bCol = mix (gCol3, gCol4, clamp (0.7 * Noisefv2 (p.xz) - 0.3, 0., 1.));\n  col = mix (wCol, bCol, smoothstep (0.4, 0.7, n.y));\n  cSpec = clamp (0.3 - 0.1 * n.y, 0., 1.);\n  return vec4 (col, cSpec);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 2.;\n  for (int i = 0; i < 10; i++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, 20. * h / d);\n    d += 4.;\n    if (h < 0.01) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat FlameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, wr;\n  q = p;\n  q.x = abs (q.x);\n  q -= fusLen * vec3 (0.5, 0., -0.55);\n  q.z -= - 1.1 * flameLen;\n  wr = 0.5 * (q.z / flameLen - 1.);\n  d = PrCapsDf (q, 0.045 * (1. + 0.65 * wr) * fusLen, flameLen);\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = FlameDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  dHit = FlameDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  dHit = FlameDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.01 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlameCol (vec3 col)\n{\n  vec3 q = qHitTransObj;\n  float fFac = 0.3 + 0.7 * clamp (mod (3. * (q.z / flameLen + 1.) +\n     0.7 * Noisefv2 (10. * q.xy + tCur * vec2 (200., 210.)) +\n     170. * tCur, 1.), 0., 1.);\n  float c = clamp (0.5 * q.z / flameLen + 0.5, 0., 1.);\n  return fFac * vec3 (c, 0.4 * c * c * c, 0.4 * c * c) +\n     (1. - c) * col;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 pp, q;\n  float d, wr, ws;\n  q = p;\n  q.yz = Rot2D (q.yz, 0.07 * pi);\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.05, 0.),\n      0.11 * fusLen, 0.1 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idCkp;  qHit = q; }\n  q = p;\n  q -= fusLen * vec3 (0., 0., -0.12);\n  wr = -0.05 + q.z / fusLen;\n  q.xz *= 0.8;\n  d = PrCapsDf (q, (0.14 - 0.14 * wr * wr) * fusLen, fusLen);\n  if (d < dHit + 0.01) {\n    dHit = SmoothMin (dHit, d, 0.01);  idObj = idFus;  qHit = q;\n  }\n  pp = p;\n  pp.x = abs (pp.x);\n  q = pp - fusLen * vec3 (0.5, 0., -0.2);\n  ws = q.z / (0.4 * fusLen);\n  wr = ws - 0.1;\n  d = PrCylDf (q, (0.05 - 0.035 * ws * ws) * fusLen, 0.45 * fusLen);\n  d = min (d, PrCylDf (q, (0.09 - 0.05 * wr * wr) * fusLen, 0.35 * fusLen));\n  if (d < dHit) { dHit = d;  idObj = idEng;  qHit = q; }\n  q = pp - fusLen * vec3 (0.1, 0., -0.15);\n  q.xz = Rot2D (q.xz, 0.12 * pi);\n  wr = 1. - 0.6 * q.x / (0.4 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.25 * wr * fusLen, 0.02 * wr * fusLen, 0.4 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idWngI;  qHit = q; }\n  q = pp - fusLen * vec3 (0.6, 0., -0.37);\n  q.xy = Rot2D (q.xy, -0.1 * pi);\n  q -= fusLen * vec3 (0.07, 0.01, 0.);\n  q.xz = Rot2D (q.xz, 0.14 * pi);\n  wr = 1. - 0.8 * q.x / (0.2 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.06 * wr * fusLen, 0.005 * wr * fusLen, 0.2 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idWngO;  qHit = q; }\n  q = pp - fusLen * vec3 (0.03, 0., -0.85);\n  q.xy = Rot2D (q.xy, -0.24 * pi);\n  q -= fusLen * vec3 (0.2, 0.02, 0.);\n  wr = 1. - 0.5 * q.x / (0.17 * fusLen);\n  q.xz = Rot2D (q.xz, 0.1 * pi);\n  d = PrFlatCylDf (q.zyx, 0.1 * wr * fusLen, 0.007 * wr * fusLen, 0.17 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idTlf;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 gp;\n  float d, dHit, cSep;\n  dHit = dstFar;\n  idObjGrp = 1 * 256;\n  dHit = FlyerDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  idObjGrp = 2 * 256;\n  dHit = FlyerDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  idObjGrp = 3 * 256;\n  dHit = FlyerDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  dHit *= 0.8;\n  cSep = 10.;\n  gp.y = cSep * floor (p.z / cSep) + 0.5 * cSep;\n  gp.x = TrackPath (gp.y).x;\n  q = p;\n  q -= vec3 (TrackPath (q.z).x, GrndHt (gp), gp.y);\n  d = 0.7 * PrCapsDf (q.xzy, 0.4, 0.1);\n  if (d < dHit) { dHit = d;  idObj = 1;  qHit = p; }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float d, h, sh;\n  sh = 1.;\n  d = 0.02;\n  for (int i = 0; i < 40; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.02;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec4 FlyerCol (vec3 n)\n{\n  vec3 col;\n  float spec;\n  spec = 1.;\n  int ig = idObj / 256;\n  int id = idObj - 256 * ig;\n  vec3 qq = qHit / fusLen;\n  float br = 4. + 3.5 * cos (10. * tCur);\n  col = vec3 (0.7, 0.7, 1.);\n  if (qq.y > 0.) col *= 0.3;\n  else col *= 1.2;\n  if (id == idTlf) {\n    if (abs (qq.x) < 0.1)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qq.z + 0.05);\n    if (qq.z < - 0.05)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001, abs (qq.x) - 0.1);\n  }\n  if (id == idCkp && qq.z > 0.) col = vec3 (0.4, 0.2, 0.);\n  else if (id == idEng) {\n    if (qq.z > 0.36) col = vec3 (1., 0., 0.);\n    else if (qq.z > 0.33) {\n      col = vec3 (0.01);\n      spec = 0.;\n    }\n  } else if (id == idWngO && qq.x > 0.17 ||\n     id == idTlf && qq.x > 0.15 && qq.z < -0.03) col = vec3 (1., 0., 0.) * br;\n  else if (id == idFus && qq.z > 0.81) col = vec3 (0., 1., 0.) * br;\n  idObj = idRfl;\n  return vec4 (col, spec);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (1., 0.3, 0., 1.) *\n     (0.6 + 0.4 * sin (6. * tCur - 0.1 * qHit.z));\n  else col4 = FlyerCol (n);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstHit, dstGrnd, dstObj, dstFlame, f, bk, sh;\n  int idObjT;\n  bool isGrnd;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  dstFlame = TransObjRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (dstObj < dstFlame) dstFlame = dstFar;\n  isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    dstHit = dstObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (vn);\n    if (idObj == idRfl) col4.rgb = 0.5 * col4.rgb +\n       0.3 * SkyCol (ro, reflect (rd, vn));\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      isGrnd = true;\n    } else col = SkyCol (ro, rd);\n  }\n  if (isGrnd) {\n    vn = VaryNf (3.2 * ro, GrndNf (ro, dstHit), 1.5);\n    col4 = GrndCol (ro, vn);\n    sh = GrndSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  }\n  if (dstFlame < dstFar) col = FlameCol (col);\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, 0.8 * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 fpF, fpB, vel, acc, ort, cr, sr, va;\n  float tInterp, dt, vy, m1, m2, tDisc, s, vFly;\n  tInterp = 5.;\n  tDisc = floor ((t) / tInterp) * tInterp;\n  s = (t - tDisc) / tInterp;\n  vFly = 18.;\n  t *= vFly;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  if (vu == 0.) { m1 = 1.;  m2 = 25.; }\n  else { m1 = 0.2;  m2 = 15.; }\n  vel.y = vy;\n  ort = vec3 (- m1 * asin (vel.y / length (vel)),\n     atan (vel.z, vel.x) - 0.5 * pi, m2 * length (va) * sign (va.y));\n  if (vu > 0.) { ort.xz *= -1.;  ort.y += pi; }\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  flPos.y = (1. - s) * GrndHt (TrackPath (tDisc).xz) +\n     s * GrndHt (TrackPath (tDisc + tInterp).xz) + 7.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd, col;\n  float tGap, zmFac, vuPeriod, lookDir, dVu;\n  sunDir = normalize (vec3 (cos (0.031 * tCur), 1.5, sin (0.031 * tCur)));\n  fusLen = 1.;\n  flameLen = 0.25 * fusLen;\n  vuPeriod = 50.;\n  lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  dVu = smoothstep (0.8, 0.97, mod (tCur, vuPeriod) / vuPeriod);\n  tGap = 0.3;\n  tCur += tGap;\n  FlyerPM (tCur, 0.);  flyerPos[0] = flPos;  flyerMat[0] = flMat;\n  FlyerPM (tCur, 0.);  flyerPos[1] = flPos;  flyerMat[1] = flMat;\n  FlyerPM (tCur + 0.5 * tGap, 0.);  flyerPos[2] = flPos;  flyerMat[2] = flMat;\n  flyerPos[0].x += 1.2 * fusLen;\n  flyerPos[1].x -= 1.2 * fusLen;\n  FlyerPM (tCur + tGap * (1. + 1.5 * lookDir * (1. - 1.2 * dVu)), lookDir);\n  ro = flPos;\n  ro.y += 2.5 * sqrt (dVu) + 0.3;\n  zmFac = 3. + 1.1 * (lookDir + 1.);\n  rd = normalize (vec3 (uv, zmFac)) * flMat;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 268, 292, 292, 339], [341, 341, 366, 366, 545], [547, 547, 568, 568, 705], [707, 707, 736, 736, 938], [940, 940, 979, 979, 1186], [1188, 1188, 1233, 1233, 1331], [1333, 1333, 1390, 1390, 1473], [1475, 1475, 1505, 1505, 1579], [1581, 1581, 1624, 1624, 1697], [1699, 1699, 1741, 1741, 1792], [1794, 1794, 1853, 1853, 1957], [2215, 2215, 2237, 2237, 2362], [2364, 2364, 2396, 2396, 2916], [2918, 2918, 2944, 2944, 3103], [3105, 3105, 3128, 3128, 3316], [3318, 3318, 3352, 3352, 3889], [3891, 3891, 3922, 3922, 4095], [4097, 4097, 4128, 4128, 4679], [4681, 4681, 4719, 4719, 4956], [4958, 4958, 4994, 4994, 5289], [5291, 5291, 5318, 5318, 5532], [5534, 5534, 5572, 5572, 5752], [5754, 5754, 5780, 5780, 6103], [6105, 6105, 6141, 6141, 7862], [7864, 7864, 7886, 7886, 8465], [8467, 8467, 8500, 8500, 8676], [8678, 8678, 8699, 8699, 8922], [8924, 8924, 8961, 8961, 9172], [9174, 9174, 9198, 9198, 10095], [10097, 10097, 10119, 10119, 10278], [10280, 10280, 10315, 10315, 11838], [11840, 11840, 11874, 11874, 12918], [12920, 12920, 12977, 12977, 13983]]}
{"id": "4tlGDr", "name": "timefunc plotter", "author": "wonko_rt", "description": "a simple plotter for timefunctions with a grid and something like a frame", "tags": ["function", "plot", "timefunction"], "likes": 2, "viewed": 1592, "date": "1420997466", "time_retrieved": "2024-06-20T18:15:49.837577", "image_code": "// Created by wonko_rt/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// a simple plotter for timefunctions with a grid and something like a frame\n// maybe the maths suck, but it seems to work\n\nconst float PI2 = 1.5707963267948966192313216916398;\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 6.283185307179586476925286766559;\n\n\nfloat func(float x)\n{\n    const float t=4.;\n    float tm = abs(mod(iTime, t)-t/2.);\n    tm *= tm;\n    return sin(x*(1.+tm));\n}\n\nfloat falloff(float d, float mx)\n{\n    return min(mx,1./(d*d*d*d*10000000000.+.00001));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy *2. - 1.;\n    uv*=1.06;\n    \n    vec2 uvf = uv;\n    uvf.x *= TWOPI;\n\t\n    vec3 iy = vec3(0.);\n    \n    // grid\n    const int gx=4;\n    const int gy=4;\n    vec2 vgxy = vec2(1./float(gx), 1./float(gy));\n    for (int i=-gx; i<=gx; i++)\n    \tfor (int j=-gy; j<=gy; j++)\n        {\n            vec2 iuv = vec2(i, j) * vgxy;\n\n            float auxy = uv.x*uv.x*uv.y*uv.y*100.;\n            float gi = clamp(1.-auxy, .4, .9);\n            iy = max(iy, falloff(abs(iuv.x-uv.x), gi));\n            iy = max(iy, falloff(abs(iuv.y-uv.y), gi));\n        }\n\n    // func\n    vec3 f1col = vec3(.4, .6, .8);\n    float y = func(uvf.x);\n    float d = (y - uvf.y)/2.;\n    float f = falloff(d, 1.);\n    iy = vec3(mix(iy.x,f*f1col.x,f), mix(iy.y,f*f1col.y,f), mix(iy.z,f*f1col.z,f));\n    \n    // border\n    vec3 bcol = vec3(.2,.6,.2);\n    const float br1=.9;\n    const float bw=1.4;\n    float dd = abs(pow(log(abs(uv.x*br1))*log(abs(uv.y*br1)), .13)*1.6);\n    float b = clamp(0.,1.,bw-pow(dd,8.));\n    iy = max(iy, vec3(bcol*b));\n    \n    fragColor = vec4(vec3(iy),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[116, 401, 422, 422, 527], [529, 529, 563, 563, 618], [620, 620, 677, 677, 1764]]}
{"id": "4tlGWn", "name": "Reflection and shadow", "author": "Lio", "description": "Perhaps there is an error in the algorithm. Help fix ... :)", "tags": ["raymarching", "reflection", "shadow"], "likes": 1, "viewed": 239, "date": "1420784551", "time_retrieved": "2024-06-20T18:15:49.839571", "image_code": "//-----------------------------\n#define time iTime\n#define EPSILON .001\n//#define lightDir lightPos\nconst int MAX_ITER = 150;\nint colorIndex = 0;\nbool bReflection = true;\nbool bShadow = true;\nvec3 lightPos = vec3(-1.5, -7.8, 23.);\nvec3 camPos = vec3(0.0, -3.6, 17.9);\nvec3 camDir = vec3(0.0, 0.0, -1.0);\nvec3 camUp  = vec3(0.0, 1.0, 0.0);\nstruct mat\n{\n  float typeMat;        // Ñ‚Ð¸Ð¿ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð° \n  float koffReflecr;    // ÐºÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ\n  vec3 color;           // Ñ†Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\n     \n};\nmat material = mat(0.0, 1.0, vec3(1.));\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir, out float object);\n//-----------------------------\n// Ð’Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ðµ - Ð¿ÐµÑ€ÐµÑÑ‡ÐµÑ‚ Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹\n//--------------------------------------------------\nvec3 rotationCoord(vec3 n, float paramRotate)\n{\n vec3 result;\n //--------------------------------------------\n   float t = time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   if(paramRotate <= 0.1)\n   {\n\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0,  1.0,  0.0,\n                      0.0,  0.0,  1.0);   \n   }\n   else if(paramRotate <= 1.0)\n   {\n      rotate = mat3(  1.0,  0.0,  0.0,\n                      0.0, sc.y,-sc.x,\n                      0.0, sc.x, sc.y);\n   }\n   else if(paramRotate <= 2.0)\n   {\n       rotate = mat3(  1.0,  0.0,  0.0,\n                       0.0, sc.y,sc.x,\n                       0.0, -sc.x, sc.y);  \n   }\n   else if (paramRotate <= 3.0)\n   {\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n   }\n   else if (paramRotate <= 4.0)\n   {\n      rotate = mat3( sc.y,  0.0, sc.x,\n                     0.0,   1.0,  0.0,\n                    -sc.x,  0.0, sc.y);   \n   }   \n   else if (paramRotate <= 5.0)\n   {\n       rotate = mat3( sc.y,sc.x,  0.0,\n                     -sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }   \n   else if (paramRotate <= 6.0)\n   {\n       rotate = mat3( sc.y,-sc.x, 0.0,\n                      sc.x, sc.y, 0.0,\n                      0.0,  0.0,  1.0);  \n   }     \n   else\n   {\n   mat3 rotate_x = mat3(  1.0,  0.0,  0.0,\n                          0.0, sc.y,-sc.x,\n                          0.0, sc.x, sc.y);\n   mat3 rotate_y = mat3( sc.y,  0.0, -sc.x,\n                         0.0,   1.0,  0.0,\n                         sc.x,  0.0,  sc.y);\n   mat3 rotate_z = mat3( sc.y, sc.x,  0.0,\n                        -sc.x, sc.y,  0.0,\n                         0.0,  0.0,   1.0);\n   rotate = rotate_z * rotate_y * rotate_z;                \n   }\n  result = n * rotate;\n  return result;\n}\n//------------------------------------------\n//------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n\n//------------------------------------------\n//----------------------------------------------------Ð¨Ð°Ñ€\nfloat distsphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------Ð¢Ð¾Ñ€\nfloat disttorus(vec3 p, vec2 t)\n{\n   vec2 q = vec2(length(p.xz) - t.x, p.y);\n   return length(q) - t.y;\n}\n//------------------------------------------Ð¡ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð±Ð»Ð¾Ðº\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n//----------------------------------------------------ÐšÑƒÐ±\nfloat distbox(vec3 p, vec3 b)\n{\n   return length(max(abs(p) - b, 0.0));\n}\n//------------------------------------------Ð¦Ð²ÐµÑ‚ Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ð°\nvec3 getmaterial( in vec3 p,  in float mat)\n{\n  vec3 pos = p; \n  vec3 color = vec3(1.);\n \n if(mat == 0.0)\n    color = vec3(0.5);\n  else if (mat == 1.0)\n    color = vec3(0.0, 1.0, 0.17);\n  else if(mat == 2.0)\n      color =  vec3(1.0); \n  else if(mat == 3.0)\n    color =   vec3(floor(length(floor(mod(pos, 2.0)+0.5))-0.5)); \n  else if(mat == 4.0)\n     color = vec3(1.0, 0.84, 0.91);\n  else color = vec3(1., 1.0, 0.0);   \n return color; \n}\n//------------------------------------------\n//-------------------------------------------------\nvec3 getlighting(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n   float b = max(0.0, dot(normal, lightDir));\n   return b * color;\n}\n//-------------------------------------------------\n//-------------------------------------------------ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð¾ÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ñ Ð¿Ð¾ Ð¤Ð¾Ð½Ð³Ñƒ\nvec3 getlightingPhong(in vec3 pos, in vec3 normal, in vec3 lightDir, in vec3 color)\n{\n    \n    \n    vec3   l = normalize (lightDir-pos);   \n    vec3   v = normalize(camPos-pos);\n\n    vec3   n = normalize (normal);        \n    vec3   r = reflect ( -l, n ); \n    vec3 diff = color * max ( dot ( n, l ), 0.0 );\n    vec3 spec = vec3(0.92, 0.98, 1.0) * pow ( max ( dot ( l, r ), 0.0 ), 32.0 );\n    \n    return diff + spec;\n}\n//-------------------------------------------------Ð¢ÐµÐ½ÑŒ\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n   float sh = 1.0;\n   float t = mint;\n   float h = 0.0;\n   for (int i = 0; i < 10; i++) {\n      if(t > maxt)\n         continue;\n      h = renderFunction(ro+rd*t);\n      sh = min(sh, k*h/t);\n      t += h;\n   }\n   return sh;\n}\n//-------------------------------------------------ÐžÑÐ²ÐµÑ‰ÐµÐ½Ð¸Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²\nvec3 colorScene(in vec3 posOnRay, in vec3 normal, in vec3 lightDir, in float numMaterial)\n{\n   vec3 color = vec3(0.0);\n   vec3 materialColor = getmaterial(posOnRay, numMaterial); \n\n    color = getlightingPhong(posOnRay, normal, lightDir, materialColor); // ÐŸÐ¾ Ð¤Ð¾Ð½Ð³Ñƒ   \n   \n   return color;\n}\n//-------------------------------------------------\nvec3 reflectColor(in vec3 posOnRay, in vec3 rayDir)\n{\n  vec3 color = vec3(1.0);\n  vec3 result_color = vec3(1.0);\n  float object = 1.0;\n  vec3 normal = vec3(1.0);\n  float k_reflectivity = 1.0;\n  vec3 lightDir ;\n    \n      for (int i = 0; i < 5; i++) \n      {\n      lightDir = normalize(lightPos - posOnRay); //ÐÐ°Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ðº ÑÐ²ÐµÑ‚Ñƒ \n      float path =  render(posOnRay, rayDir, object);\n       // Ñ‚Ð¾Ñ‡ÐºÐ°, Ð² ÐºÐ¾Ñ‚Ð¾Ñ€ÑƒÑŽ Ð¿Ñ€Ð¸ÑˆÐ»Ð¸   \n       vec3 pos = posOnRay + rayDir * path;\n       if(path < 0.0) break;\n\n       color =  getmaterial( pos,  material.typeMat);\n       normal = normalize(getNormal(pos));\n//       color =  getlighting(pos, normal, lightDir, color);\n       color =  colorScene(pos, normal, lightDir,material.typeMat);\n\n    //   result_color *= k_reflectivity * color;\n \n         result_color = mix(result_color, color, k_reflectivity);\n\n         k_reflectivity *= material.koffReflecr;\n      if(bShadow) // Ð¢ÐµÐ½ÑŒ\n      {\n         float sh = softshadow(pos, lightDir, 0.2, 20.0, 7.0); \n         result_color *= sh;       \n      }            \n          \n       if (k_reflectivity < .1) break;\n      \n       // Ð¾Ñ‚Ñ€Ð°Ð·Ð¸Ð¼ Ð»ÑƒÑ‡ Ð¸ Ð½Ð°Ñ‡Ð½ÐµÐ¼ Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¹ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\n       rayDir = normalize(reflect(rayDir, normal));\n       posOnRay = pos + rayDir * EPSILON*2.;    \n\n    }\n  \n  return result_color;\n\n}\n\n//---------------------------------------------------\n\nfloat myObject(in vec3 p)\n{\n\n vec3 pos = p; \n\n float ballMy = 1., tor = 1.0, cube = 1.0, cube1 = 1.0;\n float plan = udRoundBox(pos+vec3(0.0,-4.0,2.2), vec3(15.0,0.01,15.0),0.0);\n \n pos.y -= -4.79;\n pos.z -= -2.0;\n ballMy = distsphere(pos, 2.);\n \n vec3 pos1 = rotationCoord(pos, 7.); \n\n tor = disttorus( pos1 ,vec2(3.8, 0.79)); \n\n cube = udRoundBox(pos + vec3(-0.4, 1.35, 8.37), vec3(10., 7.0, 0.5),0.0);\n// cube = min(cube,udRoundBox(pos + vec3(-7.5, -0.6, -6.0), vec3(0.5, 4.0, 5.0),0.0));\n vec3 offset = vec3(8.69, -3.73, -5.6); \n offset.y *= sin(time );   \n cube1 = udRoundBox(pos + offset, vec3(0.5, 4.0, 7.0),0.0);\n//--------\n\n     material.typeMat = 2.0;\n     material.koffReflecr = 1.0;\n float closest = ballMy;\n float sample1 = plan;\n if (sample1 < closest) \n { // Ð¿Ð¾Ð»\n      // Ð·Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼ ÐºÐ°Ðº Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐ¸Ð¹\n      closest = sample1; \n     material.typeMat = 3.0;\n     material.koffReflecr = 0.5;\n }\n sample1 = tor;\n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 1.0;\n   material.koffReflecr = 1.0; \n } \n sample1 = cube; \n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 4.0;\n   material.koffReflecr = 0.0;  \n }\n\n sample1 = cube1; \n if (sample1 < closest) \n {\n   closest = sample1;\n   material.typeMat = 7.;\n   material.koffReflecr = 0.8; \n }  \n//--------\n\n \nreturn closest;\n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n  float result;\n  vec3 pos1 = pos;\n\n    result = myObject(pos1);    \n  return result;\n}\n\n//-------------------------------------------------\n//-------------------------------------------------ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð½Ð¾Ñ€Ð¼Ð°Ð»Ð¸  \nvec3 getNormal(in vec3 p)\n{\n  const float e = 0.0001;\n  return\n    normalize\n    (\n      vec3\n      (\n        renderFunction(p+vec3(e,0.0,0.0)) - renderFunction(p+vec3(-e,0.0,0.0)),\n        renderFunction(p+vec3(0.0,e,0.0)) - renderFunction(p+vec3(0.0,-e,0.0)),\n        renderFunction(p+vec3(0.0,0.0,e)) - renderFunction(p+vec3(0.0,0.0,-e))\n      )\n    );\n}\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir, out float object)\n{ \n  float t = 0.0;\n\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n\n    object = renderFunction(posOnRay + t*rayDir); \n    t += object;\n    if (object < EPSILON*t) \n      { t = -t; break; } // ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ Ð¼ÐµÐ½ÑŒÑˆÐµ Ð¿Ð¾Ñ€Ð¾Ð³Ð¾Ð²Ð¾Ð³Ð¾ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ, Ð²Ñ‹Ñ…Ð¾Ð´Ð¸Ð¼\n    \n  }\n   return -t;\n\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  vec2 pos =  fragCoord.xy / iResolution.xy * 2. - 1.;\n  pos.x *= iResolution.x / iResolution.y;\n  pos = -pos;\n    \n  vec3 camSide  = cross(camDir, camUp);\n  vec3 rayDir   = normalize(camSide*pos.x + camUp*pos.y + camDir);\n\n  float object   = 1.;\n  vec3 color    = vec3(1.0);\n  vec3 backColor = vec3(0.5);\n  vec3 lightDir = normalize(lightPos);\n  vec3 normal = vec3(1.0);\n\n   vec3 result_color = vec3(1.);\n//------------------------------\n\n  vec3 posOnRay = camPos;\n     // Ð²ÐµÑ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð»ÑƒÑ‡Ð°\n  float k_reflectivity = 1.;\n  float path = 0.;\n  //--------------------------- \n\n  path =  render(posOnRay, rayDir, object);   \nif(abs(object) < 0.1)\n{\n   if(!bReflection)\n   {\n   lightDir = normalize(lightPos - posOnRay); //ÐÐ°Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ñ‚ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ðº ÑÐ²ÐµÑ‚Ñƒ \n \n       posOnRay = posOnRay + rayDir * path;\n\n       color =  getmaterial( posOnRay,  material.typeMat);\n      normal = normalize(getNormal(posOnRay));\n//      color =  colorScene(posOnRay, normal, lightDir, object.y); \n      color = getlighting(posOnRay, normal, lightDir, color);\n      if(bShadow)\n      {\n         float sh = softshadow(posOnRay, lightDir, 0.2, 20.0, 7.0); \n         color *= sh;       \n      }\n      result_color *=  color;\n      fragColor = vec4(result_color, 1.);    \n   } // Ð±ÐµÐ· Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ\n   else // Ñ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸ÐµÐ¼\n   {\n   result_color = reflectColor(posOnRay, rayDir);\n    fragColor = vec4(result_color, 1.); \n   }// Ñ Ð¾Ñ‚Ñ€Ð°Ð¶ÐµÐ½Ð¸ÐµÐ¼\n}\nelse // Ñ„Ð¾Ð½ \n{\n   fragColor = vec4(backColor, 1.); \n} \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[843, 1038, 1085, 1085, 2872], [3006, 3119, 3154, 3154, 3181], [3182, 3250, 3283, 3283, 3355], [3356, 3464, 3509, 3509, 3549], [3550, 3617, 3648, 3648, 3690], [3691, 3792, 3837, 3837, 4228], [4229, 4326, 4406, 4406, 4475], [4476, 4672, 4757, 4757, 5091], [5092, 5160, 5229, 5229, 5454], [5455, 5578, 5669, 5669, 5890], [5891, 5943, 5996, 5996, 7524], [7526, 7581, 7608, 7608, 8982], [8983, 9090, 9125, 9125, 9213], [9215, 9388, 9415, 9415, 9745], [9746, 9798, 9864, 9864, 10234], [10235, 10280, 10337, 10337, 12076]]}
{"id": "4tsGD4", "name": "3D shapes ", "author": "gaz", "description": "Solid of revolution. Pull 2D", "tags": ["raymarching", "de"], "likes": 7, "viewed": 372, "date": "1422107684", "time_retrieved": "2024-06-20T18:15:49.841565", "image_code": "vec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat shapeRad1(in vec3 p)\n{\n    float a = atan(p.z, p.x);\n    return 0.5 * ((sin(5.0 * a)) + 3.0);\n}\n\nfloat shapeRad2(in vec3 p)\n{\n    float a = atan(p.z, p.x);\n    return abs(sin(2.0 * a)) + 1.0;\n}\n\nfloat deQuad(in vec2 p, in float h)\n{\n     return max(abs(p.x), abs(p.y)) - h;\n}\n\nfloat deTri(in vec2 p, in float h)\n{\n     return abs(p.x) + abs(p.y) - h;\n}\n\nfloat deCircle(in vec2 p, in float r)\n{\n     return length(p) - r;\n}\n\nfloat deShape(in vec2 p)\n{\n    \n    return max(max(deTri(p, 1.0), -p.y*p.y+p.x-0.7), -p.x*p.x+ abs(p.y)-0.6);\n}\n\nfloat shape1(in vec3 p, vec2 q)  {return          deQuad(q, 1.0);}\nfloat shape2(in vec3 p, vec2 q)  {return     deTri(q, 1.0);}\nfloat shape3(in vec3 p, vec2 q)  {return        deCircle(q, 1.0);}\nfloat shape4(in vec3 p, vec2 q)  {return   deShape(q);}\nfloat shape5(in vec3 p, vec2 q)  {return    deQuad(q * vec2(shapeRad1(p), 1.0), 1.0);}\nfloat shape6(in vec3 p, vec2 q)  {return     deTri(q * vec2(shapeRad1(p), 1.0), 1.0);}\nfloat shape7(in vec3 p, vec2 q)  {return  deCircle(q * vec2(shapeRad1(p), 1.0), 1.0);}\nfloat shape8(in vec3 p, vec2 q)  {return   deShape(q * vec2(shapeRad1(p), 1.0));}\nfloat shape9(in vec3 p, vec2 q)  {return    deQuad(q * vec2(shapeRad2(p), 1.0), 1.0);}\nfloat shape10(in vec3 p, vec2 q) {return     deTri(q * vec2(shapeRad2(p), 1.0), 1.0);}\nfloat shape11(in vec3 p, vec2 q) {return  deCircle(q * vec2(shapeRad2(p), 1.0), 1.0);}\nfloat shape12(in vec3 p, vec2 q) {return   deShape(q * vec2(shapeRad2(p), 1.0));}\nfloat shape13(in vec3 p, vec2 q) {return  max(abs(p.y) - 1.0, deShape(p.xz));}\nfloat shape14(in vec3 p, vec2 q) {return  max(abs(p.y) - 1.0, deShape(p.xz * (abs(p.y) + 1.0)));}\n\nfloat map(in vec3 p)\n{    \n    p *= 0.35;\n\tvec2 q = vec2(length(p.xz), p.y);    \n    float t = mod(iTime * 0.8, 42.0);\n    if (t < 3.0)  return mix( shape1(p, q),  shape2(p, q), smoothstep( 1.0,  2.0, t));\n    if (t < 6.0)  return mix( shape2(p, q),  shape3(p, q), smoothstep( 4.0,  5.0, t));\n    if (t < 9.0)  return mix( shape3(p, q),  shape4(p, q), smoothstep( 7.0,  8.0, t));\n    if (t < 12.0) return mix( shape4(p, q),  shape5(p, q), smoothstep(10.0, 11.0, t));\n    if (t < 15.0) return mix( shape5(p, q),  shape6(p, q), smoothstep(13.0, 14.0, t));\n    if (t < 18.0) return mix( shape6(p, q),  shape7(p, q), smoothstep(16.0, 17.0, t));\n    if (t < 21.0) return mix( shape7(p, q),  shape8(p, q), smoothstep(19.0, 20.0, t));\n    if (t < 24.0) return mix( shape8(p, q),  shape9(p, q), smoothstep(22.0, 23.0, t));\n\tif (t < 27.0) return mix( shape9(p, q), shape10(p, q), smoothstep(25.0, 26.0, t));    \n\tif (t < 30.0) return mix(shape10(p, q), shape11(p, q), smoothstep(28.0, 29.0, t));    \n\tif (t < 33.0) return mix(shape11(p, q), shape12(p, q), smoothstep(31.0, 32.0, t));    \n\tif (t < 36.0) return mix(shape12(p, q), shape13(p, q), smoothstep(34.0, 35.0, t));\n\tif (t < 39.0) return mix(shape13(p, q), shape14(p, q), smoothstep(37.0, 38.0, t));\n\tif (t < 42.0) return mix(shape14(p, q),  shape1(p, q), smoothstep(40.0, 41.0, t));\n    return 1.0;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 256; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.5);\n    p.zx = rotate(p.zx, iTime * 0.7);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.1 + p.y * 0.15);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        col = vec3(0.9, 0.95, 0.8) * dif;\n    }\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 87], [89, 89, 117, 117, 190], [192, 192, 220, 220, 288], [290, 290, 327, 327, 370], [372, 372, 408, 408, 447], [449, 449, 488, 488, 517], [519, 519, 545, 545, 630], [632, 632, 666, 666, 698], [699, 699, 733, 733, 759], [760, 760, 794, 794, 826], [827, 827, 861, 861, 882], [883, 883, 917, 917, 969], [970, 970, 1004, 1004, 1056], [1057, 1057, 1091, 1091, 1143], [1144, 1144, 1178, 1178, 1225], [1226, 1226, 1260, 1260, 1312], [1313, 1313, 1347, 1347, 1399], [1400, 1400, 1434, 1434, 1486], [1487, 1487, 1521, 1521, 1568], [1569, 1569, 1603, 1603, 1647], [1648, 1648, 1682, 1682, 1745], [1747, 1747, 1769, 1769, 3095], [3097, 3097, 3125, 3125, 3293], [3295, 3295, 3332, 3332, 3627], [3629, 3629, 3656, 3656, 3748], [3750, 3750, 3807, 3807, 4352]]}
{"id": "4tsGDH", "name": "Solar distortion", "author": "tomkh", "description": "I was bored enough to try a simple hack to distance-field tracing to emulate sort of gravitational lensing effect (i.e. like here http://hubblesite.org/gallery/album/galaxy/cluster/pr2009025ap/). A quick and dirty implementation.", "tags": ["distancefield", "gravitylensing"], "likes": 13, "viewed": 546, "date": "1421719948", "time_retrieved": "2024-06-20T18:15:50.467488", "image_code": "// Gravitation lensing simulation using DF-tracing\n// by Tomkh '20.01.2015\n// http:/moonedit.com/tom\n\n#define ptcnt 12\nvec3 pt[ptcnt];\nfloat ptrad = 0.1;\nfloat tim;\n\nvoid setup_scene()\n{\n    float t0 = tim*.5;\n    for(int i=0; i<ptcnt; ++i) \n    {\n        float t = t0 + float(i)*1.7;\n        \n        // Simple animation of spheres:\n        pt[i].x = cos(t)*.5;\n        pt[i].y = sin(t*1.1)*.5;\n        \n        // Put 6 sphere in front (lens) and 6 in the back:\n        pt[i].z = ((i*2<ptcnt)?4.0:16.0) + cos(t*2.1);\n    }\n}\n\nvec4 df(vec3 p)\n{\n    float dmin = 1e32;\n    vec3 n = vec3(0,0,0);\n    for(int i=0; i<ptcnt; ++i) \n    {\n        vec3 dp = pt[i] - p;\n        float d = dot(dp,dp);\n        \n        // Here is the key to lensing effect, approx. gravity field:\n        n += dp/d;\n        \n        dmin = min(d, dmin);\n    }\n    return vec4(n,sqrt(dmin));\n}\n\nvec4 tex(vec3 p)\n{\n    float dmin = 1e32;\n    vec3 dpmin;\n    for(int i=0; i<ptcnt; ++i) \n    {\n        vec3 dp = pt[i] - p;\n        float d = dot(dp,dp);\n        if (d < dmin) \n        {\n            dmin = d;\n            dpmin = dp;\n        }\n    }\n    float d = sqrt(dmin);\n    return vec4(dpmin/d,d);\n}\n\nvec4 trace(vec3 p, vec3 n)\n{\n    float falloff = 1.0 - (1.0 - n.z)*16.0;\n    \n    // Lensing animation:\n    float sc = sin(tim*.1);\n    sc *= sc;\n    sc *= .008;\n    \n    // DF tracing with lens-effect here:\n    vec4 dn;\n    float lit = 0.0;\n    for(int k=0; k<64; ++k)\n    {\n        dn = df(p);\n        float d = dn.w;\n        float surf_dist = d - ptrad;\n        lit += 0.003/(d + 0.1);\n        \n        // Move half the distance only:\n        float f = surf_dist*.5;\n        p += n*f;\n        \n        // Modify ray direction by gravity field:\n        n = normalize(n + dn.xyz*f*sc);\n    }\n    \n    // Shading:\n    vec4 norm = tex(p);\n    float shade = max(0.0, 1.0 - (norm.w - ptrad)*256.0);\n    vec4 col = texture(iChannel1, norm.xy*0.1);\n    vec4 bkg = texture(iChannel1, n.xy*2.0)*falloff;\n    return vec4(vec3(lit,lit,lit*0.6) - vec3(0.0,col.x*col.x*0.5,col.x)*shade,1.0)\n         + vec4(bkg.xy,bkg.z*2.0,0.0)*0.2*(1.0-shade);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Hold mouse button to stop motion / review time:\n    tim = (iMouse.z > .5) ? iMouse.x * 20.0 / iResolution.x : iTime;\n    \n    setup_scene();\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    fragColor = trace(vec3(0,0,0), normalize(vec3(uv,1)));\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 166, 186, 186, 526], [528, 528, 545, 545, 865], [867, 867, 885, 885, 1172], [1174, 1174, 1202, 1202, 2110], [2112, 2112, 2169, 2224, 2442]]}
{"id": "4tsGW7", "name": "Black wave", "author": "danjinxiangsi", "description": "This simple shader is created by Xiao Wu. \nIt is inspired by Flower shader.\nEveryone is welcome to use/modified it.", "tags": ["2d", "curve", "blackwave"], "likes": 1, "viewed": 1195, "date": "1422506451", "time_retrieved": "2024-06-20T18:15:50.467488", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center=vec2(1024.0,768.0);\n    \n\tvec2 p = 5.0 * (fragCoord.xy-center) / iResolution.xy;\n\t\n\tfloat a =abs(atan(p.x,p.y));\n\tfloat r = length(p)*1.;\n\n\tfloat w = sin(3.1415927*iTime);\n\tfloat h = 0.5+0.5*cos(1.0*a-w*7.0+r*8.0);\nfragColor = vec4(h,h,h,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 319]]}
{"id": "4tX3DH", "name": "Harmonic Pendula", "author": "dcm", "description": "An array of pendula at various lengths such that their periods sync up in various harmonies.  ", "tags": ["raycasting", "pendulum"], "likes": 2, "viewed": 1160, "date": "1421362607", "time_retrieved": "2024-06-20T18:15:51.879999", "image_code": "// Original link: https://www.shadertoy.com/view/Xds3zN\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Modified by AranHase to implement Gooch shading from:\n// http://www.cs.northwestern.edu/~ago820/SIG98/abstract.html\n// Very simple technique to auto shade technical illustrations\n\n// modified by dcm to check out an array of pendula\n\nconst int num = 40;\nconst float pi = 3.14159;\nconst float tau = 2.0*3.14159;\nint sticks = 0;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 10.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,-.25, 0.0), 0.15 ), 46.9 ) );\n    \n    float numsq = float(num*num);\n    for(int i = 0; i < num; i+=1)\n    {\n        float j = float(i)+1.0;\n        float theta = pi*cos(j*iTime/10.0);\n        float r = 3.75-3.75*(j*j/numsq);\n            \n        float c = 24.0;\n        //float c = 1.0;\n        res = opU( res,\n              vec2( sdSphere( pos-vec3( j/2.0, \n                                       4.0 - r*cos(theta), \n                                       r*sin(theta)), \n                             0.25 ), c ) );\n        /*\n        if (sticks == 1)\n        {\n        res = opU( res, \n                  vec2( sdCapsule(pos,\n                  \tvec3(float(j)/2.0, 4.0, 0.0),\n                  \tvec3(float(j)/2.0, 4.0 - r*cos(theta), \n                                       r*sin(theta)), 0.01\n                  ), 1.0));\n        }\n\t\t*/\n    }\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = float(num);\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<500; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fragCoord )\n{ \n    // y = -m(x-0.5)^2 + 1.0\n    float xx = fragCoord.y/iResolution.y-0.5;\n    xx = -5.000*xx*xx + 1.0;\n    vec3 col = vec3(0.5*xx);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m >= 0.0 )\n    {\n        vec3 view_direction = -rd;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // Light above is easier for the brain to process\n        vec3 lig = normalize( vec3(100, 100, 100)-pos );\n        \n        \n        float b = 0.4;\n        float y = 0.4;\n        float alpha = 0.2;\n        float beta = 0.6;\n        \n        vec3 kblue = vec3(0, 0, b);\n        vec3 kyellow = vec3(y, y, 0);\n        \n        // Ambient light\n        vec3 ka = vec3(0.1);\n        \n        // Diffuse light intensity\n        vec3 kd = vec3(m/55.0, (m-55.0)/55.0, 0.00);\n        \n        // These values are better explained in the original paper\n        // I kept the same names\n        vec3 kcool = kblue + alpha*kd;\n        vec3 kwarm = kyellow + beta*kd;\n        \n        \n        vec3 I = ((1.0+dot(lig,nor))*0.5)*kcool + ((1.0-(1.0+dot(lig,nor))*0.5))*kwarm;\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        col = I + 0.90*spe*vec3(1.00,1.00,1.00) + ka;\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -4.0+3.2*cos( + 6.0*mo.x), 0.1 + 2.0*mo.y, 0.0 + 3.2*sin( 6.0*mo.x) );\n\tvec3 ta = vec3( 1.0, 3.0, 0.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\n    vec3 col = render( ro, rd, fragCoord);\n\n\t//col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[617, 764, 789, 789, 804], [806, 806, 841, 841, 867], [870, 870, 895, 895, 932], [934, 934, 959, 959, 1017], [1019, 1019, 1044, 1044, 1109], [1111, 1111, 1146, 1146, 1213], [1215, 1215, 1250, 1250, 1317], [1319, 1319, 1356, 1356, 1407], [1409, 1483, 1516, 1516, 1542], [1544, 1544, 1574, 1574, 1607], [1609, 1609, 1639, 1639, 1668], [1670, 1670, 1694, 1694, 1826], [1828, 1902, 1927, 1927, 2898], [2900, 2900, 2940, 2940, 3537], [3540, 3540, 3614, 3614, 3875], [3877, 3877, 3909, 3909, 4130], [4132, 4132, 4174, 4174, 4473], [4478, 4478, 4536, 4566, 5859], [5861, 5861, 5918, 5918, 6556]]}
{"id": "4tX3Dr", "name": "Scene bleeding", "author": "predatiti", "description": "This is a test of Reinder scene, to test color \"bleeding\". Is not like in reinder scene but i quess my render is corect because code is verified in time and i make test scene in different comercial render programs and the render is the same as my.", "tags": ["pathtracer"], "likes": 7, "viewed": 310, "date": "1420663304", "time_retrieved": "2024-06-20T18:15:51.879999", "image_code": "const float t = 16.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time;\nfloat f0, f1,f2,f3;\nvec2 cw = vec2(-0.4,0.1);\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tvec2 r = rand2();\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-1.5, -1.2, -2.0);//room\n   \tbox0.max = vec3( 1.5,  1.2,  2.0);\n    \n    light = vec3(-0.0, 1.7, 0.6);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(0.0, -0.9,1.3,    0.5);//albastru\n    sfere[3].center_radius = vec4(light,    0.05);//albastru\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \t/*float tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}*/\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\n}\n\nvoid shadow(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \tfloat tSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n    \n    vec2 tRoom = intersectCube(ro, rd, box0);          \n   \tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    vec3 hit = ro + rd * t;  \n    if(hit.y > 0.9999 && hit.x<1.3 && hit.x>-1.3 && hit.z<1.99 && hit.z>1.0) t=10000.0;\n\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(normal.x>0.0)\n        { \n            mcol.xyz = vec3(0.95,0.05,0.05);\n        } \n        else if(normal.x<0.0)\n        { \n            mcol.xyz = vec3(0.05,0.95,0.05);\n        } \n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,10.0); mref = vec2(0.0,0.0);}\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n   //vec3 toLight = (lightf-hit);\n   //float sqdist = dot(toLight,toLight);\n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);// sqrt(sqdist);\n      float sh = 1000.0;//distance(lightf,hit);\n      shadow(hit + normal * 0.0001, L, sh, id, true);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n        vec3 hit = ro + rd * t;  \n        if(hit.y > 0.9999 && hit.x<1.3 && hit.x>-1.3 && hit.z<1.99 && hit.z>1.0) t=10000.0;\n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \thit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        col *= mcol.xyz;\n       /* if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*2.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            //if(tm==1) color += col * 1.5;\n            break;\n        }*/\n\t\ttm = -1;\n        //if(rnd.x>abs(mref.x))//diffuse\n        {\n        \t//rd = CosineWeightedSampleHemisphere ( normal, rnd); \n            rd = cosWeightedRandomHemisphereDirection(normal);\n        \ttm = 0;   \n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0);\n            \n            bool isLight = false;\n            vec3 rnd = vec3(rand2(),rand2().x)*2.0-1.0;\n\n         \tvec3 lightf = light + rnd * sfere[3].center_radius.w;\n         \tvec3 dl = directLight(hit, normal, lightf, vec3(1.0,1.0,1.0), isLight);\n         \tcolor += col * dl*9.0;\n         \t//if(isLight) break;\n        }       \n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time *= 0.2;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.45) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[337, 529, 542, 630, 806], [808, 808, 871, 977, 1298], [1300, 1300, 1359, 1359, 1665], [1667, 1667, 1708, 1740, 2028], [2030, 2030, 2083, 2083, 2387], [2389, 2389, 2429, 2429, 2829], [2831, 2831, 2887, 2887, 3315], [3319, 3319, 3361, 3361, 3428], [3431, 3431, 3485, 3485, 3995], [3997, 3997, 4049, 4049, 4202], [4204, 4204, 4222, 4222, 4712], [4714, 4714, 4790, 4790, 5181], [5183, 5183, 5251, 5251, 5675], [5677, 5677, 5802, 5802, 6594], [6596, 6596, 6673, 6673, 7218], [7220, 7220, 7253, 7253, 8976], [8978, 8978, 9035, 9035, 10335]]}
{"id": "4tX3RM", "name": "BallsJumps", "author": "FatumR", "description": "Simple demonstration of the jumping ball", "tags": ["3d", "raymarching", "physics"], "likes": 4, "viewed": 431, "date": "1421444420", "time_retrieved": "2024-06-20T18:15:53.382676", "image_code": "#define MAX_STEPS  128 // try to experiment with numb of steps\n#define THRESHOLD .01\n#define NUM_BALLS  30.\n\n#define OCTAVES  8.0\n\nconst float fogDensity = 0.17;\n\nstruct objectInfo{\n    float hill;\n    vec2 id;\n    float timeOffset;\n    int numBumps;\n    float inBump;\n};\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat object11(vec3 a, vec3 c, float r) {\n    return length(a - c) - r;\n}\n\nfloat valueNoiseSimple(vec2 vl) {\n   float minStep = 1.0 ;\n\n   vec2 grid = floor(vl);\n   vec2 gridPnt1 = grid;\n   vec2 gridPnt2 = vec2(grid.x, grid.y + minStep);\n   vec2 gridPnt3 = vec2(grid.x + minStep, grid.y);\n   vec2 gridPnt4 = vec2(gridPnt3.x, gridPnt2.y);\n\n    float s = rand2(grid);\n    float t = rand2(gridPnt3);\n    float u = rand2(gridPnt2);\n    float v = rand2(gridPnt4);\n    \n    float x1 = smoothstep(0., 1., fract(vl.x));\n    float interpX1 = mix(s, t, x1);\n    float interpX2 = mix(u, v, x1);\n    \n    float y = smoothstep(0., 1., fract(vl.y));\n    float interpY = mix(interpX1, interpX2, y);\n    \n    return interpY;\n}\n\nfloat fractalNoise(vec2 vl) {\n    float persistance = 2.0;\n    float amplitude = 1.;\n    float rez = 0.0;\n    vec2 p = vl;\n    \n    for (float i = 0.0; i < OCTAVES; i++) {\n        rez += amplitude * valueNoiseSimple(p);\n        amplitude /= persistance;\n        p *= persistance;\n    }\n    return rez;\n}\n\nfloat getTLow(float y0, float v0, float g) {\n    \n    // First solution is 0, second one is 2 * v0 / g\n    return 2. * v0 / g;\n}\n\nfloat physTest3D(vec3 coord, vec3 start, float v0, float g, float r,\n                out int numBumps, out float inBump) {\n\tfloat Gclr = 0.;\n    float lowerPnt = getTLow(start.y, v0, g);\n    float time = iTime / 3.;\n    \n    int attenuation = int(time / lowerPnt);\n\n    attenuation = int(mod(float(attenuation), 3.));\n    \n    vec3 center = start;\n    float y_offset = 0.;\n    \n    if (v0 > 0.5) {\n        v0 /= float(attenuation + 1);\n        lowerPnt = getTLow(start.y, v0, g);\n    \ttime = mod(time, lowerPnt);\n        \n       \ty_offset = v0 * time - (g * time * time) / 2.;\n        \n   \t\tcenter.y = start.y + y_offset;\n    }\n    \n    center.y += r;\n    \n    numBumps = attenuation;\n    inBump = time;\n    \n    return object11(coord, center, r);\n}\n\nfloat sceneSimple(vec3 a) {\n    float res = 10.;\n    float Floor = -0.98;\n    float Step = 20. / NUM_BALLS;\n    \n    float idxX = floor(a.x / Step);\n    float idxZ = floor(a.z / Step);\n    a.x = mod(a.x, Step);\n    a.z = mod(a.z, Step);\n    \n    float r = 0.1;\n    \n    float offsetX = Step / 2. + (rand(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n    float offsetZ = Step / 2. + (rand2(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n\n    int tmp1;\n    float tmp2;\n    \n    res = physTest3D(a,\n                     vec3(offsetX, Floor, offsetZ), \n                     4. + 2. * (rand(vec2(idxX / 10., idxZ/ 10.)) * 2. - 1.),\n                     9.8,\n                     r,\n                     tmp1,\n                     tmp2);\n    \n    \n    return min(res, a.y - Floor);\n}\n\nfloat scene(vec3 a, out objectInfo inf) {\n    float res = 10.;\n    float Floor = -0.98;\n    float Step = 20. / NUM_BALLS;\n    \n    float idxX = floor(a.x / Step);\n    float idxZ = floor(a.z / Step);\n    a.x = mod(a.x, Step);\n    a.z = mod(a.z, Step);\n    \n    float r = 0.1;\n    \n    float offsetX = Step / 2. + (rand(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n    float offsetZ = Step / 2. + (rand2(vec2(idxX, idxZ))* 2. - 1.) * (Step / 2. - 2. * r);\n                          \n    res = physTest3D(a,\n                     vec3(offsetX, Floor, offsetZ), \n                     4. + 2. * (rand(vec2(idxX / 10., idxZ/ 10.)) * 2. - 1.),\n                     9.8,\n                     r,\n                     inf.numBumps,\n                     inf.inBump);\n    \n    if (res > (a.y - Floor)) {\n        res = a.y - Floor;\n        inf.id = vec2(0.);\n    } else {\n        inf.id.x = idxX + 1.;\n        inf.id.y = idxZ + 1.;\n    }    \n    \n    return res;\n}\n\nvec3 snormal(vec3 a) {\n   vec2 e = vec2(.0001, 0.);\n   float tmp1;\n   float tmp2;\n   float w = sceneSimple(a);\n\n    return normalize(vec3(\n       sceneSimple(a+e.xyy) - w,\n       sceneSimple(a+e.yxy) - w,\n       sceneSimple(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D, out objectInfo inf) {\n    \n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = scene(O + D*L, inf);\n        d = clamp(d, 0., .15);\n        L += d;\n        \n        if (d < THRESHOLD * L) // Adaptive threshold \n            break;\n    }\n    \n    inf.hill = d;\n    return L;\n}\n\nfloat occluded(vec3 p, float len, vec3 dir) {\n    return max(0., len - sceneSimple(p + len * dir));\n}\n\nfloat occlusion(vec3 p, vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .2;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (1. - min(rez, 1.));\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos, objectInfo inf) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    \n    vec3 color;\n    float specMat = 0.3;\n    \n    if (inf.id.x == 0. && inf.id.y == 0.) {\n        vec3 txtP = p;\n        txtP.z += .75 * inf.timeOffset;\n        color = texture(iChannel0, txtP.xz *.5 + .5).rgb;\n    } else {\n        float threshold = 0.15;\n        float bumps = float(inf.numBumps) / 3.;\n        \n        color.r = mod(rand(vec2(inf.id.x / 1000.)) + bumps, 1.);\n        color.g = mod(rand(vec2(inf.id.y / 1000.)) + bumps, 1.);\n        color.b = mod(rand(vec2((inf.id.x + inf.id.y) / 1000.)) + bumps, 1.);\n\n        specMat = clamp(rand(vec2((inf.id.x + inf.id.y) / 1000.)), 0.01, 1.);\n        \n        float rnd = rand(inf.id / 1000.);\n\n        vec3 offset = vec3(rand(p.xz) * 2. -1.,\n                           rand(p.xy) * 2. -1.,\n                           rand2(p.xz)* 2. -1.);\n\n        if (rnd > 0.75) {\n            float noise = fractalNoise(p.xy * 50. + rnd * 10.);\n            color *= noise;\n            normal *= noise;\n        } else {\n            normal *= clamp(rnd + 0.5, .5, 1.);\n        }\n\n        if (inf.inBump < threshold) {\n            \n            color = mix(vec3(.5, .0, .0),\n                        color,\n                        inf.inBump / threshold);\n        }\n    }\n    \n    vec3 ambient = color;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    diffuse = clamp(diffuse, 0., 1.) * 0.5;\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n    \n    spec = pow(spec, specMat * 60.);\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * vec3(1.0, 1.0, 1.0);\n    \n    return Ispec + diffuse + ambient * occlusion(p, normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    float timeOffset = iTime * 2.;\n    \n    vec3 O = vec3(0., 0.1, 2. - timeOffset);\n    vec3 D = normalize(vec3(centered_uv, -3.5)); //fov\n    \n    objectInfo inf;\n    float path = trace(O, D, inf);\n    vec3 coord = O + path * D;\n    inf.timeOffset = timeOffset;\n    \n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157);\n    vec3 color = mix(skyBlueColor, vec3(1.), clamp(centered_uv.y, 0., 1.));\n    \n    if (inf.hill >= 0.15) {\n        fragColor = vec4(color , 1.);\n    } else {\n        vec3 lightPos = vec3(0., 10., -4. - timeOffset);\n        vec3 normal = snormal(coord);\n\n        vec3 resColor = enlight(coord, normal, O, lightPos, inf);\n        // Calc some fog\n    \tfloat fogFactor = exp(-pow(abs(fogDensity * (coord.z - 1. + timeOffset)), 4.0));\n    \tfogFactor = clamp(fogFactor, 0.0, 1.0);\n    \tresColor = mix(color, resColor, fogFactor);\n        \n        fragColor = vec4(resColor,\n            \t\t\t\t1.0);\n    }\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3RM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[273, 273, 293, 293, 364], [366, 366, 387, 387, 458], [461, 461, 502, 502, 534], [536, 536, 569, 569, 1170], [1172, 1172, 1201, 1201, 1475], [1477, 1477, 1521, 1579, 1605], [1607, 1607, 1729, 1729, 2356], [2358, 2358, 2385, 2385, 3146], [3148, 3148, 3189, 3189, 4105], [4107, 4107, 4129, 4129, 4348], [4350, 4350, 4399, 4399, 4708], [4710, 4710, 4755, 4755, 4811], [4813, 4813, 4851, 4851, 5528], [5530, 5530, 5606, 5606, 7335], [7337, 7337, 7394, 7394, 8472]]}
{"id": "4tX3WM", "name": "MagicSea", "author": "FatumR", "description": "My naive attempt in water simulation.", "tags": ["procedural", "3d", "raymarching", "sea", "water", "ocean"], "likes": 24, "viewed": 2568, "date": "1422457012", "time_retrieved": "2024-06-20T18:15:54.770746", "image_code": "#define OCTAVES  8\n\n#define MAX_STEPS  64\n#define THRESHOLD .0001\n\n#define SHARP_MODE 0 // Just for fun.\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat valueNoiseSimple(vec2 vl) {\n\n   const vec2 helper = vec2(0., 1.);\n    vec2 interp = smoothstep(vec2(0.), vec2(1.), fract(vl));\n    vec2 grid = floor(vl);\n\n    float rez = mix(mix(rand2(grid + helper.xx),\n                        rand2(grid + helper.yx),\n                        interp.x),\n                    mix(rand2(grid + helper.xy),\n                        rand2(grid + helper.yy),\n                        interp.x),\n                    interp.y);\n#if SHARP_MODE==1    \n    return abs(rez*2. -1.);\n#else\n    return rez;\n#endif\n}\n\nconst mat2 unique_transform = mat2( 0.85, -0.65, 0.65, 0.85 );\n\nfloat fractalNoise(vec2 vl, out float mainWave) {\n    \n#if SHARP_MODE==1\n    const float persistance = 2.4;\n    float frequency = 2.2;\n    const float freq_mul = 2.2;\n    float amplitude = .4;\n#else\n    const float persistance = 3.0;\n    float frequency = 2.3;\n    const float freq_mul = 2.3;\n    float amplitude = .7;\n#endif\n    \n    float rez = 0.0;\n    vec2 p = vl;\n    \n    float mainOfset = (iTime + 40.)/ 2.;\n    \n    vec2 waveDir = vec2(p.x+ mainOfset, p.y + mainOfset);\n    float firstFront = amplitude + \n\t\t\t        (valueNoiseSimple(p) * 2. - 1.);\n    mainWave = firstFront * valueNoiseSimple(p + mainOfset);\n    \n    rez += mainWave;\n    amplitude /= persistance;\n    p *= unique_transform;\n    p *= frequency;\n    \n\n    float timeOffset = iTime / 4.;\n\n    \n    for (int i = 1; i < OCTAVES; i++) {\n        waveDir = p;\n        waveDir.x += timeOffset;\n        rez += amplitude * sin(valueNoiseSimple(waveDir * frequency) * .5 );\n        amplitude /= persistance;\n        p *= unique_transform;\n        frequency *= freq_mul;\n\n        timeOffset *= 1.025;\n\n        timeOffset *= -1.;\n    }\n\n    return rez;\n}\n\n\nfloat scene(vec3 a) {\n   float mainWave;\n   float zVal = fractalNoise(vec2(a.x - 5., a.z ), mainWave);\n   return a.y + 0.2 + sin(zVal / 6.5);\n}\n\nfloat fractalNoiseLow(vec2 vl, out float mainWave) {\n    #if SHARP_MODE==1\n    const float persistance = 2.4;\n    float frequency = 2.2;\n    const float freq_mul = 2.2;\n    float amplitude = .4;\n#else\n    const float persistance = 3.0;\n    float frequency = 2.3;\n    const float freq_mul = 2.3;\n    float amplitude = .7;\n#endif\n    \n    float rez = 0.0;\n    vec2 p = vl;\n    \n    float mainOfset = (iTime + 40.)/ 2.;\n    \n    vec2 waveDir = vec2(p.x+ mainOfset, p.y + mainOfset);\n    float firstFront = amplitude + \n\t\t\t        (valueNoiseSimple(p) * 2. - 1.);\n    mainWave = firstFront * valueNoiseSimple(p + mainOfset);\n    \n    rez += mainWave;\n    amplitude /= persistance;\n    p *= unique_transform;\n    p *= frequency;\n    \n\n    float timeOffset = iTime / 4.;\n\n    \n    for (int i = 1; i < OCTAVES - 5; i++) {\n        waveDir = p;\n        waveDir.x += timeOffset;\n        rez += amplitude * sin(valueNoiseSimple(waveDir * frequency) * .5 );\n        amplitude /= persistance;\n        p *= unique_transform;\n        frequency *= freq_mul;\n\n        timeOffset *= 1.025;\n\n        timeOffset *= -1.;\n    }\n\n    return rez;\n}\n\nfloat sceneLow(vec3 a) {\n   float mainWave;\n   float zVal = fractalNoiseLow(vec2(a.x - 5., a.z ), mainWave);\n   return a.y + 0.2 + sin(zVal / 6.5);\n}\n\nvec3 snormal(vec3 a) {\n   vec2 e = vec2(.0001, 0.);\n   float w = scene(a);\n   return normalize(vec3(\n       scene(a+e.xyy) - w,\n       e.x,\n       scene(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D, out float hill) {\n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = sceneLow(O + D*L);\n        L += d;\n        \n        if (d < THRESHOLD*L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\nfloat occluded(vec3 p, float len, vec3 dir) {\n    return max(0., scene(p + len * dir));\n}\n\n\nfloat occlusion(vec3 p, vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .28;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (pow(min(rez, 1.), 4.5) - 0.13725) * 1.7;\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    const vec3 color0 = vec3(0.0470588, 0.1921569, 0.2980392);\n    const vec3 color1 = vec3(0.0470588, 0.3450980, 0.4078431);\n    const vec3 color2 = vec3(0.1294117, 0.5137254, 0.6901961);\n    const vec3 color3 = vec3(0.1686274, 0.7176471, 0.8156863);\n\n    vec3 diffuse = vec3(max(dot(normal, I), 0.));\n\n    vec3 diffuse0 = clamp(diffuse * color0.rgb, 0., 1.);\n    vec3 diffuse1 = clamp(diffuse * color1.rgb, 0., 1.);\n    vec3 diffuse2 = clamp(diffuse * color2.rgb, 0., 1.);\n    vec3 diffuse3 = clamp(diffuse * color3.rgb, 0., 1.);\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n\n    const vec3 spec_clr = vec3(.8, .9, 1.);\n    float dst = clamp(length(eyeDir),1. , 500.);\n    spec = pow(spec, 0.3 * 300.)* pow(.85, dst);\n\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * spec_clr;\n    \n    float dist = length(eyeDir);\n    float atten = pow(0.93, dist * 7. );\n    float deep = occlusion(p, normal) * atten;\n    const float one_of_third = 1./3.;\n    \n    // Some logic workaround, hard to say what is better from performance reason\n    float third1 = max(0., sign(one_of_third - deep));\n    float third2 = (1. - third1) * max(0., sign(2. * one_of_third - deep));\n    float third3 = (1. - third1) * (1. - third2);\n        \n    return Ispec + third1 * mix(diffuse0, diffuse1, deep * 3.) + \n        third2 * mix(diffuse1, diffuse2, (deep - one_of_third) * 3.) +\n        third3 * mix(diffuse2, diffuse3, (deep - 2. * one_of_third) * 3.)\n        ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 sunPos = vec2(.845 * iResolution.x / iResolution.y, .75);\n\n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = scene(O) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -2.0)); //fov\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n    const vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157); // nice blue color\n    const vec3 sunColor = vec3(1.0, 1.0, 1.);\n    const vec3 sunGalo = vec3(.9, .9, .8);\n\n    // Background color\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n    float sunDst = length(centered_uv - sunPos) ;\n    float sunFluctuation = valueNoiseSimple(centered_uv - sunPos + timeOffset);\n    sunFluctuation = clamp(sunFluctuation * .25, 0.1, .2);\n    \n    float galoVal= exp(-pow(sunDst * 0.35, 1.15));\n    float val  = clamp(1. / (sunDst *110.5), 0., 1.);\n    \n    bgColor = mix(bgColor, sunColor*val + (galoVal + sunFluctuation) * sunGalo, galoVal);\n\n    vec3 lightPos = vec3(20., 90. -h, -95. - timeOffset);\n    vec3 normal = snormal(coord);\n        \n    resColor = enlight(coord, normal, O, lightPos);\n    resColor = mix(resColor, bgColor, min(hill, 1.));\n\n\n    fragColor = vec4(resColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[106, 106, 126, 126, 197], [199, 199, 220, 220, 291], [293, 293, 326, 326, 831], [897, 897, 946, 946, 2015], [2018, 2018, 2039, 2039, 2161], [2163, 2163, 2215, 2215, 3287], [3289, 3289, 3313, 3313, 3438], [3440, 3440, 3462, 3462, 3610], [3612, 3612, 3657, 3657, 3899], [3901, 3901, 3946, 3946, 3990], [3993, 3993, 4031, 4031, 4730], [4732, 4732, 4792, 4792, 6392], [6396, 6396, 6453, 6453, 7882]]}
{"id": "4tXGDH", "name": "Atlantis", "author": "dr2", "description": "Follow the fish and see where it goes.", "tags": ["raymarching", "underwater"], "likes": 9, "viewed": 1148, "date": "1421342911", "time_retrieved": "2024-06-20T18:15:54.808258", "image_code": "// \"Atlantis\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nint idObj;\nmat3 fishMat, swmMat;\nvec3 qHit, sunDir, fishPos, swmPos;\nfloat tCur, teRingO, teRingI, swmVel, fishLen, angTail, angFin, posMth;\nconst float dstFar = 100.;\nconst int idBase = 1, idPlat = 2, isShel = 3, idFrm = 4, idDway = 5,\n  idTwr = 6, idBrg = 7, idBrCab = 8, idRdw = 9, idGem = 10, idFBdy = 21,\n  idTail = 22, idFin = 23, idEye = 24;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat AngQnt (float a, float s1, float s2, float nr)\n{\n  return (s1 + floor (s2 + a * (nr / (2. * pi)))) * (2. * pi / nr);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float a, d, r, tO, tI, tR, rGap;\n  bool rotStep;\n  tO = 0.5 * pi * teRingO / swmVel;\n  tI = 0.5 * pi * teRingI / swmVel;\n  rGap = teRingO - teRingI;\n  tR = rGap / swmVel;\n  rotStep = false;\n  p.y = 3.;\n  float ti[9];\n  ti[0] = 0.;  ti[1] = ti[0] + tO;  ti[2] = ti[1] + tR;  ti[3] = ti[2] + tI;\n  ti[4] = ti[3] + tR;  ti[5] = ti[4] + tO;  ti[6] = ti[5] + tR;\n  ti[7] = ti[6] + tI;  ti[8] = ti[7] + tR;\n  float tCyc = ti[8];\n  float aDir = 2. * mod (floor (t / tCyc), 2.) - 1.;\n  t = mod (t, tCyc);\n  r = teRingO;\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    rotStep = true;\n    a = (t - ti[0]) / (ti[1] - ti[0]);\n  } else if (t < ti[2]) {\n    tr.y = teRingO - rGap * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    rotStep = true;\n    a = 1. + (t - ti[2]) / (ti[3] - ti[2]);\n    r = teRingI;\n  } else if (t < ti[4]) {\n    tr.x = - (teRingI + rGap * (t - ti[3]) / (ti[4] - ti[3]));\n  } else if (t < ti[5]) {\n    rotStep = true;\n    a = 2. + (t - ti[4]) / (ti[5] - ti[4]);\n  } else if (t < ti[6]) {\n    tr.y = - teRingO + rGap * (t - ti[5]) / (ti[6] - ti[5]);\n  } else if (t < ti[7]) {\n    rotStep = true;\n    a = 3. + (t - ti[6]) / (ti[7] - ti[6]);\n    r = teRingI;\n  } else if (t < ti[8]) {\n    tr.x = teRingI + rGap * (t - ti[7]) / (ti[8] - ti[7]);\n  }\n  if (rotStep) {\n    a *= 0.5 * pi * aDir;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    if (aDir < 0.) tr.y *= -1.;\n    p.xz = tr;\n  }\n  return p;\n}\n\nvoid FishPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 0.4;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  fishPos = 0.5 * (fpF + fpB);\n  vel = (fpF - fpB) / (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  fishMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat Terrain (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q, t, ta, v;\n  float wAmp, pRough, ht;\n  wAmp = 4.;  pRough = 5.;\n  q = p * 0.05;\n  ht = 0.;\n  for (int j = 0; j < 5; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    ht += (v.x + v.y) * wAmp;\n    q *= 2. * qRot;  wAmp *= 0.2;  pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float hb = 0.;\n  float hf = 1.;\n  float su = length (p) / 50.;\n  if (su < 1.) {\n    su *= su;\n    hf = 0.3 + 0.7 * su;\n    hb = -11. * (1. - su * su * su * su);\n  }\n  su = abs (max ((SmoothMin (abs (p.x), abs (p.y), 0.5) - 2.) / 6., 0.));\n  su = SmoothMin (su, abs (length (p) - teRingO) / 6., 1.);\n  if (su < 1.2) {\n    su *= su;\n    hf = SmoothMin (hf, 0.3 + 0.7 * su, 0.2);\n    hb = SmoothMin (hb, - 11. * (1. - su) +\n       0.5 * Noisefv2 (0.8 * p) + 2. * Fbm2 (0.2 * p), 0.5);\n  }\n  return hf * Terrain (p) + hb + 5.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.05, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat FishDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, wr, tr, u;\n  dHit /= 0.75;\n  q = p;  q.x = abs (q.x);  q -= fishLen * vec3 (0.12, 0.1, 0.9);\n  d = PrSphDf (q, 0.05 * fishLen);\n  if (d < dHit) { dHit = d;  idObj = idEye;  qHit = q; }\n  q = p;\n  wr = q.z / fishLen;\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * (0.33 - 0.13 * u); \n  }\n  q.y *= 0.5;\n  d = PrCapsDf (q, 1.1 * tr * fishLen, fishLen);\n  q.y *= 2.;  q.z -= posMth * fishLen;\n  d = max (d, - PrCylDf (q.yzx, 0.03 * fishLen, 0.1 * fishLen));\n  if (d < dHit + 0.01 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.01 * fishLen);  idObj = idFBdy;  qHit = q;\n  }\n  q = p;  q.z -= -0.9 * fishLen;  q.y *= 0.1;\n  wr = q.z / (0.4 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.05 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  float dTail = PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen);\n  d = max (dTail, 0.15 * fishLen - q.z);\n  if (d < dHit + 0.01 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.01 * fishLen);  idObj = idTail;  qHit = q;\n  }\n  q.z -= 0.15 * fishLen;\n  q.xz = Rot2D (q.xz, angTail);\n  d = max (PrCylDf (q, 0.13 * tr * fishLen, 0.6 * fishLen), q.z);\n  if (d < dHit) { dHit = d;  idObj = idTail;  qHit = q; }\n  q = p;  q.y *= 0.5;  q.z -= -0.75 * fishLen;\n  q = q.xzy;\n  d = max (PrCylDf (q, 0.022 * fishLen, 0.11 * fishLen), dTail);\n  if (d < dHit) { dHit = d;  idObj = idTail;  qHit = 0.2 * q.xzy; }\n  q = p;  q.x = abs (q.x) - 0.18 * fishLen;  q.y *= 0.1;  q.z -= 0.4 * fishLen;\n  q.xz = Rot2D (q.xz, angFin);\n  wr = q.z / (0.2 * fishLen);\n  if (wr > 0.5) {\n    u = (wr - 0.5) / 0.5;  tr = 0.17 - 0.01 * u * u;\n  } else {\n    u = clamp ((wr - 0.5) / 1.5, -1., 1.);  u *= u;  tr = 0.17 - u * 0.34; \n  }\n  q.z -= 0.3 * fishLen;\n  d = PrCylDf (q, 0.12 * tr * fishLen, 0.5 * fishLen);\n  if (d < dHit + 0.005 * fishLen) {\n    dHit = SmoothMin (dHit, d, 0.005 * fishLen);  idObj = idFin;  qHit = q;\n  }\n  return 0.75 * dHit;\n}\n\nfloat BridgeDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float wRd = 1.;\n  q = p;  q.y -= -1.;\n  d = PrBoxDf (q, vec3 (wRd, 0.1, 21.));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRdw; }\n  q = p;  q.x = abs (q.x);  q.xy -= vec2 (wRd - 0.1, 2.);\n  q.z = mod (q.z + 0.75, 1.5) - 0.75;\n  d = PrCylDf (q.xzy, 0.07, 3.);\n  q = p;  q.y -= 2.;\n  d = max (d, PrBoxDf (q, vec3 (wRd, 3., 9.8)));\n  q = p;  q.y -= 13.;\n  d = max (d, - PrCylDf (q.yzx, 13., 1.01));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.x = abs (q.x);  q.xy -= vec2 (wRd - 0.1, 13.);\n  d = max (PrTorusDf (q.yzx, 0.1, 13.), q.y + 8.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (wRd - 0.1, 1.5, 13.5);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  d = PrCylDf (q, 0.1, 4.5);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.z = abs (q.z);  q.yz -= vec2 (0., 10.2);\n  d = PrBoxDf (q, vec3 (wRd + 0.2, 5., 0.2));\n  q.y -= -0.3;\n  d = max (d, - PrBoxDf (q, vec3 (wRd - 0.1, 4.8, 0.21)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrg; }\n  return dHit;\n}\n\nfloat DwayDf (vec3 p, float h1, float h2, float h3)\n{\n  return max (length (p.yz -\n     vec2 (h1 * clamp (p.y / h1, -1., 1.), 0.)) - h2, abs (p.x) - h3);\n}\n\nfloat CageDf (vec3 p, float dHit)\n{\n  const float rad = 6., hLen = 8., wg = 0.5, ww = 0.03, wThk = 0.05,\n     doorHt = 2., doorWd = 1.5;\n  vec3 q, c1, c2;\n  vec2 qo;\n  float d, ds, dd, a;\n  q = p;\n  q.y -= hLen;\n  c1 = vec3 (0., hLen * clamp (q.y / hLen, -1., 1.), 0.);\n  c2 = vec3 (0., (hLen - wThk) * clamp (q.y / (hLen + wThk), -1., 1.), 0.);\n  d = max (max (length (q - c1) - rad,\n     - (length (q - c2) - (rad - wg))), - q.y);\n  a = atan (q.z, - q.x);\n  q = p;  q.y -= hLen + 0.5 * rad;\n  q.xz = Rot2D (q.xz, AngQnt (a, 0.5, 0., 8.));\n  q.x += 0.5 * rad;\n  ds = PrBoxDf (q, vec3 (0.5 * rad, hLen + 0.5 * rad, 2. * ww));\n  q = p;  q.y = mod (q.y - 1.5, 3.) - 1.5;\n  d = max (d, min (ds, PrBoxDf (q, vec3 (rad, 2. * ww, rad))));\n  q = p;\n  qo = Rot2D (q.xz, AngQnt (a, 0.5, 0., 4.));\n  q.xz = qo;  q.xy -= vec2 (- rad, hLen + 1.2 * doorHt);\n  dd = DwayDf (q, doorHt, doorWd, 0.2 * rad);\n  d = max (d, - dd);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idFrm; }\n  q = p;  q.y -= hLen;\n  d = max (max (max (max (length (q - c1) - (rad - 0.4 * wg),\n     - (length (q - c2) - (rad - 0.6 * wg))), - q.y), - ds), - dd);\n  q = p;  q.y -= 2. * hLen + rad;\n  d = max (d, - PrCylDf (q.xzy, 0.5 * rad, 0.2 * rad));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = isShel; }\n  q = p;  q.xz = qo;  q.xy -= vec2 (-0.98 * rad, hLen + 1.2 * doorHt);\n  d = max (max (max (DwayDf (q, doorHt, doorWd, 0.1 * rad),\n     - DwayDf (q, doorHt - ww, doorWd - ww, 0.1 * rad + wThk)),\n     - (q.y + 2. * doorHt - ww - wThk)), - (q.y + 1.2 * doorHt));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idDway; }\n  return dHit;\n}\n\nfloat CentStrucDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xz = abs (q.xz) - vec2 (4.);  q.y -= -5.;\n  d = max (max (PrSphDf (q, 5.), - PrSphDf (q, 4.7)), - min (4. - q.y, q.y));\n  q.y -= 2.3;\n  d = max (d, - min (PrCylDf (q.yzx, 1., 6.), PrCylDf (q, 1., 6.)));\n  q.y += 0.5;\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBase; }\n  q = p;  q.y -= -1.;\n  d = PrTorusDf (q.xzy, 0.4, 8.5);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idPlat; }\n  d = PrCylDf (q.xzy, 8.5, 0.1);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idPlat; }\n  q = p;  q.y -= -9.;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  dHit = CageDf (q, dHit);\n  return dHit;\n}\n\nfloat CornStrucDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, a;\n  q = p;  q.y -= -5.;\n  d = max (max (PrSphDf (q, 5.), - PrSphDf (q, 4.7)), - min (3.9 - q.y, q.y));\n  q.y -= 2.3;\n  d = max (d, - min (PrCylDf (q.yzx, 1., 6.), PrCylDf (q, 1., 6.)));\n  q.y -= 1.5;\n  d = min (d, PrCylDf (q.xzy, 3., 0.1));\n  q.y += 2.;\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBase; }\n  q = p;  q.y -= 1.;\n  d = max (max (PrCapsDf (q.xzy, 2.5, 3.), - PrCapsDf (q.xzy, 2.3, 3.)), -2.2 - q.y);\n  q = p;  q.y -= 7.;\n  d = min (d, max (PrCapsDf (q.xzy, 0.7, 2.), -1. - q.y));\n  q = p;  q.y -= 0.;\n  q.xz = Rot2D (q.xz, AngQnt (0.5 + atan (q.z, - q.x), 0., 0., 4.));\n  q.x += 2.;\n  d = max (d, - DwayDf (q, 2., 1., 2.4));\n  q = p;  q.y -= 4.;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = max (d, - min (PrCylDf (q.yzx, 1., 3.), PrCylDf (q, 1., 3.)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idTwr; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  float dHit = dstFar;\n  q = p;\n  q.xz = Rot2D (q.xz, AngQnt (atan (q.z, - q.x), 0., 0.5, 4.));\n  q.x += 20.;\n  dHit = BridgeDf (q, dHit);\n  q = p;  q.xz = abs (q.xz) - vec2 (10.);  q.y -= -1.;\n  d = max (max (PrCylDf (q.xzy, 10.9, 0.1), - PrCylDf (q.xzy, 9.1, 0.5)),\n     max (- q.x, - q.z));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRdw; }\n  q = p;\n  dHit = CentStrucDf (q, dHit);\n  q.y -= 0.1; \n  d = PrSphDf (q, 1.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idGem; }\n  q = p;  q.xz = abs (q.xz) - vec2 (20.);\n  dHit = CornStrucDf (q, dHit);\n  q.y -= -0.1; \n  d = PrSphDf (q, 0.7);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idGem; }\n  dHit = FishDf (fishMat * (p - fishPos), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec3 col;\n  float spec;\n  spec = 1.;\n  if (idObj == idBase) {\n    if (qHit.y < -1.) col = vec3 (0.2, 0.3, 0.2);\n    else if (qHit.y > -0.6 || n.y < 0.) col = vec3 (0.1, 0.5, 0.1);\n    else col = mix (vec3 (0.5, 0.5, 0.), vec3 (0., 0.5, 0.5),\n       floor (mod (32. * atan (qHit.z, - qHit.x) / (2. * pi), 2.)));\n  } else if (idObj == idPlat) col = vec3 (0.9, 0.9, 0.1);\n  else if (idObj == isShel) col = vec3 (1., 1., 1.);\n  else if (idObj == idFrm) col = vec3 (0.8, 0.8, 0.);\n  else if (idObj == idDway) col = vec3 (0.8, 0.3, 0.);\n  else if (idObj == idTwr) col = vec3 (0.9, 0.7, 0.6);\n  else if (idObj == idBrg) col = vec3 (1., 1., 0.2);\n  else if (idObj == idBrCab) col = vec3 (1., 0.7, 0.);\n  else if (idObj == idRdw) col = vec3 (0.2, 0.15, 0.15);\n  else if (idObj == idGem) {\n    col = vec3 (1., 0.1, 0.1) * (0.6 + 0.4 * cos (5. * tCur));\n    spec = 5.;\n  }\n  return vec4 (col, spec);\n}\n\nvec4 FishCol (vec3 n)\n{\n  vec3 col;\n  const vec3 col1 = vec3 (1., 0.2, 0.1), col2 = vec3 (0.1, 1., 0.2);\n  qHit *= 20. / fishLen;\n  if (idObj == idEye) {\n    col = vec3 (0., 0.6, 1.);\n    if (qHit.z > 0.5) col = vec3 (0., 0., 0.1);\n  } else if (idObj == idFBdy) {\n    col = mix (col2, col1, 0.5 * (1. + sin (2. * qHit.y)));\n    vec3 nn = fishMat * n;\n    col = mix (col1,  mix (col, col2, smoothstep (0.7, 1., nn.y)),\n       smoothstep (-1., -0.7, nn.y)) *\n       (1. - 0.2 * SmoothBump (-0.2, 0.2, 0.1, qHit.x));\n  } else if (idObj == idTail) {\n    col = mix (col2, col1, 0.5 * (1. + sin (20. * qHit.y)));\n  } else if (idObj == idFin) {\n    col = mix (col2, col1, 0.5 * (1. + sin (20. * qHit.y)));\n  }\n  return vec4 (col, 1.);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  float c = 0.;\n  vec2 qq = q;\n  for (int k = 1; k <= 7; k ++) {\n    float tt = t * (1. + 1. / float (k));\n    vec2 a1 = tt - qq;\n    vec2 a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs ((1./6.) + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.3, 0.25, 0.25), gCol2 = vec3 (0.1, 0.1, 0.1),\n     gCol3 = vec3 (0.3, 0.3, 0.1), gCol4 = vec3 (0., 0.5, 0.);\n  vec3 col, wCol, bCol;\n  float a = 1. + atan (p.x, p.z) / pi;\n  vec2 s = sin (0.35 * p.xz);\n  float f = Noisefv2 (vec2 (12. * a, 7. * (p.y + 2.3 * sin (14. * a)))) +\n     Noisefv2 (p.zy * vec2 (1., 4.3 + 1.4 * s.y)) +\n     Noisefv2 (p.xy * vec2 (1.7, 4.4 + 1.7 * s.x));\n  wCol = mix (gCol1, gCol2, clamp (0.3 * f, 0., 1.));\n  bCol = mix (gCol3, gCol4, clamp (0.7 * Noisefv2 (p.xz) - 0.3, 0., 1.));\n  col = mix (wCol, bCol, smoothstep (0.4, 0.7, n.y));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, colg, vn;\n  float dstHit, dstGrnd, bBri, da;\n  int idObjT;\n  vec3 uwatCol = vec3 (0., 0.09, 0.06);\n  bool hitGrnd;\n  dstGrnd = GrndRay (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstGrnd) {\n    hitGrnd = false;\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj < idGem) vn = VaryNf (3. * ro , vn, 5.);\n    objCol = (idObj >= idFBdy) ? FishCol (vn) : ObjCol (vn);\n    bBri = 0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       0.5 * max (0., max (dot (vn, sunDir), 0.));\n    col = objCol.rgb * (bBri + 0.2 * objCol.a *\n       pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n  } else {\n    hitGrnd = true;\n    dstHit = dstGrnd;\n    if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = VaryNf (1.2 * ro, GrndNf (ro, dstGrnd), 2.);\n      col = GrndCol (ro, vn) * (0.5 + 0.5 * max (0., max (dot (vn, sunDir), 0.)));\n    } else col = uwatCol;\n  }\n  da = min (dstHit, dstFar) / dstFar;\n  da =  exp (- 7. * da * da);\n  colg = col;\n  colg.g += 0.5 * max (colg.r, colg.b);\n  colg.rgb *= vec3 (0.2, 0.5, 0.2);\n  if (hitGrnd || idObj != idGem && idObj != idEye) col = colg;\n  else if (idObj == idGem) col = mix (colg, col, da);\n  col *= 1. + 2. * TurbLt (0.01 * ro, normalize (smoothstep (0.1, 0.9, abs (vn))),\n     0.2 * tCur);\n  return sqrt (clamp (mix (uwatCol, col, da), 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd, vd;\n  float az, el, dist, zmFac;\n  sunDir = normalize (vec3 (cos (0.1 * tCur), 1.2, sin (0.1 * tCur)));\n  teRingO = 80.;\n  teRingI = 27.;\n  swmVel = 5.;\n  fishLen = 1.;\n  angTail = 0.15 * pi * sin (6. * tCur);\n  angFin = pi * (0.8 + 0.1 * sin (3. * tCur));\n  posMth = 1.04 + 0.01 * sin (5. * tCur);\n  FishPM (tCur);\n  swmPos = fishPos;\n  swmMat = fishMat;\n  FishPM (tCur + 1.2);\n  fishPos.y -= 2.;\n  ro = swmPos;\n  ro.y -= 1.;\n  zmFac = 1.5;\n  rd = normalize (vec3 (uv, zmFac)) * swmMat;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 263, 287, 287, 334], [336, 336, 361, 361, 540], [542, 542, 563, 563, 700], [702, 702, 731, 731, 933], [935, 935, 974, 974, 1181], [1183, 1183, 1228, 1228, 1326], [1328, 1328, 1385, 1385, 1468], [1470, 1470, 1502, 1502, 1597], [1599, 1599, 1632, 1632, 1659], [1661, 1661, 1703, 1703, 1754], [1756, 1756, 1799, 1799, 1872], [1874, 1874, 1920, 1920, 1991], [2343, 2343, 2373, 2373, 2447], [2449, 2449, 2503, 2503, 2573], [2575, 2575, 2601, 2601, 4045], [4047, 4047, 4070, 4070, 4375], [4377, 4377, 4401, 4401, 4834], [4836, 4836, 4859, 4859, 5386], [5388, 5388, 5422, 5422, 5947], [5949, 5949, 5980, 5980, 6153], [6155, 6155, 6190, 6190, 8239], [8241, 8241, 8278, 8278, 9365], [9367, 9367, 9420, 9420, 9522], [9524, 9524, 9559, 9559, 11129], [11131, 11131, 11171, 11171, 11785], [11787, 11787, 11827, 11827, 12691], [12693, 12693, 12715, 12715, 13460], [13462, 13462, 13495, 13495, 13671], [13673, 13673, 13694, 13694, 13902], [13904, 13904, 13926, 13926, 14819], [14821, 14821, 14844, 14844, 15550], [15552, 15552, 15592, 15592, 16055], [16057, 16057, 16088, 16088, 16695], [16697, 16697, 16732, 16732, 18194], [18196, 18196, 18253, 18253, 18931]]}
{"id": "4tXGDn", "name": "Pink Morphing", "author": "LeWiZ", "description": "Morphing sequence with multiple primitives.", "tags": ["3d", "raymarching", "primitives", "pink", "morphing"], "likes": 12, "viewed": 1651, "date": "1420903561", "time_retrieved": "2024-06-20T18:15:56.043604", "image_code": "#define _SPEED_ 0.1\n#define _NPRIM_ 10.0\n\nfloat sphere(vec3 pos)\n{\n\treturn length(pos)-1.0;   \n}\n\nfloat box(vec3 pos)\n{\n    vec3 d = abs(pos) - 1.0;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus(vec3 pos)\n{\n\tvec2 q = vec2(length(pos.xz)-1.0,pos.y);\n  \treturn length(q)-0.2;   \n}\n\nfloat rbox(vec3 pos)\n{\n\treturn length(max(abs(pos)-0.7,0.0))-0.3;   \n}\n\nfloat cone(vec3 pos)\n{\n    pos -= vec3(0.0,0.5,0.0);\n    float q = length(pos.xz);\n    vec2 c = vec2(0.8,0.6);\n    return max(box(pos),dot(c,vec2(q,pos.y)));\n}\n\nfloat capsule(vec3 pos)\n{\n    const vec3 a = vec3(0.0,-0.8,0.0);\n    const vec3 b = vec3(0.0,0.8,0.0);\n\tvec3 pa = pos - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.6;   \n}\n\nfloat blob(vec3 pos)\n{\n    const float k = 2.0;\n\tfloat s1 = sphere(pos-vec3(0.0,0.0,1.3));\n    float s2 = sphere(pos+vec3(0.0,0.0,1.3));\n    return -log(exp(-k*s1)+exp(-k*s2))/k;\n}\n\nfloat menger(vec3 pos)\n{\n\tfloat d = box(pos);\n\n    float s = 1.0;\n\tfor( int m=0; m<3; m++ )\n\t{\n\t\tvec3 a = mod( pos*s, 2.0 )-1.0;\n\t\ts *= 3.0;\n\t\tvec3 r = abs(1.0 - 3.0*abs(a));\n\n\t\tfloat da = max(r.x,r.y);\n\t\tfloat db = max(r.y,r.z);\n\t\tfloat dc = max(r.z,r.x);\n\t\tfloat c = (min(da,min(db,dc))-1.0)/s;\n\n\t\td = max(d,c);\n\t}\n\n\treturn d;   \n}\n\nfloat julia(vec3 pos)\n{\n\tvec4 c = vec4(-0.1,0.5,0.5,-0.3);\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<7;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat scene(vec3 pos)\n{\n    float time = iTime;\n    const float n = _NPRIM_;\n    const float speed = _SPEED_;\n    const float pi = 3.14159265358979;\n    float phi = 2.0 * pi / n;\n    float t1 = phi / 4.0;\n    float t2 = 3.0 * t1;\n    \n    float tok = smoothstep(cos(t2),cos(t1),cos(time*speed));\n    float bxk = smoothstep(cos(t2),cos(t1),cos(time*speed-phi));\n    float mrk = smoothstep(cos(t2),cos(t1),cos(time*speed-2.0*phi));\n    float dik = smoothstep(cos(t2),cos(t1),cos(time*speed-3.0*phi));\n    float rxk = smoothstep(cos(t2),cos(t1),cos(time*speed-4.0*phi));\n    float juk = smoothstep(cos(t2),cos(t1),cos(time*speed-5.0*phi));\n    float cpk = smoothstep(cos(t2),cos(t1),cos(time*speed-6.0*phi));\n    float cnk = smoothstep(cos(t2),cos(t1),cos(time*speed-7.0*phi));\n    float spk = smoothstep(cos(t2),cos(t1),cos(time*speed-8.0*phi));\n    float blk = smoothstep(cos(t2),cos(t1),cos(time*speed-9.0*phi));\n    \n    float to = torus(pos);\n    float bx = box(pos);\n    \n    float mr = 0.0;\n    if (mrk > 0.0) mr = menger(pos);\n    \n    float di = max(box(pos),-sphere(0.8*pos)/0.8);\n    float rx = rbox(pos);\n    \n    float ju = 0.0;\n    if (juk > 0.0) ju = julia(pos);\n    \n    float cp = capsule(pos);\n    float cn = cone(pos*0.6)/0.6;\n    float sp = sphere(pos);\n    float bl = blob(pos);\n    \n\n    \n    return (to*tok + rx*rxk + cp*cpk + di*dik + sp*spk + cn*cnk + bx*bxk + bl*blk + mr*mrk + ju*juk)\n        / (tok+rxk+cpk+dik+spk+cnk+bxk+blk+mrk+juk);\n}\n\nfloat raymarcher( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 15.0;\n\tconst float precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    const float eps = 0.002;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale)\n{\n    return texture(t, p.yz * scale) * abs (n.x) + texture(t, p.zx * scale) * abs (n.y) + texture(t, p.xy * scale) * abs (n.z);\n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    vec3 diffuse = vec3(0.6 * cosa);\n    vec3 phong = vec3(0.4 * pow(cosr, 64.0));\n    \n    return lightcol * (tex * diffuse + phong);\n}\n\nvec3 material( in vec3 pos , in vec3 camdir )\n{\n    float t = iTime;\n    \n    const float n = _NPRIM_;\n    const float speed = _SPEED_;\n    const float pi = 3.14159265358979;\n    float phi = 2.0 * pi / n;\n    float t1 = phi / 4.0;\n    float t2 = 3.0 * t1;\n    float k = smoothstep(cos(5.0*t2),cos(5.0*t1),cos(t*speed*n));\n    \n\tvec3 norm = normal(pos);\n    \n    vec3 tex1 = vec3(1.0,0.1,0.6);\n    vec3 tex2 = texture3d(iChannel1, pos, norm, 0.5).rgb;\n    vec3 tex = mix(tex1,tex2,k);\n    \n    vec3 d1 = -normalize(vec3(5.0,10.0,-20.0));\n    vec3 d2 = -normalize(vec3(-5,10.0,20.0));\n    vec3 d3 = -normalize(vec3(20,5.0,-5.0));\n    vec3 d4 = -normalize(vec3(-20.0,5.0,5.0));\n\tvec3 l1 = light(d1, vec3(1.0,0.9,0.8), tex, norm, camdir);\n    vec3 l2 = light(d2, vec3(0.8,0.7,0.6), tex, norm, camdir);\n    vec3 l3 = light(d3, vec3(0.4,0.5,0.6), tex, norm, camdir);\n    vec3 l4 = light(d4, vec3(0.2,0.2,0.2), tex, norm, camdir);\n    \n    vec3 amb = vec3(0.02);\n    \n    return amb+l1+l2+l3+l4;\n}\n\nvec3 background( in vec3 rd )\n{\n\treturn vec3(0.2+0.2*texture3d(iChannel0, rd, rd, 1.0).r);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / max(iResolution.xy.x, iResolution.xy.y);\n    \n    const float n = _NPRIM_;\n    const float speed = _SPEED_;\n    const float pi = 3.14159265358979;\n    float phi = 2.0 * pi / n;\n    float t = iTime + 0.9 * cos(iTime*n*speed+0.5*pi) / (speed*n);\n    float d = 6.0+2.0*cos(iTime*n*speed+pi)/(speed*n);\n    vec3 campos = vec3(d*sin(t*0.7),3.0+1.5*sin(t*0.3),-d*cos(t*0.7));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,0.9) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float dist = raymarcher(campos, camdir);\n    \n    if (dist==-1.0) col = background(camdir);\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = material(inters, camdir);\n    }\n    \n    col = pow(col, vec3(0.6));\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[42, 42, 66, 66, 96], [98, 98, 119, 119, 213], [215, 215, 238, 238, 310], [312, 312, 334, 334, 382], [384, 384, 406, 406, 543], [545, 545, 570, 570, 778], [780, 780, 802, 802, 960], [962, 962, 986, 986, 1295], [1297, 1297, 1320, 1320, 1660], [1662, 1662, 1685, 1685, 3125], [3127, 3127, 3171, 3171, 3458], [3460, 3460, 3488, 3488, 3841], [3843, 3843, 3902, 3902, 4031], [4033, 4033, 4126, 4126, 4397], [4399, 4399, 4446, 4446, 5389], [5391, 5391, 5422, 5422, 5483], [5485, 5485, 5549, 5549, 5727], [5729, 5729, 5786, 5786, 6672]]}
{"id": "4tXGWH", "name": "GoodTrip", "author": "Passion", "description": "a good trip", "tags": ["2d", "noise", "perlin", "pattern"], "likes": 4, "viewed": 160, "date": "1421295200", "time_retrieved": "2024-06-20T18:15:56.043604", "image_code": "float t=iTime*1.5;\nvec2 hash( vec2 p ) {                       \n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float s =noise(uv+t)*14.;\n    float b=sin(s-48.*uv.x+t)*sin(s+uv.y*43.-t);\n    float g =noise(uv+t-b);\n    float uv2= length(uv-.5+g)-sin(b)*sin(.08*t);\n    uv2=smoothstep(.49,.5,uv2+g);\n\tfragColor = vec4(uv2*uv.x-g,g*3.8,uv2,b);  \n}\n/* 2015 Passion */\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 19, 40, 40, 200], [201, 201, 227, 227, 598], [599, 599, 656, 656, 936]]}
{"id": "llf3DH", "name": "RaytraceMorphingFractal", "author": "tholzer", "description": "animated fractal with rgb normal coloration", "tags": ["3d", "fractal", "raytrace", "rgb", "morphing"], "likes": 6, "viewed": 256, "date": "1421596786", "time_retrieved": "2024-06-20T18:15:56.734726", "image_code": "\n//---------------------------------------------------------\n// Shader:   RaytraceMorphingFractal.glsl\n// http://glslsandbox.com/e#17593.1\n// added normal color\n//---------------------------------------------------------\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n//varying vec2 surfacePosition;\n//varying vec2 surfaceSize;\n\n#define resolution iResolution \n#define time iTime \n\n//---------------------------------------------------------\n\n// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n\nconst int Iterations=25;\nconst float Scale=1.27;\nconst vec3 Julia=vec3(-2.,-1.5,-.5);\nconst vec3 RotVector=vec3(0.5,-0.05,-0.5);\nconst float RotAngle=40.;\nconst float Speed=0.1;\nconst float Amplitude=0.45;\nconst float detail=.025;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\nmat2 rot;\n\nfloat de(vec3 p); \n\nvec3 normal(vec3 p) \n{\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat light(in vec3 p, in vec3 dir) \n{\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n}\n\nfloat raymarch(in vec3 from, in vec3 dir, out vec3 hitpos)\n{\n\tfloat st,d=1.0,col,totdist=st=0.0;\n\n\tfor (int i=0; i<70; i++) \n\t{\n\t  if (d>detail && totdist<50.)\n\t  {\n\t\thitpos = from+totdist*dir;\n\t\td = de(hitpos);\n\t\ttotdist += d;\n\t  }\n\t}\n\tfloat backg=0.0;\n\tif (d<detail)\n\t     col=light(hitpos-detail*dir, dir); \n\telse col=backg;\n\tcol = mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n\treturn col;\n}\n\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\treturn mat3(c + \n\t\t\t\t(1.0 - c) * v.x * v.x,\n\t\t\t\t(1.0 - c) * v.x * v.y - s * v.z, \n\t\t\t\t(1.0 - c) * v.x * v.z + s * v.y,\n\t\t\t\t(1.0 - c) * v.x * v.y + s * v.z, \n\t\t    c + (1.0 - c) * v.y * v.y, \n\t\t\t\t(1.0 - c) * v.y * v.z - s * v.x,\n\t\t\t\t(1.0 - c) * v.x * v.z - s * v.y, \n\t\t\t\t(1.0 - c) * v.y * v.z + s * v.x, \n\t\t    c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat de(vec3 p) \n{\n\tp=p.zxy;\n\tfloat a=1.5+sin(time*0.1)*0.1;\n\tp.xy=p.xy*mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp.x*=.75;\n\tfloat time=time*Speed;\n\tvec3 ani;\n\tani=vec3(sin(time),sin(time),cos(time))*Amplitude;\n\tp+=sin(p*3.+time*6.)*.04;\n\tmat3 rot = rotationMatrix3(normalize(RotVector+ani), RotAngle+sin(time)*10.);\n\tvec3 pp=p;\n\tfloat l;\n\tfor (int i=0; i<Iterations; i++) \n\t{\n\t\tp.xy=abs(p.xy);\n\t\tp=p*Scale+Julia;\n\t\tp*=rot;\n\t\tl=length(p);\n\t}\n\treturn l*pow(Scale, -float(Iterations))*.9;\n}\n\nvec4 normalColor(in vec3 p) \n{\n\tvec3 norm = normal(p);\n\treturn vec4(norm*norm,1.)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=time*.3;\n\tvec2 uv = fragCoord.xy / resolution.xy*2.-1.;\n\tuv.y*=resolution.y / resolution.x;\n\tvec3 from=vec3(0.,-.7,-20.);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n\trot=mat2(cos(-.5),sin(-.5),-sin(-.5),cos(-.5));\n\tdir.yz=dir.yz*rot;\n\tfrom.yz=from.yz*rot;\n\tvec3 hitpos;\n\tfloat col = raymarch(from,dir, hitpos); \n\tfragColor = vec4(col) + normalColor(hitpos);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llf3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[462, 870, 892, 892, 1046], [1048, 1048, 1113, 1113, 1352], [1354, 1354, 1392, 1392, 1650], [1652, 1652, 1712, 1712, 2054], [2056, 2056, 2100, 2100, 2508], [2510, 2510, 2529, 2529, 2994], [2996, 2996, 3026, 3026, 3084], [3086, 3086, 3143, 3143, 3506]]}
{"id": "llf3WM", "name": "[2TC 15] atan() K*log()", "author": "MichaelPohoreski", "description": "The evolution of the atan() - K*log()", "tags": ["2d", "math"], "likes": 1, "viewed": 140, "date": "1422380102", "time_retrieved": "2024-06-20T18:15:56.916380", "image_code": "// [2TC 15] Monochrome atan() - K*log()\n// Copyleft {c} 2015 Michael Pohoreski\n// Chars: 180\n\n// Chars: 149\n// Linear:     fragColor = vec4( fract( atan(p.y,p.x) - t*t*log(length(p)) ) > .5 );\n\n// Pattern stops, then reverses at:\n// 2PI*1440 =(t/2)^2\n// t = 2*18.973...\n//   = 37.94\n/* Original\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = 2.*w/iResolution.xy - 1.;\n    float t = iTime*0.5;\n    f = vec4( fract( atan(p.y,p.x) - 1440.*(sin(6.28318530718*t*t/1440.))*log(length(p)) ) > .5 );\n}\n*/\n\n// Minified version by Greg Rostami -- Thanks!\nvoid mainImage( out vec4 f, vec2 w )\n{\n    w = w/iResolution.xy-.5;\n    float t = iTime,c=1440.;\n    f = vec4( fract( atan(w.y,w.x) - c*sin(6.28*t*t/c)*log(length(w)) ) > .5 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llf3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[506, 553, 591, 591, 731]]}
{"id": "llfGWH", "name": "rotating wobbly lines", "author": "public_int_i", "description": "rotating wobbly lines expanding from the center", "tags": ["2d", "lines", "rotating", "moving", "wobbly"], "likes": 0, "viewed": 177, "date": "1421514977", "time_retrieved": "2024-06-20T18:15:56.916380", "image_code": "\nconst vec2 center = vec2(0.5,0.5);\n\nconst vec4 lineColor = vec4(0.2,0.4,0.9,1.0);\nconst vec4 backgroundColor = vec4(0.2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec2 dist = center-uv;\n    if (mod(atan(dist.y,dist.x)+(sin(uv.x*100.0)*0.01)+iTime,0.3925) > 0.24) {\n        fragColor = lineColor;\n    } else {\n        fragColor = backgroundColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llfGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[124, 124, 181, 181, 425]]}
{"id": "lll3WM", "name": "kali-traps c", "author": "bergi", "description": "Sorry for the fractal spamming lately - just this Kali set, it won't let go.\n", "tags": ["3d", "fractal", "volume", "marching", "kali", "apolloneanlike"], "likes": 14, "viewed": 1642, "date": "1422586255", "time_retrieved": "2024-06-20T18:15:57.862048", "image_code": "/*\tkali-traps by bergi in 2015\n\t\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n\tman, just showing ..\n\ttry the other path as well ;)\n\n\there's a quick qt app that helped with the parameter scan\n\thttps://github.com/defgsus/kaliset\n\t(though it looks quite different with webgl float precision \n     compared to intel floats..)\n\n\tIt's really difficult to make a good shadertoy selfrunner,\n\tder Spass liegt im Explorieren dieser Menge.\n\t\n\t----- Interact with all the stuff below --------------\n*/\n\n// 1 or 2\n#define PATH \t\t\t\t\t1\n// 0 or 1 (does not make sense at all times..)\n#define PARAM_MORPH\t\t\t\t0\n\n// animation time\n#if PATH == 1\n#\tdefine ti \t(iTime * 1. + 76.)\n#else\n#\tdefine ti \t(iTime * 2. + 500.)\n#endif\n\n// very slight param-set modifier\n#define modf (.5 + .5 * sin(ti / 31.))\n\n#if PARAM_MORPH\n#\tdefine KALI_PARAM \tvec3(0.99-0.02*modf, 1., .7+.4*sin(ti/71.))\n#else\n#\tdefine KALI_PARAM \tvec3(0.99-0.02*modf, 1., 1.01+0.02*modf)\n#endif\n\t  \nconst int  KALI_ITERS = \t\t29;\n\n// max traces\nconst int  NUM_ITERS = \t\t\t30;\n// multisample\nconst int  NUM_RAYS =\t\t\t1;\n// just for camera\nconst float PI = 3.14159265;\n\n/** kali set as usual. \n\treturns last magnitude step and average */\nvec4 average;\nfloat kali(in vec3 p)\n{\n    average = vec4(0.);\n\tfloat mag;\n    for (int i=0; i<KALI_ITERS; ++i)\n    {\n        mag = dot(p, p);\n        p = abs(p) / mag;\n        average += vec4(p, mag);\n        p -= KALI_PARAM;\n    }\n\taverage /= 32.;\n    return mag;\n}\n\n// steps from pos along dir and samples the cloud\n// stp is 1e-5 - 1e+?? :)\nvec3 ray_color(vec3 pos, vec3 dir, float stp)\n{\n    vec3 p, col = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_ITERS; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = kali(p);\n\n\t\t// define a surface and get trapped\n        // well it's all just numbers and signs really\n        // and trial-and-error\n        // the 'trap' is: making d small when close to what-looks-good\n\t\td = d*1.4-.3;\n            //-d*1.3+1.;\n        \t//1.4 - abs(1.1 - d);\n\t\t\n\t\t// always step within a certain range\n\t\tt += max(0.0001, min(0.0004+0.01*stp, d )) * (stp + 3. * t);\n\n\t\t// some color\n        d = max(-0.5, d-0.5);\n\t\tcol += average.rgb * (.7+.3*sin(average.rgb*vec3(3,5,7)*2.9)) \n\t\t// by distance to surface\n            / (1. + d * d * 400. + t * t / stp * 1000.);\n\t}\n    \n    return clamp(col / float(NUM_ITERS) * 7., 0., 1.);\n}\n\n// by D. Hoskins https://www.shadertoy.com/view/XlfGWN\nfloat hash(in vec2 uv)\n{\n\tvec3 p  = fract(vec3(uv,ti) / vec3(3.07965, 7.1235, 4.998784));\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // frequency of slowness\n    float phasemf = 0.12;\n    float phasem = sin(ti*phasemf);\n    float phasem2 = sin(ti*phasemf+PI/2.);\n    \n    // ray stepsize - or focus scale \n    float foc = 0.083 + 0.08*phasem2;\n\n    // camera circle phase\n    float rti = 0.05 * (ti + phasem / phasemf * 0.95);\n    \n    if (iMouse.z > .5) {\n        foc = pow(iMouse.y / iResolution.y, 2.)/6.;\n    }\n\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n\n#if PATH == 1    \n\tvec3 pos = (vec3(0.3359+0.007*modf, 0.1139+0.0064*modf, -0.001-0.001*phasem2) \n                + (.0032 + 0.003 * phasem2) * vec3(uv, 0.)\n                + (0.113 + 0.005*modf) * vec3(sin(rti),cos(rti),0.) );\n    \n    vec3 dir = normalize(vec3(uv, 2.5-length(uv)/1.3)).xyz;\n#else\n    \n    foc = foc * 3.4 + 0.01;\n    \n    vec3 pos = vec3(0.25 + .4*sin(rti), 0.1 * cos(rti), 0.),\n    \t posl = vec3(0.25 + .21*pow(sin(rti),3.), 0.02 * cos(rti) + 0.*sin(rti*2.3), -.1);\n    \n\tvec3 look = normalize(posl - pos);\n\tvec3 up = normalize(cross(vec3(0., 0., -1.), look));\n\tvec3 right = normalize(cross(look, up));\n\t//look = normalize(cross(up, right));\n\tmat3 dirm = mat3(right, up, look);\n    // screen / near-plane\n    pos += dirm * (0.05 + 0.04 * phasem2) * vec3(uv, 0)\n        ;\n    vec3 dir = dirm * normalize(vec3(uv, 2.5-length(uv)/1.3)).xyz;\n    \n#endif    \n\t\t\t\t\n\t\t\t\t\n    vec3 col = vec3(0.);\n    for (float i=0.; i<float(NUM_RAYS); ++i)\n    {\n        vec3 p = pos + dir * hash(uv*1114.+ti+i*17.) * (0.000002 + 0.001 * foc);\n\t\n    \tcol += ray_color(p, dir, foc * (1. + 0.03 * i));\n\t}\n    col /= float(NUM_RAYS);\n        \n\n\tfragColor = vec4(pow(col,vec3(1./1.9)), 1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lll3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1147, 1229, 1252, 1252, 1481], [1483, 1559, 1606, 1606, 2363], [2365, 2420, 2444, 2444, 2572], [2574, 2574, 2631, 2660, 4274]]}
{"id": "lllGR7", "name": "Planet Orbits", "author": "TheJimJames40", "description": "A simulation of planet orbits.\nclick and drag to change the orbits.\nit is slow and badly optimized.", "tags": ["simulation", "planet", "orbit"], "likes": 2, "viewed": 237, "date": "1420372805", "time_retrieved": "2024-06-20T18:15:57.868165", "image_code": "#define Iterations 512\n#define Speed 4.0\n#define FPS 10.0\n#define StarMovement\n\n\n\nstruct Particle {\n\tvec2  pos;\n    vec2  vel;\n    float mass;\n};\n\nfloat grav(Particle p1, Particle p2){\n\tvec2 d = p1.pos-p2.pos;\n    float r2 = d.x*d.x+d.y*d.y;\n    \n    return p1.mass * p2.mass / r2;\n}\n\nParticle updateP(Particle p, Particle po, float delta){\n    vec2 dir = po.pos - p.pos;\n    vec2 acc = dir * grav(p,po);\n    p.vel += acc / p.mass   * delta;\n    p.pos += p.vel * delta;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //#TODO: change uvs\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.x;\n    uv *= 150.;\n    \n    vec2 muv = (2.*iMouse.xy-iResolution.xy) / iResolution.x;\n    muv *= 150.;\n    \n    vec2 muv2 = (2.*abs(iMouse.zw)-iResolution.xy) / iResolution.x;\n    muv2 *= 150.;\n    \n    \n    Particle particles[4];\n    \n\n    if(dot(iMouse.xy,iMouse.xy) < 10.){\n        muv2 = vec2(20.,20.);\n        muv = muv2 + vec2(0.,30.);\n    }\n    \n   // for(int i = 0; i < 4; i++){\n    //    particles[i] = Particle(vec2(0.,0.) ,  vec2(0.,0.),  100.);\n   // }\n    \n    Particle star    = Particle(vec2(0.,0.) ,  vec2(0.,0.),  100.);\n    Particle planet  = Particle(vec2(-50.,0.), vec2(0.,5.),    10.);\n    Particle planet2 = Particle(muv2,  (muv-muv2)/4.,    20.);\n    Particle planet3 = Particle(vec2(-60.,0.), vec2(0.,3.),    1.);\n    \n    float delta = 1./FPS;\n    float n = 0.;\n    \n    float time = mod(iTime,delta*float(Iterations)/Speed);\n    \n    float a = 0.;\n    float b = 0.;\n    float c = 0.;\n    float d = 0.;\n    for(int i = 0; i < Iterations; i++){\n        if(dot(star.pos - uv,   star.pos - uv)    < star.mass/20.)    a = 1.;\n    \tif(dot(planet.pos - uv, planet.pos - uv)  < planet.mass/20.)  b = 1.;\n    \tif(dot(planet2.pos - uv,planet2.pos - uv) < planet2.mass/20.) c = 1.;\n    \tif(dot(planet3.pos - uv,planet3.pos - uv) < planet3.mass/20.) d = 1.;\n        #ifdef StarMovement\n          star = updateP(star,planet, delta);\n          star = updateP(star,planet2,delta);\n          star = updateP(star,planet3,delta);\n        #endif\n        planet = updateP(planet,star,delta);\n        planet = updateP(planet,planet2,delta);\n        planet = updateP(planet,planet3,delta);\n        planet2 = updateP(planet2,star,delta);\n        planet2 = updateP(planet2,planet,delta);\n        planet2 = updateP(planet2,planet3,delta);\n        planet3 = updateP(planet3,star,delta);\n        planet3 = updateP(planet3,planet,delta);\n        planet3 = updateP(planet3,planet2,delta);\n        n += delta;\n        if(n > time*Speed) break;\n    }\n    \n    if(dot(star.pos - uv,   star.pos - uv)    < star.mass)    a = 1.;\n    if(dot(planet.pos - uv, planet.pos - uv)  < planet.mass)  b = 1.;\n    if(dot(planet2.pos - uv,planet2.pos - uv) < planet2.mass) c = 1.;\n    if(dot(planet3.pos - uv,planet3.pos - uv) < planet3.mass) d = 1.;\n    if     (a > 0.5)\n        fragColor = vec4(vec3(1.,1.,0.),1.);\n    else if(b > 0.5)\n        fragColor = vec4(vec3(0.,1.,0.),1.);\n    else if(c > 0.5)\n        fragColor = vec4(vec3(1.,1.,1.),1.);\n    else if(d > 0.5)\n        fragColor = vec4(vec3(1.,0.,0.),1.);\n    else \n        fragColor = vec4(vec3(0.),1.);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[147, 147, 184, 184, 283], [285, 285, 340, 340, 485], [487, 487, 544, 568, 3184]]}
{"id": "lllGW8", "name": "[2TC 15] Spiral", "author": "aiekick", "description": "[2TC 15] Spiral", "tags": ["2tc15"], "likes": 1, "viewed": 1043, "date": "1422015153", "time_retrieved": "2024-06-20T18:15:57.868165", "image_code": "void mainImage( out vec4 f, in vec2 w )\n{\n    vec2 v = iResolution.xy; \n    v = (2.*w - v)/v.y;\n    \n    float \n        t = iTime*5., \n        a = t*2e-4, \n        k = length(v)*t/25.,\n        c = cos(t),\n        s = sin(t),\n    \tr;\n        \n    v += vec2(\n        cos(k),\n        sin(k)*cos(v.x*((0.5*sin(a)+0.5)+a))\n    );\n    \n    v *= mat2(c,-s,s,c);\n    \n    r = dot(v,v.yx);\n    \n    f = \n        vec4(\n        \tr,\n        \tr/t/5e-4,\n        \tr*r/t/0.5,\n        \t1\n        );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 484]]}
{"id": "lllGWH", "name": "[2TC 15] Mandelbrot", "author": "iq", "description": "Mandelbrot set  zoom, with smooth coloring (Douady-Hubbard)", "tags": ["2d", "tweet", "2tc15", "madelbrot"], "likes": 22, "viewed": 3053, "date": "1421825568", "time_retrieved": "2024-06-20T18:15:57.868165", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// New WebGL 2 version, 253 chars\n//\nvoid mainImage( out vec4 f, in vec2 p )\n{\n    p = vec2(-.745,.186) + 3.*(p/iResolution.y-.5)*pow(.01,1.+cos(.2*iTime));\n    \n    float n = 0.;\n    vec2 z = p*n;\n    \n    for( ; n<128. && dot(z,z)<1e4; n++ )\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + p;\n    \n    f = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(dot(z,z)))) );\n}\n\n\n// Original WebGL 1 version, 273 chars\n//\n/*\nvoid mainImage( out vec4 f, in vec2 p )\n{\n    float n = 0.;\n    vec2 c = vec2(-.745,.186) + 3. * (p/iResolution.y-.5)*pow(.01,1.+cos(.2*iTime)), \n         z = c*n;\n    \n    for( int i=0; i<128; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.*z.x*z.y ) + c;\n\n        if( dot(z,z)>1e4 ) break;\n\n        n++;\n    }\n    \n    f = .5 + .5*cos( vec4(3,4,11,0) + .05*(n - log2(log2(dot(z,z)))) );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lllGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[126, 163, 204, 204, 503]]}
{"id": "lls3D7", "name": "Mandelbrot : Power Transitioning", "author": "Gijs", "description": "As per http://nl.reddit.com/r/fractals/comments/2u9uo4/figured_out_how_to_transition_between_powers/", "tags": ["mandelbrot", "powers"], "likes": 6, "viewed": 1306, "date": "1422708927", "time_retrieved": "2024-06-20T18:15:57.868165", "image_code": "//Using Polar form, so any real number power is possible.\n\nconst float n1 = 2.; //Power 1\nconst float n2 = 4.; //Power 2\nconst float iterations = 50.;\n\nvec2 Scale(vec2 p){\n\treturn (2.*p-iResolution.xy)/iResolution.y*2.;\n}\n\n\nfloat mandelbrot(vec2 c){\n    vec2 z = vec2(0);\n    \n    float t = sin(iTime/2.)*.5+.5;\n    \n\tfor (float i=0.;i<iterations;i++){\n\t\t//to (r,a)\n\t\tfloat rad = length(z);\n\t\tfloat phi = atan(z.y,z.x);\n\t\t\n\t\t//escaped?\n\t\tif (rad>5.) return i;\n\t\t\n\t\t//calculation1\n\t\tfloat rad1 = pow(rad,n1);\n\t\tfloat phi1 = phi*n1;\n        \n        //calculation2\n\t\tfloat rad2 = pow(rad,n2);\n\t\tfloat phi2 = phi*n2;\n\t\t\n\t\t//to (x,y)\n\t\tz = vec2(\n\t\t\tcos(phi1)*rad1,\n\t\t\tsin(phi1)*rad1\n\t\t)*t+\n        vec2(\n\t\t\tcos(phi2)*rad2,\n\t\t\tsin(phi2)*rad2\n\t\t)*(1.-t)\n        +c;\n\t}\t\n\treturn iterations;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 scaledp = Scale(fragCoord.xy);\n\n\tvec3 color = vec3(mandelbrot(scaledp)/iterations);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lls3D7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[80, 152, 171, 171, 221], [224, 224, 249, 249, 785], [787, 787, 843, 843, 971]]}
{"id": "lls3z7", "name": "Wavescape", "author": "dr2", "description": "Another wave renderer, from both above and below the waterline. See the source for where it all comes from.", "tags": ["raymarching", "reflection", "waves", "clouds", "refraction", "water"], "likes": 18, "viewed": 2018, "date": "1420457211", "time_retrieved": "2024-06-20T18:16:00.286495", "image_code": "// \"Wavescape\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Water waves, including what the fish sees.\n\n// Acknowledgments: thanks for the following -\n//  Dave_H's multilayered clouds with nimitz's variable layer spacing\n//    (but depends on elevation rather than distance).\n//  Wave shapes from TDM; they seem a little more \"energetic\" than TekF's.\n//  Raymarching with binary subdivision, as used by Dave_H for mountains;\n//    TekF and TDM use one or the other, not both.\n//  Buoy based on TekF's, but raymarched for generality; shows aging effects\n//    below waterline.\n//  Foam idea from TekF.\n//  Noise functions from iq.\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;  p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 f = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  p *= 2.;\n  }\n  return dot (f, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nmat3 ballMat;\nvec3 qHit, ballPos, sunCol, sunDir, cloudDisp, waterDisp;\nfloat tCur, fCloud;\nconst float dstFar = 300.;\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, skyBg, clCol, col;\n  float colSum, attSum, s, att, a, dDotS, ds;\n  const vec3 cCol1 = 0.5 * vec3 (0.15, 0.2, 0.4),\n     cCol2 = 0.5 * vec3 (0.25, 0.5, 0.7), gCol = 1.3 * vec3 (0.05, 0.08, 0.05);\n  const float cloudLo = 100., cloudRngI = 1./50., atFac = 0.06;\n  const int nLay = 30;\n  if (rd.y < 0.015 * Fbm1 (16. * rd.x)) col = gCol * (0.5 + 0.5 *\n     Noisefv2 (1000. * vec2 (5. * atan (rd.x, rd.z), rd.y)));\n  else {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro += cloudDisp;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      q.z *= 0.7;\n      att += atFac * max (fCloud - Fbm3 (0.02 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * colSum + 0.05 * sunCol;\n    cSun = sunCol * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    skyBg = mix (cCol1, cCol2, 1. - rd.y);\n    col = clamp (mix (skyBg + cSun, 1.6 * clCol, attSum), 0., 1.);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  vec2 p;\n  float w, f;\n  p = 5. * rd.xz / rd.y;\n  w = 1.;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += w * Noisefv2 (p);\n    w *= 0.5;  p *= 2.;\n  }\n  return mix (vec3 (0.01, 0.04, 0.02), vec3 (0, 0.05, 0.05), \n     smoothstep (0.4, 0.7, f));\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.16;  wAmp = 0.6;  pRough = 5.;\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 5; j ++) {\n    t2 = 1.1 * tCur * vec2 (1., -1.);\n    t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n    t2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 1.9;  wAmp *= 0.22;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 7; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaveOutRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  ro.y *= -1.;\n  rd.y *= -1.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y + WaveHt (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 7; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y + WaveHt (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.1, 5e-5 * d * d), 0.);\n  float h = WaveHt (p);\n  return normalize (vec3 (h - WaveHt (p + e.xyy), e.x, h - WaveHt (p + e.yyx)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dHit, d;\n  dHit = dstFar;\n  q = p;\n  q -= ballPos;\n  q *= ballMat;\n  d = PrSphDf (q, 2.);\n  if (d < dHit) { dHit = d;  idObj = 1;  qHit = q; }\n  q.y -= 3.;\n  d = PrCylDf (q.xzy, 0.05, 1.);\n  if (d < dHit) { dHit = d;  idObj = 2;  qHit = q; }\n  q.y -= 1.3;\n  d = PrCylDf (q.xzy, 0.15, 0.3);\n  if (d < dHit) { dHit = d;  idObj = 3;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjRay (in vec3 ro, in vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  col = vec3 (0.);\n  if (idObj == 1) {\n    col = vec3 (1., 0.01, 0.);\n    if (abs (qHit.y) < 0.21) col =\n       (mod (floor (7. * (atan (qHit.x, qHit.z) / pi + 1.)), 2.) == 0.) ?\n       vec3 (1., 0.8, 0.08) : vec3 (0.04);\n    else if (qHit.y > 1.93) col = vec3 (0.15, 0.05, 0.);\n    else if (abs (qHit.y) < 0.25) col = vec3 (1., 0.8, 0.08);\n    else if (abs (abs (qHit.y) - 0.55) < 0.05) col = vec3 (1.);\n    else if (abs (abs (qHit.y) - 0.65) < 0.05) col = vec3 (0.04);\n    if (qHit.y < 0.) col = mix (col, vec3 (0.05, 0.2, 0.05), \n       min (- 2. * qHit.y, 0.9));\n  } else if (idObj == 2) {\n    col = vec3 (0.6, 0.4, 0.2);\n  } else if (idObj == 3) {\n    if (abs (qHit.y) < 0.2) \n       col = vec3 (0., 1., 0.) * (2. + 1.5 * cos (10. * tCur));\n    else col = vec3 (0.6, 0.4, 0.2);\n  }\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.1;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjRender (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dif, bk, sh, cc;\n  int idObjT;\n  idObjT = idObj;\n  vn = ObjNf (ro);\n  idObj = idObjT;\n  if (idObj == 1) {\n    vn = VaryNf (20. * qHit, vn, 0.3);\n    if (qHit.y < 0.) vn = mix (vn, VaryNf (12. * qHit, vn, 2.),\n      min (- 5. * qHit.y, 1.));\n  }\n  col = ObjCol (rd);\n  cc = 1. - smoothstep (0.3, 0.6, fCloud);\n  sh = ObjSShadow (ro, sunDir);\n  bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n  dif = max (dot (vn, sunDir), 0.);\n  return col * (0.2 + 0.1 * bk + max (0., dif) * (0.7 + 0.3 * cc * sh)) + \n     0.3 * cc * sh * sunCol * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, rdd, refCol, uwatCol;\n  float dstHit, dstWat, dif, bk, sh, foamFac;\n  const float eta = 0.75, att = 0.5;\n  int idObjT;\n  bool doReflect;\n  if (ro.y > WaveHt (ro)) {\n    dstWat = WaveRay (ro, rd);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    doReflect = (dstWat < dstFar && dstWat < dstHit);\n    if (doReflect) {\n      ro += rd * dstWat;\n      vn = WaveNf (ro, dstWat);\n      rdd = rd;\n      rd = reflect (rd, vn);\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      if (idObj < 0) dstHit = dstFar;\n    }\n    col = (dstHit < dstFar) ? ObjRender (ro + rd * dstHit, rd) :\n       SkyGrndCol (ro, rd);\n    if (doReflect) {\n      refCol = col;\n      rd = refract (rdd, vn, eta);\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      if (idObj < 0) dstHit = dstFar;\n      col = (dstHit < dstFar) ? ObjRender (ro + rd * dstHit, rd) *\n         exp (- att * dstHit) : SeaFloorCol (rd);\n      col = mix (col, 0.8 * refCol, pow (1. - abs (dot (rdd, vn)), 5.));\n      foamFac = pow (clamp (WaveHt (ro) +\n         0.004 * Fbm3 (256. * ro) - 0.65, 0., 1.), 8.);\n      col = mix (col, vec3 (1.), foamFac);\n    }\n  } else {\n    uwatCol = vec3 (0., 0.05, 0.05) +\n       step (0.4, Fbm1 (20. * tCur)) * vec3 (0.02, 0.02, 0.03);\n    col = uwatCol;\n    dstWat = WaveOutRay (ro, rd);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    if (dstWat < dstFar && dstWat < dstHit) {\n      ro += rd * dstWat;\n      vn = - WaveNf (ro, dstWat);\n      rdd = refract (rd, vn, 1. / eta);\n      if (length (rdd) > 0.) rd = rdd;\n      else rd = reflect (rd, vn);\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      if (idObj < 0) dstHit = dstFar;\n      if (dstHit < dstFar) col = 0.9 * ObjRender (ro + rd * dstHit, rd);\n      else if (rd.y > 0.) col = mix (uwatCol, 0.9 * SkyGrndCol (ro, rd),\n         exp (- 0.07 * att * dstWat));\n    } else if (dstHit < dstFar) col = mix (uwatCol,\n       ObjRender (ro + rd * dstHit, rd), exp (- 0.07 * att * dstHit));\n  }\n  return col;\n}\n\nvoid BallPM ()\n{\n  const vec3 e = vec3 (1., 0., 0.);\n  float h[5], b;\n  ballPos = vec3 (0., 0., 0.);\n  h[0] = WaveHt (ballPos);\n  h[1] = WaveHt (ballPos + e.yyx);  h[2] = WaveHt (ballPos - e.yyx);\n  h[3] = WaveHt (ballPos + e);  h[4] = WaveHt (ballPos - e);\n  ballPos.y = 0.5 + (2. * h[0] + h[1] + h[2] + h[3] + h[4]) / 9.;\n  b = (h[1] - h[2]) / (4. * e.x);\n  ballMat[2] = normalize (vec3 (0., b, 1.));\n  b = (h[3] - h[4]) / (4. * e.x);\n  ballMat[1] = normalize (cross (ballMat[2], vec3 (1., b, 0.)));\n  ballMat[0] = cross (ballMat[1], ballMat[2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  mat3 vuMat;\n  vec3 col, ro, rd;\n  vec2 vEl, vAz;\n  float el, az, zmFac, a, tPer, tSeq;\n  cloudDisp = 10. * tCur * vec3 (1., 0., 1.);\n  waterDisp = 0.5 * tCur * vec3 (-1., 0., 1.);\n  sunDir = normalize (vec3 (0.2, 0.5, 0.5));\n  sunCol = vec3 (1., 0.4, 0.3) + vec3 (0., 0.5, 0.2) * sunDir.y;\n  fCloud = 0.5 + 0.2 * sin (0.022 * 2. * pi * tCur);\n  zmFac = 3.5;\n  tPer = 35.;\n  if (mPtr.z <= 0.) {\n    az = 0.01 * tCur;\n    el = 0.2 * pi;\n    tSeq = mod (tCur, tPer);\n    if (mod (floor (tCur / tPer), 2.) == 0.) {\n      a = SmoothBump (10., 30., 5., tSeq);\n      zmFac -= 0.1 * a;\n      el -= 0.19 * pi * a;\n    } else {\n      a = SmoothBump (8., 26., 8., tSeq);\n      zmFac -= 0.05 * a;\n      el -= 0.55 * pi * a;\n    }\n  } else {\n    az = 1.1 * pi * mPtr.x;\n    el = 0.02 * pi - 0.7 * pi * mPtr.y;\n  }\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  rd = normalize (vec3 (uv, zmFac));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = rd * vuMat;\n  ro = vec3 (0., 0., -20.) * vuMat;\n  ro.y += 2.;\n  BallPM ();\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (sqrt (clamp (col, 0., 1.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lls3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[164, 838, 862, 862, 912], [914, 914, 938, 938, 985], [987, 987, 1011, 1011, 1250], [1252, 1252, 1277, 1277, 1407], [1409, 1409, 1434, 1434, 1615], [1617, 1617, 1643, 1643, 1937], [1939, 1939, 1961, 1961, 2095], [2097, 2097, 2118, 2118, 2378], [2380, 2380, 2409, 2409, 2608], [2610, 2610, 2649, 2649, 2856], [2858, 2858, 2915, 2915, 2998], [3000, 3000, 3033, 3033, 3060], [3062, 3062, 3104, 3104, 3155], [3288, 3288, 3324, 3324, 4690], [4692, 4692, 4720, 4720, 4973], [4975, 4975, 4998, 4998, 5683], [5685, 5685, 5719, 5719, 6243], [6245, 6245, 6282, 6282, 6836], [6838, 6838, 6869, 6869, 7023], [7025, 7025, 7047, 7047, 7425], [7427, 7427, 7466, 7466, 7642], [7644, 7644, 7665, 7665, 7873], [7875, 7875, 7897, 7897, 8712], [8714, 8714, 8751, 8751, 8961], [8963, 8963, 8998, 8998, 9631], [9633, 9633, 9668, 9668, 11709], [11711, 11711, 11727, 11727, 12261], [12263, 12263, 12320, 12320, 13701]]}
{"id": "llsGD7", "name": "Simply Trace It", "author": "digorydoo", "description": "(void *) 0", "tags": ["raytracingballs"], "likes": 2, "viewed": 129, "date": "1422695615", "time_retrieved": "2024-06-20T18:16:00.983371", "image_code": "#define SPEED\t\t 0.5\n#define BALLS   \t 5\n#define SQRADIUS     10.0\n#define BOUNCES \t 2\n#define EYE_DIST     0.9\n#define Z_FAR\t\t 1000.0\n#define SELF_COLOUR\t 0.5\n#define MELT_AMOUNT\t 0.5\n#define SUN_DIFFUSE\t 0.4\n#define SUN_SPECULAR 0.2\n#define SUN_SHININESS 20.0\n#define FLOOR_AMOUNT 0.7\n\nconst vec3 Bgnd = vec3 (0.05, 0.20, 0.33);\nconst vec3 Sun = vec3 (1.0, 2.0, -2.0)/3.0;  // normalized!\nconst vec3 Floor = vec3 (0.0, -1.0, 0.0);  // ditto!\n\nstruct Ball\n{\n    vec3 M;\n    vec3 C;\n} B[BALLS];\n\nvoid setup (float t)\n{\n    for (int i = 0; i < BALLS; i++)\n    {\n        float fi = float (i);\n        B[i].M.x = 10.0 * sin (0.91*fi + t);\n        B[i].M.y =  5.0 * cos (1.42*fi + t);\n        B[i].M.z = 12.5 + 7.5*sin (2.73*fi + t);\n\n        int mi = int (mod (float (i), float (3)));  // %?\n        if (     mi == 0) B[i].C = vec3 (0.8, 0.0, 0.0);\n        else if (mi == 1) B[i].C = vec3 (0.0, 0.5, 0.0);\n        else              B[i].C = vec3 (0.0, 0.0, 0.9);\n    }\n}\n\nbool ray (vec3 P, vec3 D, out vec3 Q, out vec3 N, out vec3 C)\n{\n    float a = dot (D, D);\n    float p = dot (P, P);\n    vec3 hitM;\n    \n    Q.z = Z_FAR;\n\n    for (int i = 0; i < BALLS; i++)\n    {\n        vec3 M = B[i].M;  // faster? slower?\n        float b = 2.0 * dot (D, (P - M));\n        float c = dot (M, M) - 2.0*dot (M, P) + p - SQRADIUS;\n        float s = b*b - 4.0*a*c;\n\n        if (s >= 0.0)\n        {\n            s = sqrt (s);\n            \n\t        float t1 = (-b + s) / (2.0*a);\n\t        float t2 = (-b - s) / (2.0*a);\n            \n            float z1 = P.z + t1*D.z;\n            float z2 = P.z + t2*D.z;\n            \n            if (z1 < Q.z || z2 < Q.z)\n            {\n                if (z1 < z2)\n                {\n                    Q.x = P.x + t1*D.x;\n                    Q.y = P.y + t1*D.y;\n                    Q.z = z1;\n                }\n                else\n                {\n                    Q.x = P.x + t2*D.x;\n                    Q.y = P.y + t2*D.y;\n                    Q.z = z2;\n                }\n                C = B[i].C;\n                hitM = M;\n            }\n        }\n    }\n    \n    if (Q.z < Z_FAR)\n    {\n        N = Q - hitM;\n        N.x += MELT_AMOUNT*sin (Q.x);\n        N.y += MELT_AMOUNT*sin (Q.y);\n        N.z += MELT_AMOUNT*sin (Q.z);\n        N = normalize (N);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3 (\n        2.0*(fragCoord.x / iResolution.x - 0.5),\n        2.0*(fragCoord.y / iResolution.y - 0.5)*(iResolution.y / iResolution.x),\n        0.0);\n\n    vec3 D = vec3 (P.xy, EYE_DIST);\n    vec3 Q, N;\n\n    vec3 colour;\n    vec3 mixed = vec3 (0.0, 0.0, 0.0);\n    float mx = 1.0;\n\n    setup (iTime*SPEED);\n\n    for (int i = 0; i <= BOUNCES; i++)\n    {\n        if (ray (P, D, Q, N, colour))\n        {\n            float d = dot (N, Sun);\n            \n            if (d > 0.0) \n            { \n                colour += SUN_DIFFUSE * d;\n                colour += SUN_SPECULAR * pow (d, SUN_SHININESS);\n            }\n            \n            d = FLOOR_AMOUNT * dot (N, Floor);\n            if (d > 0.0) colour.g = max (colour.g, d);\n            \n            mixed = mix (mixed, colour, mx);\n            mx *= SELF_COLOUR;\n            P = Q;\n            D = N;\n        } else break;\n    }\n    \n    fragColor = vec4 (mix (mixed, Bgnd, mx), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llsGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[375, 495, 517, 517, 966], [968, 968, 1031, 1031, 2322], [2324, 2324, 2381, 2381, 3334]]}
{"id": "llXGD4", "name": "[2TC 15] Voxel land", "author": "Nrx", "description": "Remake of my [url=https://www.shadertoy.com/view/XlfGR4]Voxel land[/url].", "tags": ["2tc15"], "likes": 16, "viewed": 804, "date": "1422347978", "time_retrieved": "2024-06-20T18:16:01.329010", "image_code": "// Created by Nicolas Robert (Nrx) - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Entry for [2TC 15] (= 280 chars or less, as counted by Shadertoy)\nvoid mainImage (out vec4 f, vec2 p) {\n\tf *= 0.;\n\tvec4 r = f, P = f, T;\n\tr.xy = p / iResolution.y - .8;\n\t++r.y;\n\tfor (int i = 0; i < 42; ++i)\n\t\tif ((p.x = cos (P.x * P.y + iTime * 4.) - 15.) < p.y)\n\t\t\tP += T = p.x > (p.y = min (f.x, f.y) * (r.y - 2.)) ? f - f : step (f, f.yxzw) * sign (r),\n\t\t\tf += T / r;\n\tf = .4 + .4 * sin (P) - .2 * T.x - .1 * T.y;\n}\n\n/*\n// Below: simplified version (206 chars)\nvoid mainImage (out vec4 f, vec2 p) {\n\tf *= 0.;\n\tvec4 r, P = f, T;\n\tr.xy = p / iResolution.y - .8;\n\t++r.y;\n\tfor (int i = 0; i < 42; ++i)\n\t\tif (cos (P.x * P.y + iTime * 4.) - 15. < min (f.x, f.y) * (r.y - 2.))\n\t\t\tP += T = step (f, f.yxzw) * sign (r),\n\t\t\tf += T / r;\n\tf = .6 + .4 * sin (P);\n}\n*/\n\n/*\n// Below: code to demonstrate how to move the camera (296 chars)\nvoid mainImage (out vec4 f, vec2 p) {\n\tfloat t = iTime * 4., m = t, h;\n\tvec4 N = vec4 (cos (t), t, -.8, .2),\n\t\tr = vec4 (p, p) / iResolution.y + N.zwxy,\n\t\tS = sign (r),\n\t\tT = (.5 + .5 * S - fract (N)) / r,\n\t\tP = floor (N);\n\tfor (int i = 0; i < 42; ++i)\n\t\tif ((h = cos (P.x * P.y + t) - 9.) < m)\n\t\t\tP += N = h > (m = min (T.x, T.y) * (r.y - 2.)) ? N - N : step (T, T.yxww) * S,\n\t\t\tT += N / r;\n\tf = cos (P) + N.x * .4 + N.y * .2;\n}\n*/", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/llXGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[129, 198, 235, 235, 550]]}
{"id": "ltf3DN", "name": "[2TC 15] checker mandala", "author": "mattz", "description": "Slowly changing from 2x2 checkerboard to snakey spirals... and back again. Looks better fullscreen.", "tags": ["2d", "windy", "snakey"], "likes": 17, "viewed": 386, "date": "1422063605", "time_retrieved": "2024-06-20T18:16:01.329010", "image_code": "void mainImage( out vec4 f, in vec2 w ){\n    vec2 q=iResolution.xy,p=w-.5*q;\n    float u=length(p)*2./q.x,t=30.*sin(iTime*.02);\n    u+=.05*sin(50.*u)+.02*sin(40.*atan(p.y,p.x))-.5;\n    u=(1.+exp(-16.*u*u))*t;\n    p=smoothstep(-t,t,mat2(cos(u),-sin(u),sin(u),cos(u))*p);\n    f.xyz = vec3(p.x+p.y-p.x*p.y*2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltf3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 40, 40, 309]]}
{"id": "ltf3WM", "name": "BUG2: 0 chars!", "author": "MichaelPohoreski", "description": "Another ShaderToy v0.6.1 bug :-/\nSorry iq! :-)", "tags": ["bug"], "likes": 1, "viewed": 129, "date": "1422378341", "time_retrieved": "2024-06-20T18:16:01.329010", "image_code": "/* // Look ma no code! 0 chars ShaderToy 0.6.1 :-)\n// */\n\n// From: https://www.shadertoy.com/view/4lX3WN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = 2.*fragCoord.xy/iResolution.xy - 1.;\n    fragColor = vec4( fract( 12.*atan(p.y,p.x) + .5*iTime - 1440.*log(length(p))) > .5 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltf3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[58, 105, 162, 162, 305]]}
{"id": "ltfGD4", "name": "[2TC 15] Abstract Pattern", "author": "Passion", "description": "280 character limit shader", "tags": ["2d", "2tc15", "2tc"], "likes": 4, "viewed": 209, "date": "1422002940", "time_retrieved": "2024-06-20T18:16:01.329010", "image_code": "void mainImage( out vec4 f, in vec2 w )\n{\n    float t = iTime*1.4;\n\tvec2 uv = w / iResolution.xy;\n    \n    for(int i = 0; i<4; i++)\n    {\n        uv+=-.5;\n        vec2 c = vec2(-.2+uv.x,-.1+uv.y-sin(t));\n        c*=cos(t-uv);\n        uv=abs(uv);\n        float m=uv.x*uv.x+uv.y*uv.y;\n        uv-=((uv)/m+c);\n    }\n    \n\tf = vec4((uv*.5),uv.y,1.0);\n}\n/*2015 Passion*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 348]]}
{"id": "ltfGD7", "name": "Wind Waker Ocean", "author": "Polyflare", "description": "An ocean scene inspired by The Legend of Zelda: Wind Waker. The foam in the game distorts differently than what's implemented here but it's good enough for now. Best experienced with [url]http://youtu.be/or8y5EC1_Rs[/url] playing in the background. :)", "tags": ["3d", "waves", "sea", "water", "ocean", "zelda"], "likes": 92, "viewed": 6343, "date": "1422536846", "time_retrieved": "2024-06-20T18:16:02.577471", "image_code": "// \"Wind Waker Ocean\" by @Polyflare (29/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Source code for the texture generator is available at:\n// https://github.com/lmurray/circleator\n\n//-----------------------------------------------------------------------------\n// User settings\n\n// 0 = No antialiasing\n// 1 = 2x2 supersampling antialiasing\n#define ANTIALIAS 1\n\n// 0 = Static camera\n// 1 = Animate the camera\n#define ANIMATE_CAM 1\n\n// 0 = Do not distort the water texture\n// 1 = Apply lateral distortion to the water texture\n#define DISTORT_WATER 1\n\n// 0 = Disable parallax effects\n// 1 = Change the height of the water with parallax effects\n#define PARALLAX_WATER 1\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n//-----------------------------------------------------------------------------\n\n#define WATER_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER2_COL vec3(0.0, 0.4180, 0.6758)\n#define FOAM_COL vec3(0.8125, 0.9609, 0.9648)\n#define FOG_COL vec3(0.6406, 0.9453, 0.9336)\n#define SKY_COL vec3(0.0, 0.8203, 1.0)\n\n#define M_2PI 6.283185307\n#define M_6PI 18.84955592\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv, vec3 cdir)\n{\n    uv *= vec2(0.25);\n    \n#if PARALLAX_WATER\n    // Parallax height distortion with two directional waves at\n    // slightly different angles.\n    vec2 a = 0.025 * cdir.xz / cdir.y; // Parallax offset\n    float h = sin(uv.x + iTime); // Height at UV\n    uv += a * h;\n    h = sin(0.841471 * uv.x - 0.540302 * uv.y + iTime);\n    uv += a * h;\n#endif\n    \n#if DISTORT_WATER\n    // Texture distortion\n    float d1 = mod(uv.x + uv.y, M_2PI);\n    float d2 = mod((uv.x + uv.y + 0.25) * 1.3, M_6PI);\n    d1 = iTime * 0.07 + d1;\n    d2 = iTime * 0.5 + d2;\n    vec2 dist = vec2(\n    \tsin(d1) * 0.15 + sin(d2) * 0.05,\n    \tcos(d1) * 0.15 + cos(d2) * 0.05\n    );\n#else\n    const vec2 dist = vec2(0.0);\n#endif\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\n// Quaternion-vector multiplication\nvec3 quatmul(vec4 q, vec3 v)\n{\n    vec3 qvec = q.xyz;\n    vec3 uv = cross(qvec, v);\n    vec3 uuv = cross(qvec, uv);\n    uv *= (2.0 * q.w);\n    uuv *= 2.0;\n    return v + uv + uuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n#if ANTIALIAS\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n        \tvec2 offset = vec2(0.5) * vec2(x, y) - vec2(0.25);\n#else\n        \tvec2 offset = vec2(0.0);\n#endif\n            // Camera stuff\n            vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n            vec3 cpos = vec3(0.0, 4.0, 10.0); // Camera position\n            vec3 cdir = pixtoray(uv);\n            cdir = quatmul( // Tilt down slightly\n                vec4(-0.19867, 0.0, 0.0, 0.980067), cdir);\n#if ANIMATE_CAM\n            // Rotating camera\n            float cost = cos(iTime * -0.05);\n            float sint = sin(iTime * -0.05);\n            cdir.xz = cost * cdir.xz + sint * vec2(-cdir.z, cdir.x);\n            cpos.xz = cost * cpos.xz + sint * vec2(-cpos.z, cpos.x);\n#endif\n\n            // Ray-plane intersection\n            const vec3 ocean = vec3(0.0, 1.0, 0.0);\n            float dist = -dot(cpos, ocean) / dot(cdir, ocean);\n            vec3 pos = cpos + dist * cdir;\n\n            vec3 pix;\n            if(dist > 0.0 && dist < 100.0) {\n                // Ocean\n                vec3 wat = water(pos.xz, cdir);\n                pix = mix(wat, FOG_COL, min(dist * 0.01, 1.0));\n            } else {\n                // Sky\n                pix = mix(FOG_COL, SKY_COL, min(cdir.y * 4.0, 1.0));\n            }\n#if ANTIALIAS\n        \tfragColor.rgb += pix * vec3(0.25);\n    \t}\n    }\n#else\n    fragColor.rgb = pix;\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[793, 1147, 1186, 1186, 1373], [1375, 1444, 1471, 1471, 5938], [5940, 5987, 6019, 6019, 6876], [6878, 6925, 6949, 6949, 7154], [7156, 7192, 7222, 7222, 7373], [7375, 7375, 7432, 7432, 8891]]}
{"id": "ltl3Dn", "name": "Multibrot Animation", "author": "phil_lira", "description": "Fractal animation on d. z -> zd + c", "tags": ["fractalmultibrot"], "likes": 1, "viewed": 150, "date": "1421099139", "time_retrieved": "2024-06-20T18:16:02.910821", "image_code": "// Shader Created by Phil Lira - felipedrl@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Inputs - Play with these values.\n    const int steps = 100;\n    const float scale = 2.5;\n    const vec2 pan = vec2(0.6, 0.5);\n    const float animationFactor = 8.0;\n    const float minN = 1.0;\n    const float maxN = 4.0;\n    ////////////////////////////////\n    \n    vec2 c = fragCoord.xy / iResolution.xy;\n    \n    // map from [0,1] to [-0.5,0.5] then apply pan and scale.\n    c = (c - pan) * scale;\n\t\n\t// apply aspect ratio to fix distortion     \n    c.x *= iResolution.x / iResolution.y;\n    \n    int currStep = 0;\n    \n    // modelling complex number with vec2\n    // z = x + yi\n    vec2 z = vec2(0.0, 0.0);\n    \n    float alpha = abs(sin(iTime / animationFactor));\n    float n = minN + alpha * (maxN - minN);\n    \n    for (int i = 0; i < steps; i++)\n    {\n        // General formula of Z -> pow(Z, n) + C\n        float x2 = z.x * z.x;\n        float y2 = z.y * z.y;\n        \n        float powX2Y2 = pow(x2 + y2, n * 0.5);\n        float atanN = n * atan(z.y, z.x);\n        \n        float x = powX2Y2 * cos(atanN) + c.x;\n\t\tfloat y = powX2Y2 * sin(atanN) + c.y;\n            \n        if ((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n        \n        currStep++;\n    }\n    \n    float color = float(currStep) / float(steps);\n    float r = (currStep < steps) ? color * color : 0.0; \n\tfragColor = vec4(log(r * 15.0) / log(n), color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3Dn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 54, 111, 151, 1481]]}
{"id": "ltl3WH", "name": "[2TC 15] Circle Fractal", "author": "yakoudbz", "description": "I just took my \"Circle fractal\" shader and add a little camera mode.\nThere are 86 char left to do something more beautiful :p", "tags": ["tweet", "2tc15", "2tc", "15"], "likes": 13, "viewed": 264, "date": "1421842393", "time_retrieved": "2024-06-20T18:16:02.910821", "image_code": "// Circles Fractal 2 [2TC 15]\n// By Yakoudbz\n// inpired by https://www.shadertoy.com/view/XllGDH\n//\n// 2 tweet challenge : https://www.shadertoy.com/view/4tl3W8\n\n\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    float x = .6 + cos(.7*iTime*.1)*.5;\n    \n    vec2 p = w / iResolution.y - .5*vec2(sin(x*5.),cos(x*11.));\n    \n    for(int i=0; i<10; i++)\n        p = abs(p)/dot(p,p) - x;\n    \n\tf = vec4(p,p.y-p.x,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 164, 205, 205, 412]]}
{"id": "ltl3Wn", "name": "Steam Logo", "author": "yakoudbz", "description": "fully parametrizable animated Steam logo\nEven if there already are a lot of animated Steam logo. I made this one all by myself", "tags": ["simple", "fast", "logo", "animation", "60", "steam"], "likes": 11, "viewed": 754, "date": "1421058735", "time_retrieved": "2024-06-20T18:16:03.419938", "image_code": "/* this is my version of the Steam logo\n * no infringement intended :p\n *\n * CÃ©lestin Marot (yakoudbz)\n *\n *********************/\n\n// parameters (can be modified easily ! )\nconst float r0=0.5;   // radius of big circle\nconst float sr0=r0*0.6+0.06;\nconst float vsr0=r0*0.5;\nconst float L0=1.0;   // lenght of the crank\nconst float r1=0.33;   // radius of satelite\nconst float sr1=r1*0.6+0.06;\nconst float vsr1=r1*0.5;\nconst float L1=2.0;   // length of the rod\nconst float r2=0.33;   // radius of translating circle\nconst float sr2=r2*0.6+0.06;\nconst float vsr2=r2*0.5;\nconst vec2 c0=vec2(1.0,0.0); // coordinate of the big circle\nconst float zoom=0.5;\nfloat blur=8.0;      // blur = smooth edge\n\nvec2 pix; // the position of the current pixel\n\n// to draw concentrics circles (r=radius, sr=small_radius,vsr=very small radius)\nfloat circles(vec2 center, float r, float sr, float vsr){\n    float dist=distance(center,pix);\n\n    return smoothstep(dist-blur,dist,r) * smoothstep(sr-blur,sr,dist) + smoothstep(dist-blur,dist,vsr);\n}\n\n\n// to draw a triangle\n// got to pass vertex in the clockwise order, the diagonal must be bc for a rectangle\nfloat triangle(vec2 a, vec2 b, vec2 c){\n    vec2 v0=c-a;\n    vec2 v1=b-a;\n    vec2 p=pix-a;\n\n    float area=v0.x*v1.y - v0.y*v1.x;\n\n    float alpha = (v0.x*p.y - v0.y*p.x)/area;\n    float beta = (v1.y*p.x - v1.x*p.y)/area;\n    float gamma = 1.0 - alpha - beta;\n\n    return smoothstep(-2.0*blur,blur,alpha) * smoothstep(-2.0*blur,blur,beta) * step(0.0,gamma);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    blur/=iResolution.y;\n    pix=(2.0*fragCoord.xy-iResolution.xy)/(zoom*iResolution.y)-c0;\n    \n    float st=L0*sin(iTime);\n\tfloat ct=L0*cos(iTime);\n    \n    // main circle\n    float shade=circles(vec2(0.0,0.0),r0,sr0,vsr0);\n\n    // satelite circle\n    vec2 c1=vec2(ct,st);\n    shade+=circles(c1,r1,sr1,vsr1);\n\n    // translate circle\n    vec2 c2=vec2(ct-sqrt(L1*L1-st*st),0.0);\n    shade+=circles(c2,r2,sr2,vsr2);\n\n    vec2 diff=c1/L0; // is normalized that way\n    diff=vec2(-diff.y,diff.x);\n\n    shade+=2.0*triangle(-sr0*diff,sr0*diff,c1-sr1*diff) * step(r0,length(pix)) * step(r1,distance(pix,c1));\n    shade+=2.0*triangle(c1+sr1*diff,c1-sr1*diff,sr0*diff)* step(r0,length(pix)) * step(r1,distance(pix,c1));\n\n    // diff=r*||c2->c1||  (r is the radius of the interior disk c1 & c2 )\n    diff=(c1-c2)/L1;\n    \n    // we change c1 & c2's position just to make sure the blur won't go further than the circle\n    c1=c1-blur*diff;\n    c2=c2+blur*diff;\n\n    diff=vec2(-diff.y,diff.x); // vec perpendicular to c2->c1\n\n    shade+=triangle(c2-vsr2*diff,c2+vsr2*diff,c1-vsr1*diff);\n    shade+=triangle(c1+vsr1*diff,c1-vsr1*diff,c2+vsr2*diff);\n    \n    fragColor = vec4(shade,shade,shade, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[747, 828, 885, 885, 1029], [1032, 1140, 1179, 1179, 1500], [1503, 1503, 1560, 1560, 2753]]}
{"id": "ltlGD8", "name": "Space Patrol", "author": "bergi", "description": "It's space time 0.11, 0.81, 0.8. \nThe Space Patrol \"ltlGD8\" is making it's round in the nearby Kali star system, looking for glitches - and boy they found some!", "tags": ["volume", "marching", "kaliset"], "likes": 18, "viewed": 2521, "date": "1421791163", "time_retrieved": "2024-06-20T18:16:04.323220", "image_code": "/** Space Patrol\n\n\t(c) 2015, stefan berke (aGPL3)\n\t\n\tLooked like a nice idea. \n\tThe volume tracer needs to be revised though, \n    or you have 4 recent GTX or Quadros SLIed together...\n\n\tupdate: added random start pos for tracing to remove banding\n\t\n\tParameter and path created via\n\thttps://www.shadertoy.com/view/XlsGDH\n*/\n\n// ------------------ \"interface\" -----------------------\n\n#define QUALITY\t\t\t0\t\t\t\t\t\t\t// 0 = friendly but noisy, 1 = better, 2 = future\n#define RANDOMIZE\t\t1\t\t\t\t\t\t\t// randomize trace start\n#define POST_PROCESS\t1\t\t\t\t\t\t\t// cheap post-proc to hide the artefacts\n\nconst vec3 KALI_PARAM =\tvec3(0.11, 0.81, 0.8);\t\t// the magic number \nconst int  NUM_ITER =\t23;\t\t\t\t\t\t\t// number of iterations in kali set\n\nconst float MIX_ALPHA =\t1.;\t\t\t\t\t\t\t// opacity of the traced samples\n#if QUALITY == 0\nconst float DEPTH = \t0.04;\t\t\t\t\t\t// maximum depth to trace in volume\nconst int \tNUM_TRACE =\t40;\t\t\t\t\t\t\t// number traces through volume\n#elif QUALITY == 1\nconst float DEPTH = \t0.06;\t\t\t\t\nconst int \tNUM_TRACE =\t100;\t\t\t\t\t\n#elif QUALITY == 2\nconst float DEPTH = \t0.08;\t\t\t\t\nconst int \tNUM_TRACE =\t350;\t\t\t\t\t\n#endif\nconst float STEP = \t\tDEPTH / float(NUM_TRACE);\n\n\n// ----------------- kali set --------------------------\n\nvec3 kaliset(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    for (int i=0; i<NUM_ITER; ++i)\n    {\n        p = abs(p) / dot(p, p) - KALI_PARAM;\n        c += p;\n    }\n    return c / float(NUM_ITER);\n}\n\n// ---------------------- renderer --------------------------\n\n// hash functions by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n// brute force volume tracer\n// it starts at the end of the ray (pos + DEPTH * dir)\n// and moves towards the camera plane\n// mixing-in the colors from the kaliset() function\nvec3 trace(in vec3 pos, in vec3 dir)\n{\n#if RANDOMIZE != 0\n    pos += dir * STEP * hash12(dir.xy + iTime / 100.);\n#endif\n    \n    vec3 col = vec3(0.);\n    for (int i=0; i<NUM_TRACE; ++i)\n    {\n        float t = float(i) / float(NUM_TRACE);\n        \n        vec3 p = pos + DEPTH * (1.-t) * dir;\n        \n        vec3 k = clamp(kaliset(p), 0., 1.) * (0.01+0.99*t);\n      \n        float ka = dot(k, k) / 3.;\n              \n        col += ka * MIX_ALPHA * (k - col);\n        \n    }\n    \n    return col;\n}\n\n\nvec3 postproc(in vec3 col, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    col *= 0.8+0.2*sin(uv.y * 240. + iTime);\n    \n    col *= 1. - 4.*length(max(abs(uv)-.8, 0.));\n    col = min(vec3(1.), col*1.7);\n    \n    return col;\n}\n\n\n// --------------------- put it together -----------------------\n\n/* The path more or less describes an ellipse on the x,y plane\n   with the big radius on x, so we follow the direction of these star stripes\n   most of the time. \n   By the way, the camera's up vector is z. */\nvec3 path(in float ti)\n{\n    return vec3(\n        0.28 + 0.16 * sin(ti),\n        2.91 + 0.02 * cos(ti) + 0.006 * sin(ti * 7.),\n        0.1  + 0.003 * sin(ti * 7.7)\n        );\n}\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\tfloat aspect = iResolution.x / iResolution.y;\n\n#if POST_PROCESS != 0    \n    float disto = hash11(uv.y/100000. + iTime / 50.);\n    float distoamt = pow(hash11(iTime / 4200.), 10.);\n    disto = pow(disto, 100. - distoamt * 99.);\n    uv.x += disto * hash11(uv.y + iTime / 51.);\n#endif\n    \n    float ti = iTime / 24.;\n    vec3 pos = path(ti);\n    \n    vec3 look =  normalize(path(ti + .02) - path(ti - .02));\n    vec3 up =    normalize(vec3(0., look.y, 2.));\n\tvec3 right = normalize(cross(look, up));\n         look =  normalize(cross(up, right));\n\t\n\tconst float map_size = .2;\n    const vec2 map_pos = vec2(map_size + 0.01);\n    \n    vec2 mapuv = uv - map_pos;\n    float mapr = length(mapuv) / map_size;\n        \n    vec3 col;\n    \n    // paint map\n    if (mapr < 1.)\n    {\n        mapuv = mat2(vec2(look.y, -look.x), look.xy) * mapuv;\n        pos.z = path(0.).z; // avoid wandering through the map slice\n        col = kaliset(pos + 0.01 * vec3(mapuv / map_size, 0.));\n        col = max(col, vec3(0.5,1.,0.5) * smoothstep(0.9, 1., mapr));\n        col *= smoothstep(1., .95, mapr);\n    }\n    // render volume\n    else\n    {\n        uv -= vec2(aspect*.5, .5);\n        uv *= 2.;\n        \n        mat3 dirm = mat3(right, up, look);\n    \tvec3 dir = dirm * normalize(vec3(uv, 1.1));\n        col = trace(pos, dir);\n    }\n\t\n#if POST_PROCESS != 0\n    col = postproc(col,fragCoord);\n#endif\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "agpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1160, 1218, 1243, 1243, 1408], [1473, 1545, 1568, 1568, 1710], [1711, 1711, 1733, 1733, 1861], [1863, 2037, 2075, 2075, 2536], [2539, 2539, 2583, 2583, 2798], [2867, 3077, 3101, 3101, 3253], [3255, 3255, 3288, 3288, 3377], [3395, 3395, 3452, 3452, 4910]]}
{"id": "ltlGWH", "name": "[2TC 15] Duskrise", "author": "mplanck", "description": "Two tweet challenge! (make a shadertoy under 280 chars)  Started looking good at 230 chars... so I stopped.  Open to ideas on how to take advantage of the remaining 50. ", "tags": ["2tweets", "dusk"], "likes": 1, "viewed": 1125, "date": "1421825255", "time_retrieved": "2024-06-20T18:16:04.474578", "image_code": "// 2 Tweet Challenge 2015! Thanks to nimitz - https://www.shadertoy.com/view/4tl3W8\n// tested on: \n// - 13.3-inch Macbook Pro Intel Iris 1536 MB\n// ...\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n\tfloat t = iTime + 10.;\n\tvec2 p = w / iResolution.x;\n    \n    vec3 c = mix(vec3(1., 1., .6 + p.y),\n                 vec3(.8, .5, .3 + p.y*p.y),\n                 step(.5 * sin(.1 * t + .4 * p.y) + .5, \n                      fract(floor(200. * (.5 * sin(.04 * t) + .6) * p.y + t) * (p.x + 4e-06 * t))));\n    f.rgb = c;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 153, 194, 194, 517]]}
{"id": "ltlGWM", "name": "Famous solid", "author": "nimitz", "description": "Just a hyperbolic dodecahedron doing what hyperbolic dodecahedra do.  \n(Mouse enabled, looks better in fullscreen)", "tags": ["dodecahedron", "extrapolation", "mathematica"], "likes": 60, "viewed": 951, "date": "1422663596", "time_retrieved": "2024-06-20T18:16:05.808346", "image_code": "// Famous solid by nimitz 2015 (twitter: @stormoid)\n// https://www.shadertoy.com/view/ltlGWM\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tQuick laydown of what's going on:\n\t\t-knighty's folding technique to get dodecahedron distance (see: https://www.shadertoy.com/view/XlX3zB)\n\t\t-Linear extrapolation of sphere to \"hyberbolize\" the dodecahedron\n\t\t-Fold symmetries are used to displace, shade and color\n\t\t-Cheap analytic curvature for shading (see: https://www.shadertoy.com/view/Xts3WM)\n\t\t-Wave noise for bump mapping (generalized triangle noise: https://www.shadertoy.com/view/XtX3DH)\n\t\t-eiffie's auto-overstep raymarching method: https://www.shadertoy.com/view/ldSSDV\n\t\t-Lighting mostly from iq\n*/\n\n//Type 1 to 4, Let me know which one you think looks best.\n#define TYPE 4\n\n#define ITR 130\n#define FAR 7.\n#define time iTime\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat map(in vec3 p)\n{\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    \n    #if (TYPE == 1)\n    d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n    d += tri(fp.y*5.)*0.04;\n    d*= 0.9;\n    #elif (TYPE == 2)\n    d*= 0.7;\n    d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n    d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n    d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    #elif (TYPE == 3)\n    d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n    d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    #else\n    d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n    #endif\n    \n    return d*0.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.0005;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*0.8;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.0001;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//Cheap analytic curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.03;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .15/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat wav(in float x){return sin(x*6.283)*0.25+0.25;}\nvec2 wav2(in vec2 p){return vec2(wav(p.x+wav(p.y*1.5)),wav(p.y+wav(p.x*1.5)));}\n\nfloat wavenoise(in vec2 p)\n{\n    float z=2.;\n    float z2=1.;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (wav(-time*0.5+p.x*(sin(-time)*0.3+.9)+wav(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec2 dg = wav2(bp*2.)*.8;\n        dg *= mm2(time*.2);\n        p += dg/z2;\n\n        bp *= 2.4;\n        z2 *= 1.05;\n\t\tz *= 2.4;\n\t\tp *= 1.4;\n        \n        rz+= (wav(p.x+wav(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nvec3 tex(in vec3 p)\n{    \n    #if (TYPE == 1)\n    float rz= p.y*15.+p.x*30.+p.z*5.;\n    vec3 col = (sin(vec3(.7,2.,.1-rz*0.2)+rz*.1+0.45))*0.5+0.5;\n    #elif (TYPE==2)\n    float rz= (sin(p.x*0.+p.z*20.)-p.y*20.);\n    vec3 col = (sin(vec3(2.1,.7,.1)+rz*.09+4.15))*0.5+0.5;\n    #elif (TYPE==3)    \n    float rz= sin(p.z*3.+p.x*6.)*0.5+0.5;\n    vec3 col = mix(vec3(.7,0.1,0.),vec3(1,.5,0.4),rz)*0.5+0.05;\n    #else\n    float rz= p.z*13.+p.x*30.;\n    vec3 col = (sin(vec3(2.2,.7,.1)+rz*.1+4.2))*1.3+1.3;\n    #endif\n    \n    return col;\n}\n\n//Bump mapping\nfloat bumptex(in vec3 p)\n{\n    #if (TYPE == 1)\n    return wavenoise(mix(p.zy,p.yx,1.)*0.55);\n    #elif (TYPE == 2)\n    return wavenoise(mix(p.yz,p.xy,.5)*0.55);\n    #elif (TYPE == 3)\n    return wavenoise(mix(p.zy,p.xy,.5)*0.44);\n    #else\n    return wavenoise(mix(p.zy,p.xy,.1)*0.55);\n    #endif\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bumptex(p);\n    vec3 d = vec3(bumptex(p+e.xyy)-n0, bumptex(p+e.yxy)-n0, bumptex(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*.3);\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<15; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.01, .1 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = q-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy*1.5-.75;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo += vec2(time*0.03, time*0.04);\n    \n\tvec3 ro = vec3(.0,0.0,-5.7);\n    vec3 rd = vec3(p,1.2);\n\tro = rotx(ro, -mo.y*3.0);ro = roty(ro, mo.x*3.0);\n\trd = rotx(rd, -mo.y*3.0);rd = roty(rd ,mo.x*3.0);\n\t\n    float rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        //setup\n        vec3 pos = ro+rz*rd;\n        float crv= curv(pos);\n        vec3 nor = normal(pos);\n       \tvec3 fpos = fold(pos);\n        vec3 lgt = normalize(vec3(.0, 1., 0.9));\n        float shd = shadow( pos, lgt, 0.02, 3.0 );\n        nor = bump(fpos, nor);\n        \n        //components\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt.x,lgt.y,-lgt.z)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,10.)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.25+0.75;\n\t\t\n        //compose\n        col  = 0.2*occ + dif*vec3(1.0,0.8,0.6) \n            + 0.4*bac*vec3(1.0)*occ;\n        col *= 0.5*pow(tex(fpos),vec3(.5));\n        col += .4*fre*vec3(1.0) + .35*spe*vec3(1.0);\n        col *= ao(pos,nor);\n        col = pow(col,vec3(.75))*1.3;\n    }\n    \n    //vignetting from iq\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.5+0.5;\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[797, 924, 945, 945, 997], [999, 999, 1021, 1021, 1189], [1191, 1191, 1221, 1221, 1335], [1337, 1337, 1359, 1359, 1388], [1390, 1390, 1412, 1412, 2151], [2153, 2153, 2190, 2190, 2424], [2426, 2426, 2450, 2450, 2610], [2612, 2678, 2701, 2701, 2911], [2913, 2913, 2935, 2935, 2966], [2967, 2967, 2988, 2988, 3046], [3048, 3048, 3076, 3076, 3458], [3460, 3460, 3481, 3481, 3993], [3995, 4010, 4036, 4036, 4307], [4309, 4309, 4342, 4342, 4524], [4526, 4526, 4594, 4594, 4845], [4847, 4847, 4885, 4885, 5181], [5183, 5183, 5210, 5210, 5298], [5299, 5299, 5326, 5326, 5415], [5417, 5417, 5474, 5474, 6968]]}
{"id": "lts3D4", "name": "Lorenz attractor", "author": "FatumR", "description": "Rough Lorenz Attractor", "tags": ["procedural", "2d"], "likes": 2, "viewed": 1335, "date": "1422214311", "time_retrieved": "2024-06-20T18:16:05.808346", "image_code": "#define MAX_STEPS  64 // try to experiment with numb of steps\n#define THRESHOLD .01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n\n    // Lorenz attractor\n    \n    float x = 3.051522, y = 1.582542, z = 15.62388, x1, y1, z1;\n    float dt = 0.04;\n    float ac = 5., b = 15., c = 1.;\n    float r = mod(iTime / 2., 20.);\n    \n    float radius = 0.01;\n    float rez = 100.;\n    float dst = 0.;\n    \n    for (int i = 0; i < 400; i++){\n\n        x1 = x + ac*(-x+y)*dt;\n\t\ty1 = y + (r*x-y-z*x)*dt;\n\t\tz1 = z + (-c*z+x*y)*dt;\n        \n        x = x1;\ty = y1;\tz = z1;\n        \n        vec2 center = vec2(x, z - 15.) / 14.;\n        //center.x = x;\n        //center.y /= 10.;\n        dst = length(centered_uv - center);\n        //dst = step(0., dst - radius);\n        rez = min (rez, dst);\n    }\n    \n    // Color calc taken from here: https://www.shadertoy.com/view/ldf3DN\n    // Thanks iq.\n\tfloat c1 = pow( clamp( rez / 2.,    0.0, 1.0 ), 0.5 );\n\tfloat c2 = pow( clamp( r / 20., 0.0, 1.0 ), 2.0 );\n\tvec3 col1 = 0.5 + 0.5*sin( 3.0 + 4.0*c2 + vec3(0.0,0.5,1.0) );\n\tvec3 col = 2.0*sqrt(c1*col1);\n    \n    fragColor = vec4(vec3(col), 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lts3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[85, 85, 142, 142, 1272]]}
{"id": "ltsGDH", "name": "[2TC 15] Taser", "author": "Trisomie21", "description": "[2TC 15] Shock", "tags": ["2d", "tweet"], "likes": 5, "viewed": 201, "date": "1421879298", "time_retrieved": "2024-06-20T18:16:05.808346", "image_code": "#define S(b) length(p-o-(b)*clamp(dot(p-o,b) / dot(b,b), 0., 1.))\n\n#define A(i) vec2(x.x+i, fract(sin(x+i+iTime)*1e3)*(9.-abs(x+i)))\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = w*18./iResolution.x - vec2(9, 1), x = floor(p)-.5, o=A(1.);\n\tf = vec4(2,1,2,1) - min(S(A(0.)-o), S(A(2.)-o))*4.;\n}\n\t\t    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltsGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[134, 134, 175, 175, 303]]}
{"id": "ltX3D4", "name": "[2TC 15] Rainbow cube 247ch", "author": "iapafoto", "description": "morphing, cube, sphere and colours", "tags": ["morphing", "2tc15"], "likes": 24, "viewed": 579, "date": "1422020000", "time_retrieved": "2024-06-20T18:16:05.808346", "image_code": "// Created by sebastien durand - 2015 - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid mainImage(out vec4 O, vec2 p) {\n    float   C = iTime, a=sin(C), b=cos(C);                                 \n    mat3    U = mat3(a,b*b,b*a,0,a,-b,-b,a*b,a*a);                         \n    vec3    B = vec3(0,0,7)*U, d=normalize(.5-vec3(p/iResolution.y,1.8))*U;\n    for(int E =0;++E<9;) B+=d*(a=length(max(abs(B)-1.+b*b,0.))-1.3*b*b);    \n    O.rgb = a<1.?cos(B):d*d;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltX3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 124, 160, 160, 496]]}
{"id": "MlfGD8", "name": "Kali-Bergwerk", "author": "bergi", "description": "After a hit on the head, the dwarf seems to have forgotten where she came from. Use the mouse to help her find the exit.", "tags": ["raymarching", "kaliset"], "likes": 4, "viewed": 1277, "date": "1421448217", "time_retrieved": "2024-06-20T18:16:07.596214", "image_code": "/*  Kali-Bergwerk\n\n\tAnother nice island in the absdot world\n    https://www.shadertoy.com/view/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n\taGPL3 / (c) 2014 stefan berke\n\n\tOh no, there is no flooooooo...\n\n\tThis tunnel would be a great fly-through show. \n\tUp/down in the hardcoded path is actually the z coord\n\twhich can be travelled for a while.\n\tI messed with some path generation but today only came up with\n\tthis spline which behaves like a drunken mine worker.\n\n\tRaytracing the set is quite difficult for me in general.\n\tThis one looks not completely bad if you let the values untouched. \n\tIt's terribly wrong down there, but i couldn't fix it and keep the look..\n\tThe distant glitches are not very realistic but they show the\n\tinherent tree ornament when looking along z, which forms the cave.\n\n\tAnyways, just came across this part in 2d and it looked interesting. \n\tWould be create to find a function to describe a nice flight through the whole cave. \n\tSee the DEBUG_PLOT define and CEILING..\n*/\n\n#define PATH 1\t\t\t\t// 0=mouse, 1=hardcoded spline\n#define NUM_ITER 25\t\t\t// iterations for distance field\n#define NUM_TEX_ITER 35\t\t// iterations for texture\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 100\n#define PRECISSION 0.1\t\t// unfortunately needs very low stepwidth\n#define FOG_DIST 0.27\n#define NUM_SUPERSAMP 1  \t// super samples - super slow - and somewhat ugly\n\n// 1 for slice of the cave (mouse y for slice z-position, x for surface distance)\n// 2 for value graph of a slice\n#define DEBUG_PLOT 0\n\n#define CEILING 0\t\t\t// ornamental ceiling :)\n\n// shader-local global animation time\n#define sec (iTime - 2.)\n\n\n// -------------------------- helper ------------------------------\n\n// just invented these, not special, rather lousy\nfloat hash(float x) { return fract(sin(x*123.543912)*55.39284); }\nvec3 hash3(vec3 x) { return fract(cos(x * vec3(1123.481, 135.2854, 385.21))\n                                        * vec3(1593.70341, 23142.54073, 497.2)); }\nfloat noise(float x)\n{\n    float f = floor(x), t = fract(x);\n    return hash(f) * (1.-t) + t * hash(f+1.);\n}\n\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n// cubic \nvec2 spline(float x, vec2 v0, vec2 v1, vec2 v2, vec2 v3) \n{\n\tvec2 p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n// -------------------------- fractal -----------------------------\n\n\n/* Kali set\n   somewhere in the sqaure x,y ~[0,1] is a nice 'metal-tree-skelleton-hand-snake-tunnel' \n   where a result of at least 0.1 should be the inside to make it a cave\n   the 'tree decoration' is on the xy-plane while the actual tunnel expands along z.\n   The fractal parameter is locked to the x position.\n*/\nfloat tunnelthing_scalar(in vec3 p)\n{\n    p *= 0.2;\n    p.x += 0.12;\n    vec3 param = vec3(p.x);\n    p.xy *= 4.;\n    \n\tfloat mag, ac = 0.;\n\tfor (int i=0; i<NUM_ITER; ++i)\n    {\n\t\tmag = dot(p, p);\n        p = abs(p) / mag - param;\n        ac += mag;\n    }\n    return 0.1 * ac / float(NUM_ITER);\n}\n\n// same as above but other iteration count\n// and a color as return value\nvec3 tunnel_texture(in vec3 p)\n{\n    vec3 pin = p;\n    p *= 0.2;\n    p.x += 0.12;\n    vec3 param = vec3(p.x);\n    p.xy *= 4.;\n    \n\tfloat mag;\n    vec3 ac = vec3(0.);\n\tfor (int i=0; i<NUM_TEX_ITER; ++i)\n    {\n        p = abs(p) / dot(p, p) - param;\n        ac += 0.5+0.5*sin(p*84.);\n        ac.xy = rotate(ac.xy, p.z);\n        ac.xz = rotate(ac.xz, p.y);\n    }\n    ac = clamp(1.1 * ac / float(NUM_TEX_ITER), 0., 1.);\n    \n    float mixf = 0.5*(ac.y*2.+ac.z);\n#if CEILING == 1\n    mixf += smoothstep(0.5, 0.6, pin.z);\n#endif    \n\n    return mix(vec3(0.3,0.5,0.8), ac, mixf);\n\n}\n\n// position in the tunnel for [0,1]\nvec3 tunnelpos(float t)\n{\n    t *= 21.;\n    vec2 p1  = vec2(0.1, 0.8);\n    vec2 p2  = vec2(0.175, 0.73);\n    vec2 p3  = vec2(0.21, 0.68);\n\tvec2 p4  = vec2(0.22, 0.66);\n\tvec2 p5  = vec2(0.24, 0.61);\n    vec2 p6  = vec2(0.27, 0.59);\n    vec2 p7  = vec2(0.265, 0.55);\n    vec2 p8  = vec2(0.29, 0.50);\n    vec2 p9  = vec2(0.33, 0.52);\n    vec2 p10 = vec2(0.33, 0.47);\n    vec2 p11 = vec2(0.32, 0.47);\n    vec2 p12 = vec2(0.30, 0.45);\n    vec2 p13 = vec2(0.31, 0.37);\n    vec2 p14 = vec2(0.36, 0.35);\n    vec2 p15 = vec2(0.40, 0.38);\n    vec2 p16 = vec2(0.42, 0.38);\n    vec2 p17 = vec2(0.40, 0.41);\n    vec2 p18 = vec2(0.41, 0.45);\n    // the last part is even more crappy \n    vec2 p19 = vec2(0.46, 0.49);\n    vec2 p20 = vec2(0.51, 0.475);\n    vec2 p21 = vec2(0.545, 0.385);\n    vec2 p22 = vec2(0.535, 0.30);\n    vec2 p23 = vec2(0.47, 0.26);\n\n    vec2 p;\n         if (t < 1.)  p = spline(t,     p1,p2,p3,p4);\n    else if (t < 2.)  p = spline(t-1.,  p2,p3,p4,p5);\n    else if (t < 3.)  p = spline(t-2.,  p3,p4,p5,p6);\n    else if (t < 4.)  p = spline(t-3.,  p4,p5,p6,p7);\n    else if (t < 5.)  p = spline(t-4.,  p5,p6,p7,p8);\n    else if (t < 6.)  p = spline(t-5.,  p6,p7,p8,p9);\n    else if (t < 7.)  p = spline(t-6.,  p7,p8,p9,p10);\n    else if (t < 8.)  p = spline(t-7.,  p8,p9,p10,p10);\n    else if (t < 9.)  p = spline(t-8.,  p9,p10,p11,p12);\n    else if (t < 10.) p = spline(t-9.,  p10,p11,p12,p13);\n    else if (t < 11.) p = spline(t-10., p11,p12,p13,p14);\n    else if (t < 12.) p = spline(t-11., p12,p13,p14,p15);\n    else if (t < 13.) p = spline(t-12., p13,p14,p15,p16);\n    else if (t < 14.) p = spline(t-13., p14,p15,p16,p17);\n    else if (t < 15.) p = spline(t-14., p15,p16,p17,p17);\n    else if (t < 16.) p = spline(t-15., p16,p17,p18,p18);\n    else if (t < 17.) p = spline(t-16., p17,p18,p19,p19);\n    else if (t < 18.) p = spline(t-17., p18,p19,p20,p20);\n    else if (t < 19.) p = spline(t-18., p19,p20,p21,p21);\n    else if (t < 20.) p = spline(t-19., p20,p21,p22,p22);\n    else if (t < 21.) p = spline(t-20., p21,p22,p23,p23);\n        \n    return vec3( p, 0.54)  \n           //+ 0.01*sin(vec3(sec*0.3,sec*0.5,sec*0.7))\n        \t;\n}\n\n\n\n// ---- canonical rayder  ----\n\n// 'distance' to the kali set\n// not really a distance of course\n// the scaling at the end is matched somewhat to \n// what the raytracer like\n// in fact as you can see, it returns a negative value. \n// somehow this renders better (less noise)\n// but it screws up everything below. \n// camera is tracing backwards omg\n#if CEILING == 0\nfloat scene_d(in vec3 p) { return (tunnelthing_scalar(p) - 0.5) * 0.1; }\n\n#else\nfloat scene_d(in vec3 p) \n{ \n    float flr = smoothstep(0.58, 0.6, p.z);\n    return (tunnelthing_scalar(p) - 0.5) * 0.1 * (1.-flr); \n}\n#endif\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 sky_color(in vec3 pos, in vec3 dir)\n{\n\treturn vec3(0.2,0.6,0.9);\n}\n\n// returns final color\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n        // increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n\n\t\tt += d * PRECISSION;\n\t}\n\n    vec3 nrm = scene_n(p),\n    \n         ambcol = tunnel_texture(p);\n    \n    // lighting\n    float dull = max(0., dot(nrm, vec3(0.707)));\n\tdull = pow(dull, 2.);\n    // another ambient light\n    dull += max(0., dot(nrm, normalize(vec3(-1.,-0.3,2.))));\n    \n    vec3 col = ambcol * (0.3 + 0.7 * dull);\n\n    return mix(col, col.zyx*0.3, min(2.0, -t/FOG_DIST));\n}\n\n\n\n\n// ---------- helper --------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // ----------- plot cave slice -----------\n#if DEBUG_PLOT == 1\n\n    vec3 p = vec3(uv*0.5+0.5, mouse.y);\n    float k = tunnelthing_scalar(p);\n    \n    float b = k > 0.09 + 0.9*mouse.x ? 1. : 0.;\n\t    \n    fragColor = vec4(b * tunnel_texture(p), 1.);\n#endif\n\n    // ----------- plot value graph -----------\n#if DEBUG_PLOT == 2\n\n    vec3 p = vec3(uv.x, mouse.x, mouse.y);\n    float k = tunnelthing_scalar(p);\n    \n    uv.y = (uv.y+1.) * 4.;\n    float b = k >= uv.y ? 1. : 0.;\n    \n    float grid = smoothstep(0.9,1., mod(uv.y, 1.));\n    \n    fragColor = vec4(b, b, grid, 1.);\n#endif\n\n    // ---------- render thing ----------\n#if DEBUG_PLOT == 0\n    \n    // aspect\n    uv.x *= float(iResolution.x) / float(iResolution.y);\n    \n\t// look-at\n    vec3 dir = normalize(vec3(uv, -1.5));\n\n#if PATH == 0\n    vec3 pos = vec3((mouse.x-0.5) * 5. + 0.001 * sin(sec), \n                     mouse.x-0.5       + 0.001 * sin(sec*1.1) + 0.07,\n                     0.0 + mouse.y*5.);\n    \n#elif PATH == 1\n    float derd = 1.;\n    vec3 pos = tunnelpos(0.5+0.5*sin(sec/10.));\n    // path derivative\n    vec3 posd = (tunnelpos(0.5+0.5*sin((sec+derd)/10.)) - pos) / derd;\n    float movespeed = length(posd);\n    \n    // walk-up-down\n    pos.z += 0.02*length(posd)*sin(sec*9.)\n           - 0.05+.05*sin(sec/6.);\n    \n    // look along path\n    float rotz = atan(-posd.x, posd.y);\n\n    // 'yaw'\n    float rotup = -4.*movespeed;\n    if (iMouse.z < 0.5)\n    \t// occasionally look up\n        rotup -= 1.13 * (1. - pow(noise(sec*1.), 3.));\n\n    // ego interaction\n    if (iMouse.z > 0.5)\n    {\n      \trotz = -iMouse.x / iResolution.x * 6.;\n        rotup += iMouse.y / iResolution.y * 4.;\n    }\n\n    dir.yz = rotate(dir.yz, rotup);\n    dir.xy = rotate(dir.xy, rotz);\n#endif\n    \n    // run\n#if NUM_SUPERSAMP <= 1\n    vec3 col = traceRay(pos, dir);\n#else\n\tvec3 col = vec3(0.);\n    float dofs = 0.1 + 0.03 * float(NUM_SUPERSAMP);\n    for (int i=0; i<NUM_SUPERSAMP; ++i)\n    {\n        // some ill-formed dof\n        // after the dir vec is already set\n        vec3 dis = hash3(vec3(uv, 1.1) * float(1+i)) - 0.5;\n\t\tvec3 di = normalize(dir + dofs*0.05*dis);\n        vec3 p = pos + 0.004*dofs*dis;;\n        col += traceRay(p, di);\n    }\n    col /= float(NUM_SUPERSAMP);\n#endif\n    \n   \tfragColor = vec4(col,1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "agpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1698, 1748, 1769, 1769, 1813], [1814, 1814, 1834, 1834, 1972], [1973, 1973, 1995, 1995, 2081], [2084, 2084, 2117, 2117, 2206], [2208, 2218, 2277, 2277, 2374], [2446, 2763, 2800, 2800, 3058], [3060, 3134, 3166, 3166, 3710], [3712, 3748, 3773, 3773, 5892], [5928, 6485, 6510, 6510, 6711], [6713, 6713, 6755, 6755, 6784], [6786, 6809, 6850, 6850, 7450], [7455, 7487, 7544, 7544, 9933]]}
{"id": "Mll3W4", "name": "Temple of the Waves", "author": "dr2", "description": "Somewhere in the ocean; use the mouse to investigate.", "tags": ["raymarching", "reflection", "architecture"], "likes": 30, "viewed": 3323, "date": "1422183507", "time_retrieved": "2024-06-20T18:16:09.408326", "image_code": "// \"Temple of the Waves\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nint idObj;\nvec3 qHit, sunDir, cloudDisp, waterDisp;\nfloat tCur;\nconst float dstFar = 150.;\nconst int idBaseW = 10, idBase = 11, idCol = 12, idColEnd = 13, idTop = 14,\n   idAltr = 15, idRBall = 16;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.2, 0.3, 0.55);\n  vec3 col;\n  vec2 p;\n  float sd, w, f;\n  col = sbCol + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n  sd = max (dot (rd, sunDir), 0.);\n  rd.y = abs (rd.y);\n  ro += cloudDisp;\n  p = 0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz);\n  w = 0.8;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += w * Noisefv2 (p);\n    w *= 0.5;\n    p *= 2.;\n  }\n  col += 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.25;  wAmp = 0.25;  pRough = 5.;\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 5; j ++) {\n    t2 = 1.1 * tCur * vec2 (1., -1.);\n    t4 = vec4 (q2 + t2.xx, q2 + t2.yy) * wFreq;\n    t2 = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + abs (cos (t4)));\n    v2 = pow (1. - sqrt (v4.xz * v4.yw), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.25;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = 0.;\n    sLo = 0.;\n    for (int j = 0; j < 100; j ++) {\n      p = ro + s * rd;\n      h = p.y - WaveHt (p);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.3, h) + 0.005 * s;\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n\ts = 0.5 * (sLo + sHi);\n\tp = ro + s * rd;\n\th = step (0., p.y - WaveHt (p));\n\tsLo += h * (s - sLo);\n\tsHi += (1. - h) * (s - sHi);\n      }\n      dHit = sHi;\n    }\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  float ht = WaveHt (p);\n  return normalize (vec3 (ht - WaveHt (p + e.xyy), e.x, ht - WaveHt (p + e.yyx)));\n}\n\nfloat BldgDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, da, db, wr;\n  p.y -= 0.5;\n  q = p;\n  q.y -= -0.2;\n  d = PrBoxDf (q, vec3 (8.6, 0.301, 10.6));\n  if (d < dHit) { dHit = d;  idObj = idBaseW;  qHit = q; }\n  q.y -= 0.35;\n  d = PrBoxDf (q, vec3 (8.4, 0.101, 10.4));\n  q.y -= 0.15;\n  d = min (d, PrBoxDf (q, vec3 (8.2, 0.101, 10.2)));\n  if (d < dHit) { dHit = d;  idObj = idBase;  qHit = q; }\n  q.y -= 5.52;\n  d = max (PrBoxDf (q, vec3 (7.55, 0.05, 9.55)),\n     - PrBoxDf (q, vec3 (4.45, 0.4, 6.45)));\n  q.xz = mod (q.xz + vec2 (1.), 2.) - 1.;\n  d = max (d, - PrBoxDf (q, vec3 (0.45, 0.4, 0.45)));\n  if (d < dHit) { dHit = d;  idObj = idTop;  qHit = q; }\n  q = p;  q.y -= 3.1;\n  db = max (PrBoxDf (q, vec3 (8., 5., 10.)),\n     - PrBoxDf (q, vec3 (4., 5., 6.)));\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y -= 3.1;\n  wr = q.y / 2.5;\n  d = max (PrCylDf (q.xzy, 0.3 * (1.05 - 0.05 * wr * wr), 2.55), db);\n  if (d < dHit) { dHit = d;  idObj = idCol;  qHit = q; }\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y = abs (q.y - 3.1) - 2.5;\n  d = PrCylDf (q.xzy, 0.4, 0.07);\n  q.y -= 0.14;\n  d = max (min (d, PrBoxDf (q, vec3 (0.5, 0.07, 0.5))), db);\n  if (d < dHit) { dHit = d;  idObj = idColEnd;  qHit = q; }\n  q = p;  q.y -= 0.4;\n  d = PrCylDf (q.xzy, 1.1, 0.2);\n  q = p;  q.y -= 1.;\n  q.xz = abs (q.xz) - 0.4;\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.8));\n  if (d < dHit) { dHit = d;  idObj = idAltr;  qHit = q; }\n  q = p;  q.y -= 2.9;  \n  d = PrSphDf (q, 1.5);\n  if (d < dHit) { dHit = d;  idObj = idRBall;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dHit, d;\n  dHit = dstFar;\n  dHit = 0.95 * BldgDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  float sn = Noisefv3a (110. * qHit);\n  if (idObj == idBase ||idObj == idTop) col = vec3 (0.7, 0.7, 0.6);\n  else if (idObj == idBaseW) col =\n     mix (vec3 (0.7, 0.7, 0.6), vec3 (0.1, 0.4, 0.3) * sn,\n        clamp (0.6 - 2. * qHit.y, 0., 1.));\n  else if (idObj == idCol || idObj == idColEnd) col = vec3 (0.6, 0.7, 0.5);\n  else if (idObj == idAltr) col = vec3 (0.6, 0.5, 0.2);\n  col *= 0.7 + 0.3 * sn;\n  return col;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.05;\n  for (int i = 0; i < 60; i ++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h / d);\n    d += 0.15;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 objCol, col, rdd, vn, vnw;\n  float dstHit, dstWat, dif, sh, a;\n  int idObjT;\n  bool objRefl, waterRefl;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  objRefl = false;\n  if (idObj == idRBall && dstHit < dstFar) {\n    ro += rd * dstHit;\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    objRefl = true;\n  }\n  dstWat = WaveRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstHit));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    vnw = WaveNf (ro, dstWat);\n    rdd = rd;\n    rd = reflect (rd, vnw);\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    if (idObj == idRBall && dstHit < dstFar) {\n      ro += rd * dstHit;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n      objRefl = true;\n    }\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idCol) {\n      a = 0.5 - mod (12. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a));\n    }\n    if (idObj == idBase || idObj == idBaseW) vn = VaryNf (10. * qHit, vn, 1.);\n    else vn = VaryNf (20. * qHit, vn, 0.5);\n    objCol = ObjCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    dif = max (dot (vn, sunDir), 0.);\n    col = objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) + \n       max (0., dif) * (0.2 + 0.8 * sh) *\n       (1. + 0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));\n    if (objRefl) col = 0.7 * col;\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) col = mix (vec3 (0, 0.07, 0.08), 0.5 * col,\n     0.8 * pow (1. - abs (dot (rdd, vnw)), 4.));\n  return sqrt (clamp (col, 0., 1.));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float dist, az, f;\n  sunDir = normalize (vec3 (0.8, 1., -0.8));\n  cloudDisp = 1.5 * tCur * vec3 (1., 0., -1.);\n  waterDisp = 0.2 * tCur * vec3 (-1., 0., 1.);\n  if (mPtr.z <= 0.) {\n    dist = 35.;\n    az = 0.25 * pi + 0.01 * tCur;\n  } else {\n    dist = max (2., 17. - 30. * mPtr.y);\n    az = 2.2 * pi * mPtr.x;\n  }\n  ro = dist * vec3 (sin (az), 0., cos (az));\n  ro.y = 5.;\n  vd = normalize (vec3 (0., 3., 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 274, 298, 298, 345], [347, 347, 371, 371, 610], [612, 612, 637, 637, 816], [818, 818, 844, 844, 1138], [1140, 1140, 1169, 1169, 1371], [1373, 1373, 1412, 1412, 1619], [1621, 1621, 1653, 1653, 1748], [1750, 1750, 1783, 1783, 1810], [1812, 1812, 1854, 1854, 1905], [1907, 1907, 1937, 1937, 2011], [2211, 2211, 2243, 2243, 2757], [2759, 2759, 2782, 2782, 3455], [3457, 3457, 3491, 3491, 4045], [4047, 4047, 4078, 4078, 4237], [4239, 4239, 4274, 4274, 5764], [5766, 5766, 5788, 5788, 5883], [5885, 5885, 5918, 5918, 6094], [6096, 6096, 6117, 6117, 6325], [6327, 6327, 6349, 6349, 6778], [6780, 6780, 6817, 6817, 7029], [7031, 7031, 7066, 7066, 8885], [8887, 8887, 8944, 8944, 9816]]}
{"id": "MllGWN", "name": "Funky Triangles", "author": "SexyEvilGenius", "description": "Was looking for method to check if point is inside triangle. Shadertoy is best place to check this works. Code it, automate it, crashtest it! B-)", "tags": ["triangle", "random", "vector"], "likes": 6, "viewed": 1284, "date": "1422261408", "time_retrieved": "2024-06-20T18:16:09.802094", "image_code": "// Constant parameters. Play with that numbers;\nconst float SPEED = 1.0;\nconst float TRESHOLD = 40.0;\nconst float SIZE = 3.;\nconst int COUNT = 24; // Remember: amount of triangles is COUNT^2-1!;\n\n// Initializing main variables;\nvec2 uv = vec2(0.0);\nvec3 finalColor = vec3(0.0);\nvec3 rndColor = vec3(0.0);\nfloat time = 0.0;\nvec2 rnd1, rnd2, rnd3;\nvec2 seed = vec2(0, 0);\nfloat centerMask = 0.0;\nstruct Triangle { vec2 a, b, c; };\nTriangle rndTriangle;\n\n// Simple PRNG;\nvec2 rand(vec2 co, bool isForColor){\n    float x = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    float y = fract(sin(dot(co.xy ,vec2(65.13214,24.6543))) * 123124.43225);\n    \n\tif(isForColor) return vec2(x,y); \t\t// For color number must be in 0..1 range...\n    else return (vec2(x,y)-vec2(0.5))*SIZE;\t// but for coordinates it can be any number;\n}\n\n// Thats what all this for. Function to check is point inside triangle or not;\nvec3 DrawTriangle(Triangle tr, vec3 color) {\n    float N1 = (tr.b.y-tr.a.y)*(uv.x-tr.a.x) - (tr.b.x-tr.a.x)*(uv.y-tr.a.y); \n\tfloat N2 = (tr.c.y-tr.b.y)*(uv.x-tr.b.x) - (tr.c.x-tr.b.x)*(uv.y-tr.b.y); \n\tfloat N3 = (tr.a.y-tr.c.y)*(uv.x-tr.c.x) - (tr.a.x-tr.c.x)*(uv.y-tr.c.y);\n    float result = abs(sign(N1) + sign(N2) + sign(N3));\n    \n    if (result == 3.) result = 1.;\t\t\t// Inside. All N's have same sign;\n    //else if (result < 3.) result = 0.; \t// On edge. One or more N's == 0. *Meanless in my case*;\n    else result = 0.;\t\t\t\t\t\t// Outside. Any other case;\n    return (result*color);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.-1.;\t\t\t\t\t\t\t// Remap to center;\n    time = ((iTime/50000000.)*SPEED);\n    \n    for (int i = 0; i < COUNT; i++) {\n        for(int j = 0; j < COUNT; j++) {\n            seed = vec2(i, j);\n            \n            rnd1 = rand(seed+time, false);\n            rnd2 = rand(seed*rnd1+time, false);\n            rnd3 = rand(seed*rnd1*rnd2+time, false);\n            rndTriangle = Triangle(rnd1, rnd2, rnd3);\n            \n            rnd1 = rand(rnd1, true); \n            rnd2 = rand(rnd2, true); \n            rnd3 = rand(rnd3, true);\n            rndColor = vec3(rnd1.y, rnd2.y, rnd3.y);\n            \n            centerMask = (3.-distance(uv, vec2(0.0,0.0))*2.)*TRESHOLD; // Masking non-constant PRNG-generated numbers density; \n            \n            finalColor += DrawTriangle(rndTriangle, rndColor)/centerMask;\n        }\n    }\n    \n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MllGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[452, 468, 504, 504, 831], [833, 912, 956, 956, 1502], [1503, 1503, 1560, 1560, 2472]]}
{"id": "Mls3W8", "name": "[2TC 15]Dancing curves", "author": "guil", "description": "test", "tags": ["fractal", "2tweets", "2tc15"], "likes": 8, "viewed": 364, "date": "1421777857", "time_retrieved": "2024-06-20T18:16:09.802404", "image_code": "void mainImage( out vec4 c, in vec2 w )\n{\n\t\t\n\tfloat f = 1.,g = f,t = iTime;\n\tvec2 p = 2.*w/iResolution.y-1.5,z = p,k = vec2(cos(t),sin(3.2*t));\n\n\t\n\tfor( int i=0; i<32; i++ ) \n\t{\n\t\t\t\t   \n\t\tz = vec2( z.x*z.x-z.x*z.y, z.x/z.y ) - p*k;\n\t\tf = min( f, abs(dot(z-p,z-k) ));\n\t\tg = min( g, dot(z,z));\n\t}\n\t\n\tf = log(f)/9.;\n\n\tc = abs(vec4(log(g)/8.,f*f,f*f*f,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 355]]}
{"id": "MlsGD7", "name": "Layers Of Plasma", "author": "digorydoo", "description": "Simple 2d effect.", "tags": ["plasma2dfake3d"], "likes": 4, "viewed": 197, "date": "1422697961", "time_retrieved": "2024-06-20T18:16:09.802404", "image_code": "// this shader was written from scratch by digorydoo, 2015.\n\nfloat plasma (vec2 p, float t)\n{\n    return clamp (sin (p.x*1.9 + cos (p.y*4.2 + t))\n                + cos (p.y*1.9 - sin (p.x*4.2 + t)) \n                + 0.3, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy / iResolution.xy) - vec2 (0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    \n    float grey = plasma (uv, t);\n    float prox = 1.0;\n    float alpha = 1.0;\n    \n    for (int i = 0; i < 5; i++)\n    {\n        if (grey < 0.5) { alpha *= 0.5; prox *= 0.8; }\n        uv = uv*1.7 + vec2 (sin (t), 0.0);\n        t *= 0.7;\n        grey = mix (grey, grey*plasma (uv, t), alpha);\n    }\n    \n\tfragColor = 2.0 * grey * mix (\n        vec4 (1.0, 1.0, 0.5, 1.0), vec4 (0.15, 0.25, 0.4, 1.0), prox);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 61, 93, 93, 234], [236, 236, 293, 293, 836]]}
{"id": "MlsGDH", "name": "icy mountains", "author": "public_int_i", "description": "dirty basic terrain marcher with shadows and reflections\n", "tags": ["procedural", "3d", "ray", "terrain", "heightmap", "mountains", "marcher", "icy"], "likes": 2, "viewed": 393, "date": "1421938419", "time_retrieved": "2024-06-20T18:16:09.802404", "image_code": "\nvec3 lightDir = normalize(vec3(4.0,3.0,4.0));\nvec4 lightColor = vec4(0.7);\nvec4 lightAmbient = vec4(0.2);\n\nconst vec4 iceColor = vec4(0.9,0.92,1.0,1.0);\n\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\nvec3 rayPos,rayDir;\n\nvec3 calcNormal(vec3 p1, vec3 p2, vec3 p3) {\n    vec3 u = p2-p1;\n    vec3 v = p3-p1;\n    \n    vec3 normal = vec3(u.y*v.z-u.z*v.y,\n                       u.z*v.x-u.x*v.z,\n                       u.x*v.y-u.y*v.x);\n    \n    return normalize(normal);\n}\n\nfloat getHeight(float x, float z) {\n    return max(-5.0,\n           sin(x+sin(z/4.0))*0.1 + sin(z/2.4)*2.0 +\n           sin(x/18.0)*10.0 + cos(z/18.0+sin(x/14.0))*12.0\n               );\n}\n\n\nconst float fogStart = 0.5;\nconst float viewDist = 200.0;\nconst float lowTest = 5.0;\nconst float highTest = 0.1;\nconst int lowViewTimes = int(viewDist/lowTest);\nconst int highViewTimes = int(lowTest/highTest);\n\nconst vec4 background = vec4(126.0/255.0,192.0/255.0,238.0/255.0,1.0);\n\n\n\nstruct RayHit {\n    vec3 normal;\n    bool isHit,calcNormal;\n};\n\nvoid hightrace(inout RayHit hit) {\n   for (int k = 0; k < highViewTimes; k++) {\n       rayPos += rayDir*highTest;\n                \n       if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n           if (hit.calcNormal) {\n             hit.normal = calcNormal(vec3(0.0,getHeight(rayPos.x,rayPos.z),0.0),\n                                                 vec3(0.0,getHeight(rayPos.x,rayPos.z+0.1),+0.1),\n                                                 vec3(0.1,getHeight(rayPos.x+0.1,rayPos.z),0.0));\n           }\n               \n             rayPos -= rayDir*highTest;\n             return;\n       }\n   }\n}\n\nvoid lowtrace(inout RayHit hit) {\n    hit.isHit = false;\n    \n    if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n        return;\n    }\n    \n    for (int i = 0; i < lowViewTimes; i++) {\n        rayPos += rayDir*lowTest;\n        \n        if (rayPos.y < getHeight(rayPos.x,rayPos.z)) {\n            rayPos -= rayDir*lowTest;\n                        \n\t\t\thightrace(hit);\n            hit.isHit = true;\n            return;\n        }\n    }\n}\n\n\nvec4 scenePixel() {\n    RayHit hit;\n    hit.calcNormal = true;\n    lowtrace(hit);\n    if (hit.isHit) {\n        \n        vec3 oldRayPos = rayPos;\n        vec3 oldRayDir = rayDir;\n        \n        float fogAm = (length(cameraPosition-rayPos)/viewDist);\n        if (fogAm >= fogStart) {\n            fogAm -= fogStart;\n            fogAm = (fogAm/(1.0-fogStart));\n        } else {\n            fogAm = 0.0;\n        }\n        \n        vec4 samp = texture(iChannel0,rayPos.xz*0.1);\n        \n        //snow\n        if (rayPos.y > 6.0) {\n            if (rayPos.y > 12.0) {\n                samp = texture(iChannel1,rayPos.xz*0.1)*1.7;\n            } else {\n            \tsamp = mix(samp,\n                           texture(iChannel1,rayPos.xz*0.1)*1.7,\n                           (rayPos.y-6.0)/6.0);\n            }\n        } else {\n            //ice\n            if (rayPos.y < -4.6) {\n                samp = texture(iChannel1,rayPos.xz*0.1);\n                hit.normal = reflect(hit.normal,((samp.xyz*2.0)-vec3(1.0))*0.6);//just take a normal from the texture, since we dont have access to a normal map\n                samp *= iceColor;\n                \n                \n                rayDir = reflect(rayDir,hit.normal);\n                \n                \n                RayHit reflHit;\n                reflHit.calcNormal = true;\n                lowtrace(reflHit);\n                \n                if (reflHit.isHit) {\n                    vec4 hitCol = texture(iChannel0,rayPos.xz*0.1);//calc lighting color/texture color of hit\n                    if (rayPos.y > 6.0) {\n                        if (rayPos.y > 12.0) {\n                           hitCol = texture(iChannel1,rayPos.xz*0.1)*1.7;\n                        } else {\n            \t\t\t\thitCol = mix(hitCol,\n                           texture(iChannel1,rayPos.xz*0.1)*1.7,\n                           (rayPos.y-6.0)/6.0); \n                        }\n                    }\n                    hitCol = lightAmbient*hitCol+\n                             max(dot(lightDir,reflHit.normal),0.0)*lightColor*hitCol;\n                     \n                    samp = mix(samp,hitCol,0.4);\n                } else {\n                    \n                    samp = mix(samp,background,0.4);\n                }\n                \n                rayPos = oldRayPos;\n                rayDir = oldRayDir;\n            }\n        }\n        \n        \n        //calculate lighting\n        rayDir = lightDir;\n        \n        RayHit lightHit;\n        lightHit.calcNormal = false;\n        lowtrace(lightHit);\n        \n        if (lightHit.isHit) {\n            return mix(lightAmbient*samp, background,fogAm);\n        } else {\n            float am = max(dot(lightDir,hit.normal),0.0);\n            if (oldRayPos.y < -4.6) {//is ice, do specular\n                return mix(lightAmbient*samp + am*lightColor*samp + pow(max(0.0,dot(reflect(-lightDir, hit.normal), oldRayDir)),8.0)*vec4(0.7), background, fogAm);\n            } else {\n            \treturn mix(lightAmbient*samp + am*lightColor*samp, background, fogAm);\n            }\n        }\n    } else {\n      return background;\n    }\n}\n\n\nconst float cameraMoveSpeed = 0.05;\n\nconst vec2 center = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //calculate camera\n    cameraPosition = vec3(sin(iTime*cameraMoveSpeed)*180.0,15.0,cos(iTime*cameraMoveSpeed)*180.0);\n    cameraDirection = normalize(-cameraPosition);\n    cameraPosition.y = getHeight(cameraPosition.x,cameraPosition.z)+15.0;\n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-center;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    cameraUp = cross(cameraRight,cameraDirection);\n    \n    //calculate perspective ray from uv and camera vectors\n    vec3 rPoint = cUv.x*cameraRight +\n                  cUv.y*cameraUp +\n        \t\t  cameraPosition + cameraDirection;\n    \n  \trayDir = normalize(rPoint-cameraPosition);\n    rayPos = cameraPosition;\n    \n    \n\tfragColor = scenePixel();\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[262, 262, 306, 306, 509], [511, 511, 546, 546, 698], [1050, 1050, 1084, 1084, 1650], [1652, 1652, 1685, 1685, 2084], [2087, 2087, 2106, 2106, 5183], [5259, 5259, 5316, 5339, 6093]]}
{"id": "MlsGW8", "name": "Iso Surface", "author": "iapafoto", "description": "isosurface volume rendering ", "tags": ["isosurface", "isoline"], "likes": 46, "viewed": 1757, "date": "1421769097", "time_retrieved": "2024-06-20T18:16:11.002403", "image_code": "#define BICUBIC\n#define SHADOWS  \n//#define COLOR_GRADIENT\n    \n#define time iTime\n#define resolution iResolution\n\n\nconst float MAX_STEPS = 1024.;\nconst float SX = 76.;\nconst float SY = 48.;\nconst float SZ = 80.;\n\nfloat NB_X = floor(MAX_STEPS/SX);\n\nconst float dval = .05;    // distance entre 2 valeurs significatives\nconst float dd = 1.;       // pas d'avancement du rendu volumique\nconst float _density = 1.; // densitee de la matiere\n\nconst float MinVal = .3,  \n            MaxVal = .5;\n\nvec3 Bounds;\n\n\nfloat hash1(float seed) {\n    return fract(sin(seed)*43758.5453123);\n}\n\n// -------------------------------------------------------\n\nbool box(vec3 ro, vec3 rd, vec3 sz, out float tN, out float tF, out vec3 n) {\n    vec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, b = a+k;\n    n = -sign(rd) * step(a.yzx,a.xyz) * step(a.zxy,a.xyz);\n    tN = max(max(a.x,a.y),a.z);\n    tF = min(min(b.x,b.y),b.z);\n    return tN<tF;\n}\n\n// - Bicubic --------------------------------------------------------\n// [iq: https://www.shadertoy.com/view/XsSXDy]\n\nvec4 BS_A = vec4(3.0,  -6.0,   0.0,  4.0 ) /  6.;\nvec4 BS_B = vec4(-1.0,   6.0, -12.0,  8.0 ) /  6.;\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nfloat spline(float x, float c0, float c1, float c2, float c3 ) {\n    return c0*dot( BS_B, powers(x + 1.)) + c1*dot( BS_A, powers(x      )) +\n           c2*dot( BS_A, powers(1. - x)) + c3*dot( BS_B, powers(2. - x));\n}\n\n#define SAM(a,b) textureLod(iChannel0, (i+vec2(a,b)+0.5)/res,0.).g\n\nfloat texture_Bicubic(sampler2D tex, vec2 t) {\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5, f = fract(p), i = floor(p);\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n#ifdef BICUBIC\nfloat valueAt(in vec3 p) {\n    p*= 2.2;\n    float cval0 = texture_Bicubic(iChannel0, .6*p.xy/MAX_STEPS);\n    float cval1 = texture_Bicubic(iChannel0, .5*p.xz/MAX_STEPS);\n    // Values\n    float v0 = sqrt(cval0*cval1);  // true value = v0*255.\n    return clamp(.1+.3*abs(cos(iTime*.1)) + .5*v0/*.5*mix(v0, v1, fract(p.z))*/,0.,1.);\n}\n#else\nfloat valueAt(in vec3 p) {\n    p*= 1.8;\n    vec4 cval0 = textureLod(iChannel0, .6*p.xy/MAX_STEPS,0.);\n    vec4 cval1 = textureLod(iChannel0, .5*p.xz/MAX_STEPS,0.);\n    // Values\n    float v0 = sqrt(cval0.g*cval1.b) + (cval0.r*cval1.g);  // true value = v0*255.\n    return clamp(.1+.3*abs(cos(iTime*.1)) + .5*v0/*.5*mix(v0, v1, fract(p.z))*/,0.,1.);\n}\n#endif\n\n// ------------------------------------------------------------------\n\nvec3 normalAt(in vec3 p) {\n    vec2 e = vec2(0.1, -0.1); \n    return normalize(e.xyy * valueAt(p + e.xyy) + e.yyx * valueAt(p + e.yyx) + e.yxy * valueAt(p + e.yxy) + e.xxx * valueAt(p + e.xxx));;\n}\n\nconst vec2 ep2 = vec2(.5,-.5); \nvec3 gradAt(in vec3 p) {\n    return (ep2.xyy * valueAt(p + ep2.xyy) + ep2.yyx * valueAt(p + ep2.yyx) + ep2.yxy * valueAt(p + ep2.yxy) + ep2.xxx * valueAt(p + ep2.xxx));;\n}\n\n\n\n// -----------------------------------------------------------------\n\n\n\nfloat doShadow(vec3 ro, vec3 rd, float len) {\n    vec3 p2,n;\n    float dmin, dmax;\n    bool intersect = box(ro, rd, Bounds, dmin, dmax, n);\n    if (intersect) {   \n        float val,valId,d=min(.25,dmax); //, d=.5+.5*dd*hash1(ro.x+ro.y+ro.z);\n        // suivre cette direction et ajouter un truc a ao si on rtouve un obstacle avant dMax\n        for(int k=0;k<40; k++) {\n             if (d>=dmax) break;\n            p2 = ro + min(d,dmax) *rd;\n            val = valueAt(p2);\n            if (val >= MinVal && val < MaxVal) {\n                // on a rencontrÃ© un obstacle,\n                return clamp(mix(0.,1.,(min(d,dmax)/len)),0.,1.); // plus il est pres plus il a de l'influence\n            }\n            d+=.25*dd;\n\n        }\n    }\n    return 1.;\n}\n\n\nvec3 doShading(vec3 rd, vec3 pos, vec3 nor, vec3 lig, vec3 col, float t) {\n\n    vec3 ref = reflect( rd, nor );\t        \n    float occ = 1.; \n    float amb = .9;\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    \n#ifdef SHADOWS\n    dif *= doShadow(pos, lig, 10. );\n#endif\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n    brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.4;\n    return col*brdf; //sqrt(brdf);\n}\n\nvec3 heatmapGradient(in float t) {\n    return clamp((pow(t, 1.5) * .8 + .2) * vec3(smoothstep(0., .35, t) + t * .5, smoothstep(.5, 1., t), max(1. - t * 1.7, t * 7. - 6.)), 0., 1.);\n}\n\nvec3 getColor(float val) {\n#ifndef COLOR_GRADIENT    \n    val = floor(val/dval)*dval;                \n#endif    \n    return heatmapGradient(1.5*val);\n}\n\n// -------------------------------------------------------------------------------\n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw = normalize(ro),\n         rt = normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw), fw);\n}\n\nvec2 globalFragCoord;\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return LookAt(cp-ro, vec3(0,1,0)) * normalize(vec3((2.*globalFragCoord.xy-resolution.xy)/resolution.y, 5.));\n}\n\n// -------------------------------------------------------------------------------\n\nfloat isoline(float val, vec3 p, vec3 n, float pas, float tickness) {\n    vec3 grad = gradAt(p);\n    grad -= n*dot(grad,n);\n    float v = abs(mod((val)+pas*.5, pas)-pas*.5)*(resolution.x*ep2.x)/(100.*length(grad)*tickness);\n    float v1 = abs(val-MinVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);\n    float v2 = abs(val-MaxVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);\n    return smoothstep(.1,.9, v)*smoothstep(.3,.7, v1)*smoothstep(.3,.7, v2);\n}\n\n\n// -----------------------------------------------------------------\n\n\nfloat preciseSurface(vec3 ro, vec3 rd, float val, float dmin, float dmax, float sig) {\n    float dm = dmin;\n    val *= sig;\n    for (int j=0; j<6;j++) {\n       dm = (dmin + dmax)*.5;  // on dÃ©termine l'indice de milieu\n       if (valueAt(ro+rd*dm)*sig > val) dmax = dm;  //si la valeur qui est Ã  la case \"im\" est supÃ©rieure Ã  la valeur recherchÃ©e, l'indice de fin \"ifin\" << devient >> l'indice de milieu\n       else dmin = dm;               //sinon l'indice de dÃ©but << devient >> l'indice de milieu et l'intervalle est de la mÃªme faÃ§on restreint\n    }\n    return dm;  \n}\n\nfloat findPosOfVal(vec3 ro, vec3 rd, float val, float dmin, float dmax, float dd2) {\n    vec3 p = ro+rd*dmin;\n    float v, d, sig = sign(val - valueAt(p));\n    d = dmin+dd2+hash1(rd.y*(p.x+p.y+p.z));\n\n    for (int i=0; i<100; i++) {\n        v = valueAt(ro+rd*d);\n    \tif ((d>=dmax+dd2) || (sig*(v-val)>0.)) \n            break;\n        d += dd2;\n    }\n    return (sig*(v-val)>0.) ? preciseSurface(ro, rd, val, d-dd, d, sig) : d;\n}\n\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    globalFragCoord = fragCoord;\n    Bounds = vec3(.8*SX, .7*SY, abs(.5)*SZ);\n  \n    vec2 q = fragCoord.xy/resolution.xy;\n\n    vec3 lightDir = -normalize(vec3(1.,-5.,6.5));\n    \n    vec3 ro = 180.*vec3(cos(.5*time-3.*iMouse.x/resolution.x), cos(.5*time*.3), sin(.5*time-3.*iMouse.x/resolution.x)*sin(.5*time*.3));\n    vec3 rd = RD(ro, vec3(0));\n    \n    vec4 cSum = vec4(0);\n    vec3 n,p;\n    \n    float d, dmin, dmax,\n          val, valIdMem, valId, v0;\n       \n    vec3 col = vec3(.22,.26,.28) * pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);\n\n    if (box(ro, rd, Bounds, dmin, dmax, n) && dmin>0.) {\n       p = ro+rd*(dmin);\n       v0 = valueAt(p);\n\n       if (v0 >= MinVal && v0 <= MaxVal) {\n           col = doShading(rd,p,n,lightDir, getColor(v0), d);\n           col = col*isoline(v0, p, n, dval, 1.);\n       } else {\n           val = (v0<=MinVal) ? MinVal : MaxVal;\n           d = findPosOfVal(ro, rd, val, dmin, dmax, dd);\n\t\t   if (d<dmax) {\n            \tp = ro+rd*d;\n            \tn = sign(v0-MinVal)*normalAt(p);\n           \t\tcol = doShading(rd,p,n, lightDir, getColor(val-.02), d);\n           }\n     \t}\n    }\n\n   \tfragColor = vec4(col,1);  \n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[276, 507, 532, 532, 577], [579, 639, 716, 716, 937], [939, 1158, 1182, 1182, 1217], [1219, 1219, 1283, 1283, 1435], [1505, 1505, 1551, 1551, 1993], [2708, 2779, 2805, 2805, 2976], [3010, 3010, 3034, 3034, 3181], [3185, 3257, 3302, 3302, 4010], [4013, 4013, 4087, 4087, 4676], [4678, 4678, 4712, 4712, 4860], [4862, 4862, 4888, 4888, 5013], [5015, 5099, 5135, 5135, 5244], [5268, 5268, 5301, 5301, 5416], [5418, 5502, 5571, 5571, 5968], [5971, 6042, 6128, 6128, 6637], [6639, 6639, 6723, 6723, 7068], [7073, 7073, 7130, 7130, 8276]]}
{"id": "MlX3D8", "name": "purple under mesh", "author": "crowding", "description": "I had an idea for a fabric print to put under a mesh jersey and wrote this as a test.", "tags": ["2d", "moire", "motion"], "likes": 7, "viewed": 260, "date": "1421743205", "time_retrieved": "2024-06-20T18:16:11.002403", "image_code": "const mat2 axes = mat2(2., 2., 1., -1);\nconst vec3 bfreq = vec3(-0.618, 1.618, 2.618) * 0.3; \nconst mat2 bamp = mat2(1., 1., 1., -1.) * 0.1;\nconst vec3 mfreq = vec3(2.618, 0.618, 1.618) * 0.3; \nconst mat2 mamp = mat2(1., 0., 0., 1.) * 0.1;\nconst mat4 palette = mat4(4.,1.,5.,5.,\n                          5.,1.,4.,5.,\n                          1.,2.,5.,5., \n                          2.,1.,5.,5.\n                          )/5.;\n\nvec2 grid(vec2 uv, int repeat) {\n return floor(vec2(mod(axes * uv * float(repeat), float(repeat))));\n}\n\nvec2 wave(vec2 base, vec3 freq, mat2 amplitude) {\n    float z = dot(vec3(base, iTime), freq);\n    return vec2(sin(z), cos(z)) * amplitude + base;\n}\n\nvec4 plaid(vec2 uv) {\n \tbvec2 col = bvec2(grid(uv, 2));\n\tbool margin = any(bvec2(step(grid(uv*2., 6), vec2(2))));\n    if (margin)\n        return vec4(0);\n    else \n        if (col.x)\n        if (col.y) return palette[0];\n        else return palette[1];\n        else if (col.y)\n            return palette[2];\n            else return palette[3];\n}\n\nfloat mask(vec2 uv) {\n \tbvec2 x = bvec2(grid(uv, 3));\n    return float(!any(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y) * 10.;\n    vec4 back = plaid(wave(uv, bfreq, bamp));\n\tfloat mask = mask(wave(uv, mfreq, mamp));\n    fragColor = back * mask;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[429, 429, 461, 461, 531], [533, 533, 582, 582, 680], [682, 682, 703, 703, 1027], [1029, 1029, 1050, 1050, 1111], [1113, 1113, 1170, 1170, 1357]]}
{"id": "MlX3W8", "name": "sierpinski_twister", "author": "Mana", "description": "basic fractal with some animation.\nMouse y zooms, mouse x rotates", "tags": ["3d", "fractal"], "likes": 3, "viewed": 259, "date": "1421409559", "time_retrieved": "2024-06-20T18:16:11.008487", "image_code": "\n#define MAX_RAY_STEPS 80\n#define MAX_RAY_DISTANCE 100.0\n#define DISTANCE_EPSILON 0.012\n#define PI 3.141592\n\n\nvec3 tonemap(vec3 c)\n{\n    return pow(c, vec3(2.4));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    float ca = cos(angle);\n    float ica = 1.0 - ca;\n    float sa = sin(angle);\n    \n\treturn mat3(ca + axis.x*axis.x * ica, axis.x*axis.y*ica - axis.z*sa, axis.x*axis.z*ica + axis.y*sa,\n                axis.y*axis.x*ica + axis.z*sa, ca + axis.y*axis.y*ica, axis.y*axis.z*ica - axis.x*sa,\n                axis.z*axis.x*ica - axis.y*sa, axis.z*axis.y*ica + axis.x*sa, ca + axis.z*axis.z*ica);\n\n}\n //[0->1->0]\nfloat linearInterval(vec2 interval, float t)\n{\n    float intervalC = interval.x +  (interval.y - interval.x) * 0.5;\n    return step(t, intervalC) * smoothstep(interval.x, intervalC, t) + step(intervalC,t) * (1.0 - smoothstep(intervalC, interval.y, t));\n     \n}\n\nvec3 fold(vec3 p, vec4 plane)\n{\n\treturn p - 2.0 * min(0.0, dot(p, plane.xyz) + plane.a) * plane.xyz;    \n}\n\nfloat opComplement(float a, float b)\n{\n\treturn max(-a,b);    \n}\n\nvec2 estimateDistance(vec3 p, float phase)\n{\n    \n    const float scale = 2.0;\n    const int n = 16;\n    const vec2 rotInterv = vec2(0.08,1.92);\n    const vec2 transInterval = vec2(0.9, 1.1);\n    float repr = pow(scale, -float(n));\n    const float size = 3.0;\n    \n    //calculate current point rotation\n    float t = linearInterval(rotInterv, phase);\n   \tmat3 rot = rotationMatrix(normalize(vec3(1.2, 0.5, 3.0)), PI * 0.6 * t) \n        * rotationMatrix(normalize(vec3(0.2, 0.5, 0.0)), PI * 0.4 * t);\n    \n    //fractal1\n    vec3 fp1 = p;\n    fp1.xz = -abs(fp1.xz);\n    fp1.y = abs(fp1.y);\n\n\tfor( int i = 0; i < n; ++i)\n    {\n        \n        fp1 = rot * fp1;\n    \tfp1 = fold(fp1, vec4(0.7, 0.7, 0.0, size));\n        fp1 = fold(fp1, vec4(0.7, 0.0, -0.7, size));\n        fp1 = fold(fp1, vec4(0.0, -0.7,  0.7, size));\n        \n\n        fp1 = fp1*scale;\n    }\n\t\n    //fractal2 (sierpinski tetrahedrons)     \n    vec3 fp2 = p;\n    fp2 = -abs(fp2);\n\n\tfor( int i = 0; i < n; ++i)\n    {\n        \n        fp2 = rot * fp2;\n    \tfp2 = fold(fp2, vec4(0.7, 0.7, 0.0, size));\n        fp2 = fold(fp2, vec4(0.7, 0.0, 0.7, size));\n        fp2 = fold(fp2, vec4(0.0, 0.7, 0.7, size));\n        \n\n        fp2 = fp2*scale;\n    }\n    \n    //merge\n    t = smoothstep(transInterval.x, transInterval.y, phase);\n    float fd1 = length(fp2) * repr;\n\tfloat fd2 = opComplement( length(p) - 0.6,length(fp1) * repr); \n    vec2 fd = vec2(t * fd1 + (1.0 - t)*fd2, 0.0);\n    \n    \n    \n    return fd;              \n}\n\nvec3 calculateNormal(vec3 p, float phase)\n{\n    const vec3 e = vec3( 0.002, 0.0, 0.0);\n    \n    \n\treturn normalize(vec3( estimateDistance(p + e,phase).x - estimateDistance(p - e,phase).x,\n                 estimateDistance(p + e.yxz, phase).x - estimateDistance(p - e.yxz, phase).x,\n               estimateDistance(p + e.zyx, phase).x - estimateDistance(p - e.zyx, phase).x));    \n}\n\n\n\n\nvec3 raymarch(vec3 ro, vec3 rd, float phase)\n{\n\tfloat d = 0.0;\n    float didHit = -1.0;\n    float lastId = -1.0;\n    int steps;\n    for(int i = 0; i < MAX_RAY_STEPS; ++i)\n    {\n        \n    \tvec2 dist = estimateDistance( ro + rd * d, phase);\n        if(dist.x < DISTANCE_EPSILON)\n        {\n            \n            didHit = 1.0;\n        \tbreak;\n        }\n        d += dist.x;\n        lastId = dist.y;\n        if(d > MAX_RAY_DISTANCE)\n        {\n            didHit = -1.0;\n            d = MAX_RAY_DISTANCE;\n            break;\n        }\n        steps = i;\n    }\n    return vec3(d * didHit, lastId, float(steps));\n}\n\n\n\nvec3 calculateColor(vec3 ro, vec3 rd, float phase)\n{\n    vec3 g1 = vec3(0.9, 0.4, 0.1);\n    vec3 g2 = vec3(0.1, 0.7, 0.3);\n    \n    const vec3 fc = vec3(0.4, 0.4, 0.4);\n    \n\tvec3 res = raymarch(ro, rd, phase);\n\n   \n    vec3 c = vec3( 0.0, 0.0, 0.0);\n    if(res.x > 0.0)\n    {\n        vec3 p = ro + rd * res.x;\n    \tvec3 n = calculateNormal(p, phase);\n\t\tc += clamp(0.0, 1.0, dot(n, -rd)) * fc;\n    }\n    \n    //add glow\n    float t = smoothstep(0.0, 2.0, phase);\n    vec3 g = mix(g1,g2,t);\n    c +=  (res.z / float(MAX_RAY_STEPS)) * g * 3.5;\n    \n    \n\treturn c;    \n}\n\n\n\nvec3 viewCoordinatesToRayDir(vec3 eyeDir, vec3 eyeUp,  float fovy, float near, float aspect, vec2 screen_coord) \n{\n\n\tfloat projY = tan(fovy * 0.5) * 2.0 * near;\n\tfloat projX = projY * aspect;\n  \n\n\tvec3 right = normalize( cross(eyeDir, eyeUp) );\n  \n\n\tfloat dx = projX * (screen_coord.x - 0.5);\n\tfloat dy = projY * (screen_coord.y - 0.5);\n  \n\treturn normalize( eyeDir * near + dx * right + dy * eyeUp);\n}\n\nvec3 sphericalToCartesian(float polar, float azimuth, float r)\n{\n\tfloat sinp = sin(polar);\n    float sina = sin(azimuth);\n    float cosp = cos(polar);\n    float cosa = cos(azimuth);\n    \n    return vec3( r * cosa * sinp , r * sina * sinp,  r * cosp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vp = fragCoord.xy / iResolution.xy;\n    \n    vec2 mp = iMouse.xy / iResolution.xy;\n   \n    float phase = cos(iTime * 0.2 + PI * 0.5) + 1.0;\n    \n    float camRad = mix(3.3, 12.0, 1.0 - mp.y);\n    \n    float azimuth = mp.x * 2.0 * PI + PI*0.5;\n    float polar = 0.6 * PI;\n    \n    vec3 eyePos = sphericalToCartesian(polar,azimuth,camRad);\n    vec3 eyeDir = normalize(-eyePos);\n    vec3 eyeUp = normalize(sphericalToCartesian(polar+ 0.5 * PI, azimuth , camRad));\n    float near = 0.1;\n    float fovy = radians(60.0);\n    float aspect =iResolution.x / iResolution.y;\n    \n    \n    vec3 rd = viewCoordinatesToRayDir(eyeDir, eyeUp, fovy, near, aspect, vp);\n    vec3 ro = eyePos;\n    \n    fragColor = vec4(tonemap(calculateColor(ro,rd,phase)), 1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[110, 110, 132, 132, 164], [166, 166, 211, 211, 605], [607, 619, 665, 665, 879], [881, 881, 912, 912, 987], [989, 989, 1027, 1027, 1052], [1054, 1054, 1098, 1098, 2536], [2538, 2538, 2581, 2581, 2919], [2924, 2924, 2970, 2970, 3535], [3539, 3539, 3591, 3591, 4107], [4111, 4111, 4225, 4225, 4513], [4515, 4515, 4579, 4579, 4767], [4769, 4769, 4826, 4826, 5579]]}
{"id": "MlX3Wr", "name": "Galvanize Tunnel", "author": "Virgill", "description": "Tunnel-Effect from 8K Intro Galvanize / Alcatraz               Full Intro here:\nhttp://www.pouet.net/prod.php?which=63821\nhttps://www.youtube.com/watch?v=z5cFJryE_fc\n", "tags": ["3d", "raymarching", "demoscene", "kalibox"], "likes": 83, "viewed": 4863, "date": "1420725215", "time_retrieved": "2024-06-20T18:16:12.281278", "image_code": "// Galvanize Tunnel\n// From Alcatraz 8K intro Galvanize\n\n// http://www.pouet.net/prod.php?which=63821\n// https://www.youtube.com/watch?v=z5cFJryE_fc\n\n\n// Jochen \"Virgill\" Feldkoetter\n\n//*****************************************************\n\n\nfloat blend =0.0; float scene = 35.;\nfloat d = 0.0; float m = 0.0;\nfloat kalitime;\nfloat depth = 0.0; \nfloat prec =0.002;\nvec4 orbitTrap = vec4(0.0);\n\n\n// Rotate\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2; p.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2; p.z = z2;\n\treturn p;\n}\n\nvec3 rotZaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\n\tp.x = x2; p.y = y2;\n\treturn p;\n}\n\n\n// Rand\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Polyomial smooth min (IQ)\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Length\nfloat length2(vec2 p) \n{ \n  \treturn dot(p, p); \n}\n\n// Worley effect \nfloat worley(vec2 p) \n{\n\tfloat d = 1.;\n\tfor (int xo = -1; xo <= 1; ++xo)\n\tfor (int yo = -1; yo <= 1; ++yo) \n    {\n\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\td = min(d, length2(p - tp - vec2(rand1(tp))));\n\t}\n\treturn 3.*exp(-4.*abs(2.*d - 1.));\n}\n\nfloat fworley(vec2 p) \n{\n\treturn sqrt(sqrt(sqrt(worley(p*32. + 4.3 + iTime*.250) * sqrt(worley(p * 64. + 5.3 + iTime * -.125)) * sqrt(sqrt(worley(p * -128. +7.3))))));\n}\n\n\n\n\n\n// Kalibox (Kali / Fractalforums.com)\nfloat Kalibox(vec3 pos) \n{\n\tfloat Scale = 1.84;\t\t\t\t\t\t\n\tint Iterations = 14;\t\t\t\n\tint ColorIterations = 3;\t\t\n\tfloat MinRad2 = 0.34;\t\n\tvec3 Trans = vec3(0.076,-1.86,0.036);\t\t\t\n\tvec3 Julia = vec3(-0.66,-1.2+(kalitime/80.),-0.66);\t\n\tvec4 scale = vec4(Scale, Scale, Scale, abs(Scale)) / MinRad2;\n\tfloat absScalem1 = abs(Scale - 1.0);\n\tfloat AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations));\n    vec4 p = vec4(pos,1), p0 = vec4(Julia,1); \n\tfor (int i=0; i<14; i++)\n\t\t{\n\t\t\tp.xyz=abs(p.xyz)+Trans;\n\t\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\t\tp *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0); \n\t\t\tp = p*scale + p0;\n\t\t\tif (i<ColorIterations) orbitTrap = min(orbitTrap, abs(vec4(p.xyz,r2)));\n\t\t}\n\treturn (    (length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters    );\n}\n\n\n\n// Plane\nfloat sdPlane(in vec3 p) \n{\n\treturn p.y+(0.025*sin(p.x*10.  +1.4*iTime  ))+(0.025*sin(p.z*12.3*cos(0.4-p.x)+  1.6*iTime  ))-0.05;\n}\n\n// Cylinder \nfloat sdCylinder( vec3 p, vec3 c )\n{\n\treturn length(p.xz-c.xy)-c.z;\n}\n\n\n// Map\nfloat map(in vec3 p)\n{\n\torbitTrap = vec4(10.0);\n\td = sdPlane(p);\n\n\tvec3 c = vec3(2.0, 8.0, 2.0);\n\tvec3 q = mod(p-vec3(1.0,0.1*iTime,1.0),c)-0.5*c;\n\tfloat kali = Kalibox(rotYaxis(q,0.04*iTime));\n\tm = max(kali,-sdCylinder(p,vec3(0.0,0.0,0.30+0.1*sin(iTime*0.2))) );\n\n\td = sminPoly (m, d, 0.04); \n   return d;\n}\n\n\n// Normal Calculation\nvec3 calcNormal(in vec3 p) \n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx));\n    return normalize(nor);\n}\n\n// Cast\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt) \n{\n    float precis = prec;\n    float h = precis * 2.0;\n    float t = depth;\n\n    for(int i = 0; i < 122; i++) \n\t{\n        if(abs(h) < precis || t > maxt) break;\n        orbitTrap = vec4(10.0);\n\t\th = map(ro + rd * t);\n        t += h;\n\t}\n    return t;\n}\n\n// Softshadow (IQ)\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) \n{\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 19; i++) \n\t{\n        if(t > maxt) continue;\n\t\torbitTrap = vec4(10.0);\n        h = map(ro + rd * t);\n        sh = min(sh, k * h / t);\n        t += h;\n    }\n    return sh;\n}\n\n\n// Orbit color\nvec3 getColor()\n{\n\tvec3 BaseColor = vec3(0.2,0.2,0.2);\n\tvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\n\tvec4 X = vec4(0.5, 0.6, 0.6, 0.2);\n\tvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\n\tvec4 Z = vec4(0.8, 0.7, 1.0, 0.3);\n\tvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\n    orbitTrap.w = sqrt(orbitTrap.w);\n\tvec3 orbitColor = X.xyz*X.w*orbitTrap.x + Y.xyz*Y.w*orbitTrap.y + Z.xyz*Z.w*orbitTrap.z + R.xyz*R.w*orbitTrap.w;\n\tvec3 color = mix(BaseColor,3.0*orbitColor,OrbitStrength);\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    kalitime = iTime-15.0; \n \tblend=min(2.0*abs(sin((iTime+0.0)*3.1415/scene)),1.0); \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tfloat theta = sin(iTime*0.03) * 3.14 * 2.0;\n    float x = 3.0 * cos(theta);\n    float z = 3.0 * sin(theta);\n\tvec3 ro; \n\n\n\tro = vec3(0.0, 8.0, 0.0001);  \n\n\tvec3 ta = vec3(0.0, 0.25, 0.0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n\n// Render:\n    vec3 col = vec3(0.0);\n    float t = castRay(ro, rd, 12.0);\n\tvec3 pos = ro + rd *t;\n\tvec3 nor = calcNormal(pos);\n\tvec3 lig;\t\n\tlig = normalize(vec3(-0.4*sin(iTime*0.15), 1.0, 0.5));\n\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n\tvec3 color = getColor();\n\tcol = ((0.8*dif+ spec) + 0.35*color);\n\tcol = col*clamp(sh, 0.0, 1.0);\n\n\n// Postprocessing\n\tfloat klang1=0.4;\n\tvec2 uv2=-0.3+2.*fragCoord.xy/iResolution.xy;\n\tcol-=0.20*(1.-klang1)*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\n\tcol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.x*iResolution.x);\t\n\tcol*=.9+0.20*(1.-klang1)*sin(10.*iTime+uv2.y*iResolution.y);\t\n\tfloat Scr=1.-dot(uv2,uv2)*0.15;\n\tvec2 uv3=fragCoord.xy/iResolution.xy;\n\tfloat worl = fworley(uv3 * iResolution.xy / 2100.);\n\tworl *= exp(-length2(abs(2.*uv3 - 1.))); \n\tworl *= abs(1.-0.6*dot(2.*uv3-1.,2.*uv3-1.));\n\tcol += vec3(0.40*worl,0.35*worl,0.25*worl);\n\n// Border    \n\tfloat g2 = (blend/2.)+0.39;\n\tfloat g1 = ((1.-blend)/2.);\n\tif (uv3.y >=g2+0.11) col*=0.0;\n\tif (uv3.y >=g2+0.09) col*=0.4;\n\tif (uv3.y >=g2+0.07) {if (mod(uv3.x-0.06*iTime,0.18)<=0.16) col*=0.5;}\n\tif (uv3.y >=g2+0.05) {if (mod(uv3.x-0.04*iTime,0.12)<=0.10) col*=0.6;}\n\tif (uv3.y >=g2+0.03) {if (mod(uv3.x-0.02*iTime,0.08)<=0.06) col*=0.7;}\n\tif (uv3.y >=g2+0.01) {if (mod(uv3.x-0.01*iTime,0.04)<=0.02) col*=0.8;}\n\tif (uv3.y <=g1+0.10) {if (mod(uv3.x+0.01*iTime,0.04)<=0.02) col*=0.8;}\n\tif (uv3.y <=g1+0.08) {if (mod(uv3.x+0.02*iTime,0.08)<=0.06) col*=0.7;}\n\tif (uv3.y <=g1+0.06) {if (mod(uv3.x+0.04*iTime,0.12)<=0.10) col*=0.6;}\n\tif (uv3.y <=g1+0.04) {if (mod(uv3.x+0.06*iTime,0.18)<=0.16) col*=0.5;}\n\tif (uv3.y <=g1+0.02) col*=0.4;\n\tif (uv3.y <=g1+0.00) col*=0.0;\n    \n    \n    fragColor = vec4(col*Scr,1.0)*blend;\n \n }\n\n\n", "image_inputs": [{"id": "XdX3Wj", "previewfilepath": "https://soundcloud.com/virgill/galvanize-soundtrack", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/galvanize-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[394, 404, 438, 438, 562], [564, 564, 599, 599, 723], [725, 725, 760, 760, 884], [887, 895, 917, 917, 989], [991, 1020, 1065, 1065, 1158], [1161, 1171, 1195, 1195, 1220], [1222, 1240, 1263, 1263, 1480], [1482, 1482, 1506, 1506, 1651], [1657, 1695, 1721, 1721, 2464], [2468, 2477, 2504, 2504, 2608], [2610, 2623, 2659, 2659, 2692], [2695, 2702, 2724, 2724, 3010], [3013, 3035, 3064, 3064, 3251], [3253, 3261, 3316, 3316, 3566], [3568, 3587, 3672, 3672, 3926], [3929, 3944, 3961, 3961, 4412], [4415, 4415, 4473, 4473, 6879]]}
{"id": "MlXGWM", "name": "Blue Star (Pulsar)", "author": "LewisCowles1986", "description": "This shader is a fork of https://www.shadertoy.com/view/4dXGR4#, all credit to the original author, I changed virtually nothing, but it is awesome!", "tags": ["3dnoise", "perlin", "star", "corona", "fork", "first", "pulsar", "stellar"], "likes": 48, "viewed": 3119, "date": "1422372506", "time_retrieved": "2024-06-20T18:16:12.754125", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat brightness = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( brightness < 0.15 ) {\n        brightness\t= max( ( cos(iTime) * 0.25 + sin(iTime) * 0.25 ), 0.1); \n    }\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.2, 0.65, 0.5 );\n\tvec3 orangeRed\t\t= vec3( 0.1, 0.25, 0.81 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i + 1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 0.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 3.14 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlXGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 113, 164, 164, 690], [717, 717, 774, 774, 3066]]}
{"id": "Mtf3W7", "name": "kali-traps b", "author": "bergi", "description": "variation of https://www.shadertoy.com/view/MtX3DM\ncalled \"patience is rewarded\"", "tags": ["3d", "fractal", "volume", "kali", "surface", "hybrid", "neon"], "likes": 13, "viewed": 1737, "date": "1422418644", "time_retrieved": "2024-06-20T18:16:13.396618", "image_code": "/*\tkali-traps by bergi in 2015\n\t\n\tonly cruising around here, what a fractal\n\tpraise kalibob\n\n\tforked from https://www.shadertoy.com/view/MtX3DM, now\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n*/\n\n\n// needs some more iters - lowered for webgl\nconst int  NUM_ITERS = \t\t\t45;\n\nconst vec3 KALI_PARAM = \t\tvec3(.5, .396, 1.5007);\n//const vec3 KALI_PARAM = \t\tvec3(.4993, .4046, 1.5);\n//const vec3 KALI_PARAM = \t\tvec3(.47);\nconst int  KALI_ITERS = \t\t33;\n\n// animation time\n#define ti \t(iTime * 0.02 + 140.)\n\n\n\n/** kali set as usual. \n\treturns last magnitude step and average */\nvec4 average;\nfloat kali(in vec3 p)\n{\n    average = vec4(0.);\n\tfloat mag;\n    for (int i=0; i<KALI_ITERS; ++i)\n    {\n        mag = dot(p, p);\n        p = abs(p) / mag;\n        average += vec4(p, mag);\n        p -= KALI_PARAM;\n    }\n\taverage /= 32.;\n    return mag;\n}\n\n// steps from pos along dir and samples the cloud\n// stp is 1e-5 - 1e+?? :)\nvec3 ray_color(vec3 pos, vec3 dir, float stp)\n{\n    vec3 p, col = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_ITERS; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = kali(p);\n\n\t\t// define a surface and get trapped\n\t\td = (1.3-100.*t) - abs(1.33 - d);\n\t\t\n\t\t// always step within a certain range\n\t\tt += max(0.001, min(0.01, d )) * (stp + 3. * t);\n\n\t\t// some color\n\t\tcol += (.5+.5*sin(average.rgb*vec3(3.+col.g,5,7)*4.)) \n\t\t// by distance to surface\n            / (1. + d * d * 400.);\n\t}\n    \n    return clamp(col / float(NUM_ITERS) * 3., 0., 1.);\n}\n\n// by David Hoskins https://www.shadertoy.com/view/XlfGWN\nfloat hash(in vec2 uv)\n{\n\tvec3 p  = fract(vec3(uv,ti) / vec3(3.07965, 7.1235, 4.998784));\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ray stepsize - or focus scale \n    float foc = 0.004 + 0.001*sin(ti*0.9);\n\n    // some position\n\t// - a circular path depending on the stepsize\n    float rti = ti * 0.5;\n\tfloat rad = 0.04;\n    \n    if (iMouse.z > .5) {\n        foc = pow(iMouse.y / iResolution.y, 2.)/6.;\n\t\t//rad = iMouse.x / iResolution.x;\n    }\n    \n\tvec3 pos = (vec3(-2.3, 1.19, -3.4)\n\t\t\t\t+ (0.001+rad)*vec3(2.*sin(rti),cos(rti),0.2*sin(rti/4.)) );\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n    vec3 dir = normalize(vec3(uv, 2.5-length(uv))).xzy;\n    rti = ti * 4.;\n    dir.xz = vec2(sin(rti)*dir.x-cos(rti)*dir.z, cos(rti)*dir.x+sin(rti)*dir.z);\n    \n    pos += dir * hash(uv*1114.+ti) * 0.05 * foc;\n\t\n    vec3 col = ray_color(pos, dir, foc)\n//\t\t\t+ 1.5 * ray_color(pos, dir, 0.04)\n        ;\n\n\tfragColor = vec4(pow(col,vec3(1./1.8)), 1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtf3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[544, 626, 649, 649, 878], [880, 956, 1003, 1003, 1495], [1497, 1555, 1579, 1579, 1707], [1709, 1709, 1766, 1804, 2615]]}
{"id": "Mtf3WM", "name": "[2TC 15] Expanding Rings via Log", "author": "MichaelPohoreski", "description": "Changing the constant K*log() produces interesting patterns", "tags": ["procedural", "2d"], "likes": 1, "viewed": 117, "date": "1422379396", "time_retrieved": "2024-06-20T18:16:13.511869", "image_code": "// [2TC 15] Expanding Rings via Log\n// Copyleft {c} 2015 Michael Pohoreski\n// Chars: 138 // 1 Tweet! Will there be a 2016 [1TC] :-)\n// Based on: https://www.shadertoy.com/view/4lX3WN\n\n// Minified: Hard-Coded log\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2 p = 2.*w/iResolution.xy - 1.;\n    f = vec4( fract( atan(p.y,p.x) + .5*iTime - 12.*log(length(p)) ) > .5 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtf3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[184, 212, 253, 253, 371]]}
{"id": "MtfGWN", "name": "[2TC 15] Supernova", "author": "guil", "description": "A simplified 2 tweets version of my supernova shader", "tags": ["3d", "2tweets", "2tc15"], "likes": 41, "viewed": 1473, "date": "1422031677", "time_retrieved": "2024-06-20T18:16:13.517774", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    float k=0.;\n    vec3 d =  vec3(w,1.)/iResolution-.7, o = d, c=k*d, p;\n    \n    for( int i=0; i<99; i++ ){\n        \n        p = o+sin(iTime*.1);\n\t\tfor (int j = 0; j < 10; j++) \n\t\t\n        \tp = abs(p) / dot(p,p) -1.,k += exp(-6. * abs(dot(p,o)));\n\t\t\n\t\t\n\t\tk/=3.;\n        o += d *.05/k;\n        c = .97*c + .1*k*vec3(k*k,k,1);\n    }\n    c =  .4 *log(1.+c);\n    f.rgb = c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 116, 157, 157, 531]]}
{"id": "Mtl3WH", "name": "SHAPE", "author": "mihu", "description": "A prototype of an Android app I made a couple months ago.\nIt generates abstract shapes using implicit functions, but in 2D only, and uses some 2D coord. xforms to add some 3D flavour.", "tags": ["procedural", "2d", "distancefunctions"], "likes": 26, "viewed": 3429, "date": "1421848025", "time_retrieved": "2024-06-20T18:16:13.517774", "image_code": "// thanks to iq for some primitive distance functions\n\n// info: http://miss-cache.blogspot.com/2015/01/modelling-with-distance-functions-shape.html\n\n#define COLOR_PALETTE 2\n\n#if COLOR_PALETTE==1\nvec3 backgrColor = vec3(0.51, 0.85, 0.98);\nvec3 insideColor0 = vec3(0.4, 0.75, 0.34);\nvec3 insideColor1 = vec3(0.32, 0.94, 0.47);\nvec3 borderColor = vec3(0.0, 0.25, 0.06);\nvec3 glowColor = vec3(0.06, 0.12, 0.08);\nfloat glowStrength = 0.07;\n#elif COLOR_PALETTE==2\nvec3 backgrColor = vec3(0.85);\nvec3 insideColor0 = vec3(0.0);\nvec3 insideColor1 = vec3(0.73, 0.0, 0.0);\nvec3 borderColor = vec3(0.0);\nvec3 glowColor = vec3(0.36);\nfloat glowStrength = 0.85;\n#else\nvec3 backgrColor = vec3(0.0);\nvec3 insideColor0 = vec3(1.0);\nvec3 insideColor1 = vec3(1.0);\nvec3 borderColor = vec3(1.0);\nvec3 glowColor = vec3(0.43, 0.85, 1.0);\nfloat glowStrength = 0.99;\n#endif\n\n#define PI 3.14159265359\n\nfloat distBox(vec2 p, vec2 b)\n{\n\tvec2 di = abs(p) - b;\n    float mc = max(di.x, di.y);\n    return mc < 0.0 ? mc : length(max(di,0.0));\n}\n\nfloat distDisc(vec2 p, float radius) { return length(p) - radius; }\nfloat distCircle(vec2 p, float R, float r) { return abs(length(p) - R) - r; }\nfloat distCircleTaxi(vec2 p, float R, float r) { return abs(abs(p.x) + abs(p.y) - R) - r; }\nfloat distHex(vec2 p, float h) { p = abs(p); return max(p.x+p.y*0.57735,p.y)-h; }\nfloat distRouBox(vec2 p, vec2 b, float c) { return length( max( abs(p) - b + vec2(c, c), 0.0 ) ) - c; }\n\nvec2 rotate(vec2 p, float a) { return vec2(p.x*cos(a)+p.y*sin(a), p.y*cos(a)-p.x*sin(a)); }\n#define SQRT2_OVER2 0.70710678\n\nvec2 calcCoordsID(vec2 uv, int ID, float rotation)\n{\n    vec2 cellSize = vec2(PI / 16.0, PI / 20.0);\n    \n\tif(ID == 0)\n\t{\n\t\tuv = vec2(length(uv), atan(uv.y/uv.x) * 0.2);\n\t}\n\telse if(ID == 2)\n\t{\n\t\tuv = vec2(log(length(uv) + 0.001) * 2.0, atan(uv.y, uv.x)) * 0.2;\n\t}\n\telse if(ID == 3)\n\t{\n\t\tuv = vec2(uv.x*uv.y, 0.5*(uv.y*uv.y - uv.x*uv.x)) * 2.5; // Parabolic coordinates? But reversed (parabolic to carthesian)\n\t}\n\telse if(ID == 4)\n\t{\n\t\tuv = exp(uv.x)*vec2(cos(uv.y), sin(uv.y));\n\t}\n\telse if(ID == 5)\n\t{\n\t\tfloat ff = length(uv) * 3.5;\n\t\tuv =  2.5 * uv * atan(ff) / (ff + 0.01);\n\t}\n\telse if(ID == 6)\n\t{\n\t\tuv = vec2(log(length(uv) + 0.001), atan(uv.y/uv.x));\n        uv = rotate(uv, PI*0.25);\n        cellSize *= SQRT2_OVER2 * vec2(1.0, 1.0) * 2.0;\n        //uv.y += 1.0 * uv.x;\n\t}\n\telse if(ID == 7)\n\t{\n\t\tuv.x /= (1.0 + 2.0 * abs(uv.y));\n\t}\n\t    \n    vec2 uvIntMod2 = mod(floor((uv) / cellSize), 2.0);\n\tuv = mod(uv, cellSize);\n    if(abs(uvIntMod2.x) < 0.1 || abs(2.0-uvIntMod2.x) < 0.1) uv.x = cellSize.x - uv.x;\n    if(abs(uvIntMod2.y) < 0.1 || abs(2.0-uvIntMod2.y) < 0.1) uv.y = cellSize.y - uv.y;\n    \n    uv -= cellSize*0.5;\n\n\treturn uv;\n}\n\nvec2 deformCoords(vec2 uv)\n{\n    float t = mod(iTime, 20.0);\n    float t01 = 0.0;\n    if(t > 17.0) t01 = (t-17.0) / 3.0;\n    \n    int id0 = int(floor(mod(iTime/20.0, 8.0)));\n    int id1 = int(floor(mod(iTime/20.0 + 1.0, 8.0)));\n    \n\tvec2 uv1 = calcCoordsID(uv, id0, 0.0);\n\tvec2 uv2 = calcCoordsID(uv, id1, 0.0);\n\tuv = mix(uv1, uv2, t01);\n\n    return uv;\n}\n\nfloat signNoZero(float x)\n{\n\treturn x > 0.0 ? 1.0 : -1.0;\n}\n\nvec2 domainXFormID(vec2 p, int ID, float t)\n{\n\tif(ID == 0)\n\t\tp.x += p.y * t;\n\telse if(ID == 1)\n\t\tp.y += (0.045 - abs(p.x)) * t;\n\telse if(ID == 2)\n\t\tp.x -= signNoZero(p.x) * (0.05 - 0.5*abs(p.y)) * t;\n\telse if(ID == 3)\n\t\tp.y -= signNoZero(p.y) * 0.5*abs(p.x) * t;\n\telse if(ID == 4)\n\t\tp.x -= signNoZero(p.x) * 0.45 * length(p) * t;\n\telse if(ID == 5)\n\t\tp.y += 0.35 * length(p) * t;\n\telse if(ID == 6)\n\t\tp.x -= signNoZero(p.x) * 0.05 * t;\n\telse if(ID == 7)\n\t{\n\t\tp.x -= signNoZero(p.x) * 0.05 * t;\n\t\tp.y -= signNoZero(p.y) * 0.05 * t;\n\t}\n\telse if(ID == 8)\n\t\tp.x *= (1.0 + t * 80.0 * abs(p.y));\n\telse if(ID == 9)\n\t\tp.y += t * cos(p.x * 20.0 * PI) * 0.025;\n\t\n\treturn p;\n}\n\nvec2 deformPos(vec2 p)\n{\n    int id = int(floor(mod(iTime, 40.0)))/4;\n    float t02 = mod(iTime, 4.0) * 0.5;\n    float t010 = t02 > 1.0 ? 2.0 - t02 : t02;\n    t010 = smoothstep(0.0, 1.0, t010);\n    \n    return domainXFormID(p, id, t010);\n}\n\nfloat distShapeID(vec2 p, int ID, vec2 par)\n{\n\tfloat d = 0.0;\n\tif(ID == 0)\n\t\td = distCircle(p, par.x, par.y);\n\telse if(ID == 1)\n\t\td = distCircleTaxi(p, par.x, par.y);\n    else if(ID == 6)\n\t\td = distBox(p, par);\n\telse if(ID == 3)\n\t\td = distRouBox(p, vec2(par.x), par.y);\n\telse if(ID == 4)\n\t\td = distHex(p, par.x);\n\telse if(ID == 5)\n\t\td = distBox(p, vec2(30.0, par.x * 0.5));\n\telse if(ID == 2)\n\t\td = distBox(p, vec2(par.x * 0.5, 30.0));\n\telse if(ID == 7)\n\t\td = min(distBox(p, vec2(30.0, par.x * 0.5)), distBox(p, vec2(par.y * 0.5, 30.0)));\n\t\n\treturn d;\n}\n\nfloat distShapeCSG(vec2 p, int opID, int shapeID0, int shapeID1)\n{\n    vec2 param0 = vec2(4.0, 1.5);\n    vec2 param1 = vec2(4.0, 1.5);\n    if(opID == 2) param1 *= 1.2;\n    if(opID == 3) param1 *= 0.4;\n    \n\tfloat d = distShapeID(p, shapeID0, param0);\n\tfloat d2 = distShapeID(p, shapeID1, param1);\n\t\n\tif(opID == 1) \t   d = min(d,  d2);\n\telse if(opID == 2) d = max(d,  d2);\n\telse if(opID == 3) d = max(d, -d2);\n\n\treturn d;\n}\n\nfloat distShape(vec2 modpos)\n{\n\tmodpos *= 100.0;\n    float time = iTime * 0.45;\n\n    float t01 = smoothstep(0.0, 1.0, mod(time, 1.0));\n    \n    int id00 = int(floor(mod(time, 8.0)));\n    int id01 = int(floor(mod(time+5.0, 8.0)));\n    \n    int id10 = int(floor(mod(time+1.0, 8.0)));\n    int id11 = int(floor(mod(time+6.0, 8.0)));\n    \n    int op0Id = int(floor(mod(time, 4.0)));\n    int op1Id = int(floor(mod(time+1.0, 4.0)));\n    \n    float d1 = distShapeCSG(modpos, op0Id, id00, id01);\n\tfloat d2 = distShapeCSG(modpos, op1Id, id10, id11);\n\n    float d = mix(d1, d2, t01);    \n    \n    return d * 0.01;\n}\n\nvec2 rotateCoords(vec2 uv)\n{\n    float angle = 0.0;\n    float time = mod(iTime, 23.0);\n    if(time < 8.0)\n    {\n    \tangle = smoothstep(0.0, 1.0, time * 0.125) * PI ;   \n    }\n\tuv = rotate(uv, angle);\n    \n    return uv;\n}\n\nvec3 getColor(float d)\n{\n\tfloat borderOffset = 0.0033;\n\tfloat inSmooth = smoothstep(1.0, 0.0, -d < 0.01 ? 0.0 : (-d-0.01) * 200.0);\n\tvec3 inColor = inSmooth * insideColor0 + (1.0 - inSmooth) * insideColor1;\n\t\n\tfloat outSmooth = smoothstep(1.0, 0.0, d < borderOffset ? 0.0 : (d-borderOffset) * (170.0 - glowStrength * 130.0));\n\toutSmooth *= clamp(5.0 * glowStrength, 0.0, 1.0);\n\tvec3 outColor = outSmooth * glowColor + (1.0 - outSmooth) * backgrColor;\n\t\n\tvec3 color = vec3(0.0);\n\tfloat border = smoothstep(1.0, 0.0, abs(d) * 300.0);\n\tvec3 noBorderColor = d > 0.0 ? outColor : inColor;\n\tcolor = border * borderColor + (1.0 - border) * noBorderColor;\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time010 = mod(iTime, 2.0) * 1.0;\n    time010 = smoothstep(0.0, 1.0, time010 > 1.0 ? 2.0 - time010 : time010);\n    \n    vec2 uv = fragCoord.xy / iResolution.x;\n    uv = uv * 2.0 - vec2(1.0, iResolution.y/iResolution.x);\n    \n    uv = deformCoords(uv);\n    uv = rotateCoords(uv);\n\tuv = deformPos(uv);\n    \n    float d = distShape(uv);\n    \n    float color = d < 0.0 ? 1.0 : smoothstep(1.0, 0.0, d * 250.0);\n\tfragColor = vec4(color, color * 0.3, color * 0.1, 1.0);\n    fragColor = vec4(getColor(d), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[55, 877, 908, 908, 1013], [1015, 1015, 1053, 1053, 1082], [1083, 1083, 1127, 1127, 1160], [1161, 1161, 1209, 1209, 1252], [1253, 1253, 1285, 1285, 1334], [1335, 1335, 1378, 1378, 1438], [1440, 1440, 1470, 1470, 1531], [1564, 1564, 1616, 1616, 2705], [2707, 2707, 2735, 2735, 3063], [3065, 3065, 3092, 3092, 3124], [3126, 3126, 3171, 3171, 3789], [3791, 3791, 3815, 3815, 4030], [4032, 4032, 4077, 4077, 4584], [4586, 4586, 4652, 4652, 5008], [5010, 5010, 5040, 5040, 5614], [5616, 5616, 5644, 5644, 5838], [5840, 5840, 5864, 5864, 6506], [6509, 6509, 6566, 6566, 7080]]}
{"id": "MtlGD8", "name": "Perpetual rolling", "author": "AlexPer76", "description": "Billiard table and ball", "tags": ["3d", "raymarching"], "likes": 14, "viewed": 823, "date": "1421783178", "time_retrieved": "2024-06-20T18:16:13.517774", "image_code": "#define SQUARE_PATH\n#define CAM_MOVING\n\n#define MAX_STEPS 64\n#define EPSILON .001\n\n#define M_PI 3.14159265358979\n\n//#define ANTIALIASING\n//#define AA5\nconst float AADist = 0.25;\n\nconst float MaxDistance = 80.;\nconst vec3 FadeLightSource = vec3(4., 4., -2.);\nconst vec3 LightSource2 = vec3(-10., 10., 10.);\n\nconst vec3 TableColor = vec3(0.42, 0.57, 0.14);\nconst vec3 BarrierColor = vec3(0.55, 0.27, 0.08);\nconst vec3 RoomColor = vec3(0.37, 0.36, 0.21);\nconst vec3 DoorColor = vec3(0.);\nconst vec3 WinColor = vec3(2.);\n\nconst float BallRadius = 1.0;\nconst float BallReflectivity = 0.3;\nconst vec2 StartBallPos = vec2(0, 1);\n\nconst float TableHeight = 0.0;\nconst float BarrierThickness = 0.8;\nconst float RoomRadius = 20.0;\n\nconst float CamRotSpeed =  1.0 / 25.0;\n\n#ifdef SQUARE_PATH\nconst float TableSize = 2.0 * BallRadius * (2.0 * M_PI / sqrt(2.0) + 1.0);\nvec2 StartVel = normalize(vec2(1, 1));\nconst float EyePosRadius = 9.0;\n#else\nfloat TableSize = 2.0 * BallRadius * (2.0 * M_PI * 10.0 / sqrt(101.0) + 1.0);\nvec2 StartVel = normalize(vec2(0.1, 1));\nconst float EyePosRadius = 11.0;\n#endif\n\nconst float HalfSizeTable = TableSize / 2.0;\n\nfloat TableSurface(vec3 a) {\n\tvec3 sz = vec3(HalfSizeTable, 0, HalfSizeTable);\n\treturn length(max(abs(a) - sz, 0.));\n}\n\nfloat Box(vec3 a, vec3 sz) {\n\treturn length(max(abs(a) - sz, 0.));\n}\n\nfloat sBox(vec3 a, vec3 sz) {\n  vec3 d = abs(a) - sz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Barrier(vec3 a) {\n\tfloat ht = BarrierThickness / 2.0;\n\tfloat bx1 = sBox(a + vec3(HalfSizeTable + ht, -ht, 0), vec3(ht, ht, HalfSizeTable + BarrierThickness));\n\tfloat bx2 = sBox(a + vec3(-HalfSizeTable - ht, -ht, 0), vec3(ht, ht, HalfSizeTable + BarrierThickness));\n\tfloat bx3 = sBox(a + vec3(0, -ht, HalfSizeTable + ht), vec3(HalfSizeTable + BarrierThickness, ht, ht));\n\tfloat bx4 = sBox(a + vec3(0, -ht, -HalfSizeTable - ht), vec3(HalfSizeTable + BarrierThickness, ht, ht));\n\treturn min(min(bx1, bx2), min(bx3, bx4));\n}\n\nfloat Room(vec3 a) {\n\tfloat wallSize = 60.0;\n\tfloat hs = wallSize / 2.0;\n\tfloat floorDist = wallSize / 8.0;\n \tfloat wl1 = sBox(a + vec3(RoomRadius, -hs + floorDist, 0), vec3(0.1, hs, hs));\n\tfloat wl2 = sBox(a + vec3(-RoomRadius, -hs + floorDist, 0), vec3(0.1, hs, hs));\n\tfloat wl3 = sBox(a + vec3(0, -hs + floorDist, RoomRadius), vec3(hs, hs, 0.1));\n\tfloat wl4 = sBox(a + vec3(0, -hs + floorDist, -RoomRadius), vec3(hs, hs, 0.1));\n\tfloat cl = sBox(a + vec3(0, -wallSize + floorDist, 0), vec3(hs, 0.1, hs));\n\tfloat fl = sBox(a + vec3(0, floorDist, 0), vec3(hs, 0.1, hs));\n\treturn min(min( min(wl1, wl2), min(wl3, wl4) ), min(cl, fl));\n}\n\nfloat Doors(vec3 a) {\n\tfloat size = 25.0;\n\tfloat floorDist = 10.0;\n\tfloat hs = size / 2.0;\n    vec3 sz = vec3(hs / 4.0, hs, 0.2);\n\tfloat dr1 = Box(a + vec3(0.0, -hs + floorDist, RoomRadius), sz);\n\tfloat dr2 = Box(a + vec3(0.0, -hs + floorDist, -RoomRadius), sz);\n\treturn min(dr1, dr2);\n}\n\nfloat Windows(vec3 a) {\n\tfloat size = 20.0;\n    float floorDist = 1.0;\n\tfloat hs = size / 2.0;\n    vec3 sz = vec3(0.15, hs, hs / 6.0);\n\tfloat w1 = Box(a + vec3(RoomRadius, -hs - floorDist, 0.0), sz);\n\tfloat w2 = Box(a + vec3(-RoomRadius, -hs - floorDist, 0.0), sz);\n\treturn min(w1, w2);\n}\n\nfloat Amplitude = (TableSize / 2.0 - BallRadius);\n\nfloat GetPos(float dist, float startPos) {\n\treturn Amplitude * (mod(dist - startPos, 2.0) - 1.0) * sign(mod(dist - startPos, 4.0) - 2.0);\n}\n\nvec2 GetBallPos(float time) {\n\treturn vec2(GetPos(StartVel.x * time, StartBallPos.x), GetPos(StartVel.y * time, StartBallPos.y));\n}\n\nvec3 ballCenter;\n\nfloat Ball(vec3 a) {\n\treturn length(a - ballCenter) - 1.;\n}\n\nfloat Scene(vec3 a) {\n\treturn min( min( min(Ball(a), TableSurface(a)), min(Room(a), Barrier(a)) ), min(Doors(a), Windows(a)));\n}\n\nconst vec4 CanvasColor = vec4(247.0 / 255.0, 242.0 / 255.0, 212.0 / 255.0, 1.0);\nconst vec4 DigitColor = vec4(0.0, 0.0, 0.0, 1);\n\nvec4 DrawCircle(vec2 pos, vec2 center, vec4 color) {\n\tfloat radius = 0.133;\n\t\n\tfloat k = 2.0; // w/h = 2\n\t\n\tvec2 cPos = pos - center;\n\tcPos.x *= k;\n\t\n\tif (length(cPos) < radius)\n\t\tcolor = CanvasColor;\n\t\t\n\t// digits\n\tfloat h_2 = 0.052;\n\tfloat w = 0.022;\n\tfloat dc1 = -0.030;\n\t\n\tif ((dc1 - w < cPos.x) && (cPos.x < dc1) && (-h_2 < cPos.y) && (cPos.y < h_2))\n\t\tcolor = DigitColor;\n\t\t\n\tfloat r = 0.054;\n\tfloat dc0 = 0.05;\n\tvec2 zcPos = vec2(cPos.x * 1.5 - dc0, cPos.y);\n\t\n\tvec2 zcPos2 = vec2((cPos.x - dc0 / 1.5) * 2.0, cPos.y);\n\n\tif ( ( (r - w) < length(zcPos2) ) && (length(zcPos) < r) )\n\t\tcolor = DigitColor;\n\t\t\n\treturn color;\n}\n\nvec4 DrawTex(vec2 pos) {\n\tconst float stripWidth = 0.45;\n\t\n\tconst vec4 stripColor = vec4(20.0 / 255.0, 50.0 / 255.0, 80.0 / 255.0, 1.0);\n\t\n\tvec4 res = CanvasColor;\n\n\t// draw strip\n\tif ( (pos.y > (0.5 - stripWidth / 2.0)) && (pos.y < (0.5 + stripWidth / 2.0)) )\n\t\tres = stripColor;\n\t\t\n\t// draw circles with digits\n\tres = DrawCircle(pos, vec2(0.245, 0.5), res);\n\tres = DrawCircle(pos, vec2(0.755, 0.5), res);\n\t\t\n\treturn res;\n}\n\n// Rotate around axis\nvec4 Quat(vec3 axis, float angle) {\n\tvec4 quat;\n\tquat.xyz = axis * sin(angle * 0.5);\n\tquat.w = cos(angle / 2.0);\n\treturn quat;\n}\n\n// Multiply quaternion by vector\nvec3 Transform(vec4 q, vec3 v) {\n\tvec3 uv = 2.0 * cross(q.xyz, v);\n\tvec3 uuv = cross(q.xyz, uv);\n\treturn v + uv * q.w + uuv;\n}\n\nvec3 uVec, rVec; // transformed BallUpVec and BallRightVec\n\nvec3 BallTextureColor(vec3 a) {\n\tvec3 eVec = normalize(cross(rVec, uVec)); // eye vec\n\n\tvec3 radVec = normalize(a - ballCenter);\n\t\n\tfloat angle1 = acos(-dot(radVec, uVec)) / M_PI;\n\n\tvec3 N = uVec;    // plane normal\n\tfloat K = -dot(N, radVec);\n\tvec3 prRadVec = radVec + K * N;  // equator plan projection\n\tvec3 equatorRadVec = normalize(prRadVec);\n\n\tfloat semiSphere = dot(equatorRadVec, eVec);\n\tfloat angle2 =  acos(-dot(equatorRadVec, rVec)) / M_PI / 2.0;\n\tif (semiSphere < 0.0)\n\t\tangle2 = acos(dot(equatorRadVec, rVec)) / M_PI / 2.0 + 1.0/2.0;\n\n\treturn DrawTex(vec2(angle2, angle1)).rgb;\n}\n\nstruct MaterialInfo {\n\tvec3 Kd;\n\tfloat Shininess;\n};\n\nbool ballReflection = false;\n\nMaterialInfo Material(vec3 a) {\n\tMaterialInfo m = MaterialInfo(vec3(0.), 0.);\n\tfloat closest = MaxDistance;\n\n\tfloat roomDistance = Room(a);\n\tif (roomDistance < closest) {\n\t\tm.Kd = RoomColor;\n\t\tm.Shininess = 20.;\n\t\tclosest = roomDistance;\n\t}\n\n\tfloat doorDistance = Doors(a);\n\tif (doorDistance < closest) {\n\t\tm.Kd = DoorColor;\n\t\tm.Shininess = 0.;\n\t\tclosest = doorDistance;\n\t}\n\n\tfloat winDistance = Windows(a);\n\tif (winDistance < closest) {\n\t\tm.Kd = WinColor;\n\t\tm.Shininess = 0.;\n\t\tclosest = winDistance;\n\t}\n\t\n\tfloat tableDistance = TableSurface(a);\n\tif (tableDistance < closest) {\n\t\tm.Kd = TableColor;\n\t\tm.Shininess = 20.;\n\t\tclosest = tableDistance;\n\t}\n\n\tfloat barrierDistance = Barrier(a);\n\tif (barrierDistance < closest) {\n\t\tm.Kd = BarrierColor;\n\t\tm.Shininess = 80.;\n\t\tclosest = barrierDistance;\n\t}\n\n\tfloat ballDistance = Ball(a);\n\tif ((ballDistance < closest) && (!ballReflection)) {\n\t\tm.Kd = BallTextureColor(a);\n\t\tm.Shininess = 150.;\n\t\tballReflection = true;\t\n\t}\n\treturn m;\n}\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat s = Scene(a);\n\treturn normalize(vec3(\n\t\tScene(a+e.xyy) - s,\n\t\tScene(a+e.yxy) - s,\n\t\tScene(a+e.yyx) - s));\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\t\n\tfloat b = 0.;\n\tfor (int i = 1; i <= 4; ++i) {\t\t\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = Scene(at + normal * L);\n\t\tb += max(0., L - d);\n\t}\n\treturn min(b, 1.);\n}\n\nvec3 LookAt(vec3 pos, vec3 at, vec3 rDir) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0., 1., 0.));\n\tvec3 u = cross(r, f);\n\treturn mat3(r, u, -f) * rDir;\n}\n\nfloat Trace(vec3 rPos, vec3 rDir, float distMin) {\n\tfloat L = distMin;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tfloat d = Scene(rPos + rDir * L);\n\t\tL += d;\n\t\tif (d < EPSILON * L) break;\n\t}\n\treturn L;\n}\n\nvec3 Lighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m, vec3 lColor, vec3 lPos) {\n\tvec3 lDir = lPos - at;\n\t\n\tvec3 lDirN = normalize(lDir);\n\tfloat t = Trace(at, lDirN, EPSILON*2.);\n\tif (t < length(lDir)) {\n\t\treturn vec3(0.);\n\t}\n\tvec3 color = m.Kd * lColor * max(0., dot(normal, normalize(lDir)));\n\t\n\tif (m.Shininess > 0.) {\n\t\tvec3 h = normalize(normalize(lDir) + normalize(eye - at));\n\t\tcolor += lColor * pow(max(0., dot(normal, h)), m.Shininess) * (m.Shininess + 8.) / 25.;\n\t}\n\treturn color;\n}\n\nvec3 FadeLighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m) {\t\n\tvec3 color = Lighting(at, normal, eye, m, vec3(1.2), FadeLightSource);\n\tvec3 lDir = FadeLightSource - at;\n\treturn 5.0 * color / dot(lDir, lDir);\n}\n\nvec3 Shade(vec3 rpos, vec3 rdir, float t, vec3 pos, vec3 nor)\n{\t\n\tMaterialInfo mat = Material(pos);\n\n\t// ambient light\n\tvec3 color = .11 * (1. - Occlusion(pos, nor)) * mat.Kd;\n\n\t// light from light source\n\tcolor += FadeLighting(pos, nor, rpos, mat);\n\tcolor += Lighting(pos, nor, rpos, mat, vec3(0.6), LightSource2);\n\n\treturn color;\n}\n\n\nvec3 ShadeAndReflect(vec3 rpos, vec3 rdir, float t)\n{\n\tvec3 pos = rpos + rdir * t;\n\tvec3 nor = Normal(pos);\n\n\tvec3 color = Shade(rpos, rdir, t, pos, nor);\n\n\tif (ballReflection)\n\t{\n\t\trdir = normalize(reflect(rdir, nor));\n\t\trpos = pos + rdir * EPSILON * 2.;\n\t\t\n\t\tfloat t = Trace(rpos, rdir, 0.);\n\n\t\tpos = rpos + rdir * t;\n\t\tnor = Normal(pos);\n\t\tcolor += Shade(rpos, rdir, t, pos, nor) * BallReflectivity;\n\n\t\tballReflection = false;\n\t}\n\t\n\treturn color;\n}\n\nvec3 Camera(vec2 px) {\n    #ifdef CAM_MOVING\n\tvec3 camPos = vec3(EyePosRadius * sin(CamRotSpeed * iTime), 3., EyePosRadius * cos(CamRotSpeed * iTime));\n\t#else\n\tvec3 camPos = vec3(0., 3., EyePosRadius);\n\t#endif\n    \n\tvec2 uv = px / iResolution.xy * 2. - 1.;\t\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 rayStart = camPos;\n\tvec3 rayDirection = LookAt(rayStart, vec3(0, -1, 0), normalize(vec3(uv, -2.)));\n\tfloat path = Trace(rayStart, rayDirection, 0.);\t\n\treturn ShadeAndReflect(rayStart, rayDirection, path);\n}\n\nvoid CreateBall() {\n\tvec2 ballPos = GetBallPos(iTime);\n\tballCenter = vec3(ballPos.x, TableHeight + BallRadius, ballPos.y);\n\t\n\tconst float deltaTime = 0.001;\n\tvec2 ballPosPrev = GetBallPos(iTime - deltaTime);\n\tvec2 moveVec = ballPos - ballPosPrev;\n\n\t// Rotate aroung path normal\n\tvec4 quat = Quat(normalize(vec3(moveVec.y, 0, -moveVec.x)), length(Amplitude * iTime * StartVel));\n\t\n\tconst vec3 BallUpVec = vec3(0.0, 1.0, 0.0);\n\tconst vec3 BallRightVec = vec3(1.0, 0.0, 0.0);\n\t\n\tuVec = normalize(Transform(quat, BallUpVec));\n\trVec = normalize(Transform(quat, BallRightVec));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tCreateBall();\n\tvec3 col = vec3(0.0);\n\t\n\t#ifdef ANTIALIASING\n    \n    \t#ifdef AA5\n\t\tcol = Camera(fragCoord.xy);\n\t\tcol += Camera(vec2(fragCoord.x + AADist, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x - AADist, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x + AADist, fragCoord.y - AADist));\n\t\tcol += Camera(vec2(fragCoord.x - AADist, fragCoord.y - AADist));\n\t\tcol /= 5.0;\n    \t#else\n\t\tcol = Camera(vec2(fragCoord.x, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x + AADist * sqrt(3.0) / 2.0, fragCoord.y - AADist / 2.0));    \t\n\t\tcol += Camera(vec2(fragCoord.x - AADist * sqrt(3.0) / 2.0, fragCoord.y - AADist / 2.0));\n\t\tcol /= 3.0;\n    \t#endif\n    \n    #else\n\tcol = Camera(fragCoord.xy);\n\t#endif\n\n\tfragColor = vec4(col, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[114, 1139, 1167, 1167, 1257], [1259, 1259, 1287, 1287, 1327], [1329, 1329, 1358, 1358, 1450], [1452, 1452, 1475, 1475, 1978], [1980, 1980, 2000, 2000, 2615], [2617, 2617, 2638, 2638, 2904], [2906, 2906, 2929, 2929, 3194], [3247, 3247, 3289, 3289, 3386], [3388, 3388, 3417, 3417, 3519], [3539, 3539, 3559, 3559, 3598], [3600, 3600, 3621, 3621, 3728], [3860, 3860, 3912, 3912, 4487], [4489, 4489, 4513, 4513, 4913], [4915, 4937, 4972, 4972, 5065], [5067, 5100, 5132, 5132, 5226], [5245, 5288, 5319, 5319, 5880], [5966, 5966, 5997, 5997, 6944], [6946, 6946, 6967, 6967, 7108], [7110, 7110, 7149, 7149, 7311], [7313, 7313, 7356, 7356, 7481], [7483, 7483, 7533, 7533, 7684], [7686, 7686, 7773, 7773, 8185], [8187, 8187, 8254, 8254, 8403], [8405, 8405, 8468, 8468, 8738], [8741, 8741, 8794, 8794, 9192], [9194, 9194, 9216, 9216, 9704], [9706, 9706, 9725, 9725, 10279], [10281, 10281, 10338, 10338, 11096]]}
{"id": "MtlGW8", "name": "Circles Fractal", "author": "yakoudbz", "description": "I discover that fractal, and I wonder if it is a known one. It would be wonderful if someone can explain the math behind it\n\nVisualize it in fullscreen to decrease the artefact due to the discontinuity of pixel", "tags": ["fractal", "circles", "newfractal"], "likes": 2, "viewed": 166, "date": "1421756316", "time_retrieved": "2024-06-20T18:16:13.669325", "image_code": "/* Circles Fractal   *\n * By CÃ©lestin Marot */\n\n// colored shape on black background if Iter is odd\n// black shape on colored background if Iter is even\nconst int Iter=50;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //((1,1) if x<0  | divergence if x>0.5)\n\tfloat x=cos(0.5*iTime)*0.25+0.25; // value around 0.75 with low iter are fun too\n    \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    for (int i=0; i<Iter; i++)\n        \tuv = abs(uv)/dot(uv,uv)-x;\n    \n\tfragColor = vec4(uv,uv.y-uv.x,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[51, 176, 233, 277, 547]]}
{"id": "MtlGWn", "name": "Not Your Dimension", "author": "john1011", "description": "First attempt at a shader, ever :). Really more of an exercise to get into the paradigm of shader programming. ", "tags": ["2d", "simple"], "likes": 0, "viewed": 111, "date": "1421035942", "time_retrieved": "2024-06-20T18:16:13.669325", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0 + 2.0*p;\n    q.x *= iResolution.x/iResolution.y;\n    \n    q.x /= 1.0*sin(0.250*iTime);\n    \n    float r = sqrt(dot(q,q));\n    \n    r += 0.45*sin(2.0*iTime);\n    \n    vec3 col = vec3(p,0.5+0.5*sin(iTime));\n    \n    float t = 0.0;\n    \n    t += 200.0*cos(sin(iTime/2.0));\n    \n    if(r<0.8){\n    \t//col *= 0.5 + sqrt(sin(t*q.y*q.x*20.0));\n        \n        col *= 1.0 - 0.5*smoothstep(0.6,0.9,r);\n        \n        if(r<0.3){\n            col /= vec3(0.5,0.75,0.5);\n            col *= 1.0 - smoothstep(0.1,0.4,r);\n        }\n        \n    }\n    else\n        col *= 0.25 + sqrt(sin(t*q.y*q.x));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 738]]}
{"id": "Mts3WH", "name": "[2TC 15] 2TC", "author": "bergi", "description": "2TC in 2T - 1", "tags": ["2d", "character"], "likes": 3, "viewed": 1143, "date": "1421858385", "time_retrieved": "2024-06-20T18:16:13.669325", "image_code": "// 2TC in 2T - 1\n// \n// by bergi \n// \n// character encoding from movAX13h https://www.shadertoy.com/view/lssGDj\n\n#define C(n)p+=2.+4.*sin(p.x+t)/(p.y+9.);q=floor(p*vec2(4.,-4.));if(int(mod(n/exp2(q.x+5.*q.y),2.))==1)f=sin(p.x+t),e=cos(p.y+t); \n\nvoid mainImage( out vec4 z, in vec2 w )\n{\n    vec2 p = w / iResolution.y * 9. - 9., q=p; float e = 0., f=e, t = iTime;\n    C(32584238.) C(4329631.) C(15238702.) z = vec4(f,e,f-e,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mts3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 245, 286, 286, 429]]}
{"id": "Mts3WN", "name": "dragon daggerr", "author": "public_int_i", "description": "3d ray trace of a dragon dagger from runescape", "tags": ["3d", "ray", "dragon", "trace", "dagger"], "likes": 0, "viewed": 134, "date": "1422300682", "time_retrieved": "2024-06-20T18:16:14.875570", "image_code": "\n//#define SHADOWS\n\nstruct Triangle {\n    vec3 v1,v2,v3,normal,color;\n};\n    \n    \n    \n    \nconst float viewDist = 999999.0;\n\nvec3 cameraPosition,cameraDirection,cameraRight,cameraRayDir,cameraRayPos;\nvec3 cameraUp = vec3(0.0,1.0,0.0);\n\n\n\n\nvec3 rayPos,rayDir;\nTriangle rayHit;\nfloat rayHitDist;\n\n\n\nvec3 lightDir;\nvec4 lightColor = vec4(0.8,0.75,0.75,1.0);\n\n\n\nvec3 calcNormal(vec3 p1, vec3 p2, vec3 p3) {\n    vec3 u = p2-p1;\n    vec3 v = p3-p1;\n    \n    vec3 normal = vec3(u.y*v.z-u.z*v.y,\n                       u.z*v.x-u.x*v.z,\n                       u.x*v.y-u.y*v.x);\n    \n    return normalize(cross(u,v));\n    return normalize(normal);\n}\n\n#define TEST_CULL\n\nvec3 e1,e2,tv,pv,qv;\nfloat det,inv_det,td,tU,tV;\nvoid rayTriangle(Triangle t) {//http://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\n    e1 = t.v2-t.v1;\n    e2 = t.v3-t.v1;\n\n    pv = cross(rayDir,e2);\n\n\tdet = dot(e1,pv);\n    \n    \n    #ifdef TEST_CULL\n    \n    if (det < 0.000001) {\n        return;\n    }\n    tv = rayPos-t.v1;\n    \n    tU = dot(tv,pv);\n    if (tU < 0.0 || tU > det) {\n    \treturn;\n    }\n    \n    qv = cross(tv,e1);\n    \n    tV = dot(rayDir,qv);\n    if (tV < 0.0 || tU+tV > det) {\n    \treturn;\n    }\n    \n    td = dot(e2,qv)*(1.0/det);\n    if (td < 0.0) {\n        return;\n    }\n    \n    if (td < rayHitDist) {\n    \trayHitDist = td;\n        rayHit = t;\n    }\n        \n    #else\n    \n    if (det > -0.00001 && det < 0.00001) {\n        return;\n    }\n    \n    inv_det = 1.0/det;\n\n    tv = rayPos-t.v1;\n    \n    tU = dot(tv,pv)*inv_det;\n    if (tU < 0.0 || tU > 1.0) {\n        return;\n    }\n    \n    qv = cross(tv,e1);\n    \n    tV = dot(rayDir,qv)*inv_det;\n    if (tV < 0.0 || tV+tU > 1.0) {\n        return;\n    }\n    \n    td = dot(e2,qv)*inv_det;\n    if (td < rayHitDist) {\n    \trayHitDist = td;\n        rayHit = t;\n    }\n    #endif\n}\n\nvec3 pN,pP;\nvoid yPlane(Triangle t) {\n    \n    float rY = t.v1.y-rayPos.y;//get distance from ray to plane on y axis\n        \n    if (rY < 0.0) {//check if ray going opposite direction from plane, also set the normal based on plane face while were at it\n        \n        if (rayDir.y >= 0.0) {\n            \n            return;\n            \n        } else {\n        \n\t\t\tpN = vec3(0.0,1.0,0.0);\n            \n        }\n        \n    } else {\n        \n        if (rayDir.y <= 0.0) {\n            \n            return;\n            \n        } else {\n            \n            pN = vec3(0.0,-1.0,0.0);\n        \n        }\n        \n    }\n    \n    rY = rY/rayDir.y;//calculate number of ray movements until ray\n    \n    if (rY < rayHitDist) {//check if a closer hit then the current one\n        \n        pP = rayPos+rY*rayDir;\n        \n        //check if in width/length of plane\n        if (abs(pP.x-t.v1.x) <= t.v2.x && abs(pP.z-t.v1.z) <= t.v2.z) {\n            \n            //we got a hit\n            rayHitDist = rY;\n            rayHit = t;\n            rayHit.normal = pN;\n            \n        }\n    }\n}\n    \n\nbool trace(float maxDist) {\n    rayHitDist = maxDist;\n    \n    rayTriangle( Triangle(vec3(-0.202766,-2.41208005,-0.78091699),vec3(-0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-3.09572005,-1.21421599),vec3(-1.0,0.0,-0.0),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(-0.202766,-2.20588994,-1.05089605),vec3(0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-2.8895309,-1.48419499),vec3(0.0,0.53533983,-0.84463674),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(0.202766,-2.20588994,-1.05089605),vec3(0.202766,-2.41208005,-0.78091699),vec3(0.202766,-3.09572005,-1.21421599),vec3(1.0,0.0,0.0),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(0.202766,-2.41208005,-0.78091699),vec3(-0.202766,-2.41208005,-0.78091699),vec3(0.202766,-3.09572005,-1.21421599),vec3(0.0,-0.53534037,0.84463638),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(0.202766,-3.09572005,-1.21421599),vec3(-0.202766,-3.09572005,-1.21421599),vec3(0.245487,-3.36647391,-1.37596595),vec3(0.0,-0.51285738,0.8584739),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.202766,-2.41208005,-0.78091699),vec3(0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-2.41208005,-0.78091699),vec3(0.0,0.79473335,0.60695875),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(-0.245487,-3.36647391,-1.37596595),vec3(-0.245487,-3.11684203,-1.70282698),vec3(0.245487,-3.36647391,-1.37596595),vec3(0.0,-0.79473388,-0.60695803),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.202766,-2.8895309,-1.48419499),vec3(0.202766,-3.09572005,-1.21421599),vec3(0.245487,-3.11684203,-1.70282698),vec3(0.99083394,0.10735731,0.08199124),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.202766,-2.8895309,-1.48419499),vec3(0.202766,-2.8895309,-1.48419499),vec3(-0.245487,-3.11684203,-1.70282698),vec3(0.0,0.69321346,-0.72073233),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.202766,-3.09572005,-1.21421599),vec3(-0.202766,-2.8895309,-1.48419499),vec3(-0.245487,-3.36647391,-1.37596595),vec3(-0.99083394,0.10735714,0.08199111),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-2.8895309,-1.48419499),vec3(-0.202766,-3.09572005,-1.21421599),vec3(-1.0,0.0,0.0),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(0.202766,-2.20588994,-1.05089605),vec3(0.202766,-2.8895309,-1.48419499),vec3(-0.202766,-2.8895309,-1.48419499),vec3(0.0,0.53533983,-0.84463674),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(0.202766,-2.8895309,-1.48419499),vec3(0.202766,-2.20588994,-1.05089605),vec3(0.202766,-3.09572005,-1.21421599),vec3(1.0,0.0,-0.0),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(-0.202766,-2.41208005,-0.78091699),vec3(-0.202766,-3.09572005,-1.21421599),vec3(0.202766,-3.09572005,-1.21421599),vec3(0.0,-0.53534037,0.84463638),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(-0.202766,-3.09572005,-1.21421599),vec3(-0.245487,-3.36647391,-1.37596595),vec3(0.245487,-3.36647391,-1.37596595),vec3(0.0,-0.51285732,0.85847378),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-2.20588994,-1.05089605),vec3(-0.202766,-2.41208005,-0.78091699),vec3(0.0,0.79473335,0.60695875),vec3(0.138684,0.05031,0.007084)));\n    rayTriangle( Triangle(vec3(-0.245487,-3.11684203,-1.70282698),vec3(0.245487,-3.11684203,-1.70282698),vec3(0.245487,-3.36647391,-1.37596595),vec3(0.0,-0.79473388,-0.60695803),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.202766,-3.09572005,-1.21421599),vec3(0.245487,-3.36647391,-1.37596595),vec3(0.245487,-3.11684203,-1.70282698),vec3(0.990834,0.10735705,0.08199126),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.202766,-2.8895309,-1.48419499),vec3(0.245487,-3.11684203,-1.70282698),vec3(-0.245487,-3.11684203,-1.70282698),vec3(0.0,0.69321346,-0.72073239),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.202766,-2.8895309,-1.48419499),vec3(-0.245487,-3.11684203,-1.70282698),vec3(-0.245487,-3.36647391,-1.37596595),vec3(-0.990834,0.10735721,0.08199137),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.85584497,-2.26676393,-0.62989098),vec3(-0.85584497,-2.01110601,-0.97304797),vec3(-0.59909201,-2.60908198,-0.886675),vec3(-0.8574934,-0.41258058,-0.30737969),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.85584497,-2.01110601,-0.97304797),vec3(0.85584497,-2.01110601,-0.97304797),vec3(-0.59909201,-2.35510206,-1.22757995),vec3(0.0,0.59480518,-0.80386996),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.01110601,-0.97304797),vec3(0.85584497,-2.26676393,-0.62989098),vec3(0.59909201,-2.35510206,-1.22757995),vec3(0.85749358,-0.41258052,-0.3073796),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.26676393,-0.62989098),vec3(-0.85584497,-2.26676393,-0.62989098),vec3(0.59909201,-2.60908198,-0.886675),vec3(0.0,-0.60006803,0.79994899),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.59909201,-2.60908198,-0.886675),vec3(-0.59909201,-2.35510206,-1.22757995),vec3(0.59909201,-2.60908198,-0.886675),vec3(0.0,-0.80191404,-0.59743941),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.26676393,-0.62989098),vec3(0.85584497,-2.01110601,-0.97304797),vec3(-0.85584497,-2.26676393,-0.62989098),vec3(0.0,0.80191386,0.59743971),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.85584497,-2.01110601,-0.97304797),vec3(-0.59909201,-2.35510206,-1.22757995),vec3(-0.59909201,-2.60908198,-0.886675),vec3(-0.85749352,-0.41258064,-0.30737948),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.01110601,-0.97304797),vec3(0.59909201,-2.35510206,-1.22757995),vec3(-0.59909201,-2.35510206,-1.22757995),vec3(0.0,0.59480512,-0.80386996),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.26676393,-0.62989098),vec3(0.59909201,-2.60908198,-0.886675),vec3(0.59909201,-2.35510206,-1.22757995),vec3(0.85749352,-0.4125807,-0.30737957),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.85584497,-2.26676393,-0.62989098),vec3(-0.59909201,-2.60908198,-0.886675),vec3(0.59909201,-2.60908198,-0.886675),vec3(0.0,-0.60006797,0.79994893),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(-0.59909201,-2.35510206,-1.22757995),vec3(0.59909201,-2.35510206,-1.22757995),vec3(0.59909201,-2.60908198,-0.886675),vec3(0.0,-0.80191404,-0.59743941),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.85584497,-2.01110601,-0.97304797),vec3(-0.85584497,-2.01110601,-0.97304797),vec3(-0.85584497,-2.26676393,-0.62989098),vec3(0.0,0.80191386,0.59743971),vec3(0.138684,0.138684,0.138684)));\n    rayTriangle( Triangle(vec3(0.30000001,-2.4070189,-1.02823806),vec3(0.30000001,-0.80798203,0.89341998),vec3(-0.30000001,-2.4070189,-1.02823806),vec3(0.0,-0.76868236,0.63963068),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(-0.30000001,-2.4070189,-1.02823806),vec3(-0.30000001,1.03767395,1.01542199),vec3(0.30000001,-2.4070189,-1.02823806),vec3(0.0,0.51023853,-0.86003292),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(0.30000001,-0.80798203,0.89341998),vec3(0.30000001,1.03767395,1.01542306),vec3(-0.30000001,-0.80798203,0.89341998),vec3(0.0,-0.06595888,0.9978224),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(-0.30000001,-2.4070189,-1.02823806),vec3(-0.30000001,-0.80798203,0.89341998),vec3(-0.30000001,1.03767395,1.01542199),vec3(-1.0,0.0,0.0),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(0.30000001,-0.80798203,0.89341998),vec3(0.30000001,-2.4070189,-1.02823806),vec3(0.30000001,1.03767395,1.01542306),vec3(1.0,-0.0,0.0),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(0.30000001,-0.80798203,0.89341998),vec3(-0.30000001,-0.80798203,0.89341998),vec3(-0.30000001,-2.4070189,-1.02823806),vec3(0.0,-0.76868236,0.63963068),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(-0.30000001,1.03767395,1.01542199),vec3(0.30000001,1.03767395,1.01542306),vec3(0.30000001,-2.4070189,-1.02823806),vec3(0.00000154,0.51023871,-0.86003286),vec3(0.31999999,0.006154,0.006154)));\n    rayTriangle( Triangle(vec3(0.30000001,1.03767395,1.01542306),vec3(-0.30000001,1.03767395,1.01542199),vec3(-0.30000001,-0.80798203,0.89341998),vec3(-0.00000178,-0.06595831,0.9978224),vec3(0.31999999,0.006154,0.006154)));\n\n    yPlane(Triangle(vec3(0.0,-5.0,0.0),vec3(15.0,0.0,15.0),vec3(0.0),vec3(0.0),vec3(0.3)));\n\n    if (rayHitDist >= maxDist) {\n    \treturn false;\n    }\n    return true;\n}\n\n\n\nvec4 scene() {\n    rayPos = cameraRayPos;\n    rayDir = cameraRayDir;\n\n    if (trace(viewDist)) {\n        vec3 col = 0.5*rayHit.color+max(0.0,dot(lightDir,rayHit.normal))*rayHit.color;\n        \n        rayPos += rayDir*rayHitDist+lightDir*0.01;\n        rayDir = lightDir;\n        #ifdef SHADOWS\n        if (trace(viewDist)) {\n            return col.xyzz*0.5;\n        }\n        #endif\n        \n        return col.xyzz;\n    }\n    \n    return vec4(0.0);\n}\n\n\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tcameraPosition = vec3(sin(iTime*0.1)*10.0,2.0,cos(iTime*0.1)*5.0);\n    cameraDirection = normalize(-cameraPosition);\n\n    lightDir = normalize(vec3(sin(iTime)*10.0,8.0,cos(iTime)*10.0));\n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    cameraUp = cross(cameraRight,cameraDirection);\n    \n    //calculate ray from uv and camera vectors\n    vec3 rPoint = cUv.x*cameraRight +\n                  cUv.y*cameraUp +\n        \t\t  cameraPosition + cameraDirection;\n    \n  \tcameraRayDir = normalize(rPoint-cameraPosition);\n    cameraRayPos = cameraPosition;\n    \n    \n    fragColor = scene();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mts3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 360, 404, 404, 641], [711, 711, 741, 877, 1891], [1905, 1905, 1930, 1930, 2986], [2993, 2993, 3020, 3020, 11808], [11812, 11812, 11826, 11826, 12263], [12305, 12305, 12362, 12362, 13082]]}
{"id": "MtsGzM", "name": "Fractal Flame 2", "author": "daeken", "description": "Another test of my fractal flame shader.", "tags": ["fractal", "flame", "ifs", "shaderforth"], "likes": 6, "viewed": 443, "date": "1420331442", "time_retrieved": "2024-06-20T18:16:15.390775", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\n: rand ( x:float -> float )\n\tx 123 * 17 + sin x 69 * 49 + sin *\n;\n\niResolution frag->position 2 * =p\n\n:m vlinear { } ;\n:m vsine { sin } ;\n:m vspherical { !length / } ;\n:m vswirl { ( $i ) [ i .x 2 sq sin * i .y 2 sq cos * - i .x 2 sq cos * i .y 2 sq sin * + ] } ;\n:m vdisc { ( $i ) [ i length pi * !sin swap cos ] i .y.x atan2 * } ;\n\n[\n\t[ [ 1 0 0 ] 1 10 / [ -.30 time 2.3 / sin * .82 -.90 ] [ -.11 -.23 time 3.7 / sin * 0 ] vlinear ]\n\t[ [ 0 1 0 ] 1 5 / [ .24 -.79 time 4.8 / sin * .73 ] [ .63 -.12 -.25 time 9.7 / sin * ] vsine ]\n\t[ [ 0 0 1 ] .3 [ .98 time sin * .69 -.27 ] [ -.70 .96 .57 time atan * ] vspherical ]\n\t[ [ 1 0 1 ] .5 [ -.13 -.27 time * .19 ] [ .31 -.89 time * .5 ] vswirl ]\n\t[ [ 0 1 1 ] 1 [ .60 -.75 time * -.84 ] [ -.45 time 3 / sin * .14 -.32 ] vdisc ]\n] =>funcs\n\n5 =>runs\n\n[ 0 0 0 0 ] =hist\n\n{ ( i )\n\t[ time p .x + i float 1 + 379 / + rand time 17 * p .y + p .x + i float 1 + 417 / + rand ] =P\n\t[ 0 0 0 ] =C\n\n\t50 =>iters\n\t{ ( ii )\n\t\tP .x 673 * p .y 319 * + time 417 * + rand abs funcs size * floor =ci\n\t\t\t[ funcs enumerate /{ ( [ i [ color weight xvars yvars block ] ] ) [ ci i <=\n\t\t\t\t{\n\t\t\t\t\t[\n\t\t\t\t\t\tP .x xvars .x * P .y xvars .y * + xvars .z +\n\t\t\t\t\t\tP .x yvars .x * P .y yvars .y * + yvars .z +\n\t\t\t\t\t] *block =P\n\t\t\t\t\tC color + 2 / =C\n\t\t\t\t}\n\t\t\t] } /flatten flatten ]\n\t\tcond\n\t\t{\n\t\t\t[ hist .x 1 + hist .yzw P p - length .01 / / C + 2 / ] =hist\n\t\t} P p - length 1 hist .x 3 * / .001 + < ii #20 >= and when\n\t} iters times\n} runs times\n\nhist .yzw hist .x 1 - log * ->fragcolor\n*/\n\nfloat rand(float x) {\n\treturn sin(x * 123. + 17.) * sin(x * 69. + 49.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 P;\n\tvec3 C;\n\tvec4 hist;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) * 2.;\n\thist = vec4(0., 0., 0., 0.);\n\tfor(int temp_7 = 0; temp_7 < 5; ++temp_7) {\n\t\tP = vec2(rand(iTime + p.x + (float(temp_7) + 1.) / 379.), rand(iTime * 17. + p.y + p.x + (float(temp_7) + 1.) / 417.));\n\t\tC = vec3(0., 0., 0.);\n\t\tfor(int temp_9 = 0; temp_9 < 50; ++temp_9) {\n\t\t\tfloat ci = floor(abs(rand(P.x * 673. + p.y * 319. + iTime * 417.)) * 5.);\n\t\t\tif(ci <= 0.) {\n\t\t\t\tP = vec2(P.x * vec3(-.30 * sin(iTime / 2.3), .82, -.90).x + P.y * vec3(-.30 * sin(iTime / 2.3), .82, -.90).y + vec3(-.30 * sin(iTime / 2.3), .82, -.90).z, P.x * vec3(-.11, -.23 * sin(iTime / 3.7), 0.).x + P.y * vec3(-.11, -.23 * sin(iTime / 3.7), 0.).y + vec3(-.11, -.23 * sin(iTime / 3.7), 0.).z);\n\t\t\t\tC = (C + vec3(1., 0., 0.)) / 2.;\n\t\t\t} else if(ci <= 1.) {\n\t\t\t\tP = sin(vec2(P.x * vec3(.24, -.79 * sin(iTime / 4.8), .73).x + P.y * vec3(.24, -.79 * sin(iTime / 4.8), .73).y + vec3(.24, -.79 * sin(iTime / 4.8), .73).z, P.x * vec3(.63, -.12, -.25 * sin(iTime / 9.7)).x + P.y * vec3(.63, -.12, -.25 * sin(iTime / 9.7)).y + vec3(.63, -.12, -.25 * sin(iTime / 9.7)).z));\n\t\t\t\tC = (C + vec3(0., 1., 0.)) / 2.;\n\t\t\t} else if(ci <= 2.) {\n\t\t\t\tP = vec2(P.x * vec3(.98 * sin(iTime), .69, -.27).x + P.y * vec3(.98 * sin(iTime), .69, -.27).y + vec3(.98 * sin(iTime), .69, -.27).z, P.x * vec3(-.70, .96, .57 * atan(iTime)).x + P.y * vec3(-.70, .96, .57 * atan(iTime)).y + vec3(-.70, .96, .57 * atan(iTime)).z) / length(vec2(P.x * vec3(.98 * sin(iTime), .69, -.27).x + P.y * vec3(.98 * sin(iTime), .69, -.27).y + vec3(.98 * sin(iTime), .69, -.27).z, P.x * vec3(-.70, .96, .57 * atan(iTime)).x + P.y * vec3(-.70, .96, .57 * atan(iTime)).y + vec3(-.70, .96, .57 * atan(iTime)).z));\n\t\t\t\tC = (C + vec3(0., 0., 1.)) / 2.;\n\t\t\t} else if(ci <= 3.) {\n\t\t\t\tvec2 macro_temp_4_i = vec2(P.x * vec3(-.13, -.27 * iTime, .19).x + P.y * vec3(-.13, -.27 * iTime, .19).y + vec3(-.13, -.27 * iTime, .19).z, P.x * vec3(.31, -.89 * iTime, .5).x + P.y * vec3(.31, -.89 * iTime, .5).y + vec3(.31, -.89 * iTime, .5).z);\n\t\t\t\tP = vec2(macro_temp_4_i.x * sin(4.) - macro_temp_4_i.y * cos(4.), macro_temp_4_i.x * cos(4.) + macro_temp_4_i.y * sin(4.));\n\t\t\t\tC = (C + vec3(1., 0., 1.)) / 2.;\n\t\t\t} else if(ci <= 4.) {\n\t\t\t\tvec2 macro_temp_5_i = vec2(P.x * vec3(.60, -.75 * iTime, -.84).x + P.y * vec3(.60, -.75 * iTime, -.84).y + vec3(.60, -.75 * iTime, -.84).z, P.x * vec3(-.45 * sin(iTime / 3.), .14, -.32).x + P.y * vec3(-.45 * sin(iTime / 3.), .14, -.32).y + vec3(-.45 * sin(iTime / 3.), .14, -.32).z);\n\t\t\t\tfloat var_9 = length(macro_temp_5_i) * 3.14159;\n\t\t\t\tP = vec2(sin(var_9), cos(var_9)) * atan(macro_temp_5_i.y, macro_temp_5_i.x);\n\t\t\t\tC = (C + vec3(0., 1., 1.)) / 2.;\n\t\t\t}\n\t\t\tif(length(P - p) < (1. / (hist.x * 3.) + .001) && temp_9 >= 20) {\n\t\t\t\thist = vec4(hist.x + 1., (hist.yzw / (length(P - p) / .01) + C) / 2.);\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = vec4(hist.yzw * log(hist.x - 1.), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtsGzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1641, 1662, 1662, 1714], [1715, 1715, 1772, 1772, 4712]]}
{"id": "MtX3DH", "name": "Parthenon", "author": "dr2", "description": "An alternative Parthenon, newly built (use the mouse to help look around).", "tags": ["raymarching", "reflection", "fire", "temple"], "likes": 8, "viewed": 850, "date": "1421574561", "time_retrieved": "2024-06-20T18:16:17.948510", "image_code": "// \"Parthenon\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nint idObj;\nvec3 qHit, fCylPos, sunDir;\nfloat tCur, fCylRad, fCylLen, flmFlkr;\nconst float dstFar = 70.;\nbool tryFlm;\nconst int idLogs = 1, idCoal = 2, idFCyl = 3, idBase = 11, idCol = 12,\n   idColEnd = 13, idRoof = 14, idRoofV = 15, idBall = 16, idPool = 17,\n   idGal = 18, idAltr = 19, idPost = 20;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 p;\n  float cloudFac, w, f;\n  if (rd.y > 0.) {\n    ro.x += 0.1 * tCur;\n    p = 0.05 * (rd.xz * (70. - ro.y) / rd.y + ro.xz);\n    w = 0.8;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.5;  p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.3, 0., 1.);\n    f = max (dot (rd, sunDir), 0.);\n    col =  mix (vec3 (0.2, 0.3, 0.55) + 0.2 * pow (1. - rd.y, 5.) +\n       (0.35 * pow (f, 6.) + 0.65 * min (pow (f, 256.), 0.3)),\n       vec3 (0.85), cloudFac);\n  } else {\n    p = 0.1 * (rd.xz * (10. - ro.y) / rd.y + ro.xz);\n    w = 1.;  f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);  w *= 0.7;  p *= 2.5;\n    }\n    col = mix ((1. + min (f, 1.)) * vec3 (0.15, 0.2, 0.15),\n       vec3 (0.2, 0.3, 0.55) + 0.2, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat BldgDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, da, db, wr;\n  q = p;\n  d = PrBoxDf (q, vec3 (8.6, 0.101, 12.6));\n  q.y -= 0.3;\n  d = max (min (d, PrBoxDf (q, vec3 (8.2, 0.201, 12.2))),\n     - PrBoxDf (q, vec3 (2., 0.25, 6.)));\n  if (d < dHit) { dHit = d;  idObj = idBase;  qHit = q; }\n  q.y -= 5.52;\n  d = max (PrBoxDf (q, vec3 (7.5, 0.05, 11.5)),\n     - PrBoxDf (q, vec3 (2.5, 5., 6.5)));\n  q.xz = mod (q.xz + vec2 (1.), 2.) - 1.;\n  d = max (d, - PrBoxDf (q, vec3 (0.5, 5., 0.5)));\n  if (d < dHit) { dHit = d;  idObj = idGal;  qHit = q; }\n  q = p;  q.y -= 0.4;\n  d = PrBoxDf (q, vec3 (2., 0.01, 6.));\n  if (d < dHit) { dHit = d;  idObj = idPool;  qHit = q; }\n  q = p;  q.y -= 1.;\n  db = max (PrBoxDf (q, vec3 (8., 4.9, 12.)),\n     - PrBoxDf (q, vec3 (2., 10., 6.)));\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y -= 3.14;\n  wr = q.y / 2.36;\n  d = max (PrCylDf (q.xzy, 0.3 * (1.05 - 0.05 * wr * wr), 2.36), db);\n  if (d < dHit) { dHit = d;  idObj = idCol;  qHit = q; }\n  q = p;  q.xz = mod (q.xz, 2.) - 1.;  q.y = abs (q.y - 3.14) - 2.43;\n  d = PrCylDf (q.xzy, 0.4, 0.07);\n  q.y -= 0.14;\n  d = max (min (d, PrBoxDf (q, vec3 (0.5, 0.07, 0.5))), db);\n  if (d < dHit) { dHit = d;  idObj = idColEnd;  qHit = q; }\n  q = p;  q.x = abs (q.x) - 3.;  q.y -= 8.2;\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  d = PrBoxDf (q, vec3 (6., 0.07, 12.3));\n  q.x += 0.4;  q.xz = mod (q.xz, 2.) - 1.;\n  d = max (d, - PrBoxDf (q, vec3 (0.5, 5., 0.5)));\n  if (d < dHit) { dHit = d;  idObj = idRoof;  qHit = q; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (4.1, 7.68, 11.6);\n  d = PrBoxDf (q, vec3 (4.3, 1.9, 0.1));\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  q.xy -= vec2 (-0.4, -2.);\n  d = max (d, PrBoxDf (q, vec3 (4.3, 1.9, 0.1)));\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (2.89, 7.7, 11.6);\n  da = PrBoxDf (q, vec3 (3.2, 1.4, 1.));\n  q.xy = Rot2D (q.xy, 0.15 * pi);\n  q.xy -= vec2 (-0.25, -1.5);\n  d = max (d, - max (da, PrBoxDf (q, vec3 (3.2, 1.4, 1.))));\n  if (d < dHit) { dHit = d;  idObj = idRoofV;  qHit = q; }\n  q = p;  q.y -= 7.7;  q.z = abs (q.z) - 11.6;\n  d = PrCylDf (q.xzy, 0.09, 1.4);\n  if (d < dHit) { dHit = d;  idObj = idRoofV;  qHit = q; }\n  d = PrSphDf (q, 0.4);\n  if (d < dHit) { dHit = d;  idObj = idBall;  qHit = q; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (8.5, 0.6, 12.5);\n  d = PrCylDf (q.xzy, 0.05, 0.5);\n  if (d < dHit) { dHit = d;  idObj = idPost;  qHit = q; }\n  q.y -= 0.7;\n  d = PrSphDf (q, 0.2);\n  if (d < dHit) { dHit = d;  idObj = idBall;  qHit = q; }\n  q = p;  q.y -= 1.5;  \n  d = max (max (PrSphDf (q, 0.78), -0.01 + q.y), -0.3 - q.y);\n  q.y -= -0.7;\n  d = min (d, PrCylDf (q.xzy, 0.15, 0.42));\n  if (d < dHit) { dHit = d;  idObj = idAltr;  qHit = q; }\n  return dHit;\n}\n\nfloat FireDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.x = abs (q.x) - 0.3;\n  q.y -= fCylPos.y - fCylLen + 0.09;\n  d = PrCapsDf (q, 0.12 - 0.04 * Noisefv3a (15. * p), 0.5);\n  if (d < dHit) { dHit = d;  qHit = p;  idObj = idLogs; }\n  q = p;  q.y -= fCylPos.y - fCylLen + 0.25;\n  q.z = abs (q.z) - 0.25;\n  d = PrCapsDf (q.zyx, 0.12 - 0.04 * Noisefv3a (15. * p), 0.45);\n  if (d < dHit) { dHit = d;  qHit = p;  idObj = idLogs; }\n  q = p;  q.x = abs (q.x) - 0.2;\n  q.y -= fCylPos.y - fCylLen + 0.43;\n  d = PrCapsDf (q, 0.12 - 0.04 * Noisefv3a (15. * p), 0.4);\n  if (d < dHit) { dHit = d;  qHit = p;  idObj = idLogs; }\n  q = p;  q.y -= fCylPos.y - fCylLen - 0.01;\n  d = PrCylDf (q.xzy, fCylRad, 0.01);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idCoal; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dHit, d;\n  dHit = dstFar;\n  if (tryFlm) {\n    q = p;  q -= fCylPos;\n    d = PrCylDf (q.xzy, fCylRad, fCylLen);\n    if (d < dHit) { dHit = d;  idObj = idFCyl;  qHit = q; }\n    q = p;  q.y -= 0.4;\n    d = PrBoxDf (q, vec3 (2., 0.01, 6.));\n    if (d < dHit) { dHit = d;  idObj = idPool;  qHit = q; }\n  } else {\n    dHit = 0.9 * BldgDf (p, dHit);\n    dHit = FireDf (p, dHit);\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLight)\n{\n  float sh = 1.;\n  float d = 0.15;\n  for (int i = 0; i < 30; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += max (0.15, 0.01 * d);\n    if (h < 0.01 || d > dLight) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 FireSrcCol (vec3 n)\n{ // Inspired by Dave_H's \"Campfire\", but implementation differs.\n  vec3 col, q;\n  float f, di, gl, bri;\n  if (idObj == idLogs) {\n    n = VaryNf (0.4 * qHit, n, 5.);\n    q = 45. * qHit;  q.y -= 0.8 * tCur;\n    f = Noisefv3a (q);   \n    f += Noisefv3a (10. * qHit) + 0.4 * Noisefv3a (123. * qHit);\n    f = 0.01 * pow (abs (f), 13.) + 0.7 * max (1. - 0.11 * dot (qHit, qHit), 0.);\n    bri = max (dot (normalize (vec3 (0., 0.65 + flmFlkr, 0.) - qHit), n), 0.4);\n    col = bri * bri * f * vec3 (0.5, 0.1, 0.);\n    di = 0.;\n    gl = 0.;\n    for (int i = 0; i < 3; i ++) {\n      di += 0.02;\n      gl += max (0., di - 1.2 * ObjDf (qHit + di * n));\n    }\n    col += flmFlkr * flmFlkr * clamp (2. * gl, 0., 1.) * vec3 (1., 0.3, 0.05);\n  } else if (idObj == idCoal) {\n    q.xz = 20. * qHit.xz;  q.y = tCur;\n    f = Noisefv3a (11. * q);\n    q.y = 0.04 * tCur;\n    f += Noisefv3a (3. * q);\n    bri = 3. - 0.5 * flmFlkr;\n    col = 0.1 * bri * bri * pow (f, 4.) * vec3 (0.7, 0.05, 0.) *\n       (1.1 - pow (length (qHit.xz) / fCylRad, 4.));\n  }\n  return col;\n}\n\nfloat FireLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fh, fr, f;\n  p = ro;\n  dp = (fCylRad / 40.) * rd;\n  g = 0.;\n  for (int i = 0; i < 40; i ++) {\n    p += dp;\n    s = distance (p.xz, fCylPos.xz);\n    q = 4. * p;  q.y -= 6. * tCur;\n    fh = 0.5 * max (1. - (p.y - fCylPos.y) / fCylLen, 0.);\n    fr = max (1. - s / fCylRad, 0.);\n    f = Fbm3 (q);\n    q = 7. * p;  q.y -= 8.5 * tCur;\n    f += Fbm3 (q);\n    g += max (0.5 * fr * fr * fh * (f * f - 0.6), 0.);\n    q = 23. * p;  q.y -= 11. * tCur;\n    g += 1000. * pow (abs (Noisefv3a (q) - 0.11), 64.);\n    if (s > fCylRad || p.y < fCylPos.y - 0.99 * fCylLen || g > 1.) break;\n  }\n  return g;\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  if (idObj == idBase) col = vec3 (0.8, 0.8, 0.7);\n  else if (idObj == idCol || idObj == idColEnd) col = vec3 (0.7, 0.8, 0.6);\n  else if (idObj == idRoof) col = vec3 (0.8, 0.1, 0.1) *\n      (1. - 0.6 * SmoothBump (0.98, 1.02, 0.01, mod (qHit.z, 2.))) *\n      (1. - 0.6 * SmoothBump (0.98, 1.02, 0.01, mod (qHit.x, 2.)));\n  else if (idObj == idRoofV) col = vec3 (0.8, 0.1, 0.1);\n  else if (idObj == idPost) col = vec3 (0.8, 0.1, 0.1);\n  else if (idObj == idBall) col = vec3 (1., 1., 0.1);\n  else if (idObj == idGal) col = vec3 (0.1, 0.3, 0.1);\n  else if (idObj == idAltr) col = vec3 (0.6, 0.5, 0.2);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, rdo, objCol, flmCol, foVec, col, vn;\n  float dstHit, dstFlm, dstHitR, dstFlmR, fIntens, fLum, lDist, sh, bk,\n     dif, ltExt, reflFac, a, f;\n  int idObjT;\n  bool flmRefl, objRefl;\n  fCylPos = vec3 (0., 3.53, 0.);\n  fCylRad = 0.8;\n  fCylLen = 2.;\n  roo = ro;\n  rdo = rd;\n  idObj = -1;\n  tryFlm = true;\n  dstFlm = ObjRay (roo, rdo);\n  flmRefl = false;\n  if (dstFlm < dstFar && idObj == idPool) {\n    dstFlmR = dstFlm;\n    roo += dstFlm * rdo;\n    vn = ObjNf (roo);\n    rdo = reflect (rdo, vn);\n    roo += 0.01 * rdo;\n    idObj = -1;\n    dstFlm = ObjRay (roo, rdo);\n    flmRefl = true;\n  }\n  fIntens = (dstFlm < dstFar) ? FireLum (roo + dstFlm * rdo, rdo, dstFlm) : 0.;\n  flmFlkr = Noiseff (tCur * 64.);\n  idObj = -1;\n  tryFlm = false;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  objRefl = false;\n  reflFac = 1.;\n  if (dstHit < dstFar && idObj == idPool) {\n    dstHitR = dstHit;\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, VaryNf (0.4 * qHit, vn, 0.1));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    if (idObj < 0) dstHit = dstFar;\n    reflFac = 0.8;\n    objRefl = true;\n  }\n  idObjT = idObj;\n  if (dstHit >= dstFar) col = 0.1 * BgCol (ro, rd);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    if (idObj == idBase) vn = VaryNf (10. * qHit, vn, 0.4);\n    if (idObj == idCol) {\n      a = 0.5 - mod (12. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.);\n      vn.xz = Rot2D (vn.xz, -0.1 * pi * sin (pi * a));\n    }\n    if (idObj == idCol || idObj == idColEnd) vn = VaryNf (20. * qHit, vn, 0.3);\n    else if (idObj == idAltr) vn = VaryNf (10. * qHit, vn, 1.);\n    idObj = idObjT;\n    if (idObj == idLogs || idObj == idCoal) col = FireSrcCol (vn);\n    else {\n      objCol = ObjCol (vn);\n      foVec = fCylPos - ro;\n      lDist = length (foVec);\n      foVec /= lDist;\n      sh = ObjSShadow (ro, foVec, lDist);\n      fLum = 5. * sh * (0.6 + 0.4 * flmFlkr) / pow (lDist, 1.5) *\n         max (dot (foVec, vn), 0.);\n      dif = max (dot (vn, sunDir), 0.);\n      bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n      ltExt = 0.1 * (0.4 * (1. + bk) + max (0., dif));\n      col = objCol * (ltExt * vec3 (1.) + fLum * vec3 (1., 0.3, 0.2));\n    }\n  }\n  idObj = idObjT;\n  if (dstHit < dstFar && idObj == idBall) col *= 3.;\n  if (! (dstHit < dstFar && (idObj == idCoal || idObj == idAltr) ||\n     flmRefl == objRefl && dstHit < dstFlm ||\n     objRefl && ! flmRefl && dstHitR < dstFlm ||\n     ! objRefl && flmRefl && dstHit < dstFlmR)) {\n    f = clamp (0.7 * fIntens, 0., 1.);\n    f *= f;\n    f *= f;\n    flmCol = 1.5 * mix (vec3 (1., 0.2, 0.2), vec3 (1., 1., 0.5), f);\n    fIntens *= fIntens;\n    if (idObj == idLogs) fIntens *= 0.03;\n    col = mix (col, flmCol, min (fIntens, 1.));\n  }\n  col *= reflFac;\n  return col;\n}\n\nvec3 SetVuPt (float t)\n{\n  vec4 va, vb;\n  vec3 wPt[11], ro;\n  float tp[11], vel, tVu;\n  wPt[0] = vec3 (0., 8., -20.);     wPt[1] = vec3 (0., 2., -12.);\n  wPt[2] = vec3 (-0.5, 2.5, -6.2);  wPt[3] = vec3 (-2.6, 3., -6.2);\n  wPt[4] = vec3 (-2.6, 4., 8.1);    wPt[5] = vec3 (0., 5.6, 8.9);\n  wPt[6] = vec3 (2.6, 4., 8.1);     wPt[7] = vec3 (2.6, 3., -6.2);\n  wPt[8] = wPt[2];  wPt[9] = wPt[1];  wPt[10] = wPt[0];\n  tp[0]  = 0.;\n  tp[1]  = tp[0] + distance (wPt[1],  wPt[0]); \n  tp[2]  = tp[1] + distance (wPt[2],  wPt[1]); \n  tp[3]  = tp[2] + distance (wPt[3],  wPt[2]); \n  tp[4]  = tp[3] + distance (wPt[4],  wPt[3]); \n  tp[5]  = tp[4] + distance (wPt[5],  wPt[4]); \n  tp[6]  = tp[5] + distance (wPt[6],  wPt[5]); \n  tp[7]  = tp[6] + distance (wPt[7],  wPt[6]); \n  tp[8]  = tp[7] + distance (wPt[8],  wPt[7]); \n  tp[9]  = tp[8] + distance (wPt[9],  wPt[8]); \n  tp[10] = tp[9] + distance (wPt[10], wPt[9]);\n  vel = 0.5;\n  tVu = mod (t, tp[10] / vel) * vel;\n  if (tVu < tp[5]) {\n    if (tVu < tp[1])      { va = vec4 (wPt[0], tp[0]);  vb = vec4 (wPt[1], tp[1]); }\n    else if (tVu < tp[2]) { va = vec4 (wPt[1], tp[1]);  vb = vec4 (wPt[2], tp[2]); }\n    else if (tVu < tp[3]) { va = vec4 (wPt[2], tp[2]);  vb = vec4 (wPt[3], tp[3]); }\n    else if (tVu < tp[4]) { va = vec4 (wPt[3], tp[3]);  vb = vec4 (wPt[4], tp[4]); }\n    else                  { va = vec4 (wPt[4], tp[4]);  vb = vec4 (wPt[5], tp[5]); }\n  } else {\n    if (tVu < tp[6])      { va = vec4 (wPt[5], tp[5]);  vb = vec4 (wPt[6], tp[6]); }\n    else if (tVu < tp[7]) { va = vec4 (wPt[6], tp[6]);  vb = vec4 (wPt[7], tp[7]); }\n    else if (tVu < tp[8]) { va = vec4 (wPt[7], tp[7]);  vb = vec4 (wPt[8], tp[8]); }\n    else if (tVu < tp[9]) { va = vec4 (wPt[8], tp[8]);  vb = vec4 (wPt[9], tp[9]); }\n    else                  { va = vec4 (wPt[9], tp[9]);  vb = vec4 (wPt[10], tp[10]); }\n  }\n  ro = mix (va.xyz, vb.xyz, (tVu - va.w) / (vb.w - va.w));\n  return ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd, vd, u;\n  float zmFac, hLkAt, f;\n  sunDir = normalize (vec3 (1., 1., 1.));\n  hLkAt = 3.;\n  zmFac = 1.4;\n  if (mPtr.z <= 0.) {\n    ro = 0.5 * (SetVuPt (tCur + 0.2) + SetVuPt (tCur - 0.2));\n  } else {\n    ro = SetVuPt (mod (150. * (mPtr.x + 0.45), 1000.));\n    hLkAt += 5. * mPtr.y;\n  }\n  vd = normalize (vec3 (0., hLkAt, 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd);\n  col = sqrt (clamp (col, 0., 1.));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtX3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 264, 288, 288, 338], [340, 340, 364, 364, 411], [413, 413, 437, 437, 676], [678, 678, 703, 703, 833], [835, 835, 860, 860, 1039], [1041, 1041, 1067, 1067, 1361], [1363, 1363, 1384, 1384, 1644], [1646, 1646, 1675, 1675, 1877], [1879, 1879, 1918, 1918, 2125], [2127, 2127, 2159, 2159, 2254], [2256, 2256, 2289, 2289, 2316], [2318, 2318, 2361, 2361, 2434], [2436, 2436, 2478, 2478, 2529], [2531, 2531, 2590, 2590, 2694], [2696, 2696, 2753, 2753, 2836], [2838, 2838, 2868, 2868, 2942], [3245, 3245, 3276, 3276, 4097], [4099, 4099, 4134, 4134, 6770], [6772, 6772, 6807, 6807, 7556], [7558, 7558, 7580, 7580, 7991], [7993, 7993, 8026, 8026, 8202], [8204, 8204, 8225, 8225, 8433], [8435, 8435, 8486, 8486, 8726], [8728, 8728, 8754, 8818, 9798], [9800, 9800, 9846, 9846, 10465], [10467, 10467, 10489, 10489, 11116], [11118, 11118, 11153, 11153, 13963], [13965, 13965, 13989, 13989, 15879], [15881, 15881, 15938, 15938, 16755]]}
{"id": "MtXGDn", "name": "spheart", "author": "brianfrench", "description": "simple sphere", "tags": ["sphere"], "likes": 1, "viewed": 135, "date": "1420668904", "time_retrieved": "2024-06-20T18:16:17.948510", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 l=vec3(.577,-.577,-.577);\n\tvec3 v = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.y, 1.));\n    vec3 o = vec3(sin(iTime),\n                  cos(iTime),\n                  sin(.618*iTime)+2.);\n    \n    \n    float d=dot(o,v)*dot(o,v) - dot(v,v)*(dot(o,o) - 1.);\n    \n    if(d>0.){\n        vec3 p=o + v*(-dot(o,v)+sqrt(d));\n        float m=dot(p,l)*.7;\n        if(m<0.)m*=-.2;\n        m=m*.9+.1;\n        float a=dot(v,2.*p*dot(p,l)-l);\n        //a*=a*(3.-2.*a);\n        //a*=a;\n        fragColor=vec4((sin(p*30.)*.1 + .7)*m + pow(abs(a),19.)*.7, 1.);\n    }else fragColor=vec4(-vec3(.4*dot(l,v)),1.);\n    //fragColor+=vec4(sin(fragCoord.y*234.+fragCoord.x*123.)/255.);\n        //fragColor=vec4(.3,.3,.3,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 784]]}
{"id": "MtXGDr", "name": "Distance function playground", "author": "digital_cucumber", "description": "Just a basic setup to test distance function operations.", "tags": ["raymarching"], "likes": 7, "viewed": 318, "date": "1420721571", "time_retrieved": "2024-06-20T18:16:19.099954", "image_code": "// Distance functions playground, by Ruslan Shestopalyuk, 2014/15\n\n#define PI                      3.14159265\n\n#define MTL_BACKGROUND          -1.0\n#define MTL_GROUND              1.0\n#define MTL_AX                  2.0\n#define MTL_AY                  3.0\n#define MTL_AZ                  4.0\n#define MTL_OBJ1                5.0\n#define MTL_OBJ2                6.0\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         0.001\n#define FAR_CLIP_PLANE          1000.0\n#define MAX_RAYCAST_STEPS       100\n#define STEP_DAMPING            0.9\n#define DIST_EPSILON            0.001\n\n\n#define GLOBAL_LIGHT_COLOR      vec3(0.8,1.0,0.9)\n#define SPEC_COLOR              vec3(0.8, 0.90, 0.60)\n#define BACKGROUND_COLOR        vec3(0.3, 0.342, 0.5)\n\n\n#define CAM_DIST                5.0\n#define CAM_H                   1.5\n#define CAM_FOV_FACTOR          2.5\n#define LOOK_AT_H               0.2\n\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n\n// Primitives\nfloat plane(vec3 p, vec3 n, float offs) { return dot(p, n) - offs; }\nfloat sphere(vec3 p, float r) { return length(p) - r; }\nfloat cone(in vec3 p, vec2 n) { return dot(vec2(length(p.xz), p.y), n);}\nfloat cone(vec3 p, float r, float h) {\n    float ang = atan(r, h);\n    vec2 n = vec2(cos(ang), sin(ang));\n    float d = cone(vec3(p.x, p.y - h, p.z), n);\n    return max(d, -p.y);\n}\n\n\nfloat cylinder(in vec3 p, float r) { return length(p.xz) - r; }\nfloat cylinder(in vec3 p, float r, float h) { return max(cylinder(p, r), abs(p.y) - h*0.5); }\nfloat torus(vec3 p, float ri, float ro) { return length(vec2(length(p.xz) - ri, p.y)) - ro; }\n\n\n// Boolean operations\nfloat diff(float d1, float d2) { return max(-d2, d1); }\nfloat add(float d1, float d2) { return min(d2, d1); }\nfloat intersect(float d1, float d2) { return max(d2, d1); }\n\n// Boolean operations (with material ID in second component)\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\nvoid add(inout vec2 d1, in vec2 d2) { if (d2.x < d1.x) d1 = d2; }\nvoid intersect(inout vec2 d1, in vec2 d2) { if (d1.x < d2.x) d1 = d2; }\n\n\n\n// Affine transformations\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\n\n//  Repetition\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repeatAngS(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\n\n// Helper objects\nfloat star(vec3 p) {\n    p.xy = (repeatAng(p.xy, 5.0)).xy;\n    p.xz = abs(p.xz);\n    return plane(p, vec3(0.5, 0.25, 0.8), -0.09);\n}\n\nvec2 grid(in vec3 p) {\n    p.xz += vec2(0.5, 0.5);\n    p.x = repeat(p.x, 1.0);\n    p.z = repeat(p.z, 1.0);\n    float c = cylinder(p.xzy, 0.003, 1.0);\n    c = add(c,  cylinder(p.yxz, .003, 1.0));\n    return vec2(c, MTL_GROUND);\n}\n\n\nfloat arrow(vec3 p) {\n    float c = cylinder(p - vec3(0.0, 0.5, 0.0), 0.01, 1.0);\n    return add(c, cone(p - vec3(0.0, 1.0, 0.0), 0.03, 0.2));\n}\n\n\nvec2 coordSys(vec3 p) {\n    vec2 ax = vec2(arrow(p.yxz), MTL_AX);\n    vec2 ay = vec2(arrow(p.xyz), MTL_AY);\n    vec2 az = vec2(arrow(p.xzy), MTL_AZ);\n    vec2 res = ax;\n    add(res, ay);\n    add(res, az);\n    return res;\n}\n\n\n// Your distance function here\nfloat distf(vec3 p) {\n    float scale = 0.5;\n    p *= 1.0/scale;\n    vec3 p0 = p;\n    float d = cylinder(translate(p, vec3(0.0, 1.7, 0.0)), 1.2, 0.1);\n    p.xz = repeatAng(p.xz, 5.0).xy;\n    d = add(d, sphere(translate(p, vec3(0.0, 0.0, 1.0)), 0.5));\n    d = add(d, torus(translate(p.xzy, vec3(0.0, 1.0, 1.0)), 0.5, 0.2));\n    d = intersect(d, plane(p0, normalize(vec3(1.0,1.4, 1.0)), 0.8));\n\n    d = add(d, sphere(translate(p, vec3(0.0, -8.0, 0.0)), 8.0));\n    return d*scale;\n}\n\n\nvec2 map(vec3 p) {\n    vec2 res = grid(p);\n    vec2 cs = coordSys(p);\n    add(res, cs);\n    \n    vec2 obj = vec2(distf(p), MTL_OBJ1);\n    \n    add(res, obj);\n    return res;\n}\n\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(\n        map(p + d.xyy).x - map(p - d.xyy).x,\n        map(p + d.yxy).x - map(p - d.yxy).x,\n        map(p + d.yyx).x - map(p - d.yyx).x));\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n    float t = NEAR_CLIP_PLANE;\n    float m = MTL_BACKGROUND;\n    for (int i=0; i < MAX_RAYCAST_STEPS; i++) {\n        vec2 res = map(ro + rd*t);\n        if (res.x < DIST_EPSILON || t>FAR_CLIP_PLANE) break;\n        t += res.x*STEP_DAMPING;\n        m = res.y;\n    }\n\n    if (t > FAR_CLIP_PLANE) m = MTL_BACKGROUND;\n    return vec2(t, m);\n}\n\n\nvec3 getMaterialColor(float matID) {\n    vec3 col = BACKGROUND_COLOR;\n    if (matID <= MTL_GROUND) col = vec3(0.3, 0.3, 0.5);\n    else if (matID <= MTL_AX) col = vec3(1.0, 0.0, 0.0);\n    else if (matID <= MTL_AY) col = vec3(0.0, 1.0, 0.0);\n    else if (matID <= MTL_AZ) col = vec3(0.0, 0.0, 1.0);\n    else if (matID <= MTL_OBJ1) col = vec3(0.8, 0.8, 1.8);\n    else if (matID <= MTL_OBJ2) col = vec3(1.4, 1.3, 0.3);\n    else col = vec3(0.7, 0.7, 1.8);\n    return col;\n}\n\n\nvec3 applyFog(vec3 col, float dist) {\n    return mix(col, BACKGROUND_COLOR, 1.0 - exp(-0.0015*dist*dist));\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec2 res = rayMarch(ro, rd);\n    float t = res.x;\n    float mtlID = res.y;\n    vec3  lig = -rd;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n    vec3 mtlColor = getMaterialColor(mtlID);\n    \n    float ambient = 0.05;\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n\n    vec3 col = mtlColor*(ambient + GLOBAL_LIGHT_COLOR*diffuse);\n    col = applyFog(col, t);\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\n\nvec3 getRayDir(vec3 camPos, vec3 viewDir, vec2 pixelPos) {\n    vec3 camRight = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, viewDir));\n    return normalize(pixelPos.x*camRight + pixelPos.y*camUp + CAM_FOV_FACTOR*viewDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    float ang = 0.1*(40.0 + iTime);\n    vec3 camPos = vec3(CAM_DIST*cos(ang), CAM_H, CAM_DIST*sin(ang));\n    vec3 rayDir = getRayDir(camPos,normalize(LOOK_AT - camPos), p);\n    vec3 color = render(camPos, rayDir);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[958, 972, 1013, 1013, 1040], [1041, 1041, 1072, 1072, 1096], [1097, 1097, 1128, 1128, 1169], [1170, 1170, 1208, 1208, 1350], [1353, 1353, 1389, 1389, 1416], [1417, 1417, 1462, 1462, 1510], [1511, 1511, 1552, 1552, 1604], [1607, 1629, 1661, 1661, 1684], [1685, 1685, 1716, 1716, 1738], [1739, 1739, 1776, 1776, 1798], [1800, 1861, 1899, 1899, 1974], [1975, 1975, 2012, 2012, 2040], [2041, 2041, 2084, 2084, 2112], [2116, 2142, 2174, 2174, 2194], [2195, 2195, 2227, 2227, 2310], [2313, 2328, 2370, 2370, 2418], [2420, 2420, 2453, 2453, 2578], [2580, 2580, 2614, 2614, 2768], [2771, 2789, 2809, 2809, 2921], [2923, 2923, 2945, 2945, 3151], [3154, 3154, 3175, 3175, 3298], [3301, 3301, 3324, 3324, 3523], [3526, 3557, 3578, 3578, 4036], [4039, 4039, 4057, 4057, 4214], [4217, 4217, 4245, 4245, 4447], [4450, 4450, 4489, 4489, 4826], [4829, 4829, 4865, 4865, 5297], [5300, 5300, 5337, 5337, 5408], [5411, 5411, 5448, 5448, 5868], [5871, 5871, 5929, 5929, 6140], [6143, 6143, 6200, 6200, 6557]]}
{"id": "MtXGW8", "name": "Torus beat", "author": "gaz", "description": "Outlines of sliced torus.\nhttps://www.shadertoy.com/view/XtX3WH", "tags": ["parallax"], "likes": 6, "viewed": 215, "date": "1421414003", "time_retrieved": "2024-06-20T18:16:19.099954", "image_code": "vec2 rotate(in vec2 p, in float t)\n{\n\treturn p*cos(-t)+vec2(p.y, -p.x)*sin(-t);\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.05);\n    const float steps = 30.0;\n    float pe = 3.0;\n\tfor(float i = 0.0; i < steps; i++)\n\t{\n        float r = i/steps;\n        float z = -1.0+2.0*r*r;\n        z *= 3.0;\n        float s = pe/(pe+z);\n        vec3 p3 = vec3(p2*s, z);\n    \tp3.zx = rotate(p3.zx, iTime*0.521);\n    \tp3.yz = rotate(p3.yz, iTime*0.632);\n        p3.x += 0.45;\n        float de = sdTorus(p3,\n            vec2(\n                0.7*cos(iTime*1.678)+1.2,\n           \t\t0.35*(sin(iTime*1.234)+1.0)));\n        de = smoothstep(0.08,0.0,de);\n        if (de > 0.0 && de < 0.5)\n        {\n    \t\tcol = vec3(r*0.5+0.5, 1.0-r, r*(sin(iTime*1.987)*2.0-1.0))*(1.0-de*2.0);\n        }\n    }\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 81], [83, 83, 120, 120, 184], [186, 186, 243, 243, 1005]]}
{"id": "Xlf3D8", "name": "scifi", "author": "bergi", "description": "More explorations of the Kali set. \nWatch for at least 5 hours, or play with the offset in line 39.", "tags": ["raymarching", "space", "alien", "science"], "likes": 16, "viewed": 2135, "date": "1421287180", "time_retrieved": "2024-06-20T18:16:20.051610", "image_code": "/*  i like artefacts\n    \n\tAnother nice island in the absdot world\n    https://www.shadertoy.com/view/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n\taGPL3 / (c) 2014 stefan berke\n\n\tWatch for at least 5 hours, or play with the offset in line 39.\n\tBut beware, this is like those Planetarium shows where the camera \n\ttravels with approximately 1000 light years per second to show us \n\tthe beauty of the milky way.\n\tIt's not related to our daily experience. \n\tThe Kali set gets really interesting when we zoom in on a particular\n\tspot. We just need the coordinates!\n*/\n\n#define PATH 3\t\t\t\t// 1-3\n#define NUM_ITER 19\t\t\t// very depended value\n#define NUM_TEX_ITER 60\t\t// iterations for texture\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 100\n#define PRECISSION 0.1\n#define FOG_DIST 0.05\n#define DIMENSIONS 3\t\t// 3 or 4 - complexity switch\n\n#if DIMENSIONS == 3\n// 3 coordinates to navigate through the sets\n// be careful! this is probably where arthur dent lost fenchurch.\n#define MAGIC_PARAM vec3(-.4+0.3*sin(sec/7.), -.8, -1.5 + 0.01*sin(sec/3.))\n\n#elif DIMENSIONS == 4\n// a 4 dimensional key to our three-dimensional space\n#define MAGIC_PARAM vec4(-.4+0.3*sin(sec/17.), -.31, -1.5 + 0.01*sin(sec/13.3), -0.5)\n#endif\n\n// shader-local global animation time\n// add an offset to jump to other places\n#define sec (iTime / 5. + 124.)\n\n\n// -------------------------- fractal -----------------------------\n\n#if DIMENSIONS == 3\n// kali set\n// position range depending on parameters\n// but usually at least +/- 0.01 to 2.0 or even (even much) larger\n// check the camera path's in main(), it's tiny!\nfloat duckball_s(in vec3 p) \n{\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) / mag + MAGIC_PARAM;\n\t}\n\treturn mag;\n}\n\n// same as above but in 'some' color\nvec3 duckball_color(in vec3 p) \n{\n    vec3 col = vec3(0.);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_TEX_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) / mag + MAGIC_PARAM;\n        col += p;\n\t}\n\treturn min(vec3(1.), 2.0 * col / float(NUM_TEX_ITER));\n}\n\n#elif DIMENSIONS == 4\n\nfloat duckball_s(in vec3 pos) \n{\n    vec4 p = vec4(pos, 0.1);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) / mag + MAGIC_PARAM;\n\t}\n    // it seems much more crowded in 4d\n    // so increase the distance to surfaces\n\treturn mag * 2.7;\n}\n\nvec3 duckball_color(in vec3 pos) \n{\n    vec4 p = vec4(pos, 0.1), col = vec4(0.);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_TEX_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) / mag + MAGIC_PARAM;\n        col += p;\n\t}\n\treturn min(vec3(1.), col.xyz / float(NUM_TEX_ITER));\n}\n\n#endif\n\n// ---- canonical shader magic ----\n\nfloat scene_d(in vec3 p)\n{\n\treturn min(50.1+50.*sin(sec/12.), duckball_s(p)*0.01-0.004);\n}\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 scene_color(in vec3 p)\n{\n\tvec3 ambcol = \n        vec3(0.9,0.5,0.1) * (0.2+duckball_color(p));\n    \n    // lighting\n\tfloat dull = max(0., dot(vec3(1.), scene_n(p)));\n\treturn ambcol * (0.3+0.7*dull);\n}\n\nvec3 sky_color(in vec3 pos, in vec3 dir)\n{\n\tvec3 c = vec3(0.2,0.6,0.9);\n    return c * 0.5 + 0.1 * duckball_color(dir + 0.3 * pos);\n}\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n        // increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n\n\t//\tif (d < 0.001)\n\t//\t\tbreak;\n\n\t\tt += d * PRECISSION;\n\t}\n\t\n\treturn mix(scene_color(p), sky_color(p, dir), min(2.6, t/FOG_DIST));\n}\n\n\n\n\n// ---------- helper --------\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \tuv.x *= float(iResolution.x) / float(iResolution.y);\n    \n\t// ray direction (cheap sphere section)\n\tvec3 dir = normalize(vec3(uv, 1.5));\n\n    vec3 pos = vec3(0.   + 0.25 * sin(sec/47.), \n                    0.   + 0.85 * sin(sec/17.), \n                    1.   + 0.95 * sin(sec/20.));\n    dir.xy = rotate(dir.xy, sec*0.7 + sin(sec*0.41));\n    dir.xz = rotate(dir.xz, sec*0.6);\n    \n    \t// run\n\tvec3 col = traceRay(pos, dir);\n  \n   \tfragColor = vec4(traceRay(pos, dir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "agpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlf3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2608, 2645, 2671, 2671, 2735], [2737, 2737, 2762, 2762, 2963], [2965, 2965, 2994, 2994, 3169], [3171, 3171, 3213, 3213, 3304], [3306, 3306, 3347, 3347, 3691], [3696, 3727, 3760, 3760, 3849], [3853, 3853, 3910, 3910, 4447]]}
{"id": "XlfGDN", "name": "HSV2RGB Minified", "author": "MichaelPohoreski", "description": "A cleaned up version of Sam's HSV2RGB()", "tags": ["color", "optimization", "conversion"], "likes": 1, "viewed": 315, "date": "1421960933", "time_retrieved": "2024-06-20T18:16:20.476084", "image_code": "// Optimized version by Michael Pohoreski\n// Copyleft {c} 2015 Michael Pohoreski\n//\n// Original version by Sam\n// GPU version: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// CPU version: http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n//\n// For a slower HSV2RB version also see: http://ploobs.com.br/?p=1499\n\n    // HueSaturationValue to RGB\n    // Input:\n    //    c.x Hue\n    //    c.y Saturation\n    //    c.z Value\n#if 0 // Original\n    vec3 hsv2rgb(vec3 c)\n    {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n#else // Minified/Optimized\n    vec3 hsv2rgb(vec3 c)\n    {\n        //vec3 K = vec3(3,2,1)/3.;\n        //return c.z * mix(K.xxx, clamp(abs(fract(c.xxx + K)*6. - vec3(3.)) - K.xxx, 0., 1.), c.y);\n        // Which can be further optimized to:\n        // Thanks to las @ http://www.pouet.net/user.php?who=4548\n        return mix(vec3(1.),clamp((abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),c.y)*c.z;\n    }\n\n    vec3 hue2rgb(float normalizedHueAngle)\n    {\n        return clamp(abs(fract(vec3(normalizedHueAngle)+vec3(3,2,1)/3.)*6.-3.)-1., 0., 1.);\n    }\n#endif\n\n// Thanks yakoudbz for this idea to minimize the discontinuity!\n// Unfortunately there is no good way to remove the discontinuity as it needs to be an _integer_ multiple.\n// See this version which does a straight linear blend between N an N+1\n// https://www.shadertoy.com/view/XtfGDN\n#define MIN_DISCONTUINITY\n//    const float PI = 3.14159265358979323846264;\n//    float N = 2.+cos(iTime);\n//    float d = atan(p.y,p.x) * N/PI;\n// To \"single step\" the rainbow\n//     float N = floor(iTime);\n//\n// Legend:\n//   d = angle (was originally in degrees)\n//   c = color\n//   m = mix\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  p = 2.*fragCoord.xy/iResolution.xy - 1.; // uv coordinates -1 .. +1\n    float d = atan(p.y,p.x) + iTime; // angle\n#ifdef MIN_DISCONTUINITY\n    const float PI = 3.14159265358979323846264;\n    float N = 2.+cos(iTime);\n    d -= iTime;\n    d *= N/PI; // Technically should be N/(2.0*PI), but N/PI looks better with twice the rings\n#endif\n    vec3  c = hsv2rgb( vec3(d,1.0,1.0) ); // hsv\n    vec3  m = vec3(c.r,c.g,c.b);\n    fragColor = vec4(m, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1541, 1808, 1865, 1865, 2324]]}
{"id": "Xll3Wn", "name": "The Institute", "author": "eiffie", "description": "Although their accomplishments were few the real pride of the institute was their well lit ample parking.", "tags": ["partitions"], "likes": 16, "viewed": 1276, "date": "1420826241", "time_retrieved": "2024-06-20T18:16:21.451723", "image_code": "//The Institute by eiffie\n\n#define time iTime\n#define size iResolution\n#define AUTO_OVERSTEP\n\nfloat px;\nvec4 prp=vec4(0.0);\nvec3 L;\n\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 fragCoord){\n\treturn 0.5+0.5*rnd(fragCoord.xy);\n}\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\nfloat noyz(vec2 p){//value noise - original author??\n\tvec2 c=floor(p),f=fract(p);f=f*f*(3.0-2.0*f);\n\tfloat k=257.0,u=c.x+c.y*k;\n\tvec4 v=vec4(u,u+1.0,u+k,u+k+1.0);v=fract(fract(v*1.23456789)*9.18273645*v);\n\treturn mix(mix(v.x,v.y,f.x),mix(v.z,v.w,f.x),f.y);\n}\nfloat fbm(vec2 p){\n\tvec2 s=sin(p*0.3+2.4*sin(p.yx*0.3));\n\tfloat h=1.0+(s.x+s.y)*0.5,a=0.5;\n\tp+=s.yx*0.66;\n\tfor(int i=0;i<3;i++){\n\t\th+=noyz(p)*a;\n\t\ta*=0.3;p=vec2(p.x+p.y*0.7,p.x-p.y+0.13)*2.0;\n\t}\t\n\treturn h;\n}\nvec3 Sky(vec3 rd){\n\tvec3 col=mix(vec3(0.4,0.2,0.0),vec3(0.5,0.7,0.7),clamp(0.25-0.5*rd.z,0.0,1.0));\n\tcol+=vec3(1.2,1.1,0.9)*pow(max(0.0,dot(rd,L)),100.0);\n\tfloat h=noyz(rd.xy*5.0)*0.5+noyz(vec2(2.0*abs(atan(rd.y,rd.x)),rd.z*20.0));\n\tcol=mix(col,vec3(0.9,0.8,0.6),clamp(h*0.5-0.4,0.0,1.0));\n\treturn mix(vec3(0.1,0.2,0.1),col,clamp((-rd.z+0.05)*20.0,0.0,1.0));\n}\n\nfloat capsule(vec3 p){return length(vec3(p.x,p.y-clamp(p.y,-3.0,10.0),p.z));}\nfloat rcap(vec3 p){return length(vec2(p.x-clamp(p.x,-7.0,7.0),max(abs(p.y),abs(p.z))));}\n\nfloat DE(in vec3 p){\n\tfloat layoutv=(length(p.xy+vec2(8.0,-6.0))-45.0);\n\tlayoutv=smin(layoutv,abs(p.y-28.0+sin(p.x*0.01)*40.0)-5.0,20.0)*0.02;\n\tfloat h=fbm(p.xy*0.1)*10.0*pow(clamp(layoutv,0.0,1.0),0.7),d=-p.z+7.0-h,dG=d;\n\tfor (int n = 0; n < 4; n++) {\n\t\tp=clamp(p, -3.1, 3.1) *2.0-p;\n\t\tp+=vec3(1.9,3.2,8.6);\n\t\tp=p.yzx;\n\t\td=min(d,min(capsule(p)-3.0,rcap(p)-2.0));\n\t}\n\t\n\tif(d<0.25 && d<dG){\n\t\tfloat flr=floor(p.y);\n\t\tfloat rs=1.0+sin(flr)*0.5;\n\t\tp=vec3(rs,1.0,rs)*0.5-abs(mod(p,vec3(rs,1.0,rs))-vec3(rs,1.0,rs)*0.5);\n\t\tfloat d2=d+0.05;\n\t\tif(flr<-rs || rs<0.6)\n\t\t\td=min(d2,max(d,min(p.y,min(p.x,p.z))-0.0125));\n\t\telse if(flr<rs*2.0 || rs<0.75)\n\t\t\td=max(d,min(p.y,min(p.x,p.z))-0.025);\n\t\telse {\n\t\t\td=max(d,min(p.y,max(p.x,p.z))-0.05);\n\t\t\tif(prp.x<0.0)prp=vec4((rs>1.3)?length(p):10.0,0.0,0.0,(max(p.x,p.z)<0.06)?4.0:3.0);\n\t\t}\n\t\tif(prp.x<0.0){\n\t\t\tif(d==d2)prp=vec4(10.0,0.0,0.0,2.0);\n\t\t\telse prp=vec4(10.0,0.0,0.0,3.0);\n\t\t}\n\t}else if(prp.x<0.0)prp=vec4(10.0,h,layoutv,1.0);\n\treturn d;\n}\n\nfloat shadao(vec3 ro, vec3 rd, float px,vec2 fragCoord){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=10.0*px*rndStart(fragCoord);\n\tfor(int i=0;i<12;i++){\n\t\td=max(0.0,DE(ro+rd*t)*1.5);\n\t\tt+=d;\n\t\tres=min(res,d/t);\n\t}\n\treturn res;\n}\n\nvec3 Color(vec3 ro, vec3 rd, float t, vec3 col, bool bFill, vec2 fragCoord){\n\tro+=rd*t;\n\tprp.x=-1.0;\n\tfloat d=DE(ro),spec=0.0,n=noyz(ro.xy*3.0);\n\tvec2 e=vec2(px*t,0.0);\n\tvec3 dn=vec3(DE(ro-e.xyy),DE(ro-e.yxy),DE(ro-e.yyx));\n\tvec3 dp=vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\tvec3 R=reflect(rd,N);\n\tvec3 lc=vec3(1.0,0.9,0.8),sc,rc=Sky(R);\n\tif(prp.w<1.5){\n\t\tsc=mix(vec3(0.8,0.8,0.3),vec3(0.2),clamp(abs(abs(ro.y-28.0+sin(ro.x*0.01)*40.0)-0.25)*4.0,0.0,1.0));\n\t\tsc=mix(sc,mix(vec3(0.2,0.3,0.1),vec3(0.6,0.5,0.4),clamp(prp.y*0.05-0.25,0.0,1.0)),clamp(prp.z*100.0,0.0,1.0));\n\t\tspec=0.2;//clamp(2.5-prp.y,0.0,1.0);\n\t\tn*=0.1;\n\t}else if(prp.w<2.5){sc=vec3(0.4,0.5,0.6);spec=1.0;n*=0.3;\n\t}else if(prp.w<3.5){sc=vec3(0.6,0.63,0.62);spec=0.5;n*=0.4;}\n\telse {sc=vec3(0.5,0.5,0.0);spec=0.5;}\n\tsc*=(1.0-n);\n\tfloat sh=clamp(shadao(ro,L,px*t,fragCoord)+0.2,0.0,1.0);\n\tsh=sh*(0.5+0.5*dot(N,L))+exp(-prp.x*5.0);\n\tvec3 scol=sh*lc*(sc+0.5*spec*rc*pow(max(0.0,dot(R,L)),2.0));\n\tif(bFill)d*=0.05;\n\tcol=mix(scol,col,clamp(d/(px*t),0.0,1.0));\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,0.0,-1.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvec3 cpnt(float t){\n\tif(t<0.5)return vec3(-45.0,30.0,-38.0);\n\tif(t<1.5)return vec3(-20.0,23.0,-25.0);\n\tif(t<2.5)return vec3(-13.0,23.0,-2.5);\n\tif(t<3.5)return vec3(10.0,26.0,-2.5);\n\treturn vec3(12.0,21.0,6.6);\n}\nvec3 path(float t){\n\tfloat t2=t-t*t*0.05;\n\tif(t<10.0)return vec3(-1000.0+t2*200.0,30.0-sin((-1000.0+t2*200.0)*0.01)*40.0,4.25);\n\tt2=time-10.0;\n\tfloat r=60.0-t2;\n\tif(t<25.0)return vec3(-8.0+r*cos(t2*0.3),6.0+r*sin(t2*0.25),-t2*4.0);\n\tif(t<45.0){\n\t\tt2=(t-25.0)/5.0;r=floor(t2);t2=fract(t2);\n\t\treturn mix(cpnt(r),cpnt(r+1.0)-0.25*cpnt(r+2.0)*(1.0-t2),t2);\n\t}\n\tif(t<60.0){\n\t\tt2=t-45.0;\n\t\tt2=t2-t2*t2*0.025;\n\t\tr=500.0-t2*50.0;\n\t\tvec3 p=vec3(cos(t2*0.2)*r,sin(t2*0.2)*r,-30.0);\n\t\tfloat d1=DE(p),d2=DE(p+vec3(0.0,-10.0,0.0));\n\t\tp.z+=(d1+d2)*0.4;\n\t\treturn p;\n\t}\n\treturn vec3(-8.0+cos(t*0.3)*60.0,6.0+60.0*sin(t*0.2),-29.5+sin(t*0.1)*10.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpx=0.5/size.y;\n\tL=normalize(vec3(0.5,0.3,-0.6));\n\tfloat tim=time;\n\tvec3 ro=path(tim);\n\tvec3 ta=path(tim+0.5);\n\tif(tim>10.0 && tim<25.0)ta=vec3(0.0);\n\tif(tim>60.0)ta=vec3(0.0,0.0,-20.0);\n\tvec3 rd=lookat(ta-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,3.0));\n\t//ro=eye*10.0;rd=normalize(dir);\n\tfloat t=DE(ro)*rndStart(fragCoord),d=0.0,od=1.0,step=0.0,os=0.0,pd=10.0;\n\tif(t<0.0){\n\t\tfragColor=vec4(0.0,0.0,0.0,1.0);\n\t\treturn;\n\t}\n\tvec4 edge=vec4(-1.0);\n\tbool bGrab=false;\n\tfor(int i=0;i<78;i++){\n\t\tt+=step;\n\t\td=DE(ro+rd*t);\n#ifdef AUTO_OVERSTEP\n\t\tif(d>=os){\t\t//we have NOT stepped over anything\n\t\t\tos=0.36*d*d/pd;//overstep based on ratio of this step to last\n\t\t\tstep=d+os;\t//add in the overstep\n\t\t\tpd=d;\t\t//save this step length for next calc\n\t\t}else{step=-os;d=0.0001;pd=100000.0;os=0.0;}//remove overstep\n#else\n\t\tstep=d;\n#endif\n\n\t\tif(d>od){\n\t\t\tif(bGrab && od<px*t && edge.x<0.0){\n\t\t\t\tedge=vec4(edge.yzw,t-od);\n\t\t\t\tbGrab=false;\n\t\t\t}\n\t\t}else bGrab=true;\n\t\tod=d;\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tbool bFill=false;\n\td*=0.05;\n\tif(d<px*t){\n\t\tif(edge.x>0.0)edge=edge.wxyz;\n\t\tedge=vec4(edge.yzw,t);\n\t\tbFill=true;\n\t}\n\tvec3 col=Sky(rd);\n\tfor(int i=0;i<4;i++){\n\t\tif(edge.w>0.0)col=Color(ro,rd,edge.w,col,bFill,fragCoord);\n\t\tedge=edge.wxyz;\n\t\tbFill=false;\n\t}\n\tfloat dimmer=clamp(min(abs(time-10.0),min(abs(time-25.0),min(abs(time-45.0),abs(time-60.0)))),0.0,1.0);\n\tfragColor = vec4(1.5*col*dimmer*dimmer,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xll3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 133, 151, 151, 206], [207, 207, 238, 238, 275], [276, 276, 312, 312, 375], [376, 376, 395, 428, 634], [635, 635, 653, 653, 843], [844, 844, 862, 862, 1204], [1206, 1206, 1228, 1228, 1283], [1284, 1284, 1303, 1303, 1372], [1374, 1374, 1394, 1394, 2356], [2358, 2358, 2414, 2443, 2591], [2593, 2593, 2669, 2669, 3688], [3689, 3689, 3710, 3710, 3811], [3812, 3812, 3831, 3831, 4023], [4024, 4024, 4043, 4043, 4657], [4658, 4658, 4715, 4715, 6127]]}
{"id": "Xll3zM", "name": "Peering Through the Eye", "author": "colinwackl", "description": "Just tooling around with julia sets, trying to get a handle for them.", "tags": ["perlinnoise", "juliaset"], "likes": 3, "viewed": 193, "date": "1420171253", "time_retrieved": "2024-06-20T18:16:22.439870", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec3 noiseSample(vec2 uv)\n{\t\n\tfloat f = 0.0;\n    \n    //uv *= 1.25;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f += 0.0625*snoise( vec3(uv ,iTime/2.0)); uv = m*uv;\n    f += 1.3125*snoise( vec3(uv ,iTime/2.0)); uv = m*uv;\n    f += 0.015725*snoise( vec3(uv ,iTime/2.0)); uv = m*uv;\n    f += 0.00125*snoise( vec3(uv ,iTime/2.0)); uv = m*uv;\n    f += 0.000525*snoise( vec3(uv ,iTime/2.0)); uv = m*uv;\n\n\tf = 0.5 + 0.5*f;\n\t\n    return vec3(f,f,f);\n}\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 juliaSet(vec2 p)\n{\n    //p = p * 2.0 - 1.0;\n    //p = p / ((p.x * p.x) + (p.y * p.y));\n\n    /*vec2 cc = 1.1*vec2( 1.5*cos(0.1*iTime) - 0.25*cos(0.2*iTime), \n\t                    1.5*sin(0.1*iTime) - 0.25*sin(0.2*iTime) );*/\n    \n    vec2 cc = 1.1*vec2( 0.5*cos(0.1*iTime) - 0.25*cos(0.2*iTime), \n\t                    0.5*sin(0.1*iTime) - 0.25*sin(0.2*iTime) );\n    \n    /*vec2 cc = 1.1*vec2( 40.5*cos(0.1*iTime) - 20.25*cos(0.2*iTime), \n\t                    40.5*sin(0.1*iTime) - 20.25*sin(0.2*iTime) );*/\n\n\tvec4 dmin = vec4(1000.0);\n    vec2 z = (-1.0 + 2.0*p)*vec2(1.7,1.0);\n    for( int i=0; i<4; i++ )\n    {\n        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y );\n\n\t\tdmin=min(dmin, vec4(abs(0.0+z.y + 0.5*sin(z.x)), \n\t\t\t\t\t\t\tabs(1.0+z.x + 0.5*sin(z.y)), \n\t\t\t\t\t\t\tdot(z,z),\n\t\t\t\t\t\t    length( fract(z)-0.5) ) );\n    }\n\n\treturn dmin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n  \n    vec4 dmin = juliaSet(p);\n    \n    float wave = sin(iTime) * 0.5 - 1.0;\n    wave = 1000.0;\n    \n    vec3 color = vec3( dmin.w );\n\tcolor = mix( color, vec3(0.50,0.80,0.90),     min(1.0,pow(dmin.x*0.25,0.20)) );\n    color = mix( color, vec3(0.072,0.070,0.060),     min(1.0,pow(dmin.y*0.50,0.50)) );\n\tcolor = mix( color, vec3(5.00,5.00,5.00), 1.0-min(1.0,pow(dmin.z*1.00,0.15) ));\n  \n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);\n    vec3 noise = noiseSample(uv);\n    \n    color += noise / 4.0;\n    \n\tcolor = 1.25*color*color;\n\t\n\tcolor *= 0.5 + 0.5*pow(16.0*p.x*(1.0-p.x)*p.y*(1.0-p.y),0.15); \n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Xll3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 394, 415, 415, 464], [466, 466, 487, 487, 536], [538, 538, 560, 560, 600], [602, 602, 630, 630, 682], [684, 684, 708, 708, 2854], [2856, 2856, 2883, 2883, 3304], [3306, 3431, 3454, 3659, 4271], [4273, 4273, 4330, 4330, 5013]]}
{"id": "XllGDH", "name": "[2TC 15] spring time", "author": "bergi", "description": "It's cold outside while GPUs are running hot..", "tags": ["kaliset", "2tc"], "likes": 5, "viewed": 1291, "date": "1421716158", "time_retrieved": "2024-06-20T18:16:22.439870", "image_code": "// yeah, spring is due\n//\n// For-fun entry for the 2 Tweets Challenge\n// (c) stefan berke\n// \n// credits to Kali for the magic formula\n// can not stop using it...\n//\nvoid mainImage( out vec4 f, in vec2 w )\n{\n\tfloat t = iTime/11.;\n    vec2 uv = (.2 + .05 * sin(t*1.1)) * w / iResolution.y + .2 * vec2(2.2+1.*sin(t), .4+.4*cos(t*.9));\n    \n    for (int i=0; i<11; ++i)\n        uv = abs(uv) / dot(uv,uv) - vec2(.81-.1*uv.y);\n    \n\tf = vec4(uv*uv, uv.y-uv.x, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 166, 207, 207, 461]]}
{"id": "XllGDr", "name": "Icy Moon", "author": "dr2", "description": "Who knows what they will find?", "tags": ["raymarching", "shapes", "saturn", "nv15"], "likes": 11, "viewed": 928, "date": "1420998502", "time_retrieved": "2024-06-20T18:16:22.458139", "image_code": "// \"Icy Moon\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nint idObj;\nmat3 objMat;\nvec3 objPos, qHit, sunDir;\nfloat tCur;\nconst float dstFar = 200.;\nvec3 satnPos = vec3 (-5., 25., 50.), satnCol = vec3 (1., 0.9, 0.5);\nconst int idBase = 1, idPlat = 2, isShel = 3, idFrm = 4, idDway = 5,\n  idTwr = 6, idBrg = 7, idBrCab = 8, idRdw = 9, idGem = 10, idSat = 11,\n  idRng = 12, idRefl = 13;\n\nfloat IceHt (vec3 p)\n{\n  p *= 0.3;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 1.5 * wb;\n  for (int j = 0; j < 3; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return 0.5 * ht;\n}\n\nvec3 IceNf (vec3 p, float d)\n{\n  float ht = IceHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - IceHt (p + e.xyy), e.x, ht - IceHt (p + e.yyx)));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat AngQnt (float a, float s1, float s2, float nr)\n{\n  return (s1 + floor (s2 + a * (nr / (2. * pi)))) * (2. * pi / nr);\n}\n\nfloat BridgeDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float wRd = 1.;\n  q = p;  q.y -= -1.;\n  d = PrBoxDf (q, vec3 (wRd, 0.1, 21.));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRdw; }\n  q = p;  q.x = abs (q.x);  q.xy -= vec2 (wRd - 0.1, 2.);\n  q.z = mod (q.z + 0.75, 1.5) - 0.75;\n  d = PrCylDf (q.xzy, 0.07, 3.);\n  q = p;  q.y -= 2.;\n  d = max (d, PrBoxDf (q, vec3 (wRd, 3., 9.8)));\n  q = p;  q.y -= 13.;\n  d = max (d, - PrCylDf (q.yzx, 13., 1.01));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.x = abs (q.x);  q.xy -= vec2 (wRd - 0.1, 13.);\n  d = max (PrTorusDf (q.yzx, 0.1, 13.), q.y + 8.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (wRd - 0.1, 1.5, 13.5);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  d = PrCylDf (q, 0.1, 4.5);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrCab; }\n  q = p;  q.z = abs (q.z);  q.yz -= vec2 (0., 10.2);\n  d = PrBoxDf (q, vec3 (wRd + 0.2, 5., 0.2));\n  q.y -= -0.3;\n  d = max (d, - PrBoxDf (q, vec3 (wRd - 0.1, 4.8, 0.21)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBrg; }\n  return dHit;\n}\n\nfloat DwayDf (vec3 p, float h1, float h2, float h3)\n{\n  return max (length (p.yz -\n     vec2 (h1 * clamp (p.y / h1, -1., 1.), 0.)) - h2, abs (p.x) - h3);\n}\n\nfloat CageDf (vec3 p, float dHit)\n{\n  const float rad = 6., hLen = 8., wg = 0.5, ww = 0.03, wThk = 0.05,\n     doorHt = 2., doorWd = 1.5;\n  vec3 q, c1, c2;\n  vec2 qo;\n  float d, ds, dd, a;\n  q = p;\n  q.y -= hLen;\n  c1 = vec3 (0., hLen * clamp (q.y / hLen, -1., 1.), 0.);\n  c2 = vec3 (0., (hLen - wThk) * clamp (q.y / (hLen + wThk), -1., 1.), 0.);\n  d = max (max (length (q - c1) - rad,\n     - (length (q - c2) - (rad - wg))), - q.y);\n  a = atan (q.z, - q.x);\n  q = p;  q.y -= hLen + 0.5 * rad;\n  q.xz = Rot2D (q.xz, AngQnt (a, 0.5, 0., 8.));\n  q.x += 0.5 * rad;\n  ds = PrBoxDf (q, vec3 (0.5 * rad, hLen + 0.5 * rad, 2. * ww));\n  q = p;  q.y = mod (q.y - 1.5, 3.) - 1.5;\n  d = max (d, min (ds, PrBoxDf (q, vec3 (rad, 2. * ww, rad))));\n  q = p;\n  qo = Rot2D (q.xz, AngQnt (a, 0.5, 0., 4.));\n  q.xz = qo;  q.xy -= vec2 (- rad, hLen + 1.2 * doorHt);\n  dd = DwayDf (q, doorHt, doorWd, 0.2 * rad);\n  d = max (d, - dd);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idFrm; }\n  q = p;  q.y -= hLen;\n  d = max (max (max (max (length (q - c1) - (rad - 0.4 * wg),\n     - (length (q - c2) - (rad - 0.6 * wg))), - q.y), - ds), - dd);\n  q = p;  q.y -= 2. * hLen + rad;\n  d = max (d, - PrCylDf (q.xzy, 0.5 * rad, 0.2 * rad));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = isShel; }\n  q = p;  q.xz = qo;  q.xy -= vec2 (-0.98 * rad, hLen + 1.2 * doorHt);\n  d = max (max (max (DwayDf (q, doorHt, doorWd, 0.1 * rad),\n     - DwayDf (q, doorHt - ww, doorWd - ww, 0.1 * rad + wThk)),\n     - (q.y + 2. * doorHt - ww - wThk)), - (q.y + 1.2 * doorHt));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idDway; }\n  return dHit;\n}\n\nfloat CentStrucDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xz = abs (q.xz) - vec2 (4.);  q.y -= -5.;\n  d = max (max (PrSphDf (q, 5.), - PrSphDf (q, 4.7)), - min (4. - q.y, q.y));\n  q.y -= 2.3;\n  d = max (d, - min (PrCylDf (q.yzx, 1., 6.), PrCylDf (q, 1., 6.)));\n  q.y += 0.5;\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBase; }\n  q = p;  q.y -= -1.;\n  d = PrTorusDf (q.xzy, 0.4, 8.5);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idPlat; }\n  d = PrCylDf (q.xzy, 8.5, 0.1);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idPlat; }\n  q = p;  q.y -= -9.; \n  dHit = CageDf (q, dHit);\n  return dHit;\n}\n\nfloat CornStrucDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, a;\n  q = p;  q.y -= -5.;\n  d = max (max (PrSphDf (q, 5.), - PrSphDf (q, 4.7)), - min (3.9 - q.y, q.y));\n  q.y -= 2.3;\n  d = max (d, - min (PrCylDf (q.yzx, 1., 6.), PrCylDf (q, 1., 6.)));\n  q.y -= 1.5;\n  d = min (d, PrCylDf (q.xzy, 3., 0.1));\n  q.y += 2.;\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idBase; }\n  q = p;  q.y -= 1.;\n  d = max (max (PrCapsDf (q.xzy, 2.5, 3.), - PrCapsDf (q.xzy, 2.3, 3.)), -2.2 - q.y);\n  q = p;  q.y -= 7.;\n  d = min (d, max (PrCapsDf (q.xzy, 0.7, 2.), -1. - q.y));\n  q = p;  q.y -= 0.;\n  q.xz = Rot2D (q.xz, AngQnt (0.5 + atan (q.z, - q.x), 0., 0., 4.));\n  q.x += 2.;\n  d = max (d, - DwayDf (q, 2., 1., 2.4));\n  q = p;  q.y -= 4.;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = max (d, - min (PrCylDf (q.yzx, 1., 3.), PrCylDf (q, 1., 3.)));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idTwr; }\n  return dHit;\n}\n\nfloat SatnDf (vec3 p, float dHit)\n{\n  const float dz = 6., radO = 9., radI = 6.5;\n  vec3 q;\n  float d;\n  q = p;\n  q -= satnPos; \n  q.yz = Rot2D (q.yz, -0.2 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * pi);\n  d = PrSphDf (q, 5.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idSat; }\n  q.z += dz;\n  d = PrTorusDf (q, radI, radO);\n  q.z -= 2. * dz;\n  d = max (d, PrTorusDf (q, radI, radO));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRng; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  float dHit = dstFar;\n  dHit = SatnDf (p, dHit);\n  p = objMat * (p - objPos);\n  q = p;\n  q.xz = Rot2D (q.xz, AngQnt (atan (q.z, - q.x), 0., 0.5, 4.));\n  q.x += 20.;\n  dHit = BridgeDf (q, dHit);\n  q = p;  q.xz = abs (q.xz) - vec2 (10.);  q.y -= -1.;\n  d = max (max (PrCylDf (q.xzy, 10.9, 0.1), - PrCylDf (q.xzy, 9.1, 0.11)),\n     max (- q.x, - q.z));\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRdw; }\n  q = p;\n  dHit = CentStrucDf (q, dHit);\n  q.y -= 0.1; \n  d = PrSphDf (q, 1.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idGem; }\n  q = p;  q.xz = abs (q.xz) - vec2 (20.);\n  dHit = CornStrucDf (q, dHit);\n  q.y -= -0.1; \n  d = PrSphDf (q, 0.7);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idGem; }\n  q = p;\n  q.y -= -6.2;\n  d = PrCylDf (q.xzy, 100., 2.);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = idRefl; }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.2;\n  for (int i = 0; i < 30; i ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec3 col;\n  float spec;\n  spec = 1.;\n  if (idObj == idBase) {\n    if (qHit.y < -1.) col = vec3 (0.1, 0.2, 0.1);\n    else if (qHit.y > -0.6 || n.y < 0.) col = vec3 (0.1, 0.5, 0.1);\n    else col = mix (vec3 (1., 1., 0.), vec3 (0., 1., 1.),\n       floor (mod (32. * atan (qHit.z, - qHit.x) / (2. * pi), 2.)));\n  } else if (idObj == idPlat) col = vec3 (0.9, 0.9, 0.1);\n  else if (idObj == isShel) col = vec3 (1., 1., 1.);\n  else if (idObj == idFrm) col = vec3 (0.8, 0.8, 0.);\n  else if (idObj == idDway) col = vec3 (0.8, 0.3, 0.);\n  else if (idObj == idTwr) col = vec3 (0.9, 0.7, 0.6);\n  else if (idObj == idBrg) col = vec3 (1., 1., 0.2);\n  else if (idObj == idBrCab) col = vec3 (1., 0.7, 0.);\n  else if (idObj == idRdw) col = vec3 (0.2, 0.15, 0.15);\n  else if (idObj == idGem) {\n    col = vec3 (1., 0.1, 0.1);\n    spec = 5.;\n  } else if (idObj == idSat) col = satnCol * vec3 (1., 0.9, 0.9) *\n     clamp (1. - 0.2 * Noiseff (12. * qHit.z), 0., 1.);\n  else if (idObj == idRng) col = satnCol *\n     (1. - 0.4 * SmoothBump (9.3, 9.5, 0.01, length (qHit.xy)));\n  if (idObj == idSat || idObj == idRng) spec = 0.02;\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  vec4 objCol;\n  float dstHit, sh;\n  int idObjT;\n  bool reflRay;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  reflRay = false;\n  if (dstHit < dstFar && idObj == idRefl) {\n    ro += rd * dstHit;\n    rd = reflect (rd, IceNf (objMat * (ro - objPos), dstHit));\n    ro += 0.01 * rd;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n    reflRay = true;\n  }\n  if (dstHit >= dstFar) col = vec3 (0., 0., 0.02) + 0.03 * satnCol *\n     pow (clamp (dot (rd, normalize (satnPos - ro)), 0., 1.), 128.);\n  else {\n    idObjT = idObj;\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    if (idObj != idSat && idObj != idRng) vn = objMat * vn;\n    idObj = idObjT;\n    if (idObj == idBase && qHit.y < -1.) vn = VaryNf (2. * qHit, vn, 5.);\n    if (idObj == idRdw) vn = VaryNf (5. * qHit, vn, 1.);\n    objCol = ObjCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    float bBri = 0.2 +\n       0.2 * max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.) +\n       0.5 * max (0., max (dot (vn, sunDir), 0.)) * sh;\n    if (idObj == idGem) bBri *= 1.2 + 0.2 * sin (10. * tCur);\n    col = objCol.rgb * (bBri + 0.5 * objCol.a *\n       pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n    if (reflRay) col = vec3 (0.1) + 0.8 * col;\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec3 ro, rd, vd;\n  float az, el, dist;\n  sunDir = normalize (vec3 (cos (0.4 * tCur), 1., sin (0.4 * tCur)));\n  rd = normalize (vec3 (uv, 4.));\n  az = 0.1 * pi * (1. - 2. * SmoothBump (15., 45., 10., mod (tCur, 60.)));\n  vec3 ca = cos (vec3 (0., az, 0.));\n  vec3 sa = sin (vec3 (0., az, 0.));\n  objMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  dist = 100.;\n  ro = vec3 (0., 0., - dist);\n  objPos = ro * objMat - ro;\n  vd = normalize (vec3 (objPos - ro));\n  rd.xz = Rot2D (rd.xz, atan (- vd.x, vd.z));\n  rd.yz = Rot2D (rd.yz, 0.01 * pi);\n  ro.y += 0.1 * dist;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XllGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 263, 287, 287, 337], [339, 339, 363, 363, 410], [412, 412, 437, 437, 567], [569, 569, 594, 594, 773], [775, 775, 800, 800, 1106], [1108, 1108, 1137, 1137, 1339], [1341, 1341, 1380, 1380, 1587], [1589, 1589, 1646, 1646, 1729], [1731, 1731, 1763, 1763, 1858], [1860, 1860, 1893, 1893, 1920], [1922, 1922, 1964, 1964, 2015], [2017, 2017, 2060, 2060, 2133], [2135, 2135, 2181, 2181, 2252], [2581, 2581, 2603, 2603, 2844], [2846, 2846, 2876, 2876, 3032], [3034, 3034, 3064, 3064, 3138], [3140, 3140, 3194, 3194, 3264], [3266, 3266, 3303, 3303, 4390], [4392, 4392, 4445, 4445, 4547], [4549, 4549, 4584, 4584, 6154], [6156, 6156, 6196, 6196, 6777], [6779, 6779, 6819, 6819, 7683], [7685, 7685, 7720, 7720, 8141], [8143, 8143, 8165, 8165, 9033], [9035, 9035, 9068, 9068, 9244], [9246, 9246, 9267, 9267, 9475], [9477, 9477, 9514, 9514, 9724], [9726, 9726, 9748, 9748, 10885], [10887, 10887, 10922, 10922, 12233], [12235, 12235, 12292, 12292, 13160]]}
{"id": "Xls3D8", "name": "The Sun", "author": "pixartist", "description": "Nothing to see here", "tags": ["sun", "sphere", "rotating"], "likes": 10, "viewed": 474, "date": "1421934876", "time_retrieved": "2024-06-20T18:16:23.870245", "image_code": "const float pi = 3.14159265359;\nconst float timeScale = 1.0;\nconst float radius =0.9;\nconst bool darkspots = true;\nconst bool brightspots = true;\nfloat T;\n//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nfloat NoiseT(vec3 loc, float scale, float timeScale)\n{\n    return (1.0 + cnoise(vec4(loc, T*timeScale) * scale)) * 0.5;\n}\nstruct CircInfo\n{\n    vec4 coord;\n    vec2 uv;\n    float d;\n    float a;\n};\nCircInfo circle(vec2 uv, float ar, float r)\n{\n    vec2 d = vec2(0.5) - uv;\n    d.x *= ar;\n    d /= r * 0.5;\n    vec4 ret = vec4(0.0);\n    float l = length(d);\n    \n    float a = atan(d.y, d.x);\n\n    ret.x = - l * cos(a) / r;\n    ret.y = - l * sin(a) / r;\n\n    ret.z = sqrt(1.0 -(ret.x * ret.x + ret.y * ret.y));\n\n    \n    \n    return CircInfo(ret, d, l, a);\n}\nvec4 drawTexture(CircInfo point)\n{\n    float temp = NoiseT(point.coord.xyz, 4.0, 0.004) ;\n    temp = mix(temp, NoiseT(point.coord.xyz, 34.0, 0.008), 0.8);\n   // temp = mix(temp, NoiseT(point.coord.xyz, 44.0, 0.005), 0.5);\n    temp = mix(temp, NoiseT(point.coord.xyz, 164.0, 0.01), 0.4);\n    float spots = NoiseT(point.coord.xyz, 4.0, 0.004);\n    float h = 0.75;\n    float c = 0.2;\n    if(darkspots && spots < c)\n        temp = mix(temp, 0.0, min(1.0, 2.0 * (c-spots)*(1.0/c)));\n    else if(brightspots && spots > h)\n    \ttemp = temp * (1.0 + min(1.0, 2.0 * (spots-h)*(1.0/(1.0-h))));\n    temp = pow(temp, 2.0) ;\n   \tvec4 col = vec4(min(1.0, sqrt(temp) * 3.5), min(1.0, temp * 1.2), min(1.0, temp * 0.0), 1.0);\n    float w = 0.38;\n    if(temp > w)\n        col = mix(col, vec4(1.0),  (temp-w)*(1.0/(1.0-w))); \n    return col;\n}\nvec4 drawHalo(CircInfo point, float r)\n{\n    float s = 0.5;\n    float p = pow(max(0.0, (s - (point.d-r))/s), 2.0);\n    float b = p * (1.0 + cnoise(vec4(point.uv, T*0.06, 0.0)*1.5)) * 0.5; \n    float k = (1.5 + cnoise(vec4(normalize(point.uv),T*0.01, 0.0) * 32.0)) * 0.5;\n    return vec4(b*1.5, pow(b, 3.0) * k, b*0.0, 1) ;\n}\nvec4 addFuzz(CircInfo point, vec4 col, float r)\n{\n    float k = (1.0 + cnoise(vec4(normalize(point.uv),T*0.01, 0.0) * 64.0)) * 0.5;\n    float d = k - r;\n    if(d >= 0.0)\n    {\n        col = mix(col, vec4(2.0,0.9*k,0.05,1.0), 1.0 * min(1.0, sqrt(d)) );\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T = iTime * timeScale;\n    float fuzzBegin = 0.999;\n    float fuzzWidth = 0.02;\n    fuzzBegin = radius * fuzzBegin;\n    float b = 0.997;\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tCircInfo circ = circle(uv, ar, radius);\n    vec4 col = vec4(0.0);\n    if(circ.d <= radius)\n    {\n        mat4 rot = rotationMatrix(vec3(0.3,0.9,-0.3), T * 0.03);\n        circ.coord = rot * circ.coord;\n        \n    \tcol = drawTexture(circ);\n    }\n    if(circ.d >= fuzzBegin && circ.d < fuzzBegin+fuzzWidth)\n       col = addFuzz(circ, col, (circ.d - fuzzBegin) / fuzzWidth);\n    if(circ.d >= radius * 0.98)\n    {\n        col = mix(col, drawHalo(circ, radius), 0.9 * min(1.0, (circ.d - radius * 0.98) / (radius * 0.02)));\n    }\n    \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[155, 600, 621, 621, 670], [672, 672, 694, 694, 731], [733, 733, 761, 761, 813], [815, 815, 834, 834, 874], [876, 900, 922, 922, 5982], [5983, 5983, 6028, 6028, 6656], [6657, 6657, 6711, 6711, 6778], [6855, 6855, 6900, 6900, 7214], [7215, 7215, 7249, 7249, 8040], [8041, 8041, 8081, 8081, 8365], [8366, 8366, 8415, 8415, 8641], [8642, 8642, 8699, 8699, 9487]]}
{"id": "XlsGDH", "name": "kali-set density", "author": "bergi", "description": "Left is a 2d slice, right is the volume of the Kali set. \nClick left to navigate right.", "tags": ["kaliset", "volumemarching"], "likes": 6, "viewed": 1199, "date": "1421729372", "time_retrieved": "2024-06-20T18:16:25.058103", "image_code": "/** Kali set volume rendering test\n\n\t(c) stefan berke, 2015\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tEstimating the distance to a surface in the Kali set is relatively difficult,\n\tinstead stepping through a volume and just picking up colors is quite easy. \n\tThis is a tool for finding good spots in the set and testing rendering methods. \n\n\tThe left side shows a 2d slice of the Kali set from OFFSET to OFFSET + KALI_SCALE.\n\tThe right side is a close-up 3d volume of the position you selected last with the mouse.\n\tThe SCALE parameter is the extend of the camera frustum's near-plane. It helps to \n\tview larger parts of the volume but it also clips close objects away, which may look \n\tquite unrealistic with AUTO_ROTATION - just so you know..\n*/\n\n// ------------------ \"interface\" -----------------------\n\n#define COLOR_MODE \t\t1\t\t\t\t\t\t\t// 0 == last value, 1 == average, 2 == average change\n#define AUTO_ROTATION\t17\t\t\t\t\t\t\t// rotate volume (degree per second)\n#define AUTO_MOVE\t\t1\t\t\t\t\t\t\t// slightly move camera in volume\n#define GRAYSCALE\t\t0\t\t\t\t\t\t\t// percent to convert all colors to white (anti-psychadelic)\n\nconst vec3 OFFSET = \tvec3(0., 0., 0.1);\t\t\t// offset in kali set (left and right screen)\nconst float KALI_SCALE =1.;\t\t\t\t\t\t\t// size of the visible area on the left\n\nconst vec3 KALI_PARAM =\tvec3(0.45, 0.8, 0.8);\t\t// the magic number (most of the numbers are magic :)\nconst int NUM_ITER =\t19;\t\t\t\t\t\t\t// number of iterations in kali set\n\nconst float SCALE = \t0.06;\t\t\t\t\t\t// size of the camera frustum's near-plane\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set to zero for point-camera\nconst float DEPTH = \t0.06;\t\t\t\t\t\t// maximum depth to trace in volume\nconst float MIX_ALPHA =\t0.5;\t\t\t\t\t\t// opacity of the traced samples\nconst int NUM_TRACE = \t100;\t\t\t\t\t\t// number traces through volume\nconst float STEP = \t\tDEPTH / float(NUM_TRACE);\n\n\n// ----------------- kali set --------------------------\n\n#if COLOR_MODE == 0\n\n    vec3 kaliset(in vec3 p)\n    {\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) / dot(p, p) - KALI_PARAM;\n        }\n        return p;\n    }\n\n#elif COLOR_MODE == 1\n\n    vec3 kaliset(in vec3 p)\n    {\n        vec3 c = vec3(0.);\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) / dot(p, p) - KALI_PARAM;\n            c += p;\n        }\n        return c / float(NUM_ITER);\n    }\n\n#elif COLOR_MODE == 2\n\n    vec3 kaliset(in vec3 p)\n    {\n        vec3 c = vec3(0.), pp = vec3(0.);\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) / dot(p, p) - KALI_PARAM;\n            c += abs(p - pp);\n            pp = p;\n        }\n        return c / float(NUM_ITER) / 3.;\n    }\n\n#endif\n\n\n// ---------------------- renderer --------------------------\n\n// quite inefficient volume tracer\n// it starts at the end of the ray (pos + DEPTH * dir)\n// and moves towards the camera plane\n// mixing-in the colors from the kaliset() function\nvec3 trace(in vec3 pos, in vec3 dir)\n{\n    vec3 col = vec3(0.);\n    for (int i=0; i<NUM_TRACE; ++i)\n    {\n        float t = float(i) / float(NUM_TRACE);\n        \n        vec3 p = pos + DEPTH * (1.-t) * dir;\n        \n        vec3 k = clamp(kaliset(p), 0., 1.) * (0.01+0.99*t);\n\n#if GRAYSCALE != 0\n        k += (float(GRAYSCALE)/100.) * (vec3(max(k.x, max(k.y, k.z))) - k);\n#endif\n        \n        float ka = dot(k, k) / 3.;\n              \n        col += ka * MIX_ALPHA * (k - col);\n        \n    }\n    \n    return col;\n}\n\n\n\n// ------------------- number printing ----------------------\n\n// code by eiffie https://www.shadertoy.com/view/Mdl3Wj\n\nvoid Char(int i, vec2 p, inout float d){\n  const float w=0.1,h=0.3,w2=0.2,h2=0.4;\n  if(i>127){i-=128;d=min(d,max(abs(p.x),abs(p.y)-h));}\n  if(i>63){i-=64;d=min(d,max(abs(p.x-w2),abs(p.y-w2)-w));}\n  if(i>31){i-=32;d=min(d,max(abs(p.x-w2),abs(p.y+w2)-w));}\n  if(i>15){i-=16;d=min(d,max(abs(p.x+w2),abs(p.y-w2)-w));}\n  if(i>7){i-=8;d=min(d,max(abs(p.x+w2),abs(p.y+w2)-w));}\n  if(i>3){i-=4;d=min(d,max(abs(p.x)-w,abs(p.y-h2)));}\n  if(i>1){i-=2;d=min(d,max(abs(p.x)-w,abs(p.y)));}\n  if(i>0)d=min(d,max(abs(p.x)-w,abs(p.y+h2)));\n}\nint Digi(int i){//converts digits to char codes\n  if(i==0)return 125;if(i==1)return 128;if(i==2)return 79;if(i==3)return 103;\n  if(i==4)return 114;if(i==5)return 55;if(i==6)return 63;if(i==7)return 100;\n  if(i==8)return 127;return 118;\n}\nvec3 PrintVal(float n, vec2 uv)\n{\n  uv *= 10.;\n  float d=1.0;\n  if(n!=n){//error\n    uv.x-=2.8;\n    Char(31,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(43,uv,d);uv.x-=0.6;\n    Char(10,uv,d);\n  }else{\n    if(n<0.0){n=-n;Char(2,uv+vec2(0.6,0.0),d);}//negative sign\n    float c=floor(max(log(n)/log(10.0),0.0));\n    d=min(d,length(uv+vec2(-0.6*c-0.3,0.55)));//decimal place\n    if(c>0.0)n/=pow(10.0,c);\n    for(int i=0;i<6;i++){\n      c=floor(n);\n      Char(Digi(int(c)),uv,d);\n      uv.x-=0.6;\n      n=(n-c)*10.0;\n    }\n  }\n  vec3 color=mix(vec3(0.3,0.8,0.5),vec3(0.0),smoothstep(0.0,0.2,d));\n  return mix(vec3(1.),color,smoothstep(0.0,0.08,d));\n}\n\n\n// --------------------- put it together -----------------------\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tvec2 mouse = iMouse.xy / iResolution.x * KALI_SCALE * 2.;\n\t\n    vec3 col;\n    \n    if (uv.x < 0.5)\n    {\n        vec3 pos = vec3(uv * KALI_SCALE * 2., 0.00) + OFFSET;\n        col = clamp(kaliset(pos), .0, 1.);\n    }\n    else\n    {\n        uv.x -= .5;\n        uv *= 2.;\n\t\tfloat time = iTime;\n        \n        // cheap frustum\n        vec3 pos = vec3((uv-.5) * SCALE, 0.);\n        vec3 dir = normalize(vec3(uv-.5, 1.0));\n#if AUTO_ROTATION != 0\n        float rr = 3.14159265 * float(AUTO_ROTATION) / 180. * time;\n        pos.xz = rotate(pos.xz, rr);\n        dir.xz = rotate(dir.xz, rr);\n#endif\n#if AUTO_MOVE != 0\n        pos.x += 0.001*sin(time);\n        pos.y += 0.001*sin(time*1.1);\n#endif\n\n\t\tpos.xy += mouse;\n        pos += OFFSET;\n\n\t\tcol = trace(pos, dir);\n    }\n\n    // print coordinates\n    if (iMouse.z > .5)\n    {\n    \tuv = fragCoord.xy / iResolution.x * 2. - vec2(1.08, 1.);\n    \tcol = max(col, PrintVal(mouse.x + OFFSET.x, uv));\n    \tcol = max(col, PrintVal(mouse.y + OFFSET.y, uv + vec2(0., 0.12)));\n        col = max(col, PrintVal(OFFSET.z, uv + vec2(0., 0.24)));\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2734, 2914, 2952, 2952, 3432], [3499, 3556, 3596, 3596, 4080], [4081, 4081, 4097, 4128, 4318], [4319, 4319, 4352, 4352, 5004], [5007, 5073, 5106, 5106, 5195], [5213, 5213, 5270, 5270, 6429]]}
{"id": "XlsGW7", "name": "Yellow and blue", "author": "danjinxiangsi", "description": "This simple shader is created by Xiao Wu.\nIt mimic a yellow and blue bulb effect.\nEveryone is welcome to use/modified it. Any feedbacks and comments are also helpful", "tags": ["2d", "yellow", "blue", "bulb"], "likes": 2, "viewed": 1075, "date": "1422506897", "time_retrieved": "2024-06-20T18:16:25.058103", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 flame;\n    flame.x=sin(iTime)*1.0;\n    flame.y=sin(iTime)*1.0;\n\t\n\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\tposition = position - 0.5;  //here I minus 0.5 because CCzero point on iPad is left courner.\n\tposition.x *= iResolution.x/iResolution.y;\n    position.x *= flame.x;\n    position.y *= flame.y;\n    float c = sqrt(position.x*position.x+position.y*position.y);\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfragColor = vec4(vec2(1.0 - c*2.0)+0.5*sin(iTime),uv.x+0.5*sin(iTime), 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 577]]}
{"id": "XlX3DH", "name": "Hypnobar", "author": "mpcomplete", "description": "First foray into shadertoy.", "tags": ["empty"], "likes": 0, "viewed": 1101, "date": "1421449711", "time_retrieved": "2024-06-20T18:16:25.058103", "image_code": "float SIZE = 0.05;\nfloat GAP = 1.75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = 0.5+0.5*sin(iTime);\n    uv.y += 0.1*sin((uv.x / (GAP*SIZE))*3.0 + iTime);\n    vec2 dot = step(mod(uv, GAP*SIZE), vec2(SIZE));\n    float inSquare = dot.x*dot.y;\n    fragColor = inSquare*vec4(uv,t,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[38, 38, 95, 95, 354]]}
{"id": "XlXGD4", "name": "WebGL Tunnel", "author": "MichaelPohoreski", "description": "Soulman's WebGL Tunnel converted to ShaderToy\n\nKnown bug(s): Doesn't work with Windows + GTX Titan or 980 Ti :-/", "tags": ["procedural", "2d"], "likes": 13, "viewed": 361, "date": "1421915458", "time_retrieved": "2024-06-20T18:16:25.391542", "image_code": "// http://stackoverflow.com/questions/5451376/how-to-implement-this-tunnel-like-animation-in-webgl\n// Converted to ShaderToy by Michael Pohoreski in 2015\n// https://www.shadertoy.com/view/XlXGD4\n// Minor cleanup\n// Remove unused vars: CENTER, x, y, PI\n\n// BUG: Why is precision being used from comments???\n// precision.BUG highp float;\n// #precision.BUG mediump float; // or lowp\n\nconst int   MAX_RINGS     = 30;\nconst float RING_DISTANCE = 0.05;\nconst float WAVE_COUNT    = 60.0;\nconst float WAVE_DEPTH    = 0.04;\n\n//uniform float uTime;\n//varying vec2 vPosition;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 vPosition = 2.*fragCoord.xy/iResolution.xy-1.;\n    float rot = mod(iTime*0.6, 6.28318530717959 ); // 2.*PI\n    \n    bool black = false;\n    float prevRingDist = RING_DISTANCE;\n    for (int i = 0; i < MAX_RINGS; i++) {\n        vec2  center = vec2(0.0, 0.7 - RING_DISTANCE * float(i)*1.2);\n        float radius = 0.5 + RING_DISTANCE / (pow(float(i+5), 1.1)*0.006);\n        float dist   = distance(center, vPosition);\n              dist   = pow(dist, 0.3);\n        float ringDist = abs(dist-radius);\n\n        if (ringDist < RING_DISTANCE*prevRingDist*7.0)\n        {\n            vec2  d           = vPosition - center;\n            float angle       = atan( d.y, d.x );\n            float thickness   = 1.1 * ringDist / prevRingDist;\n            float depthFactor = WAVE_DEPTH * sin((angle+rot*radius) * WAVE_COUNT);\n            if (dist > radius)\n                black = (thickness < RING_DISTANCE * 5.0 - depthFactor * 2.0);\n            else\n                black = (thickness < RING_DISTANCE * 5.0 + depthFactor);\n            break; // causes all white on GTX Titan !? // removes inner thin path\n        }\n        if (dist > radius)\n            break;\n        prevRingDist = ringDist;\n    }\n    \n    fragColor.rgb = black ? vec3(0) : vec3(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[516, 566, 624, 624, 1875]]}
{"id": "XlXGD8", "name": "Britbot", "author": "eiffie", "description": "Frolicking endlessly with my gal pal Britbot. I was going to view all the shaders here but after spending an hour playing with the first one I gave up.", "tags": ["fake3d"], "likes": 17, "viewed": 1477, "date": "1421261309", "time_retrieved": "2024-06-20T18:16:25.397432", "image_code": "//Britbot by eiffie\n//A little bit like mode7 from poljere https://www.shadertoy.com/view/ltsGWn\n//...and a lot of tunnel from iq https://www.shadertoy.com/view/Ms2SWW\n\n#define PI 3.14159\nvec3 tunnel(vec3 rd){\n\tvec2 uv=rd.xy/rd.z;\n\tfloat tm=iTime*sign(rd.z)*1.5;\n\tfloat pw=0.5+pow(min(abs(sin(tm*0.1))+0.25,1.0),16.0)*16.0;\n\tfloat r=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\tfloat x;\n\tfor(int i=1;i<10;i++){//what kind of maths are these?\n\t\tx=uv.x+sin((0.5/r+0.5*tm)*2.0)*float(i)*float(i)*0.001;\n        pw=0.5+pow(min(abs(sin((tm+max(1.0-r,0.0))*0.1))+0.25,1.0),16.0)*16.0;\n\t\tr=pow(pow(x*x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\t}\n\tuv.x=x;\n\tfloat a=atan(uv.y,uv.x)/3.14159;\n\tvec2 p=vec2(0.5/r+0.5*tm,a)*8.0;\n\tp.y*=sign(uv.x);\n\tvec2 c=floor(p);\n\tp=fract(p);\n\tp.x=pow(p.x,clamp(abs(rd.z)+pw/16.0,1.0,2.0));\n\tuv=p;\n\tuv=2.0*(uv-0.5);\n\tfloat r2=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\tp=clamp(p*1.5-0.25,0.0,1.0);\n\tvec3 col=vec3(0.5)+0.5*sin(vec3(c.xy,c.x+c.y));\n    if((a<0.25 && a>-0.25) || a<-0.75 || a>0.75){\n        float d=max(abs(p.x-0.5),abs(p.y-0.5))-0.5;\n        if(d<0.0){//min(p.x,p.y)>0.0 && max(p.x,p.y)<1.0){\n        \tif(rd.z<0.0)p.y=1.0-p.y;\n\t\t\tcol=mix(col,texture(iChannel0,p).rgb,smoothstep(0.0,0.05,-d));\n        }\n    }\n\tcol*=2.0*pow(r,1.75)*clamp(3.0-r2*3.0,0.0,1.0);\n\tif(col!=col)col=vec3(0.0);\n\treturn clamp(col,0.0,1.0);\n}\nmat3 lookat(vec3 fw, vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nstruct intersect{float t, d; vec3 N;}I1,I2; \nvoid zStack(intersect I, float px){\n\tif(I.t<=0.0 || I.d>px*I.t)return;\n\tif(I.t<I1.t){I2=I1;I1=I;}\n\telse if(I.t<I2.t)I2=I;\n}\n#define maxDepth 10.0\n//pS=p1-ro, pD=p2-p1 Hopefully no one thinks this actually works!\nintersect Segment(in vec3 pS, in vec3 pD, in float r, in vec3 rd){//mod from iq's\n\tintersect intr=intersect(0.0,maxDepth,vec3(0.0));\n\tfloat d=dot(rd,pD);\n\tfloat t=clamp((dot(rd,pS)*d-dot(pS,pD))/(dot(pD,pD)-d*d),0.0,1.0);\n\tpS+=pD*t;\n\tintr.N=-pS;\n\tfloat b=dot(pS,rd);\n\tfloat h=b*b-dot(pS,pS);\n\td=sqrt(max(0.0,-h))-r;\n\tintr.d=max(0.0,d);\n\tintr.t=b+min(d,0.0)-sqrt(max(0.0,h+r*r));\n\treturn intr;\n\t//dist: intr.t\n\t//aa/dof: clamp(intr.d/(px*intr.t),0.0,1.0);\n\t//shad: clamp(k*intr.d/intr.t,0.0,1.0);\n\t//normal: normalize(rd*intr.t+intr.N);\n}\nvec3 Light(intersect I, vec3 rd, float px, vec3 col){\n\tfloat aac=1.0-clamp(I.d/(px*I.t),0.0,1.0);\n\tif(aac>0.0){\n\t\tvec3 N=normalize(rd*I.t+I.N);\n\t\tvec3 L=normalize(vec3(0.5,0.8,0.4));\n\t\tvec3 R=reflect(rd,N);\n\t\tcol=mix(col,(vec3(1.0,0.3,0.4)+0.2*tunnel(R))*(0.5+0.5*dot(L,N)),aac);\n\t}\n\treturn col;\n}\nvec3 jsolve( vec3 a, vec3 b, float ln, vec3 rt )//mod from iq's\n{//simple joint with equal lengths\n\tvec3 p=b-a,q=p*0.5;\n\treturn a+q+sqrt(max(0.0,ln*ln-dot(q,q)))*normalize(cross(p,rt));\n}\nvec3 britbot(vec3 ro, vec3 rd, vec3 col){\n\tfloat px=2.5/iResolution.y,tm=iTime*10.0;\n\tI1.t=I2.t=I1.d=I2.d=maxDepth;\n\tfloat ct=cos(tm),st=sin(tm),st2=sin(tm*0.3);\n\tfloat h=(ct+st)*ct*-0.25;\n\tvec3 b1=vec3(0.0,h,0.0),b2=vec3(st2*0.2,-0.75+h,-0.2);\n\t\n\tvec3 le,lh=vec3(-0.75+0.1*st,-0.4-0.2*ct,0.3-0.3*ct),re,rh=vec3(0.75+0.1*st,-0.4-0.2*st,0.3+0.3*ct);\n\tvec3 lk,lf=vec3(-0.25,-2.0+max(0.0,ct*0.5),-0.25+0.4*st),rk,rf=vec3(0.25,-2.0+max(0.0,-ct*0.5),-0.25-0.4*st);\n\tvec3 rt=normalize(vec3(1.0+0.4*st2,-0.4*st2,0.0));\n\tle=jsolve(b1,lh,0.6,rt.yxz);\n\tre=jsolve(b1,rh,0.6,-rt.yxz);\n\tlk=jsolve(b2,lf,0.7,rt);\n\trk=jsolve(b2,rf,0.7,rt);\n\tfloat TR=0.15;\n\tvec3 n=vec3(TR,0.0,-TR*0.5);\n\tzStack(Segment(b1-ro,b2-b1,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lk-ro,b2-n.xyy-lk,TR,rd),px);\n\tzStack(Segment(rk-ro,b2+n.xyy-rk,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lf-ro,lk-lf,TR,rd),px);\n\tzStack(Segment(rf-ro,rk-rf,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(le-ro,b1-n.xyy-le,TR,rd),px);\n\tzStack(Segment(re-ro,b1+n.xyy-re,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lh-ro,le-lh,TR,rd),px);\n\tzStack(Segment(rh-ro,re-rh,TR,rd),px);\n\tTR*=0.75;\n\tmat3 mx=lookat(vec3(st2*ct,0.25*(st2+st),1.0),vec3(0.25*st2*st,1.0,0.25*st2*ct));\n\tvec3 n1=vec3(0.0,0.25+h,0.0)*mx,h1=vec3(-0.4,0.25+h,0.0)*mx,h2=vec3(-0.4,0.75+h,0.0)*mx;\n\tvec3 h3=vec3(0.4,0.75+h,0.0)*mx,h4=vec3(0.4,0.25+h,0.0)*mx;\n\t\n\tn=vec3(0.0,0.0,1.0)*mx;\n\tfloat t=-dot(n,ro)/dot(n,rd);\n\tif(t>0.0){\n\t\tvec3 p=mx*(ro+rd*t);\n\t\tp.y-=h;\n\t\tif(p.x>-0.4 && p.x<0.4 && p.y>0.25 && p.y<0.75){\n\t\t\tcol=texture(iChannel0,vec2(1.25,2.0)*(p.xy+vec2(0.4,-0.25))).rgb;\n\t\t}\n\t}\n\tzStack(Segment(b1-ro,n1-b1,TR,rd),px);\n\tzStack(Segment(h1-ro,h2-h1,TR,rd),px);\n\tzStack(Segment(h2-ro,h3-h2,TR,rd),px);\n\tzStack(Segment(h3-ro,h4-h3,TR,rd),px);\n\tzStack(Segment(h1-ro,h4-h1,TR,rd),px);\n\t\n\tcol=Light(I2,rd,px,col);\n\tcol=Light(I1,rd,px,col);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/ iResolution.y;\n\tfloat tm=iTime*0.1;\n\tvec3 ro=vec3(sin(tm),0.0,cos(tm)*3.0);\n\ttm=abs(sin(tm*1.5));\n\tvec3 up=vec3(1.0-tm,1.0,0.0);\n\tvec3 rd=lookat(-ro,up)*normalize(vec3(uv,1.0));\n \tvec3 col=tunnel(rd);\n\tcol=britbot(ro,rd,col);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 188, 209, 209, 1354], [1355, 1355, 1385, 1385, 1481], [1527, 1527, 1562, 1562, 1650], [1673, 1739, 1805, 1820, 2276], [2277, 2277, 2330, 2330, 2574], [2575, 2575, 2640, 2673, 2762], [2763, 2763, 2804, 2804, 4605], [4607, 4607, 4664, 4664, 4966]]}
{"id": "XlXGWM", "name": "Penrose/Robinson Pattern", "author": "tomkh", "description": "Pattern based on robinson-penrose tiling, based on [url=http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings]my shader[/url] from 2011, also try new version:  [url=https://www.shadertoy.com/view/4t2XWG]4t2XWG[/url]", "tags": ["tiling", "penrose", "aperiodic", "robinson"], "likes": 19, "viewed": 503, "date": "1422280023", "time_retrieved": "2024-06-20T18:16:26.227870", "image_code": "// Procedural Penrose/Robinson tiling\n// 2011 (C) Tom, revised in 2015\n\n// Original shader:\n//   http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings\n\n// Subsitution rules:\n//   http://tilings.math.uni-bielefeld.de/substitution_rules/robinson_triangle\n\n// TODO: would be nice to make it more \"sexy\" with better shading / 3d-look etc... ;P\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = (iMouse.z > 0.) ? iMouse.x*.005 : iTime*.25+2.;\n  //float time = iTime*.25;\n  const int levels = 8;         // number of substitutions\n  const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)\n  const float pi = 3.1415926535897931;\n   \n  // transformations constants:\n  \n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)\n  const float a2 = 0.80901699437494745; // = (1+a1)*.5\n  const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2\n  const float cos1 = -1.3090169943749466; // = cos(144*PI/180)*sc\n  const float sin1 = 0.95105651629515331; // = sin(144*PI/180)*sc\n  const float cos2 = -0.5; // = cos(108*PI/180)*sc\n  const float sin2 = 1.5388417685876261; // = sin(108*PI/180)*sc\n\n  int type;\n  float x, y, xx, yy, co, si;\n  \n  type = 0;\n  \n  // simple roto-zooming:\n  co = cos(time*.6)*.5;\n  si = sin(time)*.5;\n  vec2 p = (fragCoord.xy - iResolution.xy*.5)*0.7/iResolution.y;\n  x = p.x*co + p.y*si + .8;\n  y = -p.x*si + p.y*co;\n  float x0 = x, y0 = y;\n  \n  type = 0; // starting triangle type\n  if (y < 0.) { y = -y; type = 2; }\n  \n  for (int k=0; k<levels; k++)  // iterate all subsitutions\n  {\n     if (type == 0 || type == 2) \n     {\n        // We substitute triangle type 0\n        // with three possible triangles.\n        // We detect in which of those three\n        // triangle our current (x,y) lies\n        // by checking line equations separating them:\n        \n        if (1.0 - d1*y - x > 0.0) // left triangle\n        {         \n           // only translation/mirror here:\n           x = (1.0 - x)*sc;\n           y = y*sc;\n            \n           type = 2 - type; // tile type changes here!\n        } \n        else if (1.0 - d2*y - x > 0.0) // middle triangle\n        {\n           \n           // translate:\n           xx = x - a2;     \n           yy = y - a3;\n           \n           // rotate:\n           x = xx*cos1 - yy*sin1;\n           y = xx*sin1 + yy*cos1;\n           \n           type = 3 - type; // tile type changes here!\n        } \n        else // right triangle\n        {      \n           // translate (x only):\n           xx = x - (1.0+a1);\n           yy = y;\n        \n           // rotate:\n           x =  xx*cos1 + yy*sin1;\n           y = -xx*sin1 + yy*cos1;\n        }      \n     } \n     else \n     {\n        // We substitute triangle type 1 with \n        // two possible triangles (analogically).\n  \n        if (d1*y - x > 0.0) { // upper triangle\n        \n           // rotate only\n           xx = x; \n           yy = y;\n           x = -xx*cos2 + yy*sin2;\n           y =  xx*sin2 + yy*cos2;\n                    \n           type--; // tile type changes here!\n           \n        } else { // lower triangle\n        \n           // translate (x only):\n           xx = x - a1;\n           yy = y;\n           \n           // rotate:\n           x =  xx*cos2 + yy*sin2;\n           y = -xx*sin2 + yy*cos2;\n        }\n     }  \n  }\n  \n  vec3 base;  \n  \n  // Individual colors for Robinson tiling:\n  if (type < 2) {\n     if (type == 0) base = vec3(0.,0.,96./255.);\n     else base = vec3(255./255.,204./255.,102./255.);\n  } else if (type == 2) base = vec3(206./255.,203./255.,227./255.);\n  else base = vec3(255./255.,102./255.,0.);\n  \n  // Fancy pattern:\n  \n  float scale = sqrt(co*co + si*si);\n  //float dr = 1.; //iResolution.x*.1;\n  //float dx = fragCoord.x - iMouse.x + dr;\n  //if (dx > 0.) \n  {  \n      float d, blend = .8; //5*(1.-scale*.25);\n      //blend *= smoothstep(0.,1.,dx*.5/dr);\n      //blend = (dx < dr*2.) ? .75 : .9;\n      base = mix(base, vec3(.19,.29,.65)*.3, blend);\n      if (type == 0 || type == 2) {\n         d = abs(sqrt(1.0 - (x*x + y*y))-.6);\n      } else {\n         d = abs(sqrt((x-a1)*(x-a1) + y*y)*1.3-.27);\n      }\n      float r = pow(2.,float(levels))*.1*scale/iResolution.y; // sample size\n      if (d > 0.) {\n        d = (1. - smoothstep(.1-r,.1,d))*.9;\n        base = mix(base, vec3(255./255.,240./255.,140./255.), blend*d);\n      }\n  }\n    \n  base -= texture(iChannel0, vec2(x0,y0)*16.).xyz*.1;\n    \n  base = pow(base,vec3(.8));\n\n  fragColor = vec4(base, 1.0);\n}\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[271, 358, 415, 415, 4603]]}
{"id": "Xtf3W4", "name": "Solid Colors", "author": "Xonatron", "description": "My first shader. Just playing with the sample.", "tags": ["2d", "color"], "likes": 2, "viewed": 158, "date": "1421901696", "time_retrieved": "2024-06-20T18:16:26.227870", "image_code": "// Matthew Doucette, Xona Games\n// Thursday, January 22nd, 2015\n// ----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(\n        0.5 + 0.5*sin(iTime*2.00), // 0.0..1.0\n        0.5 + 0.5*sin(iTime*3.07), // 0.0..1.0\n        0.5 + 0.5*sin(iTime*5.09), // 0.0..1.0\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtf3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 97, 154, 154, 335]]}
{"id": "XtfGDn", "name": "bias | gain test", "author": "antonOTI", "description": "toying with the bias and gain function found here \nhttp://demofox.org/biasgain.html", "tags": ["curve"], "likes": 3, "viewed": 176, "date": "1420495653", "time_retrieved": "2024-06-20T18:16:26.227870", "image_code": "#define PI 3.14159265359\n#define PI2 2.*PI\n#define HPI PI/2.\n\n//moving\n#define BIAS sin(iTime)*.5+.5\n//#define BIAS .6\n\n#define GAIN sin(iTime)*.5+.5\n//#define GAIN .6\n\nfloat GetBias(float x,float bias)\n{\n  return (x / ((((1.0/bias) - 2.0)*(1.0 - x))+1.0));\n}\n\nfloat GetGain(float x,float gain)\n{\n  if(x < 0.5)\n    return GetBias(x * 2.0,gain)/2.0;\n  else\n    return GetBias(x * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat strock =.01;\n\t\n    float x = uv.x; // [-1.0,1.0]\n    \n    float b = GetBias(x,BIAS);\n    \n    float g = GetGain(x,GAIN);\n    \n    //x = b;\n    x = g;\n    \n    \n    \n    float f = sin((x-.5) * PI);\n    \n    \n    f = f*.5 + .5;\n\tfloat st = step(f -.005,uv.y) * step(uv.y, f + 0.005);\n\tfragColor = vec4(vec3(1.),1.) * st;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtfGDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[150, 169, 204, 204, 259], [261, 261, 296, 296, 413], [415, 415, 472, 472, 842]]}
{"id": "Xtl3z7", "name": "Voronoi Experiment 2", "author": "aiekick", "description": "Voronoi Experiment 2\nMouse axis Y : control ray marchin iterations (Current number in bottom left)\nMouse axis X : control rugosity density (current number in bottom right)", "tags": ["raymarching", "voronoi", "mouse", "experiment", "sphere", "blob", "mapping", "printing"], "likes": 0, "viewed": 1286, "date": "1420301816", "time_retrieved": "2024-06-20T18:16:26.852178", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define ITERATIONS_MAX 50\n#define RUGOSITY_DENSITY_MAX 50.\n#define RUGOSITY_DENSITY_DEFAULT 20.\n#define ROT_SPEED 0.5\n#define TIME_RATIO iTime*0.5\n// GLSL Number Printing - @P_Malin (CCO 1.0)=> https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin(const in int x){\n    if(x==0) return 480599.0; if(x==1) return 139810.0; if(x==2) return 476951.0; if(x==3) return 476999.0;\tif(x==4) return 350020.0;\n    if(x==5) return 464711.0; if(x==6) return 464727.0; if(x==7) return 476228.0; if(x==8) return 481111.0; if(x==9) return 481095.0; return 0.0;}\nfloat PrintValue(const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces){\n    vec2 vStringCharCoords = (gl_FragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n            if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;} \n        else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;} \n            else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));} } }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));}\nvec3 WriteValueToScreenAtPos(float vValue, vec2 vPixelCoord, vec3 vColour, vec2 vFontSize, float vDigits, float vDecimalPlaces, vec3 vColor){\n    float num = PrintValue(vPixelCoord, vFontSize, vValue, vDigits, vDecimalPlaces);\n    return mix( vColour, vColor, num);}\n/////////////////////////////////////////////////////////////////\n// VORONOI based on IQ shader https://www.shadertoy.com/view/ldl3W8\n//vec2 getHash2BasedTex(vec2 p) {return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;}//texture based white noise\nvec2 getHash2BasedProc(vec2 p){return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);}//procedural white noise\nvec3 getVoronoi(vec2 x){\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(TIME_RATIO+6.2831*getHash2BasedProc(n+g));//animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);}\n// sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n){\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n    return getVoronoi(1.5*uv);}\n// rotate\nfloat RotY=0.0,RotX=0.0;\nvec3 rotateX(vec3 pos, float alpha) {\nmat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans * vec4(pos, 1.0));}\nvec3 rotateY(vec3 pos, float alpha) {\nmat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans2 * vec4(pos, 1.0));}\n// sphere + sphere cloud with center points and radius from voronoi\nfloat density=RUGOSITY_DENSITY_DEFAULT;\nfloat map(vec3 p){\n    vec3 rotPX = rotateX(p, RotX*ROT_SPEED);\n    vec3 rotPXY = rotateY(rotPX, RotY*ROT_SPEED);\n    if ( iMouse.z > 0. ) {density=iMouse.x/iResolution.x * RUGOSITY_DENSITY_MAX;}\n\tfloat rugosity=cos(density*rotPXY.x)*sin(density*rotPXY.y)*sin(density*rotPXY.z)*cos(256.1)*sin(0.8);\n\tfloat disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;\n    return length(p)-1.+disp+rugosity;}\n// ray-marcher based on sebastien shader https://www.shadertoy.com/view/XtXGzM\nfloat march(vec3 ro,vec3 rd, int iter){\n\tfloat maxd=10.;\n    float tmpDist=1.;\n    float finalDist;\n    for(int i=0;i<ITERATIONS_MAX;i++){\n        if(i>iter)break;\n        if( tmpDist<0.0001||finalDist>maxd) break;\n\t    tmpDist=map(ro+rd*finalDist);\n        finalDist+=tmpDist; }\n    if(finalDist>maxd) finalDist=-1.;\n\treturn finalDist; }\n// normal calc based on nimitz shader https://www.shadertoy.com/view/4sSSW3\nvec3 normal(const in vec3 p){  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 vColour = vec3(0.);\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    RotY = iTime * ROT_SPEED;\n    RotX = iTime * ROT_SPEED;    \n    vec3 ro=vec3(0.,0.,1.9),rd=normalize(vec3(uv,-0.8));\n   \tint nIter = ITERATIONS_MAX;\n    if ( iMouse.z > 0. ) {nIter=int(floor(iMouse.y/iResolution.y * float(nIter)));}\n    float t=march(ro,rd,nIter);\n    if(t>0.){\n        vec3 pos = ro+t*rd;\n        float b=dot(normal(pos),normalize(pos))*0.8;\n        vColour=b*mix(vec3(max(0.,2.3-t)),voronoiSphereMapping(normalize(pos)),0.5)+pow(b,8.0)*(1.0-t*.01); } \n    // count iteration printing bottom left => Mouse Axis Y\n    vColour = WriteValueToScreenAtPos(float(nIter), vec2(2.), vColour, vec2(8.0, 15.0), 1., 0., vec3(0.9));\n    // rugosity density printing bottom right => Mouse Axis X\n   \tvColour = WriteValueToScreenAtPos(density, vec2(iResolution.x-16., 2.), vColour, vec2(8.0, 15.0), 1., 0., vec3(0.9));\n    fragColor.rgb = vColour; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[284, 369, 400, 400, 681], [682, 682, 833, 833, 1833], [1834, 1834, 1975, 1975, 2100], [2101, 2351, 2382, 2382, 2469], [2469, 2494, 2518, 2518, 2854], [2855, 2887, 2921, 2921, 2993], [2994, 3029, 3066, 3066, 3231], [3232, 3232, 3269, 3269, 3435], [3436, 3544, 3562, 3562, 3955], [3956, 4035, 4074, 4074, 4373], [4374, 4450, 4479, 4479, 4630], [4631, 4631, 4687, 4687, 5663]]}
{"id": "Xtl3zM", "name": "Snow Ball", "author": "iapafoto", "description": "Playing with stereographic panorama effect  :)\n[Mouse available] (with some artfacts!)", "tags": ["panorama", "stereographic"], "likes": 33, "viewed": 789, "date": "1420145523", "time_retrieved": "2024-06-20T18:16:28.888793", "image_code": "const float pi = 3.1415926536;\n\n\n\n// Created by Sebastien DURAND - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//----------------------------------------------------------------\n// A lot from IQ shader Bridge (https://www.shadertoy.com/view/Mds3z2)\n\n\n// Because does not works with trees in chrome update !!!??\n// Ok on Chrome Canary\n#define TREES\n\n\n#define NB_ITER 50 \n#define STEREOGRAPHIC\n\nbool withMen, withWomen;  // Optimization: only calculate head if it is visible by the current ray\n\nconst float cc = .866, ss = -.5;\nconst mat2 Rot = mat2(cc,ss,-ss,cc);\nconst mat2 Rot2 = mat2(cc,-ss,ss,cc);\n\nfloat noise( in vec2 x) {\n    vec2 f = fract(x);\n\treturn -1.0 + 2.0*textureLod( iChannel2, ((floor(x) + f.xy*f.xy*(3.0-2.0*f.xy))+0.5)/256.0, -100.0 ).x;\n}\n\n//----------------------------------------------------------------\n\nfloat sdTorus(in vec3 p, in vec3 t ) {\n  vec3 q = vec3(length(p.xz)-t.x,p.y,p.z);\n  return max(length(q.x)-t.y, length(q.y)-t.z);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n//----------------------------------------------------------------\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nvec2 smin(in vec2 a, in vec2 b ) {\n\tfloat h = clamp( .5 + 1.25*(b.x-a.x), 0., 1. );\n\treturn mix( b, a, h ) - .4*h*(1.-h);\n}\n\nvec2 mini(in vec2 a, in vec2 b ) {\n\treturn a.x<b.x?a:b;\n}\n\n//----------------------------------------------------------------\n\n\nfloat terrain(in vec2 p) {\n    p+=vec2(5,8.5);\n    return 3.3 + 2.*cos(.1*length(p))-(1.6-1.6*cos(p.x/4.5)*cos(p.y/3.5))+.006*noise(p.yx*35.); // very regular patern + a little bit of noise\n}\n\n\nfloat trees(in vec3 p, in float h ) { \n        vec2 v = p.xz;\n\tfloat e = .5*smoothstep( 0.4, 0.6, textureLod(iChannel1,0.001*v, -32.0).x )\n\t            *smoothstep( 23.0, 24.0, abs(p.z-3.) );\n    v = mod( v, 5.0 ) - 2.5;\n    float a = p.y - (h +6.0*e);\n    return max(dot(vec2(0.94,0.342), vec2(length(v),a)),a);\n  //  float a = p.y - (h + 3.0*smoothstep( 53., 54.0, abs(p.z-10.) ));\n  //  return max(dot(vec2(0.94,0.342), vec2(length( mod(p.xz, 10.0 ) - 5.),a)),a);\n}\n\nvec2 girl(vec3 p) {\n    p/=.85;\n\n    vec2 res = vec2(length(p-vec3(0,3,0))-1.8, 0.);\n    \n    if (withWomen) {\n\t\tres.x = min(res.x, length(p-vec3(0,5.3,0))-1.4);\n        p.xz*=Rot2;\n\n        vec3 p1 = p - vec3(0,5.3,0);\n\n        p1.xy*=Rot;\n\n        float angle = atan(p1.x,p1.z);\n        float k = .05*abs(cos(1.5+10.*angle));\n        float cc = cos(3.14-10.*p1.y);\n        float hat = sdTorus(p1, vec3(1.3,.3,.3))-.03*cc-.5*k;\n\n        if (p1.y>0.) hat = min(hat, length(p1)-1.5-.5*k);\n\n        hat = smin(hat, length(p-vec3(1.2,6.5,.0))-.4, 1.1);\n        p1.z=abs(p1.z);\n        hat = smin(hat, length(p1-vec3(-.54,-.6,1.34))-.18,.43);\n        float hat2 = length(p1-vec3(-.4,-.95,1.6))-.25;\n\n        vec3 p0 = p;    \n\n        p0-=vec3(0,4.3,0)*(1.+.05*cos(p0.x));\n\n        float echarpe = sdTorus(p0, vec3(1.3,.3,.3))-.05*cos(3.14-10.*p0.y);\n        float noze = sdCapsule(p, vec3(-1.6,5.1,0), vec3(0,5.,0), .12, .3 );\n\n        p.z = abs(p.z);\n        float eyes = length(p-vec3(-1.3,5.32,.25))-.15;\n        res = res.x<hat2 ? res : vec2(hat2, 8.); \n        res = res.x<eyes ? res : vec2(eyes, 12.); \n        res = res.x<noze ? res : vec2(noze, 13.); \n        res = res.x<hat ? res : vec2(hat,   mod(1.5708*angle,1.)>.5?8.:9.); \n        res = res.x<echarpe ? res : vec2(echarpe*.9, mod(1.5708*atan(p0.x,p0.z),1.)>.5?8.:9.); \n        res.x*=.9;\n    }\n    res.x*=.85;\n    return res;\n}\n\n\nvec2 man(vec3 p) {\n\tfloat body = min(\n            length(p-vec3(0,3,0))-1.8,\n        \tlength(p-vec3(0,5.3,0))-1.4);\n    vec2 res = vec2(body, 0.);\n    \n    vec3 p1=p;\n    p1.z = abs(p1.z);\n    float hand = min(sdCapsule(p1, vec3(.5,4.2,0), vec3(-1.6,3.2,2), .12, .09 ),\n                     sdCapsule(p1, vec3(-1.2,3.3,1.8), vec3(-1.6,3.6,2.1), .1, .05));\n\n    res = res.x<hand ? res : vec2(hand,    12.); \n\n    if (withMen) {\n        vec3 p1 = p - vec3(0,5.3,0);\n\n        p1.xy*=Rot;\n        p.xz*=Rot;\n\n        float angle = atan(p1.x,p1.z);\n        float k = .05*abs(cos(1.5+10.*angle));\n        float cc = cos(3.14-10.*p1.y);\n        float hat = sdTorus(p1, vec3(1.3,.3,.3))-.03*cc-1.1*k;\n        if (p1.y>0.) hat = min(hat, length(p1)-1.5-2.*k);\n\n        hat = min(hat, length(p1-vec3(.3,2.,.0))-.54);\n\n        vec3 p0 = p;    \n\n        p0-=vec3(0,4.3,0)*(1.+.05*cos(p0.x));\n\n        float echarpe = sdTorus(p0, vec3(1.3,.3,.3))-.05*cos(3.14-10.*p0.y);\n        float noze = sdCapsule(p, vec3(-1.8,5.1,0), vec3(0,5.,0), .12, .3 );\n\n        p.z = abs(p.z);\n        float eyes = length(p-vec3(-1.3,5.43,.3))-.15;\n\n        res = res.x<eyes    ? res : vec2(eyes,    12.); \n        res = res.x<noze    ? res : vec2(noze,    13.); \n        res = res.x<hat     ? res : vec2(hat,     mod(1.5708*angle,1.)>.5?10.:11.); \n        res = res.x<echarpe ? res : vec2(echarpe*.9, mod(1.5708*atan(p0.x,p0.z),1.)>.5?10.:11.); \n        res.x*= 0.9;\n    }\n    \n    return res;\n}\n\n\nvec2 map(in vec3 p) {\n\t// Terrain\n\tfloat h = terrain(p.xz);\n// return vec2(p.y - h, 0.);\n    // Snowmens\n    vec2 res =  smin(mini(man(p-vec3(-1.3,0,3)), girl(p-vec3(-2,0.25,8))), vec2(p.y - h, 0.));\n  \n    // Trees\n#ifdef TREES\n    float dis = trees(p,h);\n    return dis<res.x ? vec2(dis, 1.) : res;\n#else\n    return res;\n#endif \n}\n\nconst float precis = 0.0235;\nconst vec3 eps = vec3(precis,0.0,0.0);\n\nvec3 intersect( in vec3 ro, in vec3 rd ) {\n    float h = precis*1.5;\n#ifdef STEREOGRAPHIC\n    float t = .0;\n#else\n    float t = 4.0;\n#endif\n    vec2 res;\n    for( int i=0; i<NB_ITER; i++ ){\n        if(h<precis||t>100.) break;\n#ifdef STEREOGRAPHIC\n        h*=.9;\n#endif\n        t += h;\n\t    res = map( ro+rd*t );\n        h = res.x;\n    }\n    return vec3( t, res.y, (t>100.) ? -1.0 : res.y );\n}\n\nvec3 calcNormal( in vec3 pos ) {\n\treturn normalize( vec3(\n           map(pos+eps).x - map(pos-eps).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k ) {\n  //  return .5;\n    float res=1., t=0.2, h=1.;\n    for( int i=0; i<46; i++ ) {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.15, 1.0 );\n\t\tif( h<0.0012 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nfloat calcOcc( in vec3 pos, in vec3 nor ) {\n    vec3 aopos;\n\tfloat hr, dd, totao = 0.0;\n    for(float aoi=0.; aoi<1.; aoi+=.125 ){\n        hr = 0.1 + 1.5*aoi*aoi;\n        aopos = pos + nor * hr;\n        dd = map( aopos ).x;\n\t\ttotao += max( 0.0, hr-3.0*dd-0.01);\n    }\n    return clamp( 1.0 - 0.15*totao, 0.0, 1.0 );\n}\n\n\nvec3 lig = normalize(vec3(-0.5,0.25,-0.3));\n\n\nvoid shade( in vec3 pos, in vec3 nor, in vec3 rd, in float matID, out vec3 mate){\n// TODO: use an Array\n    if( matID<0.5)        { mate = vec3(.8,.8,.8); }\n    else if( matID>12.5 ) { mate = vec3(4.,.2,.2); }\n    else if( matID>11.5 ) { mate = vec3(.1); }\n    else if( matID>9.5 )  { mate = mix(vec3(0,.5,.6),vec3(.3,.8,.9), matID-10.); }\n    else if( matID>7.5 )  { mate = mix(vec3(.6,0.2,.5),vec3(.9,.6,.8), matID-8.); }\n \telse/*if( matID>.5)*/ { mate = vec3(0.05,0.1,0); }   \n}\n\n\nfloat cloudShadow( in vec3 pos ) {\n\treturn 0.45 + 0.55*smoothstep( 0.1, 0.35, texture( iChannel1, 0.0003*(pos.xz + lig.xz*(100.0-pos.y)/lig.y) + 0.1+0.0043*iTime ).x );\n}\n\n\n#ifdef STEREOGRAPHIC\nvec3 getStereoDir(vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float t = 3.+iTime*.08, ct = cos(t), st = sin(t);\n\tfloat m = .5;\n\n    p = (p * 2. * m - m)*3.1;\n    p.x *= iResolution.x/iResolution.y;\n    p *= mat2(ct,st,-st,ct);\n\n\treturn normalize(vec3(2.*p.x,dot(p,p)-1.,2.*p.y));\n}  \n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(.5,0.);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\n\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n#ifdef STEREOGRAPHIC\n\tfloat ctime = iTime*6.;\n\tvec3 rd = getStereoDir(fragCoord);\n    float r = 7.+3.0*m.x;\n    float an = -.35+1.2*sin(5.3+0.05*ctime)- 6.2831*(m.x-0.05);\n\tvec3 ro = vec3(-1.-r*sin(-an),3.5+clamp(5.*m.y, 0.,10.),4.-r*cos(-an));    \n#else\n\tfloat ctime = iTime*2.;\n    float an = -.35+1.2*sin(5.3+0.05*ctime) - 6.2831*(m.x-0.05);\n\tvec3 ro = vec3(-28.0*sin(-an),3.5+clamp(15.*m.y, 0.,100.),-28.0*cos(-an));\n    vec3 ta = vec3(2.0,2.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 3.7*ww );\n#endif // STEREOGRAPHIC\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n\tcol *= 0.9;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(2.0,1.5,0.0)*0.8*pow( sun, 32.0 );\n\n    vec3 bgcol = col;\n\n\twithMen = intersectSphere(ro, rd, vec3(-1.3,5.6,3), 2.3);\n\twithWomen = intersectSphere(ro, rd, vec3(-2,4.75,8), 1.8);\n\t\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat occ = 1.; //calcOcc(pos,nor) * clamp(0.7 + 0.3*nor.y,0.0,1.0);\n\n        // materials\n\t\tvec3 mate = vec3(0);\n        shade( pos, nor, rd, tmat.z, mate);\n\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\t// lighting\n        float sky = 0.6 + 0.4*nor.y;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\tfloat sha = 0.0;\n        if( dif>0.01 ) {\n            withMen = intersectSphere(pos+0.01*nor, lig, vec3(-1.3,5.6,3), 2.3);\n\t\t\twithWomen = intersectSphere(pos+0.01*nor, lig, vec3(-2,4.75,8), 1.8);\n            sha=softshadow( pos+0.01*nor, lig, 64.0 );\n\t\t\tsha *= cloudShadow( pos );\n        }\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\n\t\t// lights\n\t\tvec3 lin = dif*vec3(1.70,1.15,0.70)*pow(vec3(sha),vec3(1.0,1.2,2.0));\n\t\tlin += 1.2*bou*vec3(0.15,0.20,0.20)*(0.5+0.5*occ);\n        lin += occ*( fre*vec3(1.00,1.25,1.30)*0.5*(0.5+0.5*dif*sha)\n                    +sky*vec3(0.05,0.20,0.45)\n\t\t\t\t\t+bac*vec3(0.20,0.25,0.25));\n\n\t\t// surface-light interacion\n\t\tcol = mate*lin;\n\n\t\t// fog\n        #ifdef STEREOGRAPHIC\n\t\tcol = mix( bgcol, col, exp(-0.0015*pow(abs(tmat.x),1.37)) );\n\t\t#else\n        col = mix( bgcol, col, exp(-0.0015*pow(abs(tmat.x),1.67)) );\n        #endif\n    } else {\n        vec2 cuv = ro.xz + rd.xz*(1000.0-ro.y)/rd.y;\n        float cc = texture( iChannel1, 0.00015*cuv +0.1+ 0.0043*iTime ).x;\n        cc = 0.65*cc + 0.35*texture( iChannel1, 0.00015*2.0*cuv + 0.0043*.5*iTime ).x;\n        cc = smoothstep( 0.3, 1.0, cc );\n     \n        col = mix( col, vec3(1.0,1.0,1.0)*(0.95+0.20*(1.0-cc)*sun), 0.7*cc );\n      #ifdef STEREOGRAPHIC\n\t\tcol = .35+.65*col;  // less background sky => higlight the Ball\n      #endif\n    }\n\n\t// sun glow\n    col += vec3(1.0,0.6,0.2)*0.4*pow( sun, 4.0 );\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(.45)); //.53) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.8 + 0.2*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.333, 0.25 );\n\tcol *= vec3(1.0,1.02,0.96);\n#ifdef STEREOGRAPHIC\n\tcol *= 0.55 + 0.45*pow(abs( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y)), 0.35 );\n#else\n\tcol *= 0.55 + 0.45*pow(abs( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y)), 0.16 );\n#endif\n    fragColor = clamp(vec4( col, 1.0 ),0.,1.);\n}\n\n\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[468, 651, 676, 676, 806], [808, 876, 914, 914, 1007], [1009, 1009, 1086, 1086, 1224], [1226, 1226, 1295, 1295, 1396], [1398, 1466, 1507, 1507, 1595], [1597, 1597, 1631, 1631, 1720], [1722, 1722, 1756, 1756, 1779], [1781, 1850, 1876, 1876, 2041], [2044, 2044, 2081, 2081, 2512], [2514, 2514, 2533, 2533, 3901], [3904, 3904, 3922, 3922, 5366], [5369, 5369, 5390, 5402, 5701], [5772, 5772, 5814, 5814, 6164], [6166, 6166, 6198, 6198, 6377], [6379, 6379, 6432, 6449, 6668], [6671, 6671, 6714, 6714, 6988], [7037, 7037, 7118, 7140, 7518], [7521, 7521, 7555, 7555, 7691], [8026, 8026, 8083, 8083, 12139]]}
{"id": "XtlGD8", "name": "Complex power", "author": "yakoudbz", "description": "A simple shader to display the power of the complex plane (literally)\nYou can change powermax and powermin to any value you want.", "tags": ["fast", "complex", "power", "transform"], "likes": 2, "viewed": 291, "date": "1421667922", "time_retrieved": "2024-06-20T18:16:28.895253", "image_code": "// Complex power\n//--------------\n// by CÃ©lestin Marot\n// celestinmarot@hotmail.com\n\n// comment to supress isolines | shade | color\n#define ISOLINES\n#define SHADE\n#define COLORS\n\n// change it as you want\n#define powermax 2.0\n#define powermin 1.0\n\n// isoline interval and width\n#define interval 0.3\n#define linewidth 0.1\n\n#define pi 3.14159265359\n\nvec2 cartToPol(vec2 z){\n\treturn vec2(length(z),atan(z.y,z.x));\n}\n\nvec2 polToCart(vec2 p){\n\treturn vec2(p.r*cos(p.g),p.r*sin(p.g));\n}\n\nvec3 colorize(vec2 p){\n   \t// give a color for each number p\n    #ifdef COLORS\n    float A = mod(p.g/pi,2.0)-1.0; // angle from -1 to 1\n    float AA = abs(A + 1./3.) - 1.0;\n    float AAA = 1.0 - abs(A - 1./3.);\n    vec3 color = vec3(1.0 - abs(A), 1.0 - abs(AA),1.0 - abs(AAA));\n    color/=length(color);\n    #else\n    vec3 color=vec3(0);\n    #endif\n\t\n    #ifdef SHADE\n    color *= exp(-p.r)*1.2;\n    #endif\n    \n    // ==== iso-line ===\n    #ifdef ISOLINES\n    vec2 z = polToCart(p);\n    //float isog = smoothstep(interval-linewidth,interval+linewidth,abs(mod(A,2.0*interval)-interval));\n    float isor = smoothstep(linewidth,-0.03,abs(mod(p.r,interval)*2.0/interval - 1.0));\n    float isox = smoothstep(linewidth,-0.03,abs(mod(z.x,interval)*2.0/interval - 1.0));\n    float isoy = smoothstep(linewidth,-0.03,abs(mod(z.y,interval)*2.0/interval - 1.0));\n\t\n    return color + isox + isoy + isor;\n    #else\n    return color;\n    #endif\n}\n\nvec2 powz(vec2 p , float power){\n    return vec2(pow(p.r,power),power*mod(p.g,2.*pi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 Z = ( 2.0*fragCoord.xy / iResolution.xy ) - 1.0;\n\tvec2 P = cartToPol(Z);\n        \n    vec2 p = powz(P,cos(iTime)*0.5*(powermax-powermin)+0.5*(powermin+powermax));\n\n    fragColor = vec4(colorize(p), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[250, 350, 373, 373, 414], [416, 416, 439, 439, 482], [484, 484, 506, 544, 1417], [1419, 1419, 1451, 1451, 1507], [1509, 1509, 1566, 1566, 1783]]}
{"id": "XtlGDH", "name": "kalizyl", "author": "bergi", "description": "If you suffer headache or stomach pain, try Kalizyl!", "tags": ["raymarching", "kaliset", "lights", "ornamental"], "likes": 66, "viewed": 5906, "date": "1421712080", "time_retrieved": "2024-06-20T18:16:29.803923", "image_code": "/*\tkalizyl \n\t\n\t(c) 2015, stefan berke (aGPL3)\n\n\tAnother attempt on the kali set\n\thttp://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n\tLooks cool and frametime is not too bad -\n\tbut still uses precission 0.1 for raymarching. (but see EIFFIE_MOD)\n\tMaybe saves some speed by not coloring the surface.\n\t\n*/\n\n// plot a 2d slice of the distance function\n#define PLOT_2D\t\t\t0\n// enable eiffie's modification (https://www.shadertoy.com/view/XtlGRj)\n#define EIFFIE_MOD\t\t0\n\n\n#define KALI_PARAM \t\tvec3(0.71)\n#define LIGHT_COL \t\tvec3(1.0, 0.8, 0.4)\n\n#if EIFFIE_MOD == 0\n    #define FOG_DIST \t\t5.\n    #define FOG_COL \t\tvec3(0.5, 0.7, 1.0)\n    #define CYL_RADIUS \t\t0.07\n    #define NUM_TRACE \t\t80\n    #define MARCH_PRECISION\t0.1\n#else\n    #define FOG_DIST \t\t2.\n    #define FOG_COL \t\t(vec3(0.5, 0.7, 1.0)/3.)\n    #define CYL_RADIUS \t\t0.009\n    #define NUM_TRACE \t\t40\n    #define MARCH_PRECISION\t0.9\n#endif\n\n#if EIFFIE_MOD == 0\n// standard kali set \n// modified to return distance to cylinders and spheres in 'kali-space'\nvec2 scene_dist(in vec3 p)\n{\n\tvec2 d = vec2(100.);\n\tfor (int i=0; i<4; ++i)\n\t{\n\t\tp = abs(p) / dot(p, p) - KALI_PARAM;\n        // distance to cylinder\n\t\td.x = min(d.x, length(p.xz));\t\n        if (i < 3)\n        {\n            vec3 lightpos = vec3(0., 1.+sin(iTime+p.y+float(i)*1.3), 0.);\n            // distance to sphere\n        \td.y = min(d.y, length(p - lightpos));\t\n        }\n\t}\n\treturn d - CYL_RADIUS;\n}\n\n#else\n\n// eiffie's mod\nvec2 scene_dist(in vec3 pos)\n{\n    // p.w will track how much we have stretched space\n    vec4 p = vec4(pos, 1.);\n\tvec2 d = vec2(100.);\n\tfor (int i=0; i<4; ++i)\n\t{\n\t\tp = abs(p) / dot(p.xyz, p.xyz) - vec4(KALI_PARAM, 0.);\n\t\td.x = min(d.x, length(p.xz)/p.w); //now we are calcing unstretched distance\n        if (i < 3)\n        {\n            vec3 lightpos = vec3(0., 1.+sin(iTime+p.y+float(i)*1.3), 0.);\n            d.y = min(d.y, length(p.xyz - lightpos)/p.w);\n        }\n\t}\n\treturn d - CYL_RADIUS;\n}\n\n#endif\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p = pos;\n\n\tfloat t = 0., mlightd = 100.;\n    \n    vec2 d = scene_dist(pos);\n\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\t\n\t\tif (d.x < 0.001 || t >= FOG_DIST) \n\t\t\tcontinue;\n\n\t\tp = pos + t * dir;\n\t\tvec2 d = scene_dist(p);\n\n        // collect minimum distance to light\n\t\tmlightd = min(mlightd, d.y);\n\n\t\tt += d.x * MARCH_PRECISION;\t\t\n\t}\n\n    // only fog contribution\n\tvec3 col = FOG_COL * min(1., t/FOG_DIST);\n\n    // plus light glow\n    col += LIGHT_COL / (1. + 50.*max(0., mlightd));\n\n\treturn col;\n}\n\nvec3 plot2d(in vec3 pos)\n{\n\tvec2 d = scene_dist(pos);\n    // inside?\n    float ins = smoothstep(0.01,-0.01, d.x);\n    vec3 col = vec3(d.x, ins, 0.);\n    \n    return col;\n}\n\n// camera path\nvec3 path(float ti)\n{\n\tfloat a = ti * 3.14159265 * 2.;\n\n\treturn vec3(\n\t\t\t\t1.1 * sin(a),\n\t\t\t\t0.52 * sin(a*2.),\n\t\t\t\t1.1 * cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n    vec3 pos, dir;\n    mat3 dirm = mat3(vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.));\n    \n    if (iMouse.z < 0.5)\n    {\n        // camera time\n        float ti = iTime / 19.;\n\n        pos = path(ti);\n\n        // camera orientation matrix\n        vec3 look;\n\n        // how much to look towards the center [0,1]\n        float lookcenter = 0.45 + 0.45 * sin(ti*7.);\n    \tlook = normalize(path(ti + 0.1) - pos);\n\t\tlook = look + lookcenter * (normalize(-pos) - look);\n        vec3 up = normalize(cross(vec3(0., 1., 0.), look));\n        vec3 right = normalize(cross(look, up));\n        //look = normalize(cross(up, right));\n        dirm = mat3(right, up, look);\n\n        dir = dirm * normalize(vec3(uv, 1.5));\n    }\n    else\n    {\n        vec2 m = iMouse.xy / iResolution.xy;\n        pos = vec3(m.x*2.-1., 0., 3. * m.y);\n        dir = normalize(vec3(uv, -1.));\n    }\n#if PLOT_2D == 0\n\tfragColor = vec4( traceRay(pos, dir), 1.);\t\n#else\n    fragColor = vec4( plot2d(pos + dirm * vec3(uv,0.)), 1.);\t\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "agpl-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[414, 1990, 2031, 2031, 2527], [2529, 2529, 2555, 2555, 2700], [2702, 2717, 2738, 2738, 2848], [2850, 2850, 2907, 2907, 4006]]}
{"id": "XtlGW4", "name": "[2TC 15] old skool 3d driving", "author": "mattz", "description": "Inspired by a recent perusal of http://www.extentofthejam.com/pseudo/ to see if I could fit this type of effect into the \"2 tweet\" challenge.", "tags": ["road", "fake3d", "muchtiny"], "likes": 83, "viewed": 6220, "date": "1422130309", "time_retrieved": "2024-06-20T18:16:29.803923", "image_code": "void mainImage( out vec4 f, vec2 p ){\n    \n    vec3 q=iResolution,d=vec3(p-.5*q.xy,q.y)/q.y,c=vec3(0,.5,.7);\n    \n    q=d/(.1-d.y);\n    float a=iTime, k=sin(.2*a), w = q.x *= q.x-=.05*k*k*k*q.z*q.z;\n\n    f.xyz=d.y>.04?c:\n    \tsin(4.*q.z+40.*a)>0.?\n        w>2.?c.xyx:w>1.2?d.zzz:c.yyy:\n\t    w>2.?c.xzx:w>1.2?c.yxx*2.:(w>.004?c:d).zzz;\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 37, 341]]}
{"id": "Xts3R7", "name": "mod noise", "author": "dzira", "description": "just messing around, maybe there's an idea in there somewhere. I wanted to make a noise that didn't use sqrt or trig or a lookup (edit: made it more noisy)", "tags": ["noise", "hash"], "likes": 6, "viewed": 259, "date": "1420211109", "time_retrieved": "2024-06-20T18:16:29.803923", "image_code": "//edit made it less liney and more noisey by doing a has twice, the sin is only there to animate zoom\n\nfloat hash(vec2 uv)\n{\n    float r;\n    uv = abs(mod(10.*fract((uv+1.1312)*31.),uv+2.));\n    uv = abs(mod(uv.x*fract((uv+1.721711)*17.),uv));\n    return r = fract(10.* (7.*uv.y + 31.*uv.x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = .5*(abs(sin(iTime/2.))+.5)*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv.x = hash(vec2(hash(uv),1.0));\n\n    fragColor = vec4(uv.x,uv.x,uv.x,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 103, 124, 124, 294], [297, 297, 354, 354, 525]]}
{"id": "Xts3WH", "name": "[2TC 15] Lava Lamp", "author": "Trisomie21", "description": "[2TC 15] Lava Lamp", "tags": ["noise"], "likes": 13, "viewed": 2709, "date": "1421709612", "time_retrieved": "2024-06-20T18:16:29.803923", "image_code": "void mainImage( out vec4 c, in vec2 w )\n{\n\tvec2 p = w/iResolution.xy, a = p*5.; a.y -= iTime;\n\tvec2 f = fract(a); a -= f; f = f*f*(3.-2.*f);\n    vec4 r = fract(sin(vec4(a.x + a.y*1e3) + vec4(0, 1, 1e3, 1001)) * 1e5)*30./p.y;\n\tc.rgb = p.y + vec3(1,.5,.2) * clamp(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y)-30., -.2, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 41, 41, 327]]}
{"id": "XtsGz7", "name": "Voronoi Experiment 1", "author": "aiekick", "description": "Voronoi Experiment 1", "tags": ["raymarching", "voronoi", "experiment", "sphere", "blob", "mapping"], "likes": 8, "viewed": 1337, "date": "1420247765", "time_retrieved": "2024-06-20T18:16:30.167669", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/////////////////////////////////////////////////////////////////\n// VORONOI based on IQ shader https://www.shadertoy.com/view/ldl3W8\n//vec2 getHash2BasedTex(vec2 p) {return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;}//texture based white noise\nvec2 getHash2BasedProc(vec2 p){return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);}//procedural white noise\nvec3 getVoronoi(vec2 x){\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(iTime+6.2831*getHash2BasedProc(n+g));//animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);}\n// sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n){\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n   \treturn getVoronoi(1.5*uv);}\n// blobby voronoi\nfloat map(vec3 p){\n    float disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;\n\treturn length(p)-1.+disp;}\n// normal calc based on nimitz shader https://www.shadertoy.com/view/4sSSW3\nvec3 getNormal(const in vec3 p){  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );}\n// ray-marcher based on sebastien shader https://www.shadertoy.com/view/XtXGzM\nfloat march(vec3 ro,vec3 rd){\n\tfloat maxd=10.;\n    float tmpDist=1.;\n    float finalDist=0.;\n    for(int i=0;i<50;i++){\n        if( tmpDist<0.001||finalDist>maxd) break;\n\t    tmpDist=map(ro+rd*finalDist);\n        finalDist+=tmpDist; }\n    if(finalDist>maxd) finalDist=-1.;\n\treturn finalDist; }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.,0.,2.),rd=normalize(vec3(uv,-1.));\n   \tfloat t=march(ro,rd);\n     if(t>0.){\n        vec3 pos = ro+t*rd;\n        vec3 col = mix(vec3(max(0.,2.3-t)),voronoiSphereMapping(normalize(pos)),0.5);\n        float bright=dot(getNormal(pos),normalize(pos))*0.8;\n        fragColor= vec4(bright*col+pow(bright,8.0)*(1.-t*.01),1.); } }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtsGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 387, 418, 418, 505], [505, 530, 554, 554, 885], [886, 918, 952, 952, 1024], [1025, 1043, 1061, 1061, 1165], [1166, 1242, 1274, 1274, 1425], [1426, 1505, 1534, 1534, 1798], [1799, 1799, 1855, 1855, 2285]]}
{"id": "XtX3DH", "name": "Oblivion", "author": "nimitz", "description": "Thanks to eiffie for the idea of playing with triangle noise in 3d. I wanted to add floating objects but couldn't think of anything, let me know if you have ideas.", "tags": ["3d", "noise", "volumetric", "trianglenoise", "epilepsywarning"], "likes": 68, "viewed": 2747, "date": "1421350423", "time_retrieved": "2024-06-20T18:16:31.258628", "image_code": "// Oblivion by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XtX3DH\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tMostly showing off animated triangle noise, the idea is to just use\tcombinations\n\tof moving triangle waves to create animated noise. In practice, only very few\n\tlayers of triangle wave basis are needed to produce animated noise that\tis visually\n\tinteresting (using 4 layers here), meaning that this runs considerably faster\n\tthan equivalent animated perlin-style noise and without the need for value noise as input.\n*/\n\n#define ITR 50\n#define FAR 25.\n#define time iTime*2.\n\n#define MSPEED 5.\n#define ROTSPEED .3\n\n#define VOLSTEPS 20\n\n//#define PENTAGRAM_ONLY\n\nfloat hash(in float n){ return fract(sin(n)*43758.5453); }\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}                           \n\nvec3 path(in float t){return vec3(sin(t*.3),sin(t*0.25),0.)*0.3;}\n\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.5;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.)*1.;\n        p += (dg+time*0.25);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.1;\n        p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat map(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    return d;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    float id = 0.;;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nfloat mapVol(vec3 p)\n{\n    p -= path(p.z);\n    float d = 1.-length(p.xy);\n    d -= triNoise3d(p*0.15)*1.2;\n    return d*0.55;\n}\n\nvec4 marchVol( in vec3 ro, in vec3 rd )\n{\n\tvec4 rz = vec4(0);\n\n\tfloat t = 0.3;\n\tfor(int i=0; i<VOLSTEPS; i++)\n\t{\n\t\tif(rz.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float r = mapVol( pos );\n\t\t\n        float gr =  clamp((r - mapVol(pos+vec3(.0,.1,.5)))/.5, 0., 1. );\n        vec3 lg = vec3(0.7,0.5,.1)*1.2 + 3.*vec3(1)*gr;\n        vec4 col = vec4(lg,r+0.55);\n        col *= sin(time + pos.z*0.2 + sin(pos.x+pos.y))*0.15+0.88;\n\t\t\n\t\tcol.a *= .2;\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1. - rz.a);\n\t\tt += 0.05;\n\t}\n\trz.b += rz.w*0.2;\n    rz.rg *= mm2(-rd.z*0.09);\n    rz.rb *= mm2(-rd.z*0.13);\n\treturn clamp(rz, 0.0, 1.0);\n}\n\nvec2 tri2(in vec2 p)\n{\n    const float m = 1.5;\n    return vec2(tri(p.x+tri(p.y*m)),tri(p.y+tri(p.x*m)));\n}\n\nfloat triNoise2d(in vec2 p)\n{\n    float z=2.;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (tri(-time*0.5+p.x*(sin(-time)*0.3+.9)+tri(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=2.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= mm2(time*2.);\n        p += dg/z2;\n\n        bp *= 1.7;\n        z2 *= .7;\n\t\tz *= 2.;\n\t\tp *= 1.5;\n        p*= m2;\n        \n        rz+= (tri(p.x+tri(p.y)))/z;\n\t}\n\treturn rz;\n}\n\n\nvec3 shadePenta(in vec2 p, in vec3 rd)\n{   \n    p*=2.5;    \n\tfloat rz= triNoise2d(p)*2.;\n    \n    vec2 q = abs(p);\n    float pen1 = max(max(q.x*1.176+p.y*0.385, q.x*0.727-p.y), p.y*1.237);\n    float pen2 = max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237);\n    float d = abs(min(pen1,pen1-pen2*0.619)*4.28-.95)*1.2;\n    d = min(d,abs(length(p)-1.)*3.);\n    d = min(d,abs(pen2-0.37)*4.);\n    d = pow(d,.7+sin(sin(time*4.1)+time)*0.15);\n    rz = max(rz,d/(rz));\n    \n    vec3 col1 = vec3(.3,0.5,0.45)/(rz*rz);\n    vec3 col2 = vec3(1.,0.5,0.25)/(rz*rz);\n    vec3 col = mix(col1,col2,clamp(rd.z,0.,1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    float ext = smoothstep(0.7, 1.0,2.*tri(time*0.11));\n\tp += vec2(hash(time),hash(time+1.))*0.02*ext;\n    p += vec2(sin(time*1. + cos(time*1.5)),sin(time*2.5+1.))*0.025;\n    float dz = sin(time*ROTSPEED)*8.+1.;\n    vec3 ro = path(time*MSPEED+dz)*.7+vec3(0,0,time*MSPEED);\n    ro.z += dz;\n    ro.y += cos(time*ROTSPEED)*.4;\n    ro.x += cos(time*ROTSPEED*2.)*.4;\n    \n    vec3 tgt = vec3(0,0,time*MSPEED+1.);\n    vec3 eye = normalize( tgt - ro);\n    vec3 rgt = normalize(cross( vec3(0.0,1.0,0.0), eye ));\n    vec3 up = normalize(cross(eye,rgt));\n    vec3 rd = normalize( p.x*rgt + p.y*up + .75*eye );\n\t\n    #ifndef PENTAGRAM_ONLY\n    \n\tfloat rz = march(ro,rd);\n    \n    vec3 pos = ro+rz*rd;\n            \n    vec4 col = marchVol(pos,rd);\n    vec3 ligt = normalize( vec3(-.0, 0., -1.) );\n    vec2 spi = vec2(sin(time),cos(time))*1.;\n    float flick = clamp(1.-abs(((pos.z-time*MSPEED)*0.3+mod(time*5.,30.))-15.),0.,1.)*clamp(dot(pos.xy,spi),0.,1.)*1.7;\n    flick += \t clamp(1.-abs(((pos.z-time*MSPEED)*0.3+mod(time*5.+10.,30.))-15.),0.,1.)*clamp(dot(pos.xy,spi),0.,1.)*2.;\n    flick += \t clamp(1.-abs(((pos.z-time*MSPEED)*0.3+mod(time*5.+20.,30.))-15.),0.,1.)*clamp(dot(pos.xy,spi),0.,1.)*2.;\n    col.rgb += flick*(step(mod(time,2.5),0.2))*.4;\n    col.rgb += flick*(step(mod(time*1.5,3.2),0.2))*.4;\n    \n    col.rgb = mix(col.rgb*col.rgb,col.rgb*shadePenta(p,rd)*1.2, (tri(time*3.5)*0.9+0.1)*ext);\n    \n    #else\n    vec3  col = shadePenta(p,rd);\n    col = pow(col,vec3(1.5))*0.4;\n    #endif\n    \n\tfragColor = vec4( col.rgb, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[759, 785, 808, 808, 843], [844, 844, 865, 865, 917], [919, 919, 941, 941, 966], [967, 967, 988, 988, 1068], [1097, 1097, 1119, 1119, 1162], [1213, 1213, 1242, 1242, 1543], [1545, 1545, 1564, 1564, 1631], [1633, 1633, 1670, 1670, 1919], [1921, 1921, 1943, 1943, 2048], [2050, 2050, 2091, 2091, 2672], [2674, 2674, 2696, 2696, 2781], [2783, 2783, 2812, 2812, 3208], [3211, 3211, 3251, 3251, 3840], [3842, 3842, 3899, 3899, 5514]]}
{"id": "XtX3DN", "name": "Deform - tunnel : REDUX", "author": "StanRee", "description": "Based on of iq's older posts", "tags": ["tunnel", "endless"], "likes": 7, "viewed": 440, "date": "1421966312", "time_retrieved": "2024-06-20T18:16:31.719155", "image_code": "\n// Deform - square tunnel : REDUX\n// Modifications by Stanley Hayes\n// Original Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Hsv conversion from http://ploobs.com.br/?p=1499\nvec3 Hue(float a)\n{\n\tvec3 K = vec3(3,2,1)/3.;\n\treturn clamp(abs(fract(vec3(a)+K)*6. - vec3(3.)) - K.xxx, 0., 1.);\n}\n\nvec3 HSVtoRGB(vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.0) * HSV.y + 1.0) * HSV.z);\n}\n\n// Shader Begin\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates (-1 to 1 vertically)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // --- FROM IQ ----\n    // modified distance metric. Usually distance = (xÂ² + yÂ²)^(1/2). By replacing all the \"2\" numbers\n    // by 32 in that formula we can create distance metrics other than the euclidean. The higher the\n    // exponent, then more square the metric becomes. More information here:    \n    // http://en.wikipedia.org/wiki/Minkowski_distance\n    \n    //Makes everything a little trippy\n    float crayStationsCoef = .01;     \n    \n    p.x +=  sin(pow(iTime,.5))*crayStationsCoef*10.0;    \n    //p.y +=  cos(iTime)*crayStationsCoef*10.0;\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x) + iTime * sin(iTime)*.002 + iMouse.x * .0001;\n    \n    \n    float exp = 1.; // makes this a box if you see it fit\n    //Mink.. Calculation \n    float r = pow( pow(p.x*p.x,exp) + pow(p.y*p.y,exp), 1.0/(exp * 2.0) ) + sin(iTime)*crayStationsCoef;\n    a += pow(r,.5); \n           \n    // index texture by angle and radious, and animate along radius    \n    vec2 uv = vec2(0.5/r + 0.5*iTime + iMouse.y,                    a/3.1416 );\n\n    // Lighting\n    r -= sin(iTime)*.05;\n    \n    // fetch color and darken in the center\n    vec3 col =  texture( iChannel0, uv ).xyz * r;\n    \n    //Lerp in Cray Mode\n    col = (crayStationsCoef) * HSVtoRGB(vec3(col.r, 1.0, 1.0)) + col *(1.-crayStationsCoef); \t\n    col *= (sin(uv.x*5.0)*1.0 + 1.0) * .7;\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[203, 254, 273, 273, 369], [371, 371, 396, 396, 459], [461, 478, 535, 586, 2075]]}
{"id": "XtX3WH", "name": "Parallax Torus", "author": "gaz", "description": "Idea from https://www.shadertoy.com/view/4sSGD1", "tags": ["parallex"], "likes": 1, "viewed": 300, "date": "1421328348", "time_retrieved": "2024-06-20T18:16:31.719155", "image_code": "vec2 rotate(in vec2 p, in float t)\n{\n\treturn p*cos(-t)+vec2(p.y, -p.x)*sin(-t);\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\nfloat map(in vec3 p)\n{\n    return sdTorus(p, vec2(0.8,0.3));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2( 0.0001, 0.0 );\n\tvec3 n = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx ) );\n\treturn normalize( n );    \n}\n\nvec3 transform(in vec3 p)\n{\n    p.zx = rotate(p.zx, iTime*0.5);\n    p.yz = rotate(p.yz, iTime*0.6);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.3+0.1*p2.y);\n    vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n    const float steps = 64.0;\n    float pe = 3.0;\n\tfor(float i=0.0; i<steps; i++)\n\t{\n        float z = 1.0-2.0*pow(i/steps, 2.0);\n        float s = pe/(pe+z);\n        vec3 p3 = vec3(p2*s, z);\n        p3 = transform(p3);\n        if (map(p3) < 0.001)\n        {\n\t\t\tfloat dif = dot(calcNormal(p3), transform(light));\n        \tdif = clamp((dif+0.5)*0.7, 0.3, 1.0);\n\t\t\tcol =  texture(iChannel0, p3.xy).rgb*dif;\n            break;\n        }\n    }\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 81], [83, 83, 120, 120, 184], [186, 186, 208, 208, 248], [250, 250, 278, 278, 480], [482, 482, 509, 509, 597], [599, 599, 656, 656, 1271]]}
{"id": "XtX3Wr", "name": "shader-01", "author": "silviopaganini", "description": "testing mods", "tags": ["mod"], "likes": 2, "viewed": 112, "date": "1420565447", "time_retrieved": "2024-06-20T18:16:31.719155", "image_code": "precision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1. + 2. * fragCoord.xy / iResolution.xy;\n    vec2 offset = vec2(.3, .3);\n    \n    float radius = sin(iTime + sqrt(dot(p, p)));\n    float radius2 = sin(iTime + sqrt(dot(p - offset, p - offset)));\n    float radius3 = sin(iTime + sqrt(dot(p + offset, p + offset)));\n    \n    bool toggle1 = mod(radius, .1) > .01;\n    bool toggle2 = mod(radius2, .1) > .01;\n    bool toggle3 = mod(radius3, .1) > .01;\n    \n    //float col = toggle || toggle2 || toggle3 ? 1. : 0.0;\n    float col = 0.0;\n    if (toggle1) col = 1.0; \n    if (toggle2) col = 1.0;\n    if (toggle3) col = 1.0;\n    if ((toggle1) && (toggle2) && (toggle3)) col = 0.0;\n    \n//    fragColor = vec4(toggle, toggle2, toggle3, 1.); \n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 81, 81, 818]]}
{"id": "XtXGD4", "name": "[2TC 15] Blue Swirly Checkerboar", "author": "MichaelPohoreski", "description": "Inspired by Adrian's \"XOR Demoeffect in WebGL\"\nTweaked, minified to fit < 280 characters, and colorized blue", "tags": ["2d", "sin", "cos", "checkerboard"], "likes": 3, "viewed": 172, "date": "1421910203", "time_retrieved": "2024-06-20T18:16:31.901246", "image_code": "// [2TC 15] Blue Swirly Checkerboard\n// Copyleft {c} 2015 Michael Pohoreski\n// Chars: 257\n// Thanks to iq for the minification tips!\n//\n// Inspired from Adrian's XOR Demoeffect in WebGL\n// http://adrianboeing.blogspot.com/2011/01/xor-demoeffect-in-webgl.html\n\nvoid mainImage( out vec4 f, in vec2 w )\n{\n    vec2  p = 2.*w/iResolution.xy-1.,\n          v = vec2(sin(iTime*.5),cos(iTime*.5));\n    bool  a = mod(sqrt(dot(p + v.x,p + v.y)),.1)>.05,\n          b = mod(sqrt(dot(p - v  ,p - v.y)),.1)>.05; // intentional v.x -> v in first argument for anti-symmetry!\n    float t = \n        a ? b ? .1\n              : .6\n          : b ? .8\n              : dot(p,p);\n    f = vec4(1.-t,1.-t*t,1.-t*t*t,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 260, 301, 301, 696]]}
{"id": "XtXGD7", "name": "boss", "author": "gaz", "description": "3d", "tags": ["raymarching", "de"], "likes": 5, "viewed": 215, "date": "1422451086", "time_retrieved": "2024-06-20T18:16:31.907319", "image_code": "mat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{   \n    return (length(p)- r);\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b,0.0));\n}\n\nfloat map1(in vec3 p)\n{   \n    p.y +=   0.3 * smoothstep( 0.2, 0.0, length(abs(p.xz) - vec2(0.4, 0.4))) * (1.0 - step(0.0, p.y));\n    p.y +=  -0.2 * smoothstep(0.15, 0.0, length(abs(p.xz - vec2(0.4,0.0)) - vec2(0.0, 0.4))) * step(0.0, p.y);\n    p.x += -0.15 * smoothstep( 0.4, 0.3, length(p.yz)) * step(0.0, p.x);\n    p.x +=  0.15 * smoothstep( 0.1, 0.0, length(abs(p.yz) - vec2(0.0, 0.1))) * step(0.0, p.x);\n    p.x +=   0.1 * smoothstep( 0.1, 0.0, length(abs(p.yz - vec2(0.35,0.0)) - vec2(0.0, 0.3))) * step(0.0, p.x);\n    p.x +=  0.15 * smoothstep( 0.1, 0.0, length(p.yz - vec2(0.35,0.0))) * (1.0 - step(0.0, p.x));\n    return 0.6 * sdSphere(p, 1.0);\n}\n\nfloat map2(in vec3 p)\n{   \n    float a;\n    a = atan(p.y, p.x);\n    p.xy += -0.1 * smoothstep(0.2, 0.0, abs(p.z)) * vec2(cos(a), sin(a));\n    a = atan(p.z, p.y);\n\tp.yz += -0.1 * smoothstep(0.4, 0.2, abs(p.x)) * vec2(cos(a), sin(a));\n    a = atan(p.x, p.z);\n    p.zx += 0.1 * smoothstep(0.3, 0.1, abs(p.y)) * vec2(cos(a), sin(a));\n    return 0.5 * udBox(p, vec3(0.7));\n}\n\nfloat map3(in vec3 p)\n{   \n    float a = atan(p.y, p.x);\n    p.xy += -0.1 * smoothstep(0.1, 0.0, abs(mod(p.z, 0.3) - 0.15)) * vec2(cos(a), sin(a));\n    return 0.6 * sdSphere(p, 1.0);\n}\n\nfloat de1(in vec2 p)\n{\n\treturn length(normalize(p) * 0.5 -p);\t\n}\n\nfloat de2(in vec2 p)\n{\n\treturn abs(abs(p.x) + abs(p.y) - 0.5);\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nfloat de3(in vec2 p)\n{\n\treturn min(sdSegment(p, vec2(0.5, 0.5), vec2(-0.5, -0.5)),\n               sdSegment(p, vec2(-0.5, 0.5), vec2(0.5, -0.5)));\n}\n\nfloat map4(in vec3 p)\n{   \n    if (abs(p.x) > 0.6999) p.x += -0.15 * sign(p.x) * smoothstep(0.2, 0.0, de1(p.yz));\n    if (abs(p.y) > 0.6999) p.y += -0.15 * sign(p.y) * smoothstep(0.2, 0.0, de2(p.xz));\n    if (abs(p.z) > 0.6999) p.z += -0.15 * sign(p.z) * smoothstep(0.2, 0.0, de3(p.xy));\n    return 0.4 * udBox(p, vec3(0.7));\n}\n\nfloat map(in vec3 p)\n{   \n    float t = mod(iTime * 0.5, 12.0);\n    if (t < 3.0)  return mix(map1(p), map2(p), smoothstep( 1.0,  2.0, t));\n    if (t < 6.0)  return mix(map2(p), map3(p), smoothstep( 4.0,  5.0, t));\n    if (t < 9.0)  return mix(map3(p), map4(p), smoothstep( 7.0,  8.0, t));\n    if (t < 12.0) return mix(map4(p), map1(p), smoothstep(10.0, 11.0, t));\n    return 1.0;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz *= rotate(iTime * 0.5);\n    p.zx *= rotate(iTime * 0.7);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.1 + p.y * 0.15);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        //col = texture(iChannel0, pos.xz).rgb * dif * dep;\n        col = boxmap( iChannel0, pos * 2.0, n, 32.0 ).xyz * dif;\n        col = pow(col, vec3(0.8));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 72], [74, 115, 179, 179, 361], [363, 363, 402, 402, 434], [436, 436, 465, 465, 505], [507, 507, 530, 530, 1162], [1164, 1164, 1187, 1187, 1533], [1535, 1535, 1558, 1558, 1719], [1721, 1721, 1743, 1743, 1785], [1787, 1787, 1809, 1809, 1851], [1853, 1853, 1903, 1903, 2023], [2025, 2025, 2047, 2047, 2173], [2175, 2175, 2198, 2198, 2502], [2504, 2504, 2526, 2526, 2885], [2887, 2887, 2915, 2915, 3083], [3085, 3085, 3122, 3122, 3416], [3418, 3418, 3445, 3445, 3527], [3529, 3529, 3586, 3586, 4245]]}
{"id": "XtXGDM", "name": "[2TC 15] Ribbon", "author": "coyote", "description": ".", "tags": ["2d", "ribbon", "spiral"], "likes": 11, "viewed": 1395, "date": "1422296934", "time_retrieved": "2024-06-20T18:16:31.907319", "image_code": "//254 chars with Fabrice's help\n\nvoid mainImage( out vec4 f, vec2 p ) {\n    p /= iResolution.y;\n    float\n        t=iTime,\n        s=sin(t),\n        o = p.x/(.15+s/8.) - 5.*t,\n        u = (p.y-.5)/(.25+sin(3.*p.x+s)/16.),\n        a = asin( u ),\n        c = cos( a + o ),\n        b = - cos( a - o );\n    \n    s = c>.17 ? 1.+log(c)*.5 : 0.;\n    \n    f = vec4( s*.95, (1.-s)*(b>.1 ? .5 + log(b)/4. : 0.), 0, 0 ) * cos( 1.35*u );\n}\n\n\n//original 275 char\n/*\nfloat t=iTime, s=sin(t);\nvoid main() {\n    vec4\n        p = gl_FragCoord/iResolution.y;\n    float\n        o = p.x/( .15+.125*s ) - 5.*t,\n        u = (p.y-.5)/(.25+.0625*sin(3.*p.x+s)),\n        a = asin( u ),\n        c = cos( a + o ),\n        b = cos( a - o - 3.14 ),\n        r; //,g;\n    \n    r = c>.17 ? 1.+log(c)*.5 : 0.,\n    //g = b>.1 ? .5 + log(b)/4. : 0.;\n    \n    gl_FragColor = vec4( r*.95, (1.-r)*(b>.1 ? .5 + log(b)/4. : 0.), 0, 0 ) * cos( 1.35*u );\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 33, 71, 71, 427]]}
{"id": "XtXGWn", "name": "Sonar", "author": "jherico", "description": "A work in progress, public so I can test the shadertoy API", "tags": ["3d", "shadertoyvr"], "likes": 6, "viewed": 1380, "date": "1420590764", "time_retrieved": "2024-06-20T18:16:33.155725", "image_code": "// Based on 'Elevated' by by inigo quilez - iq/2013\n// Modified by Brad Davis\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat terrain( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain2( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<14; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain3( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat map( in vec3 p )\n{\n    return p.y - terrain(p.xz);\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<120; i++ )\n\t{\n\t\tfloat h = map( ro + t*rd );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<48; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = map( p );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>200.0 ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrain2(pos.xz-eps.xy) - terrain2(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrain2(pos.xz-eps.yx) - terrain2(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn 1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\nconst vec3 DARKGREY = vec3(0.1);\nconst vec3 LIGHTGREY = vec3(0.2);\nconst vec3 WHITE = vec3(1);\nconst vec3 AMBER = vec3(1, 0.49, 0);\n\n\nvec3 fade(vec3 col1, vec3 col2, float max, float min, float actual) {\n    if (actual >= max) {\n        return col2;\n    }\n\n    if (actual <= min) {\n        return col1;\n    }\n    \n    float mixVal = (actual - min) / (max - min);\n    return mix(col1, col2, mixVal);\n}\n\nvec3 fade(vec3 col, float max, float min, float actual) {\n    return fade(col, DARKGREY, max, min, actual);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x/iResolution.y,1.0);\n\n    float time = iTime*0.15 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\t\n\tvec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n\n    // camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrain3( ro.xz ) + 11.0;\n\tta.y = ro.y - 20.0;\n\tfloat cr = 0.2*cos(0.1*time);\n\n    // camera ray    \n\n    #ifdef SHADERTOY_VR\n\tvec3  rd = normalize( iDir );\n    #else\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( s.x*cu + s.y*cv + 2.0*cw );\n    #endif\n\n    // bounding plane\n    float tmin = 2.0;\n    float tmax = 2000.0;\n    float maxh = 210.0;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    float sec = fract(iTime / 2.0);\n    float dist = fract(t / 100.0);\n    if( t>tmax) {\n\t\tcol = DARKGREY;\n\t} else {\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 edge = fract(pos / vec3(40.0) + vec3(0.5));\n        vec3 mountainColor = LIGHTGREY;\n        mountainColor = fade(mountainColor, 500.0, 400.0, t);\n        vec3 gridColor = mountainColor;\n        if (edge.x < 0.03 ||edge.z < 0.03) {\n            gridColor = AMBER;\n        }\n        gridColor = fade(gridColor, 2000.0, 800.0, t);\n        mountainColor = fade(mountainColor, gridColor, 100.0, 80.0, t);\n        if (t < 100.0) {\n\t        vec3 highlightColor = vec3(0.1);\n            float dotVal = dot(rd, nor);\n            if (dotVal > 0.1) {\n            \thighlightColor = (dotVal + 0.2) * WHITE;\n            }\n\t        mountainColor = fade(highlightColor, mountainColor, 100.0, 50.0, t);\n        }\n\n        col = mountainColor;\n//        if (t < 100.0 && abs(dist-sec) < 0.01) {\n//        \tcol = mix(col, vec3(0,1,0), (1.0 - dist));\n//        } else {\n//\t\t\t    col = fade(col, 1000.0, 400.0, t);\n//\t\t\t    col = fade(col, 200.0, 100.0, t);\n//        }\n    }\n\n    // gamma\n\tcol = pow(col,vec3(0.4545));\n\n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\t\n    #ifdef STEREO\t\n    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[167, 214, 240, 240, 679], [722, 722, 750, 750, 1007], [1009, 1009, 1038, 1038, 1296], [1298, 1298, 1327, 1327, 1584], [1586, 1586, 1610, 1610, 1644], [1646, 1646, 1719, 1719, 1868], [1870, 1870, 1913, 1934, 2174], [2176, 2176, 2217, 2217, 2458], [2460, 2460, 2488, 2488, 2558], [2561, 2561, 2582, 2582, 2865], [3001, 3001, 3070, 3070, 3267], [3269, 3269, 3326, 3326, 3378], [3380, 3380, 3437, 3437, 6005]]}
