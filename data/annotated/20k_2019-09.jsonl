{"id": "3d33DS", "name": "my-balls", "author": "pqnet", "description": "balls. My first experiment on raymarching", "tags": ["raymarching"], "likes": 2, "viewed": 85, "date": "1569168061", "time_retrieved": "2024-06-20T19:43:17.159412", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nhighp vec4 sphere(vec3 center, float radius, vec3 test) {\n    vec3 normal = normalize(test-center);\n    float dist = length(test - center) - radius;\n    return vec4(normal,dist);\n}\n\nhighp vec4 opUnion(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,snd,smoothstep(-smoothness, smoothness, fst.w - snd.w));\n}\n\nhighp vec4 opIntersect(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,snd,smoothstep(-smoothness, smoothness, snd.w - fst.w));\n}\n\nhighp vec4 opSubtract(vec4 fst, vec4 snd, float smoothness) {\n    return mix(fst,-snd,smoothstep(-smoothness, smoothness,-snd.w - fst.w));\n}\n\nhighp vec4 opUnion(vec4 fst, vec4 snd) {\n    return mix(fst,snd,step(0., fst.w - snd.w));\n}\n// map: the distance from p to the closest point in the scene\nhighp vec4 map(highp vec3 p) {\n    vec3 center = vec3(0.5);\n    vec3 q = fract(p);\n    float radius = 0.2;\n    vec4 smallSphere = sphere(center + vec3(0.,0.,-1.2 * radius), radius, q);\n    return opUnion(\n        opSubtract (\n            sphere(center, radius, q),\n        \tsmallSphere,\n            0.04\n    \t),\n        opUnion(\n            sphere(center + vec3(radius/4., 0.05,-0.05), radius/4.,q),\n            sphere(center + vec3(-radius/4., 0.05,-0.05), radius/4.,q)\n        )\n    )\n        ;\n}\n\n\n\nlowp vec3 color(highp vec3 p) {\n    //vec3 q = mod(floor(p),5.);\n    //return clamp(q/10.0 + q.yzx / 20.0 + q/30.0 + q.zxy / 14.0,0.,1.);\n    vec3 q = mod(floor(p),3.);\n    //return vec3(0.00);\n    return clamp(q /2.0,0.,1.);\n}\n\n// o: origin, r: ray direction\nhighp vec4 trace(highp vec3 o, highp vec3 r) {\n\tfloat t = 1.;\n    vec3 norm = vec3(0.);\n    for (int i = 0; i < 256; i++ ) {\n        vec3 p = o + r * t;\n        vec4 normd = map(p);\n        norm = normd.xyz;\n        float d = normd.w;\n        if(abs(d)<.0001 || t>20.) break;        \n\n        t += d * 0.5;\n    }\n    return vec4(norm,t);\n}\n\nvec3 phongShading(vec3 position, vec3 normal, vec3 camera, vec3 light) {\n    // ambient light\n    vec3 ia = vec3(1,1,1);\n    vec3 id = vec3(1,1,1);\n    vec3 is = vec3(1,1,1);\n    //material\n    vec3 color = color(position);\n    vec2 txtCoord = vec2(\n        2.0 *atan(normal.x,normal.y)/ M_PI + 0.5,\n        3.0 *\n            acos(1.0 * normal.z) // -1 <> 0 <> 1 -> pi <> pi/2 <> 0\n            / M_PI);\n    float ka = 0.1;\n    float kd = 0.4 * (1.1 + 0.9 * texture(iChannel0,txtCoord).x);\n    float ks = 1.6 * (1.1 - texture(iChannel0,txtCoord).x);\n    float alpha = 30.;\n    \n    vec3 lightDir = normalize(light - position);\n    vec3 viewer = normalize(camera - position);\n    float dist = distance(camera, position);\n    // return vec3(1.0 - dist);\n    vec3 refl = normalize(2.0 * dot(lightDir, normal)  * normal - lightDir);\n    float normalDot = clamp(dot(lightDir,normal), 0., 1.);\n    float reflDot = pow(clamp(dot(refl,viewer), 0., 1.),alpha);\n\tvec3 col =\n        ka * ia * (color + vec3(0.1))/1.1 +\n        kd * normalDot * id * (color+vec3(0.05))/1.05 +\n        ks * step(0.,normalDot) * reflDot * is * (0.4  * color+vec3(1.6))/2.;\n    return col *step(dist, 20.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y * 2.;\n    //fragColor = vec4(1) * step(1.,length(uv));\n    \n    highp vec3 r = normalize(vec3(uv,2.));\n    float the = iTime * 0.2;\n    mat2 rot = mat2(cos(the), -sin(the), sin(the), cos(the));\n    r.yz*= rot * rot ;\n    r.xz*= rot;\n    vec3 o = vec3(0.,0.,iTime);\n    vec4 normt = trace(o,r);\n  \tfloat t = normt.w;\n    vec3 norm = normt.xyz;\n    vec3 lightPos = vec3(o.x,rot *o.yz );\n\tvec3 col = phongShading(\n        o + r * t,\n        norm,\n        o,\n        lightPos\n        );\n    \n    float sunlight = 1.001 * pow(clamp(dot(normalize(lightPos - o),r),0.,1.),55.);\n    col += (vec3(1) - col) * vec3(sunlight);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d33DS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d33Wn", "name": "Poincare Disk Circle Packing", "author": "skye_adaire", "description": "Click and drag to translate.\nThis is a circle packing in the Poincare Disk model of hyperbolic space. See my other shaders for more background.", "tags": ["circle", "disk", "packing", "hyperbolic", "poincare"], "likes": 16, "viewed": 366, "date": "1568144261", "time_retrieved": "2024-06-20T19:43:19.395760", "image_code": "//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexVector2 mat2x2\n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\nReal P_length(Complex p)\n{\n\tfloat n = length(p);\n \treturn log((1.0 + n) / (1.0 - n));\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = clip * 1.02;\n    vec2 z = p;\n    \n    if(length(z) > 1.0)\n    {\n     \tz = H_inverse(H_conjugate(z));   \n    }\n\n\t//translation vector, input or default\n    float time = 0.5 * iTime;\n    vec2 mouse = -(iMouse.xy / iResolution.xy - 0.5) * 5.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 def = 4.0 * vec2(cos(0.5*time), 0.1*sin(time));                        \n    vec2 v = iMouse.z > 0.0 ? mouse : def;\n    \n    //this transform moves us around \n    //transformation could also be done by complex matrix composition, just like view matrices in R3\n    //since this is a fully proceedural shader, I recompute the translation each frame\n    ComplexMatrix2 translation = M_translateDisk(v);\n    z = M_multiply(translation, z);\n\n    //these transforms comprise the fundamental domain of the tiling\n    ComplexMatrix2 transformFromA = identityMob;\n    ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n    float angleB = tau32 / 16.0;\n    Complex versorB = H_versor(angleB);\n    ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n    ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n    ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.8715), H_versor(0.8715));\n    ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n    vec3 distances;\n    z = getPoincareTiling(\n        transformFromA, transformToA,\n        transformFromB, transformToB,\n        transformFromC, transformToC,\n        z, distances);\n\n    float edge = 0.73;\n    float d = P_length(z);\n    float s = (1.0 - smoothstep(edge, edge + 0.03, d)) * 0.9 + 0.10;\n    vec3 color = hsv2rgb(vec3(d * 0.25 + 0.5, 1, 1));\n    color = mix(vec3(0.1), color, s);\n    color = mix(color, 1.0 - color, smoothstep(0.99, 1.01, length(p)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d33Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d33WX", "name": "tower of doom ", "author": "vjblind", "description": "tower of doom is cool name ? isnt it ? ", "tags": ["doom"], "likes": 7, "viewed": 253, "date": "1569344780", "time_retrieved": "2024-06-20T19:43:20.450472", "image_code": "//https://www.shadertoy.com/view/tstGD2\n///based on https://www.shadertoy.com/view/3l23Rh //\n\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\n\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;    \n   // p = p*m3;\n  //  p = sin(p.xyz*0.75 + iTime*.08);\n    f  = 0.5000 * noise(p); p =  p * 2.02;\n    f += 0.2500 * noise(p); p =  p * 2.03;\n    f += 0.1250 * noise(p); \n    f += 0.1250 * noise(p*30.);\n    return f;\n}\nfloat map5( in vec3 p )\n{    p.x = p.z+p.x;  \n p = sin(p.xyz*1.75 + iTime*.0);\n\tvec3 q = p - vec3(1.10,01.0,1.0)*iTime*0.4;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn  clamp(p.x* 1. - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\nfloat sphere(vec3 ro,vec3 p,float s)\n{\n//return length(ro-p)-s;\n      return  length(ro-p)  * -s + fbm(ro * 0.3);;\n} \n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\nfloat scene(in vec3 p)\n{ /*p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n   // p = sin(p.xyz*0.75 + iTime*.8);\n       p -= abs(dot(cos(p), sin(p.yzx)));*/\n   p = p*m3*0.01;\n  p.xy -= disp(p.z).xy;\n  // p +=p+0.0*p*.5*fbm(p * 0.01)*m3;// fbm(p * .3)*.0;\n\n\n    return  map5(  p );//length(p) * -0.00591+ fbm(p * .3);\n}\nvec2 map(vec3 ro){\nfloat res=0.0;\nfloat color=0.;\nres=  sphere(ro,vec3(0.0,1.0 ,0.0),20.5) ;\n \n\nif(res==sphere(ro,vec3(0.0,1.52 ,3.0),2.5))color=2.;\n \n\nreturn vec2(res,color);}\n\n\n\n\n\nvec4 march(vec3 ro,vec3 rd)\n{\nfloat d=0.0; //\nfloat material=0.;  \n    // Transmittance\n    float T = 1.0;\n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    vec4 color = vec4(0.0);\n   for (int i = 0; i < 64; i++)\n    {\n        // Using distance function for density.\n        // So the function not normal value.\n        // Please check it out on the function comment.\n        float d = scene(ro);\n        \n        // The density over 0.0 then start cloud ray marching.\n        // Why? because the function will return negative value normally.\n        // But if ray is into the cloud, the function will return positive value.\n        if (d > 0.0)\n        {\n            // Let's start cloud ray marching!\n           // d = abs(dot(cos(d*20.), sin(1.1-rd.z)));\n          //ro = ro*rd*m3;\n    \t\td/=0.51;\n            // why density sub by sampleCount?\n            // This mean integral for each sampling points.\n            float tmp = d / float(64);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            // Return if transmittance under 0.01. \n            // Because the ray is almost absorbed.\n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            \n            // Add ambient + light scattering color\n            float opaity = 8.0;\n            float k = opaity * tmp * T;\n            vec4 cloudColor = vec4(1.0);\n        cloudColor = vec4(sin(vec3(5.,0.4,0.2) +  +sin(d*0.4)*0.5 + 1.8)*1.5 + 0.5,0.08);\n  // cloudColor.xyz *= d*(vec3(0.005,.045,.075) + 1.5*vec3(0.33,0.07,0.03));\n     \n            vec4 col1 =((rd.y*.00083))*vec4(-1.51,10.,5.,0.10)+ cloudColor * k/2.;\n           col1=vec4(1.5,-1.,1.,10.)*col1.xyzw;\n            col1.xyz+=+col1.xyz*-m3*0.51;\n            \n            color += col1*15. ;\n        }\n        \n      ro += rd * 20.;\n    //    ro+= clamp(01.5 - d*d*.5, 0.9, -2.3);\n       \n    }\n    \n   \n            return 0.31+ color*color*.75;\n\n}\n\n\n\n\nvec4 render(vec3 ro,vec3 rd){\n\nreturn march(ro,rd);//+vec4(glowmarch(ro,rd).rgb,1.)+vec4(glowmarch1(ro,rd).rgb*glowmarch1(ro,rd).a,1);\n//march(ro,rd)*\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \nvec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n      // Camera\n    float camDist = 25.0;\n    \n    // target\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Ray origin\n    //vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), 0.7 - 1.0 * (mo.y - 1.0), sin(2.75 - 3.0 * mo.x)));\n     \n    // Ray origin. oving along the Z-axis.\n  ro = vec3(1,1500.,-1200.+iTime*250.);\n \n    \n  \n    // Output to screen\n   vec4  res=render(ro,rd)*render(ro,rd);\n    \n  \n    // res+=vec4(0.5,-res.x*1.5,res.z*30,0.5);\n    fragColor = vec4 (res.rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d33WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d33zs", "name": "Shader Showdown Nova-19 Final", "author": "evvvvil", "description": "Winning shader made at NOVA 2019 Shader Showdown. Final round against psonice / CRTC ^ UKScene Allstars ^ Church of the Spinning Cube.\nLive coded on stage in 25 minutes.\nhttps://www.youtube.com/watch?v=leD1bIsBMRg", "tags": ["demoscene", "glow", "robot", "laser", "live", "neon", "battle", "lazer", "shadershowdown", "nova", "industrial", "faces", "gargoyle"], "likes": 35, "viewed": 4684, "date": "1569080950", "time_retrieved": "2024-06-20T19:43:20.977570", "image_code": "// Winning shader made at Nova 2019 Shader Showdown,\n// Final round against psonice / CRTC ^ UKScene Allstars ^ Church of the Spinning Cube\n// Video of the battle: https://www.youtube.com/watch?v=leD1bIsBMRg\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"I'm so unlucky at the moment that if I fell in a barrel of boobs I'd come out sucking my thumb\" Ian Holloway (comical genius and football manager)\n\nvec2 s,e=vec2(.000035,-.000035);float t,tt,b,bb,bs,g,bro;vec3 np,bp,pp;\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}\nfloat cz(vec3 p,float r){p.z=0.;return length(p)-r;}\nvec2 fb( vec3 p,float s)\n{\n    p.xy*=r2(bs*1.4*s/5.);\n  vec2 h,t=vec2(bo(p,vec3(10,.6,.8)),5.+s);\n  h=vec2(bo(abs(p)-vec3(2,0,0),vec3(1.2,.8,1.2)),3.+s);\n  h.x=min(bo(abs(abs(p)-vec3(0,.6,.6))-vec3(0,.3,.3),vec3(3,.1,.1)),h.x);\n  t=(t.x<h.x)?t:h; return vec2(t.x*.5,t.y); \n}\nvec2 mp( vec3 p)\n{\n  b=sin(p.z-tt*10.)*0.1;\n  bp=pp=p;\n  pp.xz*=r2(.785*2.*bb);    \n  np=pp;\n  bro=(0.5-b*2.)*(1.-bs);\n  for(int i=0;i<6;i++){\n    np=abs(np)-mix(vec3(1.2+bro*.5,2.1,-.1),vec3(bro*.5,3,1.7),bb);  \n    np.yz*=r2(.785*float(i));\n    np.xz*=r2(.785*float(i)*.49-bro*.15);\n    np-=.3*sin(p.y)*1.5;\n      \n    bp=abs(bp)-vec3(2,0.7,1.1);    \n    bp.yz*=r2(.785*float(i));\n    bp.xz*=r2(.785*float(i)*.5);\n    bp-=.3*sin(p.y)*1.5;      \n  }\n  vec2 h,t=fb(np,0.);\n  bp.xz*=r2(1.4);bp=abs(bp*0.7)-4.5;\n  h=fb(bp,5.);\n  h.x*=1.5;\n  t=(t.x<h.x)?t:h;\n  h=vec2(length(abs(pp-vec3(0,4.-bb,0))-vec3(3.+bro*3.,0,3.-bb))-2.5+bb,6);\n  h.x=min(length(p-vec3(0,-3,0))-5.,h.x)*.7;\n  \n  h.x=min(cz(p+vec3(0,2.2,0),p.z>-21.?bro:0.),h.x);\n  g+=0.1/(0.1+h.x*h.x*20.);\n  t=(t.x<h.x)?t:h;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(0.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>50.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>50.) t.x=0.;\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv -= 0.5;uv/=vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,62.83);\n  \tbs=(0.4+clamp(sin(tt*2.),-0.4,0.4))*1.25;\n    bb=(0.25+clamp(sin(tt),-0.25,0.25))*2.;\n  \n    vec3 ro=vec3(cos(tt*0.5)*15.,sin(tt*0.5)*15.,-20.+cos(tt)*5.),\n    cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),\n    co,fo,ld=normalize(vec3(0,0.5,-0.5));\n    co=fo=vec3(.04)*(1.-(length(uv)-.2));\n    s=tr(ro,rd);t=s.x;\t\n    if(t>0.){\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n        al=vec3(1,0.05,0);\n        float dif=max(0.,dot(no,ld)),\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),\n        fr=pow(1.+dot(no,rd),4.),\n        spo=exp2(7.*texture(iChannel0,vec2(np.y,dot(np.xz,vec2(.7)))/vec2(16,20)).r);\n        if(s.y<5.) al=vec3(0);\n        if(s.y>5.) al=vec3(1);\n        if(s.y>7.) {al=vec3(0.1,0.5,0.9);spo=exp2(7.*texture(iChannel0,vec2(bp.y,dot(bp.xz,vec2(.7)))/vec2(10,16)).r);}\n        if(s.y>9.) {al=vec3(0);}\n        if(s.y>10.) {al=vec3(1);}\n        \n        vec3 sss=vec3(1.5)*smoothstep(0.,1.,mp(po+ld*0.4).x/0.4),\n        sp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp+al*(.8*ao+0.2)*(dif+sss),fo,fr);\n        co=mix(co,fo,1.-exp(-.00004*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.3*vec3(.2,.3,.6),vec3(.45)),1);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d33zs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d3GRf", "name": "Clockwork Dreams", "author": "bartofzo", "description": "WIP", "tags": ["wip"], "likes": 6, "viewed": 144, "date": "1568929778", "time_retrieved": "2024-06-20T19:43:21.377964", "image_code": "const float PI = 3.145;\nconst float TWO_PI = 2. * PI;\nconst float HALF_PI = 0.5 * PI;\n\nvec2 rotate(vec2 uv, vec2 center, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n   \n    uv -= center;\n    uv *= mat2(c, -s, s, c); \n \n\treturn uv + center;\n}\n\nvec3 gear(vec2 uv, \n          vec2 gearPos, \n          float tooths,\n          float speed)\n{\n    vec2 delta = uv - gearPos;\n\n    float d = length(delta); \n    float angle = speed * iTime + atan(delta.y, delta.x);\n    float toothMul = floor(mod(.5 * tooths * angle, PI) / HALF_PI);\n    float radius = .5 * tooths;\n    float inside = min(1., .5 * d / radius);\n    float shine = radius / (d - .1*radius);\n    inside = smoothstep(.2449, 0.25, inside);\n    \n    float gearDepth = 1.5 / tooths;\n    \n    radius *= (1. - .5*gearDepth) + \n        (gearDepth * toothMul);\n   \t\n    float g = smoothstep(radius, radius - 0.0001, d);\n    \n    \n    return (.5 + .5*shine)* g * vec3(inside, inside, inside);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\t\n    vec3 col = vec3(0.);\n    float count = 50.;\n    float scaleFactor = .9;\n    float speed = -6.;\n    float timeScale = (.5+.5*sin(.5*iTime));\n    float rotFactor = .2 + .1 * (1. + cos(.14*iTime + 10.));\n    float uvScale = 2048. * timeScale;\n    \n    uv *= 32. + uvScale;\n\n\tfor (float i = 0.; i < count; i++)\n    {\n        float scale = (1. + 0.1 * i);\n        \n        vec3 thisCol = vec3(0.);\n\n        thisCol = gear(uv, vec2(0., 0.), 16., speed * 1.);\n        thisCol += gear(uv, vec2(12., 0.), 8., speed * -2.);\n        thisCol *= .15 + .7 * vec3(mod(i, 2.) / 2., mod(i, 3.) / 3., mod(i, 4.) / 4.);\n\n        uv = rotate(uv, vec2(0.), rotFactor * PI);\n        uv *= scaleFactor;\n        uv += vec2(12.,0);\n        \n        col += .75 * (1. - (i/count)) * thisCol;\n        speed *= -scaleFactor; // slows down & flips direction every iteration\n    }\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3GRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d3GWl", "name": "Piet Mondrian ~ pBakshi", "author": "pbakshi", "description": "Piet Mondrian made with lots of rectangles", "tags": ["pietmondrian", "reproduction"], "likes": 3, "viewed": 120, "date": "1569450973", "time_retrieved": "2024-06-20T19:43:21.383916", "image_code": "#define S(a, b, c) smoothstep(a, b, c)\n#define PI 3.14159\n\nfloat sdfBand(float pt, float l, float r, float blur) {\n\treturn S(l - blur, l, pt) - S(r, r + blur, pt);\n}\n\nfloat sdfCircle(vec2 uv, vec2 cd, float r, float blur) {\n    vec2 uc = uv-cd;\n\tfloat d = dot(uc, uc);\n    float r2 = r*r;\n    return smoothstep(r2 + blur, r2 - blur, d);\n}\n\nfloat sdfBox(vec2 uv, vec2 bl, vec2 tr, float blur) {\n\treturn sdfBand(uv.x, bl.x, tr.x, blur) * sdfBand(uv.y, bl.y, tr.y, blur);\n}\n\n\nvec4 Lines(vec2 uv) {\n    vec3 bg = vec3(0.964706, 0.972549, 0.968627);\n   \tvec3 grey = vec3(0.843137, 0.870588, 0.843137);\n\tvec3 yellow = vec3(1.0, 0.831373, 0.0235294);\n    vec3 red = vec3(0.72549, 0.054902, 0.0235294);\n    vec3 blue = vec3(0.0666667, 0.172549, 0.592157);\n\n    vec4 col = vec4(bg, 1.0);\n    \n    //horizontal lines\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.y, 0.0, 0.05, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.y, 0.15, 0.2, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.y, 0.5, 0.55, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.y, 0.7, 0.75, 0.001));\n    \n    //vertical lines\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.x, 0.07, 0.1, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.x, 0.17, 0.2, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.x, 0.35, 0.38, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.x, 0.7, 0.73, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBand(uv.x, 0.96, 0.99, 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.02, 0.75), vec2(0.05, 1.0), 0.001));\n\tcol.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.75, 0.75), vec2(0.78, 1.0), 0.001));    \n\tcol.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.75, 0.0), vec2(0.78, 0.5), 0.001));  \n \tcol.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.8, 0.0), vec2(0.83, 0.5), 0.001));   \n    \n    //boxes\n   \tcol.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.02, 0.95), vec2(0.05, 1.0), 0.001));\n\tcol.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.02, 0.75), vec2(0.05, 0.8), 0.001));    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.02, 0.7), vec2(0.05, 0.75), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.02, 0.5), vec2(0.05, 0.55), 0.001));\n\t\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.05, 0.5), vec2(0.07, 0.55), 0.001));\n\tcol.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.04, 0.15), vec2(0.07, 0.2), 0.001));\n\tcol.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.04, 0.0), vec2(0.07, 0.05), 0.001));\n\n\tcol.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.07, 0.7), vec2(0.1, 0.75), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.07, 0.5), vec2(0.1, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.07, 0.3), vec2(0.1, 0.35), 0.001));    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.07, 0.2), vec2(0.1, 0.25), 0.001));    \n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.07, 0.15), vec2(0.1, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.07, 0.0), vec2(0.1, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.17, 0.95), vec2(0.2, 1.0), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.17, 0.8), vec2(0.2, 0.95), 0.001));    \n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.17, 0.75), vec2(0.2, 0.8), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.17, 0.7), vec2(0.2, 0.75), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.17, 0.65), vec2(0.2, 0.7), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.17, 0.55), vec2(0.2, 0.65), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.17, 0.5), vec2(0.2, 0.55), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.17, 0.27), vec2(0.2, 0.32), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.17, 0.15), vec2(0.2, 0.2), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.17, 0.0), vec2(0.2, 0.05), 0.001));\n    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.2, 0.7), vec2(0.23, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.2, 0.5), vec2(0.23, 0.55), 0.001));\n\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.2, 0.8), vec2(0.35, 1.0), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.25, 0.85), vec2(0.31, 0.95), 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.23, 0.5), vec2(0.32, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.255, 0.59), vec2(0.29, 0.66), 0.001));    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.2, 0.2), vec2(0.35, 0.4), 0.001));    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.28, 0.0), vec2(0.32, 0.05), 0.001));\n    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.32, 0.7), vec2(0.35, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.32, 0.5), vec2(0.35, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.35, 0.95), vec2(0.38, 1.0), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.35, 0.88), vec2(0.38, 0.93), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.35, 0.7), vec2(0.38, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.35, 0.65), vec2(0.38, 0.7), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.35, 0.5), vec2(0.38, 0.55), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.35, 0.45), vec2(0.38, 0.5), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.35, 0.35), vec2(0.38, 0.4), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.35, 0.2), vec2(0.38, 0.25), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.35, 0.15), vec2(0.38, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.35, 0.0), vec2(0.38, 0.05), 0.001));\n    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.41, 0.7), vec2(0.44, 0.75), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.45, 0.5), vec2(0.48, 0.55), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.41, 0.15), vec2(0.44, 0.2), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.43, 0.0), vec2(0.46, 0.05), 0.001));\n    \n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.52, 0.7), vec2(0.55, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.48, 0.5), vec2(0.55, 0.55), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.45, 0.2), vec2(0.55, 0.5), 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.45, 0.45), vec2(0.55, 0.5), 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.47, 0.28), vec2(0.53, 0.37), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.53, 0.15), vec2(0.56, 0.2), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.54, 0.0), vec2(0.57, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.56, 0.7), vec2(0.58, 0.75), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.56, 0.5), vec2(0.58, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.57, 0.15), vec2(0.59, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.58, 0.0), vec2(0.6, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.58, 0.2), vec2(0.66, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.58, 0.5), vec2(0.66, 0.55), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.58, 0.3), vec2(0.66, 0.45), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.59, 0.15), vec2(0.65, 0.2), 0.001));\n\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.66, 0.7), vec2(0.68, 0.75), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.66, 0.5), vec2(0.68, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.65, 0.15), vec2(0.67, 0.2), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.66, 0.0), vec2(0.68, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.7, 0.99), vec2(0.73, 1.0), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.7, 0.8), vec2(0.73, 0.85), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.7, 0.7), vec2(0.73, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.7, 0.68), vec2(0.73, 0.7), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.7, 0.63), vec2(0.73, 0.68), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.7, 0.5), vec2(0.73, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.7, 0.35), vec2(0.73, 0.4), 0.001));    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.7, 0.15), vec2(0.73, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.7, 0.05), vec2(0.73, 0.1), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.7, 0.0), vec2(0.73, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.75, 0.98), vec2(0.78, 1.0), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.75, 0.8), vec2(0.78, 0.85), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.75, 0.7), vec2(0.78, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.75, 0.5), vec2(0.78, 0.55), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.75, 0.35), vec2(0.78, 0.4), 0.001));    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.75, 0.2), vec2(0.78, 0.25), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.75, 0.15), vec2(0.78, 0.2), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.75, 0.0), vec2(0.78, 0.05), 0.001));\n\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.78, 0.5), vec2(0.82, 0.55), 0.001));\n\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.82, 0.7), vec2(0.85, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.8, 0.5), vec2(0.83, 0.55), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.8, 0.35), vec2(0.83, 0.4), 0.001));    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.8, 0.15), vec2(0.83, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.8, 0.05), vec2(0.83, 0.1), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.8, 0.0), vec2(0.83, 0.05), 0.001));\n    \n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.83, 0.85), vec2(0.91, 1.0), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.83, 0.75), vec2(0.91, 0.85), 0.001));\n    col.rgb = mix(col.rgb, yellow.rgb, sdfBox(uv, vec2(0.845, 0.92), vec2(0.9, 1.0), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.9, 0.7), vec2(0.93, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.84, 0.5), vec2(0.87, 0.55), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.91, 0.5), vec2(0.94, 0.55), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.85, 0.2), vec2(0.93, 0.5), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.87, 0.32), vec2(0.91, 0.4), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.85, 0.15), vec2(0.88, 0.2), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.88, 0.15), vec2(0.92, 0.2), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.92, 0.15), vec2(0.95, 0.2), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.85, 0.11), vec2(0.93, 0.15), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.85, 0.05), vec2(0.93, 0.11), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.86, 0.0), vec2(0.89, 0.05), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.92, 0.0), vec2(0.95, 0.05), 0.001));\n    \n    \n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.96, 0.9), vec2(0.99, 0.95), 0.001));    \n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.96, 0.85), vec2(0.99, 0.9), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.96, 0.7), vec2(0.99, 0.75), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.96, 0.55), vec2(0.99, 0.6), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.96, 0.5), vec2(0.99, 0.55), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.96, 0.32), vec2(0.99, 0.37), 0.001));\n    col.rgb = mix(col.rgb, red.rgb, sdfBox(uv, vec2(0.96, 0.15), vec2(0.99, 0.2), 0.001));\n    col.rgb = mix(col.rgb, grey.rgb, sdfBox(uv, vec2(0.96, 0.05), vec2(0.99, 0.1), 0.001));\n    col.rgb = mix(col.rgb, blue.rgb, sdfBox(uv, vec2(0.96, 0.0), vec2(0.99, 0.05), 0.001));\n    \n    return col;\n}\n\nvec4 pmPainting(vec2 uv) {\n    vec3 bg = vec3(0.964706, 0.972549, 0.968627);\n    \n    vec4 col = vec4(bg, 1.0);\n    \n    uv.y += sin(iTime)*0.1;\n    uv.x += cos(iTime - PI/3.0)*0.1;\n    vec4 lines = Lines(uv);\n    \n    col.rgb = mix(col.rgb, lines.rgb, lines.a);\n    \n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R;\n\n\n    vec4 col = pmPainting(uv);\n\n\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d3GWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dc3Wr", "name": "[phreax] strudel", "author": "phreax", "description": "old school spiral effect", "tags": ["tunnel", "spiral"], "likes": 14, "viewed": 292, "date": "1568210646", "time_retrieved": "2024-06-20T19:43:21.608298", "image_code": "#define rot(x) mat2(cos(x), sin(x), -sin(x), cos(x))\n\n// set to true for a \"fly through effect\"\n#define ROT_CAM true\n\n// bend tunnel\n#define BEND .8        \n\nfloat spiral(vec2 uv, float i) {  \n    uv *= rot(i*3.14-.4*iTime);\n    uv += .03*sin(vec2(40, 70)*uv.yx);\n\n\tfloat d = length(uv);\n    return smoothstep(1., -1., abs(d-.12)/fwidth(d)-.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float col = 0.;\n\t\n    for(float i=.02; i<=1.; i+=.02) {   \n        float z = fract(i-.1*iTime);\n        float fade = smoothstep(1., .8, z);\n        vec2 UV = uv;\n        if(ROT_CAM) {   \n       \t UV += sin(vec2(.3, .6)*iTime+z*BEND)*.3;\n        }\n        col += spiral(UV*z, i)*(.5/z)*fade;\n    }\n    \n    col = sqrt(col);\n\n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dc3Wr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dcGWM", "name": "Rainbow Truchet", "author": "Jordan", "description": "Hardcoded parallax truchet effect, with time-shifted color channels.\nPrevious parallax Truchet: \nhttps://www.shadertoy.com/view/3ddGW7\nhttps://www.shadertoy.com/view/3scGWM", "tags": ["parallax", "truchet", "chromatic", "aberration", "channels", "shifted", "cineshader"], "likes": 5, "viewed": 967, "date": "1568810758", "time_retrieved": "2024-06-20T19:43:21.608298", "image_code": "\nfloat rand(vec2 p)\n{\n    p = fract(p*vec2(234.51,124.89));\n    p += dot(p,p+54.23);\n    return fract(p.x);\n}\n\nfloat width = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int i;\n    for(i=0;i<3;i+=1) // Loop over time-shifted color channels\n    {\n        float t = iTime + 0.1*float(i);\n        vec2 pos = 5.*vec2(sin(t*0.2)+0.1*t,cos(t*0.2)+0.1*t);\n        vec3 col = 0.1 + 0.3*cos(t+(fragCoord/iResolution.xy).xyx+vec3(0,2,4));\n\n        vec2 uv1 = pos+(5.*(fragCoord-.5*iResolution.xy)/iResolution.y);\n        vec2 gv1 = (fract(uv1)-0.5);\n        vec2 id1 = floor(uv1);\n        vec2 uv2 = pos+2.5*(fragCoord-.5*iResolution.xy)/iResolution.y;\n        vec2 gv2 = (fract(uv2)-0.5);\n        vec2 id2 = floor(uv2);\n\n        gv1.x *= (float(rand(id1)>0.5)-0.5)*2.;\n        gv2.x *= (float(rand(id2+3.)>0.5)-0.5)*2.;\n\n        float mask1 = smoothstep(-0.2,0.2,width-abs(gv1.x+gv1.y-0.5*sign(gv1.x+gv1.y+0.01)));\n        float mask2 = smoothstep(-0.2,0.2,width*2.-abs(gv2.x+gv2.y-0.5*sign(gv2.x+gv2.y+0.01)));\n\n        col += mask1;\n        col += mask2;\n        fragColor[i] = col[i];\n    }\n    fragColor *= 0.5*dot(fragColor.xyz,fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dcGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dd3RX", "name": "first shader, wow", "author": "Newbobplus", "description": "wow", "tags": ["wow"], "likes": 0, "viewed": 63, "date": "1568986454", "time_retrieved": "2024-06-20T19:43:21.608298", "image_code": "float circle(float radius, float blur, float dist){\n    return smoothstep(radius + blur, radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float value;\n    float l = length(uv);\n    float radius = .1;\n    float blur = .04;\n   \tvec3 centerCircle = vec3(circle(radius, blur, l));\n    \n    vec3 color = vec3(0.);\n    float shake = .03;\n    float speed = 8.;\n    float offset = .05;\n    vec2 secUv = uv + vec2(sin(iTime * speed), cos(iTime * speed)) * shake;\n    l = length(secUv);\n    color.r += circle(radius, blur, l);\n    secUv = uv + vec2(sin((iTime + offset) * speed), cos((iTime + offset) * speed)) * shake;\n    l = length(secUv);\n    color.b += circle(radius, blur, l);\n    color -= centerCircle;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dd3RX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dd3WB", "name": "Energy Lab", "author": "kaneta", "description": "Reflection is very noisy when without AA :(", "tags": ["3d", "raymarch"], "likes": 17, "viewed": 713, "date": "1569236009", "time_retrieved": "2024-06-20T19:43:21.608298", "image_code": "#define AA 1\n\n#define FLT_EPS  5.960464478e-8\n\n#define MAT_FLOOR 0.\n#define MAT_PIPE 1.\n#define MAT_CAGE 2.\n#define MAT_BALL 3.\n#define MAT_LIGHT 4.\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi * 2.0;\nfloat time;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n)*n;\n    return p * rot(a);\n}\n\n// by http://mercury.sexy/hg_sdf/\nfloat fOpDifferenceRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r - b), vec2(0));\n\treturn min(-r, max (a, -b)) + length(u);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// by https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n\tp.y = abs(p.y) - h;\n    return max(d, p.y);\n}\n\nfloat torus(vec3 p, float r, float s) {\n\tvec2 q = vec2(length(p.xz) - s, p.y);\n    return length(q) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 lightTube(vec3 p, float r) {\n    p.xz *= rot(pi * 0.2);\n\tp.xz = pmod(p.xz, 5.0);\n    //p.z -= 5.1;\n    float a = pi * 0.1;\n\tfloat s1 = sdCappedTorus(p, vec2(sin(a), cos(a)), 8.05, 0.1);\n    return vec2(s1, MAT_LIGHT);\n}\n\nvec2 cage(vec3 p) {\n    p.y += sin(time) * 0.1;\n    p.xy *= rot(-pi*0.5);\n    p.yz *= rot(time * 0.5);\n    p.yz = pmod(p.yz, 7.0);\n    p.yx = pmod(p.yx, 7.0);\n    \n\treturn vec2(torus(p, 0.025, 0.55), MAT_CAGE);\n}\n\nvec2 object(vec3 p) {\n    vec2 s = vec2(sphere(p - vec3(0.0, cos(time) * 0.1, 0.0), 0.25), MAT_BALL);\n    vec2 c = cage(p);\n\treturn min2(s, c);\n}\n\nfloat energyAnim(float z) {\n\tfloat et = mod(z + time, pi2);\n    float etOffset = pi * 1.5;\n    return (smoothstep(etOffset - 0.2, etOffset, et) - smoothstep(etOffset + 0.2, etOffset + 0.4, et));\n}\n\nvec2 room(vec3 p) {\n    p.y = -abs(p.y);\n    // Floor\n    vec2 tile = fract(p.xz * 8.0) * 2.0 - 1.0;\n    tile = abs(tile) - 0.5;\n    float dd = max(max(tile.x, tile.y), 0.0);\n    \n    float flor = fOpDifferenceStairs(p.y, cylinder(p, 8.0, 4.0), 4.0, 15.);\n    flor = fOpUnionStairs(flor, cylinder(p - vec3(0.0, -4.0, 0.0), 1.0, 1.0), 1.0, 5.);\n    \n    // Pipe\n    p.xz = pmod(p.xz, 5.0);\n    float pipeDent = (smoothstep(0.4, 0.5, fract(p.z*10.0)) - smoothstep(0.5, 0.6, fract(p.z*10.0)));\n\n    float energy = energyAnim(p.z);\n    float pipe = fOpPipe(flor - 0.05, abs(p.x + sin(p.z*2.0) * 0.1), 0.07) + pipeDent * 0.01 - energy * 0.05;\n    \n    // Floor dent along the pipe\n    flor = fOpDifferenceRound(flor + dd * 0.02, pipe, 0.1);\n    \n    return min2(vec2(flor * 0.9, MAT_FLOOR), vec2(pipe * 0.9, MAT_PIPE));\n}\n\nvec2 map(vec3 p) {\n    //p.x += sin(p.x * 5.0) * 0.1;\n\tvec2 o = object(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    d = min2(d, lightTube(p - vec3(0.0, -3.85, 0.0), 5.0));\n    p.xz *= rot(time * 2.0);\n    d = min2(d, lightTube(p - vec3(0.0, 0.0, 0.0), 6.0));\n    \n    return d;\n}\n\nvec2 shadowMap(vec3 p) {\n    //p.x += sin(p.x * 5.0) * 0.1;\n\tvec2 o = cage(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    return d;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1.0, -1.0) * 0.00005;\n    return normalize(\n        e.xyy * map(p+e.xyy).x+\n        e.yxy * map(p+e.yxy).x+\n        e.yyx * map(p+e.yyx).x+\n        e.xxx * map(p+e.xxx).x\n        );\n}\n\nvec3 normal2(vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat shadow(vec3 p, vec3 ray, float ma) {\n    float t = 0.1;\n    float res = 1.0;\n    for(int i = 0; i < 24; i++) {\n        if (t > ma) break;\n        vec3 pos = p + ray * t;\n        float d = shadowMap(pos).x;\n        if (d < 0.0001) return 0.0;\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    return res;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 origin;\n\nfloat roughnessToExponent(float roughness)\n{\n    return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS);\n}\n\nvec3 light(vec3 p, vec3 n, vec3 v, vec3 lp, vec3 baseColor, float roughness, float reflectance, float metallic, vec3 radiance) {\n    vec3 ref = mix(vec3(reflectance), baseColor, metallic);\n\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n    \n    vec3 h = normalize(l + v);\n    \n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / pi;\n    \n    float m = roughnessToExponent(roughness);\n\tvec3 specular = ref * pow( max( 0.0, dot( n, h ) ), m ) * ( m + 2.0 ) / ( 8.0*pi );\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len*len);\n}\n\nvec3 evalLights(vec3 p, vec3 n, vec3 ray, vec3 baseColor, float roughness, float reflectance, float metallic) {\n    // Object Light\n    vec3 lp = vec3(0.0, -2.0 + cos(time) * 0.1, 0.0);\n    vec3 v = lp - p;\n    float len = length(v);\n    v /= len;\n    vec3 result = light(p, n, -ray, lp, baseColor, roughness, reflectance, metallic, vec3(0.6, 0.05, 0.01) * (sin(time) * 0.5 + 0.5) * 20.0) * shadow(p + n * 0.005, v, len);\n    \n    // Camera Light\n    result += light(p, n, -ray, origin, baseColor, roughness, reflectance, metallic, vec3(3.0));\n    return result;\n}\n\nvoid getSurfaceParams(vec3 p, vec2 mat, out vec3 outBaseColor, out vec3 outEmission, out float outRoughness, out float outReflectance, out float outMetallic) {\n    outBaseColor = vec3(0.0);\n    outEmission = vec3(0.0);\n    outRoughness = 1.0;\n    outMetallic = 0.0;\n    outReflectance = 0.04;\n    if (mat.y == MAT_FLOOR) {\n        outBaseColor = vec3(0.5);\n        outRoughness = 0.05;\n    } else if (mat.y == MAT_PIPE) {\n        outBaseColor = vec3(0.9);\n        outRoughness = 0.15;\n        outMetallic = 1.0;\n    \tp.xz = pmod(p.xz, 5.0);\n    \tfloat pipeDent = (smoothstep(0.4, 0.5, fract(p.z*10.0)) - smoothstep(0.5, 0.6, fract(p.z*10.0)));\n    \tfloat energy = energyAnim(p.z);\n        outEmission = mix(vec3(0.6, 0.05, 0.01), vec3(0.01, 0.05, 0.6), clamp(p.z * 0.2, 0.0, 1.0)) * 4.0 * energy * (1.0 - pipeDent);\n    } else if (mat.y == MAT_CAGE) {\n        outBaseColor = vec3(1.000, 0.766, 0.336);\n        outRoughness = 0.15;\n        outMetallic = 1.0;\n    } else if (mat.y == MAT_BALL) {\n        outBaseColor = vec3(0.6);\n        outEmission = vec3(0.6, 0.05, 0.01) * 4.0 * (sin(time) * 0.5 + 0.5);\n        outRoughness = 0.2;\n        outReflectance = 0.0;\n    } else if (mat.y == MAT_LIGHT) {\n        outBaseColor = vec3(0.6);\n        outEmission = vec3(4.0);\n        outRoughness = 0.2;\n        outReflectance = 0.0;\n    }\n}\n\nvoid trace(vec3 p, vec3 ray, float tmax, int ite, out vec3 outPos, out vec2 outMat, out float depth) {\n    float t = 0.1;\n    vec3 result = vec3(0.0), pos;\n    vec2 mat;\n    for(int i = 0; i < ite; i++) {\n        if (t > tmax) break;\n        pos = ray * t + p;\n        mat = map(pos);\n        if (mat.x < 0.0001) break;\n        t += mat.x;\n    }\n    depth = t;\n    outPos = pos;\n    outMat = mat;\n}\n\nvec3 shade(vec3 p, vec3 ray, vec2 mat) {\n    vec3 baseColor, emission;\n    float roughness, metallic, reflectance;\n    \n    getSurfaceParams(p, mat, baseColor, emission, roughness, reflectance, metallic);\n    vec3 n = normal(p);\n    \n    vec3 result = evalLights(p, n, ray, baseColor, roughness, reflectance, metallic) + emission;\n    vec3 f0 = vec3(1.0);\n    for(int i=0; i<1; i++) {\n    \tf0 *= mix(vec3(reflectance), baseColor, metallic);\n        vec3 secondPos;\n        vec2 secondMat;\n        float depth;\n        ray = reflect(ray, n);\n        trace(p + n * 0.001, ray, 100.0, 24, secondPos, secondMat, depth);\n        getSurfaceParams(p, secondMat, baseColor, emission, roughness, reflectance, metallic);\n        n = normal(secondPos);\n        p = secondPos;\n        result += (evalLights(secondPos, n, ray, baseColor, roughness, reflectance, metallic) + emission) * f0;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n    int aa = AA;\n    float tt = 0.0;\n    float depth;\n    for(int y=0; y<aa; y++) {\n        vec2 fc;\n        fc.y = fragCoord.y + float(y)/float(aa);\n        for(int x=0; x<aa; x++) {\n            fc.x = fragCoord.x + float(x)/float(aa);\n            p = (fc.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n            time = iTime + tt;\n            origin = vec3(sin(time * 0.1)*1.0 + cos(time * 0.5)*0.5, sin(time * 0.3) * 1.0 + cos(time * 1.0)*0.25 + sin(time * 3.0)*0.1 - 1.0, 5.0);\n            vec3 target = vec3(0.0, -2., 0.);\n            vec3 fo = normalize(target - origin);\n            vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));\n            vec3 up = normalize(cross(fo, si));\n            vec3 ray = normalize(fo * (2.5 + (sin(time * 0.5)*0.5 + 0.5)*2.0 + (1.0 - dot(p, p)) * 0.05) + si * p.x + up * p.y);\n\n            tt += 0.04 / float(aa*aa);\n            vec3 surfacePos;\n            vec2 surfaceMat;\n            trace(origin, ray, 100.0, 99, surfacePos, surfaceMat, depth);\n            col += acesFilm(shade(surfacePos, ray, surfaceMat) * 2.0);\n        }\n    }\n    col /= float(aa*aa);\n\n    col = pow(col, vec3(1.0/2.2));\n    \n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n\n    fragColor = vec4(col * vig,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dd3WB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dd3WH", "name": "Barycentric coords on polygons", "author": "kig", "description": "Implementation of \"Generalized Barycentric Coordinates on Irregular Polygons\" by Meyer et al. http://geometry.caltech.edu/pubs/MHBD02.pdf\n\nTo calculate the weights for a point wrt polygon corners.", "tags": ["math", "polygon", "coordinates"], "likes": 6, "viewed": 383, "date": "1568390879", "time_retrieved": "2024-06-20T19:43:22.117223", "image_code": "/*\nGeneralized Barycentric Coordinates on Irregular Polygons\n\nhttp://geometry.caltech.edu/pubs/MHBD02.pdf\n*/\n\n#define N 4\n\nfloat cross2d(vec3 a, vec3 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool rayIntersectsLineSegment(vec3 rayOrigin, vec3 rayDirection, vec3 point1, vec3 point2) {\n    vec3 v1 = rayOrigin - point1;\n    vec3 v2 = point2 - point1;\n    vec3 v3 = vec3(-rayDirection.y, rayDirection.x, 0.0);\n\n    float d = dot(v2, v3);\n    if (abs(d) < 0.000001)\n        return false;\n\n    float t1 = cross2d(v2, v1) / d;\n    float t2 = dot(v1, v3) / d;\n\n    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0))\n        return true;\n\n    return false;\n}\n\nbool insidePolygon(vec3 p, vec3[N] points) {\n\tint intersections = 0;    \n    vec3 d = vec3(1.0, 0.0, 0.0);\n    for (int i = 0; i < N; i++) {\n        if (rayIntersectsLineSegment(p, d, points[i], points[(i+1) % N])) {\n            intersections++;\n        }\n    }\n    return intersections % 2 == 1;\n}\n\nfloat cotangent(vec3 a, vec3 b, vec3 c) {\n    vec3 ba = a - b;\n    vec3 bc = c - b;\n    return dot(bc, ba) / length(cross(bc, ba));\n}\n\nvoid computeBarycentric(vec3 p, vec3[N] points, out float[N] weights) {\n    float weightSum = 0.0;\n    for (int i = 0; i < N; i++) {\n        int prev = (i + N - 1) % N;\n        int next = (i + 1) % N;\n        vec3 pd = p - points[i];\n        float wf = (cotangent(p, points[i], points[prev]) + cotangent(p, points[i], points[next])) / dot(pd, pd);\n        weightSum += wf;\n        weights[i] = wf;\n    }\n    for (int i = 0; i < N; i++) {\n        weights[i] /= weightSum;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3[N] points;\n    points[0] = vec3(-0.2+0.2*cos(1.0*iTime), -0.2, 0.0);\n    points[1] = vec3(0.2, -0.2, 0.0);\n    points[2] = vec3(0.2, 0.2+0.2*sin(2.0*iTime), 0.0);\n    points[3] = vec3(-0.2, 0.2, 0.0);\n    \n    mat3 rot = mat3(cos(iTime), sin(iTime), 0, -sin(iTime), cos(iTime), 0, 0, 0, 1.0);\n    for (int i = 0; i < N; i++) {\n        points[i] = (2.75 + 0.5*sin(iTime)) * (rot * points[i]);\n    }\n    \n    float[N] weights;\n\n    vec2 uv = (2.0 * fragCoord/iResolution.xy - 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(1.0);\n\n    computeBarycentric(vec3(uv, 0.0), points, weights);\n        \n    if (insidePolygon(vec3(uv, 0.0), points)) {\n        vec2 texCoord = vec2(\n            vec2(0.0, 0.0) * weights[0] +\n            vec2(1.0, 0.0) * weights[1] +\n            vec2(1.0, 1.0) * weights[2] +\n            vec2(0.0, 1.0) * weights[3]\n        );\n        vec3 ccol = \n            vec3(1.0, 0.0, 0.0) * weights[0] + \n            vec3(0.0, 1.0, 0.0) * weights[1] + \n            vec3(0.0, 0.0, 1.0) * weights[2] + \n            vec3(1.0, 0.0, 1.0) * weights[3];\n        col = mix(texture(iChannel0, texCoord).rgb, ccol, pow(cos(iTime*0.272), 2.0));\n\t    vec2 dg = mod(texCoord, vec2(0.1));\n        if (dg.x < 0.0075 || dg.y < 0.0075) {\n            col = vec3(1.0, 1.0, 1.0);\n        }\n            \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dd3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dd3zN", "name": "Blue Scanner ", "author": "AlexWalley", "description": "Practicing mapping color between the radius and the width. Similar to the scanner in no man's sky.", "tags": ["practice"], "likes": 4, "viewed": 175, "date": "1567967327", "time_retrieved": "2024-06-20T19:43:22.359807", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 gv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //You can add a texture to offset the ring, creating an\n    //outline of the image\n\tuv += texture(iChannel0, gv).rb; \n    vec3 col = vec3(0);\n    \n    float width = 0.2;\n    float radius = tan(iTime)*0.2+0.2; //Using tan to create a repeating scan\n    float c = length(uv);\n    \n    //Creating the circle based upon radius and width\n    col += smoothstep(radius+width, radius+width-0.001, c);\n    col -= smoothstep(radius, radius-0.02, c);\n\n    //Creating a linear gradient from inside to out of the ring\n    col *= vec3(0.3, 0.6, 0.8)*1.4*((c-radius+0.03)/(width-0.01));\n    \n    //Adding White ouline on the circle\n    col += smoothstep(radius+width, radius+width-0.01, c);\n    col -= smoothstep(radius+width-0.015, radius+width-0.02, c);\n    col += (sin(c*275.)*0.2)*col; //Holographic type waves\n    \n    col += vec3(0.1, 0.2, 0.33)*0.5;//Raising the background color\n    \n    \n    //col = vec3(c);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dd3zN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddGD8", "name": "Floaty Cell", "author": "MasterQ32", "description": "A simpe shader for the outline of a cell", "tags": ["animated", "worm", "outline"], "likes": 2, "viewed": 143, "date": "1568380364", "time_retrieved": "2024-06-20T19:43:22.359807", "image_code": "\nconst vec3 wormColor = vec3(0.4, 0.9, 1.0);\n\n\nfloat sdf(vec2 pos, float r)\n{\n    return length(pos) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = 2.0 * uv - 1.0;\n    \n    uv.x *= (iResolution.x / iResolution.y);\n\n    vec4 bg = max(texture(iChannel0, 0.5 * uv + vec2(0.03 * iTime, -0.01 * iTime)).rbba,\n        \ttexture(iChannel0, 0.5 * uv + vec2(0.03 * iTime, 0.01 * iTime)).brba);\n    \n    \n    bg = texture(iChannel1, bg.xy);\n    bg.rgb = pow(bg.rgb, vec3(2.0));\n    \n    bg.rgb = mix(vec3(0.1, 0.1, 0.4), vec3(0.3, 0.4, 0.9), bg.r);\n    \n    \n    vec3[] worm = vec3[](\n    \tvec3(-0.4, 0.0, 0.25),\n        vec3(-0.2, 0.0, 0.25),\n        vec3( 0.0, 0.0, 0.25),\n        vec3( 0.2, 0.0, 0.25),\n        vec3( 0.4, 0.0, 0.25)\n    );\n    \n    for(int i = 0; i < worm.length(); i++)\n    {\n        worm[i].x *= 1.0 + 0.2 * cos(iTime);\n        worm[i].y += 0.3 * sin(iTime + worm[i].x);\n    }\n    \n    float d = 10000.0;\n    for(int i = 0; i < worm.length(); i++)\n    {\n        d = min(d, sdf(worm[i].xy - uv, worm[i].z)); \n    }\n    vec4 wc;\n    if(d < 0.0) {\n    \twc = vec4(wormColor, pow(clamp(1.0 + 10.0 * d, 0.0, 1.0), 2.0));\n    } else {\n        wc = vec4(wormColor, 1.0 - 50.0 * d);\n    }\n    wc.a = clamp(wc.a, 0.0, 1.0);\n    \n    \n    // Output to screen\n    fragColor = mix(bg, wc, wc.a);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddGWM", "name": "[twitch] City Borealis", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CityBorealis_v2", "tags": ["3d", "raymarching", "reflections", "translucency"], "likes": 20, "viewed": 359, "date": "1568671836", "time_retrieved": "2024-06-20T19:43:23.772019", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nAfter the stream, I fixed a major glitch in how I apply alpha, this is the fixed version.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CityBorealis.glsl\nOr the modify version for bonzomatic here: http://lezanu.fr/LiveCode/CityBorealis_v2\n*/\n\nfloat time=0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;  \n}\n\nvec3 kifs(vec3 p, float t) {\n  \n  p.xz = repeat(p.xz, vec2(28));\n  p.xz = abs(p.xz);\n  \n  vec2 s=vec2(10,7) * 0.6;\n  for(int i=0; i<5; ++i) {\n    p.xz *= rot(t);\n    //p.xz = repeat(p.xz, vec2(28-i*0));\n    p.xz = abs(p.xz) - s;\n    p.y += 0.1*abs(p.z);\n    s*=vec2(0.7,0.5);\n  }\n  \n  return p;\n}\n\nvec3 kifs3d(vec3 p, float t) {\n  \n  p.xz = repeat(p.xz, vec2(17));\n  p = abs(p);\n  \n  vec2 s=vec2(10,7) * 0.4;\n  for(int i=0; i<5; ++i) {\n    p.yz *= rot(t*0.7);\n    p.xz *= rot(t);\n    //p.xz = repeat(p.xz, vec2(28-i*0));\n    p.xz = abs(p.xz) - s;\n    //p.y += 0.1*abs(p.z);\n    s*=vec2(0.7,0.6);\n  }\n  \n  return p;\n}\n\nvec3 tunnel(vec3 p) {\n  \n  vec3 off=vec3(0);\n  \n  off.x += abs(repeat(p.z, 15.0))*0.5;\n  off.x += abs(repeat(p.z, 19.0))*0.6;\n  \n  return off;\n}\n\nbool gold = false;\nfloat goldvalue = 0.0;\nfloat solid(vec3 p) {\n  \n  vec3 pp = p;\n  pp += tunnel(p);\n  float path = abs(pp.x)-1.5;\n    \n  vec3 p2 = kifs(p, 0.5);\n  vec3 p3 = kifs(p+vec3(3,0,0), 1.91);\n  \n  float b1 = box(p2,vec3(1,1.3,0.5));\n  float b2 = box(p3,vec3(0.5,1.3,1));\n  \n  float m1 = max(abs(b1), abs(b2)) - 0.2;\n  \n  float s1 = length(p2+vec3(0,1.4,0))-0.8;\n  float s2 = length(p3+vec3(0,1.7,0))-0.9;\n  float top = max(abs(abs(abs(s1)-0.1)-0.05),abs(s2))-0.02;\n  goldvalue = top;\n  \n  m1 = min(m1,top);\n  \n  m1 = max(m1, -path);\n  \n  float d = m1;\n  \n  \n  d = min(d, -p.y);\n  \n  //d *= 0.7;\n  \n  return d;\n}\n\nfloat rnd(float a) {\n  return fract(sin(a*425.621)*342.512);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)),rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)), 10.0));\n}\n\nfloat at=0.0;\nfloat at2=0.0;\nfloat at3=0.0;\nfloat ghost(vec3 p) {\n  \n  p.y += 3.0;\n  \n  float off = time * 0.1 - p.z*0.09;\n  \n  vec3 p2 = kifs3d(p-vec3(0,2,3), 0.8 + curve(off, 0.3) + off*0.9);\n  vec3 p3 = kifs3d(p-vec3(6,0,0), 1.2 + curve(off, 0.4) + off* 0.7);\n  \n  float b1 = box(p2,vec3(1));\n  float b2 = box(p3,vec3(0.7));\n  \n  float m1 = max(abs(b1), abs(b2)) - 0.1;\n  \n  //float s1 = length(p2.xz)-0.3;\n  float s1 = box(p2, vec3(0.3,10,0.5));\n  float s2 = box(p3, vec3(10,0.4,0.5));\n  \n  float tt=time*0.3;\n  /*\n  at += 0.1/(0.02+abs(s1+sin(p.x*0.13 + tt)*0.5));\n  at2 += 0.1/(0.02+abs(s2+cos(p.z*0.2 + tt)*0.5));\n  at3 += 0.25/(0.2+abs(m1+sin(p.x*0.59 + tt)*0.4));\n  */\n  at = 0.1/(0.02+abs(s1+sin(p.x*0.13 + tt)*0.5));\n  at2 = 0.1/(0.02+abs(s2+cos(p.z*0.2 + tt)*0.5));\n  at3 = 0.25/(0.2+abs(m1+sin(p.x*0.59 + tt)*0.4));\n  \n  //m1 *= 0.7;\n  \n  return abs(m1);\n  \n}\n\nbool isghost = true;\nfloat map(vec3 p) {\n  \n  float sol = solid(p);\n  \n  float gho = ghost(p);\n    \n  isghost = gho<sol;\n  float d = min(sol, gho);\n  gold = goldvalue<d+0.01;\n  //return gho;\n  \n  //d *= 0.7;\n  \n  return d;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*724.512+uv.yx*568.577),vec2(342.814)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  time = mod(iTime, 200.0);\n\n  vec3 s=vec3(0,-1.0,-3);\n  vec3 t=vec3(0,-1.0 + sin(time*0.2)*0.5,0);\n  \n  float adv = time * 0.9;\n  s.z += adv;\n  t.z += adv;\n  \n  s -= tunnel(s);\n  t -= tunnel(t);\n  //s.xz *= rot(time*0.3);\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(sin(time)*0.1,1,0)));\n  vec3 cy=normalize(cross(cz, cx));\n  \n  vec3 r = normalize(uv.x*cx + uv.y*cy + cz);\n  //vec3 r=normalize(vec3(-uv, 1));\n  \n  vec2 off=vec2(0.01,0);\n  \n  vec3 p=s;\n  float dd=0.0;\n  float maxdist=100.0;\n  vec3 alpha=vec3(1);\n  vec3 emi = vec3(0);\n  float rand=mix(rnd(uv),1.0,0.9);\n  float firsthit = maxdist;\n  vec3 b1 = vec3(0);\n  vec3 b2 = vec3(0);\n  vec3 b3 = vec3(0);\n  // this is done to ensure the loop is not unrolled, so compile time doesnt explode\n  float iterationcount = (100.0+min(time,0.0));\n  for(float i=0.0; i<iterationcount; ++i) {\n    float d=map(p)*rand;\n    if(abs(d)<0.003) {\n      if(!isghost) {\n        bool copygold = gold;\n        \n\t\tvec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        \n        if(p.y>-0.02) {\n          \n          float d3 = map(p-vec3(0,2,0));\n          //n.xz += sin(d3*vec2(10,0.3) + time*vec2(0.3,0.7)) * 0.3;\n          float fac = 0.02 / max(1.0,abs(d3));\n          n.x += sin(d3*45.0 + time) * 0.5 * fac;\n          n.x += sin(d3*17.0 + time*3.0) * fac;\n          n.z += sin(d3*23.0 + time*0.7) * 0.8 * fac;\n          \n          n = normalize(n);\n        }\n        \n        float fre = pow(1.0-abs(dot(n,r)),1.0);\n        r = reflect(r,n);\n        //break;\n        \n        alpha *= fre;\n\t\t\n        if(copygold) {\n          //emi += vec3(1,0.9,0.5) * alpha*0.0;\n          alpha *= vec3(1,0.9,0.5) * 2.0;\n        }\n        firsthit = min(firsthit, dd);\n      }\n      d = 0.1;\n    }\n    /*if(dd>maxdist) {\n      dd=maxdist;\n      break;\n    }*/\n      \n    b1 += at * alpha;\n    b2 += at2 * alpha;\n    b3 += at3 * alpha;\n      \n    p+=r*d;\n    dd+=d;\n  }\n  firsthit = min(firsthit, dd);\n  \n  vec3 sky = mix(vec3(0.7,0.5,1), vec3(0), pow(abs(r.y),0.4));\n  \n  vec3 col = vec3(0);\n  //col += pow(1.0-float(i)/101.0,6.0);\n  col += b1*0.005*vec3(0.3,0.5,1) * curve(time+12.2, 0.9);\n  col += b2*0.013*vec3(0.4,0.7,0.5) * curve(time, 1.2);\n  col += b3*0.014*vec3(0.8,0.2,0.5) * curve(time+17.4, 1.7);\n  col += emi;\n  float fog = pow(clamp(firsthit*3.0/maxdist,0.0,1.0),1.3);\n  //col *= 1-fog;\n  col += fog * sky *  1.0;\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddGWn", "name": "Quaternion Julia Cross Section", "author": "skye_adaire", "description": "This shows that the cross section of the quaternion Julia set in the XY plane is the complex Julia set.", "tags": ["fractal", "julia", "quaternion", "dual"], "likes": 4, "viewed": 125, "date": "1568466519", "time_retrieved": "2024-06-20T19:43:26.226783", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat getJuliaDE(DualQuaternion jc, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //directional derivatives\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 40; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), jc);\n        dy = D_add(D_multiply(dy, dy), jc);\n        dz = D_add(D_multiply(dz, dz), jc);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    float dr = length(vec3(H_norm(dx[1]), H_norm(dy[1]), H_norm(dz[1])));\n    outNormal = normalize(vec3(dot(fp, dx[1].xyz), dot(fp, dy[1].xyz), dot(fp, dz[1].xyz)));\n\n  \treturn 0.5 * log(r) * r / dr;//better for low iteration counts\n  \t//return 0.5 * r / dr;\n}\n\nfloat getDE(DualQuaternion jc, vec3 position, out int object, out vec3 normal, out int iEscape)\n{\n    float julia = getJuliaDE(jc, position, normal, iEscape);\n    float crossSection = -position.z;\n\n    return max(julia, -crossSection);//subtract;\n}\n\nbool march(\n    DualQuaternion jc,\n    vec3 rp, vec3 rd, \n    out int object, \n    out vec3 globalIntersection, \n    out vec3 globalNormal, \n    out int steps,\n\tout int iEscape)\n{\n    float t = 0.0;\n    vec3 p;\n    \n    bool hit = false;\n    object = -1;\n    \n    for(steps = 0; steps < 200; steps++)\n    {\n        p = rp + t * rd;\n        \n        float de = getDE(jc, p, object, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            break; \n        }\n\n        t += de;\n    }  \n    \n    globalIntersection = p;\n    \n    return hit;\n}\n\nbool checkered(vec2 z)\n{\n\tbool x = int(z.x) % 2 == 0;\n\tbool y = int(z.y) % 2 == 0;\n\tif(z.x < 0.0) x = !x;\n\tif(z.y < 0.0) y = !y;\n\treturn x == y;\n}\n\nvec3 colorCheckered(vec2 z)\n{\n\treturn checkered(z) ? vec3(1) : vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotationXZ((iTime * 0.0));\n    vec3 viewPosition = viewTransform * vec3(0, 0, 1);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time) * 0.8;// * 0.35 + 0.65 + 0.35 / 2.0;\n    float st = sin(time) * 0.8;\n    Quaternion d = Quaternion(st, ct, 0,0);\n    DualQuaternion jc = DualQuaternion(d, Quaternion(0));\n\n    vec3 color = vec3(0);\n    int object = -1;\n    vec3 intersection;\n    vec3 normal;\n   \tint steps;\n    int escape;\n    \n    if(march(jc, srp, srd, object, intersection, normal, steps, escape))\n    {\n        vec3 surfaceColor = hsv2rgb(vec3(float(escape) / 20.0, 1, 1));\n   \t\tfloat fade = 1.0 - float(steps) / 100.0;\n        fade *= fade;\n    \tcolor += surfaceColor * fade;\n    }\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ddGzH", "name": "2D Mobius Transform", "author": "skye_adaire", "description": "This is a geometric Mobius transformation of the complex plane. The image of the plane has also been transformed by sin(z). Uses lifted domain coloring. http://www-users.math.umn.edu/~arnold//papers/moebius.pdf", "tags": ["sphere", "mobius", "plane", "complex", "stereographic", "transform", "real", "lifted"], "likes": 10, "viewed": 273, "date": "1567790895", "time_retrieved": "2024-06-20T19:43:27.693491", "image_code": "//created by Skye Adaire\n\n#define tau32 6.2831853072\n#define eps32 1e-10\n\nfloat alpha(float x, float a, float b)\n{\n   return (x - a) / (b - a);\n}\n\n#define uclamp(x) clamp(x, 0.0, 1.0)\n#define ualpha(x, a, b) uclamp(alpha(x, a, b))\n\n#define Real float\n#define Complex vec2\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n\treturn Complex(\n        lhs.x * rhs.x - lhs.y * rhs.y, \n        lhs.x * rhs.y + lhs.y * rhs.x);\n}\n\nComplex H_sin(Complex h)\n{\n\treturn Complex(sin(h.x) * cosh(h.y), cos(h.x) * sinh(h.y));\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h.y, h.x);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\n//the hyperplane centered at the origin with normal 0,0,1\nbool intersectHyperplane(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    t = -rayPosition[2] / rayDirection[2];\n\n    return t > 0.0 && !isinf(t);\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the hypersphere centered at the origin with radius 1\nbool intersectHypersphere(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayPosition);\n    float c = dot(rayPosition, rayPosition) - 1.0;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//http://blog.hvidtfeldts.net/index.php/2012/03/lifted-domain-coloring/\nvec3 liftedDomainColor(vec2 z)\n{\n    PolarComplex polar = H_toPolar(z);\n\n    float magnitude = (1.0-1.0/pow(2.0,polar.norm)) * 0.9 + 0.1;\n    float logradius = log(polar.norm);\n\n    //black rings\n    float fractlog = fract(logradius);\n    float ringdist = min(abs(fractlog-0.5), fractlog > 0.5 ? 1.0-fractlog : fractlog);\n    float ring = (1.0 - smoothstep(0.00, 0.02, ringdist)) * 0.8;\n\n    //white rays\n    float k = 12.0;\n    float sectorsize = (tau32) / k;\n    float anglemod = mod(polar.argument, sectorsize);\n    float sectordist = anglemod > sectorsize/2.0 ? sectorsize-anglemod : anglemod;\n    float raywidth = 0.02;\n    float ray = (1.0 - smoothstep(0.0, raywidth, sectordist)) * 0.8;\n\n    //infinity will be white\n    float infinityFade = pow(magnitude,100000000.0);\n\n    //growth ring shade\n    float growth = (fractlog)*0.7 + 0.3;\n    float darkening = uclamp(1.5*magnitude * (fractlog*0.5 + 0.5) + ray + infinityFade);\n\n    float hue = polar.argument/tau32;\n    float saturation = 1.0 - infinityFade;\n    float value = darkening;\n    \n    vec3 color = hsv2rgb(vec3(hue, saturation, value));\n    color = mix(color, vec3(1.0), darkening * ray);\n    color = mix(color, vec3(0.0), darkening * (ring-infinityFade));\n\n    return color;\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n\n    mat3 viewTransform = rotationXY(-tau32 / 8.0) * rotationYZ(tau32/6.0);\n    \n    //view basis\n    vec3 viewPosition = viewTransform * vec3(0, 0, 6);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 screenRayPosition =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 screenRayDirection = normalize(screenRayPosition - frustumPoint);\n       \n    //transform sphere local to global\n    float angle = iTime * 0.4;\n    mat3 rotation = rotationXZ(angle);\n    vec3 translation = vec3(0, 0, 1.0 + cos(iTime*0.4 + tau32/2.0));\n    vec3 pole = translation + vec3(0, 0, 1);\n    \n    //transform sphere global to local\n    mat3 rotationInv = rotationXZ(-angle);\n    vec3 translationInv = -translation;\n    vec3 poleInv = vec3(0, 0, 1);\n    \n    //transform the ray to local sphere space\n    vec3 rpt = rotationInv * (translationInv + screenRayPosition);\n    vec3 rdt = rotationInv * screenRayDirection;\n    \n    float t, tmin;\n    int object = -1;\n    vec3 position;\n    \n    //sphere in local space\n    if(intersectHypersphere(rpt, rdt, t))\n    {\n        tmin = t;\n        object = 1;\n    }\n    \n    //plane in global space\n    if(intersectHyperplane(screenRayPosition, screenRayDirection, t))\n    {\n        if(object == -1 || t < tmin)\n        {\n            tmin = t;\n         \tobject = 2;\n        }\n    }\n    \n    vec3 color = vec3(0);\n    \n    if(object == 2)//we are on the global plane, project to the local sphere\n    {\n        vec3 rp = screenRayPosition + tmin * screenRayDirection;\n        vec3 rd = normalize(rp - pole) * (length(rpt) < 1.0 ? 1.0 : -1.0);;\n        \n    \trpt = rotationInv * (translationInv + rp);\n    \trdt = rotationInv * rd;\n        \n        intersectHypersphere(rpt, rdt, tmin);//must hit\n        object = 1;\n    }\n    \n    if(object == 1)//we are on the local sphere, project to the local plane\n    {\n        vec3 rp =  rpt + tmin * rdt;\n        vec3 rd = normalize(rp - poleInv);\n\n        float t;\n        intersectHyperplane(rp, rd, t);//must hit\n        \n        vec2 localPlanePosition = (rp + t * rd).xy;\n        \n        //apply a complex transform to the plane\n        vec2 z = localPlanePosition;\n        vec2 zt = H_sin(z);\n\n        color = liftedDomainColor(zt);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ddGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dGGzz", "name": "Wavy Yin-Yang", "author": "zachThePerson", "description": "Something cool I made learning shaders", "tags": ["sine"], "likes": 6, "viewed": 97, "date": "1569546784", "time_retrieved": "2024-06-20T19:43:27.899690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    float PI = radians(180.0);\n    \n    //constants\n    float rad = 150.0;\n    \n    //main circle\n    float dist = distance(fragCoord, center);\n    float circle = dist - rad;\n    float outline = clamp(abs(circle) - 1.0, 0.0, 1.0);\n    float circleCol = mix(1.0, 0.0, outline);\n    \n    //center sine\n    float sine = sin(((fragCoord.y - (iResolution.y * 0.5)) / (PI * 20.0)) + iTime);\n    float sineDiv = fragCoord.x - center.x + sine * 50.0;\n    float sinClamp = clamp(sineDiv, 0.0, 1.0);\n    float sineCropped = mix(0.0, 1.0, clamp(sinClamp - clamp(circle + 5.0, 0.0, 1.0), 0.0, 1.0));\n    \n    //Small circles\n    vec2 mirrorUV = vec2(fragCoord.x, abs(fragCoord.y - center.y));\n    float smallDist = distance(mirrorUV, vec2(center.x, center.y * 0.4));\n    float smallCirc = smallDist - 25.0;\n    float smallClamp = clamp(smallCirc, 0.0, 1.0);\n    float smallCol = mix(1.0, 0.0, smallClamp);\n    float inverted = smallCol - sineCropped * smallCol * 2.0;\n    \n    //combine\n    float comp = sineCropped + circleCol + inverted;\n\n    // Output to screen\n    fragColor = vec4(vec3(comp),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dGGzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dt3DM", "name": "JEWEL", "author": "ankd", "description": "volumetric rendering.\nreference : \"Playing marble\" by guil\nhttps://www.shadertoy.com/view/MtX3Ws", "tags": ["raymarching"], "likes": 3, "viewed": 115, "date": "1569830183", "time_retrieved": "2024-06-20T19:43:27.905717", "image_code": "float noise(in float t) {\n\tfloat s = sin(t+sin(t*1.1+sin(t*1.2)));\n    return s;\n}\n\nmat2 rotate(in float r) { float c=cos(r),s=sin(r); return mat2(c, s, -s, c); }\n\nvec2 cmul(in vec2 a, in vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\nvec2 csqr(in vec2 a) { return vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y); }\n\n// distance function\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d=abs(p)-b; return length(max(d, 0.))+min(max(d.x,max(d.y,d.z)),0.); }\n\n// get geometry\nfloat geometry(in vec3 p) {\n    vec3 q = p;\n    vec3 c = vec3(1.);\n    //q = mod(q, c) - 0.5*c;\n    \n    float res = box(q, vec3(0.3));\n\treturn res;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1., -1.) * 0.001;\n    return normalize(\n    \te.xyy*geometry(p+e.xyy) +\n    \te.yxy*geometry(p+e.yxy) +\n    \te.yyx*geometry(p+e.yyx) +\n    \te.xxx*geometry(p+e.xxx)\n    );\n}\n\n// pattern in geometry\nfloat map(in vec3 p) {\n\tfloat res = 0.;\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n        //p =.7*abs(p)/dot(p,p) -.7;\n        p =.7*abs(p)/dot(p,p) -.8*noise(iTime*0.3);\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n\t}\n\treturn res/2.;\n}\n\n\n// ray march to get geometry\nvec2 getTMinMax(in vec3 ro, in vec3 rd, in vec2 cminmax) {\n    vec2 res = vec2(-1.);\n    float thr = 0.001;\n\n    // calc tmin\n    float t = cminmax.x;\n    for(int i=0;i<128;i++) {\n    \tfloat tmp = geometry(ro + rd*t);\n        tmp = max(tmp, 0.);\n        if(tmp<thr || cminmax.y<t) {\n            break;\n        }\n        t += tmp*0.5;\n    }\n    if(cminmax.y<t) return vec2(-1.);\n    res.x = t;\n    \n    // calc tmax\n    //t += 4.*thr;\n    t += 0.05;\n    for(int i=0;i<128;i++) {\n    \tfloat tmp = geometry(ro + rd*t);\n        tmp *= -1.;\n        if(tmp<thr || cminmax.y<t) {\n            break;\n        }\n        t += tmp*0.5;\n    }\n    res.y = cminmax.y<t ? cminmax.y : t;\n    return res;\n}\n\n// \nvec3 rayMarch(in vec3 ro, in vec3 rd, in vec2 tminmax) {\n    vec3 col = vec3(0.);\n    \n\tfloat t = tminmax.x;\n\tfloat dt = (tminmax.y-tminmax.x) / 64.;\n    //dt = 0.02;\n\tfor(int i=0;i<16;i++) {\n\t\t// march t\n        t += dt;\n\t\tif(tminmax.y<t) break;\n        float c = map(ro + rd*t);\n        col = 0.99*col + 0.02*vec3(c*c);\n    }\n    //col = vec3(acc);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat time = iTime*0.1;\n\n    // camera\n    vec3 ro = vec3(cos(time), 0., sin(time));\n    //ro = vec3(0., 0., -time);\n    vec3 ta = vec3(0., 0., 0.);\n    float cr = 0.3*sin(0.1*iTime);\n    vec3 cz = normalize(ta-ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    // get tmin, tmax\n    vec2 tmm = getTMinMax(ro, rd, vec2(0., 10.));\n        \n    // render\n    vec3 col = vec3(0.);\n    if(tmm.x<0.){\n        col = vec3(1.0);\n    } else {\n\t    col = rayMarch(ro, rd, tmm);\n    }\n    \n    col += 0.3*vec3(tmm.y-tmm.x);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dt3DM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dt3Dr", "name": "Accidental Art ~ pbakshi", "author": "pbakshi", "description": "Even I dont know whats going on seriously !! XD", "tags": ["generative", "accidental"], "likes": 1, "viewed": 81, "date": "1568228709", "time_retrieved": "2024-06-20T19:43:27.905717", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nfloat sdfLine(float pt, float pos, float blur){\n    \n    return smoothstep(pos - blur, pos, pt) - smoothstep(pos, pos+blur, pt);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = max(iResolution.x, iResolution.y);\n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy)/a;\n    \n    //colors\n    vec3 bg = vec3(0.0);\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    vec3 col = bg;\n   \n    \n    //horizontals\n    float phase = sin(atan(y,x));\n    y = y + 0.3 * sin(x + iTime - phase);\n    \n    col = vec3(sdfLine(y, 0.0, 0.05));\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), vec3(sdfLine(y, 0.1, 0.05)));\n    \n    col = mix(col, vec3(0.0, 1.0, 0.0), vec3(sdfLine(y, -0.1, 0.05)));\n    \n    col = mix(col, vec3(0.0, 0.0, 1.0), vec3(sdfLine(y, 0.2, 0.05)));\n    \n    col = mix(col, vec3(1.0, 1.0, 0.0), vec3(sdfLine(y, -0.2, 0.05)));\n    \n    \n    //verticals\n    phase = sin(atan(x,y));\n    y = uv.y;\n    x = x + 0.3 * sin(y + iTime - phase);\n    \n    col = mix(col, vec3(1.0), vec3(sdfLine(x, 0.0, 0.05)));\n    \n    col = mix(col, vec3(1.0, 0.0, 0.0), vec3(sdfLine(x, 0.1, 0.05)));\n    \n    col = mix(col, vec3(0.0, 1.0, 0.0), vec3(sdfLine(x, -0.1, 0.05)));\n    \n    col = mix(col, vec3(0.0, 0.0, 1.0), vec3(sdfLine(x, 0.2, 0.05)));\n    \n    col = mix(col, vec3(1.0, 1.0, 0.0), vec3(sdfLine(x, -0.2, 0.05)));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dt3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dt3zj", "name": "Mandelbrot Ex", "author": "zxxuan1001", "description": "Parameters:\nJULIA/Mandelbrot: z=z^d+c\nd=2;\nd=3;\nd=4;\nSome interactions with mouse position.\n\nI will probably come back and do some decorations in the future.", "tags": ["mandelbrot"], "likes": 0, "viewed": 259, "date": "1568936530", "time_retrieved": "2024-06-20T19:43:28.196700", "image_code": "#define JULIA 1\n#define POLYNOMIAL_DEGREE 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float scale = 2.0;\n    float zoom = exp(-scale*mouse.x);\n    float aTime = iTime*0.5;\n    uv = vec2( uv.x*sin(aTime)-uv.y*cos(aTime), \n             uv.x*cos(aTime)+uv.y*sin(aTime) );\n    vec2 c = vec2(0.0);\n    vec2 z = vec2(0.0);\n#if JULIA==0\n    c = uv*zoom*scale;\n    z = vec2(0.1*cos(aTime), 0.1*sin(aTime)) + mouse;\n#else\n    c = vec2(sin(aTime), cos(aTime)) + mouse ;\n    z = uv*zoom*scale;\n \n#endif\n    float iter = 0.0;\n    vec3 col = vec3(0.0);\n    const float MAX_STEP = 200.0;\n    float pl = 0.0;\n    float dist = 0.0;\n    vec2 rst = vec2(0.0);\n    for (float i = 0.0; i < MAX_STEP; i++)\n    {\n        \n#if POLYNOMIAL_DEGREE==3\n        //(a+bi)^3\n        z = c + vec2(z.x*z.x*z.x-3.0*z.x*z.y*z.y, \n                 3.0*z.x*z.x*z.y-z.y*z.y*z.y);\n#elif POLYNOMIAL_DEGREE==4        \n        //(a+bi)^4\n        z = c + vec2( z.x*z.x*z.x*z.x-6.0*z.x*z.x*z.y*z.y+z.y*z.y*z.y*z.y,\n        \t\t\t  4.0*z.x*z.x*z.x*z.y-4.0*z.x*z.y*z.y*z.y );\n#else\n        //(a+bi)^2\n        z = c + vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y);\n#endif\n        dist = dot(z,z);\n        if ( dist>4.0 ) break;\n        \n        pl = iter/MAX_STEP;\n        col += vec3( pl, 0.0, pow(0.1,dist) );\n        iter++; \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dt3zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dtGR4", "name": "3D Mobius Transform", "author": "skye_adaire", "description": "Uses the 3D Mobius transform to invert the model. Distance estimations are taken in the local space of the 4D hypersphere. The hypersphere is performing a single rotation in the YW plane. See my other shaders for more background.", "tags": ["julia", "mobius", "quaternion", "dual", "set", "automatic", "hypercomplex", "differentiation"], "likes": 13, "viewed": 176, "date": "1567945657", "time_retrieved": "2024-06-20T19:43:31.021029", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\n//the 3-plane centered at the origin with normal 0, 0, 0, 1\nbool intersectHyperplane(vec4 rayPosition, vec4 rayDirection, out float t)\n{\n    t = -rayPosition[3] / rayDirection[3];\n\n    return t > 0.0 && !isinf(t);\n}\n\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the sphere centered at the origin with radius 1\nbool intersectHypersphere(vec4 rayPosition, vec4 rayDirection, out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(rayDirection, rayPosition);\n    float c = dot(rayPosition, rayPosition) - 1.0;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nmat3 rotation3XZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat4 rotation4YW(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(\n        1, 0, 0, 0,\n        0, c, 0, -s,\n        0, 0, 1, 0,\n        0, s, 0, c);\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat getJuliaDE(DualQuaternion dd, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //directional derivatives\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 20; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), dd);\n        dy = D_add(D_multiply(dy, dy), dd);\n        dz = D_add(D_multiply(dz, dz), dd);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    float dr = length(vec3(H_norm(dx[1]), H_norm(dy[1]), H_norm(dz[1])));\n    outNormal = normalize(vec3(dot(fp, dx[1].xyz), dot(fp, dy[1].xyz), dot(fp, dz[1].xyz)));\n\n  \t//return 0.5 * log(r) * r / dr;//better for low iteration counts\n    return 0.5 * r / dr;\n}\n\nvec3 mobius(vec3 p, vec4 pole, vec4 translationInv, mat4 rotationInv)\n{\n    //geometric stereo projection\n    vec4 p4 = vec4(p, 0);\n    vec4 d4 = normalize(pole - p4) * (length(p4) < 1.0 ? -1.0 : 1.0);\n        \n    //transform the ray to sphere space\n    vec4 p4t = rotationInv * (translationInv + p4);\n    vec4 d4t = rotationInv * d4;\n\n    float ts;\n    intersectHypersphere(p4t, d4t, ts);//must hit\n\n    //stereo intersect the sphere's local hyperplane\n    vec4 p4s = p4t + ts * d4t;\n    vec4 d4s = normalize(vec4(0,0,0,1) - p4s);\n\n    float tp;\n    intersectHyperplane(p4s, d4s, tp);//must hit\n\n    return vec3(p4s + tp * d4s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotation3XZ(iTime * 0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 2);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //transform hypersphere local to global\n    float angle = iTime * 0.4;\n    mat4 rotation = rotation4YW(angle);\n    vec4 translation = vec4(0, 0, 0, 0);//1.0 + cos(iTime*0.4 + tau32/2.0));\n    vec4 pole = translation + vec4(0, 0, 0, 1);\n    \n    //transform hypersphere global to local\n    mat4 rotationInv = rotation4YW(-angle);\n    vec4 translationInv = -translation;\n    vec4 poleInv = vec4(0, 0, 0, 1);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time);\n    float st = sin(time);\n    Quaternion d = Quaternion(0, ct, st, 0);\n    DualQuaternion dd = DualQuaternion(d, Quaternion(0));\n\n    //ray march the distance field\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    \n    //last julia outputs\n    int iEscape;\n    vec3 globalNormal;\n    \n    for(i = 0; i < 400; i++)\n    {\n        p = srp + t * srd;\n        \n        p = mobius(p, pole, translationInv, rotationInv);\n        \n        float de = getJuliaDE(dd, p, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    //color the intersection\n    vec4 color = vec4(0);\n    \n    if(hit)\n    {\n        float escape = 0.7 * float(iEscape) / float(20) + 0.2;\n        vec3 surfaceColor = hsv2rgb(vec3(escape, 1, 1));\n\n        vec3 bottomLightDirection = normalize(vec3(-1,-1,-1));\n        vec3 bottomLight = 0.6 * clamp(dot(globalNormal, bottomLightDirection), 0.0, 1.0) * vec3(1, 1, 1);\n        color += vec4(bottomLight * surfaceColor, 1);\n\n        vec3 spotLight1Position = vec3(10);\n        vec3 spotLight1Color = 1.5 * vec3(1, 1, 1);\n        vec3 spotLight1Direction = normalize(spotLight1Position - p);\n        float spotLight1Incidence = clamp(dot(globalNormal, spotLight1Direction), 0.0, 1.0);\n        float spotLight1Blocked = 1.0;\n        vec3 spotLight = spotLight1Blocked * spotLight1Incidence * spotLight1Color;\n        color += vec4(spotLight * surfaceColor, 1);\n    }\n    \n    color = pow(color, vec4(0.4545));\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dtGR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dV3R1", "name": "Bouncing ball, basic as it gets!", "author": "izo", "description": "As basic as it gets raytracer of a bouncing ball, with my favorite background that I discovered (like many others have) messing around with bitwise operators trying to create fractals, way back when I was 14yo. \n\nAnd some faux transparency. ", "tags": ["raytrace", "ball", "basics", "sphereintersect"], "likes": 0, "viewed": 332, "date": "1569727757", "time_retrieved": "2024-06-20T19:43:31.021029", "image_code": "#define radius .05 \n#define BGB false\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy; //Center on screen (-.5 to .5)\n\tuv.x = uv.x * (iResolution.x/iResolution.y); //Adjust x cord for aspect ratio\n\n\t\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec3 s = vec3(0.05, 0.05, abs(sin(iTime)/2.));\n    \n    float t = dot(s-ro, rd);\n    \n    vec3 p = ro + rd*t;\n    \n    float y = length(p-s);\n    \n    float x = sqrt(radius*radius - y*y);\n    \n    float t1 = x + t;\n    \n    float t2 = x - t;\n    \n    float dist = length(ro +rd*t1);\n    \n    float blink_bg = BGB ? abs(sin(iTime)) : 1.;\n    \n    vec3 ballcolor = bool(int(iTime)%10) ? vec3(1, .2, 0) \n        : vec3(float((int(fragCoord.x)*2)^(int(fragCoord.y)*2))/((iResolution.x*iResolution.y)/300.),.2,0);\n    \n  \tvec3 col = y > radius ? vec3(0,0,float(int(fragCoord.x)^int(fragCoord.y))/((iResolution.x*iResolution.y)/300./blink_bg) ) : //Generate background\n    \tmix(vec3(x*20. - dist), ballcolor, .4);//\"Raytraced\" ball\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dV3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dVGRz", "name": "itsukushijima", "author": "zaki", "description": "torii", "tags": ["torii"], "likes": 2, "viewed": 57, "date": "1569645286", "time_retrieved": "2024-06-20T19:43:31.021029", "image_code": "float MIN_DIST=0.001;\nfloat MAX_DIST=100.0;\nint MAX_STEP=100;\nfloat PI=3.141592;\n\nfloat mat = 0.0;\nfloat g = 0.0;\n\nfloat box(vec3 pos, vec3 dim)\n{\n    vec3 d = abs(pos) - dim;\n  \treturn length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat rnd(float t) { return fract(sin(t * 2838.237) * 237.1236); }\n\nfloat dot2(vec2 v) { return dot(v, v); }\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat pillar(in vec3 pos, in float h, in float r1, in float r2)\n{\n    vec2 q = vec2(length(pos.xz), pos.y);\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat beam(vec3 pos, vec3 off, vec3 size, float bend)\n{\n\tvec3 p = pos - off;\n    p.y += cos(abs(pos.x / bend));\n    return box(p, size);\n}\n\nvec2 matmin(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 base(vec3 pos)\n{\n    vec3 p = pos;\n    vec2 prim = vec2(pillar(p + vec3(0.0, 1.0, 0.0), 0.5, 100.0, 100.0), 2.0);\n    prim.x += cos(pos.x * 0.5 + iTime * 0.54) * 0.12;\n    prim.x += cos(pos.z * 0.5 + iTime * 0.43) * 0.11;\n    \n    return prim;\n}\n\n\nvec3 light()\n{\n    vec3 light = normalize(vec3(3.0, -1.0, 2.0));\n    light.xz *= rot(iTime * 0.1);\n    light.xy *= rot(iTime * 0.3);\n    light = normalize(light);\n\n    return light;\n}\n\nvec2 lll(vec3 pos)\n{\n    vec3 lp1 = vec3(6.0 + sin(iTime * 0.9) * 5.0, 4.0 + sin(iTime * 0.8), cos(iTime * 0.9) * 5.0);\n    float d1 = length(pos - lp1) - 0.1;\n    \n    g += 0.2 * (0.1 / (max(0.0, pow(d1, 2.0))));\n\n    vec3 lp2 = vec3(-6.0 - sin(iTime * 0.7) * 5.0, 4.0 - 2.0*sin(iTime * 0.5), cos(iTime * -0.9) * 5.0);\n    float d2 = length(pos - lp2) - 0.1;\n    \n    g += 0.2 * (0.1 / (max(0.0, pow(d2, 2.0))));\n\n    \n    return vec2(min(d1, d2), 0.0);\n}\n\nvec2 torii(vec3 pos)\n{\n    vec2 r = vec2(0);\n    \n    float tr1 = beam(pos, vec3(0.0, 10.0, 0.0), vec3(5.0, 0.2, 0.5),  6.0);\n    float tr2 = beam(pos, vec3(0.0, 10.1, 0.0), vec3(5.2, 0.1, 0.6),  6.0);\n    float tr3 = beam(pos, vec3(0.0,  9.5, 0.0), vec3(4.7, 0.4, 0.5),  6.0);\n    float tr4 = beam(pos, vec3(0.0,  7.5, 0.0), vec3(4.7, 0.4, 0.5), 10.0);\n\n    vec3 p1 = pos;\n    p1.x = abs(p1.x);\n    p1 -= vec3(3.5, 4.2, 0.0);\n    float c1 = pillar(p1, 5.0, 0.5, 0.3);\n    \n    vec3 p2 = pos;\n    p2.x = abs(p2.x);\n    p2.z = abs(p2.z);\n    p2 -= vec3(3.5, 1.8, 3.0);\n    float c2 = pillar(p2, 2.5, 0.4, 0.3);\n    \n    p2.y -= 2.7;\n    float cb = box(p2, vec3(0.6, 0.2, 0.6));\n    \n    vec3 cp1 = pos;\n    cp1.x = abs(cp1.x);\n    float cb1 = beam(cp1, vec3(3.5, 4.0, 0.0), vec3(0.2, 0.3, 4.0), 8.0);\n    float cb2 = beam(cp1, vec3(3.5, 2.0, 0.0), vec3(0.2, 0.3, 4.0), 8.0);\n    \n\tr = matmin(\n        \tvec2(min(min(min(tr1, tr2), tr3), tr4), 0.0),\n        \tmatmin(\n            \tmatmin(vec2(min(c1, c2), 0.0), vec2(cb, 0.0)),\n        \t\tvec2(min(cb1, cb2), 0.0)\n        \t)\n        );\n    r = matmin(r, base(pos));\n    r = matmin(r, lll(pos));\n    return r;\n}\n\nvec2 sdf(vec3 pos)\n{\n\tvec2 tr = torii(pos);\n    return tr;\n}\n\nvec3 norm(vec3 pos)\n{\n\tvec2 e = vec2(0.01, 0.0);\n    \n    return normalize(sdf(pos).x - vec3(\n    \tsdf(pos + e.xyy).x,\n        sdf(pos + e.yxy).x,\n        sdf(pos + e.yyx).x\n    ));\n}\n\nfloat march(vec3 pos, vec3 ray)\n{\n\tfloat t = 0.0;\n    int m = 0;\n    vec3 p = pos;\n    \n    for (; m < MAX_STEP; ++m)\n    {\n    \tvec2 d = sdf(p);\n        t+=d.x;\n        mat=d.y;\n        \n        if (t > MAX_DIST) {mat=1.0;t=MAX_DIST-MIN_DIST;break;}\n        if (t < MIN_DIST) break;\n        \n        p = p + d.x * ray;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float asp = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.y *= asp;\n\n    vec3 org = vec3(0.0, 5.0, -40.0);\n    vec3 ray = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    org.z += sin(iTime * 0.0576) * 10.0;\n    \n    org.xz *= rot(iTime * -0.01 + PI/4.0);\n    ray.xz *= rot(iTime * -0.01 + PI/4.0);\n    \n    float d = march(org, ray);\n    vec3 pp = org + d * ray;\n    vec3 n = norm(pp);\n\tvec3 light = light();\n    \n    vec3 col = vec3(0.5, 0.6, 0.9) * pow(d / MAX_DIST, 2.0);\n    col = vec3(0.9, 0.4, 0.3) * pow(abs(dot(n, light)), 2.0);\n\n    float dd = dot(light, vec3(0.0, 1.0, 0.0)) * 0.3 + 0.7;\n    float rf = 0.1;\n    if (mat == 1.0)\n    {\n        col = mix(vec3(0.02, 0.0, 0.01), vec3(0.7, 0.7, 0.9), smoothstep(0.1, 1.0, dd));\n        if (dd < 0.5) col.r += sin(0.5 - dd) * 0.2;\n        \n        col *= (1.2 - uv.y);\n        rf = 0.0;\n    }\n    if (mat == 2.0)\n    {\n        float l = 1.0 - pow(abs(dot(n, light)), 2.0);\n    \tcol = mix(vec3(0.01, 0.2, 0.2) * l, vec3(0.1, 0.3, 0.8) * l, dd);\n        rf = 0.5;\n    }\n    col += vec3(rf)*smoothstep(0.8, 1.0, dot(n,-light));\n\n    col *= clamp(1.3 - length(uv), 0.0, 1.0);\n    \n    col += vec3(0.4) * g;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dVGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dy3zR", "name": "Ray Marching: basic shapes", "author": "Rewlion", "description": "ray marching: basic shapes", "tags": ["raymarching"], "likes": 0, "viewed": 275, "date": "1569610186", "time_retrieved": "2024-06-20T19:43:31.021029", "image_code": "float GetSphereDistance(vec3 p, vec3 c, float r)\n{\n    float distance = length(p-c) - r;\n    return distance;\n}\n\nfloat GetCapsuleDistance(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    \n    vec3 d = normalize(ab);\n    \n    float t = dot(p-a, ab) / dot(ab,ab); \n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;   \n    float h = length(p-c) - r;\n        \n    \n    return h;\n}\n\nfloat GetTorusDistance(vec3 p, float R, float r)\n{\n    float l1 = length(p.xz) - R;\n    float l2 = p.y;\n    float d = length(vec2(l1,l2)) - r;\n    \n    return d;\n}\n\nfloat GetBoxDistance(vec3 p, vec3 s)\n{\n \t  return length(max(abs(p)- s, 0.0));\n}\n\nfloat GetDistance(vec3 r)\n{\n    \n    float cd = GetCapsuleDistance(r, vec3(0.0, 1.0, 2.5), vec3(1.0, 2.0, 2.5), 0.2);\n    float td = GetTorusDistance(r - vec3(0.0, 0.4, 2.5), 1.0 , 0.2);\n    float sd = GetSphereDistance(r, vec3(-1.2, 1.0, 2.5), 0.3);\n    float bd = GetBoxDistance(r - vec3(2.0, 0.4, 2.), vec3(0.3,0.2,0.3));\n    float surfDistance = r.y;\n    \n    float d = min(cd, surfDistance);\n    d = min(d, td);\n    d = min(d, sd);\n    d = min(d, bd);\n    \n    return d;\n}\n\nfloat RayMarching(vec3 start, vec3 dir)\n{\n \tfloat distance = 0.0;\n    \n    for(int i = 0; i < 100; ++i)\n    {\n     \tvec3 r = start + distance*dir;\n        float d = GetDistance(r);\n        \n        if(d < 0.01 || d > 100.0)\n            break;\n        \n        distance += d;\n    }\n    \n    return distance;\n}\n\nvec3 GetNormal(vec3 r)\n{\n \tvec2 e = vec2(0.01, 0.0);\n    float d = GetDistance(r);\n    \n    vec3 dr = d - vec3(\n        GetDistance(r - e.xyy),\n        GetDistance(r - e.yxy),\n        GetDistance(r - e.yyx)\n        );\n    \n    dr = normalize(dr);\n    \n    return dr;\n}\n\nfloat GetLight(vec3 p, vec3 n)\n{\n    vec3 lightpos = vec3(0.0f, 7.0f, 2.0f);\n    lightpos.xz += vec2(cos(iTime), sin(iTime)) * 1.5;\n    \n    vec3 dr = normalize(lightpos - p);\n    \n    float l = clamp(dot(dr,n), 0.0, 1.0);\n    \n    float ld = RayMarching(p + n * 0.01, dr);\n    if(ld < length(lightpos - p))\n        return l * 0.1;\n    \n    return l;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera = vec3(0.0, 1.2, 0.0);\n    vec3 dir = normalize(vec3(uv,1.0));\n    \n    float c = RayMarching(camera, dir);\n\t\n    vec3 p = camera + dir * c;\n    vec3 n = GetNormal(p);\n    \n    float l = GetLight(p, n);\n    \n    vec3 color = vec3(l);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dy3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l2Xz3", "name": "Deep-ish mandelbrot zoom", "author": "Zombye", "description": "Gets to a bit under 10^20x zoom before precision issues become noticeable, though it does vary a bit.\nI think that could be improved a bit without making it much slower, but probably not by much.", "tags": ["fractal", "mandelbrot"], "likes": 9, "viewed": 258, "date": "1568276529", "time_retrieved": "2024-06-20T19:43:31.421050", "image_code": "#define AA 2\n\n#define complexMul(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n\nfloat mandelbrot(vec2 c, vec4 pc, int iterations) {\n    vec2 z = vec2(0.0);\n    int i = 0;\n\n    vec2 zlo = vec2(0.0);\n    vec2 zhi = vec2(0.0);\n    do {\n        /* standard method\n        vec2 zn;\n        zn.x = z.x * z.x - z.y * z.y;\n        zn.y = 2.0 * z.x * z.y;\n        z = zn + c;\n\n\t\tif (dot(z, z) >= exp2(8.0)) {\n            break;\n        }\n\t\t//*/\n        //* splitting z into two parts like this helps precision a lot\n        vec2 add = 2.0 * complexMul(zhi, zlo);\n        zhi = complexMul(zhi, zhi)       + pc.xy;\n        zlo = complexMul(zlo, zlo) + add + pc.zw;\n        z = zhi + zlo;\n        \n        if (dot(z, z) >= exp2(8.0)) {\n            break;\n        }\n        \n\t\t// this avoids some issues with the way z is split so you can zoom in further\n        // sometimes changing 0.5 to something else seems to help precision a bit\n        if (dot(zlo, zlo) / dot(zhi, zhi) > 0.5) {\n            zlo = vec2(0.0);\n            zhi = z;\n        }\n\t\t//*/\n    } while (++i < iterations);\n    \n    float nu = log2(log2(dot(z, z))) - 1.0;\n    return float(i) + 1.0 - nu;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = exp2(iTime);\n    //const float zoom = exp2(60.0);\n    //const float zoom = exp2(65.0);\n    //const float zoom = exp2(70.0);\n    \n    vec3 col = vec3(0.0);\n    for (int x = 0; x < AA; ++x) {\n        for (int y = 0; y < AA; ++y) {\n            vec2 o = (vec2(x, y) + 0.5) / float(AA);\n            \n            vec2 fc = fragCoord + o - 0.5;\n    \t\tvec2 c = (2.0 * fc - iResolution.xy) / iResolution.y;\n                 c = c / zoom;\n            \n            vec4 pc = vec4(vec2(-0.05026782, 0.6721055), vec2(0.7e-16, 0.0) + c);\n                 c += pc.xy;\n\n            const float tau = radians(360.0);\n            float t = mandelbrot(c, pc, 2000);\n            vec3 s = 0.5 - 0.5 * vec3(cos(t), cos(t/tau), cos(t/(tau*tau)));\n            col += s;\n        }\n    }\n    col /= float(AA * AA);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l2Xz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ljXW3", "name": "X-RaymarchingParctice001", "author": "Hirai_worthless", "description": "twinkle", "tags": ["raymarching", "phantom"], "likes": 3, "viewed": 83, "date": "1567303016", "time_retrieved": "2024-06-20T19:43:31.427183", "image_code": "float PI = 3.14159265;\nvec3 modC(vec3 p,vec3 c){\n    p = (fract(p / c + .5)-.5) * c;\n    return p;\n}\nmat2 genRot(float v){\n    return mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec2 pMod(vec2 p,float c){\n    p *= genRot(PI / c);\n    float at = mod(atan(p.y/p.x),PI * 2./c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI /c);\n    return p;\n}\nfloat map(vec3 p){\n    p.xy = pMod(p.xy,12.);\n    p = modC(p,vec3(4.,4.,1.5));\n    vec3 q = p;\n    q.x -= 1.5;\n    q = abs(q);\n    float cube = max(q.x,max(q.y,q.z)) - 0.5;\n    float sp = length(p) - 0.5;\n    float result = min(cube,sp);\n    return result;\n}\n\nfloat fog(float d){\n    return 1./(1. + d * d * 0.01);\n}\n\nvec3 getColor(vec3 p){\n    vec3 c = sin(p);\n    c = c * 0.5 + 0.5;\n    return vec3(c);\n}\n\nvec3 trace(vec3 o,vec3 r){\n    vec3 volume = vec3(0.);\n    float l = 0.05;\n    for(int i = 0; i < 512; i++){\n        vec3 p = o + r * float(i) * l;\n        float d = map(p);\n        vec3 c = getColor(p);\n        volume += clamp(l- d,0.,l) * c * fog(float(i) * l);\n    }\n    return volume;\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-1.5);\n    c += vec3(2.5 * sin(iTime/2.),2.5 * cos(iTime/2.),iTime * 2.);\n\treturn c;\n}\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    r.yz *= genRot(PI / 4.);\n    r.xy *= genRot(PI/4.-iTime / 2.);\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 uv = ( fragCoord.xy * 2. - iResolution.xy) / iResolution.y ;\n\tvec3 c = cam();\n\tvec3 r = ray(uv,1.5);\n\tvec3 color = trace(c,r);\n\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ljXW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lsSzj", "name": "Triangle experimient 2", "author": "104", "description": "three is the best number of vertices", "tags": ["2d", "geometric"], "likes": 11, "viewed": 267, "date": "1569592789", "time_retrieved": "2024-06-20T19:43:31.978710", "image_code": "\n// boilerplate ======================\nconst float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\nfloat dtoa(float d, float amount){\n    return 1. / clamp(d*amount, 1., amount);\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opXor(float lhs, float rhs) {\n    return opUnion(opIntersection(lhs, -(rhs)), opIntersection(rhs, -(lhs)));\n}\nconst float C = sqrt(3.)/3.; // dist from center to \nfloat sdEquilateralTriangle(in vec2 p)\n{\n    p.y += C; // anchor center\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n// end boilerplate ======================\n\nfloat scurve(float x, float p) {\n    x = x / p * PI2;\n    return (x + sin(x+PI)) / PI2;\n}\n\nvoid sdthing(inout float sd, inout float sd2, vec2 uv, float a, float scale) {\n    sd2 = opXor(sd2, sdEquilateralTriangle(uv*scale));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(0,-C*2.)) * rot2D(a - PI/3.)) - vec2(1.,C))));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(-1.,C)) * rot2D(a+PI)) - vec2(1.,C))));\n    sd = opXor(sd, sdEquilateralTriangle(scale*(((uv + vec2(1.,C)) * rot2D(a + PI/3.)) - vec2(1.,C))));\n}\n\nvec4 thing(vec2 uv, float s) {\n    vec2 modperiod = vec2(8., 12.*C);\n    uv = mod(uv+modperiod*.5, modperiod) - modperiod*.5;\n    \n    float t = s*iTime*.6;\n    if (s < 0.)\n    \tt = scurve(t, 1.) * .5;\n\n    float sd = 1e6, sd2=sd;\n    // bank 1\n    float seg = mod(t, 3.);\n    float a = fract(seg) * PI * 4./3.;\n    sdthing(sd, sd2, uv, a, 1.);\n    sdthing(sd, sd2, uv, a, 3.);\n    \n    // bank 2\n    uv = mod(uv + modperiod, modperiod) - modperiod*.5;\n    seg = mod(-t+.5, 3.);\n    a = fract(seg) * PI * 4./3.;\n    sdthing(sd, sd2, uv, a, 1.);\n    sdthing(sd, sd2, uv, a, 3.);\n\n    vec4 o;\n    o.rgb = dtoa(sd, 3.*vec3(400,400,20)) * .5;\n    o.rgb += dtoa(sd2, 1.*vec3(5,40,80)) * .8;\n    o = pow(o, o-o+4.);\n    o.br *= rot2D(sd*.6);\n    o = clamp(o,o-o,o-o+1.);\n    o.a = min(sd,sd2);\n    return o;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uvorig = fragCoord/iResolution.xy-.5;\n    uvorig.x *= iResolution.x / iResolution.y;\n    //uvorig.x += iTime*.1;\n    uvorig *= 8.;\n    vec2 uv = uvorig;\n\n    o = thing(uv*3., 1.) * .5;\n    o = vec4(o.r*dtoa(-o.a,40.)*.05);\n    vec4 fore = thing(uv, -1.);\n    o = mix(o, fore, dtoa(fore.a,2000.));\n        \n    vec2 N = fragCoord / iResolution.xy-.5;\n\n    o = pow(o, o-o+.5);\n    o.rgb += (hash32(fragCoord+iTime)-.5)*.08;\n    o.rgb += dot(N,N) * vec3(.2,.5,1);\n    o = clamp(o,o-o,o-o+1.);\n    o *= 1.-length(12.*pow(abs(N), vec2(4.)));// vingette\n    o.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lsSzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s33Dr", "name": "Lil' Planet", "author": "AlexWalley", "description": "Creating a planet with square to circle mapping and looped sin and cos funtions for offsets.", "tags": ["practice"], "likes": 7, "viewed": 170, "date": "1568165260", "time_retrieved": "2024-06-20T19:43:32.372593", "image_code": "\n//For square-to-circle mapping, I used:\n//https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf\n\nfloat sgn(float n){ //Used with mapping space\n\treturn abs(n)/n;\n}\n\nvec2 SquareToCircle(vec2 i){\n    return max(abs(i.x), abs(i.y)) * i / length(i);\n}\n\nvec2 FGSqircular(vec2 i){\n\n    float x2 = i.x*i.x;\n    float y2 = i.y*i.y;\n    return i*(sqrt(x2+y2-x2*y2)/length(i));\n\n}\n\n//Pseudo Random Numbers\nvec2 N22(vec2 uv){\n\tvec3 p = fract(uv.xyx*vec3(3820.43, 2183.2, 132.34));\n    p += dot(p, p+32.34);\n    return fract(vec2(p.x*p.y, p.y*p.z));\n}\n\nfloat N21(vec2 uv){\n \treturn fract(sin(uv.x*3492.32+uv.y*824.45)*32487.32);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n   \tuv *= 2.0;\n    vec3 col = vec3(0);\n    float planetMask = smoothstep(0.75, 0.70, length(uv));\n    vec2 gv = fract(uv*9.)-0.5; //Graph UV\n    vec2 id = floor(uv*9.)-0.5; //Id for each box in Graph UV\n    float t = mod(iTime, 2000.);\n    \n    vec2 p = FGSqircular(uv*2.7)+0.5;\n    //p = SquareToCircle(uv*3.0);\n    //p = uv;\n    for(float i = 1.; i < 4.; i++){ //Creates wavy effects\n    \tp.x += cos(p.y*3.*i)*0.5+0.5;\n    \tp.y += cos(p.x*2.*i+t)*0.5+0.5;\n    }\n    p /= 4.;//Normalization\n    p = max(p, 0.);\n    \n    \n    \n    //Stars\n    vec2 pos = sin(N22(id)*40.32)*0.4;\n    pos -= gv;\n    float md = abs(pos.x) + abs(pos.y); //Manhattan distance for diamond shape\n    float ed = length(pos); // Euclidean Distance\n    float randomNum = N21(id)*0.07;\n    float starBrightness = sin(randomNum*100.+t+randomNum*2308.32)*0.4+0.6;\n    col += starBrightness*smoothstep(randomNum, randomNum-0.01, md)*(1.-planetMask);\n    \n    //Planet\n    col.rgb += (p.xxx*vec3(0.9, 0.4, 0.1)*1.8+0.1)*planetMask;\n    col += 0.9*smoothstep(0.95, 0.3, dot(uv,uv))*(1.0-planetMask)*vec3(0.9, 0.4, 0.1);\n    col -= 0.2*smoothstep(0.95, 0.3, length(uv));\n    col += 0.4*smoothstep(0.5, 0.6, dot(uv,uv))*planetMask*vec3(0.9, 0.3, 0.2);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s33Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s33W8", "name": "Triangularity", "author": "gls9102", "description": "Another adaptation of my shader, http://glslsandbox.com/e#56734.2", "tags": ["triangle", "rainbow"], "likes": 15, "viewed": 243, "date": "1568282329", "time_retrieved": "2024-06-20T19:43:32.609047", "image_code": "// v1.1\n\nvec3 hsv2rgb(vec3 c) //some formula copied from the internet\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.rrr + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.rrr, clamp(p - K.rrr, 0.0, 1.0), c.y);\n}\n\nvec2 ran22(vec2 uv) {\n\treturn fract(sin(vec2(uv.x*3.2,uv.y*21.5+uv.x/3.0))*120919.4+0.6);\n}\n\nfloat triangle(vec2 uv) {\n\tvec2 pat = uv;\n\tfloat b = 1.0;\n\tpat.y *= b/2.0;\n\tpat.x = fract(uv.x+floor(uv.y*b)*0.5) < 0.5 ? -pat.x : pat.x;\n\tif ( fract(pat.x+pat.y) > 0.5 ) {\n\t\tvec2 off = ran22(floor( vec2(uv.x+fract(floor(uv.y*b)/2.0),uv.y*b))*vec2(1.12,2.02))*2.0-1.0;\n\t\treturn length(floor( vec2(uv.x+fract(floor(uv.y*b)/2.0),uv.y*b) )-vec2(fract(floor(uv.y*b)/2.0),0.0)-off);\n\t} else {\n\t\tvec2 off = ran22(floor( vec2(uv.x+fract(floor(uv.y*b+1.0)/2.0),uv.y*b))*vec2(4.011,15.32))*2.0-1.0;\n\t\treturn length(floor( vec2(uv.x+fract(floor(uv.y*b+1.0)/2.0),uv.y*b) )-vec2(fract(floor(uv.y*b+1.0)/2.0),-b/2.0)-off);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy/iResolution.x);\n\tuv -= vec2(1.0,iResolution.y/iResolution.x)/2.0;\n\tuv *= 30.0;\n\tfloat col = max(sin(triangle(uv)/3.0-iTime*3.0),0.0);\n\n\tfragColor = vec4(hsv2rgb(vec3(iTime/8.0,1.0-col/3.0,col)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s33W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s33zj", "name": "Adjoint", "author": "iq", "description": "The best way to transform the normals of an object with an arbitrary transformation matrix it to use the adjoint, not the transpose of the inverse. See comments in the shader for more info.", "tags": ["3d", "normal", "transformation", "adjoint"], "likes": 26, "viewed": 1292, "date": "1568831403", "time_retrieved": "2024-06-20T19:43:33.918236", "image_code": "// Inigo Quilez 2019\n\n// This shader shows how to use the adjoint matrix to\n// transform the normals of an object when the scale\n// is not uniform. The adjoint matrix is quicker to\n// compute than the traditional transpose(inverse(m)),\n// is more numerically stable, and does not break\n// when the matrix has negative determinant. The shader\n// uses spheres which have been deformed with non uniform\n// scales, to show the effect.\n\n// Compare methods:\n//\n// 0: n = adjoint(m)            --> correct\n// 1: n = transpose(inverse(m)) --> sometimes incorrect, and slow\n// 2: n = m                     --> always incorrect\n\n#define METHOD 0\n\n//===================================================\n\n// Use to transform normals with transformation of\n// arbitrary non-uniform scales (including negative)\n// and skewing. The code assumes the last column of m is \n// [0,0,0,1]. More info here:\n// https://github.com/graphitemaster/normals_revisited\n\nmat3 adjoint( in mat4 m )\n{\n    // 3 alternative ways to write the same thing\n    \n    return mat3(cross(m[1].xyz, m[2].xyz), \n                cross(m[2].xyz, m[0].xyz), \n                cross(m[0].xyz, m[1].xyz));\n                \n    return mat3( \n     m[1].yzx*m[2].zxy-m[1].zxy*m[2].yzx,\n     m[2].yzx*m[0].zxy-m[2].zxy*m[0].yzx,\n     m[0].yzx*m[1].zxy-m[0].zxy*m[1].yzx );\n\n    return mat3( \n     m[1][1]*m[2][2]-m[1][2]*m[2][1],\n     m[1][2]*m[2][0]-m[1][0]*m[2][2],\n     m[1][0]*m[2][1]-m[1][1]*m[2][0],\n     m[0][2]*m[2][1]-m[0][1]*m[2][2],\n\t m[0][0]*m[2][2]-m[0][2]*m[2][0],\n     m[0][1]*m[2][0]-m[0][0]*m[2][1],\n     m[0][1]*m[1][2]-m[0][2]*m[1][1],\n     m[0][2]*m[1][0]-m[0][0]*m[1][2],\n     m[0][0]*m[1][1]-m[0][1]*m[1][0] );\n}\n\n// sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\treturn (-b-sqrt(h))/a;\n}\n\n// sphere shadow\nfloat sSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n    if( b<0.0 ) return  1.0;\n    return -sign(c);\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotateAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( in vec3 v )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t v.x, v.y, v.z, 1.0 );\n}\n\nmat4 scale( in vec3 v )\n{\n    return mat4( v.x, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, v.y, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, v.z, 0.0,\n\t\t\t\t 0.0, 0.0, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 getSphereToWorld( in int i, out bool isFlipped )\n{\n    float t = iTime*0.5;\n    vec3 fli = sign(sin(float(i)+vec3(1.0,2.0,3.0)));\n    mat4 rot = rotateAxisAngle( normalize(sin(float(11*i)+vec3(0.0,2.0,1.0))), 0.0+t*1.3 );\n    mat4 ros = rotateAxisAngle( normalize(sin(float( 7*i)+vec3(4.0,3.0,5.0))), 2.0+t*1.1 );\n    mat4 sca = scale( (0.3+0.25*sin(float(13*i)+vec3(0.0,1.0,4.0)+t*1.7))*fli );\n    mat4 tra = translate( vec3(0.0,0.5,0.0) + 0.5*sin(float(17*i)+vec3(2.0,5.0,3.0)+t*1.2) );\n    \n    isFlipped = (fli.x*fli.y*fli.z) < 0.0;\n    return ros * tra * sca * rot;\n}\n\nconst int kNumSpheres = 12;\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    for( int i=0; i<kNumSpheres; i++ )\n    {\n        bool tmp;\n        mat4 objectToWorld = getSphereToWorld( i, tmp );\n        mat4 worldToObject = inverse( objectToWorld );\n        if( sSphere( ro, rd, worldToObject ) > 0.0 )\n            return 0.0;\n    }\n    return 1.0;\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, \n            in float oid, in vec3 wnor )\n{\n    vec3 lig = normalize(vec3(-0.8,0.4,0.1));\n    vec3 wpos = ro + t*rd;\n\n    // material\n    vec3  mate = vec3(0.18);\n    if( oid>1.5 ) mate = 0.18*(0.55+0.45*cos(7.0*oid+vec3(0.0,2.0,4.0)));\n\n    // lighting\n    vec3 hal = normalize( lig-rd );\n    float dif = clamp( dot(wnor,lig), 0.0, 1.0 );\n    float sha = shadow( wpos+0.01*wnor, lig );\n    float fre = clamp(1.0+dot(rd,wnor),0.0,1.0);\n    float spe = clamp(dot(wnor,hal),0.0,1.0);\n\n    // material * lighting\t\t\n    vec3 col = vec3(0.0);\n    col += 8.0*vec3(1.00,0.90,0.80)*dif*sha;\n    col += 2.0*vec3(0.10,0.20,0.30)*(0.6+0.4*wnor.y);\n    col += 1.0*vec3(0.10,0.10,0.10)*(0.5-0.5*wnor.y);\n    col += fre*(0.6+0.4*wnor.y);\n    col *= mate;\n    col += pow(spe,16.0)*dif*sha*(0.1+0.9*fre);\n\n    // fog\n    col = mix( col, vec3(0.7,0.8,1.0), 1.0-exp( -0.003*t*t ) );\n\n    return col;\n}\n        \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 0.7, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // raytrace\n        float tmin = 1e10;\n        vec3  wnor = vec3(0.0);\n        float oid = 0.0;\n\n        // raytrace plane\n        float h = (-0.5-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            wnor = vec3(0.0,1.0,0.0); \n            vec3 wpos = ro+tmin*rd;\n            oid = 1.0;\n        }\n\n        // raytrace spheres\n        for( int i=0; i<kNumSpheres; i++ )\n        {\n            // location of sphere i\n            bool isFlipped = false;\n            mat4 objectToWorld = getSphereToWorld( i, isFlipped );\n            mat4 worldToObject = inverse( objectToWorld );\n\n            float res = iSphere( ro, rd, worldToObject );\n            if( res>0.0 && res<tmin )\n            {\n                tmin = res; \n                vec3 wpos = ro+tmin*rd;\n                vec3 opos = (worldToObject*vec4(wpos,1.0)).xyz;\n                vec3 onor = normalize(opos) *(isFlipped?-1.0:1.0);\n\n                #if METHOD==0 // CORRECT\n                wnor = normalize(adjoint(objectToWorld)*onor);\n                #endif\n                #if METHOD==1 // WRONG OFTEN\n                wnor = normalize((transpose(inverse(objectToWorld))*vec4(onor,0.0)).xyz);\n                #endif\n                #if METHOD==2 // WRONG ALWAYS\n                wnor = normalize((objectToWorld*vec4(onor,0.0)).xyz);\n                #endif\n\n                oid = 2.0 + float(i);\n            }\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.7,0.8,1.0);\n        if( oid>0.5 )\n        {\n            col = shade( ro, rd, tmin, oid, wnor );\n        }\n\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s33zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3GRM", "name": "roundrect2", "author": "zhaifuqiang", "description": "roundrect", "tags": ["round"], "likes": 3, "viewed": 71, "date": "1568021802", "time_retrieved": "2024-06-20T19:43:33.918236", "image_code": "// Created by zfq - 2019-09-10\n\n// Rect radius\nfloat radius = 0.0;\n\n// Background color\nvec4 bgColor = vec4(0, 0.2, 0.0, 1);\nvec4 bgColor2 = vec4(0.2, 0.0, 0.0, 0.0);\n\nvec2 rotate (vec2 pos, float angle)\n{ \n  float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  \n}\n\n// Rounded rect distance function\nfloat udRoundRect(vec2 p, vec2 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Rect center and half size\n    vec2 center = iResolution.xy / 2.0;\n    vec2 hsize = iResolution.xy / 4.0;\n    radius = hsize[1];\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec4 contentColor = vec4(uv, 0.5 + 0.5*sin(iTime), 1.0);\n    vec2 p = rotate(fragCoord - center, -iTime / 3.0);\n        \n\n    // Mix content with background using rounded rectangle\n    float d = udRoundRect(p, hsize - radius, radius);\n    float line = 12.0;\n    float a = clamp(d/2.0, 0.0, 1.0);\n    //float a = smoothstep(0.0,1.0,d);\n    if(d <=  -line)  {\n        a  = clamp(abs(d + line)/2.0, 0.0, 1.0);\n        fragColor = mix(contentColor, bgColor2 * 0.2, a);\n        //a = smoothstep(0.0,0.45,abs(d + line)/5.0);\n    } else {\n        fragColor = mix(contentColor, bgColor, a);\n    }\n    \n\t//a = smoothstep(0.85,0.95,abs(d / line) * 1.0);\n    //a = smoothstep(0.0, 0.02, abs(d / line)/100.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3GRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3GRr", "name": "Time-rotated Gradient", "author": "ILikePizza555", "description": "Based on the music video for All My Friends by Madeon", "tags": ["gradient"], "likes": 2, "viewed": 81, "date": "1567580500", "time_retrieved": "2024-06-20T19:43:33.918236", "image_code": "float lums(vec3 rgb)\n{\n    const vec3 W = vec3(0.299, 0.587, 0.114);\n    return dot(rgb, W);\n}\n\nvec3 gradient(float t) {\n    const vec3 COLOR1 = vec3(0.788, 0.972, 0.952);\n    const vec3 COLOR2 = vec3(0.972, 0.792, 0.843);\n    \n    // Increasing the range of t to [0, 2pi], then taking cosine to get reversed gradient\n    return mix(COLOR1, COLOR2, cos(2.0 * 3.14 * t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 chan0color = texture(iChannel0, uv.xy);\n    float c0_lum = lums(chan0color.rbg);\n    \n    fragColor.rgb = gradient(mod(c0_lum + iTime / 7.0, 1.0));\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3GRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3Gzf", "name": "Spiral Waves (EPILEPSY WARNING)", "author": "evanlorim", "description": "Spiralling Waves that will make you dizzy.", "tags": ["waves", "pattern"], "likes": 2, "viewed": 105, "date": "1568937834", "time_retrieved": "2024-06-20T19:43:33.918236", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define M_2PI M_PI * 2.\n#define M_HPI M_PI / 2.\n#define M_E exp(1.)\n\nfloat amplitude = 0.0;\nfloat pshift = 0.0;\nfloat frequency = 8.0;\nfloat vshift = 0.0;\nfloat ratio = 0.5;\n\n\nfloat tri_amplitude = 1.;\nfloat tri_pshift = 0.0;\nfloat tri_frequency = 2.0;\nfloat tri_vshift = 0.0;\n\n\nfloat patternh = .36;\nfloat bandh = .08;\nfloat bandh_m_amplitude = .06;\nfloat bandh_m_frequency = .5;\nfloat amplitude_m_amplitude = .25;\nfloat amplitude_m_frequency = .125;\nfloat ratio_m_amplitude = .125;\nfloat ratio_m_frequency = .25;\nfloat pshift_m_speed = 1.;\nfloat vshift_m_speed = -.25;\n\nvec3 cB = vec3(0.0, 0.0, 0.0); //black\nvec3 cM = vec3(1.0, 0.0, 1.0); //magenta\nvec3 cC = vec3(0.0, 1.0, 1.0); //cyan\nvec3 cW = vec3(1.0, 1.0, 1.0); //white\n\nfloat tempo = .5;\n\nfloat pulse(float x) {\n\tfloat b = frequency * 1.;\n\tfloat c = pshift * 1.;\n\treturn amplitude * floor(fract((x * b) + c) - ratio) + vshift;\n\n}\n\nfloat triangle(float x) {\n\tfloat b = tri_frequency * 1.;\n\tfloat c = tri_pshift * 1.;\n\treturn tri_amplitude * abs(2.0 * fract((x * b) + c) - 1.0) + tri_vshift;\n}\n\nvec3 colorB() {\n\treturn cB;\n}\n\n\nvec3 colorW () {\n    \n    float fr = triangle(iTime*36.);\n    \n    if (fr <= .5) { return cM; }\n    else if (fr <= 1.) { return cC; } \n}\n\nvec3 colorBW(float bw) {\n\tfloat black = (bw - 1.) * -1.;\n    float white = bw;\n    vec3 blackColor = colorB().xyz * black;\n    vec3 whiteColor = colorW().xyz * white;\n    return blackColor + whiteColor;\n}\n\nfloat eval(vec2 rt) {\n\tfloat fx = (rt.x -.5) - pulse(rt.y);\n\tfloat dist = mod((rt.y - fx), patternh);\n\treturn step(dist, bandh);\n}\n\nvoid update() {\n\tbandh+=sin(iTime*bandh_m_frequency)*bandh_m_amplitude;\n    pshift+=iTime * pshift_m_speed;\n    vshift+=iTime * vshift_m_speed;\n    amplitude+=amplitude_m_amplitude*sin(iTime*amplitude_m_frequency);\n    ratio += ratio_m_amplitude*sin(iTime*ratio_m_frequency);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 pos = vec2(0.5) - (fragCoord.xy/iResolution.xy);\n\tvec2 rt = vec2(length(pos)*2.,atan(pos.y,pos.x) / M_2PI); // radius & normalized theta\n    \n\tupdate();\n    \n\tvec3 color = colorBW(eval(rt));\n\t\n\tfragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Gzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s3Gzn", "name": "Rainbow Swirl", "author": "draco_nite", "description": "Finally I made a shader that I'm proud of. One that looks sort of like I envisioned it.", "tags": ["beginner", "rainbow"], "likes": 1, "viewed": 320, "date": "1567569284", "time_retrieved": "2024-06-20T19:43:34.233557", "image_code": "#define t .005 // thickness as % of screen\n\n// Smooth HSV to RGB conversion \n// as made by iq himself\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat clampSinTime(float x)\n{\n    return (sin(iTime + x) + 1.) / 2.;\n}\n\nvec3 rainbow(vec2 uv, float curve)\n{\n    float div = step(curve, uv.x) * 2.;\n    float time = -(iTime - iTime * div) * 2.;\n    time *= 0.1;\n    \n    float hue = 2. * (uv.x - curve - time);\n    \n    if (uv.x > curve) hue = -hue;\n    \n    return vec3(hue, 1., 1.);\n}\n\nvec3 drawLine(vec2 uv, vec3 col, float curve)\n{\n    float dist = 1.025 - 3.5 * abs(curve - uv.x);\n    col.y -= dist;\n    //col += vec3(step(curve, limit + t) * step(limit - t, curve));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float waviness = sin(iTime) * 1.25;\n    float vertSinCurve = (clampSinTime(uv.y * 7.5) * .1) * waviness + .5;\n    \n    vec3 l = rainbow(uv, vertSinCurve);\n    \n    l = drawLine(uv, l, vertSinCurve);\n    l = hsv2rgb_smooth(l);\n   \n    // Output to screen\n    fragColor = vec4(l, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Gzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3D2", "name": "mera pyara gola", "author": "pratikone", "description": "learning to create a circle", "tags": ["tutorial", "circle"], "likes": 0, "viewed": 51, "date": "1569287586", "time_retrieved": "2024-06-20T19:43:34.239591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float X = fragCoord.x/iResolution.x;\n    float Y = fragCoord.y/iResolution.y;\n    uv -= 0.5; // shift base to center\n\tfloat aspect_ratio = iResolution.x/iResolution.y;\n    uv.x *= aspect_ratio; // fix for widescreen\n\n    // Output to screen\n    const float R = 0.4;\n    const float R2 = pow(R, 2.09);\n    float sign = sin(iTime);\n    vec4 innerColor = vec4(\n        \t\t\t\t\tclamp(0., 1.,\n                                  sin(fragCoord.y + abs(sin(10.*iTime)))), // only take 0-1 sin values and ignore -1,0 values\n        \t\t\t\t\t0., 0., 1.);\n    vec3 changingColor = 1. + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    innerColor = mix(vec4(changingColor, 1.), innerColor, 0.6);\n\n    const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float sum = length(uv);\n    if (sum < R )\n    {\n        fragColor = innerColor;\n    }\n    else\n    {\n        fragColor = black;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3D2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3Df", "name": "neontest2", "author": "Del", "description": "neon test 2", "tags": ["wobble", "sin", "cos", "neon"], "likes": 5, "viewed": 567, "date": "1569357393", "time_retrieved": "2024-06-20T19:43:34.239591", "image_code": "// Neon pattern test\n// + wobble\n\n#define PI 3.1415926\n\nfloat pat(vec2 uv,float p,float q,float s,float glow)\n{\n    float z = cos(q * PI * uv.x) * cos(p * PI * uv.y) + cos(q * PI * uv.y) * cos(p * PI * uv.x);\n\n    z += sin(iTime*4.0 + uv.x+uv.y * s)*0.035;\t// +wobble\n    float dist=abs(z)*(1.0/glow);\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = pat(uv, 5.0, 2.0, 35.0, 0.35);\t\t// layer1\n    if (iMouse.z>0.5)\n    \td *= pat(uv, 1.0, 4.0, 55.0, 0.45);\t\t// layer2\n    \n    vec3 col = vec3(0.25,0.45,1.25)*0.5/d;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3Df.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3Dj", "name": "Infinite Reflecting Spheres", "author": "Not_Sean", "description": "Infinite spheres with a single reflection", "tags": ["raymarching", "infinite"], "likes": 1, "viewed": 107, "date": "1569271594", "time_retrieved": "2024-06-20T19:43:34.239591", "image_code": "#define FOV 0.9\n#define EPSILON 0.00001\n\n#define MAX_STEPS 70.\n#define MAX_DIST 40.\n#define REFLECTIONS 30.\n\n#define SPACING 2.\n\n#define multisample\n\n#define CELL_SHADER 0.03\n\nfloat sdf(in vec3 p, float spacing)\n{\n    float dist = length(mod(p, spacing) - .5 * spacing) - .5;\n    return dist;\n}\n\nvec3 estimateNormal(vec3 p, float spacing) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z), spacing) - sdf(vec3(p.x - EPSILON, p.y, p.z), spacing),\n        sdf(vec3(p.x, p.y + EPSILON, p.z), spacing) - sdf(vec3(p.x, p.y - EPSILON, p.z), spacing),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON), spacing) - sdf(vec3(p.x, p.y, p.z - EPSILON), spacing)\n    ));\n}\n\nfloat darkness(float t) \n{\n    return pow(2., - 0.07 * t);\n}\n\nvec3 marchOne(in vec3 p, in vec3 dir, float spacing)\n{\n    vec3 color = vec3(0, 0, 0);\n    \n    float t = 0.;\n    for (float r = 0.; r <= REFLECTIONS; r++)\n    {\n        float minDist = 100000.;\n        for (float i = 0.; i < MAX_STEPS; i++)\n        {\n            float dist = sdf(p, spacing);\n\n            if (abs(dist) < 0.001) {\n                vec3 normal = estimateNormal(p, spacing);\n\n                p -= 0.3 * dir;\n\n                dir = dir - (2.0 * normal * (dot(normal, dir)));\n                \n                vec3 cell3 = mod(ceil (p / spacing), 2.);\n                float cell = cell3.x + cell3.y + cell3.z;\n\n                color += 1.4 * pow(.5, r + 1.) * vec3(0.9 - 0.2 * cell, 0.3 + 0.2 * mod(cell + 1., 2.), 0.2 + 0.3 * cell) * darkness(t);\n\n                break;\n            }\n\n            p += dir * dist;\n            t += dist;\n\n            if (\n                #ifdef CELL_SHADER\n                (minDist < dist && minDist < CELL_SHADER) || \n                #endif\n                t > MAX_DIST)\n            {\n                return .5 * color;\n            }\n\n            minDist = min(dist, minDist);\n        }\n    }\n    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 samplePixel(mat4 view, vec3 center, vec2 uv, float spacing)\n{\n    vec4 pixDir = view * normalize(vec4(FOV * uv, 1, 0));\n    \n    return marchOne(center, pixDir.xyz, spacing);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.xx;\n    float pixelStep = 2. / iResolution.x;\n    \n    vec3 eye = vec3(1, cos(iTime * .12), sin(iTime * .06));\n    vec3 center = vec3(0., 0., 0.);\n    vec3 up = vec3(0, 1, 0);\n    \n    mat4 view = viewMatrix(eye, center, up);\n    \n    float spacing = SPACING * (1. + pow(sin(iTime), 2.) * (pow(sin(iTime * 0.1), 2.) + 0.1) * 0.2);\n    \n    vec3 c1 = samplePixel(view, center, uv, spacing);\n    \n    #ifdef multisample\n    vec3 c2 = samplePixel(view, center, uv + vec2(pixelStep, pixelStep) * .5, spacing);\n    vec3 c3 = samplePixel(view, center, uv + vec2(0, pixelStep) * .5, spacing);\n    vec3 c4 = samplePixel(view, center, uv + vec2(pixelStep, 0) * .5, spacing);\n    \n    vec3 col = c1 + c2 + c3 + c4;\n    col *= .25;\n    # else\n    vec3 col = c1;\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3Dj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3Rr", "name": "infinite Sierpinski carpet", "author": "DarkKiwi", "description": "This is my first attempt in shadertoy", "tags": ["fractal"], "likes": 2, "viewed": 116, "date": "1567594911", "time_retrieved": "2024-06-20T19:43:34.239591", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (2.0 + mod(iTime, 4.0));\n\n    int x = int(uv.x);\n    int y = int(uv.y);\n    for (int i = 0; i < 60; i++)\n    {\n        \n     \tif(x % 3 == 1 && y % 3 == 1)\n        {\n            fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n            return;\n        }\n        x = x / 3;\n        y = y / 3;\n        \n    }\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3Rs", "name": " - Quicky#013", "author": "totetmatt", "description": " ", "tags": ["quicky"], "likes": 1, "viewed": 293, "date": "1569066608", "time_retrieved": "2024-06-20T19:43:34.239591", "image_code": "float hash(vec2 p) {\n\n    p = fract(p*vec2(232.3414,389.264));\n    p += dot(p.yx,p+325.45);\n    return fract(p.x * p.y);\n    \n    \n    \n    \n}\nmat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=(length(uv)-2.)*r(iTime/4.+cos(iTime/2.)*2.)*5.;\n   uv.x+=-iTime;\n    vec2 id = floor(uv);\n\n    vec2 guv= fract(uv+iTime)-.5;\n         \n    guv *= r(hash(id)*2.);\n    \n\n    \n      \n    vec2 q = (guv +.0) ;\n    float d = 0.;\n    d = mix(\n     max(smoothstep(0.041,0.04,abs(dot(q.x,q.y))),step(0.4,length(guv))),\n     min(smoothstep(0.041,0.04,abs(dot(q.x,q.y))),step(0.4,length(guv))),\n     hash(id)\n     );\n    \n    \n\n    \n    vec3 col =  vec3(d,d*hash(id),d*hash(vec2(hash(id))));\n    fragColor = vec4( \n        col,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3Rs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sc3z4", "name": "GLSL ray tracing test", "author": "colin299", "description": "you can drag left/right to control roughness\nopen using CineShader: https://cineshader.com/view/3sc3z4", "tags": ["raytracing", "cineshader"], "likes": 37, "viewed": 96567, "date": "1567869303", "time_retrieved": "2024-06-20T19:43:35.148647", "image_code": "//drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 9999.0; //default value if can't hit anything\n\n    for(int i = 0; i < SPHERECOUNT; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < MAX_BOUNCE; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit at start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n               \n        //if ray can't hit anything, rayLength will remain default value 9999.0\n        //which enters this if()\n        //** 99999 is too large for mobile, use 9900 as threshold now **\n        if(h.rayLength >= 9900.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= AVERAGECOUNT; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sc3z4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scGD4", "name": " birdInAcage", "author": "foran", "description": "birdInAcage", "tags": ["birdinacage"], "likes": 1, "viewed": 66, "date": "1568476926", "time_retrieved": "2024-06-20T19:43:35.148647", "image_code": "#define PI 3.14159\n#define TAU 2. * PI\n\nvec3 lookAt (vec3 eye, vec3 at, vec2 uv) \n{\n  vec3 forward = normalize(at - eye);\n  vec3 right = normalize(cross(forward, vec3(0,1,0)));\n  vec3 up = normalize(cross(right, forward));\n  return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 modA(vec2 p, float r)\n{\n  float a = atan(p.y,p.x);\n\n  a = mod(a + PI, TAU/r) - PI;\n\n  return length(p) * vec2(cos(a),sin(a));\n}\n//----------\nfloat smin(float a,float b,float k)\n{\n  float h=clamp(.5+.5*(b-a)/k,0.,1.);\n  return mix(b,a,h)-k*h*(1.-h);\n}\n//-----------\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat ease(float t)\n{\n  return floor(t) + sin(fract(t) * PI - PI / 2.) * .5 + .5;\n}\n\nfloat map(vec3 p)\n{\n  float dist = 1000.;\n  //------------\n  vec3 cp=p;\n  float ti=iTime;\n for(float i=1.;i<5.;++i)//     5\n {\n    cp.y+=iTime*.0315;//   p.y-,  p.y+\n    cp.y+=(sin(ti+cp.x)+cos(ti+cp.z))*1.13;//  \n    dist=smin(length(cp)-1.285,dist,1.25);//    \n    ti+=i*.2;\n    cp*=.99;// FOV   - 1.1\n    cp.xz*=rot(ti*.3);//    xz\n    cp.yz*=rot(ti*.3);//    yz\n    cp.x+=.6;\n }\n //-----------\n\n  float ra = sin(p.y) * .55 + .45 + .2;//   y\n  p.y -= iTime;//   p.y-,  p.y+\n  p.xz *= rot(p.y * .5);\n  p.xz = modA(p.xz, 5.);//   3.\n  p.z += 3.;//    z\n  p.x += 4.5;//    x\n  float cy = length(p.xz) - ra;\n  dist = min(dist, cy);\n  \n  return dist;\n}\n\n  float cd = 0.;\n  vec3 outPos;\n  float ray(vec3 cp, vec3 rd)\n{\n  float st = 0.;\n  for(;st < 1.; st += 1./ 64.)\n  {\n    cd = map(cp);\n    if(cd < .01) break;\n    cp += rd * cd * .5;\n  }\n\n  outPos = cp;\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n\n  return normalize(vec3(\n  map(p - e.xyy) - map(p + e.xyy),\n  map(p - e.yxy) - map(p + e.yxy),\n  map(p - e.yyx) - map(p + e.yyx)\n  ));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n  \n //----------------\n vec3 eye = vec3(0.,0.,-20.);\n vec3 rd = lookAt(eye, vec3(0.), uv);\n vec3 cp = eye;\n float st = ray(cp,rd);\n vec3 norm = normal(outPos);\n vec3 ld=normalize(vec3(-.5,-1.,1.));\n ld.xz*=rot(iTime*.1);\n float li = dot(norm, vec3(-1.,-1.,1.));//    \n float li2=dot(normalize(vec3(1.,0.,1.)),norm);//   2\n float f=pow(max(li,li2),2.);\n f=sqrt(f);\n vec4 col=vec4(norm,0.);\n col.xy*=rot(iTime*.5);\n col.yz*=rot(iTime*.75);\n col.xz*=rot(iTime*.125);\n col=abs(col);\n vec4 out_color=vec4(1.);\n out_color=mix(vec4(0.),col*1.5,f);\n fragColor=vec4(out_color);\n //-----------\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scGDr", "name": "ChaosGame", "author": "Saturos", "description": "dynamic chaos game", "tags": ["fractal", "game", "interactive", "chaos", "dynamic", "transform"], "likes": 0, "viewed": 74, "date": "1568424704", "time_retrieved": "2024-06-20T19:43:35.148647", "image_code": "const float TWO_PI  = 6.283185307;\nconst int n_vertices = 5;\nvec2 cs, nm, polygon[n_vertices];\nint maxIter = 500;\nfloat factor, thresh = 0.008;\nmat2 M;\n\nfloat rand(float seed) {\n    return fract(sin(seed*dot(cs, vec2(5.9351794792968, 4.947297863284)))*43758.5453);\n}\n\nvoid defPolygon() {\n    float theta = TWO_PI / float(n_vertices);\n    for (int i=0; i<n_vertices; ++i) {\n        float iTheta = float(i)*theta + iTime;\n    \tfloat st = sin(iTheta), ct = cos(iTheta);\n        polygon[i] = .55*mat2(st,ct,-st,ct)*vec2(1.,0.);\n    }\n}\n\nbool shouldDraw() {\n    vec2 p = vec2(0,0);\n    for (int i=0; i<maxIter; ++i) {\n        if (distance(p, cs) < thresh && i>10) return true;\n        vec2 randVert = polygon[int(rand(float(i))* float(n_vertices))];\n        p += factor*(randVert-p + M*p);\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    cs = fragCoord/iResolution.xy * 2. - 1.;\n    nm = vec2(0.12 + 0.2*(sin(iTime)+1.));\n    //nm = iMouse.xy/iResolution.xy;\n    factor = nm.x + 0.5;\n    M = nm.y*mat2(cs.y, cs.x, -cs.y, cs.x);\n    defPolygon();\n    \n    fragColor = shouldDraw() ? vec4(1,1,0,1) : vec4(vec3(0.1),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scGW4", "name": "Inigo Quilez tutorial", "author": "victorqribeiro", "description": "following Inigo Quilez livre stream on youtube", "tags": ["inigoquilez"], "likes": 2, "viewed": 336, "date": "1568468978", "time_retrieved": "2024-06-20T19:43:35.148647", "image_code": "#define PI 3.14159\n\nvec2 map(in vec3 pos ){\n      \n    float sphere = length(pos-vec3(0.,abs(sin(iTime*2.)),0.)) - 0.25;\n    \n    float result = sphere;\n    float id = 1.0;\n\n    float sphere2 = length(pos-vec3(1.,abs(sin(iTime*2.+PI/2.)),0.)) - 0.25;\n    \n    if( sphere2 < result ){\n        result = sphere2;\n    \tid = 2.0;\n    }\n    \n    float plane = pos.y - (-0.25);\n    \n    if( plane < result ){\n     \tresult = plane;\n        id = 3.0;\n    }\n   \n    return vec2(result, id);\n}\n\nvec3 calcNormal(in vec3 pos){\n    vec2 e = vec2(0.0001, 0.);\n\treturn normalize(\n    \tvec3(\n            map(pos+e.xyy).x-map(pos-e.xyy).x,\n            map(pos+e.yxy).x-map(pos-e.yxy).x,\n            map(pos+e.xyx).x-map(pos-e.xyx).x\n        )\n    );\n}\n\nvec2 castRay(in vec3 ro, vec3 rd){\n    float t = 0., id = 0.;\n    for(int i = 0; i < 100; i++){\n    \tvec3 pos = ro + t * rd;\n        \n        vec2 object_id = map( pos );\n        \n        float object = object_id.x;\n        \n        id = object_id.y;\n        \n        if( object < 0.0001 ) break;\n        \n        t += object;\n        \n        if( t > 20. ) break;\n    }\n    \n    if( t > 20.0 ) \n        t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float an = iTime/4.;\n \n    //camera pos\n    vec3 ro = vec3(2.*sin(an), 0, 2.*cos(an));\n    \n    //camera look at\n    vec3 ta = vec3(0,.25,0);\n    \n    // wuv coordinates\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5* ww );\n    \n    //sky color with gradient\n    vec3 col = vec3(0.6, 0.7, 0.8) - 0.5 * rd.y;\n    \n    //horizon\n    col = mix( col, vec3(0.7,0.75,0.8), exp(-10.0*rd.y) );\n    \n    vec2 result = castRay( ro, rd );\n    \n    float t = result.x;\n    \n    float id = result.y;\n    \n    if( t > 0. ){\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate;\n        \n        if( id < 1.5 ){\n            mate = vec3(0.18);\n        }else if( id < 2.5 ){\n            mate = vec3(.8);\n        }else{\n         \tmate = vec3(0.02,0.2,0.02);\n        }\n        \n        \n        vec3  sun_dir = normalize( vec3(0.8, 0.4, 0.2) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0, 1.0  );\n        float sun_sha = step( castRay( pos+nor*0.001, sun_dir ).x, 0.0);\n        float sky_dif = clamp( .5 + .5 * dot(nor,vec3(0,1,0)), 0., 1. );\n        float bou_dif = clamp( .5 + .5 * dot(nor,vec3(0,-1,0)), 0., 1. );\n        \n        //sun ligth + sun shadows\n        col  = mate*vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha;\n        \n        //sky indirect light\n        col += mate*vec3(0.5, 0.8, 0.9) * sky_dif;\n            \n        //bounce light\n        col += mate*vec3(0.7, 0.3, 0.2) * bou_dif;\n    }\n    \n    //gamma correction\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scGW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3scGWM", "name": "Parallax Truchet", "author": "Jordan", "description": "Just my go of following this Truchet tutorial https://www.youtube.com/watch?v=2R7h76GoIJM&t=1990s , then adding parallax layers and color. This is my first shader. \n\nVersion 2, with perpendicular junctions: https://www.shadertoy.com/view/3ddGW7", "tags": ["2d", "lines", "colorful", "parallax", "truchet", "maze", "pipes"], "likes": 17, "viewed": 686, "date": "1568624813", "time_retrieved": "2024-06-20T19:43:35.148647", "image_code": "// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 3\n\nfloat rand(vec2 p)\n{\n    p = fract(p*vec2(234.51,124.89));\n    p += dot(p,p+54.23);\n    p = fract(p*vec2(121.80,456.12));\n    p += dot(p,p+25.12);\n    return fract(p.x);\n}\n\nfloat width = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    \n    vec2 pos = 5.*vec2(sin(iTime*0.2)+0.1*iTime,cos(iTime*0.2)+0.1*iTime);\n    vec3 col = vec3(0.);//0.5 + 0.5*cos(iTime+(fragCoord/iResolution.xy).xyx+vec3(0,2,4));\n    \n    for(float i=5.;i<10.;i+=1.)\n    {\t\n        vec2 uv = pos+((20.-1.8*i)*(fragCoord-.5*iResolution.xy)/iResolution.y);\n        vec2 gv = (fract(uv)-0.5);\n        vec2 id = floor(uv);\n        vec3 col2 = (0.5 + 0.2*sin(iTime+(i/2.)+0.3*uv.xyx+vec3(0,2,4))*sin(iTime+(i/2.)+0.3*uv.xyx+vec3(0,2,4)) + 0.5*cos(iTime+(i/2.)+0.3*uv.xyx+vec3(0,2,4)))*(i+1.)/11.;\n\n        gv.x *= (float(rand(id*i)>0.5)-0.5)*2.;\n\n        float mask1 = smoothstep(-0.01,0.01,width-abs(gv.x+gv.y-0.5*sign(gv.x+gv.y+0.01)));\n\t\tfloat mask2 = smoothstep(-0.2,0.2,width-abs(gv.x+gv.y-0.5*sign(gv.x+gv.y+0.01)));\n\n        // Output to screen\n        col = - 0.3*mask2 + 0.5*(col2.r*col2.r+col2.g*col2.g+col2.b*col2.b + col2*col2)*col2*mask1 + col*(1.-mask1);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3scGWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sdGzH", "name": "fishing", "author": "foran", "description": "fishing", "tags": ["fishing"], "likes": 4, "viewed": 85, "date": "1567792768", "time_retrieved": "2024-06-20T19:43:35.154499", "image_code": "\nfloat map(vec3 p) \n{\n  float d = cos(p.x)+cos(p.y*.5)+cos(p.z)+cos(p.y*20.+iTime)*.1+texture(iChannel1,p.xy*.91).r*1.+texture(iChannel1,p.xy*.91).r*1.75;//    \n  //float d = cos(p.x) + sin(p.y)  + 0.1 * sin(12.0 * p.z + 0.1)  + cos(p.z);//                        \n  return min (d, length(p.xy + 0.05 * vec2(0.2 + cos(p.z), - 8.0 + sin(p.z)) - 0.05)) ;//              \n}\n\nvec3 rm(vec3 ro, vec3 rd)\n{\n  vec3 p = ro;\n  for (int i = 0 ; i < 25; ++i)\n   {\n      p += map(p) * rd * .8;\n    } \n  return p;\n}\n\nvec3 grad(vec3 p)\n{\n vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3 \n (\n    map(p + e.xyy) - map(p - e.xyy),\nmap(p + e.yxy) - map(p - e.yxy),\nmap(p + e.yyx) - map(p - e.yyx)\n));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n\n  vec3 ro = vec3(0.0, 1.0, 2.0 * iTime + 10.0);\n  vec3 rd = normalize(vec3(uv, 0.7 - length(uv)));\n\n  vec3 p = rm(ro, rd);\n\n  float s = exp(-distance(ro, p) * 0.1);\n  vec3 color = vec3(s);\n  vec3 n = grad(p);\n  color *= (n * .75 + 0.5).xzy;\n\n  vec3 p2 = rm(p + n * 0.1, reflect(rd, n));\n  vec3 n2 = grad(p2);\n   float s2 = exp(-distance(ro, p) * 0.1);\n  vec3 color2 = exp(-distance(ro, p) * 0.1) * (n2 * 0.5 + 0.5);\n  color = mix(color, color2, 0.1);\n  vec4 out_color=vec4(1.);\n  out_color = vec4(color, 1.0);\n  fragColor=vec4(out_color);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sdGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGRz", "name": "Lumpy Elongated Gutted Object", "author": "adurdin", "description": "Its a lego brick! It seemed a fitting subject for learning raymarching sdfs and csg.", "tags": ["3d", "raymarching", "sdf", "lego"], "likes": 3, "viewed": 325, "date": "1569599356", "time_retrieved": "2024-06-20T19:43:37.179297", "image_code": "// Lighting and camera stuff from https://www.shadertoy.com/view/lt33z7\n// SDF primitives from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// NOTE: modified from iq's, because his seems to have b be halfsize, not size!\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - 0.5*b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF2(vec3 p, vec3 b) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - b;\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n// NOTE: modified from iq's, because his seemed to have radius doubled, and\n// height doubled too!?\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-ra+rb, abs(p.y) - 0.5*h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// NOTE: modified from iq's, because his seemed to have height and radius swapped,\n// and height doubled!?\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,0.5*h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// ---------------------------------------------------\n\nfloat sdIntersect(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat sdUnion(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat sdDifference(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// ---------------------------------------------------\n\nfloat sdStud(vec3 p, vec3 brickSize, float x, float z)\n{\n    float studRadius = 2.4;\n    float studHeight = 1.8;\n    vec3 studOrigin = vec3(0.0, 0.5*studHeight + 0.5*brickSize.y, 0.0);\n    return sdRoundedCylinder(p - studOrigin + vec3(x*4.0, 0.0, z*4.0),\n        studRadius, 0.1, studHeight);\n}\n\nfloat sdStudHollow(vec3 p, vec3 brickSize, float x, float z)\n{\n    float radius = 1.3;\n    float height = 1.7;\n    vec3 origin = vec3(0.0, 0.5*height + 0.5*brickSize.y - 1.01, 0.0);\n    return sdCappedCylinder(p - origin + vec3(x*4.0, 0.0, z*4.0), radius, height);\n}\n\nfloat sdButtressZ(vec3 p, vec3 brickSize, float z)\n{\n    float buttWidth = 0.6;\n    float buttDepth = 0.4;\n    return sdCube(\n        p - vec3(0.0, 0.0, z*(0.5*brickSize.z-1.2)),\n        vec3(buttWidth, brickSize.y, buttDepth)\n        );\n}\n\nfloat sdButtressX(vec3 p, vec3 brickSize, float x, float z)\n{\n    float buttWidth = 0.6;\n    float buttDepth = 0.4;\n    return sdCube(\n        p - vec3(x*(0.5*brickSize.x-1.2), 0.0, z*4.0),\n        vec3(buttDepth, brickSize.y, buttWidth)\n        );\n}\n\nfloat sdSupport(vec3 p, vec3 brickSize, float z)\n{\n    float radius = 3.255;\n    float height = brickSize.y;\n    return sdCappedCylinder(p - vec3(0.0, 0.0, z*4.0), radius, height);\n}\n\nfloat sdSupportHollow(vec3 p, vec3 brickSize, float z)\n{\n    float radius = 2.4;\n    float height = brickSize.y;\n    return sdCappedCylinder(p - vec3(0.0, -1.0, z*4.0), radius, height);\n}\n\nfloat sceneSDF(vec3 p) {\n    vec3 brickSize = vec3(15.8, 9.6, 31.8);\n    float brickBody = sdDifference(\n        sdCube(p, brickSize),\n        sdCube(p - vec3(0.0, -1.0, 0.0), brickSize - vec3(2.4, 0.0, 2.4))\n        );\n    float crossBeam = sdCube(p - vec3(0.0, 1.65-0.1, 0.0), vec3(13.8, 9.6-3.3, 0.8));\n    float studs = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdStud(p, brickSize, 1.0, -3.0),\n                sdStud(p, brickSize, 1.0, -1.0)\n            ),\n            sdUnion(\n                sdStud(p, brickSize, 1.0, 1.0),\n                sdStud(p, brickSize, 1.0, 3.0)\n            )\n        ),\n        sdUnion(\n            sdUnion(\n                sdStud(p, brickSize, -1.0, -3.0),\n                sdStud(p, brickSize, -1.0, -1.0)\n            ),\n            sdUnion(\n                sdStud(p, brickSize, -1.0, 1.0),\n                sdStud(p, brickSize, -1.0, 3.0)\n            )\n        )\n    );\n    float studHollows = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdStudHollow(p, brickSize, 1.0, -3.0),\n                sdStudHollow(p, brickSize, 1.0, -1.0)\n            ),\n            sdUnion(\n                sdStudHollow(p, brickSize, 1.0, 1.0),\n                sdStudHollow(p, brickSize, 1.0, 3.0)\n            )\n        ),\n        sdUnion(\n            sdUnion(\n                sdStudHollow(p, brickSize, -1.0, -3.0),\n                sdStudHollow(p, brickSize, -1.0, -1.0)\n            ),\n            sdUnion(\n                sdStudHollow(p, brickSize, -1.0, 1.0),\n                sdStudHollow(p, brickSize, -1.0, 3.0)\n            )\n        )\n    );\n    float buttresses = sdUnion(\n        sdUnion(\n            sdUnion(\n                sdUnion(\n                    sdButtressX(p, brickSize, 1.0, -3.0),\n                    sdButtressX(p, brickSize, 1.0, -1.0)\n                ),\n                sdUnion(\n                    sdButtressX(p, brickSize, 1.0, 1.0),\n                    sdButtressX(p, brickSize, 1.0, 3.0)\n                )\n            ),\n            sdUnion(\n                sdUnion(\n                    sdButtressX(p, brickSize, -1.0, -3.0),\n                    sdButtressX(p, brickSize, -1.0, -1.0)\n                ),\n                sdUnion(\n                    sdButtressX(p, brickSize, -1.0, 1.0),\n                    sdButtressX(p, brickSize, -1.0, 3.0)\n                )\n            )\n        ),\n        sdUnion(\n            sdButtressZ(p, brickSize, 1.0),\n            sdButtressZ(p, brickSize, -1.0)\n        )\n    );\n    float supports = sdUnion(\n        sdSupport(p, brickSize, 0.0),\n        sdUnion(\n            sdSupport(p, brickSize, -2.0),\n            sdSupport(p, brickSize, 2.0)\n        )\n    );\n    float supportHollows = sdUnion(\n        sdSupportHollow(p, brickSize, 0.0),\n        sdUnion(\n            sdSupportHollow(p, brickSize, -2.0),\n            sdSupportHollow(p, brickSize, 2.0)\n        )\n    );\n    float brick = sdDifference(\n        sdUnion(\n            sdUnion(\n                brickBody,\n                crossBeam\n            ),\n            sdUnion(\n                buttresses,\n                supports\n            )\n        ),\n        sdUnion(\n            studHollows,\n            supportHollows\n        )\n    );\n    return sdUnion(brick, studs);\n}\n\n// ---------------------------------------------------\n\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define MAX_MARCHING_STEPS 255\n#define EPSILON 0.0001\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z))\n            - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z))\n            - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON))\n            - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 n, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(36.0, 24.0, 36.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, n, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-24.0, -24.0, -24.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, n, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nstruct raymarch_result {\n    float depth;\n    int steps;\n};\n\nraymarch_result raymarch(\n    vec3 eye, vec3 direction, float start, float end)\n{\n    raymarch_result result;\n    float depth = start;\n    int stepCount = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        stepCount = i;\n        float dist = sceneSDF(eye + depth * direction);\n        if (dist < EPSILON) {\n            result.depth = depth;\n            result.steps = stepCount;\n            return result;\n        }\n        depth += dist;\n        if (depth >= end) {\n            result.depth = end;\n            result.steps = stepCount;\n            return result;\n        }\n    }\n    result.depth = end;\n    result.steps = stepCount;\n    return result;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime;\n    float fov = 80.0;\n    vec3 dir = rayDirection(fov, iResolution.xy, gl_FragCoord.xy);\n    float cameraDistance = 100.0;\n    float cameraSpeed = 0.5;\n    vec3 eye = vec3(\n        0.5*cameraDistance * sin(cameraSpeed*time),\n        cameraDistance / 1.5 * sin(1.5*cameraSpeed*time),\n        0.5*cameraDistance * cos(cameraSpeed*time)\n        );\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    raymarch_result result = raymarch(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (result.depth > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n\n    vec3 p = eye + result.depth * worldDir;\n    vec3 n = estimateNormal(p);\n\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(1.0, 0.0, 0.0);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 30.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, n, eye);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sKGz1", "name": "Psychodelic_Caleidoscope ", "author": "sirArthurDayne", "description": "Well this is my first post in ShaderToy and also working with shaders.\nThis code was originally wrote in Visual Studio and my OpenGL setup. I like the result so i decided to post it here.\nHope someone like it!! Feel free to modify it whatever you want", "tags": ["2d", "caleidoscope", "2dcaleidoscope"], "likes": 4, "viewed": 331, "date": "1569729809", "time_retrieved": "2024-06-20T19:43:37.900455", "image_code": "\n#define PI 3.141592\n#define TAU (2.0*PI)\n\n\nvec2 ConvertToPolar(vec2 rectCoord)\n{\n    //vectors becomes: magnitude, angle\n    return vec2(length(rectCoord), atan(rectCoord.y, rectCoord.x));\n}\n\nvec2 ConvertToRect(vec2 polarCoord)\n{\n    return vec2(polarCoord.x * cos(polarCoord.y), polarCoord.x * sin(polarCoord.y));\n}\n\nvec3 ColorTransition(vec3 colorA, vec3 colorB)\n{\n    float pct = abs(sin(iTime))/2.0;\n\n    return vec3(mix (colorA, colorB, pct));\n}\n\n\nvec2 pMod2(inout vec2 p, vec2 size) \n{\n    vec2 c = floor((p + size * 0.5) / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\nfloat DistanceCircle(float radius, vec2 origin)\n{\n    return length(origin) - radius;\n}\n\nfloat DistanceRoundedBox(float radius, vec2 origin)\n{\n    /*the more pow increment the less rounded the box is*/\n    origin = origin * origin;\n    origin = origin * origin;\n    float d8 = dot(origin, origin);\n    return pow(d8, 1.0 / 8.0) - radius;\n}\n\nfloat DistanceBox(vec2 size, vec2 origin)\n{\n    origin = abs(origin);\n    float dx = 2.0*origin.x - size.x;\n    float dy = 2.0*origin.y - size.y;\n    return max(dx, dy);\n}\n\nfloat DrawMotionOne(vec2 position)\n{\n    position = abs(position);\n    vec2 p_position = ConvertToPolar(position);\n    p_position.y += position.x * sin(iTime);//rotation\n    p_position.x *= 1.0 + position.y;//mod radius\n    position = ConvertToRect(p_position);\n    float distanceThree = DistanceBox(vec2(0.5, 0.5), position + vec2(0.0));\n    return distanceThree;\n}\n\nfloat DrawCaleidoscopeSimple(vec2 position, float times)\n{\n    vec2 p_pos = ConvertToPolar(position);\n    p_pos.y = mod(p_pos.y, TAU / times);\n    p_pos.y += iTime;\n    position = ConvertToRect(p_pos);\n    pMod2(position, vec2(0.5));\n    float d1 = DistanceCircle(0.2, position);\n    float d2 = DistanceBox(vec2(0.2), position - vec2(0.1));\n    return min(d1, d2);\n}\n\nfloat DrawCaleidoscopeEffect(vec2 position, float times, vec2 size)\n{\n    vec2 p_pos = ConvertToPolar(position);\n    float beta = TAU / times;\n    float np = p_pos.y / beta;\n    p_pos.y = mod(p_pos.y, beta);\n    float m2 = mod(np, 2.0);\n    if (m2 > 1.0)\n    {\n        p_pos.y = beta - p_pos.y;\n    }\n    p_pos.y += iTime;\n    position = ConvertToRect(p_pos);\n\n    //make repeating patron\n    pMod2(position, size);\n\n    float d1 = DistanceCircle(0.1, position);\n    float d2 = DistanceBox(vec2(0.1), position - vec2(0.1));\n    return min(d1, d2);\n}\n//post processing methods\nvoid Rotation(inout vec2 position, float angle)\n{\n    position = vec2(position.x * cos(angle) + position.y * sin(angle), \n        -position.x * sin(angle) + position.y * cos(angle));\n}\n\nvec3 ChangeSaturation(vec3 color, vec2 position)\n{\n    Rotation(position, iTime);\n    color = clamp(color, 0.0, 1.0);\n    return pow(color, vec3(length(position)));//more saturate at borders\n    \n    //return pow(color, vec3(1.0 /length(position)));//more saturate at center\n    //saturate roullete\n    //return pow(color, vec3(abs(position.x)/ length(position), abs(position.y)/ length(position),length(position)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 crimson =  vec3(0.7, 0.02, 0.23);\n    vec3 elecgreen = vec3(0.04, 1.0, 0.16);\n    vec3 outputColor = vec3(0.0);\n\n    //setup scaling and origin pos\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    //uv.y *= iResolution.x / iResolution.y;\n    \n\n    \n    vec2 offset = uv;\n    Rotation(offset, iTime);\n\n    float distance = DrawCaleidoscopeEffect(uv-offset, 25.0, vec2(0.5));\n    float md = mod(distance, 0.1);\n    float nd = abs(distance / 0.1) ;\n\n    if (abs(distance) < 0.1)\n    {\n        outputColor = ColorTransition(crimson, elecgreen);\n    }\n    \n    if (abs(md) < 0.01)\n    {\n        outputColor = (distance < 0.0) ? crimson / nd : elecgreen / nd;\n    }\n    \n    //apply postProccessing before outputing \n    \n    fragColor = vec4(ChangeSaturation(outputColor, uv), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sKGz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3DH", "name": "weird shapes", "author": "thefox231", "description": "use mouse to control it a little bit\ni have no clue what this is", "tags": ["2d", "simple", "shapes"], "likes": 3, "viewed": 294, "date": "1568395662", "time_retrieved": "2024-06-20T19:43:37.900455", "image_code": "#define PI 3.1415926538\n#define thickness 0.01\n\nfloat cubex = -0.8;\nfloat cubey = -0.8;\n\nbool looseEquals( float value1, float value2 )\n{\n    return value1-thickness < value2 && value1+thickness > value2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y * PI;\n     \n    uv.x += cos(iTime+uv.y*uv.x-iMouse.x/50.0);\n    uv.y += cos(iTime+uv.x*uv.y-iMouse.y/30.0);\n    \n    if (  ( looseEquals(uv.x, cubex) || looseEquals(uv.x, -cubex) ) && uv.y > cubey && uv.y < -cubey*1.5\n       || ( looseEquals(uv.y, cubey) || looseEquals(uv.y, -cubey) ) && uv.x > cubex*1.5 && uv.x < -cubex) {\n    \tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        \n    \tfragColor = vec4(col,1.0);\n    }\n    \n    if ( ( uv.x < cubex || uv.x > -cubex ) || ( uv.y < cubey || uv.y > -cubey ) ) {\n        uv.y *= 0.9;\n        uv.x += 0.7;\n        \n        vec3 col = 0.5 + 0.5*cos(iTime+cos((iMouse.x+iMouse.y)/50.0)+uv.xyx+vec3(0,2,4));\n        \n    \tfragColor = vec4(col/4.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3Dl", "name": "icebreak", "author": "tono", "description": "practice", "tags": ["icebreak"], "likes": 4, "viewed": 400, "date": "1569496730", "time_retrieved": "2024-06-20T19:43:38.670198", "image_code": "\n#define M(x,y) mod(x,y) - y/2.\n#define eq(x,y) (1.-sign(abs(x - y))-0.5)*2.\n#define fsin(x) fract(sin(x))\n#define S(a) clamp(a,1.,0.)\n\nconst float pi = acos(-1.);\nconst float pi2 = pi *2.;\nfloat dsphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat dbox(vec3 p,vec3 s)\n{\n\tp = abs(p) - s;\n\treturn max(p.x,max(p.y,p.z));\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(s,c,-c,s);\n}\n\nvec2 pmod(vec2 p , float r)\n{\n\tfloat a = atan(p.x,p.y) + pi/r;\t\n\tfloat n = pi2/r;\n\ta = floor(a/n) * n;\n\treturn p * rot(-a);\n}\n\nvec3 IFS(vec3 p)\n{\n\tfor(int i = 0; i < 5 ; i++)\n\t{\n\t\tp = abs(p) - 1.5;\n\t\tp.xz = rot(1.) * p.xz;\n\t\tp.xy = rot(1.) * p.xy;\n\t}\n\treturn p;\n}\n\nfloat dist(vec3 p)\n{\n\tp = IFS(p);\n\t\n\tvec3 s = vec3(0.55);\n\tfloat bo = dbox(p , s);\n\t\n\tp = M(p,7.);\n\tfor(int i = 0; i < 4 ; i++)\n\t{\n\t\tp = abs(p) - 1.11;\n\t\tp.xz *= rot(1.);\n\t\tp.xy *= rot(1.);\n\t}\n\t\n\t\n\tp.yz = pmod(p.yz  , 4.);\n\tp.xy = pmod(p.xy  , 4.);\n\t\n\treturn (dbox(p,s));\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 d = vec3(0.001,0.,0.);\n\t\n\treturn normalize(vec3(\n\t\tdist(p.x + d) - dist(p.x - d),\n\t\tdist(p.y + d.yxz) - dist(p.y - d.yxz),\n\t\tdist(p.z + d.zyx) - dist(p.z - d.zyx)\n\t));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n\treturn ((clamp(abs(fract(h + vec3(0.,2.,1.)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = ( fragCoord.xy * 2.- iResolution.xy )/min(iResolution.x,iResolution.y) +  iMouse.xy / min(iResolution.x,iResolution.y);\n\tvec3 color = vec3(.0);\n\t\n    float windowMax = max(iResolution.x,iResolution.y);\n    \n\tfloat t = iTime*2.;\n\t\n\t//p *= rot(t/20.);\n\t\n\tvec3 light = vec3(0.,0.,2.);\n\tvec3 cp = vec3(0.,0.,-2.);\n\tvec3 cd = vec3(0.,0.,1.);\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cs = cross(cd , cu);\n\t\n\tcp += cd * t/2.;\n    //cp += cs * cos(t/18.) * 3.4;\n   // cp.xz *= rot(t/200.); \n    //cp.xy *= rot(t/30.);\n    //cp += cu *t/3.;\n    \n    \n\tfloat target = 2.5;\n\tvec3 rd = normalize(vec3(cu * p.y + cs * p.x + cd * target));\n    \n\tcp += cu * 5.5* clamp(cos(t/20.),-0.8,0.8);\n\tcp += cs * 5.5 * clamp(sin((t + 5.)/20.),-0.8,0.8);\n\t//cp.xy += rot(t / 20.) * cp.xy;\n\t\n\t\n\tfloat depth = 0.0;\n\tfloat ac = 0.0;\n\tvec3 normal;\n    float elect = 0.;\n    vec3 rp;\n\tfor(int i = 0; i < 99 ; i++)\n\t{\n\t\trp = cp + rd * depth + vec3(1.);\n        rp.xz *= rot(1.);\n\t\tfloat d = dist(rp);\n       // cp += step(d,0.001) * step(float(i) ,5.) * cu * 2.;\n        //cp += step(distance(rp,cp),100.) * cu * 10.;\n\t\t//d = max(d , 0.001);\n\t\tif(d < 0.001)\n\t\t{\n            \n\t\t\tnormal = getNormal(rp);\n            elect = clamp(length(rp.xy - cp.xy * S(sin(t/1.)*5.) ),0.,10.);\n\t\t\tbreak;\n\t\t}\t\n\t\tac += exp(-d * 3.);\n\t\tdepth += d;\n\t}\n\t\n\tcolor = vec3(ac/100.);\n\t\n\tfloat h = fract(sin(ac/50.));\n\tfloat s = 1.;\n\tfloat v = 3./ac;\n\t\n\tcolor = hsv(h,s,v);\n    \n    color.b = elect;\n\tcolor = color * pow(dot(normal,light),2.);\n\tfragColor = vec4( color, 1. );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3Dl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3Wl", "name": "Twisting Tux", "author": "dr2", "description": "Extreme case of focal-plane (or rolling) shutter distortion; using \"Tux the Penguin\".", "tags": ["distortion", "camera", "shutter", "penguin"], "likes": 11, "viewed": 339, "date": "1569490423", "time_retrieved": "2024-06-20T19:43:38.680820", "image_code": "// \"Twisting Tux\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nfloat dstFar, tCur, fAng;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dh;\n  dMin = dstFar;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMIN (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMIN (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMIN (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -1.05);\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  q.y -= -0.6;\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMIN (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMIN (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMIN (6);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);\n    if (idObj == 1) col = (ro.z < -0.6 || ro.z < 0. && length (vec2 (abs (ro.x), ro.y) -\n       vec2 (0.3, 2.)) < 0.2) ? vec3 (0.9) : vec3 (0.1, 0.1, 0.15);\n    else if (idObj == 2) col = vec3 (1., 0.8, 0.2);\n    else if (idObj == 3) col = vec3 (0.05, 0.1, 0.05);\n    else if (idObj == 4) col = vec3 (0.8, 0.8, 0.);\n    else if (idObj == 5) col = vec3 (0.9, 0.9, 0.);\n    else if (idObj == 6) col = vec3 (0.15, 0.15, 0.2);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n       0.2 * smoothstep (0.9, 1., sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = vec3 (0.6, 0.6, 1.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr, tCurN;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCurN = tCur + 2.5 * uv.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.8 * pi * sin (0.25 * pi * tCurN);\n    el -= 0.1 * pi * sin (0.1 * pi * tCurN);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0.7, -20.);\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  dstFar = 30.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 7.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col *= 1. - 0.6 * length (uv);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3Wl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3WX", "name": "Moire vortex", "author": "demografica", "description": "Black hole that descends into Moire patterns", "tags": ["moire"], "likes": 1, "viewed": 114, "date": "1569401692", "time_retrieved": "2024-06-20T19:43:38.680820", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec2 q = p-vec2(0.5,0.5);\n\n    q.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(1.0,1.0,1.0);\n\n    q = abs(q); //symmetry\n    q = (q + vec2(q.y, -q.x))*sqrt(0.5); // rotate 45 degrees\n\n    \n    float r = 0.3 + 0.1*cos(atan(q.y,q.x)*iTime*20.0);\n\n    col *= smoothstep(r, r+0.01, length(q)); \n\n    fragColor = vec4(sin(col.x), sin(col.y-r), sin(col.z-r) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3zB", "name": "Doodling : Utrecht", "author": "Flopine", "description": "I worked on this shader for the showdown that happened at Utrecht during Cultural Sundays, this one being organized with CCU : https://twitter.com/cc_utr", "tags": ["raymarching", "flower", "spikes"], "likes": 12, "viewed": 201, "date": "1568798597", "time_retrieved": "2024-06-20T19:43:39.306941", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{\n    return length(max(abs(p)-c,0.));\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float a = atan(p.y,p.x);\n    float per = 2.*PI/rep;\n    float l = length(p);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat tunnel (vec3 p)\n{\n    p.x += texture(iChannel0, p.yz*0.01).r*0.4;\n    p.y += texture(iChannel0, p.xz*0.008).r*0.5;\n    return -cyl(p, 5., 1e10);\n}\n\nfloat ribs (vec3 p)\n{    \n    float per = .5;\n    p.z = mod(p.z-per*0.5, per)-per*0.5;\n    p.y += p.x*p.x*0.6;\n    return cyl(p.yzx, .2-abs(p.x)*0.2, 5.);\n}\n\nfloat g1 = 0.;\nfloat skeleton (vec3 p)\n{\n    p.z += iTime;\n    p.xy *= rot(p.z*0.1);\n    mo(p.xy, vec2(1., 1.8));\n    p.x -= 2.5;\n    p.y += sin(p.z*0.6);\n    p.x += cos(p.z)*0.2;\n    p.xy *= rot(p.z*0.1);\n    float spine = cyl(p, 0.25,1e10);\n    float d =  min(spine, ribs(p));\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat g2 = 0.;\nfloat flower(vec3 p)\n{\n    p.z -= 2.+iTime;\n    p.xz *= rot(iTime);\n    p.xz *= rot(p.y*0.5);\n    mo(p.xy, vec2(0.5));\n    mo(p.xz, vec2(1.));\n    moda(p.xz, 3.);\n    p.x -= 0.5;\n    float d = box(p, vec3(.05-sin(p.y-.5),1.5,0.05));\n    g2 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    return min(flower(p),min(tunnel(p), skeleton(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    float dither = texture(iChannel0, uv).r;\n    \n    vec3 ro = vec3(0.001,0.001, -3.+iTime); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.6+dither*0.1;\n        p+=d*rd;\n    }\n    \n    col = vec3(shad);\n    col += g1*vec3(0.08,0.12,0.08)*exp(-fract(iTime))*0.25;\n    col += g2 * vec3(0.5,0.1,0.2)*0.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3zB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3st3zX", "name": "BlinkStar", "author": "mizu9972", "description": "practice", "tags": ["begginer"], "likes": 2, "viewed": 92, "date": "1569311772", "time_retrieved": "2024-06-20T19:43:39.512648", "image_code": "const float PI = 3.141592;\n\nconst float BLINK_SPEED  = 8.0;  //\nconst float BLINK_RADIUS = 0.001; //\n\nvec2 Star1;\n\nvoid SetStar(){\n    Star1.x = 320.0;\n    Star1.y = 180.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetStar();//\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 backcol = vec3(0,0,0); //\n    vec3 col \t = vec3(1,1,1); //\n\n    float Length = distance(Star1.xy / iResolution.xy,uv.xy);//\n    \n    //\n    col = (1.0 / Length * col) * BLINK_RADIUS * ((sin(mod(iTime * BLINK_SPEED,PI)) + 1.0) / 2.0);\n    \n    // Output to screen\n    fragColor = vec4(backcol + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3st3zX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stGD8", "name": "Snake low poly texture", "author": "gabwoot", "description": "just a small experiment", "tags": ["triangle", "texture", "lowpoly", "snale"], "likes": 9, "viewed": 171, "date": "1568377039", "time_retrieved": "2024-06-20T19:43:39.512648", "image_code": "#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\t6.283185307179586\n\nvec2 coord(in vec2 p) {\n  p = p / iResolution.xy;\n  // correct aspect ratio\n  if (iResolution.x > iResolution.y) {\n    p.x *= iResolution.x / iResolution.y;\n    p.x += (iResolution.y - iResolution.x) / iResolution.y / 2.0;\n  } else {\n    p.y *= iResolution.y / iResolution.x;\n    p.y += (iResolution.x - iResolution.y) / iResolution.x / 2.0;\n  }\n  // centering\n  p -= 0.5;\n  p *= vec2(-1.0, 1.0);\n  return p;\n}\n\n\nmat2 rotation2d(float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat random (in vec2 st) {\n    return fract(\n        sin(\n            dot(st.xy, vec2(12.9898,78.233))\n        ) * 43758.5453123\n    );\n}\n\nfloat between(float minV, float maxV, float v) {\n    return minV + v * (maxV - minV);\n}\n\nfloat tiles = 3.;\nconst vec2 vel = vec2(1., 0.);\nconst vec4 skfbBlue = vec4(20, 170, 217, 255);\nconst vec4 orange = vec4(200, 54, 96, 255);\nconst vec4 purple = vec4(58, 31, 93, 255);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color1 = orange / vec4(255);\n    vec4 color2 = purple / vec4(255);\n  \n    vec2 uv = coord(fragCoord.xy);\n    float time = fract(iTime);\n\n      vec2 wave = uv;\n      wave.x += sin(uv.y * 5. + iTime) * 0.1;\n      wave.y += cos(uv.x * 5. + iTime) * 0.1;\n      uv += wave;\n\n    uv *= rotation2d(PI / 3.2 * iTime);\n    uv *= vec2(between(0.7, 1.5, (1. + sin(iTime)) / 2.));\n    uv += vec2(between(5., 10., iTime / 1.4));\n\n    vec2 index = floor(tiles * uv) / tiles;\n    float t = floor(random(index) * 4.) / 4.;\n\n    uv = 2.0 * fract(tiles * uv) - 1.0;\n    uv *= rotation2d(t * PI * 2.);\n\n    float c = step(uv.x, uv.y) * 0.9;\n    c = abs(sin(5. + fract((random(index + c) + 0.1))));\n\n    vec4 color = random(vec2(c)) > 0.5 ? color1 : color2;\n\n    fragColor = vec4((c * .5 + 0.5) * color.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stGDS", "name": "Voronoi Practice", "author": "Janovski", "description": "something I did following tutorial from ArtOfCode", "tags": ["voronoi", "practice", "notmine"], "likes": 3, "viewed": 116, "date": "1569221066", "time_retrieved": "2024-06-20T19:43:39.512648", "image_code": "vec2 N22(vec2 p)\n{\n\tvec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime * 0.5;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n    vec3 col = vec3(0);\n    if(false)\n    {\n           \n    for(float i=0. ; i< 50. ; i++)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv-p);\n        m += smoothstep(.02, .01, d);\n        \n        if(d<minDist)\n        {\n         \tminDist = d; \n            cellIndex = i;\n        }\n    }\n    } else {\n        uv *= 3.;\n     \tvec2 gv = fract(uv) - .5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        \n        for(float y=-1.; y<=1. ; y++){\n            for(float x=-1.; x<=1.;x++){\n                vec2 offs = vec2(x, y);\n                \n                vec2 n = N22(id + offs);\n        \t\tvec2 p = offs + sin(n*t) *.5;\n                p -= gv;\n                float ed = length(p);\n                float md = abs(p.x)+abs(p.y);\n                float d = mix(ed, md, sin(iTime)*1.+0.5);\n                \n                if(d<minDist)\n                    {\n                        minDist = d; \n                        cid = id + offs;\n                    }\n            }\n        }\n        //col = vec3(gv, 0);\n        col = vec3(minDist);\n        col.rg *= sin(iTime)*cid;\n        col *= vec3(1.,0.+ (sin(iTime)*0.5+0.5),.5);\n    }\n    \n  \n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stGDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stGRf", "name": "second shader ,click on it", "author": "Newbobplus", "description": "Second shader ever.\nMessy af, i got lazy towards the end.", "tags": ["a"], "likes": 2, "viewed": 97, "date": "1569008024", "time_retrieved": "2024-06-20T19:43:40.052091", "image_code": "const float PI = 3.14159265359;\n\nfloat seed = 6.;\nfloat LABY_STEP_SPACING = .07;\nfloat LABY_STEP_RADIUS = .04;\n\nconst float CURSOR_RADIUS = .05;\nconst float CIRCLE_BLUR = .02;\nconst float LABYRINTH_RADIUS = .48;\nconst float CENTER_RADIUS = .07;\n\nconst float BRANCH_WIDTH = .005;\n\nfloat circle(float radius, float blur, float dist){\n    return smoothstep(radius + blur, radius, dist);\n}\n\nfloat slice(float turn, float width, float dist){\n    float a = ceil(dist - turn);\n    float b = ceil(dist - turn - width);\n    return clamp(a - b, 0., 1.);   \n}\n\nfloat remap(float value, float minA, float maxA, float minB, float maxB){\n\treturn minB + (value - minA) * (maxB - minB) / (maxA - minA);   \n}\n\nfloat _rand(float s){\n    float r = s;\n    r *= cos(r * r);\n    r = fract(r) * 3.;\n    return r * r;\n}\n\n//I know exactly what i'm doing.\nfloat rand(float s){\n\tint c = int(ceil(_rand(s)));\n    float r = s;\n    for(int i = 0; i < c; i++){\n   \t\tr = _rand(r);\n    }\n    return fract(r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = 6. + floor(iTime / 5.);\n    \n    vec2 recRes = 1. / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 mouse = iMouse.xy;\n    if(mouse.x + mouse.y == 0.) mouse = iResolution.xy * .5;\n    \n    vec2 m = mouse * recRes;\n    vec2 cursorUv = (uv - m) * vec2(ratio, 1.);\n    float cursorDist = length(cursorUv);\n    \n    vec3 cursor = vec3(circle(CURSOR_RADIUS, CIRCLE_BLUR, cursorDist));\n    \n    vec2 centerUv = (uv - vec2(.5)) * vec2(ratio, 1.);\n    float centerDist = length(centerUv);\n    \n    vec3 labyrinth = vec3(0., 0., circle(CENTER_RADIUS, CIRCLE_BLUR, centerDist));\n    int steps = int((LABYRINTH_RADIUS - CENTER_RADIUS) / (LABY_STEP_RADIUS + LABY_STEP_SPACING));\n    float r = CENTER_RADIUS + float(steps) * (LABY_STEP_RADIUS + LABY_STEP_SPACING);\n    float scale = LABYRINTH_RADIUS / r;\n    float stepRadius = LABY_STEP_RADIUS * scale;\n    float stepSpacing = LABY_STEP_SPACING * scale;\n    \n    float angularDist = atan(centerUv.x, centerUv.y);\n    angularDist = remap(angularDist, -PI, PI, 0., 1.);\n    \n    for(int i = 1; i < steps + 1; i++){\n        float c = circle(CENTER_RADIUS + float(i) * (stepRadius + stepSpacing), CIRCLE_BLUR, centerDist);\n        c -= circle(CENTER_RADIUS + float(i) * stepSpacing + float(i-1) * stepRadius, CIRCLE_BLUR, centerDist);\n        labyrinth += c;\n        float b = circle(CENTER_RADIUS + float(i) * stepSpacing + float(i-1) * stepRadius, CIRCLE_BLUR, centerDist);\n        float br = CENTER_RADIUS + float(i-1) * (stepRadius + stepSpacing);\n        b -= circle(br, CIRCLE_BLUR, centerDist);\n        float t = rand(seed+rand(float(i)) * .1);\n        labyrinth += slice(t, BRANCH_WIDTH / br, angularDist) * b;\n    }\n    float e = circle(CENTER_RADIUS + float(steps + 1) * stepSpacing + float(steps) * stepRadius, CIRCLE_BLUR, centerDist);\n    float er = CENTER_RADIUS + float(steps) * (stepRadius + stepSpacing);\n    e -= circle(er, CIRCLE_BLUR, centerDist);\n    float es = slice(.6, BRANCH_WIDTH / er * 4., angularDist) * e;\n    labyrinth += vec3(0., es, 0.);\n    \n    vec3 background = vec3(.5, .1, 0.5);\n    \n    vec3 rect = vec3(0.);\n    if(uv.x > .9 && uv.x < .95 && uv.y < 1. - mod(iTime/5., 1.)) rect = vec3(1.);\n    \n    vec3 col = background * clamp(ceil(length(background)) - length(labyrinth), 0., 1.);\n    col += labyrinth;\n    col = col * clamp(length(col) - length(cursor), 0., 1.) ;\n    col +=  vec3(1., 0., 0.) * length(cursor) * ceil(length(labyrinth));\n    col += rect;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stGRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stGRH", "name": "Shader Showdown Rev-19 1/4 final", "author": "evvvvil", "description": "Winning shader made at Revision 2019 Shader Showdown \"World championships\". Quarter final round against Hardy / TRSI ^ Genesis Project ^ Lemon. Live coded on stage in 25 minutes.\nVideo of the battle: https://youtu.be/uifMBMt9ASU?t=3496", "tags": ["demoscene", "particles", "glow", "revision", "live", "battle", "spaceship", "shadershowdown", "creature", "flying", "industrial", "fly", "biomechanic"], "likes": 19, "viewed": 734, "date": "1567785346", "time_retrieved": "2024-06-20T19:43:40.597595", "image_code": "// Winning shader made at Revision 2019 Shader Showdown \"world championships\",\n// Quarter final round against Hardy / TRSI ^ Genesis Project ^ Lemon\n// Video of the battle: https://youtu.be/uifMBMt9ASU?t=3496\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"If the seagulls follow the trawler it's because they think fish will be thrown to the sea.\" - Eric Cantona to journalists who expected him to apologise for kicking a Crytal Palace fan who had insulted him.\n\nvec2 s,e=vec2(.00035,-.00035);float t,tt,b,bb,g,att,si;vec3 np,bp,cp;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nvec2 fb( vec3 p,float s)\n{\n  bb=sin(p.z*.1);\n  vec2 h,t=vec2(bo(abs(p)-vec3(3,0,0),vec3(1)),5.+s);\n  h=vec2(bo(abs(p)-vec3(2,0,0),vec3(1.2)),3.+s);\n  h.x=min(bo(abs(abs(p)-vec3(0,1,.6))-vec3(0,.3,.3),vec3(3,.1,.1)),h.x);\n  t=t.x<h.x?t:h;\n  h=vec2(bo(abs(p)-vec3(2,0,0),vec3(.4-bb,.4-bb,10)),6.+s);  \n  t=t.x<h.x?t:h;\n  h=vec2(bo(abs(p)-vec3(2,0,0),vec3(.3-bb,.5-bb,10)),3.+s);  \n  t=t.x<h.x?t:h; t.x*=0.5;\n  return t;\n}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 mp( vec3 p)\n{\n  att=length(p)-20.;\n  si=sin(p.z*.1+tt*20.+1.57);\n  p.y+=si*5.;\n  p.xy*=r2(si*.3);\n  np=bp=p;\n  for(int i=0;i<6;i++){\n      np=abs(np)-vec3(1.+4.*b,1,3);\n    np.xy*=r2(.5+sin(p.z*.2)*.3+b);\n    np.yz*=r2(.2);\n    if(mod(float(i),2.)>0.){\n      bp=abs(bp)-vec3(5.+2.*b,1,2);\n    bp.xz*=r2(.1);\n    bp.xy*=r2(.2+si*.2);\n    }        \n  }\n  bp.x-=1.;\n  vec2 h,t=fb(np,0.);\n  h=fb(bp,5.);  \n  t=t.x<h.x?t:h;\n  h=vec2(length(abs(p)-vec3(4.+2.*b,0,15))-3.,6);  \n  g+=0.1/(0.1+h.x*h.x*20.);\n  t=t.x<h.x?t:h;\n  cp=p*.5;cp.z=mod(cp.z+tt*100.-sin(p.y),10.)-5.;\n  h=vec2(length(cos(cp*.5-2.))-0.001,6);  \n  g+=0.1/(0.1+h.x*h.x*400.);\n  t=t.x<h.x?t:h;\n  h=vec2(bo(abs(np*.5)-1.-fract(tt*10.)*20.,vec3(.2,10,.2)),6);  \n  g+=0.1/(0.1+h.x*h.x*10.);\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(t.x<.0001||t.x>60.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>60.) t.x=0.;\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv -= 0.5;uv/=vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime*.1,6.283);\n  b=.5+2.*clamp(sin(tt*5.),-.25,.25);\n  vec3 ro=vec3(2.+cos(tt*5.-1.57)*(1.-b)*40.,2,sin(tt*5.-1.57)*40.),\n  cw=normalize(vec3(0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,ld=normalize(vec3(-.5,.5,.1));\n  co=fo=vec3(1,.5,.2)-rd.y*.4;  \n  s=tr(ro,rd);t=s.x;\n if(t>0.){\n   vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),al=vec3(.1,.5-att*0.03,.6-att*0.03);   \n   if(s.y<5.) al=vec3(0);\n   if(s.y>5.) al=vec3(1);\n   if(s.y<10.) al=vec3(0);\n   if(s.y>10.) al=vec3(1);\n   if(s.y==10.||s.y==5.) al=vec3(.1,.5+att*0.03,.6-att*0.03);\n   float dif=max(0.,dot(no,ld)),\n   aor=t/50.,ao=exp2(2.-pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),\n   spo=exp2(10.*texture(iChannel0,vec2(np.y,dot(np.xz,vec2(0.7)))/vec2(30,10)).r);\n   if(s.y>6.) spo=exp2(10.*texture(iChannel0,vec2(bp.y,dot(bp.xz,vec2(0.7)))/vec2(30,10)).r);\n   float fr=pow(1.+dot(no,rd),4.),\n   sss=smoothstep(0.,1.,mp(po+ld*.4).x/.4),       \n   sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);   \n   co=mix(sp+al*ao*(dif+sss),fo,min(fr,.5));\n   co=mix(co,fo,1.-exp(-.000003*t*t*t));\n }\n fragColor = vec4(pow(mix(co,co.zyx,b)+g*0.3,vec3(.45)),1);//Color change .zyx idea by Slerpy / Alcatraz, added on twitch after showdown\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stGRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3stGzf", "name": "Simple Landscape", "author": "Radiant", "description": "Sun", "tags": ["shader"], "likes": 3, "viewed": 92, "date": "1569004732", "time_retrieved": "2024-06-20T19:43:40.597595", "image_code": "float hypot(float x, float y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159265;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tvec2 pos = vec2(uv.x * iResolution.x / iResolution.y - 0.5 * iResolution.x / iResolution.y, uv.y - 0.5);\n    \n    float a = atan(pos.x, pos.y);\n    float val = 0.0;\n    for (float i = 0.0; i < 1.0; i += 0.04)\n    {\n        float speed = (mod(pow(i * 10.0, 2.1) * 1.2, 3.8) - 1.9) * 0.5;\n\t\tfloat phase = iTime * speed + i * 0.256;\n        \n        float comp1 = pow(i * 10.0, 2.5);\n        \n        float freq = 2.0 * mod((comp1 - mod(comp1, 1.0)), 10.0) + 3.0;\n        float f = pow(max(0.0, sin(a * freq + phase)), 0.2);\n        \n        val += pow(max(0.0, sin(a * freq + phase)), 0.3);\n    }\n    \n    float c = 1.0 - (hypot(pos.x, pos.y) - 0.10) / (val + 0.02) * 40.0;\n    \n   \tc = pow(c, 3.0);\n    c = clamp(c, 0.0, 1.0);\n    \n    vec3 sky_horizon = vec3(1.0, 0.3, 0.1);\n    vec3 sky_zenith = vec3(0.0, 0.0, 0.0);\n    vec3 sky = sky_zenith + sky_horizon * pow(1.0 - uv.y, 0.3);\n    \n    vec3 col = (vec3(1.0, 1.0, cos(iTime) * 0.1 + 0.9) - sky) * c + sky;\n    \n    for (float i = 0.0; i < 3.0; i += 1.0)\n    {\n    \tfloat terrain = sin((uv.x * pow(4.0 - i, 1.29) + iTime * 1.1) * 0.8 - 1.8 * i - 0.98) * 0.1 + 0.5 - i * 0.1;\n\t\tif (uv.y < terrain)\n   \t\t{\n\t\t\tcol = vec3(0.6, 0.3, 0.1) * (i / 22.0 + 0.2) * 0.7;\n    \t}\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3stGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sVGzh", "name": "Hessian of the Cayley Cubic", "author": "skye_adaire", "description": "Equation taken from http://mathworld.wolfram.com/CayleyCubic.html", "tags": ["geometry", "dual", "real", "algebraic"], "likes": 2, "viewed": 116, "date": "1569711960", "time_retrieved": "2024-06-20T19:43:41.937024", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n        case 10:\n        {\n\t\t\tDualReal x = d[0];\n            DualReal x2 = D_multiply(x, x);\n            DualReal x3 = D_multiply(x, x2);\n            DualReal y = d[1];\n            DualReal y2 = D_multiply(y, y);\n            DualReal y3 = D_multiply(y, y2);\n            DualReal z = d[2];\n            DualReal z2 = D_multiply(z, z);\n            DualReal z3 = D_multiply(z, z2);\n\n            DualReal t0 = 25.0 * (D_multiply(x3, y + z) + D_multiply(y3, x + z) + D_multiply(z3, x + y));\n            DualReal t1 = 50.0 * (D_multiply(x2, y2) + D_multiply(x2, z2) + D_multiply(y2, z2));\n            DualReal t2 = -125.0 * (D_multiply(x2, D_multiply(y, z)) + D_multiply(y2, D_multiply(x, z)) + D_multiply(z2, D_multiply(x, y)));\n            DualReal t3 = 60.0 * D_multiply(x, D_multiply(y, z));\n            DualReal t4 = -4.0 * (D_multiply(x, y) + D_multiply(x, z) + D_multiply(y, z));\n            return t0 + t1 + t2 + t3 + t4;\n            \n        }\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    float bound = length(p) - 1.0;\n    \n    return max(abs(de), bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = 10;\n    \n    //view basis\n    float polar = (iMouse == vec4(0)) ? 0.0 : tau32 * iMouse.y / iResolution.y + pi32;\n    float az = (iMouse == vec4(0)) ? time * tau32 : -tau32 * iMouse.x / iResolution.x;\n    mat3 viewTransform = rotationXZ(az) * rotationYZ(polar);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 1.5);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0) * 2.0;\n        color *= normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(vec3(0.2),1);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sVGzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3syGRR", "name": "Batman Model", "author": "Dirk", "description": "Batman model", "tags": ["batman", "model"], "likes": 2, "viewed": 98, "date": "1569709505", "time_retrieved": "2024-06-20T19:43:43.179624", "image_code": "\nconst float PI = 3.1415926535897932384626433832795;\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdElipsoid( in vec3 pos, vec3 rad )\n{\n\tfloat k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n\t\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin( in float a, in float b, float k )\n{\n \tfloat h = max( k - abs(a-b), 0.0 );\n    return min( a, b ) - h*h/(k*4.0);\n}\n\nvec2 sdBatman( in vec3 pos )\n{\n    float t = 0.5;//fract(iTime);\n    float sine = sin(iTime);\n    float cose = cos(iTime);\n    \n    float y = 4.0*t*(1.0-t);\n    float dy = 4.0*(1.0-2.0-t);\n    \n    vec3 cen = vec3(0.0,y,0.0);\n    \n    float sy = 0.5 + 0.5*y;\n    float sz = 1.0/sy;\n    \n    vec3 rad = vec3(0.25,0.25*sy,0.25*sz);\n    \n    vec3 q = pos-cen;\n    \n\t// Head\n    \n    vec3 h = q - vec3(0.0,0.20,0.0);\n    float head = sdElipsoid(h - vec3(0.0,0.05,0.03),rad*vec3(0.02,0.01,0.01));\n    head = smin( sdElipsoid(h+vec3(0.0,0.02,-0.04),vec3(0.005,0.01,0.005)), head,0.2 );\n    float face = sdElipsoid(h+vec3(0.0,-0.02,-0.02),vec3(0.01,0.03,0.01));\n    \n    float chest = sdElipsoid(h+vec3(0.0,0.22,0.10),rad*0.5);\n    head = smin(head,face,0.02);\n    head = smin(face,head,0.02);\n    float core = sdElipsoid(h+vec3(0.0,0.25,0.08),rad*vec3(0.8,0.6,0.4));\n    head = smin(head,chest,0.02);\n    head = smin(head,core,0.02);\n    \n\t// Neck\n    \n\tvec3 nk = q - vec3(0.0,0.14,-0.05);\n    nk.zy = mat2(0.3,0.8,-0.8,0.3)*nk.zy;\n    nk.y += 0.08*nk.y*nk.y;\n    float d8 = sdElipsoid( nk, vec3(0.05,0.1,0.05) );\n    \n\tpos.x = abs(pos.x);//reflect\n\th.x = abs(h.x);//reflect\n    \n\t// horns\n    \n\tvec3 horns = h - vec3(0.04,0.07,0.0);\n    horns.xy = mat2(0.9,0.15,-0.15,0.9)*horns.xy;\n    horns.x += 0.8*horns.y*horns.y;\n    float d4 = sdElipsoid( horns, vec3(0.008,0.05,0.010) );\n    \n\t// Pecs\n    \n\tvec3 pk = pos - vec3(0.08,0.95,0.02);\n    pk.yz = mat2(0.3,0.14,-0.14,0.5)*pk.yz;\n    pk.x += 0.8*pk.y*pk.y;\n    float d7 = sdElipsoid( pk, vec3(0.1,0.025,0.02) );\n    \n\t// Shoulders\n    \n\tvec3 sh = pos - vec3(0.19,1.02,-0.1);\n    sh.xy = mat2(0.3,0.4,-0.4,0.5)*sh.xy;\n    sh.x += 0.8*sh.y*sh.y;\n    float d5 = sdElipsoid( sh, vec3(0.065,0.065,0.1) );\n    \n\t// Bicep\n    \n\tvec3 bc = pos - vec3(0.3,0.9,-0.1);\n    bc.xy = mat2(0.3,0.8,-0.8,0.3)*bc.xy;\n    bc.x += 0.8*bc.y*bc.y;\n    float d6 = sdElipsoid( bc, vec3(0.09,0.05,0.08) );\n    \n    // Forarm\n\t\n    vec3 fa = pos - vec3(0.32,0.85,-0.1);\n    fa.yx = mat2( sine,cose,-cose,sine)*fa.yx;\n    fa.x += 1.6*fa.y*fa.y;\n    float d9 = sdRoundCone( fa, 0.05, 0.03, 0.3 );\n    \n    \n    float d = smin(d4,head,0.015);\t//head\n \td = smin(d,d8,0.02); \t\t\t//neck\n \td = smin(d,d7,0.02); \t\t\t//pecs\n \td = smin(d,d5,0.05);\t\t\t//shoulders\n \td = smin(d,d6,0.02);\t\t\t//bicep\n \td = smin(d,d9,0.02);\t\t\t//Forarms\n    \n    vec2 res = vec2(d,2.0);\n    return vec2(d,2.0);\n}\n\nvec2 map( in vec3 pos )\n{\n\tvec2 d1 = sdBatman(pos);\n    float d2 = pos.y - (-0.12);\n    return (d2<d1.x) ? vec2(d2,1.0) : d1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.0001,0.0);\n\treturn normalize( vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                           map(pos+e.yxy).x-map(pos-e.yxy).x,\n                           map(pos+e.yyx).x-map(pos-e.yyx).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd )\n{\n\tfloat res = 1.0;\n    \n    float t = 0.001;\n    for( int i=0; i<100; i++ )\n    {\n     \tvec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, 16.0*h/t );\n        \n        if( h<0.0001 ) break;\n        \n        t += h;\n        if( t>20.0 ) break;\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec2 castRay( in vec3 ro, vec3 rd ){\n    \n    float m = -1.0;\n    float t = 0.0;\n    for( int i=0; i<100; i++ ){\n    \t\n        vec3 pos = ro + t*rd;\n        \n        vec2 h = map( pos );\n        m = h.y;\n        if( h.x<0.001 )\n            break;\n        \n        t+= h.x;\n        if( t>20.0 ) break;\n    }   \n    if( t>20.0 ) m=-1.0;\n    return vec2(t,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 an = 10.0*iMouse.xy/iResolution.xy;//0.1*iTime;\n    \n    vec3 ta = vec3(0.0,0.95,0.0);\n    vec3 ro = ta + vec3(1.0*sin(an.x),(1.0*cos(an.y/PI)),1.0*cos(an.x));\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu,ww) );\n                        \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n    \n    vec3 col = vec3(0.4,0.75,1.0) - 0.7*rd.y;\n    col = mix( col, vec3(0.7,0.75,0.8), exp(-10.0*rd.y) );\n    \n    \n    \n    vec2 tm = castRay( ro, rd );\n    \n    if( tm.y>0.0 )\n    {\n        float t = tm.x;\n    \tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        if( tm.y<1.5 )\n        {\n            float scale = 5.0;\n         \tmate = vec3(0.4)*step(sin(pos.x*2.0)+cos(pos.z*2.0),0.0);   \n        }else\n        if( tm.y<2.5 )\n        {\n         \tmate = vec3(0.01);   \n        }\n        \n        vec3 sun_dir = normalize(vec3(0.8,0.4,0.2) );\n        float sun_dif = clamp( dot(nor,sun_dir),0.0,1.0);\n        float sun_sha = step( castRay( pos+nor*0.001, sun_dir ).y,0.0);\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,-1.0,0.0)), 0.0, 1.0 );\n        \n        col  = mate*vec3(3.0,3.0,3.0)*sun_dif*sun_sha;  \n        col += mate*vec3(0.5,0.8,0.9)*sky_dif;  \n        col += mate*vec3(0.7,0.3,0.2)*bou_dif;   \n        \n    }\n    \n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3syGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3t2SWd", "name": "Megapolis - 2D pattern", "author": "FabriceNeyret2", "description": "Extracting the 2D pattern use in skaplun \"Megapolis\" [url]https://shadertoy.com/view/MlKBWD[/url] to make 3D animated building growth.", "tags": ["animation", "pattern", "videotransition"], "likes": 9, "viewed": 469, "date": "1567518659", "time_retrieved": "2024-06-20T19:43:43.179624", "image_code": "// extracted and refactored from skaplun 3D \"Megapolis\" https://shadertoy.com/view/MlKBWD\n\n#define TIME_MULT   .25\n#define IDLE_TIME   .05\n\n#define rnd(p) fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 R  = iResolution.xy;\n    float p = 6./R.y;\n    U *= p;\n\tO-=O; \n    \n    float t = fract(iTime * TIME_MULT),\n         mt = ceil(iTime * TIME_MULT),\n        cellStartTime = rnd(ceil(U) * mt) * .5 + IDLE_TIME,\n          w = .25 + .75* smoothstep(0., .175, t-cellStartTime-.225);\n\n    if (t > cellStartTime) \n        U = smoothstep(p,0.,abs(fract(U)-.5) - w/2. ),\n        O += U.x*U.y;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3t2SWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tjSDc", "name": "mg circles", "author": "mwgooding", "description": "playing with 2D sdf and noise", "tags": ["2d"], "likes": 3, "viewed": 116, "date": "1567347238", "time_retrieved": "2024-06-20T19:43:43.385728", "image_code": "float circleSdf(vec2 p, float r, vec2 st) {\n  return length(p - st) - r;\n}\n\n// https://thebookofshaders.com/10/\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) *\n        43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const vec3 BG_COLOR = vec3(0.25, 0.15, 0.05);\n  const vec3 FG_COLOR_1 = vec3(0.95, 0.45, 0.25);\n  const vec3 FG_COLOR_0 = FG_COLOR_1 * 0.4;\n\n  vec2 st = fragCoord.xy / iResolution.y;\n\n  vec2 bucket = floor(st * 20.0) / 20.0;\n  float sdf = circleSdf(vec2(0.025) + bucket, 0.025, st);\n\n  if (sdf > 0.0)\n      fragColor = vec4(BG_COLOR, 1);\n  else {\n    // lerp between noise changes\n    float thisRandom = random(bucket + floor(iTime));\n    float nextRandom = random(bucket + floor(iTime + 1.0));\n    float lerp = mix(thisRandom, nextRandom, iTime - floor(iTime));\n    vec3 color = mix(FG_COLOR_0, FG_COLOR_1, lerp);\n    // pseudo-aa\n    color = mix(color, BG_COLOR, smoothstep(-0.002, 0.0, sdf));\n    fragColor = vec4(color, 1);\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tjSDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tSSDt", "name": "Warped Flower", "author": "aiekick", "description": "based on [url=Bumped Sinusoidal Warp]https://www.shadertoy.com/view/4l2XWK[/url]", "tags": ["flower", "warped"], "likes": 20, "viewed": 553, "date": "1567435756", "time_retrieved": "2024-06-20T19:43:43.385728", "image_code": "#define AA 2\n#define COUNT_PETALS \t5.\n#define TIME_SPEED \t\t0.5\n#define BUMP_FACTOR     0.05\n#define MOVE_SPEED\t\t0.0\n\nvec3 sdf(vec2 p, float t)\n{\n    p = vec2(atan(p.x+sin(t * MOVE_SPEED)*0.5,p.y), length(p * 3.5)); \t// cart to polar\n    for (int i=0; i<3; i++)\n\t{\n\t\tp.y += cos(p.x * COUNT_PETALS - t)/3.; \t// l warping \n\t\tp.x += sin(p.y * 4. - t*2.)/3.;\t\t\t// a warping\n    }\n\tp = vec2(cos(p.x), sin(p.x)) * p.y; \t\t// polar to cart\n\tp = abs(fract(p)-0.5);\t\t\t\t\t\t// domain repeat\n\treturn vec3(length(p), p);\n}\n\nvec4 render(in vec2 v, in vec2 o)\n{\n    float t = iTime * TIME_SPEED; \n\t\n    vec2 uv = (v + o - iResolution.xy*0.5)/iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.));\n\n\t// light point\n    vec3 lp = vec3(cos(iTime)*0.5, sin(iTime)*0.2, -1.);\n\t\n\t// bump mapping\n\tvec2 eps = vec2(5./iResolution.y, 0.);\n    vec3 f = sdf(uv, t);\n    float fx = (sdf(uv-eps.xy, t).x-f.x)/eps.x;\n    float fy = (sdf(uv-eps.yx, t).x-f.x)/eps.x;\n\tvec3 n = normalize( vec3(0., 0., -1) + vec3(fx, fy, -1.) * BUMP_FACTOR );           \n\t\n\t// distance to light point\n\tvec3 ld = lp - vec3(uv,0);\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n    float atten = (f.x*0.9+0.1)/(1.0 + lDist*lDist*0.15);\n\t\n\t// diffuse\n\tfloat diff = max(dot(n, ld), 0.);  \n    diff = pow(diff, 4.)*0.7 + pow(diff, 8.)*0.3; \n\t\n\t// specular\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 12.); \n    \n\t// texture\n\tvec3 col = texture(iChannel0, uv + f.yz).xyz; \n    col = smoothstep(0.05, .75, pow(col*col, vec3(.75, .8, .85)));    \n    \n\t// final light\n\tcol = (col * (diff*vec3(0.496, 0.853, 1.0)*2. + 0.5) + vec3(1)*spec*2.)*atten;\n\treturn vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    int _AA = max(AA,1); // avoid div by 0 at line 69\n    \n\tfor(int i=0;i<_AA;i++)\n    for(int j=0;j<_AA;j++)\n        fragColor += render(fragCoord, vec2(i,j) / float(_AA));\n    \n    fragColor /= float(_AA * _AA);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tSSDz", "name": "polar coordinate experiment", "author": "eimink", "description": "experimenting, dark because it's used as a background on one website", "tags": ["test"], "likes": 3, "viewed": 160, "date": "1569580945", "time_retrieved": "2024-06-20T19:43:43.385728", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tvec2 st = vec2(atan(uv.x,uv.y),length(uv));\n    uv = vec2(st.x/6.2831+.518,st.y);\n    float p = -((uv.y*0.6-.6)*sin(uv.x*.518))-0.3*sin(100.*uv.x);\n    vec3 c = -uv.y+p + 0.6*cos(uv.yyy+1.*sin(iTime+11.*uv.x)*vec3(1,2,3));\n    vec3 col = .3*c.x*(sin(c.y)+.5)*vec3(uv.y,1.,c.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tSSDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dGBzD", "name": "Wave1", "author": "deerfeeder", "description": "wave", "tags": ["wave"], "likes": 2, "viewed": 58, "date": "1568734831", "time_retrieved": "2024-06-20T19:43:43.385728", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    uv.x+=1.5;  \n    uv.y += cos(uv.x*(8.0  + 2.7 * (0.0 + cos(iTime * 0.1))))*0.15;\n    uv.y*=-20.0 + 33.0 * sin(iTime * 0.02);\n    float r = sin(iTime * 0.1) * 2.0,\n    e = uv.x-iTime*0.1,\n    t = e + abs(uv.y),\n   //s = step( fract(t*r),f);\n   // s = smoothstep(1.5,0., (fract(t*r)-f)/fwidth(t*r-f)); \n   //O = vec4(s);\n   f = (1.0+sin(uv.x*2.0 * cos(iTime *0.1)))*0.2+0.1, \n   d = f - abs(fract(t*r) - .1)*0.9,\n   s = smoothstep(0., .25/max(d + .01, 0.), d + .1);    \n   O = vec4(vec3(sqrt(s*0.1)),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlycDV", "name": "water ring", "author": "Minus256", "description": "refraction in this is inaccurate af.\nIt just looks like water. Except it's totally wrong.\nI wrote this shader a year ago.", "tags": ["raymarching", "refraction"], "likes": 3, "viewed": 69, "date": "1568563514", "time_retrieved": "2024-06-20T19:43:44.670951", "image_code": "//MinusRefraction\nconst float err = 0.00001;\nconst float eserr = 0.001;\nconst float sta = 0.0;\nconst float end = 1000.0;\nconst float refval = 1.33;\nconst int mxmrch = 2000;\n\n//Calculate Ray Dir\nvec3 raydir(float fov,vec2 res,vec2 pos)\n{\n    vec2 norpos = (pos.xy-res.xy/2.0)/(res.xx/2.0);\n    float depth = 1.0/(tan(radians(fov/2.0)));\n    return normalize(vec3(vec2(norpos.xy),depth));\n}\n\n//Transformation Set\nmat3 viewmat(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 rX(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rY(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rZ(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdTorus(p,vec2(10.0,5.0));//length(p)-10.0;\n    float D1 = 0.5;\n    float d2 = sin(D1*p.x)*sin(D1*p.y)*sin(D1*p.z);\n    return d1+d2;\n}\n\n//Material Getting\nfloat mat1sdf(vec3 point)\n{\n    //return -(length(point)-10.0);\n    return -(sdBox(point,vec3(100.0)));\n}\n\nfloat mat2sdf(vec3 point)\n{\n    return length(point-vec3(20.0*sin(iTime),0.0,-90.0))-10.0;\n}\n\nfloat mat3sdf(vec3 point)\n{\n    vec3 rp = (point-vec3(0.0,0.0,-30.0)) * rZ(iTime) * rY(iTime) * rX(iTime);\n    //return length(point-vec3(1.0,0.0,-3.0))-1.0;\n    return opDisplace(rp);\n}\n\nvec3 scdstmat(vec3 p)\n{\n    float sdf = min(mat1sdf(p),min(mat2sdf(p),mat3sdf(p)));\n    float minussdf = max(mat1sdf(p),max(mat2sdf(p),mat3sdf(p)));\n    float matnum = 0.0;\n    if(mat3sdf(p) == sdf)\n        matnum = 3.0;\n    else if(mat2sdf(p) == sdf)\n        matnum = 2.0;\n        else\n            matnum = 1.0;\n        return vec3(sdf,minussdf,matnum);\n}\n\n//Scene Distance Function\nfloat scenesdf(vec3 point)\n{\n    return scdstmat(point).x;\n}\n\nfloat minussdf(vec3 point)\n{\n    return scdstmat(point).y;\n}\n\nfloat getmat(vec3 point)\n{\n    return scdstmat(point).z;\n}\n\n//Get length\nfloat veclength(vec3 pos,vec3 dir)\n{\n    float depth = sta;\n    float dist = 0.0;\n    \tfor(int i = 0; i < mxmrch; i++)\n    \t{\n        \tdist = scenesdf(pos + dir * depth);\n            \tif(abs(dist) < err)\n            \t{\n                \treturn depth;\n            \t}\n        \tdepth += dist;\n        \tif(abs(depth) >= end)\n        \t{\n            \treturn end;\n        \t}\n    \t}\n    return end;\n}\n\n//Normal Estimation\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scenesdf(vec3(p.x + eserr,p.y,p.z)) - scenesdf(vec3(p.x - eserr,p.y,p.z)),\n        scenesdf(vec3(p.x,p.y + eserr,p.z)) - scenesdf(vec3(p.x,p.y - eserr,p.z)),\n        scenesdf(vec3(p.x,p.y,p.z + eserr)) - scenesdf(vec3(p.x,p.y,p.z - eserr))\n        ));\n}\n\n//Minus256 Refracting Method\nvec4 posMath(vec3 firpos,vec3 firdir)\n{\n    float leng = veclength(firpos,firdir);\n    float minusleng , plusleng = .0;\n    float mat = 0.0;\n    vec3 pos = firdir*leng;\n    vec3 dir = firdir;\n    vec3 refvec ,fravec= vec3(.0);\n    for(int i = 0;i < 10;i++)\n    {\n    mat = getmat(pos);\n        if(mat == 1.0)\n    \t{\n        \treturn vec4(pos,leng);\n    \t}\n    \telse if(mat == 2.0)\n    \t{\n        \trefvec = normalize(reflect(dir,normal(pos)));\n            plusleng = (veclength(pos,refvec));\n        \tleng += plusleng;\n        \tpos += refvec*plusleng;\n            dir = refvec;\n        }\n        else if(mat == 3.0)\n        {\n            if(length(dir+normal(pos))>sqrt(2.0))\n            {\n            \tfravec = normalize(refract(dir,normal(pos),refval));\n            \tpos -= (normal(pos)*(3.0*err));\n            \tminusleng = (veclength(pos,-fravec));\n            \tpos += (fravec*minusleng);\n            }\n            else\n            {\n                pos -= (normal(pos)*(3.0*err));\n                fravec = dir;\n            }\n            pos += (normal(pos))*(3.0*err);\n            fravec = normalize(refract(-fravec,-normal(pos),1.0/refval));\n            leng += minusleng;\n            dir = fravec;\n            pos += dir*veclength(pos,dir);\n            leng += veclength(pos,fravec);\n        }\n    }\n    return vec4(pos,leng);\n}\n\n//Phong Illumination\nvec3 phongContribForLight(vec3 k_d,vec3 k_s,float alpha,vec3 p,vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity,vec3 ffff)\n\t{\n    vec3 N = ffff;\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));   \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0)\n    {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n//Phong Illumination Collect\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,vec3 ffff) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-10.0,0.0,-50.0);\n    vec3 light1Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongContribForLight(k_d,k_s,alpha,p,eye,light1Pos,light1Intensity,ffff);\n    return color;\n}\n\n//Main Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 90.0;\n    vec3 viewDir = raydir(fov,iResolution.xy,fragCoord.xy);\n    vec3 point = vec3(0.0,0.0,1.0);\n    vec3 center = vec3(0.0,0.0,2.0);\n    vec3 roll = vec3(0.0,1.0,0.0);\n    mat3 viewToWorld = viewmat(point,center,roll);\n    vec3 worldDir = viewToWorld * viewDir;\n    vec4 posmap = posMath(point,worldDir);\n    vec3 p = point + abs(length(point - posmap.xyz)) * worldDir;\n    vec3 sp = point + veclength(point,worldDir) * worldDir;\n    vec3 snormal = normal(sp);\n    \n    vec3 a = vec3(0.3,0.3,0.3);\n    vec3 d = vec3(0.5,0.5,0.5);\n    vec3 s = vec3(1.0,1.0,1.0);\n    float al = 1.0;\n\n    vec3 normal = normal(posmap.xyz);\n    vec3 color = phongIllumination(a,d,s,al,p,point,normal);\n    vec3 scolor = phongIllumination(vec3(.0),vec3(.0),s,al,sp,point,snormal);\n    float shad = posmap.w/(4.0*end);\n    fragColor = vec4(color,al);\n       // vec4(vec3(0.5)-normal/2.0,al);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlycDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33D4", "name": "Truchet Tiling mirror solution", "author": "clem494949", "description": "Solution to Martijn's problem: https://youtu.be/2R7h76GoIJM", "tags": ["truchet", "mirror", "tiling"], "likes": 4, "viewed": 361, "date": "1568519266", "time_retrieved": "2024-06-20T19:43:44.919212", "image_code": "// Solution to Martijn's problem\n// Based on this video:\n// https://youtu.be/2R7h76GoIJM\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*.05;\n    uv *= 5.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); // random number between 0 and 1\n    \n    float width = .1;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n\tfloat angle = atan(cUv.x, cUv.y); // -pi to pi\n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    float flow = sin(iTime+checker*angle*10.);\n    \n    float x = (checker*angle/1.57-iTime*.3);\n    float y = (d-(.5-width))/(2.*width);\n    //Here the thing\n    if(n<.5 ^^ checker>0.) y=1.-y;\n    col += y*mask;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33R7", "name": "hex(SST)", "author": "Del", "description": "hex - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["hex"], "likes": 7, "viewed": 361, "date": "1568060230", "time_retrieved": "2024-06-20T19:43:44.925217", "image_code": "// Hex texture (SST)\n\n// nice hex function from - https://www.shadertoy.com/view/lldfWH\n// ret.x  - distance to border, \n// ret.y  - distance to center\n// ret.zw - cell uv\n// id - cell coordinates\nvec4 hex(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\n\nfloat hbar(vec2 p, float nline, float t)\n{\n    return 0.5+sin((p.y*nline)+t)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    //uv.x += t*0.1;\n    \n    vec2 id;\n    vec4 h = hex(uv*8.0, id);\n\n    float v = smoothstep(0.0,0.025,h.x);\n    \n    vec3 col1 = vec3(1.0,1.0,1.0);\t\t\t// hex border colour\n    vec3 col2 = vec3(0.2,0.35,0.2);\t\t\t// hex internal colour\n    \n    float cm = 1.0 + pow(sin(length(id)*4.1 + t*0.65), 4.0);\t// pulse mult\n    cm *= 1.0 + (hbar(h.zw,100.0,t*12.0)*0.1);\t\t\t\t\t// bars mult\n    col2 *= cm;\n    \n    // Output to screen\n    fragColor = vec4(mix(col1,col2,v*v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33RB", "name": "Repeating Ray March", "author": "AlexWalley", "description": "Learning how to make repetitive patterns with raymarching. It is a bit dark though, I would love to take comments and suggestions!", "tags": ["3d", "raymarching", "practice"], "likes": 2, "viewed": 147, "date": "1568775212", "time_retrieved": "2024-06-20T19:43:44.925217", "image_code": "#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n   \treturn length(max(d, 0.)) + \n        \tmin(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat sdBoxColor(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n   \treturn length(max(d, 0.));\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 map(vec3 p){\n    \n    p.xz = fract(p.xz) - 0.5;\n    p = fract(p) - 0.5;\n    \n    float barThickness = 0.45;\n    float boxDist1 = sdBox(p, vec3(0.5));\n    float boxDist2 = sdBox(p, vec3(0.6, barThickness, barThickness));\n    float boxDist3 = sdBox(p, vec3(barThickness, barThickness, 0.6));\n    float boxDist4 = sdBox(p, vec3(barThickness, 0.6, barThickness));\n    \n    float yoff = fract(iTime)-0.5;\n    \n    \n    vec3 sphPos = vec3(0.5, yoff*sign(p.x), 0.5);\n    float sphDist = length(p-sphPos) - 0.2;\n    float sphDist2 = length(p+sphPos)-0.2;\n    \n    sphPos = vec3(0.5, yoff*sign(p.x), -0.5);\n    float sphDist3 = length(p-sphPos) - 0.2;\n    float sphDist4 = length(p+sphPos)-0.2;\n    \n    vec2 res = vec2(0.);\n    res = vec2(max(-boxDist2, boxDist1), (boxDist1 < boxDist2) ? 3. : 3.);\n    res = vec2(max(-boxDist3, res.x), res.y);\n    res = vec2(max(-boxDist4, res.x), res.y);\n    \n    float a = 0.;\n    float b = 0.;\n    \n    //Ball on grid\n    float k = 0.11;\n    res.x = smin(res.x, sphDist,  k);\n    res.x = smin(res.x, sphDist2, k);\n  \tres.x = smin(res.x, sphDist3, k);\n    res.x = smin(res.x, sphDist4, k);\n    \n    return res;\n}\n\n//https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k){\n \n    float res = 1.0;\n    for(float t = mint; t < maxt;){\n        float h = map(ro + rd*t).x;\n        if(h < SURF_DIST) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    float dS = 0.;\n    float t;\n    for(t = 0.; t < MAX_STEPS; t++){\n\t\tdS = map(ro+rd*dO).x;\n        \n        if(dO > MAX_DIST) return vec2(dO, -1.);\n        if(dS < SURF_DIST) return vec2(dO, map(ro+rd*dO).y);\n        \n        dO += dS;\n    }\n    return vec2(dO, -1.);\n}\n\nvec3 applyFog(vec3 rgb, float dist){\n\n    float amount = 1.0 - exp(-dist*2.*rgb.b);\n    return mix(rgb, vec3(0.), amount);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 e = vec2(0.01, 0.);\n    float d = map(p).x;\n    return normalize(d - vec3(map(p-e.xyy).x,\n                    \t\t  map(p-e.yxy).x,\n                   \t\t\t  map(p-e.yyx).x));\n}\n\nvec3 getLight(vec3 p, vec3 ro){\n\n    vec3 lightPos = vec3(0, 0., 0.);\n    lightPos = ro + vec3(3.*sin(iTime), 0., 3.*cos(iTime));\n    vec3 n = getNormal(p);\n    \n    vec3 l = normalize(lightPos-p);\n    \n    float sunDif = max(dot(n,l), 0.);\n   \tfloat hardSha = (rayMarch(p+n*SURF_DIST*2., l).y > 0.) ? 0. : 1.;\n    float softSha = softShadow(p, l, 1., 100., 32.);\n    float skyDif = clamp(0.5 + 0.5*dot( vec3(0.,1.,0.), n), 0., 1.);\n    float bounceDif = clamp(dot(n, vec3(0.,-1.,0.)), 0., 1.);\n    float specular = pow(max( dot( reflect(-l, n), normalize(p-ro) ), 0.), 2.);\n    \n    vec3 mat = vec3(0.2);\n    \n    vec3 res = vec3(0.);\n    //res += mat*sunDif*(hardSha+0.3)*vec3(0.8, 0.6, 0.3);\n    res += mat*sunDif*softSha*vec3(0.8, 0.6, 0.3);\n    res += specular*vec3(0.8, 0.6, 0.3);\n    res += mat*vec3(0.8, 0.3, 0.6)*0.1;\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;   \n    vec3 col = vec3(0.);\n\n    \n    //============CAMERA==================\n    float zoom = 0.5;\n    \n    float t = mod(iTime, 200.)*0.2;\n    \n    vec3 ro = vec3(3.*sin(t), 1., 3.*cos(t));\n    ro = vec3(1.0);\n    //ro = vec3(1., sin(iTime)*0.5+0.5, 0.);\n    \n    \n    vec3 lookat = vec3(0.);\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i-ro;\n    \n    //Taken from Shane https://www.shadertoy.com/view/4dt3zn\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    \n    vec2 march = rayMarch(ro, rd);\n    vec3 p = ro+rd*march.x;\n    vec3 light = getLight(p, ro);\n    //Coloring\n    if(march.y < 3.5){ // Box\n    \tcol = vec3(0.4, 0.2, 0.9)*light;   \n    }\n    if(march.y < 2.5){//Ball\n     \tcol = vec3(0.4, 0.9, 0.2)*light;   \n    }\n    if(march.y < 1.5){//Ground\n\t\tcol = vec3(1.)*light;\n    }\n    if(march.y <= -0.5){//Sky\n\t\tcol = vec3(0.4, 0.65, 0.8) - 0.7*rd.y;\n        col = mix(col, vec3(1.), exp(-rd.y*15.));\n        col = vec3(0.0);\n    }\n    \n    col = applyFog(col, march.x);\n    \n    col = pow(col, vec3(1./2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33RH", "name": "Meta Ball", "author": "guspash", "description": "Simple meta ball", "tags": ["metaball"], "likes": 2, "viewed": 900, "date": "1567748406", "time_retrieved": "2024-06-20T19:43:44.925217", "image_code": "float metaball(vec2 p, vec2 pixel, float r)\n{\n    vec2 d = p-pixel;\n\treturn r / dot(d,d);\n}\nfloat metaDiamond(vec2 p, vec2 pixel, float r)\n{\n    vec2 d = abs(p-pixel);\n\treturn r / (d.x + d.y);\n}\nfloat metaEllipse(vec2 p, vec2 pixel, float r, float xM, float yM)\n{\n    vec2 d = p-pixel;\n    d.x /= xM;\n    d.y /= yM;\n\treturn r / dot(d,d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfloat r = metaball(iResolution.xy / 2., fragCoord, 200.);\n    \n\tfloat r1 = metaDiamond(iResolution.xy / 2. + vec2(sin(iTime) * 200.,  0.), fragCoord, 20.);\n    \n\tfloat r2 = metaEllipse(iResolution.xy / 2. + vec2(0., cos(iTime) * 200.), fragCoord, 50., 1., 5.);\n    \n    fragColor = vec4(vec3(r+r1+r2), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33RH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33Rj", "name": "fractal noise", "author": "Nazlbit", "description": "fractal_noise, value_noise, perlin_noise", "tags": ["fractal", "noise", "perlin"], "likes": 3, "viewed": 433, "date": "1569020785", "time_retrieved": "2024-06-20T19:43:45.925317", "image_code": "const float pi2 = radians(360.);\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n\nvec2 random_unit_vector(vec2 uv)\n{\n    float theta = random(uv)*pi2;    \n    return vec2(cos(theta), sin(theta));\n}\n\n\nvec3 random_unit_vector(vec3 uv)\n{\n    const vec3 offset = vec3(531.2346,652.56,567.3);\n    \n    float theta = random(uv)*pi2;\n    float phi = acos(1. - 2. * random(uv+offset));\n    vec3 unit_vec;\n    unit_vec.x = sin(phi) * cos(theta);\n    unit_vec.y = sin(phi) * sin(theta);\n    unit_vec.z = cos(phi);\n    \n    return unit_vec;\n}\n\nvec2 smooth_func(vec2 x)\n{\n    return x*x*x*((6.*x - 15.)*x + 10.);\n}\n\nvec3 smooth_func(vec3 x)\n{\n    return x*x*x*((6.*x - 15.)*x + 10.);\n}\n\nfloat value_noise(vec2 uv)\n{\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    \n    float lb = random(id);\n    float rb = random(id + vec2(1., 0.));\n    float lt = random(id + vec2(0., 1.));\n\tfloat rt = random(id + vec2(1., 1.));\n\n    return mix(mix(lb, rb, lv.x), mix(lt, rt, lv.x), lv.y);\n}\n\nfloat value_noise(vec3 uv)\n{\n    vec3 lv = smoothstep(0., 1., fract(uv));\n    vec3 id = floor(uv);\n    \n    float lbf = random(id);\n    float rbf = random(id + vec3(1., 0., 0.));\n    float ltf = random(id + vec3(0., 1., 0.));\n\tfloat rtf = random(id + vec3(1., 1., 0.));\n    \n    float lbb = random(id + vec3(0., 0., 1.));\n    float rbb = random(id + vec3(1., 0., 1.));\n    float ltb = random(id + vec3(0., 1., 1.));\n\tfloat rtb = random(id + vec3(1., 1., 1.));\n\t\n    float front = mix(mix(lbf, rbf, lv.x), mix(ltf, rtf, lv.x), lv.y);\n    float back = mix(mix(lbb, rbb, lv.x), mix(ltb, rtb, lv.x), lv.y);\n    return mix(front, back, lv.z);\n}\n\nfloat perlin_noise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    vec2 lb, rb, lt, rt;\n    \n    lb = random_unit_vector(id);\n    rb = random_unit_vector(id + vec2(1., 0.));\n    lt = random_unit_vector(id + vec2(0., 1.));\n    rt = random_unit_vector(id + vec2(1., 1.));\n    \n    float dlb = dot(lb, lv);\n\tfloat drb = dot(rb, lv - vec2(1., 0.));\n    float dlt = dot(lt, lv - vec2(0., 1.));\n    float drt = dot(rt, lv - vec2(1., 1.));\n\n    lv = smooth_func(lv);\n\n    return mix(mix(dlb, drb, lv.x), mix(dlt, drt, lv.x), lv.y)*1.41421356*0.5+0.5;\n}\n\nfloat perlin_noise(vec3 uv)\n{\n    vec3 lv = fract(uv);\n    vec3 id = floor(uv);\n    \n    vec3 lbf, rbf, ltf, rtf, lbb, rbb, ltb, rtb;\n\n    lbf = random_unit_vector(id);\n    rbf = random_unit_vector(id + vec3(1., 0., 0.));\n    ltf = random_unit_vector(id + vec3(0., 1., 0.));\n    rtf = random_unit_vector(id + vec3(1., 1., 0.));\n    lbb = random_unit_vector(id + vec3(0., 0., 1.));\n    rbb = random_unit_vector(id + vec3(1., 0., 1.));\n    ltb = random_unit_vector(id + vec3(0., 1., 1.));\n    rtb = random_unit_vector(id + vec3(1., 1., 1.));\n    \n    float dlbf = dot(lbf, lv);\n\tfloat drbf = dot(rbf, lv - vec3(1., 0., 0.));\n    float dltf = dot(ltf, lv - vec3(0., 1., 0.));\n    float drtf = dot(rtf, lv - vec3(1., 1., 0.));\n    \n    float dlbb = dot(lbb, lv - vec3(0., 0., 1.));\n\tfloat drbb = dot(rbb, lv - vec3(1., 0., 1.));\n    float dltb = dot(ltb, lv - vec3(0., 1., 1.));\n    float drtb = dot(rtb, lv - vec3(1., 1., 1.));\n    \n    lv = smooth_func(lv);\n    \n    float f = mix(mix(dlbf, drbf, lv.x), mix(dltf, drtf, lv.x), lv.y);\n    float b = mix(mix(dlbb, drbb, lv.x), mix(dltb, drtb, lv.x), lv.y);\n\n    return mix(f, b, lv.z)*1.154700538*0.5+0.5;\n}\n\nfloat fractal_noise(vec2 uv, float octaves)\n{\n    float c = 0.;\n    float s = 0.;\n    for(float i = 0.; i < octaves; i++)\n    {\n        float a = pow(2., i);\n        float b = 1. / a;\n        c += perlin_noise(uv*a)*b;\n        s += b;\n    }\n    \n    return c / s;\n}\n\nfloat fractal_noise(vec3 uv, float octaves)\n{\n    float c = 0.;\n    float s = 0.;\n    for(float i = 0.; i < octaves; i++)\n    {\n        float a = pow(2., i);\n        float b = 1. / a;\n        c += perlin_noise(uv*a)*b;\n        s += b;\n    }\n    \n    return c / s;\n}\n\nfloat noise(vec2 uv)\n{\n    return fractal_noise(vec3(uv, iTime*0.2), 3.);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.y);\n    \n\tfragColor = vec4(hsv2rgb(vec3(noise(uv)*10., 1., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33Rj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33RN", "name": "Gingham Vortex", "author": "isohedral", "description": "Rotating gingham vortices. A first experiment in using stream functions from stable fluid flow in complex analysis. See for example https://math.mit.edu/~jorloff/18.04/notes/topic6.pdf.", "tags": ["flow", "geometry", "tiling", "complexanalysis"], "likes": 11, "viewed": 338, "date": "1567911707", "time_retrieved": "2024-06-20T19:43:45.925317", "image_code": "const float TWOPI = 2.0*3.14159265358979;\nconst float fac = 10.0 / TWOPI;\n\n// 240, 23, 24\n// 246, 128, 126\n// 255, 255, 255\n\nvec2 eval( vec2 p, vec2 c, float strength )\n{\n    p -= c;\n    float l = log( length( p ) );\n    float ang = atan( p.y, p.x );\n    return strength * vec2( l, ang );\n}\n\nvec4 getColour( vec2 sp )\n{\n    vec2 p = 3.*(2.*sp - iResolution.xy) / iResolution.x;\n\n    vec2 ep = eval( p, vec2( -1.5, 1 ), 1.0 ) \n        + eval( p, vec2( 1.5, -1 ), 1.0 )\n        + eval( p, vec2( -1.5, -1 ), -1.0 )\n        + eval( p, vec2( 1.5, 1 ), -1.0 );\n    float d = fwidth(ep).x * 4.*fac;\n    ep = ep + 4.*vec2(-ep.y,ep.x);\n\tvec2 si = smoothstep(-.5*d,.5*d,abs(mod(fac*ep + iTime*0.75,2.)-1.)-.5);  \n\n    return 1.- (1.-vec4(1,.5,.5,0)) * (si.x+si.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = getColour( fragCoord );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33Rr", "name": "Voronoi X", "author": "flyingrub", "description": "try to recreate an organic feeling thanks to voronoi", "tags": ["voronoi", "grid"], "likes": 5, "viewed": 175, "date": "1567615282", "time_retrieved": "2024-06-20T19:43:46.725430", "image_code": "#define resolution iResolution\n#define frame iFrame\n#define pixel_width 1./iResolution.y\n\nconst float speed = .1;\nconst float grid = 10.;\nconst float falloff = 12.;\nfloat t;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh and \n// taken from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin2(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n//\n// More Voronoi shaders:\n//\n// Exact edges:  https://www.shadertoy.com/view/ldl3W8\n// Hierarchical: https://www.shadertoy.com/view/Xll3zX\n// Smooth:       https://www.shadertoy.com/view/ldB3zc\n// Voronoise:    https://www.shadertoy.com/view/Xd23Dh\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 index = floor(x);\n    vec2 gv = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 minOffset, minPoint;\n\n    float minDist = 8.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n\t\tvec2 random = hash2( index + offset );\n\t\t#ifdef ANIMATE\n        vec2 a = t+random;\n        random = 0.5 + 0.5*sin( t + 6.2831*random );\n        #endif\t\n        vec2 p = offset + random - gv;\n        float d = dot(p,p);\n\n        if( d<minDist )\n        {\n            minDist = d;\n            minPoint = p;\n            minOffset = offset;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    minDist = 8.0;\n    float smoothDist = 0.0;\t\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 offset = minOffset + vec2(float(i),float(j));\n\t\tvec2 random = hash2( index + offset );\n\t\t#ifdef ANIMATE\n        random = 0.5 + 0.5*sin( t + 6.2831*random );\n        #endif\t\n        vec2 p = offset + random - gv;\n\n        if( dot(minPoint-p,minPoint-p)>0.00001 )\n        {\n            float d = dot( 0.5*(minPoint+p), normalize(p-minPoint) );\n            minDist = min( minDist, d );\n        \tsmoothDist += exp( -falloff*d );\n        }\n    }\n    \n    smoothDist = -(1.0/falloff)*log( smoothDist );\n\n    return vec3( smoothDist, minPoint );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime*speed+10.;\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec3 c = voronoi( grid*uv );\n    vec3 col = vec3(1,1,1);\n    col *= 1.-vec3(smoothstep(pixel_width*grid, 0.00, c.x-0.01));\n\t\n    col *= smoothstep(pixel_width, 0., length(uv)-0.443);\n\t\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33Rr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td33z7", "name": "[twitch] Fluid Tank", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/FluidTank.glsl", "tags": ["3d", "raymarching", "fluid"], "likes": 33, "viewed": 1035, "date": "1568065640", "time_retrieved": "2024-06-20T19:43:47.961822", "image_code": "\n/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/FluidTank.glsl\n*/\n\nfloat time = 0.;\n\nfloat cyl(vec2 p, float s) {\n  return length(p)-s;\n}\n\nfloat sph(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off=vec3(0);\n  float dd = p.z*0.02;\n  dd = floor(dd) + smoothstep(0.,1.,smoothstep(0.,1.,fract(dd)));\n  dd *= 1.7;\n  off.x += sin(dd)*10.;\n  off.y += sin(dd*0.7)*10.;\n  \n  return off;\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat blue = 0.;\nfloat tmpo = 0.;\nfloat part1(vec3 p2) {\n    \n  // main tunnel\n  float d = -cyl(p2.xy,10.);\n  \n  // details holes\n  vec3 p3 = repeat(p2, vec3(2));\n  float db = d;\n  d = max(d, -sph(p3, 1.1));\n  d = min(d, db+2.);\n  \n  // electric arcs\n  vec3 p4 = p2;\n  p4.xy *= rot(p4.z*0.05);\n  p4.x = abs(p4.x) - 3.;\n  p4.z = repeat(p4.z, 10.);\n  p4.x += sin(p4.y*0.3 + p2.z*0.08)*2.;\n  float go = min(sin(p2.z*0.2 + time*3.)*0.6,0.);\n  float cy = cyl(p4.xz, 0.3+go);\n  tmpo = abs(cy);\n  d = min(d, cy);\n  \n  // polar coordinates\n  vec3 p5 = p2;\n  p5.x = atan(p2.y,p2.x) * 20. / 3.141592;\n  p5.x -= p2.z*0.5;\n  p5.y = length(p2.xy) - 10.;\n  \n  p5.xz = repeat(p5.xz, vec2(5,5));\n  // box on the side of tunnel\n  d = min(d, box(p5, vec3(1)));\n  \n  return d;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k) - k * (1.-k) * h;\n}\n\nfloat part2(vec3 p) {\n  \n  float d = -cyl(p.xy,25.);\n  float d1 = d;\n  \n  p.xy *= rot(sin(p.z*0.05 - time) * sin(p.z*0.07 - time)*3.);\n\n  \n  for(int i=0; i<4; ++i) {\n    \n    vec3 p3 = p;\n    \n    p3.xy *= rot(0.7*(float(i)+1.)+time*0.007);\n    p3.zy *= rot(0.9*(float(i)+1.)-time*0.009);\n    \n    p3 = repeat(p3, vec3(12 + i));\n    \n    float f = sph(p3, 1. + float(i)*1.);\n    //f = smin(f, cyl(p3.xy, 0.5), 3);\n    d = smin(d, f, 5.);\n    \n  }\n  \n  d = smin(d, d1-4., -3.);\n  \n  \n  return d;\n  \n}\n\nvec3 lpos = vec3(0,-4,0);\n\nfloat light = 0.;\n\nfloat water = 1.;\nfloat map(vec3 p) {\n  \n  p += tunnel(p);\n  \n  float d1 = part1(p);\n  float d2 = part2(p);\n  \n  vec3 p2 = p;\n  p2.z = repeat(p2.z, 120.);\n  float mi = box(p2, vec3(100,100,34));\n  \n  // mix part 1 and part 2\n  d1 = max(d1, -mi);\n  d1 = min(d1, max(d2, mi));\n  \n  // enter hatch\n  float cc = abs(cyl(p.xy,11.))-2.;\n  cc = max(cc, abs(mi)-1.);\n  d1 = min(d1, cc);\n  \n  //d1 = d2; // tmp\n  \n  // light position\n  p.z = repeat(p.z, 67.);\n  vec3 relp = lpos-p;\n  float dl = length(relp)-0.5;\n  light += 1.0/(0.2+dl*dl);\n  d1 = min(d1, dl);\n  d1 = min(d1, max(-relp.y,length(relp.xz)-0.3));\n  \n  \n  tmpo = max(tmpo, -mi);\n  blue += 0.7/(0.2+abs(tmpo));\n  \n  water = (d1 == d2) ? 0. : 1.;\n  \n  d1 *= 0.7;\n  \n  return d1;\n  \n}\n\nfloat rnd(float t) {\n  return fract(sin(t*754.652)*652.642);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time =  mod(iTime, 200.);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0,0,8);\n  vec3 t=vec3((curve(time, 1.8)-0.5)*5.,0,0);\n  \n  float advance = time * 12. + curve(time, 2.)*4.;\n  s.z -= advance;\n  t.z -= advance;\n  s -= tunnel(s);\n  t -= tunnel(t);\n  \n  //lpos = vec3(0,0,-30);\n  //lpos.z -= advance;\n  \n  //vec3 r=normalize(vec3(-uv, 1));\n  vec3 cz = normalize(t-s);\n  vec3 cx = normalize(cross(cz, vec3(sin(time*0.3)*0.3,1,0)));\n  vec3 cy = normalize(cross(cz, cx));\n  \n  float fov = 0.7 + curve(time, 2.8) * 0.7;\n  vec3 r = normalize(cx * uv.x + cy * uv.y + cz * fov);\n  \n  vec2 off=vec2(0.01,0);\n  //vec2 off=vec2(0,0.01); // This was a mistake made during the stream\n  \n  vec3 p=s;\n  int i=0;\n  float alpha = 1.;\n  float dd=0.;\n  for(i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      if(water<0.5) {\n        vec3 n=normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        alpha *= pow(1.-abs(dot(n,r)),2.0);\n        r = reflect(r,n);\n        d = 0.2;\n        if(alpha<0.01) break;\n      } else {\n        break;\n      }\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  \n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 lpos2 = lpos;\n  lpos2 -= tunnel(lpos2)*0.5;\n  vec3 pl = p;\n  pl.z = repeat(pl.z, 67.);\n  vec3 l = normalize(lpos2-p);\n  \n  float ao = clamp(map(p+n),0.,1.);\n  \n  vec3 col=vec3(0);\n  //col += pow(1-i/101.0, 6) * 3;\n  float falloff = 10./(1.+length(lpos-pl));\n  vec3 lightcol = vec3(1,0.7,0.3);\n  col += (dot(n,-l)*0.5+0.5) * falloff * lightcol * alpha * ao;\n  col += light*lightcol;\n  col += pow(dd * 0.007,4.) * vec3(0.5,0.7,1);\n  col += blue * 0.05 * vec3(0.4,0.5,1);\n  \n    \n  col *= 1.2-length(uv);\n  col = 1.-exp(-col * 2.);\n  col = pow(col, vec3(1.4));\n  \n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td33z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3GD2", "name": "Why noisy reflections?", "author": "kaneta", "description": "Help me.\n Cylinder wall noise\n Fireflies at the box corner\nI don't know why these happen and how to fix them\n\nDebug information can be displayed with the following buttons.\n\nZ - Primary Normal\nX - Reflected Ray\nC - Secondary Normal", "tags": ["reflection"], "likes": 2, "viewed": 410, "date": "1569298792", "time_retrieved": "2024-06-20T19:43:48.955975", "image_code": "#define MAT_FLOOR 0.\n#define MAT_BALL 3.\n#define MAT_LIGHT 4.\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi * 2.0;\n\n/////////////////////////\n\n// Keyboard \n\n\n// Keyboard constants definition\n// https://www.shadertoy.com/view/XdcGWS by P_Malin\n\nconst int KEY_C     = 67;\nconst int KEY_X     = 88;\nconst int KEY_Z     = 90;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel0, ivec2(key, 0), 0 ).x > 0.0;\n}\n\n/////////////////////////\n\n// Utility\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a = pi/r - atan(p.x, p.y);\n    float n = pi2/r;\n    a = floor(a/n)*n;\n    return p * rot(a);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n///////////////////////////////////////////////\n\n// Distance Functions\n// by https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 lightTube(vec3 p, float r) {\n    p.xz *= rot(pi * 0.2);\n\tp.xz = pmod(p.xz, 5.0);\n    float a = pi * 0.1;\n\tfloat s1 = sdCappedTorus(p, vec2(sin(a), cos(a)), 8.05, 0.1);\n    return vec2(s1, MAT_LIGHT);\n}\n\nvec2 object(vec3 p) {\n    vec2 s = vec2(sphere(p - vec3(0.0, cos(iTime) * 0.1, 0.0), 0.25), MAT_BALL);\n\treturn s;\n}\n\nvec2 room(vec3 p) {\n    return vec2(-cylinder(p, 8.0, 4.0), MAT_FLOOR);\n}\n\nvec2 map(vec3 p) {\n\tvec2 o = object(p - vec3(0.0, -2.0, 0.0));\n    vec2 r = room(p);\n    \n    vec2 d = min2(r, o);\n    \n    d = min2(d, lightTube(p - vec3(0.0, -3.85, 0.0), 5.0));\n    d = min2(d, lightTube(p - vec3(0.0, -0.85, 0.0), 5.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0, -2.85, 0.0), vec3(0.5)), MAT_FLOOR));\n    \n    return d;\n}\n///////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1.0, -1.0) * 0.0001;\n    return normalize(\n        e.xyy * map(p+e.xyy).x+\n        e.yxy * map(p+e.yxy).x+\n        e.yyx * map(p+e.yyx).x+\n        e.xxx * map(p+e.xxx).x\n        );\n}\n\nvoid getSurfaceParams(vec3 p, vec2 mat, out vec3 outEmission) {\n    outEmission = vec3(0.0);\n    if (mat.y == MAT_FLOOR) {\n    } else if (mat.y == MAT_BALL) {\n        outEmission = vec3(0.6, 0.05, 0.01) * 4.0 * (sin(iTime) * 0.5 + 0.5);\n    } else if (mat.y == MAT_LIGHT) {\n        outEmission = vec3(4.0);\n    }\n}\n\nvoid trace(vec3 p, vec3 ray, float tmax, int ite, out vec3 outPos, out vec2 outMat, out float depth) {\n    float t = 0.1;\n    vec3 result = vec3(0.0), pos;\n    vec2 mat;\n    for(int i = 0; i < ite; i++) {\n        if (t > tmax) break;\n        pos = ray * t + p;\n        mat = map(pos);\n        if (mat.x < 0.001) break;\n        t += mat.x;\n    }\n    depth = t;\n    outPos = pos;\n    outMat = mat;\n}\n\nvec3 render(vec3 p, vec3 ray) {\n    vec3 emission;\n    float depth;\n\n    // Primary ray\n    vec3 primaryPos;\n    vec2 primaryMat;\n    trace(p, ray, 100.0, 256, primaryPos, primaryMat, depth);\n    getSurfaceParams(primaryPos, primaryMat, emission);\n    vec3 n = normal(primaryPos);\n\n    vec3 result = emission;\n\n    // Secondary ray\n    vec3 secondaryPos;\n    vec2 secondaryMat;\n    ray = reflect(ray, n);\n    trace(primaryPos + n * 0.001, ray, 100.0, 128, secondaryPos, secondaryMat, depth);\n    getSurfaceParams(secondaryPos, secondaryMat, emission);\n    \n    // Why noisy???\n    result += emission * 0.04;\n\n    // Debug\n    if(KeyIsPressed(KEY_Z)) {\n        // Primary normal\n    \tresult = normal(primaryPos);\n    }\n    if(KeyIsPressed(KEY_X)) {\n        // Reflected ray\n    \tresult = ray;\n    }\n    if(KeyIsPressed(KEY_C)) {\n        // Secondary normal\n    \tresult = normal(secondaryPos);\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    vec3 origin = vec3(sin(iTime) * 2.0, -1.0, 5.0);\n    vec3 target = vec3(0.0, -2., 0.);\n    vec3 fo = normalize(target - origin);\n    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));\n    vec3 up = normalize(cross(fo, si));\n    vec3 ray = normalize(fo * 4.5 + si * p.x + up * p.y);\n\n\n    col += render(origin, ray);\n\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3GD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3GRj", "name": "Truchet Pattern", "author": "prozacgod", "description": "Been years since I've posted here, but wanted to do some more, Truchet pattern - based somewhat loosely on \"The Art of Code\" example from youtube.\n\nhttps://www.youtube.com/watch?v=2R7h76GoIJM\n\nhttps://www.shadertoy.com/view/3lBXWK", "tags": ["truchet"], "likes": 0, "viewed": 72, "date": "1568844054", "time_retrieved": "2024-06-20T19:43:49.452850", "image_code": "float hash(vec2 v) {\n    v = fract(v * vec2(234.23556, 992.111));\n    v += dot(v, v+34.67);\n    \n    return fract(v.x*v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 uv = fragCoord - (iResolution.xy/iResolution.y);\n    float scale = 10.0;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = ((fragCoord.xy - (iResolution.xy/2.0)) / iResolution.y) * scale;\n        \n    \n\t// rotate whole field of view\n    \n    float a = iTime * 0.1;    \n    uv = mat2(cos(a), sin(a), -sin(a), cos(a)) *\n        (\n            uv - vec2( 0.5, 0.5)\n        ) +\n        vec2( 0.5, 0.5);\n    \n    \n    vec3 col = vec3(0.0,0.0,0.0);\n   \n    // create the floating circles..\n    \n    float dist = 1.0;\n    for (int i = 0; i < 100; i++) {\n        vec2 pos = vec2(\n            (hash(vec2(i)) - 0.5) * scale * ratio,\n            (hash(vec2(i, 234.444)) - 0.5) * scale\n        );\n        \n        \n        float radius = (hash(vec2(i, 90234.4534))) / 1.0;\n        \n        // radius changes over time, scaled to a random number for max size and time ratio\n        radius = radius + ((sin(iTime * 4.0 * hash(vec2(i, 1111.23532))) + 1.0) / 2.0 * hash(vec2(i, 9911.232)));\n        \n        vec2 pathrad = vec2(\n\t\t\thash(vec2(i, 1111.23532)),\n            hash(vec2(i, 9111.23532))\n        ) * 10.0;\n        \n        float pathSpeed = hash(vec2(i, 6711.23532)) * 0.1;\n            \n        pos = pos + (vec2(sin(iTime * pathSpeed), cos(iTime * pathSpeed)) * pathrad);\n     \t\n        if (distance(uv, pos) < radius) {\n        \tfloat d = distance(uv, pos) / radius;\n            if (d < dist) {\n                dist = d;\n            }\n        }\n    }    \n    \n    col.x = 1.0-dist;\n    \n    // Truchet calculation\n    \n    vec2 c_uv = fract(uv);\n   \n    float direction = hash(floor(uv)) > 0.5 ? 1.0 : 0.0;\n    \n    // direction = 1.0;\n    // + abs(sin(iTime * 2.0) / 20.0) +\n    \n    float thickness = 0.1 + (dist / 10.0);\n    \n    float d1 = distance(c_uv, vec2(0.0, direction));\n        if (d1 > (0.5 - thickness) && d1 < (0.5 + thickness)) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    \n    float d2 = distance(c_uv, vec2(1.0, 1.0-direction));    \n    if (d2 > (0.5 - thickness) && d2 < (0.5 + thickness)) {\n        col = vec3(0.0, 1.0, 0.0);\n    }\n    \n        \n    if (c_uv.x < 0.02) {\n\t\t//col = vec3(1.0, 1.0, 1.0);\n    }\n    \n    if (c_uv.y < 0.02) {\n\t\t//col = vec3(1.0, 1.0, 1.0);\n    }    \n   \n            \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3GRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3GRl", "name": "Painting-Colors Noise", "author": "Numero7", "description": "This shader uses 3d noise and 2d to create nicely colored art moving randomly around the scene :)", "tags": ["noise", "colors", "random", "painting", "paint", "art"], "likes": 4, "viewed": 137, "date": "1569078969", "time_retrieved": "2024-06-20T19:43:49.452850", "image_code": "#define TAU 4.0 * asin(1.0)\n\nfloat HASH21(vec2 p) {\n    return fract(sin(p.x * 100.0 + p.y * 6574.0) * 5647.0);\n}\n\nfloat HASH31(vec3 p) {\n    return fract(sin(p.x * 100.0 + p.y * 6574.0 + p.z * 452.0) * 5647.0);\n}\n\n\nfloat SmoothNoise2D(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.0-2.0*lv);\n    \n    float bl = HASH21(id + vec2(0, 0));\n    float br = HASH21(id + vec2(1, 0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = HASH21(id + vec2(0, 1));\n    float tr = HASH21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise3D(vec3 uv) {\n    vec3 lv = fract(uv);\n    vec3 id = floor(uv);\n    \n    lv = smoothstep(0.0, 1.0, lv);\n    \n    float fbl = HASH31(id + vec3(0, 0, 0));\n    float fbr = HASH31(id + vec3(1, 0, 0));\n    float fb = mix(fbl, fbr, lv.x);\n    float ftl = HASH31(id + vec3(0, 1, 0));\n    float ftr = HASH31(id + vec3(1, 1, 0));\n    float ft = mix(ftl, ftr, lv.x);\n    \n    float bbl = HASH31(id + vec3(0, 0, 1));\n    float bbr = HASH31(id + vec3(1, 0, 1));\n    float bb = mix(bbl, bbr, lv.x);\n    float btl = HASH31(id + vec3(0, 1, 1));\n    float btr = HASH31(id + vec3(1, 1, 1));\n    float bt = mix(btl, btr, lv.x);\n    \n    return mix(mix(fb, ft, lv.y), mix(bb, bt, lv.y), lv.z);\n}\n\nfloat PerlinNoise2D(vec2 uv, int octaves) {\n    float c = 0.0;\n    float s = 0.0;\n    for (float i = 0.0; i < float(octaves); i++) {\n        c += SmoothNoise2D(uv * pow(2.0, i)) * pow(0.5, i);\n        s += pow(0.5, i);\n    }\n    \n    return c /= s;\n}\n\nfloat PerlinNoise3D(vec3 uv, int octaves) {\n    float c = 0.0;\n    float s = 0.0;\n    for (float i = 0.0; i < float(octaves); i++) {\n        c += SmoothNoise3D(uv * pow(2.0, i)) * pow(0.5, i);\n        s += pow(0.5, i);\n    }\n    \n    return c /= s;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float angle = TAU * iTime * 0.01;\n    \n    float x = 100.0*PerlinNoise2D(vec2(iTime * 0.02, 126.0), 4);\n    float y = 100.0*PerlinNoise2D(vec2(iTime * 0.02, -324.0), 4);\n    \n    vec2 pos = vec2(x, y);\n    vec2 luv = uv * 5.0 + pos;\n    \n    float c1 = PerlinNoise3D(vec3(luv.x, luv.y, 0.0), 16);\n    float c2 = PerlinNoise3D(vec3(luv.x, luv.y, 100.0), 16);\n    float c3 = PerlinNoise3D(vec3(luv.x, luv.y, 1000.0), 16);\n    \n    vec3 col = vec3(c1, c2, c3);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3GRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td3GWS", "name": "Jellyfish - By Dani Frank", "author": "ChibiDenDen", "description": "First try at shadertoy.\nA simple jellyfish animation", "tags": ["animation", "jellyfish", "first"], "likes": 8, "viewed": 345, "date": "1569181142", "time_retrieved": "2024-06-20T19:43:49.452850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates for y (from -1 to 1), for x (from -xMin to xMax)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // rotate 45 degrees\n    uv = vec2(uv.x*.5+uv.y*.5, uv.x*.5-uv.y*.5);\n    // tile more jellys\n    uv *= 5.;\n    \n    float idx = trunc(uv.x) + 2.*trunc(uv.y);\n    // each jelly is in range 0-1, 0-1\n    uv = fract(uv);\n\n    // bg\n    vec3 col = vec3(uv.xy*.8, .9).yxz;\n    \n    // jelly belly\n    float d = length(uv - vec2(.5))*2.;\n    float rmix = .5*sin(iTime+length(uv)*8.+idx*8.)+.5; \n    float r = mix(.4,.7,rmix);\n    float sr = 0.9;\n    float jelly = smoothstep(r, sr*r,d)*0.3;\n    col += jelly;\n    \n    // tentacles\n    if (jelly < .2) {\n        if (abs(uv.x - uv.y + sin(uv.x*18.+uv.y*18. + iTime)*0.05) < 0.008) {\n            col += smoothstep(.2,.3, uv.x+uv.y)*0.6;\n            col -= smoothstep(.8,.9, uv.x+uv.y)*0.6;\n        }    \n        else if (abs(uv.x - uv.y - .2 + sin(uv.x*18.+uv.y*18. + iTime*2.)*0.05) < 0.008) {\n            col += smoothstep(.3,.4, uv.x+uv.y)*0.6;\n            col -= smoothstep(.8,.9, uv.x+uv.y)*0.6;\n        }    \n        else if (abs(uv.x - uv.y + .2 + sin(uv.x*18.+uv.y*18. + iTime*2.)*0.05) < 0.008) {\n            col += smoothstep(.3,.4, uv.x+uv.y)*0.6;\n            col -= smoothstep(.8,.9, uv.x+uv.y)*0.6;\n        }\n    }\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td3GWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdc3W7", "name": "Julia Set Hipercomplex 3D", "author": "aaraomelo", "description": "Julia Set  Hipercomplex 3D ray march", "tags": ["fractal", "julia", "hipercomplex3d"], "likes": 5, "viewed": 175, "date": "1568661592", "time_retrieved": "2024-06-20T19:43:49.846863", "image_code": "//vec3 multiply(vec3 a,vec3 b){\n//    float r1 = sqrt(a.x*a.x+a.y*a.y);\n//    float r2 = sqrt(b.x*b.x+b.y*b.y);\n//    if(r1==0.){\n//        if(r2==0.)\n//            return vec3(-a.z*b.z,0.,0.);\n//        else\n//            return vec3(-a.z*b.z*b.x/r2,-a.z*b.z*b.y/r2,a.z*r2);\n//    }\n//    else{\n//        if(r2==0.)\n//            return vec3(-a.z*b.z*a.x/r1,-a.z*b.z*a.y/r1,b.z*r1);\n//        else{\n//            float gamma = 1.-a.z*b.z/(r1*r2);\n//            return vec3((a.x*b.x-a.y*b.y)*gamma,(a.x*b.y+b.x*a.y)*gamma,a.z*r2+b.z*r1);\n//        }\n//    }\n//}\n\nvec3 multiply(vec3 a,vec3 b){\n    \n\treturn vec3(a.x*b.x-a.y*b.y-a.z*b.z,a.x*b.y+b.x*a.y,a.x*b.x+b.z*a.z);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    mat3 rotz = mat3(\n        vec3(1., 0., 0.),\n        vec3(0.,cos(iTime), sin(iTime)),\n        vec3(0.,-sin(iTime), cos(iTime))\n    );\n    mat3 rotx = mat3(\n        vec3(cos(iTime), sin(iTime),0.),\n        vec3(-sin(iTime), cos(iTime),0.),\n        vec3(0., 0., 1.)\n    );\n    mat3 rot= rotz*rotx;\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 color = vec3(0.);\n    vec3 ro = vec3(0.0,0.0,2);\n    \n    // modify ///\n    vec3 c = vec3(-0.2,0.3,-0.85);\n    \n    for(int i = 0; i<100; i++){\n    // March\n    \tvec3 point = rot*(rd*(float(i)/100.*3.)-ro); \n    \tbool flag = false;\n        for(int j = 0;j<30;j++){\n           point = multiply(point,point)+c;\n           float mq = dot(point,point);\n           if( mq > 4.){\n               flag = true;\n               break;\n           }\n        }\n        if(!flag){          \n            color += vec3(2.*float(i)/4000., float(i)/4000.,0.0);\n        }\n    }\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdc3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcGDf", "name": "(Actually) Square Tunnel", "author": "jsbrucker", "description": "Modified version of 'square tunnel' example from the Shadertoy Wikipedia page.\n- Has flat sides and 90 degree corners instead of the approximation used in the example\n- The texture was also given a spiraling corkscrew appearance (some distortion present)", "tags": ["tunnel"], "likes": 12, "viewed": 508, "date": "1569388184", "time_retrieved": "2024-06-20T19:43:49.846863", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input: pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n    \n    // modified distance metric\n    float r = length(p)*cos(mod(a+.785, 1.57)-0.785);\n    \n    // index texture by (animated inverse) radius and angle\n    vec2 uv = vec2(1.0/r + 0.1*iTime, a + iTime/4. + .5/r);\n    \n    // pattern: stripes\n    vec2 gv = fract(5.*uv/3.14)-.5;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    float f = smoothstep(.01, -.01, d-.25);\n\n    // color fetch: palette\n    vec3 col = 0.5 + 0.5*sin(f + vec3(1.0,0.0,0.0) );\n    \n    // lighting: light at end of the tunnel    \n    col = 0.1 + col/r/4.;\n    \n    // output: pixel color\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcGDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcGRn", "name": "finty", "author": "foran", "description": "finty", "tags": ["finty"], "likes": 13, "viewed": 162, "date": "1567607168", "time_retrieved": "2024-06-20T19:43:49.846863", "image_code": "\nfloat o(vec3 p)\n{\n  return cos(p.x) + cos(p.y*.5) + cos(p.z) + cos(p.y*20. + iTime)*.1 + texture(iChannel0, p.xy*.91).r*2.5 ;//    \n}\n\nfloat water( vec3 p)\n{\n  float d = p.y + texture(iChannel1, p.xz*.1+vec2(iTime*.01)).r*.1;//+ texture(iChannel1, p.xz*.1-vec2(iTime*.05)).r*.1;//\n  d = min(d, mix(length(p-vec3(0.,1.,iTime+2.5)) - 1., length(p.xy-vec2(sin(p.z),1.+cos(p.z))) - .5, cos(iTime)*.45+.5));//\n  return d;\n}\n\nfloat map( vec3 p)\n{\n  float d = min(o(p), water(p));\n  return d;\n}\n\nvec3 rm( vec3 ro ,vec3 rd)\n{\n  vec3 p = ro;\n  for(int i=0; i<64; i++)\n  {\n    float d = map(p);\n  p += rd *d;\n  }\nreturn p;\n}\n\nvec3 normal( vec3 p)\n{\n  vec2 eps = vec2(0.01, 0.);\n  vec3 n;\n  n.x = map(p) - map(p+eps.xyy);\n  n.y = map(p) - map(p+eps.yxy);\n  n.z = map(p) - map(p+eps.yyx);\n  return normalize(n);\n}\n\nvec3 shade( vec3 ro, vec3 rd, vec3 n, vec3 p)\n{\n  vec3 col = vec3(0.);\n  col += vec3(1.) * max(0., dot(n, normalize(vec3(1.,1.,1.))))*.5;\n  vec3 fog = mix(vec3(cos(iTime)*.5+.5, .7, .5), vec3(0.,.7,1.5), rd.x) * (length(p-ro)*.05 );;\n\n  col += fog;\n  return col;\n}\n\nmat2 rot( float v)\n{\n  float a = 1.;\n  float b = sin(v)*0.1;\n  return mat2( a,-b,b,a);\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\nuv-=.5;\nuv/=vec2(iResolution.y/iResolution.x,1);\n\n  vec3 ro = vec3( 0., 1., iTime);\n  vec3 rd = normalize( vec3(uv, 1.) );\n  rd.xy = rot(iTime*.91) * rd.xy;\n  vec3 p = rm(ro ,rd);\nvec3 n = normal(p);\n\n  vec3 col = shade(ro,rd,n,p);\n  for(int i=0; i<3; i++)\n  if(water(p)<.1)\n  {\n    rd = reflect(  rd, n);\n    p += rd*.1;\n  ro = p;\n    p = rm(ro,rd);\n    n = normal(p);\n    col = vec3(0.5,.47,1.) * shade(ro,rd,n,p);\n  }\n  vec4 out_color=vec4(1.);\n  out_color=vec4(col,1.);\n  fragColor=vec4(out_color);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcGRs", "name": "Minimal Jigsaw - BW (222 chars)", "author": "FabriceNeyret2", "description": "BW version golfed from \"Minimal Jigsaw\" by Shane. [url]https://shadertoy.com/view/wddGzj[/url]", "tags": ["2tweets", "minimal", "short", "jigsaw", "golf"], "likes": 6, "viewed": 313, "date": "1569084690", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "// BW & golfed from \"Minimal Jigsaw\" by Shane. https://shadertoy.com/view/wddGzj\n\n          \n// 222 chars ( -1 by MMZ, -1 by Fab )  ( -12/16 without animation )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2  u = 8.* U /iResolution.y + iTime/vec2(1,2),\n          i = ceil(u),\n          m = mod(i,2.) - .5,\n          D = dot(m, u -= i-.5) < 0. ? -m : m,\n          c = length(u - D*.2) - .2 +u-u,\n          f = abs(u - D)*.7; f += f.y -.7;\n    O -=  28.*min(c, (fract(length(i*1e2))-.5)*D.x<0. ? max(f,-c) : f).x;\n}/*\n\n\n\n\n// 224 chars by Fab  ( -13/17 without animation )\n\n#define mainImage(O,U)                                    \\\n    vec2  u = 8.* U /iResolution.y + vec2(1,.5)*iTime,    \\\n          i = ceil(u),                                    \\\n          m = mod(i,2.) - .5,                             \\\n          D = dot(m, u -= i-.5) < 0. ? -m : m,            \\\n          f = abs(u - D)*.7 -.35,                         \\\n          c = length(u - D*.2) - .2 +u-u;  f+= f.y;       \\\n    O -=  28.*min(c, (fract(length(i*1e2))-.5)*D.x<0. ? max(f,-c) : f).x /*\n\n\n\n\n// 230 chars by Greg & Fab  ( -21 without animation )\n\n#define mainImage(O,U)                                    \\\n    vec2  R = iResolution.xy,                             \\\n          u = 8.* U /R.y + vec2(1,.5)*iTime,              \\\n          i = ceil(u),                                    \\\n          m = mod(i,2.) - .5,                             \\\n          D = dot(m, u -= i-.5) < 0. ? -m : m;            \\\n    float f = dot( abs(u - D), R/R) *.7 -.7,              \\\n          c = length(u - D*.2) - .2;                      \\\n    O -=  28.*min(c, (fract(length(i*R))-.5)*D.x<0. ? max(f,-c) : f) /*\n\n\n\n\n// 246 chars by Fab \n\n#define mainImage(O,U)                                    \\\n    vec2  R = iResolution.xy,                             \\\n          u = 4.* ( U+U - R ) /R.y + vec2(1,.5)*iTime,    \\\n          i = ceil(u),                                    \\\n          m = mod(i,2.) - .5,                             \\\n          D = dot(m, u -= i-.5) < 0. ? -m : m;            \\\n    float f = dot( abs(u - D), R/R) *.7 -.67,             \\\n          c = length(u - D*.2) - .2;                      \\\n    O += 1.- R.y/8.* min(c, (fract(length(i*R))-.5)*D.x<0. ? max(f,.06-c) : f) /*\n\n\n\n\n// 262 chars by Fab\n\n#define mainImage(O,U)                                    \\\n    vec2  R = iResolution.xy,                             \\\n          u = 4.*( U+U - R )/R.y + vec2(1,.5)*iTime,      \\\n          i = ceil(u),                                    \\\n          m = mod(i,2.) - .5,                             \\\n          D = dot(m, u -= i-.5) < 0. ? -m : m;            \\\n    float f = dot( abs(u - D), R/R) *.7 -.67,             \\\n          c = length(u - D*.2) - .2;                      \\\n    O += 1.- R.y/8.* min((fract(sin(dot(i,vec2(27, 57)))*1e5)-.5)*D.x<0. ? max(f,.06-c) : f, c) /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcGRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcGzN", "name": "warlokkz - transformation", "author": "warlokkz", "description": "translate & rotation exercise", "tags": ["motion"], "likes": 1, "viewed": 58, "date": "1567920657", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "#define R iResolution.xy\n#define T iTime\n#define TPW 3./R.y\n\nfloat circle(in vec2 st, float r) {\n\tvec2 dst=st-vec2(.5);\n    return 1.-smoothstep(r-TPW,r+TPW,\n                         dot(dst,dst)*4.);\n}\nfloat box(in vec2 st, in vec2 sz){\n    sz = vec2(0.5)-sz*0.5;\n    vec2 uv = smoothstep(sz,sz+vec2(TPW),\n                        st);\n    uv *= smoothstep(sz,sz+vec2(TPW),\n                    vec2(1.0)-st);\n    return uv.x*uv.y;\n}\nfloat plus(in vec2 st, float sz){\n    return  box(st, vec2(sz,sz/4.)) +\n            box(st, vec2(sz/4.,sz));\n}\nmat2 rotate2d(float ang) {\n\treturn mat2(cos(ang),-sin(ang),\n                sin(ang),cos(ang));\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = (2.*U-R)/R.y;\n    vec3 col = vec3(0.);\n    float fn=(tan(T)+3.)*.25;\n    vec2 tr=vec2(fn);\n    uv += tr*.5;\n    \n    uv -= vec2(.5);\n    uv = rotate2d(50./fn)*uv;\n    uv += vec2(.5);\n    \n    float crs=plus(uv,0.4);\n    float crc=circle(uv,0.15);\n    col += vec3(mix(crs,crc,step(.8,fn)));             \n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdcGzs", "name": "Energy Bubble", "author": "j0", "description": "Started as a snow effect shader and now we're here :]", "tags": ["snow"], "likes": 8, "viewed": 218, "date": "1569146940", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "#define HARDNESS 25.\n#define AMOUNT 90\n#define MAX_DISTANCE 20.\n#define SPEED 0.2\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k ){\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius){\n    return length(uv-pos) - radius;\n}\n\nfloat sdLine(vec2 uv, vec2 start, vec2 end){\n    return 0.;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec4 N24(vec2 p){\n \tfloat x = N21(p);\n    float y = N21(vec2(x, p.x));\n    return vec4(x, y, N21(vec2(y, x)), N21(vec2(x, y)));\n}\n\nfloat Star(vec2 uv, float dist, vec2 id){\n    \n    vec4 rand = N24(id);\n    \n    float progress = fract(-iTime*SPEED + rand.z);\n    \n    vec2 dir = 2.*(normalize(rand.xy)-0.5);\n    \n    rand.w = clamp((rand.w-0.5)*999., -1., 1.);\n    dir *= rand.w;\n    \n    return smin(dist, sdCircle(uv, dir * progress * MAX_DISTANCE, 0.01)/(progress+0.7), 9.);\n}\n\nfloat Graph(vec2 uv){\n    \n    uv *= mix(length(uv), 1., 0.8+cos(iTime*10.)*0.01);\n    \n    float dist = sdCircle(uv, vec2(0., 0.), 0.4);\n    \n    dist = Star(uv, dist, vec2(1., 1.));\n    \n    for(int s = 1; s < AMOUNT; ++s)\n        dist = Star(uv, dist, vec2(-1., s));\n    \n    dist *= HARDNESS;\n    \n    dist = max(dist, 0.);\n    dist = 1./(dist+0.001);\n    dist *= length(uv);\n    \n    return dist;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    float angle = iTime * 0.4;\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n    mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n    uv *= rot;\n\n    vec3 col = vec3(0);\n    \n    uv *= 2. + sin(iTime*0.876)*0.5;\n    \n    float m = Graph(uv);\n    \n    vec3 tint = vec3(\n        \t\t\t\tsin(iTime*1.19+9684.927)*0.5+0.5,\n        \t\t\t\tsin(iTime*1.18+968.927)*0.5+0.5,\n        \t\t\t\tsin(iTime*1.17+96.927)*0.5+0.5\n    \t\t\t\t);\n    tint = mix(vec3(0., 1., 1.), tint, 0.5);\n    \n    col += m*mix(tint, vec3(1., 1., 1.), m);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdcGzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdd3RB", "name": "testing art of code", "author": "hexdump", "description": "Just a simple circle shader", "tags": ["simple", "circle"], "likes": 1, "viewed": 97, "date": "1569327101", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "vec4 drawCircle(vec2 center, vec2 uv, float radio, vec4 color)\n{\n    float d = length(uv-center);\n    float c = 1.0-smoothstep(radio-0.01, radio,d);\n\n    color *= c;\n    color.w = 1.0;\n    return color;\n}\n\nvec4 drawVBand(vec2 uv, float x, float width, vec4 color, float blur)\n{\n   \tfloat halfWidth = width/2.;\n    float rightBand = smoothstep(x-halfWidth,x-halfWidth+blur, uv.x);\n    float leftBand = 1.-smoothstep(x+halfWidth,x+halfWidth+blur, uv.x);\n    \n    return leftBand*rightBand*color;\n}\n\nvec4 drawHBand(vec2 uv, float y, float width, vec4 color, float blur)\n{\n   \tfloat halfWidth = width/2.;\n    float dithering = width/100.;\n    float rightBand = smoothstep(y-halfWidth,y-halfWidth+blur, uv.y);\n    float leftBand = 1.-smoothstep(y+halfWidth,y+halfWidth+blur, uv.y);\n    \n    return leftBand*rightBand*color;\n}\n\nvec4 drawRect(vec2 uv, float centerX, float centerY, float widthX, float widthY, vec4 color, float blur)\n{\n\tvec4 fragColor = drawHBand(uv, centerX, widthY, color, blur);\n    fragColor *= drawVBand(uv, centerY, widthX, color, blur);\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord.xy/iResolution.xy; // 0 - 1\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    uv.y += cos(uv.x*10.+iTime*5.)*0.2;\n    \n    /*fragColor = drawHBand(uv, 0., 0.3, vec4(1.,0.,0.,1.));\n    fragColor = drawHBand(uv, 0., 0.01, vec4(1.,0.,0.,1.));*/\n    \n    float widthX = 0.8;\n    float blur = smoothstep(0.,0.5,uv.x)/0.5;\n    fragColor = drawRect(uv, 0., 0.,widthX,0.2, vec4(1.,0.,0.,1.), blur);\n    \n}\n\n\n\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord.xy/iResolution.xy; // 0 - 1\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    fragColor = drawCircle(vec2(0,0), uv, 0.5, vec4(1,1,0,1));\n    fragColor -= drawCircle(vec2(0,0), uv, 0.4, vec4(1,1,1,1));\n    fragColor += drawCircle(vec2(0,0.1), uv, 0.4, vec4(1,1,0,1));\n    fragColor -= drawCircle(vec2(0.2,0.3), uv, 0.1, vec4(1,1,1,1))*2.0;\n    fragColor -= drawCircle(vec2(-0.2,0.3), uv, 0.1, vec4(1,1,1,1))*2.0;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdd3RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdd3W2", "name": "black hole with diamond ring", "author": "n88", "description": "random things while trying to learn", "tags": ["circle", "rainbow"], "likes": 7, "viewed": 228, "date": "1569335794", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "float dmd(vec2 uv, vec2 p, float size, float intensity){\n    uv -= p;\n\tfloat m = mix(2.*abs(uv.x) + abs(uv.y),length(uv),.4);\n    float shp = m;\n    shp = smoothstep(size + .02,size,m);\n    shp -= smoothstep(size  ,size - .02,m);\n\tshp += intensity*smoothstep(size - .019  ,size - .05,m);\n    //m -= smoothstep(size -.1 ,size -.2,m);\n    shp += .1*smoothstep(size + .3,size - .1, length(uv));\n\treturn clamp(shp,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec2 cursor = 2.*iMouse.xy/iResolution.xy-1.;\n\tcursor.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    col += 2.*(1.-abs(uv.y))*vec3(.1,.05,.2);\n    \n    float innerCircle = smoothstep(.35, .43, length(uv));\n    \n    col += .1*vec3(.1, .2, .8)*smoothstep(-.01, .01, sin(uv.x*12.*cos(uv.y) + iTime)*cos(uv.y*12. - iTime*.3));\n    col += vec3(.8, .0, .4)*smoothstep(.42, .41, length(uv)+.015*sin(uv.x*34.*cos(uv.y) - iTime)*cos(sin(iTime) + uv.y*34. - iTime*.3));\n    \n    col *= innerCircle;\n    \n    \n\t\n    float asp = iResolution.x/iResolution.y;\n\tfor (float i = -3.1415; i <= 3.1415; i+=.35) {\n\t\tvec2 pos = vec2(.5*cos(.1*iTime+i),.8*sin(1.*iTime+i));\n        float scale = .4 + .15*sin(1.*iTime+i+1.57);\n        float blink = fract(i*10.);\n        vec3 color = vec3(.5+.5*sin(iTime-i+2.),.5+.5*sin(iTime-i-2.),.5+.5*sin(3.*iTime-i-.4));\n        //scale = .5;\n        if (scale >= .3)\n    \t\tcol += color*dmd(uv, pos, scale*.3, blink);\n        else {\n            col += color*dmd(uv, pos, scale*.3, blink)*innerCircle;\n            //col *= innerCircle;\n        \t//col = vec3(smoothstep(.4, .41, length(uv)));\n        }\n        \n        //if (scale <= .3) col *= 0.; //smoothstep(.4, .41, length(uv));\n    }\n        \n    \n    //col *= smoothstep(.3, .31, length(uv));\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdd3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdd3W8", "name": "throughColor", "author": "foran", "description": "throughColor", "tags": ["throughcolor"], "likes": 3, "viewed": 66, "date": "1568404349", "time_retrieved": "2024-06-20T19:43:50.252923", "image_code": "#define PI 3.14159\n\nvec2 modA(vec2 p, float c)\n{\n  float a = atan(p.y,p.x);\n  a = mod(a , c);\n\n  return vec2(cos(a),sin(a)) * length(p);\n}\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(.5 + .5 * (b -a)/k,0.,1.);\n  return mix(b,a,h) - k * h *(1. - h);\n}\n\nmat2 rot(float a)\n{\n  float sa = sin(a);  float ca  = cos(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\n#define time (iTime)\n\nfloat map(vec3 p, out float id)\n{\n  id = 0.;\n  float dist  = 10000.;\n  vec3 cp = p;\n  p.yz = modA(p.yz, 6.);//   \n  p.yz *= rot(p.x * .75 + time*2.);//  \n  p.y += 3.;//  \n  float co = length(p.yz) - (1. + sin(p.x) * .58);//  \n\n  p = cp;\n  float ti = time;\n  for(float i  = 1.; i < 5.; ++i)//    \n  {\n    p.y += (sin(ti + p.x ) + cos(ti + p.z)) * 1.13;//  \n    dist = smin(length(p) - .85, dist, 1.25);//    \n    ti += i * .2;\n    p *= 1.1;// FOP   -\n    p.xz *= rot(.25 + i);//    xz\n    p.yz *= rot(i * 2.);//    yz\n    p.x += .6;\n  }\n\n  if(co < .01) id = 1.;//  \n  dist = min(dist , co);\n  return dist;\n}\n\nfloat Ray(inout vec3 cp, vec3 rd, out float id)\n{\n  float st = 0.;\n  float cd = 0.;\n  for(; st < 1.; st += 1. / 40.)  //128.)  // \n  {\n    cd = map(cp, id);\n    if(cd < .01) break;// epsilon=0.01\n    cp += rd * cd * .45;\n  }\n\n  return st;\n}\n\nvec3 normal(vec3 p)\n{\n  float id;\n  float m = map(p, id);\n  vec2 e = vec2(.01,.0);\n  return normalize(vec3(\n  m - map(p + e.xyy, id),\n  m - map(p + e.yxy, id),\n  m - map(p + e.yyx, id)\n));\n}\n\nvec3 LookAt(vec3 eye, vec3 sub,vec2 uv)\n{\n  vec3 fo = normalize(sub - eye);\n  vec3 ri = cross(fo, vec3(0.,1.,0.));\n  vec3 up = cross(ri,fo);\n  return normalize(fo + ri * uv.x + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n\n  vec3 eye = vec3(0.,0.,-12.);//  FOV\n  vec3 sub = vec3(0.);\n  vec3 cp = eye;\n  float st = 0.;\n  float id = 0.;\n  vec3 rd = LookAt(eye, sub, uv);\n  st = Ray(cp, rd, id);\n  vec3 ld = normalize(sub - eye);\n  vec3 norm = normal(cp);//  cp  Ray\n  float li = dot(ld, norm);\n  li = 1. - li;\n  li *= 1.5;// \n  li = pow(li, 2.);\n  norm.xy *= rot(time + cp.z);\n  norm.xz *= rot(time + cp.y);\n  norm.yz *= rot(time + cp.x);\n  vec4 out_color=vec4(1.);\n  out_color = vec4(norm, 0.) * li;\n  out_color *= (1. - st) * (5. );\n  fragColor=vec4(out_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdd3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddGRr", "name": "trippy breathing exercise", "author": "1nsignia", "description": "breathe\n\n15min shader exercise meant for a minigame and discarded in favour of visual coherency of the game", "tags": ["trippy", "breathing"], "likes": 3, "viewed": 124, "date": "1567688306", "time_retrieved": "2024-06-20T19:43:50.259002", "image_code": "#define PI 3.1416\n\nvec3 bg(vec2 uv) {\n    return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\n\nvoid fold(inout float dist, float w) {\n    dist = abs(dist) - w;\n}\n\nvoid foldall(inout float dist, float w, float o) {\n    if (dist <= 0.)\n    \tdist = abs(mod(dist - w/2. + o*w, 2.*w) - w) - w/2.;   \n}\n\nfloat mixsin(float a, float b, float speed) {\n    return mix(a, b, sin(iTime * speed)/2.+.5);\n}\n\nfloat tri(in vec2 p)\n{\n    // https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat dist(vec2 uv) {\n    float ang = atan(uv.x, uv.y);\n    \n    float o = sin(abs(abs(ang) * 5. + iTime*4.));\n    float s = mixsin(1.1, 8., 1.4);\n    \n    float d = length(uv) - mixsin(.3, .9, 1.) + o * 0.03; //  mixsin(0.03, 0.3, .89);// 0.03;\n    float dd = tri(uv * s) / s;\n    \n    d = max(min(d, dd), -max(d, dd));\n    \n    foldall(d, .05, iTime*5.);\n    \n    return d;\n}\n\nvec3 viz(float d, float r) {\n\tvec3 c = vec3(0);\n    \n    if (d < 0.)\n        c.r = 1. - fract(d * r);\n    else if (d > 0.)\n        c.g = fract(d * r);\n    else\n        c.b = 1.;\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy - .5) * 2.;\n    uv *= vec2(iResolution.x/iResolution.y,1);\n\n    vec3 col = bg(uv);\n    \n    float d = dist(uv);\n    col = mix(col, vec3(.9), smoothstep(0.005, 0., d));\n    \n    // col = viz(d, 8.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddGRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddGWf", "name": "Shape tests", "author": "Clinery", "description": "It displays shapes, nothing to it", "tags": ["shapes"], "likes": 0, "viewed": 72, "date": "1569428549", "time_retrieved": "2024-06-20T19:43:50.259002", "image_code": "bool circle(float radius,float width,vec2 position,vec2 xy) {\n    float res=(pow(xy.x-position.x,2.0))+(pow(xy.y-position.y,2.0));\n    return (res<pow(radius+width,2.0))&&(res>pow(radius,2.0));\n}\nbool fillCircle(float radius,vec2 position,vec2 xy) {\n    float res=(pow(xy.x-position.x,2.0))+(pow(xy.y-position.y,2.0));\n    return res<pow(radius,2.0);\n}\nbool square(float sideLength,float width,vec2 position,vec2 xy) { // Position is the center of the shape\n    float halfLength=sideLength/2.0;\n    float x=xy.x;float y=xy.y;\n    return ((x>position.x-halfLength)&&(x>(position.x-halfLength)-width))&&\n           ((x<position.x+halfLength)&&(x<(position.x+halfLength)+width))&&\n           ((y>position.y-halfLength)&&(y>(position.y-halfLength)-width))&&\n           ((y<position.y+halfLength)&&(y<(position.y+halfLength)+width));\n}\nbool fillSquare(float sideLength,vec2 position,vec2 xy) {\n    float halfLength=sideLength/2.0;\n    float x=xy.x;float y=xy.y;\n    return (x>position.x-halfLength)&&(x<position.x+halfLength)&&(y>position.y-halfLength)&&(y<position.y+halfLength);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time=iTime/5.0;\n    vec3 col=vec3(0.5,0.0,1.0);\n    bool circle1=circle(100.0,10.0,iResolution.xy/2.0,fragCoord.xy);\n    bool circle2=fillCircle(100.0,vec2(iResolution.x/2.0+100.0,iResolution.y/2.0),fragCoord.xy);\n    float x=fragCoord.x;\n    float y=fragCoord.y;\n    float tolerance=1.0;\n    \n    // The equation for the x sine wave\n    float tmp=(32.0*sin((x/20.0)+time*8.0))+iResolution.y/2.0;    float half33=iResolution.y/2.00-33.0;\n    \n    // The x sin wave\n    if (y-tolerance<tmp&&y+tolerance>tmp&&x<half33) {col=vec3(0.0);}\n    // The circle\n    if (circle(32.0,2.0,vec2(iResolution.y/2.0),vec2(x,y))) {col=vec3(0.0);}\n    // The equation for the y cosine wave\n    float tmp2=(32.0*cos((y/20.0)+time*8.0))+(iResolution.y/2.0);\n    // The y cosine wave\n    if (x-tolerance<tmp2&&x+tolerance>tmp2&&y<half33) {col=vec3(0.0);}\n    \n    if ((x>half33&&x<half33+33.0)||(x>half33&&fillCircle(33.0,vec2(iResolution.y/2.0),vec2(x,y)))) {\n        tmp= (32.0*sin((half33/20.0)+time*8.0))+(iResolution.y/2.0);\n        tmp2=(32.0*cos((half33/20.0)+time*8.0))+(iResolution.y/2.0);\n        if (y-tolerance<tmp&&y+tolerance>tmp&&x<tmp2) {\n        \tcol=vec3(1.0,0.0,0.0);\n        }\n    }\n    if ((y>half33&&y<half33+33.0)||(y>half33&&fillCircle(33.0,vec2(iResolution.y/2.0),vec2(x,y)))) {\n        tmp= (32.0*sin((half33/20.0)+time*8.0))+(iResolution.y/2.0);\n        tmp2=(32.0*cos((half33/20.0)+time*8.0))+(iResolution.y/2.0);\n        if (x-tolerance<tmp2&&x+tolerance>tmp2&&y<tmp) {\n        \tcol=vec3(1.0,0.0,0.0);\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddGWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tddGzf", "name": "Rubik's Transformation (wip)", "author": "cmarangu", "description": "Inspriation: some gifs by wblut and muratpak on Twitter\n[url]https://twitter.com/wblut/status/1157370352718307328[/url]\n[url]https://twitter.com/muratpak/status/1234879106774372353[/url]", "tags": ["wip"], "likes": 4, "viewed": 375, "date": "1569032464", "time_retrieved": "2024-06-20T19:43:53.447204", "image_code": "// /*\n// Current code for \"Rubik's Transformation\"\n// Title: -\n// Started: 2020 3/13\n// Tags: wip\n// Description: Inspriation: some gifs by wblut and muratpak on Twitter\n//     [url]https://twitter.com/wblut/status/1157370352718307328[/url]\n//     [url]https://twitter.com/muratpak/status/1234879106774372353[/url]\n\n// 2020 7/11 I've been working on this on and off for a long time now. I think\n//   i've finally formulated the idea for the generalized algorithm for\n//   splicing space in my head now - it would be nice to finally get this\n//   project over with as also btw i had a faulty prototype (though laggy with\n//   only a few panes and texture mapping from the original space was not\n//   working)\n//\n//   so today i restarted from scratch (except for code to trace/march onto\n//   primitives and code to render to screen a specular-mapped thing i.e. we\n//   are restarting the inter_shattered() function (the core of this entire\n//   shaer)\n//\n// 2020 8/9 Picking up this project after another few weeks' inactivity.\n//   Managed to kill a number of straggler bugs and am about to implement the\n//   rotation as described at\n//   http://paulbourke.net/geometry/rotate/\n//\n// 2020 8/11 So I think I've finally got it working lol. Took forever. very\n//   complicated, but it seems to be getting the normals right now,\n\n// TODO:\n// - make the actual thing, and work\n//   - delete unused variables\n//   - to fix some bugs:\n//     - abs(SDFp) < 1e-4 may be contradicting p += d*1e-3\n//     - increase max steps to about 1 million\n//     - multiply step size by ~1/2\n//     - try improving newly-added-face detection\n//     - multisample pixel position from 4x4 square grid\n//     - fix normals of both inter_closest and panes\n//\n// then play around w it\n// - schlick fractal gradient-noise water\n// - shattered tribar (voxel w specular highlights)\n//   - shadow on self (point lights rotate around inverted circle)\n//   - black/cyan tinted glass\n\n// - shattered wire cube\n// - shattered infinite world//cylinder\n// - shattered 4x4x4 aqua/pearl spheres\n// - / frameblend\n\n\n\n// i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459230\n//7816406286208998628\n#define TAU PI*2.\n\n#define arg mod(float(iFrame)/60./14., 1.)\n\n\n\n\n\n\n\n\n\n// sky map\n\nvec3 sky_map (vec3 d) {\n    //return abs(d);\n    //return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    \n    float dimness = .5+.5*clamp(cos(d.y*PI), -.8, .8);\n    \n    //return texture(iChannel2, d).rgb;\n    \n    vec3 aus = vec3(0.);\n    float licht;\n    licht = clamp(dot(d, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n    aus += vec3(1.)*pow(licht, 1.);\n    licht = clamp(dot(d, normalize(vec3(0., 1., 1.)) ), 0., 1.);\n    aus += vec3(0., 0., 1.)*pow(licht, 5.);\n    \n    \n    //vec2 pl = d.xz/d.y*6.;\n    //if (d.y < 0.) { aus += mod(floor(pl.x)+floor(pl.y), 2.); }\n    \n    //return clamp(aus, 0., 1.);\n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n        // dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return clamp(SKY_COLOR*pow(dimness, .05), 0., 1.);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(\n            .0+.8*texture(iChannel1, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-\n            2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return clamp(GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.)), 0., 1.);\n    \n    }\n\n}\n\n\n\n\n\n// related to tracing onto things (return distance and normal)\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// plane - one liner lol\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n\n#define inter_plane_short(p, d, c, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(c-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) (\\\n//dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n// sphere\n#define SDF_sphere(p, c, r) ( length(p-c)-r )\n\n// #define inter_sphere(p, d, c, r) ( dot(d, c-p)\n\n\n// SDF\n\n#define SDF_sq(p) ( length(max(abs(p)-.98, 0.))-.015 )\n//#define SDF_core(p) ( length(max(abs(p)-.8, 0.))-.015 )\n//#define SDF(p) max(SDF_sq(p), -SDF_core(p) )\n#define SDF(p) SDF_sq(p)\n//#define SDF(p) ( length(p)-2. )\n\n\n\n\n#define inf vec2(1e-3, 0.)\n\n#define dSDF(p) normalize(vec3(SDF(p+inf.xyy),SDF(p+inf.yxy),SDF(p+inf.yyx))-SDFp)*sign(SDFp)\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // return inter_sphere(p, d, vec3(0.), .5);\n    float SDFp;\n    \n    vec3 camp = p;\n    \n    //for (int i=0; i<1333222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        if (abs(SDFp) < 1e-4) {\n            return vec4(dSDF(p), length(p-camp));\n        }\n        //p += d*abs(SDFp)*.5;\n        p += d*abs(SDFp);\n        if (abs(SDFp) > 10.) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\n\n\nvoid shift_shard (inout vec3 p, inout vec3 d, vec3 c, vec3 n, float angtot, float amt, out mat3 rot) {\n    #define iv .4\n    //p += n*.1*clamp(amt/iv, 0., 1.);\n    //p += n*.01;\n    //p -= n*.1*clamp((amt-iv)/(1.-iv), 0., 1.);\n    //p += n*.05;\n    //p += n*.2*amt;\n    \n    float arg4 = clamp((amt-iv)/(1.-iv), 0., 1.);\n    \n    #define easen 5.\n    //arg4 = 1.- pow(.3, floor(arg4*(easen*2.-1.)/2.-.5)+1.) * abs(sin(PI*( arg4*(easen*2.-1.)/2. - .5)  ));\n    #undef easen\n    \n    arg4 = .5-.5*cos(arg4*PI);\n    \n    p -= c;\n    // d -= c;\n    \n    \n    // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    float th = arg4*angtot;\n    float costh = cos(th);\n    float ONE_MIN = 1.-costh;\n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    p = rot*p;\n    d = rot*d;\n    \n    th = -th;\n    costh = cos(th);\n    ONE_MIN = 1.-costh;\n    /*rot = mat3(\n        cos(th)+n.x*n.x*(1.-cos(th)),     n.x*n.y*(1.-cos(th))-n.z*sin(th), n.x*n.z*(1.-cos(th))+n.y*sin(th),\n        n.y*n.x*(1.-cos(th))+n.z*sin(th), cos(th)+n.y*n.y*(1.-cos(th)),     n.y*n.z*(1.-cos(th))-n.x*sin(th),\n        n.z*n.x*(1.-cos(th))-n.y*sin(th), n.z*n.y*(1.-cos(th))+n.x*sin(th), cos(th)+n.z*n.z*(1.-cos(th))\n    );*/\n    \n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    //nc = n;\n    //nc = vec3(1., 0., 0.);\n    \n    p += c;\n    // d += c;\n    //#undef iv\n}\n\n\n#define numpanes 5\nvec4 inter_shattered (vec3 p, vec3 d, vec3 panec[numpanes],\n    vec3 panen[numpanes], float angtot[numpanes], inout vec3 pT, inout vec3 dT, out int midspace) {\n    //pT = p; dT = d; return inter_SDF(p, d);\n    float arg2 = min(arg*2., 2.-arg*2.);\n    //arg2 = max(1.+(arg2-1.)*1.0, 0.);\n    arg2 = min(arg2*1.4, 1.);\n    arg2 = max(1.-(1.-arg2)*1.4, 0.);\n    vec4 inter_closest;\n    vec4 inter_pane1;\n    vec4 inter_pane1T;\n    vec4 inter_SDF1;\n    //\n    float arg3; mat3 rottot = mat3(1.); mat3 rottot_; mat3 rot;\n    // for jumps\n    inter_closest = inter_sky;\n    pT = p;\n    dT = d;\n    midspace = 0;\n    //for (int i=0; i<numpanes; ++i) {\n    for (int i=numpanes-1; i>=0; --i) {\n        pT = p;\n        dT = d;\n        arg3 = clamp(arg2*float(numpanes)-float(i), 0., 1.);\n        if (arg3 == 0.) {continue;}\n        \n        if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n            // upper space - no transform\n            inter_pane1 = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            if (inter_pane1.w < inter_closest.w) {\n                inter_closest = inter_pane1;\n            }\n        }\n        else {\n            // keep track of plane in original space\n            inter_pane1 = inter_plane(p, d, panec[i], panen[i]);\n            // warp space and check stuff\n            shift_shard(pT, dT, panec[i], panen[i], angtot[i],\n                arg3, rot\n            );\n            \n            rottot_ = rottot;\n            // rottot = rot*rottot;\n            rottot = rottot * rot;\n            \n            inter_pane1T = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            \n            if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n                // midspace - can only trace onto 2 planes to escape\n                midspace += 1;\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n                if (inter_pane1.w < inter_closest.w) {\n                    // we are dealing in untransformed space\n                    // this one pane gets the texture coords of\n                    // upper space\n                    pT = p;\n                    dT = d;\n                    inter_closest = inter_pane1;\n                    inter_closest.xyz = rottot_ * inter_closest.xyz;\n                }\n            }\n            else {\n                // lower space - can only trace onto transformed\n                // pane or obj\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n            }\n            \n        }\n        p = pT;\n        d = dT;\n    }\n    if (midspace == 0) {\n        inter_SDF1 = inter_SDF(pT, dT);\n        if (inter_SDF1.w < inter_closest.w) {\n            inter_closest = inter_SDF1;\n        }\n        inter_closest.xyz = rottot*inter_closest.xyz;\n    }\n    \n    \n    \n    return inter_closest;\n    //return inter_sky;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 panec[numpanes];\n    vec3 panen[numpanes];\n    float angtot[numpanes];\n    \n    panec[0] = vec3(.03, 0., 0.);\n    panec[1] = vec3(.0, .1, .0);\n    panec[2] = vec3(.0, .0, .0);\n    panec[3] = vec3(.4, .4, .4);\n    panec[4] = vec3(.0, 0., 0.);\n    \n    panen[0] = normalize(vec3(0., 1., 1.));\n    panen[1] = normalize(vec3(1., 0., 0.));\n    panen[2] = normalize(vec3(0., 0., 1.));\n    panen[3] = normalize(vec3(-1.));\n    panen[4] = normalize(vec3(-1., 1., 0.));\n    \n    angtot[0] = PI;\n    angtot[1] = PI*.5;\n    angtot[2] = PI*.5;\n    angtot[3] = TAU/3.;\n    angtot[4] = PI;\n    \n    \n    #define spp 1\n    #define spw 1.\n    vec3 finalCol = vec3(0.);\n    vec3 randy;\n    float ox; float oy;\n    for (ox=0.; ox<spw; ++ox) {\n        for (oy=0.; oy<spw; ++oy) {\n            #define samplei 0.\n            //for (float samplei=0.; samplei<float(spp); ++samplei) {\n                randy = vec3(\n                    fract(sin(\n                        mod(\n                            samplei*21.463049023049+\n                                (float(iFrame)+fragCoord.x)*0.021415,\n                            TAU\n                        )+fragCoord.y*52.2324352432\n                    )),\n                    fract(sin(\n                        mod(\n                            samplei*421.83743204984+\n                                (float(iFrame)+fragCoord.x)*8.234203,\n                            TAU\n                        )+fragCoord.y*123.242543465\n                    )),\n                    fract(sin(\n                        mod(\n                        samplei*952.13454543556+\n                            float(iFrame)*8.234203,\n                        TAU\n                        )+fragCoord.y*.003432443\n                    ))\n                );\n                vec2 screen = (fragCoord.xy+vec2(ox, oy)/spw+randy.rg/spw-iResolution.xy/2.)/iResolution.y;\n                \n                // camera\n                vec3 camp = vec3(0., 0., -4.);\n                vec3 camd = normalize(vec3(screen.x, screen.y, 1.));\n                \n                float ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n                mat2 zenith = mat2(\n                    cos(ph), cos(PI*.5+ph),\n                    sin(ph), sin(PI*.5+ph)\n                );\n                camd.yz *= zenith;\n                camp.yz *= zenith;\n                \n                float th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n                th += arg*TAU;\n                mat2 azimuth = mat2(\n                    cos(th), cos(PI*.5+th),\n                    sin(th), sin(PI*.5+th)\n                );\n                camd.xz *= azimuth;\n                camp.xz *= azimuth;\n                \n                camd = normalize(camd);\n                \n                camp += camd*(randy.b*2.-1.)*1e-2;\n                \n                // retina color at point from raytracing\n                vec3 retina = vec3(0.);\n                float shiny = 1.;\n                vec4 inter_shattered1;\n                vec3 p = camp;\n                vec3 d = camd;\n                vec3 pT;\n                vec3 dT;\n                int midspace;\n                bool wasout;\n                bool isout;\n                vec3 pT2;\n                vec3 dT2;\n                \n                //vec4 inter_cam = inter_plane(\n                //    p, d, normalize(p)*.5, normalize(p-vec3(0.))\n                //);\n                //p += d*inter_cam.w;\n                \n                for (int bounces=0; bounces<37; ++bounces) {\n                    if (shiny < .1) {\n                        break;\n                    }\n                    inter_shattered1 = inter_shattered(\n                        p, d, panec, panen, angtot, pT, dT, midspace\n                    );\n                    if (inter_shattered1.w >= inter_sky.w) {\n                        // too far - hits sky\n                        break;\n                    }\n                    else {\n                        p += d*inter_shattered1.w;\n                        pT += dT*inter_shattered1.w;\n                        \n                        \n                        wasout = midspace > 0 || SDF(pT) > 1e-3;\n                        inter_shattered(\n                            p+d*1e-2, d, panec, panen, angtot, pT2, dT2, midspace);\n                        \n                        //if (abs(SDF(pT)) < 1e-3 ) {\n                        //if (abs(SDF(pT)) < 1e-3 || SDF(pT) < 1e-2 &&\n                        //    sign_shattered(p+d*1e-2, panec, panen) !=\n                        //    sign_shattered(p-d*1e-2, panec, panen) ) {\n                        //if (wasout != isout) {\n                        if (abs(SDF(pT)) < 1e-3 ||\n                            wasout != (midspace > 0 || SDF(pT2+dT2*1e-2) > 1e-3)) {\n                            \n                            // hits object - have distance to intersection and normal\n                            \n                            /*//vec3 TEXp = .5+.5*(inter_shattered1.xyz);\n                            float SDFp = SDF(pT);\n                            vec3 seid = abs(dSDF(pT) );\n                            \n                            vec3 TEXp = vec3(0., 0., 0.);\n                            float ang1;\n                            \n                            ang1 = acos(dot(seid, vec3(0., 1., 0.) ));\n                            TEXp = mix(TEXp, vec3(0., 1., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            ang1 = acos(dot(seid, vec3(1., 0., 0.) ));\n                            TEXp = mix(TEXp, vec3(1., 1., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            ang1 = acos(dot(seid, vec3(0., 0., 1.) ));\n                            TEXp = mix(TEXp, vec3(0., 0., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            #if 1\n                            TEXp = mix(\n                                TEXp,\n                                vec3(.3),\n                                .0+.3*mod(floor(pT.x*9.+.001)+floor(pT.y*9.+.001)+floor(pT.z*9.+.001), 2.)\n                            );\n                            #endif\n                            //TEXp = abs(inter_shattered1.xyz);\n                            //TEXp = vec3(0.);\n                            */\n                            vec4 inter_closest = inter_shattered1;\n                            vec3 specular = sky_map(reflect(camd, inter_closest.xyz))*0.;\n                            float specularh = length(specular)/sqrt(3.);\n                            vec3 TEXp;\n                            \n                            #define cz1 2.\n                            \n                            //if (mod(floor(pT.x*cz1-inf.x)+floor(pT.y*cz1-inf.x)+floor(pT.z*cz1-inf.x), 2.) < 1.) {\n                            if (abs(SDF(pT)) < 1e-3 && !(length(pT-vec3(1., 0., 0.)) < .5) ) {\n                                // pearly white\n                                float diffuse = clamp(dot(inter_closest.xyz, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 4.);\n                                TEXp = vec3(.53)+vec3(.6)*diffuse+specularh*.7;\n                                \n                                \n                                #define shininess .79993\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                            else {\n                                // heres for blue bubble\n                                /*vec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n                                vec2 glob = vec2(\n                                    .5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n                                    .5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n                                );\n                                float glo = length(glob)/sqrt(2.);*/\n                                float glo = 1.-(.5+.5*p.y); //mod(p.y*cz1, 1.);\n                                \n                                glo = 3.*glo*glo-2.*glo*glo*glo;\n                                //glo = pow(glo, 1.7);\n                                \n                                specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 1.5);\n                                \n                                float glo2 = pow(glo, 2.);\n                                TEXp = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n                                \n                                \n                                #define shininess .999\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                //d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                        }\n                        else {\n                            // hits pane - translucency if want debug\n                            \n                            vec3 TEXp = abs(inter_shattered1.xyz)*0.+mod(\n                                floor(p.x+1e-3)+floor(p.y+1e-3)+floor(p.z+1e-3),\n                                2.\n                            );\n                            #define shininess .0\n                            retina += TEXp*shiny*shininess;\n                            shiny *= 1.-shininess;\n                            \n                            //d = reflect(d, inter_shattered1.xyz);\n                            p += d*1e-4;\n                            #undef shininess\n                        }\n                    }\n                }\n                \n                if (shiny == 1.) {\n                    // white background if never hit obj\n                    retina = vec3(0., 0., 100./255.);\n                    shiny *= 0.;\n                }\n                \n                // add sky color to last reflection/refaction etc.\n                retina += shiny*sky_map(d);\n                finalCol += retina;\n            //}\n        }\n    }\n    finalCol /= float(spp);\n    fragColor = vec4(finalCol, 1.);\n    \n}\n\n\n\n\n\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n// OLD CODE FOR: \"kissing blobs\"\n// title: kissing blobs\n// created: 2019 9/21\n// tags: blobs, slime, field\n// description: I independently discovered that summing up the\n// reciprocol of the blobs distances gave the desired effect I'd\n// seen here:\n// khanacademy.org/computer-programming/metalslab/6640525797228544\n// years ago, but I did not realize that \"meatballs\" were already a\n// \"thing\"\nfloat daht(vec2 pos, vec2 screen, float rad) {\n    float p = length(pos-screen)/rad;\n    return (0.5/p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 centre = iResolution.xy/2.;\n    \n    float count = 0.;\n    \n    // BLOBS\n    count += daht(centre, fragCoord, 50.);\n    float arg1 = 150.*sin(iTime);\n    float arg2 = 80.*sin(iTime*0.5);\n    count += daht(centre+vec2(90.+arg1, 10.+arg2), fragCoord, 50.);\n    count += daht(iMouse.xy, fragCoord, 50.);\n    \n    // old code\n    // float val = min(count/1.0, 1.0);\n    // val = val >= 1.0 ? 1. : 0.;\n    //fragColor = vec4(val, val, val, 1.0);\n    \n    // new code thx to FabriceNeyret2\n    float val = count/1. - 1.;\n    fragColor = vec4( smoothstep( -.7,.7, val / fwidth(val) ) );\n}\n/**/", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tddGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdG3R1", "name": "Interlocked Polygon Illusion", "author": "mathmasterzach", "description": "Idea based on https://archillect.com/119960", "tags": ["2d", "lines", "geometric", "golf", "interlocked"], "likes": 15, "viewed": 363, "date": "1569768170", "time_retrieved": "2024-06-20T19:43:53.447204", "image_code": "/*242 char version by FabriceNeyret2\n#define mainImage(O,U)                                 \\\n    float R = iResolution.y/4., i = 0.;                \\\n    for( vec2 r = ceil(U/R), v = O.zw *11., a,b,q;     \\\n         i/r.y < 8.;                                   \\\n         i += 6.28 / ( r.x + 2. )                      \\\n       )                                               \\\n        a = cos( iTime+i/r.y + v ) + 5.* cos( i + v ), \\\n        O = max( O, 1.2*sign(i) - R/25.                \\\n          * length( clamp( dot( q = 16.*(U/R-r+.5) -a, b -= a ) / dot(b,b), 0.,1.) *b -q)),\\\n        b = a\n\n*/\n\n//360 char full shader\n#define A(x) vec2(cos(x),sin(x))\n#define L(a,b) length(q-a-(b-a)*clamp(dot(q-a,b-a)/dot(b-a,b-a),0.,1.))\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2 R=iResolution.xy,\n         p=4.*U/R.y,\n         q=16.*(fract(p)-.5),\n         r=floor(p)+vec2(3,1);\n\tfloat d=1.,\n          t=iTime,\n          s=0.,\n          b=r.x*r.y,\n          P=2.*acos(-1.)/b,\n    \t  Q=P*r.y;\n    for(;s<Q*b;t+=P,s+=Q)d=min(d,L(A(t)-5.*A(s),A(t+P)+5.*A(s+Q)));\n    O+=1.-smoothstep(-64./R.y,64./R.y,d-.2);\n}\n/*\n\n//319 char version with a focus on the triangle\n#define A(x) vec2(cos(x),sin(x))\n#define L(a,b) length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.))\n#define B d=min(d,L((A(t)+5.*A(s)),(A(t+P)+5.*A(s+Q))));t+=P;s+=Q;\n#define mainImage(O,U) \\\n\tvec2 R=iResolution.xy,\\\n         p=8.*(U+U-R)/R.y;\\\n    float d=1.,\\\n          t=iTime,\\\n          s=0.,\\\n          P=1.047,\\\n    \t  Q=P*2.;\\\n    B B B B B B\\\n    O+=1.-smoothstep(-8./R.y,8./R.y,d-.1)/*\n\n/*326 char version with more precise pi calculation and a focus on the triangle\n#define A(x) vec2(cos(x),sin(x))\n#define L(a,b) length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.))\n#define B d=min(d,L((A(t)+5.*A(s)),(A(t+P)+5.*A(s+Q))));t+=P;s+=Q;\n#define mainImage(O,U) \\\n\tvec2 R=iResolution.xy,\\\n         p=8.*(U+U-R)/R.y;\\\n    float d=1.,\\\n          t=iTime,\\\n          s=0.,\\\n          P=acos(-1.)/3.,\\\n    \t  Q=P*2.;\\\n    B B B B B B\\\n    O+=1.-smoothstep(-8./R.y,8./R.y,d-.1)*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdG3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdKGzD", "name": "color Tunnel", "author": "arifr123", "description": "drag the mouse over the screen", "tags": ["torus"], "likes": 2, "viewed": 89, "date": "1569862671", "time_retrieved": "2024-06-20T19:43:54.010819", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat torusDist(vec3 p, float r1, float r2)\n{\n    float d = sqrt(pow(p.z, 2.0) + pow(length(p.xy) - r1, 2.0));\n    if(r2 <= d)\n    \treturn d - r2;\n    else\n        return r2 - d;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getColor(vec3 p, float r1, float time, vec3 cp)\n{\n    vec4 col = vec4(0, 0, 0, 0.25);//black\n    \n    float t = atan(p.y, p.x) / (2.0*PI) + 0.5;\n\n    float rings = 10.;\n\n    t = rings*r1*t;\n\n    float colorNum = 2.0;\n    float colorChange = 0.025;//0 - 1\n\n    if(0.9 < fract(t + time))\n    {\n        col.rgb = hsv2rgb(vec3((t + (1. + colorChange)*time)/colorNum, 1.0, 1.0));\n        col.rgb *= 50. / pow(distance(p, cp), 2.);\n        \n        col.a = 1.0;//opaque\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 8.*iTime;\n    \n    vec2 uv = (fragCoord - iResolution.xy/2.0) / iResolution.y;\n    \n    vec2 um = (iMouse.xy - iResolution.xy/2.0) / iResolution.y;\n    um = 1.5*um.yx;\n    float umLength = 0.3*length(um);\n    um = normalize(um);\n    \n    \n    float r1 = 1.0 / umLength;\n    float r2 = 0.75;//0.55 + 0.5*sin(time/5.0);\n    \n    float torusCameraDist = 0.5*r2;\n    \n    vec3 cp = vec3(-r1, 0, 0);\n    vec3 i = vec3(um.y, 0, -um.x);\n    vec3 j = vec3(um.x, 0, um.y);\n    vec3 k = -vec3(0, 1, 0);\n    \n    //vec3 cp = vec3(r1, 0, 3);\n    //vec3 i = vec3(0, 1, 0);\n    //vec3 j = normalize(vec3(-3, 0, 3));\n    //vec3 k = normalize(vec3(-3, 0, -3));\n    \n    \n    float zoom = 0.007;\n    \n    \n    uv *= 0.01;\n    vec3 ld = normalize(uv.x * i + uv.y * j + zoom * k);\n    \n    vec4 col = vec4(0);\n    bool searchAgain = true;\n    \n    vec3 smp = cp;\n    \n    while(searchAgain)\n    {\n        searchAgain = false;\n        \n        vec3 p = smp;\n        \n        for(int i = 0; i < 200; i++)\n        {\n            float d = torusDist(p, r1, r2);\n            p += d * ld;\n            \n            if(d < 0.01)\n            {\n                vec4 nc = getColor(p, r1, time, cp);\n                col.rgb = mix(nc.rgb, col.rgb, col.a);\n                col.a = 1. - (1. - col.a)*(1. - nc.a);\n                \n                smp = p + 0.01 * ld;\n                \n                searchAgain = true;\n                \n                break;\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col.a * col.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdKGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdt3RN", "name": "bluenoise jittering question", "author": "Carandiru", "description": "is my modification to add temporal jittering working properly?\nthanks fabrice for all your interesting shaders\n\noriginal shader: https://www.shadertoy.com/view/wtsXD7\nby fabrice neyret", "tags": ["noise", "blue", "jitter"], "likes": 2, "viewed": 580, "date": "1567998632", "time_retrieved": "2024-06-20T19:43:54.259376", "image_code": "// original shader: https://www.shadertoy.com/view/wtsXD7\n// by fabrice neyret\n\n// mod: temporal test\n\n#define JIT 42.   // amout of spatial jittering\n\t\t\t\t\t// temporal jittering is +- 1 pixel/frame\nvoid mainImage( out vec4 O, vec2 U )\n{  \n    vec2 R = iResolution.xy, \n         P = ( 2.*U - R ) / R.y, S;\n    \n    if (P.x==-P.y) { O=vec4(1,0,0,0); return; } // red separator\n    \n    // --- random seed for the current location\n\tvec2 dither_uv = mix(vec2(-1.0f,1.0f), vec2(1.0f,-1.0f), bvec2(iFrame & 1));\n    S = P.x > -P.y\n        ? texelFetch( iChannel0, ivec2(U + 0.5 + dither_uv)%1024, 0).yx // top: bluenoise\n        : texelFetch( iChannel1, ivec2(U)%256, 0).xy // left: whitenoise\n    \t;\n    // --- stochastic cone-trace the scene ( = 1 sphere ) \n    \n    P += .6*cos(iTime+vec2(0,33));              // camera motion\n    \n    vec3 D = vec3( P + JIT* (S-.5)/R.y, 1),                // pseudo-blue noise\n         //D = vec3( P + JIT* (S.x-.5)/R.y*normalize(P), 1), // real radial bluenoise\n         C = vec3(0,0,-1), L = normalize(vec3(-1,1,-2)), N,H;\n    D = normalize(D);\n    float r = .5, b = dot(D,C), c = dot(D,D) - r*r, d = b*b - c;\n    O = vec4(0);\n    if (d>0.) { \n        d = -b - sqrt(d); C += d*D;             // ray-sphere intersection\n        N = normalize(C);                       // local normal\n        H = normalize(L+vec3(0,0,-1));\n        O =   dot(N,L) *vec4(0,1,0,0)           // diffuse shading\n            + 2.*pow(max(0.,dot(N,H)),100.) ;   // specular shading\n      }\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdt3RN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdt3W8", "name": "Quaternion Julia Set", "author": "Blake447", "description": "Putting to test a distance estimation function for julia sets in 4 dimension, using quaternions. The raymarcher itself I constructed, but the DE function I got from Inigo Quilez.\n", "tags": ["raymarching", "fractal", "julia", "mandlebrot"], "likes": 9, "viewed": 233, "date": "1568484730", "time_retrieved": "2024-06-20T19:43:55.792703", "image_code": "// Blog post for DE function of a julia set by Inigo Quilez;\n// https://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\n\n// Quick little function to multiply two quaternions.\n// The proof is left as an exercise to the reader\nvec4 MultiplyQuaternions(vec4 a, vec4 b)\n{\n\tfloat real = a.w*b.w - dot(a.xyz, b.xyz);  \n    vec3 complex = (a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz));\n\treturn vec4(complex, real);\n}\n\n// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    // find the distance to the center\n    vec3 v = pos - center;\n    \n    // return that, minus the radius\n    return length(v) - radius;\n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n\n\n\n\n// Distance estimation for a julia set.\nfloat DE(vec3 p, vec3 c, vec4 seed)\n{\n    // First, offset the point by the center\n\tvec3 v = p - c;\n\n    // Set C to be a vector of constants determining julia set we use\n\tvec4 C = seed;\n    \n    // Set Z to be some form of input from the vector\n\tvec4 Z = float4(v.z, v.y, 0.0, v.x);\n    \n    // I'll be honest, I'm not entirely sure how the distance estimation works.\n    // Calculate the derivative of Z. The Julia set we are using is Z^2 + C,\n    // So this results in simply 2z\n\tvec4 dz = 2.0*Z + vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Run the iterative loop for some number of iterations\n\tfor (int i = 0; i < 64; i++)\n\t{\n        // Recalculate the derivative\n\t\tdz = 2.0 * MultiplyQuaternions(Z, dz) + vec4(1.0, 1.0, 1.0, 1.0);\n        \n        // Rcacalculate Z\n\t\tZ = MultiplyQuaternions(Z, Z) + C;\n        \n       \t// We rely on the magnitude of z being fairly large (the derivation includes\n        // A limit as it approaches infinity) so we're going to let it run for a bit longer\n        // after we know its going to explode. i.e. 1000 instead of the usual, like 8.\n\t\tif (dot(Z, Z) > 1000.0)\n\t\t{\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n    \n    // And this is where the witchcraft happens. Again, not sure how this works, but as\n   \t// you can see, it does.\n\tfloat d = 0.5*sqrt(dot(Z, Z) / dot(dz, dz))*log(dot(Z, Z)) / log(10.0);\n\t\n    // Return the distance estimation.\n    return d;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 200;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 2.5;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.001;\n    \n    // Define if we should invert the color at the end\n    const bool DARK_MODE = true;\n    \n    \n    // Define the specific julia set being marched. Below are a couple different seeds\n    // I found to be interesting. Just uncomment the ones you want to see\n    \n    //vec4 julia_seed = vec4(0.0, -0.2, 0.0, -1.17);\n    //vec4 julia_seed = vec4(0.2, 0.67, 0.0, -0.5);\n    vec4 julia_seed = vec4(0.33, 0.56, 0.0, -0.72);    \n    //vec4 julia_seed = vec4(-0.15, -0.15, 0.0, -.95);\n    \n    // Define the center of the julia set\n    vec3 julia_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    //// Define the Camera position\n    //vec3 cam_pos = vec3(0,0,-2);\n    \n    //// Define the forward, up, and right vectors (needs rework)\n    //vec3 forward = normalize(vec3(0,0,1));\n    //vec3 up = normalize(vec3(0,1,0));\n    //vec3 right = normalize(vec3(1,0,0));\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - julia_center, ray, 2.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    float minDist = 1000.0;\n    vec3 closestPoint = vec3(0.0,0.0,0.0);\n    \n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, julia_center, julia_seed);\n        \n        if (dist < minDist)\n        {\n        \tclosestPoint = p;\n        }\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - julia_center, p-julia_center) > 8.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n    \n    // calculate the brightness based on iterations used\n\tfloat di = float(j) / float(ITERATIONS);\n\n    \n    \n    // determine if we hit the fractal or not\n    float hit = step(dist, EPSILON);\n    \n    if (!DARK_MODE)\n    {\n     \tdi = 1.0 - di;   \n    }\n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    \n\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    //vec3 col = vec3(0.7,1.0,.93);\n    \n\n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdt3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdt3z8", "name": "Log warp", "author": "ciric50", "description": "Logarithmic warping added to a shader by inigo quilez", "tags": ["warping"], "likes": 4, "viewed": 77, "date": "1567804448", "time_retrieved": "2024-06-20T19:43:56.520126", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this:\n//\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n\n// Sep 6, 2019\n// Willard Maier\n// I added logarithmic warping to what inigo did.\n\n//====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.3*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.4*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvec2 warp(in vec2 p)\n{\n#define R1  0.1\n#define R2  4.0\n\n    // Logarithm\n    vec2 a = log(abs(p+0.01));\n\n    // Rotate\n    float alpha = atan(log(R2/R1)/6.283185307);\n    float f = cos(alpha);\n    float s = sin(alpha);\n    vec2 b = f*vec2(a.x*f - a.y*s, a.x*s+a.y*f);\n\n    // Exponential\n    return vec2(exp(b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p = warp(p1);\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                2.0*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdt3z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdt3zj", "name": "Liquid Crystal Hallucination", "author": "jarble", "description": "This is another modification of my \"Psychedelic Rainbow Trip\" fractal.", "tags": ["hash"], "likes": 1, "viewed": 325, "date": "1568903487", "time_retrieved": "2024-06-20T19:43:56.520126", "image_code": "//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord/pow(2.0,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.0,mag),0),mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,0);\n    float maximum = 6.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tfragColor += vec4(pixel_above(fragCoord.xy/(i+sin(iTime))+fragCoord.yx/(i+cos(iTime)),i+1.0),0.0);\n    }\n    fragColor /= maximum;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdt3zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtGDr", "name": "Ray Marching thing", "author": "Dogemaster09", "description": "just a little test i did. i followed a tutorial by The Art Of Code, you should check out his channel! https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg", "tags": ["raymarching"], "likes": 1, "viewed": 105, "date": "1568261441", "time_retrieved": "2024-06-20T19:43:56.520126", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n/*float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n*/\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox (vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat dPlane (vec3 p, vec4 n) {\n    return dot(p,n.xyz) + n.w;\n\t//return ((p.x*p2.x)-p3.x)+((p.y*p2.y)-p3.y)+((p.z*p2.z)-p3.z);\n}\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float pd = dPlane(p, normalize(vec4(0, 1, 0, 0)));\n    //float qd = udQuad(p, vec3(-0.7, 2, 1), vec3(-0.7, 2.4, 1), vec3(-0.8, 2.4, 1), vec3(-0.8, 2, 1));\n    //float pd = p.y2\n    float cd = sdCapsule(p, vec3(0, 1.2, 5), vec3(0, 2.6, 7), .5);\n    float td = sdTorus(p-vec3(0,.3,6), vec2(1.5, .3));\n    float bd = dBox(p-vec3(-2.5, .5, 6), vec3(.5));\n    float cyld = sdCylinder(p, vec3(0, 0.3, 3), vec3(3, 0.3, 5), .3);\n    float d = min(cd, pd);\n    d = min(d, td);\n    d = min(d, bd);\n    d = min(d, cyld);\n    //d = min(d, qd);\n    return d;\n}\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float res = 1.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        res = min(res, dS/dO);\n        dO += dS;\n        if (dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return vec2(dO, res);\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n\tvec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    vec2 d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d.x<length(lightPos-p)) {\n    \tdif *= .2;\n    }\n    else {\n    \t//dif = d.y;\n    }\n    return dif;\n    //return d.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.y = mouse.y*2.+1.;\n    mouse.x = mouse.x*2.-2.;\n    \n    vec3 ro = vec3(mouse.x,mouse.y,0);\n    vec3 rd = normalize(vec3(uv.x+.2, uv.y+-0.2, 1));\n    \n    vec2 d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d.x;\n    \n    float dif = GetLight(p);\n\tcol = vec3(dif);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtGDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdtGWr", "name": "Rave Ghost", "author": "AlexWalley", "description": "Rave Ghost for friends.", "tags": ["practice"], "likes": 2, "viewed": 115, "date": "1568252347", "time_retrieved": "2024-06-20T19:43:56.520126", "image_code": "#define TWO_PI 6.28\n#define PI 3.1415926535\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat N21(vec2 p){\n\treturn fract(sin(p.x*884.32+p.y*49993.)*239.);\n}\n\nfloat smoothNoise(vec2 uv){\n    \n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    float bl = N21(id);\n    float br = N21(id+vec2(1, 0));\n    \n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0, 1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    float height = 0.2;\n    vec2 p = uv;\n    \n    float rate = 3.5;\n    p.x += sin(uv.y*6.+iTime*rate)*0.025;\n    if(p.y < -0.2) // Tail wiggle\n    \tp.x += sin(uv.y*65.+iTime*rate)*0.25*(p.y+0.2);\n    \n    float pix = 1.5/iResolution.y;\n    p.y += 0.1;\n    //Body\n    col += smoothstep(0.2+pix, 0.2-pix, abs(p.x));\n   \n    col -= smoothstep(0.3-pix, 0.3+pix, abs(p.y-0.0));\n\tcol = clamp(col, 0., 1.0);\n    col += smoothstep(0.201+pix, 0.201-pix, length(vec2(p.x, p.y-0.29)));\n    \n    \n    \n    \n    //Triangle\n    vec2 gt = p;\n    \n    float a = 0.9;\n    gt *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    col -= smoothstep(0.1+pix, 0.1-pix, abs(gt.y+0.3));\n    col = clamp(col, 0., 1.);\n    \n    \n    a = -0.9;\n    gt *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    gt.x *= -1.;\n    a = 0.9;\n    gt *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    col -= smoothstep(0.1+pix, 0.1-pix, abs(gt.y+0.3));\n    \n    //Random number based upon time\n    float t = mod(iTime, 200.);\n    float h = smoothNoise(vec2(t));\n    h += smoothNoise(vec2(t*2.))*0.5;\n    h += smoothNoise(vec2(t*4.))*0.25;\n    \n    //Eyes\n    float size = sin(iTime*rate)*0.02+0.05;\n    \n    col *= vec3( smoothstep(size-pix, size+pix, length(vec2(abs(p.x - 0.1), p.y-0.3))));\n    col *= vec3( smoothstep(size-pix, size+pix, length(vec2(abs(p.x + 0.1), p.y-0.3))));\n    col = clamp(col, 0., 1.0);\n    \n    //Arms\n    vec2 av = p;\n    \n    av.y -= sin(abs(av.x*30.)-2.*iTime)*0.025;\n    float thickness = 0.05*(1.0-abs(av.x*1.5));\n    col += smoothstep( thickness+pix, thickness-pix, abs(av.y-0.13) );\n    col = clamp(col, 0., 1.);\n    \n    \n    \n    \n    vec3 rave = hsv2rgb(vec3(h, 0.7,1.0));\n    col *= rave;\n    \n    col = clamp(col, 0., 1.);\n    \n    col += smoothstep(0.0, 1.0, abs(p.y-0.1))*rave;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdtGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdVGR1", "name": "Rising bubbles 3", "author": "avin", "description": "visual experiment", "tags": ["bubbles"], "likes": 11, "viewed": 544, "date": "1569754410", "time_retrieved": "2024-06-20T19:43:56.520126", "image_code": "float rand(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ouv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    \n    float fCol = 0.;\n    float t = iTime * 0.25;\n    \n    float total = 7.;\n    for(float i=1.; i<total; i+=1.){\n        float iTotal = i/total;\n        float niTotal = 1. - i/total;\n                \n        vec2 uv = ouv * (10. + i*1.) - vec2(0., t*(1.-i/total));\n        vec2 id = floor(uv) + vec2(i*1000.);\n        uv = fract(uv) - 0.5;\n        \n        for(float y=-1.; y<=1.; y+=1.){\n            for(float x=-1.; x<=1.; x+=1.){   \n                \n                vec2 iuv = uv + vec2(x,y);    \n                vec2 iid = id - vec2(x,y);  \n                \n                if(rand(iid * 200.) > .25){\n                    iuv.x += rand(iid)-.5;\n                    iuv.y += rand(vec2(rand(iid)))-.5;        \n\n                    float l = length(iuv * (niTotal)*1.5);  \n                    float size = rand(iid*5.)*.1 + .25 - .1;\n                    float force = rand(iid*10.)*.5+.5;\n                    fCol += \n                        smoothstep(l, l + (iTotal)*.25, size) *                         \n                        niTotal *\n                        force;        \n                }                         \n            }\n        }        \n    }\n      \n    fragColor = vec4(fCol);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdVGR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3z1", "name": "Ray Marching: basic operations.", "author": "Rewlion", "description": "basic operations.", "tags": ["raymarching"], "likes": 0, "viewed": 223, "date": "1569705279", "time_retrieved": "2024-06-20T19:43:56.526105", "image_code": "float GetSphereDistance(vec3 p, vec3 c, float r)\n{\n    float distance = length(p-c) - r;\n    return distance;\n}\n\nfloat GetBoxDistance(vec3 p, vec3 s)\n{\n \t  return length(max(abs(p)- s, 0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistance(vec3 r)\n{\n    float s1 = GetSphereDistance(r, vec3(-1.0, 0.5, 2.0), 0.4);\n    float s2 = GetSphereDistance(r, vec3(-2.0 + 0.5*sin(iTime), 0.5, 2.0), 0.7);\n \n    float b  = GetBoxDistance(r - vec3(-1.0, 2.0 - 0.5*sin(iTime), 2.0), vec3(0.3,0.3, 0.3));\n    \n    float s3 = GetSphereDistance(r, vec3( 1.0, 0.5, 2.0), 0.4);\n    float s4 = GetSphereDistance(r, vec3( 2.0 + 0.5*sin(-iTime), 0.5, 2.0), 0.7);\n    \n    float b2 = GetBoxDistance(r - vec3(0.0, 0.5, 2.0), vec3(0.3,0.3,0.3));\n\tfloat s5 = GetSphereDistance(r, vec3(0.0, 0.5, 2.0), 0.45);\n\tfloat d3 = max(b2,s5);\n    \n    float surfDistance = r.y;\n    \n    float d = smin(s1, s2, 0.7);\n    d = smin(d, b, 0.7);\n    float d2 = max(s3, s4);\n    d = min(d, d2);\n    d = min(d, surfDistance);\n    d = min(d,d3);\n    \n    return d;\n}\n\nfloat RayMarching(vec3 start, vec3 dir)\n{\n \tfloat distance = 0.0;\n    \n    for(int i = 0; i < 100; ++i)\n    {\n     \tvec3 r = start + distance*dir;\n        float d = GetDistance(r);\n        \n        if(d < 0.01 || d > 100.0)\n            break;\n        \n        distance += d;\n    }\n    \n    return distance;\n}\n\nvec3 GetNormal(vec3 r)\n{\n \tvec2 e = vec2(0.01, 0.0);\n    float d = GetDistance(r);\n    \n    vec3 dr = d - vec3(\n        GetDistance(r - e.xyy),\n        GetDistance(r - e.yxy),\n        GetDistance(r - e.yyx)\n        );\n    \n    dr = normalize(dr);\n    \n    return dr;\n}\n\nfloat GetLight(vec3 p, vec3 n)\n{\n    vec3 lightpos = vec3(0.0f, 7.0f, -3.0f);\n    \n    vec3 dr = normalize(lightpos - p);\n    \n    float l = clamp(dot(dr,n), 0.0, 1.0);\n    \n    float ld = RayMarching(p + n * 0.01, dr);\n    if(ld < length(lightpos - p))\n        return l * 0.1;\n    \n    return l;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera = vec3(0.0, 1.2, 0.0);\n    vec3 dir = normalize(vec3(uv,1.0));\n    \n    float c = RayMarching(camera, dir);\n\t\n    vec3 p = camera + dir * c;\n    vec3 n = GetNormal(p);\n    \n    float l = GetLight(p, n);\n    \n    vec3 color = vec3(l);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdy3zW", "name": "CobaltXII", "author": "CobaltXII", "description": "A cool font made using only signed distance functions (SDFs). Uses only sphere, capsule, torus, half-torus and quarter-torus SDFs. The font was mainly inspired by the one on this page:\n\nhttps://mzucker.github.io/2016/08/03/miniray.html", "tags": ["raymarching", "noise", "raymarch", "flame", "fire", "gradient", "font", "lava"], "likes": 4, "viewed": 519, "date": "1569800367", "time_retrieved": "2024-06-20T19:44:01.199336", "image_code": "/*\n\n// If you want to easily generate SDFs for any text (a-z, A-Z, 0-9 and spaces only), use this Javascript code.\n\nvar widths = {\n\t\"a\": 4, \"b\": 4, \"c\": 4, \"d\": 4,\n\t\"e\": 4, \"f\": 4, \"g\": 4, \"h\": 4,\n\t\"i\": 0, \"j\": 4, \"k\": 4, \"l\": 0,\n\t\"m\": 8, \"n\": 4, \"o\": 4, \"p\": 4,\n\t\"q\": 4, \"r\": 4, \"s\": 4, \"t\": 4,\n\t\"u\": 4, \"v\": 4, \"w\": 8, \"x\": 4,\n\t\"y\": 4, \"z\": 4, \"A\": 4, \"B\": 4,\n\t\"C\": 4, \"D\": 4, \"E\": 4, \"F\": 4,\n\t\"G\": 4, \"H\": 4, \"I\": 4, \"J\": 4,\n\t\"K\": 4, \"L\": 4, \"M\": 8, \"N\": 4,\n\t\"O\": 4, \"P\": 4, \"Q\": 4, \"R\": 4,\n\t\"S\": 4, \"T\": 4, \"U\": 4, \"V\": 4,\n\t\"W\": 8, \"X\": 4, \"Y\": 4, \"Z\": 4,\n\t\"0\": 4, \"1\": 4, \"2\": 4, \"3\": 4,\n\t\"4\": 4, \"5\": 4, \"6\": 4, \"7\": 4,\n\t\"8\": 4, \"9\": 4\n};\n\nfunction measureText(text) {\n\tvar length = 0;\n\tfor (var i = 0; i < text.length; i++) {\n\t\tif (text[i] == \" \") {\n\t\t\tlength += 3;\n\t\t} else {\n\t\t\tif (text[i] in widths) {\n\t\t\t\tlength += widths[text[i]];\n\t\t\t\tif (i != text.length - 1) {\n\t\t\t\t\tlength += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Bad character '\" + text[i] + \"' at index \" + i + \" in string \\\"\" + text + \"\\\"\");\n\t\t\t}\n\t\t}\n\t}\n\treturn length;\n}\n\nfunction generateSDF(text) {\n\tvar length = measureText(text);\n\tvar lines = [];\n\tlines.push(\"// SDF of the scene.\");\n\tlines.push(\"float z_offset = float(\" + (length / 2) + \");\");\n\tlines.push(\"float sdf(in vec3 pos) {\");\n\tlines.push(\"\tfloat t = 1000.0;\");\n\tlines.push(\"\tvec3 offset = vec3(\" + (-length / 2) + \", 4, \" + Math.ceil(-length * 0.65) + \");\");\n\tvar x = 0;\n\tfor (var i = 0; i < text.length; i++) {\n\t\tif (text[i] == ' ') {\n\t\t\tx += 3;\n\t\t} else {\n\t\t\tif (text[i] in widths) {\n\t\t\t\tlines.push(\"\tt = min(t, sdf_\" + text[i] + \"(pos, vec3(\" + x + \", 0, 0) + offset));\");\n\t\t\t\tx += widths[text[i]];\n\t\t\t\tif (i != text.length - 1) {\n\t\t\t\t\tx += 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Bad character '\" + text[i] + \"' at index \" + i + \" in string \\\"\" + text + \"\\\"\");\n\t\t\t}\n\t\t}\n\t}\n\tlines.push(\"\treturn t;\");\n\tlines.push(\"}\");\n\treturn lines.join('\\n');\n}\n\n*/\n\n#define THICKNESS 0.5\n\n// **************************************************************** //\n// **************************************************************** //\n// **** PRIMITIVES                                             **** //\n// **************************************************************** //\n// **************************************************************** //\n\n// Constant torus definition.\nconst vec2 torus = vec2(2.0, THICKNESS);\n\n// SDF of a torus.\nfloat sdf_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return length(q) - torus.y;\n}\n\n// SDF of the top half of a torus.\nfloat sdf_half0_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, -pos.y);\n}\n\n// SDF of the bottom half of a torus.\nfloat sdf_half1_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, pos.y);\n}\n\n// SDF of the left half of a torus.\nfloat sdf_half2_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, pos.x);\n}\n\n// SDF of the right half of a torus.\nfloat sdf_half3_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, -pos.x);\n}\n\n// SDF of the top-left quarter of a torus.\nfloat sdf_quarter0_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, max(-pos.y, pos.x));\n}\n\n// SDF of the top-right quarter of a torus.\nfloat sdf_quarter1_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, max(-pos.y, -pos.x));\n}\n\n// SDF of the bottom-left quarter of a torus.\nfloat sdf_quarter2_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, max(pos.y, pos.x));\n}\n\n// SDF of the bottom-right quarter of a torus.\nfloat sdf_quarter3_torus(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);\n    return max(length(q) - torus.y, max(pos.y, -pos.x));\n}\n\n// SDF of a capsule.\nfloat sdf_capsule(in vec3 pos, in vec3 a, in vec3 b) {\n    vec3 pa = pos - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba , ba), 0.0, 1.0);\n    return length(pa - ba * h) - THICKNESS;\n}\n\n// SDF of a sphere.\nfloat sdf_sphere(in vec3 pos, in vec3 offset) {\n    return length(pos - offset) - THICKNESS;\n}\n\n// **************************************************************** //\n// **************************************************************** //\n// **** LOWERCASE                                              **** //\n// **************************************************************** //\n// **************************************************************** //\n\n// SDF for the letter A.\nfloat sdf_a(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter B.\nfloat sdf_b(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter C.\nfloat sdf_c(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter D.\nfloat sdf_d(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter E.\nfloat sdf_e(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4.5, 0), vec3(4, -4.5, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4.5, 0), vec3(4, -4, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter F.\nfloat sdf_f(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(2, -2, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_quarter0_torus(pos, vec3(4, -2, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4.5, 0), vec3(4, -4.5, 0)));\n    return t;\n}\n\n// SDF for the letter G.\nfloat sdf_g(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter H.\nfloat sdf_h(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter I.\nfloat sdf_i(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -0.5, 0)));\n    return t;\n}\n\n// SDF for the letter J.\nfloat sdf_j(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -0.5, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));\n    return t;\n}\n\n// SDF for the letter K.\nfloat sdf_k(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -6, 0), vec3(4, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -6, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter L.\nfloat sdf_l(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// SDF for the letter M.\nfloat sdf_m(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half0_torus(pos, vec3(6, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(8, -4, 0), vec3(8, -8, 0)));\n    \n    return t;\n}\n\n// SDF for the letter N.\nfloat sdf_n(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter O.\nfloat sdf_o(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter P.\nfloat sdf_p(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// SDF for the letter Q.\nfloat sdf_q(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter R.\nfloat sdf_r(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));\n    return t;\n}\n\n// SDF for the letter S.\nfloat sdf_s(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));\n    return t;\n}\n\n// SDF for the letter T.\nfloat sdf_t(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -2, 0)));\n    return t;\n}\n\n// SDF for the letter U.\nfloat sdf_u(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    return t;\n}\n\n// SDF for the letter V.\nfloat sdf_v(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter W.\nfloat sdf_w(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(6, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(8, -2, 0), vec3(6, -8, 0)));\n    return t;\n}\n\n// SDF for the letter X.\nfloat sdf_x(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// SDF for the letter Y.\nfloat sdf_y(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -4, 0)));\n    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter Z.\nfloat sdf_z(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// **************************************************************** //\n// **************************************************************** //\n// **** UPPERCASE                                              **** //\n// **************************************************************** //\n// **************************************************************** //\n\n// SDF for the letter A.\nfloat sdf_A(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));\n    return t;\n}\n\n// SDF for the letter B.\nfloat sdf_B(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));\n    return t;\n}\n\n// SDF for the letter C.\nfloat sdf_C(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter D.\nfloat sdf_D(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_quarter1_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter E.\nfloat sdf_E(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_quarter2_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -8, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter F.\nfloat sdf_F(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(4, 0, 0)));\n    return t;\n}\n\n// SDF for the letter G.\nfloat sdf_G(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(4, -4, 0)));\n    return t;\n}\n\n// SDF for the letter H.\nfloat sdf_H(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));\n    return t;\n}\n\n// SDF for the letter I.\nfloat sdf_I(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter J.\nfloat sdf_J(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));\n    return t;\n}\n\n// SDF for the letter K.\nfloat sdf_K(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_quarter3_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -6, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter L.\nfloat sdf_L(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_quarter2_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -8, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter M.\nfloat sdf_M(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half0_torus(pos, vec3(6, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(8, -2, 0), vec3(8, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// SDF for the letter N.\nfloat sdf_N(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter O.\nfloat sdf_O(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter P.\nfloat sdf_P(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));\n    return t;\n}\n\n// SDF for the letter Q.\nfloat sdf_Q(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -6, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter R.\nfloat sdf_R(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -6, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// SDF for the letter S.\nfloat sdf_S(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_quarter2_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));\n    return t;\n}\n\n// SDF for the letter T.\nfloat sdf_T(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter U.\nfloat sdf_U(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the letter V.\nfloat sdf_V(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter W.\nfloat sdf_W(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(6, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(8, 0, 0), vec3(8, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));\n    return t;\n}\n\n// SDF for the letter X.\nfloat sdf_X(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// SDF for the letter Y.\nfloat sdf_Y(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(2, -8, 0)));\n    return t;\n}\n\n// SDF for the letter Z.\nfloat sdf_Z(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(0, -8, 0)));\n    return t;\n}\n\n// **************************************************************** //\n// **************************************************************** //\n// **** NUMBERS                                                **** //\n// **************************************************************** //\n// **************************************************************** //\n\n// SDF for the number 0.\nfloat sdf_0(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));\n    return t;\n}\n\n// SDF for the number 1.\nfloat sdf_1(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -2, 0)));\n    return t;\n}\n\n// SDF for the number 2.\nfloat sdf_2(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -2, 0)));\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_sphere(pos, vec3(0, -2, 0)));\n    return t;\n}\n\n// SDF for the number 3.\nfloat sdf_3(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));\n    return t;\n}\n\n// SDF for the number 4.\nfloat sdf_4(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -2, 0)));\n    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(4, -4, 0)));\n    t = min(t, sdf_quarter2_torus(pos, vec3(2, -2, 0)));\n    return t;\n}\n\n// SDF for the number 5.\nfloat sdf_5(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));\n    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));\n    return t;\n}\n\n// SDF for the number 6.\nfloat sdf_6(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_half0_torus(pos, vec3(2, -6, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));\n    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));\n    return t;\n}\n\n// SDF for the number 7.\nfloat sdf_7(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, 0, 0)));\n    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));\n    return t;\n}\n\n// SDF for the number 8.\nfloat sdf_8(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_torus(pos, vec3(2, -2, 0)));\n    t = min(t, sdf_torus(pos, vec3(2, -6, 0)));\n    return t;\n}\n\n// SDF for the number 9.\nfloat sdf_9(in vec3 pos, in vec3 offset) {\n    pos -= offset;\n    float t = 1000.0;\n    t = min(t, sdf_torus(pos, vec3(2, -2, 0)));\n\tt = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));\n    return t;\n}\n\n// **************************************************************** //\n// **************************************************************** //\n// **** SCENE                                                  **** //\n// **************************************************************** //\n// **************************************************************** //\n\n// SDF of the scene.\nfloat z_offset = float(24);\nfloat sdf(in vec3 pos) {\n\tfloat t = 1000.0;\n\tvec3 offset = vec3(-24, 4, 0);\n\tt = min(t, sdf_C(pos, vec3(0, 0, 0) + offset));\n\tt = min(t, sdf_o(pos, vec3(6, 0, 0) + offset));\n\tt = min(t, sdf_b(pos, vec3(12, 0, 0) + offset));\n\tt = min(t, sdf_a(pos, vec3(18, 0, 0) + offset));\n\tt = min(t, sdf_l(pos, vec3(24, 0, 0) + offset));\n\tt = min(t, sdf_t(pos, vec3(26, 0, 0) + offset));\n\tt = min(t, sdf_X(pos, vec3(32, 0, 0) + offset));\n\tt = min(t, sdf_I(pos, vec3(38, 0, 0) + offset));\n\tt = min(t, sdf_I(pos, vec3(44, 0, 0) + offset));\n\treturn t;\n}\n\n// Calculate the surface normal of the scene at a certain point.\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calc_normal(in vec3 pos) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize(e.xyy * sdf(pos + e.xyy * ep) + \n                     e.yyx * sdf(pos + e.yyx * ep) + \n                     e.yxy * sdf(pos + e.yxy * ep) + \n                     e.xxx * sdf(pos + e.xxx * ep));\n}\n\n// Calculate soft shadows.\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calc_soft_shadows(in vec3 ro, in vec3 rd, in float tmin, in float tmax, const float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 50; i++) {\n        float h = sdf(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if (res < 0.005 || t > tmax) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Gradient noise function.\n// https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash(in vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 074.7)),\n\t\t\t dot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\t dot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Gradient noise function.\n// https://www.shadertoy.com/view/Xsl3Dl\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(dot(hash(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)), \n                       dot(hash(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),\n                   mix(dot(hash(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)), \n                       dot(hash(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),\n               mix(mix(dot(hash(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)), \n                       dot(hash(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),\n                   mix(dot(hash(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)), \n                       dot(hash(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);\n}\n\n// Rotation matrices.\nmat3 x_rotate(float a) {\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(a), -sin(a),\n                0.0, sin(a), cos(a));\n}\nmat3 y_rotate(float a) {\n    return mat3(cos(a), 0.0, sin(a),\n                0.0, 1.0, 0.0,\n                -sin(a), 0.0, cos(0.0));\n}\nmat3 z_rotate(float a) {\n    return mat3(cos(a), -sin(a), 0.0,\n                sin(a), cos(a), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Anti-aliasing level.\n#define AA 1\n\n// Main shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color0 = vec3(0.0, 0.0, 1.0);\n    vec3 color1 = vec3(1.0, 0.0, 0.0);\n    \n    vec3 lig = normalize(vec3(0.0, 4.0, 1.0));\n    \n    vec3 tot = vec3(0.0);\n    \n    // Do multiple samples for anti-aliasing.\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        // Offset pixel coordinate.\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 p = (fragCoord / iResolution.xy * 2.0 - 1.0);\n        p.x *= iResolution.x / iResolution.y;\n \n        // Calculate ray parameters.\n        vec3 ro = vec3(p * z_offset * 0.75, 0.0);\n        vec3 rd = vec3(0.0, 0.0, -1.0);\n\n       \t// Maximum ray distance.\n        const float tmax = 10000.0;\n        \n        // Cast ray.\n        float t = 0.0;\n        for (int i = 0; i < 64; i++) {\n            vec3 p = ro + t * rd;\n            float h = sdf(p);\n            if (abs(h) < 0.001) {\n                break;\n            }\n            t += h;\n        }\n\n        // Calculate lighting if the ray hit something.\n        vec3 col = vec3(0.0);\n        if (t < tmax)\n        {\n            vec3 pos = ro + t * rd;\n            vec3 nor = calc_normal(pos); \n            float dif = clamp(dot(nor, lig), 0.0, 1.0);\n            pos.y -= iTime;\n            pos.z += iTime;\n            float n = 1.0000 * noise(pos * 1.0) +\n                      0.5000 * noise(pos * 2.0) +\n                      0.2500 * noise(pos * 4.0) +\n                      0.1250 * noise(pos * 8.0) +\n                      0.0650 * noise(pos * 16.0);\n            n /= 0.5;\n            col = clamp(mix(color0, color1, fragCoord.x / iResolution.x) + vec3(n), vec3(0.0), vec3(1.0)) + dif;\n        } else {\n            vec3 pos = ro / z_offset;\n            pos.z += iTime / 10.0;\n            float n = 1.0000 * noise(pos * 1.0) +\n                      0.5000 * noise(pos * 2.0) +\n                      0.2500 * noise(pos * 4.0) +\n                      0.1250 * noise(pos * 8.0) +\n                      0.0650 * noise(pos * 16.0);\n            col = vec3(pow((n + 1.0) / 2.0, 8.0));\n        }\n        \n        tot += sqrt(col);\n    }\n    \n    tot /= float(AA * AA);\n    \n    const float temp = -20.0 / 255.0;\n    tot.x += temp;\n    tot.z -= temp;\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3zW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdyGRW", "name": "Raymarching studies", "author": "makio135", "description": "Based on: \n- [Ray Marching and Signed Distance Functions by Jamie Wong](http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)\n- [@iq distance functions](http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)", "tags": ["raymarching", "sdf"], "likes": 12, "viewed": 323, "date": "1569791071", "time_retrieved": "2024-06-20T19:44:01.199336", "image_code": "#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define PI 3.1415926\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat dot2(vec2 v) {\n    return dot(v, v);\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0 * h);\n    vec2 ca = vec2(q.x - min(q.x,(q.y < 0.0) ? r1 : r2), abs(q.y) - h);\n    vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0, 1.0);\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat opSmoothUnion(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0 ) / k;\n  return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nfloat sceneSDF(vec3 p) {\n  p = rotateY(iTime) * p;\n\n  float s = sin(iTime * 2.) / 2. + 0.5;\n  float t = smoothstep(0., 2., s);\n  float l = 0.5 + s;\n  float r = 0.4;\n  float r2 = r - s/2.;\n\n  vec3 q = abs(p);\n  float d = sdCappedCone(q + vec3(0, -l, 0.), l, r, r2);\n  float a90 = radians(90.);\n  float a45 = radians(45.);\n  mat3 rotX = rotateX(a90);\n  d = min(d, sdCappedCone(rotX * q + vec3(0, -l, 0.), l, r, r2));\n  d = min(d, sdCappedCone(rotX * rotateY(a90) * q + vec3(0, -l, 0.), l, r, r2));\n  d = opSmoothUnion(d, sdCappedCone(rotateX(a45) * q + vec3(0, -l, 0.), l, r, r2), 0.1);\n  d = opSmoothUnion(d, sdCappedCone(rotateX(radians(60.)) * rotateY(a45)* q + vec3(0, -l, 0.), l, r, r2), 0.1);\n\n  return d;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    float pDist = sceneSDF(p);\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - pDist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - pDist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - pDist\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n\n    vec3 light1Pos = vec3(-4.0, //* sin(iTime),\n                          2.0,\n                          4.0); //* cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n\n    vec3 light2Pos = vec3(2.0, //* sin(0.37 * iTime),\n                          2.0, //* cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    /*if (dist > MAX_DIST - EPSILON) { // Didn't hit anything\n         float d = 0.6 - length((fragCoord - iResolution.xy/2.)/iResolution.x);\n         fragColor = vec4(vec3(d), 1.0);\n         return;\n    }*/\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.97, 0.22, 0.5) * (mod(length(p), 0.3) > 0.15 ? 1. : 0.);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 40.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(fragCoord/iResolution.xy, 0.5, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdyGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl2XWt", "name": "kompot", "author": "foran", "description": "kompot", "tags": ["kompot"], "likes": 4, "viewed": 104, "date": "1567531810", "time_retrieved": "2024-06-20T19:44:01.659922", "image_code": "#define PI 3.14158\n#define TAU PI*2.\n#define t iTime*.13\n\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat sdBox(vec3 p,vec3 b)\n{ vec3 d=abs(p)-b; return length(max(d,0.)) +min(max(d.x,max(d.y,d.z)),0.);// remove this line for an only partially signed sdf\n}\nvec3 moda (vec2 p, float count) {\n  float an = TAU/count;\n  float a = atan(p.y,p.x)+an/2.;\n  float c = floor(a/an);\n  a = mod(a,an)-an/2.;\n  c = mix(c, abs(c), step(count/2., abs(c)));\n  return vec3(vec2(cos(a),sin(a))*length(p),c); \n}\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nfloat smin (float a, float b, float r) {\n  float h = clamp(.5+.5*(b-a)/r, 0.,1.);\n  return mix(b,a,h)-r*h*(1.-h);\n}\n\nfloat map (vec3 p);\n\nvec3 normal (vec3 p){\n  float e = 0.01;\n  return normalize(vec3(map(p+vec3(e,0,0))-map(p-vec3(e,0,0)),\n  map(p+vec3(0,e,0))-map(p-vec3(0,e,0)),\nmap(p+vec3(0,0,e))-map(p-vec3(0,0,e))));\n}\n\nfloat iso (vec3 p, float r) { return dot(p, normalize(sign(p)))-r; }\n\nfloat map (vec3 p) {\n  p.xy *= rot(t);\n  p.yz *= rot(t*.5);\n  p.xz *= rot(t*.3);\n  p.xz *= rot(p.y*.3+t);\n\n  float cyl2 = cyl(p.xz, .3+.8 * (.5+.5*sin(p.y*1.+t*10.)));\n  float a = atan(p.y,p.x);\n  float l = length(p.xy);\n  float c = 1.;//   10\n  p.x = mod(abs(l*.95-4.)+t*1., c)-c/2.;\n  //p.y = cos(a)*10.;\n\n  vec3 p1 = moda(p.xz, 8.);//      20\n  float wave1 = sin(t*10.+p.y*0.5+p1.z);\n  p1.x -= 2.+(.5+.5*wave1);\n  p.xz = p1.xy;\n  float celly = 3.;\n  vec3 p2 = p1;\n  p.y = mod(p.y+t*10.+p1.z,celly)-celly/2.;\n  float sph1 = sphere(p, 0.2+.2*(.5+.5*sin(p.y+t*10.)));\n  float cyl1 = cyl(p.xz, 0.2*wave1+.02);\n  float box=sdBox(p-vec3(0,-wave1,0),vec3(2.*.125));\n  float box1=sdBox(p-vec3(0,0,0),vec3(.3+.8*(.5+.5*sin(t*10.))));\n  float scene=smin(cyl1,box,.3);\n  scene=smin(scene,cyl2,.3);\n    \n  p.y = mod(p.y+t*10.,celly)-celly/2.;\n  float iso1 = iso(p,0.2+.2*wave1);\n  scene = smin(scene, iso1, .13);\n  return scene;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n\n{\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec3 eye = vec3(uv, -5.), ray = (vec3(uv,.5)), pos = eye;\n  int ri = 0;\n  for (int i = 0; i < 50; ++i) {\n    float dist = map(pos);\n    if (dist < 0.01) {\n      break;\n    }\n    pos += ray*dist;\n    ri = i;\n  }\n  vec3 n = normal(pos);\n  float ratio = float(ri)/50.;\n  vec4 color = vec4(1.);\n  color.rgb = n*.5+.5;\n  color.rgb *= 1.- ratio;\n  fragColor = vec4(color.rgb,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl2XWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlBGRR", "name": "sensors_fork", "author": "deerfeeder", "description": "dfghdfghdfghdfgh", "tags": ["circles", "grid", "random", "distance", "tiles", "mono"], "likes": 3, "viewed": 70, "date": "1568735518", "time_retrieved": "2024-06-20T19:44:01.659922", "image_code": "// Fork of \"sensors\" by lennyjpg. https://shadertoy.com/view/tlsGDs\n// 2019-05-19 00:58:01\n\n# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    vec2 u = fract(uv.xy*25.);\n    vec2 s = vec2(1.0,1.0);\n\n    u-=0.5;\n    vec2 g = iTime*0.2+floor(uv*5.);\n\n    float r = 1.0;\n    float angle = PI*0.5+floor(rand(floor(g))*4.)*PI*2.5;      \n    u.x+=sin(angle)*r;\n    u.y+=cos(angle)*r;\n  \n    float d = length(u);\n \t//float k = smoothstep(d,d*1.01,0.5);\n    float k =fract(d*1.0-iTime*0.7);\n    \n    k -= step(length(s),0.93);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlBGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tljXWt", "name": "Rothko generator", "author": "stseagle", "description": "Inspired by Mark Rothko paintings, it cycles through color palettes and generates a noisier and more watercolor looking version.", "tags": ["2d", "art", "rothko"], "likes": 6, "viewed": 589, "date": "1567533482", "time_retrieved": "2024-06-20T19:44:02.993412", "image_code": "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\n// Official HSV to RGB conversion \n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n// Color, and then amount (in percent) is positive for  \n// brightening and negative for darkening\nvec3 brighten(in vec3 color, in float amt) {\n    vec3 c_hsv = rgb2hsb(color);\n    return hsv2rgb(vec3(c_hsv.x, c_hsv.y, c_hsv.z * (1. + amt)));\n}\n\n// Color, and then amount to shift the hue\nvec3 shiftHue(in vec3 color, in float amt) {\n    vec3 c_hsv = rgb2hsb(color);\n    return hsv2rgb(vec3(c_hsv.x + amt, c_hsv.y, c_hsv.z));\n}\n\n// Color, and then amount (in percent) of saturation -\n//  positive to saturate negative to desaturate\nvec3 saturate(in vec3 color, in float amt) {\n    vec3 c_hsv = rgb2hsb(color);\n    return hsv2rgb(vec3(c_hsv.x, c_hsv.y * (1. + amt), c_hsv.z));\n}\n\nvec3 drawRect(in vec2 _st, vec2 pos, vec2 size, vec3 color) {\n    float hor = step(pos.x,_st.x) - step(pos.x + size.x,_st.x);\n    float ver = step(pos.y,_st.y) - step(pos.y + size.y,_st.y);\n    return mix(vec3(0.0), color,  hor * ver);\n}\n\nfloat drawRoundRect(in vec2 _st, vec2 pos, vec2 size, float edges) {\n    float hor = smoothstep(pos.x, pos.x + edges, _st.x) - smoothstep(pos.x + size.x,pos.x + size.x + edges,_st.x);\n    float ver = smoothstep(pos.y, pos.y + edges,_st.y) - smoothstep(pos.y + size.y, pos.y + size.y + edges,_st.y);\n    return hor * ver;\n}\n\n// From Inigo Quilez\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// https://www.shadertoy.com/view/XdXGW8 \nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat random(in float seed) {\n    return fract(sin(dot(vec2(seed),\n                         vec2(11.039234,66.74392)))*\n        5706.2373);\n}\n\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    return mix(random(i), random(i + 1.), smoothstep(0.,1.,f));\n}\n\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat noisyRect(in vec2 _st, vec2 pos, vec2 size, vec2 noiseFrac, float ratio) {\n    float r1 = 0.;\n    // The crispy rectangle\n    float no = snoise(_st * 115.) *.3;\n    vec2 mt = iMouse.xy/max(iResolution.x, iResolution.y);\n    float hor = smoothstep(pos.x , pos.x + 0.07,_st.x) - \n        smoothstep(pos.x + size.x , pos.x + size.x + 0.07,_st.x) ;\n    float ver = smoothstep(pos.y , pos.y + 0.07,_st.y) - \n        smoothstep(pos.y + size.y , pos.y + size.y+ 0.07,_st.y) ;\n\n    r1 = hor * ver + no;\n    r1 = ratio * step(0.7,r1);\n\n    // the soft rectangle\n    float r2= 0.;\n    no = noise(_st * (28.23)) * (0.06 + 0.02 * sin(iTime))+0.02;\n    float hor2 = smoothstep(pos.x +no, pos.x + 2.*no,_st.x) - \n        smoothstep(pos.x + size.x+no, pos.x + size.x + 2.*no,_st.x) ;\n    float ver2 = smoothstep(pos.y+no, pos.y +2.*no,_st.y) - \n        smoothstep(pos.y + size.y+no, pos.y + size.y+2.*no,_st.y) ;\n\n    r2 = (1. - ratio ) *hor2 * ver2;\n\n    return  r1 + r2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/min(iResolution.x, iResolution.y);\n    float w = 0.74;\n    // Center the tall rectangle if landscape aspect ratio\n    if (iResolution.x > iResolution.y) { \n    \tst.x -= 0.4*(iResolution.x - 0.74 * iResolution.y)/iResolution.y;\n    }\n    \n    vec2 mt = iMouse.xy/min(iResolution.x, iResolution.y);\n    vec3 base_color = vec3(0.4 + 0.4 * sin(iTime * 0.12 + 0.4), \n                0.36 + 0.35 * sin(iTime* 0.05 + 0.3), 0.5 +\n                0.57 * cos(iTime * 0.034 + 0.35)); \n    vec3 color = brighten(shiftHue(base_color, 0.5), -0.7);\n   \n\n    float splits[4]; \n    splits[0] = 0.;\n    splits[1] = 0.1 + 0.3 * noise(iTime * .11);\n    splits[2] = 0.3 + 0.3 * noise(iTime * .352);\n    splits[3] = .95;\n\n    // Paint noise\n    float n = 0.5 + 0.6 * noise(vec2(st.x*  90., st.y* 16.1 ) + mt);\n\t\n    // The buffer between the rectangles and edges\n    float bf = 0.02;\n    \n    // Make three noisy rectangles\n    vec3 rects = vec3(0.);\n    for (int i = 0; i < 3; i++) {\n        float x = bf;\n        float y = bf * (float(i) ) + splits[i];\n        \n        float h = splits[i+1] - y;\n        vec3 c = shiftHue(brighten(saturate(base_color, -float(i) * 0.25), \n                                   -float(i) * 0.18), -float(i-2) * 0.02);\n\n        rects += noisyRect(st , vec2(x,y), vec2(w, h), vec2(mt.x, mt.y) ,\n                           0.2 + mt.y * 0.4) * c + \n            0.5 * noisyRect(st , vec2(x,y), vec2(w, h), vec2(mt.x, mt.y) , mt.y) * c ;\n        rects -= drawRoundRect(st, vec2(x,y), vec2(w, h), 0.03) * n * \n                    brighten(shiftHue(c, -0.16) , -0.5) * 0.45;\n\n    }\n\n    color += rects;\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tljXWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlSSzc", "name": "Dragon Ball Collections", "author": "tobia88", "description": "Practicing for drawing dragon ball", "tags": ["2d"], "likes": 18, "viewed": 785, "date": "1568211582", "time_retrieved": "2024-06-20T19:44:02.999466", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x, 0., 1.)\n\n#define PI 3.14159265\n#define TWO_PI 2.*PI\n\n#define BALL_MIN_SIZE .2\n#define BALL_MAX_SIZE .3\n\n#define BALL_BASE_COL vec3( .85, .52, .25 )\n#define BALL_INNER_COL vec3( .8, .4, .2 )\n#define BALL_SHADOW_COL vec3( .42, .0, .0 )\n#define BALL_HIGHLIGHT_COL vec3( .85, .8, .6 )\n\n// 7 dragon balls\n// floating\n// sky\n// glowing\n\n// Star\n#define STAR_COL vec3( .6, .1, .0 )\n\nfloat rand(float seed) {\n \treturn fract( sin( seed * 100. ) * 1392. );   \n}\n\nvec2 remapUV( vec2 uv, vec4 rect ) {\n \treturn (uv - rect.xy) / ( rect.zw - rect.xy );\n}\n\nfloat lerp( float a, float b, float t ) {\n\treturn (t - a) / (b - a);\n}\n\nfloat remap( float a, float b, float c, float d, float t ) {\n\treturn lerp( a, b, t ) * ( d - c ) + c;\n}\n\nfloat polygon(vec2 uv, float n) {\n\tfloat a = atan(uv.x, uv.y) + PI;\n\tfloat r = TWO_PI / n;\n\treturn cos(floor(.5 + a / r) * r - a) * length(uv);\n}\n\nfloat star( vec2 uv, float size, float id ) {\n    // rotate uv\n    float t = iTime * -1. + rand(id) * 100.;\n    float s = sin( t );\n    float c = cos( t );\n    mat2 m = mat2( c, s,\n                   -s, c );\n    uv *= m;\n    \n    float pentagon = polygon( uv, 5. );\n \tfloat pen1 = polygon( uv * vec2( 1., -1 ), 5. );\n    float pen2 = polygon( uv, 5. );\n    return S(.1, .05, ( pen1 - pen2 * .619 ) * size );\n}\n\nvec4 stars( vec2 uv, float n ) {\n    vec4 col = vec4( STAR_COL, 0. );\n    \n    float t = sin( iTime + rand(n) * 100. );\n    float s = sin( t );\n    float c = cos( t );\n    mat2 m = mat2( c, s,\n                  -s, c );\n    uv *= m;\n    \n    if ( n == 1. )\n    \tcol.a += star( uv, 3., n );\n    else if ( n == 2. ) {\n        col.a += star( uv + vec2(.2, 0), 3., n );\n        col.a += star( uv + vec2( -.2, .1 ), 3., n + 1. );\n    }\n    else if ( n == 3. ) {\n\t\tcol.a += star( uv + vec2(.2, -.05), 3., n );\n        col.a += star( uv + vec2( .1, .3 ), 3., n + 1. );\n        col.a += star( uv + vec2( -.2, .08 ), 3., n + 1. );\n    }\n    else if ( n == 4. ) {\n        col.a += star( uv + vec2(.015, -.21), 3., n );\n        col.a += star( uv + vec2( -.325, -.0 ), 3., n + 1. );\n        col.a += star( uv + vec2( .3, .08 ), 3., n + 1. );\n        col.a += star( uv + vec2( -.028\t, .31 ), 3., n + 1. );\n    }\n    else if ( n == 5. ) {\n        col.a += star( uv + vec2(.015, -.35), 3., n );\n        col.a += star( uv + vec2( -.325, -.0 ), 3., n + 1. );\n        col.a += star( uv + vec2( .325, .03 ), 3., n + 1. );\n        col.a += star( uv + vec2( -.028\t, .31 ), 3., n + 1. );\n        col.a += star( uv + vec2( 0., 0. ), 3., n + 1. );\n    }\n    else if ( n == 6. ) {\n\t\tcol.a += star( uv + vec2(.015, -.35), 3., n );\n        col.a += star( uv + vec2( -.325, -.10 ), 3., n + 1. );\n        col.a += star( uv + vec2( .325, -.08 ), 3., n + 1. );\n        col.a += star( uv + vec2( -.2, .23 ), 3., n + 1. );\n        col.a += star( uv + vec2( .2, .25 ), 3., n + 1. );\n        col.a += star( uv + vec2( 0., 0. ), 3., n + 1. );\n    }\n    else {\n        col.a += star( uv + vec2(.186, -.32), 3., n );\n        col.a += star( uv + vec2( -.345, -.052 ), 3., n + 1. );\n        col.a += star( uv + vec2( .385, -.038 ), 3., n + 1. );\n        col.a += star( uv + vec2( -.2, .28 ), 3., n + 1. );\n        col.a += star( uv + vec2( .221, .28 ), 3., n + 1. );\n        col.a += star( uv + vec2( 0., 0. ), 3., n + 1. );\n        col.a += star( uv + vec2( -.185, -.35 ), 3., n + 1. );\n    }\n\n    return col;\n}\n\nvec4 dragonBall( vec2 uv, vec2 p, float star, float glow ) {\n    vec4 col = vec4(BALL_BASE_COL, 1.);\n    \n    float size = remap( -.5, .5, .15, .1, p.y * 3.3);\n    float fade = remap( -.5, .5, 1., .8, p.y * 3. );\n    \n    p.y += sin( iTime * 2. + rand( star ) * 100. ) * remap( -.5, .5, .05, .0, p.y );\n    \n    float halfSize = size * .5;\n    vec2 nuv = remapUV( uv, vec4( p.x - halfSize, p.y - halfSize, p.x + halfSize, p.y + halfSize)) - .5;\n    \n    float d = length( nuv );\n    col.a = sat(S( 1., .95, d ) + S( 2., 0., d ) * glow);\n    \n    // inner\n    col.rgb = mix( col.rgb, BALL_INNER_COL, S( .9, .85, d ));\n    \n    // stars\n    vec4 stars = stars( nuv, star );\n    col.rgb = mix( col.rgb, stars.rgb, stars.a );\n    \n    // shading\n    float shadingMaskA = S( .9, .85, d );\n    float shadingMaskB = S( .9, .85, length( nuv - vec2( -.17, .4 )));\n    float finalShadingMask = sat(shadingMaskA - shadingMaskB) * .25;\n    \n    col.rgb = mix( col.rgb, BALL_SHADOW_COL, finalShadingMask );\n    \n    // highlight A\n    float highlightPower = remap( .0, 1., .75, .25, glow );\n    \n    vec2 huv = nuv;\n    huv.y *= 1.4 - huv.x * .3;\n    float highlightMask = S( .4, .39, length( huv - vec2( -.25, .88 ))) * highlightPower;\n    col.rgb = mix( col.rgb, BALL_HIGHLIGHT_COL, highlightMask );\n    \n    // highlight B\n    huv = nuv;\n    huv.y *= 1.4;\n    huv.y += huv.x * .4;\n    highlightMask = S( .15, .14, length( huv - vec2( .5, 1.08 ))) * highlightPower;\n    col.rgb = mix( col.rgb, BALL_HIGHLIGHT_COL, highlightMask );\n    \n    col.rgb *= fade + 1. * glow * 1.5;\n    \n    // glow\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float glow = remap(-1., 1., 0., 1., sin( iTime * 2. ));\n    \n    vec4 col = vec4(0.);\n    \n    vec4 d1 = dragonBall( uv, vec2(.1, .312), 3., glow );\n    vec4 d2 = dragonBall( uv, vec2(.25, .21), 2., glow );\n    vec4 d3 = dragonBall( uv, vec2(-.2, .17), 1., glow );\n    vec4 d4 = dragonBall( uv, vec2(.05, .08), 6., glow );\n    vec4 d5 = dragonBall( uv, vec2(-.4, -.02), 5., glow );\n    vec4 d6 = dragonBall( uv, vec2(.32, -.08), 7., glow );\n    vec4 d7 = dragonBall( uv, vec2(-.15\t, -.2), 4., glow );\n    \n    col.rgb = mix(col.rgb, d1.rgb, d1.a);\n    col.rgb = mix(col.rgb, d2.rgb, d2.a);\n    col.rgb = mix(col.rgb, d3.rgb, d3.a);\n\tcol.rgb = mix(col.rgb, d4.rgb, d4.a);\n\tcol.rgb = mix(col.rgb, d5.rgb, d5.a);\n\tcol.rgb = mix(col.rgb, d6.rgb, d6.a);\n    col.rgb = mix(col.rgb, d7.rgb, d7.a);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlSSzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlSXDc", "name": "Fibers", "author": "gressettd", "description": "Tiling threads / fibers", "tags": ["fiber"], "likes": 3, "viewed": 77, "date": "1567298075", "time_retrieved": "2024-06-20T19:44:03.975439", "image_code": "// With props / regards to\n//\n// https://www.shadertoy.com/view/lsdfRM\n// and\n// https://www.researchgate.net/publication/230605029_A_Procedural_Thread_Texture_Model\n//\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\nfloat Map( float range_a_point, float a0, float a1, float b0, float b1 )\n{\n    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;\n}\n\nvec4 ComputeThreadPattern(\n\tvec2 pos, \n\n\tfloat twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded\n\t)\n{\n    vec2 uv = pos;\n\tuv.x *= twists;\n\t\n\n\tfloat twistTrajectory = \n       ( ( asin( 2.0 * uv.y - 1.0)/( PI / 2.0 ) + 1.0 ) * tightness * facetLength ) / 2.0;\n    \n\tfloat thickness = 1.0 - Map(sin(1.0 - PI / 2.0), -1.0, 1.0, 0.0, 0.6);\n\tfloat trajH = uv.x + twistTrajectory;\n\tfloat displacement =\n\t\t(2.0 / thickness) * (trajH - (floor(trajH / thickness) * thickness)) - 1.0;\n\t\n\tfloat pDisplacement =\n\t\tsmoothness * displacement + (1.0 - smoothness);\n\n\tfloat twistShading = 0.0;\n\tif (rounded)\n\t\ttwistShading = exp( -(  pow( pDisplacement, 2.0 )/0.5 ) );\n\telse\n\t\ttwistShading = abs(pDisplacement);\n\n\tfloat yShading = offset.y + (1.0 - offset.y) * sin(uv.y * PI);\n\tfloat xShading = 1.0;\n\tfloat steepness = facetLength;\n\t//if (uv.x < 0.5)\n\t//{\n\t\txShading = offset.x + (1.0 - offset.x) * tanh(pos.x * steepness);\n\t//}\n\t//else\n\t//{\n\t//\txShading = offset.x + (1.0 - offset.x) * tanh((1.0 - scaledPos.x) * steepness);\n\t//}\n\n\tfloat threadShading = twistShading * yShading * xShading;\n\n\treturn vec4(threadShading, twistShading, xShading, yShading);\n}\n\nvec4 ComputeThreadsPatternH(\n    highp vec2 pos,\n    vec2 tiling,\n    \n    float twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded)\n{\n    highp vec2 uv = \n        vec2(pos.x, fract(pos.y * tiling.y));\n    \n    vec4 rv = ComputeThreadPattern(uv,\n                                twists * tiling.x, \n                                facetLength,\n                                tightness,\n                                smoothness,\n                                offset,\n                                rounded);\n    rv.z = floor(pos.x * tiling.x);\n    rv.w = floor(pos.y * tiling.y);\n    return rv;\n    \n}\n    \nvec4 ComputeThreadsPatternV(\n    highp vec2 pos,\n    vec2 tiling,\n    \n    float twists,\n\tfloat facetLength, // def 5.0\n\tfloat tightness, // 0 .. 1, default 0.5\n\tfloat smoothness, //\n\tvec2 offset, // brightness offset, default 0.3\n\tbool rounded)\n{\n    highp vec2 uv = \n        vec2( pos.y, fract(pos.x * tiling.x));\n    \n    vec4 rv = ComputeThreadPattern(uv,\n                                twists * tiling.x, \n                                facetLength,\n                                tightness,\n                                smoothness,\n                                offset,\n                                rounded);\n    rv.z = floor(pos.x * tiling.x);\n    rv.w = floor(pos.y * tiling.y);\n    return rv;\n    \n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    highp vec2 uv = fragCoord/iResolution.xy;\n    uv += vec2(cos(iTime*0.1) + iTime*0.1,iTime * 0.05);\n    \n    vec4 cc;\n    \n    float switchSeconds = 6.6;\n    float frm = mod(iTime,switchSeconds) /switchSeconds;\n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n    \n    \n    \n    float t = 0.0;\n    \n    if(frm < 0.5)\n    {\n        cc = ComputeThreadsPatternH(\n            uv, \n            vec2(16.0,16.0),\n\n            5.0, \n            5.0, \n            1.0, \n            1.0, \n            vec2(0.5,0.1), \n            true);\n        \n        t = Random1D(cc.w);\n    } else\n        \n    {\n\t    cc = ComputeThreadsPatternV(\n            uv, \n            vec2(16.0,16.0),\n\n            5.0, \n            5.0, \n            1.0, \n            1.0, \n            vec2(0.5,0.1), \n            true);\n        \n        t = Random1D(cc.z);\n    }   \n    \n    vec4 col = cc.x * ComputeWaveGradientRGB(t,bias,scale,freq,phase);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlSXDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts33DX", "name": "Sakura Bliss", "author": "PixelPhil", "description": "My first ShaderToy entry : a poetic rain of stylized sakura flowers with intricate self shadowing and tilt-shift effect.", "tags": ["2d", "flower", "bokeh", "pattern", "cherry", "blossom", "sakura"], "likes": 53, "viewed": 1484, "date": "1569368973", "time_retrieved": "2024-06-20T19:44:05.042046", "image_code": "//\n// Sakura Bliss by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n//\n// I recently stumbled upon Martijn Steinrucken aka BigWings Youtube channel\n// his work amazed me and inspired me to take a leap and try it out for myself.\n//\n// This is my first ShaderToy entry.\n//\n\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n\n\n// Borrowed from BigWIngs\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Computes the RGB and alpha of a single flower in its own UV space\nvec4 sakura(vec2 uv, vec2 id, float blur)\n{\n    float time = iTime + 45.0; //time is offset to avoid the flowers to be aligned at start\n    \n    vec4 rnd = N14(mod(id.x, 500.0) * 5.4 + mod(id.y, 500.0) * 13.67); //get 4 random numbersper flower\n    \n    // Offset the flower form the center in a random Lissajous pattern\n    uv *= mix(0.75, 1.3, rnd.y);            \n    uv.x += sin(time * rnd.z * 0.3) * 0.6;\n    uv.y += sin(time * rnd.w * 0.45) * 0.4;\n    \n    \n    // Computes the angle of the flower with a random rotation speed\n    float angle = atan(uv.y, uv.x) + rnd.x * 421.47 + iTime * mix(-0.6, 0.6, rnd.x);\n    \n    \n    // euclidean distance to the center of the flower\n    float dist = length(uv);\n   \n  \t// Flower shaped distance function form the center\n    float petal = 1.0 - abs(sin(angle * 2.5));\n    float sqPetal = petal * petal;\n    petal = mix(petal, sqPetal, 0.7);\n    float petal2 = 1.0 - abs(sin(angle * 2.5 + 1.5));\n    petal += petal2 * 0.2;\n    \n    float sakuraDist = dist + petal * 0.25;\n    \n   \n    // Compute a blurry shadow mask.\n    float shadowblur = 0.3;\n    float shadow = S(0.5 + shadowblur, 0.5 - shadowblur, sakuraDist) * 0.4;\n    \n    //Computes the sharper mask of the flower\n    float sakuraMask = S(0.5 + blur, 0.5 - blur, sakuraDist);\n    \n    // The flower has a pink hue and is lighter in the center\n    vec3 sakuraCol = vec3(1.0, 0.6, 0.7);\n    sakuraCol += (0.5 -  dist) * 0.2;\n    \n\t// Computes the border mask of the flower\n    vec3 outlineCol = vec3(1.0, 0.3, 0.3);\n    float outlineMask = S(0.5 - blur, 0.5, sakuraDist + 0.045);\n    \n    // Defines a tiling polarspace for the pistil pattern\n    float polarSpace = angle * 1.9098 + 0.5;\n    float polarPistil = fract(polarSpace) - 0.5; // 12 / (2 * pi)\n    \n    // Round dot in the center\n    outlineMask += S(0.035 + blur, 0.035 - blur, dist);\n    \n    float petalBlur = blur * 2.0;\n    float pistilMask = S(0.12 + blur, 0.12, dist) * S(0.05, 0.05 + blur , dist);\n    \n    // Compute the pistil 'bars' in polar space\n    float barW = 0.2 - dist * 0.7;\n    float pistilBar = S(-barW, -barW + petalBlur, polarPistil) * S(barW + petalBlur, barW, polarPistil);\n    \n    // Compute the little dots in polar space\n    float pistilDotLen = length(vec2(polarPistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;\n    float pistilDot = S(0.1 + petalBlur, 0.1 - petalBlur, pistilDotLen);\n    \n    //combines the middle an border color\n    outlineMask += pistilMask * pistilBar + pistilDot;\n    sakuraCol = mix(sakuraCol, outlineCol, sat(outlineMask) * 0.5);\n    \n    //sets the background to the shadow color\n    sakuraCol = mix(vec3(0.2, 0.2, 0.8) * shadow, sakuraCol, sakuraMask);\n    \n    //incorporates the shadow mask into alpha channel\n    sakuraMask = sat(sakuraMask + shadow);\n    \n\t//returns the flower in pre-multiplied rgba\n    return vec4(sakuraCol, sakuraMask);\n}\n\n// blends a pre-multiplied src onto a dst color (without alpha)\nvec3 premulMix(vec4 src, vec3 dst)\n{\n    return dst.rgb * (1.0 - src.a) + src.rgb;\n}\n\n// blends a pre-multiplied src onto a dst color (with alpha)\nvec4 premulMix(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = premulMix(src, dst.rgb);\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n    return res;\n}\n\n\n// Computes a Layer of flowers\nvec4 layer(vec2 uv, float blur)\n{\n    vec2 cellUV = fract(uv) - 0.5;\n    vec2 cellId = floor(uv);\n    \n    vec4 accum = vec4(0.0);\n    \n    // the flowers can overlap on the 9 neighboring cells so we blend them all together on each cell\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offset = vec2(x, y); \n            vec4 sakura = sakura(cellUV - offset, cellId + offset, blur);\n            accum = premulMix(sakura, accum);\n        }\n    }\n    \n \treturn accum;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 nominalUV = fragCoord/iResolution.xy;\n    \n    vec2 uv = nominalUV - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Scroll the UV with a cosine oscillation\n    uv.y += iTime * 0.1;\n    uv.x -= iTime * 0.03 + sin(iTime) * 0.1;\n    \n    uv *= 4.3;\n\n    //Compute a BG gradient\n    float screenY = nominalUV.y;\n    vec3 col = mix(vec3(0.3, 0.3, 1.0), vec3(1.0, 1.0, 1.0), screenY);\n    \n    // Compute a tilt-shift-like blur factor\n    float blur = abs(nominalUV.y - 0.5) * 2.0;\n    blur *= blur * 0.15;\n    \n    // Computes several layers with various degrees of blur and scale\n    vec4 layer1 = layer(uv, 0.015 + blur);\n    vec4 layer2 = layer(uv * 1.5 + vec2(124.5, 89.30), 0.05 + blur);\n    layer2.rgb *= mix(0.7, 0.95, screenY);\n    vec4 layer3 = layer(uv * 2.3 + vec2(463.5, -987.30), 0.08 + blur);\n    layer3.rgb *= mix(0.55, 0.85, screenY);\n    \n    // Blend it all together\n\tcol = premulMix(layer3, col);\n    col = premulMix(layer2, col);\n\tcol = premulMix(layer1, col);\n    \n    // Adds some light at the to of the screen\n    col += vec3(nominalUV.y * nominalUV.y) * 0.2;\n\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts33DX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts33R2", "name": "Truchet flow", "author": "blinry", "description": ":)", "tags": ["truchet", "pattern"], "likes": 6, "viewed": 543, "date": "1568850482", "time_retrieved": "2024-06-20T19:44:05.042046", "image_code": "float N21(vec2 p) {\n    p = fract(p*vec2(234.234, 823.923));\n    p += dot(p, p+42.34);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec2 UV2 = abs(UV-0.5);\n    \n    uv.x += iTime*0.1;\n    uv.y += sin(iTime)*0.1+iTime*0.05;\n    \n    vec3 col = vec3(1.0, UV.x, sin(0.5*iTime+UV.y)*0.5+0.5);\n    \n    uv *= 7.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = N21(id);\n    float band = -.03+pow(0.5*UV.y, 1.5);\n    float width = 0.01+0.1*UV.x;\n    \n    if (n > 0.5) gv.x *= -1.;\n    \n    float d = length(gv - .5*sign(gv.x+gv.y+.001))-0.5;\n    d = abs(d);\n    d = abs(d-band);\n    d = abs(d-band);\n    d = abs(d-band); \n    d = abs(d)-width;\n    \n    float fuzzy = 0.01+0.2*pow(UV2.x+UV2.y, 2.);\n    float mask = smoothstep(fuzzy, 0.0, d);\n    \n    col *= mask;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts33R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts33W2", "name": "Stream of life", "author": "ende76", "description": "Mesmerizing view of squishy cells", "tags": ["voronoi"], "likes": 1, "viewed": 84, "date": "1569295361", "time_retrieved": "2024-06-20T19:44:05.042046", "image_code": "vec2 normalizedUv(vec2 f, vec3 r) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = f/r.xy;\n    \n    // Origin centered in viewport\n    uv -= .5;\n    \n    // Same scale in x/y dimensions\n    float a = r.x/r.y;\n    uv *= a > 1. ? vec2(a, 1.) : vec2(1., 1./a);\n    return uv;\n}\n\nvec2 N22(vec2 p) {\n\tvec3 n = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    n += dot(n, n+34.45);\n    return fract(vec2(n.x*n.y, n.y*n.z));\n}\n\nfloat N21(vec2 p) {\n    p += fract(vec2(1003.123,32003.987));\n    p = N22(p);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = normalizedUv(fragCoord, iResolution);\n    \n    // shorthand to access time\n    float t = iTime;\n    \n    // number of cells in grid\n    float gridSize = 5.;\n \tuv *= gridSize;\n    \n    uv.x += gridSize*sin(.031*t);\n    uv.y += gridSize*cos(.037*t);\n\n    // [0., 1.] coord relative to grid cell\n \tvec2 gv = fract(uv)-.5;\n    \n    // unique id for grid cell (i.e. id is the same value for every pixel in the same cell\n    vec2 id = floor(uv);\n    \n    vec2 n = N22(id);\n    \n    float minDist = 2.;\n    float minDist1 = minDist;\n    vec2 minId = vec2(0., 0.);\n    vec2 minId1 = minId;\n\n    for (float y = -2.; y < 3.; y++) {\n        for (float x = -2.; x < 3.; x++) {\n            vec2 offset = vec2(x, y);\n            vec2 otherId = floor(uv + offset);\n            vec2 otherN = N22(otherId);\n            vec2 otherP = offset + sin(otherN * (t + 6.283)) * .5;\n            \n            float d = length(gv - otherP);\n            if (d < minDist) {\n                minDist1 = minDist;\n                minDist = d;\n                minId1 = minId;\n                minId = otherId;\n            } else if (d < minDist1) {\n                minDist1 = d;\n                minId1 = otherId;\n            }\n        }\n    }\n\n    vec3 col = vec3(0);\n    col.r = (1. - minDist / 1.414);\n\n    col *= .5 * col;\n    col.r += .12;\n    col.r = sqrt(col.r);\n    \n    col += clamp(pow(1. - minDist1 - minDist, 4.), 0., .75);\n        \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts33W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3GD8", "name": "Bendy Buildings", "author": "pocketCoffee", "description": "Makin' some ray marchin'.", "tags": ["raymarching", "lighting", "shadows", "materials", "city", "buildings"], "likes": 4, "viewed": 89, "date": "1568326477", "time_retrieved": "2024-06-20T19:44:07.048261", "image_code": "#define MAX_STEPS 50\n#define MIN_DIST 0.001\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n\n// First ray marcher! Borrowed some code from IQ and various youtube tutorials.\n\n// Structs\nstruct Mat{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 shininess;\n};\n\nstruct Light{\n\tvec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Hit{\n    float d; // distance at hit\n    Mat mat;\n};\n\n    \n// SD Shapes\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Box rounded edges cause weird things to happen\nfloat sdBox(vec3 p, vec3 b){\n    vec3 d = abs(p) - b;\n      return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat Plane(vec3 p, float h){\n    return p.y - h;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c )\n{\n    // c is the sin/cos of the angle\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPyramid(vec3 p, vec3 h )\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa);\n }\n\n// Transforms\n// Rotation\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Bool Functions\nfloat boolSmoothSubtract(float a, float b, float k){\n    float h = clamp( 0.5 - 0.5*(a+b)/k, 0.0, 1.0 );\n    return mix( b, -a, h ) + k*h*(1.0-h);\n}\n\nfloat boolAdd(float a, float b){\n    return min(a, b);\n}\n\nfloat boolSmoothAdd(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat boolSubtraction( float d1, float d2 ) {\n\treturn max(-d1,d2); \n}\n\nvec3 opBend(vec3 p, float bend)\n{\n    float c = cos(bend * p.y);\n    float s = sin(bend * p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Models\nfloat leftBuilding(vec3 p){\n    p = opBend(p, -0.1);\n    float box = sdBox(p, vec3(1.5, 4., 1));\n    float ceiling = sdBox(p + vec3(0,-3.8,0), vec3(1.65, .1, 1.3));\n    float window0 = sdBox(p + vec3(-1.4, -1.8, .65), vec3(.14, .2, .1));\n    float window1 = sdBox(p + vec3(-1.4, -1.4, -.3), vec3(.14, .2, .1));\n    float window2 = sdBox(p + vec3(-1.4, -.7, .1), vec3(.14, .2, .1));\n    float windows = min(min(window2, window0), window1);\n\tfloat door = sdBox(p + vec3(-1.4, .4, .5), vec3(.15, .6, .1));\n    float shape1 = min(windows, door);\n    box = min(box, ceiling);\n    float building = boolSubtraction(shape1, box);\n\n    return building;\n}\n\nfloat rightBuilding(vec3 p){\n    p = opBend(p, 0.1);\n    float box = sdBox(p, vec3(1.5, 4., 1));\n    float ceiling = sdBox(p + vec3(0,-3.8,0), vec3(1.65, .1, 1.3));\n    float window0 = sdBox(p + vec3(1.4, -2.1, .1), vec3(.14, .2, .1));\n    float window1 = sdBox(p + vec3(1.4, -1.6, -.5), vec3(.14, .2, .1));\n    float window2 = sdBox(p + vec3(1.4, -.7, .1), vec3(.14, .2, .1));\n    float windows = min(min(window1, window0), window2);\n\tfloat door = sdBox(p + vec3(1.4, .4, -.3), vec3(.15, .6, .1));\n    float shape1 = min(windows, door);\n    box = min(box, ceiling);\n    float building = boolSubtraction(shape1, box);\n\n    return building;\n}\n\nfloat lamp(vec3 p){\n    float capsule0 = sdVerticalCapsule(p + vec3(0., 1., 0.), 1.5, .05);\n    float capsule1 = sdCapsule(p + vec3(.25, -.4, 0), vec3(.5, 0, 0), vec3(0, .0, 0), .015);\n    float bottom = sdBox(p + vec3(0, .95, 0), vec3(.16, .05, .16));\n    float middle = sdBox(p + vec3(0, .8, 0), vec3(.08, .1, .08));\n    vec3 lp = p + vec3(0, -.75, 0);\n    vec3 lpb = p + vec3(0, -.5, 0);\n    vec3 lpt = p + vec3(0, -.8, 0);    \n    lp.yz *= Rot(1.6);\n    lpb.yz *= Rot(1.6);\n\n    float lightTop = sdPyramid(lpt, vec3(.4, .4, .06));\n    float lightBottom = sdHexPrism(lpb, vec2(.15, .02));\n    float lightCombo1 = min(lightBottom, lightTop);\n    float lightCombo2 = min(lightCombo1, lightBottom);\n    float shape0 = min(middle, bottom);\n    float shape1 = min(capsule0, capsule1);\n    float shape2 = min(lightCombo2, shape1);\n    float lamp = boolSmoothAdd(shape2, shape0, 0.2);\n    return lamp;\n}\n\nfloat lampLight(vec3 p){\n    vec3 lp = p;\n    lp += vec3(0, -.65, 0);\n\tlp.yz *= Rot(1.6);\n\tfloat light = sdHexPrism(lp, vec2(.11, .13));\n    return light;\n}\n\nfloat sidewalk(vec3 p){\n\tfloat box = sdBox(p, vec3(2.5, .05, 4));\n    return box;\n}\n\n// Define materials\nfloat hash(float n) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nbool isHit = false;\n\nHit map(in vec3 p){\n    vec3 bp1 = p + vec3(0, 0, 0);\n    bp1.xz *= Rot(iTime);\n    bp1.xy *= Rot(iTime);\n    \n    vec3 cp = vec3(p);\n    cp.yz *= Rot(90.);\n    \n    vec3 lp = p + vec3(.84, 0, 4);\n    \n    float plane0 = Plane(opRep(p, vec3(0,0,5.)), -1.);\n    float building0 = leftBuilding(opRep(p + vec3(3, 0., 2.), vec3(0, 0, 4.)));\n    float building1 = rightBuilding(opRep(p + vec3(-3., 0., 1.), vec3(0, 0, 6.)));\n    float building2 = leftBuilding(opRep(p + vec3(2.9, 0., 0.), vec3(0, 0, 12.)));\n    //float building3 = leftBuilding(p + vec3(3, 0., 4.5));\n\t//float building4 = rightBuilding(opRep((p + vec3(-3., 0., 0.)), vec3(0, 0, 4.)));\n\t//float building5 = rightBuilding(p + vec3(-3., 0., -3.));\n    float lamp0 = lamp(opRep(lp + vec3(-2., 0, 0), vec3(0, 0, 12.)));\n    float lampLight0 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamp1 = lamp(opRep(lp, vec3(0,0,12.)));\n    float lampLight1 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float sidewalk0 = sidewalk(opRep(p + vec3(3., 1, 1), vec3(0,0,4.)));\n    float sidewalk1 = sidewalk(opRep(p + vec3(-3.5, 1, 1), vec3(0,0,4.))); \n    float sidewalks = min(sidewalk0, sidewalk1);\n    \n    \n    //float greenBuildings = min(building0, building1);\n    //float redBuildings = min(building2, building3);\n    //float blueBuildings = min(building4, building5);\n    \n    float shape0 = min(plane0, building0);\n    float shape1 = min(shape0, building1);\n    float shape2 = min(shape1, lamp1);\n    float shape9 = min(shape2, lampLight1);\n    float shape7 = min(shape9, sidewalks);\n    float shape10 = min(shape7, building2);\n    //float shape11 = min(shape10, building4);\n    \n    float result = shape10;\n    Hit hit;\n    hit.d = result;\n    \n    return hit;\n}\n\nMat AddMatStuff(Mat matResult, float stepResult, Mat matSample){\n    // Adds sampled material to a resulting material depending on step function float\n    matResult.ambient += matSample.ambient * stepResult;\n    matResult.diffuse += matSample.diffuse * stepResult;\n    matResult.specular += matSample.specular * stepResult;\n    matResult.shininess += matSample.shininess * stepResult;\n    return matResult;\n}\n\nfloat hash(vec2 coords){\n    return sin(coords.x + coords.y);\n    \n}\n\nMat ChooseMaterial(vec3 p){\n    // Make material to add to\n    Mat mat = Mat(vec3(0), vec3(0), vec3(0), vec3(0));\n    \n    // Building calculations\n    float building0 = leftBuilding(opRep(p + vec3(3, 0., 2.), vec3(0, 0, 4.)));\n    float building1 = rightBuilding(opRep(p + vec3(-3., 0., 1.), vec3(0, 0, 6.)));\n    float building2 = leftBuilding(opRep(p + vec3(2.9, 0., 0.), vec3(0, 0, 12.)));\n\t//float building3 = rightBuilding(opRep((p + vec3(-3., 0., 0.0)), vec3(0, 0, 4.)));\n    //building0 = min(building0, building3);\n    \n    // Street light calculations\n    vec3 lp = p + vec3(.84, 0, 4);\n    float lamp0 = lamp(opRep(lp + vec3(-2., 0, 0), vec3(0, 0, 12.)));\n    float lampLight0 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamp1 = lamp(opRep(lp, vec3(0,0,12.)));\n    float lampLight1 = lampLight(opRep(lp, vec3(0,0,12.)));\n    float lamps = min(lamp0, lamp1);\n    float lampLights = min(lampLight0, lampLight1);\n\n    // Ground calculations\n    float plane0 = Plane(opRep(p, vec3(0,0,5.)), -1.);    \n    float sidewalk0 = sidewalk(opRep(p + vec3(3., 1, 1), vec3(0,0,4.)));\n    float sidewalk1 = sidewalk(opRep(p + vec3(-3.5, 1, 1), vec3(0,0,4.))); \n    float sidewalks = min(min(sidewalk0, sidewalk1), plane0);\n    \n    // Get scene grid, hash grid to get random number 0-2\n    float sqz = mod(floor(p.z*.5 + 0.51),2.);\n    float sqx = step(p.x, 0.0);\n    //mat.diffuse = vec3(sqz, .5, .5);\n    vec2 coords = vec2(sqz, sqx);\n    float hashNum = hash(coords);\n    \n    // Materials\n    Mat groundMat = Mat(vec3(0.25, 0.20725, 0.20725), vec3(.4, .3, .3), vec3(0.296648, 0.296648, 0.296648), vec3(0.088, 0.088, 0.088));    \n\tMat copperMat = Mat(vec3(0.19125, 0.0735, 0.0225), vec3(0.7038, 0.27048, 0.0828), vec3(0.256777, 0.137622, 0.086014), vec3(0.1, 0.1, 0.1));\n\tMat buildingMat = Mat(vec3(0.9, 0.0, 0.3), vec3(0.5, 0.5, 0.4), vec3(0.7, 0.7, 0.04), vec3(0.078175));\n\tMat lampMat = Mat(vec3(.15, .15, .15), vec3(.3, .3, .3), vec3(.3, .3, .3), vec3(.3)*2.);\n\tMat lightMat = Mat(vec3(1.0, 1.0, .8), vec3(1.0, 1.0, .8), vec3(1.0, 1.0, .6), vec3(1.0)*30.);\n\tMat redBuildingMat = Mat(vec3(0.4, 0, 0.1), vec3(0.5, 0.3, 0.2), vec3(0.4, 0, 0.1), vec3(.2));\n\tMat blueBuildingMat = Mat(vec3(0.2, 0.3, 0.4), vec3(0.2, 0.5, 0.5), vec3(0.1, 0.2, 0.3), vec3(.1));\n\tMat greenBuildingMat = Mat(vec3(0.2, 0.6, 0.3), vec3(0.2, 0.4, 0.2), vec3(0.1, 0.6, 0.3), vec3(.1));\n\n    // Use step to check if tracer distance is less than min dist, return material if yes\n    mat = AddMatStuff(mat, step(building0, MIN_DIST), redBuildingMat);\n    mat = AddMatStuff(mat, step(building1, MIN_DIST), blueBuildingMat);\n    mat = AddMatStuff(mat, step(building2, MIN_DIST), greenBuildingMat); \n    mat = AddMatStuff(mat, step(lamps, MIN_DIST), lampMat); \n    mat = AddMatStuff(mat, step(lampLights, MIN_DIST), lightMat);     \n    mat = AddMatStuff(mat, step(sidewalks, MIN_DIST), groundMat);     \n        \n    return mat;    \n                       \n}\n\nvec3 getNormals(vec3 p){\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(map(p + eps.xyy).d - map(p - eps.xyy).d,\n                          map(p + eps.yxy).d - map(p - eps.yxy).d,\n                          map(p + eps.yyx).d - map(p - eps.yyx).d));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd){\n    float dt = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dt * rd;\n        Hit hit = map(p);\n        float dist = hit.d;\n        if(dist < MIN_DIST){\n            isHit = true;\n            break;\n        }\n        if(isHit == true || dist > MAX_DIST){\n            return vec3(0.0, 0.0, 0.2);\n            break;\n        }\n        dt += dist*0.925; // Multiplied by 0.925 to stop weird things from happening\n    }\n    return ro + dt * rd;\n}\n\nfloat GetShadows(in vec3 ro, in vec3 rd, float k){\n    float res = 1.0;\n    float d;\n    float t = 0.001;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(ro + rd * t).d;\n        if(d < MIN_DIST){\n            return 0.0;\n        }\n        res = min(res, k * d / t);\n        t += d;\n    }\n    return res;\n}\n\nvec4 getMaterial(vec3 p, vec3 rd, Light mainLight){\n    Mat mat = ChooseMaterial(p);;\n        \n\t// Need light vector, normal vector\n    vec3 l = normalize(mainLight.pos - p);\n    vec3 n = getNormals(p);\n        \n    // Shadows - figure these out at some point\n    float shadows = GetShadows(mainLight.pos, l, 20.0);\n    mainLight.diffuse += shadows;\n    \n    // Ambient\n    float ambientStr = 0.8;\n    vec3 ambient = ambientStr * mainLight.ambient;\n    \n    // Diffuse\n    float dif = max(dot(n, l), 0.0);\n    vec3 diffuse = dif * mainLight.diffuse;\n    \n    // Specular\n    vec3 viewDir = normalize(rd - p);\n    vec3 reflectDir = reflect(-l, n);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float specularStr = 6.;\n    vec3 specular = mainLight.specular * (spec * mat.specular * specularStr);\n    \n    return vec4((diffuse * mat.diffuse + ambient * mat.ambient + specular * mat.shininess) , 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Get correct uvs\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspectRatio;\n\n    // Make the camera\n    vec3 camPos = vec3(0, -.3, fract(iTime*.1)*24.);\n    //vec3 camPos = vec3(0, -.3, -4);\n    vec3 ro = camPos;\n    vec3 rd = vec3(uv, 1.0);\n    \n    vec3 p = RayMarch(ro, rd);\n    \n    \n    vec4 col = vec4(0);\n    //col = GetNormals(col);\n    if ( isHit == true){\n        // Main light I'm gonna use\n        vec3 lightPos = vec3(0, 1.5, fract(iTime*.1)*24.);\n    \tLight mainLight = Light(lightPos, vec3(.3), vec3(.9), vec3(.4));\n    \tcol = getMaterial(p, rd, mainLight);\n    }\n    else{\n        col = vec4(0.01, 0.05, 0.12, 1.0); // bg color\n    }\n    \n    //col.x = smoothstep(col.x, .4, .25);\n    //col.y = smoothstep(col.y, .5, .25);\n    //col.z = smoothstep(col.z, .4, .2);    \n    \n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3GD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3GRf", "name": "Yellow Blob", "author": "j0", "description": "A first attempt at raymarching :) There's probably a bunch of mistakes but i'm not rly expecting anyone to point them out cos my code is a huge mess woop", "tags": ["raymarching"], "likes": 4, "viewed": 89, "date": "1568999607", "time_retrieved": "2024-06-20T19:44:07.048261", "image_code": "#define MAX_STEPS 1000\n#define MAX_DISTANCE 100.\n#define MIN_DISTANCE 0.02\n\n//https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k ){\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdSphere(vec3 p, vec4 s){ return length(s.xyz-p) - s.w; }\n\nfloat Distance(vec3 p){\n    vec4 s1 = vec4(0., 1.+sin(iTime*0.564)*0.1, 0., 1.);\n    vec4 s2 = vec4(2.*sin(iTime), 1., 0., 0.4);\n    vec4 s3 = vec4(0., 1., 0.2, 1.);\n    \n    float sd = sdSphere(p, s1);\n    sd = max(-sdSphere(p, s3), sd);\n    sd = smin(sd, sdSphere(p, s2), 5.);\n    float pd = abs(p.y);\n    \n    float d = smin(sd, pd, 5.);\n    return d;\n}\n\nfloat CastRay(vec3 o, vec3 dir){\n    float d = 0.;\n    for(int i = 0; i<MAX_STEPS; ++i){\n        float dist = Distance(o+dir*d);\n        d += dist;\n        if(dist < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = Distance(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(Distance(p-e.xyy), Distance(p-e.yxy), Distance(p-e.yyx));\n    return normalize(n);\n}\n\nfloat Light(vec3 p, vec3 lightPos){\n    vec3 toLight = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n   \tfloat diffuse = dot(n, toLight);\n    \n    float distToLight = CastRay(p + n * MIN_DISTANCE * 2., n) / length(lightPos-p);\n    diffuse *= clamp(distToLight, 0., 1.);\n    \n    return clamp(diffuse, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 cameraPos = vec3(sin(iTime*0.291)*0.5, 1., 6.);\n    vec3 cameraFwd = vec3(0., 0., -1.);\n    vec3 cameraUp = vec3(0., 1., 0.);\n    vec3 cameraRight = vec3(1., 0., 0.);\n    float zoom = 1.5+sin(iTime*0.347)*0.2;\n    \n    vec3 rayOrigin = cameraPos + cameraFwd*zoom + cameraUp*uv.y + cameraRight*uv.x;\n    vec3 rayDirection = normalize(rayOrigin-cameraPos);\n    \n    float d = CastRay(rayOrigin, rayDirection);\n    vec3 point = rayOrigin + rayDirection * d;\n    \n \tvec3 lightPos = vec3(0., 0.5, 0.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 1.;\n    col += Light(point, lightPos * 1.5) * vec3(1., 0., 0.);\n    \n    lightPos = vec3(0., 3., cos(iTime*0.87))*(3.+sin(iTime*2.));\n    col += Light(point, lightPos) * vec3(1., 1., 0.);\n    \n    col += vec3(0., 0., 0.35);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3GRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3GRM", "name": "lullababy", "author": "foran", "description": "lullababy", "tags": ["lullababy"], "likes": 3, "viewed": 72, "date": "1568047760", "time_retrieved": "2024-06-20T19:44:07.054331", "image_code": "#define rep(p,r) (mod(p + r/2.,r) - r/2.)\n\nfloat sdSphere(vec3 p,float r)\n{\n  return length(p) -r;\n}\n\nmat2 rot(float a)\n{\nfloat c  = cos(a); float s = sin(a);\nreturn mat2(c,-s,s,c);\n}\n\n\n\n\nfloat map(vec3 p)\n{\n\n  p.xz *= rot(.003);\n\n  //float a = atan(p.z,p.y);\n\n  p.y += 1.5 + sin(iTime + length(p * 2.31) );\n\n  float plane = p.y + 1.;\n\n\n  float d = length(p.xy);\n\n\n\n\n  p.xy *= rot(sin(iTime *.912)+ d * .021);  \n  p.y += .5 * sin(d * 5. + iTime) * .1 +1.15;\n  p.xz = rep(p.xz, 4.);\n\n\n  float sp = sdSphere(p,1.);\n  \n\n  return min(plane,sp);\n}\n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.1,0.);\n  return(normalize(vec3(\n    map(p - e.xyy) - map(p + e.xyy),\n    map(p - e.yxy) - map(p + e.yxy),\n    map(p - e.yyx) - map(p + e.yyx)\n)));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n\n  vec3 ro = vec3(0.,0.,-15.);\n  vec3 rd = normalize(vec3(uv, 1.));\n  vec3 cp = ro;\n\n  float id = 0.;\n  for(float st = 0.; st < 1.; st += 1. / 128.)\n  {\n    float cd = map(cp);\n    if(cd < .01)\n    {\n      id = 1. - st;\n      break;\n    }\n    cp += rd * cd * .5;\n  }\n\n\n  vec3 norm = normal(cp);\n  vec3 ld = normalize(cp - vec3(1. * sin(-iTime*2.),9.,50.*cos(-iTime*2.)));\n    \n  float light = clamp(dot(norm,ld),0.,1.);\n\n  float f = id;\n  //vec4 base = vec4(.2,.14,.7,1.);\n  vec4 base=vec4(0.0, 0.0, 0.0, 1.0);\n\n  float l = light * id;\n  vec4 out_color=vec4(1.);\n  //out_color = vec4(mix(vec4(1.),base,1. / l)) ;\n  out_color=vec4(mix(vec4(0.2549, 0.8314, 0.2235, 1.0),base,1.-l));\n  fragColor=vec4(out_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3GRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts3GRN", "name": "Blobs 2", "author": "vitasa", "description": "Created a blob effect using metaballs in close proximity. Feedback always appreciated.\n\nNote: Overlay another blob using mouse position x", "tags": ["2blobs"], "likes": 2, "viewed": 118, "date": "1567992330", "time_retrieved": "2024-06-20T19:44:07.442409", "image_code": "// based on https://www.shadertoy.com/view/4lKXzd\n\nconst float numOfBalls = 10.;\t\t\t\t\t\t\t\t\t\t// number of balls\nconst float distanceTraveled = 1.5;\nconst float speed = .8;\t\t\t\t\t\t\t\t\t\t\t\t// speed of effect\nconst float rotationSpeed = .5;\n\nfloat metaballs(vec2 uv, float time) {\t\t\t\t\t\t\t\t\t\n    float size = .9;\t\t\t\t\t\t\t\t\t\t\t\t// base size\n    const float startIndex = numOfBalls;\n\tconst float endIndex = numOfBalls * 2.;\n    \n    for(float i = startIndex; i < endIndex; i++) {\t\t\t\t\t// create x number of balls\t\t\t\t\t\t\t\t\t\t\t// get rads for control point\n        float radius = distanceTraveled * sin(time + i * 2.);\t\t// calculate radius\n        vec2 ball = radius * vec2(sin(i), cos(i));\t\t\t\t\t// ball position\n\t\tsize += 1. / pow(i, distance(uv, ball));\t\t\t\t\t// metaball calculation\n    }\n    return size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rotationAngle = iTime * rotationSpeed;\n\tmat2 rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                         sin(rotationAngle),  cos(rotationAngle));\n    \n    float time = iTime * speed;\t\t\t\t\t\t\t\t\t\t// assigning time\n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * fragCoord - R) / R.y;\t\t\t\t\t\t\t// center coordinates\n\tuv *= 5.; \t\t\t\t\t\t\t\t\t\t\t\t\t\t// zoom out    \n    uv *= rotation;\n    float blob = metaballs(uv, time);\t\t\t\t\t\t\t\t// creating the blob\n    float blob2 = metaballs(uv, time + 1.);\t\t\t\t\t\t\t// offset blob\n    \n    float mouseX = iMouse.x;\n    \n    if (iMouse.x == 0.) {\n    \tmouseX = (sin(iTime * 2.) / 2. + .5) * iResolution.x; \n    }\n    \n    blob = smoothstep(1., 1. + 3./R.y, blob);\t\t\t\t\t\t// Anti Aliasing based on resolution\t\t\n    blob2 = smoothstep(1., 1. + 3./R.y, blob2);\n    \n    vec3 col = vec3(.8, .2, .2);\t\t\t\t\t\t\t\t\t// color of blob\t\t\t\t\t\n    vec3 col2 = vec3(.2, .8, .2) * mouseX / iResolution.x;\n    \n    vec3 b1 = blob * col;\t\t\t\t\t\t\t\t\t\t\t\n    vec3 b2 = blob2 * col2;\n    vec3 final = max (b1, b2);\t\t\t\t\t\t\t\t\t\t// combining the color with the effect\n    fragColor = vec4(final, 1); \t\t\t\t\t\t\t\t\t// ouput\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts3GRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsc3Rj", "name": "Mandelbulb 3D Fractal", "author": "Nazlbit", "description": "This is the visualization of the Mandelbulb 3D fractal.\n\nhttps://youtu.be/VMqlgqWFp00\nhttps://github.com/Nazlbit/mandelbulb_visualization", "tags": ["fractal", "mandelbulb"], "likes": 9, "viewed": 729, "date": "1568842184", "time_retrieved": "2024-06-20T19:44:08.048391", "image_code": "//Try to tweak this values\nconst float epsilon = 0.002;\nconst float fov = radians(35.);\nconst float mandelbulb_power = 8.;\nconst float view_radius = 10.;\nconst int mandelbulb_iter_num = 15;\nconst float camera_distance = 4.;\nconst float rotation_speed = 1./36.5;\n\nfloat mandelbulb_sdf(vec3 pos) {\n    vec2 cursor = iMouse.xy / iResolution.xy;\n    float power = 1. + (mandelbulb_power-1.)*(0.5 - cos(iTime*radians(360.)/73.)*0.5);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < mandelbulb_iter_num ; i++)\n\t{\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat scene_sdf(vec3 p)\n{\n\treturn mandelbulb_sdf(p);\n}\n\nvec3 ray_marching(const vec3 eye, const vec3 ray, out float depth, out float steps)\n{\n\tdepth = 0.;\n\tsteps = 0.;\n\tfloat dist;\n\tvec3 intersection_point;\n\n\tdo\n\t{\n\t\tintersection_point = eye + depth*ray;\n\t\tdist = scene_sdf(intersection_point);\n\t\tdepth += dist;\n\t\tsteps++;\n\t}\n\twhile(depth < view_radius && dist > epsilon);\n\n\treturn intersection_point;\n}\n\nvec3 estimate_normal(const vec3 p, const float delta)\n{\n    return normalize(vec3(\n        scene_sdf(vec3(p.x + delta, p.y, p.z)) - scene_sdf(vec3(p.x - delta, p.y, p.z)),\n        scene_sdf(vec3(p.x, p.y + delta, p.z)) - scene_sdf(vec3(p.x, p.y - delta, p.z)),\n        scene_sdf(vec3(p.x, p.y, p.z  + delta)) - scene_sdf(vec3(p.x, p.y, p.z - delta))\n    ));\n}\n\n\nvec2 transformed_coordinates(vec2 frag_coord)\n{\n\tvec2 coord = (frag_coord / iResolution.xy)*2. - 1.;\n\tcoord.y *= iResolution.y / iResolution.x;\n\treturn coord;\n}\n\nfloat contrast(float val, float contrast_offset, float contrast_mid_level)\n{\n\treturn clamp((val - contrast_mid_level) * (1. + contrast_offset) + contrast_mid_level, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = transformed_coordinates(fragCoord);\n    \n\tvec3 ray = normalize(vec3(coord*tan(fov), 1));\n\n    float angle = radians(360.)*iTime*rotation_speed;\n    \n    mat3 cam_basis = mat3(0, cos(angle), sin(angle),\n                          -1, 0, 0,\n                          0, -sin(angle), cos(angle));\n    \n\tray = cam_basis*ray;\n    \n    vec3 cam_pos = -cam_basis[2]*camera_distance;\n    \n\tfloat depth = 0.;\n\tfloat steps = 0.;\n\tvec3 intersection_point = ray_marching(cam_pos + epsilon*ray, ray, depth, steps);\n\n\t//AO\n\n\tfloat ao = steps * 0.01;\n\tao = 1. - ao / (ao + 0.5);  // reinhard\n\n\tconst float contrast_offset = 0.3;\n\tconst float contrast_mid_level = 0.5;\n\tao = contrast(ao, contrast_offset, contrast_mid_level);\n\n\tvec3 normal = estimate_normal(intersection_point, epsilon*0.5);\n\n\tvec3 fColor = ao*(normal*0.5 + 0.5);\n    \n    // Output to screen\n    fragColor = vec4(fColor,1.0);\n}", "image_inputs": [{"id": "4tsGWB", "previewfilepath": "https://soundcloud.com/sad_production/cosmic-full-ver", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sad_production/cosmic-full-ver", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsc3Rj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsc3Rl", "name": "Space Fungus", "author": "Frigo", "description": "Shader prototype of the demo that placed 3rd in the 256 byte category of Function 2019 demoparty.\nPouet link: https://www.pouet.net/prod.php?which=82934\nTwitch link: https://www.twitch.tv/videos/481421862?t=03h01m54s\n", "tags": ["fractal", "kaliset", "kali", "function", "2019", "function2019"], "likes": 3, "viewed": 294, "date": "1569079848", "time_retrieved": "2024-06-20T19:44:08.054405", "image_code": "#define iterations 20\n\nvec3 kaliset(vec3 p, vec3 u){\n    vec3 c=p;\n    for(int i=0;i<iterations;i++){\n        float len=length(p);\n        p=abs(p)/(len*len)-u;\n        c+=p;\n    }\n    return c/float(iterations);\n}\n\nvoid mainImage(out vec4 c, in vec2 xy)\n{\n    vec2 uv=vec2(xy.x/iResolution.x-0.5,-(xy.y-iResolution.y*0.5)/iResolution.x);\n    float m=iTime/60.0;\n    vec3 p=vec3(uv*iTime,0.1);\n    vec3 u=vec3(1.0,1.0,0.1)*m;\n    c.xyz=kaliset(p,u);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsc3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsc3WN", "name": "abstractTown", "author": "foran", "description": "abstractTown", "tags": ["abstracttown"], "likes": 3, "viewed": 122, "date": "1568533987", "time_retrieved": "2024-06-20T19:44:08.054405", "image_code": "#define time iTime*.51\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\nreturn max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*457.332)*584.321);\n\n}\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(floor(g), floor(g+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nfloat at=0.;\nfloat map(vec3 p) {\n  //vec3 bp=p;\n  float t3=time*0.2;\n  p.xz *= rot(sin(p.y * 0.02 + t3)*1.1);\n  p.xy *= rot(sin(p.z * 0.04 + t3)*.1);\n  vec3 bp=p;\n  float dist = 150.;\n  p = (fract(p/dist-0.5)-0.5)*dist;\n  for(float i=0.; i<5.; ++i) {\n    float t = curve(time, 550.8+0.05*i);\n    p.xy *= rot(t*0.3);\n    p.xz *= rot(t*0.2+i);\n    p=abs(p);\n    p-= 5.;\n    p.z-=2.;//    \n  }\n  float d = box(p, vec3(.51,10,5.2));//     x y z\n  d = min(d, length(p.zy)-0.2);\n  vec3 bp2 = bp;\n  bp2 = (fract(bp2/20.-0.5)-0.5)*50.;//     20.\n  float k = box(bp2, vec3(10.,0.2,0.2));\n  k = min(k, box(bp2, vec3(0.2,10,0.2)));\n  k = min(k, box(bp2, vec3(0.2,0.2,10)));\n  at += 0.2/(0.2+k);\n  d = min(d, k);\n  d = max(d, -(length(bp)-30.));//   \n  d *= 0.97;//   .7\n  return d;\n}\n\nvoid cam(inout vec3 p) {\n\n  float t = time + curve(time, 11.5)*0.9 + curve(time, 14.7)*2.9;//      1.5 4.7\n  p.yz *= rot(t*0.2);// .2\n  p.xz *= rot(t*0.5);// .5\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1.);\n  vec3 s=vec3(0.,0.,-110.);\n  vec3 r=normalize(vec3(-uv,1.));\n  cam(s);\n  cam(r);\n  float maxdist = 1000.;// .200\n  vec3 p=s;\nfloat i=0.;\n  float dd=0.;\n  for(i=0.; i<128.; ++i) {// \n    float d=map(p);\n    if(d<0.001) {//  epsilon\n      i+=d/0.001;\n      break;\n    }\n    if(dd>maxdist) { dd=maxdist; break; }\n    p+=d*r;\n    dd+=d;\n  }\n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  vec3 col=vec3(0.);\n  vec3 l = normalize(-vec3(1.,3.,2.));\n  float fog = 1.-clamp(dd/maxdist,0.,1.);\n  vec3 sky = mix(vec3(0.5,0.3,2.2), vec3(2.5,0.3,0.2), pow(abs(r.y),2.));\n  float ao= clamp(map(p+n),0.,1.) * clamp(map(p+n*4.)/4.,0.,1.);\n  col += max(dot(n,l),0.);\n  col += pow(1.-abs(dot(n,r)), 5.) * sky * 2.;\n  col *= fog * ao;\n  col += pow(at * 0.04,0.5) * vec3(2.,1.1,0.5);\n  col += sky * pow((1.-fog)*1.2, 3.);\n  float tt=time*0.93 - dd*0.02;//    .3  .01\n  col.xy *= rot(tt);\n  col.yz *= rot(tt*5.3);\n  col=abs(col);\n  col *= .89;\n  col *= 1.32-length(uv);\n  vec4 out_color=vec4(1.);\n  out_color = vec4(col, 1.);\n  fragColor=vec4(out_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsc3WN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsc3zM", "name": "That cat", "author": "zxxuan1001", "description": "Been following along iq's live coding stream. ", "tags": ["animation", "cat"], "likes": 17, "viewed": 465, "date": "1568272670", "time_retrieved": "2024-06-20T19:44:08.054405", "image_code": "//#define TIME mod(iTime,10000.0)\n#define PI 3.1416\n#define TERRAIN_PATTERN 4.0*sin(12.0*pos.x)+sin(20.0*pos.y)+sin(15.0*pos.z)\n#define SPEED aTime*0.3\n#define MAX_DIST 20.0\n#define MAX_STEP 80\n#define SUN_DIRECTION vec3(0.8,0.3,0.9)\n#define SUNLIGHT_INTENSITY vec3(6.0,5.5,4.0)\n#define SUNSET_COLOR vec3(0.7,0.2,0.1)\n#define SKY_COLOR vec3(0.25, 0.35, 0.6)\n#define TERRAIN_COLOR vec3(0.07,0.04,0.03)\n#define RIM_COLOR vec3(0.85,0.1,0.1)\n#define RIM_POWER 0.15\n#define AA_SIZE 1\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 0.013);\n    p3 += dot(p3, p3.yzx + 19.31);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k4*u.x*u.y;\n}\n\nfloat sdSphere(in vec3 pos, in float r)\n{\n    return length(pos)-r;\n}\n\n//http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\nfloat sdElipsoid(in vec3 pos, in vec3 r)\n{\n    float k0 = length(pos/r);\n    float k1 = length(pos/r/r);\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float r = mix(r1, r2, h);\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return max(a,b) + h*h*0.25/k;\n}\n\nvec4 sdUnion(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x)? d1:d2;\n}\n\nvec4 map(in vec3 pos, float aTime)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    float t = fract(aTime);\n    float y = 3.0*t*(1.0-t); \n    vec3 cen = vec3(0.0,0.25+0.01*y,SPEED);\n    float sy = 0.8 + 0.2*y;\n    float sz = 1.0/sy;\n    vec3 r = vec3(0.35,0.32+0.02*sy,0.25+0.05*sz);\n    vec3 q = pos-cen;\n    vec3 h = q;\n    \n    //body\n    float d = sdElipsoid(q-vec3(0.0, 0.03, -0.09), r);\n    \n  \n    {\n    \n    //head\n    float hr = sin(aTime);\n    hr = 0.5*sign(hr)*smoothstep(0.5,1.0,abs(hr));\n    h.xz = mat2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    \n    float d1 = sdElipsoid(h - vec3(0.0, 0.32, 0.01), vec3(0.28, 0.2, 0.18));\n    float d2 = sdElipsoid(h - vec3(0.0, 0.30, -0.07), vec3(0.2));\n    d2 = smin(d1, d2, 0.08);\n    d = smin(d, d2, 0.08);\n    \n    \n    vec3 sh = vec3(abs(h.x), h.yz);//symmetric along x\n    \n    //legs\n    vec3 shh = vec3(abs(h.x), h.y, abs(h.z+0.1));//symmetric along x and z\n    //animation settings\n    float t1 = fract(aTime+4.71*sign(h.x));\n    float y1 = 3.0*t1*(1.0-t1); \n    float offset = y1;\n    \n    d1 = sdStick(shh - vec3(0.11,-0.24,0.22), vec3(0.0,0.18,-0.1), vec3(0.0,-0.1,-0.15*offset), 0.08, 0.05); \n    d = smin(d, d1, 0.04);\n        \n    //nose\n    d1 = sdStick(h, vec3(0.0,0.41,0.12), vec3(0.0,0.37,0.18), 0.05, 0.03);\n    d = smin(d,d1,0.01);\n    \n    //ears\n    d2 = sdElipsoid(sh - vec3(0.15, 0.47, -0.05), vec3(0.06, 0.09, 0.04));\n    d = smin(d, d2, 0.08);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    //tail\n    d2 = sdStick(h, vec3(0.0,-0.3,-0.1), vec3(-0.1*y,0.2,-0.55), 0.03, 0.05);\n    d = smin(d, d2, 0.06);\n    res = vec4(d,2.0,0.0,0.0);\n    \n    \n    //eyelids\n    vec3 elPos = sh - vec3(0.04,0.33,0.09);\n    d2 = sdStick(elPos, vec3(0.0,0.12,0.02), vec3(0.05,0.1,-0.02), 0.02, 0.02);\n   \td = smin(d, d2, 0.03);\n    res = vec4(d,2.0,0.0,0.0);\n    \n     \n    //eyes\n    float d5 = sdSphere(sh - vec3(0.065,0.4,0.108), 0.07);\n    res = sdUnion(res, vec4(d5,3.0,0.0,0.0));\n    \n    float eyeOffsetY = 0.01*smoothstep(0.0, 0.8,sin(aTime));\n    \n    d5 = sdSphere(sh - vec3(0.066,0.40+eyeOffsetY,0.124), 0.056);\n    res = sdUnion(res, vec4(d5,4.0,0.0,0.0));\n         \n    //mouth\n    float d6 = sdElipsoid(h - vec3(0.0,0.29,0.16), vec3(0.06,0.03,0.04));\n    float d7 = sdElipsoid(sh - vec3(0.035,0.32,0.175), vec3(0.055,0.036,0.04));\n    d6 = smin(d6,d7,0.01);\n    res = sdUnion(res, vec4(d6,6.0,0.0,0.0));\n    \n    //terrain\n    float fh = -0.1+0.05*(sin(2.2*pos.x) + sin(1.5*pos.z));\n    d1 = pos.y - fh;\n    d1 -= .01*noise(vec2(pos.x*10.0,pos.z*10.0));\n    if (d1<res.x) res = vec4(d1,1.0,0.0,0.0);\n    \n    //watermelon\n    float b = 5.0;\n    vec3 rep = vec3(mod(abs(pos.x),b)-3.5, pos.y, mod(abs(pos.z+1.5), b)-2.5);\n    vec2 id = vec2(floor(abs(pos.x)/b),floor((pos.z+1.5)/b));\n    float fid = id.x*13.3 + id.y*31.7;\n    float wr = 1.4+0.5*sin(fid*1.312);\n    \n    d2 = sdSphere(rep, wr);\n    if (d2<res.x) res = vec4(d2,8.0,0.0,0.0);\n \n    }\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float aTime)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, aTime ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos, in float aTime)\n{\n    vec2 e = vec2(0.001,0.0);\n    return normalize( vec3(map(pos + e.xyy,aTime).x - map(pos - e.xyy,aTime).x,\n                          map(pos + e.yxy,aTime).x - map(pos - e.yxy,aTime).x,\n                          map(pos + e.yyx,aTime).x - map(pos - e.yyx,aTime).x) );\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd, in float aTime)\n{\n    float res = 1.0;\n    float t = 0.01;\n    float tMax = MAX_DIST;\n\n    for (int i=0; i<MAX_STEP;++i)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos,aTime).x;\n        res = min( res, 18.0*h/t );\n        if (res<0.001) break;\n        t += h;\n        if (t>tMax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd, in float aTime)\n{\n   float t = 0.01;\n   vec3 m = vec3(0.0);\n   float tMax = MAX_DIST;\n   /*\n   float hMax = 2.5;\n   float bt = (hMax-ro.y)/rd.y;\n   if ( bt>0.0 ) tMax = min(tMax, bt);\n   */\n   \n   for ( int i = 0; i < MAX_STEP; ++i )\n   {\n       vec3 pos = ro + t*rd;\n       vec4 h = map( pos,aTime );\n       m = h.yzw;\n       if ( abs(h.x)<(0.001*t) )\n       {\n           break;\n       }\n       t += h.x;\n       if ( t>tMax ) break;\n   } \n    \n   if ( t>tMax )\n   {\n       m = vec3(-1.0);\n   }\n   return vec4(t,m);\n}\n\nvec3 render(in vec2 fragCoord, in float aTime)\n{\n    vec2 p = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float angle = 10.0*iMouse.x/iResolution.x+1.0;\n    \n    vec3 ta = vec3(0.0,0.45,0.8+SPEED);\n    vec3 ro = ta+vec3( 1.0*cos(angle), mouse.y, 1.0*sin(angle) );;\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross( ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0*ww);\n    vec3 sunDir = SUN_DIRECTION;//normalize( vec3(0.8,0.4,0.9) );\n    \n    vec3 col = SKY_COLOR - 0.8*rd.y;\n    \n    vec2 uv = rd.xz/rd.y; //sky dome( intersect the top )\n    float sinV = 1.0*(sin(1.0*uv.x )+sin(1.0*uv.y))\n        \t\t+ 0.5*(sin(2.0*uv.x+aTime)+sin(2.0*uv.y+aTime));\n    col = mix( col, vec3(0.9,0.85,0.6),smoothstep(-0.3,0.3,-0.5+sinV) );\n    col = mix(col, SUNSET_COLOR, exp(-4.0*rd.y));\n   \n    vec4 tm = castRay(ro, rd, aTime);\n    if ( tm.y>-1.0 )\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, aTime);\n        vec3 mate = vec3(0.18);\n        if (tm.y==8.0)\n        {\n            //watermelon\n            mate = vec3(0.03,0.1,0.07);\n            float f = 1.0-smoothstep(-0.2, 0.2, TERRAIN_PATTERN);\n            mate = mix(mate, vec3(0.0,0.05,0.03), f);\n        } \n        else if (tm.y==7.0)\n        {\n            mate = vec3(0.8,0.2,0.0);\n        }\n        else if (tm.y==6.0)\n        {\n            mate = vec3(0.2,0.2,0.2); //mouth\n        }\n        else if (tm.y==5.0)\n        {\n            mate = vec3(0.25)*pos.y; //tail\n        } \n        else if (tm.y==4.0)\n        {\n        \tmate = vec3(0.01, 0.01, 0.015); //eyes \n        }\n        else if (tm.y==3.0)\n        {\n            mate = vec3(0.5, 0.5, 0.5); //eyes\n        }\n        else if (tm.y==2.0)\n        {\n            mate = vec3(0.01,0.01,0.02);//body\n        } else\n        {\n            mate = TERRAIN_COLOR;//terrain\n        }\n        \n        float occ = calcOcclusion( pos, nor, aTime );\n        float fresnel = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float sunDiff = clamp( dot(nor, sunDir),0.0,1.0 );\n        float sunShadow = castShadow(pos+nor*0.01, sunDir, aTime);//step( castRay(pos+nor*0.001, sunDir).y,0.0 );\n        float skyDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,1.0,0.0)),0.0,1.0 );\n        //Simulate how lights bounce off from the ground to the object surface.\n        float bounceDiff = clamp( 0.5 + 0.5*dot(nor, vec3(0.0,-1.0,0.0)),0.0,1.0 );\n        col = mate*SUNLIGHT_INTENSITY*sunDiff*sunShadow;\n        col += mate*SKY_COLOR*skyDiff;\n        col += mate*SUNSET_COLOR*bounceDiff;\n        col *= occ;\n        col += RIM_POWER*RIM_COLOR*fresnel;\n        \n        if (tm.y==4.0 || tm.y==8.0)\n        {\n            vec3 viewDir = normalize(ro-pos);\n            vec3 reflectDir = normalize(reflect(-sunDir, nor));\n            float spec = pow(max(dot(reflectDir, viewDir), 0.0), 64.0);\n            vec3 speCol = vec3(1.0) * spec;\n            col += speCol;\n        }\n        \n        // fog\n        col = mix( col, SUNSET_COLOR, 1.0-exp( -0.005*t*t ) );\n    } \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    vec2 off = vec2(0.0);\n    \n#if AA_SIZE>1\n    //anti aliasing & motion blur\n    for (float aaY = 0.0; aaY < float(AA_SIZE); ++aaY)\n    {\n        for (float aaX = 0.0; aaX < float(AA_SIZE); ++aaX)\n        {\n            off = -0.5+vec2(aaY,aaX)/float(AA_SIZE);\n            \n            float md = texelFetch(iChannel0, ivec2(fragCoord)&255, 0).x;\n            float mb = (aaY*float(AA_SIZE)+aaX)/(float(AA_SIZE*AA_SIZE-1));\n            mb += (md-0.5)/float(AA_SIZE*AA_SIZE);\n            float aTime = iTime - mb*0.5*(1.0/24.0); //1 frame in 24fps for film\n#else\n            float aTime = iTime;\n#endif\n            \n            col += render(fragCoord+off, aTime);\n            \n#if AA_SIZE>1\n        }\n    }\n    col /= float(AA_SIZE*AA_SIZE);\n#endif\n    \n    //gamma\n    col = pow( col, vec3(0.4546));\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsc3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscGRl", "name": "Unfalling Hearts - Voulitsa", "author": "Jercieblue", "description": "Gia tin voulitsa pou einai arostoula!", "tags": ["hearts"], "likes": 4, "viewed": 149, "date": "1569079584", "time_retrieved": "2024-06-20T19:44:08.060628", "image_code": "const vec3 colors[5] = vec3[5](\n    vec3(0.969, 0.706, 0.831),\n    vec3(0.933, 0.522, 0.714),\n    vec3(0.886, 0.373, 0.616),\n    vec3(0.839, 0.251, 0.529),\n    vec3(0.765, 0.122, 0.424)\n);\n\nfloat seed = 3265.0;\n\nfloat N31(vec3 v) {\n    return fract(sin(v.x * 345.74 + v.y * 798.54 + v.z* 175.87) * seed);\n}\n\nfloat N21(vec2 v) {\n    return fract(sin(v.x * 345.74 + v.y * 798.54 ) * seed);\n}\n\nvec2 N22(vec3 v) {\n    float x = N31(v);\n    float y = N31(v * x);\n    return vec2(x, y);\n}\n\nvec3 N33(vec3 v) {\n    float x = N31(v);\n    float y = N31(v * x);\n    float z = N31(v * y);\n    return vec3(x, y, z);\n}\n\nfloat Noise2(vec2 v) {\n    vec2 lv = fract(v);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    vec2 id = floor(v);\n    float c = \n        mix(\n            mix(N21(id + vec2(0,0)), N21(id + vec2(1,0)), lv.x),\n            mix(N21(id + vec2(0,1)), N21(id + vec2(1,1)), lv.x), \n        lv.y);\n    return c;\n}\n\n\nfloat SmoothNoise2(vec2 v){\n    float n = 0.0;\n    float o = 1.0;\n    float av = 0.0;    \n    for (float i = 1.0; i < 4.0; i += 1.0) {\n        n += Noise2(v * o) / pow(2.0, i);\n        o *= 2.0;\n        av += 1.0 / pow(2.0, i);\n    }\n    return n / av;\n}\n\nfloat Noise3(vec3 v) {\n    vec3 lv = fract(v);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    vec3 id = floor(v);\n\n    float c = mix(\n        mix(\n            mix(N31(id + vec3(0,0,0)), N31(id + vec3(1,0,0)), lv.x),\n            mix(N31(id + vec3(0,1,0)), N31(id + vec3(1,1,0)), lv.x), lv.y),\n        mix(\n            mix(N31(id + vec3(0,0,1)), N31(id + vec3(1,0,1)), lv.x),\n            mix(N31(id + vec3(0,1,1)), N31(id + vec3(1,1,1)), lv.x), lv.y), lv.z);\n\n    return c;\n}\n\nfloat SmoothNoise3(vec3 v){\n    float n = 0.0;\n    float o = 1.0;\n    float av = 0.0;    \n    for (float i = 1.0; i < 64.0; i += 1.0) {\n        n += Noise3(v * o) / pow(2.0, i);\n        o *= 2.0;\n        av += 1.0 / pow(2.0, i);\n    }\n    return n / av;\n}\n\nfloat smax(float a, float b, float k){\n    float h = clamp((b-a) / k + 0.5, 0.0, 1.0);\n    return mix(a,b,h) + h * (1.0 - h) * k * 0.5;\n}\n\nfloat HeartDist(vec2 uv, vec2 o, float r, float bias){\n    vec2 s = vec2(0.7, 1.0) / r;\n    uv = o + uv * s;\n   \tfloat b = r * bias;\n    uv.y -= smax(sqrt(abs(uv.x))*0.5,b,0.1);\n    //uv.y -= sqrt(abs(uv.x))*0.5;\n    uv.y += b;\n    float d = length(uv);\n    return smoothstep(r + b, r - b, d);\n}\n\nvec4 DrawHeart(vec2 uv, float r, float bias){\n    vec3 c = vec3(0.0);\n    float d = HeartDist(uv, vec2(0,0.1), r, bias);\n    float alpha = d;\n    c += mix(colors[4], colors[2], pow(d,1.0));\n    \n    return vec4(c, step(0.1,alpha));\n}\n\nvoid DrawHearts(in vec2 uv, inout vec3 color) {\n    uv /= 128.0;\n    vec4 c = vec4(0.0);\n    float layers = 12.0;\n    float layer_time = 16.0;\n    float layer_spawn = layer_time / layers;\n    float time = -iTime*2.0;\n    for (float i = layers - 1.0; i >= 0.0; i--) {\n        float lt = mod(time, layer_time) + i * layer_time;\n        vec2 luv = fract(uv * lt*4.0) - 0.5;\n        vec2 id = floor(uv * lt*4.0)-0.5;\n        float tt = floor(time / (layer_time)) - i;\n        float fade_time = \n            smoothstep(0.0,0.1, lt / (layers * layer_time))*\n            smoothstep(1.0,0.5, lt / (layers * layer_time));\n        if (N31(vec3(id, floor(tt))) > 0.9){\n            vec4 sc = DrawHeart(luv, 0.2, 0.2);\n\t\t\tc = mix(c, sc, sc.a * fade_time);\n        }\n        \n    }\n    color = mix(color, c.rgb,c.a);\n}\n\nvec3 DrawHeartLight(vec2 uv, float r, float bias, float time, vec2 id){\n    float i = time*(sin((N21(id) + iTime)*2.0)*0.5+0.5);\n    float to_center = length(uv);\n    float atten = 1.0 / (1.0 + to_center*to_center*to_center*500.0)*0.25;\n    return vec3(1.0) * atten*i;\n}\n\nvoid DrawLights(in vec2 uv, inout vec3 color) {\n    uv /= 128.0;\n    vec3 c = vec3(0.0);\n    float layers = 12.0;\n    float layer_time = 16.0;\n    float layer_spawn = layer_time / layers;\n    float time = -iTime*2.0;\n    for (float i = layers - 1.0; i >= 0.0; i--) {\n        float lt = mod(time, layer_time) + i * layer_time;\n        vec2 luv = fract(uv * lt*4.0) - 0.5;\n        vec2 id = floor(uv * lt*4.0)-0.5;\n        float tt = floor(time / (layer_time)) - i;\n        float fade_time = \n            smoothstep(0.0,0.1, lt / (layers * layer_time))*\n            smoothstep(1.0,0.5, lt / (layers * layer_time));\n        if (N31(vec3(id, floor(tt))) > 0.9){\n            vec3 sc = DrawHeartLight(luv, 0.2, 0.2,fade_time, id)*fade_time;\n\t\t\tc += sc;\n        }\n        \n    }\n    color += c;\n}\n\n\n\n\nvoid DrawClouds(vec2 uv, inout vec3 color) {\n    float time = iTime*0.5;\n    \n    float c = SmoothNoise3(vec3(uv*8.0, time*0.5));\n    \n    vec3 cloud_color =pow(mix(colors[1],colors[4],c),vec3(2.0));\n    color += cloud_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.xy * 2.0 / aspect;\n    \n    vec3 c = vec3(0.0);\n    \n    float big_heart_mask = clamp(HeartDist(uv/16.0, vec2(0.0,0.05),0.20, 0.4), 0.0, 1.0);\n    DrawClouds(uv,c);\n    c = (c - vec3(big_heart_mask*0.5)) ;\n    DrawLights(uv,c);\n    DrawHearts(uv,c);\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscGRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscGRX", "name": "Elevated coast modernized", "author": "TimoKinnunen", "description": "A shader from 2015 with some very cheap improvements included.", "tags": ["3d", "noise", "terrain", "normals", "fog"], "likes": 13, "viewed": 432, "date": "1568946268", "time_retrieved": "2024-06-20T19:44:09.509175", "image_code": "// Modernized version of Elevated coast @ https://www.shadertoy.com/view/4l23Rh\n// Changes:\n//\n// - addition of distance fog\n// - reduced normal shimmering by taking into account pixel footprint\n// - simple mouse controls\n// - increase of terrain noise levels\n// - sky reacts to mouse movement (how did I miss this one..?)\n//\n// Original shader with changes incorporated follows:\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n\nfloat dh;\n\n                                 \nconst mat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nconst mat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(noise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn .3*a+.5;\n}\n\nfloat swissTurbulence(vec2 p )//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n     \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float warp = 0.15;\n    float sum = 0.;\n     float freq = 1.0, amp = 1.0;\n     vec2 dsum = vec2(0.);\n     for(int i=0; i < 7; i++)\n     {\n         vec3 n = noised((p + warp * dsum)*freq);\n         sum += amp * (1. - abs(n.x));\n         dsum += amp * n.yz * -n.x;\n         freq *= lacunarity;\n         amp *= gain * clamp(sum,0.,1.);\n    }\n    return sum/3.;\n}\n\nfloat jordanTurbulence(vec2 p)//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n    \n    \n    float lacunarity = 2.0;\n    float gain1 = 0.8;\n    float gain = 0.5;\n    float warp0 = 0.4;\n    float warp = 0.35;\n    float damp0 = 1.0;\n    float damp = 0.8;\n    float damp_scale = 1.0;\n    vec3 n = noised(p);\n    vec3 n2 = n * n.x;\n    float sum = n2.x;\n    vec2 dsum_warp = warp0*n2.yz;\n    vec2 dsum_damp = damp0*n2.yz;\n\n    float amp = gain1;\n    float freq = lacunarity;\n    float damped_amp = amp * gain;\n\n    for(int i=1; i < 8; i++)\n    {\n        n = noised(p * freq + dsum_warp.xy);\n        n2 = n * n.x;\n        sum += damped_amp * n2.x;\n        dsum_warp += warp * n2.yz;\n        dsum_damp += damp * n2.yz;\n        freq *= lacunarity;\n        amp *= gain;\n        damped_amp = amp * (1.-damp_scale/(1.+dot(dsum_damp,dsum_damp)));\n    }\n    return sum/2.+.5;\n}\n\nfloat rocks(vec2 p){\n   //return jordanTurbulence(p );\n   // return swissTurbulence(p );\n   return terrainIq(p);\n   //return fbmabs(p)*.5+.5;   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p,float px)\n{\n\t//const vec2 e = vec2(0.004, 0.0);\n    vec2 e = vec2(px, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        2.0*e.x,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p,float px)\n{\n\t//const vec2 e = vec2(0.002, 0.0);\n    vec2 e = vec2(px, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        2.0*e.x,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\t//return sin(vec3(1.7,1.5,1.)+1.8- .9*fbmabs(p*4.-.02*time))+.2;\n    return sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*time))+.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 35.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n   \tvec3 sd = rd;\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    if(iMouse.y>iResolution.y*0.125) {\n        ro.xy += 2.0 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n        sd = normalize(vec3(p + 0.125 * (2.0 * iMouse.xy - iResolution.xy) / iResolution.y, -2.));\n    }\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n\tsd = transform(sd);\n    \n    //sky\n    col = sky(sd.xz*(.1+sd.y));\n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        //if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n    vec3 p1 = t * normalize(vec3(p+1./iResolution.y,-2.));\n    vec3 p2 = t * normalize(vec3(p-1./iResolution.y,-2.));\n    float px = distance(p1,p2);\n        \n        float k=rocks(pos.xz)*2.;\n        \n        vec3 nor = normalRocks(pos.xz,px);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.02)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.02){\n        \tvec3 nor = normalSea(pos.xz,px);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,.2,.05)*dh*.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.xz/(.5+nor.y));\n            \n        }\n\t    col = mix(.1+col1,col,clamp(exp2(smoothstep(0.,35.,t))-1.,0.,1.));\n        \n\t}\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscGRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tscGzH", "name": "#Maze", "author": "bkpjjj", "description": "Maze", "tags": ["maze"], "likes": 3, "viewed": 180, "date": "1567764136", "time_retrieved": "2024-06-20T19:44:09.691019", "image_code": "float hash(vec2 uv){\n    \n return fract(sin(uv.x * 168. + uv.y * 124.)*151.);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.t;\n    uv.x += iTime*0.01;\n    uv *= 20.;\n    uv.xy *= sin(iTime * 0.5)*0.5+1.5;\n    uv.xy *= mat2(cos(iTime*0.2),-sin(iTime*0.2),sin(iTime*0.2),cos(iTime*0.2));\n    vec2 fuv = fract(uv)-0.5;\n    vec2 guv = floor(uv);\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    float nuv = fuv.x + fuv.y;\n    if(hash(guv) > 0.5) nuv = fuv.x - fuv.y;\n\tcol.xyz = vec3(1.-step(0.1,abs(nuv)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tscGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsd3Wj", "name": "Ray Tracing Spheres", "author": "StarikTenger", "description": "Use mouse to move camera", "tags": ["raytracing", "ray", "sphere"], "likes": 6, "viewed": 174, "date": "1569358280", "time_retrieved": "2024-06-20T19:44:10.654592", "image_code": "#define PI 3.141693\n\nstruct Cam {\n  \tvec3 pos;\n\tvec2 dir;\n};\n\nstruct Sphere {\n\tvec3 pos;\n    vec3 col;\n    \n    float r;\n    float mirrorK;\n    bool chess;\n};\n    \nstruct Light{\n\tvec3 pos;\n    vec3 col;\n};\n    \nstruct System {\n    Cam cam;\n\tSphere spheres[10];\n    Light lights[5];\n};\n    \nstruct Data {\n\tvec3 pos;\n    vec3 dir;\n};\n\nfloat multiply(vec3 a, vec3 b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nvec2 rotate(vec2 v, float a){\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\nvec3 rotate(vec3 v, vec2 ang){\n    \n    vec2 p = rotate(vec2(v.x, v.z), ang.y);\n\tv = vec3(p.x, v.y, p.y);\n    \n    v = vec3(rotate(vec2(v.x, v.y), ang.x), v.z);\n\n    return v;\n}\n\nbool chess(vec3 pos){\n    float k = 10.;\n\treturn (sign(sin(pos.x*k)) == sign(sin(pos.y*k)));\n}\n\nbool sphereCollision(vec3 pos, vec3 dir, Sphere sp){\n\tvec3 d = dir / length(dir);\n    vec3 p = sp.pos - pos;\n    \n   \tfloat k1 = multiply(d, d);\n    float k2 = -2.0 * multiply(d, p);\n    float k3 = multiply(p, p) - sp.r*sp.r;\n    \n    float t1 = ( -k2 + sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    float t2 = ( -k2 - sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    \n    vec3 c1 = d * t1 + pos;\n    vec3 c2 = d * t2 + pos;\n    \n    if(k2 * k2 - 4.0 * k1 * k3 > 0.0 && (t1 > 0. || t2 > 0.) ){\n    \treturn true;   \n    }\n    return false;\n    //return mat2x3(c1, c2);\n}\n\nvec3 sphereCollisionC(vec3 pos, vec3 dir, Sphere sp){\n\tvec3 d = dir / length(dir);\n    vec3 p = sp.pos - pos;\n    \n   \tfloat k1 = multiply(d, d);\n    float k2 = -2.0 * multiply(d, p);\n    float k3 = multiply(p, p) - sp.r*sp.r;\n    \n    float t1 = ( -k2 + sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    float t2 = ( -k2 - sqrt(k2 * k2 - 4.0 * k1 * k3 )) / (2.0 * k1);\n    \n    vec3 c1 = d * t1 + pos;\n    vec3 c2 = d * t2 + pos;\n    \n    if(k2 * k2 - 4.0 * k1 * k3 > 0.0 || k2 * k2 - 4.0 * k1 * k3 > 0.0){\n    \t//return true;   \n    }\n    \n    if(t1 < t2)\n    \treturn c1;\n    else\n        return c2;\n}\nvec3 rayTrace(System sys, vec3 pos, vec3 dir){\n    vec3 colF = vec3(0, 0, 0);\n    float refK = 1.0;\n    for(int k=0; k<5; k++) {\n        dir = dir / length(dir);\n        vec3 nearestCollision = vec3(100000000., 0., 0.);\n        int nearestI = -1;\n        // Finding nearest sphere collision\n        for(int i=0; i<sys.spheres.length(); i++){\n            if(sphereCollision(pos, dir, sys.spheres[i])){\n                vec3 collision = sphereCollisionC(pos, dir, sys.spheres[i]);\n                if(distance(pos, collision) < distance(pos, nearestCollision)){\n                    nearestCollision = collision;\n                    nearestI = i;\n                }\n            }            \n        }\n        if(nearestI == -1) // Return if no collision detected\n            break;\n\n        // Continue from collision point\n        vec3 v = nearestCollision;\n        vec3 col = sys.spheres[nearestI].col * 0.05;\n        vec3 n = (v - sys.spheres[nearestI].pos ) / length(v - sys.spheres[nearestI].pos); // surface normal vector\n\n        // Calculating Lights\n        for(int i = 0; i<sys.lights.length(); i++){\n\n            vec3 d = (sys.lights[i].pos - v) / length(v - sys.lights[i].pos ); // direction to Light\n            bool spColl = false;\n            \n            for(int j=0; j<sys.spheres.length(); j++){\n                if (j == nearestI)\n                    continue;\n                if(sphereCollision(v + d*0.01, d, sys.spheres[j]) && \n                   distance(sphereCollisionC(v + d*0.01, d, sys.spheres[j]), v) < distance(sys.lights[i].pos, v))\n                    spColl = true;\n            }\n      \n            if(!spColl && (!sys.spheres[nearestI].chess || chess(v)))\n                col += max( multiply(n, d) * sys.lights[i].col * sys.spheres[nearestI].col, vec3(0., 0., 0.)) / pow(distance(sys.lights[i].pos, v), 2.0);\n        }\n        vec3 ray = (pos - v) / length(pos- v);\n        vec3 ref = 2.0 * n * multiply(n, ray) - ray;\n    \tcolF +=  col*refK;\n        pos = v+n*0.01;\n        dir = ref;\n        refK *= sys.spheres[nearestI].mirrorK;\n    }\n        \n    //col += rayTrace1(sys, v+n*0.01, ref) * sys.spheres[nearestI].mirrorK;\n    return colF;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    System sys;\n    \n    //// Camera\n    sys.cam.dir = vec2(2.*PI*(iMouse.x/iResolution.x - 0.5), PI/2.0*(iMouse.y/iResolution.y - 1.0));\n    sys.cam.pos = vec3(0,0,0.1) -  rotate(vec3(2.3, 0, 0), sys.cam.dir);\n    \n    //// Objects  \n    // Spheres\n    sys.spheres[0] = Sphere(vec3(0, 0, -1000.1), vec3(1., 1., 1.)*1., 1000., 0.1, true);\n    sys.spheres[5] = Sphere(vec3(0, 0, 1001.1), vec3(1., 1., 1.)*1., 1000., 0.0, false);\n    sys.spheres[1] = Sphere(vec3(0,0,0), vec3(1.0, 0.0, 0.0)*1.0, 0.20, 0.5, false);\n    sys.spheres[2] = Sphere(vec3(0,0,0), vec3(0.0, 1.0, 0.0)*1.0, 0.10, 0.5, false);\n    sys.spheres[3] = Sphere(vec3(0,0,0), vec3(0.0, 0.0, 1.0)*1.0, 0.15, 0.5, false);\n    sys.spheres[4] = Sphere(vec3(0,0,0), vec3(1.0, 1.0, 0.0)*1.0, 0.05, 0.5, false);\n    // Lights\n    sys.lights[0] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 0.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n    sys.lights[1] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 2.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n    sys.lights[2] = Light(rotate(vec3(0.8, 0.0, 1.0), vec2(iTime*0.11 + 4.0 * PI/3.0, 0)),  0.2*vec3(1.0, 1.0, 1.0));\n        \n    \n    sys.spheres[1].pos = vec3(0.3, 0.0, 0.2) + vec3(0, sin(iTime)*0.06, 0) ;\n    sys.spheres[2].pos = vec3(0.0, 0.3, 0.1)+ vec3(0, 0, sin(iTime*0.7)*0.1) ; ;\n    sys.spheres[3].pos = vec3(-0.3, 0.0, 0.1) + vec3(cos(iTime*0.85)*0.03, 0, 0) ;;\n    sys.spheres[4].pos = vec3(0.0, -0.4, 0.2) + vec3(0, 0, -sin(iTime*1.1)*0.1) ;;\n\n    \n    //// Rendering\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);    \n\n    // Time varying pixel color\n    //vec3 n = sys.cam.dir;\n    \n    \n    vec3 col = rayTrace(sys, sys.cam.pos, rotate(vec3(1.4, uv.x, uv.y * iResolution.y / iResolution.x), sys.cam.dir));\n\t    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsd3Wj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsd3WS", "name": "Case Study : Glow Glitter effect", "author": "MonsieurSoleil", "description": "Thx Nusan for the tips :\nUsing intersection from two kifs helped making the effect I Desired.\nI needed this matter/glowing.", "tags": ["glow", "kifs"], "likes": 3, "viewed": 154, "date": "1569252773", "time_retrieved": "2024-06-20T19:44:11.642727", "image_code": "/*\n\t\tDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                   Version 2, December 2004\n\nCopyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n\n           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n 0. You just DO WHAT THE FUCK YOU WANT TO.\n*/\n\n#define NUM_LOOP 100\n#define MAT_LIMIT 0.01\n#define PI 3.14159265\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p)-s;\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec2 kifs(vec2 p, float t, vec2 s, int iter, vec2 prog)   \n{\n    for(int i = 0; i < iter; ++i)\n    {\n     \tp.xy *= rot(t);\n        p.xy = abs(p.xy) - s;\n\t\ts *= prog;\n    }\n    \n    return p;\n}\n\nvec3 rep(vec3 p, vec3 r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nvec2 rep(vec2 p, vec2 r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nfloat rep(float p, float r)\n{\n \treturn (fract(p/r+0.5) - 0.5) * r;\n}\n\nvec2 map(vec3 p)\n{\n  \tvec2 result = vec2(10.0, 1.0);\n    \n    \n    \n    vec3 p2 = p, p3 = p;\n    \n    \n    \n    p2.xz = kifs(p.xz, 4.0, vec2(20.5, 5.5), 5, vec2(0.4, 0.01));\n    p2.xz *= rot(((cos(iTime * 0.005) * 0.5) + 0.4) * 0.5);\n    p2.yx = kifs(p.yx, 5.0, vec2(12.5, 10.5), 15, vec2(0.45, 0.95));\n    p2.yx *= rot(cos(iTime * 0.05) * 0.001);\n \n    p2 = rep(p2, vec3(12.0));\n    \n    p.y -= sin(p.z * 1.0);\n    p.x -= sin(p.z * 0.5);\n    p.z -= sin(p.x * 1.2);\n    \n    p.xz *= rot(cos(iTime * 0.0001) * 15.0);\n    \n    p.yx *= rot(sin(iTime * 0.0001) * 25.0);\n    \n    p3.xz = kifs(p.xz, 2.0, vec2(20.5, 15.5), 25, vec2(0.5, 0.5));\n    p3.zx *= rot(((cos(iTime * 0.001) * 0.5) + 0.4) * 10.5);\n    p3.yx = kifs(p.yx, 5.0, vec2(25.5, 20.5), 20, vec2(0.1, 0.05));\n    p3.yx *= rot(cos(iTime * 0.005) * 0.001);\n    \n    p3.xyz = rep(p3.xyz, vec3(7.5));\n   \n    p3.y += cos(cos(iTime * 0.0) * 0.001) * 0.005;\n    \n    result.x = min(result.x, sdBox(p2, vec3(1.5)));\n    \n    result.x = opSmoothIntersection(result.x, sdSphere(p3, 0.1), 4.0);\n    //result.x = min(result.x, sdSphere(p3, 0.2));\n    \n   return result;\n}\n\nvec3 look(vec2 uv, vec3 pos, vec3 at)\n{\n    vec3 f = normalize(at - pos);\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(f, r));\n    \n    return normalize(f + r * uv.x + u * uv.y); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv - 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 pos = vec3( sin(iTime * 0.01)*100.0, 1005.0, cos(iTime * 0.01)*100.0);\n    vec3 at = vec3(0.0,0.0,0.);\n\tvec3 dir = look(uv, pos, at);\n    \n    vec3 p = pos;\n    float dist = 0.0; vec2 mat = vec2(0.0);\n    float glow = 0.0;\n    for(int i = 0; i < NUM_LOOP; ++i)\n    {\n        mat = map(p);\n        \n        if(mat.x < 1.0)\n            glow += 0.05/0.02*(mat.x+mat.x);\n        \n     \tif(mat.x <= MAT_LIMIT)\n        {\n\t\t\tdist = 1.0 - (float(i) / float(NUM_LOOP));\n            break;\n        }\n        \n        p += mat.x * dir * 0.65;\n    }\n    \n    col += vec3(1.0, 0.4, 0.0) * glow * 0.05;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "wtfpl-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsd3WS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsdGz7", "name": "Poincare Half Plane Model", "author": "skye_adaire", "description": "The upper half plane model of hyperbolic space. Each point in the plane is first transformed to the Poincare disk, then transformed and colored.", "tags": ["plane", "complex", "model", "transformation", "hyperbolic", "poincare", "hypercomplex", "half"], "likes": 4, "viewed": 158, "date": "1568135210", "time_retrieved": "2024-06-20T19:44:13.745828", "image_code": "//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexVector2 mat2x2\n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\nComplex M_fromPlaneToDisk(Complex z)\n{\n   return Complex(2.0 * z.x, H_sqnorm(z) - 1.0) / (H_sq(z.x) + (1.0 + z.y) * (1.0 + z.y));\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = (clip + vec2(0, 1)) * 2.0;\n    \n    vec2 z = M_fromPlaneToDisk(p);\n\n    //this transform moves us around \n    //transformation could also be done by complex matrix composition, just like view matrices in R3\n    //since this is a fully proceedural shader, I recompute the translation each frame\n    float time = 0.4 * iTime;\n    ComplexMatrix2 translation = M_translateDisk(4.0 * vec2(0.2*cos(0.5*time), sin(time)));\n    z = M_multiply(translation, z);\n\n    //these transforms comprise the fundamental domain of the tiling\n    ComplexMatrix2 transformFromA = identityMob;\n    ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n    float angleB = tau32 / 8.0;\n    Complex versorB = H_versor(angleB);\n    ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n    ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n    ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.852), H_versor(0.852));\n    ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n    vec3 distances;\n    z = getPoincareTiling(\n        transformFromA, transformToA,\n        transformFromB, transformToB,\n        transformFromC, transformToC,\n        z, distances);\n\n    distances = vec3(1) - distances;\n    distances = pow(distances, vec3(30.0));\n\n    vec3 color = distances;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsdGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsK3zR", "name": "faz_hexmap", "author": "fazouane_marouane", "description": "fiddling with webgl", "tags": ["hex"], "likes": 1, "viewed": 57, "date": "1569620584", "time_retrieved": "2024-06-20T19:44:13.745828", "image_code": "// Based on https://github.com/fazouane-marouane/fiddling-with-webgl\n#define PI 3.1415926538\n\nprecision mediump float;\n\n\nmat2 mInv = mat2(\n  1.0, 0.0,\n  0.577, 1.154\n);\n\nvec4 hsv2rgb(vec4 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec4(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), c.w);\n}\n\nvec2 updateCenter(vec2 c, vec2 acc, vec2 p) {\n  if (mod(c.x + c.y, 3.0) == 0.0 && (acc == p || distance(acc, p) > distance(c, p))) {\n    return c;\n  }\n  return acc;\n}\n\nvec2 getPosition(vec2 p, float angle) {\n  float radianAngle = -2.0 * PI * angle;\n  mat2 rotation = mat2(\n    cos(radianAngle), sin(radianAngle),\n    -sin(radianAngle), cos(radianAngle)\n  );\n  vec2 shift = vec2(iResolution.x, iResolution.y) / min(iResolution.x, iResolution.y);\n  vec2 clipPos = 2.0*p/min(iResolution.x, iResolution.y) - shift;\n  vec2 position = 10.0 * mInv * rotation * clipPos;\n  return position;\n}\n\nvec2 getCenter(vec2 position) {\n  vec2 c1 = floor(position);\n  vec2 c2 = ceil(position);\n  vec2 c3 = vec2(c1.x, c2.y);\n  vec2 c4 = vec2(c2.x, c1.y);\n  vec2 center = updateCenter(c1,\n    updateCenter(c2,\n        updateCenter(c3,\n            updateCenter(c4, position, position),\n            position),\n        position),\n    position);\n  return center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float progress = mod(iTime, 10.0) / 10.0;\n  float angle = progress;  \n  vec2 mouse = iMouse.xy;\n  vec4 color = vec4(progress, 1.0, 1.0, 1.0);\n    \n  vec2 position = getPosition(fragCoord, angle);\n  vec2 center = getCenter(position);\n  vec2 mouseCenter = getCenter(getPosition(mouse, angle));\n  vec2 pos = position - center;\n  float cc = fract(angle);\n  float d = 2.0 * (cc <= 0.5 ? cc: 1.0-cc);\n  float delta = 0.05 * d;\n  if ( abs(pos.x) <= 1.0 - delta && abs(pos.y) <= 1.0 - delta &&\n       abs(pos.x-pos.y) <= 1.0 - delta) {\n    if (center.x == 0.0 && center.y == 0.0 &&\n    abs(pos.x) <= 1.0 - 2.0*delta && abs(pos.y) <= 1.0 - 2.0*delta &&\n       abs(pos.x-pos.y) <= 1.0 - 2.0*delta) {\n      fragColor = hsv2rgb(color);//vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n      if (mouseCenter.x == center.x && mouseCenter.y == center.y) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n      } else {\n        float c = fract(angle);\n        c = 2.0 * (c <= 0.5 ? c: 1.0 - c);\n        fragColor = vec4(c, c, c, 1.0);//vec4((1.0+ cos(center.x))/2.0, (1.0+ sin(center.y))/2.0, (1.0-cos(center.y)*sin(center.x))/2.0, 1.0);\n      }\n    }\n  } else {\n    fragColor = hsv2rgb(color);\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsK3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsl3Ds", "name": "N Polygon distance 2D", "author": "remotion", "description": "Signed distance to a polygon(negative in the inside, positive in the outside). Note there's only one square root involved.\nBased on  https://www.shadertoy.com/view/XsXSz4", "tags": ["2d", "triangle", "distance", "polygon"], "likes": 3, "viewed": 154, "date": "1568839227", "time_retrieved": "2024-06-20T19:44:15.715651", "image_code": "// The MIT License\n// Copyright  2014 Inigo Quilez\n// Remotion 2019\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// See here for a specialization when the triangle is equilateral: https://www.shadertoy.com/view/Xl2yDW\n\n\n// List of some other 2D distances:\n//\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\n// Equilateral Triangle: https://www.shadertoy.com/view/Xl2yDW\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\n// Cross:                https://www.shadertoy.com/view/XtGfzw\n//\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat min3(float a, float b, float c) {\n\treturn (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);\n}\n\nfloat min6(float a, float b, float c, float d, float e, float f) {\n\treturn min(min3(a,b,c),min3(d,e,f));\n}\nfloat min8(float a, float b, float c, float d, float e, float f, float g, float h) {\n\treturn min3(min3(a,b,c),min3(d,e,f),min(g,h));\n}\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n// Test if point p crosses line (a, b)\nfloat orient2d(vec2 p0, vec2 p1, vec2 point) {\n    return ((p1.x - p0.x) * (point.y - p0.y) -\n            (point.x - p0.x) * (p1.y - p0.y));\n}\n\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n  \n  //? if( abs(2.0*a+b+d) < 1.0 ) return closestPointInSegment(b0,b2);\n  //float o = orient2d(b0,b2,b1);\n  //if (o < 0.01 && o > -0.01) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t);\n\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  float o = orient2d(b0,b2,b1);\n  if (o < 0.05 && o > -0.05) return sdBezier(b0,b1,b2,p);\n    \n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n\n// signed distance to a 2D triangle\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdLineSquared( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a; \n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return dot2( pa - ba*h );\n}\n\nfloat sdLineSquared2(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    vec2 diff = (ab*t + a) - p;\n    return dot2(diff);\n}\n\nfloat sdCapsule2(vec2 p, vec2 a, vec2 b, float r1, float r2) {\n    vec2 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    vec2 diff = (ab*t + a) - p;\n    return sqrt(dot(diff, diff)) - (r1*t + r2 * (1.0 - t));\n}\n\nbool pnpoly4(vec2 vert[4], vec2 test)\n{\n  int nvert = 4;\n  bool c = false;\n  for (int i = 0, j = nvert-1; i < nvert; j = i++) {\n    if ( ((vert[i].y>test.y) != (vert[j].y>test.y)) &&\n        (test.x < (vert[j].x-vert[i].x) * (test.y-vert[i].y) / (vert[j].y-vert[i].y) + vert[i].x) ) {\n       c = !c;\n    }\n  }\n  return c;\n}\n\nbool pnpoly5(vec2 vert[5], vec2 test)\n{\n  int nvert = 5;\n  bool c = false;\n  for (int i = 0, j = nvert-1; i < nvert; j = i++) {\n    if ( ((vert[i].y>test.y) != (vert[j].y>test.y)) &&\n        (test.x < (vert[j].x-vert[i].x) * (test.y-vert[i].y) / (vert[j].y-vert[i].y) + vert[i].x) ) {\n       c = !c;\n    }\n  }\n  return c;\n}\n\n// even-odd rule\nbool pnpoly9(vec2 vert[9], int nvert, vec2 test)\n{\n  bool c = false;\n  for (int i = 0, j = nvert-1; i < nvert; j = i++) {\n    if ( ((vert[i].y>test.y) != (vert[j].y>test.y)) &&\n        (test.x < (vert[j].x-vert[i].x) * (test.y-vert[i].y) / (vert[j].y-vert[i].y) + vert[i].x) ) {\n       c = !c;\n    }\n  }\n  return c;\n}\n\n\n// Nonzero-rule\nbool is_inside(vec2 vert[9], int nvert, vec2 point) {\n    int winding_number = 0; // The winding number counter.\n    for (int i = 0, j = nvert-1; i < nvert; j = i++) {\n        vec2 point1 = vert[i];\n        vec2 point2 = vert[j];\n        if (point1.y <= point.y) {                                  // start y <= point.y\n            if (point2.y > point.y) {                               // An upward crossing\n                if (orient2d(point1, point2, point) > 0.0) {         // Point left of edge\n                    ++winding_number;                               // Have a valid up intersect\n                }\n            }\n        }\n        else {\n            // start y > point.y (no test needed)\n            if (point2.y <= point.y) {                              // A downward crossing\n                if (orient2d(point1, point2, point) < 0.0) {         // Point right of edge\n                    --winding_number;                               // Have a valid down intersect\n                }\n            }\n        }\n    }\n    return (winding_number != 0);\n}\n\n\n\nfloat sdQuad(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p) {\n    \n\tfloat d1 = sdLineSquared(p, p0, p1);\n\tfloat d2 = sdLineSquared(p, p1, p2);\n\tfloat d3 = sdLineSquared(p, p2, p3);\n\tfloat d4 = sdLineSquared(p, p3, p0); \n    \n    float d = sqrt(min(min(d1,d2),min(d3,d4)));\n    \n\tvec2 vert[4] = vec2[](p0,p1,p2,p3);\n\tbool inside = pnpoly4(vert,p);\n    if (inside) return -d;\n    return d;\n}\n\nfloat sdPoly5(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4, in vec2 p) {\n    \n\tfloat d1 = sdLineSquared(p, p0, p1);\n\tfloat d2 = sdLineSquared(p, p1, p2);\n\tfloat d3 = sdLineSquared(p, p2, p3);\n\tfloat d4 = sdLineSquared(p, p3, p4); \n    float d5 = sdLineSquared(p, p4, p0); \n    \n    float d = sqrt(min(min(min(d1,d2),min(d3,d4)),d5));\n    \n\tvec2 vert[9] = vec2[](p0,p1,p2,p3,p4,p4,p4,p4,p4);\n\tbool inside = pnpoly9(vert,5,p);\n    if (inside) return -d;\n    return d;\n}\n\nfloat sdPoly6(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4, in vec2 p5, in vec2 p) {\n    \n\tfloat d1 = sdLineSquared2(p, p0, p1);\n\tfloat d2 = sdLineSquared2(p, p1, p2);\n\tfloat d3 = sdLineSquared2(p, p2, p3);\n\tfloat d4 = sdLineSquared2(p, p3, p4); \n    float d5 = sdLineSquared2(p, p4, p5); \n\tfloat d6 = sdLineSquared2(p, p5, p0); \n    \n    float d = sqrt(min(min(min(d1,d2),min(d3,d4)),min(d5,d6)));\n    \n\tvec2 vert[9] = vec2[](p0,p1,p2,p3,p4,p5,p4,p4,p4);\n\tbool inside = is_inside(vert,6,p);\n    if (inside) return -d;\n    return d;\n}\n\nfloat sdPoly8(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4, in vec2 p5, in vec2 p6, in vec2 p7, in vec2 p) {\n    \n\tfloat d1 = sdLineSquared2(p, p0, p1);\n\tfloat d2 = sdLineSquared2(p, p1, p2);\n\tfloat d3 = sdLineSquared2(p, p2, p3);\n\tfloat d4 = sdLineSquared2(p, p3, p4); \n    float d5 = sdLineSquared2(p, p4, p5); \n\tfloat d6 = sdLineSquared2(p, p5, p6); \n\tfloat d7 = sdLineSquared2(p, p6, p7); \n\tfloat d8 = sdLineSquared2(p, p7, p0); \n    \n    float d = sqrt(min8(d1,d2,d3,d4,d5,d6,d7,d8));\n    \n\tvec2 vert[9] = vec2[](p0,p1,p2,p3,p4,p5,p6,p7,p7);\n\tbool inside = is_inside(vert,8,p);\n    //bool inside = pnpoly9(vert,8,p);\n    if (inside) return -d;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.4;\n    \n   \tvec2 m1 = ((2.0*iMouse.xy-iResolution.xy)/iResolution.y) * 1.4;;\n     \n\tvec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( iTime + vec2(0.0,3.00) + 4.0 );\n    vec2 v4 = cos( iTime + vec2(0.0,4.00) + 3.0 );\n    \n\tvec2 v5 = cos( iTime + vec2(0.0,2.00) + 1.5 );\n\tvec2 v6 = cos( iTime + vec2(0.0,6.00) + 4.0 );\n    vec2 v7 = cos( iTime + vec2(0.0,6.00) + 3.0 );\n    vec2 v8 = cos( iTime + vec2(0.0,7.00) + 2.0 );\n    vec2 v9 = cos( iTime + vec2(0.0,1.00) + 4.0 );\n    //vec2 v7 = iMouse.xy / iResolution.xy; //cos( iTime + vec2(0.0,6.00) + 3.0 );\n\n\tfloat dt = sdTriangle( v5, v6, v7, p );\n    float dq = sdQuad( v1, v2, v3, v4, p );\n    float dq2 = sdPoly5( v5, v6, v7, v8, v9, p );\n    float dq3 = sdPoly6( v1, v2, v3, v4, v8, v9, p );\n    float dq4 = sdPoly8( v1, v2, v3, v4, v5, v6, v7, m1, p );\n    \n    float bd = approx_distance( p, v1, m1, v3);\n    \n    //float d = min(dq2,dq3);\n    //float d = abs(dq4) - 0.01; //min(dq2,dq);\n    float d = dq4;//bd;\n    //float d = bd;\n\n    vec3 col = vec3(1.0,1.0,1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,5.0/iResolution.y,abs(d)) );\n    \n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/tsl3Ds.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tst3Wn", "name": "dip glitch", "author": "ompuco", "description": "glitchy variant of my dip shader + simple cel shading!", "tags": ["raymarch", "animation", "glitch", "character", "demon"], "likes": 0, "viewed": 327, "date": "1568337435", "time_retrieved": "2024-06-20T19:44:17.249242", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 96;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat hash( float n )\n\t\t\t{\n\t\t\t    return fract(sin(n)*43758.5453);\n\t\t\t}\n\n\t\t\tfloat noise( vec3 x )\n\t\t\t{\n\t\t\t    // The noise function returns a value in the range -1.0f -> 1.0f\n\n\t\t\t    vec3 p = floor(x);\n\t\t\t    vec3 f = fract(x);\n\n\t\t\t    f       = f*f*(3.0-2.0*f);\n\t\t\t    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n\t\t\t    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z)-.5;\n\t\t\t}\n\n\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec3 Zigzag(vec3 pos, float freq, float offset){\n    float i = (pow(offset+abs(pos.x),.8));\n    float x = freq-abs(mod(i,2.0*freq)-freq);\n    pos.y+=(x);\n    return pos;\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n\n\nfloat map(vec3 p) {\n    \n    \n    \n    //p.x=mix(p.x,.0,step(p.x,.0)*step(sin(iTime+p.x),-.7));\n    //float cut = max(p.x,p.x+sin(iTime));\n    //p.x=mix(p.x,cut,step(p.x,sin(iTime)));//*step(sin(iTime+p.x),-.7));\n    \n    \n    if(iTime>5.50-round(p.y*8.0)/8.0)\n    p.x=clamp(p.x,-1.+sin(iTime+round(p.y)*round(random(round(p.xy*4.0)/4.0)*4.0*8.0)/8.0),2.);\n    if(iTime>8.20-round(p.y*8.0)/8.0)\n    p.x=clamp(p.x,-1.,1.-cos(iTime+round(p.y)*round(random(round(p.xy*8.0)/8.0)*4.0*8.0)/8.0));\n    \n    //p.x+=random(round(p.yz*6.0))*step((sin(iTime*1.0+round(p.y*16.0)/12.0)+1.01)*4.0-.1,.0);\n    p.x+=round(\n        random(round(p.yz*6.0))*step((sin(iTime*1.0+round(p.y*16.0)/12.0)+1.01)*4.0-.1,.0+round(random(round(p.xx*8.-vec2(iTime)))*32.0)/32.0)\n        *8.0)/8.0;\n\n    //p.x+=sin(p.y*2.0+iTime*4.0)/8.0;\n    \n    //p.x-=sin(iTime*10.0)/(1.0+distance(p.xyz,vec3(.0))*32.0)*4.0;\n    \n    float head=sdRoundedCylinder(p+vec3(.0,.05,-.050),.375,.6,.01);\n\n    vec3 p2 = p;p2.x=abs(p2.x);p2.y/=1.4;\n\n    vec3 p3 = p;p3.z*=1.12;\n    //p3.x-=sin(iTime*2.0)/4.0;\n    //p3.x-=sin(p3.y+iTime*2.0)/8.0;\n    //p3.z+=step(p.z,.0)*sin(p3.y)/8.0;\n    p3.z-=smoothstep(.0,1.0,p3.y)/8.0;\n\t\n    \n    float body = sdRoundedCylinder(p3+vec3(.0,1.7,.350+sin(p3.y)/8.0),.3,1.7,.103);\n\t    p3.yz=rotate(p3.yz,.105);\n\n    body = opSmoothUnion(body, sdRoundedCylinder(p3+vec3(.0,.9,.150),.25,1.7,.103),.1);\n    \n    float d=opSmoothUnion(body,head,.15);\n     \n    float horns = sdOctahedron(p2-vec3(.5,.44,.1),.5);\n    horns = max(horns,-sdBox(p2-vec3(.0,.5,.0),vec3(.2,1.0,1.0)));\n    d=min(d,horns);\n    \n    const int layers = 4;\n    \n    d+=1.0/3.0;\n    \n    \n    \n    for(int layer = 1; layer < layers; layer++){\n        float m = pow(float(layer),1.1);\n        d=onion(d,.2/m);\n    }\n    \n    //d+=.0001;\n    \n    float d2 = 0.0;\n    \n\n    for(int b = 0; b<4; b++){\n        vec3 m = texture(iChannel0,vec2(iTime/128.0,float(b)/8.0)).rgb;//iTime+random(vec2(float(b)*32.0,.4))*8.0;\n        m=(m-vec3(.5))*4.0;\n        //d2=min(d2,sdBox(p+(m),vec3(.5)));\n        //d2=opSmoothUnion(d2,sdBox(p+(m),vec3(.25)),.3);\n        //d2=opSmoothUnion(d2,sdBox(p+(m),vec3(.25+sin(iTime+float(b)*1.10)/8.0+.05)),.3);\n        \n        if(iTime>14.-p.z)\n\t\td2=min(d2,sdBox(p+(m),vec3(.25+sin(iTime+float(b)*1.10)/12.0+.25)));\n\t\t\n        //d=max(d,-sdBox(p+(m),vec3(.5/(float(b)/8.0+1.0)*2.0)));\n\n\n    }\n    d2+=.1;\n    \n    d=max(d,-d2);\n    \n    \n    //d=min(d,body);\n    \n\n\n    \n    return d;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nstruct rmData{\n    vec4 color;//TODO @SAM: just do the colors at end of rm() function, u dummy\n    vec3 pos;\n    float depth;\n};\n\n    \nrmData rm(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    rmData raym;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * dir);\n        if (dist < EPSILON) {\n            raym.depth=depth;\n            raym.pos=eye + depth * dir;\n\t\t\treturn raym;\n        }\n        depth += dist;\n        if (depth >= end) {\n            raym.depth=end;\n            return raym;\n        }\n    }\n    raym.depth=end;\n    return raym;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rotor = vec2(sin(iTime*2.0)/2.0,cos(iTime));\n    if(iMouse.z>.0)\n    rotor=-vec2((iMouse.x/128.),(iMouse.y/64.-3.14))*2.0;\n\n    float eyeLook = mod(rotor.x+3.14*9.0,3.14*2.0)-3.14;\n    //eyeLook=clamp(eyeLook*12.5,-2.7,2.7)/2.7;\n    eyeLook=clamp(eyeLook*2.0,-1.0,1.0);\n\n    eyeLook=smoothstep(0.0,1.0,eyeLook/2.0+.5)*2.0-1.0;\n    eyeLook*=.85;\n        //eyeLook=clamp(eyeLook,-1.,1.)*.6;\n\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    dir.xz=rotate(dir.xz,rotor.x);\n    dir.yz=rotate(dir.yz,rotor.y/4.0-.15);\n\n    vec3 eye = vec3(0.0, 0.2, 5.25);\n    eye.z+=(sin(iTime/2.0)/2.0+.5)*1.0;\n    eye.xz=rotate(eye.xz,rotor.x);\n    eye.yz=rotate(eye.yz,rotor.y/4.0-.15);\n    \n\n\n    rmData r = rm(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = r.depth;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 n = estimateNormal(r.pos);\n    \n    vec3 p = r.pos;\n    p.x=abs(p.x);\n    \n    vec3 lDir = (vec3(.65,.5,.85))*2.0;\n    \n    \n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    float eyes=step(length(p+vec3(-.4,-.1,-.6)),.25);\n    float blink = clamp(1.0-abs(sin(iTime*0.45))*16.0,.0,1.0);\n    \n    \n    //blink rate for second blink set\n    float blinkRate = .4;\n    \n    //second set of blinks for more dynamic blinking lol\n    blink = max(blink,clamp(1.0-abs(cos(iTime*0.45*blinkRate))*16.0/blinkRate,.0,1.0));\n    \n    //squint occasionally\n    blink = max(blink,clamp(.35-abs(cos(iTime/4.0+.15)),.0,.10));\n\n    eyes*=step(p.y+p.x/8.0,.2-blink);\n    \n    //horizontal pupils follow camera\n    float pupils =step(.0,sdBox(p+vec3(-.4-eyeLook*sign(r.pos.x)/6.0,-.1+p.x/8.0,-.6),vec3(.01,.1,.5)));\n    \n    \n    //fragColor.g+=step(.0,n.y)*.25*step(-.5,r.pos.y);\n    //fragColor.g+=step(.0,n.y)*.05*step(n.y,.01);\n    \n    //fragColor.rgb=n.rgb;\n\n    fragColor.g=clamp(fragColor.g+eyes*pupils,.0,1.0);\n\n    \n    \n    \n    vec3 pm = Zigzag(r.pos,.11,.15);\n    \n    \n    pm.y=mix(r.pos.y,pm.y*2.0+.35,clamp(1.0-abs(pm.x),.0,1.0));\n\n\n    \n    float talkFreq = mix(sin(iTime*16.0),sin(iTime*13.0)-.8,clamp((cos(iTime*2.0+.15)+.5)*4.0,0.0,1.0));\n    float talkH=clamp(talkFreq/16.0+.1,.015,.25);\n    //float talkW=smoothstep(-1.0,1.0,clamp(-cos(iTime*2.0+.15)*8.0+.5,.0,1.0)*.24)*1.15-.34;\n    float talkW=smoothstep(-1.0,1.0,clamp(-cos(iTime*2.0+.15)*8.0+.5,.0,1.0)*.24)*.65;\n\n    float mouth = (sdEllipsoid(pm+vec3(.0,.425-pow(abs(pm).x,2.0)/1.0,-.5),vec3(talkW,talkH,.5)));\n\n    \n    \n    fragColor.g+=1.0-step(-.01,mouth);\n    \n    //cel shading\n    fragColor*=mix(.5,1.0,clamp(fragColor.g+round(dot(n,lDir)+.5),.0,1.0));\n\n    /*\n    fragColor.g+=1.0-step(-.01,mouth);\n    fragColor.r=max(fragColor.r,1.0-step(-.01,mouth));\n\n    fragColor.g=clamp(fragColor.g+eyes*pupils,.0,1.0);\n    fragColor.r=max(fragColor.r,clamp(fragColor.g+eyes*pupils,.0,1.0));\n    */\n\n\n\n    \n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tst3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tst3WS", "name": "Resolution independent starfield", "author": "AntoineC", "description": "Stars are very small in respect to pixel size! This shader is an attempt to render a star field that looks the same under various resolutions by changing the brightness instead of changing the size of the stars.  ", "tags": ["2d", "star", "starfield"], "likes": 16, "viewed": 657, "date": "1569252112", "time_retrieved": "2024-06-20T19:44:17.727985", "image_code": "// Goals:\n//  - Star sizes should not change when switching to fullscreen\n//  - Perceived brightness should not change with resolution (somewhat exclusive with goal one!)\n//  - Reduce flickering when scrolling\n\n\n\n// Dave Hoskins hash functions\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx) - 0.5;\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx+19.19);\n    return -1.0+2.0*fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// IQ's Gradient Noise\nfloat Gradient2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nconst vec3 cold = vec3(255.0, 244.0, 189.0)/255.0;\nconst vec3 hot  = vec3(181.0, 236.0, 255.0)/255.0;\n\nvec3 StarFieldLayer(vec2 p, float du, float count, float brightness, float size)\n{\n    // Tiling:\n    vec2 pi;\n    du *= count;    p *= count;\n    pi  = floor(p); p  = fract(p)-0.5;\n  \n    // Randomize position, brightness and spectrum:\n    vec4 h = hash42(pi);\n\n    // Resolution independent radius:\n    float s = brightness*(0.7+0.6*h.z)*smoothstep(0.8*du, -0.2*du, length(p+0.9*h.xy) - size*du);\n\n    return s*mix(mix(vec3(1.), cold, min(1.,-2.*h.w)), hot, max(0.,2.*h.w));\n}\n\nvec3 StarField(vec2 p, float du)\n{\n    vec3 c;\n    c  = StarFieldLayer(p, du, 25.0, 0.18, 0.5); \n    c += StarFieldLayer(p, du, 15.0, 0.25, 0.5); \n    c += StarFieldLayer(p, du, 12.0, 0.50, 0.5); \n    c += StarFieldLayer(p, du,  5.0, 1.00, 0.5); \n    c += StarFieldLayer(p, du,  3.0, 1.00, 0.9); \n\n    // Cluster:\n    float s = 3.5*(max(0.2, Gradient2D(2.0*p*vec2(1.2,1.9)))-0.2)/(1.0-0.2);\n    c += s*StarFieldLayer(p, du, 160.0, 0.10, 0.5); \n    c += s*StarFieldLayer(p, du,  80.0, 0.15, 0.5); \n    c += s*StarFieldLayer(p, du,  40.0, 0.25, 0.5); \n    c += s*StarFieldLayer(p, du,  30.0, 0.50, 0.5); \n    c += s*StarFieldLayer(p, du,  20.0, 1.00, 0.5); \n    c += s*StarFieldLayer(p, du,  10.0, 1.00, 0.9); \n\n    c *= 1.3;\n    \n    // Resolution independent brightness:\n    float f = 1.0 / sqrt(660.0*du);\n\n    return f*min(c, 1.0);\n}\n\n\nvoid mainImage( out vec4 o, in vec2 v )\n{\n    float du = 1.0 / iResolution.y;\n    vec2  uv = du*(v-0.5*iResolution.xy) + 1.33 + iTime/30.0;\n    o = vec4(StarField(uv, du), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tst3WS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tst3zM", "name": "Fake Azimuthal Equidistant", "author": "skye_adaire", "description": "This is an interesting view of the hyperboloid model of hyperbolic space that is similar to azimuthal equidistant projection. See my other shaders for more background.", "tags": ["fake", "projection", "hyperbolic", "hyperboloid", "azimuthal", "equidistant"], "likes": 6, "viewed": 152, "date": "1568127054", "time_retrieved": "2024-06-20T19:44:19.728168", "image_code": "//created by Skye Adaire\n\n#define tau32 6.2831853072\n#define eps32 1e-10\n\n//begin Ray\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\n//the hyperplane centered at the origin with normal 0,0,1\nbool intersectHyperplane(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    t = -rayPosition[2] / rayDirection[2];\n\n    return t > 0.0 && !isinf(t);\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - radius * radius;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nfloat hdot(vec3 a, vec3 b)\n{\n    return a[0] * b[0] + a[1] * b[1] - a[2] * b[2];\n}\n\nbool intersectHypercone(vec3 rayPosition, vec3 rayDirection, float hyperness, out float t)\n{\n    float a = hdot(rayDirection, rayDirection);\n    float b = 2.0 * hdot(rayDirection, rayPosition);\n    float c = hdot(rayPosition, rayPosition) + hyperness;\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nbool intersectEllipticHyperboloid(vec3 rayPosition, vec3 rayDirection, out float t)\n{\n    return intersectHypercone(rayPosition, rayDirection, +1.0, t);\n}\n\n//end Ray\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\n#define Complex vec2\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    vec2 fcc = ratioSpacePosition * 12.5;\n\n    //view basis\n    mat3 viewTransform = mat3(1.0);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 20);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * fcc.x +\n       viewUp * fcc.y;\n    vec3 srd = viewForward;\n    \n    //intersect the screen ray\n    float t;\n    vec3 color = vec3(0);\n    \n    if(intersectEllipticHyperboloid(srp, srd, t))\n    {\n    \tvec3 position = srp + t * srd;\n        vec3 pole = position.z > 0.0 ? vec3(0,0,-1) : vec3(0,0,1);\n        \n        vec3 rp = position;\n        vec3 rd = normalize(pole - rp);\n        \n        intersectHyperplane(rp, rd, t);//must hit\n        \n      \tposition = rp + t * rd;\n       \n        vec2 z = position.xy;\n        \n        //this transform moves us around \n        //transformation could also be done by complex matrix composition, just like view matrices in R3\n        //since this is a fully proceedural shader, I recompute the translation each frame\n        float time = iTime * 0.2;\n        ComplexMatrix2 translation = M_translateDisk(4.0 * vec2(cos(0.5*time), 0.1*sin(time)));\n        z = M_multiply(translation, z);\n         \n        //these transforms comprise the fundamental domain of the tiling\n        ComplexMatrix2 transformFromA = identityMob;\n        ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n        float angleB = tau32 / 8.0;\n        Complex versorB = H_versor(angleB);\n        ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n        ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n        ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.852), H_versor(0.852));\n        ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n        vec3 distances;\n        z = getPoincareTiling(\n            transformFromA, transformToA,\n            transformFromB, transformToB,\n            transformFromC, transformToC,\n            z, distances);\n\n        distances = vec3(1) - distances;\n        distances = pow(distances, vec3(30.0));\n\n        color = distances;\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tst3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstGWX", "name": "maglev", "author": "zaki", "description": "Shadertoy testing", "tags": ["test"], "likes": 3, "viewed": 81, "date": "1569425430", "time_retrieved": "2024-06-20T19:44:21.097879", "image_code": "uniform float _Time;\nuniform vec2 _Resolution;\nuniform vec4 _FFT;\n\n#define Time iTime\n\n#define PI acos(-1)\n#define MAX_MARCH 200\n#define MAX_DIST 400.0\n#define MIN_DIST 0.001\n#define BPM 123.0\n\nvec2 g = vec2(0.0);\n\nfloat sphere(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat box(vec3 pos, vec3 dim)\n{\n    vec3 d = abs(pos) - dim;\n\n    return length(max(d, 0.0))\n         + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nmat2 rot(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n\n    return mat2(ca, sa, -sa, ca);\n}\n\nfloat smin(float d1, float d2, float k)\n{\n  float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0.0, 1.0);\n  return mix(d1, d2, h) - k * h * (1.0 - h);\n}\n\nvec3 rep(vec3 p, vec3 r)\n{\n    return mod(p, r) - 0.5 * r;\n}\n\nvec3 fog(vec3 col, vec2 dd)\n{\n    float f = 1.0 - exp(MAX_DIST - dd.x);\n    vec3 fc = vec3(0.45, 0.3, 0.66);\n\n    return mix(col, fc, f);\n}\n\nfloat beat()\n{\n    float pw = _FFT.x;\n\n    float b = 600.0 / BPM;\n    float s = mod(Time, b) / b;\n    return smoothstep(0.5, 1.0, pw) * 2.0;\n}\n\nfloat rnd(float t)\n{\n    return fract(sin(t * 2838.237) * 237.1236);\n}\n\nfloat curve(float t, float d)\n{\n    float g = t / d;\n\n    return mix(rnd(floor(g)), rnd(floor(g) + 1.0), pow(smoothstep(0.0, 1.0, fract(g)), 10.0));\n}\n\nvec3 offset(vec3 pos)\n{\n    vec3 off = vec3(0.0, 0.0, 0.0);\n\n    off.x += curve(pos.z / 20.0, 10.0) * 3.0 * smoothstep(0.0, 1.0, Time - 15.0);\n    off.y += curve(pos.z / 40.0, 10.0) * 4.0 * smoothstep(0.0, 1.0, Time - 15.0);\n    return off;\n}\n\nfloat bend()\n{\n    return smoothstep(0.0, 1.0, clamp(Time - 14.5, 0.0, 1.0));\n}\n\nfloat lll()\n{\n    return smoothstep(0.9, 1.0, clamp(Time - 14.5, 0.0, 1.0)) * -1.0;\n}\n\nfloat rail(vec3 pos)\n{\n    vec3 rep = vec3(24.6, 15.4, 10.0);\n    vec2 r = vec2(sin(pos.z / 40.0) * -0.6 * cos(Time * 10.0), sin(pos.z / 55.0) * 1.0 * cos(Time));\n    float d = MAX_DIST;\n    vec3 off = vec3(-11.0, 9.0, 0.0);\n\n    for (int i = 0; i < 3; ++i)\n    {\n        vec3 p = pos + off + vec3(sin(float(i) * Time) * 0.16 * float(i), cos(float(i) * Time) * 0.7 * float(i), 0.0);\n        p.yx += r * bend();\n        p = mod(p, rep) - 0.5*rep;\n        p += offset(pos) * 0.3 * float(i);\n\n        float s = sin(Time * 0.5) * 0.03 + _FFT.x * 0.9;\n        float b = box(p, vec3(0.3 + s, 0.3 + s, 5.2));\n\n        d = smin(d, b, 0.6);\n    }\n\n    g.x += 0.2 / (1.3 + d*d);\n\n    return d;\n}\n\nfloat lights(vec3 pos)\n{\n    vec2 r = vec2(sin(pos.z / 40.0) * 2.0, sin(pos.z / 55.0) * 3.0);\n    vec3 rep = vec3(12.3, 15.4, 340.0);\n    float d = MAX_DIST;\n    vec3 off = vec3(13.0, 1.0, 0.0);\n\n    vec3 p = pos + off;\n    p.yx += r * bend();\n    p = mod(p, rep) - 0.5*rep;\n    p += offset(pos);\n    d = sphere(p, vec4(0.1));\n\n    g.y += 7.3 / (0.1 + d*d);\n\n    return MAX_DIST;\n}\n\nfloat ll(vec3 pos)\n{\n    vec3 rep = vec3(24.6, 15.4, 40.0);\n    float r = -sin(pos.z / 40.0);\n    float d = MAX_DIST;\n    vec3 off = vec3(-11.0, 9.0, lll() * Time * 300.0);\n\n    vec3 p = pos + off;\n    p.z += r * bend();\n    p = mod(p, rep) - 0.5*rep;\n    p += offset(pos);\n\n    d = sphere(p, vec4(0.2));\n    g.y += 1.7 / (5.1 + d*d);\n\n    return MAX_DIST;\n}\n\nfloat guard(vec3 pos)\n{\n    vec2 r = vec2(sin(pos.z / 40.0) * 2.0, sin(pos.z / 55.0) * 3.0) * bend();\n    vec3 rep = vec3(12.3, 15.4, 10.0);\n    vec3 p1 = pos;\n    vec3 p2 = pos + vec3(0.0, 2.0, 5.5);\n    vec3 p3 = pos + vec3(0.0, -2.0, 0.0);\n    vec3 p4 = pos + vec3(0.0, -2.3, 0.0);\n    vec3 p5 = pos + vec3(0.0, -2.3, 0.0);\n\n    p1.yx += r;\n    p1 = mod(p1, rep) - 0.5*rep;\n    p1 += offset(pos);\n\n    p2.yx += r;\n    p2 = mod(p2, rep) - 0.5*rep;\n    p2 += offset(pos);\n\n    p3.yx += r;\n    p3 = mod(p3, rep) - 0.5*rep;\n    p3 += offset(pos);\n\n    p4.yx += r;\n    p4 = mod(p4, rep) - 0.5*rep;\n    p4 += offset(pos);\n\n    p5.yx += r;\n    p5 = mod(p5, rep) - 0.5*rep;\n    p5 += offset(pos);\n\n    float b1 = box(p1, vec3(0.3, 1.6, 3.0));\n    float b2 = box(p2, vec3(0.3, 0.8, 5.0));\n    float b3 = box(p3, vec3(0.3, 0.8, 5.0));\n    float b4 = box(p4, vec3(10.3, 0.2, 0.2));\n    float b5 = box(p5, vec3(0.3, 10.2, 0.2));\n\n    return min(min(min(min(b1, b2), b3), b4), b5);\n}\n\nfloat sdf(vec3 pos)\n{\n    return  min(\n                min(\n                    min(guard(pos), rail(pos)),\n                    lights(pos)),\n                ll(pos));\n}\n\nvec3 march(vec3 pos, vec3 ray)\n{\n    float d = 0.0;\n    int mi = 0;\n    int mat = 0;\n\n    for(mi = 0; mi < MAX_MARCH; ++mi)\n    {\n        vec3 r = pos + ray * d;\n        float s = sdf(r);\n        d += s;\n        if (s < MIN_DIST) break;\n\n        if (d > MAX_DIST)\n        {\n            mat = 1;\n            break;\n        }\n    }\n\n    float m = float(mi);\n    return vec3(d, m, mat);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float d = sdf(pos);\n    vec2 offset = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdf(pos - offset.xyy),\n        sdf(pos - offset.yxy),\n        sdf(pos - offset.yyx));\n    \n    return normalize(n);\n}\n\nvec3 campos(float time)\n{\n    vec3 cp = vec3(0.0, 5.0, time * 100.0);\n    return cp - offset(cp);\n}\n\nvec3 color(vec2 uv, vec3 px, vec3 normal)\n{\n    vec3 lightPos = normalize(vec3(10.0, 7.0, 5.0));\n\n    vec3 col = vec3(0.5, 0.1, 0.1) * pow(1.0 - px.x / MAX_DIST, 1.7);\n    col += dot(lightPos, normal) * vec3(0.1, 0.1, 0.1);\n    if (px.z == 1.0) col = vec3(0.3, 0.3, 0.3);\n\n    vec3 fog = vec3(0.2, 0.5, 0.9) * pow(px.x / MAX_DIST, 0.3);\n\n    if (px.z == 0.0)\n    {\n        col *= vec3(0.6, 0.3, 0.1);\n    }\n\n    col += mix(col, vec3(1.0, 0.6, 0.4), g.x * 0.04);\n    col += mix(col, vec3(0.9, 0.9, 0.9), g.y * 0.04);\n\n    return mix(col, fog, px.x / MAX_DIST);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 camPos = campos(Time);\n    float fov = 1.0 + (1.0 * (1.0 - bend())) + curve(Time * 2.0, 10.0) * bend();\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, fov));\n\n    vec3 dd = march(camPos, rayDir);\n\n    vec3 n = getNormal(camPos + dd.x * rayDir);\n    vec3 col = color(uv, dd, n);\n\n    col *= vec3(0.8, 0.8, 0.8) * (1.0 - length(uv));\n\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tstGzH", "name": "Menger Space", "author": "senzheng", "description": "A Menger Space", "tags": ["3d", "fractal", "space", "menger"], "likes": 4, "viewed": 196, "date": "1567838398", "time_retrieved": "2024-06-20T19:44:22.958649", "image_code": "\nstruct Hit {\n    float d;\n    vec2 uv;\n    vec3 col;\n    float ref;\n    float spe;\n    float rough;\n    float lightD;\n    vec3 lightCol;\n    float lightStrength;\n};\n    \nvec3 ro, lookAt, camup;\n#define MAX_RAYMARCHING_COUNT 250\n#define PRECISION 0.00001\n#define FAR 20.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time iTime\n#define PI 3.1415926\n\nvec2 rotate(vec2 v, float a) {\n    return vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nfloat rand(vec3 p) {\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n    return dot(abs(p), vec3(1.0));\n}\nvec3 hash( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n    \n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nvec3 noise3(vec3 p)\n{\n    return vec3(noise(p), noise(p + vec3(31.54, 72.4, 54.425)), noise(p + vec3(156.456, 87.45, 99.45)));\n}\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.0;\n    }\n    return rz;\n}\nvec3 fbm3(in vec3 x)\n{\n    vec3 rz = vec3(0.);\n    float a = .45;\n    for (int i = 0; i<3; i++)\n    {\n        rz += noise3(x)*a;\n        a*=.3;\n        x*= 4.;\n    }\n    return rz;\n}\n\n// color\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//sdf\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCross2( vec3 p )\n{\n  float da = udRoundBox(p, vec3(99999, 1.0, 1.0), 0.2);\n  float db = udRoundBox(p.yzx, vec3(1.0-0.05, 99999, 1.0-0.05), 0.);\n  float dc = udRoundBox(p.zxy, vec3(1.0, 1.0, 99999), 0.1);\n  return min(da, min(db, dc));\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n// OP\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nHit opUnion( Hit h1, Hit h2 ) {  \n    float d1 = h1.d;\n    float d2 = h2.d;\n    float resd = min(d1,d2); \n    if (resd == d1) return h1;\n    else return h2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d2,d1); }\n\nHit opSubtraction( Hit h1, Hit h2 ) {  \n    float d1 = h1.d;\n    float d2 = h2.d;\n    float resd = max(-d2,d1); \n    return Hit(resd, h1.uv, h1.col, h1.ref, h1.spe, h1.rough, h1.lightD, h1.lightCol, h1.lightStrength);\n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n//------------------------------------------------------------------\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt-ro);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat sponge(vec3 p, float factor, float phiFactor, float reverseYFactor){\n    vec3 backuppos = p;\n    float r = length(p);\n    float theta = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    p = vec3(r*sin(theta)*cos(phi*phiFactor),\n               r*sin(theta)*sin(phi*phiFactor),\n               r*cos(theta));\n    float yfactor = mix(1.0, p.y, factor);\n    p *= yfactor;\n    \n    float dscale = 1.0 / phiFactor / yfactor / (r+1.0) * phi * 0.25;\n    float d = sdBox(p, vec3(1.0)) * dscale ;\n    \n    float scale = 1.0;\n    for (int i = 0 ; i < 4 ; i++) {\n        vec3 a = mod(p*scale+1.0, 2.0) - 1.0;\n        float c = sdCross2(a * 3.0) / scale * dscale;\n        scale *= 3.0;\n        d = opSubtraction(d, c);\n    }\n    \n    d = opIntersection(d*1.0, sdRoundBox(backuppos, vec3(1.), 0.1));\n    return d;\n}\n\nvec3 distortSpace(vec3 p) {\n    vec3 backupPos = p;\n    \n    p.xy = rotate(p.xy, -0.3*time + p.z);\n    return p;\n}\n\n\nHit innerspace(vec3 p) {\n    p = distortSpace(p);\n    p = mod(p, vec3(3.0)) - 1.5;\n    float d = sponge(p, 1.0, 1.0, 0.0);\n    \n    return Hit(d, vec2(0), vec3(0.6, 0.65, 0.7), 0.0, 0.5, 0.0, d, vec3(0), 0.0);\n}\n\nHit myLight(vec3 p) {\n    p = distortSpace(p);\n    //p.y += sin(p.z + p.x +time)*0.5;\n    p += vec3(0.5);\n    p = mod(p, vec3(1.6, 1.6, 100.)) - vec3(0.8, 0.8, 50.0);\n    float d = sdBox(p, vec3(0.001, 0.001, 100));\n    \n    return Hit(d, vec2(0.0), vec3(1.0), 0.0, 0.0, 0.0, d, vec3(0.2, 0.6, 1.0), 1.0);\n}\n\nHit map2(vec3 p) {\n    return opUnion(innerspace(p), myLight(p));\n}\n\nvec3 calcuNormal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + \n                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map2( ro + rd*t ).d;\n        res = min( res, 5.0*h/t );\n        t += clamp( h, 0.02, 0.2 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map2( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec4 render(vec3 ro, vec3 rd, vec2 samplepos) {\n    Hit hitdata;\n    float t = 0.1 + 0.2 * texture(iChannel0, samplepos*100.0+time).r;\n    float told = t, mid, dn;\n    float d = map2(rd*t + ro).d;\n    float sgn = sign(d);\n    \n    vec3 col = vec3(1.0, 0.0, 0.0);\n    vec3 bgCol = vec3(0.1);\n    bgCol = vec3(0.9, 0.4, 0.1)*1.5;\n    \n    // light source\n    vec3 lp = ro;\n    vec3 atm = vec3(0.0);\n    float att = 1.0;\n    \n    float forwardstep = FAR / float(MAX_RAYMARCHING_COUNT);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n        \n        vec3 sp = ro + rd*t;\n        vec3 sundir = lp - sp;\n        float sundist = length(sundir);\n        vec3 ld = normalize(sundir);\n        \n        hitdata = map2(rd*t + ro);\n        d = hitdata.d;\n        \n        \n        float illum = 0.0;\n        illum = 100.0 / (hitdata.lightD*hitdata.lightD+0.0001);\n        atm += illum * 0.00005 * att * hitdata.lightCol * hitdata.lightStrength;\n        \n        if (sign(d) != sgn || d < PRECISION) {\n        \n            if (sign(d) != sgn) {\n                hitdata = map2(rd*told + ro);\n                dn = sign(hitdata.d);\n                vec2 iv = vec2(told, t);\n                \n                for (int j = 0 ; j < 8 ; j++) {\n                    mid = dot(iv, vec2(.5));\n                    //float d = map2(rd*mid + ro);\n                    hitdata = map2(rd*t + ro);\n                    d = hitdata.d;\n                    if (abs(d) < PRECISION) break;\n                    iv = mix(vec2(iv.x, mid), vec2(mid, iv.y),step(0.0, d*dn));\n                }\n                t = mid;\n            }\n            \n            vec3 nor = normalize(calcuNormal(sp));\n            //nor = normalize(nor + 0.5*tex3D( iChannel1, sp*1.0, nor ));\n   \n            float shd = calcSoftshadow( sp, ld, 0.02, FAR );\n            float occ = calcAO( sp, nor );\n            \n            \n            vec3 hal = normalize( lp - rd );\n            float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n            float dif = max( dot( ld, nor ), 0.0);\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0)*dif;\n            \n            \n            // surface color\n            col = hitdata.col;\n            vec2 uv = hitdata.uv;\n            \n            vec3 lin = vec3(1.) * dif * shd;\n            lin += 0.8*amb*vec3(1.0)*occ;\n            lin += hitdata.spe*spe*vec3(1., 0.4, 0.2)*occ;\n            col *= lin;\n            \n            // Fog\n            col = mix(col, bgCol, smoothstep(1., FAR, pow(t,1.2)));\n            \n            break;\n        } else if (t >= FAR || i+1 == MAX_RAYMARCHING_COUNT) {\n            col = bgCol;\n            break;\n        }\n        \n        att *= 0.98;\n        \n        told = t;\n        t += min(d, forwardstep*1.0);\n        t = min(FAR, t);\n    }\n    // Light\n    col += atm*0.2;\n    col = pow(col, vec3(1.3));\n    \n    return vec4(col, t);\n}\n\nvoid campath(float t, out vec3 cam,  out vec3 lookAt,  out vec3 camup) {\n    cam = vec3(sin(t)*0.5, cos(t)*0.5, t*0.6);\n    lookAt = cam + vec3(0.0, 0.0, -0.1);\n    camup = vec3(cos(t*0.5), sin(t*0.5), 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    campath(time, ro, lookAt, camup);\n    mat3 viewMat = setCamera(ro, lookAt, camup);\n    \n    vec3 rd = viewMat * normalize(vec3(p, 0.5));\n    vec4 col = render( ro, rd, p );\n    \n    fragColor = col;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tstGzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsVGRz", "name": "Oddtiles (optimized)", "author": "stb", "description": "Procedural tiles, now a public shader.", "tags": ["procedural", "random", "bricks", "tiles", "tiles", "oddtiles", "odd"], "likes": 4, "viewed": 106, "date": "1569624964", "time_retrieved": "2024-06-20T19:44:23.673968", "image_code": "/*\tOddtiles (optimized)\n\t2019 stb\n \tMight still be somewhat unoptimized :)\n\tAlso discovered by Shane: https://www.shadertoy.com/view/Ws3GRs\n\tSearch the POV-Ray newsgroups and you may find procedural patterns and a CSG version of this, from waaay back.\n*/\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat rand(vec2 p){\n\treturn\n\t\tfract(\n\t\t\tsin(\n\t\t\t\tdot(\n\t\t\t\t\tp,\n\t\t\t\t\tvec2(12.9898, 78.233)\n\t\t\t\t)\n\t\t\t)*43758.5453\n\t\t);\n}\n\nvec4 oddTiles(vec2 p)\n{\n\tfloat C = rand(floor(p));\n\tfloat N, S, E, W, NE, SE, NW, SW;\n\t\n\tvec2 c1, c2;\n\tif(fract(p.x*.5) > .5 ^^ fract(p.y*.5) > .5)\n\t{\n\t\tif(fract(p.y)-C > .0)\n        {\n            N = rand(floor(p+vec2(0., 1.)));\n            if(fract(p.x) > N)\n\t\t\t{\n\t\t\t\tE = rand(floor(p+vec2(1., 0.)));\n                NE = rand(floor(p-vec2(-1., -1.)));\n                c1 = vec2(N, C);\n\t\t\t\tc2 = vec2(E+1., NE+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW = rand(floor(p-vec2(1., 0.)));\n                NW = rand(floor(p-vec2(1., -1.)));\n                c1 = vec2(W-1., C);\n\t\t\t\tc2 = vec2(N, NW+1.);\n\t\t\t}\n        }\n\t\telse\n        {\n            S = rand(floor(p-vec2(0., 1.)));\n            if(fract(p.x) > S)\n\t\t\t{\n\t\t\t\tE = rand(floor(p+vec2(1., 0.)));\n                SE = rand(floor(p-vec2(-1., 1.)));\n                c1 = vec2(S, SE-1.);\n\t\t\t\tc2 = vec2(E+1., C);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tW = rand(floor(p-vec2(1., 0.)));\n                SW = rand(floor(p-vec2(1., 1.)));\n                c1 = vec2(W-1., SW-1.);\n\t\t\t\tc2 = vec2(S, C);\n\t\t\t}\n        }\n\t}\n\telse\n\t{\n\t\tif(fract(p.x)-C > 0.)\n        {\n            E = rand(floor(p+vec2(1., 0.)));\n            if(fract(p.y) > E)\n\t\t\t{\n\t\t\t\tN = rand(floor(p+vec2(0., 1.)));\n                NE = rand(floor(p-vec2(-1., -1.)));\n                c1 = vec2(C, E);\n\t\t\t\tc2 = vec2(NE+1., N+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS = rand(floor(p-vec2(0., 1.)));\n                SE = rand(floor(p-vec2(-1., 1.)));\n                c1 = vec2(C, S-1.);\n\t\t\t\tc2 = vec2(SE+1., E);\n\t\t\t}\n        }\n\t\telse\n        {\n            W = rand(floor(p-vec2(1., 0.)));\n            if(fract(p.y) > W)\n\t\t\t{\n\t\t\t\tN = rand(floor(p+vec2(0., 1.)));\n                NW = rand(floor(p-vec2(1., -1.)));\n                c1 = vec2(NW-1., W);\n\t\t\t\tc2 = vec2(C, N+1.);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tS = rand(floor(p-vec2(0., 1.)));\n                SW = rand(floor(p-vec2(1., 1.)));\n                c1 = vec2(SW-1., S-1.);\n\t\t\t\tc2 = vec2(C, W);\n\t\t\t}\n        }\n\t}\n\treturn vec4(c1, c2);\n}\n\nfloat roundBoxPlusRand(in vec2 p, vec2 c1, vec2 c2, float rad)\n{\n\tvec2 c1_ = -c1 * sign(c2-c1);\n\tvec2 c2_ = c2 * sign(c2-c1);\n    float f = rand( (floor(p)-fract(c1+c2)/2.) );\n    return f * clamp(1.-length(max(abs(p-(c1+c2)/2.)-(c2_+c1_)/2.+rad, 0.))/rad, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvOrig = fragCoord.st;\n\t\n    vec2 uv = 16. * uvOrig / iResolution.x;\n    \n    uv.y -= iTime;\n    vec4 ot = oddTiles(uv);\n    float f;\n    f = roundBoxPlusRand(fract(uv), ot.xy, ot.zw, .2);\n    f = pow(f, .5);\n    vec3 tex = vec3(f, f*.75, f*.5);\n        \n    \n    fragColor = vec4(tex, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsVGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsy3Rz", "name": "Essa Pattern", "author": "MeDope", "description": "Just pattern from beer label xD", "tags": ["dotspatternbeer"], "likes": 4, "viewed": 102, "date": "1569766125", "time_retrieved": "2024-06-20T19:44:23.680087", "image_code": "#define col1 vec3(1., 1., 0.)\n#define col2 vec3(1., 0., 0.)\n\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(78.52, 34.7176))) * 47912.2979);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv.x += 100.;\n\tvec2 id = floor(uv * 18.);\n    vec2 move = vec2((cos((iTime + 3.57) * hash(id)*17.)*.5+.5), (cos((iTime + 5.57) * hash(id)*23.)*.5+.5));\n\tvec2 fuv = fract(uv * 18. + move * 0.1) - .5;\n    float dots = smoothstep(.4, .3, length(fuv));\n\tvec3 col = vec3(dots);\n\tcol = mix(col2 * col, mix(col1 * col, col, sin((iTime + 7.54)*hash(id)*2.)*.5+.5), smoothstep(-.5, .2, uv.y));\n\tcol *= vec3(cos((iTime + 8.67) * hash(id))*.5+.5) * 3.;\n    col += mix((1.-vec3(dots)) * col1, 1. - vec3(dots), sin(uv.y*3. - iTime*3.));\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsy3Rz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt2XDt", "name": "The Opera Game", "author": "Poita_", "description": "Ray-marched SDF for geometry, shadows, reflections with some volumetric mist and procedural sky. The game is Paul Morphy's famous Opera Game.", "tags": ["procedural", "sdf", "volumetric", "fog", "chess", "opera"], "likes": 51, "viewed": 940, "date": "1569868807", "time_retrieved": "2024-06-20T19:44:27.019662", "image_code": "// The Opera Game, by Peter Alexander.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The game is Paul Morphy's famous Opera Game.\n//\n// https://en.wikipedia.org/wiki/Opera_Game\n\n\n///////////////////\n// Feature flags //\n///////////////////\n\n// If performance isn't good enough then you can disable some of these.\n// MSAAx4 has the largest perf cost.\n#define RENDER_SKY true\n#define RENDER_MIST true\n#define RENDER_REFLECTIONS true\n#define RENDER_SHADOWS true\n#define MSAAx4 true\n\n////////////\n// Timing //\n////////////\n\nconst float INTRO_TIME = 5.0;\nconst float TIME_PER_POSITION = 2.0;\nconst float OUTRO_TIME = 7.0;\nconst float INTERMISSION = 1.5;\nconst int TOTAL_POSITIONS = 34;\nconst float TOTAL_TIME = INTRO_TIME + TIME_PER_POSITION * float(TOTAL_POSITIONS) + OUTRO_TIME + INTERMISSION;\n    \nfloat loopTime() {\n    return mod(iTime, TOTAL_TIME);\n}\n\nfloat introTime() {\n    return min(1.0, loopTime() / INTRO_TIME);\n}\n\nfloat moveTime() {\n\treturn max(0.0, loopTime() - INTRO_TIME);\n}\n\nfloat outroTime() {\n    return clamp(1.0 - (loopTime() - (TOTAL_TIME - INTERMISSION - OUTRO_TIME)) / OUTRO_TIME, 0.0, 1.0);\n}\n\nfloat timeOfMove(float m) {\n    return INTRO_TIME + m * TIME_PER_POSITION;\n}\n\n///////////\n// Noise //\n///////////\n\n// Adapted from https://www.shadertoy.com/view/4ts3z2\nfloat tri(float x) {\n    return abs(fract(x) - 0.5);\n}\n\nvec3 tri3(vec3 p) {\n   return abs(fract(p.zzy + abs(fract(p.yxx) - 0.5)) - 0.5);   \n}\n                                 \nfloat triNoise3D(in vec3 p, float spd) {\n    float z = 1.4;\n\tfloat rz = 0.0;\n    vec3 bp = p;\n\tfor (float i = 0.0; i <= 3.0; i++) {\n        vec3 dg = tri3(bp * 2.0);\n        p += (dg + iTime * .3 * spd);\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;    \n        rz += tri(p.z + tri(p.x + tri(p.y))) / z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n////////////////////\n// SDF primitives //\n////////////////////\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sphere2(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat ellipse(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat ellipse2(vec2 p, vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat box3(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat box2(vec2 p, vec2 r) {\n    vec2 d = abs(p) - r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.0)\n        return length(q) - r1;\n    if(k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 rad)  {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\t\n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0); // no intersection\n    return vec2(tN, tF);\n}\n\nfloat blend(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//////////////////////\n// SDF chess pieces //\n//////////////////////\n\nfloat pawn(vec3 p) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dt = sphere2(vec2(0, 1) - p2, 1.0);\n    float dn = ellipse2(vec2(0, -0.15) - p2, vec2(1.0, 0.3));\n    float dw0 = ellipse2(vec2(0, 0) - p2, vec2(0.5, 0.8));\n    float dw1 = ellipse2(vec2(0, -2.3) - p2, vec2(0.9, 0.3));\n    float dw2 = ellipse2(vec2(0, -2.1) - p2, vec2(1.4, 0.3));\n    float db0 = ellipse2(vec2(0, -2.3) - p2, vec2(1.2, 0.6));\n    float db1 = ellipse2(vec2(0, -3.3) - p2, vec2(2.0, 0.6));\n    float db2 = ellipse2(vec2(0, -3.8) - p2, vec2(2.1, 0.5));\n    float r = blend(dt, dn, 0.3);\n    r = min(r, blend(dw0, dw1, 3.0));\n    r = min(r, dw2);\n    r = min(r, blend(blend(db0, db1, 1.2), db2, 0.3));\n    return r;\n}\n\nfloat base(vec3 p, float rad) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.0) - p2, vec2(1.3 * rad, 1.0));\n    float db0 = ellipse2(vec2(0, -2.3) - p2, vec2(1.6 * rad, 0.6));\n    float db1 = ellipse2(vec2(0, -3.3) - p2, vec2(2.5 * rad, 0.6));\n    float db2 = ellipse2(vec2(0, -3.8) - p2, vec2(2.6 * rad, 0.5));\n    float dw = ellipse2(vec2(0, -2.1) - p2, vec2(1.8 * rad, 0.3));\n    float r = blend(blend(db0, db1, 1.0), db2, 0.3);\n    r = min(r, dw);\n    return r;\n}\n\nfloat base1(vec3 p) {\n    return base(p, 1.0);\n}\n\nfloat base2(vec3 p) {\n    float r = base(p, 1.2);\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.4) - p2, vec2(1.15, 2.7));\n    float dc = ellipse2(vec2(0, 2.0) - p2, vec2(1.6, 0.3));\n    float dc1 = ellipse2(vec2(0, 2.2) - p2, vec2(1.5, 0.2));\n    float dc2 = ellipse2(vec2(0, 2.8) - p2, vec2(1.2, 0.2));\n    float ds = ellipse2(vec2(0, 5.9) - p2, vec2(1.9, 2.8));\n    float dcut = box2(vec2(0, 7.2) - p2, vec2(3.0, 2.5));\n    r = blend(r, dn, 1.8);\n    r = blend(r, dc, 1.8);\n    r = min(r, dc1);\n    r = blend(r, dc2, 0.55);\n    r = blend(r, ds, 1.1);\n    return max(r, -dcut);\n}\n\nfloat rook(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.0) - p2, vec2(1.2, 1.3));\n    float dc = ellipse2(vec2(0, 0.5) - p2, vec2(1.7, 0.2));\n    float r = blend(base, dn, 1.0);\n    r = blend(r, dc, 1.4);\n    r = min(r, box2(vec2(1.4, 1.1) - p2, vec2(0.2, 0.6)));\n    vec3 b3 = p;\n    const float ang = 3.141593 * 2.0 / 3.0;\n    const mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    for (int i = 0; i < 3; ++i) {\n        r = max(r, -box3(vec3(0, 1.4, 0) - b3, vec3(2.0, 0.6, 0.2)));\n        b3.xz = rot * b3.xz;\n    }\n    return r;\n}\n\nfloat knight(vec3 p, float base) {\n    p.x = abs(p.x);\n    float ds1 = sphere(vec3(0.0, 2.0, 0.0) - p, 4.0);\n    float ds2 = ellipse(vec3(0.0, 2.0, 0.0) - p, vec3(2.0, 5.0, 1.8));\n    float dn = roundCone(vec3(-0.3, 1.0, 0.5) - p, 0.8, 2.2, 2.2);\n    float dncut = ellipse(vec3(2.2, 0.0, 0.0) - p, vec3(1.5, 2.5, 5.0));\n    const float a = 1.3;\n    const mat3 rot = mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n    float dh = roundCone(rot * (vec3(0.0, 2.5, 0.5) - p), 1.2, 0.6, 1.9);\n    float de = ellipse(vec3(0.5, 3.5, 0.5) - p, vec3(0.4, 0.5, 0.35));\n    float dhcut1 = 0.5 - p.x;\n    float dhcut2 = sphere(vec3(2.1, 2.8, -1.9) - p, 2.0);\n    float dhs = ellipse(vec3(0.0, 2.2, 0.0) - p, vec3(2.0, 1.3, 2.3));\n    float r2 = max(dn, -dncut);\n    float h = dh;\n    h = max(h, -dhcut1);\n    h = max(h, -dhcut2);\n    h = max(h, dhs);\n    h = min(h, max(de, -dhcut1));\n    r2 = blend(r2, h, 0.7);\n    return min(base, max(max(r2, ds1), ds2));\n}\n\nfloat bishop(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.4) - p2, vec2(1.0, 1.6));\n    float dc = ellipse2(vec2(0, 0.7) - p2, vec2(1.6, 0.3));\n    float dc1 = ellipse2(vec2(0, 0.9) - p2, vec2(1.5, 0.2));\n    float dc2 = ellipse2(vec2(0, 1.5) - p2, vec2(1.2, 0.2));\n    float dh = ellipse2(vec2(0, 2.6) - p2, vec2(1.3, 1.5));\n    float dt = ellipse2(vec2(0, 4.2) - p2, vec2(0.4, 0.4));\n    const float ang = -0.4;\n    const mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    vec3 c3 = vec3(0.8, 3.7, 0.0) - p;\n    c3.xy = rot * c3.xy;\n    float cut = box3(c3, vec3(0.2, 1.0, 2.0));\n    float r = blend(base, dn, 0.9);\n    r = blend(r, dc, 1.5);\n    r = min(r, dc1);\n    r = blend(r, dc2, 0.55);\n    r = min(r, dh);\n    r = min(r, dt);\n    return max(r, -cut);\n}\n\nfloat king(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dh = ellipse2(vec2(0, 4.6) - p2, vec2(1.8, 0.4));\n    float dt1 = box3(vec3(0, 5.2, 0) - p, vec3(0.3, 1.5, 0.25)); \n    float dt2 = box3(vec3(0, 5.8, 0) - p, vec3(1.0, 0.3, 0.25));    \n    float r = min(base, dh);\n    r = min(r, dt1);\n    return min(r, dt2);\n}\n\nfloat queen(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dh = ellipse2(vec2(0, 4.0) - p2, vec2(1.3, 1.5));\n    float dhcut = box2(vec2(0, 2.0) - p2, vec2(3.0, 2.0));\n    float dt = ellipse2(vec2(0, 5.6) - p2, vec2(0.5, 0.5));\n    vec3 pc = vec3(abs(p.x), p.y, abs(p.z));\n    if (pc.x > pc.z)\n        pc = pc.zyx;\n    float dccut = sphere(vec3(1.0, 4.7, 2.2) - pc, 1.1);\n    float r = min(base, max(dh, -dhcut));\n    return max(min(r, dt), -dccut);\n}\n\n// State of the board throughout the game.\n// Each square is 4 bits (13 possibilities: 6 white, 6 black, or empty)\n// Each row is an int (32 bits)\n// Each board is 8 ints.\n// Total 34 positions.\nint board(int m, int r) {\n    if (r == 0) {\n        if (m < 3) return 591750194;\n        if (m < 9) return 541418546;\n        if (m < 11) return 541393970;\n        if (m < 15) return 537199666;\n        if (m < 17) return 537199618;\n        if (m < 23) return 537198594;\n        if (m < 25) return 536880384;\n        if (m < 27) return 536872192;\n        if (m < 33) return 9472;\n        return 1280;\n    }\n    if (r == 1) {\n        if (m < 1) return 286331153;\n        if (m < 5) return 286265617;\n        return 286261521;\n    }\n    if (r == 2) {\n     \tif (m < 3) return 0;\n        if (m < 8) return 3145728;\n        if (m < 9) return 10485760;\n        if (m < 13) return 6291456;\n        if (m < 15) return 96;\n        if (m < 19) return 864;\n        if (m < 31) return 96;\n        return 0;\n    }\n    if (r == 3) {\n        if (m < 1) return 0;\n        if (m < 5) return 65536;\n        if (m < 6) return 69632;\n        if (m < 7) return 167841792;\n        if (m < 8) return 167837696;\n        if (m < 11) return 65536;\n        if (m < 21) return 66560;\n        return 65536;\n    }\n    if (r == 4) {\n        if (m < 2) return 0;\n        if (m < 7) return 458752;\n        if (m < 10) return 65536;\n        if (m < 17) return 458752;\n        if (m < 18) return 67567616;\n        if (m < 19) return 67567728;\n        if (m < 20) return 67567664;\n        if (m < 21) return 67567728;\n        if (m < 29) return 67567680;\n        return 67567616;\n    }\n    if (r == 5) {\n        if (m < 4) return 0;\n        if (m < 10) return 28672;\n        if (m < 12) return 0;\n        if (m < 16) return 9437184;\n        if (m < 20) return 9438976;\n        if (m < 28) return 9437184;\n        if (m < 30) return 10223616;\n        return 786432;\n    }\n    if (r == 6) {\n        if (m < 2) return 2004318071;\n        if (m < 4) return 2003859319;\n        if (m < 14) return 2003830647;\n        if (m < 16) return 2004617079;\n        if (m < 18) return 2004615287;\n        if (m < 22) return 2004615175;\n        if (m < 25) return 2004652039;\n        if (m < 26) return 2004623367;\n        if (m < 28) return 2004647943;\n        if (m < 29) return 2003861511;\n        if (m < 30) return 2003845127;\n        if (m < 32) return 2003865607;\n        return 2003828743;\n    }\n    if (m < 6) return -1985230184;\n    if (m < 12) return -1985232744;\n    if (m < 14) return -2136227688;\n    if (m < 22) return -2136276840;\n    if (m < 24) return -2136276984;\n    if (m < 26) return -2136244224;\n    if (m < 31) return -2136276992;\n    if (m < 32) return -2136276896;\n    if (m < 33) return -2136276848;\n    return -2136268656;\n}\n\n// Materials.\nconst float BOARD_MAT = 0.0;\nconst float WHITE_MAT = 1.0;\nconst float BLACK_MAT = 2.0;\n\n// Cache of board position.\n// Set at the start of mainImage.\nint[8] board_cache;\n\n// SDF evaluation of the board.\n// Returns (distance, material).\nvec2 sdf(vec3 p) {\n    // A hack: for efficiency, we only evaluate piece distance for the piece\n    // in the current square. If there is no piece in the current square then\n    // we return INF distance as a lower-bound distance to pieces in adjacent squares\n    // without needing to evaluate them.\n    const float INF = 1.0;\n\n    float r = min(INF, p.y + 4.0);\n    vec2 res = vec2(r, BOARD_MAT);\n\n    // Discretize coordinates onto board.\n    vec2 ip = p.xz / 8.0 + 4.0;\n    int ix = int(ip.x) & 7;\n    int iy = int(ip.y) & 7;\n    int piece = (board_cache[7 - iy] >> (ix * 4)) & 0xF;\n    if (piece == 0)\n        return vec2(min(res.x, INF), res.y);\n    \n    vec2 pp2 = mod(p.xz, 8.0) - 4.0;\n    vec3 pp3 = vec3(pp2.x, p.y, pp2.y);\n    float is_white = piece < 7 ? 1.0 : 0.0;\n    piece = (piece - 1) % 6;\n    pp3.z *= (is_white * 2.0 - 1.0); // black knight are flipped on z-axis\n    \n    float d_piece;\n    if (piece == 0)\n        d_piece = pawn(pp3);\n    else if (piece == 1)\n        d_piece = rook(pp3, base1(pp3));\n    else if (piece == 2)\n        d_piece = knight(pp3, base1(pp3));\n    else if (piece == 3)\n        d_piece = bishop(pp3, base1(pp3));\n    else if (piece == 4)\n        d_piece = king(pp3, base2(pp3));\n    else\n        d_piece = queen(pp3, base2(pp3));\n\n    float bound = max(abs(p.x) - 32.0, abs(p.z) - 32.0);\n    r = max(bound, d_piece);\n\n    if (r < res.x)\n        res = vec2(r, BLACK_MAT - is_white);\n    \n    return res;\n}\n\nvec3 norm(vec3 p) {\n    // Tetrahedron technique\n    vec3 n = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n/////////////\n// Shading //\n/////////////\n\nconst vec3 SKY = vec3(0.16,0.20,0.28) * 0.1;\nconst vec3 LIGHT = vec3(1.64, 1.27, 0.99);\nconst vec3 LIGHT_DIR = normalize(vec3(1.2, -1, 2));\nconst vec3 INDIRECT = LIGHT * 0.1;\nconst vec3 INDIRECT_DIR = normalize(-LIGHT_DIR * vec3(-1.0, 0.0, -1.0));\n\n// Ray march for shadows.\nfloat shadowray(vec3 pos) {\n    if (!RENDER_SHADOWS)\n        return 1.0;\n\n    float res = 1.0;\n    float t = 0.2;\n    for (int i = 0; i < 50; i++) {\n\t\tfloat h = sdf(pos + -LIGHT_DIR * t).x;\n        res = min(res, 16.0 * h / t);\n        t += clamp(h, 0.05, 0.4);\n        if (res < 0.05)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 albedo, vec3 n, vec3 pos, vec3 dir, float ks, bool shadows) {\n    float shadow = shadows ? shadowray(pos) : 1.0;\n    float light_diffuse = clamp(dot(n, -LIGHT_DIR), 0.0, 1.0);\n    vec3 light_half = normalize(-LIGHT_DIR - dir);\n    float sky = sqrt(clamp(0.5 + 0.5 * n.y, 0.0, 1.0));\n    vec3 ref = reflect(dir, n);\n    float frenel = clamp(1.0 + dot(n, dir), 0.0, 1.0);\n    float indirect = clamp(dot(n, INDIRECT_DIR), 0.0, 1.0);\n    \n    vec3 light = vec3(0.0);\n    light += light_diffuse * LIGHT * shadow;\n    light += sky * SKY;\n    light += indirect * INDIRECT;\n    vec3 col = light * albedo;\n    col += ks * smoothstep(0.0, 0.5, ref.y) * (0.04 + 0.96 * pow(frenel, 4.0)) * SKY;\n\tcol += shadow * ks * pow(clamp(dot(n, light_half), 0.0, 1.0), 8.0) * light_diffuse * (0.04 + 0.96 * pow(clamp(1.0 + dot(light_half, dir), 0.0, 1.0), 3.0)) * LIGHT * 5.0;\n\treturn col;\n}\n\n/////////////////\n// Mist effect //\n/////////////////\n\nfloat fogDensity(vec3 p) {\n    const vec3 fdir = normalize(vec3(10,0,-7));\n    float f = clamp(1.0 - 0.5 * abs(p.y - -4.0), 0.0, 1.0);\n    f *= max(0.0, 1.0 - length(max(vec2(0.0), abs(p.xz) - 28.0)) / 7.0);\n    p += 4.0 * fdir * iTime;\n    float d = triNoise3D(p * 0.007, 0.2) * f;\n    return d * d;\n}\n\nfloat integrateFog(vec3 a, vec3 b) {\n    if (!RENDER_MIST)\n        return 0.0;\n    vec3 d = normalize(b - a);\n    float l = length(b - a);\n \tvec2 trange = boxIntersect(a - vec3(0.0, -3.0, 0.0), d, vec3(36.0, 1.0, 36.0));\n\tif (trange.x < 0.0)\n        return 0.0;\n    trange = min(trange, vec2(l));\n    const float MIN_DIS = 0.2;\n    const float MAX_DIS = 2.0;\n    const float MIN_SAMPLES = 3.0;\n    float tdiff = trange.y - trange.x;\n    float samples = max(MIN_SAMPLES, tdiff / MAX_DIS);\n    float dis = clamp(tdiff / samples, MIN_DIS, MAX_DIS);\n    samples = ceil(tdiff / dis);\n    dis = tdiff / (samples + 1.0);\n    float visibility = 1.0;\n    for (float t = trange.x + 0.5; t < trange.y; t += dis) {\n        float density = fogDensity(a + t * d);\n        visibility *= pow(3.0, -1.0 * density * dis);\n    }\n\treturn 1.0 - visibility;\n}\n\n//////////////////\n// Ray marching //\n//////////////////\n\n// Ray march for reflections.\n// Somewhat more simplified than castray for perf.\nvec3 castray2(vec3 pos, vec3 dir) {\n    if (!RENDER_REFLECTIONS)\n        return SKY;\n    float tmax = (7.0 - pos.y) / dir.y;\n    int i = 0;\n\tfor (float t = 0.1; t < tmax && i < 50; ++i) {\n        vec3 p = pos + t * dir;\n\t\tvec2 res = sdf(pos + t * dir);\n        float d = res.x;\n        float mat = res.y;\n\t\tif (d < 0.001) {\n            vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);\n            return shade(albedo, norm(p), p, dir, 1.0, false);\n\t\t}\n\t\tt += d;\n\t}\n    return SKY;\n}\n\n// Shading for the board.\nvec3 floorColor(vec2 p, vec3 ray) {\n    // checkerboard color\n    float xr = p.x / 16.0;\n    float yr = p.y / 16.0;\n \tint x = fract(xr) < 0.5 ? 0 : 1;\n    int y = fract(yr) < 0.5 ? 0 : 1;\n    int w = x ^ y;\n    vec3 albedo = (w & 1) == 0 ? vec3(0.2) : vec3(0.04);\n    \n    const vec3 normal = vec3(0, 1, 0);\n    \n    // reflection\n    vec3 rpos = vec3(p.x, -4.0, p.y);\n    vec3 rdir = reflect(ray, normal);\n    vec3 rcolor = castray2(rpos, rdir);\n    \n    // shading\n    albedo = mix(albedo, rcolor, 0.2);\n    vec3 color = shade(albedo, normal, rpos, ray, 0.1, true);\n    \n    return color;\n}\n\n// Main ray march from eye.\nvec3 castray(vec3 pos, vec3 dir) {\n    vec3 c = vec3(0.0);\n    vec2 trange = boxIntersect(pos - vec3(0, 1.4, 0), dir, vec3(36.0, 5.5, 36.0));\n    vec3 p = pos;\n    float mat = -1.0;\n    if (trange.y > 0.0) {\n        int i = 0;\n        float t = trange.x;\n        for (; t < trange.y && i < 150; ++i) {   \n            p = pos + t * dir;\n            vec2 res = sdf(p);\n            float d = res.x;\n            if (d < 0.05) {\n                if (max(abs(p.x), abs(p.z)) > 32.0)\n                    break;\n                mat = res.y;\n                if (mat == BOARD_MAT) {\n                    c = floorColor(p.xz, dir);\n                    break;\n                }\n                vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);\n                albedo += vec3(.1,.1,.05) * (mat == BLACK_MAT ? 0.5 : 2.2) * (0.2 * sin(15.0 * p.x + 25.0 * sin(2.0 * p.z)));\n                c = shade(albedo, norm(p), p, dir, 1.0, true);\n                break;\n            }\n            t += d;\n        }\n        t = min(t, trange.y);\n        p = pos + t * dir;\n    }\n    if (RENDER_SKY && mat < 0.0) {\n        // Sky\n        const vec3 C1 = vec3(0.12, 0.08, 0.08);\n        const vec3 C2 = vec3(0.04, 0.03, 0.06) * 2.0;\n        float y = dir.y + 0.2 * triNoise3D(dir * 2.0, 1.0);\n        c = mix(C1, C2, smoothstep(-0.35, 0.0, y));\n        float disp = triNoise3D(dir * 0.9, 0.08);\n        c += vec3(1.0) * (pow(disp, 5.0) * 3.47);\n        \n        // Fade to black\n        float h = dot(dir - 0.08 * triNoise3D(dir * 0.3, 0.0), vec3(0.02, 1.0, -0.01));\n        float hstart = -0.2;\n        float hend = -0.5;\n        c = mix(c, vec3(0.0), smoothstep(hstart, hend, h));\n    }\n    \n    // Mist\n    float fog = integrateFog(pos, p);\n    const vec3 FOG_COLOR = vec3(1.5, 1.1, 0.9);\n    return mix(c, FOG_COLOR, clamp(fog, 0.0, 1.0));\n}\n\n////////////\n// Camera //\n////////////\n\nvec2 normScreenSpace(vec2 fragCoord) {\n    return (fragCoord / iResolution.xy - 0.5) * (iResolution.xy / iResolution.x);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 look(vec2 fragCoord) {\n\tvec2 uv = normScreenSpace(fragCoord);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    float a = loopTime() * 0.3;\n    vec3 ro = vec3(120.0 * -sin(a * 0.5), 45.0 + 10.0 * sin(a - 0.4), 120.0 * cos(a * 0.5));\n    vec3 target = vec3(0, 3, 0);\n  \tmat3 m = setCamera(ro, target, 0.0);\n    vec3 c = castray(ro, m * rd);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Warp time by position to get a disintegrate move effect.\n    float t = moveTime() / TIME_PER_POSITION + 0.8 * triNoise3D(vec3(3.0 * normScreenSpace(fragCoord), 0.0), 0.0);\n    int move = min(33, int(t));\n    \n    // Precache board layout.\n    for (int i = 0; i < 8; ++i)\n        board_cache[i] = board(move, i);\n\n    // MSAA\n\tint AA = MSAAx4 ? 4 : 1;\n    vec3 c = vec3(0.0);\n    vec2 delta = MSAAx4 ? vec2(0.3, 0.4) : vec2(0.0);\n    for (int i = min(0, iFrame); i < AA; ++i) {\n    \tc += look(fragCoord + delta);\n        delta = vec2(delta.y, -delta.x);\n    }\n    c /= float(AA);\n    \n    float fade = min(1.0, 3.0 * min(introTime(), outroTime()));\n    \n    c *= vec3(0.95, 0.8, 1.1); // color grade   \n    c *= fade;\n    c = pow(c, vec3(0.4545)); // gamma\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tt2XWd", "name": "Slither.io Hexagons", "author": "jaburns", "description": "hexagons", "tags": ["hexagons"], "likes": 2, "viewed": 217, "date": "1567558112", "time_retrieved": "2024-06-20T19:44:27.662223", "image_code": "\n\n#define BASE_LAYER_COLOR (vec3(16,25,38) / 255.)\n#define TOP_LAYER_COLOR  (0.2*vec3(28,42,59) / 255.)\n\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// ===== Grain ============================\n\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(random(ip),random(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(random(ip+vec2(0.0,1.0)),random(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat getGrainAmount(vec2 uv)\n{\n    return noise(uv*5000.0);\n}\n\n\n// ===== Hexagon ============================\n\n\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\nconst float borderThickness = .02;\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p);\n    return max(dot(p, s * .5), p.x);\n}\n\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nfloat getHexDistanceField(vec2 uv)\n{\n    vec4 hexInfo = calcHexInfo(uv);\n    float totalDist = clamp((calcHexDistance(hexInfo.xy) + borderThickness) / 0.52, 0.0, 1.0);\n    return totalDist;\n}\n\nvec2 getHexCoordinates(vec2 uv)\n{\n    vec4 hexInfo = calcHexInfo(uv);\n    return hexInfo.xy;\n}\n\nvec2 getHexIndex(vec2 uv)\n{\n    vec4 hexInfo = calcHexInfo(uv);\n    return hexInfo.zw;\n}\n\n\n// ===== Coordinates ==============================\n\n\n\nvec2 getUV(vec2 fragCoord)\n{\n    float th = -0.15;\n    fragCoord = mat2(cos(th), sin(th), -sin(th), cos(th)) * fragCoord;\n    return 3. * (2. * fragCoord - iResolution.xy) / iResolution.y;\n}\n\n\n// ===== Main ==============================\n\nfloat getPointSeven(vec2 uv)\n{\n    vec2 index = getHexIndex(uv);\n    return 0.7+0.1*sin(2.*iTime + .5*(index.x-index.y));\n}\n\n\nvec3 getBaseLayer(vec2 uv)\n{\n    return BASE_LAYER_COLOR + (0.05*getGrainAmount(uv)-0.05);\n}\n\nvec3 getShadowLayer(vec2 uv)\n{\n    uv.x += 0.02;\n    uv.y += 0.07;\n    float dist = getHexDistanceField(uv) - getPointSeven(uv);\n    dist = clamp(dist, -0.1, 0.1);\n    \n    return vec3(-0.25*(0.1-dist));\n}\n\nvec3 getTopHexagonLayer(vec2 uv)\n{\n    if (getHexDistanceField(uv) > getPointSeven(uv)) \n        return getShadowLayer(uv);\n    \n    float th = 0.35;\n    \n    vec2 hexCoords = mat2(cos(th), sin(th), -sin(th), cos(th)) \n        * getHexCoordinates(uv);\n    \n    return TOP_LAYER_COLOR + mix(-0.15, 0.15, 0.5*(hexCoords.y+1.0));\n}\n\nfloat getBorderAmount(vec2 uv)\n{\n    float dist = getHexDistanceField(uv);\n    return clamp(20.0*abs(dist - getPointSeven(uv)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = getUV(fragCoord);\n        \n    vec3 baseLayer = getBaseLayer(uv);\n    vec3 topHexagonLayer = getTopHexagonLayer(uv);\n    float borderAmount = getBorderAmount(uv);\n    \n    vec3 color = borderAmount * (baseLayer + topHexagonLayer);\n    \n    fragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tt2XWd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttBSDR", "name": "Glitch#08", "author": "104", "description": "Character RAM bank switching?", "tags": ["2d", "glitch"], "likes": 20, "viewed": 414, "date": "1568991989", "time_retrieved": "2024-06-20T19:44:27.668301", "image_code": "\nconst vec2 z = vec2(1);\nconst float complexity =5.;\nconst float density = .9;\nconst float speed = 1.;\n\nconst float PI = atan(1.)*4.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n#define q(x,p) (floor((x)/(p))*(p))\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = C/R.xy;\n    vec2 N = uv-.5;\n    float t = iTime+1e2;\n    uv.x *= R.x/R.y;\n    uv *= z;\n    uv += floor(iTime*speed)*z;\n    float s = 1.;\n\n    for (float i = 1.;i <= complexity; ++ i) {\n        vec2 c = floor(uv+i);\n        vec4 h = hash42(c);\n        vec2 p = fract(uv+i+q(t,h.z+1.)*h.y);\n        uv+= p*h.z*h.xy*vec2(s,2.);\n        uv *= 2.;\n        if (i < 2. || h.w > density) {\n            o = h;\n        }\n    }\n    o=step(.5,o) * mod(C.x,3.)/2.;\n    o *= 1.-dot(N,N*2.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttBSDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttsGW8", "name": "Menger squares", "author": "kindpotato", "description": "Eazy peazy. spam", "tags": ["fractalmengersponge"], "likes": 2, "viewed": 57, "date": "1569125509", "time_retrieved": "2024-06-20T19:44:27.668301", "image_code": "#define third 0.3333333333\n\nbool coloured(vec2 uv){\n    \n    return uv.x < third || uv.x > 2.*third || uv.y < third || uv.y > 2.*third;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float zoom = mod(30.*iTime,109.);\n    uv*= pow(0.99,zoom);\n    fragColor = vec4(1);\n    float its = log(iResolution.y)/log(3.);\n\n    for(float i = 0.; i < its; i+=1.){\n        if (coloured(uv)){\n            uv = fract(3.*uv);\n        }\n        else{\n        \tfragColor = vec4(0,0,0,1);\n            return;\n        }\n    } \n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttSSW3", "name": "Magic Lamp", "author": "ikuto", "description": " ", "tags": ["3d", "raymarching", "noise", "light", "volumetric", "tranlucent"], "likes": 10, "viewed": 384, "date": "1567775629", "time_retrieved": "2024-06-20T19:44:28.826008", "image_code": "#define PI 3.1415927\n\nstruct Light\n{\n    vec3  pos;\n    vec3  col1, col2;\n    float rad1, rad2;\n    mat3  rotMat;\n};\n\nLight lights[4];\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRing(vec3 p, float r1, float r2)\n{\n    vec2 v = vec2(abs(length(p.xy)-r1), p.z);\n    return length(v)-r2;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float d = max(k-abs(a-b), 0.0);\n    return min(a,b) - d*d/k/4.0;\n}\n\nvec2 sincos(float t) { return vec2(sin(t), cos(t));}\n\nvec2 mapScene(vec3 p)\n{\n    float objID = 1.0;\n\n    //rings\n    float d = sdRing(p, 1.0, 0.03);\n    d = smin(d, sdRing(lights[2].rotMat*p, 1.0, 0.03), 0.02);\n    d = smin(d, sdRing(lights[3].rotMat*p, 1.0, 0.03), 0.02);\n    \n    vec3 p2 = p-vec3(0.0,-1.9,0.0);\n    float h = 1.0;\n    float x = (1.0-clamp((p2.y+h)/(2.0*h), 0.0, 1.0));\n    float r = 0.05*(15.0*pow(x,6.0)+1.0);\n\n    //body\n    float d2 = sdCappedCylinder(p2, h, r);\n    d2 = smin(d2, length(p2-vec3(0.0,1.0,0.0))-0.1, 0.05);\n    vec3 p3 = p2-vec3(0.0,0.0,0.0); p3.y *= 2.0;\n    d2 = smin(d2, length(p3)-0.18, 0.2);\n    p3= p2-vec3(0.0,-0.3,0.0); p3.y *= 2.0;\n    d2 = smin(d2, length(p3)-0.2, 0.2);\n    \n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,2.0,0.0), 0.06, 0.4), 0.2);\n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,1.75,0.0), 0.06, 0.6), 0.2);\n    d2 = smin(d2, sdCappedCylinder(p3-vec3(0.0,1.5,0.0), 0.1, 0.5), 0.2);\n    if (d2 < d) objID = 2.0;\n    d = min(d, d2);\n    \n    return vec2(d, objID);\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    vec3 dt = vec3(0.01, 0.0, 0.0);\n    return normalize( vec3(\tmapScene(p+dt.xyy).x-mapScene(p-dt.xyy).x,\n                         \tmapScene(p+dt.yxy).x-mapScene(p-dt.yxy).x,\n                          \tmapScene(p+dt.yyx).x-mapScene(p-dt.yyx).x ) );\n}\n\nfloat calculateAO(vec3 pos, vec3 normal)  //ambient occlusion\n{\n    float ao = 0.0, sca = 1.0;\n    for (int i = 0; i < 5; ++i)\n    {\n   \t\tfloat h = 0.01 + 0.11*float(i)/4.0;\n        vec3 p = pos + h * normal;\n        float d = mapScene(p).x;\n        ao += (h-d)*sca;\n        sca *= 0.95;\n    }\n    \n    return pow(clamp(1.0-2.0*ao, 0.0, 1.0), 2.0);\n}\n\nvec3 noise(vec3 pos, vec3 nor)\n{\n\tvec3 x = texture(iChannel0, pos.yz).xyz;\n\tvec3 y = texture(iChannel0, pos.zx).xyz;\n\tvec3 z = texture(iChannel0, pos.xy).xyz;\n\treturn x*abs(nor.x) + y*abs(nor.y) + z*abs(nor.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 background(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 noise = hash31(float(i)*215.4);\n        vec3 lv = (10.0*noise-5.0) - ro;\n        float ll = length(lv);\n        float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n        float t = (1.0-smoothstep(0.0, 1.5 + 1.0*noise.x, angle*ll));\n        color += 0.05 * (0.6*noise+vec3(0.1)) *pow(t, 4.0); \t\n    }\n    return color;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //init lights\n    float st = 0.8 + 0.1*sin(5.0*iTime);\n    lights[0] = Light(vec3(0.0), 0.5*vec3(0.5,1.0,1.0), 8.0*vec3(0.5,1.0,1.0), 4.0*st, 0.8*st, mat3(0.0));\n    lights[1] = Light(vec3(0.0), 0.5*vec3(1.0,0.0,0.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    lights[2] = Light(vec3(0.0), 0.5*vec3(0.0,1.0,0.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    lights[3] = Light(vec3(0.0), 0.5*vec3(0.0,0.0,1.0), 2.0*vec3(1.0), \t\t   0.8*st, 0.4, mat3(0.0));\n    \n    //update lights\n    float t = iTime-0.5;\n\tlights[1].pos = vec3(sincos(t), 0.0);\t    \t\n    lights[2].rotMat = rotate(vec3(1.0,0.2,0.0), PI/3.0);\n    lights[2].pos = vec3(sincos(t-PI/1.5), 0.0) * lights[2].rotMat;\n    lights[3].rotMat = rotate(vec3(1.0,-0.2,0.0), -PI/3.0);\n    lights[3].pos = vec3(sincos(-t-PI/0.75), 0.0) * lights[3].rotMat;\n    \n  \tvec3 color = background(ro, rd);\n    //ray marching\n    float tmin = 0.1, tmax = 8.0;\n    vec2 res;\n    for (float t = tmin; t < tmax;)\n    {\n        vec3 pos = ro + t * rd;\n        res = mapScene(pos);\n        float dist = res.x;\n        \n        if (dist < 0.05)\n        {\n            vec3 nor = calculateNormal(pos);\n            float ao = calculateAO(pos, nor);\n            \n            vec3 albedo = vec3(0.0);\n            if (res.y < 1.5)\n            {\n            \talbedo = vec3(5.0);\n            }\n            else if (res.y < 2.5)\n            {\n                albedo = vec3(1.0);\n                float w = 0.5 + 0.5*sin(iTime);\n            \tnor = normalize(nor + 0.5*w*(noise(w*pos, nor)-0.5)); //alter normal\n            }\n                \n            if (dist < 0.02)\n            {\n            \tfor (int i = 0; i < 4; ++i) //apply lights\n            \t{\n                \tvec3  l = lights[i].pos - pos;\n                    float d = length(l);\n                    float attenuation = 1.0 / (0.2*d*d+0.5*d+1.0);\n                    float diffuse = max(0.0,dot(normalize(l),nor));\n                    float sepcular = pow(max(dot(normalize(reflect(l,nor)),rd),0.0), 16.0);\n\n                    vec3 col = 0.01*albedo * lights[i].col2 * diffuse;\n                    col += 4.0*sepcular*lights[i].col1;\n                    col *= attenuation * pow(ao,4.0);\n                    color += 0.07 * col;\n                }\n            }\n\n            color += 0.002*vec3(0.0,1.0,0.9)*pow(1.0-smoothstep(0.0, 0.1, dist), 1.0);\n        }\n        \n        t += max(0.005, (dist-0.1)*0.5);\n    }\n    \n    for (int i = 0; i < 4; ++i) //draw lights\n    {\n        vec3 lv = lights[i].pos - ro;\n        float ll = length(lv);\n        float angle = acos(clamp(dot(rd, lv/ll), 0.0, 1.0));\n        float t = (1.0-smoothstep(0.0, lights[i].rad1, angle*ll));\n        color += lights[i].col1*pow(t, 4.0);\n        t = (1.0-smoothstep(0.0, lights[i].rad2, angle*ll));\n        color += lights[i].col2*pow(t, 4.0);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float an = PI/2.0 + 0.4*iTime;\n    \n    vec3  rayOri = 4.0 * vec3(sin(an), 0.1, cos(an));\n    mat3  viewMat = lookAt(rayOri, vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0));\n    vec3  rayDir = viewMat * normalize(vec3(uv, -1.5));\t//rotate camera\n    \n    vec3 color = render(rayOri, rayDir);\n    \n    //gamma correction\n    color = pow(color, vec3(0.4545)); \n    \n    //contrast\n\tcolor = clamp(color, 0.0, 1.0);\n\tcolor = color * color * (3.0 - 2.0 * color);\n\n\t//saturation\n\tfloat sat = 0.2;\n\tcolor = color * (1.0 + sat) - sat * dot(color, vec3(0.33));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttSSW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ttXSWN", "name": "shaderattempt3", "author": "mardinator2", "description": "asdf", "tags": ["asdf"], "likes": 2, "viewed": 78, "date": "1568165807", "time_retrieved": "2024-06-20T19:44:29.086591", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n\tp.x *= iResolution.x/iResolution.y;\n\n   uv -= vec2 (0.9, 0.9)*(iTime*0.009);\n    float r = sqrt ( dot (uv,uv));\n    float a = atan ( uv.y, uv.x) + iTime*0.1;\n    float s = 0.1 + 0.1*sin ( 5.0*a);\n    float t = 0.15 + 0.15*pow ( s, 0.3);\n    t += 0.1*pow ( 0.5 + 0.5*cos ( 9.0*a), 0.5);\n    float h = r/t;\n    float f = 0.0;\n    \n    p.y = p.y + 1.0*sin(iTime*PI);\n    p.x = p.x + 1.0*sin(iTime);\n    \n    p.y = p.y*10.0 + sin(iTime*1.);\n    p.x = p.x*5.0 + sin(iTime*5.);\n    float ss = 0.5 + 0.5*sin (2.0*iTime);\n    float anim = 1.0 + 0.1*ss*clamp ( 1.0-r, 0.5, 1.0);\n    h *= anim;\n    \n    if ( h < 1.0) \n    {\n        f = 1.0;\n    }\n    \n    \n    \n    // Time varying pixel color\n    vec3 col = 0.1 + 1.5*sin(iTime+uv.xyx+vec3(0,2,9)*h) * 1.0*cos(iTime+uv.xyx+vec3(0,2,0)*h);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ttXSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd33DH", "name": "OOOFF", "author": "Bouyer", "description": "my first shadertoy", "tags": ["oof"], "likes": 3, "viewed": 306, "date": "1568363785", "time_retrieved": "2024-06-20T19:44:29.086591", "image_code": "\nmat3 rot(vec3 angles)\n{   \n    float theta = angles.y;\n    float c = cos(theta);\n    float s = sin(theta);\n    mat3 m = mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    \n    theta = angles.x;\n    c = cos(theta);\n    s = sin(theta);\n    m *= mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n    \n    theta = angles.z;\n    c = cos(theta);\n    s = sin(theta);\n    m *= mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n    \n    return m;\n}\n\nvec3 warp(vec3 p)\n{\n    mat3 m = rot((floor((p + 4.) / 8.) + vec3(0., -1., 0.)) * iTime);\n    \n    vec3 rep = mod(p + vec3(4.), 8.) - vec3(4.);\n    return m * rep;\n}\n\nfloat sdf(vec3 p)\n{\n    p = warp(p);\n    float h2 = 1.;\n    float r = 1.;\n    float inflate = .5;\n    \n    float capDist = max(abs(p.y) - h2, 0.);\n    float sideDist = max(length(p.xz) - r, 0.);\n    return sqrt(pow(sideDist, 2.) + pow(capDist, 2.)) - inflate;\n}\n\nfloat eyeSDF(vec3 p, vec2 eyePos)\n{\n    return length(vec2(2, 1) * (p.xy - eyePos)) - .2;\n}\n\nfloat mouthSDF(vec3 p)\n{\n    float thickness = .05;\n    \n    float ringDist = max(abs(length(p.xy * vec2(1.6, 1)) - 1.) - thickness, 0.);\n    float hideFactor = max(p.y + .4, 0.);\n    \n    \n    return ringDist + hideFactor;\n}\n\nvec3 albedoSDF(vec3 p)\n{\n    p = warp(p);\n    float eyeDist = min(eyeSDF(p, vec2(.33, .7)), eyeSDF(p, vec2(-.33, .7)));\n    eyeDist = min(eyeDist, mouthSDF(p));\n    \n    float factor = clamp(eyeDist * 10., 0., 1.);\n    if (p.z < 0.)\n        factor = 1.;\n    \n    return mix(vec3(0.05, 0.05, 0.1), vec3(1., .85, .2), factor);\n}\n\nvec3 nsdf(vec3 p)\n{\n    vec2 H = vec2(0., 0.01);\n    return normalize(vec3(sdf(p + H.yxx), sdf(p + H.xyx), sdf(p + H.xxy)) - sdf(p));\n}\n\nvec3 lighting(vec3 albedo, vec3 n)\n{\n    float NL = max(dot(n, vec3(1., 1., 1.)), 0.) * .8;\n    return (NL + .1) * albedo;\n}\n\nmat3 view()\n{\n    return rot(.02 * vec3(sin(iTime * .5672), sin(iTime * .1414), sin(iTime * 0.114) * 0.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\t\n    vec3 O = vec3(0., mod(-iTime * 20., 64.) * 0., 5.);\n    vec3 D = view() * normalize(vec3(uv.x, uv.y, -1.));\n    \n    float l = 0.0;\n    vec3 p;\n    float d;\n    for (int i = 0; i < 100; i++)\n    {\n        p = O + D * l;\n        d = sdf(p);\n        l += d;\n    }\n    \n    vec3 n = nsdf(p);\n    vec3 albedo = albedoSDF(p);\n    \n    if (d > .01)\n        fragColor = vec4(0.);\n    else\n    \tfragColor = vec4(lighting(albedo, n), 1.0);\n    \n    float fogFactor = clamp(l / 100., 0., 1.);\n    fragColor = mix(fragColor, vec4(0.), fogFactor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd33DH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd33Dr", "name": "Dip [Animated Portrait]", "author": "ompuco", "description": "Really dirty shader code with the intent to make a somewhat lively animation of my imp character, Dip.\nMight revisit it later and rewrite it all, since a lot of it is kinda frankenspaghetticode from rapid prototyping.\n\nV proud of my son, tho!\nowo", "tags": ["raymarching", "sdf", "animation", "character"], "likes": 6, "viewed": 393, "date": "1568165846", "time_retrieved": "2024-06-20T19:44:30.195630", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec3 Zigzag(vec3 pos, float freq, float offset){\n    float i = (pow(offset+abs(pos.x),.8));\n    float x = freq-abs(mod(i,2.0*freq)-freq);\n    pos.y+=(x);\n    return pos;\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n\n\nfloat map(vec3 p) {\n    //p.x+=sin(p.y*2.0+iTime*4.0)/8.0;\n    \n    float head=sdRoundedCylinder(p+vec3(.0,.05,-.050),.375,.6,.01);\n\n    vec3 p2 = p;p2.x=abs(p2.x);p2.y/=1.4;\n\n    vec3 p3 = p;p3.z*=1.12;\n    //p3.x-=sin(iTime*2.0)/4.0;\n    //p3.x-=sin(p3.y+iTime*2.0)/8.0;\n    //p3.z+=step(p.z,.0)*sin(p3.y)/8.0;\n    p3.z-=smoothstep(.0,1.0,p3.y)/8.0;\n\t\n    \n    float body = sdRoundedCylinder(p3+vec3(.0,1.7,.350+sin(p3.y)/8.0),.3,1.7,.103);\n\t    p3.yz=rotate(p3.yz,.105);\n\n    body = opSmoothUnion(body, sdRoundedCylinder(p3+vec3(.0,.9,.150),.25,1.7,.103),.1);\n    \n    float d=opSmoothUnion(body,head,.15);\n     \n    float horns = sdOctahedron(p2-vec3(.5,.44,.1),.5);\n    horns = max(horns,-sdBox(p2-vec3(.0,.5,.0),vec3(.2,1.0,1.0)));\n    d=min(d,horns);\n    \n    \n    //d=min(d,body);\n    \n\n\n    \n    return d;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nstruct rmData{\n    vec4 color;//TODO @SAM: just do the colors at end of rm() function, u dummy\n    vec3 pos;\n    float depth;\n};\n\n    \nrmData rm(vec3 eye, vec3 dir, float start, float end) {\n    float depth = start;\n    rmData raym;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * dir);\n        if (dist < EPSILON) {\n            raym.depth=depth;\n            raym.pos=eye + depth * dir;\n\t\t\treturn raym;\n        }\n        depth += dist;\n        if (depth >= end) {\n            raym.depth=end;\n            return raym;\n        }\n    }\n    raym.depth=end;\n    return raym;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rotor = vec2(sin(iTime*2.0)/2.0,cos(iTime));\n\n    float eyeLook = mod(rotor.x+3.14*9.0,3.14*2.0)-3.14;\n    //eyeLook=clamp(eyeLook*12.5,-2.7,2.7)/2.7;\n    eyeLook=clamp(eyeLook*2.0,-1.0,1.0);\n\n    eyeLook=smoothstep(0.0,1.0,eyeLook/2.0+.5)*2.0-1.0;\n    eyeLook*=.85;\n        //eyeLook=clamp(eyeLook,-1.,1.)*.6;\n\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    dir.xz=rotate(dir.xz,rotor.x);\n    dir.yz=rotate(dir.yz,rotor.y/4.0-.15);\n\n    vec3 eye = vec3(0.0, 0.2, 5.25);\n    eye.z+=(sin(iTime/2.0)/2.0+.5)*1.0;\n    eye.xz=rotate(eye.xz,rotor.x);\n    eye.yz=rotate(eye.yz,rotor.y/4.0-.15);\n    \n\n\n    rmData r = rm(eye, dir, MIN_DIST, MAX_DIST);\n    float dist = r.depth;\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    //vec3 n = estimateNormal(r.pos);\n    \n    vec3 p = r.pos;\n    p.x=abs(p.x);\n    \n    vec3 lDir = (vec3(.65,.5,.85))*2.0;\n    \n    \n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    \n    float eyes=step(length(p+vec3(-.4,-.1,-.6)),.25);\n    float blink = clamp(1.0-abs(sin(iTime*0.45))*16.0,.0,1.0);\n    \n    \n    //blink rate for second blink set\n    float blinkRate = .4;\n    \n    //second set of blinks for more dynamic blinking lol\n    blink = max(blink,clamp(1.0-abs(cos(iTime*0.45*blinkRate))*16.0/blinkRate,.0,1.0));\n    \n    //squint occasionally\n    blink = max(blink,clamp(.35-abs(cos(iTime/4.0+.15)),.0,.10));\n\n    eyes*=step(p.y+p.x/8.0,.2-blink);\n    \n    //horizontal pupils follow camera\n    float pupils =step(.0,sdBox(p+vec3(-.4-eyeLook*sign(r.pos.x)/6.0,-.1+p.x/8.0,-.6),vec3(.01,.1,.5)));\n    \n    \n    //fragColor.g+=step(.0,n.y)*.25*step(-.5,r.pos.y);\n    //fragColor.g+=step(.0,n.y)*.05*step(n.y,.01);\n    \n    //fragColor.rgb=n.rgb;\n\n    fragColor.g=clamp(fragColor.g+eyes*pupils,.0,1.0);\n\n    \n    \n    \n    vec3 pm = Zigzag(r.pos,.11,.15);\n    \n    \n    pm.y=mix(r.pos.y,pm.y*2.0+.35,clamp(1.0-abs(pm.x),.0,1.0));\n\n\n    \n    float talkFreq = mix(sin(iTime*16.0),sin(iTime*13.0)-.8,clamp((cos(iTime*2.0+.15)+.5)*4.0,0.0,1.0));\n    float talkH=clamp(talkFreq/16.0+.1,.015,.25);\n    //float talkW=smoothstep(-1.0,1.0,clamp(-cos(iTime*2.0+.15)*8.0+.5,.0,1.0)*.24)*1.15-.34;\n    float talkW=smoothstep(-1.0,1.0,clamp(-cos(iTime*2.0+.15)*8.0+.5,.0,1.0)*.24)*.65;\n\n    float mouth = (sdEllipsoid(pm+vec3(.0,.425-pow(abs(pm).x,2.0)/1.0,-.5),vec3(talkW,talkH,.5)));\n\n    \n    \n    fragColor.g+=1.0-step(-.01,mouth);\n    \n    //cel shading\n    //fragColor*=mix(.5,1.0,clamp(fragColor.g+round(dot(n,lDir)+.5),.0,1.0));\n\n    \n\n\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd33Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd33R4", "name": "Truchet sausage", "author": "ruojake", "description": "I really like truchet patterns, about time I rendered one myself!", "tags": ["truchet"], "likes": 7, "viewed": 138, "date": "1567902742", "time_retrieved": "2024-06-20T19:44:30.674459", "image_code": "// (C) Kristian Sivonen 2019\n\n// edit 2019-09-09: changed outline color, I like the vaguely 90's sticker look\n\n// edit 2019-09-08: fancier fake specular\n//\t\t\t\t\tsimplified truchet function\n//\t\t\t\t\teliminated some matrix multiplications\n\n// Hash without sine by Dave Hoskins, CC BY-SA 4.0\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    float h00 = hash12(pi);\n    float h01 = hash12(pi + vec2(0., 1.));\n    float h10 = hash12(pi + vec2(1., 0.));\n    float h11 = hash12(pi + 1.);\n    return mix(mix(h00, h10, pf.x), mix(h01, h11, pf.x),pf.y);\n}\n\nfloat truchet(vec2 p, float w, float t)\n{\n    p *= t;\n    vec2 i = floor(p);\n    vec2 uv = p - i;\n    float s = sign((hash12(i) * 2. - 1.) + .001);\n    uv.x = fract(abs(uv.x + s));\n    vec2 toC = uv - .499;\n    s = sign(dot(toC, vec2(1.)));\n    uv = fract(abs(uv - s));\n    \n    float mn = .5 - w;\n    float mx = .5 + w;\n\tfloat truch = smoothstep(mn, mx, 1. - length(uv));\n    truch = 1. - abs(truch * 2. - 1.);\n    return truch;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y + sin(vec2(iTime, iTime + 1.57) * .13);\n    \n    float move = sin(iTime * .123) * .5 + .5;\n    float rot = (move * 2. - 1.) * 3.14;\n    float tiling = move * 5. + 5.;\n    float rcpT = 1. / tiling;\n    \n\tmat2x2 rMat = mat2x2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    uv = rMat * uv;\n    vec2 one = rMat * vec2(1.);\n    vec2 shadowUV = uv + one * .2 * rcpT;\n    vec2 hlUV = uv - one * .05 * rcpT;\n    vec2 hlUV2 = hlUV + vec2(-one.y, one.x) * .072 * rcpT;\n    \n    float outline = truchet(uv, .44, tiling);\n    float truch = truchet(uv, .3, tiling);\n    float shadow = truchet(shadowUV, .3, tiling);\n    float hl = truchet(hlUV, .1, tiling);\n    hl = min(hl, truchet(hlUV2, .1, tiling));\n    float light = truchet(hlUV, .3, tiling);\n    \n    outline = smoothstep(.36, .43, outline);\n    truch = smoothstep(.3, .4, truch);\n    shadow = smoothstep(.1, .6, shadow);\n    hl = smoothstep(.15, .85, hl) * truch;\n    light = smoothstep(.2, .7, light) * truch;\n    \n    vec3 col = vec3(.1, .2, .35) + noise(uv * tiling * 100.) * .04 - .02;\n    col *= 1. - shadow * .4;\n    col *= 1. - outline;\n    col += outline * vec3(1., 1., .9);\n    col -= truch;\n    \n    col += vec3(.8, .2, .5) * truch;\n    col *= 1. - clamp(truch - light, 0., 1.) * vec3(.6, .6, .4);\n    \n    col += vec3(1., .8, .4) * hl * .7;\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd33R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd33R7", "name": "rotating crosses 2", "author": "FabriceNeyret2", "description": "ref: [url]https://www.youtube.com/watch?v=o8R8fwegHsk[/url]", "tags": ["tiling", "cross", "gif", "short", "golf", "reproduction", "escherlike"], "likes": 23, "viewed": 379, "date": "1568233389", "time_retrieved": "2024-06-20T19:44:30.674459", "image_code": "// Fork of  https://shadertoy.com/view/wd3GR7\n\n#define R     (iResolution.xy)\n#define S(v)   smoothstep( 13./R.y , -13./R.y, v )\n#define rot(a) mat2(cos( a + vec4(0,33,11,0) ))       // from https://www.shadertoy.com/view/XlsyWX\nfloat t = 3.14/4., s;\n\nfloat draw(vec2 U, float r) {                         // --- draw rotating cross\n    U = 3.*(fract(U)-.5) *s;      \n    vec2 A = abs( U * rot( iTime +.46*r ) );          // .46 ~= atan(1/2)\n    return S( max(A.x,A.y) - 1.5 ) * S( min(A.x,A.y) - .5 ); // cross\n}\n    \nvoid mainImage( out vec4 O, vec2 U ) {\n    O-=O;\n    U = 2.7* (U+U-R)/R.y * rot(.46);                  // coords normalized + tilted                 \n    U /= s = 1.6* ( 1.+ max( abs(sin(t+=iTime)) ,abs(cos(t)) ) - .707 );// breathing \n    O += draw(U,-1.); U+=.5; O += draw(U,-1.);        // ( debug: O.r=  *1 *.5 )\n    U.x = .5-U.x;                                     // contra-rotative\n    O += draw(U, 1.); U+=.5; O += draw(U, 1.);        // ( debug: O.g=  *1 *.5 )\n    O = sqrt(O);                                      // to sRGB\n}\n\n\n\n\n\n\n\n/*\n\n// for those wandering, the code golfed version is 357 chars ;-p\n\n#define S(v)   smoothstep( 13./R , -13./R, v )                         //\n#define r(a) mat2(cos( a.46 + vec4(0,33,11,0) ))                       //\n#define D(k,d) ( A = abs( (3.*(fract(k+U)-.5) *s) * r( iTime d ) ),     \\\n               S( max(A,A.x) - 1.5 ) * S( min(A,A.x) - .5 )         ).y//\n#define mainImage(O,u)                                                  \\\nfloat s = .79+iTime;                                                    \\\n    vec2 A, R = iResolution.xy,                                         \\\n    U = 2.7* (u+u-R)/R.y * r();                                         \\\n    U /= s = 1.6* ( 1.+ max( abs(sin(s)) ,abs(cos(s)) ) -.73 );         \\\n    O += D(,-); O += D(.5,-);                                           \\\n    U.x = .5-U.x;                                                       \\\n    O += D(,+); O += D(.5,+)                                           /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd33R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd33Rf", "name": "Emergent BehaviAAAAAA", "author": "Cotterzz", "description": "Trying to create lettering with a shader, led to some unexpected emergent behavior.\nSeizure warning with this one, sorry.", "tags": ["typography", "letters"], "likes": 1, "viewed": 134, "date": "1568935176", "time_retrieved": "2024-06-20T19:44:30.977487", "image_code": "vec2 vect2d(vec2 p1, vec2 p2) {\n    vec2 temp;\n    temp.x = (p2.x - p1.x);\n    temp.y = -1.0 * (p2.y - p1.y);\n    return temp;}\n\nbool pointInRectangle(in vec2 A, in vec2 B, in vec2 C, in vec2 D, in vec2 m ) {\n    vec2 AB = vect2d(A, B);  float C1 = -1.0 * (AB.y*A.x + AB.x*A.y); float  D1 = (AB.y*m.x + AB.x*m.y) + C1;\n    vec2 AD = vect2d(A, D);  float C2 = -1.0 * (AD.y*A.x + AD.x*A.y); float D2 = (AD.y*m.x + AD.x*m.y) + C2;\n    vec2 BC = vect2d(B, C);  float C3 = -1.0 * (BC.y*B.x + BC.x*B.y); float D3 = (BC.y*m.x + BC.x*m.y) + C3;\n    vec2 CD = vect2d(C, D);  float C4 = -1.0 * (CD.y*C.x + CD.x*C.y); float D4 = (CD.y*m.x + CD.x*m.y) + C4;\n    return     0.0 >= D1 && 0.0 >= D4 && 0.0 <= D2 && 0.0 >= D3;}\n\nfloat inCharacter ( in vec2 position, in int character){\n    if (character == 65){\n        vec2 tl = vec2(0.4,0.9);\n        vec2 tr = vec2(0.6,0.95);\n        vec2 br = vec2(0.9,0.1);\n        vec2 bl = vec2(0.1,0.1);\n        if (pointInRectangle(tl,tr,br,bl,position)){\n            vec2 itl = vec2(0.5,0.66);\n        \tvec2 itr = vec2(0.5,0.66);\n        \tvec2 ibr = vec2(0.7,0.1);\n        \tvec2 ibl = vec2(0.3,0.1);\n            if (pointInRectangle(itl,itr,ibr,ibl,position)){\n                \n                return step (0.1,abs(0.4-position.y));\n                    } else { return 0.0;}\n            \n        } else {return 1.0;}\n        //float l2 = step((position.x * 3.00),(position.y+0.4));\n        //float l1 = step((position.y+0.8),(position.x * 3.00));\n        //return l1+l2;\n    }\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //if (((fragCoord.x * 2.00) + 5.00)>fragCoord.y){\n        //col = vec3 (0.0,0.0,0.0);\n    //}\n    float fcol = inCharacter(mod(fragCoord,iTime/100.00)/(iTime/100.00), 65);\n    col = vec3(fcol,fcol,fcol);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd33Rf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd33RM", "name": "Tunnel of Souls", "author": "K1mpp4", "description": "Based on nimitz's shader", "tags": ["volumetric"], "likes": 10, "viewed": 310, "date": "1568051770", "time_retrieved": "2024-06-20T19:44:31.789442", "image_code": "// Based on Protean clouds by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\nuniform sampler2D tex0;\nuniform vec4 bkg_color;\nuniform float time;\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.5;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.1-0.02;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .81;\n    float z = 1.;\n    float trk = 1.0;\n    float dspAmp = 2.1 + prm1*0.02;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 0.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*1., time + ldst);\n\tfloat t = -1.5;\n\tfloat fogT = 0.5;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.0;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*1.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)*(ma+ 1e-7);\n}\n//from nimitz's \"Will it blend\" shader\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 3.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,-0.2,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (0.5 - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*1.2;\n    vec3 ro = vec3(1,0,time);\n    \n    ro += vec3(sin(iTime)*1.8,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .2;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*1.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(0.-prm1,0.05,0.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(0.5,1.0,1.2);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 62.0 );\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd33RM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd33RX", "name": "Modified Apollonian Gasket", "author": "jarble", "description": "This is based on https://www.shadertoy.com/view/Mt2fzR. I edited only one line of code to make this animation!", "tags": ["fractal"], "likes": 4, "viewed": 362, "date": "1568948782", "time_retrieved": "2024-06-20T19:44:31.789698", "image_code": "// Created by evilryu - evilryu/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\nvec2 rot(vec2 p, float r)\n{\n    vec2 q;\n    q.x = p.x * cos(r) - p.y * sin(r);\n    q.y = p.x * sin(r) + p.y * cos(r);\n    return q;\n}\n\nvec3 apollonian(vec2 p)\n{\n    p = rot(p, iTime*0.1);\n\n    float scale = 1.0;\n    float t0 = 1e20, t1 = 1e20;\n    for(int i = 0; i < 7; ++i)\n    {\n        p = -1.0 + 2.0*fract(p*0.5+0.5);\n        float k=(1.34)/dot(p,p)*sin(iTime+p.x/p.y);\n        p*=k;\n        \n        t0 = min(t0, dot(p,p));\n        t1 = min(t1, max(abs(p.x), abs(p.y)));\n        scale*=k;\n\n    }\n    float d=0.25*abs(p.y)/scale;\n    d=smoothstep(0.001, 0.002,d);\n    \n    float c0=pow(clamp(t0, 0.0, 1.0), 1.5); \n    float c1=pow(clamp(t1, 0.0, 1.0), 2.);\n    vec3 col0=0.5+0.5*sin(1.0+3.4*c0+vec3(2.,1.3, 0.)); \n\tvec3 col1=0.5+0.5*sin(3.7*c1+vec3(2.,1.5, 0.)); \n\n    vec3 col = sqrt(d*col1*col0)*3.;\n    \n    return col;\n}\n\n\nvec2 getsubpixel(int id,vec2 fragCoord)\n{\n\tvec2 aa=vec2(floor((float(id)+0.1)*0.5),mod(float(id),2.0));\n\treturn vec2((2.0*fragCoord.xy+aa-iResolution.xy)/iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    for(int i=0;i<4;++i)\n    {\n        vec2 p = getsubpixel(i,fragCoord);\n        p*=exp(sin(iTime*0.2)*0.2);\n        col += apollonian(p);\n    }\n    col/=4.0;\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n   \tcol*=0.5+.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);  // vigneting\n\tfragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd33RX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd33z7", "name": "Mandelbrot from TAOC", "author": "GreenMoonMoon", "description": "Mandelbrot shader acheived by following TheArtOfCode.\nThe formula itself, despite sensible explanations form AOC, still sounds like magic to me. It's fun to play with it nonetheless.\nAOC tutorial: https://www.youtube.com/watch?v=kY7liQVPQSc&t=275s\n", "tags": ["mandelbrot", "theartofcode", "taoc"], "likes": 2, "viewed": 108, "date": "1568059917", "time_retrieved": "2024-06-20T19:44:32.207962", "image_code": "#define ASPECT iResolution.x/iResolution.y\n#define MAXSTEP 100.0\n\n// Simple rotation algorithm\nvec2 rotate(vec2 position, vec2 pivot, float angle){\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    position -= pivot;\n    position = vec2(position.x * c - position.y * s, position.x * s + position.y * c);\n    position += pivot;\n    \n    return position;\n}\n\n// The mandlebrot implementation;\n// f(z) = z^2 + c\n// z is the starting position and c is the center.\n// Once the length of z goes above a threshold, the loop breaks and the result is returned.\n// The value is then normlalized and used to depict and image.\nvec2 mandelbrot(vec2 z, vec2 c){\n    float iter = 0.0; //The number of iteration counted before z length goes abobe threshold.\n    float smoothIter = 0.0;\n    \n    // The r and r2 enable us to figure out the distance between the edge of the threshold and the start.\n    // Use this is get a smooth interpolation between steps.\n    float r = 4.0;\n    float r2 = r * r;\n    \n    // The  main loop.\n\tfor(float i = 0.0; i < MAXSTEP; i++){\n        vec2 oz = z;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        // if(length(z) > r) break; // Original escape clause.\n        if(dot(z, oz) > r) break; // idk how that work exactly, but AOC does it and it's really nice.\n        \n        float dist = length(z);\n    \t//float fractIter = fract((dist - r) / (r2 -r)); //Linear interpolation\n        float fractIter = log(dist) / log(r) - 1.0; //Smooth interpolation\n        smoothIter -= fractIter;\n        iter++;\n    }\n    \n    //Here I return the step value as well as the smooth interpolated step value.\n    return vec2(iter/MAXSTEP, smoothIter/MAXSTEP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinate and setup aspect ratio.\n    vec2 uv = 1.0 - fragCoord.xy/iResolution.xy * 2.0;\n    uv.x *= ASPECT;\n\tvec2 mouse = (iMouse.xy/iResolution.xy);\n    mouse.x *= ASPECT;\n    \n    // Small function to get a smooth zoom over time.\n    float timeFactor = pow(iTime, -iTime * 0.1);\n    \n    vec2 zoom = vec2(timeFactor);\n    vec2 center = vec2(-0.7869340, -0.163849);\n    vec2 c = uv * zoom + center;\n    c = rotate(c, center, iTime  * 0.1);\n    \n    vec2 z = vec2(0.0);\n    vec2 f = mandelbrot(z, c);\n    \n    // Colorize\n    vec3 lum = sin(vec3(f.y) * 2.0);\n    vec3 albedo = sin(f.x * vec3(0.3, 0.63, 0.94) * 20.0 + (iTime * 0.5));\n    vec3 color = albedo * smoothstep(0.0, 0.5, sqrt(f.y));\n     \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd33z7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3GD4", "name": "Lissajous oscilloscope", "author": "blinry", "description": ":)", "tags": ["oscilloscope", "lissajous"], "likes": 9, "viewed": 467, "date": "1568494789", "time_retrieved": "2024-06-20T19:44:32.207962", "image_code": "float map(vec2 p, float r, float t) {\n    return distance(0.4*vec2(cos(3.0*t), sin(2.0*t)), p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int l = 500;\n   \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 col = vec3(.015/distance(0.4*vec2(cos(3.0*iTime), sin(2.0*iTime)), uv));\n    \n    // Would there be a better way to do this? :D\n    for(int i=0; i<l; i++) { \n        col = max(col,\n                 vec3(\n                     smoothstep(-0.005, 0.005, -map(uv, 0.02*float(l-i)/float(l), iTime-float(i)*0.005)))\n                     *pow(float(l-i), 0.8)/float(l));\n    }\n    \n    col *= vec3(1.0, 2.0, 1.0);\n\n    col += vec3((1.0-step(0.002, abs(mod(uv.y, 0.1))))*(1.0-step(0.02, abs(uv.x))));\n    col += vec3((1.0-step(0.002, abs(mod(uv.x, 0.1))))*(1.0-step(0.02, abs(uv.y))));\n    col += vec3((1.0-step(0.002, abs(uv.y))));\n    col += vec3((1.0-step(0.002, abs(uv.x))));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3GD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3GR4", "name": "Dungeon crawler floor/ceiling", "author": "Roninkoi", "description": "Draws the floor and ceiling like you might see in an old school dungeon crawler", "tags": ["floor", "dungeon", "ceiling"], "likes": 4, "viewed": 226, "date": "1567888485", "time_retrieved": "2024-06-20T19:44:32.207962", "image_code": "vec3 c1 = vec3(0.8, 0.3, 0.2);\nvec3 c2 = vec3(0.4, 0.7, 0.7);\n\nvoid mainImage(out vec4 fragCol, in vec2 fragPos)\n{\n    float s = 4.;\n    \n    float res = 32.0;\n    \n    float rot = iTime * 0.2;\n    \n    float camX = iTime * 0.2;\n    float camZ = -iTime * 0.2;\n    \n    vec2 uv = fragPos/iResolution.xy*2. - 1.;\n    uv.y *= 2.*(uv.y/abs(uv.y));\n    \n    uv.y = floor(uv.y * res) / res;\n    res *= 2.0*(iResolution.x / iResolution.y);\n    uv.x = floor(uv.x * res) / res;\n    \n    float x = uv.x / uv.y;\n    float z = 1. / uv.y;\n    \n    float ox = x;\n    x = x * cos(rot) + z * sin(rot);\n    z = ox * sin(rot) - z * cos(rot);\n    \n    float rx = x;\n    float rz = z;\n    \n    x += camX;\n    z += camZ;\n\n    vec3 col = vec3(0.0);\n    \n    float a = floor(mod(s*x, 2.)) + floor(mod(s*z, 2.));\n    a = clamp(a, 0., 1.);\n    \n    float b = floor(mod(s*x + 1., 2.)) + floor(mod(s*z + 1., 2.));\n    b = clamp(b, 0., 1.);\n    \n    a *= b;\n    \n    col.rgb += c1*mod(s*z,1.) * a;\n    col.rgb += c1*mod(s*x,1.) * a;\n    \n    col.rgb += c2*mod(s*z,1.) * (1. - a);\n    col.rgb += c2*mod(s*x,1.) * (1. - a);\n    \n    float d = sqrt(rx*rx + rz*rz);\n        \n    col.rgb /= exp(d);\n    \n    fragCol = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3GR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd3GR7", "name": "rotating crosses (225 chars)", "author": "FabriceNeyret2", "description": "( note that letting only O += S(min)   yields some kind of oriental pattern ;-) )", "tags": ["cross", "2tweets", "gif", "short", "golf", "reproduction", "escherlike"], "likes": 8, "viewed": 314, "date": "1568059035", "time_retrieved": "2024-06-20T19:44:32.577615", "image_code": "// readable version at the end ;-)\n\n// --- 225 by Fab ( + antialiasing fixed :-) )\n//      -2 by moving A= inside S macro at first use, but would be really ugly ;-)\n//      +1: ceil(U) instead of floor create artifacts at some resolutions\n         \n//#define S(v) smoothstep(15.,-15., ( v(A.x,A.y) -.5 ) *R.y ) //\n#define S(v) clamp( .5 - ( v(A,A.x) -.5 ) /30. *R , 0., 1. ).y//\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 3.* (u+u-R)/R.y, A = mod(floor(U),2.);\n    A = abs( 3.1*(fract(U)-.5) * mat2(cos(vec4(0,33,11,0) +(A.x==A.y?1.:-1.)*iTime))),\n    O += S(-1.+max) * S(min);\n}/*\n\n\n             \n// --- 241 by mathmasterzach\n\n#define S(v) smoothstep(4.2/R.y,-4.2/R.y,v-.5)            //\n#define mainImage(O,u)                                     \\\n    vec2 R = iResolution.xy,                               \\\n         U = 3.* (u+u-R)/R.y, A = mod(ceil(U),2.);         \\\n    A = abs(3.1*(fract(U)-.5) * mat2(cos(vec4(0,33,11,0)-2.*(abs(A.x-A.y)-.5)*iTime))),\\\n    O += S(max(A.x,A.y)-1.) * S(min(A.x,A.y))             /*\n    \n\n\n             \n// --- 267 chars\n\n#define S(v) smoothstep(.7*6./R.y,-.7*6./R.y,v)                       //\n#define d ( B = mod(ceil(U),2.),                                       \\\n    A = abs( 3.1*(fract(U)-.5) * mat2(cos(iTime+vec4(0,33,11,0)) ) ),  \\\n    B.x==B.y ? S( max(A.x,A.y) - 1.5 ) * S( min(A.x,A.y) - .5 ): 0. ) //\n//\n#define mainImage(O,u)                   \\\n    vec2 R = iResolution.xy,             \\\n         U = 3.* (u+u-R)/R.y, B,A;       \\\n    O += d;                              \\\n    U.x = -U.x;                          \\\n    O += d                              /*\n\n\n\n\n// --- 330 chars\n\n#define R (iResolution.xy)\n#define S(v) smoothstep(.7*6./R.y,-.7*6./R.y,v)\n\nfloat draw(vec2 U) {\n    vec2 V = ceil(U), B = mod(V,2.), A;\n    U = 3.1*(fract(U)-.5);\n    A = abs( U * mat2(cos(iTime+vec4(0,33,11,0)) ) );\n    return B.x==B.y \n             ? S( max(A.x,A.y) - 1.5 ) * S( min(A.x,A.y) - .5 )\n             : 0.;\n}\n    \nvoid mainImage( out vec4 O, vec2 u ) {\n    vec2 U = 3.* (u+u-R)/R.y;\n    O += draw(U);\n    U.x = -U.x;\n    O += draw(U);\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd3GR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3GRs", "name": "Shine Through", "author": "caeonosphere", "description": "A second march inside the sphere finds the distance to internal lights, which I use to light the exterior, plus bonus fake glow that only works perpendicularly.", "tags": ["3d", "raymarching", "glow"], "likes": 2, "viewed": 311, "date": "1569073396", "time_retrieved": "2024-06-20T19:44:32.577615", "image_code": "#define M_PI 3.14159\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat hash21(vec2 p) {\n\tp = fract(p*vec2(1.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    vec3 rayOrigin = vec3(0, 0, -1.75);\n    vec3 lens = vec3(0, 0, -1);\n    vec3 up = vec3(0, 1, 0);\n    vec3 cameraAngle = normalize(lens - rayOrigin);\n    vec3 right = cross(up, cameraAngle);\n    up = cross(cameraAngle, right);\n    vec3 planePosition = lens + uv.x * right + uv.y * up;\n    vec3 rayDirection = normalize(planePosition - rayOrigin);\n\n    // First march.\n    vec3 perpendicularPoint = rayOrigin + dot(-rayOrigin, rayDirection) * rayDirection;\n    float firstTotal = 0.;\n    for (int i = 0; i < 200; i++) {\n        float distance = sphere(rayOrigin, .8);\n        rayOrigin += rayDirection * distance;\n        firstTotal += distance;\n    }\n    vec3 minPoint = length(rayOrigin) - .8 < .001 ? rayOrigin : perpendicularPoint;\n    // Second march.\n    rayOrigin = minPoint;\n    rayDirection = normalize(-rayOrigin);\n    float secondTotal = 0.;\n    float time = iTime + 60.;\n    for (int i = 0; i < 16; i++) { // few iterations for a bit of blur\n        float distance = -1.;\n        for (float j = 0.; j < 12.; j++) {\n            float innerRadius = .45;\n            float xSpeed = .5 + .5 * hash21(vec2(.2, j * 34.23));\n            float x = innerRadius * cos(time * xSpeed);\n            float ySpeed = .5 + .5 * hash21(vec2(.4, j * 47.22));\n            float y = innerRadius * cos(time * ySpeed);\n            float zSpeed = .5 + .5 * hash21(vec2(.6, j * 21.11));\n            float z = innerRadius * cos(time * zSpeed);\n            vec3 innerSphere = vec3(x, y, z);\n            if (length(innerSphere) > .48) {\n                innerSphere = normalize(innerSphere) * .48;\n            }\n            float innerSphereDistance = sphere(rayOrigin - innerSphere, .1);\n            if (distance == -1.) {\n                distance = innerSphereDistance;\n            } else {\n            \tdistance = smin(distance, innerSphereDistance, .2);\n            }\n        }\n        rayOrigin += rayDirection * distance;\n        secondTotal += distance;\n    }\n    // Calculate lighting.\n    float d = max(2.5 - firstTotal, 0.) * .1f;\n    float firstMin = length(minPoint) - .8;\n    float glow = max(0., 1. - firstMin * 8.) * (1. - secondTotal) * 1.1;\n    glow = max(glow, 0.);\n    fragColor.xyz = vec3(d + glow);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3GRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3GWf", "name": "Wind Waker Ocean 2D", "author": "vamoss", "description": "Zelda: Wind Walker Ocean 2D", "tags": ["ocean", "toon"], "likes": 2, "viewed": 170, "date": "1569351685", "time_retrieved": "2024-06-20T19:44:33.274681", "image_code": "// Original code by @Polyflare\n// https://www.shadertoy.com/view/ltfGD7\n\n// 0 = Antialias the water texture\n// 1 = Do not antialias the water texture\n#define FAST_CIRCLES 1\n\n\nconst vec2 vel = vec2(.2, 0.);\n\n//-----------------------------------------------------------------------------\n\n#define WATER_COL vec3(0.0, 0.4453, 0.7305)\n#define WATER2_COL vec3(0.0, 0.4180, 0.6758)\n#define FOAM_COL vec3(0.8125, 0.9609, 0.9648)\n\nfloat circ(vec2 pos, vec2 c, float s)\n{\n    c = abs(pos - c);\n    c = min(c, 1.0 - c);\n#if FAST_CIRCLES\n    return dot(c, c) < s ? -1.0 : 0.0;\n#else\n    return smoothstep(0.0, 0.002, sqrt(s) - sqrt(dot(c, c))) * -1.0;\n#endif\n}\n\n// Foam pattern for the water constructed out of a series of circles\nfloat waterlayer(vec2 uv)\n{\n    uv = mod(uv, 1.0); // Clamp to [0..1]\n    float ret = 1.0;\n    ret += circ(uv, vec2(0.37378, 0.277169), 0.0268181);\n    ret += circ(uv, vec2(0.0317477, 0.540372), 0.0193742);\n    ret += circ(uv, vec2(0.430044, 0.882218), 0.0232337);\n    ret += circ(uv, vec2(0.641033, 0.695106), 0.0117864);\n    ret += circ(uv, vec2(0.0146398, 0.0791346), 0.0299458);\n    ret += circ(uv, vec2(0.43871, 0.394445), 0.0289087);\n    ret += circ(uv, vec2(0.909446, 0.878141), 0.028466);\n    ret += circ(uv, vec2(0.310149, 0.686637), 0.0128496);\n    ret += circ(uv, vec2(0.928617, 0.195986), 0.0152041);\n    ret += circ(uv, vec2(0.0438506, 0.868153), 0.0268601);\n    ret += circ(uv, vec2(0.308619, 0.194937), 0.00806102);\n    ret += circ(uv, vec2(0.349922, 0.449714), 0.00928667);\n    ret += circ(uv, vec2(0.0449556, 0.953415), 0.023126);\n    ret += circ(uv, vec2(0.117761, 0.503309), 0.0151272);\n    ret += circ(uv, vec2(0.563517, 0.244991), 0.0292322);\n    ret += circ(uv, vec2(0.566936, 0.954457), 0.00981141);\n    ret += circ(uv, vec2(0.0489944, 0.200931), 0.0178746);\n    ret += circ(uv, vec2(0.569297, 0.624893), 0.0132408);\n    ret += circ(uv, vec2(0.298347, 0.710972), 0.0114426);\n    ret += circ(uv, vec2(0.878141, 0.771279), 0.00322719);\n    ret += circ(uv, vec2(0.150995, 0.376221), 0.00216157);\n    ret += circ(uv, vec2(0.119673, 0.541984), 0.0124621);\n    ret += circ(uv, vec2(0.629598, 0.295629), 0.0198736);\n    ret += circ(uv, vec2(0.334357, 0.266278), 0.0187145);\n    ret += circ(uv, vec2(0.918044, 0.968163), 0.0182928);\n    ret += circ(uv, vec2(0.965445, 0.505026), 0.006348);\n    ret += circ(uv, vec2(0.514847, 0.865444), 0.00623523);\n    ret += circ(uv, vec2(0.710575, 0.0415131), 0.00322689);\n    ret += circ(uv, vec2(0.71403, 0.576945), 0.0215641);\n    ret += circ(uv, vec2(0.748873, 0.413325), 0.0110795);\n    ret += circ(uv, vec2(0.0623365, 0.896713), 0.0236203);\n    ret += circ(uv, vec2(0.980482, 0.473849), 0.00573439);\n    ret += circ(uv, vec2(0.647463, 0.654349), 0.0188713);\n    ret += circ(uv, vec2(0.651406, 0.981297), 0.00710875);\n    ret += circ(uv, vec2(0.428928, 0.382426), 0.0298806);\n    ret += circ(uv, vec2(0.811545, 0.62568), 0.00265539);\n    ret += circ(uv, vec2(0.400787, 0.74162), 0.00486609);\n    ret += circ(uv, vec2(0.331283, 0.418536), 0.00598028);\n    ret += circ(uv, vec2(0.894762, 0.0657997), 0.00760375);\n    ret += circ(uv, vec2(0.525104, 0.572233), 0.0141796);\n    ret += circ(uv, vec2(0.431526, 0.911372), 0.0213234);\n    ret += circ(uv, vec2(0.658212, 0.910553), 0.000741023);\n    ret += circ(uv, vec2(0.514523, 0.243263), 0.0270685);\n    ret += circ(uv, vec2(0.0249494, 0.252872), 0.00876653);\n    ret += circ(uv, vec2(0.502214, 0.47269), 0.0234534);\n    ret += circ(uv, vec2(0.693271, 0.431469), 0.0246533);\n    ret += circ(uv, vec2(0.415, 0.884418), 0.0271696);\n    ret += circ(uv, vec2(0.149073, 0.41204), 0.00497198);\n    ret += circ(uv, vec2(0.533816, 0.897634), 0.00650833);\n    ret += circ(uv, vec2(0.0409132, 0.83406), 0.0191398);\n    ret += circ(uv, vec2(0.638585, 0.646019), 0.0206129);\n    ret += circ(uv, vec2(0.660342, 0.966541), 0.0053511);\n    ret += circ(uv, vec2(0.513783, 0.142233), 0.00471653);\n    ret += circ(uv, vec2(0.124305, 0.644263), 0.00116724);\n    ret += circ(uv, vec2(0.99871, 0.583864), 0.0107329);\n    ret += circ(uv, vec2(0.894879, 0.233289), 0.00667092);\n    ret += circ(uv, vec2(0.246286, 0.682766), 0.00411623);\n    ret += circ(uv, vec2(0.0761895, 0.16327), 0.0145935);\n    ret += circ(uv, vec2(0.949386, 0.802936), 0.0100873);\n    ret += circ(uv, vec2(0.480122, 0.196554), 0.0110185);\n    ret += circ(uv, vec2(0.896854, 0.803707), 0.013969);\n    ret += circ(uv, vec2(0.292865, 0.762973), 0.00566413);\n    ret += circ(uv, vec2(0.0995585, 0.117457), 0.00869407);\n    ret += circ(uv, vec2(0.377713, 0.00335442), 0.0063147);\n    ret += circ(uv, vec2(0.506365, 0.531118), 0.0144016);\n    ret += circ(uv, vec2(0.408806, 0.894771), 0.0243923);\n    ret += circ(uv, vec2(0.143579, 0.85138), 0.00418529);\n    ret += circ(uv, vec2(0.0902811, 0.181775), 0.0108896);\n    ret += circ(uv, vec2(0.780695, 0.394644), 0.00475475);\n    ret += circ(uv, vec2(0.298036, 0.625531), 0.00325285);\n    ret += circ(uv, vec2(0.218423, 0.714537), 0.00157212);\n    ret += circ(uv, vec2(0.658836, 0.159556), 0.00225897);\n    ret += circ(uv, vec2(0.987324, 0.146545), 0.0288391);\n    ret += circ(uv, vec2(0.222646, 0.251694), 0.00092276);\n    ret += circ(uv, vec2(0.159826, 0.528063), 0.00605293);\n\treturn max(ret, 0.0);\n}\n\n// Procedural texture generation for the water\nvec3 water(vec2 uv)\n{\n    uv *= vec2(3.);\n\n    const vec2 dist = vec2(0.0);\n    \n    vec3 ret = mix(WATER_COL, WATER2_COL, waterlayer(uv + dist.xy));\n    ret = mix(ret, FOAM_COL, waterlayer(vec2(1.0) - uv - dist.yx));\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //wave\n    vec2 wave = uv;\n    wave.x += sin(uv.y*5.+iTime)*0.1;\n    wave.y += cos(uv.x*5.+iTime)*0.1;\n    uv += wave;\n    \n    uv+=vel*iTime;\n    \n    vec3 col = water(uv); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3GWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3GWl", "name": "rainbow gears", "author": "sushila", "description": "just playing around while learning glsl.\n\nThanks to FabriceNeyret2 for the suggestions.", "tags": ["2d", "learning"], "likes": 5, "viewed": 130, "date": "1569437095", "time_retrieved": "2024-06-20T19:44:33.656487", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord -.5 * iResolution.xy ) / iResolution.y;\n    \n    // shift over time\n    uv += iTime*0.1;\n    \n    // Divide into grid\n    float gridSize = 3.;\n    \n    // Magick?\n    //float px = 0.01;\n    float px = 1.5*gridSize/iResolution.y;\n    \n    // grid uv is fractional part of uv\n    vec2 gv = fract(uv*gridSize)-0.5;\n    // grid id is integer part of uv\n    vec2 id = floor(uv*gridSize);\n    \n\t// start with black and add color where appropriate\n    vec3 col = vec3(0);\n    \n    // loop over neighboring grid areas to draw overlapping/intermeshing gears\n    for (int x = -1; x <= 1; x++) {\n        for ( int y = -1; y <= 1; y++) {\n            vec2 offs = vec2(x, y);\n            // Distance to center of grid\n            float cd = length(gv+offs);\n            // angle relative to center of grid\n            float a = atan(gv.y+offs.y, gv.x+offs.x);\n           \n            // Alternate rotation direction by grid id\n            float dir = (mod(id.x+id.y+offs.x+offs.y, 2.)-0.5)*2.;\n\n            \n            // gear shape - radius as a function of angle, direction, and time\n            float ra = 0.495+0.1*clamp(sin(10.*a+dir*5.*iTime), -.4, .5);\n            float mask = 0.9 * smoothstep(ra+px, ra-px, cd);\n            \n            // remove center\n            mask -= smoothstep(0.1+px, 0.1-px, cd);\n            \n            // get color for grid - not sure why this needs to be minus offs??\n            vec3 icol = (0.5 + 0.5*cos((id.xyx-offs.xyx)/2.+vec3(0,2,4)));\n            // add color with mask\n            col += mask * icol;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3GWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3GWS", "name": "ExperimentOnPsychedelism", "author": "TheOldBeach", "description": "Experiment", "tags": ["experiment"], "likes": 3, "viewed": 101, "date": "1569164422", "time_retrieved": "2024-06-20T19:44:33.656487", "image_code": "float DrawPoint(vec2 uv,vec2 p, float r)\n{\n    return smoothstep(abs(r)+0.000001,abs(r),length(uv-p));\n}\n\nfloat H21(vec2 uv)\n{\n    uv = vec2(uv.x*25.64f,uv.y*651.1f);\n    uv += dot(uv,uv+2.34f);\n    return fract(uv.x+uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5f*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0f);\n    float p = 0.0f;\n    const float spacing = 0.1f;\n    const float row = 10.0f;\n    const float column = 13.0f;\n    float time = iTime*0.5+26.3;\n    vec2 coord;\n    float r;\n    float seed;\n    float loop;\n    float t;\n    \n    for(float j = -row; j <= row; j++){\n        for(float i = -column; i <= column; i++){\n            \n            coord = vec2(i * spacing,j*spacing);\n            seed = H21(coord);\n            t = time-length(coord)*0.2;\n\n            loop = mod(floor((t/6.283f)),16.) +1.0f ;\n            r = mix(-0.01,0.1*loop,clamp(smoothstep(-1.0,1.0,sin(t)),0.0f,1.0f));\n            p += DrawPoint(uv,coord,r * mix(1.0,1.f,H21(coord)));\n        }\n    }\n    col+= mod(p,2.0f);\n    col = fract(vec3(-p*205.061,p*1797.87f,p*18.16));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3GWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3Gz4", "name": "Water pillar Giyu Tomioka", "author": "yasuo", "description": "Breath of water", "tags": ["kimetsu"], "likes": 5, "viewed": 502, "date": "1567865139", "time_retrieved": "2024-06-20T19:44:34.377769", "image_code": "// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\n}\n\n// modefied version of the sdTriangle\nfloat sdQuads( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p3-p2, e3 = p0-p3;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2, v3 = p -p3;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    vec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e3.y - e0.y*e3.x );\n    vec2 d = min( min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                 \t   vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) )),\n                       vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 isometricCube(vec2 p, vec2 pos, vec2 size, float h, vec3 col){\n    \n    vec3 topCol = vec3(0.8,0.6,0.0);\n    vec3 lWallCol = vec3(0.1,0.4,0.0);\n    vec3 rWallCol = vec3(0.1,0.3,0.0);\n    \n    float d = sdRhombus(p+pos-vec2(0.0,h),size);\n    col = mix( col, topCol, smoothstep(0.01,0.0,d));\n    d = sdQuads(p+pos,vec2(-size.x,0.0),vec2(-size.x,h),vec2(0.0,h-size.y),vec2(0.0,-size.y));\n    col = mix( col, lWallCol, smoothstep(0.01,0.0,d));\n    d = sdQuads(p+pos,vec2(0.0,-size.y),vec2(0.0,h-size.y),vec2(size.x,h),vec2(size.x,0.0));\n    col = mix( col, rWallCol, smoothstep(0.01,0.0,d));\n    return col;\n}\n\nvec3 isometricCube2(vec2 p, vec2 pos, vec2 size, float h, vec3 col){\n    \n    vec3 topCol = vec3(0.0,0.2,0.0);\n    vec3 lWallCol = vec3(0.8,0.5,0.0);\n    vec3 lWallCol2 = vec3(0.6,0.3,0.0);\n    vec3 lWallCol3 = vec3(0.8,0.2,0.0);\n    vec3 rWallCol = vec3(0.7,0.4,0.0);\n    \n    float d = sdRhombus(p+pos-vec2(0.0,h),size);\n    col = mix( col, topCol, smoothstep(0.01,0.0,d));\n    d = sdQuads(p+pos,vec2(-size.x,0.0),vec2(-size.x,h),vec2(0.0,h-size.y),vec2(0.0,-size.y));\n    col = mix( col, lWallCol, smoothstep(0.01,0.0,d));\n    \n    d = sdQuads(p+pos,vec2(-size.x,0.0),vec2(-size.x,h*0.7),vec2(-size.x*0.3,(h*0.7)-size.y*0.7),vec2(-size.x*0.3,-size.y*0.7));\n    col = mix( col, lWallCol2, smoothstep(0.01,0.0,d));\n    \n    d = sdQuads(p+pos,vec2(-size.x,0.0),vec2(-size.x,h*0.6),vec2(-size.x*0.4,(h*0.6)-size.y*0.6),vec2(-size.x*0.4,-size.y*0.6));\n    col = mix( col, lWallCol, smoothstep(0.01,0.0,d));\n    \n    d = sdQuads(p+pos,vec2(-size.x,0.0),vec2(-size.x,h*0.4),vec2(-size.x*0.6,(h*0.4)-size.y*0.4),vec2(-size.x*0.6,-size.y*0.4));\n    col = mix( col, lWallCol3, smoothstep(0.01,0.0,d));\n    \n    \n    d = sdQuads(p+pos,vec2(0.0,-size.y),vec2(0.0,h-size.y),vec2(size.x,h),vec2(size.x,0.0));\n    col = mix( col, rWallCol, smoothstep(0.01,0.0,d));\n    \n    \n    d = sdQuads(p+pos,vec2(size.x*0.3,-size.y*0.7),vec2(size.x*0.3,(h*0.7)-size.y*0.7),vec2(size.x,(h*0.7)),vec2(size.x,0.0));\n    col = mix( col, lWallCol2, smoothstep(0.01,0.0,d));\n    \n    d = sdQuads(p+pos,vec2(size.x*0.4,-size.y*0.6),vec2(size.x*0.4,(h*0.6)-size.y*0.6),vec2(size.x,(h*0.6)),vec2(size.x,0.0));\n    col = mix( col, rWallCol, smoothstep(0.01,0.0,d));\n    \n    d = sdQuads(p+pos,vec2(size.x*0.6,-size.y*0.4),vec2(size.x*0.6,(h*0.4)-size.y*0.4),vec2(size.x,(h*0.4)),vec2(size.x,0.0));\n    col = mix( col, lWallCol3, smoothstep(0.01,0.0,d));\n    \n    return col;\n}\n\nvec3 pattern(vec2 p, vec2 pos, vec2 size, vec3 col) {\n\tvec2 uvRef = p;\n    p.x = mod(p.x,0.8)-0.4;\n    col = isometricCube(p,pos,size, 0.2, col); \n    p = uvRef;\n\t\n    p.x -= 0.4;\n    p.x = mod(p.x,0.8)-0.4;\n    col = isometricCube2(p,pos,size, 0.2, col); \n    p = uvRef;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 uvRef = p;\n    \n    vec3 col = vec3(0.3,0.1,0.1); \n    float xstep = 0.2;\n    float ystep = 0.33;\n    \n    float animateX = iTime*0.1;\n    \n    vec2 offsetPos = vec2(0.0,-0.99);\n    vec2 size = vec2(0.2,0.12);\n    \n    p.y +=0.205;\n    p.x-=animateX;\n\tcol = pattern(p,offsetPos,size,col);\n    \n    offsetPos = vec2(0.0,-ystep*2.0);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n    \n    offsetPos = vec2(0.0,-ystep);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n    \n    offsetPos = vec2(0.0,0.0);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n        \n    offsetPos = vec2(0.0,ystep);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n    \n    offsetPos = vec2(0.0,ystep*2.0);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n    \n    offsetPos = vec2(0.0,ystep*3.0);\n    p.x -= xstep;\n    col = pattern(p,offsetPos,size,col);\n    \n    vec3 res = (uvRef.x<0.0)?col: vec3(0.3,0.1,0.1);\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3Gz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd3Gzj", "name": "Barth Decic", "author": "skye_adaire", "description": "Implicit equation taken from:\nhttp://mathworld.wolfram.com/BarthDecic.html", "tags": ["geometry", "dual", "real", "algebraic", "barth", "decic"], "likes": 7, "viewed": 137, "date": "1568824998", "time_retrieved": "2024-06-20T19:44:35.765751", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n        case 10:\n        {\nDualReal x = d[0];\n            DualReal x2 = D_multiply(x, x);\n            DualReal x3 = D_multiply(x, x2);\n            DualReal x4 = D_multiply(x, x3);\n            DualReal y = d[1];\n            DualReal y2 = D_multiply(y, y);\n            DualReal y3 = D_multiply(y, y2);\n            DualReal y4 = D_multiply(y, y3);\n            DualReal z = d[2];\n            DualReal z2 = D_multiply(z, z);\n            DualReal z3 = D_multiply(z, z2);\n            DualReal z4 = D_multiply(z, z3);\n            DualReal w = DualReal(1.5,0);\n            DualReal w2 = D_multiply(w, w);\n            DualReal w3 = D_multiply(w, w2);\n            DualReal w4 = D_multiply(w, w3);\n            \n            Real ro = 0.5 * (1.0 + 2.2360679775);\n            Real ro2 = ro * ro;\n            Real ro3 = ro * ro2;\n            Real ro4 = ro * ro3;\n            \n            DualReal t0 = 8.0 * (x2 - ro4 * y2);\n            DualReal t1 = y2 - ro4 * z2;\n            DualReal t2 = z2 - ro4 * x2;\n            DualReal t3 = x4 + y4 + z4 - 2.0 * D_multiply(x2, y2) - 2.0 * D_multiply(x2, z2) - 2.0 * D_multiply(y2, z2);\n            DualReal p0 = D_multiply(t0, D_multiply(t1, D_multiply(t2, t3)));\n            DualReal t4 = (3.0 + 5.0 * ro) * D_sq(x2 + y2 + z2 - w2);\n            DualReal t5 = D_multiply(D_sq(x2 + y2 + z2 - (2.0 - ro) * w2), w2);\n            DualReal p1 = D_multiply(t4, t5);\n            return p0 + p1;\n            \n        }\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    float bound = length(p) - 3.5;\n    \n    return max(abs(de), bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = 10;\n    \n    //view basis\n    float polar = (iMouse == vec4(0)) ? 0.0 : tau32 * iMouse.y / iResolution.y + pi32;\n    float az = (iMouse == vec4(0)) ? time * tau32 : -tau32 * iMouse.x / iResolution.x;\n    mat3 viewTransform = rotationXZ(az) * rotationYZ(polar);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 7);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0) * 2.0;\n        color *= normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(vec3(0.2),1);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3Gzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdc3R2", "name": "Togliatti Quintic", "author": "skye_adaire", "description": "Implicit equation taken from:\nhttp://oliverlabs.net/wp-content/uploads/2018/04/AlgSurfManySings_English.pdf", "tags": ["distance", "geometry", "dual", "quintic", "real", "algebraic", "estimate"], "likes": 6, "viewed": 164, "date": "1568834771", "time_retrieved": "2024-06-20T19:44:37.135614", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n        case 10:\n        {\n            DualReal x = d[0];\n            DualReal x2 = D_multiply(x, x);\n            DualReal x3 = D_multiply(x, x2);\n            DualReal x4 = D_multiply(x, x3);\n            DualReal x5 = D_multiply(x, x4);\n            DualReal y = d[1];\n            DualReal y2 = D_multiply(y, y);\n            DualReal z = d[2];\n            DualReal z2 = D_multiply(z, z);\n            DualReal z3 = D_multiply(z, z2);\n            DualReal z4 = D_multiply(z, z3);\n            \n            Real a = -5.0 / 32.0;\n            Real b = -(5.0 - sqrt(5.0)) / 20.0;\n            Real d = -(1.0 + sqrt(5.0));\n                       \n            DualReal q = x2 + z2 + b * y2 + y + DualReal(d, 0);\n            DualReal p = \n                x5 - 5.0 * x4 - 10.0 * D_multiply(x3, z2) - \n                10.0 * D_multiply(x2, z2) + 20.0 * x2 + \n                5.0 * D_multiply(x, z4) - 5.0 * z4 + 20.0 * z2 - DualReal(16,0);\n                       \n            return (1.0 / 16.0) * p - a * D_multiply(y, D_sq(q));   \n        }\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    float bound = length(p) - 6.0;\n    \n    return max(abs(de), bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = 10;\n    \n    //view basis\n    float polar = (iMouse == vec4(0)) ? -0.5 : tau32 * iMouse.y / iResolution.y + pi32;\n    float az = (iMouse == vec4(0)) ? time * tau32 : -tau32 * iMouse.x / iResolution.x;\n    mat3 viewTransform = rotationXZ(az) * rotationYZ(polar);\n    vec3 viewPosition = viewTransform * vec3(0, 0.2, 13);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0) * 2.0;\n        color *= normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(vec3(0.2),1);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdc3R2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdc3RB", "name": "Untitled 0x00000007", "author": "harry7557558", "description": "simple test of non-recursive ray tracing", "tags": ["raytracing"], "likes": 5, "viewed": 163, "date": "1569197432", "time_retrieved": "2024-06-20T19:44:37.141642", "image_code": "#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n#define EPSILON 1e-5\n\nstruct Sphere{\n    vec3 O;\n    float r;\n};\nbool sphInt(in Sphere S, in vec3 P, in vec3 d, out float t, out vec3 n) {\t// doesn't work when inside\n\tvec3 p = P - S.O; if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= S.r*S.r) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(S.r*S.r - rd2); if (t < EPSILON) return false;\n\tn = (p + t * d) / S.r; return true;\n}\nconst Sphere sph1 = Sphere(vec3(-2.0,-2.0,1.0),1.0);\nconst Sphere sph2 = Sphere(vec3(3.0,-2.0,1.3),1.3);\nconst Sphere sph3 = Sphere(vec3(1.0,3.0,1.8),1.8);\nconst Sphere sph4 = Sphere(vec3(1.0,1.0,0.4),0.4);\n\n\nvec3 traceRay(vec3 p, vec3 d, vec3 light){\n    vec3 col=vec3(1.0), ecol;\n    for (int i=0;i<64;i++){\n    \tfloat t, mt=1e+12; vec3 n, mn; bool r=false;\n    \tt=-p.z/d.z;\n        if (t>EPSILON){\n            mt=t, mn=vec3(0.0,0.0,1.0), r=true;\n            vec3 q=p+t*d;\n            ecol = ((int(floor(q.x))&1)==(int(floor(q.y))&1)) ? vec3(135,206,250)/256.0 : vec3(148,166,188)/256.0;\n        }\n    \tif (sphInt(sph1,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(221,160,221)/256.0;\n    \tif (sphInt(sph2,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(173,216,230)/256.0;\n    \tif (sphInt(sph3,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(255,182,193)/256.0;\n    \tif (sphInt(sph4,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(244,164,96)/256.0;\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n            col*=ecol;\n        }\n        else {\n            col *= vec3(max(dot(d,light),0.0));\n            break;\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*(cos(0.4*iTime)+2.0);\n    float r = sqrt(40.0-h*h) + 0.5*(cos(iTime)+1.0) + 3.0;\n    vec3 pos = 2.0*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0)-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(0.0,0.0,1.0));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += traceRay(pos,normalize(d),light);\n    }\n    col/=float(AA*AA);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdc3RB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdc3W7", "name": "Local Spot Noise : NormalMapping", "author": "H4w0", "description": "Analytical Normal Mapping of Local Spot Noise for Procedural Surface Details Synthesis", "tags": ["procedural", "texture", "filtering", "normalmapping", "spotnoise"], "likes": 4, "viewed": 325, "date": "1568644693", "time_retrieved": "2024-06-20T19:44:38.238690", "image_code": "//=======================================================\n//= Local Spot Noise : Normal Mapping \n//=======================================================\n//== Local Spot Noise for Procedural Surface Details Synthesis \n//== https://acavalier.github.io/research/local-spot-noise-paper\n//=======================================================\n//== You can devise your own kernel by summing gaussians in the kernel function\n//=======================================================\n//== Analytic Filtering - https://www.shadertoy.com/view/tdyXzK\n//== Normal Mapping - https://www.shadertoy.com/view/Wdc3W7\n//== Control Map - https://www.shadertoy.com/view/Ws33W7\n//=======================================================\n//== Authors : Arthur Cavalier, Guillaume Gilet, Djamchid Ghazanfarpour\n//=======================================================\n\n\n\n// User Parameters -----------------------------------------------------------------\nconst uint  LSN_GLOBAL_SEED = 0u;\nconst float LSN_RESOLUTION  = 40.;\nconst int   LSN_IMPULSES    = 5;\nconst float LSN_SLOPE_SCALE = 0.1;\n\n// Constants -----------------------------------------------------------------------\nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n// RayTracing -----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\nfloat plane_intersection(in vec3 ro, in vec3 rd, in vec4 plane)\n{\n    return -(dot(ro,plane.xyz)+plane.w)/dot(rd,plane.xyz);\n}\n\n// Quick Matrix Maths\nfloat det2x2(in mat2 m)         {return (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\nmat2  inv2x2(in mat2 m)         {return (1./det2x2(m))*mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]);}\nmat2  tra2x2(in mat2 m)         {return mat2(m[0][0],m[1][0],m[0][1],m[1][1]);}\nmat2  rot2x2(in float th)       {return mat2(cos(th),-sin(th),sin(th),cos(th));}\n\n// PRNG ----------------------------------------------------------------------------\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n// Gaussians -----------------------------------------------------------------------\n/* Elliptical Gaussian Covariance Matrix    */\n/* From RotationAngle, ScaleX, ScaleY       */\n/* Geometric definition of the CovMatrix    */\nmat2 RxSxSxRinv(in float theta, in float sx, in float sy)\n{\n    float A = cos(theta);\n    float B = sin(theta);\n    float A2 = A*A;\n    float B2 = B*B;\n    float sx2 = sx*sx;\n    float sy2 = sy*sy;\n\n    float r00 = A2*sx2+B2*sy2;\n    float r11 = A2*sy2+B2*sx2;\n    float r01 = A*B*sx2-A*B*sy2;\n    float r10 = r01;\n    return mat2(r00,r01,r10,r11);\n}\n\n/* K : \\lambda    */\n/* M : \\mu        */\n/* S : \\Sigma     */\nfloat gaussian(in vec2 X, in float K, in vec2 M, in mat2 S)\n{\n    vec2 P = X-M;\n    return( K * exp( -0.5 * dot(P,inv2x2(S)*P) ) );\n}\n\n/* K : \\lambda                              */\n/* M : \\mu                                  */\n/* S : \\Sigma                               */\n/* Kp: Pixel footprint amplitude            */\n/* Sp: Pixel footprint covariance matrix    */\nvec3 gaussian_plus_derivatives_filtered(in vec2 X, in float K, in vec2 M, in mat2 S, in float Kp, in mat2 Sp)\n{\n    mat2  invSp = inv2x2(Sp);\n    mat2  invS = inv2x2(S);\n    vec2  XM = X-M;\n\n    mat2  S3 = inv2x2(invSp + invS);   \n    vec2  M3 = S3 * invS * XM ;\n\n    float dHdx = -dot(invS[0],XM-M3);\n    float dHdy = -dot(invS[1],XM-M3);\n    return vec3(LSN_SLOPE_SCALE * dHdx, LSN_SLOPE_SCALE * dHdy,1.) * m_2_pi * sqrt(det2x2(S3)) * gaussian(XM,K*Kp,vec2(0.),S+Sp);\n}\n\n\nvec3 kernel(in uint prng, in vec2 xy, in int cell_id, in float Kp, in mat2 Sp, in float orientation)\n{\n    float theta = orientation; \n    if(cell_id%2 == 0)\n        theta += m_pi_2;\n\n    return gaussian_plus_derivatives_filtered(xy, 1., vec2(0.0), RxSxSxRinv(theta,0.5,0.05), Kp, Sp);\n}\n\nvec3 local_spot_noise(in vec2 texture_coords)\n{\n    vec2 scaled_coords = LSN_RESOLUTION * texture_coords ;   \n    vec2 cell_coords = fract(scaled_coords);\n    vec2 cell_index = floor(scaled_coords);\n\n    vec2 dUdx = 0.5 * dFdx(scaled_coords);\n    vec2 dUdy = 0.5 * dFdy(scaled_coords);\n    mat2  Jc = mat2(dUdx,dUdy); \n    mat2  Sp = Jc*tra2x2(Jc);\n    float Kp = 1.0/(m_2_pi*sqrt(det2x2(Sp))); \n\n    ivec2 cell_ID;\n    uint  seed, prng;\n    vec2  cell_shot;\n\n    float distribution  = clamp( 0.5*sin(iTime), 0., 1. ); \n    float chaos_max     = clamp( 0.2*sin(0.2*iTime), 0., 1. ) * m_pi_2; \n    float orientation   = clamp( cos(iTime), 0., 1. ) * m_pi_2; \n\n    vec3  sum = vec3(0.0);\n    float wei = 1.0/float(LSN_IMPULSES);\n    float amp = 1.0;\n\tfor (int m = -1; m <= +1; m++)\n    for (int n = -1; n <= +1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed  = cell_seed(cell_ID, LSN_GLOBAL_SEED);\n        prng  = wang_hash(seed);\n\n        for(int k=0;k<LSN_IMPULSES;k++)\n        {\n            cell_shot.x = myrand_uniform_m_M(prng, 0.5-distribution, 0.5+distribution);  \n            cell_shot.y = myrand_uniform_m_M(prng, 0.5-distribution, 0.5+distribution); \n            float perturbation = myrand_uniform_m_M(prng, 0., chaos_max);\n            sum += kernel(prng,cell_coords-vec2(m,n)-cell_shot,cell_ID.x+cell_ID.y, Kp, Sp, orientation+perturbation);\n        }\n    }\n    return sum * wei;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = ((2.*fragCoord.xy-iResolution.xy) / iResolution.y);\n    vec2 mouse = clamp(iMouse.xy/iResolution.xy, 0., 1.);\n\n    // IQ - Raymarching Primitives https://www.shadertoy.com/view/Xds3zN Camera controls\n    vec3 origin = vec3( 0.5+3.5*cos(0.1*iTime + 6.0*mouse.x), 2.3 + 2.0*mouse.y, -0.5+3.5*sin(0.1*iTime + 6.0*mouse) );\n    vec3 target = vec3( 0.5, -0.4, -0.5 );\n    vec3 direction = compute_camera_ray_direction(coords, origin, target, 0.0);\n    \n    // Background Color\n    fragColor = vec4(vec3(0.),1.);\n\n    float hit = plane_intersection(origin,direction,vec4(0.,1.,0.,0.));\n    if(hit>0.0)\n    {\n        vec3 hit_position = (origin + hit*direction);\n        vec2 texture_coords = hit_position.xz/5.;\n        vec3 spot_noise = local_spot_noise(texture_coords);\n\n        float Dx = spot_noise.x;\n        float Dy = spot_noise.y;\n        float N = spot_noise.z;\n\n        fragColor.rgb = normal_map_from_slope(Dx,Dy);;\n        if(coords.x<0.)\n            fragColor.rgb = vec3(N);\n    }\n\n    fragColor.rgb*= smoothstep( 0.0, 0.01, abs(coords.x) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdc3W7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdc3zn", "name": "warlokkz - bouncing", "author": "warlokkz", "description": "hmm", "tags": ["pixelspirit"], "likes": 0, "viewed": 55, "date": "1567576665", "time_retrieved": "2024-06-20T19:44:38.238690", "image_code": "float circle(vec2 uv, vec2 ctr, float ry, float sz) {\n\tfloat pct = 0.;\n    pct = distance(uv, ctr);\n    pct = smoothstep(sz + 3./ry, sz, pct);\n    return pct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * fragCoord - R) / R.y;\n\tvec3 col = vec3(0.);\n    float mgn = 0.45;\n    float sz = 0.5;\n    vec3 wh = vec3(1.);\n    \n    vec2 lctr = vec2(\n     min(abs(sin(t)+0.5),1.-mgn),\n     min(abs(sin(t)-0.5),1.-mgn)\n    );\n    \n    vec2 rctr = vec2(\n     min(abs(sin(t)-0.5),1.-mgn),\n     min(abs(sin(t)+0.5),1.-mgn)\n    );\n        \n    vec2 cctr = vec2(\n     max(abs(cos(t)-sz),mgn),\n     max(abs(cos(t)-(0.5-sz)),mgn)\n    );\n    \n    vec2 ictr = vec2(\n     max(abs(cos(t)+sz),mgn),\n     max(abs(cos(t)+(0.5-sz)),mgn)\n    );\n    \n    col += circle(uv, lctr, R.y, sz) * vec3(0., 0., 1.);\n    col += circle(uv, rctr, R.y, sz) * vec3(0., 1., 0.);\n    col += circle(uv, cctr, R.y, sz) * vec3(1., 0., 0.);\n    col += circle(uv, ictr, R.y, sz) * wh;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdc3zn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcGWf", "name": "Distance Field Guide", "author": "dr2", "description": "Distance fields for various objects along two moving cut planes (horizontal mouse overrides autopaging)", "tags": ["raymarch", "sdf", "contour", "book"], "likes": 23, "viewed": 390, "date": "1569353149", "time_retrieved": "2024-06-20T19:44:38.259607", "image_code": "// \"Distance Field Guide\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmoothMin (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDirEx, ltDir, qHit, pgSize, pPos;\nfloat tCur, dstFarEx, dstFar, tpBook, phsTurn, idPage, rSep;\nint idObj, objType;\nconst float pi = 3.14159;\n\nconst int nPage = 15;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjTypeDst (vec3 p)\n{\n  float d;\n  p.yz = Rot2D (p.yz, 0.05 * 2. * pi * tCur);\n  p.xz = Rot2D (p.xz, 0.033 * 2. * pi * tCur);\n  if (objType <= 4) {\n    if      (objType == 1)  d = PrSphDf (p, 1.);\n    else if (objType == 2)  d = PrEllipsDf (p, vec3 (1.3, 1., 0.7));\n    else if (objType == 3)  d = PrBoxDf (p, vec3 (1., 0.8, 0.6));\n    else if (objType == 4)  d = PrTorusDf (p, 0.4, 1.);\n  } else if (objType <= 8) {\n    if      (objType == 5)  d = PrCylDf (p, 0.7, 1.);\n    else if (objType == 6)  d = PrEllCylDf (p, vec2 (0.8, 0.5), 1.);\n    else if (objType == 7)  d = PrCylAnDf (p, 0.6, 0.05, 1.);\n    else if (objType == 8)  d = PrCapsDf (p, 0.5, 1.);\n  } else if (objType <= 12) {\n    if      (objType == 9)  d = PrFlatCylDf (p, 0.7, 0.4, 1.);\n    else if (objType == 10) d = PrConeDf (p - vec3 (0., 0., 0.5), vec3 (0.6, 0.8, 1.));\n    else if (objType == 11) d = SmoothMin (PrSphDf (p - vec3 (0.1 + 0.9 * rSep, 0., 0.), 1.),\n       PrSphDf (p + vec3 (0.1 + 0.9 * rSep, 0., 0.), 1.), 0.2);\n    else if (objType == 12) d = SmoothMin (PrCylDf (p - vec3 (rSep, 0., 0.), 0.5, 1.),\n       PrCylDf (p.xzy + vec3 (rSep, 0., 0.), 0.5, 1.), 0.2);\n  } else {\n    if      (objType == 13) d = PrBoxDf (vec3 (abs (p.xz) - 0.7, p.y).xzy, vec3 (0.2, 1., 0.2));\n    else if (objType == 14) d = max (PrCylDf (vec3 (mod (p.x + 0.5, 1.) - 0.5, p.yz), 0.1, 1.),\n       abs (p.x) - 2.5);\n    else if (objType == 15) {\n      d = min (PrCylAnDf (p, 2., 0.2, 0.2), PrCylDf (p, 0.4, 0.2));\n      p.xy = Rot2D (p.xy, 2. * pi * (floor (5. * atan (p.y, - p.x) / (2. * pi) + 0.5)) / 5.);\n      d = min (d, PrCylDf (vec3 (p.x + 1., p.y, p.z).zyx, 0.2, 1.));\n    }\n  }\n  return d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = ObjTypeDst (q);\n  DMIN (1);\n  q = p;\n  q.y -= pPos.y;\n  d = PrBoxDf (q, vec3 (4., 0.01, 4.));\n  DMIN (2);\n  q = p;\n  q.z -= pPos.z;\n  d = PrBoxDf (q, vec3 (4., 4., 0.01));\n  DMIN (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj;\n  pPos = 1.2 * vec3 (0., - (0.5 + 0.5 * sin (0.09 * 2. * pi * tCur)),\n     (0.5 + 0.5 * sin (0.11 * 2. * pi * tCur)));\n  rSep = 0.5 + 0.5 * sin (0.3 * 2. * pi * tCur);\n  objType = int (idPage);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 1., 0.2, 0.2);\n    } else {\n      if (abs (((idObj == 2) ? vn.y : vn.z)) < 0.99) col4 = vec4 (0.1);\n      else col4 = (((idObj == 2) ? vec4 (1., 0.9, 1., 0.1) : vec4 (0.9, 1., 1., 0.1))) *\n         (0.3 + 0.7 * smoothstep (-0.2, 0.2, sin (8. * pi * ObjTypeDst (ro)))) *\n         (0.8 + 0.2 * smoothstep (0., 0.05, length (ro.yz - pPos.yz)));\n    }\n    col = col4.rgb * (0.2 + 0.7 * max (dot (vn, ltDir), 0.) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.));\n  } else {\n    col = vec3 (0.9);\n  }\n  return col;\n}\n\nvoid ExMain  (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 ori, ca, sa;\n  float el, az, zmFac;\n  el = -0.15 * pi;\n  az = 0.2 * pi * sin (0.05 * pi * tCur);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -40.);\n  dstFar = 100.;\n  zmFac = 6.;\n  rd = vuMat * normalize (vec3 (fCoord, zmFac));\n  ltDir = normalize (vec3 (0., 1., -1.));\n  fCol = clamp (ShowScene (ro, rd), 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rRad, hRad, hOff, np, zr, thFac;\n  dMin = dstFarEx;\n  rRad = 0.4;\n  hRad = 0.08;\n  hOff = 0.15;\n  thFac = 2.2;\n  np = float (nPage - 1);\n  q = p;\n  zr = mod (q.z, 0.5 * pgSize.z) - 0.25 * pgSize.z;\n  for (int k = 0; k < nPage; k ++) {\n    q = p;\n    q.y -= 0.5 * np * thFac * pgSize.y;\n    if (k == 0) q.xy = Rot2D (vec2 (q.x, q.y + np * thFac * pgSize.y * phsTurn),\n       -2. * pi * phsTurn);\n    else q.y -= thFac * pgSize.y * (phsTurn - float (k));\n    q.x -= pgSize.x + rRad - hOff;\n    d = max (PrRoundBoxDf (q, pgSize - pgSize.y, pgSize.y), hRad -\n       length (vec2 (q.x + pgSize.x - hOff, zr)));\n    DMINQ (k + 1);\n  }\n  q = p;\n  d = abs (q.z) - pgSize.z;\n  q.z = zr;\n  d = max (PrTorusDf (q, 0.5 * hRad, rRad + 0.3 * hRad), d);\n  DMINQ (nPage + 1);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFarEx) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ExObjDf (p + e.xxx), ExObjDf (p + e.xyy), ExObjDf (p + e.yxy), ExObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c, vn;\n  vec2 s, w;\n  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;\n  bool isImg;\n  pgSize = vec3 (2.5, 0.011, 2.5);\n  tpCyc = 3.;\n  tpWait = 4.;\n  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :\n     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));\n  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));\n  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);\n  isImg = false;\n  dstObj = ExObjRay (ro, rd);\n  if (dstObj < dstFarEx) {\n    ro += dstObj * rd;\n    vn = ExObjNf (ro);\n    nDotL = max (dot (vn, ltDirEx), 0.);\n    if (idObj <= nPage) {\n      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;\n      c = HsvToRgb (vec3 ((idPage - 1.) / float (nPage), 0.7, 1.));\n      s = pgSize.xz - abs (qHit.xz - vec2 (0.05, 0.));\n      col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n      if (qHit.y > 0.) {\n        w = (qHit.xz - vec2 (0.05, 0.)) / (pgSize.x - 0.05);\n        if (min (s.x, s.y) > 0.3) {\n          isImg = true;\n          ExMain (col, w);\n        } else if (min (s.x, s.y) > 0.27) {\n          col4 = vec4 (0.6 * c, 0.2);\n        } else {\n          col4 = vec4 (c, 0.2);\n        }\n      } else {\n        col4 = vec4 (c, 0.2);\n      }\n    } else if (idObj == nPage + 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      nDotL *= nDotL;\n    }\n    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);\n    if (isImg) col *= 0.2 + 0.8 * sh;\n    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tpBook = tCur;\n  az = 0.;\n  el = -0.5 * pi;\n  if (mPtr.z > 0.) {\n    tpBook = - clamp (1.05 * mPtr.x + 0.5, 0., 1.);\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vec3 (0.5, 0., -20.);\n  ro = vuMat * ro;\n  zmFac = 7.;\n  dstFarEx = 40.;\n  ltDirEx = normalize (vec3 (1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ExShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (1.)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcGWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcGWr", "name": "Submerging Tower", "author": "dr2", "description": "Up and down (structure from \"Stairs to Nowhere\"); why?", "tags": ["symmetry", "stairs", "structure"], "likes": 14, "viewed": 391, "date": "1568194584", "time_retrieved": "2024-06-20T19:44:38.275095", "image_code": "// \"Submerging Tower\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec4 szFlr;\nvec3 sunDir;\nvec2 twrCs;\nfloat dstFar, tCur, szFac, flSpc, nFlr, twrRad, bSizeV, cIdV, vShift;\nint idObj;\nconst int idFlr = 1, idStr = 2, idRl = 3, idStn = 4, idCln = 5;\nconst float pi = 3.14159, sqrt2 = 1.41421;\n\n#define SZ(x) (szFac * (x))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, stSpc, xLim1, xLim2, bRad, r, a, x;\n  bool topFlr, botFlr;\n  p.xz = Rot2Cs (p.xz, twrCs);\n  r = length (p.xz) - twrRad;\n  a = 2. * pi * ((floor (6. * atan (p.x, - p.z) / (2. * pi)) + 0.5) / 6.);\n  stSpc = SZ(6.);\n  xLim1 = abs (dot (p.xz, sin (a + vec2 (0.5 * pi, 0.)))) - SZ(22.);\n  xLim2 = xLim1 + SZ(16.);\n  bRad = SZ(0.35);\n  topFlr = (cIdV == 2. * nFlr - 1.);\n  botFlr = (cIdV == 0.);\n  dMin = dstFar;\n  if (topFlr) {\n    d = length (max (abs (vec2 (p.y + 0.5 * szFlr.w, r + szFlr.z + stSpc)) -\n       vec2 (0.5 * szFlr.w, szFlr.z), 0.));\n    DMIN (idFlr);\n    d = max (length (vec2 (p.y + SZ(0.4), abs (r + szFlr.z + stSpc - SZ(0.5))) -\n       (szFlr.z - SZ(0.1))) - bRad, - xLim2);\n    DMIN (idRl);\n  }\n  d = max (length (max (abs (vec2 ((topFlr ? - p.y : abs (p.y)) - flSpc,\n     r - 0.4 * (szFlr.z + stSpc))) - vec2 (szFlr.w, 1.4 * (szFlr.z + stSpc)), 0.)), - xLim1);\n  DMIN (idFlr);\n  d = max (length (max (abs (vec2 (p.y + szFlr.w, r)) - vec2 (szFlr.w,\n     2. * szFlr.z + stSpc + SZ(0.5)), 0.)), xLim2);\n  DMIN (idFlr);\n  p.zx = Rot2D (p.zx, a);\n  p.z = abs (p.z) - twrRad;\n  for (float sz = -1.; sz <= 1.; sz += 2.) {\n    if (! topFlr || sz < 0.) {\n      q.x = abs (p.x) - szFlr.x;\n      q.yz = p.yz - sz * vec2 (szFlr.y - szFlr.w, - (szFlr.z + stSpc));\n      d = abs (q.y) - (szFlr.y - szFlr.w - SZ(0.005));\n      q.xy = vec2 (q.x + sz * q.y, - sz * q.x + q.y) / sqrt2;\n      x = mod (q.x, SZ(sqrt2));\n      d = max (max (max (q.y - min (x, SZ(sqrt2) - x), abs (q.z) - szFlr.z),\n         - SZ(1.) - q.y), d);\n      DMIN (idStr);\n    }\n  }\n  d = max (length (vec2 (p.y + flSpc - SZ(4.), abs (r - szFlr.z) -\n     (2. * szFlr.z + stSpc - SZ(0.8)))) - bRad, - xLim1);\n  DMIN (idRl);\n  d = max (length (vec2 (p.y - SZ(3.5), abs (r - SZ(0.4)) -\n     (2. * szFlr.z + stSpc - SZ(0.1)))) - bRad, xLim2);\n  DMIN (idRl);\n  q = vec3 (abs (p.x) - szFlr.x - SZ(4.), p.y + 0.5 * flSpc,\n     abs (p.z - (szFlr.z + stSpc)) - szFlr.z);\n  d = max (length (vec2 ((q.x + q.y) / sqrt2, q.z)) - bRad,\n     abs (abs (p.x) - szFlr.x) - SZ(8.));\n  DMIN (idRl);\n  q.xz = vec2 (abs (p.x) - szFlr.x + SZ(4.), abs (p.z + szFlr.z + stSpc) - szFlr.z);\n  if (! botFlr) {\n    d = max (length (vec2 ((q.x - (p.y + 1.5 * flSpc)) / sqrt2, q.z)) - bRad,\n       abs (abs (p.x) - szFlr.x) - SZ(8.));\n    DMIN (idRl);\n  }\n  if (! topFlr) {\n    d = max (length (vec2 ((q.x - (p.y - 0.5 * flSpc)) / sqrt2, q.z)) - bRad,\n       abs (abs (p.x) - szFlr.x) - SZ(8.));\n    DMIN (idRl);\n  }\n  q.x = abs (p.x) - SZ(22.);\n  d = min (length (vec2 (q.x, p.y + flSpc - SZ(4.))),\n     length (vec2 (abs (p.x) - SZ(6.), p.y - SZ(3.5)))) - bRad;\n  d = max (d, max (abs (p.z) - (2. * szFlr.z + stSpc), szFlr.z - abs (abs (p.z) -\n     (szFlr.z + stSpc))));\n  DMIN (idRl);\n  q.yz = vec2 (p.y + flSpc - SZ(2.5), abs (abs (p.z) - (szFlr.z + stSpc)) - szFlr.z);\n  d = PrCapsDf (q.xzy, SZ(0.7), SZ(2.));\n  DMIN (idStn);\n  if (! topFlr) {\n    d = length (vec2 (q.x, p.z)) - SZ(0.8);\n    DMIN (idCln);\n  }\n  d = PrCapsDf (vec3 (abs (p.x) - SZ(6.), p.y - SZ(2.5), q.z).xzy, SZ(0.7), SZ(2.));\n  DMIN (idStn);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps, sy;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.y == 0.) rd.y = 0.001;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + dHit * rd;\n    p.y -= vShift;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    d = abs (sy) + eps;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n      p.y = p.y - bSizeV * (cIdV + 0.5);\n      d = min (ObjDf (p), d);\n    }\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  p.y -= vShift;\n  cIdV = floor (p.y / bSizeV);\n  p.y -= bSizeV * (cIdV + 0.5);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, sd, a, tCloud;\n  rd.y = abs (rd.y);\n  a = atan (rd.x, - rd.z);\n  if (rd.y < 0.02 * Fbm1 (32. * a) + 0.005) {\n     col = mix (0.5 * vec3 (0.4, 0.5, 0.7), vec3 (0.6, 0.4, 0.4),\n        0.5 + 0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n        (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    tCloud = -0.05 * tCur;\n    p = rd * (100. - ro.y) / rd.y;\n    p.xz += tCloud * vec2 (1.);\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    d = fd;\n    ds *= fd;\n    for (int j = 0; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    sunCol = vec3 (1., 0.8, 0.7) * pow (sd, 1024.) +\n       vec3 (1., 0.4, 0.2) * pow (sd, 256.);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n       max (rd.y - 0.1, 0.))) + 0.3 * sunCol;\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, tWav, ht;\n  tWav = 0.5 * tCur;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.8 * (1. + sin (length (p) - 3. * tCur));\n  p *= 0.1;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.1, 0.001 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, dstWat, nDotS;\n  bool watRefl, isBg;\n  watRefl = false;\n  isBg = true;\n  bSizeV = 2. * flSpc;\n  dstObj = ObjRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (dstWat < min (dstObj, dstFar)) {\n    watRefl = true;\n    ro += dstWat * rd;\n    rd = reflect (rd, WaveNf (ro, dstWat));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == idFlr) {\n      col4 = vec4 (0.7, 0.4, 0.2, 0.1);\n      if (vn.y > 0.99) col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05,\n         mod (0.5 * length (ro.xz) / SZ(1.), 1.));\n    } else if (idObj == idStr) {\n      col4 = vec4 (0.6, 0.3, 0.2, 0.1);\n    } else if (idObj == idRl) {\n      col4 = vec4 (0.7, 0.7, 0.9, 0.4);\n    } else if (idObj == idStn) {\n      col4 = vec4 (0.9, 0.9, 0.1, 0.4);\n    } else if (idObj == idCln) {\n      col4 = vec4 (0.6, 0.8, 0.6, 0.2);\n    }\n    nDotS = max (dot (vn, sunDir), 0.);\n    if (idObj != idFlr && idObj != idStr) nDotS *= nDotS;\n    col = col4.rgb * (0.2 + 0.8 * nDotS) +\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    isBg = false;\n  } else if (! watRefl && rd.y < 0.) {\n    watRefl = true;\n    ro += dstWat * rd;\n    rd = reflect (rd, WaveNf (ro, dstWat));\n  }\n  if (isBg) col = BgCol (ro, rd);\n  if (watRefl) col = mix (mix (vec3 (0., 0.15, 0.), vec3 (0., 0.1, 0.1),\n     smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.8 * col, 1. - pow (abs (rd.y), 4.));\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.04 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az -= 2.5 * pi * sin (0.002 * pi * tCur);\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 2.;\n  szFac = 0.25;\n  szFlr = SZ(vec4 (14., 8.5, 4., 0.5));\n  flSpc = 2. * szFlr.y - szFlr.w;\n  nFlr = 5.;\n  t = SmoothBump (0.25, 0.75, 0.2, mod (0.03 * tCur, 1.));\n  vShift = -0.95 * 4. * nFlr * flSpc * t;\n  twrCs = sin (pi * t * (2. * floor (mod (0.03 * tCur, 2.)) - 1.) + vec2 (0.5 * pi, 0.));\n  twrRad = SZ(60.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 1.5 * nFlr * flSpc, -120.);\n  sunDir = normalize (vec3 (-1., 0.2, -1.));\n  dstFar = 200.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcGWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcGWS", "name": "rainbow ooze", "author": "ahihi", "description": "made at Bring Your Own Beamer / Otaniemi Night of Arts 2019", "tags": ["2d"], "likes": 2, "viewed": 324, "date": "1569182839", "time_retrieved": "2024-06-20T19:44:39.869271", "image_code": "// uncomment to use square pattern instead of circles\n//#define SQUARES\n\n#define TAU 6.283185307179586\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec2 polar(vec2 p_rect) {\n    return vec2(atan(p_rect.y, p_rect.x), length(p_rect));\n}\n\nvec2 rect(vec2 p_polar) {\n    return vec2(p_polar.y * cos(p_polar.x), p_polar.y * sin(p_polar.x));\n}\n\nvec2 rotate(float angle, vec2 p) {\n    return rect(polar(p) + vec2(angle, 0.0));\n}\n\nfloat map(float l0, float r0, float l1, float r1, float x) {\n  return (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 map(vec2 l0, vec2 r0, vec2 l1, vec2 r1, vec2 p) {\n  return vec2(map(l0.x, r0.x, l1.x, r1.x, p.x), map(l0.y, r0.y, l1.y, r1.y, p.y));\n}\n\nvec2 map(float l0, float r0, float l1, float r1, vec2 p) {\n  return map(vec2(l0), vec2(r0), vec2(l1), vec2(r1), p);\n}\n\nvec3 rgb2hsl(vec3 rgb) {\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n    float v, m, vm, r2, g2, b2;\n    float h = 0.0;\n    float s = 0.0;\n    float l = 0.0;\n    v = max(max(r, g), b);\n    m = min(min(r, g), b);\n    l = (m + v) / 2.0;\n    if(l > 0.0) {\n        vm = v - m;\n        s = vm;\n        if(s > 0.0) {\n            s /= (l <= 0.5) ? (v + m) : (2.0 - v - m);\n            r2 = (v - r) / vm;\n            g2 = (v - g) / vm;\n            b2 = (v - b) / vm;\n            if(r == v) {\n                h = (g == m ? 5.0 + b2 : 1.0 - g2);\n            } else if(g == v) {\n                h = (b == m ? 1.0 + r2 : 3.0 - b2);\n            } else {\n                h = (r == m ? 3.0 + g2 : 5.0 - r2);\n            }\n        }\n    }\n    h /= 6.0;\n    return vec3(h, s, l);\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n    float r = l;\n    float g = l;\n    float b = l;\n    float v = (l <= 0.5) ? (l * (1.0 + s)) : (l + s - l*s);\n    if(v > 0.0) {\n        float m, sv;\n        int sextant;\n        float fract, vsf, mid1, mid2;\n        m = l + l - v;\n        sv = (v - m) / v;\n        h *= 6.0;\n        sextant = int(h);\n        fract = h - float(sextant);\n        vsf = v * sv * fract;\n        mid1 = m + vsf;\n        mid2 = v - vsf;\n        if(sextant == 0) {\n            r = v;\n            g = mid1;\n            b = m;\n        } else if(sextant == 1) {\n            r = mid2;\n            g = v;\n            b = m;\n        } else if(sextant == 2) {\n            r = m;\n            g = v;\n            b = mid1;\n        } else if(sextant == 3) {\n            r = m;\n            g = mid2;\n            b = v;\n        } else if(sextant == 4) {\n            r = mid1;\n            g = m;\n            b = v;\n        } else if(sextant == 5) {\n            r = v;\n            g = m;\n            b = mid2;\n        }\n    }\n    return vec3(r, g, b);\n}\n\nvec3 hueshift(float dh, vec3 color) {\n  vec3 hsl = rgb2hsl(color);\n  hsl.x = fract(hsl.x + 1.0 + dh);\n  return hsl2rgb(hsl);\n}\n\nvec2 aspect_correct(float aspect, vec2 p) {\n  return aspect >= 1.0\n    ? vec2(p.x, p.y/aspect)\n    : vec2(p.x*aspect, p.y);\n}\n\nvec2 aspect_decorrect(float aspect, vec2 p) {\n  return aspect >= 1.0\n    ? vec2(p.x, p.y*aspect)\n    : vec2(p.x/aspect, p.y);\n}\n\nbool checkers(vec2 d, vec2 uv) {\n    bool px = mod(uv.x, 2.0*d.x) < d.x;\n    bool py = mod(uv.y, 2.0*d.y) < d.y;\n    return px != py;\n}\n\nbool circlers(vec2 d, float kr, vec2 uv) {\n    float x = fract(uv.x/d.x);\n    float y = fract(uv.y/d.y);\n\n    return distance(vec2(x, y), vec2(0.5)) < 0.5*kr;\n}\n\nfloat quant(float n, float x) {\n    return floor(n * x)/n;\n}\n\nfloat cool_pow(float b, float e) {\n  return (b < 0.0 ? -1.0 : 1.0) * pow(abs(b), e);\n}\n\nvec3 shatter(float time, vec2 xy) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = aspect_correct(aspect, map(vec2(0.0), iResolution.xy, vec2(-1.0), vec2(1.0), xy));\n    vec2 uv_p = polar(uv);\n    uv_p.x += uv_p.x < 0.0 ? TAU : 0.0;\n    \n    float turn = map(0.0, TAU, 0.0, 1.0, uv_p.x);\n    \n    float wob1 = sin(0.47*time) * sin(7.0*uv_p.x + 1.47*time);\n    float wob2 = cos(-0.66*time)  * cos(5.0*uv_p.x - 1.21*time);\n    vec2 uv1_p = uv_p * vec2(1.0, 1.0 + 0.3 * wob1);\n    vec2 uv2_p = uv_p * vec2(1.0, 1.0 + 0.28 * wob2);\n    vec2 uv1 = rect(uv1_p);\n    vec2 uv2 = rect(uv2_p);\n\n    vec2 uv1a = rotate(0.05*time, uv1);\n    vec2 uv1b = rotate(-0.036*time, uv2);\n\n    float hhh = 90.0;\n    float ggg = 4.0;\n    float n1 = quant(ggg, map(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(uv1a * hhh, 0.4*time))));\n    float n2 = quant(ggg, map(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(-0.53*time, uv1b * hhh))));\n    vec3 c1 = vec3(abs(uv1a.x), 1.0-abs(uv1a.x), 0.0) * n1;\n    vec3 c2 = vec3(0.0, 0.0, abs(uv1b.y)) * n2;\n    float kr = 0.5;\n\n    #ifdef SQUARES\n    bool p1 = checkers(vec2(0.012), uv1a + time * vec2(0.005, 0.01));\n    bool p2 = checkers(vec2(0.016), uv1b + time * vec2(-0.004, 0.0065));\n    #else\n    bool p1 = circlers(vec2(0.012), kr, uv1a + time * vec2(0.005, 0.01));\n    bool p2 = circlers(vec2(0.02), kr, uv1b + time * vec2(-0.004, 0.0065));    \n    #endif\n    \n    vec3 color = (p1 != p2) ? c1 : c2;\n    float sh = map(-1.0, 1.0, 0.0, 1.0, wob1) * map(-1.0, 1.0, 0.0, 1.0, wob2);\n    color = hueshift(0.1*time + sh*0.3 + turn, color) * pow(sh, map(-1.0, 1.0, 0.01, 0.15, sin(0.12*time)));\n\n    vec3 color_hsl = rgb2hsl(color);\n    color_hsl.y *= map(0.0, 1.0, 0.25, 1.0, pow(sh, 1.0));\n    color_hsl.z *= map(0.0, 1.0, 0.25, 1.0, pow(sh, 1.0));\n\n    color = hsl2rgb(color_hsl);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n\n    vec2 xy_p = polar(xy - 0.5*iResolution.xy);\n    xy_p.x += 0.00008*xy_p.y * cool_pow(sin(-0.13*iTime), 1.3) * sin(0.89*pow(xy_p.y, 0.5) - 4.0*iTime);\n    xy_p.x += 0.0005*sin(0.23*iTime)*xy_p.y;\n    vec2 xy1 = rect(xy_p) + 0.5*iResolution.xy;\n    \n    vec3 color = shatter(iTime, xy1);\n    fragColor = vec4(color*3.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcGWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcGz4", "name": "Metaball Blob", "author": "vitasa", "description": "A Blob I made using metaballs influenced by https://www.shadertoy.com/view/4lKXzd", "tags": ["blob"], "likes": 6, "viewed": 201, "date": "1567990350", "time_retrieved": "2024-06-20T19:44:40.081613", "image_code": "const float numOfBalls = 10.;\t\t\t\t\t\t\t\t\t\t// number of balls\nconst float distanceTraveled = .8;\nconst float speed = 1.;\t\t\t\t\t\t\t\t\t\t\t\t// speed of effect\n\nfloat metaballs(vec2 uv, float time) {\t\t\t\t\t\t\t\t\t\n    float size = .5;\t\t\t\t\t\t\t\t\t\t\t\t// base size\n    const float startIndex = numOfBalls;\n\tconst float endIndex = numOfBalls * 2.;\n    \n    for(float i = startIndex; i < endIndex; i++) {\t\t\t\t\t// create x number of balls\t\t\t\t\t\t\t\t\t\t\t\n        float radius = distanceTraveled * sin(time + i * 2.);\t\t// calculate radius\n        vec2 ball = radius * vec2(sin(i), cos(i));\t\t\t\t\t// ball position\n\t\tsize += 1. / pow(i, distance(uv, ball));\t\t\t\t\t// metaball calculation\n    }\n    return size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    float time = iTime * speed;\t\t\t\t\t\t\t\t\t\t// assigning time\n    vec2 uv = (2. * fragCoord - R.xy) / R.y;\t\t\t\t\t\t// center coordinates\n\tuv *= 3.; \t\t\t\t\t\t\t\t\t\t\t\t\t\t// zoom out    \n\n    float blob = metaballs(uv, time);\t\t\t\t\t\t\t\t// creating the blob\n    blob = smoothstep(1., 1. + 50./R.y, blob);\t\t\t\t\t\t// Anti Aliasing\t\t\t\n    \n    vec3 col = vec3(.8, .2, .2);\t\t\t\t\t\t\t\t\t// color of blob\n    vec3 final = blob * col;\t\t\t\t\t\t\t\t\t\t// combining the color with the effect\n    fragColor = vec4(final, 1); \t\t\t\t\t\t\t\t\t// ouput\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcGz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdcGzf", "name": "Truchet Rainbow Tiling Floor", "author": "MeDope", "description": "  ", "tags": ["rainbowtruchetraymarchingsdf"], "likes": 8, "viewed": 151, "date": "1568974387", "time_retrieved": "2024-06-20T19:44:40.081613", "image_code": "#define SURF_DIST .001\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\nmat2x2 rot(float a) \n{\n\treturn mat2x2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdf(vec3 p)\n{\n    return min(1.,p.y);\n}\n\nfloat march(vec3 ro, vec3 rd) \n{\n    float dS, dO;\n    vec3 p;\n    for(int i=0; i < MAX_STEPS; i++)\n    {\n    \tp = ro + dO * rd;\n        dS = sdf(p);\n        dO += dS;\n        if(dS < SURF_DIST || dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = sdf(p);\n\tvec2 e = vec2(0.01, 0.0);\n\tvec3 n = d - vec3(sdf(p - e.xyy), sdf(p - e.yxy), sdf(p - e.yyx));\n\treturn normalize(n);\n}\n\nfloat light(vec3 p, vec3 ro)\n{\n    vec3 lp = ro + vec3(0.0, 0.0, -0.1);\n    vec3 l = normalize(lp - p);\n    vec3 n = normal(p);\n    return dot(n, l);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(27.754, 78.4476))) * 47125.3567);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    rd.zy *= rot(0.4);\n    vec3 ro = vec3(0.5, 5.5, iTime * 3.5);\n    vec3 col;\n\tfloat m = march(ro, rd);\n    float im = 1.0 / m;\n    vec3 p = ro + rd * m;\n    col += light(p, ro);\n    p.x += sin(iTime*3. + p.z*0.3)*0.5;\n    vec2 fluv = floor(p.xz);\n    vec2 fruv = fract(p.xz) - 0.5;\n    float t = fruv.y - fruv.x;\n    if (hash(fluv) > 0.5) {t = fruv.y + fruv.x;}\n    col += smoothstep(0.1,0.0,vec3(abs(t))) + smoothstep(0.9,1.0,vec3(abs(t)));\n    col *= 0.5 + 0.5*cos(-iTime*2.+p.zzz*0.15+vec3(0,2,4));\n    col *= im*im*100.;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdcGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdcGzN", "name": "Dual Quaternion Julia Set", "author": "skye_adaire", "description": "Uses automatic differentiation to compute the distance estimate and surface normal. The hypercomplex functions are my design. This draws heavily from http://blog.hvidtfeldts.net/index.php/2011/12/distance-estimated-3d-fractals-vii-dual-numbers/", "tags": ["fractal", "julia", "quaternion", "dual", "set", "automatic", "hypercomplex", "differentiation"], "likes": 8, "viewed": 169, "date": "1567884392", "time_retrieved": "2024-06-20T19:44:42.238940", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define Quaternion vec4\n\nQuaternion H_negate(Quaternion h)\n{\n    return -h;\n}\n\nQuaternion H_conjugate(Quaternion h)\n{\n    return Quaternion(h[0], -h[1], -h[2], -h[3]);\n}\n\nReal H_sqnorm(Quaternion h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Quaternion h)\n{\n    return length(h);\n}\n\nQuaternion H_inverse(Quaternion h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nQuaternion H_normalize(Quaternion h)\n{\n    return normalize(h);\n}\n\nQuaternion H_add(Quaternion lhs, Quaternion rhs)\n{\n    return lhs + rhs;\n}\n\nQuaternion H_subtract(Quaternion lhs, Quaternion rhs)\n{\n    return lhs - rhs;\n}\n\nQuaternion H_multiply(Quaternion lhs, Quaternion rhs)\n{\n    Complex lhs_0 = Complex(lhs[0], lhs[1]);\n    Complex lhs_1 = Complex(lhs[2], lhs[3]);\n    Complex rhs_0 = Complex(rhs[0], rhs[1]);\n    Complex rhs_1 = Complex(rhs[2], rhs[3]);\n\n    return Quaternion(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nQuaternion H_divide(Quaternion lhs, Quaternion rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Quaternion h)\n{\n    return H_norm(h) < eps32;\n}\n\nstruct PolarQuaternion\n{\n    Real norm;\n    Real angle;\n    vec3 axis;//normalized\n};\n\nPolarQuaternion H_toPolar(Quaternion h)\n{\n    PolarQuaternion result;\n    Real vectorLength2 = dot(h.yzw, h.yzw);\n\n    if(H_isZero(vectorLength2))\n    {\n        result.axis = vec3(0);\n    }\n    else//normalize the vector part\n    {\n        result.axis = h.yzw / sqrt(vectorLength2);\n    }\n\n    result.norm = sqrt(H_sq(h[0]) + vectorLength2);\n\n    if(H_isZero(result.norm))\n    {\n        result.angle = 0.0;\n    }\n    else\n    {\n        result.angle = acos(h[0] / result.norm);\n    }\n\n    return result;\n}\n\nQuaternion H_toCartesian(PolarQuaternion p)\n{\n    return p.norm * Quaternion(cos(p.angle), sin(p.angle) * p.axis);\n}\n\nQuaternion H_versor(Real angle, vec3 axis)\n{\n    return H_toCartesian(PolarQuaternion(1.0, angle / 2.0, axis));\n}\n\nPolarQuaternion H_power(PolarQuaternion polar, Real exponent)\n{\n    polar.norm = pow(polar.norm, exponent);\n    polar.angle = polar.angle * exponent;\n    return polar;\n}\n\nQuaternion H_power(Quaternion h, Real exponent)\n{\n    if(H_isZero(exponent))\n    {\n        return Quaternion(1,0,0,0);\n    }\n    else\n    {\n        return H_toCartesian(H_power(H_toPolar(h), exponent));\n    }\n}\n\nQuaternion H_sq(Quaternion h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\n#define DualQuaternion mat2x4\n\nDualQuaternion D_add(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs + rhs;\n}\n\nDualQuaternion D_subtract(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return lhs - rhs;\n}\n\nDualQuaternion D_multiply(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualQuaternion D_divide(DualQuaternion lhs, DualQuaternion rhs)\n{\n    return DualQuaternion(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualQuaternion D_power(DualQuaternion d, Real exponent)\n{\n    return DualQuaternion(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\nmat3 rotation3XZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nfloat getJuliaDE(DualQuaternion dd, vec3 inPosition, out vec3 outNormal, out int i)\n{\n    Quaternion c = Quaternion(inPosition, 0);\n\n    //gradient\n    DualQuaternion dx = DualQuaternion(c, Quaternion(1,0,0,0));\n    DualQuaternion dy = DualQuaternion(c, Quaternion(0,1,0,0));\n    DualQuaternion dz = DualQuaternion(c, Quaternion(0,0,1,0));\n\n    for(i = 0; i <= 10; i++)\n    {\n        if(H_sqnorm(dx[0]) > 16.0)\n        {\n            break;\n        }\n\n        dx = D_add(D_multiply(dx, dx), dd);\n        dy = D_add(D_multiply(dy, dy), dd);\n        dz = D_add(D_multiply(dz, dz), dd);\n    }\n\n    //the final position is the same for all partials\n    vec3 fp = dx[0].xyz;\n    float r = H_norm(dx[0]);\n    \n    vec3 vdx = vec3(dx[1]);\n    vec3 vdy = vec3(dy[1]);\n    vec3 vdz = vec3(dz[1]);\n    float dr = length(vdx) + length(vdy) + length(vdz);\n    outNormal = normalize(vec3(dot(fp, vdx), dot(fp, vdy), dot(fp, vdz)));\n\n  \treturn 0.5 * log(r) * r / dr;//better for low iteration counts\n    //return 0.5 * r / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //view basis\n    mat3 viewTransform = rotation3XZ(iTime * 0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 2);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n    \n    //julia constant\n    float time = 0.2 * iTime;\n    float ct = cos(time);\n    float st = sin(time);\n    Quaternion d = Quaternion(0, ct * 1.1, 0, 0);\n    DualQuaternion dd = DualQuaternion(d, Quaternion(0));\n\n    //ray march the distance field\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    \n    //last julia outputs\n    int iEscape;\n    vec3 globalNormal;\n    \n    for(i = 0; i < 150; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getJuliaDE(dd, p, globalNormal, iEscape);\n        \n        if(de < 0.001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        fragColor = vec4(globalNormal, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdcGzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3D4", "name": "carouselShade", "author": "foran", "description": "carouselShade", "tags": ["carouselshade"], "likes": 2, "viewed": 73, "date": "1568558393", "time_retrieved": "2024-06-20T19:44:42.238940", "image_code": "#define PI 3.14159\n#define REP(p,r) (mod(p + r/2.,r) - r/2.)\n\nmat2 rot(float a)\n{\n  float ca = cos(a); float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\nfloat idA(vec2 p, float n)\n{\n  return floor((atan(p.y, p.x)) * n / (2. * PI) );\n}\n\nvec2 modA(vec2 p, float n)\n{\n  float a = atan(p.y, p.x);\n  a = mod(a, (2. * PI) / n );\n  return vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat map(vec3 p)\n{\n  float dist = 1000.;\n  float time = iTime + p.z * 2.;\n  p.z += iTime;\n  p.z = REP(p.z, 3.);\n  vec3 cp = p;\n  float a = atan(p.y, p.x);\n  a *= 5.;\n  vec3 dir = normalize(p);\n  p += (dir * sin(a) + cos(a) * vec3(0.,0.,1.)) * .75;\n  float tor = length(vec2(length(p.xy) - 4.,p.z)) - .545 * pow((sin(a + time) * .5 + .45), 2.);\n  dist = min(dist, tor);\n  p = cp;\n  tor = length(vec2(length(p.xy) - 4.,p.z)) - .05;\n  dist = min(dist, tor);\n  return dist;\n}\n\nvec3 lookAt(vec3 ro, vec3 rt, vec2 uv)\n{\n  vec3 fd = normalize(rt - ro);\n  vec3 ri = cross(vec3(0.,1.,0.), fd);\n  vec3 up = cross(fd, ri);\n  return normalize(vec3(fd + ri * uv.x + up * uv.y));\n}\n\nvec3 normal(vec3 p)\n{\n  vec3 n;\n  vec2 eps=vec2(.01,0.);\n  n.x=map(p)-map(p+eps.xyy);\n  n.y=map(p)-map(p+eps.yxy);\n  n.z=map(p)-map(p+eps.yyx);\n  return normalize(n);\n}\n\nvec3 shade(vec3 ro,vec3 rd,vec3 p,vec3 n)//  color\n{\n  vec3 ld=normalize(vec3(.1,1.,-.5));\n  vec3 col=vec3(0.);\n  col=vec3(1.)*max(0.,dot(n,ld))*.943;//                                 .3\n  //col += mix(vec3(1.,.7,.1), vec3(.1,1.,.7), rd.x)*length(p-ro)*.05;//     rd.x\n  col+=mix(vec3(0.0, 0.851, 1.0),vec3(0.7176, 0.0, 1.0),rd.x)*length(p-ro)*.05;//     rd.x\n  col+=mix(vec3(.7882,.098,.1529),vec3(1.0, 1.0, 1.0),rd.y)*length(p-ro)*.05;//     rd.y\n  return col;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n   vec3 ro = vec3(0.,0.,-10.);\n  vec3 sub = vec3(0.,0.,0.);\n  vec3 rd = lookAt(ro, sub, uv);\n  vec3 cp = ro;\n  float st = 0.; float cd = 0.;\n  for(;st < 1.; st += 1. / 128.)\n  {\n    cd = map(cp);\n    if(cd < .01) break;\n    cp += rd * cd * .15;\n  }\n  vec3 n=normal(cp);\n  vec3 col=shade(ro,rd,cp,n);//     \n  vec4 out_color=vec4(1.);\n  out_color = vec4(col,1.)*(1.-st);\n  fragColor=vec4(out_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdd3Dl", "name": "LebronShades", "author": "Philiperen", "description": "Very kewl boi", "tags": ["kewl"], "likes": 0, "viewed": 50, "date": "1569513840", "time_retrieved": "2024-06-20T19:44:42.366335", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float i = sin(uv.y*iTime*sin(uv.x)*iTime);\n    float j = cos(10.0+iTime*20.0*i);\n    float q = sin(i*j/uv.y);\n\n    // Output to screen\n    fragColor = vec4(i*j*q,sin(uv.x),sin(uv.y),0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdd3Dl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdd3Dr", "name": "Test_Locked_shader", "author": "suspendwings", "description": "Locked_shader", "tags": ["2d", "lock"], "likes": 1, "viewed": 40, "date": "1568273296", "time_retrieved": "2024-06-20T19:44:42.493579", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    \n    // Time varying pixel color\n    vec3 col = 0.0 + 0.3*(cos(2.0*iTime+uv.xyx+vec3(0,1,2)));\n    vec4 fog = vec4(col,1.0);\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = mix(tex, fog, 0.8);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdd3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3R4", "name": "Poincare Disk Transformations", "author": "skye_adaire", "description": "This is showing a translation of the Poincare disk using complex-valued matrices for the Mobius transform. The hypercomplex functions are my design. I studied the thesis of Martin von Gagern http://mediatum.ub.tum.de/node?id=1210572", "tags": ["mobius", "complex", "disk", "transform", "hyperbolic", "poincare"], "likes": 11, "viewed": 197, "date": "1567958377", "time_retrieved": "2024-06-20T19:44:44.669652", "image_code": "//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexVector2 mat2x2\n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d)\n{\n   for(int i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = clip * 1.02;\n    \n    vec3 color;\n    \n    if(length(p) < 1.0)\n    {\n        vec2 z = p;\n        \n        //this transform moves us around \n        //transformation could also be done by complex matrix composition, just like view matrices in R3\n        //since this is a fully proceedural shader, I recompute the translation each frame\n        float time = 0.5 * iTime;\n        vec2 mouse = -(iMouse.xy / iResolution.xy - 0.5) * 5.0;\n        mouse.x *= iResolution.x / iResolution.y;\n        vec2 def = 4.0 * vec2(cos(0.5*time), 0.1*sin(time));                        \n        vec2 v = iMouse.z > 0.0 ? mouse : def;\n        \n        ComplexMatrix2 translation = M_translateDisk(v);\n        z = M_multiply(translation, z);\n         \n        //these transforms comprise the fundamental domain of the tiling\n        ComplexMatrix2 transformFromA = identityMob;\n        ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n        float angleB = tau32 / 8.0;\n        Complex versorB = H_versor(angleB);\n        ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n        ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n        ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.852), H_versor(0.852));\n        ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n        vec3 distances;\n        z = getPoincareTiling(\n            transformFromA, transformToA,\n            transformFromB, transformToB,\n            transformFromC, transformToC,\n            z, distances);\n\n        distances = vec3(1) - distances;\n        distances = pow(distances, vec3(30.0));\n\n        color = mix(distances, vec3(0.1), smoothstep(0.97, 1.0, length(p)));\n\n        /*\n\t\t//to test individual domain edges\n        vec2 z = M_multiply(transformToB, p);\n        color = vec3(0,0,1.0-abs(z.y));\n        color = pow(color, vec3(30.0));\n        color += vec3(pow(1.0 - length(z), 3.0));\n\t\t*/\n    }\n    else\n    {\n     \tcolor = vec3(0.1);   \n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3R4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdd3R7", "name": "rotating oriental pattern 1", "author": "FabriceNeyret2", "description": "based on 4-branches cross contra-rotative along a checker grid.", "tags": ["pattern", "tiling", "cross", "2tweets", "gif", "short", "golf", "islamic", "reproduction"], "likes": 5, "viewed": 305, "date": "1568133554", "time_retrieved": "2024-06-20T19:44:44.827296", "image_code": "// Fork of  https://shadertoy.com/view/wd3GR7\n// NB: -2 by moving A= inside S macro at first use, but would be really ugly ;-)\n// funny: ceil(U) instead of floor create artifacts at some resolutions\n   \n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 3.* (u+u-R)/R.y, A = mod(floor(U),2.);\n    A = abs( 3.1*(fract(U)-.5) * mat2(cos(vec4(0,33,11,0) +(A.x==A.y?1.:-1.)*iTime))),\n    O += .5 - ( min(A.y,A.x) -.5 ) /30. *R.y;\n//  O += sin(12.* clamp( .5 - ( min(A,A.x) -.5 ) /420. *R , 0., 1. ).y) // variant\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdd3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdd3Rj", "name": "Animandelbrot 2", "author": "Cotterzz", "description": "another version, this time zooming and changing the escape limit over time", "tags": ["fractal", "mandelbrot", "time"], "likes": 3, "viewed": 68, "date": "1568900103", "time_retrieved": "2024-06-20T19:44:45.015064", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    float slow = 2.00;\n    float scale = slow/iTime;\n    //if(scale>3.00){scale=3.00;}\n    float cx = -1.782/scale;//-10.00+((iMouse.x)/iResolution.x);\n    float cy = -0.50;//+((iMouse.y)/iResolution.y);\n    float limit =((sin(iTime*3.30)+1.00)*100.00) + 3.6;//iMouse.x;//iTime/slow;\n    float ax=(cx+uv.x)*scale;\n    float ay=(cy+uv.y)*scale;\n    float a1=ax;\n    float b1=ay;\n    int lp=0;\n    for(int i=0;i<255;++i){\n        float a2=(a1*a1)-(b1*b1)+ax;\n        float b2=2.0*a1*b1+ay;\n        a1=a2;\n        b1=b2;\n        lp=i;\n        if(((a1*a1)+(b1*b1))>limit){break;}\n    }\n    vec3 col = vec3(a1*b1,a1*b1,a1*b1);\n    if(lp==254){\n        col = vec3(sin(((a1*a1)/(b1*b1))/(iTime/(1.00*slow))), sin((a1/b1)/(iTime/(2.00*slow))),sin(((b1/a1)/(a1/b1))/(iTime/(3.00*slow))));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdd3Rj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3WM", "name": "Log Triangular Voronoi Lighted 2", "author": "aiekick", "description": "based on [url=https://www.shadertoy.com/view/WdSSDz]Log Triangular Voronoi Lighted[/url]", "tags": ["voronoi", "2", "triangular", "lighted"], "likes": 12, "viewed": 388, "date": "1568678295", "time_retrieved": "2024-06-20T19:44:45.463522", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via NoodlesPlate (https://github.com/aiekick/NoodlesPlate/releases)\n\n// thumbail at 14.95\n\nconst vec3 color0 = vec3(0.224071,0.115035,0.348214);\nconst vec3 color1 = vec3(0.6,1.1,1.6);\nconst vec3 lightColor = vec3(0.751786,1.6,0.6);\n\nvec3 shape(vec2 g)\n{\n\tfloat c = 9.0;\n    \t\n    float t = iTime;\n\tfloat t1 = t * 0.1;\n\t\n\tvec2 p = vec2(0), sp = p;\n\t\n    g = vec2(log(length(g))-t, atan(g.x,g.y));\n        \n    float t2 = sin(t*0.2)*0.5+0.5;\n        \n    g.y = abs(fract(g.y/6.28318*(10.*t2+2.))-0.5);\n\n    for(int x=-2;x<=2;x++)\n    for(int y=-2;y<=2;y++)\n    {\t\n        p = vec2(x,y);\n        p += .5 + .5*sin( t1 * 10. + 9. * fract(sin((floor(g)+p)*mat2(2,5,5,2)))) - fract(g);\n        p *= mat2(cos(t1), -sin(t1), sin(t1), cos(t1));\n        float d = max(abs(p.x)*.866 - p.y*.5, p.y);\n        if (d < c)\n        {\n            c = d;\n            sp = p;\n        }\n    }\n\n    return vec3(c,sp);\n}\n\nvec3 getColor(vec2 uv, float t)\n{\n    float k = 0.01;\n\tvec3 f = shape(uv);\n\tfloat fx = (f.x-shape(uv + vec2(k,0.0)).x)/k;\n\tfloat fy = (f.x-shape(uv + vec2(0.0, k)).x)/k;\n\t\n    vec3 n = normalize(vec3(0,0,1) - vec3(fx, fy, k) * 0.5);\n\t\n\tvec3 col = mix( color0, color1, f.x );\n\n    float r = sin(t+f.y)*cos(t+f.z)*0.5+0.5;\n\tcol = mix(col.rgb, mix(col.brg, col.gbr, r), 1.0-r);\n    \n\tcol += 0.5 * pow(max(dot( n, vec3(0,0,1)), 0.), 16.) * lightColor;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\n\tfragColor = vec4( getColor(uv, iTime), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3WM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdd3zs", "name": "Raytracing Demo", "author": "pineapplemachine", "description": "This shader has a focus on code readability. It displays a simple raytraced scene demonstrating shadows, reflections, and refraction.", "tags": ["raytracing", "refraction", "shadows", "reflections"], "likes": 6, "viewed": 392, "date": "1569137758", "time_retrieved": "2024-06-20T19:44:47.471521", "image_code": "// This shader was written by Sophie Kirschner.\n// It is released under a CC0 public domain license.\n\n// Maximum number of reflections/refractions per fragment\n// Higher numbers look better but are more demanding\n#define MAX_PATHS 8\n\n// Color of the \"void\" - the space behind the scene\n#define VOID_COLOR vec3(0.45, 0.65, 0.8)\n\n// Set to 1.0 for a nice typical viewing experience.\n// Set higher to reduce the FOV and produce a zoomed-in effect.\n// Set lower to increase FOV and produce a fisheye effect.\n#define CAMERA_ZOOM 1.0\n\n// The scene is illuminated by a directional light and\n// an ambient light; their parameters are defined here.\n#define LIGHT_DIRECTION normalize(vec3(-4.7, -4.2, 9.5))\n#define AMBIENT_LIGHT 0.3\n\n// Name the various recognized material numbers.\n#define MATERIAL_NONE 0\n#define MATERIAL_RED_LIGHTER 1\n#define MATERIAL_RED_DARKER 2\n#define MATERIAL_GREEN_LIGHTER 3\n#define MATERIAL_GREEN_DARKER 4\n#define MATERIAL_PLANE 5\n\n// Number of vertices in the scene's vertices[] array\n#define NUM_VERTICES 17\n// Number of triangles in the scene's triangles[] array\n#define NUM_TRIANGLES 14\n\n// Struct returned by the cast_ray function\nstruct cast_ray_result {\n    // Identify the triangle within the triangles[] array\n    // that the ray intersected\n    int tri_index;\n    // UV describing where on the triangle the intersection occurred\n    vec2 uv;\n    // Distance to the intersected point on the triangle\n    float dist;\n    // 3D position of the ray/triangle intersection\n    vec3 intersection;\n};\n\n// Describe the position of verticies in 3D space\nconst vec3 vertices[NUM_VERTICES] = vec3[NUM_VERTICES](\n    // Big Transparent Pyramid\n    vec3(+0.0, +2.0, +0.0),\n    vec3(+1.0, +0.0, +1.0),\n    vec3(-1.0, +0.0, +1.0),\n    vec3(+1.0, +0.0, -1.0),\n    vec3(-1.0, +0.0, -1.0),\n    // Small Green Pyramid\n    vec3(+2.0, +1.0, +2.0),\n    vec3(+2.5, +0.0, +2.5),\n    vec3(+1.5, +0.0, +2.5),\n    vec3(+2.5, +0.0, +1.5),\n    vec3(+1.5, +0.0, +1.5),\n    // Plane\n    vec3(-4.0, +0.0, -4.0),\n    vec3(-4.0, +0.0, +4.0),\n    vec3(+4.0, +0.0, -4.0),\n    vec3(+4.0, +0.0, +4.0),\n    vec3(+4.0, +1.0, -4.0),\n    vec3(+4.0, +1.0, +4.0),\n    vec3(-4.0, +1.0, +4.0)\n);\n    \n// Describe triangles by identifying their verticies.\n// The w component describes the triangle's material.\nconst ivec4 triangles[NUM_TRIANGLES] = ivec4[NUM_TRIANGLES](\n    // Big Transparent Pyramid\n    ivec4(0, 2, 1, MATERIAL_RED_LIGHTER),\n    ivec4(0, 4, 2, MATERIAL_RED_DARKER),\n    ivec4(0, 3, 4, MATERIAL_RED_LIGHTER),\n    ivec4(0, 1, 3, MATERIAL_RED_DARKER),\n    // Small Green Pyramid\n    ivec4(5, 7, 6, MATERIAL_GREEN_DARKER),\n    ivec4(5, 9, 7, MATERIAL_GREEN_LIGHTER),\n    ivec4(5, 8, 9, MATERIAL_GREEN_DARKER),\n    ivec4(5, 6, 8, MATERIAL_GREEN_LIGHTER),\n    // Plane\n    ivec4(10, 11, 12, MATERIAL_PLANE),\n    ivec4(13, 12, 11, MATERIAL_PLANE),\n    ivec4(14, 12, 13, MATERIAL_PLANE),\n    ivec4(15, 14, 13, MATERIAL_PLANE),\n    ivec4(15, 13, 16, MATERIAL_PLANE),\n    ivec4(13, 11, 16, MATERIAL_PLANE)\n);\n\n// Get surface color given a material number\n// plus ray intersection data.\nvec3 get_material_color(int material, cast_ray_result ray) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? vec3(1.0, 0.8, 0.8) :\n        material == MATERIAL_RED_DARKER ? vec3(1.0, 0.4, 0.4) :\n        material == MATERIAL_GREEN_LIGHTER ? vec3(0.1, 0.8, 0.3) :\n        material == MATERIAL_GREEN_DARKER ? vec3(0.0, 0.6, 0.1) :\n        material == MATERIAL_PLANE ? vec3(0.25 + ray.uv * 0.5, 0.75) :\n        VOID_COLOR\n    );\n}\n\n// Get reflectivity of a material.\n// 0.0 is not reflective at all.\n// 1.0 is maximally reflective, a perfect mirror.\nfloat get_material_reflectivity(int material) {\n    return (\n        material == MATERIAL_NONE ? 0.0 :\n        material == MATERIAL_PLANE ? 0.8 :\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        0.125\n    );\n}\n\n// Get index of refraction of a material.\nfloat get_material_refraction(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 1.25 :\n        material == MATERIAL_RED_DARKER ? 1.25 :\n        0.0\n    );\n}\n\n// Get opacity of a material.\n// 0.0 is totally transparent.\n// 1.0 is completely opaque.\nfloat get_material_opacity(int material) {\n    return (\n        material == MATERIAL_RED_LIGHTER ? 0.25 :\n        material == MATERIAL_RED_DARKER ? 0.25 :\n        1.0\n    );\n}\n\n// Determine whether a line intersects a triangle.\n// Returns a vector whose components are: (intersected?, U, V)\n// https://www.shadertoy.com/view/MlGcDz\nvec3 line_intersects_tri(vec3 line_a, vec3 line_b, vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 v1v0 = tri_b - tri_a;\n    vec3 v2v0 = tri_c - tri_a;\n    vec3 rov0 = line_a - tri_a;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, line_b);\n    float d = 1.0 / dot(line_b, n);\n    float u = d * dot(-q, v2v0);\n    float v = d * dot(q, v1v0);\n    float t = d * dot(-n, rov0);\n    if(u < 0.0 || v < 0.0 || (u + v) > 1.0) t = -1.0;\n    return vec3(t, u, v);\n}\n\n// Given the three points of a triangle in clockwise order,\n// compute the surface normal of that triangle.\n// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#targetText=A%20surface%20normal%20for%20a,winding).\nvec3 get_tri_surface_normal(vec3 tri_a, vec3 tri_b, vec3 tri_c) {\n    vec3 u = tri_b - tri_a;\n    vec3 v = tri_c - tri_a;\n    return normalize(cross(u, v));\n}\n\n// Generate a look-at rotation matrix based on a camera\n// position and view target.\n// https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/lookat-function\nmat3 look_at_matrix(vec3 camera_position, vec3 camera_target) {\n    vec3 forward = normalize(camera_target - camera_position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return mat3(right, up, forward);\n}\n\n// Check all triangles in the scene for intersection with a ray.\n// Return information about the intersection nearest to ray_origin,\n// if there was any intersection.\ncast_ray_result cast_ray(vec3 ray_origin, vec3 ray_target) {\n    int result_tri_index = -1;\n    vec2 result_uv = vec2(0.0);\n    float result_dist = 1e18;\n    vec3 result_intersection = vec3(0.0);\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5 &&\n            tri_distance < result_dist\n        ) {\n            result_tri_index = tri_index;\n            result_uv = intersection.yz;\n            result_dist = tri_distance;\n            result_intersection = intersection_point;\n        }\n    }\n    return cast_ray_result(\n        result_tri_index,\n        result_uv,\n        result_dist,\n        result_intersection\n    );\n}\n\n// Cast a ray from a surface toward the scene's directional light\n// source and determine how much in shadow the surface is.\n// Considers opacity, but not refraction.\nfloat cast_shadow_ray(vec3 ray_origin, vec3 ray_target) {\n    float shadow_amount = 0.0;\n    for(int tri_index = 0; tri_index < NUM_TRIANGLES; tri_index++) {\n        vec3 tri_a = vertices[triangles[tri_index].x];\n        vec3 tri_b = vertices[triangles[tri_index].y];\n        vec3 tri_c = vertices[triangles[tri_index].z];\n        vec3 intersection = line_intersects_tri(\n            ray_origin, ray_target, tri_a, tri_b, tri_c\n        );\n        vec3 intersection_point = (\n            (tri_b * intersection.y) +\n            (tri_c * intersection.z) +\n            (tri_a * (1.0 - intersection.y - intersection.z))\n        );\n        float tri_distance = length(\n            ray_origin - intersection_point\n        );\n        if(intersection.x > 0.0 &&\n            tri_distance > 1e-5\n        ) {\n            shadow_amount += (\n                get_material_opacity(triangles[tri_index].w)\n            );\n            if(shadow_amount >= 1.0) {\n                break;\n            }\n        }\n    }\n    return shadow_amount;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec3 sample_ray(vec3 ray_origin, vec3 ray_target) {\n    // Initialize the ray queue -\n    // list of ray paths that should contribute to this sample\n    // It will initially contain only the input sample\n    int next_path_index = 1;\n    vec3 queued_ray_origin[MAX_PATHS];\n    vec3 queued_ray_target[MAX_PATHS];\n    float queued_ray_weight[MAX_PATHS];\n    float color_accumulator_weight = 0.0;\n    vec3 color_accumulator = vec3(0.0);\n    queued_ray_origin[0] = ray_origin;\n    queued_ray_target[0] = ray_target;\n    queued_ray_weight[0] = 1.0;\n    // Enumerate rays in the queue\n    for(int path_index = 0; path_index < MAX_PATHS; path_index++) {\n        // Check for queue exhaustion\n        if(path_index >= next_path_index) {\n            break;\n        }\n        // Ignore rays with a very small contribution to the overall\n        // sample result\n        float this_ray_weight = queued_ray_weight[path_index];\n        if(this_ray_weight < 0.02) {\n            continue;\n        }\n        // Time to trace the ray\n        vec3 this_ray_origin = queued_ray_origin[path_index];\n        vec3 this_ray_target = queued_ray_target[path_index];\n        cast_ray_result this_ray = cast_ray(\n            this_ray_origin, this_ray_target\n        );\n        vec3 tri_normal = get_tri_surface_normal(\n            vertices[triangles[this_ray.tri_index].x],\n            vertices[triangles[this_ray.tri_index].y],\n            vertices[triangles[this_ray.tri_index].z]\n        );\n        // Get material properties for the intersected triangle\n        int material = (this_ray.tri_index >= 0 ?\n            triangles[this_ray.tri_index].w : MATERIAL_NONE\n        );\n        vec3 material_color = get_material_color(material, this_ray);\n        float material_reflectivity = get_material_reflectivity(material);\n        float material_opacity = get_material_opacity(material);\n        // Calculate diffuse directional lighting with shadows\n        float shadow_amount = cast_shadow_ray(\n            this_ray.intersection, -LIGHT_DIRECTION\n        );\n        float diffuse_light_intensity = AMBIENT_LIGHT + max(0.0,\n\t\t\t(1.0 - AMBIENT_LIGHT) * 2.0 * dot(tri_normal, -LIGHT_DIRECTION)\n        );\n        float light_intensity = clamp(\n\t\t\tAMBIENT_LIGHT + diffuse_light_intensity - shadow_amount,\n            AMBIENT_LIGHT, 1.0\n\t\t);\n        // Cast a reflection ray\n        // http://paulbourke.net/geometry/reflected/\n        // https://www.fabrizioduroni.it/2017/08/25/how-to-calculate-reflection-vector.html\n        if(material_reflectivity > 1e-3) {\n            vec3 reflected_ray_target = this_ray_target - (\n                2.0 * tri_normal * dot(this_ray_target, tri_normal)\n            );\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * material_reflectivity\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = reflected_ray_target;\n            next_path_index++;\n        }\n        // Cast a refracted ray for transparent surfaces\n        if(material_opacity < (1.0 - 1e-3)) {\n            // Compute the refracted ray direction\n            // https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n            float refraction = get_material_refraction(material);\n            float iof_before = 1.0;\n            float iof_after = refraction;\n            float cos_incidence = dot(tri_normal, this_ray_target);\n            vec3 refraction_normal = tri_normal;\n            if(cos_incidence < 0.0) {\n                cos_incidence = -cos_incidence;\n            }\n            else {\n                iof_before = refraction;\n                iof_after = 1.0;\n                refraction_normal = -refraction_normal;\n            }\n            float eta = iof_before / iof_after;\n            float k = 1.0 - eta * eta * (1.0 - cos_incidence * cos_incidence);\n            vec3 refracted_ray_target = (\n                k < 0.0 ? this_ray_target :\n                eta * this_ray_target + (eta * cos_incidence - sqrt(k)) * refraction_normal\n            );\n            // Add refraced ray to the queue\n            queued_ray_weight[next_path_index] = (\n                this_ray_weight * (1.0 - material_opacity)\n            );\n            queued_ray_origin[next_path_index] = this_ray.intersection;\n        \tqueued_ray_target[next_path_index] = refracted_ray_target;\n            next_path_index++;\n        }\n        // Determine the color sampled at the end of this ray\n        // and add it to the accumulator\n        vec3 this_sample_color = light_intensity * material_color;\n        float this_sample_weight = max(0.0, (\n            this_ray_weight * material_opacity * (1.0 + light_intensity)\n        ));\n        color_accumulator = (\n            color_accumulator * color_accumulator_weight +\n            this_sample_color * this_sample_weight\n        ) / (\n            color_accumulator_weight + this_sample_weight\n        );\n        color_accumulator_weight += this_sample_weight;\n    }\n    // No more paths to trace! Return the final sample color.\n    return color_accumulator;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Describe the position of the camera in the scene\n    float t = 1.5 + 0.75 * iTime;\n    vec3 camera_position = vec3(6.0 * cos(t), 3.5, 6.0 * sin(t));\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    mat3 camera_rot_matrix = look_at_matrix(\n        camera_position, camera_target\n    );\n    // Determine the direction of the ray\n    // Rays toward the center of the view travel in a more\n    // directly forward direction; rays toward the edges of\n    // the view travel at more of an angle to the camera.\n    // This produces a nice field-of-view effect.\n    vec2 ray_coord = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 forward_ray_direction = normalize(\n        vec3(ray_coord.x, ray_coord.y, CAMERA_ZOOM)\n    );\n    vec3 ray_direction = camera_rot_matrix * forward_ray_direction;\n    // Calculate the color of the fragment at this location.\n    vec3 sample_color = sample_ray(camera_position, ray_direction);\n    fragColor = vec4(sample_color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdd3zs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddGD2", "name": "sphere emergence", "author": "tono", "description": "i practiced raymarching shader", "tags": ["raymarching"], "likes": 3, "viewed": 98, "date": "1569338812", "time_retrieved": "2024-06-20T19:44:47.472519", "image_code": "const float pi = acos(-1.);\nconst float pi2 = pi*2.;\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a) ,s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nvec2 pmod(vec2 p , float r)\n{\n\tfloat a = atan(p.x,p.y) +pi/r;\n\tfloat n = pi2 / r;\n\ta = floor(a/n) * n;\n\treturn p * rot(-a);\n}\n\nfloat sdPlane(vec3 p)\n{\n\tfloat d = p.y;\n\treturn d;\n}\n\nvec3 foldx(vec3 p)\n{\n\tp.x = abs(p.x);\n\treturn p;\n}\n\t\nfloat sdBox(vec3 p , float s)\n{\n\tp = abs(p) - s;\n\treturn max(max(p.x,p.y),p.z);\n}\n\t\nfloat distFunc(vec3 p)\n{\n\tvec3 pp = mod(p,5.) - 8./2.;\n\tfloat s= 0.8;\n\treturn sdBox(pp,s);\t\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn ((clamp(abs(fract(h+vec3(0.,2.,1.)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (fragCoord.xy * 2.  -  iResolution.xy) / min(iResolution.x ,iResolution.y) ;\n\t\n\tfloat t = iTime *6.;\n\t\n\tvec3 cpos = vec3(0.,0.,-5.);\n\tvec3 cup = vec3(0.,1.,0.);\n\tvec3 cside = normalize(cross(cpos,cup));;\n\tcpos += vec3(t,t/5.,0.);\n\tfloat target = 2.5;\n\tvec3 rd = normalize(vec3(((1.0 - dot(p,p)) + cside * p.x + cup * p.y)));\n\t\n\trd.xy = pmod(rd.xy,8. * max(0.01,sin(pi/8.*t)));\n\t\n\tfloat transparent = sin(pi/8. * t) * 10.;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat depth = 0.0;\n\tfloat c = 0.;\n\tfloat ac = 0.;\n\tfor(int i = 0; i < 99 ; i++)\t\n\t{\n\t\tvec3 rayPos = cpos + rd* depth;\n\t\tfloat d = distFunc(rayPos);\n\t\td = max(abs(d),0.01 * transparent);\n\t\tac += exp(-d*3.);\n\t\tdepth += d;\n\t}\n\tdepth = ac/depth ;\n\tcol = hsv(depth,ac*0.01,depth);\n\t\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddGD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddGD4", "name": "Simple Clouds 2D", "author": "Jahrulnr", "description": "This code i get from Minecraft PE Shader. This looks great.", "tags": ["clouds"], "likes": 2, "viewed": 473, "date": "1568581560", "time_retrieved": "2024-06-20T19:44:47.472519", "image_code": "#define TIME iTime\n\nhighp float rand( highp vec2 n) { \n\treturn fract(sin(dot(n, vec2(0.360,0.690))) * 1001.585);\n}\n\nhighp float noise(highp vec2 p){\n\thighp vec2 ip = floor(p);\n\thighp vec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\thighp float res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    highp vec3 color = vec3(0., 0., 1.);\n    \n    highp float speed = TIME * .35;\n    const int n = 15;\n    \n    highp float awan = 0.;\n    highp float d = 1.400;\n    highp vec2 pos = uv*3.1;\n    for(int i = 0; i < n; i++){\n        awan += noise(pos) / d;\n        pos *= 2.040;\n        d *= 2.064;\n        pos -= speed * 0.127 * pow(d, 0.9);\n    }\n    \n    color += pow(abs(awan), 2.604);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddGR2", "name": "color transform", "author": "Easy", "description": "good", "tags": ["tutorial"], "likes": 3, "viewed": 100, "date": "1568882222", "time_retrieved": "2024-06-20T19:44:47.597029", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv1 = (1.2*fragCoord.xy - iResolution.xy) /iResolution.y;\n    vec2 uv;\n\tuv.x = uv1.x*cos(1.0*iTime) - uv1.y*sin(1.0*iTime);\n    uv.y = uv1.x*sin(-1.1*iTime) + uv1.y*cos(1.3*iTime);\n    // Time varying pixel color\n    float r = 0.3 + 0.45*cos(0.923*iTime + 2.0 + sin(-uv.x+uv.y));\n\tfloat g = 0.45 + 0.27*sin(1.3*iTime + 4.0 + sin(2.0*uv.x) + smoothstep(0.0,1.0,cos(uv.y + uv.x)));\n    float b = 0.4 + 0.32*cos(-0.57*iTime + 6.0 + uv.x*1.8*uv.y);\n    vec3 col = vec3(b,r,g);\n    \n    //col = vec3(uv.x,uv.y,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddGR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddGRN", "name": "wire net", "author": "kaswan", "description": "wire net", "tags": ["weave", "wireneting"], "likes": 6, "viewed": 175, "date": "1567963081", "time_retrieved": "2024-06-20T19:44:47.602879", "image_code": "#define EPSILON 0.001\n#define MAX_ITERATION 64\n#define PI 3.1415926535\n\nfloat sphere(vec3 p, vec3 c, float r)\n{\n\treturn length(p - c) - r;\n}\n\nfloat sdBox(vec3 p, vec3 c, vec3 b)\n{\n\tvec3 d = abs(p - c) - b;\n    return  max(max(d.x, d.y), d.z); \n}\n\nfloat sdCylinder(vec3 p, vec3 c, vec2 h)\n{\n  \tp -= c;\n    \n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveV(vec3 p, vec2 h)\n{\n\tp.z += sin(p.y * 1.0) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveV2(vec3 p, vec2 h)\n{\n\tp.z += sin(p.y * 1.0 + PI) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveH(vec3 p, vec2 h)\n{\n  \tp.xyz = p.yxz;\n\tp.z += sin(p.y * 1.0) * 0.2;\n  \t\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderWaveH2(vec3 p, vec2 h)\n{\n  \tp.xyz = p.yxz;\n\tp.z += sin(p.y * 1.0 + PI) * 0.2;\n    \n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat scene(vec3 pos)\n{\n \tfloat grid_size = PI;\n    vec3 p, pR;\n    float d; \n    \n    vec3 sph = vec3(15.0 * sin(iTime), 15.0 * cos(iTime), 3.0);\n    vec3 box = vec3(15.0 * sin(iTime + PI), 15.0 * cos(iTime + PI), 4.0);\n    \n    float theta = 2.0 * iTime * PI / 180.0;\n\tfloat c = cos(iTime * 0.25);\n    float s = sin(iTime * 0.25);\n    \n    float deg = -60.0;\n    float rad = deg * PI / 180.0;\n    p = pos;\n    pos.y = p.y * cos(rad) + p.z * sin(rad);\n    pos.z = -p.y * sin(rad) + p.z * cos(rad);\n    \n    vec2 r = pos.xy - sph.xy;\n    float h = 5.0 / (1.0 + .01 * dot(r, r)); \n    pR.x = pos.x * c + pos.y * s;\n\tpR.y = pos.x * -s + pos.y * c;\n\tpR.z = pos.z + h;\n    //pR = pos;\n    \n    p = pR;\n    p.x += grid_size * 0.5;\n    p.x = mod(p.x, grid_size * 2.0) - grid_size;\n\td = sdCylinderWaveV(p, vec2(0.2, 150));\n\n    p = pR;\n    p.x += grid_size * 0.5;\n    p.x = mod(p.x + grid_size, grid_size * 2.0) - grid_size;\n\td = min(d, sdCylinderWaveV2(p, vec2(0.2, 150)));\n    \n    p = pR;\n    p.y -= grid_size * 0.5;\n    p.y = mod(p.y, grid_size * 2.0) - grid_size;\n    d = min(d, sdCylinderWaveH(p, vec2(0.2, 150)));\n\n\tp = pR;\n    p.y -= grid_size * 0.5;\n    p.y = mod(p.y + grid_size, grid_size * 2.0) - grid_size;\n    d = min(d, sdCylinderWaveH2(p, vec2(0.2, 150)));\n\n    d = min(d, sphere(pos, sph, 6.0));\n    d = min(d, sdBox(pos, box, vec3(4.0, 4.0, 4.0)));\n    d = min(d, sdCylinder(pos, vec3(0.0, 0.0, 4.0), vec2(4.0, 4.0)));\n    \n    return d;\n}\n\nvec3 normal(vec3 pos)\n{\n \tvec3 e = vec3(EPSILON, 0, 0);\n    \n    vec3 n;\n    n.x = scene(pos + e.xyy) - scene(pos - e.xyy);\n    n.y = scene(pos + e.yxy) - scene(pos - e.yxy);\n    n.z = scene(pos + e.yyx) - scene(pos - e.yyx);\n    \n    return normalize(n);\n}\n\nvec3 lightDir = vec3(1.0, 2.5, 1.0);\n\nvec3 traceReflect(vec3 pos, vec3 ray)\n{\n    pos += ray * 0.1;\n    \n    for (int i = 0; i < MAX_ITERATION; i++){\n    \tfloat d = scene(pos);\n        if (abs(d) < EPSILON){\n            \n            vec3 color = vec3(0.0, 1.0, 1.0);\n            \n            vec3 N = normal(pos);\n            vec3 L = normalize(lightDir);\n\t\t\tfloat diffuse = max(dot(N,L), 0.0);\n            \n\t\t\tcolor *= diffuse;\n\n            //vec3 R = reflect(-L,N);\n\t\t\t//vec3 V = -ray;\n            //float specular = pow(max(dot(R,V), 0.0), 32.0);\n            \n            //color += specular;\n\n\t\t\treturn color * 0.6;\n        }\n    \t\n        pos += ray * d;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspectRatio;\n    \n    vec3 pos = vec3(0.0, 0.0, 50.0);\n\n    vec3 dir = normalize(vec3(uv, -3.0));\n    \n    for (int i = 0; i < MAX_ITERATION; i++){\n    \tfloat distance = scene(pos);\n        if (distance < EPSILON){\n            \n            vec3 color = vec3(0.5, 0.5, 0.5);\n            \n            // diffuse\n            vec3 N = normal(pos);\n            vec3 L = normalize(lightDir);\n\t\t\tfloat diffuse = max(dot(N,L), 0.0);\n\t\t\tcolor *= diffuse;\n\n            // specular by Phong model\n            //vec3 R = reflect(-L,N);\n            //vec3 V = -dir;\n            //float specular = pow(max(dot(R,V), 0.0), 32.0);\n            \n            // specular by Blinn model\n\t\t\tvec3 V = -dir;\n            vec3 H = normalize(V + L);\n            float specular = pow(max(dot(H,N), 0.0), 32.0);\n\n            // reflection\n            vec3 Ref = reflect(-V,N);\n            //vec3 Ref = refract(-V, N, 0.96);\n            vec3 reflectColor = traceReflect(pos, Ref);\n            color += reflectColor;\n\n            color += specular;\n\n\t\t\tfragColor = vec4(color, 1.0);\n\n            return;\n        }\n        pos += dir * distance;\n    }\n\tfragColor = vec4(0.1, 0.4, 0.6, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddGRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddGWH", "name": "manhattan transfer", "author": "tristanwhitehill", "description": "bike bike", "tags": ["bike"], "likes": 3, "viewed": 87, "date": "1568388514", "time_retrieved": "2024-06-20T19:44:48.106304", "image_code": "\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 3.0*sin( (iTime*.4)*130.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = ceil( p );\n\t\n\tvec2 u = f*f*(sin(iTime*.5)*5.-1.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat manhatanDistance(vec2 pointA, vec2 pointB)\n{\n    return abs(pointA.x - pointB.x) + abs(pointA.y - pointB.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n= (noise(uv));\n   float fm = sin(iTime*.5)*.5;\n   float fm2 = sin(iTime*.03)*fm*n;\n    //Define points used for partitioning the plane\n    vec2 points[10];\n    points[0] = vec2(0.048, 0.259-fm);\n\tpoints[1] = vec2(0.45+fm2, 0.233-fm2);\n\tpoints[2] = vec2(0.386-fm*n, 0.556-fm);\n\tpoints[3] = vec2(0.847, 0.868+fm);\n\tpoints[4] = vec2(0.437+fm, 0.718-fm2);\n\tpoints[5] = vec2(0.095+fm, 0.558);\n\tpoints[6] = vec2(0.513-fm2, 0.680-fm2);\n\tpoints[7] = vec2(0.013, 0.865-fm);\n\tpoints[8] = vec2(0.168+fm2*n, 0.653+fm2);\n\tpoints[9] = vec2(0.891-fm, 0.721+fm);\n    \n    \n    //Define the point colors\n    vec4 pointColors[10];\n    pointColors[0] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[1] = vec4(255.,255.,255., 1.0);\n\tpointColors[2] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[3] = vec4(255.,255.,255., 1.0);\n\tpointColors[4] = vec4(0.,0.,0.0, 1.0);  \n    pointColors[6] = vec4(255.,255.,255., 1.0);\n\tpointColors[5] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[7] = vec4(255.,255.,255., 1.0);\n\tpointColors[8] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[9] = vec4(255.,255.,255., 1.0);\n    \n    //Allow the image to be scaled\n\n    //Preserve aspect ratio\n    if(iResolution.x > iResolution.y)\n    {\n        uv.x = uv.x / iResolution.y * iResolution.x;\n        for(int i = 0; i < 10; i++)\n        {\n            points[i].x = points[i].x / iResolution.y * iResolution.x;\n        }\n    }\n    else\n    {\n        uv.y = uv.y / iResolution.x * iResolution.y;\n        for(int i = 0; i < 10; i++)\n        {\n            points[i].y = points[i].y / iResolution.x * iResolution.y;\n        }\n    }\n    \n    //Find the point closest to the pixel that is beeing colored now\n    float minDistance = manhatanDistance(uv, points[0]);\n    fragColor = pointColors[0];\n    for(int i = 1; i < 10; i++)\n    {\n        float currentDistance = manhatanDistance(uv, points[i]);\n        if(currentDistance < minDistance)\n        {\n            minDistance = currentDistance;\n            fragColor = pointColors[i];\n        }\n    }\n    \n    //Color the points\n    if(minDistance < 0.0005)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddGWj", "name": "spin generator", "author": "lomateron", "description": "play-pause timer to generate new image\nclick to adjust image\nsome are good\nsome are bad\nhow it works:\nunpause timer\nchange n = 1        compile           observe\nchange n = 2        compile           observe\nchange n = 3        compile           observe", "tags": ["2d", "abstract", "rotation"], "likes": 4, "viewed": 297, "date": "1569328376", "time_retrieved": "2024-06-20T19:44:48.112140", "image_code": "#define pi 3.14159265359\nfloat ssin(float x, float s)//aliased sin\n{\n    return cos(floor(x*s)*pi/s);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 4.*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime+1002.56+m.x*.01;\n    float n = 277.;\n    float s = 0.;\n    for(float i = .5; i < n; ++i)\n    {\n        vec2 a = sin(t*i+vec2(0.,pi*.5));\n        s += ssin(dot(u,a)+t*.001*i,1.);\n    }\n    s = s/sqrt(n)+4.;\n    fragColor = .5+.5*cos(s*.5+vec4(.7,.1,.0,.0)\n                          + pi*2.*m.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddGWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddGWN", "name": "Julia Set Hipercomplex 2D", "author": "aaraomelo", "description": "Julia Set Hipercomplex 2D", "tags": ["juliaset", "hipercomplex2d"], "likes": 3, "viewed": 82, "date": "1568589996", "time_retrieved": "2024-06-20T19:44:48.112391", "image_code": "/* \n    The Julia set is the subset of the complex plane given by the points \n    whose nth iteration of the function f_c (z) = z * z + c has a modulus \n    of at most two for all natural n.\n*/\n\nvec2 multiply(vec2 a,vec2 b){\n    if(a.x==0.){\n        if(b.x==0.)\n            return vec2(-a.y*b.y,0.);\n        else\n            return vec2(-a.y*b.y*sign(b.x),a.y*abs(b.x));\n    }\n    else{\n        if(b.x==0.)\n            return vec2(-a.y*b.y*sign(a.x),b.y*abs(a.x));\n        else{\n            return vec2\t(a.x*b.x-a.y*b.y*sign(a.x*b.x),abs(a.x)*b.y+a.y*abs(b.x));\n        }\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 5.*(fragCoord/iResolution.x-vec2(.5,.27));\n    vec2 col;\n    vec2 c = cos(iTime)*vec2(cos(iTime/2.),sin(iTime/2.)); \n    for(int i = 0; i < 500;i++){\n        vec2 z = multiply(z0,z0)+c;\n        float mq = dot(z,z);\n        if( mq > 4.){\n            col = vec2(float(i)/20.,0.);\n            break;\n        } else {\n            z0 = z;\n        }\n        col =  vec2(mq/2.,mq/2.);\n    }\n    fragColor = vec4(col,0.,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddGWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wddGzj", "name": "Minimal Jigsaw", "author": "Shane", "description": "Constructing a jigsaw pattern with minimal instruction count.", "tags": ["2d", "diamond", "pattern", "tile", "minimal", "puzzle", "jigsaw"], "likes": 10, "viewed": 654, "date": "1569073260", "time_retrieved": "2024-06-20T19:44:48.766962", "image_code": "/*\n\n\tMinimal Jigsaw\n\t--------------\n\n\tI put together a square 3D jigsaw pattern a while back, and Fizzer \n\tnoticed that the planar version could be constructed with less effort \n    when considering one diagonal (instead of the four sides I was \n    comparing), then put together a cool example demonstrating that. The \n    link is below, for anyone interested.\n\n    Anyway, that idea got me wondering just how little code you could\n\tuse to construct a basic colored jigsaw pattern, so this is my take\n\ton it. \n\n\tFizzer took a clever space segmented approach. My mind isn't as \n\tsophisticated, so I usually have to code things in a brute force \n\tfashion, then look for optimization opportunities via patterns and\n\tsymmetry, and so forth, so that's the method I applied here. Either way, \n\tI was pleasantly surprised by how much it was possible to cut things \n    down. Having said that, I still left enough code in there to give the \n\tcode golfers something to work with. :)\n\n    \n\tOther Examples:\n\n\t// Cleverly constructed, as always.\n\tJigsaw Pattern - Fizzer\n\thttps://www.shadertoy.com/view/3tlXR4\n\n\t// Jigsaw patterns are possible with all kinds of shapes.\n\tIsosceles Jigsaw Strips - Shane\n\thttps://www.shadertoy.com/view/3sd3Rj\n\n*/\n\n\n// IQ's vec2 to float hash, with some decimals taken out. Obviously,\n// you wouldn't use these figures for more important things.\nfloat h21(vec2 p){  return fract(sin(dot(p, vec2(27.3, 57.7)))*1e4); }\n\n// A basic diamond shape -- Shuffled a little. \nfloat di(vec2 p){ p = abs(p); return (p.x + p.y - 1.)*.7 + .05; }\n\n// The jigsaw pattern algorithm -- cut down considerably.\n//\n// Each cell consists of a diagonal partitioning with one jigsaw piece \n// color on one side and its neighboring color on the other. In addition \n// the diagonals are oriented in such a way that they form diamonds, or\n// squares, depending on perspective. The nodule logic involves rendering \n// a circle over a random side of the line and updating the color ID \n// accordingly. \n//\n// Trust me, none of it is that hard. The only thing left to do after \n// that was to look for symmetrical patterns in order to minimize \n// instruction count, streamline the syntax, etc.\n//\nvec3 jigsaw(vec2 p){\n    \n    // Local cell ID and coordinates.\n    vec2 ip = floor(p); p -= ip + .5; \n \n    // Directional helper vectors.\n    vec2 m = fract(ip/2.)*2. - .5; // Orientation vector.   \n    vec2 dirV = dot(m, p)<0.? -m : m; // Direction vector.\n    vec2 rD = (h21(ip) - .5)*dirV;///m; // Random vector.\n    \n    // Temporary fix for the zero case, which seems to confuse\n    // the GPU on occasion, resulting in an absent nodule.\n    //if(rD.x == 0.) rD += dirV; \n    \n    // The distance functions -- A diamond, and offset nodule.\n    float d = di(p - dirV), c = length(p - dirV*.2) - .2;\n    \n\n    // Add the nodules to a random side of the diagonal.\n    if(rD.x<0.){  \n        d = max(d, .1 - c);\n        if(c<d) ip -= dirV*2.;\n    }  \n     \n    // Return the distance field and ID.\n    return vec3(min(d, c), ip + dirV);    \n}\n\nvoid mainImage(out vec4 fC, in vec2 u){    \n\n    // Aspect correct screen coordinates.\n    vec2 R = iResolution.xy;\n    \n    // Resizing and scaling.\n    u = (u - R*.5)/R.y*8. + vec2(1, .5)*iTime;\n  \n    // The jisaw pattern.\n    vec3 d = jigsaw(u);\n\n    // Some ID-based coloring.\n    //vec3 col = vec3(1, h21(d.yz)*.65 + .35, h21(d.yz + .5)*.7 + .3);\n    //col = mix(col.yzx, col, h21(d.yz + .2));\n    // Fabrice's addition, which uses IQ's palette formula: It's a subtly \n    // pleasant pastel palette. \n    vec3 col = .8 + .2*cos(6.3*h21(d.yz) + vec3(0, 23, 21));\n    // Etc.\n    //vec3 col = .5 + .4*cos(6.3*h21(d.yz) + vec3(2, 1, 0));\n    //vec3 col = .6 + .4*cos(6.*h21(d.yz) + vec3(5, 3, 1));\n\n\n    // Apply the jigsaw pattern.\n    col = mix(col, vec3(0), smoothstep(0., 8./R.y, d.x));   \n     \n    // Rough gamma correction.\n    fC = vec4(sqrt(col), 1);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wddGzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdGGRR", "name": "Kaleidozoom", "author": "shadeThrower", "description": "Check out my Kaleidozoom VR shader for some infinite-tunnel 3D fun if you have a phone-based VR headset. I promise it's less pukey than it sounds. If you try it out using the Shadertoy app make sure to use the HD setting.", "tags": ["kaleidoscope", "trig", "geometric"], "likes": 3, "viewed": 428, "date": "1569691323", "time_retrieved": "2024-06-20T19:44:49.433610", "image_code": "/*const int initRes = iResolution.x * iResolution.y;\nvec3 buffer[initRes.x * initRes.y];*/\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec3 CalcColor(float tme, vec2 uv, vec2 uvM, float posModGradA, float posModGradB)\n{\n    vec3 col = vec3(\n        0.5 + 0.5*tan((cos(tme)+2.)*8.*\n                      (uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*\n        (((cos(length(uv*posModGradA*100.))*.4+.6)+\n          (cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n\n        0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*\n                      (uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*\n        (((cos(length(uv*posModGradA*100.))*.4+.6)+\n          (cos(length(uvM*posModGradB*100.))*.4+.6))/2.),\n\n        0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*\n                      (uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*\n        (((cos(length(uv*posModGradA*100.))*.4+.6)+\n          (cos(length(uvM*posModGradB*100.))*.4+.6))/2.);\n    \n    return col;\n}\n\nvec3 colorVec(vec2 fragCoord)\n{\n    float tme = iTime*.20;\n    tme += 3600.3;\n    float scale = 0.125;\n   \n    vec2 adjVec = vec2((sin(tme)*.5), (cos(tme)*.5));\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Diagonal Moving\n    //uv.x = sin((fract(tme)+uv.x)*3.14)/2.+.5;\n    //uv.y = cos((fract(tme)+uv.y)*3.14)/2.+.5;\n\n    //Mouse Movement Multiple\n    \n\t/*uv.x = sin((1.-iMouse.x/iResolution.y*3.6+(uv.x-.5)\n                *5.*(abs(1.-pow(length(vec2(.5, .5)-uv), .7)\n                *pow((cos(tme/2.)+1.1)/2., .2)))\n                *((cos(tme/2.)+1.1)/2.)*4.)*3.14)/2.+.5;\n    \n    uv.y = cos(1.57+(1.-iMouse.y/iResolution.x*8.+(uv.y-.5)\n                *5.*(abs(1.-pow(length(vec2(.5, .5)-uv), .7)\n                *pow((cos(tme/2.)+1.1)/2., .2)))\n                *((cos(tme/2.)+1.1)/2.)*4.)*3.14)/2.+.5;*/\n\t\n\t//texelFetch( iChannel0, ivec2(KEY_UP,1),0 ).x\n    \n    \n    //Auto Move Circular\n    //uv.x = sin((1.-(sin(tme/2.)/2.+1.)*5.+uv.x)*3.14)/2.+.5;\n    //uv.y = cos((1.-(cos(tme/2.)/2.+1.)*8.+uv.y)*3.14)/2.+.5;\n    \n    // Move and Zoom\n\t//uv.x = sin((1.-.5*5.+uv.x)*6.28*(sin(tme)+2.))/2.+.5;\n    //uv.y = sin((1.-.5*8.+uv.y)*6.28*(sin(tme)+2.))/2.+.5;\n    \n    \n    //Rotation (in progress)\n    /*vec2 uvTmp = uv;\n    uvTmp.x += sin(length(uv-vec2(.5,.5)))*(sin(tme)/2.+.5);\n    uvTmp.y += cos(length(uv-vec2(.5,.5)))*(sin(tme)/2.+.5);\n    uv = uvTmp;*/\n    \n    vec2 uvM;\n    float posMod;\n    float posModGradA;\n    float posModGradB;\n    posMod = (cos(tme/2.+3.1416)*.95 + .05)/2.+.5;\n    posModGradA = (cos(tme*1.1)*.9 + .1)/2.+.5;\n    posModGradB = (cos(tme*.9)*.9 + .1)/2.+.5;\n    //uv = vec2(pow((uv.x-.5)*length(normalize(uv-0.5))*5., -.05)*posMod, pow((uv.y-.5)*length(normalize(uv-0.5))*5., -.05)*posMod);\n    //uv = vec2(pow((uv.x-.5)*length(uv-0.5)*5., -.07)*posMod*2., pow((uv.y-.5)*length(uv-0.5)*5., -.07)*posMod*2.);\n    uv = vec2(pow(abs(uv.x-.5)+length(uv-.5), -.07)*posMod*3., pow(abs(uv.y-.5)+length(uv-.5), -.07)*posMod*3.);\n    uvM = mod(uv, scale);\n    uv = normalize(uvM-vec2(scale/2.))*(adjVec+vec2(.5));\n\n    if(mod(floor((uv.x)/scale),2.) == 0.)\n            uvM.x = scale - uvM.x;\n    if(mod(floor((uv.y)/scale),2.) == 0.)\n            uvM.y = scale - uvM.y;\n\n    uvM += adjVec*length(uvM + adjVec - vec2(0.5));\n\n    // With uvM and uv gradients\n    vec3 col = CalcColor(tme, uv, uvM, posModGradA, posModGradB);\n    \n    // With uv gradients\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(uv*posModGrad*100.))*.4+.6),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(uv*posModGrad*100.))*.4+.6),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(cos(length(uv*posModGrad*100.))*.4+.6);*/\n    \n    // True to fragCoord (in progress)\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))))*(cos(length(((fragCoord/iResolution.xy-.5)*posMod))*100.)/2.+.5);*/\n    \n    // Without gradients\n    /*vec3 col = vec3(0.5 + 0.5*tan((cos(tme)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((sin(tme*1.2)+2.)*8.*(uvM.x/sin(uvM.y+0.2+(cos(tme)/2.+1.)))),\n                    0.5 + 0.5*tan((cos(tme*1.3)+3.)*8.*(uvM.x/sin(uvM.y+0.2+(sin(tme)/2.+1.)))));*/\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = colorVec(fragCoord);\n    // Blur\n    /*float radius = 10.;\n    vec3 blurred = vec3(0.);\n    float weight=0.;\n    float sumW = 0.;\n    vec2 dropper;\n    float spanDis = length(vec2(0.)-vec2(radius, radius));\n    for(float i=-radius; i<radius; i++){\n        for(float j=-radius; j<radius; j++){\n            dropper = vec2(fragCoord.x + i, fragCoord.y + j);\n            if(dropper.x >= 0. && dropper.y >= 0. && dropper.x < iResolution.x && dropper.y < iResolution.y){\n            \tweight = pow(spanDis - abs(length(fragCoord-dropper)), 2.);\n                sumW += weight;\n                blurred += vec3(weight)*(colorVec(dropper));\n            }\n        }\n    }\n    blurred /= vec3(sumW);\n    fragColor = vec4(blurred,1.0);*/\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdGGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdK3RD", "name": "SparklePlexus", "author": "carmandale", "description": "random dots, connected and sparkling.", "tags": ["sparkle", "plexus"], "likes": 17, "viewed": 583, "date": "1569836162", "time_retrieved": "2024-06-20T19:44:49.433610", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos (vec2 id, vec2 offs) {\n    vec2 n = N22(id+offs)* iTime;\n    \n    return offs+sin(n)*.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p,a,b); // distance to the line segment\n    float m = S(.03,.01,d); // cut out the line\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2)*.5+S(.05,.03, abs(d2-.75)); // make them not all visible\n    return m;\n}\n\nfloat Layer (vec2 uv) {\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    \n\n    \n    for (float y=-1.; y<=1.;y++) {\n        for (float x=-1.;x<=1.;x++) {\n            p[i++] = GetPos(id, vec2(x,y));\n        }\n    }\n    \n    float t = iTime*20.;\n    for(int i=0; i<9; i++) {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv)*15.;\n        float sparkle = 1./dot(j, j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5+.5);\n    }\n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[5], p[7]);\n    m += Line(gv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n    float m = 0.;\n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c,-s,s,c);\n    \n    uv *= rot;\n    mouse *= rot;\n    \n    for (float i=0.; i<1.;i+=1./4.){\n        float z = fract(i+t);\n        float size = mix(10.,.5,z);\n        float fade = S(0.,.5,z)*S(1.,.8,z);\n        m += Layer(uv*size+i*20.-mouse)*fade;\n    }\n    \n    \n    \n\n    vec3 col = vec3(m);\n    \n    //col.rg = id+1.;\n    \n    //if (gv.x>.48||gv.y>.48) col = vec3(1.,0,0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdK3RD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3D4", "name": "Radiant lines", "author": "Radiant", "description": "My first shader", "tags": ["shader"], "likes": 4, "viewed": 129, "date": "1568578883", "time_retrieved": "2024-06-20T19:44:49.439813", "image_code": "float func(float x)\n{\n\treturn sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.14159265;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float val = 0.0;\n    vec3 col3 = vec3(0.0);\n    \n    for (float i = 0.0; i < 1.0; i += 0.10)\n    {\n        vec2 p = vec2(uv.x * 5.0 + iTime * (mod(pow(i * 5.0 + 2.0, 3.0), 2.77) - 1.4), uv.y * 5.0 - i * 5.0);\n        vec2 psin = vec2(p.x, func(p.x));\n\n        val += max(0.0, 1.0 - pow(distance(psin, p) * 0.8, 0.12));\n    }\n    \n    vec3 col = vec3(sin(iTime * 1.3 + uv.x), cos(iTime * -0.57 + uv.y), cos(iTime)) / 2.0 + 0.5;\n    col3 = col * pow(val, 3.0);\n    // Output to screen\n    fragColor = vec4(col3, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdt3DN", "name": "Floppydisk", "author": "Minus256", "description": "Thx iq <3", "tags": ["raymarching", "floppydisk", "diskette"], "likes": 2, "viewed": 103, "date": "1569161739", "time_retrieved": "2024-06-20T19:44:49.439813", "image_code": "//--2019/22/9--\n//written by juwon \"Minus256\" ko(verification for school writing)\nconst float eps = 0.001;\nconst int mxmarch = 255;\nconst float maxlength = 1023.0;\nconst float beattime = 0.5;\nconst float halfpi = 1.57079632679;\nconst int bcnt = 7;\nfloat beat(float time)\n{\n    return mod(iTime,beattime)/beattime;\n}\nvec4 RotationToQuaternion(vec3 axis, float angle)\n{\n    float half_angle = angle * halfpi / 180.0;\n    vec2 s = sin(vec2(half_angle, half_angle + halfpi));\n    return vec4(axis * s.x, s.y);\n}\nvec3 rotate(vec3 pos, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n\tvec4 q = RotationToQuaternion(axis, angle);\n    return pos + 2.0 * cross(q.xyz, cross(q.xyz, pos) + q.w * pos);\n}\nfloat rand(float seed)\n{\n    float a = dot(vec2(seed*57.18273649,seed*32.190263728),vec2(18.123512,23.126423));\n    return sin(a);\n}\nfloat smoothrandom(float time)\n{\n    float timeseed = floor(time);\n    float smth = smoothstep(.0,1.,fract(time));\n    float smoothtime = mix(rand(timeseed),rand(timeseed+1.),smth);\n    return smoothtime;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b/2.0;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCol( vec3 p, vec3 info )\n{\n    vec2 nor = p.xy - info.xy;\n    return length(nor)-info.z;\n}\n\nfloat merge(float p1,float p2)\n{\n    return min(p1,p2);\n}\n\nfloat sub(float p1,float p2)\n{\n    return max(-p1,p2);\n}\n\nfloat sphere(vec3 pos,float rad)\n{\n    return length(pos)-rad;\n}\nfloat fsphere(vec3 pos,vec3 origin,float s)\n{\n    float c =0.4;\n    float en = 1.5;\n    float bt = beat(iTime);\n    float a = 0.;\n    float dsp = 0.2;\n    if(bt<0.4)\n    {\n        a=sin(bt*2.);\n        dsp = (c-bt);\n        s *= 1.+pow(dsp*0.3,1.2);\n    }\n    s *= en;\n    float p = ((sin(pos.x*c)+sin(pos.y*c)+sin(pos.z*c)))*0.01;\n    pos -= origin;\n    pos.yx  -= sin(length(pos.xyz*100.)*a)*dsp*0.5;\n    float diskbody = sdBox(pos,vec3(5.25,5.25,.06)*s);\n    float diskhole = sdCol(pos,vec3(.0,.0,.75)*s);\n    float diskhole2 = sdCol(pos,vec3(1.,-.27,.12)*s);\n    float diskrechole = sdBox(pos-vec3(.0,-1.8,.0)*s,vec3(.5,1.,3.)*s);\n    float disktab = sdBox(pos-vec3(2.7,1.3,.0)*s,vec3(.4,.25,3.)*s);\n    float diskrndhole =  sdCol(pos,vec3(.0,-1.3,.25)*s);\n    float diskrndhole2 = sdCol(pos,vec3(.0,-2.3,.25)*s);\n    float disknotchhole = sdCol(pos,vec3(.6,-2.625,.07)*s);\n    float disknotchhole2 = sdCol(pos,vec3(-.6,-2.625,.07)*s);\n    float subt = merge(diskhole,\n                 merge(diskhole2,\n                 merge(diskrechole,\n                 merge(disktab,\n                 merge(diskrndhole,\n                 merge(diskrndhole2,\n                 merge(disknotchhole,disknotchhole2)))))));\n    return sub(subt,diskbody)+p*max(sin(0.72),.0)-p;\n}\nfloat foprnd(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat sdf2(vec3 pos)\n{\n    vec3 bpos,rotater = vec3(.0);\n    float modtime = iTime*0.1;\n    float stk = 0.41;\n    float rts = 2.;\n    float s1,s2 = .0;\n    for(int i = 0;i < bcnt;i++)\n    {\n        float I = float(i);\n        bpos = vec3(smoothrandom(modtime+I*0.4234)\n                   ,smoothrandom(modtime*0.324+I*0.5342)\n                   ,smoothrandom(modtime*0.643+I*2.4321))*0.5;\n        rotater = vec3(smoothrandom(modtime*0.14322*rts+I*2.58245)\n                      ,smoothrandom(modtime*0.12132*rts+I*9.824356)\n                      ,smoothrandom(modtime*0.14532*rts+I*3.72434)\n                      )*0.2;\n        pos = rotate(pos,rotater,modtime*299.);\n        s1 = fsphere(pos,bpos*5.,(length(bpos[i])*0.5));\n        if(i == 0)\n        {\n            s2=s1;\n        }\n        else\n        {\n        \ts2 = foprnd(s1,s2,1.12);\n        }\n    }\n    float s3 = sphere(pos,.6);\n    return merge(s2,s3);\n}\nvec3 norm(vec3 pos)\n{\n    \n    float p = sdf2(pos);\n    vec2 h = vec2(.0,eps);\n    return normalize(vec3(\n        sdf2(pos+h.yxx)-p,\n        sdf2(pos+h.xyx)-p,\n        sdf2(pos+h.xxy)-p));\n}\nvec3 Luminance(vec3 N,vec3 W,vec3 cons1,vec3 cons2,vec3 cons3,vec3 cons4)\n{\n    return pow(vec3(abs(dot(N,W)))+cons4,cons1)*cons2+cons3;\n}\nvec3 render(vec3 Oi,vec3 OR,vec3 N,vec3 col)\n{\n    return Luminance(N,OR,vec3(123.3214,42.421,41.3412),vec3(1.5),vec3(0.19,0.01372,0.11123),vec3(.01))/\n           (Luminance(N,Oi,vec3(0.3452,0.2345,0.334523),vec3(1.),vec3(1.),vec3(.0))*abs(dot(N,Oi)));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lookat = vec3(.0,.0,.0);\n    vec3 pos = vec3(3.*cos(iTime*0.2),3.*sin(iTime*0.2),3.0*sin(iTime*0.2));\n    vec3 post = pos;\n    vec3 vv = normalize(lookat-pos);\n    vec3 sv = cross(vv,vec3(.0,1.,.0));\n    vec3 up = cross(sv,vv);\n    vec2 uv = vec2((2.*fragCoord.xy-iResolution.xy)/iResolution.xx)*1.0;\n    vec3 ray = normalize(vv+up*uv.y+sv*uv.x);\n    vec3 ray2,normal2,pos2 = vec3(.0);\n    float L2,A2 = .0;\n    float A =.0;\n    float L=.0;\n    float shade = .0;\n    bool hit,hit2 = false;\n    for(int i=0;i<mxmarch;i++)\n    {\n        A = sdf2(pos);\n        L += A;     \n        shade++;\n        pos += ray*A;\n        if(A < eps)\n        {\n            hit = true;\n            break;\n        }\n        if(L>maxlength)\n        {\n            break;\n        }\n    } \n    vec3 normal = vec3(.0);\n    if(hit)\n    {\n        normal = norm(pos);\n    }\n    vec3 color = vec3(.0);\n    vec3 lightpos = vec3(sin(iTime*2.458672)*5.2345,-7.,sin(iTime*4.273289)*4.234);\n    vec3 OR = normalize(post);\n    vec3 Oi = -ray;\n    vec3 N = normal;\n    color = render(Oi,OR,N,pow(mod(pos,0.1)*44.44,vec3(55.0)));\n    if(sphere(pos,.6)<= eps)\n    {\n        ray2 = reflect(ray,normal);\n        pos2 = pos + 2.*eps*ray2;\n        for(int i=0;i<mxmarch;i++)\n    \t{\n        \tA2 = sdf2(pos2);\n       \t\tL2 += A2;     \n        \tpos2 += ray2*A2;\n        \tif(A2 < eps)\n        \t{\n            \thit2 = true;\n            \tbreak;\n        \t}\n        \tif(L2>maxlength)\n        \t{\n            break;\n        \t}\n    \t} \n        if(hit2)\n    \t{\n    \t    normal2 = norm(pos2);\n            color = render(-ray2,normalize(pos2),normal2,pow(mod(pos,0.1)*44.44,vec3(55.0)));\n    \t}\n        else\n        {\n            color = vec3(1.,1.,1.);\n        }\n    }\n    if(!hit)\n    {\n        color = vec3(1.,.24,.64);\n    }\n    color = pow(color,vec3(shade/280.));\n    color += shade/320.;\n    fragColor = vec4(vec3(color),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdt3DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3Rl", "name": "weird noise stuff time", "author": "thefox231", "description": "experimented with simplex noise, looks quite cool imo", "tags": ["2d", "noise", "simplex", "rainbow"], "likes": 4, "viewed": 311, "date": "1569099681", "time_retrieved": "2024-06-20T19:44:49.439813", "image_code": "#define PI 3.14159265358979323846\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float noisevalue = snoise(vec2((uv.x) * (5.0*(cos(iTime+cos(iTime)/7.0)+0.5))+(iTime + iMouse.x/5.0), uv.y*(3.0*(cos(iTime+cos(iTime)/7.0)+0.5))+(iTime + iMouse.y/5.0)));\n    \n    float grad = rotate(uv.xy, (sin(iTime*2.0)+1.0)-noisevalue)[0];\n    \n    // Output to screen\n    fragColor = vec4((vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(3,5,7)))*grad),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3Rn", "name": "Passing Windows", "author": "stseagle", "description": "An exercise from The Book of Shaders, inspired by Ryoji Ikeda", "tags": ["2d", "random", "squares"], "likes": 3, "viewed": 378, "date": "1567633358", "time_retrieved": "2024-06-20T19:44:49.627548", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.246334,78.34534)))*\n        4346.23643);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridSize = 100.;\n    vec2 st = fragCoord.xy/ gridSize;\n    \n    float diag = mod(floor(st).x + floor(st).y, 2.);\n\n    st.x += iTime * (random(floor(st) )- 0.75) * 0.5;\n    st.y += 1.2 + random(floor(st) );\n\n\n    vec2 ipos = floor(st);  // get the integer coords\n    \n    st = fract(st);\n\n    // Assign a random value based on the integer coord\n    vec3 color = vec3(mix(random(ipos), random(ipos + 1.0), smoothstep(0.,1.,st.y)));\n\n    fragColor = vec4(mix(vec3(0.0, 0.1255, 0.1098),vec3(0.9529, 0.8667, 0.8392),color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3W2", "name": "Groovy Mandelbrot", "author": "RisingThumb", "description": "Mandelbrot set with constant zoom in over time, and comments on where and how to change it for different effects.", "tags": ["mandelbrot"], "likes": 3, "viewed": 124, "date": "1569323390", "time_retrieved": "2024-06-20T19:44:49.912520", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Flip between these if you want zoom in over time at different rates, or just static zoom\n    float zoomPower=(iTime*iTime);\n    //float zoomPower = (iTime*5.0);\n    //float zoomPower = iTime;\n    //float zoomPower = 1.0;\n    \n    // Normalized mouse coords\n    vec2 m = iMouse.xy/iResolution.xy/zoomPower;\n    //float zoom = pow(10.0, -m.x*3.0);\n    \n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    uv-=0.5;\n    \n    vec2 c = uv*1.0/zoomPower;\n    c += m;\n    c += vec2(-0.69955, 0.37999);\n    \n    vec2 z = vec2(0.0);\n    float iter = 0.0;\n    const float max_iter = 500.0;\n    \n    // Modify me for weird variations\n    float weirdFlexButOk=2.0;\n    \n    for(float i=0.0; i<max_iter; i++){\n        // Modify the below equation for weird effects\n    \tz = vec2(z.x*z.x - z.y*z.y, weirdFlexButOk*z.x*z.y) + c;\n        if(length(z)>2.0) {break;}\n        iter++;\n    }\n    \n    float f = iter/max_iter;\n\n    // Time varying pixel color\n    vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*f*2.0;\n    // If you want static colour, comment out the above and uncomment below\n    //vec3 col = vec3(f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3WX", "name": "spin generated", "author": "lomateron", "description": "same as https://www.shadertoy.com/view/wddGWj\nbut every loops adds random color", "tags": ["2d", "abstract", "rotation"], "likes": 3, "viewed": 304, "date": "1569401650", "time_retrieved": "2024-06-20T19:44:49.912520", "image_code": "#define pi 3.14159265359\nfloat ssin(float x, float s)//aliased sin\n{\n    return cos(floor(x*s)*pi/s);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 4.*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = 1060.01109;//+m.x*.001;\n    float n = 333.;\n    vec4 s = vec4(0.);\n    for(float i = .5; i < n; ++i)\n    {\n        vec2 a = sin(t*i+vec2(0.,pi*.5));\n        vec4 b = fract(sin(i)\n                   *vec4(6925.953,7925.953,8925.953,9925.953)\n                      +iTime*.05);\n        s += ssin(dot(u,a)+t*.001*i,1.)*b;\n    }\n    s = s/sqrt(n)+4.;\n    fragColor = .5+.5*cos(s+5.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdt3zr", "name": "warlokkz - gear", "author": "warlokkz", "description": "a spinning gear", "tags": ["shapes"], "likes": 1, "viewed": 98, "date": "1567665401", "time_retrieved": "2024-06-20T19:44:49.912520", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (2. * fragCoord - R) / R.y;\n    vec2 pos = vec2(0.)-uv;\n    float r = length(pos)*1.;\n    float a = atan(pos.y,pos.x);\n    float k = cos(a*min(9.,round(iTime))+iTime);\n    float f = smoothstep(-.35,.9,k)*.2+.5;\n    float pct = smoothstep(f+.02,f,r);\n    pct -= smoothstep(f+.02,f,r*2.);\n    vec3 col = vec3(pct);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdt3zr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGD4", "name": "3D Dual Vector Distance Estimate", "author": "skye_adaire", "description": "This uses a vector3 of dual real numbers to compute the distance estimate and normal of an implicit surface. A variety of algebraic surfaces are shown https://en.wikipedia.org/wiki/List_of_complex_and_algebraic_surfaces", "tags": ["distance", "dual", "automatic", "algebraic", "differentiation", "estimate"], "likes": 5, "viewed": 95, "date": "1568557377", "time_retrieved": "2024-06-20T19:44:51.445948", "image_code": "//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n     \tcase 1:\n        //https://en.wikipedia.org/wiki/Fermat_cubic\n    \treturn \n            D_power(d[0], 3u) + \n            D_power(d[1], 3u) + \n            D_power(d[2], 3u) - \n            DualReal(1,0); \n        \n        case 2:\n        //https://en.wikipedia.org/wiki/Roman_surface\n    \treturn\n            D_multiply(D_sq(d[0]), D_sq(d[1])) + \n            D_multiply(D_sq(d[1]), D_sq(d[2])) + \n            D_multiply(D_sq(d[2]), D_sq(d[0])) -\n            D_multiply(d[0], D_multiply(d[1], d[2]));\n        \n        case 3:\n        //https://en.wikipedia.org/wiki/Monkey_saddle\n    \treturn \n            d[2] - \n            D_power(d[0], 3u) + \n            D_multiply(DualReal(3,0), D_multiply(d[0], D_sq(d[1])));\n        \n        case 4:\n        //https://en.wikipedia.org/wiki/Whitney_umbrella\n        return \n            D_sq(d[0]) - \n            D_multiply(d[2], D_sq(d[1]));\n        \n        case 5:\n        //https://en.wikipedia.org/wiki/Cayley%27s_ruled_cubic_surface\n        return \n            D_multiply(DualReal(3,0), d[2]) - \n            D_multiply(DualReal(3,0), D_multiply(d[0], d[1])) + \n            D_power(d[0], 3u);\n       \n        case 6:\n        //hyperbolic paraboloid\n        return D_sq(d[0]) - D_sq(d[1]) - d[2];\n        \n        case 7:\n        //lemniscate of bernoulli\n        DualReal a = DualReal(1.0, 0);\n        return\n            D_sq(D_sq(d[0]) + D_sq(d[1])) - \n            2.0 * D_multiply(D_sq(a), D_sq(d[0]) - D_sq(d[1]));\n        \n        case 8:\n        //double tori\n        return \n            D_sq(D_sq(D_sq(d[0]) + D_sq(d[1])) - D_sq(d[0]) + D_sq(d[1])) + D_sq(d[2]) - DualReal(0.01);\n            \n            /*\n            D_sq(D_multiply(d[0], D_multiply(D_sq(d[0] - DualReal(1,0)), d[0] - DualReal(2,0))) + D_sq(d[1])) + \n            D_sq(d[2]) - \n            DualReal(0.02);*/\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    //bounding cylinder\n    float bound = length(p.xz) - 2.2;\n    \n    if(abs(bound) < 0.001)//correct the normal\n    {\n        gradient = normalize(vec3(p.xz, 0));\n    }\n   \n    return max(de, bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = int(time) % 8 + 1;\n    \n    //view basis\n    mat3 viewTransform = rotationXZ(time * tau32 + tau32 / 2.0) * rotationYZ(-0.1);\n    vec3 viewPosition = viewTransform * vec3(0, 0, index == 2 ? 1 : 8);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0);\n        color = normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(0,0,0,1);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGDB", "name": "Learning Ray Marching Sphere ", "author": "chunza2542", "description": "Learning ray marching and calculate light to make a sphere.", "tags": ["ray", "sphere", "marching", "chun"], "likes": 1, "viewed": 249, "date": "1569240748", "time_retrieved": "2024-06-20T19:44:51.888295", "image_code": "#define NO_OF_STEP 100\n#define MIN 0.001\n#define MAX 1000.\n\n// Get Distance of the sphere\nfloat get_dist(vec3 p) {\n    // define sphere location and radius\n    vec3 loc = vec3(0, 1. + 2. * abs(sin(iTime * 3.)), 7);\n    float r = 1.0;\n    \n    // sphere dist and plane dist\n    float s_dist = length(p - loc) - r;\n    float p_dist = p.y;\n    \n    float d = min(s_dist, p_dist);\n    return d;\n}\n\n// Implement ray marching\nfloat ray_march(vec3 ro, vec3 rd) {\n    float dist = 0.;\n    \n    for (int i = 0; i < NO_OF_STEP; ++i) {\n     \tvec3 point = ro + dist * rd;\n        float d = get_dist(point);\n        \n        dist += d;\n        \n        if (d <= MIN || d >= MAX) break;\n    }\n    \n    return dist;\n}\n\nvec3 get_normal(vec3 p) {\n\tfloat d = get_dist(p);\n  \t// calculate normal\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n    \tget_dist(p - e.xyy),\n        get_dist(p - e.yxy),\n        get_dist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat get_diffuse_light(vec3 p) {\n    vec3 light_pos = vec3(4. + 4. * cos(iTime / 10.), 5., 4. + 2. * sin(iTime / 10.));\n    // get light and normal vector\n    vec3 l = normalize(vec3(light_pos - p));\n  \tvec3 n = get_normal(p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    // calculate the shadow\n    float d = ray_march(p + n * MIN, l);\n    if (d < length(light_pos - p)) {\n     \tdif *= 0.1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // camera position\n    vec3 ro = vec3(0, 1, 0);\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = ray_march(ro, rd);\n    \n    // calculate the light\n    vec3 p = ro + rd * d;\n    float l_dif = get_diffuse_light(p);\n    vec3 col = vec3(l_dif);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtGRl", "name": "Parallax Occlusion Material ", "author": "viclw17", "description": "Shader Study based on https://www.shadertoy.com/view/Xs2cDz\n", "tags": ["parrallax"], "likes": 26, "viewed": 798, "date": "1569209308", "time_retrieved": "2024-06-20T19:44:52.251979", "image_code": "// Based on https://www.shadertoy.com/view/Xs2cDz\n// layers\nconst float steps = 128.0;\n// Slight jitter to alleviate banding. Relies slightly on camera movement.\n#define JITTER 1\n// Slight screen distortion.\n#define DISTORTION 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.   \n\tvec2 texcoord = (fragCoord.xy - iResolution.xy*.5)/iResolution.y; \n    \n    #if DISTORTION\n    texcoord *= sqrt(1.+dot(texcoord, texcoord)*1.); \n    #endif\n       \n    #if JITTER\n    float jitter = fract(sin(fract(iTime) + dot(texcoord, vec2(41.97, 289.13)))*43758.5453)*min(.25 + length(texcoord), 1.);\n\t#else\n    float jitter = 1.;\n    #endif\n    \n\tvec3 color;\n    vec2 uv;\n    float time = iTime/5.;\n    \n\tfor ( int i = 0; i < int(steps); i++ )\n\t{\n\t\t\n\t\tfloat depth = (float(i) + jitter) / steps;\n \n        uv = texcoord * depth;\n\t\t\n        // Camera movement to hide the artifacts. \n\t\tcolor = texture(iChannel0, uv + vec2(time, 0.)).rgb;\n        color = vec3(color.r);\n        \n\t\t// Reducing the heightmap to distance plane ratio.\n\t\tif ( 1.-dot(color, vec3(0.33333)*0.2) < depth) break; // 0.1*(sin(iTime*2.)+1.)\n\n\t}\n    \n    // Fake directional derivative-based lighting to bring out the surface a little more.\n    float diff = max(color.r - texture(iChannel0, uv + vec2(time, 0.) - .005).r, 0.)*3.;\n    float diff2 = max(color.r - texture(iChannel0, uv + vec2(time, 0.) + .005).r, 0.)*3.;\n    // Surface color.\n    color *= vec3(.5)*color; \n    // Two fake lights.\n    color += vec3(.4, .7, 1.)*diff*diff*5. + vec3(1, .7, .4)*diff2*diff2*5.; \n   \n    color += jitter * .04 - .02; \n    \n   \t// Gamma correction.\n\tfragColor = vec4(sqrt(max(color, 0.)),1.0); \n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtGRS", "name": "Truchet Rasta", "author": "Janovski", "description": "Followed tutorial and made this one \noriginal : https://youtu.be/2R7h76GoIJM\nClicking around canvas to randomize the Truchet tile", "tags": ["tutorial", "truchet"], "likes": 5, "viewed": 110, "date": "1568801205", "time_retrieved": "2024-06-20T19:44:52.530547", "image_code": "float Hash21(vec2 p)\n{\n \tp = fract(p*vec2(iMouse.x + 55.24565, iMouse.y/0.568 + 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord- .5 * iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0);\n\n    uv *= 5.;\n    \n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); // return random num 0-1\n    float width = .04*abs(uv.y+2.);\n    \n    if (n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x + gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d-.5) - width);\n    //uv += iTime*iMouse.x/100.;\n   \t\n    float angle = atan(cUv.x, cUv.y); // -pi to pi\n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    float flow = sin(iTime + angle*checker * 10.);\n    float a = iTime*10. + angle*checker * 10.;\n    col += (sin(a)*mask)/4.;\n    float x = fract(angle/1.57);\n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(x,y);\n    col.rg += tUv*mask;\n    \n    //col += checker;\n    //col += n;\n    \n    //if (gv.x > .48 || gv.y > .48) col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGWB", "name": "Ray Marching with reflection", "author": "Varandunil", "description": "Ray Marching", "tags": ["raymarching"], "likes": 0, "viewed": 80, "date": "1569246693", "time_retrieved": "2024-06-20T19:44:53.482399", "image_code": "#define MAX_STEPS 120\n#define MAX_DIST 120.\n#define SURF_DIST .01\n\nstruct Sphere {\n    vec4 point;\n    vec3 color;\n    float transp;\n    float shiny;\n};\n\nstruct Hit {\n\tfloat distance;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n    vec3 light;\n    float transp;\n    float shiny;\n    vec3 center;\n};\n    \nHit TestScene(vec3 p) {\n    Sphere spheres[5] = Sphere[](\n    \tSphere(vec4(0, 1, 6, 1), vec3(1, 0, 0), 0.8, 0.2),\n        Sphere(vec4(1.7, 0.7, 6, 0.7), vec3(0.1, 0.5, 1), 0.5, 0.2),\n        Sphere(vec4(-1.5, 1, 10, 1), vec3(1, 0.7, 0.1), 0.5, 0.2),\n        Sphere(vec4(1.5, 2, 10, 2), vec3(0.5, 0.6, 0.9), 0.5, 0.8),\n        Sphere(vec4(-3, 1.3, 6, 1.3), vec3(0.2, 1, 0.5), 0.8, 0.2)\n    );\n    \n    Hit hit = Hit(\n    \tp.y - 0.48 + (sin((p.x + iTime) * 1.33) * 0.2) + (cos((p.z + iTime) * 1.5) * 0.2),\n        p,\n        vec3(0),\n        vec3(0.1, 0.3 + cos(p.x) * 0.2, 0.7),\n        vec3(0),\n        0.6,\n        0.6,\n        vec3(0)\n    );\n    \n    for(int i = 0 ; i < spheres.length() ; i++){\n        Sphere s = spheres[i];\n        vec3 pos = vec3(s.point.x + sin(float(i) + iTime), s.point.y, s.point.z + cos(float(i) + iTime));\n        float sd = length(p - pos) - s.point.w;\n        \n        //float k = 0.05;\n        //float h = clamp( 0.5+0.5*(sd-hit.distance)/k, 0.0, 1.0 );\n        //sd = mix( sd, hit.distance, h ) - k*h*(1.0-h);\n        \n        if(sd < hit.distance) {\n            hit.distance = sd;\n            hit.color = s.color;\n            hit.transp = s.transp;\n            hit.shiny = s.shiny;\n            hit.center = s.point.xyz;\n        }\n    }\n\n    return hit;\n}\n\nHit SendRay(vec3 origin, vec3 direction) {\n\tHit hit = TestScene(origin);\n    float t = hit.distance;\n    \n    for(int i = 0 ; i < MAX_STEPS - 1 ; i++) {\n    \tvec3 p = origin + direction * t;\n        hit = TestScene(p);\n        t += hit.distance;\n        if(t > MAX_DIST || hit.distance < SURF_DIST) break;\n    }\n    \n    return hit;\n}\n\nHit findOutside(vec3 origin, vec3 direction) {\n\tHit hit = TestScene(origin);\n    float t = abs(hit.distance);\n    \n    for(int i = 0 ; i < MAX_STEPS - 1 ; i++) {\n    \tvec3 p = origin + direction * t;\n        hit = TestScene(p);\n        t += abs(hit.distance) + 0.01;\n        if(t > MAX_DIST || hit.distance >= 0.01) break;\n    }\n    \n    return hit;\n}\n\nHit AddNorm(Hit hit) {\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = hit.distance - vec3(\n        TestScene(hit.point - e.xyy).distance,\n        TestScene(hit.point - e.yxy).distance,\n        TestScene(hit.point - e.yyx).distance);\n\n    hit.normal = normalize(n);\n\n    return hit;\n}\n\nHit AddLight(Hit hit, vec3 lightPos) {\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - hit.point);\n   \n    float dif = clamp(dot(hit.normal, l), 0., 1.);\n    float d = SendRay(hit.point + hit.normal * SURF_DIST * 5., l).distance;\n    \n    if(d < length(lightPos - hit.point)) {\n        dif *= .7;\n    }\n    \n    dif *= dif * dif  * dif * dif * dif;\n    \n    hit.light += hit.color * dif * 2.6;\n    \n    return hit;\n}\n\nHit SendRayWithLight(vec3 origin, vec3 direction) {\n\tHit hit = SendRay(origin, direction);\n    \n    if(hit.distance <= SURF_DIST) {\n        hit = AddNorm(hit);\n        hit = AddLight(hit, vec3(0, 5, 6));\n        hit = AddLight(hit, vec3(1, 4, 5));\n        hit = AddLight(hit, vec3(6, 10, -10));\n    } else {\n    \thit.color = vec3(1, 1, 1);\n    }\n    \n    return hit;\n}\n\nHit SendRayWithReflection(vec3 origin, vec3 direction) {\n    Hit hit = SendRayWithLight(origin, direction);\n    \n    if(hit.distance <= SURF_DIST) {\n        \n        if(hit.shiny > 0.) {\n            vec3 refDir = direction - 2. * hit.normal * dot(direction, hit.normal);\n            Hit hitR = SendRayWithLight(hit.point + hit.normal * SURF_DIST * 2., refDir);\n            hit.light += hitR.light * hit.shiny * 0.6;\n            \n            if(hitR.distance <= SURF_DIST) {\n            \trefDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                hit.light += hitR.light * hit.shiny * 0.3;\n                \n                if(hitR.distance <= SURF_DIST) {\n                    refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                    Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                    hit.light += hitR.light * hit.shiny * 0.15;\n                    \n                    if(hitR.distance <= SURF_DIST) {\n                        refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                        Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                        hit.light += hitR.light * hit.shiny * 0.075;\n                    }\n                }\n            }\n        }\n        \n        if(hit.transp > 0.) {\n            vec3 refDir = normalize(direction + hit.normal * 0.3 + (hit.point.x * hit.point.y * 0.5));\n            Hit outside = findOutside(hit.point + (direction * 0.1), refDir);\n            Hit hitR = SendRayWithLight(outside.point, refDir);\n            hit.light += hitR.light * hit.transp;\n            \n            if(hitR.distance <= SURF_DIST) {\n            \tvec3 refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                hit.light += hitR.light * hit.shiny;\n            }\n        }\n        \n    }\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 origin = vec3(0, 1, 0);\n    vec3 direction = normalize(vec3(uv.x + (sin(iTime) * 0.1), uv.y + (sin(iTime * 0.3) * 0.2), 1));\n    \n    fragColor = vec4(SendRayWithReflection(origin, direction).light,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGWf", "name": "Seigaiha Mandala", "author": "PixelPhil", "description": "A design inspired by scales patterns found on traditional japanese fabric and indian mandala art.\nIt also features motion blur. Best viewed in full screen.\nTry staring at it for a minute ;)", "tags": ["motion", "hypnotic", "pattern", "japanese", "scales", "fabric"], "likes": 78, "viewed": 1811, "date": "1569488230", "time_retrieved": "2024-06-20T19:44:54.440043", "image_code": "//\n// Seigaiha Mandala by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n\n// blends a pre-multiplied src onto a dst color (without alpha)\nvec3 premulMix(vec4 src, vec3 dst)\n{\n    return dst.rgb * (1.0 - src.a) + src.rgb;\n}\n\n// blends a pre-multiplied src onto a dst color (with alpha)\nvec4 premulMix(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = premulMix(src, dst.rgb);\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n    return res;\n}\n\n// compute the round scale pattern and its mask\n// output rgb is premultiplied by alpha\nvec4 roundPattern(vec2 uv)\n{\n    float dist = length(uv);\n    \n    // Resolution dependant Anti-Aliasing for a prettier thumbnail\n    // Thanks Fabrice Neyret & dracusa for pointing this out.\n    float aa = 8. / iResolution.x;\n\n    // concentric circles are made by thresholding a triangle wave function\n    float triangle = abs(fract(dist * 11.0 + 0.3) - 0.5);\n    float circles = S(0.25 - aa * 10.0, 0.25 + aa * 10.0, triangle);\n\n    // a light gradient is applied to the rings\n    float grad = dist * 2.0;\n    vec3 col = mix(vec3(0.0, 0.5, 0.6),  vec3(0.0, 0.2, 0.5), grad * grad);\n    col = mix(col, vec3(1.0), circles);\n    \n    // border and center are red\n    vec3 borderColor = vec3(0.7, 0.2, 0.2);\n    col = mix(col, borderColor, S(0.44 - aa, 0.44 + aa, dist));\n    col = mix(col, borderColor, S(0.05 + aa, 0.05 - aa, dist));\n    \n    // computes the mask with a soft shadow\n    float mask = S(0.5, 0.49, dist);\n    float blur = 0.3;\n    float shadow = S(0.5 + blur, 0.5 - blur, dist);\n   \n    return vec4(col * mask, clamp(mask + shadow * 0.55, 0.0, 1.0)); \n}\n\n\n//computes the scales on a ring of a given radius with a given number of scales\nvec4 ring(vec2 uv, float angle, float angleOffet, float centerDist, float numcircles, float circlesRad)\n{\n    // polar space is cut in quadrants (one per scale)\n    float quadId = floor(angle * numcircles + angleOffet);\n    \n    // computes the angle of the center of the quadrant\n    float quadAngle = (quadId + 0.5 - angleOffet) * (6.283 / numcircles);\n    \n    // computes the center point of the quadrant on the circle\n    vec2 quadCenter = vec2(cos(quadAngle), sin(quadAngle)) * centerDist;\n    \n    // return to color of the scale in the quadrant\n    vec2 circleUv = (uv + quadCenter) / circlesRad;\n    return roundPattern(circleUv);\n}\n\n// computes a ring with two layers of overlapping patterns\nvec4 dblRing(vec2 uv, float angle, float centerDist, float numcircles, float circlesRad, float t)\n{\n    // Odd and even scales dance up and down\n    float s = sin(t * 3.0 + centerDist * 10.0) * 0.05;\n    float d1 = 1.05 + s;\n    float d2 = 1.05 - s;\n    \n    // the whole thing spins with a sine perturbation\n    float rot = t * centerDist * 0.4 + sin(t + centerDist * 5.0) * 0.2;\n    \n    // compute bith rings\n    vec4 ring1 = ring(uv, angle, 0.0 + rot, centerDist * d1, numcircles, circlesRad);\n    vec4 ring2 = ring(uv, angle, 0.5 + rot, centerDist * d2, numcircles, circlesRad);\n    \n    // blend the results\n    vec4 col = premulMix(ring1, ring2);\n    \n    // add a bit of distance shading for extra depth\n    col.rgb *= 1.0 - (centerDist * centerDist) * 0.4;\n    \n    return col;\n}\n\n// computes a double ring on a given radius with a number of scales to fill the circle evenly\nvec4 autoRing(vec2 uv, float angle, float centerDist, float t)\n{\n    float nbCircles = 1.0 + floor(centerDist * 23.0);\n    return dblRing(uv, angle, centerDist, nbCircles, 0.23, t);\n}\n\n// Computes the pixel color for the full image at a givent time\nvec3 fullImage(vec2 uv, float angle, float centerDist, float t)\n{\n    vec3 col;\n    \n    // the screen is cut in concentric rings\n    float space = 0.1;\n    \n    // determine in which ring the pixel is\n    float ringRad = floor(centerDist / space) * space;\n    \n\t// computes the scales in the previous, current and next ring\n\tvec4 ringCol1 = autoRing(uv, angle, ringRad - space, t);\n \tvec4 ringCol2 = autoRing(uv, angle, ringRad, t);\n    vec4 ringCol3 = autoRing(uv, angle, ringRad + space, t);\n    \n    // blends everything together except in the center\n    if (ringRad > 0.0)\n    {\n        col.rgb = ringCol3.rgb;\n        col.rgb = premulMix(ringCol2, col.rgb);\n        col.rgb = premulMix(ringCol1, col.rgb);\n    }\n\telse\n    {\n        col.rgb = ringCol2.rgb; \n    }\n\n    return col;\n}\n\n// A noise function that I tried to make as gaussian-looking as possible\nfloat noise21(vec2 uv)\n{\n    vec2 n = fract(uv* vec2(19.48, 139.9));\n    n += sin(dot(uv, uv + 30.7)) * 47.0;\n    return fract(n.x * n.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    uv *= 0.9;\n    \n    // Computes polar cordinates\n    float angle = atan(uv.y, uv.x) / 6.283 + 0.5;\n    float centerDist = length(uv);\n    \n    vec3 col = vec3(0.0);\n    \n\t// average 4 samples at slightly different times for motion blur\n    float noise = noise21(uv + iTime);\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        col += fullImage(uv, angle, centerDist, iTime - ((i + noise) * 0.03));\n    }\n    col /= 4.0;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4lXGDj", "previewfilepath": "https://soundcloud.com/alvydasm/the-heart-of-reiki-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/alvydasm/the-heart-of-reiki-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGWl", "name": "multi", "author": "foran", "description": "multi", "tags": ["multi"], "likes": 1, "viewed": 62, "date": "1569486890", "time_retrieved": "2024-06-20T19:44:54.440043", "image_code": "\nprecision mediump float;\n#define WIDTH 0.061\n//---------------- \n    vec3 pal(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d){\n    return a+b*cos(3.14159*(c*t+d));\n}\n     vec3 spectrum(float n){\n     return pal(n,vec3(.5,.5,.5),vec3(.5,.5,.5),vec3(1.0,0.7,0.4),vec3(0.00,0.15,0.20));\n   }\n//-----------------\n    vec2 resize(vec2 st, vec4 rect){\n    return vec2(rect[0], rect[1]) + vec2(rect[2], rect[3]) * st;\n}\n\n    float curve(float x){\n    return fract(sin(x)*(100.0+iTime*.5));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 st=fragCoord.xy/iResolution.xy;\n    st = resize(st, vec4(-1.0, -.010, 2.0, 1.0));\n    float bright = abs(st.y - curve(st.x)) < WIDTH ? 1.0 : 1.20;\n    vec3 color=spectrum((bright*3.5-1.)*sin(.152*iTime)+1.4*st.y*st.x);//   spectrum  vec3 color=vec3(0);\n    color.zy*=st.y+sin(iTime*.1);//  -\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtGWn", "name": "RVA Game Jams Magic Flame Demo", "author": "samlo", "description": "A quick example I live coded to demo some shadertoy basics for RVA Game Jams community members. Code has been cleaned up and (almost?) all the coefficients are defines at the top of the shader to make it easier to play around with ", "tags": ["tutorial", "flame", "demo", "magic"], "likes": 22, "viewed": 795, "date": "1568299911", "time_retrieved": "2024-06-20T19:44:54.440043", "image_code": "// FLAME MASK SHAPING\n#define FLAME_SIZE 2.2\n#define FLAME_WIDTH 1.3\n#define DISPLACEMENT_STRENGTH 0.3\n#define DISPLACEMENT_FREQUENCY 5.0\n#define DISPLACEMENT_EXPONENT 1.5\n#define DISPLACEMENT_SPEED 5.0\n#define TEAR_EXPONENT 0.7\n#define BASE_SHARPNESS 4.0\n\n// NOISE\n#define NOISE_SCALE 3.0\n#define NOISE_SPEED -4.2\n#define NOISE_GAIN 0.5\n#define NOISE_MULT 0.35\n\n// FLAME BLENDING\n#define FALLOFF_MIN 0.2\n#define FALLOFF_MAX 1.3\n#define FALLOFF_EXPONENT 0.9\n\n// COLOR\n#define BACKGROUND_MIN 0.0\n#define BACKGROUND_MAX 0.15\n#define RIM_EXPONENT 2.0\n#define BACKGROUND_COLOR_MIN vec3(0.2, 0.0, 0.2)\n#define BACKGROUND_COLOR_MAX vec3(0.6, 0.0, 0.4)\n#define RIM_COLOR vec3(0.0, 0.9, 0.9)\n\n// GLOW\n#define FLICKER_SPEED 4.0\n#define FLICKER_STRENGTH 0.08\n#define GLOW_OFFSET vec2(0.0, 0.1)\n#define GLOW_EXPONENT 4.0\n#define GLOW_WIDTH 1.5\n#define GLOW_SIZE 0.4\n#define GLOW_STRENGTH 0.4\n#define GLOW_COLOR vec3(0.0, 0.8, 1.0)\n\n\nvec3 permute(vec3 x)\n{ \n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nfloat snoise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n            -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tfloat aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec2 p = uv - vec2(0.5 * aspect, 0.5);\n    vec2 glowP = p; // this is saved for when we do our glow\n    \n    // shape our base flame mask.\n    // first we squish a circle and displace it, then we turn it into a teardrop shape\n    p *= FLAME_SIZE;\n    p.x *= FLAME_WIDTH;\n    \n    float flameDisplacement = max(0.0, sin(iTime * DISPLACEMENT_SPEED + (p.y * DISPLACEMENT_FREQUENCY)) * DISPLACEMENT_STRENGTH * pow(uv.y - 0.1, DISPLACEMENT_EXPONENT));\n    p.x += flameDisplacement;\n    p.x += p.x / pow((1.0 - p.y), TEAR_EXPONENT); // teardrop shaping\n    \n    // next we create our base flame mask, it looks a bit like a spooky ghost\n    float gradient = length(p);\n    float base = 1.0 - pow(gradient, BASE_SHARPNESS);\n    \n\t// next we create our noise mask, which we will use to create the flickering part\n    // of the flame\n    float noise = snoise((uv * NOISE_SCALE) + vec2(0.0, iTime * NOISE_SPEED)) * NOISE_MULT + NOISE_GAIN;\n    \n    // define a gradient that we can use to make the flame fall off at the top,\n    // and apply it to BOTH the flame mask and the noise together\n    float flame = (base * noise);\n    \n    float falloff = smoothstep(FALLOFF_MIN, FALLOFF_MAX, pow(uv.y, FALLOFF_EXPONENT));\n    flame = clamp(flame - falloff, -0.0, 1.0); // we have a flame!\n    \n    // time to give it some color! we will do this with two masks,\n    // a background mask, and a rim light mask\n    float background = smoothstep(BACKGROUND_MIN, BACKGROUND_MAX, flame);\n\tfloat rim = pow(1.0 - flame, RIM_EXPONENT) * background;\n    \n    // first we calculate our background color. I did a vertical gradient from dark purple to light purple,\n    // and it is multiplied by the background mask\n    vec3 color = mix(BACKGROUND_COLOR_MIN, BACKGROUND_COLOR_MAX, uv.y) * background;\n    \n    // now we apply rim light (I did cyan). We mix over our current color using the rim light mask\n    color = mix(color, RIM_COLOR, rim);\n    \n    // we could call it a day now, but lets add a little glow to give our flame a bit more ambience\n    // this time we'll make the glow flicker using noise! noise is a fantastic way to animate things as well\n    float glowFlicker = 1.0 + snoise(vec2(iTime * FLICKER_SPEED)) * FLICKER_STRENGTH;\n    glowP += GLOW_OFFSET;\n    glowP.x *= GLOW_WIDTH;\n    glowP *= GLOW_SIZE;\n        \n    vec3 glow = GLOW_COLOR * (pow(1.0 - length(glowP), GLOW_EXPONENT) * GLOW_STRENGTH * glowFlicker);\n    color += glow;    \n\n    // all done!\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtGWs", "name": "My first fractal", "author": "Radiant", "description": "biba", "tags": ["fractal"], "likes": 3, "viewed": 96, "date": "1569603491", "time_retrieved": "2024-06-20T19:44:55.295075", "image_code": "#define raymarch_iterations 24\n#define fractal_depth 16\n#define PI 3.14159265\n\n#define epsilon 0.001\n\nfloat far_clip = 50.0;\nvec3 v_main_color = vec3(1.0, 0.1, 0.1);\nvec3 v_sky_color = vec3(0.6, 0.8, 0.8);\n\n// fractal parameters\nfloat fractal_radius = 0.1;\nfloat fractal_scale = 1.55;\nvec3 fractal_offset = vec3(-0.1,-2.1,-0.3);\nmat3 m;\n\nfloat getAngle(vec3 v1, vec3 v2)\n{\n\treturn atan(length(cross(v1, v2)), dot(v1, v2));\n}\n\nfloat primitiveDist(vec3 pos)\n{\n    float x = abs(pos.x);\n    float y = abs(pos.y);\n    float z = abs(pos.z);\n\treturn max(max(x, y), z);   // cubes\n//\treturn x + y + z;\t\t\t// octaedrs (don't work)\n//\treturn length(pos.xyz);     // spheres\n}\n\nvec2 getDistance(vec3 v_pos)\n{\n\tfloat f_trap = far_clip;\n    float f_total_scale = 1.0;\n    \n    for (int i = 0; i < fractal_depth; i++)\n    {\n\t\tv_pos.xyz = abs(v_pos.xyz);\n        v_pos *= fractal_scale;\n        f_total_scale *= fractal_scale;\n        v_pos += fractal_offset;\n        v_pos *= m;\n        \n        float f_curr_dist = primitiveDist(v_pos) * f_total_scale;\n        f_trap = min(f_trap, f_curr_dist);\n    }\n    \n    float l = primitiveDist(v_pos) / f_total_scale;\n    \n    float f_dist = l - fractal_radius;\n    \n    return vec2(f_dist, f_trap);\n}\n\nvec3 getNormal(vec3 v_pos)\n{\n    float f_delta = 0.0001;\n\tvec3 v_offset1 = vec3( f_delta, -f_delta, -f_delta); \n\tvec3 v_offset2 = vec3(-f_delta, -f_delta,  f_delta); \n\tvec3 v_offset3 = vec3(-f_delta,  f_delta, -f_delta); \n\tvec3 v_offset4 = vec3( f_delta,  f_delta,  f_delta); \n    \n    float f1 = getDistance(v_pos + v_offset1).x;\n    float f2 = getDistance(v_pos + v_offset2).x;\n    float f3 = getDistance(v_pos + v_offset3).x;\n    float f4 = getDistance(v_pos + v_offset4).x;\n    \n    vec3 v_normal = v_offset1 * f1 +  v_offset2 * f2 +  v_offset3 * f3 +  v_offset4 * f4; \n    \n    return vec3(v_normal);\n}\n\nvec4 raycast(vec3 v_ray_origin, vec3 v_ray_direction)\n{\n\tfloat f_closest = far_clip;\n    vec2 d = vec2(0.0);\n    float t = 0.01;\n    \n    for (int i = 0; i < raymarch_iterations; i++)\n    {\n\t\td = getDistance(v_ray_origin + v_ray_direction * t);\n        f_closest = min(f_closest, d.x);\n        \n        if (abs(d.x) < epsilon)\n        {\n\t\t\tbreak;\n        }\n        \n        t += d.x;\n        \n        if (t > far_clip)\n        {\n\t\t\tt = far_clip;\n            break;\n        }\n    }\n    \n    return vec4(t, d.x, d.y, f_closest);\n}\n\nvec3 traceRay(vec3 v_ray_origin, vec3 v_ray_direction, vec3 v_light)\n{\n\tvec4 v_hit = raycast(v_ray_origin, v_ray_direction);  \n    vec3 v_hit_point = v_ray_origin + v_ray_direction * v_hit.x;\n    \n\tvec3 n = getNormal(v_hit_point);\n    \n    float f_angle = getAngle(n, v_light - v_hit_point);\n    vec4 v_light_hit = raycast(v_light, normalize(v_hit_point - v_light));\n    \n    vec3 v_hit_pos = v_ray_origin + v_ray_direction * v_hit.x;\n    vec3 v_color = v_sky_color;\n    \n    if (v_hit.w < fractal_radius * 0.4)\n    {\n        v_color = v_main_color;\n\t\tv_color *= (1.0 - clamp(f_angle / PI, 0.0, 0.7));\n        \n        if (abs(v_light_hit.x - length(v_light - v_hit_point)) > 0.1)\n        {\n\t\t\tv_color *= 0.5;\n        }\n    }\n    \n    return vec3(v_color);\n}\n\nmat3 calculateMatrix(float param)\n{\n\tfloat a = sin(param + 2.0); // yaw\n\tfloat b = sin(param + 4.0); // pitch\n\tfloat c = sin(param);       // roll\n        \n    vec3 v1 = vec3(cos(a)*cos(b), cos(a)*sin(b)*sin(c)-sin(a)*cos(c), cos(a)*sin(b)*cos(c)+sin(a)*sin(c));    \n    vec3 v2 = vec3(sin(a)*cos(b), sin(a)*sin(b)*sin(c)+cos(a)*cos(c), sin(a)*sin(b)*cos(c)-cos(a)*sin(c));\n    vec3 v3 = vec3(-sin(b), cos(b)*sin(c), cos(b)*cos(c));\n    mat3 r = mat3 (v1, v2, v3);\n    \n    return r;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 v_window = uv * 2.0 - 1.0;\n    v_window.x *= iResolution.x / iResolution.y;\n    \n    // Camera parameters\n    float f_angle = iTime / PI * 2.0 + 1.0;\n    float f_camera_distance = 5.0;\n    vec3 v_camera_position = vec3(sin(f_angle), 0.5, cos(f_angle)) * f_camera_distance;\n\tvec3 v_camera_target = vec3(0.0, 0.0, 0.0);\n    \n    float zoom = 1.0;\n    vec3 v_forward = normalize(v_camera_target - v_camera_position);    \n    vec3 v_right = normalize(cross(vec3(0.0, 1.0, 0.0), v_forward));    \n    vec3 v_up = normalize(cross(v_forward, v_right));\n                             \n    vec3 v_dir = normalize(v_window.x * v_right + v_window.y * v_up + v_forward * zoom);                         \n    \n    // Light Parameters\n    vec3 v_light_pos = vec3(2.1, 2.2, 1.5) * 10.0;\n    \n    m = calculateMatrix(iTime);\n    \n    vec3 result = traceRay(v_camera_position, v_dir, v_light_pos);                         \n                                \n    fragColor = vec4(result,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdtGWX", "name": "2D Cogs", "author": "zodiax", "description": "2D cogs animated", "tags": ["cogs"], "likes": 2, "viewed": 126, "date": "1569425240", "time_retrieved": "2024-06-20T19:44:55.295075", "image_code": "#define iterX 10\n#define iterY 6\n\nmat2 rotate2d(float _angle){//https://thebookofshaders.com/08/\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rectangle(vec2 uv, vec2 center, vec2 size){\nreturn step(abs(uv.x-center.x), size.x/2.)*step(abs(uv.y-center.y), size.y/2.);\n}\n\nfloat elipse(vec2 uv, vec2 center, vec2 size){\nreturn step(distance(uv/size,center), 0.2);\n}\n\nfloat cog(vec2 uv, float cogRadius, int cogSize, float rotSpeed, float scale,float dill)\n{\n    float cog;\n    uv /= scale;\n    uv *= rotate2d((dill+sin(iTime/4.)*4.)*rotSpeed); // rotation of the cog\n    for(int i = 0; i<cogSize; i++)//setting the ends of the cog - number and size\n    {\n       float toDeg = 3.14159/180.0;\n       cog += clamp(rectangle(uv*rotate2d((360.)/float(cogSize)*float(i+1)*toDeg),vec2(0.,0.2), vec2(.06, 0.055)),0.,1.);\n    };\n    cog += elipse(uv,vec2(0.),vec2(cogRadius*3.))-rectangle(uv,vec2(0.),vec2(cogRadius*0.35));\n    return cog;\n}\n\nfloat generateCogsX(vec2 uv, float iniDir, float tOffset)\n{\n    float cogSet;\n    float dir = iniDir;\n    float dill = 0.0+tOffset;\n    float cogOffset = 0.0825;\n\n    uv.x -= cogOffset*(float(iterX)-1.)/2.;\n    for(int i = 0; i<iterX; i++)//setting the ends of the cog - number and size\n    {\n       uv.x += cogOffset*min(float(i),1.); //offset the cog\n       dir *= -1.; //change the direction of rotation\n       dill += 180.*(-1.);// offset the roation to match the next cog\n       cogSet += cog(uv,0.3,10,dir,0.2,dill);\n    };\n\treturn cogSet;\n}\n\nfloat cogsXY(vec2 uv)\n{\n    float dir = -1.;\n    float cogs;\n    float cogOffset = 0.0825;\n    float tOffset = 0.;\n    uv.y -= cogOffset*(float(iterY)-1.)/2.;\n    for(int i = 0; i<iterY; i++)//setting the ends of the cog - number and size\n    {\n        tOffset += 180.;\n        dir *= -1.;\n        uv.y += cogOffset*min(float(i),1.); //offset the cog\n\t\tcogs += generateCogsX(uv, dir, tOffset);\n    };\n\treturn cogs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.0)/iResolution.x;\n\n    vec3 col = vec3(0.2,0.4,0.0)*min(cogsXY(uv),1.0);\n    col += (1.-min(cogsXY(uv),1.0)) * vec3(1.,.8,.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdtGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGzf", "name": "Arc UI", "author": "mystery", "description": "Just an example of futuristic animated ui", "tags": ["ui", "arc", "futuristic"], "likes": 1, "viewed": 351, "date": "1568998573", "time_retrieved": "2024-06-20T19:44:55.295075", "image_code": "float PI = 3.14159;\nfloat smoothness = 0.01;\n    \nvec2 NormalizeSpace(vec2 uv)\n{\n    return (uv - 0.5 * iResolution.xy) / iResolution.y;\n}\n\nvec2 Rotate(vec2 uv, float angle)\n{\n\treturn vec2(uv.x * cos(angle) - uv.y * sin(angle), uv.x * sin(angle) + uv.y * cos(angle));\n}\n\nfloat GetAngle(vec2 uv)\n{    \n\treturn 0.5 + ((atan(uv.x, uv.y)) / (PI)) * 0.5;   \n}\n\nfloat GetDonut(vec2 uv, float inRadius, float outRadius)\n{\n    float d = length(uv);\n    return (1.0-smoothstep(outRadius, outRadius + smoothness, d)) * (smoothstep(inRadius, inRadius + smoothness, d));;    \n}\n\nfloat DrawArc(vec2 uv, float inRadius, float outRadius, float arcAngle, float rotation)\n{\n    float color = GetDonut(uv, inRadius, outRadius);\n    vec2 rotatedUV = Rotate(uv, rotation * PI * 2.0);\n    float angle = GetAngle(rotatedUV);\t\n    float angleSmoothness = smoothness;\n    color *= smoothstep(angle, angle + angleSmoothness, arcAngle) * smoothstep(0.0, angleSmoothness, angle);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uvTex = fragCoord/iResolution.xy;\n    vec2 uv = NormalizeSpace(fragCoord);\n\tfloat c = 0.0;\n    c += DrawArc(uv, 0.25, 0.6, 0.25, iTime);\n    c += DrawArc(uv, 0.15, 0.2, 0.1, -iTime + 0.5);\n    c += DrawArc(uv, 0.05, 0.1, 0.05, iTime + 0.25);\n    \n    fragColor = texture(iChannel0, uvTex);\n    fragColor.rgb += vec3(c, c, c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdtGzj", "name": "Pixel road", "author": "mosaic", "description": "Modified from https://www.shadertoy.com/view/wsc3Rj", "tags": ["retro", "loopless", "infiniteroad"], "likes": 2, "viewed": 108, "date": "1568869984", "time_retrieved": "2024-06-20T19:44:55.295075", "image_code": "float hash(vec2 p) {\n   \n    p = fract(p*vec2(234.34, 435.345));\n    p += sin(dot(p, p+342.23));\n    return fract(p.x*p.y);\n    \n\n}\nmat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     uv*=r(sin(uv.x))*15.;\n     \n     vec2 guv = fract(uv+vec2(0,0));\n     vec2 id = floor(uv+vec2(0,0));\n     float d = guv.x;\n     //if(hash(id) >0.5) d = 1.-guv.x;\n     vec3 col = mix(vec3(0.1),vec3(.9,.9,.0),vec3(d));\n     col.r *= (sin(id.y+iTime*10.)) ;\n     col.g *= .5+hash(id+iTime/1000000.) ;\n     if(mod(id.y,  5.) == 0. ) col.b+=.9 ;\n     else col.b=.0;\n     \n     if(mod(abs(id.x),5.) == 2.-step(0.,sign(id.x))) col*=vec3(1.9,1.2,.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdtGzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdVGRW", "name": "Julia set animation", "author": "3ncryp73d", "description": "Animation of the Julia set, moving through different parameters for c", "tags": ["fractal", "julia", "math", "mandelbrot"], "likes": 0, "viewed": 70, "date": "1569854464", "time_retrieved": "2024-06-20T19:44:55.603823", "image_code": "vec3 colFromFloat(float f)\n{\n    vec3 col = vec3(0.);\n    \n    col.x = sin(f*5. + 0.5);\n    col.y = sin(f*5.);\n    col.z = sin(f*5. - 0.5);\n    \n    return col*col/distance(vec3(0.), col) * f * 2.;\n}\n\n\nvec2 nonperiodicCurve()\n{\n    \n    float pi = 3.141592653589793238426433832795028841971;\n    \n    vec2 ret = vec2(0.);\n    ret += 0.7*vec2(sin(iTime/10.), cos(iTime/10.));\n    ret += 0.2*vec2(sin(iTime/pi*2.), cos(iTime/pi*2.));\n    \n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y * 2.5; \n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    col = vec3(0.);\n    \n    vec2 c = nonperiodicCurve(); //vec2(sin(iTime/10.), cos(iTime/10.)) * sin(iTime / 50.);\n    vec2 z = uv;\n    \n    float l;\n    \n    for (float i = 0.; i < 200.; i++)\n    {\n        z = vec2(z.x*z.x + c.x - z.y*z.y, 2.*z.x*z.y + c.y);\n        \n        if (z.x*z.x + z.y*z.y > 5.) {\n            l = i / 50.;\n            break;\n        }\n    }\n        \n      \n    col = colFromFloat(l),// + ((0.03 < distance(uv, c)) ? vec3(0.) : vec3(1.));\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdVGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdy3zh", "name": "crispy ball", "author": "hexjay", "description": "Shane's texture bump mapping on IQ's raymarching base code.", "tags": ["raymarch", "bumpmap"], "likes": 9, "viewed": 156, "date": "1569659383", "time_retrieved": "2024-06-20T19:44:56.858397", "image_code": "/*\n\tToying with code from :\n\tShane's texture bump mapping -> https://www.shadertoy.com/view/MlXSWX\n\tIQ's raymarch code -> https://www.shadertoy.com/view/Xds3zN\n\tNimitz's fog -> https://www.shadertoy.com/view/4ts3z2\n\n\tThanks to Shane for the very useful help.\n*/\n\nmat3 rotate3(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat customShape( vec3 p, vec2 t )\n{\t// 3 torus with displacements\n  \tfloat t1 = length( vec2(length(p.xz)-t.x,p.y*0.2) )-t.y*cos(p.z*1.4);\n  \tfloat t2 = length( vec2(length(p.yx)-t.x,p.z*0.2) )-t.y*cos(p.x*1.4);\n  \tfloat t3 = length( vec2(length(p.zy)-t.x,p.x*0.2) )-t.y*cos(p.y*1.4);  \n  \treturn min(min(t1,t2),t3);\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.x += iTime*1.5;\n    p.z += sin(p.x*.5);\n    return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,.7,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .5;\n    for(int i=0; i<7; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd =  clamp((rz - fogmap(pos+.8-float(i)*0.1,d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(.1,0.1,.1)*.5 + .5*vec3(.1, .1, 0.1)*(1.7-grd))*0.55;\n        col = mix(col,col2,clamp(rz*smoothstep(d-0.4,d+2.+d*.75,mt),0.,1.) );\n        d *= 1.5+0.3;\n        if (d>mt)break;\n    }\n    return col;\n}\n\n//----------------------------------------------------------------------\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// from Shane : https://www.shadertoy.com/view/MlXSWX\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p )\n{\n    float dist;\n    vec2 obj1, obj2, rmap;\n       \n   \tvec3 pr1 = rotate3(vec3(0.2,0.13,0.)*iTime*2.)*p;\n   \tvec3 pr2 = rotate3(vec3(-0.24,-0.13,1.1)*iTime)*p;    \n\n\tdist = sdSphere(pr1,0.8) ;\n    obj1 = vec2 ( dist, 1 );\n\n    dist = customShape( pr2-vec3( 0.0, 0.0, 0.0), vec2(1.3,0.1) );\n    obj2 = vec2 ( dist, 2 );\n    \n    rmap = opU(obj1,obj2);\n    return rmap;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmax = 20.0;  \n    float t = 1.;\n    float oid = -1.0;\n    \n    for( int i=0; i<550; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x< 0.001 || t>tmax ) break;\n        t += res.x;\n        oid = res.y; \n    }\n\n    if( t>tmax ) oid=-1.0;\n    return vec2(t,oid);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.);\n    vec2 res = castRay(ro,rd);\n    vec3 p = ro +rd*res.x;        \n    \n    if ( res.x < 20. ) \n    {\n        \n        vec3 n = calcNormal(p);\n        vec3 lightDir=normalize(vec3(1.,1.,-1.));\n        \n        vec3 light2Pos=vec3(2.,-1.,-4.);\n        vec3 light2Dir=normalize(light2Pos-p);\n\n        vec3 tex = vec3(0.);\n        mat3 rotMat = mat3( 0. );\n        if ( res.y == 1. ) // sphere\n        {\n            vec3 rotationValues = vec3(0.2,0.13,0.) * iTime*2.;\n            rotMat = rotate3( rotationValues );\n        \tp = rotMat * p;\n            n = rotMat * n;\n            \n            n = doBumpMap( iChannel1, p, n, 0.045);\n            tex = tex3D( iChannel1, p, n);\n        } else //( res.y == 2. ) // custom shape\n        {\n            vec3 rotationValues = vec3(-0.24,-0.13,1.1) * iTime; \n            rotMat = rotate3( rotationValues );\n        \tp = rotMat * p;\n            n = rotMat * n;\n        \n            n = doBumpMap( iChannel2, p, n, 0.045);\n            tex = tex3D( iChannel2, p, n);\n        }\n\t\t\n        lightDir = rotMat * lightDir;\n        light2Dir = rotMat * light2Dir;\n        float b=dot(lightDir,n);\n        float b2=dot(light2Dir,n);\n        col = vec3( (b+b2)*tex+pow( (b+b2)*0.5,9.0));    \n        \n    } else \n    {\n        col = vec3(0.,0.,0.);\n        p = mix(p,ro+rd*20.,exp(rd/20.));\n        vec3 btex = tex3D(iChannel1,p/20., -rd).xyz;\n        col = mix(col,btex,0.9);\n    }\n    \n    col = fog( col, ro, rd, 2.2);\n    \n \treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 4., 0., 0.);\n    \n\tvec3 ta = vec3( 0., 0., 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.6) );\n\n   \t// vignetting from : https://www.shadertoy.com/view/4lSXDm\n   \tfloat falloff = 0.6;\n    float rf = sqrt(dot(p, p)) * falloff;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    \n\tfragColor = vec4(col * e * 1.3, 1.0);\n    \n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdy3zh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdyGRz", "name": "Spoooky", "author": "klemek", "description": "Right in time for spooktober.\n(My first shader derived from a beginner tutorial.)", "tags": ["simple", "ghost", "spooky"], "likes": 5, "viewed": 467, "date": "1569581742", "time_retrieved": "2024-06-20T19:44:56.858397", "image_code": "#define debug false\n#define eps 1.5 / iResolution.y\n#define pi4 .785\n#define is2 .0707\n\n#define ratio iResolution.x/iResolution.y\n\nfloat seed = 195845.184613;\n\nfloat rand(float max)\n{\n    seed = fract(100000.0*sin(seed));\n    return seed * max;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 place(vec2 uv, vec2 pos, float size, float a)\n{\n     return (uv-pos)*size * rot(a);\n}\n\nfloat norm(float i) {\n    return min(max(i, 0.), 1.);\n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n    float d = length(uv - p);\n    return smoothstep(r, r - eps, d);\n}\n\nfloat rect(vec2 uv, vec2 p, vec2 d, float a) {\n    uv *= rot(a);\n    p *= rot(a);\n    return smoothstep(0., eps, uv.x - p.x) *\n        smoothstep(0., -eps, uv.x - p.x - d.x) *\n        smoothstep(0., eps, uv.y - p.y) *\n        smoothstep(0., -eps, uv.y - p.y - d.y);\n}\n\nvec4 ghost(vec2 uv, float time) {\n    float a = .4 * cos(time * 1.1 + rand(10.));\n    float speed = 5. * cos(time + rand(10.));\n    float radius = .3 * cos(time * .8 + rand(10.));\n    float size = 1. + .1 * cos(time * 1.2 + rand(10.));\n    float eye = cos(time * .75 + rand(10.));\n    vec3 col = 0.5 + 0.5 * cos(time + vec3(0, 2, 4));\n    if (debug)\n    {\n        radius = 0.;\n        a = 0.;\n        size = 1.;\n        eye = 1.;\n    }\n    vec2 p = vec2(\n        cos(time * .9 + speed + rand(10.)) * ratio, \n        sin(time * .9 + speed + rand(10.))\n    ) * radius;\n    uv = place(uv, p + vec2(0., .05), size, a);\n    \n    vec2 assp = vec2(is2, is2);\n\n    float ass = rect(uv, vec2(.15, -.2), assp, pi4) +\n        rect(uv, vec2(.05, -.2), assp, pi4) +\n        rect(uv, vec2(-.05, -.2), assp, pi4) +\n        rect(uv, vec2(-.15, -.2), assp, pi4) +\n        rect(uv, vec2(-.25, -.2), assp, pi4);\n\n    float body = circle(uv, vec2(0.), .2) +\n        rect(uv, vec2(-.2, -.2), vec2(.4, .2), 0.) +\n        rect(uv, vec2(-.2, -.25), vec2(.4, .06), 0.) * ass;\n\n    float eyes =\n        circle(uv, vec2(.08 + .05 * eye, 0.), .05) +\n        circle(uv, vec2(-.08 + .05 * eye, 0.), .05) -\n        circle(uv, vec2(.08 + .08 * eye, 0.), .02) -\n        circle(uv, vec2(-.08 + .08 * eye, 0.), .02);\n\n    float mask = norm(body) - eyes;\n\n    return vec4(vec3(norm(mask)) * col, .5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    fragColor = ghost(uv, iTime) +\n        ghost(uv, iTime + rand(1000.)) +\n        ghost(uv, iTime + rand(1000.)) +\n        ghost(uv, iTime + rand(1000.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdyGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wl2SD3", "name": "Broken LCD)))", "author": "Kapsy", "description": "DEMO OR DIE!", "tags": ["kapsy"], "likes": 0, "viewed": 97, "date": "1567320711", "time_retrieved": "2024-06-20T19:44:56.858397", "image_code": "float smin(float a,float b, float h){\n  float k = clamp((a-b)/h*0.5+0.5,0.,1.);\n  return mix(a,b,k)-k*(1.0-k)*h;\n  }\n  \nvec2 moda(vec2 p, float per){\n  float a = atan(p.y,p.x);\n  float l = length(p);\n  a = mod(a-per/2.,per)-per/2.;\n  return vec2(cos(a),sin(a))*l;\n  }\n\nmat2 rot(float a){\n  return mat2(cos(a),sin(a),-sin(a),cos(a));\n  }\n  \nfloat cone(vec3 p , vec2 c){\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n  }\n  \n  float nose(vec3 p , vec2 h){\n    vec3 q = abs(p);\n    return max(q.z-h.y, max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n  }\n float c1=0.0;  \nfloat head(vec3 p){\n  float b = length(p)-1.2;\n  float s1 = length(p+vec3(-0.4,0.3,1.0))-0.2;\n  float s2 = length(p+vec3(0.4,0.3,1.0))-0.2;\n  float s = min(s1,s2);\n  float f = smin(b,-s,-0.050);\n  c1=0.1/(0.1+f*f);\n  return f;\n  }\n  \nfloat sborka(vec3 p){\n  vec3 pp =p;\n  p.xz*=rot(iTime);\n  float h = head(p);\n  float n = nose(vec3(p.x,-p.y,p.z)+vec3(0.,0.,1.0),vec2(0.2));\n  float x = smin(h,-n,-0.050);\n float m = length(vec3(p.x/2.0,p.z+0.9,p.y*3.0-1.4))-mix(0.3,0.35,sin(iTime*4.0));\n   return smin(x,-m,-0.050);\n\n  }\n  \nfloat SDF(vec3 p){\n  vec3 pp = p;\n\n  p.xy = moda(p.xy,3.145926/4.0);\n  p.xy=mod(p.xy+sin(p.x),4.0);\n  p.yxz = min(p.xyz,cross(p.xyx,abs(pp))); \n  p.xz*=rot(iTime);\n  float s = sborka(p);\n  s = min(s,length(abs(p.y)));\n  \n  \n  return s;\n  }\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  vec2 reso = vec2(10,5);\n  uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  vec2 uvx = vec2(fragCoord.x / reso.x, fragCoord.y / reso.y);\n  uvx -= 0.5;\n  uvx /= vec2(reso.y / reso.x, 1.0);\n  vec3 ro = vec3(0.001,0.001,-4); vec3 p =ro;\n  vec3 rd = normalize(vec3(-uv,1.));\n  vec3 col = vec3(1.);\n  float shad = 0.;\n  float dd =0.0;\n  bool hit = false;\n  for(float i =0.0; i<100.0; i++){\n    float d = SDF(p);\n    if(d<0.001) {shad=i/100.0;\n      hit = true;\n      break;}\n    if(dd>100.0) {dd=100.0; break;}\n    p+=d*rd;\n    dd+=d;    \n    }\n    float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n    vec2 eps = vec2(0.001,0);\n    vec3 n = normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.xxy),SDF(p-eps.yyx)));\n    vec3 l = normalize(-vec3(1,3,5));\n    vec3 h = normalize(l-rd);\n    if(hit) col=max(0.0,dot(n,l))*fog*(vec3(0.0,0.300,0.4)+pow(max(0.0,dot(n,h)),1.3)*pow(max(0.0,dot(n,h)),10.0));\n    else  {\n        vec3 col2 = vec3(texture(iChannel0,vec2(mix(uv.x/1.0,uv.x/2.0,sin(iTime*0.3)),uvx)));\n       col=mix(col2.rgb+sin(uvx.y+mix(uvx.x,uvx.x+0.3,tan(iTime))),col2.rgb,tan(iTime*0.5));\n    }\n     col+=c1*vec3(4.,0.,0.);\n       \n  fragColor = vec4(clamp(col,0.0,2.0),0.0);\n}\n/*                        ______                     \n _________        .---\"\"\"      \"\"\"---.              \n:______.-':      :  .--------------.  :             \n| ______  |      | :                : |             \n|:______B:|      | |  DEMO  OR      | |             \n|:______B:|      | |                | |             \n|:______B:|      | |  DIE!          | |             \n|         |      | |                | |             \n|:_____:  |      | |                | |             \n|    ==   |      | :                : |             \n|       O |      :  '--------------'  :             \n|       o |      :'---...______...---'              \n|       o |-._.-i___/'             \\._              \n|'-.____o_|   '-.   '-...______...-'  `-._          \n:_________:      `.____________________   `-.___.-. \n                 .'.eeeeeeeeeeeeeeeeee.'.      :___:\n               .'.eeeeeeeeeeeeeeeeeeeeee.'.         \n              :____________________________:\n*/", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2SD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wl2XD3", "name": "insect colony", "author": "lomateron", "description": "remix of:\nhttps://www.shadertoy.com/view/MdjGWy\nhttps://www.shadertoy.com/view/3lBXWc\n", "tags": ["noise", "gabor"], "likes": 5, "viewed": 376, "date": "1567381554", "time_retrieved": "2024-06-20T19:44:56.858397", "image_code": "float rnd(vec2 u, vec2 f)\n{\n    vec4 a = fract(sin(dot(f,vec2(37.34,97.74)))\n                   *vec4(6925.953,7925.953,8925.953,9925.953));\n    vec2 b = cos(a.x*6.2831+vec2(0.,1.57)+iTime*(a.z-.5));\n    return cos(dot(u,b*a.y*6.)+a.w*6.2831)*.5+.5;\n}\nfloat bub(vec2 u)\n{\n    return max(cos(min(length(u)*3.4641,3.141))*.5+.5,0.);\n    //return exp(dot(u,u)*-4.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 16.*(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 s = vec2(2.,1.73205080757);\n    vec2 a0 = (u+s*vec2(.0 ,.0))/s;\n    vec2 a1 = (u+s*vec2(.5 ,.0))/s;\n    vec2 a2 = (u+s*vec2(.25,.5))/s;\n    vec2 a3 = (u+s*vec2(.75,.5))/s;\n    vec2 a0f = fract(a0)*s-s*.5;\n    vec2 a1f = fract(a1)*s-s*.5;\n    vec2 a2f = fract(a2)*s-s*.5;\n    vec2 a3f = fract(a3)*s-s*.5;\n    fragColor = vec4(bub(a0f)*rnd(u,floor(a0)+.0)+\n                     bub(a1f)*rnd(u,floor(a1)+.1)+\n                     bub(a2f)*rnd(u,floor(a2)+.2)+\n                     bub(a3f)*rnd(u,floor(a3)+.3));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wl2XD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlBSRD", "name": "W Tile", "author": "TLC123", "description": "procedural texture", "tags": ["procedural", "texturesynth"], "likes": 6, "viewed": 68, "date": "1569272315", "time_retrieved": "2024-06-20T19:44:57.300883", "image_code": "//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 pal( in float t) {\n\tvec3 pa = vec3(0.5, 0.5, 0.5);\n\tvec3 pb = vec3(0.5, 0.5, 0.5);\n\tvec3 pc = vec3(1.0, 1.0, 1.0);\n\tvec3 pd = vec3(0.3, 0.20, 0.20);\n\treturn pa + pb * cos(6.28318 * (pc * t + pd));\n}\n\nvec3 getTileData(vec2 uv) {\n\tvec2 cornerUV = floor(uv);\n\tfloat id = (hash12(cornerUV));\n\tvec2 tileCore = 0.5 + ((hash22(cornerUV)) - 0.5) * 0.95;\n\treturn vec3(tileCore, id);\n}\n\nbool insideBox(vec2 v, vec2 b, vec2 t) {\n\n\treturn\n\tv.x < max(t.x, b.x) && v.x > min(t.x, b.x) &&\n\n\tv.y < max(t.y, b.y) && v.y > min(t.y, b.y)\n\n\t;\n\n}\n\nvec3 tile(vec2 uv) {\n\tvec2 tileUV = uv - floor(uv);\n\n\tvec2 o = vec2(1., 0.);\n\tvec3 res1 = getTileData(uv + o.yy);\n\tvec3 res2 = getTileData(uv + o.xy);\n\tvec3 res3 = getTileData(uv + o.yx);\n\tvec3 res4 = getTileData(uv + o.xx);\n\tfloat id = 0.;\n\n\tif (insideBox(tileUV, vec2(0., res1.y), res3.xy + o.yx)) id = res3.z;\n\tif (insideBox(tileUV, vec2(res3.x, res2.y), res4.xy + o.xx)) id = res4.z;\n\tif (insideBox(tileUV, vec2(res1.x, 0.), res2.xy + o.xy)) id = res2.z;\n\tif (insideBox(tileUV, vec2(0.), res1.xy)) id = res1.z;\n\n\tvec2 cornerUV = floor(uv);\n\tfloat rnd = hash12(cornerUV);\n\tif (rnd < 0.25 && insideBox(tileUV, vec2(res1.x, 0.), res2.xy + o.xy)) id = res2.z;\n\tif (rnd < 0.50 && insideBox(tileUV, vec2(res3.x, res2.y), res4.xy + o.xx)) id = res4.z;\n\tif (rnd < 0.75 && insideBox(tileUV, vec2(0., res1.y), res3.xy + o.yx)) id = res3.z;\n\n\t//if (length((res1.xy) - tileUV) < 0.05) id = .5;\n\n\treturn pal(id);\n}\n\nvec3 difftile(vec2 uv) {\n\nreturn tile(  uv).yxy-tile(  uv+.05).zyz;\n\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.x - 0.5;\n\tpR(uv, iTime);\n\t// Time varying pixel color\n\tuv = uv * (cos(iTime) + 1.2) * 30. + vec2(sin(iTime * .6), cos(iTime * .6)) * 17.;\n\tvec3 col = difftile(uv) * 0.2 + 0.5;\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlBSRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wljXDc", "name": "Simple Shapes", "author": "Nano98", "description": "First Step, just some models", "tags": ["raymarching"], "likes": 2, "viewed": 67, "date": "1567413449", "time_retrieved": "2024-06-20T19:44:57.300883", "image_code": "mat2 rotate(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat cap(vec3 p,float h,float r){\n    p.y -= clamp(p.y,0.0,h);\n    return length(p) - r;\n}\nfloat tor(vec3 p,vec2 t){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat oct(vec3 p,float s){\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if(3.0*p.x < m) q = p.xyz;\n    else if(3.0*p.y < m) q = p.yzx;\n    else if(3.0*p.z < m) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat getDist(vec3 p){\n    float s = sphere(p,0.25);\n    float cap = cap(abs(p)-vec3(0.3,0,0.3),0.4,0.02);\n    float p1 = p.y - (-0.25);\n    float tor = tor(abs(p)-vec3(0.3,0.0,0.3),vec2(0.3,0.05));\n    vec3 q = p;\n    q.xz *= rotate(iTime*2.0);\n    float oct = oct(q - vec3(0,0.5,0),0.1);\n    float m = min(min(s,p1),cap);\n    m = min(m,tor);\n    m = min(m,oct);\n    return m;\n}\n\nfloat Ray(vec3 ro, vec3 rd){\n    int steps = 100;\n    float h,t = 0.0;\n    \n    for(int i = 0;i<steps;i++){\n        vec3 pos = ro + t * rd;\n        h = getDist(pos);\n        t += h;\n        if(h<0.01 || t>20.0) break;\n    }\n    if(t > 20.0) t = -1.0;\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(getDist(p+e.xyy) - getDist(p-e.xyy),\n                          getDist(p+e.yxy) - getDist(p-e.yxy),\n                          getDist(p+e.yyx) - getDist(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.4,0.5,0.7);\n    \n    float angle = iTime;\n    \n    vec3 ro = vec3(sin(iTime),abs(cos(iTime)),1.0*cos(iTime));\n    vec3 tar = vec3(0.0,.125,0.0);\n    vec3 ww = normalize(tar-ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.2*ww);\n    \n    float t = Ray(ro,rd);\n\n    if(t > 0.0){\n    \n        vec3 pos = ro + t * rd;\n        \n        vec3 keyLight = vec3(.8,.4,0.2);\n        vec3 light_dir = normalize(keyLight);\n        \n        vec3 nor = getNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        float key_dif = clamp(dot(nor,light_dir),0.0,1.0);\n        float key_shadow = step(Ray(pos+ 0.01*nor,light_dir),0.0);\n        float sky_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0);\n        float bound_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        col = mate*vec3(6.0,4.0,3.0)*key_dif*key_shadow;\n        col += mate*vec3(0.5,0.8,0.9) * sky_dif;\n        col += mate*vec3(0.7,0.3,0.2) * bound_dif;\n        \n    }\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wljXDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlSGDh", "name": "inference jani", "author": "janiorca", "description": "A very long time ago one of the amiga demo effects was creating an inference pattern bby rapidly moving two bitplanes with concentric circles. This is the glsl equivalent of that. and my first shadertoy submission", "tags": ["tests"], "likes": 6, "viewed": 183, "date": "1569698293", "time_retrieved": "2024-06-20T19:44:57.300883", "image_code": "#define num_circles 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 sc = vec2( 0.5, 0.5*iResolution.y/iResolution.x );\n\n    for( int idx=0; idx<num_circles; idx++ ) \n    {\n        vec2 center = vec2(sin( iTime*(float(idx)*0.132+0.1672 ) )*(0.146+0.0132*float(idx)),\n                                sin( iTime+ iTime*(float(idx)*0.1822+0.221))*(0.1131+0.0112*float(idx)) ) + sc;\n\n        float dist = distance( center, uv );\n        vec3 col = vec3( sin( 100.0*dist ), sin( 110.0*dist ), sin( 120.0*dist ) );\n        col *= max( 0.0, (1.0-dist*3.0) );\n        fragColor += vec4( col, 0.0 );\n    }    \n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlSGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSDS", "name": "Bips and Bops", "author": "vitasa", "description": "Learning", "tags": ["learning"], "likes": 9, "viewed": 257, "date": "1567395717", "time_retrieved": "2024-06-20T19:44:57.300883", "image_code": "// function to return a random number\nfloat random (vec2 p) {\n    p = fract(p*vec2(123.45, 678.91));\n    p += dot(p, p+23.45);\n    return fract (p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 pattern = vec3(0);\n    \n    \n    float units = 18.;\n    vec2 gv = fract(uv * units) - .5;\n    vec2 id = floor(uv * units) + .5; // add .5 here to center\n    \n    float d = length(gv);\n    \n    float minRadius = .2;\n    float maxRadius = .4;\n    float speed = 10.2;\n    float time = iTime * speed;\n    float pulseAmount = 3.;\n    float radiusTime = sin(random(id) * time) * .5 + .5; \n    \n    float radius = mix(\n        minRadius, \n        maxRadius,\n        radiusTime);\n        \n    pattern += smoothstep(radius, radius*mix(.4,.7,(radiusTime)),d);\n    \n    float t = sin(length(gv - id) - time)*.5+.5;\n    vec3 color = vec3(random(id));\n    \n    fragColor = vec4(color * pattern,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlSSDt", "name": "Colorful Lights", "author": "ikuto", "description": " ", "tags": ["3d", "colorful", "ring", "lights"], "likes": 4, "viewed": 269, "date": "1567488338", "time_retrieved": "2024-06-20T19:44:57.700894", "image_code": "#define PI 3.1415927\n#define LIGHT_NUM  73\n\nstruct Light\n{\n    vec3  pos;\n    vec3  col1, col2;\n    float rad1, rad2;\n};\n\nLight lights[LIGHT_NUM];\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up) //calculate view matrix\n{\n    vec3 w = normalize(target - eye);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n    return mat3(u, v, -w);\n}\n\nvoid rotate(inout vec2 v, float a) { v = cos(a)*v+sin(a)*vec2(-v.y,v.x); }\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //init lights\n    lights[0] = Light(vec3(0.0), 0.5*vec3(1.0,0.8,0.3), 8.0*vec3(1.0,0.6,0.3), 6.0, 0.8);\n    for (int i = 1; i < LIGHT_NUM; ++i)\n    {\n        vec3 col[3] = vec3[](vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,0.0,1.0));\n        lights[i] = Light(vec3(0.0), 0.4*col[i%3], 2.0*vec3(1.0), 2.0, 0.3);\n    }\n    \n    //update lights\n    const int N = (LIGHT_NUM-1)/3;\n    float an = 0.0, dt = 2.0*PI/float(N); \n    for (int i = 1; i < LIGHT_NUM; ++i)\n    {\n\t    lights[i].pos.xy = 2.0 * vec2(sin(iTime+an),cos(iTime+an));    \t\n        if (i%3==0) an += dt;\n    }\n    \n    for (int i = 0; i < N; ++i) \n    {\n        rotate(lights[3*i+2].pos.yz, PI/3.0);\n        rotate(lights[3*i+3].pos.yz, -PI/3.0); \n    }\n    \n    //draw lights\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < LIGHT_NUM; ++i)\n    {\n        vec3  lv = lights[i].pos - ro;\n        float an = acos(dot(rd, lv/length(lv)));\n\t#define T(r) (1.0-smoothstep(0.0, r, an*length(lv)))\n        float w = (i == 0) ? 1.0 : 0.1;\n        color += lights[i].col1 * pow(T(lights[i].rad1), \t 4.0) * w;\n        color += lights[i].col1 * pow(T(lights[i].rad2*2.0), 4.0);\n        color += lights[i].col2 * pow(T(lights[i].rad2), \t 4.0);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2  uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    float an = PI/2.0 + 0.3 + 0.4*iTime;\n    vec3  rayOri = 5.0 * vec3(sin(an), 0.0, cos(an));\n    mat3  viewMat = lookAt(rayOri, vec3(0.0), vec3(0.0,1.0,0.0));\n    vec3  rayDir = viewMat * normalize(vec3(uv, -1.5));\n \n   \tvec3 color = render(rayOri, rayDir);\n    color = pow(color, vec3(0.95+0.4*sin(iTime)));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlSSDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WlsSRB", "name": "Times Table", "author": "Deirin", "description": "First attempt at shader coding. Idea stolen from this video: https://www.youtube.com/watch?v=qhbuKbxJsk8 . You can try and change the timesTableSubject variable on top while the shader time is stopped to see some interesting patterns displayed.", "tags": ["2d", "math", "sdf", "rainbow", "timestables"], "likes": 11, "viewed": 253, "date": "1569025516", "time_retrieved": "2024-06-20T19:44:57.700894", "image_code": "const int pointsCount = 99;\nfloat radius    = .45;\nconst float thickness = .0005;\nfloat timesTableSubject = 1.;\nconst float colorIntensity = 2.;\nconst float TAU = 6.28318530718;\nconst float speed = .8;\n\nfloat Circle( in vec2 c, in float r ) {\n    return length( c ) - r;\n}\n\nfloat Union( in float a, in float b ) {\n    return min( a, b );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv     = fragCoord / iResolution.xy;    \n    vec2 center = ( uv - .5 );\n    float angle = TAU / float( pointsCount );\n    \n    timesTableSubject += iTime * speed;\n    \n    center.x *= iResolution.x / iResolution.y;   \n    \n    radius += abs(sin(iTime)) * .05;\n    float sdf = Circle( center, radius );\n    sdf       = abs( sdf ) - thickness;\n    \n    for( int i = 0; i < pointsCount; i++ ) {\n        vec2 sPoint = vec2( cos( angle * float(i) ) * radius + center.x, sin( angle * float(i) ) * radius + center.y );\n        int targetPointIndex = int( mod( ( float( i + 1 ) ) * timesTableSubject, float( pointsCount ) ) );\n        vec2 tPoint = vec2( cos( angle * float(targetPointIndex) ) * radius + center.x, sin( angle * float(targetPointIndex) ) * radius + center.y );\n        sdf = Union( sdf, sdLine( vec2(0.,0.), sPoint, tPoint) );\n    }\n    \n    float pulseCircle = abs( Circle(center, fract(iTime*.8))) - thickness;\n    sdf = min(sdf, pulseCircle);\n    sdf = smoothstep(0.005, 0.0, sdf);\n    float bg = sin(Circle(center,radius));\n    bg = min(bg, sin(bg*130.*sin(iTime)));\n    sdf = max(bg, sdf);\n    \n    fragColor = vec4( vec3( sin(iTime)*.5+.5,sin(iTime+TAU/3.)*.5+.5,sin(iTime+TAU*2./3.)*.5+.5) * sdf * colorIntensity, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WlsSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws33Dj", "name": "overTheHills", "author": "melkor", "description": "Raymarched mountainous terrain", "tags": ["raymarchterrain"], "likes": 0, "viewed": 53, "date": "1569526593", "time_retrieved": "2024-06-20T19:44:57.700894", "image_code": "#define CLIPPING_DIST 0.001\n#define PI 3.14159265359\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat hash3(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);\n}\n//http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\nfloat noise( vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = vec3(hash3( p + g ))*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\nfloat terrain(float x, float y, bool s) {\n    float level = 0.5*sin(x) + sin(y);\n    level += noise(vec2(x,y), 1.0, 1.0);\n    if (!s) {\n    \tlevel += 0.1*noise(vec2(10.0*x,10.0*y),1.0,1.0);\n    }\n    \n    float waterLevel = -0.5;\n    \n    return max(level, waterLevel);\n}\n\nfloat getDist(vec3 p) {\n\tvec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    float sphereDist = length(p-sphere.xyz) - sphere.w;\n    float terrainDist = p.y - terrain(p.x, p.z, false);\n    \n    return min(sphereDist, terrainDist);\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 n;\n    \n    //sphere\n    vec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    vec3 radius = p-sphere.xyz;\n    if (abs(length(radius)-sphere.w) < CLIPPING_DIST) {\n    \tn = radius;\n    }\n    else {\n    \t//Terrain\n        float d = 0.001;\n        n = vec3( terrain(p.x-d,p.z, false) - terrain(p.x+d,p.z, false),\n                            2.0f*d,\n                            terrain(p.x,p.z-d, false) - terrain(p.x,p.z+d,false));\n    }\n    \n    return normalize(n);\n}\n\nfloat getLighting(vec3 p, vec3 n) {\n\tvec3 light = vec3(3.0, 10.0, 5.0);\n    vec3 ray = p-light;\n    return (1.0 - dot(ray, n))/pow(length(ray), 2.0);\n}\n\nvec3 getColour(vec3 p, vec3 n) {\n    float reflectivity;\n    vec3 surfaceColour;\n    vec3 lightColour = vec3(1.0, 0.2, 0.2);\n    vec3 ambientColour = vec3(0.1, 0.1, 1.0);\n    float brightness = 50.0;\n    \n    //sphere\n    vec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    if (abs(length(p-sphere.xyz)-sphere.w) < CLIPPING_DIST) {\n        //metal\n    \treflectivity = 0.9;\n        surfaceColour = vec3(0.8, 1.0, 0.8);\n    }\n    else {\n        if (abs(p.y + 0.5) < CLIPPING_DIST) {\n            //water\n            return 0.5*mix(vec3(0.5, 0.5, 1.0), vec3(0.2, 0.1, 0.1), getLighting(p, n));\n        }\n        else if(p.y > 1.2+0.5*noise(10.0*p.xz, 1.0, 1.0)) {\n        \t//ice\n            reflectivity = 0.9;\n        \tsurfaceColour = vec3(0.9, 0.9, 1.0);\n        }\n        else {\n        \treflectivity = 0.2;\n            surfaceColour = vec3(0.2, 0.1, 0.1);\n        \t//colour = vec3(1.0, 0.4, 0.0);\n        }\n    }\n    \n    float light = reflectivity*getLighting(p, n);\n    float ambientIntensity = 0.1+reflectivity/100.0; //ambient blue light from sky\n    \n    return (brightness * light * lightColour * surfaceColour) + (ambientIntensity * ambientColour);\n}\n\nfloat castRay(vec3 origin, vec3 direction) {\n    float visibilityDist = 100.0;\n    float stepDist;\n    float travelled = CLIPPING_DIST;\n    int maxSteps = 100;\n    vec3 loc = origin + direction * CLIPPING_DIST;\n    \n    for (int i = 0; i < maxSteps; i++) {\n    \tstepDist = getDist(loc);\n        if (stepDist < CLIPPING_DIST || travelled > visibilityDist) {\n            break;\n        }\n        travelled += stepDist;\n        loc += direction * stepDist;\n    }\n    return travelled;\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 r = 2.0 * (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    //move camera in circle\n    float angle = 0.2*iTime;\n    vec2 loc = vec2(10.0*cos(angle), 10.0*sin(angle)+6.0);\n    vec3 cameraPos = vec3(loc.x, terrain(loc.x, loc.y, true) + 2.0, loc.y);\n    vec3 lookAt = vec3(r.xy, 1.0);\n    mat3 rotation = mat3(cos(angle + PI/2.0),0.0,sin(angle + PI/2.0),\n                         0.0, 1.0, 0.0,\n                         -sin(angle + PI/2.0), 0.0, cos(angle + PI/2.0));\n    lookAt = normalize(rotation*lookAt);\n    \n    \n    vec3 skyColour = vec3(0.0, 0.1, 0.2);\n    vec3 terrainColour = vec3(0.6, 0.4, 0.2);\n    \n    float dist = castRay(cameraPos, lookAt);\n    vec3 p = cameraPos + dist*lookAt;\n    vec3 n = getNormal(p);\n    n.z = -n.z;\n    vec3 colour = getColour(p, n);\n    \n    //antialias horizon\n    colour = mix(colour, skyColour, smoothstep(5.0, 100.0, dist));\n    \n    fragColour = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws33Dj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws33Dl", "name": "Liquid", "author": "shiauming", "description": "Liquid", "tags": ["2d"], "likes": 7, "viewed": 195, "date": "1569465663", "time_retrieved": "2024-06-20T19:44:57.700894", "image_code": "#define MAIN_COLOR vec3(1.0, 1.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfor(int i=1;i<10;i++)\n\t{\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.6/float(i)*sin(float(i)*p.y+iTime+0.3*float(i))+1.0;\n\t\tnewp.y+=0.6/float(i)*sin(float(i)*p.x+iTime+0.3*float(i+10))-1.4;\n\t\tp=newp;\n\t}\n\tvec3 col=vec3(1.0 - abs(sin(p.x)), 1.0 - abs(sin(p.x+p.y)), 1.0 - abs(sin(p.y)))\n        \t\t\t* MAIN_COLOR;\n\tfragColor=vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws33Dl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws33DN", "name": "Minecrafted Oldschool", "author": "dabadab", "description": "The shader for my 1k intro for the Function 2019 party - requires GLSL ES 3.0\n\nA tribute to the old duck.3ds mesh that was overused in the '90s PC demoscene.\nhttps://www.pouet.net/prod.php?which=82886", "tags": ["1k", "function2019"], "likes": 7, "viewed": 383, "date": "1568753451", "time_retrieved": "2024-06-20T19:44:58.222281", "image_code": "// the code is written to be small after compressed with shader minifier and Crinkler\n\n// the letters ENP\n\n// 111011001100\n// 100010101010\n// 110010101110\n// 100010101000\n// 111010101000\nint Z[5]=int[5](0xecc,0x8aa,0xcae,0x8a8,0xea8);\n \nvoid mainImage( out vec4 O, vec2 fragCoord )\n{\n    O=vec4(0,0,.6,0);\n    \n    float t = cos(iTime/6.)/2.+.5,md=1. // time is translated into the [0..1] interval, slowing down at the ends\n        ,k0,k1;\n    int X,Y;\n    \n    // screen coordinate translation\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3\n        // the Bezier curve along which the camera moves\n        p = mix(\n              mix(\n                mix(vec3(22,  4, 40),vec3(20, -3, 10),t),\n                mix(vec3(20, -3, 10),vec3(20, 34,  5),t),\n                t),\n              mix( \n                mix(vec3(20, -3, 10),vec3(20, 34,  5),t),\n                mix(vec3(20, 34,  5),vec3(12,  3,  0),t),\n                t),\n              t),\n        \n        // camera looks at (0,0,0)\n    \tww = normalize(- p),\n    \tuu = normalize(vec3(ww.z,0,-ww.x)), // actually it's cross(vec3(0,1,0),ww) but spelling it out is a few bytes shorter\n    \tvv = normalize(cross(ww,uu)),\n    \tdir = normalize( uv.x*uu + uv.y*vv + 2.5*ww ),\n        \n        t2;\n    \n    // tracing the ray through voxels\n    for (int i=0 ; i < 99; i++)\n\t{   \n        // calculate distance to voxel boundary\n        t2 = max((-fract(p))/dir, (1.-fract(p))/dir);\n        // go to next voxel\n        p += dir * (min(min(t2.x, t2.y), t2.z)+.01);\n        // get voxel's center\n        vec3 pi=ceil(p)-.5;\n        \n        // reflection\n        if (p.y<-2.) {\n            dir.y=-dir.y;\n            dir.z+=sin(p.x+iTime)/16.; // the rather simplistic waving\n            md=.5; // reflected voxels are darker\n        }\n        \n        // the duck's body and head - ellipsoid distance function taken from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n        if (min( (k0=length(pi/vec3(6,5,9)),k1=length(pi/vec3(6,5,9)/vec3(6,5,9)),k0*(k0-1.0)/k1), length(pi-vec3(0,6,4))-4.) < 0.)\n            O = pi.zy == vec2(5.5,7.5) ? vec4(.2) : vec4(.9,.9,0,0); // this is where the eyes are painted\n        \n        // the letters\n        // this is horribly verbose and inefficient - a last minute addition at 3 AM\n        if (pi.z==25.5)\n        \tfor(Y=0;Y<5;Y++)\n\t            for(X=0;X<16;X++)                    \n\t                if( ((Z[Y]>>X)&1)==1 &&pi==vec3(-2.5+float(X),2.5-float(Y),25.5))\n    \t                O=vec4(1.3);\n\n        // the duck's beak\n        if ( (pi -=vec3(0,5.7,7),k0=length(pi/vec3(2,1,4)),k1=length(pi/vec3(2,1,4)/vec3(2,1,4)),k0*(k0-1.0)/k1) <0.)\n            O=vec4(.8,.4,0,0);\n\n        // check if we set a new color (that is, hit a non-empty voxel)\n        if(O.x!=0.) {\n\t        // add the reflection modifier and a simple texture to the color and return that\n            O*=md*(1.4-length(mod(p,1.)-.5));\n            return;\n        }\n\t}\n    \n    // all tested voxels were empty, return a sea / sky color\n    O=mix(vec4(.8),O,abs(dir.y));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws33DN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws33R7", "name": "Naive Area Light", "author": "crundle", "description": "A naive Implementation of using a SDF as a light source - works fine with simple lights, not so fine with complex setups...\n", "tags": ["raymarching", "arealight"], "likes": 10, "viewed": 247, "date": "1568061103", "time_retrieved": "2024-06-20T19:44:59.095100", "image_code": "\n\n//#define MULTILIGHT //second light\n#define USESHADOW //shadows only work for simple shapes and get very glitchy with multiple lights\n//#define MULTICOLOR //uncomment this to see the artifacts that happen when multicolored lights interact\n\nvec2 e = vec2(0.0035f,-0.0035f); \nfloat tt,lr=3.0; //lr is light radius\nvec3 ld,fo,glow; //light direction vector, background color, accumulated glow\n\nmat2 r2(float a) { \n\treturn mat2(sin(a + 1.57), sin(a), sin(a + 1.57 * 2.), sin(a + 1.57));\n}\n\nfloat smin(float d1, float d2) { //smooth minimum\n  float h=clamp(.5+.5*(d2-d1)/0.2,0.0,1.0);\n  return mix(d2,d1,h)-0.2*h*(1.-h);\n}\n\nfloat bo(vec3 pos, vec3 b)\n{\n\tvec3 d = abs(pos) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat noi(vec3 p) { //triplanar sampling for some reflection detail\n    float ns = texture(iChannel0,p.xy*.3).r*.3;\n    ns+=texture(iChannel0,p.xz*.3).r*.3;\n    ns+=texture(iChannel0,p.yz*.3).r*.3;\n    return ns;\n}\n\nvec3 getAlbedo(float mi) { // seperated this for convenience\n  if(mi<.4)return vec3(1.,.4,.0);\n  if(mi>.6)return vec3(0,0,1);\n  return vec3(1);\n}\n\nvec4 mp(vec3 p) {//we need extra data for lights, but a vec4 is enough\n\tvec2 l,h,g,t=vec2(p.y,.5); //using evvvvils method for material id's\n\tt.x=min(t.x,bo(abs(p)-vec3(4,0,4),vec3(.5,12.,.5)));\n  t.x=min(t.x,-length(p)+12.);\n\th=vec2(length(p-vec3(0,2,0))-2.3,1.2); //lets add some reflective stuff, just to show we can\n\tt=t.x<h.x?t:h; //how we mix material id's\n\th=vec2(bo(abs(p+vec3(0,-2.6+sin(tt*.4),0))-vec3(0,0,2.9),vec3(4.6,.5,.5)),2.9); //and some transparent stuff, for the same reason\n\tt=t.x<h.x?t:h;\n  vec3 np = p+vec3(0,-6.5,cos(tt*.5)*4.);np.yz*=r2(tt*.3); np.xz*=r2(tt*.2); //make it spin\n\th=vec2(bo(np,vec3(2.5,.2,.2)),10.5); //light geometry, and our lights of course also have materials\n#ifdef MULTILIGHT\n  g=vec2(bo(p+vec3(sin(tt*.5)*3.,-5.,cos(tt*.5)*3.),vec3(.2,.2,4.)),10.1); //more light geometry, define MULTILIGHT to see ...\n#ifndef MULTICOLOR\n  h.x=smin(h.x,g.x); //...soft minimum for smooth transition or...\n#else\n  h=vec2(smin(h.x,g.x),h.x<g.x?h.y:g.y); // ... ugly artifacts when multicolored lights interact since we only guess one light direction\n#endif\n#endif\n  glow+=(0.1/(0.1+pow(abs(h.x),2.))*.5)*getAlbedo(fract(h.y)); //accumulate some glow on our lights for better looks\n  t.x*0.9;h.x*=.9;\n  t=t.x<h.x?t:h; // final mixdown\n  \n\treturn vec4(t,h); //return dist and mat at xy, lights only on zw\n}\n\n\n\nvec3 tr(vec3 p, vec3 r) { //do it all in the trace, lights, materials, shadows, everything\n  vec4 m = vec4(0.001);float t=0.,sig,tf,ff;\n  vec3 no,acc=fo, sr; //some helpers \n  for(int b=0;b<2;b++) { //stay bouncy\n    sig=1.;tf=.75*float(b); //sign (are we inside yet?) and a correction factor for reflections and transparency, because I don't want full transparency or perfect reflections \n    for(int i=0;i<120;i++) {\n      p=p+r*m.x; //baby steps\n      m =abs(mp(p)); //a vec4 because we also need distance to closest light and its material\n      t+=m.x; //total distance\n      if(t>30.) return mix(fo,acc,ff*tf); //we went too far, use the last calculated fog color and correction factor to make sure far reflective objects get fogged correctly\n      if(m.x<0.001f) { //we hit something\n        mat4 drs = mat4(mp(p+e.xyy),mp(p+e.yyx),mp(p+e.yxy),mp(p+e.xxx)); //grab everything we need for normals and area light direction, so we don't need to calculate everything twice\n        no=normalize(e.xyy*drs[0].x+e.yyx*drs[1].x+e.yxy*drs[2].x+e.xxx*drs[3].x); //normals as usual\n        ld=-normalize(e.xyy*drs[0].z+e.yyx*drs[1].z+e.yxy*drs[2].z+e.xxx*drs[3].z); //light direction \n        sr=ld;ld=normalize(no*.05+ld); //store for shadows, then bias by normal to fake away edge cases and pretend our lights have volume\n        float dif=(1.-exp2(-2.*pow(max(0.,lr-m.z/lr),2.)))*max(.0,dot(no,ld)), //our diffuse light, similar to how we do...\n        aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(p+no*aor).x/aor),2.)), //... ambient occlusion!\n\t\tsp=pow(max(dot(reflect(-ld,no),-r),0.),4.), //specular\n        mi=fract(m.y),ri=trunc(fract(m.y*.1)*10.),si=trunc(m.y*.1); //encoded material properties, >10 means luminant, >1 means reflective, >2 means transparent, .1-.9 mark colors... so 11.2 is a reflective white light\n\t\tvec3 lc=getAlbedo(fract(m.w)); //encoded light material\n        vec3 nr,alb=getAlbedo(mi); //we have a helper for albedo, since we also use it for light color and glow\n        if(si>0.){dif=1.;sp=0.;} //luminant material\n        ff=exp(-.00012*t*t*t); //fog factor\n        acc=mix(fo,mix((sp*lc)*dif+alb*(.4*ao+0.6)*(lc*dif)+glow*.1,acc,tf),ri>=1.?ff+tf:ff); //mixdown, respect limits in reflection pass\n        if(ri<1.) {b=1;break;} //are we cool yet?\n        tf=.5; //increase opacity of transparent objects in the next bounce\n\t\tnr=ri<2.?refract(r,-no,1.-.8*noi(p)):refract(r,no*sig,.9-.8*noi(p)); //nope, not cool, so refract or reflect?\n        if(nr.x+nr.y+nr.z==0.){nr=reflect(r,no);ri+=1.;} //handle refraction edge cases\n        r=nr;p=p+r*.05; //our new ray\n        if(ri<2.) break; //reflect\n        sig=-sig; //refract\n      }\n    }\n    #ifdef USESHADOW //soft shadows\n\t//done in the bounce, so we have shadows in reflections and on reflective objects as well\n    vec3 so=p+sr*.01,sco=vec3(1); \n\tfloat st=0., sh = 1.; \n\tvec4 sd=vec4(.01,0,.01,0);\n    if(trunc(m.y*.1)<=0.) { //don't cast shadows on luminant objects\n\t\tfor(int i=0; i<80;i++) {\n\t\t  so=so+sr*sd.x; sd=abs(mp(so)); float ri = trunc(fract(sd.y*.1)*10.); \n\t\t  if(trunc(sd.y*.1)>0.) { break; } //we are close to a light, so bail\n      if(sd.x<.0001) {//we hit geometry and are most likely in total shadow...\n        if(ri>=2.)  { sd.x=0.01; } //... but maybe we hit something transparent\n        else {sh=0.0; break;} \n      } \n\t\t  sh=min(sh,sd.x/st*24.); st+=sd.x; //accumulate shadow\n      if(ri>=2.) { sh=max(sh,.4); sco=mix(getAlbedo(fract(sd.y)),vec3(1),sh); }//make transparency great again\n\t\t  if(st>lr*4.){  break; } //out of light radius, so bail\n\t\t}\n\t\tacc=acc*.5+acc*.5*sh*sco; //keep some ambient\n\t}\n    #endif\n  }\n  return acc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t//basic setup\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\ttt = mod(iTime,3000.0);\n\tvec3 ro=vec3(sin(tt*.25)*10.,4.,cos(tt*.25)*10.),\n\t\tcw=normalize(vec3(0.,1.5+sin(tt*.25)*1.5,0.)-ro),\n\t\tcu=normalize(cross(cw,vec3(0,1,0))),\n\t\tcv=normalize(cross(cu,cw)),\n\t\trd=mat3(cu,cv,cw)*normalize(vec3(uv,.5));\n\tfo=vec3(0.1,.2+uv.y*.2,.3+uv.y*.2); //background fog color\n\tvec3 co = tr(ro,rd); //the grand trace\n\tfragColor = vec4(co,1.f);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws33R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws33z4", "name": "My tunnel 1.0", "author": "dimonoid", "description": "tunnel", "tags": ["tunnel"], "likes": 3, "viewed": 104, "date": "1567905130", "time_retrieved": "2024-06-20T19:44:59.095100", "image_code": "float PI = 3.14159;\n\n/*void mainImage( out vec4 fragColor, in vec2 x )\n{\n    vec3 r;\n    x.x=x.x/iResolution.x*4.0;\n    \n    x.x=x.x;//-iTime;\n    r.r=sin(x.x*PI*1.0);\n    r.g=sin(x.x*PI*1.0+PI/3.0);\n    r.b=sin(x.x*PI+PI*2.0/3.0);\n    \n    //r=r*r;\n    r=abs(r);\n    r.r=pow(r.r,0.0001);\n    r.g=pow(r.g,0.0001);\n    r.b=pow(r.b,0.0001);\n    \n    r=r-min(min(r.r,r.g),r.b);\n    r=r/max(max(r.r,r.g),r.b);\n    \n    fragColor = vec4(r,1.0);\n}*/\n////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/300.0;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x-=0.20;\n    uv.x*=iResolution.x/iResolution.y;\n    //vec3 a;\n    float pi=3.14159;\n    float rad=sqrt(pow(uv.x-0.5,2.0)+pow(uv.y-0.5,2.0)); //radius\n    float o=atan((uv.y-0.5)/(uv.x-0.5));               //angle\n    \n    //o=o/(2.0*pi);\n    //if (uv.x<0.5)\n    //    o=(o+0.5);\n    //o=o-iTime;\n    //o=mod(o,1.0);\n    \n    //a=a*2.0/sqrt(2.0);\n    //if (a.r>=0.999)//test\n    //    a.r=0.0;\n    //a.g=o;\n    //a.b=1.0-a.r;\n    \n    //a=a+r;\n    \n    //rad=rad*2.0/sqrt(2.0); ///\n    rad*=0.3;\n    \n    vec3 r;//rainbow\n    \n    vec2 x;\n    x.x=atan(rad*pow(iTime*0.2+1.0,2.0)*5.0)-pow(iTime*0.2+1.0,2.0)*1.0;\n    //x.x=(a.r+a.g+a.b)/3.0;//hack\n    \n    //x.x=x.x/iResolution.x*4.0;\n    \n    //x.x=x.x;//-iTime;\n    r.r=sin(x.x*PI*1.0);\n    r.g=sin(x.x*PI*1.0+PI/3.0);\n    r.b=sin(x.x*PI+PI*2.0/3.0);\n    \n    //r=r*r;\n    //r=abs(r);\n    r=pow(abs(r),vec3(0.0001));\n    //r.g=pow(r.g,0.0001);\n    //r.b=pow(r.b,0.0001);\n    \n    r=r-min(min(r.r,r.g),r.b);\n    r=r/max(max(r.r,r.g),r.b);\n    \n    \n    \n    fragColor = vec4(r,1.0);\n    //fragColor = vec4(a,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws33z4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws33zf", "name": "fur test", "author": "jojobavg", "description": "test of fur with ray tracing, ray marching and hypertexture.", "tags": ["raytracing", "raymarching", "fur", "hypertexture"], "likes": 31, "viewed": 600, "date": "1569005263", "time_retrieved": "2024-06-20T19:45:00.095122", "image_code": "// Using code from\n\n// Inigo Quilez for the primitives\n// https://www.shadertoy.com/view/Xds3zN\n\n// NuSan for the noise function\n// https://www.shadertoy.com/view/3dXSDH\n\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n#define time iTime\n\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp=fract(p);\n\tp=smoothstep(0.0,1.0,p);\n\tvec3 st=vec3(7,37,289);\n\tvec4 pos=dot(ip,st) + vec4(0.0,st.y,st.z,st.y+st.z);\n\tvec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n\tvec2 val2=mix(val.xz,val.yw, p.y);\n\treturn mix(val2.x,val2.y, p.z);\n}\n\nvec3 noise3(vec3 p) \n{\n\tfloat x=noise(p);\n\tfloat y=noise(p+sin(noise(p)));\n\tfloat z=noise(p+cos(noise(p)));\n\treturn vec3(x,y,z);\n}\n\nfloat dot2(  vec3 v ) { return dot(v,v); }\n\nfloat fur(vec3 pIn,vec3 p1,vec3 tU,vec3 tV,float h,float l,float sF,float sD,float speed,vec3 norm )\n{\n\tvec3 fDir = normalize(noise3(p1*sD+time*speed))*2.0-1.0;\n\tfloat dot1= dot(norm,p1-pIn);\n\tvec3 Vnoise = ((pIn-p1)-(norm+fDir*2.0)*(1.0-dot1));\n\tvec3 noisV =(tU)*(dot((tU),Vnoise))+(tV)*(dot((tV),Vnoise));\n\tvec3 noisy =noisV*((cos(1.0-h)*0.2))*l;\n\tfloat noise=noise((pIn+noisy)*sF);\n\treturn noise-(1.0-h);\n}\n\nmat2 rot(float a) \n{\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere(in vec3 p, in vec3 centerPos, float radius) \n{\n\treturn length(p-centerPos) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t,vec3 centerPos )\n{\n\tvec2 q = vec2(length(p.xz+ centerPos.xz)-t.x,p.y+ centerPos.y);\n\treturn length(q)-t.y;\n}\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n\tvec3 ba = b - a; vec3 pa = p - a;\n\tvec3 cb = c - b; vec3 pb = p - b;\n\tvec3 dc = d - c; vec3 pc = p - c;\n\tvec3 ad = a - d; vec3 pd = p - d;\n\tvec3 nor = cross( ba, ad );\n\n\treturn sqrt(\n\t(sign(dot(cross(ba,nor),pa)) +\n\t sign(dot(cross(cb,nor),pb)) +\n\t sign(dot(cross(dc,nor),pc)) +\n\t sign(dot(cross(ad,nor),pd))<3.0)\n\t ?\n\t min( min( min(\n\t dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n\t dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n\t dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n\t dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n\t :\n\t dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p)\n{\n\tfloat s = sphere(p,vec3(0.0,0.0,25.0),20.0);\n\tfloat pl = udQuad(p,\n\t\t\t  vec3(10000.0, 20.0, 10000.0),\n\t\t\t  vec3(-10000.0, 20.0, 10000.0), \n\t\t\t  vec3(-10000.0, 20.0, -10000.0),\n\t\t\t  vec3(10000.0, 20.0, -10000.0));\n\tfloat c = sdTorus(p,vec2(20.0,10.0),vec3(0.0,-10.0,25.0));\n\tfloat res = s;\n\treturn min(min(res, pl),c);\n}\n  \nfloat map(vec3 p)\n{\n\treturn sphere(p,vec3(0.0,0.0,0.0),20.0);\n}\n  \nfloat mapFur(vec3 p,vec3 p1,vec3 tU,vec3 tV,float h,vec3 n)\n{\n\treturn fur(p,p1,tU,tV,h,10.0,3.0,0.05,1.0,n);\n}\n  \nfloat getao(vec3 p, vec3 n, float dist) \n{\n\treturn clamp(map3(p+n*dist)/dist, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 s=vec3(0.0,0.0,-100.0);\n\tfloat t2=(time*0.5+10.0);\n\ts.y = -abs(cos(t2*0.5)*100.0);\n\ts.xz *= rot(t2*0.5);\n\n\tvec3 t=vec3(0.0,0.0,0.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0.0,1.0,0.0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\n\tvec3 p=s;\n\tvec2 off=vec2(0.001,0.0);\n\tvec3 n;\n\tvec3 pIn;\n\tvec3 tU;\n\tvec3 tV;\n\tfloat h;\n\tvec3 up;\n\tfloat depth = 1.0;\n\tfor(int cpt=0;cpt<2;cpt++)\n\t{\n\t\tbool hit = false;\n\t\tfloat d=0.0;\n\t\tfloat dd=0.0;\n\t\tfor(int i=0; i<60; ++i) \n\t\t{\n\t\t\td=map3(p);\n\t\t\tif(d<0.0001 ){hit = true; break;}\n\t\t\tif(dd>400.0) {dd=400.0;hit = true; break;}\n\t\t\tp+=d*r*0.8;\n\t\t\tdd+=d;\n\t\t}\n\t\tdepth = (1.0-length(p-s)/300.0);\n\t\tbool hit2;\n\t\tif(depth>0.0)\n\t\t{\n\t\t\tn=normalize(map3(p)-vec3(map3(p-off.xyy), map3(p-off.yxy), map3(p-off.yyx)));\n\t\t\tup=normalize(vec3(0.001,0.952315,0.0001));\n\t\t\tvec3 right=normalize(vec3(0.001,0.001,0.952315));\n\t\t\ttU = normalize(cross(right,n));\n\t\t\ttV = normalize(cross(n,tU));\n\t\t\tvec3 dirT = normalize(r*(1.0-dot(r,tU))+r*(1.0-dot(r,tV)));\n\t\t\tfloat hmax =2.0;\n\t\t\tfloat distmax = 5.0;\n\t\t\tvec3 maxDirI = r*distmax;\n\t\t\tfloat step = 100.0;\n\t\t\tvec3 dirI = maxDirI/step;\n\t\t\th=1.0;\n\t\t\tfloat dotI = 1.0-max(dot(dirI,dirT),0.0);\n\t\t\tpIn=p;\n\t\t\tfloat d2=0.0;\n\t\t\thit2 = false;\n\t\t\t\n\t\t\tfor(int i=0; i<100; ++i) \n\t\t\t{\n\t\t\t\th = (clamp(dot(normalize(dirI),-n),0.2,1.0)*length(dirI)*float(i))/hmax;\n\t\t\t\td2=mapFur(p+dirI*float(i),p,tU,tV,h,normalize(n));  \n\t\t\t\tpIn=p+dirI*float(i);\n\t\t\t\tif(d2>0.001){hit2=true; break;}\n\t\t\t}\n\t\t}\n\t\tif(hit)\n\t\t\tif(hit2)\n\t\t\t\tbreak;\n\n\t\t\t\n\t}\n\t\n\tvec3 l=normalize(vec3(-1,-2,-3));\n\tvec3 color1 = vec3(0.7,0.7,0.9);\n\tvec3 color2 = vec3(0.6,0.6,1.0);\n\tfloat dotr=(dot(r,l));\n\tvec3 sky = mix(color1,color2,min(dotr,1.0));\n\toff=vec2(0.0001,0.0);\n\tvec3 nStrand=normalize(mapFur(pIn,p,tU,tV,h,n)-vec3(mapFur(pIn-off.xyy,p,tU,tV,h,n), mapFur(pIn-off.yxy,p,tU,tV,h,n), mapFur(pIn-off.yyx,p,tU,tV,h,n)));\n\tvec3 col=vec3(0.0);\n\tvec3 ambient = sky*(1.0-max(dot(n,up),0.0)*0.8+0.2);\n\tfloat ao = (getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.1 + 0.9);\n\tcol = ((dot(normalize(nStrand+n),l)*0.5+0.5)*0.1+ambient*0.9)*ao;\n\tcol = mix(sky,clamp(col,0.0,1.0)*clamp(1.0-h,0.2,1.0),clamp(ceil(depth),0.0,1.0));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws33zf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GDS", "name": "Some Raymarching Practice", "author": "MeDope", "description": " ", "tags": ["raymarchingsdfblue"], "likes": 8, "viewed": 98, "date": "1569166920", "time_retrieved": "2024-06-20T19:45:00.095122", "image_code": "#define SURF_DIST .001\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\nmat2x2 rot(float a) { return mat2x2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(27.754, 78.4476))) * 47125.3567);\n}\n\nfloat sdf(vec3 p)\n{\n    p -= 0.5;\n    p.xy += sin(p.xz*0.8 + iTime)*0.5+0.5;\n    p.zy += sin(p.zx*0.3 + iTime)*0.5+0.5;\n    vec3 fp = floor(p);\n    p = vec3(\n        fract(p.x) - 0.5,\n        p.y,\n        fract(p.z) - 0.5);\n    p.xz *= 0.5;\n    float l = length(p.xyz) - 0.25 * (sin(iTime + 50.*hash(fp.zx))*0.5+0.5);\n    return max(-l, p.y);\n}\n\nfloat march(vec3 ro, vec3 rd) \n{\n    float dS, dO;\n    vec3 p;\n    for(int i=0; i < MAX_STEPS; i++)\n    {\n    \tp = ro + dO * rd;\n        dS = sdf(p);\n        dO += dS;\n        if(dS < SURF_DIST || dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = sdf(p);\n\tvec2 e = vec2(0.005, 0.0);\n\tvec3 n = d - vec3(sdf(p - e.xyy), sdf(p - e.yxy), sdf(p - e.yyx));\n\treturn normalize(n);\n}\n\nfloat light(vec3 p, vec3 ro)\n{\n    vec3 lp = ro + vec3(0.0, 0.0, 2.5);\n    vec3 l = normalize(lp - p);\n    vec3 n = normal(p);\n    return dot(n, l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    rd.zy *= rot(0.4);\n    rd.zx *= rot(0.5);\n    vec3 ro = vec3(0.0, 5.5, iTime);\n    vec3 col;\n\tfloat m = march(ro, rd);\n    float im = 1.0 / m;\n    vec3 p = ro + rd * m;\n    col += light(p, ro);\n    col = mix(vec3(0.01, 0.05, 0.85), col * col * 2.0, im) * im * im * 100.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GRs", "name": "Asymmetric Blocks", "author": "Shane", "description": "Here's a cheap trick that I came up with to give the impression of random asymmetric rectangular tiling.", "tags": ["grid", "wall", "rectangle", "tiling", "block", "paving", "asymmetric"], "likes": 42, "viewed": 932, "date": "1569077427", "time_retrieved": "2024-06-20T19:45:02.601138", "image_code": "/*\n\n\tAsymmetric Blocks\n\t-----------------\n\n    Here's a cheap trick that I came up with to give the impression of random\n    asymmetric rectangular tiling. The final implementation was a bit fiddly to \n    code, but I thought it fell into place nicely. However, it took me ages to \n\tdream up something that'd work. Producing random packed rectangles in realtime, \n\teven in pseudo form, isn't something you see much of, or at all, which surprises \n\tme, since it's a common thing to see in the world of architecture, and so forth.\n\n\tThere's a really cool way to use five edge Wang tiles, but it requires various \n\ttileset restrictions, which I don't think would be easy to replicate on Shadertoy... \n\tor so I'd imagine. There's some pretty smart people on here, so you never know. :)\n    Either way, in the meantime, here's a less sophisticated method that seems to \n\twork well enough. Well, it fools my eyes anyway. :)\n\n\tAs usual, I've dressed the pattern up a little, but the method itself is quite\n\tsmall and simple, so for anyone interested, the workings can be found in the\n    \"pattern\" function.\n\n\tBy the way, I wrote the algorithm in such a way that each brick returns a local\n\tposition and position-based ID which means it can be used to render picture\n\tmosaics, and more importantly, can be adapted for raymarching purposes. In fact, \n\tI have an example ready to go, which I'll put up when I've tidied it up a little.\n    \n\n    Similar Examples:\n\n    To my knowledge, there aren't any, but here's an unlisted box divide version. \n    Unlike all other versions, it maintains aspect correctness and returns tile IDs \n    based on position.\n\t\n    Box Divide ID - Shane.\n\thttps://www.shadertoy.com/view/WlsSRs\n\n*/\n\n// Simple overlays.\n//#define NAIVE_HATCH // I made this up a while back, and find it useful.\n//#define PAPER_GRAIN\n\n// Uncomment this to give it a cleaner look.\n//#define UNTEXTURED\n\n// Shadows almost always look better, but there are times when they might\n// overcook things a little. I think they enhance this example, but it's\n// all a matter of personal requirements. Turning them off gives it a \n// fresher, more naive, rendering style, which can sometimes be preferable.\n#define SHADOWS\n\n// Highlights -- Usually performed by taking a nearby sample, then adding a\n// variation on the difference.\n#define HIGHLIGHTS\n\n// Palettes: Not many, but I might add more.\n//#define GRAYSCALE\n\n// Wobbling the coordinates, just a touch, in order to give the blocks a subtle \n// hand cut appearance. Turning this off will result in cleaner straight lines.\n#define PERTURB_COORDINATES\n    \n// Display the square cell grid boundaries. It's there for debug purposes,\n// but has a certain aesthetic appeal.\n//#define SHOW_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n// IQ's box function with a smoothing factor added.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n    vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n/*\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n*/\n\n\n// Dave Hoskins's vec2 to float hash -- Modified for this particular example.\n// You can find the details here:\n//\n// Hash without Sine - Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21B(vec2 p){ \n    \n    //  2 in, 1 out. \n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return (fract((p3.x + p3.y) * p3.z) - .5)*.75;\n\n\n    /*\n    //p = mod(p, 8.); // If you wanted to create a wrapped version.\n    \n    // Here's an annoying, but necessary hack for less accurate systems.\n    // If you have what I'd consider a normal system, the following line\n    // wouldn't be necessary. :)\n    //\n    // Anyway, if anyone knows of a cheaper algorithmic way around this,\n    // feel free to let me know. Reading from a texture would work, but \n    // I'd like a cheap algorithmic solution.\n    p = floor(p*1048576.)/1048576.;\n    return (fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453) - .5)*.75;\n    */\n}\n\n// The asymmetric block pattern.\n//\n// By the way, you could take a simple line-drawing and partitioning approach to greatly\n// minimize the instruction count, and if 2D bump mapping effects, etc, are all you're\n// after, it might be worth doing. However, if you wish to raymarch this, or do other\n// interesting things, the four rectangles, and corresponding IDs, are a necessary evil.\nvec3 pattern(vec2 p, float sc){\n\n    vec2 ip = floor(p*sc) + .5; // Grid ID.\n    p -= ip/sc; // Local coordinates.\n    \n    vec3 e = vec3(-1, 0, 1); // Helper vector.\n    \n    float h11 = hash21B(ip); // Original cell.\n    \n    float h10 = hash21B(ip + e.xy); // Left.\n    float h01 = hash21B(ip + e.yz); // Top.\n    float h12 = hash21B(ip + e.zy); // Right.\n    float h21 = hash21B(ip + e.yx); // Bottom.\n    \n    float h00 = hash21B(ip + e.xz); // Top left.\n    float h02 = hash21B(ip + e.zz); // Top right.\n    float h22 = hash21B(ip + e.zx); // Bottom right.\n    float h20 = hash21B(ip + e.xx); // Bottom left.\n      \n     \n    vec2[4] ctr;\n    vec2[4] l;\n    \n    \n    // The code looks fiddly, but it's based on a simple idea.\n    // A while ago, I noticed that if you ran vertical and \n    // horizontal lines on alternate checkered tiles, you could\n    // render perpendicular lines on either side at random\n    // positions and everything would line up to form rectangles.\n    // The following is just an implementation of that.\n    \n    // If you uncomment the SHOW_GRID define you'll see that \n    // each cell consists of either a vertical line flanked on\n    // either side by horizontal lines at random Y-positions, or \n    // a horizontal line flanked on either side by vertical\n    // lines at random X-positions.\n    \n    // Implementing the aforementioned is simple enough. However, \n    // lines are great, but cell boundaries -- in order to\n    // render things like blocks would be the thing we'd be more \n    // interested in rendering, so that requires a little more\n    // work.   \t\n    \n    \n    \n    if(mod((ip.x + ip.y), 2.)<.5){ // Horizontal cell.\n\n        // Partition the cell with a randomly positioned horizontal \n        // line and two joining randomly positioned vertical lines\n        // then determine the cell dimensions and cell center of\n        // all four resultant rectangular blocks.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(h01 - h10, h00 - h11) + 1.;\n        l[1] = vec2(-h01 + h12, h02 - h11) + 1.;\n        l[2] = vec2(-h21 + h12, -h22 + h11) + 1.;\n        l[3] = vec2(h21 - h10, -h20 + h11) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h01, h11) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h01, h11) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h21, h11) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h21, h11) + l[3]*vec2(-.5, -.5); \n\n    }\n    else { // Vertical cell.\n\n        // Partition the cell with a randomly positioned vertical \n        // line and two joining randomly positioned horizontal lines\n        // then determine the cell dimensions and cell center.\n        \n        // Four block dimensions (X: Width, Y: Height).\n        l[0] = vec2(-h00 + h11, h01 - h10) + 1.;\n        l[1] = vec2(h02 - h11, h01 - h12) + 1.;\n        l[2] = vec2(h22 - h11, -h21 + h12) + 1.;\n        l[3] = vec2(-h20 + h11, -h21 + h10) + 1.;\n        \n        // Four block centers.\n        ctr[0] = vec2(h11, h10) + l[0]*vec2(-.5, .5);\n        ctr[1] = vec2(h11, h12) + l[1]*vec2(.5, .5);\n        ctr[2] = vec2(h11, h12) + l[2]*vec2(.5, -.5);\n        ctr[3] = vec2(h11, h10) + l[3]*vec2(-.5, -.5); \n        \n\n    }\n                                                                             \n\n    // Debugging: Show the squares with a set single dimension.\n    //l[0] = l[1] = l[2] = l[3] = vec2(.7); // Overlapping: vec2(1.5); \n    \n    // Scaling down the block dimensions.\n    l[0] /= sc; l[1] /= sc; l[2] /= sc; l[3] /= sc;\n    \n    \n    \n    // Determine the minimum block using the standard method.\n    float d = 1e5;\n    vec2 tileID = vec2(0);\n    //vec2 ctri = vec2(0);\n    //vec2 li = vec2(0);\n     \n    for(int i = 0; i<4; i++){\n    \t \n    \tfloat bx = sBoxS(p - ctr[i]/sc, l[i]/2. - .05/sc, .1/sc);\n        \n        if(bx<d) {\n            d = bx;\n            tileID = ip + ctr[i];\n            //ctri = ctr[i];\n            //li = l[i];\n        }\n        \n    }\n    \n    \n    // Return the distance value of the closed rectangular block\n    // and it's cell center, which doubles as a unique ID. By the\n    // way, you could also return the the tile center and dimensions,\n    // if you wished to render other things.\n    return vec3(d, tileID);\n\n}\n\n\n\n// The square grid.\nfloat gridField(vec2 p){\n    \n    p = abs(fract(p) - .5);\n    float grid = abs(max(p.x, p.y) - .5) - .008;\n    \n    return grid;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    \n    // You could rotate also, if you felt like it: rot2(a)*uv...\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera to the north east (top right) direction. \n    vec2 p = uv - vec2(-1, -.25)*iTime/12.;\n    \n    // Keeping a copy of the background vector.\n    vec2 oP = p;\n\n    // The smoothing factor -- based on scale.\n    float sf = 1.5/iResolution.y;\n  \n    #ifdef PERTURB_COORDINATES\n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\n    p += vec2(n2D3G(p*8.5), n2D3G(p*8.5 + 7.3))*.008;\n    #endif\n    \n    // The grid block scaling -- as opposed to the global scaling, which is set to \n    // one for this example.\n    const float sc = 12.;\n    \n    \n    \n    // Take two pattern samples.\n    vec3 d = pattern(p, sc);\n    vec2 e = vec2(.005*8./sc, -.007*8./sc);\n    vec3 d2 = pattern(p - e, sc);\n    \n \n    // Highlighting the objects.\n    float ba = mix(min(-d.x*4., .1), smoothstep(0., sf*2., -d.x), .1);\n    float bb = mix(min(-d2.x*4., .1), smoothstep(0., sf*2., -d2.x), .1);\n    float b = max(-bb - -ba, 0.)/length(e);\n\n\n    // Coloring each individual tile using the ID. It's scaled down by the scaling\n    // factor to bring the texture into view.\n    vec3 tx = texture(iChannel0, d.yz/sc).xyz; tx *= tx;\n    tx = smoothstep(-.1, .7, tx);\n    \n    // Mixing in a regular non-mosaic texture in with it.\n    vec3 tx2 = texture(iChannel1, oP).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.1, .6, tx2);\n    tx2 = mix(tx2, vec3(1)*dot(tx2, vec3(.299, .587, .114)), .25);\n    \n    \n    // Just a dark background. You only see this between the tiles. If I were \n    // putting in effort, I'd probably have to arrange for some mortar to put \n    // between the blocks.\n    vec3 col = vec3(.725, .7, .675)*tx2*tx2/3.;\n    \n    #ifdef UNTEXTURED\n    col = vec3(.1);\n    #endif\n\n    \n    // Apply the line shadows and the fist layer object shadows.\n    #ifdef SHADOWS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d2.x - .003))*.9);\n    #endif\n    \n    \n    \n    #ifdef UNTEXTURED\n    // Using the ID for a shade.\n    vec2 rnd = hash22(d.yz);\n    vec3 lCol = vec3(1, .5 + rnd.y*.5, rnd.x*.4 + .4)*.75 + .15;\n    // Fabrice's candy colored palette.\n    //vec3 lCol = .6 + .3*cos(6.3*rnd.x + vec3(0, 23, 21));\n    #else\n    // Setting the block color to the texture at the specific ID position.\n    vec3 lCol = (tx2*2.)*tx*1.; \n    #endif\n    \n    \n    \n    \n    #ifdef HIGHLIGHTS\n    lCol *= (1. + b*.125);\n    #endif\n\n\n    // The Pattern.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., d.x - .002))*.9);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x - .002)));\n    col = mix(col, lCol, (1. - smoothstep(0., sf, d.x + .002)));  \n\n    \n    #ifdef SHOW_GRID\n    // The grid.\n    float grid = gridField(p*sc);\n  \n    vec3 svC = col;\n    // Display the grid boundaries. Usually used for debug purposes.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.5*sc, grid - .05))*.9);\n    col = mix(col, mix(svC.zyx*1.5, vec3(1, 1, 4), .5), (1. - smoothstep(0., sf*sc, grid)));\n    #endif\n    \n    \n    // POST PROCESSING\n    #ifdef GRAYSCALE\n    col = vec3(1)*dot(col, vec3(.289, .597, .114));\n    #endif\n\n    \n    #ifdef NAIVE_HATCH\n    float hatch = doHatch(oP, iRes);\n    col *= hatch*.5 + .7;\n    #endif\n    \n    #ifdef PAPER_GRAIN\n    // Cheap paper grain.\n    oP = floor(oP*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    #endif\n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= min(pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.1, 1.);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GW4", "name": "Fractal Mandelbrot ", "author": "aaraomelo", "description": "Mandelbrot fractal", "tags": ["fractal", "mandelbrot", "complexnumbers"], "likes": 1, "viewed": 116, "date": "1568467363", "time_retrieved": "2024-06-20T19:45:02.602136", "image_code": "/*\n    The Mandelbrot set is defined as the set of points c in the complex plane to which the \n    recursively defined sequence:\n        z_0 = 0\n        z_{n+1} = z_n*z_n + c\n    it does not tend to infinity.\n*/\n\nvec2 multiply(vec2 x,vec2 y){\n    return vec2(x.x*y.x-x.y*y.y,x.x*y.y+x.y*y.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.*(fragCoord/iResolution.x-vec2(.5,.27));\n    vec2 col;\n    \n    vec2 z0 = vec2(0.2*cos(iTime),0.2*sin(iTime));\n    for(int i = 0; i < 1000;i++){\n        vec2 z = multiply(z0,z0)+uv;\n        float mq = dot(z,z);\n        if( mq > 1000.0){\n            col = vec2(float(i)/30.0,0.0);\n            break;\n        } else {\n            z0 = z;\n        }\n        col =  vec2(mq/2.0,mq/2.0);\n    }\n    fragColor = vec4(col,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GW7", "name": "Dark Heart", "author": "dr2", "description": "Mysterious heavenly object ", "tags": ["reflection", "stars", "surface"], "likes": 1, "viewed": 269, "date": "1568639556", "time_retrieved": "2024-06-20T19:45:03.652981", "image_code": "// \"Dark Heart\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"Reflecting Heart\" (mouse stops motion)\n\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 sunDir;\nfloat tCur, dstFar, a, b;\nconst float pi = 3.14159;\n\nfloat SurfDf (vec3 p)\n{\n// f(x,y,z) = (x^2 + ((1 + b) * y)^2 + z^2 - 1)^3 - x^2 * z^3 - a * y^2 * z^3\n  float v1, v2;\n  v1 = (1. + b) * p.y;\n  v2 = p.x * p.x + v1 * v1 + p.z * p.z - 1.;\n  return v2 * v2 * v2 - (p.x * p.x + a * p.y * p.y) * p.z * p.z * p.z;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  float v1, v2;\n  v1 = (1. + b) * p.y;\n  v2 = p.x * p.x + v1 * v1 + p.z * p.z - 1.;\n  return normalize (vec3 (6. * p.x * v2 * v2 - 2. * p.x * p.z * p.z * p.z,\n     6. * (1. + b) * v1 * v2 * v2 - 2. * a * p.y * p.z * p.z * p.z,\n     6. * p.z * v2 * v2 - 3. * (p.x * p.x + a * p.y * p.y) * p.z * p.z));\n}\n\nvec2 BallHit (vec3 ro, vec3 rd, float s)\n{\n  float dbIn, dbOut, b, d;\n  b = dot (rd, ro);\n  d = b * b + s * s - dot (ro, ro);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec2 bnd;\n  float dHit, h, s, ds, sLo, sHi;\n  const float nDiv = 200.;\n  dHit = dstFar;\n  bnd = BallHit (ro, rd, 2.);\n  if (bnd.x < dstFar) {\n    s = bnd.x;\n    sLo = bnd.x;\n    ds = (bnd.y - bnd.x) / nDiv;\n    for (float j = 0.; j < nDiv; j ++) {\n      h = SurfDf (ro + s * rd);\n      if (h < 0. || s > bnd.y) break;\n      sLo = s;\n      s += ds;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (float j = 0.; j < 16.; j ++) {\n        s = 0.5 * (sLo + sHi);\n        if (SurfDf (ro + s * rd) > 0.) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 StarPat (vec3 rd)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 1031.13 * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 1071.13 * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, rdo, vn;\n  float dstObj, sd, sFac;\n  a = 0.5;\n  b = 0.5;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = SurfNf (ro);\n    rdo = rd;\n    rd = reflect (rd, vn);\n    sFac = 2.;\n  } else {\n    sFac = 1.;\n  }\n  sd = pow (max (dot (rd, sunDir), 0.), 32.);\n  sd = (0.1 * sd + 0.4 * pow (sd, 16.));\n  col = mix (sFac * StarPat (rd), vec3 (1., 0.7, 0.) * sd, min (1., 2. * sd));\n  if (dstObj < dstFar) {\n    col += vec3 (0.07) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) + vec3 (0.05, 0.03, 0.03) +\n       vec3 (0.05, 0., 0.) * (0.6 + 0.4 * sin (pi * tCur)) * max (dot (- vn, rdo), 0.);\n  } else col += vec3 (0.03, 0.03, 0.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = pi;\n  el = 0.6 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n    el += 0.1 * pi * sin (0.021 * pi * tCur);\n  }\n  ro = vec3 (0., 0.05, -4.);\n  ro.yz = Rot2D (ro.yz, el);\n  ro.xy = Rot2D (ro.xy, az);\n  dstFar = 20.;\n  sunDir = normalize (vec3 (1., 1., -0.2));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 2.));\n    rd.yz = Rot2D (rd.yz, el);\n    rd.xy = Rot2D (rd.xy, az);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3GWj", "name": "rainbow expanding circle", "author": "RisingThumb", "description": "This is my first ShaderToy shader. It's a rainbow expanding and shrinking Rainbow circle.", "tags": ["rainbowcircle"], "likes": 1, "viewed": 59, "date": "1569295496", "time_retrieved": "2024-06-20T19:45:03.822625", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv-= 0.5;\n    \n    uv.x*=(iResolution.x/iResolution.y)+0.2*sin(iTime); // Make it adjust in xscale over time.\n    \n    float d = length(uv); // get length from center(0.5,0.5)\n    vec3 c = vec3(0.0);\n    float r = 0.5+0.1*sin(iTime); // radius of circle\n    \n    c=vec3(smoothstep(r, r-0.005, d))*vec3(0.5+0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n\n    // Time varying pixel color\n    vec3 col = vec3(c);\n\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3GWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GWr", "name": "Half Plane Circle Packing", "author": "skye_adaire", "description": "A circle packing in the Poincare Half Plane model. See my other shaders for more background.", "tags": ["circle", "plane", "packing", "hyperbolic", "poincare", "half"], "likes": 12, "viewed": 154, "date": "1568154233", "time_retrieved": "2024-06-20T19:45:06.240982", "image_code": "//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n//end Hypercomplex\n\n//column-major and complex-valued \n#define ComplexVector2 mat2x2\n#define ComplexMatrix2 mat4x2\n\nComplexMatrix2 identityMob = ComplexMatrix2(1,0, 0,0, 0,0, 1,0); \n\n//inverse of mobius transform with det 1\nComplexMatrix2 M_inverse(ComplexMatrix2 m)\n{\n    return ComplexMatrix2(m[3], -m[1], -m[2], m[0]); \n}\n\nComplexMatrix2 M_multiply(ComplexMatrix2 lhs, ComplexMatrix2 rhs)\n{\n    return ComplexMatrix2(\n        H_multiply(lhs[0], rhs[0]) + H_multiply(lhs[2], rhs[1]),\n        H_multiply(lhs[1], rhs[0]) + H_multiply(lhs[3], rhs[1]),\n        H_multiply(lhs[0], rhs[2]) + H_multiply(lhs[2], rhs[3]),\n        H_multiply(lhs[1], rhs[2]) + H_multiply(lhs[3], rhs[3]));\n}\n\n//complex-valued homogeneous transform\nComplex M_multiply(ComplexMatrix2 m, Complex z)\n{\t\n    return H_divide(H_multiply(m[0], z) + m[2], H_multiply(m[1], z) + m[3]);\n}\n\n//returns the mob mapping z0 -> 0, z1 -> 1, z2 -> inf\nComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)\n{\n    return ComplexMatrix2(\n        z0 - z2,\n        z0 - z1,\n        H_multiply(-z1, z0 - z2),\n        H_multiply(-z2, z0 - z1));\n}\n \n//uses the cross ratio to construct the mob taking the ordered triple a,b,c -> p,q,r\nComplexMatrix2 M_mapTripleToTriple(\n    Complex a, Complex b, Complex c, \n\tComplex p, Complex q, Complex r)\n{\n\treturn M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));\n}\n\n//mob taking  [-1, 0, 1] to [L, c, R]\nComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)\n{\n    return M_mapTripleToTriple(\n        Complex(-1, 0), Complex(0, 0), Complex(1, 0),\n        L, c, R);\n}\n\n//the euclidean rotation of the plane is an isometry of the disk\nComplexMatrix2 M_rotation(Real a)\n{\n    return ComplexMatrix2(H_versor(0.5 * a), Complex(0, 0), Complex(0, 0), H_versor(-0.5 * a));\n}\n\nComplexMatrix2 M_translateReals(Real t)\n{\n    Real ex = exp(t);\n    Complex exp1 = Complex(ex + 1.0, 0);\n    Complex exm1 = Complex(ex - 1.0, 0);\n    \n    return ComplexMatrix2(exp1, exm1, exm1, exp1);\n}\n\nComplexMatrix2 M_translateDisk(vec2 v)\n{\n    PolarComplex p = H_toPolar(v);\n    ComplexMatrix2 r = M_rotation(p.argument);\n    return M_multiply(r, M_multiply(M_translateReals(p.norm), M_inverse(r)));\n}\n\nstruct Circle\n{\n \tComplex center;\n    Real radius;\n};\n\nCircle M_getCircleBetweenDiskPoints(Complex p, Complex q)\n{\n    Real dp = H_sqnorm(p) + 1.0;\n    Real dq = H_sqnorm(q) + 1.0;\n    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);\n    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;\n\n    return Circle(center, sqrt(H_sqnorm(center) - 1.0));\n}\n\n//return the first positive solution along the ray\nbool solveQuadraticIntersection(float a, float b, float c, out float t)\n{\n    if(abs(a) < eps32)\n    {\n        t = -c / b;\n        return t > 0.0;\n    }\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\n    if(abs(discriminant) < eps32)\n    {\n        t = - b / (2.0 * a);\n        return true;\n    }\n    else if(discriminant < 0.0)\n    {\n        return false;\n    }\n    else\n\t{\n        float sqrtd = sqrt(discriminant);\n\n        float t0 = (-b + sqrtd) / (2.0 * a);\n        float t1 = (-b - sqrtd) / (2.0 * a);\n\n        if(t1 < t0)\n        {\n            float tt = t0;\n            t0 = t1;\n            t1 = tt;\n        }\n\n        if(t0 > 0.0)\n        {\n            t = t0;\n            return true;\n        }\n\n        if(t1 > 0.0)\n        {\n            t = t1;\n            return true;\n        }\n\n        return false;\n\t}\n}\n\nbool intersectHypersphere(\n    vec2 rayPosition,\n    vec2 rayDirection,\n    vec2 center,\n    float radius,\n    out float t)\n{\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));\n    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);\n\n    return solveQuadraticIntersection(a, b, c, t);\n}\n\nComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)\n{\n \tCircle c = M_getCircleBetweenDiskPoints(i0, i1);\n    vec2 d = normalize(c.center);\n    \n    float t;\n    intersectHypersphere(vec2(0), d, c.center, c.radius, t);\n    \n    return M_mapRealsToLine(i0, t * d, i1);\n}\n\nComplex M_fromPlaneToDisk(Complex z)\n{\n   return Complex(2.0 * z.x, H_sqnorm(z) - 1.0) / (H_sq(z.x) + (1.0 + z.y) * (1.0 + z.y));\n}\n\n//a tile is constructed from half planes\n//the union of these half planes is the fundamental domain\n//we reflect the point about half planes until it is in the domain\nvec2 getPoincareTiling(\n    ComplexMatrix2 transformFromA, ComplexMatrix2 transformToA, \n    ComplexMatrix2 transformFromB, ComplexMatrix2 transformToB, \n    ComplexMatrix2 transformFromC, ComplexMatrix2 transformToC, \n    vec2 z, out vec3 d, out int i)\n{\n   for(i = 0; i < 60; i++)\n   {\n      vec2 t;\n       \n      t = M_multiply(transformToA, z);\n\n      d[0] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromA, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToB, z);\n\n      d[1] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromB, t);\n         continue;\n      }\n       \n      t = M_multiply(transformToC, z);\n\n      d[2] = abs(t.y);\n\n      if(t.y < 0.0)\n      {\n         t = H_conjugate(t);\n         z = M_multiply(transformFromC, t);\n         continue;\n      }\n\n      //the point is in the fundamental domain\n      break;\n   }\n\n   return z;\n}\n\nReal P_length(Complex p)\n{\n\tfloat n = length(p);\n \treturn log((1.0 + n) / (1.0 - n));\n}\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = (clip + vec2(0, 1)) * 2.0;\n    \n    vec2 z = M_fromPlaneToDisk(p);\n    \n    //translation vector, input or default\n    float time = 0.4 * iTime;\n    vec2 mouse = -(iMouse.xy / iResolution.xy - 0.5) * 5.0;\n    vec2 def = 4.0 * vec2(0.2*cos(0.5*time), sin(time));                      \n    vec2 v = iMouse.z > 0.0 ? mouse : def;\n\n    //this transform moves us around \n    //transformation could also be done by complex matrix composition, just like view matrices in R3\n    //since this is a fully proceedural shader, I recompute the translation each frame\n    ComplexMatrix2 translation = M_translateDisk(v);\n    z = M_multiply(translation, z);\n\n    //these transforms comprise the fundamental domain of the tiling\n    ComplexMatrix2 transformFromA = identityMob;\n    ComplexMatrix2 transformToA = M_inverse(transformFromA);\n\n    float angleB = tau32 / 16.0;\n    Complex versorB = H_versor(angleB);\n    ComplexMatrix2 transformFromB = M_mapRealsToLine(versorB, Complex(0,0), -versorB);\n    ComplexMatrix2 transformToB = M_inverse(transformFromB);\n\n    ComplexMatrix2 transformFromC = M_getIdealLine(H_versor(-0.872), H_versor(0.872));\n    ComplexMatrix2 transformToC = M_inverse(transformFromC);\n\n    vec3 distances;\n    int i;\n    z = getPoincareTiling(\n        transformFromA, transformToA,\n        transformFromB, transformToB,\n        transformFromC, transformToC,\n        z, distances, i);\n\n    float edge = 0.755;\n    float d = P_length(z);\n    float s = 1.0 - smoothstep(edge, edge + 0.02, d);\n    vec3 color = hsv2rgb(vec3(d * 0.25 + 0.5, 1, 1));\n    \n    color = mix(vec3(0.1), color, s);\n    \n    //if(length(p) > 1.0) color = 1.0 - color;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws3GWs", "name": "First RayMarching", "author": "Rewlion", "description": "hello world for shadertoy.", "tags": ["raymarching"], "likes": 1, "viewed": 254, "date": "1569447297", "time_retrieved": "2024-06-20T19:45:06.240982", "image_code": "float GetDistance(vec3 r)\n{\n \tvec3 s = vec3(0.0f, 1.0f, 3.0f);\n    float sr = 1.0f;\n    \n    float sphereDistance = length(r - s) - sr;\n    float surfDistance = r.y;\n    \n    return min(sphereDistance, surfDistance);\n}\n\nfloat RayMarching(vec3 start, vec3 dir)\n{\n \tfloat distance = 0.0;\n    \n    for(int i = 0; i < 100; ++i)\n    {\n     \tvec3 r = start + distance*dir;\n        float d = GetDistance(r);\n        \n        if(d < 0.01 || d > 100.0)\n            break;\n        \n        distance += d;\n    }\n    \n    return distance;\n}\n\nvec3 GetNormal(vec3 r)\n{\n \tvec2 e = vec2(0.01, 0.0);\n    float d = GetDistance(r);\n    \n    vec3 dr = d - vec3(\n        GetDistance(r - e.xyy),\n        GetDistance(r - e.yxy),\n        GetDistance(r - e.yyx)\n        );\n    \n    dr = normalize(dr);\n    \n    return dr;\n}\n\nfloat GetLight(vec3 p, vec3 n)\n{\n    vec3 lightpos = vec3(0.0f, 7.0f, 2.0f);\n    lightpos.xz += vec2(cos(iTime), sin(iTime)) * 1.5;\n    \n    vec3 dr = normalize(lightpos - p);\n    \n    float l = clamp(dot(dr,n), 0.0, 1.0);\n    \n    float ld = RayMarching(p + n * 0.01, dr);\n    if(ld < length(lightpos - p))\n        return l * 0.1;\n    \n    return l;\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 camera = vec3(0.0, 1.0f, 0.0);\n    vec3 dir = normalize(vec3(uv,1.0));\n    \n    float c = RayMarching(camera, dir);\n\t\n    vec3 p = camera + dir * c;\n    vec3 n = GetNormal(p);\n    \n    float l = GetLight(p, n);\n    \n    vec3 color = vec3(l);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3GWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3Gz8", "name": "Liquid Orb", "author": "BradyInstead", "description": "Click to move. All 2D noise functions. No raymarching.\n", "tags": ["noise", "orb"], "likes": 10, "viewed": 605, "date": "1567731756", "time_retrieved": "2024-06-20T19:45:07.059159", "image_code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n// from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise1D(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return (mix(rand(fl), rand(fl + 1.0), fc)-.5)*2.;\n}\n\n// from: https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat perlin( vec3 P )\n{\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\nfloat perlin(vec2 pos, float time)\n{\n    return (perlin(vec3(pos, time))+1.)*.5;\n}\n\nfloat noise(vec2 pos, float dist, float rotation, float time)\n{\n    time *= 1.+dist/100.;\n    pos += vec2(time*rotation, 0.)*.5;\n    pos -= vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    return perlin(pos*dist + vec2(dist), time*2.);\n}\n\nvec3 fbm(vec2 pos, float time)\n{\n    vec3 n = vec3(.05);\n\n    pos += perlin(pos*.5, time)*.1;\n    \n    n += noise(pos, 1., .01, time)      * vec3(.25, 1., .5);\n    n += noise(pos, 5., .025, time)*.85 * vec3(.75, 1., 1.);\n    n += noise(pos, 10., .05, time)*.5  * vec3(.25, 1., 1.);\n    n += noise(pos, 20., .1, time)*.25  * vec3(1., 0., .2);\n    n += noise(pos, 75., .15, time)*.1  * vec3(1.,1., 1.);\n    \n    return n;\n}\n\n\nfloat circle(vec2 pos, float radius)\n{\n    return smoothstep(30./iResolution.y, -30./iResolution.y, length(pos)- radius);\n}\n\nfloat highlight(float circle, vec2 pos, float radius)\n{\n    float h = smoothstep(0., radius, length(pos));\n    h -= 1.-circle;\n    return h*(.4+(sin(iTime)+1.)*.1);\n}\n\n// from: https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // position\n    vec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // distortions\n    pos.x += noise1D(iTime)*.05;\n    pos.y += noise1D(iTime+10.)*.05;\n    pos += perlin(pos*2., iTime)*.1;\n    pos *= 1.1;\n    \n    // variables\n    float radius = .9 + sin(iTime*4.)*.1;\n    float time = iTime;\n    \n    // fisheye\n    pos *= .5 + pow(length(pos), 10.);\n\n    // forms\n    vec3 noise = fbm(pos, time);\n    vec3 circ = vec3(circle(pos, radius));\n    vec3 hl = vec3(highlight(circ.r, pos, radius));\n    \n    // post processing\n    vec3 res = clamp(circ - noise, vec3(0.), vec3(1.));\n    res.rgb = res.bgr;\n    res *= 2.;\n    res += hl*vec3(1., .2, .5);\n    res = hueShift(res, 5. + sin(iTime));\n    res *= 1.4;\n    \n    // output\n    fragColor = vec4(res, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3Gz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3GzH", "name": "Truchet wave", "author": "TheRomanOne", "description": "Marching Truchet attempt\nThanks to BugWings - The Art of Code\nhttps://www.youtube.com/watch?v=2R7h76GoIJM", "tags": ["truchetwave"], "likes": 2, "viewed": 149, "date": "1567762874", "time_retrieved": "2024-06-20T19:45:07.059159", "image_code": "#define EPS 0.01\n#define MAX_DIST 1000.\n\n// Big thanks to BigWings!!!\n\nmat2x2 rot(float ang)\n{\n    ang *= 3.141592654/180.;\n \tfloat c = cos(ang),\n          s = sin(ang);\n    \n    return mat2x2(c, s, -s, c);\n}\n\nfloat hash21(vec2 p)\n{\n\tp = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nfloat getMaze(vec2 uv, float width)\n{\n    uv *= rot(iTime*10.);\n    //uv *= 5.;\n\tuv.y += 2.*iTime;\n\n    if(hash21(floor(uv)) < .5)\n       uv *= rot(90.);\n       \n    vec2 fv = fract(uv), rfv = fract(-uv);\n    float lfv = length(fv), lrfv = length(rfv);\n    \n    if(lfv < .5 + width && lfv > .5 - width ||\n       lrfv < .5 + width && lrfv > .5 - width)\n        return 1.;   \n    return 0.;\n}\n\nfloat map(vec3 p)\n{\n \tfloat pl = p.y + 1. - getMaze(p.xz, .05)/5.;   \n    return pl + sin(p.x)*cos(p.z)/2.;\n}\n\nvec3 getNormal(vec3 p)\n{\n \treturn normalize(vec3(\n        map(p + vec3(EPS, 0, 0)) - map(p - vec3(EPS, 0, 0)),\n        map(p + vec3(0, EPS, 0)) - map(p - vec3(0, EPS, 0)),\n        map(p + vec3(0, 0, EPS)) - map(p - vec3(0, 0, EPS))\n        ));\n}\n\nfloat lighting(vec3 p)\n{\n    vec3 normal = getNormal(p);\n    \n    vec3 light = normalize(vec3(1, 2, -1));\n    \n    //light.yz *= rot(iMouse.y/2.);\n    light.xz *= rot(iMouse.x/2.);\n    \n    float c = max(0.2, dot(normal, light));\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0, 5, -10);\n    vec3 ta = vec3(0);\n    vec3 fw = normalize(ta - ro);\n    vec3 ri = normalize(vec3(-fw.z, 0, fw.x));\n\tvec3 up = cross(ri, fw);\n    \n    float FOV = .57;\n    vec3 rd = normalize(mat3x3(ri, up, fw) * vec3(FOV * uv, 1.));\n        \n    vec3 col;\n    \n    float d, dst;\n    vec3 ray;\n    for(int i = 0; i < 256; i++)\n    {\n        ray = ro + rd * d;\n     \tdst = map(ray);\n        if(dst < EPS || d > MAX_DIST)\n            break;\n        d += dst * .1;\n    }\n    \n    if(d < MAX_DIST)\n    \tcol = vec3(lighting(ray));\n    \n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3GzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws3GzM", "name": "invitro", "author": "foran", "description": "invitro", "tags": ["invitro"], "likes": 3, "viewed": 57, "date": "1568055767", "time_retrieved": "2024-06-20T19:45:07.059159", "image_code": "#define T iTime\nfloat C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\nfloat map(vec3 q){\n  float d=10e4;\n  for(float f=0.;f<10.;++f){//    10\n   vec3 p=q;\n   float ri=mod(f+T,10.),\n   ro=-ri*0.121+.82;\n   p.xy*=rot(T*.3+f);\n   p.yz*=rot(T*.5+f+p.z*.2);\n   p.xz*=rot(T*.7+f+p.x*.2);\n   d=min(d,length(vec2(length(p.xz)-ri,p.y))-ro);\n }\n  return d;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n\n  vec3 ro=vec3(0.,0.,-6.),\n rd=normalize(vec3(uv,1.)),//  \n mp=ro;\n float f,dmin=10.,dt=.2;\n for(f=0.;f<30.;f++){//        \n   float d=map(mp);//          \n   dmin=min(dmin,d);\n   if(d<.01)break;\n   mp+=rd*d;\n }\n float r=(dmin-.01)/(dt-.01);\n vec3 c=vec3(max(1.-f/30.,r*(1.-r)*4.));\n c=mix(c,vec3(0.9216, 0.0824, 0.0824),.29);\n vec4 out_color=vec4(1.);\n  out_color = vec4(c,1.);\n  fragColor=vec4(out_color);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws3GzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsc3D4", "name": "2D Dual Vector Distance Estimate", "author": "skye_adaire", "description": "This uses a vector2 of dual real numbers to compute the distance estimate of an implicit function.", "tags": ["distance", "implicit", "dual", "real", "estimate"], "likes": 1, "viewed": 106, "date": "1568509847", "time_retrieved": "2024-06-20T19:45:08.059314", "image_code": "//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n\n//end Hypercomplex\n\nDualReal f(DualVector2 d)\n{\n    DualReal a = DualReal(cos(iTime) * 4.0, 0);\n    DualReal s = DualReal(sin(iTime * pi32 * 0.2)*0.4 + 0.6, 0);\n    \n    return d[1] - D_multiply(D_cos(D_multiply(d[0], s)), a);\n    \n    \n    \n    return D_multiply(D_sq(d[0]), a) + D_sq(d[1]) - DualReal(1, 0);\n}\t\n\nfloat getDE(vec2 p, out vec2 gradient)\n{\n \tDualReal dx = f(DualVector2(p.x, 1, p.y, 0)); \n    DualReal dy = f(DualVector2(p.x, 0, p.y, 1));\n    \n    float fp = dx[0];//level, same for both partials\n    gradient = vec2(dx[1], dy[1]);\n   \n    return fp / length(gradient);\n}\n\nvec3 getColor(vec2 p)\n{\n    vec2 gradient;\n    float de = getDE(p, gradient);\n    \n    vec3 normal = normalize(vec3(gradient, 0));\n    float curve = 1.0 - smoothstep(0.19, 0.2, abs(de));\n    \n    vec3 color = vec3(0);  \n    vec3 colorNegative = vec3(1,0.8,0.8);\n    vec3 colorPositive = vec3(0.8,1,0.8);\n    vec3 background = vec3(fract(de));\n    if (de < 0.0) background = 1.0 - background;\n    background *= 0.7;\n    \n    color = mix(background, normal, curve);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 p = clip * 6.0;\n\n    // Output to screen\n    fragColor = vec4(getColor(p),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3D4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsc3DS", "name": "Flame producing structure", "author": "TambakoJaguar", "description": "I've been inspired by an image I created with POVRay in 1997 for a flyer and wanted to recreate it with Shadertoy!\nUse mouse to move around", "tags": ["3d", "raymarching", "mouse", "sunset", "flame", "fire", "light", "sky", "shadows", "animated", "hot", "metallic", "structure", "installation"], "likes": 14, "viewed": 228, "date": "1569353481", "time_retrieved": "2024-06-20T19:45:10.914115", "image_code": "/*\n\"Flame producing structure\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n#define shadow\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 8;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.35;\n\n// Specular options\nconst float specint = 0.36;\nconst float specshin = 25.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0001;\nconst float maxdist = 50.;\nconst int nbref = 2;\n\n// Color options\nconst float gamma = 1.75;\nconst vec3 structure_color = vec3(0.98, 0.8, 0.6);\nconst vec3 structure_color2 = vec3(0.7, 0.9, 0.65);\nconst vec3 floor_color = vec3(0.5, 0.65, 0.2);\nconst float structureRef = 0.8;\n\n// Geometry options\nconst float r1 = 0.1;\nconst float r2 = 0.3;\nconst float r3 = 0.75;\nconst float h = 1.;\nconst float e = 1.75;\nconst float l = 0.2;\nconst float f1 = 1.18;\nconst float f2 = 1.088;\nconst float ng = 12.;\nconst float gd = 0.07;\nconst float sf = 250.;\nconst float sa = 0.02;\n\n// Flame parameters\nconst float fcp = 1.5;\nconst vec3 flameColor = vec3(1., 0.6, 0.22);\nconst float flameIntensity = 0.7;\nconst float flameIntensity2 = 0.5;\nconst float flameStep = 0.02;\nconst float flamePow = 2.5;\nconst float flameBias = 0.;\nconst float dnf = -0.85;\nconst float dnx = -0.25;\nconst float dns = -21.;\nconst float fts = 7.5;\nconst float ftf = 1.1;\nfloat ft;\n\n// Campera options\nvec3 campos = vec3(0., 0., 10.);\nvec3 camtarget = vec3(0., 1.4, 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 4.2;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define FLOOR_OBJ       1\n#define STRUCTURE_OBJ   2\n#define FLAME_OBJ       3\n    \nLamp lamps[3];\n\nint aai;\nint aaj;\n\nfloat flameVar;\n\nvoid init()\n{    \n    lamps[0] = Lamp(vec3(30., 70., .0), vec3(0.5, 0.7, 1.), 1.3, 0.01);\n    lamps[1] = Lamp(vec3(10., 40., -100.), vec3(1., 0.7, 0.1), 3.8, 0.01);\n    lamps[2] = Lamp(vec3(0., h*2. + r2, 0.), flameColor, 0.5, 0.01);\n    \n    // Power of the flame in function of the time\n    flameVar = sin(iTime*0.55) + 0.56*sin(iTime*0.134) + 0.22*sin(iTime*0.095);\n    \n    ft = iTime*dns;\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat2 m = mat2(1.1,  1., -1.,  1.1);\nfloat fbm(vec3 n)\n{\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn.xy = m * n.xy;\n        n.yz = m * n.yz;\n        n.zx = m * n.zx;\n\t\tamplitude *= 0.8;\n\t}\n\treturn total;\n}\n\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat map_floor(vec3 pos)\n{\n   return pos.y;\n}\n\nfloat map_structure(vec3 pos)\n{\n   pos.x = abs(pos.x);\n    \n   float a = atan(pos.x - e, pos.z); \n   float r1b = r1*(1. - gd*smoothstep(-0.7, 1., sin(a*ng))*smoothstep(1.95*h, 1.8*h, pos.y));\n   float c = sdCylinder(pos - vec3(e, h, 0.), vec2(r1b, h*1.0));\n   float t = max(-pos.y + h*2., max(-pos.x + e - r2, sdTorus(pos.xzy - vec3(e - r2, 0., h*2.), vec2(r2, r1))));\n   c = min(c, t);\n   c = min(c, sdCylinder(pos.yxz - vec3(h*2. + r2, e - r2 - l, 0.), vec2(r1, l)));\n   float r2b = r2*(1. + sa*sin(pos.x*sf)*smoothstep(e - r2 - l - r2*0.85, e - r2 - l - r2*0.65, pos.x));\n   c = smin(c, length(pos - vec3(e - r2 - l - r3, h*2. + r2b, 0.)) - r3, 0.15);\n   c = smax(c, -length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) + r3*f2, 0.06);\n   c = max(c, -pos.x + e - r2 - l - r3*0.35);\n       \n   return c;\n}\n\nfloat map_flame(vec3 pos, bool turb)\n{\n   vec3 pos0 = pos;    \n    \n   if (turb)\n   {\n      vec3 q = pos*fts;       \n       \n      float n = 0.1*noise(q*1.9);\n      q.xy = rotateVec(-q.xy, pos.z*n);\n      q.yz = rotateVec(-q.yz, pos.x*n);\n      q.zx = rotateVec(-q.zx, pos.y*n);\n        \n      q*= vec3(1., 1.5, 1.);\n      q+= vec3(ft, 0., 0.);\n      q.x+= 0.5*pos.x*noise(q + vec3(30., 40., 50. + ft));\n      q.y+= 0.5*pos.x*noise(q + vec3(10., 30. + ft, 20.));\n      q.z+= 0.5*pos.x*noise(q + vec3(20., 60. - ft, 40. - ft));\n \n      float dn = dnf;\n      pos.x+= dn*noise(q + vec3(12., 3.+ ft, 16. - ft)) - dn/2.;\n      pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n      pos.z+= dn*noise(q + vec3(8. + ft*0.3, 22., 9.)) - dn/2.;\n   }\n   pos.x = abs(pos.x);\n    \n   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;\n   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);\n   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2((turb?0.45:0.58) + 0.32*cos(pos.x*pi/e), e)));\n    \n   if (turb)\n   {\n     c = mix (c, 0.3*c -0.9*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.3, e - r2 - l, -pos0.x));\n     c*= (1. + 0.6*smoothstep(e - r2 - l - 1., e - r2 - l, pos0.x)); \n   }\n   return c;\n}\n\nfloat map_flame_s(vec3 pos)\n{\n   vec3 pos0 = pos;    \n    \n   vec3 q = pos*0.6;\n   q*= vec3(1., 1.5, 1.);\n   q+= vec3(ft, 0., 0.);\n   float dn = 0.5*(dnf - dnx*pos.x);\n   pos.x+= dn*noise(q + vec3(12., 3. + ft, 16.)) - dn/2.;\n   pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n   pos.z+= dn*noise(q + vec3(8., 22., 9.)) - dn/2.;\n   \n   pos.x = abs(pos.x);\n    \n   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;\n   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);\n   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2(0.58 + 0.32*cos(pos.x*pi/e), e)));\n\n   c = mix (c, 0.6*c -0.3*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.2, e - r2 - l, -pos0.x)); \n    \n   return c;\n}\n\nvec2 map(vec3 pos, bool flame)\n{\n    float floor = map_floor(pos);\n    vec2 res = vec2(floor, FLOOR_OBJ);\n    \n    float structure = map_structure(pos);\n    res = opU(res, vec2(structure, STRUCTURE_OBJ)); \n    \n    if (flame)\n    {\n       float flame = map_flame(pos, false);\n       res = opU(res, vec2(flame, FLAME_OBJ));\n    }\n    \n    return res;\n}\n\n// Gets the color of the flame depending on the position and ray direction by volume sampling\nvec3 getFlameDensColor(vec3 pos, vec3 ray, float s, float fi, int nbSteps)\n{\n    float d = 1.;\n    float f;\n    vec3 scol = vec3(0.);\n    for (int i=0; i<nbSteps; i++)\n    {\n        pos+= ray*s;\n        f = -map_flame(pos, true);\n        f = sign(f)*pow(abs(f), flamePow);\n    \td = clamp(f + flameBias, 0., 1.);\n        scol+= flameIntensity2*d*flameColor;\n    }\n    \n    return clamp(scol*fi, 0., 1.5);\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool flame) \n{\n    float t = 0.08;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 140; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, flame);\n        dist = res.x;\n        objnr = abs(res.y);        \n        if (dist>maxdist || abs(dist)<(int(objnr)==FLAME_OBJ?0.03:0.0001))\n            break;\n        t+= dist*0.95;\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, false).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<30; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, false).x;\n        res = min( res, 27.0*h/t );\n        t += clamp( h, 0., 0.80 );\n        if( res<0.0005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    vec3 col = mix(vec3(1.1, 0.8, 0.), vec3(0.2, 0.4, 0.7), clamp(1.1*ray.y + 0.5*ray.z, 0., 1.));\n    col*= 1.+ 0.4*smoothstep(0.5, 0., pow(clamp(0.7*ray.y + 2.2*ray.z + 2.3, 0., 1.), 1.1));\n    col.b+= smoothstep(0.5, 0., pow(clamp(0.7*ray.y + 2.2*ray.z + 2.25, 0., 1.), 0.7));\n    \n    return col;\n}\n\nfloat mm;\nfloat gg;\nvec3 getStructureColor(vec3 pos)\n{\n   pos.x = abs(pos.x);\n   mm = (length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)));\n   gg = pos.y>2.*h?0.:smoothstep((1. - 0.1*gd)*r1, (1. - 0.8*gd)*r1, length(pos.xz - vec2(e, 0.)));\n   gg+= smoothstep(0.83, 0.815, mm);\n       \n   vec3 col = mix(structure_color, structure_color2, gg);\n   col*= smoothstep(0.813, 0.824, mm);\n   float fb = fbm(pos);\n   col = mix(structure_color2*0.5, col, 0.5 + 0.5*gg + 0.5*(1. - gg)*(1. - smoothstep(0.155, 0.16, fb) + smoothstep(0.16, 0.165, fb)));\n   return col;\n}\n\nfloat getStructureRef(vec3 pos)\n{\n   pos.x = abs(pos.x);\n   float rf = pos.y>2.*h?1.:smoothstep((1. - 1.3*gd)*r1, (1. - 0.1*gd)*r1, length(pos.xz - vec2(e, 0.)));\n   rf*= smoothstep(0.815, 0.824, mm);\n   float fb = fbm(pos);\n   rf*= 0.5 + 0.5*(1. - gg)*(1. - smoothstep(0.155, 0.16, fb) + smoothstep(0.16, 0.165, fb));    \n   return rf*structureRef;\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==FLOOR_OBJ)\n      return floor_color;   \n   else if (objnr==STRUCTURE_OBJ)\n      return getStructureColor(pos);\n   else\n      return getSkyColor(ray);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    if (lampnr==2)\n    {\n        if (objnr==FLOOR_OBJ)\n            lamp.position.x = pos.x*0.25;\n        lamp.intensity = 0.9*(1. + 0.3*flameVar)*smoothstep(0., 2.2, 2.8/(map_flame_s(pos) - 0.4) - 0.45); //*smoothstep(e + 1.8, e + 1., abs(pos.x));\n    }    \n    \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.78, 0.83);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\n// Combine the flame color with its background in a non-linear way\nvec3 combFlameCol(vec3 col1, vec3 col2)\n{\n    return pow(pow(col1, vec3(fcp)) + pow(clamp(col2, 0., 1.), vec3(fcp)), vec3(1./fcp));   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool flame)\n{\n    vec2 tr = trace(tpos, ray, maxdist, flame);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist, true);\n  \tvec3 col = traceinf.col;\n    vec3 startpos = campos;\n    \n    vec3 flamecol;\n    float flameIntensityV = flameIntensity*(1. + 0.37*flameVar);    \n    \n    #ifdef reflections\n    vec3 rf = vec3(1.);\n    for (int r=0; r<nbref; r++)\n    {\n       flamecol = vec3(0.);\n       if (traceinf.objnr==STRUCTURE_OBJ)\n       {           \n          rf*= getStructureRef(traceinf.pos);\n          vec3 refray = reflect(ray, traceinf.norm);\n        \n          traceinf = trace0(traceinf.pos, refray, maxdist, true);\n          col = mix(col, structure_color*traceinf.col, rf);\n\n          rf*= structure_color;\n          ray = refray;\n       }\n       else if (traceinf.objnr==FLAME_OBJ)\n       {\n          flamecol = getFlameDensColor(traceinf.pos, ray, flameStep, flameIntensityV, 70);\n          traceinf = trace0(startpos, ray, maxdist, false);\n          col = traceinf.col;\n       }\n       startpos = traceinf.pos;        \n       col = combFlameCol(col, flamecol);\n    }\n    #endif\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3DS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsc3Rj", "name": " - Quicky#012", "author": "totetmatt", "description": "Random coding that reminds me of the Sonic special stage :D https://www.youtube.com/watch?v=JgbFHHHE4Vk", "tags": ["quicky", "infiniteroad"], "likes": 1, "viewed": 244, "date": "1568841684", "time_retrieved": "2024-06-20T19:45:10.914115", "image_code": "float hash(vec2 p) {\n   \n    p = fract(p*vec2(234.34, 435.345));\n    p += sin(dot(p, p+342.23));\n    return fract(p.x*p.y);\n    \n\n}\nmat2 r(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     uv*=r(sin(uv.x))*10.;\n     \n     vec2 guv = fract(uv+vec2(0,iTime));\n     vec2 id = floor(uv+vec2(0,iTime));\n     float d = guv.x;\n     if(hash(id+iTime/1000000.) >0.3) d = 1.-guv.x;\n     vec3 col = mix(vec3(0.1),vec3(.9,.9,.0),vec3(d));\n     col.r *= .5+hash(id+iTime/1000000.) ;\n     col.g *= .5+hash(id+iTime/1000000.) ;\n     if(mod(id.y,  5.) == 0. ) col.b+=.9 ;\n     else col.b=.0;\n     \n     if(mod(abs(id.x),5.) == 2.-step(0.,sign(id.x))) col*=vec3(1.9,1.2,.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsc3Rj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsc3Rn", "name": "Forest Tour", "author": "Pyrolykos", "description": "Demo of 3D fractal tree raymarching", "tags": ["3d", "fractal", "demo", "tree"], "likes": 3, "viewed": 171, "date": "1567567769", "time_retrieved": "2024-06-20T19:45:12.205251", "image_code": "// Mapping function approach:\n// We dynamically construct the closest branch of each tree, starting with\n// an initial root node, and then finding what \"quadrant\" of the world\n// we're in based on splitting planes, proceeding iteratively from there.\n// Assumes symmetry across splitting planes, or else could have weird\n// \"discontinuities\" along them.\n\n// 7 looks cool, but is pretty slow. Can change to 5 for slower computers.\n#define NUM_ITERS 6\n\n// Turns on mirror-water effect and shadows. Can disable for slower computers.\n#define SECOND_RAY\n\n// Little spheres for leaf-nodes. Positioning not right yet.\n// #define LEAF_SPHERES\n\n// Test if point is above or below the infinite plane defined by a planeCenter\n// (any point on plane) and the normal to the plane (pointing \"up\"/\"above\")\nbool abovePlane(vec3 point, vec3 planeCenter, vec3 normalDir) {\n    vec3 ray = point - planeCenter;\n    return dot(ray, normalDir) >= 0.0;\n}\n\n// Rotation fcn: rotAxis assumed to be normalized and origin-rooted\nvec3 rotateVec(vec3 v, vec3 rotAxis, float sinAngle, float cosAngle) {\n    return cosAngle*v + sinAngle*cross(rotAxis, v) + (1.0 - cosAngle)*dot(rotAxis, v)*rotAxis;\n}\n\nfloat sphereDist(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\n// From iq's raymarching primitives website:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat ellipsoidDist(vec3 pos, float rad, float stretch) {\n    vec3 r = vec3(rad, stretch, rad);\n\tfloat k0 = length(pos/r);\n    float k1 = length(pos/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat groundDist(vec3 pos) {\n    // TODO: Add some soft hills\n    return pos.y + 1.3;\n}\n\n// Size of grid; initially was 5.0\n#define G 7.0\n\n// Fractal backtrace\nfloat backTrace(vec3 pos) {\n    // Assign unique id's to our GxG gridspaces\n    vec2 id = floor(pos.xz/G);\n    float fullId = 131.1*id.x+173.7*id.y;\n\n    // Spin the trees\n    vec3 boxRight = vec3(sin(fullId+iTime), 0.0, cos(fullId+iTime));\n    \n    // Repeat our trees every GxG\n    pos = vec3(mod(pos.x, G)/1.5-1.5, pos.y, mod(pos.z, G)/1.5-1.0);\n    \n    // Randomize our trees a bit\n    float offsetDelta = 0.40+.12*sin(fullId);\n    float ellipseSizeA = 0.09+.06*cos(fullId);\n    \n    // Didn't bother calculating; just eyeballed\n    float ellipseSizeB = 30.0*ellipseSizeA;\n    vec3 boxCenter = vec3(0.0, -offsetDelta-0.7-ellipseSizeA/3.0, 0.0);\n    \n    // Direction of box movement; starts pointing up\n    vec3 boxUp = vec3(0.0, 1.0, 0.0);\n    \n    float theta = 0.6+0.6*cos(iTime+fullId);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    const float scaleFactor = 0.70;\n    \n    float currScale = 1.0;\n    \n    float closestBoxDist = 1000.0;  // +inf\n    \n    vec3 relativePos;\n    for (int iters = 0; iters < NUM_ITERS; iters++) {\n        // Second splitting plane calculated\n        vec3 boxForwards = normalize(cross(boxUp, boxRight));\n\n        relativePos = pos - boxCenter;\n        mat3 m;\n        m[0] = boxRight;\n        m[1] = boxUp;\n        m[2] = boxForwards;\n        // Ortho, so transpose=inverse\n        m = transpose(m);\n        relativePos = m*relativePos;\n\n        // New node along our branch\n        closestBoxDist = min(closestBoxDist, ellipsoidDist(relativePos, ellipseSizeA*currScale, ellipseSizeB*offsetDelta));\n        \n\t\t// Current branch splits the world into quadrants; find our quadrant\n        bool upSplit = abovePlane(pos, boxCenter, boxRight);\n        bool rightSplit = abovePlane(pos, boxCenter, boxForwards);\n        \n        vec3 rotAxis;\n        // Find rotation axis based on quadrant splitting\n        if (upSplit) {\n            rotAxis = boxForwards;\n        } else {\n            rotAxis = -boxForwards;\n        }\n        if (rightSplit) {\n            rotAxis -= boxRight;\n        } else {\n            rotAxis += boxRight;\n        }\n        \n        rotAxis = normalize(rotAxis);\n        \n        // First move forwards in old direction\n        boxCenter += offsetDelta * boxUp;\n        \n        // Rotate\n        boxUp = rotateVec(boxUp, rotAxis, sinTheta, cosTheta);\n    \tboxRight = rotateVec(boxRight, rotAxis, sinTheta, cosTheta);\n\n        // And shrink\n        currScale *= scaleFactor;\n\n        offsetDelta *= scaleFactor;\n        // Move forwards after scaling in the new direction\n        boxCenter += offsetDelta * boxUp;\n    }\n    \n    // For little leaf-spheres\n#ifdef LEAF_SPHERES\n    closestBoxDist = min(closestBoxDist, sphereDist(relativePos-vec3(0.0,ellipseSizeA*1.5,0.0), ellipseSizeA*1.5*currScale));\n#endif\n    return closestBoxDist;\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(0.0, 0.00001);\n    return normalize(vec3(backTrace(pos + e.yxx) - backTrace(pos - e.yxx),\n                          backTrace(pos + e.xyx) - backTrace(pos - e.xyx),\n                          backTrace(pos + e.xxy) - backTrace(pos - e.xxy)));\n}\n\nvec2 wavify(vec2 uv) {\n    uv = uv + 0.2*vec2(sin(5.0*(uv.y+iTime/5.0)), 0.0);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 sun_dir = normalize(vec3(0.5, 0.8, -0.5));\n    \n    // normalized pixel coords --> pixel ray\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(uv.xy, -1.5));\n    \n    // construct camera path\n    float zPos = 2.0-100.0*sin(iTime*6.0/100.0);\n    vec3 ro = vec3(2.0*cos(1.1*iTime), 1.0+1.5*sin(1.3*iTime), zPos);\n \n    // Raymarch\n    float t = 0.0;\n    vec3 pos;\n    for (int i = 0; i < 100; i++) {\n        pos = ro + t*rd;\n        float h = backTrace(pos);\n        \n        // Ground check\n        h = min(h, groundDist(pos));\n        \n        t += h;\n        \n        if (t > 25.0) break;\n    }\n\n    vec3 col;\n    if (t < 25.0) {\n        if (pos.y > -1.27) {\n\t\t\t// Hit a tree; rainbow color\n            vec2 id = floor(pos.xz/G);\n    \t\tfloat fullId = 11.1*id.x-17.3*id.y;\n        \tcol = vec3(sin(iTime+id.xy+1.5*pos.xy)/3.0+0.6, cos(iTime+id.x+id.y+1.5*pos.z)/3.0+0.6);\n\t\t\n        \t// Simple sunlight\n        \tfloat light = 0.7+0.7*clamp(dot(sun_dir, normal(pos)), 0.0, 1.0);\n        \tcol *= light;\n        } else {\n            // Ground\n            col = texture(iChannel0, vec2(pos.x, pos.z)/10.0).xyz+vec3(0.0,0.1,0.0);\n#ifdef SECOND_RAY\n            // March ray again, either back to sun for shadows (grass)\n            // or else forwards until it hits something for mirror (water)\n            vec3 spos;\n            t = 0.01;\n            vec3 ref_dir = sun_dir;\n            bool isWater = (sin(pos.z/2.0)+cos(pos.x/2.0)) >= 0.8;\n            if (isWater) {\n                ref_dir = vec3(rd.x, -rd.y, rd.z);\n               \t\n                // Cheap bumpy mirror; just use texture\n\t\t    \tref_dir += 0.2*col;\n                ref_dir = normalize(ref_dir);\n            }\n            for (int i = 0; i < 100; i++) {\n                spos = pos + t*ref_dir;\n                float h = backTrace(spos);\n                t += 0.9*h;  // for finer shadow details mid-expansion\n                if (t > 20.0) break;\n            }\n            if (!isWater) {\n            \tif (spos.y < 1.2) {\n                \t// shadow\n                \tcol *= 0.75;\n                }\n            } else {\n                // mirrored tree\n                if (spos.y < 1.2) {\n                    // just use spos color!\n                    vec2 id = floor(spos.xz/G);\n\t\t    \t\tfloat fullId = 11.1*id.x-17.3*id.y;\n        \t\t\tcol = vec3(sin(iTime+id.xy+1.5*spos.xy)/3.0+0.6, cos(iTime+id.x+id.y+1.5*spos.z)/3.0+0.6);\n        \n\t\t        \t// sunlight\n\t\t        \tfloat light = 0.7+0.7*clamp(dot(sun_dir, normal(spos)), 0.0, 1.0);\n\t\t        \tcol *= light;\n                    col *= 0.7;\n                } else {\n                    // mirrored sky\n                    uv = wavify(uv);\n                    col = vec3(0.13,0.13,0.2)+vec3(0.1, 0.1, 0.2) * texture(iChannel1, vec2(uv.x, uv.y)/3.0).rgb;\n                }\n            }\n#endif\n        }\n        // Hacky distance fog\n    \tcol *= 1.0-(ro.z-pos.z)*(ro.z-pos.z)/500.0;\n    } else {\n    \t// Sky\n        uv = wavify(uv);\n\t\tcol = vec3(0.2, 0.2, 0.4) * texture(iChannel1, vec2(uv.x, uv.y)/3.0).rgb;\n    }\n        \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3Rn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsc3W2", "name": "hedges", "author": "a22dae1d4f0e484ba4114a147eac4e", "description": "hedges", "tags": ["truchet"], "likes": 1, "viewed": 89, "date": "1569298394", "time_retrieved": "2024-06-20T19:45:12.205251", "image_code": "float Hash21(vec2 p)\n{\n    // PRNG\n    vec2 seed = vec2(200);\n    p += seed;\n    p = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rv = (fragCoord-.5*iResolution.xy)/(iResolution.y);\n    vec2 uv = rv*10.;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*vec2(-0.05, -0.2);\n    float width = .35;\n    float s = 0.018;\n    \n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    if(n<.5) gv.x *= -1.;  //apply random\n    float mask = smoothstep(s, -s, abs(gv.y + gv.x)-width);\n    mask +=  smoothstep(s, -s, abs(gv.y-0.5 + gv.x-0.5)-width);\n    mask +=  smoothstep(s, -s, abs(gv.y+0.5 + gv.x+0.5)-width);\n    \n    //float d= abs(abs(gv.x + gv.y)-.5);\n    //d = length(gv - vec2(0.5))-.5;\n    //float mask = smoothstep(.01, -.01, abs(d) - width);\n    //d = length(gv - vec2(-0.5))-.5;\n    //mask += smoothstep(.01, -.01, abs(d) - width);\n    \n    \n    //col += smoothstep(.01, -.01, abs(gv.y-gv.x))*vec3(0,0,1);\n    \n    float gradient = (rv.x+1.)/2.;\n    vec3 gradientv = gradient*vec3(0.2,0.8,0.1) + (1.-gradient)*vec3(0,0.8,0.6);\n    \n    col += mask*gradientv;\n    //col.rg += n;\n    \n    //if(gv.x > 0.48 || gv.y > .48) col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsc3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsc3W4", "name": "CoreEngine", "author": "EvilRyu", "description": "Play with some simple kifs in the weekend.", "tags": ["glow", "kifs", "sierpinski"], "likes": 41, "viewed": 914, "date": "1568558556", "time_retrieved": "2024-06-20T19:45:12.217412", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define AA 2\n#define FAR 100.\n\nfloat rnd=0.;\n\nfloat hash12(vec2 p)\n{\n    p=fract(p*vec2(5.3983, 5.4427));\n    p+=dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t), s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat infi_box(vec2 p, vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.0))+min(max(d.x,d.y),0.0); \n}\n\nfloat oct(vec3 p, float s)\n{\n    p=abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 kifs(vec3 p)\n{\n    float s=1.;\n    float scale=3.5;\n    for(int i=0;i<4;++i)\n    {\n        p=scale*abs(p)-(scale-1.);\n        p.xy*=rot(-0.4);\n        p.yz*=rot(0.23);   \n        s*=scale;\n     }\n    p/=s;\n    return p;\n}\n\nvec3 kifs2(vec3 p)\n{\n    float s=.7;\n    for(int i=0;i<5;++i)\n    {\n        if(p.x+p.y<0.){p.xy = -p.yx;}\n      \tif(p.x+p.z<0.){p.xz = -p.zx;}\n      \tif(p.y+p.z<0.){p.yz = -p.zy;}\n\t\tp = p*2.-1.+0.3*sin(iTime);\n        p.xy*=rot(iTime);\n       \tp.yz*=rot(iTime);\n\n    }\n    p*=pow(2.,-5.);\n    return p;\n}\n\nint obj=0;\n\nvec3 tri(vec3 p){ return abs(fract(p)-0.5);}\nfloat tri_surf(vec3 p)\n{\n    return dot(tri(p*0.5+tri(p.yxz*0.25+tri(p.xzy*0.125))), vec3(0.6666));\n}\n\n\nfloat acc0=0., acc1=0.;\n\nfloat core(vec3 p)\n{\n    vec3 q=p;\n   \tp=kifs2(p*0.5);\n    float d0=infi_box(q.xy,vec2(0.1));\n    float d1=box(p,vec3(0.05));\n    float d=d1*2.;\n    \n    q=q+vec3(0.,3.,0.);\n    float d2=infi_box(abs(q.xz)-4.,vec2(0.3));\n    \n    d=min(d,d2);\n    \n    acc0+=0.2/(0.15+abs(d));\n    acc1+=0.2/(0.15+abs(d));\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q=p;\n    p=kifs(p);\n    float d1=abs(p.y+1.5);\n    \n    obj=1;\n    \n    float d=d1;\n    d-=tri_surf(p)*0.2;\n    \n    vec3 r=q;\n    r.xz=abs(r.xz*rot(2.*iTime))-1.9;    \n    r.yz=abs(r.yz*rot(2.*iTime))-1.9;\n\n    float d3=oct(r,0.5);\n    d=min(d,d3);\n    \n    float d0=core(q);\n    if(d0<d){obj=0;d=d0;}\n\n    return d*0.8;\n}\n\nvec3 get_normal(vec3 p)\n{\n    vec2 eps=vec2(0.001,0.);\n    return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                    map(p+eps.yxy)-map(p-eps.yxy),\n                    map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\n    \nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.1;\n    for(int i=0;i<128;++i)\n    {\n        float d=map(ro+t*rd);\n        if(obj==0)d*=rnd;\n        t+=d;\n        if(d<0.005 || t>=FAR)\n            break;\n    }\n    \n    return t;\n}\n\nvec3 firecolor(float f)\n{\n    f=f*f*(3.0-2.0*f);\n    return  min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.0);\n}\n\nvec3 lightcolor(float t)\n{\n    return mix(firecolor(0.4), vec3(0.,1.0,0.5)*0.5, pow(abs(t),8.));\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r+=w*(d-map(p+n*d));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nvec3 lighting(vec3 ro, vec3 rd, vec3 n, vec3 p)\n{\n    vec3 l1d=normalize(-p);\n    vec3 l1c=lightcolor(rd.x)*10.;\n        \n    float ao=get_ao(p,n);\n    \n    float dif=max(dot(n,l1d),0.)*ao;\n    float bac=max(dot(n,-l1d),0.)*ao;\n    float amb=clamp(0.3+0.7*n.y,0.0,1.0);\n    float spe=pow(max(dot(reflect(-l1d,n),normalize(-l1d-rd)),0.), 32.);\n   \n    map(p);\n\n    vec3 mate;\n    if(obj==0)mate=lightcolor(rd.x);\n    else mate=vec3(0.1,0.2,0.3)*0.5;\n    \n   \tvec3 lin=(l1c*(4.*dif+1.*bac)+amb*vec3(1.))*mate.xyz+4.*spe*vec3(1.);\n    \n    return lin*0.2;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nvec3 get_reflection(vec3 ro, vec3 rd, vec3 n)\n{\n    vec3 new_rd=reflect(rd,n);\n    ro+=0.1*n;\n    \n    acc1=0.;\n    float t=0.1;\n    for(int i=0;i<20;++i)\n    {\n        float d=core(ro+t*new_rd);\n        d*=rnd; t+=d;\n        if(d<0.1 || t>=FAR)\n            break;\n    }\n    vec3 col=vec3(0);\n    if(t<FAR)\n        col=acc1*0.1*lightcolor(rd.x);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n\n    rnd=hash12(fragCoord)*0.1+0.9;\n    \n    vec3 ro=vec3(0.,-1.,10.+cos(iTime));\n    vec3 ta=vec3(0.,1.,0.);\n    \n    ro.xz*=rot(.5*iTime); \n     // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n        ro=vec3(0.,0,-3)+vec3(cos(y_rot)*cos(x_rot),cos(y_rot)*cos(x_rot),cos(y_rot)*sin(x_rot))*12.;\n    \n    vec3 tot=vec3(0.0);\n    \n    vec3 rd;\n\n#if AA>1\n    for(int m=0; m<AA; m++)\n    for(int n=0; n<AA; n++)\n    {\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        p=(-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        p=(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        rd = cam(ro,ta)*normalize(vec3(p.xy,1.8));\n        vec3 col=vec3(0.);\n\n        float t=intersect(ro,rd);\n        if(t<FAR)\n        {\n            vec3 pos=ro+t*rd;\n            vec3 n=get_normal(pos);\n            col=lighting(ro,rd,n,pos);\n\t\t\t\n            if(obj>0)\n            {\n            float fre=0.04+(1.-0.04)*pow(1.-max(dot(n,-rd),0.),3.);\n            col+=fre*get_reflection(pos,rd,n);\n            }\n        }\n        \n      \tcol=mix(col,vec3(0.), 1.0-exp(-0.005*t*t)); \n\n        tot+=col;\n#if AA>1\n    }\n    tot/=float(AA*AA);\n    acc0/=float(AA*AA);\n#endif\n    \n    tot+=acc0*0.1*lightcolor(rd.x);\n    tot=tonemap(tot);\n    tot=pow(clamp(tot,0.,1.0),vec3(0.45));\n    tot=clamp(tot*0.5+0.5*tot*tot*1.3,0.0,1.0);\n    tot*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3W4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsc3WS", "name": "Reflection demo 1.0", "author": "livvy", "description": "Just trying out some really basic reflections with raymarching, phong shading, some basic sin/cos animation. It's not pretty but this took me some time to figure out. I had the formula for the phong shading model and some psudocode for the raymarcher. :)", "tags": ["raymarching", "phong", "animation"], "likes": 3, "viewed": 227, "date": "1569186845", "time_retrieved": "2024-06-20T19:45:13.272051", "image_code": "/*\n* Reflections demo 1.0\n*/\n\n//CONSTANTS\nconst float GAMMA = 2.2;\n\n// PRIMITIVES\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// SCENE\nvec2 map(vec3 p) {\n  vec3 p1 = p + vec3(-sin(iTime)*.5, 0.0, cos(iTime)*.5-1.3);\n  vec3 p2 = p + vec3(sin(iTime)*.5, 0.0, -cos(iTime)*.5-1.3);\n\n  float sphere1 = sdSphere(p1, 0.25);\n  float sphere2 = sdSphere(p2, 0.25);\n  \n  if (sphere1 < sphere2) {\n    return vec2(sphere1, 0);\n  } else {\n    return vec2(sphere2, 1);\n  }\n}\n\n\n// PHONG MATERIALS\n// Each material has an 'ID'.\n// Each function returns a particular phong component\nvec3 getAmbientColour(float m) {\n  switch(int(m)) {\n    case 0: return vec3(0.5, 0.0, 0.0);\n    case 1: return vec3(0.0, 0.0, 0.5);\n    default: vec3(0.0);\n  }\n}\n\nvec3 getDiffuseColour(float m) {\n    switch(int(m)) {\n      case 0: return vec3(1.0, 0.0, 0.0);\n      case 1: return vec3(0.0, 0.0, 1.0);\n      default: vec3(0.0);\n    }\n}\n\nvec3 getSpecularColour(float m) {\n    switch(int(m)) {\n      case 0: return vec3(1.0, 1.0, 1.0);\n      case 1: return vec3(1.0, 1.0, 1.0);\n      default: vec3(0.0);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  \n  // Calculate normalized 'uv' coordinates that run 0 to 1 but preserve aspect rati\n  //vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  //uv -= 0.5;\n  //uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  //uv = (gl_FragCoord.xy-v2Resolution.xy/2.) / v2Resolution.y;\n \n  // Ray origin (position of the eye/camera)\n  // The camera is moved along the Z-axis as our scene is at the origin by default\n  vec3 ro = vec3(0.0, 0.0, -2.0);\n  \n  \n  // Calulate ray direction\n  vec2 xy = gl_FragCoord.xy - iResolution.xy * .5;\n  float z = iResolution.y / tan(radians(45.0) * .5);\n  vec3 rd = normalize(vec3(xy,z));\n  \n  \n  // Set starting depth (this is the depth of the intersection plane)\n  float dep = 1.0;\n  bool hit = true;\n  float m;\n  // A higher number of iterations make for a more accurate raymarch at the expense\n  // of performance.\n  for (int i=0; i<96; i++)\n  {\n      // Get the current minimum distance to our scene from the ray origin)\n      vec2 o = map(ro + dep * rd);\n      float d = o.x;\n      m = o.y;\n    \n      // If we're suuuuueper close, finish marching\n      if (d < .001) break;\n    \n      // March forward the current minimum distance the the scene\n      dep += d;\n    \n      // If we go too far we're probably not going to hit the scene so we can stop.\n      // Setting the depth to 0 just helps us use bool() function to determine if we hit\n      // out scene. If it's anything other than 0, it's the depth we had to travel.\n      if (dep >= 100.0) {\n        hit=false;\n        break;\n      }\n  }\n \n\n  // Normal estimation\n  vec3 p = ro + (dep) * rd;\n  vec2 e = vec2(.001, 0.);\n  vec3 normal = normalize(vec3(\n      map(p+e.xyy).x - map(p-e.xyy).x,\n      map(p+e.yxy).x - map(p-e.yxy).x,\n      map(p+e.yyx).x - map(p-e.yyx).x\n  ));\n\n  // Phong time!\n  // Here, given an ambient lighting value, we'll calculate the colour value that we add based on\n  // the light position as well as diffuse, specular and alpha components.\n  const vec3 ambientLux = vec3(0.45);\n\n  \n  vec3 ka = getAmbientColour(m);\n  vec3 colour = ambientLux * ka;\n\n  // Take the ambient intensity and multiply by the ambient colour. This is a 'starting point'\n  // We shall add the diffuse and specular components on top, depending on p.\n  vec3 kd = getDiffuseColour(m);\n  vec3 ks = getSpecularColour(m);\n  float alpha = 600.0;\n  \n  // Now that we've set up the differnt phong component colours, we can actually calculate the\n  // diffuse and specular additions.\n  // L = Light direction vector\n  // V = 'View vector'\n  // R = 'reflection vector'\n  \n  \n  vec3 lightPos = vec3(0.1, 0.5, -0.5);\n  float lightInt = 0.6;\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(ro - p);\n  vec3 R = normalize(reflect(-L, normal));\n  \n  // Now we calculate some dot-products of the vectors above. Specifically:\n  // Dot-prod of light^normal\n  // Dor-prod of reflection^view\n  float dotLN = dot(L, normal);\n  float dotRV = dot(R, V);\n  \n  \n\n\n\n  // Now that we've set the colour of the object at first hit, we need to march again\n  // until we hit another object. We can then take the colour of that object and mix it\n  // with the first hit colour to get a 'reflection'\n\n  // Only do a second march if we hit the scene in the first\n  bool hit2=false;\n  if (bool(dep)) {\n    hit2 = true;\n    dep = 1.0;\n    for (int i=0; i<48; i++)\n    {\n      // We need to set the ray origin to equal R\n      vec2 o = map(p + dep * R);\n      float d = o.x;\n      m = o.y;\n   \n      // If we're suuuuueper close, finish marching\n      if (d < .001) break;\n\n      // March forward the current minimum distance the the scene\n      dep += d;\n\n      // If we go too far we're probably not going to hit the scene so we can stop.\n      // Setting the depth to 0 just helps us use bool() function to determine if we hit\n      // out scene. If it's anything other than 0, it's the depth we had to travel.\n      if (dep >= 100.0) {\n        hit2=false;\n        break;\n      }\n    }\n  }\n  \n  \n    \n  // If we hit another object again, go get the colour\n  if (hit2) {\n     kd += getDiffuseColour(m) * 3.0; \n  }\n  \n  // If the light is 'behind' the surface, we don't want to add any light\n  if (dotLN < 0.0) colour += vec3(0.0);\n  else if (dotRV < 0.0) colour += (lightInt * kd * dotLN);\n  else colour += lightInt * (kd * dotLN + ks * pow(dotRV, alpha));\n    \n  fragColor = vec4(pow(colour.rgb, vec3(1.0/GAMMA)), 1.0);\n\n  // If we hit the scene, draw colour, else black. At this point we would do lighting calculations\n  // and give what appears to be a '2D' object in our render some shadows.\n  if (bool(hit)) {\n      fragColor = vec4(colour, 1.0);\n  } else {\n      fragColor = vec4(vec3(0.0), 1.0);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsc3WS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsc3z2", "name": "Adjoint 2", "author": "remotion", "description": "based on https://www.shadertoy.com/view/3s33zj\n\nWe do not need to all the extra computation in adjoint function because mat4 is special and has some hard coded zeros and ones.\n\nUpdated: using cross version now.", "tags": ["3d", "normal", "transformation", "adjoint"], "likes": 3, "viewed": 227, "date": "1568838129", "time_retrieved": "2024-06-20T19:45:14.568938", "image_code": "// Inigo Quilez 2019\n// Remotion 2019\n\n// This shader shows how to use the adjoint matrix to\n// transform the normals of an object when the scale\n// is not uniform. The adjoint matrix is quicker to\n// compute than the traditional transpose(inverse(m)),\n// is more numerically stable, and does not break\n// when the matrix has negative determinant. The shader\n// uses spheres which have been deformed with non uniform\n// scales, to show the effect.\n\n\n// Compare methods:\n//\n// 0: n = adjoint(m)            --> correct\n// 1: n = transpose(inverse(m)) --> sometimes incorrect, and slow\n// 2: n = m                     --> always incorrect\n//\n#define METHOD 0\n\n//===================================================\n\n// Computes the lower 3x3 part of the adjoint.\n// Use to transform normals with arbitrary \n// matrices.The code assumes the last column of m is \n// [0,0,0,1]. More info here:\n// https://github.com/graphitemaster/normals_revisited\nmat3 adjoint( in mat4 m )\n{\n#if 1    \n    return mat3(cross(m[1].xyz, m[2].xyz), \n                cross(m[2].xyz, m[0].xyz), \n                cross(m[0].xyz, m[1].xyz));\n#else   \n\tfloat ax = m[0][0]; float ay = m[0][1]; float az = m[0][2];\n\tfloat bx = m[1][0]; float by = m[1][1]; float bz = m[1][2];\n\tfloat cx = m[2][0]; float cy = m[2][1]; float cz = m[2][2];\t         \n    return mat3( \n      (by * cz - bz * cy), -(bx * cz - bz * cx),  (bx * cy - by * cx),\n     -(ay * cz - az * cy),  (ax * cz - az * cx), -(ax * cy - ay * cx),\n      (ay * bz - az * by), -(ax * bz - az * bx),  (ax * by - ay * bx));\n#endif\n}\n\n#define tau 6.2831853072\n\n// sphere intersection\nfloat iSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    \n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\treturn (-b-sqrt(h))/a;\n}\n\n// sphere shadow\nfloat sSphere( in vec3 ro, in vec3 rd, in mat4 worldToObject )\n{\n\tvec3 roo = (worldToObject*vec4(ro,1.0)).xyz;\n    vec3 rdd = (worldToObject*vec4(rd,0.0)).xyz;\n    \n    float a = dot( rdd, rdd );\n\tfloat b = dot( roo, rdd );\n\tfloat c = dot( roo, roo ) - 1.0;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return -1.0;\n\n    return sign( h - b*b*sign(b) );\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotateAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( in vec3 v )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t v.x, v.y, v.z, 1.0 );\n}\n\nmat4 scale( in vec3 v )\n{\n    return mat4( v.x, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, v.y, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, v.z, 0.0,\n\t\t\t\t 0.0, 0.0, 0.0, 1.0 );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 getSphereToWorld( in int i, out bool isFlipped )\n{\n    float t = (length(iMouse.xy)<24.0) ? iTime*0.5 : tau * iMouse.y / iResolution.y;\n    vec3 fli = sign(sin(float(i)+vec3(1.0,2.0,3.0)));\n    mat4 rot = rotateAxisAngle( normalize(sin(float(11*i)+vec3(0.0,2.0,1.0))), 0.0+t*1.3 );\n    mat4 ros = rotateAxisAngle( normalize(sin(float( 7*i)+vec3(4.0,3.0,5.0))), 2.0+t*1.1 );\n    mat4 sca = scale( (0.3+0.25*sin(float(13*i)+vec3(0.0,1.0,4.0)+t*1.7))*fli );\n    mat4 tra = translate( vec3(0.0,0.5,0.0) + 0.5*sin(float(17*i)+vec3(2.0,5.0,3.0)+t*1.2) );\n    \n    isFlipped = (fli.x*fli.y*fli.z) < 0.0;\n    return ros * tra * sca * rot;\n}\n\nconst int kNumSpheres = 12;\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    for( int i=0; i<kNumSpheres; i++ )\n    {\n        bool tmp;\n        mat4 objectToWorld = getSphereToWorld( i, tmp );\n        mat4 worldToObject = inverse( objectToWorld );\n        if( sSphere( ro, rd, worldToObject ) > 0.0 )\n            return 0.0;\n    }\n    return 1.0;\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, \n            in float oid, in vec3 wnor )\n{\n    vec3 lig = normalize(vec3(-0.8,0.4,0.1));\n    vec3 wpos = ro + t*rd;\n\n    // material\n    vec3  mate = vec3(0.18);\n    if( oid>1.5 ) mate = 0.18*(0.55+0.45*cos(7.0*oid+vec3(0.0,2.0,4.0)));\n\n    // lighting\n    vec3 hal = normalize( lig-rd );\n    float dif = clamp( dot(wnor,lig), 0.0, 1.0 );\n    float sha = shadow( wpos+0.01*wnor, lig );\n    float fre = clamp(1.0+dot(rd,wnor),0.0,1.0);\n    float spe = clamp(dot(wnor,hal),0.0,1.0);\n\n    // material * lighting\t\t\n    vec3 col = vec3(0.0);\n    col += 8.0*vec3(1.00,0.90,0.80)*dif*sha;\n    col += 2.0*vec3(0.10,0.20,0.30)*(0.6+0.4*wnor.y);\n    col += 1.0*vec3(0.10,0.10,0.10)*(0.5-0.5*wnor.y);\n    col += fre*(0.6+0.4*wnor.y);\n    col *= mate;\n    col += pow(spe,16.0)*dif*sha*(0.1+0.9*fre);\n\n    // fog\n    col = mix( col, vec3(0.7,0.8,1.0), 1.0-exp( -0.003*t*t ) );\n\n    return col;\n}\n        \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = (length(iMouse.xy)<24.0) ? iTime * 0.4 : tau * iMouse.x / iResolution.x;\n\tvec3 ro = vec3( 2.5*cos(an), 0.7, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.2, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\n        // raytrace\n        float tmin = 1e10;\n        vec3  wnor = vec3(0.0);\n        float oid = 0.0;\n\n        // raytrace plane\n        float h = (-0.5-ro.y)/rd.y;\n        if( h>0.0 ) \n        { \n            tmin = h; \n            wnor = vec3(0.0,1.0,0.0); \n            vec3 wpos = ro+tmin*rd;\n            oid = 1.0;\n        }\n\n        // raytrace spheres\n        for( int i=0; i<kNumSpheres; i++ )\n        {\n            // location of sphere i\n            bool isFlipped = false;\n            mat4 objectToWorld = getSphereToWorld( i, isFlipped );\n            mat4 worldToObject = inverse( objectToWorld );\n\n            float res = iSphere( ro, rd, worldToObject );\n            if( res>0.0 && res<tmin )\n            {\n                tmin = res; \n                vec3 wpos = ro+tmin*rd;\n                vec3 opos = (worldToObject*vec4(wpos,1.0)).xyz;\n                vec3 onor = normalize(opos) *(isFlipped?-1.0:1.0);\n\n                #if METHOD==0 // CORRECT\n                wnor = normalize(adjoint(objectToWorld)*onor);\n                #endif\n                #if METHOD==1 // WRONG OFTEN\n                wnor = normalize((transpose(inverse(objectToWorld))*vec4(onor,0.0)).xyz);\n                #endif\n                #if METHOD==2 // WRONG ALWAYS\n                wnor = normalize((objectToWorld*vec4(onor,0.0)).xyz);\n                #endif\n\n                oid = 2.0 + float(i);\n            }\n        }\n\n        // shading/lighting\t\n        vec3 col = vec3(0.7,0.8,1.0);\n        if( oid>0.5 )\n        {\n            col = shade( ro, rd, tmin, oid, wnor );\n        }\n\n        col = pow( col, vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsc3z2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscGD8", "name": "Local Random Phasor Noise", "author": "H4w0", "description": "My take on Procedural Phasor Noise (Here: [url]https://hal.archives-ouvertes.fr/hal-02118508/document[/url]\nUsing the Regular grid formulation of Local Random Phase Noise.\n", "tags": ["procedural", "noise", "texture", "phasor"], "likes": 9, "viewed": 374, "date": "1568289984", "time_retrieved": "2024-06-20T19:45:15.490315", "image_code": "//=================================================================\n//= Local Random Phasor Noise \n//=================================================================\n//== Based on Siggraph 2019 paper : Procedural Phasor Noise \n//== From Tricard, Efremov, Zanni, Neyret, Martinez and Lefebvre\n//== https://hal.archives-ouvertes.fr/hal-02118508/document\n//=================================================================\n//== Phasor Noise in a regular grid, \n//== Getting rid of the gabor impulse process \n//== Author or Culprit : Arthur Cavalier\n//=================================================================\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- User Parameters -------------------------------------------------------------------------------------  \n#define MOUSE_CONTROL\n#define TIMER_OFFSET\nconst int   LRPN_COSINES     = 3;\nconst float LRPN_RESOLUTION  = 5.0;\nconst float LRPN_SLOPE_SCALE = 0.1;\nconst uint  LRPN_GLOBAL_SEED = 0u;\n\n//--------------------------------------------------------------------------------------------------------\n//-- Constants -------------------------------------------------------------------------------------------  \nconst float m_pi_2 = 1.5707963267;         \nconst float m_pi   = 3.1415926535;          \nconst float m_2_pi = 6.2831853071;  \n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Pseudo Random Number Generation ---------------------------------------------------------------------  \n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------  \nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\nfloat wave_square(float x)  {return PWM(x,0.5);}\nfloat wave_saw(float x)     {return mod(x,m_2_pi)/(m_2_pi);}\nfloat wave_sine(float x)    {return 0.5+0.5*sin(x);}\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Local Random Phase Noise ----------------------------------------------------------------------------\nvec4 local_random_phasor_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    vec4  lrpn   = vec4(0.);\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( (1.2*1.2)/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float d = dot(xy,xy);\n        \n        vec2  sum_of_cosines    = vec2(0.); \n        float sum_of_partial_x  = 0.; \n        float sum_of_partial_y  = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            vec2  sc = vec2( cos(ff+ph), sin(ff+ph) ); \n\n            sum_of_cosines   += sc;\n            sum_of_partial_x += -m_2_pi * fr * cos(or) * sc.y;\n            sum_of_partial_y += -m_2_pi * fr * sin(or) * sc.y; \n        }\n\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * vec4(sum_of_cosines, sum_of_partial_x, sum_of_partial_y);\n    }\n    return vec4(lrpn); // vec3(Cosines, Sines, Partial X, Partial Y); \n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Utils -----------------------------------------------------------------------------------------------\nfloat looped_smooth_stairs(float t, float ratio, float nof_values)\n{\n    t*= nof_values;\n    return mix(floor(mod(t/ratio, nof_values)), floor(mod((t+1.)/ratio, nof_values)), smoothstep(0.0, 1.0, fract(t)));\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcoords = fragCoord.xy / iResolution.xy;\n    vec2 texcoords = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n\n    vec2  F = vec2(0.4,0.5);        //~ Frequecy range [fmin;fmax]\n    vec2  O = vec2(0.,m_pi / 6.);   //~ Orientation range [omin;omax]\n    float R = LRPN_RESOLUTION;      //~ Grid resolution\n    int   K = LRPN_COSINES;         //~ Number of cosines\n\n#ifdef TIMER_OFFSET\n    texcoords += vec2(0.1*iTime);\n#endif\n\n#ifdef MOUSE_CONTROL\n    F = vec2(0.3, max(0.3,mouse.x) ); \n    O = vec2(0.,mouse.y*m_pi);    \n#endif\n\n\n    vec4  lrpn = local_random_phasor_noise(texcoords,R,K,F,O);\n    float Sc = lrpn.x;\n    float Ss = lrpn.y;\n    float Dx = lrpn.z * LRPN_SLOPE_SCALE;\n    float Dy = lrpn.w * LRPN_SLOPE_SCALE;\n\n    float Phi = atan(Ss,Sc);\n\n\n    if(pixcoords.x < 0.33)\n        fragColor.rgb = vec3(0.5+0.5*Sc);\n    else if(pixcoords.x < 0.66)\n        fragColor.rgb = normal_map_from_slope(Dx,Dy);\n    else \n    {\n        float Weight = looped_smooth_stairs(iTime,4.,3.);\n        float Phasor = max(1.-abs(Weight-0.),0.) * wave_sine(Phi)\n                        + max(1.-abs(Weight-1.),0.) * wave_saw(Phi)\n                        + max(1.-abs(Weight-2.),0.) * wave_square(Phi);\n        fragColor.rgb = vec3( Phasor );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscGD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscGWH", "name": "rotating crosses 2 (remix)", "author": "mathmasterzach", "description": "A remix of FabriceNeyret2's shader now with swapping active crosses: https://www.shadertoy.com/view/wd33R7", "tags": ["remix", "tiling", "cross", "golf"], "likes": 8, "viewed": 369, "date": "1568299925", "time_retrieved": "2024-06-20T19:45:15.490315", "image_code": "//Fork of FabriceNeyret2's brilliant shader: https://www.shadertoy.com/view/wd33R7\n//This version swaps between which crosses are rotating(black/white)\n//Most of this code was written by FabriceNeyret (https://www.shadertoy.com/user/FabriceNeyret2)\n//I have identified the lines of code that I added:\n//I also have replaced trig estimations with high precision values\n\n#define R     (iResolution.xy)\n#define S(v)   smoothstep( 13./R.y , -13./R.y, v )\n#define rot(a) mat2(cos( a + vec4(0,33,11,0) ))       //from https://www.shadertoy.com/view/XlsyWX\nfloat t = acos(-1.)/4., s;\n\nfloat draw(vec2 U, float r) {               \n    U = 3.*(fract(U)-.5) *s;\n    vec2 A = abs( U * rot( iTime +atan(.5)*r ) );\n    return S( max(A.x,A.y) - 1.5 ) * S( min(A.x,A.y) - .5 );\n}\n    \nvoid mainImage( out vec4 O, vec2 U ) {\n    float f=float(fract((iTime/acos(-1.))-.5*atan(.5))>.5);//Added by me\n    O-=O;\n    U = 2.7* (U+U-R)/R.y * rot(atan(.5));               \n    U /= s = 1.6* ( 1.+ max( abs(sin(t+=iTime)) ,abs(cos(t)) ) - .707 ); \n    U-=.25*f;//Added by me\n    O += draw(U,-1.); U+=.5; O += draw(U,-1.);\n    U.x = .5-U.x;\n    O += draw(U, 1.); U+=.5; O += draw(U, 1.);\n    O = abs(f-O);//Added by me\n    O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscGWl", "name": "Pixelated RGB with shadows", "author": "reyemxela", "description": "I made this to use as a wallpaper for my Android phone, using Shader Editor on the play store.\nIt's evolved over time, starting as just a simple RGB wave, to being pixelated, then with varying brightness for each cell, and finally adding in the \"shadows\"", "tags": ["pixel", "rgb"], "likes": 24, "viewed": 332, "date": "1569507448", "time_retrieved": "2024-06-20T19:45:15.751035", "image_code": "float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); } // random noise\n\nfloat getCellBright(vec2 id) {\n    return sin((iTime+2.)*rand(id)*2.)*.5+.5; // returns 0. to 1.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / mx;\n    \n    float time = iTime*.5;\n    \n    uv *= 30.; // grid size\n\n\tvec2 id = floor(uv); // id numbers for each \"cell\"\n    vec2 gv = fract(uv)-.5; // uv within each cell, from -.5 to .5\n\n\tvec3 color = vec3(0.);\n    \n\tfloat randBright = getCellBright(id);\n    \n    vec3 colorShift = vec3(rand(id)*.1); // subtle random color offset per \"cell\"\n    \n    color = 0.6 + 0.5*cos(time + (id.xyx*.1) + vec3(4,2,1) + colorShift); // RGB with color offset\n    \n    float shadow = 0.;\n    shadow += smoothstep(.0, .7,  gv.x*min(0., (getCellBright(vec2(id.x-1., id.y)) - getCellBright(id)))); // left shadow\n    shadow += smoothstep(.0, .7, -gv.y*min(0., (getCellBright(vec2(id.x, id.y+1.)) - getCellBright(id)))); // top shadow\n    \n    color -= shadow*.4;\n    \n    color *= 1. - (randBright*.2);\n    \n\tfragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wscGz8", "name": "MandelbrotJulia Relationship", "author": "harry7557558", "description": "Relationship between Mandelbrot and Julia set: the red dot in the Mandelbrot set represents c, where Julia set is defined by zz+c. ", "tags": ["fractal", "complex", "iteration"], "likes": 3, "viewed": 66, "date": "1567813560", "time_retrieved": "2024-06-20T19:45:15.757040", "image_code": "#define AA 2\n#define MAX_ITER 1024\n\nvec3 colorf(float n) {\n    float m = 5.0*sin(0.1*(n-6.0))+n;\n    return vec3(\n        pow(sin(0.05*(m-8.0)),6.0),\n        pow(sin(0.05*(m+1.0)),4.0),\n        (0.8*pow(sin(0.05*(m+2.0)),2.0)+0.2)*(1.0-pow(abs(sin(0.05*(m-14.0))),12.0))\n    );\n}\n\nvec3 Iter(vec2 z, vec2 c)\n{\n    for (int i=0;i<MAX_ITER;i++){\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y)+c;\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(0.5*log2(h))+4.0;\n            return colorf(n);\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = length(iResolution);\n    float m = 7.0/d, s = 0.06*d;\n    vec2 b = iResolution.xy-sqrt(iResolution.xy*vec2(s));\n    \n    vec2 c = abs(asin(sin(0.017*iTime)))*vec2(cos(iTime)-0.4,0.8*sin(iTime));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n            vec2 p = fragCoord+vec2(u,v)/float(AA);\n            float sd = max(b.x-p.x,b.y-p.y);\n            if (abs(sd)<0.04*s)  // red border\n                col+=vec3(1.0,0.0,0.0);\n            else if (sd<0.0){  // Mandelbrot\n                p = 2.75*(p-b);\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                if (length(z-c)<0.06) col+=vec3(1.0,0.0,0.0);  // red dot\n                else col += Iter(vec2(0.0),z);\n            }\n            else{  // Julia\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                col += Iter(z, c);\n            }\n        }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wscGz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscGzf", "name": "Shader Showdown Nova-19 Round 1", "author": "evvvvil", "description": "Winning shader made at NOVA 2019 Shader Showdown. First round against LovelyHannibal / Amnesty. Live coded on stage in 25 minutes.\nVideo of the battle: https://youtu.be/xegAFqulK8I?t=319", "tags": ["demoscene", "abstract", "glow", "vortex", "live", "neon", "battle", "shadershowdown", "nova", "industrial"], "likes": 6, "viewed": 482, "date": "1568983635", "time_retrieved": "2024-06-20T19:45:16.211544", "image_code": "// Winning shader made at Nova 2019 Shader Showdown,\n// First round round against LovelyHannibal / Amnesty\n// Video of the battle: https://youtu.be/xegAFqulK8I?t=319\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"It turns out that if you bang 2 halves of a horse together, it does not make the sound of a coconut.\" Sir Ken Dodd\n\nvec2 s,e=vec2(.00035,-.00035);float t,tt,att,g,f;vec3 np;\n#define pi acos(-1.)\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb( vec3 p)\n{\n    vec2 h,t=vec2(bo(abs(p)-vec3(3,0,0),vec3(1)),3);\n    t.x=min(bo(p,vec3(3,.5,.5)),t.x);\n    h=vec2(bo(abs(abs(p)-vec3(3,0,0))-vec3(.4,0,.4),vec3(.3,1.2,.3)),5);\n    h.x=min(bo(abs(p)-vec3(1,0,0),vec3(.1,100,.1)),h.x);\n    h.x=min(length(p-vec3(0,att*.3,0))-2.5,h.x);\n    t=t.x<h.x?t:h;\n    h=vec2(bo(p,vec3(10,.3,.7)),6);\n    t=t.x<h.x?t:h;\n    p.xz*=r2(pi/2.+sin(tt)*pi);\n    h=vec2(bo(abs(p)-vec3(2,2,0),vec3(10,0,0)),6);\n    g+=0.1/(0.1+h.x*h.x*10.);\n    t=t.x<h.x?t:h;\n    t.x*=.5;  \n    return t;\n}\nvec2 mp( vec3 p)\n{\n    p.yz*=r2(sin(p.x*.1+tt)*.75);\n    np=p;\n    np.x=mod(np.x-tt*5.,10.)-5.;\n    att=min(length(p)-(10.+f*6.),15.);\n    for(int i=0;i<6;i++){\n        np=abs(np)-vec3(2,2,0)-att*.3;\n        np.xz*=r2(.3-att*.02);\n    }\n    vec2 h,t=fb(np);\n    h=vec2(.7*bo(p,vec3(1,100,1)),6);\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 tr( vec3 ro, vec3 rd)\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(t.x<.0001||t.x>70.) break;\n        t.x+=h.x;t.y=h.y;    \n    }\n    if(t.x>70.) t.x=0.;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv -= 0.5;uv/=vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime*.6,37.7);\n    //f=abs(sin(tt))*texelFetch( iChannel1, ivec2(200,0), 0 ).x; \n    vec3 ro=vec3(10,cos(tt)*10.,sin(tt)*40.),\n        cw=normalize(vec3(0)-ro),\n        cu=normalize(cross(cw,vec3(0,1,0))),\n        cv=normalize(cross(cu,cw)),\n        rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,ld=normalize(vec3(.1,.3,-.1));\n    co=fo=vec3(.5)*(1.-(length(uv)-.4));\n    s=tr(ro,rd);t=s.x;\n    if(t>0.){\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x),\n            al=vec3(1,.5,0);\n        if(s.y<5.) al=vec3(0);\n        if(s.y>5.) al=vec3(1);\n        float dif=max(0.,dot(no,ld)),aor=t/50.,ao=exp2(-2.*pow(max(0.,1.-mp(po+no*aor).x/aor),2.)),\n            spo=exp2(5.*texture(iChannel0,vec2(np.y,dot(np.xz,vec2(0.7)))/vec2(16,20)).r),\n            fr=pow(1.+dot(no,rd),4.),\n            sss=0.5+smoothstep(0.,1.,mp(po+ld*.4).x/.4),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);    \n        co=mix(sp+al*(.2+ao)*(dif+sss),fo,min(fr,.5));\n        co=mix(co,fo,1.-exp(-.00002*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.3*vec3(.2,.3,.9),vec3(.45)),1);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WscGzj", "name": "QuadDamage", "author": "dila", "description": "\"Inspired\" by one of the maps in Quake3 Arena. You can see the reference screenshot here https://i.imgur.com/23JQqr1.png", "tags": ["raymarch", "quake"], "likes": 12, "viewed": 239, "date": "1568837767", "time_retrieved": "2024-06-20T19:45:16.217645", "image_code": "mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p) - d;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat top(vec3 p) {\n    p.y -= 2.0;\n    p.z = abs(p.z) - 0.2;\n    float b = box(p, vec3(3.0, 3.0, 0.1));\n    vec3 ap = vec3(abs(p.x) - 1.0, p.y, p.z);\n    b = max(b, dot(ap, normalize(vec3(1.0, -1.0, 0.0))) + 1.0);\n    b = max(b, dot(ap, normalize(vec3(0.0, -1.0, 0.0))) + 1.0);\n    b = min(b, length(p.xy - vec2(0.0, 2.0)) - 0.125);\n    return b;\n}\n\nfloat swing(vec3 p) {\n    p.x = abs(p.x) - 0.1;\n    float b = box(p, vec3(1.7, 3.5, 0.1));\n    p.y += 0.5;\n    float c = 1000.0;\n    c = min(c, dot(p, normalize(vec3(-0.15, -1.0, 0.0))) - 0.0);\n    c = min(c, dot(p, normalize(vec3(1.0, 0.15, 0.0))) - 0.2);\n    b = max(b, c);\n    b = max(b, dot(p, normalize(vec3(0.0, -1.0, 0.0))) - 1.4);\n    float e = 1000.0;\n    e = min(e, dot(p, normalize(vec3(-0.15, 1.0, 0.0))) - 0.6);\n    e = min(e, dot(p, normalize(vec3(1.0, -0.05, 0.0))) - 0.2);\n    b = max(b, e);\n    return b;\n}\n\nfloat wallbox(vec3 p, vec3 d) {\n    vec3 q = abs(p) - d;\n    return max(q.x, q.z);\n}\n\nfloat wall(vec3 p) {\n    float b = wallbox(p - vec3(3.0, 0.0, 0.0), vec3(4.0, 5.0, 1.3));\n    float c = 1000.0;\n    c = min(c, dot(p, normalize(vec3(-1.0, 0.4, 0.0))) + 1.2);\n    c = min(c, dot(p, normalize(vec3(-0.5, -0.5, 0.0))) + 1.0);\n    c = min(c, dot(p, normalize(vec3(0.0, -1.0, 0.0))) + 2.0);\n    c = min(c, dot(p, normalize(vec3(-1.0, 0.0, 0.0))) + 0.5);\n    b = max(b, c);\n    return b;\n}\n\nvec3 mapp = vec3(0.0);\nfloat mapmat = 0.0;\n\nfloat map(vec3 p) {\n    mapmat = 0.0;\n    mapp = p;\n    float nz = floor(p.z / 3.0 + 0.5);\n    float pz = (fract(p.z / 3.0) - 0.5) * 3.0;\n    float qz = (fract(p.z / 3.0 + 0.5) - 0.5) * 3.0;\n    float ww = max(abs(p.x) - 0.35, p.y + 2.0);\n\tfloat w = wall(vec3(abs(p.x) - 2.5, p.y, pz));\n    float d = w;\n    if (ww < d) {\n        d = ww;\n        mapmat = 3.0;\n    }\n    float t = top(vec3(p.x, p.y, qz));\n    if (t < d) {\n        mapmat = 2.0;\n        d = t;\n    }\n    for (int i = -1; i <= 1; ++i) {\n        float qzi = qz + float(i) * 3.0;\n        float nzi = nz - float(i);\n        vec3 rp = vec3(p.x, p.y, qzi);\n        p.y -= 3.5;\n        float st = 3.141592 * 0.75 + iTime * 3.141592 * 0.5;\n    \tp.xy *= rot(cos(st + nzi * 3.141592 / 4.0));\n    \tp.y += 3.5;\n    \tfloat s = swing(rp);\n        if (s < d) {\n            mapp = rp + vec3(0.0, 0.0, nzi);\n            d = s;\n            mapmat = 1.0;\n        }\n    }\n    return d;\n}\n\nvec3 normal(vec3 p) {\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n  float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 tex3(sampler2D channel, vec3 p) {\n    vec3 ta = texture(channel, p.yz).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.xy).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvec4 surf(vec3 r, vec3 w, vec3 sn)\n{\n    vec3 from = vec3(0.8, 0.2, 0.1);\n    vec3 to = vec3(1.0, 1.0, 1.0);\n    float prod = max(dot(sn,-r), 0.0);\n    float off = 0.5 + 0.5 * sin(tex3(iChannel1, w).x*3.141592*5.0);\n    return vec4(mix(from, to, 1.0 - pow(off, 4.0)), off);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 fuv = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 0.7));\n    vec3 o = vec3(0.5, -1.0, iTime * 2.0);\n    \n    r.yz *= rot(0.2);\n    r.xz *= rot(-0.3);\n    \n    float t = trace(o, r);\n    vec3 wuv = mapp;\n    float mat = mapmat;\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    \n    vec3 lpos = o + vec3(0.2, 1.0, -0.5);\n    vec3 ldel = w - lpos + sn * 0.01;\n    float len = length(ldel);\n    ldel /= len;\n    float lt = trace(lpos, ldel);\n    float lit = max(dot(ldel, -sn), 0.0);\n    if (lt < len) {\n        lit = 0.0;\n    }\n    \n    vec3 tex = tex3(iChannel0, wuv);\n    vec3 s = mix(tex, tex * surf(r, wuv * 0.05 - vec3(0.0, 0.125, 0.0), sn).xyz, 8.0);\n    \n    float wallmat = 1.0 - abs(sign(mat - 0.0));\n    float crossmat = 1.0 - abs(sign(mat - 1.0));\n    float topmat = 1.0 - abs(sign(mat - 2.0));\n    float walkmat = 1.0 - abs(sign(mat - 3.0));\n    \n    vec3 fc = mix(tex, s * vec3(0.75, 0.25, 0.25), crossmat);\n    fc = mix(fc, s, walkmat);\n    fc = mix(fc, s, topmat);\n    fc = mix(fc, s, wallmat);\n    \n    fc *= 1.0 / (1.0 + max(-1.0-wuv.y, 0.0) * 0.5);\n    fc *= 1.0 / (1.0 + max(-3.0+wuv.y, 0.0) * 2.0);\n    fc *= 1.0 / (1.0 + max(abs(wuv.x) - 3.0, 0.0) * 1.0);\n    \n    fc *= lit;\n    \n    float wuy = 1.0 / (1.0 + t * t * 0.01);\n    fc = mix(fc, vec3(1.0, 0.5, 0.25), 1.0 - wuy);\n    \n    fc *= pow(max(1.0 - max(abs(fuv.x), abs(fuv.y)), 0.0), 0.5);\n\n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WscGzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsd3D8", "name": "TransparentRaymarching(Additive)", "author": "Torumu106", "description": "Same as the title.", "tags": ["raymarching", "transparent"], "likes": 2, "viewed": 77, "date": "1568794688", "time_retrieved": "2024-06-20T19:45:16.217645", "image_code": "const int arraysize = 2;\nconst float loaddist =10.0;\nstruct solid\n{\n\tvec4 color;\n    float dist;\n    float thick;\n};\nvoid Sort(inout solid first[arraysize]){\n    int size = arraysize;\n    // \n    for (int i=1; i<size; ++i){\n        int j = i; // \n        // \n        while (j > 0){\n            if (first[(j-1)/2].dist < first[j].dist){\n                solid w = first[(j-1)/2];\n                first[(j-1)/2] = first[j];\n                first[j] = w;\n               j = (j-1)/2;\n            } else {\n               break;\n            } \n        }\n    }\n\n    for (int i=size-1; i>0; --i) {\n        solid w = first[0];\n        first[0] = first[i];\n        first[i] = w; // \n        int j = 0;\n        int k = 0;\n        // \n        while(true){\n            int left = 2*j + 1;\n            int right = 2*j + 2;\n            if (left >= i) break;\n            if (first[left].dist > first[k].dist) k = left;\n            if ((right < i) && (first[right].dist > first[k].dist)) k = right;\n            if (k == j) break;\n            solid w = first[k];\n            first[k] = first[j];\n            first[j] = w;\n            j = k;\n        }\n    }\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat map(vec3 p, int num){\n    //float d = length(p-vec3(0.0,0.0,1.0)) - 0.25;\n    float d =  loaddist;\n    if(num == 0){\n        d = sdBox(p - vec3(0.0,0.0,0.2), vec3(0.3,0.3,0.3));\n    }\n    if(num == 1){\n        d = sdBox(p - vec3(0.2,0.05,-0.4), vec3(0.2,0.15,0.2));\n    }\n\treturn d;\n}\nfloat trace(vec3 o, vec3 r, int num){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n    \tvec3 p = o + r * t;\n        float d = map(p, num);\n        t += d * 0.5;\n    }\n    return t;\n}\nvec4 col = vec4(1.0,1.0,1.0,1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv1 = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec4 fc = vec4(0.0, 0.0, 0.0, 0.0);\n    solid solids[arraysize];\n    solids[0].color = vec4(1.0, 0.0, 1.0, 0.8);\n    solids[1].color = vec4(0.0, 1.0, 1.0, 0.7);\n    \n    for(int i = 0; i < arraysize; i++){\n    \tvec3 o = vec3(-1.0* sin(-the), 0.0, -1.0 * cos(-the));\n    \tfloat t = trace(o, r, i);\n        solids[i].dist = t;\n    \tsolids[i].thick = trace(o+r*loaddist, -r, i);\n    \tsolids[i].thick = loaddist - t - solids[i].thick;\n        solids[i].thick=max(solids[i].thick,0.0);\n    }\n    Sort(solids);\n    for(int i = 0; i < arraysize; i++){\n    \tif(solids[i].thick!=0.0){\n    \t\tsolids[i].thick += 0.5;\n    \t\tcol = solids[i].color;\n        \tfloat fog = 1.0 - pow(col.w,solids[i].thick);\n            vec3 col3 = fc.rgb * fc.w + col.rgb * (1.0 - fc.w) * fog;\n    \t\tfc = vec4(col3, fc.w + (1.0 - fc.w) * fog);\n            fc.rgb /= fc.w;\n    \t}\n    }\n    vec3 col3 = fc.rgb * fc.w + vec3(0.2) * (1.0 - fc.w);\n    fc = vec4(col3, 1.0);\n\tfragColor = vec4(fc);\n    \n    //solid test[arraysize];\n    //test[0].color = vec4(1.0, 0.0, 0.0, 1.0);\n    //test[1].color = vec4(0.0, 1.0, 0.0, 1.0);\n    //test[0].dist = 2.0;\n    //test[1].dist = 1.0;\n    //Sort(test);\n    //fragColor = test[0].color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsd3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3Dr", "name": "Checkerboard Assembly - 273ch", "author": "mathmasterzach", "description": "A fun little idea I had the other day. Try to golf it lower if you can.", "tags": ["animated", "checkerboard", "monochrome", "2tweets", "tiles", "golf", "escherlike"], "likes": 30, "viewed": 490, "date": "1568298326", "time_retrieved": "2024-06-20T19:45:16.217645", "image_code": "//FabriceNeyret2, iapafoto, and I reduce it down to 273 characters! Fits in 2 Tweets!\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2 R = iResolution.xy,\n         p = 9.5* (U+U-R)/R.x,  S = sign(p),\n         n = .25-S.xx/4.,\n         t = .5*iTime + n ,\n         s = vec2( 0, round(p-t)+t )*.1,\n         c = p - p*s*s,\n         r = abs( ( fract( c - vec2(t.x-.5,n) ) -.5 )\n                  * vec3( 1, p/c ).xz\n                  * mat2( cos( vec4(0,11,33,0)\n                           -S.x*(3.*s*s*(ceil(c-n)+n-.5)).y )));\n    O += .5 + ( (r+r.y-.5) *R/S/40. ).x;\n}\n/*\n\n//360 characters of complete mess\n//If you have any questions about how this works feel free to ask\n//Original 360 character version\n/*#define mainImage(O,U)\\\n\tvec2 R=iResolution.xy,\\\n    \t p=9.5*(U+U-R)/R.x,\\\n         n=.5*vec2(p.x<0.,iTime),\\\n         s=vec2(0.,round(p.x-fract(n.y+n.x))+fract(n.y+n.x))/10.,\\\n         c=p*(vec2(1.)-s*s),\\\n         q=fract((c+.5-n.x)-vec2(n.y,.5))-.5,\\\n         a=vec2(3.*s.y*s.y*(floor(c.y+n.x)+.5-n.x)*-sign(p.x),q.y/=(c.y/p.y)),\\\n    \t r=abs(q*mat2(cos(a.x),sin(a.x),-sin(a.x),cos(a.x)));\\\n    O+=abs(2.*n.x-smoothstep(.49,.51,r.x+r.y))*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3Dr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3DS", "name": "The Light", "author": "chunza2542", "description": "My first shader.", "tags": ["basic", "light", "circle", "easy", "first", "chun"], "likes": 3, "viewed": 265, "date": "1569226939", "time_retrieved": "2024-06-20T19:45:16.217645", "image_code": "float map(vec3 p) {\n    vec3 q = fract(p) * 2.0 - 1.0;\n \treturn length(q) - 0.40;\n}\n\nfloat trace(vec3 origin, vec3 ray) {\n    float t = 0.0;\n    for (int i = 0; i < 20; ++i) {\n     \tvec3 p = origin + ray * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    // Transform Coordinate to -1 to 1\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, 0.0, iTime);\n    \n    float the = iTime * .1;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    float t = trace(o, r);\n    float fog = 1.0 / (1.0 + 0.1 * t * t);\n    \n    vec3 fc = vec3(fog, 0.5 + 0.7 * sin(iTime * .25), 0.7 + 0.5 * sin(iTime * .25));\n \n    fragColor = vec4(fc, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3DS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsd3R7", "name": "rotating oriental pattern 2", "author": "FabriceNeyret2", "description": "6-branches crosses contra-rotative along a checker grid.", "tags": ["pattern", "tiling", "cross", "2tweets", "gif", "short", "golf", "islamic", "reproduction"], "likes": 5, "viewed": 279, "date": "1568133603", "time_retrieved": "2024-06-20T19:45:16.332768", "image_code": "// Fork of  https://shadertoy.com/view/wd3GR7   \n// funny: ceil(U) instead of floor create artifacts at some resolutions\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = 3.* (u+u-R)/R.y, A = mod(floor(U),2.);\n    A = abs( 3.1*(fract(U)-.5) * mat2(cos(vec4(0,33,11,0) +(A.x==A.y?1.:-1.)*iTime))),\n    O += clamp( .5 - ( min(abs(.9*A-.5*A.x),A.x) -.2 ) /30. *R , 0., 1. ).y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsd3R7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3W8", "name": "This Is Not A Reflected Pipe", "author": "dr2", "description": "Smokers' delight (mouseable)", "tags": ["symmetry", "magritte", "relection"], "likes": 14, "viewed": 349, "date": "1568375835", "time_retrieved": "2024-06-20T19:45:18.290391", "image_code": "// \"This Is Not A Reflected Pipe\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"This Is Not A Pipe\" and \"Inside Reflective Polyhedra\"\n\n#define AA  1  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, vc, pMid, vp[3];\nfloat tCur, dstFar, szFac;\nint idObj, pType;\nconst int idFace = 1, idEdge = 2, idPipe = 3, idCoal = 4;\nconst float pi = 3.14159;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PInit ()\n{\n  vec3 c;\n  float cp, sp;\n  c = vec3 (0., 1., 0.);\n  pType = 5;\n  cp = cos (pi / float (pType));\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  vp[0] = vec3 (0., 0., 1.);\n  vp[1] = vec3 (sp, 0., 0.5);\n  vp[2] = vec3 (0., sp, cp);\n  pMid = (length (c) > 0.) ? normalize ((c.x * vp[0] + c.y * vp[1] + c.z * vp[2])) : vec3 (0.);\n  vp[1] = normalize (vp[1]);\n  vp[2] = normalize (vp[2]);\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat PipeDist (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 rp;\n  float d;\n  dMin /= szFac;\n  p /= szFac;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (PrCapsAnDf (q.xzy, 0.55, 0.06, 0.25), q.y - 0.5, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = 0.5 * SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  DMIN (idPipe);\n  q = p;\n  q.y -= 0.3 + 0.03 * Noisefv2 (32. * q.xz);\n  d = PrCylDf (q.xzy, 0.5, 0.01);\n  DMIN (idCoal);\n  return szFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, dv;\n  float dMin, d;\n  dMin = dstFar;\n  dMin = PipeDist (p, dMin);\n  for (int k = 0; k < 5; k ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n    //if (k == pType - 1) break;\n  }\n  q = p - pMid;\n  dv = vec3 (dot (q, vp[0]), dot (q, vp[1]), dot (q, vp[2]));\n  d = - Maxv3 (dv);\n  DMIN (idFace);\n  dv = vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc));\n  d = Minv3 (dv) - 0.015;\n  DMIN (idEdge);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat PipeSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = PipeDist (ro + d * rd, dstFar);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, q;\n  float dstObj, nDotL, sh;\n  int nRef;\n  const int maxRef = 5;\n  szFac = 0.2;\n  bgCol = vec3 (0.2, 0.2, 0.3);\n  col = bgCol;\n  dstObj = ObjRay (ro, rd);\n  nRef = 0;\n  for (int k = VAR_ZERO; k < maxRef; k ++) {\n    if (dstObj < dstFar && idObj == idFace) {\n      ro += dstObj * rd;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.001 * rd;\n      dstObj = ObjRay (ro, rd);\n      nRef = k + 1;\n    } else break;\n  }\n  if (dstObj < dstFar && idObj != idFace) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idEdge) {\n      col = vec3 (0.75, 0.75, 0.95);\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = col * (0.2 + 0.8 * nDotL) +\n         0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    } else {\n      q = ro / szFac;\n      if (idObj == idPipe) {\n        q.xy -= vec2 (0.4);\n        q.xy = Rot2D (q.xy, -0.2 * pi);\n        if (q.x < -0.03) vn = VaryNf (16. * q, vn, 0.1);\n        col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.),\n           0.5 * Fbm3 (4. * q)) : vec3 (0.1), vec3 (0.7, 0.6, 0.),\n           SmoothBump (-0.03, 0.03, 0.01, q.x));\n        sh = PipeSShadow (ro, ltDir);\n        col = col * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) +\n           0.8 * sh * max (dot (vn, ltDir), 0.)) +\n           0.3 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n      } else if (idObj == idCoal) {\n        col = mix (vec3 (1., 0.2, 0.) * (0.2 + 0.8 * smoothstep (0.1, 1.5, Fbm1 (0.5 * tCur))),\n           vec3 (0.1, 0., 0.), Fbm2 (32. * q.xz));\n      }\n    }\n    col = mix (bgCol, col, pow (0.95, 10. * float (nRef) / float (maxRef)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az = 2. * pi * sin (0.05 * tCur);\n    el = -0.3 * pi * cos (0.2 * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -0.7);\n  zmFac = 2.;\n  dstFar = 10.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n  PInit ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (length (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - length (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3W8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3WH", "name": "cool abstract thing", "author": "mat44", "description": "something", "tags": ["abstract"], "likes": 2, "viewed": 281, "date": "1568391446", "time_retrieved": "2024-06-20T19:45:18.290642", "image_code": "vec3 hsl2rgb(vec3 hsl) {\n    float H = hsl.x * 360.;\n    float S = hsl.y;\n    float L = hsl.z;\n    \n    float c = (1. - abs(2.*L - 1.)) * S;\n    float x = c * (1. - abs(mod(H / 60., 2.) - 1.));\n    float m = L - c / 2.;\n    \n    vec3 rgb;\n    if (H < 60.) {\n        rgb = vec3(c, x, 0.);\n    } else if (H < 120.) {\n     \trgb = vec3(x, c, 0.);\n    } else if (H < 180.) {\n     \trgb = vec3(0., c, x);\n    } else if (H < 240.) {\n        rgb = vec3(0., x, c);\n    } else if (H < 300.) {\n     \trgb = vec3(x, 0., c);   \n    } else {\n     \trgb = vec3(c, 0., x);   \n    }\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy ) / iResolution.y;\n\t\n    uv.x += sin(uv.y*10.0 + iTime)/20.0;\n\n    // float col = max(uv.x * uv.x, uv.y * uv.y);\n    float col = uv.x * uv.x + uv.y * uv.y;\n    \n    float stripes = iMouse.x/iResolution.x*10.0;\n    if (iMouse.x == 0.0) stripes = 10.0;\n    col = floor(col*stripes*2.0)/stripes;\n    \n    fragColor = vec4(hsl2rgb(vec3(fract(col), 1.0, 0.5)), 1.0);\n    //fragColor = vec4(vec3(fract(col)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3WH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsd3zH", "name": "Grid_", "author": "xiahogzhi", "description": "Grid", "tags": ["grid"], "likes": 3, "viewed": 260, "date": "1567848901", "time_retrieved": "2024-06-20T19:45:18.290642", "image_code": "float GetGrid(vec2 uv){\n    \n    int flag = int(floor(iTime * 0.5)) % 2;\n    float time = fract(iTime*0.5);\n    \n    int invertFlag = (flag -1) * -1;\n    \n\tint tx =  (int(fract(uv.x)*10.0) % 2) * 2 -1;\n    \n    \n    int vy = int(fract(uv.y + time * float(invertFlag) * float(tx))*10.0);\n    \n    \n    int ty = (vy % 2) * 2 - 1;\n    \n    int vx = int(fract(uv.x + time * float(flag) * float(ty))*10.0);\n    \n    \n\treturn float((vx  + vy) % 2);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) /iResolution.y;\n\n\tfloat c = GetGrid(uv);\n    \n    // Output to screen\n    fragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsd3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3zM", "name": "CodebaseAlpha 2", "author": "codebasealpha", "description": "The second shader created live on-stream at https://twitch.tv/codebasealpa as part of the Introduction to Shaders series of streams.", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 319, "date": "1568100593", "time_retrieved": "2024-06-20T19:45:18.290642", "image_code": "float sdSphere(in vec3 p, in float r)\n{\n  return length(p) - r;\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y, p.z));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc, length(max(di, 0.0)));\n}\n\nvoid rot(inout vec2 p, float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c * p.x + s * p.y, -s * p.x + c * p.y);\n}\n\n// soft min function\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k * a ) + exp( -k * b );\n  return -log( res ) / k;\n}\n\nfloat distanceEstimator(in vec3 p)\n{\n  float d = sdSphere(p, 1.0);\n    \n  for (float x = 0.0; x < 12.0; x++)\n  {\n    vec3 off = vec3(0.0, 0.0, 0.0 +3.0 * sin(0.3 * (iTime + x)));\n    rot(off.xz, x);\n    float sphere = sdSphere(p - off, 0.75);\n    d = smin(d, sphere, 10.0);\n  }\n    \n  float box = sdBox(p - vec3(0.0,-1.0,0.0), vec3(2.0, 0.1, 2.0));\n  \n  return min(box, d);\n}\n\n#define TOLERANCE       0.001\n#define MAX_RAY_LENGTH  32.0\n#define MAX_RAY_MARCHES 60\n\nfloat rayMarch(in vec3 ro, in vec3 rd)\n{\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance = distanceEstimator(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  return t;\n}\n\n// Calculate vector normal to pos\nvec3 normal(in vec3 pos)\n{\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = distanceEstimator(pos+eps.xyy) - distanceEstimator(pos-eps.xyy);\n  nor.y = distanceEstimator(pos+eps.yxy) - distanceEstimator(pos-eps.yxy);\n  nor.z = distanceEstimator(pos+eps.yyx) - distanceEstimator(pos-eps.yyx);\n  return normalize(nor);\n}\n\n// Specular lighting\nfloat specular(in vec3 nor, in vec3 ld, in vec3 rd)\n{\n  return pow(max(dot(reflect(ld, nor), rd), 0.), 75.);\n}\n\n// Diffuse lighting\nfloat diffuse(in vec3 nor, in vec3 ld)\n{\n  return max(dot(nor, ld),0.0);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, float mint, float k)\n{\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<32; i++)\n  {\n    float distance = distanceEstimator(pos + ld*t);\n    res = min(res, k*distance/t);\n    t += max(distance, mint*0.2);\n  }\n  return clamp(res,0.25,1.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  // position of light source\n  vec3 lightPos = -2.0*vec3(1.5, 3.0, -1.0);\n  // background color\n  vec3 skyCol = mix(vec3(0.8, 0.8, 1.0)*0.3, vec3(0.8, 0.8, 1.0)*0.6, 0.25 + 0.75*rd.y);\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  float t = rayMarch(ro,rd);\n\n  if (t < MAX_RAY_LENGTH)\n  {\n    // Ray intersected object\n    vec3 pos = ro + t * rd;\n    vec3 ld = normalize(pos - lightPos);\n    \n    vec3 nor = normal(pos);\n    \n    // diffuse lighting\n    float d = diffuse(nor, ld);\n    // specular lighting\n    float s = specular(nor, ld, rd);\n    \n    float sh = softShadow(pos, ld, 0.01, 16.0);\n    \n    return (color * d + s) * sh;\n  }\n  else\n  {\n    // Ray intersected sky\n    return skyCol;\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord/iResolution.xy - vec2(0.5);\n  p.x *= iResolution.x/iResolution.y;\n    \n  // camera\n  vec3 ro = 3.0*vec3(2.0, 1.0, 0.2);\n  rot(ro.xz, iTime*0.2);\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  // ray direction\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 col = render(ro, rd);\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3zM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsd3zr", "name": "Infinite spheres in spheres", "author": "TambakoJaguar", "description": "I wanted to do something simple but infinite, inspired by something I saw on the TV.\nI hope you like it.\nUse mouse to move around!", "tags": ["mouse", "patterns", "colorful", "sphere", "animation", "reflections", "infinite", "opening", "futuristic"], "likes": 17, "viewed": 268, "date": "1567789007", "time_retrieved": "2024-06-20T19:45:20.599769", "image_code": "/*\n\"Infinite spheres in spheres\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define shadow\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.31;\n\n// Specular options\nconst float specint = 0.41;\nconst float specshin = 28.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 50.;\n\n// Color options\nconst vec3 sphere_color = vec3(1., 0.3, 0.2);\nconst vec3 floor_color = vec3(0.5, 0.55, 0.6);\n\n// Geometry options\nfloat sphereR = 1.5;\nconst float sizeFact1 = 0.94;\nconst float sizeFact2 = 0.85;\n\n// Timing options\nconst float period = 16.;\nconst float startTime = 0.;\n\n// Campera options\nvec3 campos = vec3(12., 0., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 6.5;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define SPHERE_OBJ    5\n    \nLamp lamps[2];\nvec3 colors[6];\n\nvoid init()\n{\n    sphereR/= pow(pow(sizeFact2, 6.), mod((iTime + startTime)/period, 1.));\n    \n    float c = 0.25;\n    colors[0] = vec3(1., c, c);\n    colors[1] = vec3(c, 1., c);\n    colors[2] = vec3(c, c, 1.);\n    colors[3] = vec3(c, 1., 1.);\n    colors[4] = vec3(1., c, 1.);\n    colors[5] = vec3(1., 1., c);      \n    \n    lamps[0] = Lamp(vec3(-6., 7., -2.), vec3(1., 1., 1.), 1.1, 0.01);\n    lamps[1] = Lamp(vec3(7., 13., 8.), vec3(0.7, 0.8, 1.), 0.85, 0.01);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdCylinder(vec3 p, vec2 h, float t, float rr)\n{\n    h-= vec2(rr);\n    vec2 d = abs(vec2(length(p.xz*(1. + t*p.y)),p.y)) - h;\n    return -rr + min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat getStime(float i)\n{\n   float time2 = max(0., mod(iTime + startTime, period) - (i - 1.)*period/6.);\n   return clamp(6.*time2/period, 0., 1.);    \n   //return smoothstep(-0.1, 1., clamp(6.*time2/period, 0., 1.));\n}\n\nfloat getOpening(float i, float sphere, vec2 o, vec2 o2, float f)\n{\n   float aa = getStime(i)*pi;\n   float rf = pow(sizeFact2, i - 1.);\n    \n   float angle;\n   if (i>3.)\n   {\n      angle = asin(o2.x/(sphereR*rf))*sign(o2.y);\n      aa+= 0.05*smoothstep(-0.8, 0.8, sin(angle*15.*(sphereR*rf)));\n   }\n    \n   float b = 0.09 - 0.27*smoothstep(0.5, 0.05, aa) + clamp(0.2*(1. - sqrt(1. - pow(f*(sphere+0.045), 2.))), 0., 0.1);\n   float c;\n   if (aa<pi*0.5)\n      c = min(rotateVec(o, aa).x + b, -rotateVec(o, -aa).x + b);\n   else\n      c = max(rotateVec(o, aa).x + b, -rotateVec(o, -aa).x + b);\n    \n   return c;\n}\n\nfloat map_sphere0(vec3 pos, float r, float level)\n{\n   float rf = pow(sizeFact2, level - 1.);\n    \n   float outside = length(pos) - r*rf;\n   float inside = length(pos) - r*sizeFact1*rf;\n    \n   return max(outside, -inside);\n}\n\nfloat map_sphere(vec3 pos, float level)\n{\n   float sphere = map_sphere0(pos, sphereR, level);\n   float c = getOpening(level, sphere, mod(level, 2.)==1.?pos.zx:pos.yx, mod(level, 2.)==1.?pos.yz:pos.zy, 16.);\n    \n   float rf = pow(sizeFact2, level - 1.);\n   if (level==3.)\n   {\n      float a1 = atan(pos.x, pos.y);\n      float s1 = sin(a1*16.)*smoothstep(sphereR*0.97*rf, sphereR*0.8*rf, abs(pos.z)); \n      sphere-= 0.022*smoothstep(0.6, 1.3, s1);\n   }\n   if (level==5.)\n   {\n      float a1 = atan(pos.x, pos.y) + pos.z/(sphereR*rf);\n      float a2 = atan(pos.x, pos.y) - pos.z/(sphereR*rf);\n      float s1 = sin(a1*28.)*smoothstep(sphereR*0.97*rf, sphereR*0.88*rf, abs(pos.z)); \n      float s2 = sin(a2*28.)*smoothstep(sphereR*0.97*rf, sphereR*0.88*rf, abs(pos.z)); \n      sphere+= 0.03*smax(smoothstep(0.6, 1.5, s1), smoothstep(0.6, 1.5, s2), .5);\n   }    \n    \n   return max(sphere, c);\n   //return max(max(sphere, c), pos.y);\n}\n\nfloat map_sphere7(vec3 pos)\n{\n   return map_sphere0(pos, sphereR, 7.);\n}\n\nvec2 map(vec3 pos)\n{ \n    float sphere1 = map_sphere(pos, 1.);\n    float sphere2 = map_sphere(pos, 2.);\n    float sphere3 = map_sphere(pos, 3.);\n    float sphere4 = map_sphere(pos, 4.);\n    float sphere5 = map_sphere(pos, 5.);\n    float sphere6 = map_sphere(pos, 6.);\n    float sphere7 = map_sphere7(pos);\n    \n    vec2 res = vec2(sphere7, SPHERE_OBJ);\n    \n    if (getStime(1.)<1.)\n       res = opU(res, vec2(sphere1, SPHERE_OBJ));\n    if (getStime(2.)<1. && getStime(1.)>0.)\n       res = opU(res, vec2(sphere2, SPHERE_OBJ + 1));\n    if (getStime(3.)<1. && getStime(2.)>0.)\n       res = opU(res, vec2(sphere3, SPHERE_OBJ + 2));\n    if (getStime(4.)<1. && getStime(3.)>0.)\n       res = opU(res, vec2(sphere4, SPHERE_OBJ + 3));\n    if (getStime(5.)<1. && getStime(4.)>0.)\n       res = opU(res, vec2(sphere5, SPHERE_OBJ + 4));\n    if (getStime(6.)<1. && getStime(5.)>0.)\n       res = opU(res, vec2(sphere6, SPHERE_OBJ + 5));     \n      \n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 130; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.5;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map(ro + rd*t).x;\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    //return texture(iChannel0, ray).rgb;\n    \n    float axz = atan(ray.x, ray.z);\n    float sc = mix(0.7, 0.15, smoothstep(-1., 0., ray.y));\n    sc+= 0.4*smoothstep(0., 0.02, ray.y);\n    sc+= 0.4*smoothstep(0., 1., ray.y);\n    \n    sc+= 2.5*(smoothstep(0.4, 0.42, ray.y) - smoothstep(0.58, 0.6, ray.y))*smoothstep(0.5, 0.7, sin(axz*8.));\n    //sc+= 0.6*(smoothstep(0.65, 0.77, ray.y) - smoothstep(0.85, 0.87, ray.y))*smoothstep(0.5, 0.7, sin(axz*5.));\n    \n    float cc1 = pow(smoothstep(0.01, -0.01, ray.y) - smoothstep(0., -1.1, ray.y), 1.5);\n    float cc2 = pow(smoothstep(-0.4, -0.99, ray.y), 2.1);\n    sc*= (1. - cc1*smoothstep(0.98 - cc2*2.1, 1., sin(axz*15.)));\n    sc*= (1. - cc1*smoothstep(0.98 - cc2*2.5, 1., sin(ray.y*35.)));\n    \n    sc*= 1. + 0.5*sin(axz)*cc1;\n    \n    return vec3(sc);\n}\n\nvec3 getSphereColor(int objnr)\n{\n   return colors[objnr - SPHERE_OBJ];\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr>=SPHERE_OBJ)\n      return getSphereColor(objnr);   \n   if (objnr==SKY_OBJ)\n      return getSkyColor(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n  \n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n    \n    #ifdef reflections\n    float rf;\n    if (traceinf.objnr!=SKY_OBJ)\n    {\n       rf = fresnel(ray, traceinf.norm, 4.5);\n       int objnr = traceinf.objnr; \n       vec3 refray = reflect(ray, traceinf.norm);\n       traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n       col = mix(col, mix(getSphereColor(objnr), vec3(1.), 0.4)*traceinf.col, rf);\n    }\n    #endif\n    \n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}", "image_inputs": [{"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsd3zr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGDB", "name": "Dot dot dot", "author": "ruojake", "description": "Baby's first raymarching shader.", "tags": ["raymarching", "voronoi", "abstract"], "likes": 3, "viewed": 162, "date": "1569328018", "time_retrieved": "2024-06-20T19:45:21.648773", "image_code": "// (c) Kristian Sivonen 2019\n\n#define MAX_STEPS 60\n#define MAX_STEPS_SHADOW 45\n#define MIN_DISTANCE .001\n#define MIN_DISTANCE_SHADOW .001\n#define MAX_DISTANCE 45.\n\n// Hash without sine by Dave Hoskins, CC BY-SA 4.0\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// --\n\nfloat noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = smoothstep(.01, .99, fract(p));\n    float h00 = hash12(pi);\n    float h01 = hash12(pi + vec2(0., 1.));\n    float h10 = hash12(pi + vec2(1., 0.));\n    float h11 = hash12(pi + 1.);\n    return mix(mix(h00, h10, pf.x), mix(h01, h11, pf.x), pf.y);\n}\n\nfloat halftone(vec2 p)\n{\n    vec2 sc = sin(vec2(.785, 2.356));\n    p = vec2(p.x * -sc.y + p.y * sc.x, p.y * sc.x + p.x * sc.y);\n    return length(fract(p) - .5) * .25;\n}\n\nfloat sMin(float a, float b)\n{\n    float t = clamp(b - a + .5, 0., 1.);\n    return mix(b, a, t) - t * (1. - t) * .5;\n}\n\nfloat sSub(float a, float b)\n{\n    float t = clamp(.5 - (b + a) * .25, 0., 1.);\n    return mix(b, -a, t) + t * (1. - t) * .5;\n}\n\nvec4 quat(in vec3 x, in float a)\n{\n    return vec4(x * sin(a), cos(a));\n}\n\nvec3 rot(vec3 p, vec4 q)\n{\n    return cross(q.xyz,cross(q.xyz, p) + q.w * p) * 2. + p;\n}\n\nfloat sIntersect(float a, float b)\n{\n\tfloat t = clamp(b - a + .5, 0., 1.);\n    return mix(a, b, t) + t * (1. - t) * .5;\n}\n\n// 2x2x2 voronoi, produces some ugly discontinuities but oh well\nfloat vor(in vec3 p)\n{\n\tvec3 p_i = floor(p + .501) - 1.;\n    float mDist = 10.;\n    for(int i = 0; i < 8; i++)\n    {\n    \tvec3 n = p_i + vec3(ivec3(1, 2, 4) & i) * vec3(1., .5, .25);\n        vec3 h = hash33(n) * .6 + .2;\n        vec3 d = n + h - p;\n        mDist = min(mDist, dot(d,d));\n        if (mDist < .02) break;\n    }\n    return sqrt(mDist) * .4;\n}\n\nvec3 sphereDeform;\nvec4 sphereRotation;\nfloat sphere(vec3 p, vec3 sp, float r)\n{\n    p *= sphereDeform;\n    float ds = length(p - sp) - r;\n    if(ds > 1.2)\n        return ds;\n    vec3 vp = rot((p - sp) , sphereRotation) + vec3(0., iTime, 0.);\n\treturn sIntersect(abs(ds + sp.y * .1) - .55, vor(vp * 2.) * .5 - .075 + sp.y * .0125);\n}\n\nfloat ground(vec3 p)\n{\n\treturn p.y + noise(p.xz * 30.) * .005;\n}\n\nvec3 spherePos;\nfloat scene(vec3 p)\n{\n    float sphereRadius = 2.;\n\treturn sMin(ground(p), sphere(p, spherePos, sphereRadius));\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n\tfloat res = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float d = scene(ro + rd * res);\n        res += d;\n    \tif(abs(d) < MIN_DISTANCE || res > MAX_DISTANCE)\n            break;\n    }\n    return res;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float k, float maxDist)\n{\n\tfloat res = 1.;\n    float d = 0.;\n    float t = .02;\n    for(int i = 0; i < MAX_STEPS_SHADOW; ++i)\n    {\n        d = scene(ro + rd * t);\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < MIN_DISTANCE_SHADOW || t >= maxDist)\n            break;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nfloat light(vec3 p, vec3 n, float k)\n{\n\tvec3 lightPos = vec3(0, 2. + sin(iTime * 2.) * 1.9, 7);\n    lightPos.xz += vec2(-cos(iTime * .5), sin(iTime * .5)) * .2;\n    vec3 l = normalize(lightPos - p);\n    \n    float res = dot(n, l);\n    float d = length(p - lightPos) + .001;\n    \n    p += n * .02;\n    if(res >= 0. && d < 20.)\n    {\n    \tfloat sh = shadow(p, l, k, d);\n        res *= sh;\n    }\n    \n        \n    res = clamp(res, 0., 1.);\n    res *= smoothstep(20., 0., d);\n    return res;\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return uv.x * r + uv.y * u + f * zoom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 col = vec3(0.);\n\t\n    float sd = sin(iTime * 4. - 2.);\n    sd *= .6 + sd * .4;\n    sphereDeform = vec3(vec2(1.1 - sd * .3), (-.12 * sd - .07) * sd + 1.1).xzy;\n    spherePos = vec3(0, 1.75 + sin(iTime * 2.) * 2., 7);\n    \n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = ray(ro, spherePos, uv, .9 + sin(iTime * 2.) * .4);//normalize(vec3(uv, .8));\n    \n    vec2 cs = sin(vec2(iTime + 1.57, iTime)) * vec2(-1,1);\n    vec3 axis = vec3(cs, 0.);\n    sphereRotation = quat(axis, iTime * .3 + (1.75 + sin(iTime * 2.) * 2.) * .5);\n    float d = march(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normal(p);\n    float l = light(p, n, 128.);\n    l += (halftone(fragCoord * .15));\n    l *= .75;\n    //col = vec3(l);\n\tfloat hl = smoothstep(.65, .75, l);\n\tl = smoothstep(.22, .28, l);\n    col = mix(mix(vec3(.2, .3, .5), vec3(1., .6, .1), l), vec3(1.), hl);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdGDH", "name": "Water Dragon Scales", "author": "mathmasterzach", "description": "A Simple Effect: Water Dragon Scales\nA quick sketch of an idea I had", "tags": ["water", "effect", "dragon", "pseudo3d", "short", "scales"], "likes": 12, "viewed": 504, "date": "1568492822", "time_retrieved": "2024-06-20T19:45:21.648773", "image_code": "//Water Dragon Scales\n//classic rand function\n#define R(a) fract(sin(dot(a,vec2(12.9898,78.233)))*43758.5453)\nconst float S=sqrt(2.)/2.;\nvoid mainImage(out vec4 O,in vec2 U){\n    vec2 R=iResolution.xy,\n         p=(U+U-R)/R.y,\n         q=6.*p*mat2(S,S,-S,S),\n         r=fract(q)+vec2(R(U)-.5)/25.,\n    \t d=floor(q)/2.;\n    float h=R(d);\n    vec3 c=normalize(vec3(0.,h,1.));\n    float f=.2*float(r.x>r.y)+.8;\n    float wv=.5*sin(3.*iTime+d.x+d.y);\n    float sd=min(.5*h+3.7+wv-2.*max(r.x,r.y)-1.*(r.x+r.y),1.);\n    O=vec4(sd*f*(c-.2*wv),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGRH", "name": "Mandelbrot swirl ", "author": "1337_shader", "description": "it's a Mandelbrot with a swirl ", "tags": ["mandlebrot"], "likes": 2, "viewed": 90, "date": "1567826435", "time_retrieved": "2024-06-20T19:45:21.648773", "image_code": "#define r 10000.\n#define r2 5.\n#define  Max 2555.\n#define mouse (iMouse.xy-0.5*iResolution.xy) / iResolution.y; \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    float time = iTime;\n    vec2 n = vec2(time*time*time*0., time*time*time*0.);\n    vec2 m = n/iResolution.xy;\n    float zoom = pow(10. , -m.x*3.);\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;  \n  \n   \n\n \n    vec2 yuy = (fragCoord.xy*iResolution.xy) / iResolution.y;\n    yuy *= zoom*3.;\n    uv /= 2.5;\n\tvec2 c = mouse;\n \n\t\n    \n    c = uv*zoom*3.*2.1;\n    vec2 z = vec2(c);\n\t//c = mouse;\n    float iter = 0.;\n    float iterr = 0.;\n    \n    vec2 j = vec2(0.);\n    float ma = (0.);\n    float m2 = 0.;\n    float t = 0.;\n    float t2 = 0.;\n    float io = 0.;\n    float ey = 0.;\n     float di =  1.0;\n    vec2 dz = vec2(0.0);\n \n    vec2 rt = vec2(c);\n    if (time > 4.) time = 4.;\n    //\n\tfor(float i=0.; i<=Max; i++) {\n        if( m2>r ) { di=0.0; break; }\n              dz = 2.0*vec2(z.x*dz.x-z.y*dz.y,( z.x*dz.y + z.y*dz.x)) + vec2(1.0,0.0);\n        z = vec2(z.x*z.x-z.y*z.y,( 2.*z.x*z.y)) + c;\n      \titer++;\n        m2 = dot(z,z);\n   }\n   float  w = 0.; \n   if (iter >= Max) w=0.;                  \n   \n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n      if( di>.5) d=0.0;\n \n    \td = clamp( pow(4.0*d/r2,0.2), 0.0, 1.0 );\n    float d2 = d;\n    if (di > .5 )d -= (dz.y+(z.x+z.y));\n \n   \n    float f = d;\n    f = (f);\n    \n   \n\n    float gg = iTime;\n    ey = io;\n  \n   float g = abs(sin(9.2));\n    vec3 col = cos(643.68 + f*5.+ vec3(0.3,0.45,.9));\n   vec3 h =  cos(gg + f*5.+ vec3(0.3,0.45,.9));\n           if (di > 0.5)col =h;\n        fragColor = vec4(vec3(col),1.0);\n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGRH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsdGRn", "name": "Rainbow Gradient Tiles", "author": "stseagle", "description": "Simple rotating tiles with rainbows for good measure.", "tags": ["2d", "rainbow", "tiles"], "likes": 3, "viewed": 375, "date": "1567630041", "time_retrieved": "2024-06-20T19:45:21.648773", "image_code": "vec3 sunset(vec2 st) {\n    float stretchTime = iTime/20.0 + st.y/40.0;\n    \n    float r = 0.7 * abs(cos(stretchTime)) + 0.2;\n    float g = 0.6 * abs(cos(stretchTime*9.743)) - 0.4 * sin(stretchTime);\n    float b = 0.9 * abs(cos(stretchTime)) + 0.1;\n\n    return vec3(r,g,b);\n}\n\n// From the Book of Shaders\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n// Box from the book\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float repeat = 8.;\n    vec2 st = fragCoord/iResolution.y * repeat;\n    vec3 color = sunset(st);\n    st = fract(st);\n    \n    float gridWidth = iResolution.y/repeat;\n    vec2 coords = floor(fragCoord.xy/gridWidth);\n    float diag = mod(coords.x + coords.y, 2.) + 1.;\n\n    float rotation = 0.7854 * diag *(1. - iTime*0.3);\n\n    st = rotate2D(st,rotation);\n\n    // Draw a square\n    float bx = box(st,vec2(0.7),10./iResolution.y);\n\n    fragColor = vec4(color * bx, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsdGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGRX", "name": "Waving Abyss", "author": "StarikTenger", "description": "Waves", "tags": ["wavewaves"], "likes": 4, "viewed": 124, "date": "1569007495", "time_retrieved": "2024-06-20T19:45:21.909113", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float x = fragCoord.x/100.0;\n    float phase = iTime;\n\n    float ass = 0.0;\n    float arr[10];\n\n    arr[0] = -0.55;\n    arr[1] = 0.77;\n    arr[2] = 0.15;\n    arr[3] = -0.45;\n    arr[4] = -0.3;\n    arr[5] = 0.42;\n    arr[6] = 0.433;\n    arr[7] = -0.13;\n    arr[8] = 0.55;\n    arr[9] = 0.65;\n\n    for(float i=0.0; i<7.0; i+=1.0){\n    \tfloat k = pow(2.0, i);\n    \tass += sin(iTime + arr[int(i)] * x ) * sin((x+ arr[int(i)] * phase)*k/2.0) / k / 4.0;\n    }\n\n\n    vec3 col = vec3(sin(iTime), distance(vec2(0, 0), fragCoord)/500.0, 0);\n    float val = ass/2.0 + 0.5 - uv.y;\n    float p = 100.0;\n    float p1 = 40.0;\n    if(uv.y < ass/2.0 + 0.5)\n        col = vec3(pow(1.0-val, p), pow(1.0-val, p), pow(1.0-val, 2.0));\n    else {\n        val = -val;\n        col = vec3(pow(1.0-val, p), pow(1.0-val, p), pow(1.0-val, p1));\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGWB", "name": "Rainbow Wall", "author": "FelixTheWolfrick", "description": "Project for class", "tags": ["itime", "gradientsfloor"], "likes": 1, "viewed": 57, "date": "1569260866", "time_retrieved": "2024-06-20T19:45:21.909113", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n\tuv = floor(uv * 30.0);\n    if(mod(uv.x, 2.0) == 0.0)\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    else\n        col = vec3(0.63, 0.45, 0.23);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGWH", "name": "Tree Bloom", "author": "voz", "description": "Tree Bloom", "tags": ["tree", "bloom"], "likes": 12, "viewed": 386, "date": "1568445278", "time_retrieved": "2024-06-20T19:45:22.599978", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*GR*E*5.)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime/PI/GR/E)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, 1.0, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvec3 mcol;\nfloat dB;\nfloat dfScene(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n\tfloat d=max(abs(z.y+1.0)-1.0,length(z.xz)-0.13);\n\tfor(int i=0;i<5;i++){\n\t\tz.xz=Kaleido(z.xz,float(i+2)*2.);\n\t\tz.yz=Rotate(z.yz,(saw(time*PI)-1.));\n\t\t\n        float dcap = sdCapsule(z.xyz+vec3(0., 0., 1.), vec3(0.,0.,1.), vec3(0.,2.0,0.),0.1);\n        dB += dcap/z.w/10.;\n\t\td=min(d,dcap/z.w);\n\t\tz.z+=1.0;\n        z.y -= 2.;\n\t\tz*=vec4(2.0,2.0,2.0,2.0);\n\t}\n\t//dB=(length(z.xyz)-1.0)/z.w;\n\treturn d;\n}\n\nvec3 surfaceNormal(vec3 p, vec3 rd) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor, vec3 rd) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 64; i++) {\n        rp = ro + rd * d;\n        float ns = dfScene(rp);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = flux(dB+time); //surface colour\n        vec3 n = surfaceNormal(rp, rd);\n        float ao = calcAO(rp, n, rd);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = sc;//pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, 1./GR, -PI)*2.;\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsdGz7", "name": "stump", "author": "foran", "description": "stump", "tags": ["stump"], "likes": 3, "viewed": 79, "date": "1568136652", "time_retrieved": "2024-06-20T19:45:22.599978", "image_code": "#define time iTime\n#define PI 3.14159\n#define TAU (2.*PI)\nfloat smin(float a, float b, float k)\n{\nfloat h = clamp(0.5+0.5*(b-a)/k,0.,1.);\nreturn mix(b,a,h)-k*h*(1.-h);\n}\nvec2 moda (vec2 p, float per)\n{\nfloat angle = atan(p.y, p.x);\nfloat l = length(p);\nangle = mod(angle-per/2., per)-per/2.;\nreturn vec2(cos(angle),sin(angle))*l;\n}\n\nfloat sphe (vec3 p, float r)\n{\np.y-=2.42;//               \nreturn length(p)-r;\n}\n\nfloat cylY (vec3 p, float r, float h)\n{\nreturn max(length(p.xz)-r, abs(p.y)-h); \n}\n\nfloat plane (vec3 p, vec2 uv)\n{\nvec4 text = texture(iChannel0, uv/2.);\np.y +=.5;\np.y+=text.x;\nreturn p.y;\n}\nfloat cylX (vec3 p, float r, float h)\n{\n\np.xz = moda(p.xz, 2.*3.14/5.);\np.x -= 0.8;\np.xy += p.z*sin(iTime);\np.y += .99;//     \nr-=p.x*0.2;\nreturn max(length(p.yz)-r, abs(p.x)-h); \n}\n\nfloat SDF(vec3 p, vec2 uv)\n{\nfloat body = smin(cylY(p,0.49,2.25), sphe(p,0.5), 0.14);//cylY(p,.53,1.95)//.53    1.95  \nfloat all_body =  smin(body,cylX(p, 0.2, 1.), 0.5);\nreturn min(all_body, plane(p, uv));\n}\n//----------\nfloat rng(vec2 seed){return fract(sin(dot(seed*.1,vec2(123,165)))*121513.);}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat amod(inout vec2 p,float count){\n  float an=TAU/count;\n  float a=atan(p.y,p.x)+an/2.;\n  float c=floor(a/an);\n  a=mod(a,an)-an/2.;\n  p=vec2(cos(a),sin(a))*length(p);\n  return c;\n}\n//---------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n//----------\n  vec2 uvv=uv;\nfloat star=0.;\nfloat circle=0.;\nfor(float i=0.;i<100.;++i){\n  vec2 p=uv;\n  float a=rng(vec2(i))*TAU;\n  a+=time;\n  float radius=.1;\n  float r=mod(time*.1+i*.1,1.);\n  radius*=clamp(r,0.,1.);\n   p.xy+=vec2(cos(a),sin(a))*r;\n  p.x*=.8;\n  p.y+=-sin(abs(p.x*1.5))*.5;\n  float c=1.-smoothstep(radius*.99,radius,length(p));\n  c*=1.-clamp(length(p)*8.,0.,1.);\n  circle+=c;\n  a=rng(vec2(i+3.))*TAU;\n  r=i*.1;\n  p=uvv;\n  r=mod(time*.3+r,1.);\n  float thin=.01*r;\n  p.xy+=vec2(cos(a),sin(a))*r;\n  float x=thin/clamp(length(p.x),0.,1.);\n  float y=thin/clamp(length(p.y),0.,1.);\n  star+=x*y*(.01/clamp(length(p),0.,1.));\n  \n}\n//------------\nvec3 p = vec3 (0.01,0.01,-6.5);//-3\nvec3 dir = normalize(vec3(uv, 1.));\nfloat shad = 0.;\nfor (int i=0; i<60; i++)\n{\nfloat d = SDF(p, uv);\nif (d<0.01)\n{shad = float(i)/60.;\nbreak;}\np += d*dir;\n}\n//----------\nvec4 out_color=vec4(1.);\nvec4 colour=vec4(circle,0,0,1);\ncolour+=star;\nout_color=colour;\n//--------\n  vec4 color=vec4(1.);\n    color*=(1.-shad);\n    color+=vec4(mix(vec4(0.8588, 0.2039, 0.2039, 1.0),vec4 (colour),.5));\n  out_color=vec4(mix(vec4(0.8588, 0.2039, 0.2039, 1.0),vec4 (color),.65));\n  fragColor=vec4(out_color);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsdGz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGRD", "name": "perlin noises", "author": "remotion", "description": "perlin noise ported from c++ to glsl\nhttps://github.com/nothings/stb/blob/master/stb_perlin.h", "tags": ["noise", "perlin", "c"], "likes": 7, "viewed": 131, "date": "1569774965", "time_retrieved": "2024-06-20T19:45:24.054501", "image_code": "#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n// based on \n// https://github.com/nothings/stb/blob/master/stb_perlin.h\n\n\n//-----------------------------------------------------------------------------\nint _perlin_fastfloor(float a) {\n    return int(floor(a)); // nearest integer less than or equal to x\n}\n\n#define uchar int //TODO: find a bettrer way\n\n//-----------------------------------------------------------------------------\n// different grad function from Perlin's, but easy to modify to match reference\nfloat _perlin_grad(int hash, float x, float y, float z) {\n   const vec3 basis[12] = vec3[12](\n      vec3(  1, 1, 0 ),\n      vec3( -1, 1, 0 ),\n      vec3(  1,-1, 0 ),\n      vec3( -1,-1, 0 ),\n      vec3(  1, 0, 1 ),\n      vec3( -1, 0, 1 ),\n      vec3(  1, 0,-1 ),\n      vec3( -1, 0,-1 ),\n      vec3(  0, 1, 1 ),\n      vec3(  0,-1, 1 ),\n      vec3(  0, 1,-1 ),\n      vec3(  0,-1,-1 )\n   );\n\n   // perlin's gradient has 12 cases so some get used 1/16th of the time\n   // and some 2/16ths. We reduce bias by changing those fractions\n   // to 5/64ths and 6/64ths, and the same 4 cases get the extra weight.\n   const uchar indices[64] = uchar[64](\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,9,1,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11,\n      0,1,2,3,4,5,6,7,8,9,10,11\n   );\n\n   // if you use reference permutation table, change 63 below to 15 to match reference\n   // (this is why the ordering of the table above is funky)\n   vec3 grad = basis[indices[hash & 63]];\n   return grad[0]*x + grad[1]*y + grad[2]*z;\n}\n\n//-----------------------------------------------------------------------------\nfloat _perlin_noise3(float x, float y, float z, int x_wrap, int y_wrap, int z_wrap)\n{\n    // not same permutation table as Perlin's reference to avoid copyright issues;\n    // Perlin's table can be found at http://mrl.nyu.edu/~perlin/noise/\n    // @OPTIMIZE: should this be unsigned char instead of int for cache?\n    const uchar _perlin_randtab[512] = uchar[512](\n    23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n    152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n    175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n    8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n    225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n    94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n    165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n    65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n    26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n    250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n    132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n    91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n    38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n    131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n    27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n    61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,\n\n    // and a second copy so we don't need an extra mask or static initializer\n    23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,\n    152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,\n    175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,\n    8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,\n    225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,\n    94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,\n    165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,\n    65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,\n    26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,\n    250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,\n    132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,\n    91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,\n    38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,\n    131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,\n    27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,\n    61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5\n    );\n\n   float u,v,w;\n   float n000,n001,n010,n011,n100,n101,n110,n111;\n   float n00,n01,n10,n11;\n   float n0,n1;\n\n   int x_mask = (x_wrap-1) & 255;\n   int y_mask = (y_wrap-1) & 255;\n   int z_mask = (z_wrap-1) & 255;\n   int px = _perlin_fastfloor(x);\n   int py = _perlin_fastfloor(y);\n   int pz = _perlin_fastfloor(z);\n   int x0 = px & x_mask, x1 = (px+1) & x_mask;\n   int y0 = py & y_mask, y1 = (py+1) & y_mask;\n   int z0 = pz & z_mask, z1 = (pz+1) & z_mask;\n   int r0,r1, r00,r01,r10,r11;\n\n   // Quintic interpolation curve  y = x*x*x*(x*(x*6.-15.)+10.);\n   #define _perlin_ease(a)   (((a*6.0-15.0)*a + 10.0) * a * a * a)\n\n   x -= float(px); u = _perlin_ease(x);\n   y -= float(py); v = _perlin_ease(y);\n   z -= float(pz); w = _perlin_ease(z);\n\n   r0 = _perlin_randtab[x0];\n   r1 = _perlin_randtab[x1];\n\n   r00 = _perlin_randtab[r0+y0];\n   r01 = _perlin_randtab[r0+y1];\n   r10 = _perlin_randtab[r1+y0];\n   r11 = _perlin_randtab[r1+y1];\n\n   n000 = _perlin_grad(_perlin_randtab[r00+z0], x  , y  , z   );\n   n001 = _perlin_grad(_perlin_randtab[r00+z1], x  , y  , z-1.0 );\n   n010 = _perlin_grad(_perlin_randtab[r01+z0], x  , y-1.0, z   );\n   n011 = _perlin_grad(_perlin_randtab[r01+z1], x  , y-1.0, z-1.0 );\n   n100 = _perlin_grad(_perlin_randtab[r10+z0], x-1.0, y  , z   );\n   n101 = _perlin_grad(_perlin_randtab[r10+z1], x-1.0, y  , z-1.0 );\n   n110 = _perlin_grad(_perlin_randtab[r11+z0], x-1.0, y-1.0, z   );\n   n111 = _perlin_grad(_perlin_randtab[r11+z1], x-1.0, y-1.0, z-1.0 );\n\n   n00 = mix(n000,n001,w);\n   n01 = mix(n010,n011,w);\n   n10 = mix(n100,n101,w);\n   n11 = mix(n110,n111,w);\n\n   n0 = mix(n00,n01,v);\n   n1 = mix(n10,n11,v);\n\n   return mix(n0,n1,u);\n}\n\n#undef uchar\n//-----------------------------------------------------------------------------\nfloat _perlin_ridge_noise3(float x, float y, float z,float lacunarity, float gain, float offset, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float prev = 1.0f;\n   float amplitude = 0.5f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = float(_perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap));\n      r = r<0.0 ? -r : r; // fabs()\n      r = offset - r;\n      r = r*r;\n      sum += r*amplitude*prev;\n      prev = r;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n//-----------------------------------------------------------------------------\nfloat _perlin_fbm_noise3(float x, float y, float z,float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      sum += _perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n//-----------------------------------------------------------------------------\nfloat _perlin_turbulence_noise3(float x, float y, float z, float lacunarity, float gain, int octaves,int x_wrap, int y_wrap, int z_wrap)\n{\n   int i;\n   float frequency = 1.0f;\n   float amplitude = 1.0f;\n   float sum = 0.0f;\n\n   for (i = 0; i < octaves; i++) {\n      float r = _perlin_noise3(x*frequency,y*frequency,z*frequency,x_wrap,y_wrap,z_wrap)*amplitude;\n      r = r<0.0 ? -r : r; // fabs()\n      sum += r;\n      frequency *= lacunarity;\n      amplitude *= gain;\n   }\n   return sum;\n}\n\n//-----------------------------------------------------------------------------\n// This function computes a random value at the coordinate (x,y,z).\n// Adjacent random values are continuous but the noise fluctuates\n// its randomness with period 1, i.e. takes on wholly unrelated values\n// at integer points. Specifically, this implements Ken Perlin's\n// revised noise function from 2002.\n// The \"wrap\" parameters can be used to create wraparound noise that\n// wraps at powers of two. The numbers MUST be powers of two. Specify\n// 0 to mean \"don't care\". (The noise always wraps every 256 due\n// details of the implementation, even if you ask for larger or no\n// wrapping.)\nfloat perlin_noise(const in vec3 p,const in ivec3 wrap) {\n  return _perlin_noise3(p.x, p.y, p.z, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\n// Fractal Noise:\n//\n// Three common fractal noise functions are included, which produce \n// a wide variety of nice effects depending on the parameters \n// provided. Note that each function will call perlin_noise3 \n// 'octaves' times, so this parameter will affect runtime.\n\n// Typical values to start playing with:\n//     octaves    =   6     -- number of \"octaves\" of noise3() to sum\n//     lacunarity = ~ 2.0   -- spacing between successive octaves (use exactly 2.0 for wrapping output)\n//     gain       =   0.5   -- relative weighting applied to each successive octave\n//     offset     =   1.0?  -- used to invert the ridges, may need to be larger, not sure\n\n//-----------------------------------------------------------------------------\nfloat perlin_ridge(const in vec3 p, float lacunarity, float gain,\n    int octaves, float offset, const in ivec3 wrap) {\n  return _perlin_ridge_noise3(\n      p.x, p.y, p.z, lacunarity, gain, offset, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\nfloat perlin_fbm(const in vec3 p, float lacunarity, float gain,\n    int octaves, const in ivec3 wrap) {\n  return _perlin_fbm_noise3(\n      p.x, p.y, p.z, lacunarity, gain, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n//-----------------------------------------------------------------------------\nfloat perlin_turbulence(const in vec3 p, float lacunarity, float gain,\n    int octaves, const in ivec3 wrap) {\n  return _perlin_turbulence_noise3(\n      p.x, p.y, p.z, lacunarity, gain, octaves, wrap.x, wrap.y, wrap.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n   \tvec3 col = vec3(0.0);\n\n    const float lacunarity = 2.0;\n    const float gain = 0.7;\n    const int octaves = 5;\n    const float offset = 0.8;\n\n    const ivec3 wrap = ivec3(0);\n\tconst vec3 scale = vec3(5.0,3.0,3.0);\n\n\tfloat time = iTime*0.25 + 1.0;\n    \n    float f = 0.0;\n    f = perlin_turbulence(vec3(uv*scale.xy,time*0.7)     , lacunarity,gain,octaves,wrap);\n    f = perlin_turbulence(vec3(uv*scale.xy,time*0.5) + f, lacunarity,gain,octaves,wrap);\n    // f = perlin_turbulence(vec3(uv*scale.xy,time*0.3) + f, lacunarity,gain,octaves,wrap);\n    f  = perlin_turbulence(vec3(uv*scale.xy,time*1.0) + f, lacunarity,gain,octaves,wrap);\n    \n    // col = vec3(0.2,0.07,0.01) / (f*f); /// red\n    // col = vec3(0.0,0.24,0.03) / (f*f); /// green\n    col = vec3(0.1, 1.1*f, pow(f, 0.5-f)); /// blue\n\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGGRR", "name": "Backwards Golfing", "author": "BackwardsCap", "description": "First attempt at a golf shader.. not great by any means but I am happy with my first try!\nI created the non-music version first (241 characters) but thought that this would fit well as a visualizer so I added a bit more for some fun :)", "tags": ["music", "visualizer", "golf", "codegolf"], "likes": 1, "viewed": 175, "date": "1569526791", "time_retrieved": "2024-06-20T19:45:24.054501", "image_code": "\n//Longer version, but also a visualizer (322 characters): \nvoid mainImage( out vec4 c, in vec2 u )\n{\n    vec2 p = (u-0.5*iResolution.xy)/iResolution.y;\n    \n    int t = int(abs(p.x * p.y)*200.0+10.);\n\tfloat m  = texelFetch( iChannel0, ivec2(t,0), 0 ).x, \n    \tr=length(p)*2.,a = atan(p.y,p.x), sp = length(p)-2.,\n        f = cos(a*12.+iTime*5.+m)-abs(cos(a*5.-m))*1.5+.1;\n    c = vec4(vec3(1.-smoothstep(f,f+.9,r))/sp*vec3(p*2.,-.5-p.x)*3.,1.);\n}\n\n//Non-music, shorter version (241 characters):\n/*\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    vec2 p = (u-0.5*iResolution.xy)/iResolution.y;\n    float r=length(p)*2.,a = atan(p.y,p.x),sp = length(p)-2.,\n        f = cos(a*12.+iTime*3.)-abs(cos(a*5.))*2.;\n    c = vec4(vec3(1.-smoothstep(f,f+.9,r))*sp*vec3(p*2.,-.5-p.x)*4.,1.);\n}*/", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsGGRW", "name": "VoronoiSample", "author": "carmandale", "description": "learning about shaders", "tags": ["voronoi"], "likes": 5, "viewed": 117, "date": "1569790812", "time_retrieved": "2024-06-20T19:45:24.054501", "image_code": "vec2 N22 (vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. *fragCoord-iResolution.xy)/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime * 1.;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n    vec3 col = vec3(0);\n    \n    if (false) {\n    for (float i=0.; i<50.;i++) {\n    \tvec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv-p);\n        m += smoothstep(.02, .01, d);\n        \n        if (d<minDist) {\n            minDist = d;\n            cellIndex = i;\n        }\n    }} else {\n        uv *= 3.;\n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        \n        for (float y = -1.; y<=1.; y++) {\n            for (float x=-1.; x<=1.;x++) {\n                vec2 offs = vec2(x,y);\n                \n                vec2 n = N22(id+offs);\n        \t\tvec2 p = offs+sin(n*t)*.5;\n                p -= gv;\n                float ed = length(p);\n                float md = abs(p.x)+abs(p.y);\n                float d = mix(ed, md, sin(iTime*2.));\n                \n                if (d<minDist) {\n            \tminDist = d;\n            \tcid = id+offs;\n       \t\t\t}\n            }\n        }\n        \n        col = vec3(minDist);\n        //col.rg = cid*.1;\n    }\n\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsGGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjSzV", "name": "Stripes+Eyes", "author": "deerfeeder", "description": "simple loopable collection ", "tags": ["basics", "polarityv1"], "likes": 0, "viewed": 66, "date": "1568734651", "time_retrieved": "2024-06-20T19:45:24.218284", "image_code": "// Fork of \"Stripes\" by None. https://shadertoy.com/view/-1\n// 2019-04-04 17:35:14\n\nfloat stripes(vec2 p) {\n\treturn (-1.+ p.y*2.) * sin(iTime);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = abs(uv-0.5);\n    // Time varying pixel color\n    float x = stripes(uv) * (50. * cos(uv.x* (10. * sin(iTime * 0.2))));\n    vec3 col = vec3(log(x*x)*sin(x));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjSzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsK3z1", "name": "Reflective Orbs", "author": "atsn", "description": "raymarching and reflections", "tags": ["raymarching"], "likes": 0, "viewed": 230, "date": "1569813259", "time_retrieved": "2024-06-20T19:45:25.260732", "image_code": "mat3 objSphere(vec3 p,float r){\n    vec3 n = normalize(p);\n\treturn mat3(\n        0.2,0.4,0.2,\n        n.x,n.y,n.z,\n       .31,.02,length(p)-r\n    );\n}\nmat3 objPlane(vec3 p){\n    float rad = 10.;\n    float d = length(vec2(p.x,p.z));\n    \n\treturn mat3(\n        .5,.5,.5 ,\n        0.,1.,0.,\n        //n.x,n.y,n.z,\n        .1,0.3,p.y\n    );\n}\n\nvec3 rotZ(vec3 p,float rad){\t\n    float angle = atan(p.y,p.x)+rad;\n    mat3 rot = mat3(cos(angle),sin(angle),0.,-sin(angle),cos(angle),0.,0.,0.,1.);\n    return p * rot;\n}\n\nvec3 rotY(vec3 p,float rad){\t\n    float angle = atan(p.z,p.x)+rad;\n    mat3 rot = mat3(cos(angle),0.,sin(angle),0.,1.,0.,-sin(angle),0.,cos(angle));\n    return p * rot;\n}\nvoid add(inout mat3 ret, mat3 obj){\n\tif(obj[2][2]<ret[2][2]){\n    \tret = obj;\n    }\n}\n\nmat3 map(vec3 p){\n    \n    //return objSphere(rotY(p+vec3(0.,0.,1.),iTime*5.));\n    \n    mat3 ret = mat3(100.);\n    float amt = 15.;\n    for(float i=0.;i<amt;i++){\n        float ang = (i/amt)*3.1415*2. + iTime*.1;\n        mat3 o = objSphere(\n            p +\n            vec3(cos(ang),sin(ang)*-.5 + sin(iTime*1.+ang*10.)*.01,4.+sin(ang)),.1\n        );\n       \tadd(ret,o);\n        \n    }\n    add(ret,objSphere(\n        p +\n        vec3(0.,0. + sin(iTime*.5)*.05,4.),.4\n    ));\n    \n    //add(ret,objPlane(p+vec3(0.,.7,0.)));\n    add(ret,objSphere(\n        p + vec3(0.,10.5,10.),\n        10.\n    ));\n    return ret;\n}\n\nvec3 normal(vec3 p){\n    vec3 dx = vec3(0.02,0.,0.);\n    vec3 dy = vec3(0.,0.02,0.);\n    vec3 dz = vec3(0.,0.,0.02);\n \treturn normalize(vec3(\n    \tmap(p+dx)[2][2],\n        map(p+dy)[2][2],\n        map(p+dz)[2][2]\n    ));\n}\n\nvec3 fuzz(vec3 p,float amt){\n    vec3 dx = vec3(amt,0.,0.);\n    vec3 dy = vec3(0.,amt,0.);\n    vec3 dz = vec3(0.,0.,amt);\n \treturn normalize(vec3(\n    \tmap(p+dx)[2][2],\n        map(p+dy)[2][2],\n        map(p+dz)[2][2]\n    ));\n}\n\nvec3 lighting(vec3 dir){\n    float t = iTime*1.1;\n\treturn max(\n\t\t(\n            //pow(max(0.,dot(dir,vec3(1.,1.,1.))),1.)*vec3(2.,.3,0.2) +\n            //pow(max(0.,dot(dir,vec3(-1.,1.,1.))),1.)*vec3(0.2,.2,.3)+\n            pow(max(0.,1.+dot(dir,vec3(0.,5.,0.))),1.)*vec3(0.8+sin(iTime*.21)*.5,.8+sin(iTime*.32+103.)*.5,.8+sin(iTime*.4+53.)*.5)\n        ),\n\t\tvec3(0.4,0.4,0.4)\n\t);\n}\nvec3 rayMarch(vec3 start,vec3 dir,int maxSteps,float minDist,float maxDist){\n    float closest = 100.;\n    float dist = 0.;\n    float influence = 1.;\n    vec3 moved = vec3(0.);\n    \n    mat3 hit = mat3(0.);\n    int bounces = 0;\n    \n    vec3 c = vec3(.0);\n    \n    float give = 0.0;\n    \n    while(maxSteps-->0){\n        //give += sin(iTime)*.01+.01;\n        \n        hit = map(start+moved);\n        dist = hit[2][2];\n        give += dist*.001;\n        \n        if(dist<minDist+give){\n            give = 0.;\n            \n            \n            //vec3 n = normal(start+moved,dir);\n            //n += vec3(hit[1][0],hit[1][1],hit[1][2]);\n            \n            vec3 n = vec3(hit[1][0],hit[1][1],hit[1][2]);\n            //return n;\n            \n            \n            //float fg = 8.+sin(iTime)*5.;\n            //n = floor(n*fg)/fg;\n            \n            //Normal map\n            //return n;\n            \n            //calc fresnel\n            float fresnel = pow(1.-dot(-dir,n),1.45);\n            //return vec3(fresnel);\n            \n            \n            //bounce the light\n            bounces++;\n            //n.x += cos(hit[2][1]);\n            \n            //c += influence * max(0.,n.y) * vec3(0.8,0.1,0.1);\n            \n            float alignment = -dot(dir,n);\n            \n            //return vec3(alignment);\n            dir = normalize(alignment*n + (1.-alignment)*dir);\n            moved += dir;\n            \n            c += influence *\n                vec3(hit[0][0],hit[0][1],hit[0][2]) *\n                lighting(dir);\n            \n            \n            influence *= max(hit[2][0],fresnel*hit[2][1]);\n            \n            if(influence<0.01) break;\n            \n        }\n        closest = min(closest,dist);\n        if(dist>maxDist){\n            break;\n\t\t}\n        moved += dir*dist;\n    }\n    \n    //Sun\n    //c += influence*dot(dir,vec3(sin(iTime),1.,0.))*vec3(1.,0.,0.);\n    //Ambient\n    //c += influence*lighting(dir);\n    c += influence*lighting(dir);\n    if(bounces==0){\n        //return c*.5;\n    }\n\t\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n   \t\n    vec3 cpos = vec3(0.,0.,-4.);\n    \n    \n    float xAng = atan(cpos.z,uv.x-cpos.x);\n    float yAng = atan(cpos.z,uv.y-cpos.y);\n    vec3 off = normalize(vec3(\n        cos(xAng),\n        cos(yAng),\n        cpos.z\n    ));\n    \n    vec3 pix = rayMarch(vec3(uv.x,uv.y,0.),off,80,0.001,3.1);\n    \n\n\tcol = vec3(pix.r,pix.g,pix.b);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsK3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsKGzW", "name": "Rounded Box Example", "author": "red", "description": "An example answer to the stack overflow question https://stackoverflow.com/questions/58169154/glsl-rounded-rectangle-corners-are-stretched", "tags": ["sdf", "box"], "likes": 1, "viewed": 508, "date": "1569857358", "time_retrieved": "2024-06-20T19:45:25.545784", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Input info\n    vec2 boxPos; // The position of the center of the box (in normalized coordinates)\n    vec2 boxBnd; // The half-bounds (radii) of the box (in normalzied coordinates)\n    float radius;// Radius\n    \n    \n   \tboxPos = vec2(0.5, 0.5);\t// center of the screen\n    boxBnd = vec2(0.25, 0.25);  // half of the area\n    radius = 0.1;\n    \n    // Normalize the pixel coordinates (this is \"passTexCoords\" in your case)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    // In order to make sure visual distances are preserved, we multiply everything by aspectRatio\n    uv *= aspectRatio;\n    boxPos *= aspectRatio;\n    boxBnd *= aspectRatio;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    float alpha = length(max(abs(uv - boxPos) - boxBnd, 0.0)) - radius;\n    \n\t// Shadertoy doesn't have an alpha in this case\n    if(alpha <= 0.0){\n    \tfragColor = vec4(col,1.0);\n    }else{\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsKGzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSSWw", "name": "Hexagon tiling (custom version)", "author": "deerfeeder", "description": "adding custom modulations", "tags": ["tutorial", "artofcode"], "likes": 1, "viewed": 91, "date": "1568734523", "time_retrieved": "2024-06-20T19:45:25.860770", "image_code": "// Fork of \"Hexagon (layout)\" by deerfeeder. https://shadertoy.com/view/tsjSDD\n// 2019-03-29 19:35:41\n\nfloat skew = 1.73;\nfloat blur = 0.99;\nfloat scale = 5.0;\n\nfloat HexDist(vec2 p) {\n    // vertical mirror\n\tp = abs(p);\n    \n    // hex skew;\n    float c = dot(p, normalize(vec2(1,skew)));\n    // vertical sides\n    c = max(c, p.x);    \n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv){\n \n   \t//skew\n    vec2 r = vec2(1,skew);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r)-h;\n\t\n    \n    //basegrid midpoints\n    vec2 b = mod(uv-h, r )-h;\n    vec2 gv = dot(a,a) < dot(b,b) ? a : b;\n    vec2 id = uv - gv;\n    float y = atan(gv.x,gv.y)+sin(1.* iTime+id.y);\n    float x = atan(gv.x,gv.y)+cos(0.5* iTime+id.x);\n    return vec4(x, y,id.x,id.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// middle & squared \n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n \tscale -= abs((scale*0.75) * sin(iTime*0.4));\n    skew += 1. *cos(iTime);\n    vec3 col = vec3(0);\n\tuv = uv * scale;\n    vec4 hc = HexCoords(uv);\n\n    \n \tcol.rgb = hc.yyy*0.2;\n   \t\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSSWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wst3D8", "name": "Triangle ocean", "author": "Mipmap", "description": "Slower, zoomed out version of gabwoot's 'Snake low poly texture' https://www.shadertoy.com/view/3stGD8", "tags": ["triangle", "texture", "wavy", "lowpoly"], "likes": 6, "viewed": 355, "date": "1568383489", "time_retrieved": "2024-06-20T19:45:25.867019", "image_code": "// Slower, zoomed out version of gabwoot's 'Snake low poly texture' https://www.shadertoy.com/view/3stGD8\n#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\tPI * 2.0\n#define TIME_SCALE      1.0 / 32.0\n#define BRIGHTNESS      1.6\n#define TRIPPINESS      8.0\n#define ZOOM            12.0\n\nconst vec4 color1 = vec4(0, 59, 70, 255) / vec4(255);\nconst vec4 color2 = vec4(7, 87, 91, 255) / vec4(255);\n\nvec2 coord(in vec2 p) {\n  p = p / iResolution.xy;\n  // correct aspect ratio\n  if (iResolution.x > iResolution.y) {\n    p.x *= iResolution.x / iResolution.y;\n    p.x += (iResolution.y - iResolution.x) / iResolution.y / 2.0;\n  } else {\n    p.y *= iResolution.y / iResolution.x;\n    p.y += (iResolution.x - iResolution.y) / iResolution.x / 2.0;\n  }\n  // centering\n  p -= 0.5;\n  p *= vec2(-1.0, 1.0);\n  return p;\n}\n\nmat2 rotation2d(float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat random (in vec2 st) {\n    return fract(\n        sin(\n            dot(st.xy, vec2(12.9898,78.233))\n        ) * 43758.5453123\n    );\n}\n\nfloat normalize2(float minV, float maxV, float v) {\n    return minV + v * (maxV - minV);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = coord(fragCoord.xy);\n    float time = iTime * TIME_SCALE;\n\n    vec2 wave = uv;\n    wave.x += sin(uv.y * TRIPPINESS + time) * 0.1;\n    wave.y += cos(uv.x * TRIPPINESS + time) * 0.1;\n    uv += wave;\n\n    uv *= rotation2d(PI / 3.2 * time);\n    uv *= vec2(normalize2(1., 2., (1. + sin(time)) / 2.));\n    uv += vec2(normalize2(5., 10., time));\n\n    vec2 index = floor(ZOOM * uv) / ZOOM;\n    float t = floor(random(index) * 4.) / 4.;\n    uv = 2.0 * fract(ZOOM * uv) - 1.0;\n    uv *= rotation2d(t * TWO_PI);\n\n    float c = step(uv.x, uv.y) * 0.9;\n    c = abs(sin(5. + fract((random(index + c) + 0.1))));\n    vec4 color = random(vec2(c)) > 0.5 ? color1 : color2;\n    fragColor = vec4((c * BRIGHTNESS + 0.5) * color.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wst3D8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wst3RH", "name": "bounding slice", "author": "gaz", "description": "volume?", "tags": ["3d"], "likes": 3, "viewed": 106, "date": "1567830704", "time_retrieved": "2024-06-20T19:45:25.867019", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// https://www.shadertoy.com/view/Xlf3zf\nfloat DE(vec3 p0)\n{\n    //float time =0.0;\n    float time =iTime;\n\tvec3 p=p0+sin(p0.yzx*4.0+2.4*sin(p0.zxy*5.0+time)+time*0.7)*0.5;\n\tfloat d=length(p)-1.0;\n\treturn d;\n}\n\nfloat map(vec3 p)\n{\n    p.xz*=rot(iTime*0.2);\n\tp.yz*=rot(iTime*0.1);\n    return DE(p);\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,3);\n    vec3 rd = normalize(vec3(uv,-2));\n    vec3 col = vec3(0.3,0.3,0.5)*uv.y*uv.y;\n    \n    vec3 center = vec3(0);//vec3(sin(iTime),0,0);\n    float r=1.8;\n    float h=1.0;\n    vec3 p;\n \n    if(length(cross(rd,center-ro))<r)\n    {\n    \tfloat ITR=300.;\n   \t\tvec3 g= normalize(center-ro);\n    \tvec3 pos=center+g*r;   \n       \tfor(float i=0.;i<ITR;i++)\n    \t{\n        \tfloat z = dot(pos-ro,rd);\n        \tvec3 q = ro+rd*z;\n        \tfloat d = map(q-center);\n        \th = min(h,max(d,0.0));\n\t\t\tif(d<0.01)p = q-center;\n        \tpos -= g*(r/ITR)*2.0;\n    \t}\n    }\n    if (h<0.01)\n    {\n        float d=map(p);\n        vec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        col = vec3(0.2,0.8,1.0);\n        float dif = clamp(dot(nor, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * nor.y, 0.0);\n        float spc = pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 50.0);\n        col *= dif * amb ;\n        col += spc;\n        col = clamp(col,0.0,1.0);\n    }\n    col = pow(col, vec3(0.6));\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wst3RH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wst3Rl", "name": "hexagon force field", "author": "Angramme", "description": "based on the tuts of Art Of Code", "tags": ["hexagon"], "likes": 8, "viewed": 455, "date": "1569103080", "time_retrieved": "2024-06-20T19:45:25.867019", "image_code": "float HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\n\nvec4 HexCoords(vec2 uv) {\n\tconst vec2 r = vec2(1, 1.73);\n    const vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv1 = uv + vec2(0, sin(uv.x*5. +t)*.02);\n    \n    vec2 uv2 = .5*uv1 + .5*uv + vec2(sin(uv.y*5. + t)*.02, 0);\n    float a = 1. + t*.05;\n    float c = cos(a);\n    float s = sin(a);\n    uv2 *= mat2(c, -s, s, c);\n    \n    vec3 col = vec3(0);\n    col += smoothstep(.05, .0, HexCoords(uv1*5.).y) * vec3(.2, .2, 1.);\n    col += smoothstep(.1, .0, HexCoords(uv2*20.).y) * vec3(.1, .1, .3);\n    \n    col *= dot(sin(uv*vec2(cos(uv.x*1.3), 7.)+t*2.), vec2(.7, .55974))*1.2+3.;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wst3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wst3Wn", "name": "roadToHell", "author": "foran", "description": "roadToHell", "tags": ["roadtohell"], "likes": 21, "viewed": 272, "date": "1568214480", "time_retrieved": "2024-06-20T19:45:25.867019", "image_code": "float obj(vec3 p)\n{\n  vec3 pp = p;\n  pp.z = mod(p.x, 110.)-55.;//  \n  float d=  -abs(p.x-1.)+63.;\n  return d;\n}\n\nfloat obj2(vec3 p)\n{\n  float d = length(p.xy-vec2(1.+cos(p.z),0.+sin(p.z)))-.21;//     .21\n  return d;\n}\n\nfloat map(vec3 p)\n{\n  float d = dot(cos(p.xyz), sin(p.zxy))+1.;\n  d += cos(p.z*10.)*.1;\n  d = min(d, obj(p));\n  d = min(d, obj2(p));\n\n  return d*.8;//   .8\n}\n\nvec3 normal(vec3 p)\n{\n  vec3 n;\n  vec2 eps = vec2(0.01,0.);\n  n.x = map(p) - map(p+eps.xyy);\n  n.y = map(p) - map(p+eps.yxy);\n  n.z = map(p) - map(p+eps.yyx);\n\n  return normalize(n);\n}\n\nmat2 rotate(float v)\n{\n  float a = cos(v);\n  float b = sin(v);\n  return mat2(a,b,-b,a);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n  vec3 p = ro;\n\n  for(int i=0; i<64; i++)\n  {\n    float d = map(p);\n    p += rd * d;\n  }\n\n  return p;\n}\n\nvec3 shade( vec3 ro, vec3 rd, vec3 p, vec3 n)//  color\n{\n  vec3 ld = normalize(vec3(.1,1.,-.5));\n  vec3 col = vec3(0.);\n\n  col = vec3(1.) * max(0., dot(n,ld))*.43;//                                 .3\n  col+=mix(vec3(0.7882, 0.098, 0.1529),vec3(0.0902, 0.8196, 1.0),rd.y)*length(p-ro)*.05;//     rd.y\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n  vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=.5;\n  uv/=vec2(iResolution.y/iResolution.x,1);\n  \n    vec3 ro = vec3(1.,0.,-iTime);//  -iTime , +iTime \n    vec3 rd = normalize(vec3(uv*2.,-1.));//  uv*2 , -1. \n    vec3 p = raymarch(ro,rd);//  \n    vec3 n = normal(p);\n    vec3 col = shade(ro, rd, p, n);//     \n\n  vec4 out_color=vec4(1.);\n  out_color = vec4(col, 1.);\n  fragColor=vec4(out_color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wst3Wn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wst3Ws", "name": "3D Voronoi Sphere", "author": "bignobody", "description": "After watching Art of Code's excellent Voronoi video I wanted to extend it to 3 dimensions. Though I guess with the time based animation, is this 4 dimensions...?", "tags": ["voronoiraymarch"], "likes": 5, "viewed": 220, "date": "1569519267", "time_retrieved": "2024-06-20T19:45:26.564067", "image_code": "//-----------------------------------------------------------------------\n// 3D Voronoi Sphere\n// After watching Art of Code's Voronoi Explained video (thank you!)\n// the next obvious step is \"make it 3D\" :) \n//-----------------------------------------------------------------------\n#define MAX_STEPS 64\n#define EPSILON 0.001\n#define MAX_DIST 200.0\n\nvec3 n33(vec3 p)\n{\n\tvec3 a = fract(p * vec3(564.391,309.444,666.777));\n    a +=  dot(a, a*5.63);\n\treturn fract(vec3(a.x*a.y, a.y*a.z, a.x*a.z));\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\nvec3 getqR(vec3 p)\n{\n    float t = iTime;\n    mat4 tm = mat4(1.0,0.0,0.0,0.0,\n                   0.0,1.0,0.0,0.0,\n                   0.0,0.0,1.0,0.0,\n                   0.0,-0.20,0.0,1.0);\n    float ra = t* 0.04;\n\tmat4 tr = mat4(cos(ra),0.0,sin(ra),0.0,\n                   0.0,1.0,0.0,0.0,\n                   -sin(ra),0.0,cos(ra),0.0,\n                   0.0,0.0,0.0,1.0);\n   \n    return (inverse(tm * tr) * vec4(p,1.0)).xyz;\n}\n\nfloat sceneSDF(vec3 p)\n{\n   return sphereSDF(p,9.5);\n}\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n\t        return depth;\n    \t}\n\t    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 vmat(vec3 p)\n{\n\tfloat t = iTime + 1000.0;\n    vec3 col = vec3(0.0);\n\t\n    vec3 gv = fract(p *3.0)-.5;\n\tvec3 id = floor(p*3.0);\n    \n    float d = 10000.0;\n    float closest = 10000.0;\n    vec3 tint = vec3(0.0);\n    \n    for (int x=-1; x <=1; x ++)\n    {\n        for (int y=-1; y <= 1; y ++)\n        {\n \t\t\tfor (int z=-1; z <= 1; z ++)\n        \t{\n           \t\tvec3 offset = vec3(x,y,z);\n    \t\t\tvec3 n = n33(offset+id);\n            \tvec3 p = offset+ sin(n*t * 2.0)*.5;\n            \td = length(gv-p);\n            \tif (d < closest)\n            \t{\n                \tclosest = d;\n            \t}\n            }\n        }\n    }\n    \n\treturn vec3(closest) - vec3(0.02,0.16,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1 to +1\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;           \n    \n    \n // camera setup and ray cast\n    float zoom = 0.45;\n  //  float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 camOrigin = vec3(2.0,2.0,-10.0);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0, MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n        vec2 gv = floor(abs(uv) * 16.0) * 0.1;\n     \t// no hit\n        fragColor = vec4(vec3(cos(gv) * sin(iTime),1.0),1.0);\n        return;\n    }\n\n    vec3 col = pow(vmat(getqR(camOrigin + rayDirection * d)),vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wst3Ws.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wst3z8", "name": "Hexagonal Tiling Practice", "author": "AlexWalley", "description": "Practicing how to tile with different shapes (hexagon)", "tags": ["practice"], "likes": 19, "viewed": 475, "date": "1568167925", "time_retrieved": "2024-06-20T19:45:26.564067", "image_code": "#define FACTOR 20.\n\nfloat HexDist(vec2 p, vec2 id){\n    float t = iTime;\n    mat2 rot = mat2(cos(t-id.x/FACTOR), -sin(t), sin(t), cos(t-id.x/FACTOR));\n    p*=rot*1.3;\n    p = abs(p); // Copy over first quad into all\n    float c = dot(p, normalize(vec2(1,1.73)));// Dot to get correct angle\n    return max(c, p.x); // Find where the vert line and angled intersect\n}\n\nvec4 HexCoords(vec2 uv){\n    vec2 rep = vec2(1, 1.73);\n    vec2 h = rep*0.5;\n    vec2 a = mod(uv, rep)-h;\n    vec2 b = mod(uv-h, rep)-h;\n\n    \n    vec2 gv;\n\tif(length(a) < length(b))\n    \tgv = a;\n    else \n        gv = b;\n    \n    vec2 id = (uv-gv)+FACTOR;\n    float y = 0.5-HexDist(gv, id);\n    return vec4(gv.x, y, id.x, id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    uv *= FACTOR;\n\tvec4 hexC = HexCoords(uv);\n\tfloat t = mod(iTime, 2000.);\n    col += smoothstep(0.05, 0.1, hexC.y*sin(hexC.w*hexC.z+t));\n    col += smoothstep(0.2, 0.15, hexC.y);\n    col += 0.5-smoothstep(0.15, 0.1, hexC.y);\n    col *= (0.7+sin(((hexC.z)/3.)+iTime)*0.3)*vec3(0.4, 0.7, 1.0);\n    col += vec3(0.3, 0.4, 0.8)*0.2;\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wst3z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstGDH", "name": "Palette soup", "author": "Mipmap", "description": "Palette cycling version of 'Triangle ocean' (https://www.shadertoy.com/view/Wst3D8).\n", "tags": ["wave", "triangle", "texture", "lowpoly"], "likes": 1, "viewed": 317, "date": "1568458439", "time_retrieved": "2024-06-20T19:45:26.564067", "image_code": "// Palette cycling (https://www.shadertoy.com/view/ll2GD3) version of \n// 'Triangle ocean' (https://www.shadertoy.com/view/Wst3D8).\n#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\tPI * 2.0\n#define TIME_SCALE      1.0 / 32.0\n#define BRIGHTNESS      0.2\n#define TRIPPINESS      8.0\n#define ZOOM            12.0\n\nconst vec4 color1 = vec4(0, 59, 70, 255) / vec4(255);\nconst vec4 color2 = vec4(7, 87, 91, 255) / vec4(255);\n\nvec2 coord(in vec2 p) {\n  p = p / iResolution.xy;\n  // correct aspect ratio\n  if (iResolution.x > iResolution.y) {\n    p.x *= iResolution.x / iResolution.y;\n    p.x += (iResolution.y - iResolution.x) / iResolution.y / 2.0;\n  } else {\n    p.y *= iResolution.y / iResolution.x;\n    p.y += (iResolution.x - iResolution.y) / iResolution.x / 2.0;\n  }\n  // centering\n  p -= 0.5;\n  p *= vec2(-1.0, 1.0);\n  return p;\n}\n\nmat2 rotation2d(float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n}\n\nfloat random (in vec2 st) {\n    return fract(\n        sin(\n            dot(st.xy, vec2(12.9898,78.233))\n        ) * 43758.5453123\n    );\n}\n\nfloat normalize2(float minV, float maxV, float v) {\n    return minV + v * (maxV - minV);\n}\n\n// See http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = coord(fragCoord.xy);\n    float time = iTime * TIME_SCALE;\n\n    vec2 wave = uv;\n    wave.x += sin(uv.y * TRIPPINESS + time) * 0.1;\n    wave.y += cos(uv.x * TRIPPINESS + time) * 0.1;\n    uv += wave;\n\n    uv *= rotation2d(PI / 3.2 * time);\n    uv *= vec2(normalize2(1., 2., (1. + sin(time)) / 2.));\n    uv += vec2(normalize2(5., 10., time));\n\n    vec2 index = floor(ZOOM * uv) / ZOOM;\n    float t = floor(random(index) * 4.) / 4.;\n\n    uv = 2.0 * fract(ZOOM * uv) - 1.0;\n    uv *= rotation2d(t * TWO_PI);\n\n    float c = step(uv.x, uv.y) * 0.9;\n    c = abs(sin(5. + fract((random(index + c) + 0.1))));\n\n    vec3 palColor1 = pal( iTime*.10, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );   \n    vec3 palColor2 = pal( iTime*.04, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    vec4 color = random(vec2(c)) > 0.5 ? vec4(palColor1.xyz, 1.0) : vec4(palColor2.xyz, 1.0);\n\n    fragColor = vec4((c * BRIGHTNESS + 0.5) * color.xyz, 1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstGDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstGR4", "name": "2D Weird stuff for Twitch", "author": "mrange", "description": "2D Weird stuff I did for the essenbee guest stream of writing shaders in GLSL: https://www.twitch.tv/essenbee.\n\nIntended as a 2D example of distance functions, domain repetition and other common techniques before moving on to 3D raymarchers.", "tags": ["2dmandala"], "likes": 28, "viewed": 671, "date": "1567973465", "time_retrieved": "2024-06-20T19:45:27.503494", "image_code": "#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvec3 saturate(vec3 col) {\n  return clamp(col, 0.0, 1.0);\n}\n\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 mod2(inout vec2 p, vec2 size)  {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\n\nfloat mandala_df(float localTime, vec2 p) {\n  vec2 pp = toPolar(p);\n  float a = TAU/64.0;\n  float np = pp.y/a;\n  pp.y = mod(pp.y, a);\n  float m2 = mod(np, 2.0);\n  if (m2 > 1.0) {\n    pp.y = a - pp.y;\n  }\n  pp.y += localTime/40.0;\n  p = toRect(pp);\n  p = abs(p);\n  p -= vec2(0.5);\n  \n  float d = 10000.0;\n  \n  for (int i = 0; i < 4; ++i) {\n    mod2(p, vec2(1.0));\n    float da = -0.2 * cos(localTime*0.25);\n    float sb = box(p, vec2(0.35)) + da ;\n    float cb = circle(p + vec2(0.2), 0.25) + da;\n    \n    float dd = max(sb, -cb);\n    d = min(dd, d);\n    \n    p *= 1.5 + 1.0*(0.5 + 0.5*sin(0.5*localTime));\n    rot(p, 1.0);\n  }\n\n  \n  return d;\n}\n\nvec3 mandala_postProcess(float localTime, vec3 col, vec2 uv) \n{\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  col = clamp(col, 0.0, 1.0);   \n  col=pow(col,mix(vec3(0.5, 0.75, 1.5), vec3(0.45), r)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=sqrt(1.0 - sin(-localTime + (50.0 - 25.0*sqrt(r))*r))*(1.0 - sin(0.5*r));\n  col = clamp(col, 0.0, 1.0);\n  float ff = pow(1.0-0.75*sin(20.0*(0.5*a + r + -0.1*localTime)), 0.75);\n  col = pow(col, vec3(ff*0.9, 0.8*ff, 0.7*ff));\n  col *= 0.5*sqrt(max(4.0 - r*r, 0.0));\n  return clamp(col, 0.0, 1.0);\n}\n\nvec2 mandala_distort(float localTime, vec2 uv) {\n  float lt = 0.1*localTime;\n  vec2 suv = toSmith(uv);\n  suv += 1.0*vec2(cos(lt), sin(sqrt(2.0)*lt));\n//  suv *= vec2(1.5 + 1.0*sin(sqrt(2.0)*time), 1.5 + 1.0*sin(time));\n  uv = fromSmith(suv);\n  modMirror2(uv, vec2(2.0+sin(lt)));\n  return uv;\n}\n\nvec3 mandala_sample(float localTime, vec2 p)\n{\n  float lt = 0.1*localTime;\n  vec2 uv = p;\n  uv *=8.0;\n  rot(uv, lt);\n  //uv *= 0.2 + 1.1 - 1.1*cos(0.1*iTime);\n\n  vec2 nuv = mandala_distort(localTime, uv);\n  vec2 nuv2 = mandala_distort(localTime, uv + vec2(0.0001));\n\n  float nl = length(nuv - nuv2);\n  float nf = 1.0 - smoothstep(0.0, 0.002, nl);\n\n  uv = nuv;\n  \n  float d = mandala_df(localTime, uv);\n\n  vec3 col = vec3(0.0);\n \n  const float r = 0.065;\n\n  float nd = d / r;\n  float md = mod(d, r);\n  \n  if (abs(md) < 0.025) {\n    col = (d > 0.0 ? vec3(0.25, 0.65, 0.25) : vec3(0.65, 0.25, 0.65) )/abs(nd);\n  }\n\n  if (abs(d) < 0.0125) {\n    col = vec3(1.0);\n  }\n\n  col += 1.0 - pow(nf, 5.0);\n  \n  col = mandala_postProcess(localTime, col, uv);;\n  \n  col += 1.0 - pow(nf, 1.0);\n\n  return saturate(col);\n}\n\nvec3 mandala_main(vec2 p) {\n\n  float localTime = iTime + 30.0;\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  const int aa = 2;\n  for(int y = 0; y < aa; ++y)\n  {\n    for(int x = 0; x < aa; ++x)\n    {\n      col += mandala_sample(localTime, p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= float(aa*aa);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = 0.1*iTime;\n  vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n  uv.x *= iResolution.x/iResolution.y;\n\n  vec3 col = mandala_main(uv);\n    \n  fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstGR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstGRn", "name": "spiralsNova", "author": "foran", "description": "spiralsNova", "tags": ["spiralsnova"], "likes": 5, "viewed": 112, "date": "1567670922", "time_retrieved": "2024-06-20T19:45:27.503494", "image_code": "#define time iTime\n#define STEP 1./30.\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\n\nfloat cylinder(vec2 p, float r) { return length(p)-r; }\n//----------\n//Box-exact    \nfloat sdBox(vec3 p,vec3 b) {vec3 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,max(d.y,d.z)),0.); }\n//----------\nfloat amod (inout vec2 p, float count) {//         12  5  5        my 1  1  111\n\n  float an = 3.14159*2./count;\n  float a = atan(p.y,p.x)+an/2.;\n  a = mod(a,an)-an/2.;\n  p = vec2(cos(a),sin(a))*length(p);\n  return 0.;\n}\n\nmat2 rot (float a) {//             \nfloat c=cos(a),s=sin(a);\nreturn mat2(c,-s,s,c);\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\n\nfloat smin (float a, float b, float r) {\nfloat h = clamp(.5+.5*(b-a)/r,0.,1.);\nreturn mix(b,a,h)-r*h*(1.-h);\n}\n\nvoid orbit (inout vec3 p) {\n\n  p.xz *= rot(iTime);//     \n  p.yz *= rot(iTime*.7);//  \n p.xy *= rot(iTime*.4);//   \n  p.xy *= rot(length(p)*.2);//    \n  p.xz *= rot(length(p)*.5);//  \n  p.yz *= rot(length(p)*.3);//    \n}\n\nfloat rand (vec2 s) { return fract(sin(dot(s, vec2(55.,100.)))*440545.); }\n\nfloat map (vec3 pos) \n{\n  float scene = 1000.;\n  vec3 p = pos;//        p\n  orbit(p);//             p ()\n//----------  \n  p.xz *= rot(p.y*.3);//               .3\n  amod(p.xz, 1.);//       12    my 1.\n  float wave = sin(time+p.y*2.);//   wave   y\n  p.x -= 1. + .2*wave;//   wave   x .2\n  //p.x = repeat(p.x, 1.);//    wave   x   1.\n  scene = min(scene, cylinder(p.xz, .21));//     .1\n  p.y = repeat(p.y + time, .2);//      y .2\n  scene = smin(scene, cylinder(p.xy, .032), .31);//      xy    .02  .1\n  scene = smin(scene, cylinder(p.yz, .032), .31);//      yz    .02  .1\n//--------\n//float box=sdBox(p.xyz-vec3(p.y,-wave,0),vec3(2.*.125));\n//float box1=sdBox(p-vec3(0,0,0),vec3(.3+.8*(.5+.5*sin(time*10.))));\n//float sph1=sphere(p,.2+.2*(.5+.5*sin(p.y+time*10.)));\n//float cyl1=cylinder(p.xz,.2*wave+.02);\n//scene=smin(scene,sdBox(p-vec3(0,-wave,0),vec3(2.*.125)));//      yz    .02  .1\n//scene=smin(cyl1,scene,.3);\n//--------\n\n  p = pos;//                 p  \n  orbit(p);//                  p\n  p.xz *= rot(p.y*5.);//       5.0  xz\n  amod(p.xz, 21.);////       5    my 1.          5 ?\n  p.x -= .2 + wave * .2;//  wave   x\n  p.y = repeat(p.y, .5);//      y .5\n  scene = smin(scene, sphere(p, .2 + .1 * wave), .1);//   sphere    xyz    .02  .1\n\n  p = pos;//                 p  \n  amod(p.xz, 51.);//       5    my 111.\n  orbit(p);//                  p\n  p.xz*=rot(p.y*1.);//       5.0  xz\n  p.x = repeat(p.x, 1.);//      x .5\n  p.z=repeat(p.z,.015);//           y .5\n  //p.y = repeat(p.y, .015);//      y .5\n  //p.y=repeat(p.y,.55);//          y .5\n  scene = smin(scene, sphere(p, .2 + .1 * wave), .1);//   sphere    xyz    .02  .1\n  return scene;\n}\n\nvec3 getNormal (vec3 p) {\nvec2 e = vec2(.01,.0);\nreturn normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n//void main(void)\n{\nvec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\nuv-=.5;\nuv/=vec2(iResolution.y/iResolution.x,1);\n   vec3 eye = vec3(0,0,-4);\nvec3 ray = normalize(vec3(uv, .2));\nvec3 pos = eye;\nfloat shade = 0.;\nfor (float i =0.; i <= 1.; i += STEP) {\nfloat dist = map(pos);\nif (dist < .1) {\n  shade += 1./STEP;\n}\nif (shade >= 1.) break;\ndist = max(dist, .001);\ndist *= .6 + .1 * rand(uv);\npos += ray * dist;\n}\n\n  vec4 out_color=vec4(1.);//\n  vec3 color = vec3(1);\n  vec3 normal = getNormal(pos);\n  color = normal*1.5+.35;\n  color *= shade;\n  out_color = vec4(color, 1);\n  fragColor=vec4(out_color);//\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstGRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wstGz4", "name": "Tron disco", "author": "Loldog", "description": "title\n\nEdit: 09-10-2019 23:41 - gamma corrected and cleanup", "tags": ["grid", "tron", "neon"], "likes": 11, "viewed": 826, "date": "1567983241", "time_retrieved": "2024-06-20T19:45:27.503494", "image_code": "#define PI 3.14159265359\n#define DEG2RAD PI/180.\n\n// Prevents flickering\n#define SUPERSAMP 8\n\n// Project camera to world plane with constant worldY (height)\nvec3 revProject(vec2 camPos, float worldY, float fov) {\n    float worldZ = worldY / (camPos.y * tan(fov*DEG2RAD*.5));\n    float worldX = worldY * camPos.x / camPos.y;\n    return vec3(worldX, worldY, worldZ);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Define supersample sizes\n    float fragsize = 1. / iResolution.y;\n    float supersize = fragsize / float(SUPERSAMP);\n\n    // Define the screenspace horizon [-0.5, 0.5]\n    float horizonY = 0.2;\n    \n    // Clip above horizon (optional)\n    if (p.y > horizonY) {\n    \tfragColor = vec4(vec3(0.), 1.0);\n    }\n    else {\n        // Initialize current fragment intensity\n        float intensity = 0.;\n        // Define the current grid displacement\n        vec3 displace = vec3(3.*sin(2.*PI*0.1*iTime), 4.*iTime, 1.5);\n        // Define the FOV\n        float fov = 90.0;\n        \n        // Retrieve supersamples\n        for (int i = 0; i < SUPERSAMP; i++) {\n            for (int j = 0; j < SUPERSAMP; j++) {\n                vec2 superoffset = vec2(i,j) * supersize;\n                // Get worldspace position of grid\n                vec2 gridPos = revProject(p + superoffset - vec2(0., horizonY), displace.z, fov).xz;                \n                // Create grid\n                vec2 grid = fract(gridPos - displace.xy) - 0.5;\n                // Make wavy pattern\n                float pattern = 0.7+0.6*sin(gridPos.y - 6.*iTime);\n                \n                // Compute distance from grid edge\n                float dist = max(grid.x*grid.x, grid.y*grid.y);\n                // Compute grid fade distance\n                float fade = min(1.5, pow(1.2, -length(gridPos) + 15.0));\n                // Set brightness\n                float bright = 0.015 / (0.26 - dist);\n                intensity += fade * pattern * bright;\n            }\n        }\n        \n        // Define current fragment color\n        vec3 col = 0.5 + 0.5*cos(iTime+p.yxy+vec3(0,10,20));\n        // Normalize intensity\n        intensity /= float(SUPERSAMP*SUPERSAMP);\n        \n    \tfragColor = vec4(intensity * col, 1.0);\n    }\n    \n    fragColor = pow(fragColor, vec4(.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wstGz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsV3Rh", "name": "hypnosis", "author": "guk", "description": "ranging circles with intervals and giving them different gradient colors + some camera zooming at specified scales.", "tags": ["camera", "period", "ranges"], "likes": 2, "viewed": 127, "date": "1569707161", "time_retrieved": "2024-06-20T19:45:27.909363", "image_code": "float map_dist(float val, float step_val);\nfloat period();\nfloat camera_scale_period();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - vec2(iResolution.xy)) / iResolution.y;\n    p *= camera_scale_period(); // comment to see static camera\n\n    float len = length(p);\n    len = pow(len, period()); // comment to see static len\n\n    float val_step = .1;\n    val_step *= (period()/2.0 + 1.0); // comment to see static step\n    \n    len = map_dist(len, val_step);\n    len = clamp(len, 0.0, 3.0); // first version has 'clamp(0.0, 3.0, len);' at this place causing some user seeing only pink - fixed thanks to FabriceNeyret2 comment\n    \n    // some magic numbers to give cool colors\n    vec3 col = vec3(sin(len*2.0)*0.4 + 0.5, sin(len+2.5)*0.5 + .5, sin(len+3.2)*0.5 + .5);\n    fragColor = vec4(col * len,1.0);\n}\n\n// with all the random formulas tweaking up here I decided to make a \n// fixed-point camera with zooming to most interesting spots :)\nconst int cam_point_size = 8;\nconst float[cam_point_size] g_values = float[cam_point_size](.1, 5., 10., 12., 0.015, 0.015, 0.05, 0.08);\nfloat camera_scale_period() {\n    float time_in_per = mod(iTime, 6.28318); // 2 pi\n    float interval = 6.28318 / float(cam_point_size);\n    int current = int(time_in_per / interval);\n    int next = (current + 1) % cam_point_size;\n    float rem = time_in_per / interval - floor(time_in_per / interval);\n    float val = mix(g_values[current], g_values[next], rem);\n    return val;\n}\n\nfloat period() {\n    return sin(iTime);\n}\n\n// floor val into n intervals (n = 1/step_val)\nfloat map_dist(float val, float step_val) {\n    // in case, all this function can be replaced with \n    // 'return floor(val) * step_val;'\n    \n    float rem = val - floor(val);\n    float smooth_interval = 0.05 * val;\n    float smooth_border = 1.0 - smooth_interval / 2.0;\n    float smooth_rem = step(smooth_border, 1.0-rem) * step(smooth_border / 2.0, 1.0-rem)\n        + step(smooth_border, rem) * step(smooth_border, rem);\n    \n    // a lot of code for smoothing borders :(\n    if (smooth_rem == 1.0) {\n        // smooth transition between colors\n        // there's certainly a way to do it without branching\n        if (rem > 0.5) {\n            // case 1: increasing (from current color to next)\n            float current = floor(val) * step_val;\n            float next = (floor(val) + 1.0) * step_val;\n            float average = (current + next) / 2.0;\n            return mix(current, average, (rem - smooth_border) / (smooth_interval / 2.0));\n        } else {\n         \t// case 2: decreasing\n            float current = floor(val) * step_val;\n            float prev = (floor(val) - 1.0) * step_val;\n            float average = (current + prev) / 2.0;\n            return mix(average, current, rem / (smooth_interval / 2.0));\n        }\n    } else {\n    \treturn floor(val) * step_val;\n    } \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsV3Rh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGRz", "name": "Cordoba", "author": "PixelPhil", "description": "My first attempt at SDF ray marching.\nIt is a shader interpretation of MC Escher's drawings of the mosk of Cordoba.\nMany thanks to Bigwings, iq and Shane for the learning material.\nMusic by : Blanloeil Nino", "tags": ["raymarching", "reflexion", "escher", "softshadows", "marble"], "likes": 17, "viewed": 478, "date": "1569848432", "time_retrieved": "2024-06-20T19:45:30.564227", "image_code": "//\n// This is my first attempt at a ray marching shader\n// It is inspired of MC Escher's drawings of the Cordoba mosk.\n//\n// https://hotelviento10.es/en/art/77-the-drawings-of-cordoba-by-m-c-escher\n//\n// It was mostly developped during the 8 train hours of a week-end away from my workstation\n// so one of my objectives was to keep a decent framerate on my laptop and, although\n// the fan is screaming like hell I managed to maintain a 25fps preview which is not bad.\n// I might push the rendering a bit with AA and motion blur later.\n//\n// I'm also quite confident there is an enormous room for optimization.\n//\n// I started writing this thing after watching the Youtube intro to ray marching by BigWing\n// and studiying a few shaders by iq and Shane so kudos to these guys.\n// \n// Although I've been doing 'regular\" 3D code for quite some years now discovering the\n// wonders of Signed distance Fields and their properties feels like. I would never have\n// believed that I could achieve such an elaborate result (soft shadows, reflections,\n// procedural marble, AO & all) in less than 600 lines of code before comments.\n// This is truly opening new doors in my mind.\n//\n// I first implemented the shadows using a classic ray marching scheme an tried to soften\n// them by Jittering the light position and averaging a bunch of sample, the result was\n// super noisy and very slow. Thanks to iq's latest shader I figured out the concept of\n// using 'penumbra' to get soft shadows in a single ray cast and implemented it for a\n// huge improvement. At first I struggled a bit with it as my SDF turned non-eucydean when\n// I tried to blend my arches into my pillars with mix.There were many artefacts, missed\n// details and misplaced shadows. I took a bit of time to rework my SDF with a cone\n// intersection which fixed everything for a very similar shape.\n//\n\n// EDIT 3/01/2020 : Replace the Silly 3D texture for Noise with procedural Perlin noise\n//\t\t\t\t\tIt only ended up being used for the floor and the ceiling anyways\n\n\n#define MAX_DST 40.0\n#define FOG_DST 5.0\n#define MIN_DST 0.001\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise texture I use for the marble\nfloat Noise(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\nfloat NoisePM(vec2 uv)\n{\n    return Noise(uv) * 2.0 - 1.0;\n}\n\n\n// A basic Perlin-style marble that I hacked quite a bit\nfloat marble(vec3 pos)\n{\n    /*\n    vec3 marbleAxis = vec3(0.5, 0.4, -0.1);\n  \n\tvec3 mfp = (pos + dot(pos, marbleAxis) * marbleAxis * 2.0) * 0.02;*/\n    \n\tfloat marble = 0.0;\n    \n    pos *= 1.0;\n    \n\tmarble += abs(NoisePM(pos.xz));\n\tmarble += abs(NoisePM(pos.xz * 4.0)) * 0.5;\n\tmarble += abs(NoisePM(pos.xz * 8.0)) * 0.3;\n    //marble += abs(NoisePM(pos.xz * 16.0)) * 0.15;\n\n    \n\tmarble /= (1.0 + 0.5 + 0.3 /*+ 0.15*/);\n\tmarble = pow(1.0 - marble, 3.0) * 1.5;\n    \n\treturn marble;\n}\n\nvec3 marble(vec3 pos, vec3 col1, vec3 col2)\n{\n\treturn mix( col1, col2, marble(pos) );\n}\n\n// box distance function (stolen from iq)\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// cylinder distance function (stolen from iq)\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n// cone distance function\nfloat sdCone(vec3 p, vec2 c)\n{\n    float q = length(p.xz);\n    return dot(c, vec2(q, p.y));\n}\n\n// boolean add with y as material id\nvec2 combine(vec2 a, vec2 b)\n{\n    return (a.x < b.x ? a : b);   \n}\n\n// boolean subtract with y as material id\nvec2 subtract(vec2 a, vec2 b)\n{\n    b.x = -b.x;\n    return (a.x > b.x ? a : b);\n}\n\nfloat subtract(float a, float b)\n{\n    return max(a, -b);\n}\n\n// boolean intersect with y as material id\nvec2 inter(vec2 a, vec2 b)\n{\n    return (a.x > b.x ? a : b);\n}\n\n\n// Material ids\n//\n//0.0 -> floor\n//1.0 -> Ceiling\n//2.0 -> Ceiling wall\n//3.0 -> higer arch\n//4.0 -> Pillar\n//5.0 -> Lower arch\n\nvec2 SDF(vec3 pos)\n{\n    vec2 floorVal = vec2(pos.y + 0.5, 0.0); // ground plane\n    \n    // Bend space to mirror-tile the arches on both x and z\n    pos.x = abs(mod(pos.x, 2.0) - 1.0);\n    pos.z = abs(mod(pos.z, 4.0) - 2.0);\n    \n    \n    float ceilValue = 4.5 - pos.y;\n    ceilValue = min(ceilValue, sdBox(pos - vec3(0.0, 4.3, 0.0), vec3(0.2, 0.2, 4.0)));\n    vec2 ceilVal = vec2(ceilValue, 1.0); // Ceiling and beams with label 1.0\n    \n    \n    vec2 dist = combine(floorVal, ceilVal);\n    \n    vec2 arch1 = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.3),vec3(1.0, 3.0, 0.3), 1.15), 3.0);\n    arch1 = combine(arch1, vec2(sdBox(pos - vec3(0.0, 5.0, 0.0), vec3(2.0, 1.4, 0.23)), 3.5));\n    vec2 arch1Neg = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.4),vec3(1.0, 3.0, 0.4), 0.78), 3.0);\n    arch1 = subtract(subtract(arch1, arch1Neg), vec2(pos.y - 3.0, 3.0));\n\n    \n    float colDist = length(pos.xz) - 0.15;\n    float pillarBox  = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.16, 1.2, 0.3));\n    float pillarBox2 = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.22, 1.2, 0.2));\n    float cone = sdCone(pos - vec3(0.0, 1.2, 0.0), normalize(vec2(2.0, -1.0)));\n    \n\tpillarBox = min(pillarBox, pillarBox2);    \n    pillarBox = max(pillarBox, cone);\n    pillarBox = min(pillarBox, colDist);\n\n    vec2 pillar = vec2(pillarBox, 4.0);\n\n\n    \n    arch1 = combine(pillar, arch1);\n    \n    \n    float arch2 = sdCylinder(pos, vec3(1.0, 1.8, -0.15),vec3(1.0, 1.8, 0.15), 1.13);\n    float arch2Neg = sdCylinder(pos, vec3(1.0, 1.8, -0.6),vec3(1.0, 1.8, 0.6), 0.8);\n    \n    arch2 = subtract(subtract(arch2, arch2Neg), pos.y - 2.0);\n    \n    vec2 arch2Value = vec2(arch2, 5.0);\n    \n    dist = combine(dist, arch1);\n    dist = combine(dist, arch2Value);\n    \n    \n     \n    \n\treturn dist;// + Noise(pos * 3.0) * 0.0003 // a bit of noise make refections an highlights richer\n}\n\n\n#define ZERO (min(iFrame,0))\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst)\n{\n    vec2 dst = SDF(pos);\n    //return dst;\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        t += dst.x;\n        pos += dst.x * dir;\n        dst = SDF(pos);\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n// A marble pattern with .a as Speculairty/Reflection\nvec4 floorColor(vec3 pos)\n{\n    vec2 uvs = fract(pos.xz * vec2(0.5, 0.25));\n    vec2 ids = floor(uvs);\n    \n    bool mask1 = uvs.x > uvs.y;\n    bool mask2 = uvs.x > 1.0- uvs.y;\n\n    float mask = mask2 ^^ mask1 ? 0.0 : 1.0;\n    \n    vec3 baseCol = mix(vec3(0.2, 0.6, 0.3),vec3(0.6, 0.2, 0.4), mask);\n    \n    float marble = marble(pos * 4.0);\n\n    return  vec4(baseCol * (1.0 - marble * 0.2), 1.1 + marble);\n}\n\n\n// The stripes in polar space\nfloat ArchPattern(vec3 pos, float height)\n{\n    pos.x = abs(mod(pos.x, 2.0) - 1.0);\n    \n    vec2 delta = pos.xy - vec2(1.0, height);\n    float angle = atan(delta.y, delta.x);\n    \n    return S(0.26, 0.25, abs(fract(angle * 2.8) - 0.5));\n}\n\n\nvec3 archesColor(vec3 pos, float matId)\n{\n        float arch = 1.0;\n        \n        if (matId < 3.1)\n        {\n            arch = ArchPattern(pos, 3.0);\n        }\n        else if (matId > 4.9)\n        {\n            arch = ArchPattern(pos, 1.8);\n        }\n        \n        //vec3 mainColor = mix(vec3(0.90, 0.70, 0.60) * 0.9, vec3(0.80, 0.5, 0.40) * 0.9, S(2.0, 1.5, pos.y));\n        \n        vec3 col = mix(vec3(0.7, 0.41, 0.40) * 0.8, vec3(1.0, 0.8, 0.70), arch); \n        //vec3 col2 = mix(vec3(0.8, 0.53, 0.52), mainColor, arch);\n        \n    \t// The marble onthe colums didn't add that much to the look\n        return col;//marble(pos + col, col2, col);\n}\n\n\n// Some pretty shitty procedural wood (but it's barely visible)\nvec3 ceilingColor(vec3 pos)\n{\n    float p = pos.x * 5.0;\n    \n    p += Noise(pos.xy * vec2(0.5, 0.05) + pos.y * 0.1) * 3.0;\n    \n    float wood = fract(sin(p) * 2.0);\n    \n    return mix(vec3(0.69, 0.55, 0.4) * 0.8, vec3(0.5, 0.25, 0.15), wood);\n}\n\n\nvec4 MatColor(float matId, vec3 pos)\n{\n    if (matId < 0.1)\n    {\n        return floorColor(pos);\n    }\n    else if (matId < 1.1)\n    {\n        return vec4(ceilingColor(pos), 0.1);\n    }\n    else\n    {\n        return vec4(archesColor(pos, matId), 1.0);\n    }\n}\n\n// inspired by\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(vec3 pos, vec3 lPos)\n{\n    lPos.xyz += (vec3(N2(pos.xy), N2(pos.yz), N2(pos.zx)) - 0.5)* 0.03; //jitters the banding away\n    \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 10.0;  // Get out of the surface\n    \n    vec2 dst = SDF(pos); // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst.x < MIN_DST) return 0.0; \n        \n        obscurance = min(obscurance, (20.0 * dst.x / t)); \n        \n        t += dst.x;\n        pos += dst.x * dir;\n        dst = SDF(pos);\n    }\n    \n    return obscurance;     \n}\n\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos)\n{\n    return shadow(p + n * MIN_DST * 4.0, lPos);\n}\n\n// Computes the X of a pseudo-random path that will never \n// bump into pillar With agivent z and a seed value\nfloat CamX(float camZ, float seed)\n{\n    float normalized = (camZ - 2.0) / 4.0; // nomalize Z on the column grid\n    \n    float ratio = fract(normalized);  // 0.0 -> between cells\n    float cur = floor(normalized);    // current cell id\n    float next = cur + 1.0;\n    \n    // Pick random arches (0.0, 1.0 ou 2.0) for the current and next cell\n    cur = floor(N2(vec2(cur, seed)) * 2.9) * 4.0 - 2.0;\n    next = floor(N2(vec2(next, seed)) * 2.9) * 4.0 - 2.0;\n\n    // Cosine interpolate between the two\n    ratio = (1.0 - cos(ratio * 3.14)) * 0.5;\n    return mix(cur, next, ratio);\n}\n\n// Camera position from z\nvec3 CamPos(float z)\n{\n    float x = CamX(z, 666.0);\n    float y = 1.0 + sin(z * 0.14); // going up & down\n    return vec3(x, y, z);\n}\n\nconst vec3 fogColor = vec3(1.5f, 1.0f, 0.6); \nconst vec3 lightCol =  vec3(2.0, 1.5, 1.0);\n\n// A simpler rendering for reflections (diffuse only)\nvec3 reflection(vec3 pos, vec3 ref, vec3 lightPos)\n{\n    pos += ref * MIN_DST * 4.0;\n    \n    vec2 d = castRay(pos, ref, MAX_DST, MIN_DST);\n    \n    vec3 nPos = pos + ref * d.x;\n\n    float hAtten = sat((5.0 - nPos.y) / 3.0);\n    \n    if (d.x > MAX_DST)\n    {\n        return fogColor * hAtten; \n    }\n    else   \n    {\n   \n        vec3 col = MatColor(d.y, nPos).rgb;// * atten;\n      \t  \n      \tvec3 pointDir = lightPos - nPos;\n        float len = length(pointDir);\n        \n                \n        vec3 n = calcNormal(nPos);\n        \n        float atten = sat(1.0 - len / 20.0);\n        \n        atten *= shadow(nPos, n, lightPos);\n        \n        pointDir /= len;\n        \n        float diffuse = sat(dot(n, pointDir));\n        \n        col *= (diffuse * (atten * atten) * hAtten);\n        \n        return col;\n    }\n}\n\n// Main rendering\nvec3 render(vec2 uv, float time)\n{\n    float camZ = time * 0.6;\n    \n    // Compute camera position and 3-Axis base\n    vec3 camPos = CamPos(camZ);\n    vec3 nextPos = CamPos(camZ + 2.5);\n    vec3 camDir = normalize(nextPos - camPos);\n    vec3 camRight = normalize(vec3(-camDir.z, 0.0, camDir.x));\n    vec3 camUp = cross(camRight, camDir);\n    \n    // Compute ray\n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir * 1.8 + (camRight * uv.x)  +  (camUp * uv.y));\n    \n \t// Liighting & sading\n    vec3 lightDir = normalize(vec3(1.0, -0.4, 1.0));\n \n    float lightZ = camZ - 1.0;\n    float lightX = CamX(lightZ, 576.0);\n    \n    vec3 lightPos = vec3(lightX, 1.5, lightZ);\n    \n    vec2 d = castRay(rayPos, rayDir, MAX_DST, MIN_DST);\n    \n    vec3 col;\n    \n    if (d.x > MAX_DST)\n    {\n        col = fogColor; \n    }\n    else   \n    {\n        //float field = fract(d * 1.0);\n\t    col = vec3(d.y / 8.0);//\n        vec3 pos = camPos + rayDir * d.x;\n        \n        vec4 mat = MatColor(d.y, pos);\n        \n        vec3 n = calcNormal(pos);\n        \n\n        vec3 pointDir = lightPos - pos;\n        float len = length(pointDir);\n        \n        float atten = sat(1.0 - len / 20.0);\n        \n        pointDir /= len;\n        \n        //float ambient = (n.y + 0.5) * 0.1;// mix(vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.0), n.y * 0.5 + 0.5);\n        \n        float lambertPoint = 0.0;\n        \n \t\tatten *= atten;\n     \n        float shadow = shadow(pos, n, lightPos); \n        \n        lambertPoint = sat(dot(n, pointDir));\n        \n        lambertPoint *= shadow * atten; \n        \n        vec3 ref = reflect(rayDir, n);\n        float specular =  sat(dot(pointDir, ref));\n        \n        specular = specular * specular * shadow * atten;\n\n        vec3 diffuseCol = lambertPoint * lightCol;\n        \n        vec3 specularCol = vec3(specular);\n        \n        col = (mat.rgb * diffuseCol) + mat.a * specularCol;\n        \n        float dst = 1.0 - sat(SDF(pos + n * 0.5).x * 1.0);\n\n        col *= vec3((1.0 - dst * dst) * 0.7 + 0.3); // Fake AO\n        \n        if (mat.a > 1.05) // Reflections on the floor\n        {\n            float fresnel = abs(dot(n, rayDir));\n            col += reflection(pos, ref, lightPos) * atten * fresnel;// * mat.a;\n        }\n        \n        float fogDst = sat(d.x / MAX_DST);\n\n        col = mix(col, fogColor, pow(fogDst, 1.5));\n    }\n    \n    return col;\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // an attempt a 4X Multisampling, quite slow, not neat\n\t/*\n    vec4 offset = vec4(-0.25,0.25,-0.25,0.25) / iResolution.y;\n    float noize = N2(uv) * 0.005;\n  \tvec3 col = render(uv + offset.zx, iTime);\n    col += render(uv + offset.yw, iTime + 0.005 + noize);\n    col += render(uv + offset.wx, iTime + 0.01 + noize);\n    col += render(uv + offset.xz, iTime + 0.015 + noize);\n    col /= 4.0;\n\t*/\n    \n    vec3 col = render(uv, iTime + 9.0); // +9 is for a nicer thumbnail\n    \n    // Gamma correction\n    float gamma = 0.85;\n    col = vec3(pow(col.r, gamma), pow(col.g, gamma), pow(col.b, gamma));\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": "MtXGWj", "previewfilepath": "https://soundcloud.com/blanloeil-nino/arabian-flute", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/blanloeil-nino/arabian-flute", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGz1", "name": "Munching squares tunnel", "author": "id523", "description": "Based on the effects demonstrated in https://www.youtube.com/watch?v=aKMrBaXJvMs", "tags": ["tunnel", "xor", "squares", "munching"], "likes": 14, "viewed": 383, "date": "1569735148", "time_retrieved": "2024-06-20T19:45:30.564227", "image_code": "#define INV_PI 0.318309886\n\nfloat safe_atan2_pi(float y, float x) {\n    return x == 0.0 ? 0.5*sign(y) : atan(y, x)*INV_PI;\n}\n\nvec4 sampleAt(vec2 fragCoord) {\n    float t = iTime * 0.4;\n    \n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    float dist = length(uv)+0.0001;\n    float fog = clamp(dist*2.0,0.0,1.0);\n    vec2 tunnel_uv = vec2(4. * safe_atan2_pi(uv.y, uv.x) + t * 0.7, t + 0.7/dist);\n    tunnel_uv = fract(tunnel_uv);\n    ivec2 int_uv = ivec2(65536. * tunnel_uv);\n    float xor_texture = float(int_uv.x ^ int_uv.y) * (1./65536.);\n    \n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    color.rgb = vec3(fog * fract(t * 0.4 + xor_texture));\n    color.a = 1.0;\n    return color;\n}\n\n#define ANTIALIAS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef ANTIALIAS\n    fragColor = (\n        sampleAt(fragCoord + vec2(0.00, 0.25)) +\n        sampleAt(fragCoord + vec2(0.25, 0.75)) +\n        sampleAt(fragCoord + vec2(0.50, 0.00)) +\n        sampleAt(fragCoord + vec2(0.75, 0.50))\n    ) * 0.25;\n#else\n    fragColor = sampleAt(fragCoord);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGzD", "name": "Spinning Chair", "author": "atsn", "description": "raymarching and boolean operations", "tags": ["raymarching"], "likes": 1, "viewed": 256, "date": "1569853668", "time_retrieved": "2024-06-20T19:45:30.564227", "image_code": "mat4 scale(vec3 p){\n\treturn mat4(\n        1./p.x, 0.,  0.,  0.,\n        0.,  1./p.y, 0.,  0.,\n        0.,  0.,  1./p.z, 0.,\n        0.,  0.,  0.,  1.\n    );\n}\nmat4 translate(vec3 p){\n\treturn mat4(\n        1., 0., 0., p.x,\n        0., 1., 0., p.y,\n        0., 0., 1., p.z,\n        0., 0., 0., 1.\n    );\n}\nmat4 rotate(vec3 u,float rad){\n    u = normalize(u);\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    float ic = 1.-c;\n    float is = 1.-s;\n    return mat4(\n        u.x*u.x*ic+c,     u.x*u.y*ic-u.z*s, u.x*u.z*ic+u.y*s, 0.,\n        u.y*u.x*ic+u.z*s, u.y*u.y*ic+c,     u.y*u.z*ic-u.x*s, 0.,\n        u.z*u.x*ic-u.y*s, u.z*u.y*ic+u.x*s, u.z*u.z*ic+c,     0.,\n        0.,               0.,               0.,               1.\n    );\n}\n\nfloat cube(vec4 p){\n\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.5;\n}\nfloat sphere(vec4 p){\n\treturn length(p.xyz)-.5;\n}\n\nvoid add(inout float dist,float shape){\n    dist = min(dist,shape);\n}\nvoid remove(inout float dist,float shape){\n    dist = max(dist,-shape);\n}\nvoid intersect(inout float dist,float shape){\n    dist = max(dist,shape);\n}\nfloat world(vec4 p){\n    float dist = 100.;\n    \n    \n    add(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)\n    ));\n    intersect(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\tscale(vec3(0.8,1.2,1.2))\n    ));\n    remove(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.,0.8,0.))*\n\t\tscale(vec3(.9,1.,0.9))\n    ));\n    \n    remove(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.1,-0.2,0.))*\n\t\tscale(vec3(.9,.9,0.9))\n    ));\n    \n    add(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.,0.15,0.))*\n\t\tscale(vec3(.7,.2,0.85))\n    ));\n    \n    \n    /*add(dist,sphere(p*\n        translate(vec3(-1.5,0.,-2.4))\n    ));*/\n    \n    add(dist,cube(p*\n        translate(vec3(0.,1.5,-2.3))*\n                  scale(vec3(8.,1.,8.))\n    ));\n    \n    \n    /*add(dist,sphere(p*\n        translate(vec3(0.,-1.,-1.))*\n                    scale(vec3(2.,2.,2.))\n    ));*/\n    \n    return dist;\n}\n\n#define STEP 0.01\nvec4 normal(vec4 p){\n\treturn vec4(\n        normalize(vec3(\n            world(vec4(p.x+STEP,p.y,p.z,1.)),\n        \tworld(vec4(p.x,p.y+STEP,p.z,1.)),\n        \tworld(vec4(p.x,p.y,p.z+STEP,1.))\n\t\t)),\n        0.\n    );\n}\n\nvoid dither(inout vec4 dir,vec4 p,float soft){\n    dir = normalize(dir+vec4(\n        sin(p.y*10000.),\n        sin(p.z*10000.),\n        sin(p.x*10000.),\n        0.\n    )*soft);\n}\n\nfloat rayCastSun(vec4 p, vec4 dir, float softness, float maxSteps, float minDist, float maxDist){\n    float dist = 0.;\n    while(maxSteps-->0.){\n        dist = world(p);\n        dither(dir,p,softness);\n        p += dir*dist;\n        if(dist<minDist){\n            return 0.;\n        }\n        if(dist>maxDist){\n            break;\n        }\n    }\n    return 1.;\n}\n\nfloat sun(vec4 p, vec4 n, vec4 a,float soft,float maxSteps, float minDist, float maxDist){\n    a = normalize(a);\n    float alignment = max(0.,dot(n,a));\n    return alignment * rayCastSun(p,a,soft,maxSteps,minDist,maxDist);\n}\nfloat lamp(vec4 p, vec4 n, vec4 s,float soft,float d,float maxSteps, float minDist, float maxDist){\n    float dist = length(s-p);\n    if(dist>d) return 0.;\n    vec4 a = normalize(s-p);\n    float alignment = max(0.,dot(n,a));\n    return alignment * rayCastSun(p,a,soft,maxSteps,minDist,dist) * pow(1.-dist/d,2.);\n}\nvec3 lights(vec4 p,vec4 n,float maxSteps, float minDist, float maxDist){\n\tvec3 c = vec3(.1);\n    \n    c += vec3(.8,.8,.8) * sun(p,n,vec4(0.,1.,-.1,0.),0.002,maxSteps,minDist,maxDist);\n    //c += vec3(.0,.0,.8) * sun(p,n,vec4(1.,1.,-1.,0.),0.02,maxSteps,minDist,maxDist);\n    \n    c += vec3(.3,.3,2.) * lamp(p,n,vec4(cos(iTime)*2.,.8,1.+sin(iTime)*2.,0.),0.0,5.,maxSteps,minDist,maxDist);\n    \n    //c += rayCastLights(p,normalize(vec4(0.,1.,-1.,0.)),maxSteps,minDist,maxDist) * vec3(.0,.8,0.);\n    \n\treturn c;\n}\n\nvec3 rayCast(vec4 p, vec4 dir, float maxSteps, float minDist, float maxDist, float maxBounce){\n    float dist = 0.;\n    vec3 col = vec3(1.);\n    float influence = 1.;\n    while(maxSteps-->0. && maxBounce>0.){\n        dist = min(maxDist,world(p));\n        \n        //col += 0.01*(dist/maxDist)*influence;\n        \n        p += dir*dist;\n        //col = vec3(dist);\n        //return;\n        if(dist<minDist){\n            maxBounce--;\n            vec3 albedo = vec3(.5,.5,.5);\n            \n            \n            vec4 n = normal(p);\n            float glance = dot(dir.xyz,n.xyz);\n            float fresnel = pow(1.+glance,4.45);\n            float reflective = min(1.,.01+fresnel);\n            //return vec3(reflective);\n            vec4 dif = dir-n;\n            vec4 bounce = normalize(dir-dif*2.);\n            dir = bounce;\n            \n            \n            vec3 lighting = lights(p+n*minDist*2.,n,maxSteps,minDist,maxDist);\n            \n            p += dir;\n            \n            col = (1.-influence)*col + (influence)*albedo*lighting;\n            //return lighting;\n            influence *= reflective;\n            //return col;\n            //col = dif.xyz;\n            //return;\n        }\n        if(dist>maxDist){\n            break;\n        }\n    }\n    //col += influence * lights(p,dir,maxSteps,minDist,maxDist);\n    return col;\n}\n\n/*\n   FEATURES\n--------------\n[k] Fresnel\n[k] Boolean Operations\n[k] Fog\n[k] Reflections\n[k] Shadows\n[k] Sun lights\n[k] Lamps\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = rayCast(\n        vec4(uv.x,uv.y,0.,1.),\n        normalize(vec4(uv.x,uv.y,1.,0.)),\n        200.,0.00001,1000.,10.\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsVGzR", "name": "Vai's Guitar", "author": "ss_blade", "description": "Ibanez UV77 Steve Vai paint job.\nhttp://www.ibanezrules.com/namm/images/2010/005.JPG", "tags": ["trippy"], "likes": 9, "viewed": 171, "date": "1569620118", "time_retrieved": "2024-06-20T19:45:30.564227", "image_code": "#define COLOR vec3(1.1, 1.0, 1.1)\n\nvoid mainImage( out vec4 OUT, in vec2 fragCoord )\n{\n\tvec2 point=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfor(int i=1;i<11;i++)\n\t{\n\t\tvec2 iter=point;\n\t\titer.x+=2.5/float(i)*sin(float(i)*point.y+(iTime/3.0)+0.3*float(i));\n\t\titer.y+=1.6/float(i)*cos(float(i)*point.x+(iTime/4.0)+0.3*float(i));\n                                             \n\t\tpoint=iter;\n\t}\n\tvec3 col=vec3(1.0 - abs(cos(point.x)), 1.0 - abs(cos(point.x+point.y)), 1.0 - cos(sin(point.y)))\n        \t\t\t*   COLOR;\n    \n\t OUT = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsVGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsVGzW", "name": "BeyondTimeWarp", "author": "rmmcal", "description": "Just a contribution to time...", "tags": ["raymarching", "text", "clock", "wall", "floor", "chain"], "likes": 9, "viewed": 222, "date": "1569829320", "time_retrieved": "2024-06-20T19:45:34.800994", "image_code": "//  originally posted on http://glslsandbox.com/e#57593.5\n//    by twitter/@rmmcal\n//\n//  Rename to: BeyondTimeWarp\n//\n//  fork from http://glslsandbox.com/e#57593.0\n//  fork from http://glslsandbox.com/e#3044.0\n/////////////////////////////////////////////////////////////////////////////////////////\n\n// https://www.shadertoy.com/view/XtsSDH\n// https://www.shadertoy.com/view/ldl3zn\n// https://www.shadertoy.com/view/Msl3Rn\n\n\n// TimeWarp @P_Malin\n \n// added pan/zoom - hard work stolen from other shaders, thanks @emackey\n \n#ifdef GL_ES\nprecision highp float;\n#endif\n \n#define time iTime\n#define mouse iMouse.xy/iResolution.xy-.5\n#define resolution iResolution.xy\n \n// somehow these enable pan/zoom controls (using magic)\n//uniform vec2 surfaceSize;\n//varying vec2 surfacePosition;\n\nvec2 surfaceSize;\nvec2 surfacePosition;\n    \nconst float kPI = acos(0.0);\nconst float kHalfPi = asin(1.0);\nconst float kTwoPI = kPI * 2.0;\n\n \n \n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n//#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_DIRECTIONAL_LIGHT\n\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n \nvoid CalcPixelRandom()\n{\n    // Nothing special here, just numbers generated by bashing keyboard\n    vec4 s1 = sin(time * 3.3422 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n    vec4 s2 = sin(time * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n    gPixelRandom = fract(2142.4 + s1 + s2);\n    gRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n\nfloat GetTime()\n{\n\treturn 0.0;\n}\n#else\nfloat GetTime()\n{\n\treturn time;\n}\n#endif\n \nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\n \nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n \nstruct C_Material\n{\n    vec3 cAlbedo;\n\tfloat fR1;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n};\n \nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n   \n    return vResult;\n}\n \nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n   \n    return vResult;\n}\n   \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n   \n    return vResult;\n}\n \nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n \nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n \nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n \nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vTile = (vTilePos + 1000.0);\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n    vec3 vResult = vPos;\n    vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n    return vResult;\n}\n \nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n    float angle = atan( vPos.x, vPos.z );\n \n    float fScale = fSteps / (kTwoPI);\n    float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n \n    float s = sin(-steppedAngle);\n    float c = cos(-steppedAngle);\n \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z,\n                vPos.y,\n                -s * vPos.x + c * vPos.z);\n \n    return vResult;\n}\n \nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.xy)-r1,p.z);\n    return length(q)-r2;\n}\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.yz)-r1,p.x);\n    return length(q)-r2;\n}\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\n    return length(vPos.xz) - r;\n}\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n{\n    vec3 vDist = (abs(vPos) - vSize);\n    return max(vDist.x, max(vDist.y, vDist.z));\n}\n \nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n    vec3 vClosest = max(min(vPos, vSize), -vSize);\n    return length(vClosest - vPos) - fRadius;\n}\n \nfloat GetDistanceWinder( const in vec3 vPos )\n{\n   float fWinderSize = 0.15;\n   float fAngle = atan(vPos.x, vPos.z) + vPos.y * 2.0;\n\t\n   float fBump = 1.0 + sin(fAngle * 10.0 * kPI) * 0.05;\n   return length(vPos + vec3(0.0, -1.0 - 0.2, 0.0)) * fBump - fWinderSize;\t\n}\n\nvec4 GetDistanceClock( const in vec3 vPos )\n{\n\tconst float fRadius = 1.0;\n\tconst float fThickness = 0.1;\n\tconst float fInsetRadius = 0.9;\n\tconst float fInsetDepth = 0.1;\n\tfloat fTorusDist = GetDistanceXYTorus(vPos, 1.0, fThickness);\n\t\n\tfloat fCylinderDist = length(vPos.xy) - fRadius;\n\tfloat fCylinderCap = abs(vPos.z) - fThickness;\n\tfCylinderDist = max(fCylinderDist, fCylinderCap);\n\tfloat fDist = min(fTorusDist, fCylinderDist);\n\t\n\tfloat fWinderDist = GetDistanceWinder(vPos);\n\tfDist = min(fDist, fWinderDist);\n\tvec4 vResult = vec4(fDist, 2.0, 0.0, 0.0);\n\t\n\tfloat fInsetDist = length(vPos.xy) - fInsetRadius;\n\tfloat fInsetCap = abs(vPos.z - fThickness) - fInsetDepth;\n\t\n\tvec4 vInsetCapDist = vec4(fInsetCap, 3.0, vPos.x, vPos.y);\n\tvec4 vInsetDist = vec4(fInsetDist, 2.0, 0.0, 0.0);\n\t\n\tvInsetDist = DistCombineIntersect(vInsetDist, vInsetCapDist);\n\t\n\tvResult = DistCombineSubtract(vResult, vInsetDist);\n\t\n\t\n\tfloat fHandSeconds = time;\n\t\n\tfHandSeconds = floor(fHandSeconds) + (pow(fract(fHandSeconds), 50.0));\n\tfloat fHandAngle = -fHandSeconds * kPI * 2.0 / 60.0;\n\t\n\tvec3 vHandDomain = RotateZ(vPos, fHandAngle);\n\tfloat fHandHeight = 0.05;\n\tvHandDomain.z -= fThickness - fInsetDepth + fHandHeight;\n\tfloat fHandDist = length(vHandDomain.xz) - 0.01;\n\tfHandDist = max(fHandDist, (abs(vHandDomain.y + 0.4) - 0.4));\n\t\n\tvec4 vHandDist = vec4(fHandDist, 4.0, 0.0, 0.0);\n\t\n\tvResult = DistCombineUnion(vResult, vHandDist);\n\t\n\treturn vResult;\n}\n \nvec3 WarpDomain( const in vec3 vPos )\n{\n\tvec3 vResult = vPos + vec3(0.0, 0.1, 0.1);\n\n\tfloat fUnbend = clamp(atan(vResult.y, vResult.z), 0.0, kPI * 0.9);\n\t\n\tfloat t = abs(fract(time/50.)*2.-1.);\n\tvResult = mix(vResult, RotateX(vResult, -fUnbend), t );\n\t \n\tfloat fDroopBlend = max(-vResult.y, 0.0);\t\n\tvResult.y = mix(vResult.y, vResult.y + fDroopBlend * 0.4, t);\n\tvResult.z = mix(vResult.z, vResult.z + sin(vResult.x * 4.0  + vResult.y * 6.0 + time) * fDroopBlend * 0.05, t);\n\treturn vResult;\n}\n\n// Utilities\nfloat udBox(vec3 p, vec3 s) { return length(max(abs(p)-s,0.0)); }\n\nfloat GetDistanceChain(vec3 vPos)\n{\n\tvec3 vChainDomain = vPos;\n\tvChainDomain.y = fract(vChainDomain.y + 0.5) - 0.5;\t\t\n\tfloat fDistTorus1 = GetDistanceXYTorus(vChainDomain, 0.35, 0.1);\n\tvChainDomain.y = fract(vChainDomain.y + 1.0) - 0.5;\t\t\n\tfloat fDistTorus2 = GetDistanceYZTorus(vChainDomain, 0.35, 0.1);\n\tfloat fDist = min(fDistTorus1, fDistTorus2);\n\treturn fDist;\n}\n\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\n{\n\treturn mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec2 DistCombineIntersect( const in vec2 v1, const in vec2 v2 )\n{\n\treturn mix(v2, v1, step(v2.x,v1.x));\n}\nvec2 DistCombineSubstract( const in vec2 v1, const in vec2 v2 )\n{\n\treturn DistCombineIntersect(v1, vec2(-v2.x, v2.y));\n}\n\nfloat GetDistanceSceneChain( const in vec3 vPos, float fRepeat )\n{             \n\tvec2 vDistFloor = vec2(10000.0, -1.0);\n\t \n\tvec2 vChainTile;\n\tvec3 vChainDomain = vPos;\n\n\tvChainDomain.xz += fRepeat / 2.0;\n\tvChainDomain = DomainRepeatXZGetTile(vChainDomain, vec2(fRepeat), vChainTile);\n\tfloat fSpeed = (sin(vChainTile.y + vChainTile.x) + 1.1) * 0.5;\n\t\n\tvec2 vDistChain = vec2( GetDistanceChain(vChainDomain), 100.0);\n\n\tvec2 vDistChainHole = vec2( GetDistanceCylinderY(vChainDomain, 0.7), 2.0);\t\n\tvec2 vResult = vDistFloor;\n\tvResult = DistCombineSubstract( vResult, vDistChainHole );\n\tvResult = DistCombineUnion( vResult, vDistChain );\n\t\n\tfloat bounding = udBox(vPos-vec3(0.0,17.0,0.0), vec3(fRepeat,20.0,fRepeat));\n\tvResult.x = max(bounding, vResult.x);\t\n\t\n\treturn vResult.x;\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nfloat voronoi( in vec2 x )\n{\n\t   \n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec2  o = hash( n + g );\n\t\tvec2  r = g - f + (0.5+0.5*sin(6.2831*o));\n\tfloat d = dot( r, r );\n\t\tif( d<m.x )\n\t\t\tm = vec3( d, o );\n\t}\n\n\t vec2 c = vec2( sqrt(m.x), m.y+m.z );\n\t\n\treturn 0.5 + 0.5*cos( c.y*6.2831 + 0.0 );\t\n}\n\nconst float lineWidth = 0.059;\nconst float border = 0.05;\nconst float scale = 0.07;\nfloat line(vec2 p, vec2 s, vec2 e) {s*=scale;e*=scale;float l=length(s-e);vec2 d=vec2(e-s)/l;p-=vec2(s.x,-s.y);p=vec2(p.x*d.x+p.y*-d.y,p.x*d.y+p.y*d.x);return length(max(abs(p-vec2(l/2.0,0))-vec2(l/2.0,lineWidth/2.0),0.0))-border;}\nfloat A(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(1,5)));d=min(d,line(p,vec2(1,5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(5,8)));return d;}\nfloat C(vec2 p){float d=1.0;d=min(d,line(p,vec2(5,1.5),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));return d;}\nfloat L(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));return d;}\nfloat R(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(1,5)));d=min(d,line(p,vec2(1,5),vec2(3.5,5)));d=min(d,line(p,vec2(3.5,5),vec2(5,8)));return d;}\nfloat M(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(3,4)));d=min(d,line(p,vec2(3,4),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,8)));return d;}\nfloat AT(vec2 p){float d=1.0;d=min(d,line(p,vec2(5, 1.5),vec2(1, 1.5)));d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));d=min(d,line(p,vec2(3.5,5),vec2(5, 5)));d=min(d,line(p,vec2(5,5),vec2(5,1.0)));return d;}\nvec2 rot(vec2 v, float angle){float c = cos(angle); float s = sin(angle); return mat2(c, -s, s, c)*v;}\nconst vec3 boundingSize = vec3(40.,30.,1.0)*scale;\nvec2 pv = vec2(0);\n\n#define __ pv = pv + vec2(0.5,0);\n\n\n#define P p.xy-(pv = pv + vec2(0.5,0))\n#define _(v) letters = min(letters,v(P));\n\nvec4 sceneText1(const in vec3 p1)\n{\t\n\tvec3 p = p1;\n\tp.x += 1.2;\n\tp.xz = rot(p.xz,3.1416);\t\n\tfloat letters  = 1e10;\t\n\tp += vec3 ( 4.0, 0.2, 0. );\n\tfloat bounding = udBox(p-vec3(2.0,0.0,0.4), boundingSize);\n   \tpv = vec2(0); _(AT)__ _(R)_(M)_(M)_(C)_(A)_(L)\n\tletters = max(bounding, letters);\t\n\tvec4 vHandDist = vec4(letters, 4.0, 0.0, 0.0);\n\treturn vHandDist  ; \n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{         \n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n   \n\tvec3 vClockDomain = WarpDomain(vPos + vec3(0.0, -0.1, -0.45));\n\tvClockDomain.y += 0.2;\t\n\tvResult = DistCombineUnion(vResult, GetDistanceClock(vClockDomain));\t\n    \tvResult = DistCombineUnion(vResult,  sceneText1(vPos));    \n\tvResult = DistCombineUnion(vResult, vec4(udBox(vPos+vec3(0.,3.,0.),vec3(5.,.2,5.)),5.,vPos.xz)); // floor\n\tvResult = DistCombineUnion(vResult, vec4(udBox(vPos+vec3(0.,1.,0.),vec3(3., 1.,.2)),1.,vPos.xy)); // wall    \n\tvResult = DistCombineUnion(vResult, vec4(GetDistanceSceneChain(vPos, 5.),6.,vPos.xy)); // wall\n\t\n\tvec2 t = vec2(3.,0.0);\n\tvec2 q = vec2(length(vPos.xy)-3., max(0.,abs(vPos.z)-1.));\n\tvec3 p = vPos*1.5;\n\tfloat min_wave = cos(p.x*p.y/100.)*cos(p.x * 23. + cos(p.z * 3.))/280. ;\n\tfloat v1 = abs(voronoi(p.xz*1.5))/8.;\n\tfloat noise = 0.;\n\tfloat terrain = 0.;\n\tfloat v = abs(p.y + noise + min_wave + terrain + 100.1 ) - 90.;\n\tvResult = DistCombineUnion(vResult, vec4(v, 7., p.xz)); // wall\n  \n\treturn vResult;\n}\n \nvec3 GetWatchFaceColour( const vec2 vUV )\n{\n        float fRadius = length(vUV);\n       \n        float fFraction = (atan(vUV.x, -vUV.y) / (kPI * 2.0)) + (0.5 / 60.0);\n               \n        float fTickValue = fFraction * 60.0;   \n        float fTickIndex = floor(fTickValue);\n        float fTickFraction = fract(fTickValue);\n               \n\tfloat fTickLength = 0.25;       \n\tfTickLength += step( fract(fTickIndex / 10.0), 0.5 / 10.0 ) * 0.1;\n\tfTickLength += step( fract(fTickIndex / 5.0), 0.5 / 5.0 ) * 0.05;\n\t\n\tfloat fTickWidth = 0.2;\n\tfloat fInTickSegment = step(abs(fTickFraction - 0.5), fTickWidth);\n\t\n\tfloat fInTickRadiusOuter = step(fRadius, 0.8);\n\tfloat fInTickRadiusInner = step(1.0 - fTickLength, fRadius);\n\t\n\t// 1.0 if not one of these...\n\tfloat fBlend = 1.0 - fInTickSegment * fInTickRadiusOuter * fInTickRadiusInner;\n\t\n\t// central dot\n\tfBlend = fBlend * step(0.025, fRadius);                                 \n\t\n\treturn mix(vec3(0.05), vec3(0.95), fBlend);\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (1.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 grid (vec2 frag) {\n\tfrag *= 10.0;\n\tfloat random = rand (floor (frag));\n\tvec2 black = smoothstep (1.0, 0.9, cos (frag * 3.14159 * 2.0));\n\tvec3 color = hsv2rgb (vec3 (random, 1.0, 1.0));\n\tcolor *= black.x * black.y * smoothstep (1.0, 0.1,length(fract(frag) - 0.5));\n\tcolor *= 0.5 + 0.8 * cos (random * time ); \n\treturn vec4 (color * vec3(1.0,1.0,1.0), 1.0);\n}\nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\n    C_Material mat;\n    mat.fR1 = 1.;\n    if(vObjId.x < 1.5)\n    {\n        // wall\n        mat.fR0 = 0.02;\n        mat.fSmoothness = 0.0;\n\tvec2 vBrickPos = vObjId.yz;\n\tvBrickPos.x += floor(vBrickPos.y * 3.0) * 0.5;\n\tvBrickPos = fract(vBrickPos * vec2(1.0, 3.0));\n\t   \n        float fFade = 1.0 - step(vBrickPos.x, 0.96) * step(vBrickPos.y, 0.9);\n        //mat.cAlbedo = vec3(0.9, 0.4, 0.2) * (0.3 + fFade * 0.6);\n\t    \n\tfloat v = voronoi((vPos.yz+vPos.x)*500.);\n\tmat.cAlbedo = vec3(0.9, 0.4, 0.2) * (0.3 + fFade * 0.6) * (v/5.+.3);\n\tmat.fR1 = (v*v)/10.0;\n    }\n    else\n    if(vObjId.x < 2.5)\n    {\n        // silver\n        mat.fR0 = 0.95;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.9, 0.9, 0.91);\n    }\n    else\n    if(vObjId.x < 3.5)\n    {\n\t    // clock face\n            mat.fR0 = 0.01;\n            mat.fSmoothness = 0.9;\n            mat.cAlbedo = GetWatchFaceColour( vObjId.yz );\n    }\n    else\n    if(vObjId.x < 4.5)\n    {\n        // hand\n        mat.fR0 = 0.01;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.95, 0.05, 0.05);\n    }\n    else\n    if(vObjId.x < 5.5)\n    {\n        // floor      \n\t\tmat.fR0 = 0.10;\t    \n\t\tmat.fSmoothness = 1.2;\n\t\t\n\t\tvec2 vBrickPos = vObjId.yz;\n\t\tvBrickPos.x += floor(vBrickPos.y * 3.0) * 0.5;\n\t\tvBrickPos = fract(vBrickPos * vec2(1.0, 3.0));\n\t   \n\t\tfloat fFade = 1.0 - step(vBrickPos.x, 0.96) * step(vBrickPos.y, 0.9);\n\t\n\t    \tfloat v2 =  voronoi(vObjId.yz*5.);\n\t\tvec3 cAlbedo = vec3(0.0, 0.11, 0.0) * (0.3 + fFade * 0.6) * v2;\n\t\t//vec3 ghsv = grid(vec2(vBrickPos/8.)).xyz / 5.;\n\t    \tmat.cAlbedo = mix(cAlbedo, cAlbedo, .2);\n    }\n\t else\n\tif(vObjId.x < 6.5)\n\t{\n\t\t// hand\n\t\tmat.fR0 = 0.41;\n\t\tmat.fSmoothness = 0.2;\n\t\tmat.cAlbedo = vec3(0.95, 0.35, 0.00) ;\n\t} else\n\tif(vObjId.x < 7.5)\n\t{\n\t\t// hand\n\t\tmat.fR1 = 0.1;\n\t\tmat.fR0 = .001;\n\t\tmat.fSmoothness = .05;\n\t\tmat.cAlbedo = vec3(0.15, 0.15, 0.15) ;\n\t}\n    return mat;\n}\nvec3 GetLightDirection()\n{\n    vec3 vLightDir = vec3(1.0, 2.0, 1.0);\n\n    #ifdef ENABLE_MONTE_CARLO       \n    vLightDir += gRandomNormal * 0.01;\n    #endif\n    return normalize(vLightDir);\n}\nvec3 GetLightCol()\n{\n    return vec3(1.0, 0.7, 0.5) * 10.0;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat v = abs(dot(vDir.xyz, vDir.yzx));\n\tfloat fBlend =   vDir.y * 0.5 + 0.5 + v*v;  \n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.25, 0.5, 1.0) * 4.0, fBlend);\n}\n \nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n \n#define kFogDensity 0.075\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(intersection.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    col = mix(cFog, col, fFogAmount);\n    #endif\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    float fDelta = 0.01;\n \n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n \n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n \n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n \n    return normalize( vNormal );\n}\n \n#define kRaymarchEpsilon 0.01\n#define kRaymarchMatIter 256\n#define kRaymarchStartDistance 0.01\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{       \n    result.fDistance = kRaymarchStartDistance;\n    result.vObjectId.x = 0.0;\n                             \n    for(int i=0;i<=kRaymarchMatIter;i++)             \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos );\n        result.vObjectId = vSceneDist.yzw;\n \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n        {\n            break;\n        }                       \n \n        result.fDistance = result.fDistance + vSceneDist.x;   \n    }\n     \n      \n    if(result.fDistance >= fMaxDist)\n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n        result.fDistance = 1000.0;\n    }\n}\n \nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n    C_Ray shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n \n    C_HitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n                                                                                                       \n    return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );         \n}\n \n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vNormal, -vView);\n    fDot = min(max((1.0 - fDot), 0.0), 1.0);\n    float fDot2 = fDot * fDot;\n    float fDot5 = fDot2 * fDot2 * fDot;\n    return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n    return max(0.0, dot(vLightDir, vNormal));\n}\n \nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{         \n    vec3 vHalf = normalize(vLightDir - ray.vDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n \n    float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n \n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n \n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n    vec3 vPos = intersection.vPos;\n     \n    float fAmbientOcclusion = 1.0;\n     \n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n        fDist += 0.1;\n \n        vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n \n        fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                 \n    }\n     \n    return fAmbientOcclusion;\n}\n \nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n    vec3 cScene ;\n   \n    vec3 vSpecularReflection = vec3(0.0);\n    vec3 vDiffuseReflection = vec3(0.0);\n   \n    //float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n    //vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n    vec3 vAmbientLight = GetAmbientLight(vNormal) * material.fR1;\n\t\n    vDiffuseReflection += vAmbientLight;\n   \n    //vSpecularReflection += cReflection * fAmbientOcclusion;\n    vSpecularReflection += cReflection;\n             \n   // #ifdef ENABLE_DIRECTIONAL_LIGHT\n    vec3 vLightDir = GetLightDirection();\n      \n    float fShadowBias = 0.05;           \n    float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, 10.0 );\n    vec3 vIncidentLight = GetLightCol() * fShadowFactor;\n   \n    vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                               \n    vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n   // #endif ENABLE_DIRECTIONAL_LIGHT\n   \n    vDiffuseReflection *= material.cAlbedo;             \n    \n    #ifdef ENABLE_SPECULAR\n    float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n   \n    return cScene;\n}\n \nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 16.0, 32);\n                       \n    vec3 cScene;\n \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n \n        // use sky gradient instead of reflection\n        vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n \n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n \n    ApplyAtmosphere(cScene, ray, intersection);\n \n    return cScene;\n}\n \nvec3 GetSceneColour( const in C_Ray ray )\n{                                                         \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 30.0, 256);\n               \n    vec3 cScene;\n     \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n \n        #ifdef ENABLE_MONTE_CARLO\n        vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n        #endif\n \n        vec3 cReflection;\n        #ifdef ENABLE_REFLECTIONS   \n        {\n            // get colour from reflected ray\n            float fSepration = 0.05;\n            C_Ray reflectRay;\n            reflectRay.vDir = reflect(ray.vDir, vNormal);\n            reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n                                                                 \n            cReflection = GetSceneColourSimple(reflectRay);                                                                       \n        }\n        #else\n        cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                             \n        #endif\n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n     \n    ApplyAtmosphere(cScene, ray, intersection);\n     \n    return cScene;\n}\n \nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\n    vec2 vPixelCoord = gl_FragCoord.xy;\n    #ifdef ENABLE_MONTE_CARLO\n    vPixelCoord += gPixelRandom.zw;\n    #endif\n    vec2 vUV = ( vPixelCoord / resolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n \n    vViewCoord *= 0.75;\n     \n    float fRatio = resolution.x / resolution.y;\n \n    vViewCoord.y /= fRatio;                         \n \n    ray.vOrigin = vPos;\n \n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n       \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);       \n}\n \nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n \n    GetCameraRay(vPos, vForwards, vUp, ray);\n}\n \nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n \nvec3 Gamma( const in vec3 cCol )\n{\n    return cCol * cCol;\n}\n \nvec3 InvGamma( const in vec3 cCol )\n{\n    return sqrt(cCol);\n}\n \n \nvec3 Tonemap( const in vec3 cCol )\n{\n    // simple Reinhard tonemapping operator   \n    vec3 vResult = cCol / (1.0 + cCol);\n \n    return Gamma(vResult);\n}\n \nvec3 InvTonemap( const in vec3 cCol )\n{\n    vec3 vResult = cCol;\n    vResult = clamp(vResult, 0.01, 0.99);\n    vResult = InvGamma(vResult);\n    return - (vResult / (vResult - 1.0));\n}\n \nvoid mainBuff(  out vec4 fragColor, in vec2 fragCoord )\n{\n    float pan = 1.;\n    float zoom = 3.;\n    vec2 r = resolution;\n    vec2 p = gl_FragCoord.xy/r;\n    surfaceSize=vec2(pan, zoom);\n\tsurfacePosition=((p-.5)*surfaceSize+(mouse+.5)*8.);\n    \n    #ifdef ENABLE_MONTE_CARLO           \n    CalcPixelRandom();\n    #endif\n     \n    C_Ray ray;\n     \n    const float fCamreaInitialHeading = -0.6;\n    const float fCamreaInitialElevation = 0.5;\n    const float fCamreaInitialDist = 4.5;\n    const float fOrbitSpeed = 1.0;\n   \n    // This magic stolen from other 3d pan/zoom examples\n    float fZoom = surfaceSize.y * 0.5 + 0.4;\n   \n    vec2 vCenterPosition = (0.5 - ( gl_FragCoord.xy / resolution )) * surfaceSize + surfacePosition;\n    float fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\n    float fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n   \n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n   \n    #ifdef ENABLE_MONTE_CARLO           \n    float fDepthOfField = 0.025;\n    vCameraPos += gRandomNormal * fDepthOfField;\n    #endif\n     \n    GetCameraRayLookat( vCameraPos, vec3(0.0, -0.5, 0.2), ray);\n     \n    vec3 cScene = GetSceneColour( ray ); \n      \n    float fExposure = 2.5;\n    cScene = cScene * fExposure;\n     \n    #ifdef ENABLE_MONTE_CARLO                             \n    vec3 cPrev = texture2D(backbuffer, gl_FragCoord.xy / resolution).xyz;\n    // add noise to pixel value (helps values converge)\n    cPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n    cPrev = InvTonemap(cPrev);\n    // converge speed\n    float fBlend = 0.1;\n    vec3 cFinal = mix(cPrev, cScene, fBlend);\n    #else\n    vec3 cFinal = cScene;\n    #endif\n   \n    cFinal = Tonemap(cFinal);\n         \n    float fAlpha = 1.0;\n     \n    fragColor = vec4( cFinal, fAlpha );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmainBuff(fragColor, fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsVGzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsy3z1", "name": "Sphere lit outline", "author": "jsharifi", "description": "Attempt to help https://www.reddit.com/r/GraphicsProgramming/comments/daj3ln/some_advice_for_shader_optimization_for_unity/", "tags": ["light", "sphere", "normal"], "likes": 0, "viewed": 166, "date": "1569700852", "time_retrieved": "2024-06-20T19:45:34.800994", "image_code": "const float sphere_screen_radius = 0.4;\nconst float scatter_light_threshold = 0.9;\n\nvec3 sphere_normal(vec2 uv) {\n\tvec2 xy = (uv);\n    float z = sphere_screen_radius - length(xy);\n    if (z < 0.0) return vec3(0.0);\n    \n    vec3 n = normalize(vec3(xy.x, xy.y, z));\n    return(n);\n}\n\nfloat sphere_surface_dot(vec3 surface_norm, vec3 approach) {\n    return(dot(surface_norm, normalize(approach) ));\n}\n\nvec3 vector_along_y_plane() {\n   float theta = iTime;\n   vec3 v = normalize(vec3(cos(theta), 0.0, sin(theta)));\n   return(v); \n}\n\nvec3 camera_look_dir = normalize(vec3(0.0, 0.0, 1.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 norm = sphere_normal(uv);\n    vec3 approach = vector_along_y_plane();\n    \n    float direct_light = clamp(sphere_surface_dot(norm, approach), 0.0, 1.0);\n    vec3 col = vec3(abs(norm.x), norm.yz) * direct_light;\n    \n    float indirect_light = 1.0 - dot(norm, camera_look_dir);\n    if (indirect_light > scatter_light_threshold && direct_light > 0.0) {\n        float rayleigh_k = (1.0 - direct_light) * (indirect_light - scatter_light_threshold) / (1.0 - scatter_light_threshold);\n        col = mix(col, vec3(1.0), pow(rayleigh_k, 3.0 * indirect_light));\n    }\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsy3z1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsy3zm", "name": "[twitch] The Orb of Great Power", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/TheOrbOfGreatPower.glsl", "tags": ["3d", "raymarching", "explosion", "translucency"], "likes": 30, "viewed": 532, "date": "1569880011", "time_retrieved": "2024-06-20T19:45:36.007139", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/TheOrbOfGreatPower.glsl\n*/\n\nfloat time=0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat rnd(float a) {\n  return fract(sin(a*452.655)*387.521);  \n}\n\nvec3 rnd3(float a) {\n  return fract(sin(a*vec3(845.652,257.541,289.675))*vec3(354.852,685.527,947.544));\n}\n\nvec3 rndcol(float a) {\n  vec3 r=rnd3(a);\n  //r/=dot(r,vec3(0.33));\n  r/=max(r.x, max(r.y,r.z));\n  return r;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*357.542+uv.yx*685.427),vec2(925.674)));\n  \n}\n\nvec3 kifs(vec3 p, float t, float t3) {\n  \n  vec3 bp=p;\n  float s=0.0 + smoothstep(0.0,1.0,fract(t3))*10.0;\n  for(int i=0; i<3; ++i) {\n    float t2 = t + float(i);\n    p.xz *= rot(t2);\n    p.xy *= rot(t2*0.7);\n    \n    // using smooth minimum on all 3 channels to make a \"smooth\" symmetry\n    p=smin(p, -p, -3.0);\n    //p=abs(p);\n    p-=s;// + sin(t*0.2-length(p)*1.0) * 0.5;\n    s*=0.7;\n  }\n  \n  \n  return p;\n}\n\nfloat exspeed = 0.25;\nfloat explode(vec3 p, float t, float offset) {\n  \n  // rotating and swirling in all directions\n  p.xz *= rot(p.y*0.09+t*0.15);\n  p.xy *= rot(p.z*0.052+t*0.18);\n  \n  float t1 = t * exspeed + offset;\n  vec3 p2 = kifs(p, t*0.1, t1);\n  vec3 p3 = kifs(p+vec3(3,2,1), t*0.13, t1);\n  \n  float fade = 1.0-pow(fract(t1),10.0);\n  \n  float d1 = length(p2)-1.5*fade;\n  d1=min(d1, length(p2.xz)-0.8*fade);\n  float d2 = length(p3)-1.4*fade;\n  d2=min(d2, length(p3.xz)-0.8*fade);\n  \n  return smin(d1,d2, -1.0);\n}\n\nfloat box(vec3 p, float r) {\n  p=abs(p)-r;\n  return max(p.x, max(p.y,p.z));\n}\n\nfloat box(vec2 p, float r) {\n  p=abs(p)-r;\n  return max(p.x, p.y);\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\n\nfloat at=0.0;\nfloat at2=0.0;\nbool metal=false;\nvec3 pos1 = vec3(0);\nvec3 pos2 = vec3(0);\nfloat map(vec3 p) {\n  \n  #if 0\n  // having fun with repetition and rotations\n  float t=time*0.2;\n  p.z += t*15;\n  p.x += sin(p.z*0.037+t)*33;\n  p.y += sin(p.z*0.027+t*0.7)*23;\n  p.xy *= rot(p.z*0.02+t*5.0);\n  //p.xz *= rot(p.y*0.015+t*0.7);\n  \n  float dist = 35;\n  p.z = (fract(p.z/dist-0.5)-0.5)*dist;\n  p=abs(p);\n  #endif\n    \n  // we compute two explosion at the same time\n  // offseted in time so one explosion start when the other disappear\n  float m1 = explode(p+pos1, time, 0.0);\n  float m2 = explode(p+pos2, time, 0.5);\n  \n  at += 0.8/(2.0+abs(m1));\n  at2 += 0.8/(2.0+abs(m2));\n  \n  float m3 = min(abs(m1),abs(m2));\n  \n  vec3 bp=p;\n  bp += smoothstep(-0.5,0.5,sin(p.yzx*1.0))*0.2;\n  float other = (length(bp)-15.0)*0.8;\n  \n  #if 0\n  // Tried to add a \"cage\" but it's less great\n  for(int i=0;i<2;++i) {\n    float t3=time*0.1+i;\n    p.xz *= rot(0.7);\n    p.xy *= rot(0.7);\n    p=abs(p)-5.6;\n    //p=smin(p, -p, -2.0)-3;\n  }\n  float s=0.5;\n  other=min(other, cyl(p.xy, s));\n  other=min(other, cyl(p.yz, s));\n  other=min(other, cyl(p.xz, s));\n  //other=smin(other, length(bp)-25,-10);\n  other=max(other, length(bp)-35);\n  \n  //other = max(-(length(p)-8.5),sqrt(abs(p.x)+abs(p.y)+abs(p.z))-1.2*3);\n  #endif \n  \n  metal=other<m3;\n  \n  return min(m3, other);\n}\n\nvoid cam(inout vec3 p) {\n  \n  float t=time*0.3;\n  p.xz *= rot(t);\n  p.xy *= rot(t*1.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  time = mod(iTime, 300.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // pick a random position for each explosion\n  pos1 = (rnd3(floor(time*exspeed))-0.5) * 20.0;\n  pos2 = (rnd3(floor(time*exspeed+0.5)+37.2)-0.5) * 20.0;\n  \n  float fade1 = 1.0-pow(fract(time*exspeed),10.0);\n  float fade2 = 1.0-pow(fract(time*exspeed+0.5),10.0);\n  \n  // pick a random color for each explosion\n  vec3 c1 = rndcol(floor(time*exspeed)+17.3);\n  vec3 c2 = rndcol(floor(time*exspeed+0.5)+37.5);\n  \n  vec3 s=vec3(0,0,-60);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  cam(s);\n  cam(r);\n  \n  float dither = mix(1.0, rnd(uv), 0.1);\n  \n  vec2 off=vec2(0.01,0);\n  \n  vec3 col=vec3(0);\n  vec3 p=s;\n    // this is done to ensure the loop is not unrolled, so compile time doesnt explode\n  float iterationcount = (90.0+min(time,0.0));\n  for(float i=0.0; i<iterationcount; ++i) {\n    // we use the absolute value of the distance field, so we can also march inside the surface\n    float d=abs(map(p))*dither;\n    if(d<0.01) {\n      if(metal) {\n        vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        r=reflect(r,n);\n      }\n      // instead of breaking when we find a surface, we continue to march forward with a slight offset\n      d=0.1;\n      //break;\n    }\n    col += pow(at * 0.010,3.0) * c1 * fade1;\n    col += pow(at2 * 0.010,3.0) * c2 * fade2;\n    p+=r*d;\n  }\n    \n  col *= 3.0;\n  \n  // the dark souls\n  //col *= smoothstep(0.0,0.01,length(uv)-0.25);\n  \n  // bloom to white on primary colors\n  col += max(vec3(0),col.yzx-1.0);\n  col += max(vec3(0),col.zxy-1.0);\n  \n  //col=smoothstep(0,1,col);\n  col=1.0-exp(-col);\n  col=pow(col, vec3(1.0));\n  \n  \n  //col += pow(1-i/101.0,6) * 1.5;\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsy3zm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsy3zR", "name": "Musical raymarching", "author": "zodiax", "description": "Following Inigo Quilez's tutorial on raymarching. Did first 3h and since not have spare time in next weeks I decided to publish what I have so far. Will make next versions soon.", "tags": ["raymarching"], "likes": 3, "viewed": 189, "date": "1569535369", "time_retrieved": "2024-06-20T19:45:37.662367", "image_code": "#define _tries 80\n#define _renTreshold 0.001\n\n//RENDERING OBJECTS HERE\n\n\t\tfloat smin(float a, float b, float k)// smooth minimum\n        {\n            float m = max(k - abs(a-b),0.0); //spike fucntion - checking when they are close enough to smooth\n        \tfloat s = min(a,b) - pow(m,2.)/(k*4.0);\n            return s;\n        }\n\n\t\tfloat smax(float a, float b, float k)// smooth maximum\n        {\n            float m = max(k - abs(a-b),0.0); //spike fucntion - checking when they are close enough to smooth\n        \tfloat s = max(a,b) + pow(m,2.)/(k*4.0);\n            return s;\n        }\n\n\t\t//Music animations\n\t\tfloat GatherSoundInfo(int SampleWished)// 0 - 512\n            {\n                return texelFetch(iChannel0, ivec2(float(SampleWished), 0), 0).r;\n            }\n\n\t//Cylinder\n\tfloat sdCappedCylinder( vec3 p, float h, float r )//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n        {\n          vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\n\t//Elipsoid\n\tfloat elipsoid(vec3 lastStep, vec3 rad)\n    {\n    \tfloat k0 = length(lastStep/rad);\n        float k1 = length(lastStep/rad/rad);\n        return k0*(k0-1.0)/k1;\n    }\n\n\t//Sphere\n\tfloat sphere(vec3 lastStep, float radius)\n    {\t\n    \treturn length(lastStep) - radius;\n    }\n\n\t//Character\n    vec2 character(vec3 lastStep)\n    {\n        \n        float time = 0.5 + sin(iTime/2.)/5.;\n        vec3 radius = vec3(0.25,0.25,0.25);\n        float parabola = 4.0*time*(1.0-time)- radius.y*3./4.; //up and down parabolic movement\n        \tfloat dParabola = 3.0*(1.0-2.0*time);//derivative to calc the angle\n        \tvec2 u = normalize(vec2(1.0,dParabola));\n        \tvec2 v = normalize(vec2(-dParabola, 1.0));\n\t\tfloat squashfactor = 0.5 + 0.5* parabola;\n        float strechfactor = 0.5 + 0.5*(1.-parabola);\n        radius.y *= squashfactor;\n        radius.xz *= strechfactor;\n        vec3 center = vec3(0.0,parabola,0.0);\n        \n        \tvec3 q = lastStep - center;\n        \t//q.xz = vec2(dot(u,q.xz),dot(v,q.xz));\n        \t\t//////////////ALL THE MODELLING OF THE HEAD\n        \t\t\t\t        \t\t\t\tfloat moveT = (step(cos(iTime),0.)*(-1.)+1.)*clamp(tan(iTime),-1.,1.)+step(cos(iTime),0.)*(-1.)*clamp(tan(iTime),-1.,1.);\n\n        \t\t\t//HEAD SHAPE\n        \t\t\tvec3 p = q + vec3(0.,0.,0.5);\n        \t\t\tfloat headP1 = elipsoid(p, vec3(0.55,0.6,.45));\n        \t\t\tp = vec3(pow(q.x,2.),q.yz)+vec3(-0.15,-0.35,0.48);\n        \t\t\tfloat headP2 = elipsoid(p, vec3(0.7,0.45,.45));\n        \t\t\t//Eyebrow\n        \t\t\tp = vec3(pow(q.x,2.),q.yz)+vec3(-0.2,-0.45,0.025);\n        \t\t\tp.xy = (mat2(3.,1.*sin(moveT),-1.,5.)/5.)*p.xy;// check pitagorian triplets\n        \t\t\tfloat headP3 = elipsoid(p, vec3(0.09,0.045,.03));\n        \t\t\t//Mouth\n        \t\t\tp = q + vec3(0.,0.4,0.25);\n        \t\t\t\tp.y += 2.*pow(p.x,2.)*0.7*moveT;\n        \t\t\tfloat headP4 = elipsoid(p, vec3(0.2,0.08,.2));\n        \t\t\t\n        \t\t\t//Combinig the parts\n        \t\t\tfloat head = smin(headP1,headP2,0.15);\n        \t\t\thead = smin(head, headP3, 0.08);\n        \t\t\thead = smax(head, -headP4,0.08);\n        \n        \t\t\t///NOSE\n        \t\t\tfloat d = elipsoid(q, radius);\n        \t\t\t\tvec3 h = q - vec3(0.0,0.25,-0.15);\n        \t\t\tfloat d2 = sphere(h, 0.15);\n        \t\t\t\th = vec3(abs(q.x),q.yz) - vec3(0.2,-0.03,-0.02);\n        \t\t\tfloat d3 = sphere(h, 0.1);\n\n        \t\t\td2 = smin(d2,d3,0.1);\n        \n        \t\t\tfloat nose = smin(d2,d,0.1);\n        \t\t\tnose = smin(nose, head, 0.03);\n        \n        \t\t\t///EYES\n         \n\t\t\t\t\th = q - vec3(0.35,0.3,-0.03);\n        \t\t\tfloat eyeRB = elipsoid(h, vec3(0.15,0.07,0.03));\n        \t\t\th = q - vec3(-0.35,0.3,-0.03);\n        \t\t\tfloat eyeLB = elipsoid(h, vec3(0.15,0.07,0.03));\n       \t\t\t\t\n        \t\t\th = q - vec3(0.35+(.07*moveT),0.3,-0.03);\n        \t\t\tfloat eyeR = sphere(h, 0.01);\n        \t\t\teyeR = smin(eyeR,eyeRB,0.04);\n  \t\t\t\t\th = q - vec3(-0.35+(.07*moveT),0.3,-0.03);\n        \t\t\tfloat eyeL = sphere(h, 0.01);\n        \t\t\teyeL = smin(eyeL,eyeLB,0.04);\n        \t\t\tfloat eyes = smin(eyeL, eyeR, 0.04);\n        \t\t\t        \n        \t\t\td = min(eyes, nose);\n        \t\t\t\n        //COLORING RESULT\n        vec2 result = vec2(d, 2.0);//DISTANCE AND IDENTIFIER\n        \n        \tif(eyeR<eyeRB || eyeL<eyeLB)\n            {\n            result.y = 3.0;\n            }\n        \tif(nose<eyes)\n            {\n            result.y = 4.0;\n            }\n        return result;\n    }\n\t//Glows\n\t\tvec2 glows(vec3 lastStep)\n\t\t{\n        \treturn vec2(1.,1.);\n        }\n\t//Musical cylinders\n\tfloat cylinders(vec3 lastStep)\n\t\t{\n        vec3 p = lastStep;\n        p.y += 0.5;\n        float height = .03;\n        float radius = 0.05;\n        float geo = 20.;\n        float dist = 0.7;\n        int parts = 10; \n        for(int i=0;i<parts;i++)\n        \t{\n                height = GatherSoundInfo(int(512./float(parts)*float(i)));\n        \t\tp.x = lastStep.x + sin((iTime/6.+3.151592*2./float(parts)*float(i)))*dist;\n                p.z = lastStep.z + cos((iTime/6.+3.151592*2./float(parts)*float(i)))*dist;\n                geo = min(sdCappedCylinder(p, radius, height ), geo);\n        \t}\t\n        return geo;\n        }\n\n//MAIN RENDERING FUCNCTION\nvec2 objects(vec3 lastStep)\n{\n    vec2 plane = vec2(lastStep.y - (-0.25),1.0);\n    //plane.x = lastStep.y - (((sin(lastStep.z*5.)*sin(iTime*0.2)+sin(lastStep.x*5.+iTime)*cos(iTime*0.7))/7.-0.45));\n    plane = vec2(lastStep.y - ((sin((lastStep.x)*2.)*(lastStep.x))*0.1*sin(lastStep.z)-0.5),1.0);\n    vec2 cylinders = vec2(cylinders(lastStep-vec3(0.0,0.0,-0.7)),5.);\n    vec2 character = character(lastStep-vec3(0.0,-0.2,0.0)); // check what is closer to the screen\n    float mixedFloor = smin(cylinders.x, plane.x, 0.1);\n    vec2 enviro = (plane.x < cylinders.x) ? plane : cylinders;\n    enviro.x = mixedFloor;\n    \n    return (enviro.x < character.x) ? enviro : character;\n}\n\n//END OF RENDERING OBJECTS\nvec3 calcNormal(vec3 localNormals)\n{\n    vec2 e = vec2(0.0001,0.0); //crete 2 variables - 1 null and other really small\n    return normalize(vec3(objects(localNormals+e.xyy).x - objects(localNormals-e.xyy).x,\n                          objects(localNormals+e.yxy).x - objects(localNormals-e.yxy).x,\n                          objects(localNormals+e.yyx).x - objects(localNormals-e.yyx).x)    \n    \t\t\t\t);\n}\nfloat castShadow(vec3 camPos, vec3 rayDirection)\n{\n\tfloat result = 1.0;\n    float dist = 0.01;\n    for(int i = 0; i<_tries; i++) //repeat 100 times or unless geometry found\n        {\n            vec3 lastStep = camPos + dist * rayDirection; // add the step to the ray\n            float renderableDist = objects(lastStep).x;\n\t\t\tresult = min(result,16.*renderableDist/dist);\n            if (result<0.0001) break;\n\t\t\tdist += renderableDist;\n            if (dist>20.) break;\n\n        }\n    return clamp(result,.0,1.);\n}\nvec2 castRay(vec3 camPos, vec3 rayDirection)\n{\n    float materialID = -1.;// initial mat\n    float dist = 0.01;//start with initial value of 0\n    for(int i = 0; i<_tries; i++) //repeat 100 times or unless geometry found\n        {\n            vec3 lastStep = camPos + dist * rayDirection; // add the step to the ray\n            vec2 renderableDist = objects(lastStep);\n            materialID = renderableDist.y;\n\n            if(dist < _renTreshold)\n                {\n                    break; //if the current distance from ray to shape is smaller than our threshold then finish the loop\n                }\n            else\n                {\n                    dist += renderableDist.x; // if the current distance is greater then the treshold then travel closer to it\n                }\n\n            if(dist > 20.0) \n                {\n                    break;   // far clip - do not render anything further than 20 // could be 0??\n                }\n        }\n    if(dist > 20.0) \n        {\n          \tdist = -1.0;  // far clip - do not render anything further than 20 // could be 0??\n        \tmaterialID = -1.0;\n        }\n    return vec2(dist,materialID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//coordinate system\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) /iResolution.y; // -1 do 1 na y, x dependent from y\n    \n    \n    //camera position and orienation\n    \t//STEADY CAMERA\n       // vec3 camPos = vec3(0.0, 0.0, 1.0); // camera 1m away from the center\n       // vec3 rayDirection = normalize(vec3(uv, -1.5)); // ray direction from Camera to Pixel, add near clip\n    \t//MOVING CAMERA\n    \tvec3 camLook = vec3(0.0, 0.5, -1.0);\n    \tfloat angle = 10.0 * iMouse.x/iResolution.x;//0.3 * iTime;\n    \tvec3 camPos = vec3(1.3*sin(angle),0.0,1.3*cos(angle));\n    \t\t//rotating the direction\n    \t\tvec3 ww = normalize(camLook - camPos);\n    \t\tvec3 uu = normalize(cross(ww, vec3(0.0,1.0,.0)));\n    \t\tvec3 vv = normalize(cross(uu,ww));\n    \tvec3 rayDirection = normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n    \t\n    //initial color, background color\n    vec3 color = vec3(0.4,0.75,1.0) - 0.2*rayDirection.y;\n    color = mix(color, vec3(0.7,0.75,0.8), exp(-10.0*rayDirection.y)); // fade out color when far\n    //COLORING\n      vec2 depthMapMaterial = castRay(camPos, rayDirection);\n\n    //Casting the ray\n    //color the geometry - geometry shows only when it is more than 0, otherwise use initial color\n    if(depthMapMaterial.y > 0.0)\n    {\n        float depthMap = depthMapMaterial.x;\n        //Normals\n    \tvec3 worldNormals = camPos + (depthMap * rayDirection);\n        vec3 localNormals = calcNormal(worldNormals);\n        \n        //Sun and light\n            //001 SUN\n            vec3 sunColor = vec3(7.0,4.5,3.0); //affetcted intesity after mate\n            vec3 sunDirection = vec3(0.8,0.4,0.2); \n            float sunReflectionFactor = clamp(dot(localNormals,sunDirection),0.0,1.0);\n                //shadows\n                   float SunShadows = castShadow(worldNormals + localNormals*0.001, sunDirection);\n\n            //002 SKY\n            vec3 skyColor = vec3(0.5,0.8,0.9); //affetcted intesity after mate\n            vec3 skyDirection = vec3(0.0, 1.0, 0.0);\n            float skyReflectionFactor = clamp(0.5 + 0.5 * dot(localNormals,skyDirection),0.0,1.0); // starting with minimal value of 0.5\n\n            //003 BOUNCE - BELOW\n            vec3 bounceColor = vec3(0.7,0.3,0.2); //affetcted intesity after mate\n            vec3 bounceDirection = vec3(0.0, -1.0, 0.0);\n            float bounceReflectionFactor = clamp(0.5 + 0.5 * dot(localNormals,bounceDirection),0.0,1.0); // starting with minimal value of 0.5\n                \n        //Object colors\n        //MATERIAL\n        vec3 material = vec3(0.18);\n        if(depthMapMaterial.y == 1.0)\n            {\n\t\t\t\tmaterial = vec3(0.02,0.09,0.02);\n                float f = smoothstep(.3,.3,sin(18.0*worldNormals.x)+sin(18.0*worldNormals.z));\n                material += f*vec3(0.06,0.06,0.02);\n            }\n        else if(depthMapMaterial.y == 2.0)\n            {\n\t\t\t\tmaterial = vec3(1.0,1.0,1.0);\n            }\n        else if(depthMapMaterial.y == 3.0)\n            {\n\t\t\t\tmaterial = vec3(0.2,0.2,0.2);\n            }\n        else if(depthMapMaterial.y == 4.0)\n            {\n\t\t\t\tmaterial = vec3(0.8,0.8,0.2)*0.4;\n                \n            }\n         else if(depthMapMaterial.y == 5.0)\n            {\n\t\t\t\tmaterial = vec3(.1,0.1,0.2);\n            }\n        \n        color = material * sunColor * sunReflectionFactor * SunShadows; //Add sun light and shadows\n        color += material * skyColor * skyReflectionFactor; //Add sky light\n        color += material * bounceColor * bounceReflectionFactor; //Add bounce light\n    }\n    \n    //Gamma correction - from physics to eye\n    color = pow(color, vec3(0.4545));\n    \n    //FinalColor\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsy3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsyGRh", "name": "Van damme's transformation", "author": "izo", "description": "Wave", "tags": ["2d", "sine", "scaling"], "likes": 0, "viewed": 242, "date": "1569682764", "time_retrieved": "2024-06-20T19:45:37.825461", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 effect = vec4((uv.x+uv.y)*abs(sin(iTime)),0,0,0.5);\n    //vec4 effect = vec4(0);\n    \n    vec2 distcord =  vec2( uv.x, uv.y / abs(sin((uv.x+iTime)*2.))); //vec2( uv.x, uv.y/0.1);\n    \n    vec4 tex = texture(iChannel0,distcord);\n    if(tex.y > 0.3 && tex.x < 0.25 && tex.z < 0.25)\n        tex = vec4(0);\n        \n    vec4 col = tex + effect;\n    // Output to screen\n    fragColor = col;\n}\n\n", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsyGRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt2SDt", "name": "Random Cells", "author": "gressettd", "description": "What can we do with 1d voronoi?", "tags": ["voronoi", "tiling"], "likes": 4, "viewed": 92, "date": "1567656366", "time_retrieved": "2024-06-20T19:45:37.825461", "image_code": "const float JITTER = 3.0;          // jitter Voronoi amount. 1 = stay in cell\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\n\nfloat Random2DS(vec2 p, float s)\n{\n\treturn fract(sin(dot(p,vec2(127.1,311.7)))*18.5453 * (1.0+s));\n}\n\n\n// Ala Fab. N.\n#define disp(p) ( -(JITTER-1.0)/2.0 + JITTER * (p) )\n\nvec2 Voronoi1D( vec2 u, float seed )\n{\n    vec2  n = floor( u );\n    float f = fract( u.x );\n\n\tvec2 m = vec2(1e5);\n    for( float g=-2.0; g<=2.0; g++ )\n        {\n            float o = Random2DS(n + vec2(g,0), seed);\n            float d = abs(g - f + disp(o));\n            if( d < m.x )\n                m = vec2( d, o );\n        }\n\n    return m;\n}\n\n\nvec4 RandomCell(vec2 uv, float scale, float seed)\n{\n    uv *= scale;\n    \n    vec2 vert = Voronoi1D(uv.yy, seed);\n    float vdist = vert.x;\n    float vid = vert.y;\n    \n    float hseed = Random1D(vert.y * seed)*100.0;\n    \n    vec2 horiz = Voronoi1D(vec2(uv.x + hseed, uv.y + hseed), seed);\n    float hdist = horiz.x;\n    float hid = horiz.y;\n        \n    vec4 rv = vec4(hid,vid,hdist,vdist);\n        \n    return rv;\n}\n\nvec4 RandomGrid(vec2 uv, float scale, int iterations, float lac, float seed)\n{\n    float dampen = 1.0 / (2.0 * scale);\n    vec4 rv = RandomCell(uv, scale, seed); \n    rv.xy *= dampen;\n    scale *= lac;\n    \n    for(int i=0; i<6 - 1; i++)\n    {\n\t\tdampen = 1.0 / (2.0 * scale);\n        vec4 cell = RandomCell(uv, scale, seed);\n        rv = vec4(rv.xy + (cell.xy*dampen), cell.wz);\n\t\t\n        scale *=lac;\n    }\n    \n   \n    return rv;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 p = (2.0 * U - iResolution.xy) / min(iResolution.x,iResolution.y);\n    \n\tp.y += iTime * 0.2;\n    float seed = Random1D(floor(iTime / 3.0)) + iDate.x + iDate.y;   \n    \n    vec4 cc = RandomGrid(p, 1.0, 6, 2.0, seed);\n    \n    float cellC = cc.z + cc.w;\n    vec3 col;\n    \n    // col = vec3(cc.x, cc.z, cc.w);\n    col = cc.xxy;\n        \n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt2SDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wt2XDt", "name": "lens bug", "author": "Pyramid", "description": "following a short calibration, it will proceed to find your dimension. please dont halt the process once started\none universe will be over quickly. just calm down and sit back. relax and maybe hold on to your hat", "tags": ["lens", "dimensionalcalibrator"], "likes": 2, "viewed": 162, "date": "1567552946", "time_retrieved": "2024-06-20T19:45:37.825461", "image_code": "float dist(vec2 origin, vec2 target)\n{\n    return abs(sqrt(pow(target.x+origin.x,2.)+pow(target.y+origin.y,2.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //pixel coord center origo\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=vec2(.5);\n    \n    //set aspect ratio\n    float ratio=iResolution.x/iResolution.y;\n    uv.x*=ratio;\n    \n    //set time\n    float t = 39.2+iTime/3.;//*.2+iTime*+sin(iTime*8.)/4000.;\n\n    //save o\n    vec2 o=uv;\n    \n    //Fisheye anim\n    //uv.x+=sin(t*6.)/6.;\n    //uv.y+=sin(t*2.)/12.;\n    \n    //Fisheye\n    float d=length(uv*2.);\n    float z = sqrt(1.0 - d * d);\n    float rad = atan(d, z) / 3.14159;\n    float phi = atan(uv.y, uv.x);\n    uv = vec2(rad*cos(phi)+.5,rad*sin(phi)+.5);\n    uv-=vec2(.5);\n    \n    //save o2\n    vec2 o2 = uv;\n\t\n    //uv=o;\n    \n    //circles ani\n    uv.x+=sin(t*6.)/6.;\n    uv.y+=sin(t*2.)/12.;\n    \n\t//circles\n    float distFromCenter = dist(o,uv);\n    float circles = sin(distFromCenter*-5.);\n\n    //back to o2\n    uv = o2;\n    \n    float r,g,b;\n    \n    r=g=b=circles/16.;\n    \n    if(uv.x > o.x + o.y*sin(t))\n        r+=.1;\n    \n    float size = .15*sin(t/80.);\n    float size2 = .003*(.6+sin(t*8.)/6.);\n\n    \n    for(float i=-500.; i<500.; i++)\n    {\n        vec2 position = vec2(sin(t+i*size)*.212003,cos(t-i*size)*.4003);\n        \n        for(float sub=1.;sub<3.;sub++)\n        {\n            vec2 position2=position*.6;\n            position2 += vec2(sin(t+i)*.3*sub/2.,cos(t-i)*.3*sub/2.);\n            position2/=vec2(1.0,1.2);\n        \tg+=smoothstep(size2+size2, 0., distance(uv, position2))/2.;\n            r+=smoothstep(size2+size2, .0, distance(uv, position2))*.6;\n        }\n    }\n\n    vec3 col = vec3(r,g,b);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wt2XDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wt2XW3", "name": "Blessed Dream", "author": "Hirai_worthless", "description": "nightmareless", "tags": ["raymarching", "phantom"], "likes": 9, "viewed": 364, "date": "1567303701", "time_retrieved": "2024-06-20T19:45:37.825461", "image_code": "float PI = 3.14159265;\nvec3 modC(vec3 p,vec3 c){\n    p = (fract(p / c + .5)-.5) * c;\n    return p;\n}\nmat2 genRot(float v){\n    return mat2(cos(v),-sin(v),sin(v),cos(v));\n}\nvec2 pMod(vec2 p,float c){\n    p *= genRot(PI / c);\n    float at = mod(atan(p.y/p.x),PI * 2./c);\n    float r = length(p);\n    p = vec2(r * cos(at),r * sin(at));\n    p *= genRot(-PI /c);\n    return p;\n}\n\nvec2 path(float t){\n    vec2 r;\n    r.x = sin(t) + 0.5 * cos(t * 2.);\n    r.y = cos(t) + 0.5 * sin(t * 2.);\n    return r;\n}\nfloat map(vec3 p){\n    p.xy += path(p.z + iTime);\n    vec3 r = p;\n    p.xy = pMod(p.xy,12.);\n    p = modC(p,vec3(4.,4.,1.5));\n    vec3 q = p;\n    q.x -= 1.5;\n    q = abs(q);\n    float cube = max(q.x,max(q.y / 4.,q.z)) - 0.25;\n    float sp = length(p) - 0.3;\n    float result = min(cube,sp);\n    result = max(result,-(length(r.xy) - 0.5));\n    return result;\n}\n\nfloat fog(float d){\n    return 1./(1. + d * d * 0.01);\n}\n\nvec3 getColor(vec3 p){\n    vec3 c = sin(p);\n    c = c * 0.5 + 0.5;\n    return vec3(c);\n}\n\nvec3 trace(vec3 o,vec3 r){\n    vec3 volume = vec3(0.);\n    float l = 0.05;\n    for(int i = 0; i < 512; i++){\n        vec3 p = o + r * float(i) * l;\n        float d = map(p);\n        vec3 c = getColor(p);\n        volume += clamp(l- d,0.,l) * c * fog(float(i) * l);\n    }\n    return volume;\n}\n\nvec3 cam(){\n\tvec3 c = vec3(0.,0.,-1.5);\n    c.z += iTime * 4.;\n    //c += vec3(2.5 * sin(iTime/2.),2.5 * cos(iTime/2.),iTime * 2.);\n\treturn c;\n}\nvec3 ray(vec2 uv,float z){\n\tvec3 r = normalize(vec3(uv,z));\n    //r.yz *= genRot(PI / 4.);\n    //r.xy *= genRot(PI/4.-iTime / 2.);\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 uv = ( fragCoord.xy * 2. - iResolution.xy) / iResolution.y ;\n\tvec3 c = cam();\n\tvec3 r = ray(uv,1.5);\n\tvec3 color = trace(c,r);\n\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2XW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wt2XzK", "name": "Velocity", "author": "iq", "description": "Velocity", "tags": ["3d"], "likes": 9, "viewed": 684, "date": "1568362246", "time_retrieved": "2024-06-20T19:45:38.510456", "image_code": "// The MIT License\n// Copyright  2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This shader shows how to control the velocity of an\n// object that is being animated with a sin() function.\n//\n// When animating something like angle=sin(v*t), with t being\n// the time (iTime for example), w is only the (angular) \n// velocity of the object if v is a constant.  Hence, doing \n// v(t) = smoothstep(0,1,t) for exampe will  result in an\n// acceleration and a deceleration, which is probably not\n// intenteded.\n//\n// To get the desired behaviour you need to define your v(t),\n// integrate it to get w(t), then plug it into the sin:\n//\n// v(t) = smoothste(0,1,t)      if t<1\n// v(t) = 1                     if t>=1\n//\n// Then you integrate that to get\n//\n// w(t) = t*t*t*(1.0 - t/2.0)   if t<1\n// w(t) = t-0.5                 if t>=1\n// \n// Try using the incorrect method below and restarting the\n// shader in order to see the difference:\n\n\n// 0: incorrect method: sin(v(t)*t)\n// 1:   correct method: sin(w(t))\n#define METHOD 1\n\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 tx, in vec3 rad ) \n{\n\tvec3 rdd = (tx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (tx*vec4(ro,1.0)).xyz;\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3( 0.0, 0.0, 2.2 );\n    vec3 rd = normalize( vec3(p.xy,-1.8) );\n    \n    \n    #if METHOD==0\n        // WRONG\n    \tfloat animation = smoothstep(0.0,1.0,iTime)*iTime;\n    #else\n        // CORRECT\n        float animation = (iTime<1.0) ?\n    \t    iTime*iTime*iTime*(1.0 - iTime/2.0)\n            :\n            iTime-0.5;\n    #endif\n    \n\tmat4 txi = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 0.5*animation-1.0 );\n\n\tvec3 col = vec3(0.1);\n\t\t\n\tconst vec3 box = vec3(0.4,0.6,0.8) ;\n\tvec4 res = iBox( ro, rd, txi, box);\n\tif( res.x>0.0 )\n\t{\n\t\tvec3 onor = res.yzw;\n\t\tvec3 wpos = ro + res.x*rd;\n\t\t\n\t    mat4 txx = inverse( txi );\n        vec3 opos = (txi*vec4(wpos,1.0)).xyz;\n        vec3 wnor = (txx*vec4(onor,0.0)).xyz;\n\n        col = vec3(1.0,0.5,0.1)*(0.5 + 0.5*wnor.y);\n        col *= 1.0 - (1.0-abs(onor.x))*smoothstep( box.x-0.04, box.x-0.02, abs(opos.x) );\n        col *= 1.0 - (1.0-abs(onor.y))*smoothstep( box.y-0.04, box.y-0.02, abs(opos.y) );\n        col *= 1.0 - (1.0-abs(onor.z))*smoothstep( box.z-0.04, box.z-0.02, abs(opos.z) );\n\t}\n\t\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2XzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtBXD3", "name": "Some cool screen thing", "author": "Yusef28", "description": "I'm sure I'll find a use for something like this down the line.", "tags": ["procedural", "2d", "step", "squares", "cool"], "likes": 4, "viewed": 83, "date": "1567382484", "time_retrieved": "2024-06-20T19:45:38.516492", "image_code": "mat2 rot(float a)\n{\n return mat2 (cos(a), -sin(a), sin(a), cos(a));   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=3.;\n    vec2 st = abs(uv);\n\tvec3 col = vec3(0.);\n    float offset = 0.;\n    float ss = 0.009;\n    float shat = 0.2;\n    float bottom = 0.0;\n    float top = 0.1;\n   \n    float line = 0.;\n    float shadowline = 0.;\n    float rim =0.;\n    float t1 = vec3(texture(iChannel0,uv)).x;\n    float t2 = vec3(texture(iChannel1,uv)).x;\n    vec2 ff = uv*rot(-3.14159265359/4.); \n    float stripes = mod(floor(ff.x*2.), 2.);\n    float movement = 0.;\n\n    col = vec3(0.6);\n    vec2 xyshift = vec2(0.);\n         \n    for(float i=0.;i<20.;i++)\n    {\n     movement = clamp((sin(iTime/2.-offset)*1.),-0.02, .9)*2.;\n        \n        float movement2 = clamp((sin(iTime/2.0-offset)*1.25),-0.02, .9)*2.;  \n \t\tst = uv*rot(3.14159265359/4.);\n        \n        \n        if(st.x>0. &&  st.y>0.){ //right\n         xyshift = vec2(-movement2, 0.0);   \n        }\n        else if(st.x<0. &&  st.y>0.){//top\n         xyshift = vec2(0., -movement2);   \n        }\n        else if(st.x<0. &&  st.y<0.){//left\n         xyshift = vec2(movement2, 0.);   \n        }\n        else xyshift = vec2(0., movement2);//bottom\n        t1 = vec3(texture(iChannel0,uv+xyshift)).x;\n        \n    t2 = vec3(texture(iChannel1,uv+xyshift)).x;\n        \n    st = abs(uv);\n        \n        \n    st = st*rot(-3.14159265359/4.);  \n    st = abs(st);\n        \n        \n    st.y-= movement;\n       \n\n    st.y-=i/4.;\n        \n    shadowline = smoothstep(bottom, bottom+shat, st.y) \n        - smoothstep(top, top+shat, st.y);\n    st.y-=0.04;\n        \n    line = smoothstep(bottom, bottom+ss, st.y) ;\n        \n    //- smoothstep(top, top+ss, st.y);\n        rim = smoothstep(bottom, bottom+ss, st.y)\n            - smoothstep(top/10., top/10.+ss, st.y);\n    offset=i/10.; \n        \n        \n \n       \n        \n    \n    //bottom +=i/10.;\n    //top +=i/10.;\n    float te =step(1., mod(i, 2.));\n    \n        \n    col = mix(col, vec3(0.),shadowline);\n    col = mix(col, vec3(0.2)*t1,line*te);\n    col = mix(col, vec3(0.5, 0., 0.)*t2,line*(1.0-te));\n    col = mix(col, vec3(215., 145., 15.)/555.\n              +abs(sin((uv.x*uv.y*4.+i/10.)/10.+iTime))/5.\n              ,rim); \n    }\n    // Output to screen\n    fragColor = vec4(col*1.5,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtBXD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtjSD3", "name": "Implicit Heart", "author": "harry7557558", "description": "defined by implicit equation (x + 9/4 y + z) - x z - 9/80 y z = 0", "tags": ["heart", "implicit", "love"], "likes": 5, "viewed": 179, "date": "1567308037", "time_retrieved": "2024-06-20T19:45:38.934658", "image_code": "#define PI 3.14159265358979\n#define AA 2\n\n#define EPSILON 1e-5\n\n#define MAX_STEP 1024\n#define MAX_DIST 20.0\n\nvec3 light = normalize(vec3(-0.3, 0.1, 1));\n\n// put any implicit equations you want to visualize there \\\n     (you may need to reduce the step length)\nfloat func(in vec3 p) {\n    float e = p.x*p.x + 2.25*p.y*p.y + p.z*p.z - 1.0;\n\treturn e*e*e - (p.x*p.x + 0.1125*p.y*p.y)*p.z*p.z*p.z;\n}\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = func(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = func(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = func(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = func(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = func(p + t * d);\n        dt /= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            P = normalize(p + t * d);\n            vec3 col = sin(30.0*P.x)+sin(30.0*P.y)+sin(30.0*P.z)>0.0 ?\n                vec3(0.2,0.6,1.0) : vec3(0.6,0.4,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn (0.3+0.7*t)*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.7*dif + 0.2*pow(max(dot(d, light), 0.0), 4.0) + 0.3)*vec3(1.0, 0.1, 0.6);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.6*length(iResolution);\n    \n    float rz=atan(-pos.x,pos.y), rx=atan(length(pos.xy),-pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtjSD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WtjSDV", "name": "WE FUCKING LOVE OUR FANS!", "author": "toomuchvoltage", "description": "More Beeple covert art: https://i.redd.it/fu5p0nwfaqsy.jpg\n\nIt actually does Mie scattering with Frostbite's phase function... which makes it somewhat expensive. But I like the end result :). Hope you like it too!", "tags": ["raymarching", "raycasting", "scattering", "mie", "dragons", "beeple", "imagine"], "likes": 10, "viewed": 588, "date": "1567489055", "time_retrieved": "2024-06-20T19:45:40.837786", "image_code": "/***********************************************************\n\n   More Beeple cover art in Shadertoy! :D\n   This one was an album teaser for Imagine Dragons: https://i.redd.it/fu5p0nwfaqsy.jpg\n   It actually does Mie scattering with Frostbite's Mie phase function approximation.\n   Also raymarches/casts rather than sphere marches given that vast majority of what you see is the scattering.\n\n   This rendition is covered under the MIT license:\n\n   Copyright (c) 2019 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n#define SCATTERING_COEF 8.0\n#define TRANSMISSION_COEF 0.0\n#define EXTINCTION_COEF (SCATTERING_COEF + TRANSMISSION_COEF)\n\nfloat _2dNoise (vec2 forPos)\n{\n\tfloat noiseVal = texture (iChannel0, forPos * 0.5).r;\n    return 0.5 + noiseVal * 0.5;\n}\n\nvoid intersectBox(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax, inout float finalK, inout vec3 norm) {\n    vec3 maxODiff = boxMax - rayOrigin;\n    vec3 minODiff = boxMin - rayOrigin;\n    vec3 invDir = vec3 (1.0) / rayDir;\n    if ( rayDir.x != 0.0 )\n    {\n        float k1 = maxODiff.x * invDir.x;\n        float k2 = minODiff.x * invDir.x;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (-1.0, 0.0, 0.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.yz, boxMin.yz, boxMax.yz) == hitPt.yz )\n            {\n                norm = vec3 (1.0, 0.0, 0.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n    if ( rayDir.y != 0.0 )\n    {\n        float k1 = maxODiff.y * invDir.y;\n        float k2 = minODiff.y * invDir.y;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, -1.0, 0.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xz, boxMin.xz, boxMax.xz) == hitPt.xz )\n            {\n                norm = vec3 (0.0, 1.0, 0.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n    if ( rayDir.z != 0.0 )\n    {\n        float k1 = maxODiff.z * invDir.z;\n        float k2 = minODiff.z * invDir.z;\n        if ( k1 < finalK && k1 == clamp (k1, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k1;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, -1.0);\n\t\t        finalK = k1;\n            }\n        }\n        if ( k2 < finalK && k2 == clamp (k2, 0.0, 1.0) )\n        {\n            vec3 hitPt = rayOrigin + rayDir * k2;\n            if ( clamp (hitPt.xy, boxMin.xy, boxMax.xy) == hitPt.xy )\n            {\n                norm = vec3 (0.0, 0.0, 1.0);\n\t\t        finalK = k2;\n            }\n        }\n    }\n}\n\nvoid intersectPlaneWithYHole (vec3 rayOrigin, vec3 rayDir, float y, vec2 holeXZ, float holeRad, inout float finalK, inout vec3 norm)\n{\n    if ( rayDir.y == 0.0 ) return ;\n    float lineK = (y - rayOrigin.y) / rayDir.y;\n    if ( lineK < finalK && lineK == clamp (lineK, 0.0, 1.0) )\n    {\n        vec3 hitPt = rayOrigin + rayDir * lineK;\n        vec3 toHoleCentDiff = hitPt - vec3 (holeXZ.x, y, holeXZ.y);\n        if ( dot (toHoleCentDiff, toHoleCentDiff) >= holeRad*holeRad )\n        {\n\t        finalK = lineK;\n\t        norm = vec3 (0.0, -1.0, 0.0);\n        }\n    }\n}\n\nvoid rayCylinderWithYAmount (vec3 rayOrigin, vec3 rayDir, vec2 cylinderXZ, vec2 bottomTopY, float cylinderRad, inout float finalK, inout vec3 norm)\n{\n    rayOrigin.xz -= cylinderXZ;\n    float A = rayDir.x * rayDir.x + rayDir.z * rayDir.z;\n    float B = 2.0 * rayOrigin.x * rayDir.x + 2.0 * rayOrigin.z * rayDir.z;\n    float C = rayOrigin.x * rayOrigin.x + rayOrigin.z * rayOrigin.z - cylinderRad * cylinderRad;\n    float q2 = (B * B) - (4.0 * A * C);\n    if ( q2 < 0.0 ) return ;\n    float inv2A = 1.0 / (2.0 * A);\n    float k1 = (-B + sqrt (q2)) * inv2A;\n    float k2 = (-B - sqrt (q2)) * inv2A;\n    bool k1IsGood = (k1 < finalK && k1 == clamp (k1, 0.0, 1.0));\n    bool k2IsGood = (k2 < finalK && k2 == clamp (k2, 0.0, 1.0));\n    if ( k1IsGood || k2IsGood )\n    {\n        float candidateK;\n        if ( k1IsGood && k2IsGood )\n        {\n            candidateK = min (k1,k2);\n        }\n        else if ( k1IsGood && !k2IsGood )\n        {\n            candidateK = k1;\n        }\n        else if ( !k1IsGood && k2IsGood )\n        {\n            candidateK = k2;\n        }\n        vec3 hitPt = rayOrigin + rayDir * candidateK;\n        if ( hitPt.y >= bottomTopY.x && hitPt.y <= bottomTopY.y )\n        {\n\t\t\tfinalK = candidateK;\n            norm = normalize (-vec3 (hitPt.x, 0.0, hitPt.z));\n        }\n    }\n}\n\nmat4 rotationMatrix(vec3 axis, float cosA, float sinA) {\n    float s = sinA;\n    float c = cosA;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float cosA, float sinA) {\n\tmat4 m = rotationMatrix(axis, cosA, sinA);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat PHG (float g, float cosTheta)\n{\n    float Inv4Pi = 1.0 / (4.0 * M_PI);\n\tfloat gSq = g * g;\n\tfloat denomPreMul = max (abs (1.0 + gSq - (2.0 * g * cosTheta)), 0.00001);\n\treturn (1.0 - gSq) * Inv4Pi * inversesqrt(denomPreMul * denomPreMul * denomPreMul);\n}\n\nfloat miePhase (float cosTheta)\n{\n\treturn mix (PHG (0.8, cosTheta), PHG (-0.5, cosTheta), 0.5);\n}\n\nvoid LineMap (vec3 l1, vec3 rayDir, inout float minK, inout vec3 norm)\n{\n    intersectBox (l1, rayDir, vec3 (-3.0, -1.0, -5.0), vec3 (3.0, 10.0, 3.25), minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 1.2, vec2 (0.0, 2.0), 0.17, minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 0.8, vec2 (0.0, 2.0), 0.5, minK, norm);\n    intersectPlaneWithYHole (l1, rayDir, 0.7, vec2 (0.0, 2.0), 0.5, minK, norm);\n    rayCylinderWithYAmount (l1, rayDir, vec2 (0.0, 2.0), vec2 (0.7, 0.8), 0.5, minK, norm);\n\n    mat3 invTran1, invTran2, invTran3;\n    invTran1[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, 0.30901699437);\n    invTran1[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, 0.30901699437);\n    invTran1[2] = vec3 (0.0, 0.0, 1.0);\n    invTran2[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, -0.30901699437);\n    invTran2[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.95105651629, -0.30901699437);\n    invTran2[2] = vec3 (0.0, 0.0, 1.0);\n    invTran3[0] = rotate (vec3 (1.0, 0.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.5, 0.86602540378);\n    invTran3[1] = rotate (vec3 (0.0, 1.0, 0.0), vec3 (0.0, 0.0, 1.0), 0.5, 0.86602540378);\n    invTran3[2] = vec3 (0.0, 0.0, 1.0);\n    vec3 ySwing = vec3 (0.0, sin(iTime), 0.0) * 0.3;\n    vec3 trans1 = vec3 (-0.04, 0.04, 2.0) + ySwing;\n    vec3 trans2 = vec3 (0.06, 0.04, 2.0) + ySwing;\n    vec3 trans3 = vec3 (-0.14, -0.04, 2.0) + ySwing;\n    vec3 trans4 = vec3 (-0.1, -0.095, 1.87) + ySwing;\n    vec3 trans5 = vec3 (-0.1, -0.095, 2.13) + ySwing;\n    vec3 trans6 = vec3 (0.12, -0.15, 1.87) + ySwing;\n    vec3 trans7 = vec3 (0.12, -0.15, 2.13) + ySwing;\n    \n    float saveMinK;\n    saveMinK = minK;\n    intersectBox (invTran1 * (l1 - trans1), invTran1 * rayDir, vec3 (-0.075, -0.05, -0.15), vec3 (0.075, 0.05, 0.15), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;     // Flip the normal as it is inside as per the proc. above\n        norm *= invTran1; // With an orthonormal basis, transpose == inverse, so we can mul. by invTran\n    }\n    saveMinK = minK;\n    intersectBox (invTran2 * (l1 - trans2), invTran2 * rayDir, vec3 (-0.075, -0.05, -0.15), vec3 (0.075, 0.05, 0.15), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n        norm *= invTran2;\n    }\n    saveMinK = minK;\n    intersectBox (invTran3 * (l1 - trans3), invTran3 * rayDir, vec3 (-0.05, -0.05, -0.05), vec3 (0.05, 0.05, 0.05), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n        norm *= invTran3;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans4, rayDir, vec3 (-0.025, -0.15, -0.025), vec3 (0.025, 0.15, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans5, rayDir, vec3 (-0.025, -0.15, -0.025), vec3 (0.025, 0.15, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans6, rayDir, vec3 (-0.025, -0.2, -0.025), vec3 (0.025, 0.2, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n    saveMinK = minK;\n    intersectBox (l1 - trans7, rayDir, vec3 (-0.025, -0.2, -0.025), vec3 (0.025, 0.2, 0.025), minK, norm);    \n    if ( minK < saveMinK )\n    {\n        norm = -norm;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 finalColor = vec3 (0.0);\n    float timeSwing = sin (iTime * 1.125) + 3.0;\n    float timeSwing2 = (sin (iTime * 0.5) + 1.0) * 0.5 + 1.5;\n    vec3 curEye = vec3 (0.0, 0.0, 2.0) + vec3 (sin(timeSwing) * timeSwing2, -0.9, cos(timeSwing) * timeSwing2);\n    vec3 curLook = normalize (vec3 (0.0, 0.0, 2.0) - curEye);\n    vec3 curUp = vec3 (0.0, 1.0, 0.0);\n    vec3 curSide = normalize (cross (curLook, curUp));\n    curUp = cross (curSide, curLook);\n    if ( curUp.y < 0.0 ) curUp = -curUp;\n    vec3 sampleDirNorm = normalize (curLook + curSide * uv.x + curUp * uv.y);\n    float sampleDirLen = 0.05 * _2dNoise (uv);\n    vec3 sampleDir = sampleDirNorm * sampleDirLen;\n    \n    float minK = 2.0;\n    vec3 norm = vec3 (0.0);\n    float drawDist = 100.0;\n    vec3 sampleDirBig = sampleDirNorm * drawDist;\n    LineMap (curEye, sampleDirBig, minK, norm);\n    if ( minK == 2.0 )\n    {\n\t\tfragColor = vec4 (0.0);\n        return ;\n    }\n    float distToWall = (minK * drawDist) / sampleDirLen;\n    int nSteps = int(distToWall) + 1;\n    \n    vec3 mapHitPt = curEye + sampleDirBig * minK;\n    \n    vec3 toRedGreenLight = vec3 (-0.5, 0.0, 2.0) - mapHitPt;\n    vec3 toBlueGreenLight = vec3 (0.5, 0.0, 2.0) - mapHitPt;\n    float toRedGreenLightLen = length (toRedGreenLight);\n    float toBlueGreenLightLen = length (toBlueGreenLight);\n    vec3 toRedGreenLightNorm = toRedGreenLight / toRedGreenLightLen;\n    vec3 toBlueGreenLightNorm = toBlueGreenLight / toBlueGreenLightLen;\n    \n    float redLightIntensity = max (dot(toRedGreenLightNorm, norm), 0.0) * clamp (1.0 - toRedGreenLightLen/2.0, 0.0, 1.0);\n    float blueLightIntensity = max (dot(toBlueGreenLightNorm, norm), 0.0) * clamp (1.0 - toBlueGreenLightLen/2.0, 0.0, 1.0);\n    float fakeLightIntensity = 8.0 / SCATTERING_COEF;\n    finalColor += blueLightIntensity * vec3 (0.0, 0.1, 0.1) * fakeLightIntensity;\n    finalColor += redLightIntensity * vec3 (0.1, 0.1, 0.0) * fakeLightIntensity;\n    finalColor += clamp (4.0/distToWall, 0.0, 1.0) * vec3 (fakeLightIntensity);\n\n    float mediumDensity = 0.1; // Don't touch this. Since the secondary lighting is fake, it'll mess with perception.\n\tfloat scat = 1.0;\n\n    for (int jj = 0; jj != nSteps; jj++)\n    {\n        vec3 samplePt = curEye + float(jj) * sampleDir;\n\n        vec3 sumLightContrib = vec3 (0.0);\n        for (int i = 0; i != 3; i++)\n        {\n\t\t    vec3 lightPos, lightColor;\n            if ( i == 0 )\n            {\n                lightPos = vec3 (-0.1, 2.0, 2.0);\n                lightColor = vec3 (0.0, 0.0, 1.0);\n            }\n            else if ( i == 1 )\n            {\n                lightPos = vec3 (0.0, 2.0, 2.0);\n                lightColor = vec3 (0.0, 1.0, 0.0);\n            }\n            else\n            {\n                lightPos = vec3 (0.1, 2.0, 2.0);\n                lightColor = vec3 (1.0, 0.0, 0.0);\n            }\n\n            vec3 toLightDir = lightPos-samplePt;\n            float toLightLen = length (toLightDir);\n            vec3 toLightNorm = toLightDir / toLightLen;\n\n            float toLightHitMinK = 2.0;\n            vec3 toLightHitNorm = vec3 (0.0);\n            LineMap (samplePt, toLightDir, toLightHitMinK, toLightHitNorm);\n            if ( toLightHitMinK == 2.0 )\n            {\n                float atten = clamp (1.0/toLightLen, 0.0, 1.0) * 2500.0;\n                float evalLightDensity = exp (-mediumDensity * EXTINCTION_COEF * toLightLen) * atten;\n                sumLightContrib += lightColor * evalLightDensity * miePhase (dot (toLightNorm, sampleDirNorm));\n            }\n        }\n\n        vec3 lightScattering = mediumDensity * SCATTERING_COEF * sumLightContrib;\n        float toViewerExtinction = exp(-mediumDensity * EXTINCTION_COEF * sampleDirLen);\n        vec3 curScatteringIntegral = (lightScattering - lightScattering * toViewerExtinction) / max (mediumDensity * EXTINCTION_COEF, 0.000001);\n\n        finalColor += scat * curScatteringIntegral;\n\n        scat *= toViewerExtinction;\n        if ( scat < 0.01 ) break;\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WtjSDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtSXDw", "name": "Shader Showdown EVOKE-19 Round 1", "author": "evvvvil", "description": "Winning shader made at EVOKE 2019 Shader Showdown. First round against Alkama / Calodox ^ The Planet of Leather Moomins\nLive coded on stage in 25 minutes.", "tags": ["time", "clouds", "demoscene", "volumetric", "abstract", "specular", "laser", "limit", "live", "battle", "shadershowdown", "turbine", "gloss", "industrial"], "likes": 15, "viewed": 829, "date": "1569344735", "time_retrieved": "2024-06-20T19:45:41.419834", "image_code": "// Winning shader made at EVOKE 2019 Shader Showdown,\n// First round against Alkama / Calodox ^ The Planet of Leather Moomins\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// \"I'd halve the price of cigarettes, double the tax on health food, then I'd declare war on France.\" Mark E. Smith on what he would do if he was prime minister.\n\nvec2 s,v,e=vec2(.00035,-.00035);float t,tt,g,de,cr,f,ff;vec3 np,cp,pp,po,no,ld,al;vec4 su=vec4(0);\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} \nvec2 fb(vec3 p)\t\n{\n  p.xy*=r2(tt);cp=p;\n  pp=abs(p)-vec3(0,0,3);\n  vec2 h,t=vec2(bo(p,vec3(.6,.6,4.3)),3);\n  t.x=min(bo(pp,vec3(.2,3.9,.2)),t.x);\n  t.x=min(bo(pp,vec3(3.9,.2,.2)),t.x);\n  h=vec2(length(cp.xy)-4.,5);\n  h.x=max(h.x,-(length(cp.xy)-3.8));\n  h.x=max(h.x,bo(pp,vec3(4,4,1)));\n  h.x=min(h.x,bo(pp,vec3(1)));\n  t=t.x<h.x?t:h;\n  h=vec2(bo(pp,vec3(.8,1.2,.8)),6);\n  h.x=min(h.x,bo(pp,vec3(1.2,.8,.8)));\n  h.x=min(h.x,bo(abs(abs(p)-vec3(0,0,1))-vec3(0,0,.5),vec3(.4,.8,.4)));\n  h.x=min(h.x,length(p)-.1);\n  t=t.x<h.x?t:h;\n  h=vec2(bo(p,vec3(-.05,25,-.05)),6);\n  t=t.x<h.x?t:h;\n  g+=0.1/(0.1+h.x*h.x*20.);\n  t.x*=0.7;\n  return t;\n}\nvec2 mp( vec3 p )\n{ \n  p.xy*=r2(sin(p.z*0.2)*0.2);\n  np=p;\n  np.z=mod(p.z+tt*10.,60.)-30.;\n  for(int i=0;i<5;i++){\n    np=abs(np)-vec3(2,2,3.8);\n    np.xy*=r2(1.);\n    np.xz*=r2(.5);    \n    np.xz-=2.;\n  }\n  vec2 h,t=fb(np);\n  h=vec2(1.2*bo(abs(np*.5)-vec3(4,0,0),vec3(.5,.5,10)),6);    \n  h.x=min(.8*length(abs(p.xy)-vec2(20,0.5))-(.6+sin(np.z*.2)*.5),h.x);\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>70.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>70.) t.y=0.;  \n  return t;\n}\nfloat noi(vec3 p){\n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nfloat cno(vec3 p,float k){\n  float f=0.; p.z+=tt*k;\n  f+=0.5*noi(p);p=2.1*p;\n  f+=0.25*noi(p+1.);p=2.2*p;\n  f+=0.125*noi(p+2.);p=2.3*p;\n  return f;\n}\nfloat cmp( vec3 p)\n{\n  float t=.8*bo(p-vec3(0,-68,0),vec3(50,50.+sin(p.z*.2)*3.-sin(p.x*.2)*3.,250));\n  p.xy*=r2(sin(p.z*0.2)*0.2);\n  p.z=mod(p.z+tt*10.+30.,60.)-30.;\n  t=min(t,.8*length(abs(p)-vec3(8.,4.+sin(tt)*6.,2.))-(sin(tt)*7.));\n  return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,62.83);\n    vec3 ro=vec3(35.-cos(tt*1.05)*10.,sin(tt*1.05)*10.,-5),\n    cw=normalize(vec3(0)-ro),\n    cu=normalize(cross(cw,vec3(cos(tt*0.2-0.5),1,0))),\n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,0.5)),co,fo,\n    ld=normalize(vec3(.2,.5,.1));\n    co=fo=vec3(.2,.6,.5)+((length(uv)-.5));\n    s=tr(ro,rd);t=s.x;    \n    if(s.y>0.){\n        vec3 po=ro+rd*t,no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        co=mix(mix(pow(max(dot(reflect(-ld,no),-rd),0.),exp2(11.*cno(np*.5,0.)))+(s.y==5.?vec3(.1,.2,.6):vec3(s.y<5.?0.:0.5))*(clamp(mp(po+no*.2).x/.2,0.,1.)*clamp(mp(po+no*.4).x/.4,0.,1.)+.1)*(max(0.,dot(no,ld))+smoothstep(0.,1.,mp(po+ld*.4).x/.4)+smoothstep(0.,1.,mp(po+ld*2.).x/2.)),fo,min(pow(1.+dot(no,rd),4.),.5)),fo,1.-exp(-.000005*t*t*t));\n    }\n    cr=cmp(ro-1.)+fract(dot(sin(uv*476.567+uv.yx*785.951),vec2(984.156)));\n    for(int i=0;i<120;i++){\n        cp=ro+rd*(cr+=1./3.);\n        if(su.a>.99||cr>t) break;\n        de=clamp(-cmp(cp)+2.*cno(cp,10.),0.,1.);\n        su+=vec4(vec3(mix(1.,0.,de)*de),de)*(1.-su.a);\n    }\n    fragColor = vec4(pow(mix(co,mix(su.xyz,fo,1.-exp(-.000005*cr*cr*cr)),su.a*.9)+g*0.3,vec3(0.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtSXDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
