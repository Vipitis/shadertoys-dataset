{"id": "3d2XRc", "name": "Voronoi Min Vector Shading", "author": "FrickHazard", "description": "Experimenting with returning the vector to the  nearest voronoi cell center and nearest edge. Using both vectors to do some interesting shading effects.", "tags": ["voronoi"], "likes": 8, "viewed": 491, "published": "Public API", "date": "1557455811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#define GRID_SIZE 10.0\n#define SHADING_METHOD_SEED 112.7\n#define SHADING_METHOD_DURATION_TIME 8.0\n#define SHADING_METHOD_TRANSITION_TIME 2.0\n#define OFFSET_FUNTCION_SEED 22.4\n#define OFFSET_FUNTCION_DURATION_TIME 16.\n#define OFFSET_FUNTCION_TRANSITION_TIME 2.0\n#define PALETTE_SEED 324.6\n#define PALETTE_DURATION_TIME 10.\n#define PALETTE_TRANSITION_TIME 2.0\n#define PI 3.14159265\n\nfloat hash11(float p){p = fract(p * .1031);p *= p + 19.19;p *= p + p;return fract(p);}\nfloat hash12(vec2 p){ vec3 p3  = fract(vec3(p.xyx) * .1031); p3 += dot(p3, p3.yzx + 19.19);return fract((p3.x + p3.y) * p3.z);}\nvec2 hash21(float p){vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));p3 += dot(p3, p3.yzx + 19.19);return fract((p3.xx+p3.yz)*p3.zy);}\nmat2 rotate2d(float _angle){return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));}\n\nfloat panSequence = 0.;\nfloat rotateSequence = 0.;\nfloat shadingMethodTick = 0.;\nfloat shadingMethodTransition = 0.;\nfloat offsetFunctionTick = 0.;\nfloat offsetFunctionTransition = 0.;\nfloat paletteTick = 0.;\nfloat paletteTransition = 0.;\n\nvoid sequence()\n{\n  panSequence =    smoothstep(0.0, 4.0, mod(iTime, 20.)) - smoothstep(8.0, 12.0, mod(iTime, 20.));\n  rotateSequence = smoothstep(0.0, 3.0, mod(iTime, 10.)) - smoothstep(6.0,  9.0, mod(iTime, 10.));\n  shadingMethodTick = floor(iTime / SHADING_METHOD_DURATION_TIME);\n  shadingMethodTransition = smoothstep(0.0, SHADING_METHOD_TRANSITION_TIME, mod(iTime, SHADING_METHOD_DURATION_TIME));\n  offsetFunctionTick = floor((iTime + OFFSET_FUNTCION_TRANSITION_TIME) / OFFSET_FUNTCION_DURATION_TIME);\n  offsetFunctionTransition = smoothstep(0.0, OFFSET_FUNTCION_TRANSITION_TIME, mod((iTime + OFFSET_FUNTCION_TRANSITION_TIME), OFFSET_FUNTCION_DURATION_TIME));\n  paletteTick = floor(iTime / PALETTE_DURATION_TIME);\n  paletteTransition = smoothstep(0.0, PALETTE_TRANSITION_TIME, mod(iTime, PALETTE_DURATION_TIME));\n}\n// iq's palette function\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(2. * PI * (c * t + d));\n}\nvec3 randomPalette(float seed, float uniqCellSeed)\n{\n  switch(int(floor(seed * 4.)))\n  {\n      case 0: return palette(uniqCellSeed, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.0, 0.25, 0.25));\n      case 1: return palette(uniqCellSeed, vec3(0.2, 0.3, 0.7), vec3(0.7, 0.7, 0.5), vec3(1. , 1. , 0.8), vec3(0.4, 0.33, 0.5 ));\n      case 2: return palette(uniqCellSeed, vec3(0.5, 0.4, 0.5), vec3(0.5, 0.5, 0.5), vec3(1. , 1. , 1. ), vec3(0.3, 0.6, 0.6));\n      case 3: return palette(uniqCellSeed, vec3(0.5, 0.8, 0.5), vec3(0.6, 0.4, 0.8), vec3(1. , 0.8 , 0.4 ), vec3(1., 1., 0.1));\n  }\n}\nvec3 randomColor(float uniqCellSeed)\n{\n    return mix(\n      randomPalette(hash12(vec2(PALETTE_SEED, paletteTick     )), uniqCellSeed),\n      randomPalette(hash12(vec2(PALETTE_SEED, paletteTick + 1.)), uniqCellSeed),\n      paletteTransition);\n}\nfloat isoLine(float dist, float lineScale){return abs(sin(lineScale * dist));}\n// -------------- different ways to render voronoi data  ------------------\nvec3 randomShadingMethod(vec4 voronoiData, float seed, float uniqCellSeed)\n{\n    float angle = abs(dot(normalize(voronoiData.xy), normalize(voronoiData.wz)));\n    float determinantValue = abs(voronoiData.x * voronoiData.w - voronoiData.z * voronoiData.y);\n    switch (int(floor(seed * 8.)))\n    {\n        case 0: return vec3(isoLine(length(voronoiData.zw), 20.)) * length(voronoiData.zw);\n        case 1: return isoLine(length(voronoiData.xy), 20.) * randomColor(uniqCellSeed);\n        case 2: return vec3(mix(0., 1., smoothstep(0.07, 0.14, length(voronoiData.xy)))) * randomColor(uniqCellSeed);\n        case 3: return angle * randomColor(uniqCellSeed);\n        case 4: return determinantValue * randomColor(uniqCellSeed);\n        case 5: return length(voronoiData.xy) / length(voronoiData.wz) * randomColor(uniqCellSeed);\\\n        case 6: return min(length(voronoiData.xy), length(voronoiData.wz)) * randomColor(uniqCellSeed);\n        case 7: return smoothstep(0., 0.1, length(voronoiData.xy) - length(voronoiData.wz)) * randomColor(uniqCellSeed);\n    } \n}\nvec3 getVoronoiColor(vec4 voronoiData, float uniqCellSeed)\n{\n   return mix(\n      randomShadingMethod(voronoiData, hash12(vec2(SHADING_METHOD_SEED, shadingMethodTick     )), uniqCellSeed),\n      randomShadingMethod(voronoiData, hash12(vec2(SHADING_METHOD_SEED, shadingMethodTick + 1.)), uniqCellSeed),\n      shadingMethodTransition);\n}\nvec2 getRandomCellOffsetFunction(vec2 pos, float seed, float uniqCellSeed)\n{\n   switch (int(floor(seed * 4.0)))\n   {\n       case 0: return vec2(sin(pos.y + iTime * 2.), cos(pos.x + iTime * 2.)) * normalize(pos + vec2(0.0001));\n       case 1: return hash21(uniqCellSeed) * vec2(mod(pos.y, 3.) * cos(iTime * 2.), mod(pos.x, 3.) * sin(iTime * 2.));\n       case 2: return vec2(0.4 * sin(iTime + PI * 2. * hash21(uniqCellSeed)));\n       case 3: return vec2(uniqCellSeed);\n   }\n}\nvec2 getCellOffsetFunction(vec2 pos, float uniqCellSeed)\n{\n    vec2 cellOffset = mix(\n      getRandomCellOffsetFunction(pos, hash12(vec2(OFFSET_FUNTCION_SEED, offsetFunctionTick     )), uniqCellSeed),\n      getRandomCellOffsetFunction(pos, hash12(vec2(OFFSET_FUNTCION_SEED, offsetFunctionTick + 1.)), uniqCellSeed),\n      offsetFunctionTransition);\n   float halfGridCellSideLength = 0.4999;\n   return clamp(cellOffset, -halfGridCellSideLength, halfGridCellSideLength);\n}\nvec4 voronoiGrid(vec2 pixelCoord, out float outCellSeed)\n{\n    vec2 centerOfCellFromGridOffset = vec2(0.5, 0.5);\n    vec2 gridLocation = floor(pixelCoord);\n    vec2 normalizedLocalGridCoord = fract(pixelCoord);\n\n    float minimumDistanceToCenter = GRID_SIZE;\n    vec2 minimumgridOffset, minimumVectorToAdjacentVoronoiCellCenter;\n    // first pass min distance from cell center\n    for(int j=-2; j<=2; j++)\n    for(int i=-2; i<=2;  i++)\n    {\n       vec2 gridOffset = vec2(float(i), float(j));\n        \n       vec2 adajacentCell = gridLocation + gridOffset;\n        \n       float cellSeed = hash12(adajacentCell);\n        \n       vec2 offset = getCellOffsetFunction(adajacentCell, cellSeed) + centerOfCellFromGridOffset;\n        \n       vec2 vectorToAdjacentVoronoiCellCenter = (gridOffset + offset) - normalizedLocalGridCoord;\n       float distanceToCenter = length(vectorToAdjacentVoronoiCellCenter);\n       if (distanceToCenter < minimumDistanceToCenter) {\n           outCellSeed = cellSeed;\n           minimumDistanceToCenter = distanceToCenter;\n           minimumgridOffset = gridOffset;\n           minimumVectorToAdjacentVoronoiCellCenter = vectorToAdjacentVoronoiCellCenter;\n       }\n    }\n    // second pass min distance to border\n    float minimumDistanceToBorder = GRID_SIZE;\n    vec2 minimumVectorToVoronoiCellBorder;\n    for(int j=-2; j<=2; j++)\n    for(int i=-2; i<=2; i++)\n    {\n       vec2 gridOffset = minimumgridOffset + vec2(float(i), float(j));\n        \n       vec2 adajacentCell = gridLocation + gridOffset;\n        \n       float cellSeed = hash12(adajacentCell);\n        \n       vec2 offset = getCellOffsetFunction(adajacentCell, cellSeed) + centerOfCellFromGridOffset;\n        \n       vec2 vectorToAdjacentVoronoiCellCenter = (gridOffset + offset) - normalizedLocalGridCoord;\n        \n       // skip if same point\n       if( dot(minimumVectorToAdjacentVoronoiCellCenter - vectorToAdjacentVoronoiCellCenter,\n               minimumVectorToAdjacentVoronoiCellCenter - vectorToAdjacentVoronoiCellCenter) > 0.00001)\n       {\n          vec2 segmentNormal = normalize(vectorToAdjacentVoronoiCellCenter - minimumVectorToAdjacentVoronoiCellCenter);\n          float scalarProjection = dot(0.5 * (minimumVectorToAdjacentVoronoiCellCenter + vectorToAdjacentVoronoiCellCenter),\n                      segmentNormal);\n          if (scalarProjection < minimumDistanceToBorder) {\n              vec2 vectorProjection = segmentNormal * scalarProjection;\n              minimumVectorToVoronoiCellBorder = vectorProjection;\n              minimumDistanceToBorder = scalarProjection;\n          }\n       }\n    }\n    return vec4(minimumVectorToVoronoiCellBorder, minimumVectorToAdjacentVoronoiCellCenter);\n}\n\nvec2 rotate(vec2 pixelCoord)\n{\n    float aspect = (iResolution.y / iResolution.x);\n    vec2 centerShift = vec2(0.5, 0.5 * aspect);\n    float speed = 0.15;\n    pixelCoord -= centerShift;\n    pixelCoord = rotate2d(rotateSequence * PI * speed) * pixelCoord;\n    pixelCoord += centerShift;\n    return pixelCoord;\n}\nvec2 pan(vec2 pixelCoord)\n{ \n  float seed = floor(iTime / 20.);\n  float speed = mix(0., 1.0, panSequence);\n  return pixelCoord + normalize(vec2(hash21(seed)) + 0.0001) * speed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    sequence();\n    \n    vec2 pixelCoord = (gl_FragCoord.xy - 0.5 * iResolution.xy)/iResolution.xy;\n    pixelCoord.x *= iResolution.x/ iResolution.y;\n\n    pixelCoord = rotate(pixelCoord);\n    pixelCoord = pan(pixelCoord);\n    pixelCoord *= GRID_SIZE;\n    \n    float uniqCellSeed;\n    vec4 voronoiResult = voronoiGrid(pixelCoord, uniqCellSeed);\n\n    fragColor = vec4(getVoronoiColor(voronoiResult, uniqCellSeed), 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2XRc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1405, 1405, 1427, 1427, 1491], [1492, 1492, 1513, 1513, 1619], [1620, 1620, 1641, 1641, 1759], [1760, 1760, 1788, 1788, 1851], [2093, 2093, 2110, 2110, 2912], [2913, 2938, 3008, 3008, 3057], [3058, 3058, 3110, 3110, 3668], [3669, 3669, 3707, 3707, 3913], [3914, 3914, 3957, 3957, 3992], [3993, 4069, 4145, 4145, 5126], [5127, 5127, 5187, 5187, 5462], [5463, 5463, 5539, 5539, 5936], [5937, 5937, 5995, 5995, 6407], [6408, 6408, 6466, 6466, 9110], [9112, 9112, 9142, 9142, 9422], [9423, 9423, 9450, 9450, 9601], [9603, 9603, 9658, 9658, 10079]], "test": "error"}
{"id": "3l23Rh", "name": "Protean clouds", "author": "nimitz", "description": "Fully procedural 3D animated volume with three evaluations per step (for shading) running fast enough for 1080p rendering.\n\nFeaturing simple mouse interaction.", "tags": ["procedural", "3d", "fast", "volumetric"], "likes": 1346, "viewed": 79297, "published": "Public", "date": "1558990029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l23Rh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1153, 1153, 1205], [1317, 1317, 1336, 1336, 1353], [1354, 1354, 1406, 1406, 1450], [1490, 1490, 1509, 1509, 1560], [1562, 1562, 1580, 1580, 2107], [2109, 2109, 2160, 2160, 3194], [3196, 3196, 3218, 3218, 3333], [3335, 3408, 3454, 3454, 3800], [3802, 3802, 3859, 3859, 4956]], "test": "ok"}
{"id": "3l23Wh", "name": "[0002] glass sphere", "author": "Meow8p", "description": "Perfectly transparent glass sphere", "tags": ["raymarching", "refraction", "sphere", "glass", "refract"], "likes": 3, "viewed": 140, "published": "Public", "date": "1559339558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS (128)\n#define SURFACE_DIST (0.001)\n   \nint mat=0;\n   \nvec2 rotate(vec2 p, float a)\n{\n   float s=sin(a);\n   float c=cos(a);\n   mat2 r=mat2(c, -s, s, c);\n   return p*r;\n}\n\nfloat sphereDist(vec3 p, vec3 origin, float radius)\n{\n   return length(p-origin)-radius;\n}\n\nfloat planeDist(vec3 p, float position)\n{\n   return p.y-position;\n}\n   \nfloat sceneDistance(vec3 p)\n{\n   float s1=sphereDist(p, vec3(0.0, 0.5, 0.0), 0.2);\n   if(s1<SURFACE_DIST)\n   {\n      mat=1;\n   }\n   float p1=planeDist(p, 0.0);\n   if(p1<SURFACE_DIST)\n   {\n      mat=2;\n   }\n   p.xz=rotate(p.xz, iTime);\n   float s2=sphereDist(p, vec3(1.0, 0.5, 0.0), 0.2);\n   if(s2<SURFACE_DIST)\n   {\n      mat=3;\n   }\n   return min(p1, min(s1, s2));\n}\n\nvec3 normalAt(vec3 p)\n{\n   float dist=sceneDistance(p);\n   vec2 epsilon=vec2(0.001,0.0);\n   return normalize(vec3(dist-sceneDistance(p-epsilon.xyy), \n                         dist-sceneDistance(p-epsilon.yxy),\n                         dist-sceneDistance(p-epsilon.yyx)));\n}\n   \nfloat lightAt(vec3 p)\n{\n   vec3 lightPosition=vec3(0.0,2.0,0.0);\n   vec3 n=normalAt(p);\n   vec3 lightDirection=normalize(lightPosition-p);\n   \n   float diffuse=clamp(dot(n, lightDirection), 0.0, 1.0);\n   return diffuse;\n}\n\nvec3 pixelColor(vec2 uv)\n{\n   vec3 direction=normalize(vec3(uv,1.0));\n   vec3 color=vec3(0.0,0.0,0.0);\n   float distance=0.0;\n   vec3 camera=vec3(0.0,0.5,-1.5);\n   float sceneDist=0.0;\n   vec3 p;\n   int refractCount=0;\n   vec3 n;\n   \n   for(int i=0;i<MAX_STEPS;i++)\n   {\n      p=camera+distance*direction;\n      sceneDist=sceneDistance(p);\n      \n      if(sceneDist<=SURFACE_DIST)\n      {\n         if(mat==1)\n         {\n            n=normalAt(p);\n            camera=p+SURFACE_DIST*direction*10.0;\n            direction=normalize(refract(direction,n,1.0/1.5));\n            \n            distance=0.0;\n            for(int j=0;j<MAX_STEPS;j++)\n            {\n               p=camera+distance*direction;\n               sceneDist=sceneDistance(p);\n               distance+=max(abs(sceneDist),SURFACE_DIST); \n               if(sceneDist>SURFACE_DIST)\n               {\n                  break;\n               }\n            }\n            \n            camera=p+SURFACE_DIST*direction*10.0;\n            distance=0.0;\n         }\n         else\n         {\n            break;\n         }\n      }\n      \n      distance+=sceneDist;\n   }\n   \n   if(sceneDist<=SURFACE_DIST\n      && mat!=1)\n   {\n      color=vec3(lightAt(p));\n   }\n   \n   if(mat==2)\n   {\n      color*=vec3(0.0,1.0,0.0);\n   }\n   else if(mat==3)\n   {\n      color*=vec3(0.0,0.0,1.0);\n   }\n   \n   return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    // Output to screen\n    fragColor = vec4(pixelColor(uv),1.0);\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l23Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 102, 102, 186], [188, 188, 241, 241, 278], [280, 280, 321, 321, 347], [352, 352, 381, 381, 719], [721, 721, 744, 744, 994], [999, 999, 1022, 1022, 1220], [1222, 1222, 1248, 1248, 2574], [2578, 2578, 2635, 2685, 2828]], "test": "ok"}
{"id": "3l23Wz", "name": "Bilinear Point Distribution", "author": "fizzer", "description": "Here is a method of sampling bilinearly-distributed points. It could perhaps be used for sampling a low-res environment map or emissive surface map. Hold the mouse button to see non-jittered points.", "tags": ["sampling", "points", "distribution", "bilinear"], "likes": 18, "viewed": 394, "published": "Public", "date": "1559171393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Here is a method of sampling bilinearly-distributed points.\n//\n// A uniform distribution can be 're-shaped' into some other distribution using what's\n// known as a cumulative distribution function (CDF). This CDF can be created by inverting the integral\n// of your distribution function, and that's what I've done here. It turned out to be quite\n// straightforward, not requiring higher than 2nd-order polynomials.\n//\n// For the explanation I'll talk about a 1-dimensional bilinear patch defined with control points\n// like this:\n//\n//\t  0  --u-→ 1\n//\t  | p0   p1\n//\t  v\n//\t  ↓ p2   p3\n//    1\n//\n// The bilinear distribution function is F=(p0+(p1-p0)u)(1-v)+(p2+(p3-p2)u)v\n//\n// For each v there is a linear function c+mu where c=p0+v(p2-p0) and m=(p1-p0)+v((p3-p2)-(p1-p0)),\n// which when integrated over [0,1] yields c+m/2\n//\n// c+m/2 as a function of v is another linear function, which can easily be integrated.\n//\n// Integrating c+m/2 gives the following quadratic polynomial:\n// \n// \t\tv(v(p2+p3-p0-p1)+2(p0+p1))/4\n//\n// This function of v can be inverted to obtain a cumulative distribution function.\n//\n// After a value for v has been found by applying the CDF to a uniformly-chosen v,\n// the corresponding linear function of u for that 'slice' of the patch can easily\n// be integrated and inverted to produce a CDF for u.\n//\n//\n\n// Degree-2 polynomial, with c = 0\nfloat quadratic(float x, float b, float a)\n{\n    return (b + a * x) * x;\n}\n\n// Inverse degree-2 polynomial, with c = 0\n// Assumes real solution, and returns the 2nd root\nfloat inverseQuadratic(float y, float b, float a)\n{\n    float d = b * b + 4. * a * y;\n    return (sqrt(d) - b) / (2. * a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    fragColor = vec4(0, 0, 0, 1);\n    vec2 p = uv.xy / 1.7 + .5;\n\n    fragColor.rgb = vec3(.8);\n    \n    if(all(greaterThan(p, vec2(-.05))) && all(lessThan(p, vec2(1.05))))\n\t    fragColor.rgb = vec3(.05);\n\n    const float pi = 3.14159265358979323;\n    \n    if(all(greaterThan(p, vec2(0))) && all(lessThan(p, vec2(1))))\n    {\n\n        // Bilinear patch control points\n        float p0 = pow(.5 + .5 * cos(iTime + pi * 0.0), 6.);\n        float p1 = pow(.5 + .5 * cos(iTime + pi * 0.5), 6.);\n        float p2 = pow(.5 + .5 * cos(iTime + pi * 1.0), 6.);\n        float p3 = pow(.5 + .5 * cos(iTime + pi * 1.5), 6.);\n\n        // Fv polynomial coefficients\n        float b2 = 2. * (p0 + p1) / 4.;\n        float c2 = (p2 + p3 - p0 - p1) / 4.;\n\n        // sum is the bilinear patch integrated over the domain\n        float sum = quadratic(1., b2, c2);\n\n        const int n = 32;\n        \n        fragColor.rgb = vec3(mix(mix(p0, p1, p.x), mix(p2, p3, p.x), p.y));\n        \n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n            {                \n                vec4 ns = texelFetch(iChannel0, ivec2(i, j) & 255, 0);\n\n                // Jitter\n                float ju = iMouse.z < .5 ? ns.x : .5;\n                float jv = iMouse.z < .5 ? ns.y : .5;\n\n                float u = (float(i) + ju) / float(n), v = (float(j) + jv) / float(n);\n\n                // Remap U to the domain of Fv\n                v *= sum;\n\n                // Apply Fv\n                v = inverseQuadratic(v, b2, c2);\n\n                // U-axis linear function coefficients\n                float c2 = mix(p0, p2, v);\n                float m2 = mix(p1 - p0, p3 - p2, v) / 2.;\n\n                // Remap U to the domain of Fu\n                u *= c2 + m2; // = quadratic(1., c2, m2);\n\n                // Apply Fu\n                u = inverseQuadratic(u, c2, m2);\n\n                vec3 sprite = vec3(1. - clamp((distance(p, vec2(u, v)) - .007) / .001, 0., 1.));\n\n                fragColor.rgb = mix(sprite, fragColor.rgb,\n                                    clamp((distance(p, vec2(u, v)) - .01) / .001, 0., 1.));\n            }\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l23Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1345, 1380, 1424, 1424, 1454], [1456, 1550, 1601, 1601, 1674]], "test": "error"}
{"id": "3lBGRh", "name": "Simplex Noise Explained", "author": "DanielMz25", "description": "Simplex Noise explanation.\nThis is not original simplex noise. It's still unfinished. Gradients - Noise transition is ugly.", "tags": ["simplexnoise"], "likes": 5, "viewed": 152, "published": "Public", "date": "1558365477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 gradients[4] = vec2[4](\n    vec2(1.0,1.0),vec2(1.0,-1.0),\n    vec2(-1.0,-1.0),vec2(-1.0,1.0));\n\nconst float pi = 3.141592653589793238462643383279502884157169399375105820974944592307816406286208998628034825342117067982148086513282;\n\nconst vec3 rainbowColors[6] = vec3[6](\n    vec3(1.0,0.0,0.0),vec3(1.0,0.5,0.0),vec3(1.0,1.0,0.0),\n    vec3(0.0,0.75,0.0),vec3(0.0,0.75,1.0),vec3(0.5,0.0,1.0));\n    \nfloat hash(vec2 v)\n{\n    float h = v.x * 1.0071 + v.y * 0.9873;\n    h = fract((h+0.00103)*v.x*0.927) + fract((h+0.0010421)*v.y*1.0219);\n    h = fract(h*2184.72427142 + 1.732);\n    h = fract(h * 21982.623632 + 4.637235);\n    return h;\n}\n\n\n\nvec3 rainbow(float f)\n{\n    f = clamp(f,0.0,1.0);\n    f = f*6.0;\n    float ff = floor(f);\n\treturn mix(rainbowColors[int(ff)],rainbowColors[int(min(4.99,ff))+1],f-ff);\n}\n\nfloat sFac(float f)\n{\n    return 0.5-cos(clamp(f,0.0, 1.0)*pi)*0.5;\n}\n\nfloat grid(vec2 uv, vec2 size)\n{\n\tvec2 uv0 = floor(uv);\n    \n    return step(uv.x - uv0.x, size.x) \n        + step(uv.y - uv0.y, size.y);\n}\n\nfloat vector(vec2 v0, vec2 v, vec2 uv, float dotSize, float lineWidth)\n{\n    vec2 v1 = uv - v0;\n    float v1Len = length(v1);\n    \n    float dotVal = step(v1Len, dotSize);\n    \n    vec2 vDot = vec2(dot(v1,v) , dot(vec2(-v.y,v.x),v1));\n    \n    float vecVal = step(vDot.x,0.0)*step(abs(vDot.y), lineWidth)*step(v1Len, length(v));\n        \n    return max(dotVal, vecVal);\n}\n\nfloat gradient(vec2 v0, vec2 v, vec2 uv)\n{\n    vec2 v1 = v0 - uv;   \n    return dot(v1,v);\n}\n\nfloat pNoiseTransition(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    vec2 facSmooth = vec2(sFac(fac.x),sFac(fac.y));\n    vec2 fac2 = vec2(step(0.5,fac.x),step(0.5,fac.y));\n    \n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //fac = mix(facSmooth,fac2,1.0-transition);\n    \n    fac = (fac-0.5)*pow(32.0,transition)+0.5;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nfloat pNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nconst float unskewVal = (3.0-sqrt(3.0))/6.0;\nconst float skewVal = (sqrt(3.0)-1.0)/2.0;\nconst float xyDelta = 1.0 - 2.0*unskewVal;\n\nfloat sNoise(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    p0*=p0;\n    p1*=p1;\n    p2*=p2;\n    \n    float ret = 0.0;\n    \n    ret += p0*p0*gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    ret += p1*p1*gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    ret += p2*p2*gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*25.0;\n}\n\nfloat sNoiseTransition(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n\tfloat pp0 = mix(pow(p0,4.0),step(max(p1,p2), p0)*0.034, transition);    \n    float pp1 = mix(pow(p1,4.0),step(max(p0,p2), p1)*0.034, transition);\n    float pp2 = mix(pow(p2,4.0),step(max(p1,p0), p2)*0.034, transition);\n    \n    p0=pp0;\n    p1=pp1;\n    p2=pp2;\n    /*\n    \n    float tr0 = pow(25.0,transition);\n    float tr1 = 0.315*(pow(transition,0.4));\n    float tr2 = 0.05*(transition);\n    \n    p0 = clamp(p0-tr1,0.0,0.5);\n    p1 = clamp(p1-tr1,0.0,0.5);\n    p2 = clamp(p2-tr1,0.0,0.5);\n    \n    p0 = clamp(p0*tr0,0.0,0.5-tr2);\n    p1 = clamp(p1*tr0,0.0,0.5-tr2);\n    p2 = clamp(p2*tr0,0.0,0.5-tr2);\n    \n    p0 = pow(p0,4.0);\n    p1 = pow(p1,4.0);\n    p2 = pow(p2,4.0);*/\n    \n\t/*p0 = step(0.013,p0)*0.04;\n    p1 = step(0.013,p1)*0.04;\n    p2 = step(0.013,p2)*0.04;*/\n    \n    float ret = 0.0;\n    \n    ret += p0*gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    ret += p1*gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    ret += p2*gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*25.0;\n}\n\nfloat simplexGrid(vec2 uv, vec3 size)\n{\n    vec2 u_uv = uv;\n    \n\tuv = uv + (uv.x+uv.y) * skewVal;\n    vec2 uv0 = floor(uv);\n    \n    vec2 u_uv0 = uv0 - (uv0.x+uv0.y)*unskewVal;\n    u_uv = u_uv - u_uv0;\n    \n    return step(uv.x - uv0.x, size.x) \n        + step(uv.y - uv0.y, size.y)\n        + step(abs(u_uv.x-u_uv.y),size.z);\n}\n\nfloat simplexVectors(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float ret = 0.0;\n    \n    if(p0 > p1 && p0 > p2)\n        ret = vector(uv0, gradients[int(hash(i0)*4.0)], uv, 0.06, 0.03);\n    else if(p1 > p0 && p1 > p2)\n        ret = vector(uv1, gradients[int(hash(i1)*4.0)], uv, 0.06, 0.03);\n    else\n        ret = vector(uv2, gradients[int(hash(i2)*4.0)], uv, 0.06, 0.03);\n        \n    return ret;\n}\n\nfloat simplexGradients(vec2 uv)\n{\n\tvec2 i0 = floor(uv + (uv.x+uv.y) * skewVal);\n    vec2 uv0 = i0 - (i0.x+i0.y)*unskewVal;\n    \n    vec2 lUv = uv - uv0;\n    \n    float wTri = step(lUv.y,lUv.x);\n    vec2 vWTri = vec2(wTri, 1.0-wTri);\n    \n    vec2 i2 = i0 + 1.0;\n    vec2 i1 = i0 + vWTri;\n    \n    vec2 uv1 = uv0 + vWTri - unskewVal;\n    vec2 uv2 = uv0 + xyDelta;\n    \n    vec2 lUv1 = uv - uv1;\n    vec2 lUv2 = uv - uv2;\n    \n    float p0 = 0.5-dot(lUv,lUv);\n    float p1 = 0.5-dot(lUv1,lUv1);\n    float p2 = 0.5-dot(lUv2,lUv2);\n    \n    float ret = 0.0;\n    \n    if(p0 > p1 && p0 > p2)\n        ret = gradient(uv0, gradients[int(hash(i0)*4.0)], uv);\n    else if(p1 > p0 && p1 > p2)\n        ret = gradient(uv1, gradients[int(hash(i1)*4.0)], uv);\n    else\n        ret = gradient(uv2, gradients[int(hash(i2)*4.0)], uv);\n        \n    return 0.5+ret*0.5;\n}\n\nvec3 rainbowNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tvec3 g0 = rainbow(gradient(v0, gradients[int(hash(v0)*4.0)], uv)*0.5+0.5);\n\tvec3 g1 = rainbow(gradient(v1, gradients[int(hash(v1)*4.0)], uv)*0.5+0.5);\n    vec3 g2 = rainbow(gradient(v2, gradients[int(hash(v2)*4.0)], uv)*0.5+0.5);\n    vec3 g3 = rainbow(gradient(v3, gradients[int(hash(v3)*4.0)], uv)*0.5+0.5);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    vec3 g01 = mix(g0,g1,fac.x);\n    vec3 g23 = mix(g3,g2,fac.x);\n    \n    vec3 g = mix(g01,g23,fac.y);\n    \n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/50.0 + 2.0*iTime*0.1;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float transition = (clamp(sin(iTime*0.5)*0.25+0.5,0.3,0.7)-0.3)/0.4;\n    \n    float gridRet = simplexGrid(uv,vec3(0.05,0.05,0.025))*transition*0.5;\n    \n    float vecRet = simplexVectors(uv) * transition;\n   \n    //float gradRet = simplexGradients(uv);\n    float gradRet = sNoiseTransition(uv);\n    \n    float NoGrad = clamp(1.0 - gridRet - vecRet, 0.0 ,1.0);\n    \n    // Output to screen\n    //fragColor = vec4(vec3(gridRet),1.0);\n    //fragColor = vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,vecRet,vecRet,1.0);\n    //fragColor = vec4(vec3(sNoise(uv)),1.0);\n    fragColor = vec4(vec3(gradRet)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n    //fragColor = vec4(rainbowNoise(uv)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n\t//fragColor = vec4(vec3(gradRet),1.0);\n    //fragColor = vec4(vec3((pNoise(uv)*0.5+pNoise(uv*2.26+320.0)*0.25+pNoise(uv*4.12+128.0)*0.125)*0.5+0.5),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 428, 428, 643], [647, 647, 670, 670, 815], [817, 817, 838, 838, 886], [888, 888, 920, 920, 1027], [1029, 1029, 1101, 1101, 1400], [1402, 1402, 1444, 1444, 1494], [1496, 1496, 1529, 1529, 2386], [2388, 2388, 2411, 2411, 2984], [3118, 3118, 3141, 3141, 3941], [3943, 3943, 3976, 3976, 5578], [5580, 5580, 5619, 5619, 5908], [5910, 5910, 5941, 5941, 6780], [6782, 6782, 6815, 6815, 7632], [7634, 7634, 7662, 7662, 8288], [8290, 8290, 8347, 8397, 9506]], "test": "error"}
{"id": "3lBGWR", "name": "Second Shader B", "author": "sgiobairog", "description": "Mouse feckery.", "tags": ["shaders"], "likes": 2, "viewed": 336, "published": "Public API", "date": "1558981815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centre = vec2(0.5 + 0.5 * sin(iTime), 0.5 + 0.5 * sin(iTime));\n    \n    uv = uv * 10.0;\n    \n    vec2 pos = uv - centre;\n    pos.y /= iResolution.x/iResolution.y;\n    \n    float dist = length(pos);\n    \n    dist = pow(dist, 0.5);\n    dist -= iTime*0.1;\n    dist *= 1.0;\n    dist *= fract(dist);\n    \n        \n    float angle = atan(pos.x, pos.y);\n    // Normalized pixel coordinates (from 0 to 1)\n\n    dist += angle * iMouse.y;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(dist + uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 686]], "test": "ok"}
{"id": "3lf3DB", "name": "Spinning dotCube", "author": "AlexNilsson", "description": "hello world, cube, following tutorial by: The Art of Code\nhttps://www.youtube.com/watch?v=PBxuVlp7nuM\n", "tags": ["cube", "dots", "spinning"], "likes": 3, "viewed": 82, "published": "Public", "date": "1557433152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat drawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = distLine(ro, rd, p);\n    return smoothstep(.06, .05, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(t) + 0.5, 3.*sin(t*0.5) + 0.5, -3.*cos(t)+0.5);\n    \n    vec3 lookat = vec3(.5);\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1.0, 0.), f);\n    vec3 u = cross(f, r);\n    \n    float zoom = 1.;\n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    float d = 0.;\n    \n    d += drawPoint(ro, rd, vec3(0., 0., 0.));\n    d += drawPoint(ro, rd, vec3(0., 0., 1.));\n    d += drawPoint(ro, rd, vec3(0., 1., 0.));\n    d += drawPoint(ro, rd, vec3(0., 1., 1.));\n    d += drawPoint(ro, rd, vec3(1., 0., 0.));\n    d += drawPoint(ro, rd, vec3(1., 0., 1.));\n    d += drawPoint(ro, rd, vec3(1., 1., 0.));\n    d += drawPoint(ro, rd, vec3(1., 1., 1.));\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(d, d, d, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lf3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 88], [90, 90, 133, 133, 203], [205, 205, 262, 262, 1307]], "test": "ok"}
{"id": "3lf3W2", "name": "[00005] spheres+\"volumetric fog\"", "author": "samel", "description": "[00005] spheres+\"volumetric fog\"", "tags": ["raymarching", "basic", "fog", "diffusa", "volumetricy"], "likes": 1, "viewed": 128, "published": "Public", "date": "1557606340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd1(vec2 p)\n{\n return fract(sin(dot(p,vec2(13.0,170.0)))*2100.0);\n}\n\nvec2 rnd2(vec2 p)\n{\n vec2 r=vec2(0.29,0.37);\n return 1.0-2.0*vec2(rnd1(p),rnd1(p*r));\n}\n\nfloat noise(vec2 p)\n{\n vec2 i=floor(p);\n vec2 f=fract(p);\n vec2 u=f*f*(3.0-2.0*f);\n return mix(\n  mix(\n   dot(rnd2(i+vec2(0.0,0.0)),f-vec2(0.0,0.0)),\n   dot(rnd2(i+vec2(1.0,0.0)),f-vec2(1.0,0.0)),\n   u.x),\n  mix(\n   dot(rnd2(i+vec2(0.0,1.0)),f-vec2(0.0,1.0)),\n   dot(rnd2(i+vec2(1.0,1.0)),f-vec2(1.0,1.0)),\n   u.x),\n  u.y);\n}\n\nfloat scene(vec3 p)\n{\n p=mod(p,5.0)-2.5;\n vec3 sPos=vec3(0.0,0.0,0.0);\n return length(p-sPos)-1.0;\n}\n\nvec3 normalAt(vec3 p)\n{\n float s=scene(p);\n vec2 e=vec2(0.01,0.0);\n return normalize(vec3(s-scene(p-e.xyy),\n                  s-scene(p-e.yxy),\n                  s-scene(p-e.yyx)));\n}\n\nfloat diffuse(vec3 p)\n{\n vec3 lp=vec3(0.0,3.0,-3.0);\n vec3 ld=normalize(lp-p);\n vec3 n=normalAt(p);\n return dot(ld,n);\n}\n\nvec3 pixelColor(vec2 uv)\n{\n vec3 c=vec3(0.0,0.0,0.0);\n vec3 o=vec3(0.0,0.0,-5.0);\n vec3 d=vec3(uv,1.0);\n vec3 p;\n float t=0.0;\n for(int i=0;i<100;i++)\n {\n  p=o+t*d;\n  float s=scene(p);\n  if(s<0.01 || t>50.0)\n  {\n   c=vec3(1.0,0.0,0.0)*diffuse(p);\n   break;\n  }\n  t+=s;\n }\n float td=length(p);\n for(float l=0.0;l>-1.0;l+=0.1)\n {\n  if(l>td)\n  {\n   break;\n  }\n  p=o+l*d;\n  float n=abs(noise(p.xy*0.2+iTime*0.2));\n  float f=1.0-exp(-length(p)*n);\n  c=mix(c,vec3(0.1,0.1,0.5),f/10.0);\n }\n return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    // Output to screen\n    fragColor = vec4(pixelColor(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lf3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 74], [76, 76, 95, 95, 163], [165, 165, 186, 186, 490], [492, 492, 513, 513, 592], [594, 594, 617, 617, 777], [779, 779, 802, 802, 899], [901, 901, 927, 927, 1396], [1398, 1398, 1455, 1505, 1633]], "test": "ok"}
{"id": "3lf3z2", "name": "Paint Archipelago", "author": "samlo", "description": "An fbm domain warp I made in 2017 when I was first learning shaders! Code is kind of terrible but I still think it's beautiful ❤️\n\n\n\n", "tags": ["noise", "fbm", "oil", "paint"], "likes": 32, "viewed": 1082, "published": "Public API", "date": "1556877877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n#define octaves 14\nfloat fbm (in vec2 p) {\n\n    float value = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;    \n\n    for (int i = 0; i < octaves; i++) {\n        value += amp * (noise((p - vec2(1.0)) * freq));\n        freq *= 1.9;\n        amp *= 0.6;\n    }\n    return value;\n}\n\nfloat pattern(in vec2 p) {\n    vec2 offset = vec2(-0.5);\n\n    vec2 aPos = vec2(sin(iTime * 0.005), sin(iTime * 0.01)) * 6.;\n    vec2 aScale = vec2(3.0);\n    float a = fbm(p * aScale + aPos);\n\n    vec2 bPos = vec2(sin(iTime * 0.01), sin(iTime * 0.01)) * 1.;\n    vec2 bScale = vec2(0.6);\n    float b = fbm((p + a) * bScale + bPos);\n\n    vec2 cPos = vec2(-0.6, -0.5) + vec2(sin(-iTime * 0.001), sin(iTime * 0.01)) * 2.;\n    vec2 cScale = vec2(2.6);\n    float c = fbm((p + b) * cScale + cPos);\n    return c;\n}\n\nvec3 palette(in float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.45, 0.25, 0.14);\n    vec3 c = vec3(1.0 ,1.0, 1.0);\n    vec3 d = vec3(0.0, 0.1, 0.2);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    float value = pow(pattern(p), 2.); // more \"islands\"\n    vec3 color = palette(value);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lf3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 108], [109, 109, 130, 130, 414], [435, 435, 458, 458, 693], [695, 695, 721, 721, 1200], [1202, 1202, 1228, 1228, 1416], [1418, 1418, 1474, 1474, 1686]], "test": "ok"}
{"id": "3lf3zX", "name": "Star Globe", "author": "dr2", "description": "Stars... (mouseable)", "tags": ["fbm", "stars"], "likes": 10, "viewed": 416, "published": "Public API", "date": "1557055290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Star Globe\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\nfloat BallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  return (d > 0.) ? - b - sqrt (d) : dstFar;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy = Rot2D (q.xy, pi / 6.);\n  d = PrCylDf (q.xzy, 0.05, 1.18);\n  DMINQ (1);\n  d = max (min (PrCylAnDf (q, 1.1, 0.05, 0.025), PrCylAnDf (q, 1.16, 0.01, 0.04)), - q.x);\n  DMINQ (2);\n  q = p;\n  q.y -= -1.17;\n  d = PrCylDf (q.xzy, 0.7, 0.02);\n  DMINQ (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 531.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 571.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, sd;\n  float dstBall, dstObj, nDotL, tCyc, t, aRot;\n  dstBall = BallHit (ro, rd, vec3 (0.), 1.);\n  dstObj = ObjRay (ro, rd);\n  if (dstBall < min (dstObj, dstFar)) {\n    ro += dstBall * rd;\n    vn = normalize (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    sd = vn;\n    sd.xy = Rot2D (sd.xy, pi / 6.);\n    col = vec3 (0.1, 0.1, 0.15);\n    if (abs (sd.y) > 0.997) {\n      col = vec3 (0.7, 0.6, 0.1);\n      nDotL *= nDotL;\n    }\n    col = col * (0.2 + 0.8 * nDotL) + 0.05 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (abs (sd.y) < 0.997) {\n      tCyc = 10.;\n      t = 2. * pi * tCur / tCyc;\n      aRot = 0.02 * tCyc * t + 0.5 * (t - sin (t));\n      sd.xz = Rot2D (sd.xz, aRot);\n      col += 4. * StarPat (sd, 1.) * smoothstep (0.05, 0.4, max (- dot (rd, vn), 0.));\n    }\n  } else if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col = vec3 (0.7, 0.6, 0.1);\n    } else if (idObj == 2) {\n      col = vec3 (0.9, 0.8, 0.4) * (1. - 0.5 * step (abs (length (qHit.xy) - 1.1), 0.043) *\n         SmoothBump (0.45, 0.55, 0.02, mod (60. * atan (qHit.y, - qHit.x) / pi, 1.)));\n    } else if (idObj == 3) {\n      col = vec3 (0.6, 0.6, 0.65);\n      if (vn.y > 0.99) col *= (1. - 0.1 * smoothstep (0.4, 0.5, Fbm2 (4. * qHit.xz * vec2 (1., 8.)))) *\n         (0.7 + 0.3 * smoothstep (0., 0.1, max (abs (qHit.x) - 0.35, abs (qHit.z) - 0.02))) *\n         (1. - step (abs (length (qHit.xz) - 0.6), 0.05) *\n         0.6 * SmoothBump (0.46, 0.54, 0.02, mod (15. * atan (qHit.z, - qHit.x) / pi + 0.5, 1.)));\n    }\n    if (idObj > 1) vn = VaryNf (128. * qHit, vn, 1.);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.8 * nDotL * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = StarPat (rd, 4.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., -0.1, -8.);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 6.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lf3zX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[501, 501, 552, 552, 690], [763, 763, 785, 785, 1111], [1113, 1113, 1146, 1146, 1323], [1325, 1325, 1346, 1346, 1538], [1540, 1540, 1575, 1575, 2028], [2030, 2030, 2065, 2065, 3916], [3918, 3918, 3974, 3974, 5104], [5106, 5106, 5148, 5148, 5199], [5201, 5201, 5254, 5254, 5315], [5317, 5317, 5374, 5374, 5457], [5459, 5459, 5481, 5481, 5519], [5521, 5521, 5551, 5551, 5664], [5698, 5698, 5722, 5722, 5852], [5854, 5854, 5879, 5879, 6065], [6067, 6067, 6088, 6088, 6243], [6245, 6245, 6274, 6274, 6486], [6488, 6488, 6527, 6527, 6707]], "test": "error"}
{"id": "3lfGWf", "name": "RNBW", "author": "avin", "description": "color experiment", "tags": ["color", "rainbow"], "likes": 8, "viewed": 399, "published": "Public API", "date": "1557814002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI2 6.2831852\n#define RCOS(v) cos(v)*.5+.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float l = length(uv);\n    float lg = smoothstep(.5, .4, l) - .5;\n    \n    float t = iTime*2.;\n    float ofst = (uv.y*10. + sin(uv.x*10.)*.5) * lg * -1.;\n    \n    float r = RCOS(t + ofst);\n    float g = RCOS(t+PI2*.33 + ofst);\n    float b = RCOS(t+PI2*.66 + ofst);\n    \n    fragColor = vec4(vec3(r, g, b) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 109, 109, 496]], "test": "ok"}
{"id": "3lj3Rh", "name": "Pulsating ring tunnel", "author": "Neebz", "description": "Ring shader used in a school project of mine. Based off of a shader made by one of my group members, although altered in a lot of ways in order to create the current effect.", "tags": ["rings", "pulsating"], "likes": 0, "viewed": 82, "published": "Public", "date": "1558540350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ringThickness .05\n#define numberOfRings 15.\n#define minimumSize 10.\n#define maximumSize 0.\n#define ringSpeed .1\n#define colorChangeSpeed 10.\n#define ringIntensity 1.5\n\nvec3 spaceCircles(vec2 uv){\n\t//Define a mask to contain all the rings\n\tvec3 mask = vec3(0);\n\n\t//Forloop for number of rings\n\tfor (float x = 0.; x < 1.; x += 1./numberOfRings){\n\t\t//Define time at offsets, defined by indexer\n\t\tfloat t = (iTime * ringSpeed + x);\n\t\t//Color time defined, as the time variable to change ring color, defined by indexer\n\t\tfloat colorT = (iTime * colorChangeSpeed + x);\n\n\t\t//Define size as a value, by linearly scaling between two values\n\t\t//using the fraction of the time variable as the input.\n\t\tfloat size = mix(minimumSize, maximumSize, fract(t));\n\t\t//Scaling the uv\n\t\tvec2 uvScaled = uv * size;\n\t\t//Define a fade, to fade in the rings at a certain depth.\n\t\tfloat fade = smoothstep(0.,.05, fract(t));\n\t\t//Change color over time\n\t\tvec3 col = 0.5 + 0.5 * cos(colorT + uvScaled.xyx *  + vec3(1, 2, 4));\n\t\t\n\t\t//Create ring, by calculating the multiplicative inverse distance between\n\t\t//the current uv coord and the center of the screen.\n\t\tfloat dis = 1. / distance(uvScaled, vec2(0., 0.));\n\t\t\n\t\t//Multiply number to create different colors on the ring\n\t\tdis *= 2.;\n\n\t\t//To make sure we only create 1 ring, we cut out all values outside of a certain range.\n\t\t//Multiple rings are otherwise created because of the sine / cosine. The 'dist' value gets quite large as it\n\t\t//gets closer to the center, since 1 dvivded by a small number creates a large number, which input into one of \n\t\t//these functions (sine or cosine), will return a greater frequency in the fluxuation.\n\t\tif (dis < 4.5 && dis > 2.){\n\t\t\t//Outer thickness of the rings\n\t\t\tcol *= ringThickness / (sin(dis));\n\t\t\t//Inner thickness of the rings\n\t\t\tcol = (col / sin(dis)) * ringThickness;\n\t\t\t//Adds the current ring to the mask, times the fade, to make sure it slowly fades in to the screen.\n\t\t\t//Multiplied is also an intensity value, used to make the intensity of the rings greater or smaller.\n\t\t\tmask += col * ringIntensity * fade;\n\t\t}\n\t}\n\n\treturn mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    vec3 mask = vec3(0);\n\tmask += spaceCircles(uv);\n    fragColor = vec4(mask, 1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lj3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 203, 245, 2120], [2122, 2122, 2179, 2179, 2367]], "test": "ok"}
{"id": "3ljGzD", "name": "Inverted blob raytracer", "author": "bitsofcode", "description": "test", "tags": ["raymarching"], "likes": 5, "viewed": 105, "published": "Public", "date": "1558848254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n// how deep do the reflections go\nconst int maxBounces = 2;\n\n\n// control the tracer precision and efficiency\nconst float traceStartDistance = .01;\nconst int traceLoopCount = 200;\nconst float shadowStartDistance = .1;\nconst int shadowLoopCount = 50;\n\n\n// polished copper\n//const vec3 blobAlbedo = vec3(0); const vec3 blobSpecColour = vec3(.8,.3,.2); const float blobMaxSpecular = 1.;\n// shiny white\nconst vec3 blobAlbedo = vec3(1); const vec3 blobSpecColour = vec3(.02); const float blobMaxSpecular = 1.;  //.02 = schlick(1.33)\n// chocolate\n//const vec3 blobAlbedo = vec3(.2,.03,.01); const vec3 blobSpecColour = vec3(.007); const float blobMaxSpecular = .5;\n\n\n\nconst vec2 quasirand2 = vec2(.754877666247,.569840290998); // from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n\nstruct Light\n{\n    vec3 pos;\n    vec3 colour;\n};\n    \nLight lights[] = Light[]\n    (\n         Light( vec3(1,2,-3), vec3(1)*8. )\n        ,Light( vec3(-1,-.5,-1), vec3(1,.1,0)*1. )\n        ,Light( vec3(.5,-.9,-.5), vec3(0,.3,1)*.3 )\n\t);\n\n\nfloat Mat1SDF( vec3 p )\n{\n    // 4 walls\n    float f = -abs(p.x-2.5)-(-4.);\n    f = min(f, -abs(p.z+1.)-(-5.) );\n    \n    // 4 more walls at 45 degrees for more interesting reflections!\n    f = min(f, -abs((p.z+p.x)*.7071+1.)-(-5.) );\n    f = min(f, -abs((p.z-+p.x)*.7071+1.5)-(-4.5) );\n\n    return f;\n}\n\n\nfloat Mat2SDF( vec3 p )\n{\n    // blob\n    vec3 p1 = p - .7*sin(vec3(1,quasirand2)*iTime);\n\tvec3 p2 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.x);\n\tvec3 p3 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.y);\n    \n    float r = .0;\n    float a = length(p )-.8+.4;\n    float b = length(p1)-.5+.4;\n    float c = length(p2)-.5+.4;\n    float d = length(p3)-.5+.4;\n    \n    // I based this on a smooth-min function, it didn't work as intended but it's pretty!\n    float avg = (a+b+c+d)/4.;\n    //a -= avg;\n    b -= avg;\n    c -= avg;\n    d -= avg;\n    return (avg - sqrt( a*a+b*b+c*c+d*d+r*r ))*.8;\n}\n\nfloat Mat3SDF( vec3 p )\n{\n    // floor\n    return -abs(p.y-1.)-(-2.);\n}\n\nfloat SDF( vec3 p )\n{\n    return min(min(Mat1SDF(p),Mat2SDF(p)),Mat3SDF(p));\n}\n\n\nvec3 Trace( in vec3 p, in vec3 ray )\n{\n    p += ray*traceStartDistance;\n    float epsilon = .001;\n    float h = 1.;\n    for ( int i=0; i < traceLoopCount; i++ )\n    {\n        if ( h < epsilon )\n            break;\n        h = SDF(p);\n        p += ray*h;\n    }\n    return p;\n}\n\n\nfloat Shadow( in vec3 p, in vec3 toLight )\n{\n    const float softness = 1.;\n    toLight = toLight-p;\n    float l = length(toLight);\n    vec3 ray = toLight/l;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float minh = 1e30;\n    for ( int i=0; i < shadowLoopCount; i++ )\n    {\n        if ( h < epsilon || t > l )\n            break;\n        h = SDF(p+ray*t);\n        minh = min(minh,h/max(t*softness,1.));\n        t += h;\n    }\n    return smoothstep(epsilon,.03,minh);\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*.001;\n    return normalize(\n            SDF(p+d.xxx)*d.xxx +\n            SDF(p+d.yyx)*d.yyx +\n            SDF(p+d.yxy)*d.yxy +\n            SDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvoid Shading( out vec3 bounce, out vec3 bounceTint, out vec3 diffuse, in vec3 p, in vec3 ray )\n{\n    vec3 normal = GetNormal(p);\n    \n    vec3 light = vec3(0);\n    for( int i=0; i < lights.length(); i++ )\n    {\n        vec3 toLight = lights[i].pos - p;\n\n        float nDotL = dot(normal,toLight);\n        if ( nDotL <= 0. ) continue;\n\n        float l = max(nDotL/pow(dot(toLight,toLight),3./2.),0.);\n\n        l *= Shadow(p,lights[i].pos);\n        \n        light += lights[i].colour * l;\n    }\n    \n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0.,SDF(p+normal*.3)/.3-1.));\n    ao *= exp2(min(0.,SDF(p+normal*.15)/.15-1.));\n    ao *= exp2(min(0.,SDF(p+normal*.07)/.07-1.));\n    light += ao;\n    \n    // get material\n    vec3 albedo = vec3(.3,.5,.6)*.4;\n    vec4 specLevel = vec4(vec3(.9),1);\n    \n    // put a pattern on the walls, so they're visible\n//    albedo *= 1.-.5*pow(texture(iChannel0,vec2(p.y,p.x+p.z)/2.).rgb,vec3(.2));\n    specLevel.rgb = vec3(mix( .8, .95, texture(iChannel0,vec2(p.y,p.x+p.z)/2.).g ));\n//    normal = normalize( normal + (texture(iChannel0,vec2(p.y,p.x+p.z)/2.).rgb-.5)*.002 );\n    \n    // frame the mirrors - so we can read the scene better\n    float frame = .07;\n    if ( abs(p.y-1.) > 2.-frame )//|| abs(p.x-2.5)+abs(p.z+1.) > 9.-frame )\n    {\n        albedo = vec3(.1);\n        specLevel = vec4(0);\n    }\n    \n    float mat1sdf = Mat1SDF(p);\n    float mat2sdf = Mat2SDF(p);\n    if ( mat2sdf < mat1sdf )\n    {\n        // main object\n        albedo = blobAlbedo;\n        specLevel = vec4(blobSpecColour,blobMaxSpecular);\n    }\n    \n    if ( Mat3SDF(p) < min(mat1sdf,mat2sdf) )\n    {\n        // floor\n        vec2 uv = p.xz;\n        uv = uv*cos(.3)+sin(.3)*vec2(-1,1)*uv.yx;\n        albedo = mix( vec3(.01), vec3(1), step(.0,(fract(uv.x/1.)-.5)*(fract(uv.y/1.)-.5)) );\n        float ior = 1.33;\n        float schlick = pow((ior-1.)/(ior+1.),2.);\n\t    specLevel = vec4(vec3(schlick),1);\n    \tspecLevel *= mix( .2, .7, texture(iChannel0,vec2(p.xz)/2.).g );\n    \tnormal = normalize( normal + (texture(iChannel0,vec2(p.xz)/2.).rgb-.5)*.005 );\n    }\n\n    float fresnel = pow(dot(normal,ray)+1.,5.);\n    \n    vec3 spec = mix( specLevel.xyz, specLevel.www, fresnel );\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1)-spec) * light;\n    bounce = reflect(ray,normal);\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,2.);\n    ray = normalize(ray);\n    \n    vec3 camPos = vec3(1,0,-4.5) + vec3(1.5,.5,1)*cos(vec3(1,quasirand2).zyx*iTime*.618);\n    \n    vec3 camK = normalize(vec3(0,-.3,0)-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    \n    vec3 pos = camPos;\n    vec3 tint = vec3(1);\n\n    for( int bounce=0; bounce < maxBounces; bounce++ ) // gosh this can handle a lot of bounces!\n    {\n        pos = Trace( pos, ray );\n\n        vec3 bounceTint, diffuse;\n        Shading( ray, bounceTint, diffuse, pos, ray );\n        fragColour.rgb += diffuse*tint;\n        tint *= bounceTint;\n        if ( length(tint) < .01 ) break; // early out if reflections aren't visible\n    }\n    \n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    \n    fragColour.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljGzD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[1242, 1242, 1267, 1282, 1545], [1548, 1548, 1573, 1585, 2148], [2150, 2150, 2175, 2188, 2221], [2223, 2223, 2244, 2244, 2301], [2304, 2304, 2342, 2342, 2578], [2581, 2581, 2625, 2625, 3085], [3088, 3088, 3114, 3114, 3309], [3312, 3312, 3408, 3408, 5684], [5687, 5687, 5745, 5745, 6661]], "test": "error"}
{"id": "3ll3Dl", "name": "[Wan] Sand dunes", "author": "wan", "description": "Noise texture tests. Also discovering that smoothstep = quick cubic interpolation.", "tags": ["raymarching", "noise"], "likes": 3, "viewed": 359, "published": "Public API", "date": "1558080043", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 0.5\n#define STEPS 100.\n\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noiseTex(vec2 p) {\n\tvec2 n = floor(p*SCALE);\n\tvec2 f = fract(p*SCALE);\n    f = vec2(smoothstep(0.,1.,f.x),smoothstep(0.,1.,f.y));\n\tfloat c1 = rand(n), c2 = rand(n+vec2(1.,0.)), c3 = rand(n+vec2(0.,1.)), c4 = rand(n+vec2(1.,1.));\n    return mix(mix(c1,c2,f.x), mix(c3,c4,f.x), f.y);\n}\n\nfloat sdf(vec3 p, vec3 eye) {\n    if (length(p - eye) > 30.) return 1000.;\n\treturn p.y - noiseTex(p.xz) + noiseTex(p.xz*10.*vec2(2.5,1.))/100. - noiseTex(p.xz*150.)/350.;\n}\n\nvec3 normal(vec3 p, vec3 eye) {\n\tvec2 e = vec2(0.001, 0.);\n\treturn normalize(vec3(\n\t\tsdf(p+e.xyy, eye)-sdf(p-e.xyy, eye),\n\t\tsdf(p+e.yxy, eye)-sdf(p-e.yxy, eye),\n\t\tsdf(p+e.yyx, eye)-sdf(p-e.yyx, eye)\n\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) /iResolution.y;\n\n\tvec2 eyexz = vec2(0.,iTime);\n\tvec3 eye = vec3(eyexz.x,3. - sdf(vec3(eyexz.x,2.,eyexz.y), eyexz.xxy), eyexz.y);\n\tvec3 raydir = normalize(vec3(uv.x,uv.y-.5,1.));\n\tvec3 p = eye;\n\tfloat hit = 0.;\n\t\t\t\t\n\tfor (float i = 0.; i < STEPS; i++) {\n\t\tfloat d = sdf(p, eye);\n\t\tif (d < 0.001) {\n\t\t\thit = i;\n\t\t\tbreak;\n\t\t}\n\t\tp += d * raydir;\n\t}\n\t\n\tvec3 lightdir = normalize(vec3(-.5,-1.,-1.));\n\tvec3 color = vec3(0.);\n    vec3 dark = vec3(.3,.2,.1);\n\tif (hit > 0.) {\n\t\tcolor = mix(\n            dark,\n            vec3(.9,.7,.4),\n            clamp(dot(normal(p, eye), -lightdir) - hit/STEPS, 0.,1.));\n        color = mix(\n            color,\n            vec3(1.,0.9,0.5),\n            p.y-.3\n            );\n      \tcolor = mix(\n            color,\n            dark,\n            clamp(length(p-eye)/20., 0., 1.));\n    } else if (length(p-eye) > 100.) {\n     \tcolor = mix(vec3(.9,.99,.90),vec3(.5,.6,.99),uv.y);\n    } else {\n        color = dark;\n    }\n    \n    //color = vec3(noiseTex(uv*10.));\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 124], [126, 126, 150, 150, 415], [417, 417, 446, 446, 589], [591, 591, 622, 622, 797], [799, 799, 856, 856, 1930]], "test": "timeout"}
{"id": "3ll3DS", "name": "[Wan] Tentacle Tunnel", "author": "wan", "description": "April 29nd, 2019. Practicing tunnels.", "tags": ["raymarching", "tunnel"], "likes": 4, "viewed": 313, "published": "Public API", "date": "1557490975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p) {\n\tfloat a = p.z/30.;\n\tp = vec3(p.x*cos(a)-p.y*sin(a),p.y*cos(a)+p.x*sin(a), p.z);\n\tp.y += cos(p.z);\n\tp += cos(p.y*2.)*sin(p.x*2.+p.z)*(.7+sin(p.z/3.)*.4);\n\treturn 2.+3.*abs(sin(iTime)) - length(p.xy);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.001, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyy)-map(p-e.xyy),\n\t\tmap(p+e.yxy)-map(p-e.yxy),\n\t\tmap(p+e.yyx)-map(p-e.yyx)\n\t\t));\n}\n\nvec3 lightdir = normalize(vec3(.5,-.5, 1.1));\nfloat light(vec3 p) {\n\treturn dot(normal(p), -lightdir) * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos= (2.*fragCoord.xy - iResolution.xy )/min(iResolution.x, iResolution.y);\n\n\tvec3 eye = vec3(0.,0.,iTime*4.);\n\tvec3 p = eye;\n\tvec3 raydir = normalize(vec3(pos.x, pos.y, 1.));\n\tint hit = -1;\n\t\n\tfor (int i = 0; i < 200; i++) {\n\t\tfloat d = map(p);\n\t\tif (d < 0.001) {\n\t\t\thit = i;\n\t\t\tbreak;\n\t\t}\n\t\tp += d * raydir * .4;\n\t}\n\t\n\tfloat color = -.5;\n\tif (hit > -1) color = light(p) - float(hit)/100.;\n\t\n\tfragColor = vec4(mix(vec3(.5,.2,.4), vec3(.7,.8,.5), color), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 221], [223, 223, 244, 244, 388], [436, 436, 457, 457, 504], [506, 506, 563, 563, 1037]], "test": "ok"}
{"id": "3ll3Rl", "name": "[00002] sphere + fog", "author": "samel", "description": "[00002] sphere + fog", "tags": ["raymarching", "basic", "shadow", "fog", "diffuse"], "likes": 1, "viewed": 112, "published": "Public", "date": "1557328756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plane(vec3 p, float y)\n{\n return p.y-y;\n}\n\nfloat sphere(vec3 p,vec3 pos,float r)\n{\n return length(pos-p)-r;\n}\n\nfloat scene(vec3 p)\n{\n float sphere1=sphere(p,vec3(1.0,1,6),1.0);\n float sphere2=sphere(p,vec3(0.0,sin(iTime)*3.0,10),1.0);\n float plane=plane(p,0.0);\n return min(sphere1,min(sphere2,plane));\n}\n\nfloat raymarch(vec3 origin,vec3 direction)\n{\n float traveled=0.0;\n float distance=0.0;\n for(int i=0;i<100;i++)\n {\n  vec3 p=origin+traveled*direction;\n  distance=scene(p);\n  if(distance<=0.01 || traveled>100.0)\n  {\n   break;\n  }\n  traveled+=distance;\n }\n return traveled;\n}\n\nvec3 normalAt(vec3 p)\n{\n vec2 epsilon=vec2(0.01,0);\n float distanceAtP=scene(p);\n return normalize(vec3(distanceAtP-scene(p-epsilon.xyy),\n                       distanceAtP-scene(p-epsilon.yxy),\n                       distanceAtP-scene(p-epsilon.yyx)));\n}\n\nfloat diffuse(vec3 p)\n{\n vec3 sunPos=vec3(sin(iTime),25,cos(iTime)+6.0);\n vec3 normal=normalAt(p);\n vec3 lightDir=normalize(sunPos-p);\n if(raymarch(p+lightDir*0.1,lightDir)<length(sunPos-p))\n {\n  return 0.0;\n }\n return clamp(dot(lightDir,normal),0.0,1.0);\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in vec3 p ) // camera to point distance\n{\n    float distance=length(p);\n    //float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float fogAmount = (1.0 - exp( p.y-1.5 ))*(p.y<1.5?1.0:0.0);\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 applyFog2( in vec3  rgb,      // original color of the pixel\n               in vec3 p, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float distance=length(p);\n    float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 color=vec3(0,0,0);\n    vec3 origin=vec3(0.0,2.0,-2);\n    vec3 direction=normalize(vec3(uv,1));\n    float traveled=raymarch(origin,direction);\n    color=vec3(diffuse(origin+direction*traveled));\n    vec3 sunPos=vec3(sin(iTime),25,cos(iTime)+6.0);\n    vec3 lightDir=normalize(sunPos-origin+traveled*direction);\n    color=applyFog(color,origin+traveled*direction);\n    /*color=applyFog2(color,\n                    origin+traveled*direction,\n                   direction,\n                    lightDir\n                   );*/\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 47], [49, 49, 88, 88, 115], [117, 117, 138, 138, 310], [312, 312, 356, 356, 584], [586, 586, 609, 609, 841], [843, 843, 866, 866, 1100], [1102, 1102, 1224, 1224, 1472], [1474, 1474, 1712, 1712, 2074], [2076, 2076, 2133, 2133, 2763]], "test": "ok"}
{"id": "3ll3RS", "name": "slice", "author": "lennyjpg", "description": "asdfasdfasd", "tags": ["asdfasdfasdf"], "likes": 7, "viewed": 337, "published": "Public API", "date": "1556740845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x*= iResolution.x / iResolution.y;\n    float t = iTime;\n    float z = t;\n    uv = rotate(uv,z*0.1);\n\n   float st = .1;\n   vec2 fu = mod(fragCoord,100.0);\n   float grid = step(length(fu-50.0),2.0);   \n    \n   \n    \n   vec2 p = vec2(cos(uv.y*12.11),sin(uv.x*11.4))*0.21;\n   float k = length(uv - p);\n   k -= t*0.07;\n\n    float g = fract(k*7.34);\n    vec3 col = vec3(1.2-g);\n    col.gb -= step(mod(k,1.2),0.3);\n    col.rg *= step(mod(k,1.),0.8);\n    fragColor +=  vec4(col + grid*0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 126], [129, 129, 186, 186, 730]], "test": "ok"}
{"id": "3ll3WS", "name": "Mandelbrot DNL Maths", "author": "martantoine", "description": "Mandelbrot set Illustration created by Antoine MARTIN", "tags": ["mandelbrot"], "likes": 1, "viewed": 55, "published": "Public", "date": "1557679778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct complex\n{    \n    float a, b;\n};\n\n//(a1+ib1)(a2+ib2) = a1*a2 + a1*ib2 + a2*ib1 - b1*b2\ncomplex multiple(complex c1, complex c2)\n{\n    float a = (c1.a * c2.a) - (c1.b * c2.b);\n\tfloat b = (c1.a * c2.b) + (c2.a * c1.b);\n    return complex(a,b);\n}\n\ncomplex add(complex c1, complex c2)\n{\n    return complex(c1.a + c2.a, c1.b + c2.b);\n}\n\nfloat norm(complex c)\n{\n\tfloat dist = sqrt(c.a * c.a + c.b * c.b);\n\treturn dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int n = 18;\n    complex z = complex(0.0,0.0);\n    \n    float scale = 5.0 - exp(sin(iTime));\n    vec2 uv = vec2(scale, scale) * (fragCoord/iResolution.xy - vec2(0.5,0.5));\n\tcomplex c = complex(uv.x,uv.y);\n    \n    for(int i = 0; i < n; i++)\n    {\n    \tz = add(multiple(z,z),c);\t    \n    }\n    \n    vec3 col;\n    \n    if(norm(z) < 5.0)\n    \tcol = vec3(0.0,0.0,0.0);\n\telse\n    \tcol = vec3(cos(norm(z)), sin(log(norm(z))), 0.0);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 94, 136, 136, 250], [252, 252, 289, 289, 337], [339, 339, 362, 362, 421], [423, 423, 480, 480, 952]], "test": "ok"}
{"id": "3ll3z2", "name": "Motion without Movement 2", "author": "FabriceNeyret2", "description": "Testing various modulations to convey illusion of motion.\ninspired from paper [url]http://www.cse.yorku.ca/~kosta/Motion_Without_Movement/Motion_Without_Movement.html[/url]", "tags": ["illusion", "perception"], "likes": 2, "viewed": 314, "published": "Public API", "date": "1556957080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 2.* u / R.y,\n         D = cos(.3*iTime-vec2(0,1.57));           // custom dir\n    if (U.x>3.) { O-=O; return; }\n    int i = int(U.x)+3*int(U.y);                   // pannel id\n    U = 2.*fract(U)-1.;                            // pannel coords\n    \n    float t = 10.*iTime,\n          kl = 50.,                                // wavelenght\n          kr = .1,                                 // border width\n          l = length(U), r = .5,\n          m = smoothstep(-kr,kr,r-l),              // disk mask\n          b = .5-.5*cos(6.28*m),                   // border zone (where effect occurs)\n          x = dot(U,D),                            // pos along D\n          d = x*x+r*r-l*l, s = -x+sign(x)*sqrt(d), // distance to disk in dir D\n        phi =   i==0 ? kl*l                        // radial\n              : i==1 ? kl*x                        // axial\n              : i==2 ? d > 0. ? kl*s : t           // axial from disk\n              : i==3 ? d > 0. && x < 0. ? kl*s : t // axial left to disk\n              : i==4 ? -kl*l\n              : i==5 ? d > 0. && x < 0. ? -kl*s : t\n              : t;\n    \n    O = vec4( m + .25*b*sin(phi-t) );              // magic draw\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1254]], "test": "ok"}
{"id": "3llGzX", "name": "3D Worley noise texturing", "author": "tpfto", "description": "Demonstration of an experimental 3D Worley noise implementation, by texturing a sphere and a plane.", "tags": ["procedural", "voronoi", "noise", "worley", "cellular"], "likes": 12, "viewed": 1102, "published": "Public API", "date": "1557142509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// demo of using an experimental implementation of 3D Worley noise to texture a surface\n\n// modified MATLAB bone colormap\n\nvec3 bone( float t )\n{\n\t return 0.875 * t + 0.125 * clamp(vec3(4.0, 3.0, 3.0) * t - vec3(3.0, 1.0, 0.0), 0.0, 1.0);\n}\n\n// rescaling function\n\nfloat rescale(float x, vec2 range)\n{\n\t  float a = range.x, b = range.y;\n      return (x - a)/(b - a);\n}\n\n// simple LCG\n\n#define LCG(k) k = (65 * k) % 1021\n#define lr(k) float(k)/1021.\n\n// permutation polynomial\n\nint permp (int i1, int i2)\n{\n      int t = (i1 + i2) & 255;\n        \n      return ((112 * t + 153) * t + 151) & 255;\n}\n\n// return the two closest distances for 3D Worley noise\n// type controls the type of metric used\n\nvec2 worley(int type, vec3 p)\n{\n    vec2 dl = vec2(20.0);\n    ivec3 iv = ivec3(floor(p));\n    vec3 fv = fract(p);\n    \n    int j = 0; // initialization for Knuth's \"algorithm L\"\n    ivec3 di = ivec3(1), ki = -di;\n    ivec4 fi = ivec4(0, 1, 2, 3);\n    \n    // instead of writing a triply nested loop (!!)\n    // generate the indices for the neighbors in Gray order (Knuth's \"algorithm L\")\n    // see section 7.2.1.1 of TAOCP, Volume 4A or https://doi.org/10.1145/360336.360343\n    \n\tfor (int k = 0; k < 27; k++) // loop through all neighbors\n    { \n\t\t // seeding\n        int s = permp(permp(permp(0, iv.z + ki.z), iv.y + ki.y), iv.x + ki.x); LCG(s);\n            \n\t\t for (int m = 0; m < 2; m++) // two points per cell\n             {\n                // generate feature points within the cell\n                LCG(s); float sz = lr(s);\n                LCG(s); float sy = lr(s);\n                LCG(s); float sx = lr(s);\n                \n                vec3 tp = vec3(ki) + vec3(sx, sy, sz) - fv;\n                float c = 0.0;\n                if (type == 1) c = dot(tp, tp); // Euclidean metric\n                if (type == 2) c = abs(tp.x) + abs(tp.y) + abs(tp.z); // Manhattan metric\n                if (type == 3) c = max(abs(tp.x), max(abs(tp.y), abs(tp.z))); // Chebyshev metric\n                \n                float m1 = min(c, dl.x); // ranked distances\n                dl = vec2(min(m1, dl.y), max(m1, min(max(c, dl.x), dl.y)));\n             }\n        \n        // updating steps for Knuth's \"algorithm L\"\n        j = fi[0]; fi[0] = 0; ki[2 - j] += di[j];\n        if ((ki[2 - j] & 1) == 1) {\n            di[j] = -di[j];\n            fi[j] = fi[j + 1]; fi[j + 1] = j + 1;\n        }\n\t}\n    \n    if (type == 1) dl = sqrt(dl); // don't forget to root at the end for Euclidean distance\n        \n    return dl;\n}\n\n// raytracing demo code adapted from Inigo Quilez, https://www.shadertoy.com/view/4sfGzS\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5 * iTime;\n\tvec3 ro = vec3( 2.5 * cos(an), 1.0, 2.5 * sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross(uu, ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x * uu + p.y * vv + 1.5 * ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0, 1.0, 0.0);\n\n    // raytrace\n\tfloat tmin = 1.0e3;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = -ro.y/rd.y;\n\tif( h > 0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0, 1.0, 0.0); \n\t\tpos = ro + h * rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor, di/l)/(l * l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b * b - c;\n\tif( h > 0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h < tmin ) \n\t\t{ \n\t\t\ttmin = h; \n\t\t\tnor = normalize(ro + h * rd - sc); \n\t\t\tocc = 0.5 + 0.5 * nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.8);\n\tif( tmin < 100.0 )\n\t{\n\t    pos = ro + tmin * rd;\n\t    float f = 0.0;\n        int type = int(0.05 * iTime) % 3 + 1;\n\t\t\n\t\tif( p.x < 0.0 )\n\t\t{\n\t\t\tvec2 w = worley(type, 5.0 * pos);\n            f = length(w.xy)/(w.y + w.x) - w.x;\n\t\t}\n\t\telse\n\t\t{\n            vec3 q = 2.0 * pos; // three octaves\n            vec2 w = worley(type, q);\n            f  = 2.0 * (w.y - w.x); q = m * q * 2.01;\n            w = worley(type, q);\n            f += 0.5 * (w.y - w.x); q = m * q * 2.02;\n            w = worley(type, q);\n            f += 0.25 * (w.y - w.x);\n\t\t}\t\t\n\t\t\n\t\tf = smoothstep( -0.7, 0.7, f );\n\t\tf *= occ;\n\t\tcol = bone(rescale(f, vec2(0.0, 2.8)));\n\t\tcol = mix( vec3(0.8), col, exp( -0.01 * tmin * tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llGzX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1194, 1194, 1216, 1216, 1311], [1336, 1336, 1372, 1372, 1439], [1548, 1548, 1576, 1576, 1666], [1766, 1766, 1797, 1797, 3575], [3793, 3793, 3850, 3850, 5784]], "test": "ok"}
{"id": "3lS3DR", "name": "OpenSpace", "author": "Stef", "description": "My first shader. Originally coded on Bonzomatic.\n", "tags": ["openspace"], "likes": 25, "viewed": 260, "published": "Public", "date": "1558992282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution\n#define texNoise iChannel0\n#define texChecker iChannel2\n#define texTex1 iChannel1\n#define texTex3 iChannel3\n\nmat2 rot(float a) \n{\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdBox(vec3 p,vec3 s)\n{\n  vec3 ap=abs(p)-s;\n  return length(max(vec3(0.0),ap)) + min (0.0, max(0.0, max(ap.x,max(ap.y,ap.z))));\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdTaperedCapsule( vec3 p, float r1, float r2, float h ) \n{ \n  vec2 q = vec2( length(p.xz), p.y ); \n  float b = (r1-r2)/h; float a = sqrt(1.0-b*b); float k = dot(q,vec2(-b,a)); \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n     vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\nfloat rnd(float t) \n{\n  return fract(sin(t*745.565)*7842.654);\n}\n\n#define matDef 0.0\n#define matEcran -1.0 // custom material id must be <0 (tricks for initialize default obj mat  from distance with vec4(dist))\n#define matTable -2.0\n#define matLight -3.0\n#define matBlack -4.0\n#define matSol   -5.0\n#define matPaper -6.0\n\nvec4 minObj(vec4 obj1, vec4 obj2) { return obj1.x<=obj2.x ? obj1 : obj2; }\nvec4 minObj(vec4 obj1, float dist2) { return obj1.x<=dist2 ? obj1 : vec4(dist2); }\nvec4 sminObj(vec4 obj1, vec4 obj2, float k ) { float h = clamp( 0.5 + 0.5*(obj2.x-obj1.x)/k, 0.0, 1.0 ); return vec4(mix( obj2.x, obj1.x, h ) - k*h*(1.0-h), minObj(obj1,obj2).yzw); }\nvec4 sminObj(vec4 obj1, float dist2, float k ) { float h = clamp( 0.5 + 0.5*(dist2-obj1.x)/k, 0.0, 1.0 ); return vec4(mix( dist2, obj1.x, h ) - k*h*(1.0-h), minObj(obj1,dist2).yzw); }\n\nbool checkBoundingSphere(inout vec4 obj, vec3 p, float h, bool show)\n{\n  if(show) { obj=minObj(obj,sdSphere(p,h));return true; }\n  return sdSphere(p,h)<obj.x;\n}\nbool checkBoundingBox(inout vec4 obj, vec3 p, vec3 s, bool show)\n{\n  if(show) { obj=minObj(obj,sdBox(p,s));return true; }\n  return sdBox(p,s)<obj.x;\n}\n\nvec4 objTable(vec3 p)\n{\n  vec3 p2 = p;\n  p2.x = abs(p2.x);\n  p2.z = abs(p2.z);\n  vec4 obj= vec4(sdBox(p2-vec3(2,-.8,1),vec3(.06,.8,.06)));     // les pattes de la table\n  obj = minObj(obj, vec4(sdBox(p-vec3(0,-1.6,0),vec3(2.2,.05,1.2)), matTable,p.x,p.z)); // le plateau\n  return obj;\n}\n\nvec4 objPlaystation(vec3 p)\n{\n  float t=sdBox(p,vec3(0.5,.2,0.35)); // le plateau\n  return vec4(t);\n}\n\nvec4 objEcran(vec3 p, float h)\n{\n  vec3 center=vec3(0,.7+h,0);\n  vec3 size=vec3(0.75,.5,0.05);\n  vec4 obj=vec4(sdBox(p,vec3(0.4,.02,0.2))); // le plateau\n  obj = minObj(obj, vec4(sdBox(p+vec3(0,.4,0.1),vec3(0.1,.4,0.02)))); // le pied\n  obj = minObj(obj, vec4(sdBox(p+center,size),p.z>0.05?matEcran:matDef,(p+center).x/size.x,(p+center).y/size.y)); // le cadre\n  return obj;\n}\n\nvec4 objOrdi(vec3 p)\n{\n  float t = abs(sdBox(p+vec3(0,.6,0.1),vec3(0.25,.6,0.7))); // la tour\n  return vec4(t);\n}\n\nvec4 objChaisepied(vec3 p)\n{\n  vec3 p2=p;\n  p2.xy*=rot(-.3);\n  vec4 obj = vec4(sdBox(p2+vec3(.26,.43,0),vec3(0.36,.03,.03))); // une barre de pied\n  p2=p+vec3(0.7,0.1,0);\n  p2.yz=p2.yz*rot(3.14/2.0);\n  p2.xy*=rot(p.x);\n  obj = minObj(obj, vec4(sdRoundedCylinder(p2,.05,.04,.02),matBlack,0,0));\n  return obj;\n}\n    \nvec4 objChaisecoude(vec3 p)\n{\n  float t = sdBox(p+vec3(0,.15,0),vec3(0.02,.15,.05)); // barre verticale\n  t = min(t, sdBox(p+vec3(0,.3,.1),vec3(0.07,.01,.18))); // accoudoir\n  return vec4(t);\n}\n\nvec4 objChaise(vec3 p)\n{\n  vec4 obj = vec4(sdVerticalCapsule(p+vec3(0,.9,0),.65,.05)); // la barre verticale\n  vec3 p2=p;  \n  for(int i=0;i<5;++i)\n  {\n    obj = minObj(obj,objChaisepied(p2)); // les pieds\n    p2.xz*=rot(3.14/2.5);\n  }\n\n//  p2.xz*=rot(time);\n  \n  obj = minObj(obj, sdRoundedCylinder(p2+vec3(0,1,0),.25,.03,.02));\n  obj = minObj(obj, sdBox(p2+vec3(0,.9,0),vec3(.57,.02,.05)));\n  obj = minObj(obj, objChaisecoude(p2+vec3(-.55,.9,0)));\n  obj = minObj(obj, objChaisecoude(p2+vec3(.55,.9,0)));\n\n  p2=p2+vec3(0,1.5,-.5);\n  p2.yz=p2.zy;\n  obj = minObj(obj, sdRoundedCylinder(p2,.25,.03,.02));\n\n  return obj;\n}\n\nvec4 objLampe(vec3 p)\n{\n  vec4 obj = vec4(sdSphere( p*vec3(1,1.5,1), .1),matLight,0,0);\n  p.y+=.1;\n  obj = minObj(obj, vec4(sdCappedCone( p, .1, .1, .15 ),matBlack,0,0));\n  p.y+=.1;\n  p.xy *= rot(1.0);\n  p.y-=.1;\n  obj = minObj(obj, vec4(sdVerticalCapsule(p,.6,.03),matBlack,(p.y*2.0-.5),0.0));\n  p.x+=.2;\n  p.y-=.45;\n  p.xy *= rot(-1.0);\n  p.y-=.3;\n  obj = sminObj(obj, sdVerticalCapsule(p,.6,.03), .1);\n  p.y-=.8;\n  obj = sminObj(obj, vec4(sdSphere(p,.15)), .1);\n  return obj;\n}\n\nvec4 objKeyboard(vec3 p)\n{\n  float t=sdBox(p,vec3(0.65,.05,0.35)); // le contour\n  p.z-=.02;\n  //float f=max(0.0,texture(texTex1, p.xz*vec2(1.98,.58)).z-.6)+.6;\n\tfloat f=max(0.0,max(fract(p.x*15.0),fract(p.z*15.0))-.5);\n  t = min(t,  sdBox(p,vec3(0.58,.02,0.26))-f*.09); // les touches\n  return vec4(t);\n}\n\nvec4 objBureau(vec3 p)\n{\n  vec3 p2=p;\n  p2.xz *= rot(0.5);\n  vec3 p3=p;\n  p3.xz *= rot(-0.5);\n  \n  vec4 obj = objTable(p);\n  obj = minObj(obj,objOrdi(p+vec3(-1.6,0,-.3)));\n  if(checkBoundingBox(obj,p+vec3(0,2.4,0),vec3(2.2,.8,1.2), false))\n  {\n    obj = minObj(obj,objPlaystation(p3+vec3(1.1,1.8,1)));\n    obj = minObj(obj,objEcran(p3+vec3(1.1,2.04,1),-.1));\n    obj = minObj(obj,objEcran(p2+vec3(-1.1,1.68,1),.27));\n    obj = minObj(obj,objEcran(p+vec3(0,1.68,.7),.27));\n    obj = minObj(obj,objKeyboard(p+vec3(0,1.68,-.7)));\n  }\n  if(checkBoundingSphere(obj,p-vec3(0,-.9,2.1),1.2, false))\n  {\n    obj = minObj(obj,objChaise(p+vec3(0,0,-2)));\n  }\n  return obj;\n}  \n\nvec4 objBureaux(vec3 p)\n{\n  vec3 p2=p;\n  p2.xz = abs(p2.xz)-vec2(2.21,1.21);\n  return objBureau(p2);\n}\n\nvec4 objPlafond(vec3 p)\n{\n  return vec4(20.0+p.y,matDef,0.0,0.0);\n}\n\nvec4 objPaper(vec3 p, float ry, float h)\n{\n  float width=.25;\n  float height=.35;\n  p.xz*=rot(-ry);\n  return vec4(sdBox(p+vec3(0,h*.5,0),vec3(width,h,height)),matPaper,p.x/width,p.z/height);\n}\n\nvec4 objStylo(vec3 p, float ry)\n{\n  float width=.01;\n  float height=.35;\n  p.xy*=rot(1.57);\n  p.xz*=rot(-ry);\n  return vec4(sdVerticalCapsule(p,height,width),matDef,0,0);\n}\n\nvec4 objHumanLeg(vec3 p2, float hipsx, float hipsy, float kneex, float anklex)\n{\n  float hips_knee_len = .9;\n  float hips_radius = .25;\n  float knee_radius = .15;\n  float knee_ankle_len = .9;\n  float ankle_radius = .1;\n  float foot_radius = .08;\n  float ankle_foot_len = .35;\n  p2.xz *= rot(hipsy);\n  p2.yz *= rot(hipsx); // hips.x\n  vec4 obj = vec4(sdTaperedCapsule(p2,hips_radius,knee_radius,hips_knee_len));\n  p2.y-=hips_knee_len;\n  p2.yz *= rot(kneex); // knee.x\n  obj = sminObj(obj,sdTaperedCapsule(p2,knee_radius,ankle_radius,knee_ankle_len), .1);\n  p2.y-=knee_ankle_len;\n  p2.yz *= rot(1.5+anklex); // ankle.x\n  obj = minObj(obj,sdTaperedCapsule((p2-vec3(0,-.03,0)),ankle_radius*1.2,foot_radius,ankle_foot_len));\n  return obj;\n}\n\nvec4 objHumanArm(vec3 p2, float shoulderx, float shouldery, float shoulderz, float elbowx, float wristx)\n{\n  float shoulder_elbow_len = .55;\n  float shoulder_radius = .15;\n  float elbow_radius = .1;\n  float elbow_wrist_len = .55;\n  float wrist_radius = .07;\n  float hand_radius = .08;\n  float wrist_hand_len = .2;\n  p2.xz *= rot(shouldery);\n  p2.xy *= rot(shoulderz);\n  p2.yz *= rot(shoulderx);\n  vec4 obj = vec4(sdTaperedCapsule(p2,shoulder_radius,elbow_radius,shoulder_elbow_len));\n  p2.y-=shoulder_elbow_len;\n  p2.yz *= rot(elbowx);\n  obj = sminObj(obj,sdTaperedCapsule(p2,elbow_radius,wrist_radius,elbow_wrist_len),.1);\n  p2.y-=elbow_wrist_len;\n  p2.yz *= rot(wristx);\n  obj = minObj(obj,sdTaperedCapsule(p2*vec3(.95,1,1.4),wrist_radius,hand_radius,wrist_hand_len));\n  return obj;\n}\n\nvec4 objHumanTorso(inout vec3 p2, float hipsx, float spinex)\n{\n  float hips_spine_len = .1;\n  float hips_radius = .45;\n  float spine_radius = .4;\n  float neck_radius = .45;\n  float spine_neck_len = .1;\n  p2.yz *= rot(3.14+hipsx); // hips.x\n  p2.y -=.15;\n  vec4 obj = vec4(sdTaperedCapsule(p2*vec3(1,1,1.4),hips_radius,spine_radius,hips_spine_len)); \n  p2.y-=hips_spine_len;\n  p2.y -=.15;\n  p2.yz *= rot(spinex); // knee.x\n  p2.y -=.15;\n  obj = sminObj(obj,sdTaperedCapsule(p2*vec3(1,1,1.3),spine_radius,neck_radius,spine_neck_len),.1);\n  p2.y-=spine_neck_len*2.2;\n  return obj;\n}\n\nvec4 objHumanHead(vec3 p2, float headx, float heady)\n{\n  p2.yz *= rot(headx); // knee.x\n  p2.xz *= rot(heady); // knee.x\n  p2.y -=.15;\n  vec4 obj = vec4(sdSphere(p2*vec3(1.2,1,1),.25)); \n  p2.y -=.15;\n  obj = minObj(obj, vec4(sdRoundedCylinder(p2,.122,.07,.07))); \n  obj = sminObj(obj, vec4(sdRoundedCylinder(p2+vec3(0,.07,-.2),.1,.01,.005)),.1); \n  return obj;\n}\n\nvec4 objHuman(vec3 p)\n{\n  float hips_width = .25;\n  float shoulder_width = .4;\n  vec4 obj = objHumanLeg(p-vec3( hips_width,-1.6,0.0),1.35,-.3,-1.5,.0);\n  obj = sminObj(obj,objHumanLeg(p-vec3(-hips_width,-1.6,0.0),1.4,.3,-1.5,.2+sin(iTime*10.0)*.1),0.1);\n  vec3 p2 = p-vec3(0.0,-1.7,0.0);\n  obj = sminObj(obj,objHumanTorso(p2,0.0,-.2),.1);\n  obj = sminObj(obj,objHumanHead(p2-vec3(0.0,.4,-.05),sin(iTime*10.0)*.1,sin(iTime*1.154)*.5),.1);\n  p2.yz *= rot(3.14);\n  obj = sminObj(obj,objHumanArm(p2-vec3(-shoulder_width,0.0,0.0),1.2,sin(iTime*.12)*cos(iTime*1.1)*.2,.4,.55,sin(round(iTime)*10.0)*.1),.1);\n  obj = sminObj(obj,objHumanArm(p2-vec3( shoulder_width,0.0,0.0),.9,sin(iTime*1.25)*cos(iTime*1.445)*.2,-.4,1.1,sin(iTime*10.0)*.1),.1);\n  return obj;\n}\n\nvec3 lp = vec3(.6,-2.65,1.8);\n\nvec4 map(vec3 p)\n{\n  //return minObj(vec4(-p.y,matDef,0,0),objHuman(p));\n  \n  vec3 size = vec3(13,1,10);\n  vec3 rp = (fract(p/size-.5)-0.5)*size;\n  rp.y = p.y;\n \n  \n  vec4 obj = objBureaux(rp);\n//obj = minObj(obj,objPlafond(p));\n  obj = minObj(obj,vec4(-p.y,matSol,p.x,p.z));  // sol\n\n  if(checkBoundingBox(obj,p+vec3(-2.2,2.3,-1.65),vec3(2.3,.7,.8),false))\n  {\n    obj = minObj(obj,objLampe(p-lp));\n    obj = minObj(obj,objPaper(p-vec3(.6,-1.7,2),.2,.1));\n    obj = minObj(obj,objPaper(p-vec3(.6,-1.9,2),.4,.1));\n    obj = minObj(obj,objPaper(p-vec3(4.0,-1.7,2),-1.4,.1));\n    obj = minObj(obj,objPaper(p-vec3(3.9,-1.9,1.9),-1.6,.1));\n    obj = minObj(obj,objPaper(p-vec3(1.5,-1.7,1.25),-1.1,.05));\n    obj = minObj(obj,objStylo(p-vec3(.7,-2.1,2.0),0.0));\n  }\n  \n  p-=size*.5;\n  p.xz *=rot(3.14);\n  p.x-=4.25;\n  p.y+=.1;\n  p.z-=1.65;\n  \n  if(checkBoundingSphere(obj,p-vec3(0,-1.9,.4),1.6,false))\n    obj = minObj(obj,objHuman(p));\n\n  return obj;\n}\n\nvec3 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec3( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25);\n}\n\nvec3 colScreenLeft(vec2 uv)\n{\n  vec2 m;\n  m.x = atan(uv.x / uv.y) / 3.14;\n  m.y = 1.0 / length(uv) * .2;\n  float d = m.y;\n  m.x += sin( time ) * 0.1;\n  m.y += time * 0.25;\n  vec3 t = plas( m * 3.14, time ) / d;\n  t = clamp( t, 0.0, 1.0 );\n  return t;\n}\n\nvec3 colScreenCenter(vec2 uv)\n{\n  vec2 uvchar = round(vec2(0,round(time*.5))+uv*30.0)/30.0;\n  \n  float noisey = texture(texNoise, uvchar.yy).r;\n  float noisex1 = texture(texNoise, uvchar.xy).r;\n  bool lineon = (fract(uv.y*30.0)>.4);\n  float linewidth = rnd(noisey)-1.0;\n  \n  vec3 col=vec3(0,.1,0); \n  if(lineon && uv.x<linewidth && uv.x>-.9 && abs(uv.y)<.9) col+=vec3(0,noisex1,0);\n  return col;\n}\n\nvec3 colScreenRight(vec2 uv)\n{\n  uv.xy*=1.0+sin(time)*.5;\n  uv.x+=time*2.+sin(time*.123);\n  uv.y+=sin(uv.x*8.0*.05+time);\n \n  vec3 col=vec3(.5)+sin(vec3(uv.x+uv.y)*vec3(.319,.257,.187))*.5;\n  return texture(texChecker, uv).r*col; // + col*(abs(uv.y)>texture(texFFT,(uv.x+1)*.5).r?1.:0.);\n}\n\nfloat colAmbientOcclusion(vec3 p, vec3 n, float dist)\n{\n  return clamp(map(p+n*dist).x/dist,0.0,1.0);\n}\nfloat colSoftShadow(vec3 p, vec3 d, float mint, float maxt, float k)\n{\n  float shad=1.0;\n  float t=.5;\n  for(float t=mint;t<maxt;)\n  {\n    float d=map(p+d*t).x;\n    if(abs(d)<.001) return 0.0;\n    shad = min(shad,k*d/t);\n    t += d;\n  }\n  return shad;\n}\n\nvoid cam(inout vec3 p)\n{\n  p.yz *= rot(sin(time*.1)*.1+.5);\n  p.xz *= rot(time*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n   vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n \n\n  vec3 s=vec3(-2,0,-8.0+sin(3.14+time-.5));\n  vec3 r=normalize(vec3(-uv,2));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  vec4 obj;\n  for(int i=0;i<100; ++i)\n  {\n    obj=map(p);\n    if(obj.x<0.001) break;\n    p+=obj.x*r;\n  }\n  \n  vec3 l=normalize(lp-p);\n  //l = normalize(vec3(sin(time*1.2)*2,-2,4+sin(time)*2));\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p).x-vec3(map(p-off.xyy).x, map(p-off.yxy).x, map(p-off.yyx).x));\n  float shad = 1.0;//\n\n  vec3 lproj=p-lp;\n  lproj.y=0.0;\n  shad = 1.0/length(lproj)-1.0; // * \n  //shad = colSoftShadow(p+n*.01,l,.1,5,10);\n\n  float ao = colAmbientOcclusion(p,n,max(.4,length(lproj)/10.0))*(sin(time*.2)*.3+.7)*.6+.6;\n  vec3 col=vec3(min(1.0,ao+shad));\n\n  if(obj.y==matEcran)\n  {\n    bool original = p.x>0.0 && p.x<5.0 && p.z>0.0 && p.z<5.0;\n    if(original)\n    {\n         if(p.x<1.45) col=colScreenLeft(obj.zw);\n    else if(p.x<2.96) col=colScreenCenter(obj.zw);\n    else              col=colScreenRight(obj.zw);\n    }\n    else             col*=vec3(.2,.2,.2);\n  }\n  else if(obj.y==matTable)    col *= pow(texture(texTex3,obj.zw*vec2(1.0,2.0)).r,0.2)*vec3(1,1,.95);\n  else if(obj.y==matLight)    col  = vec3(1,1,.5);\n  else if(obj.y==matBlack)    col *= vec3(obj.z);\n  else if(obj.y==matSol)      col *= texture(texNoise,obj.zw*vec2(1.0)).r;\n  else if(obj.y==matPaper)    col *= mix(texture(texNoise,p.yy).r*.6+.4, 1., abs(n.y));\n  else                        col *= (dot(n,l)*.5+.5);\n \n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lS3DR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 179, 179, 248], [250, 250, 285, 285, 309], [310, 310, 338, 338, 444], [445, 445, 498, 498, 561], [562, 562, 626, 626, 747], [748, 748, 812, 812, 1056], [1057, 1057, 1128, 1128, 1468], [1469, 1469, 1490, 1490, 1533], [1791, 1791, 1826, 1826, 1865], [1866, 1866, 1903, 1903, 1948], [1949, 1949, 1995, 1995, 2131], [2132, 2132, 2180, 2180, 2315], [2317, 2317, 2387, 2387, 2477], [2478, 2478, 2544, 2544, 2628], [2630, 2630, 2653, 2653, 2916], [2918, 2918, 2947, 2947, 3019], [3021, 3021, 3053, 3053, 3397], [3399, 3399, 3421, 3421, 3512], [3514, 3514, 3542, 3542, 3823], [3829, 3829, 3858, 3858, 4022], [4024, 4024, 4048, 4048, 4642], [4644, 4644, 4667, 4667, 5124], [5126, 5126, 5152, 5152, 5431], [5433, 5433, 5457, 5457, 6096], [6100, 6100, 6125, 6125, 6202], [6204, 6204, 6229, 6229, 6271], [6273, 6273, 6315, 6315, 6465], [6467, 6467, 6500, 6500, 6639], [6641, 6641, 6721, 6721, 7376], [7378, 7378, 7484, 7484, 8164], [8166, 8166, 8228, 8228, 8745], [8747, 8747, 8801, 8801, 9110], [9112, 9112, 9135, 9135, 9865], [9898, 9898, 9916, 9970, 10846], [10848, 10848, 10881, 10881, 11040], [11042, 11042, 11071, 11071, 11294], [11296, 11296, 11327, 11327, 11693], [11695, 11695, 11725, 11725, 11984], [11986, 11986, 12041, 12041, 12089], [12090, 12090, 12160, 12160, 12343], [12345, 12345, 12369, 12369, 12430], [12432, 12432, 12489, 12537, 14112]], "test": "error"}
{"id": "3ls3DS", "name": "[Wan] Flower dance", "author": "wan", "description": "May 9th, 2019. Practicing work in polar coordinates.", "tags": ["2d", "polarcoordinates"], "likes": 1, "viewed": 342, "published": "Public API", "date": "1557491164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat sstep(float a, float x) {\n\treturn smoothstep(a*0.98, a*1.02, x);\n}\n\nfloat flower(vec2 p) {\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat arms = a*(5. + ceil((sin(iTime*3.)+.215)*5.));\n\treturn sstep(.5,r + sin(arms)/5.);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(p.x*cos(a)-p.y*sin(a),p.y*cos(a)+p.x*sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n\tvec2 p = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tp = rot(p, iTime/3.);\n\t\n\tvec2 p1 = mod(p*5., 2.)-1.;\n\tvec3 color = mix(vec3(.5,.2,.0),\n\t\t\t  vec3(.9,.9,.1),\n\t\t\t  flower(p1) - flower(.8*p1));\n\tcolor += mix(vec3(.5,.2,.0),\n\t\t    vec3(.8,.7,.4),\n\t\t    flower(p*.8)) * .9;\n\tcolor *= mix(vec3(1.,1.,1.),\n\t\t    vec3(.8,.8,.8),\n\t\t    flower(p*.4));\n\t\n\tfragColor = vec4( vec3( color ), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ls3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 92], [94, 94, 116, 116, 257], [259, 259, 286, 286, 347], [349, 349, 406, 406, 815]], "test": "ok"}
{"id": "3ls3RB", "name": "Magenta/Cyan Plasma", "author": "ix", "description": "Port of a shader made for a lab lunch exercise.", "tags": ["plasma", "xor"], "likes": 4, "viewed": 299, "published": "Public API", "date": "1556750645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float px = 1.5*(fragCoord.x - 0.5 * iResolution.x) / iResolution.y;\n    float py = 1.5*(fragCoord.y - 0.5 * iResolution.y) / iResolution.y;\n    float r,g,b;\n    \n    px -= 0.75;\n\tpy += 0.33;\n\n\tfloat px2 = px + sin(py * 4.6 + 0.5 * iTime) * 0.2;\n\tfloat py2 = py + sin(px * 2.6) * 0.7;\n\n\tpx2 += sin(py2*px2 * 9.6) * 0.1;\n\tpy2 += sin(px2*px2 * 7.6 + iTime) * 0.2;\n\n\tfloat fx = px2;\n\tfloat fy = py2;\n\n\tr = sin(10.0f * ((fx*fx)+(fy*fy))) * 0.5 + 0.5;\n\tg = sin(10.0f * sqrt((fx*fx)+(fy*fy))) * 0.5 + 0.5;\n\tb = sin(10.0f * pow((fx*fx)+(fy*fy), 1.5)) * 0.5 + 0.5;\n\n\tr = (r + b + g) / 3.0 + 0.2f;\n\tr *= r;\n\tr *= r;\n\tg = (b + g) / 2.0;\n\tb = g;\n\tg *= 0.9;\n\n\tr *= float((int(fragCoord.x) ^ int(fragCoord.y)) & 0xff) / 255.0;\n\tg += 0.2 * r;\n\tb += 0.2 * r;\n\n    if ((px2 * 2.0f) - floor(px2 * 2.0f) < 0.5) {\n        float t = r;\n        r = g;\n        g = t;\n    }\n\n    // Output to screen\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ls3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "3ls3RX", "name": "3D Worley Noise Slices", "author": "tpfto", "description": "Demonstration of an experimental 3D Worley noise implementation, by displaying slices of various combinations.", "tags": ["procedural", "voronoi", "noise", "worley", "cellular"], "likes": 13, "viewed": 1186, "published": "Public API", "date": "1557125677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Demonstrating an experimental 3D Worley noise implementation.\n// A little bit of something old, something new, and something borrowed.\n\n// XY range of the display.\n\n#define DISP_SCALE 6.0 \n\n// rescaling functions\n\nfloat rescale(float x, vec2 range)\n{\n\t  float a = range.x, b = range.y;\n      return (x - a)/(b - a);\n}\n\nfloat rescale(float x, vec2 r1, vec2 r2)\n{\n\t  float a = r1.x, b = r1.y;\n      float c = r2.x, d = r2.y;\n      return c + (d - c) * ((x - a)/(b - a));\n}\n\n// custom colormap\n\nvec3 lake( float t )\n{\n\t return vec3((2.0 * t + 1.0)/3.0, min(4.0 * t, 2.0 * t + 1.0)/3.0, min(0.8 * t + 0.5, 1.0 - 0.1 * t));\n}\n\n// simple LCG\n\n#define LCG(k) k = (65 * k) % 1021\n#define lr(k) float(k)/1021.\n\n// permutation polynomial\n\nint permp (int i1, int i2)\n{\n      int t = (i1 + i2) & 255;\n        \n      return ((112 * t + 153) * t + 151) & 255;\n}\n\n// return the two closest distances for 3D Worley noise\n// type controls the type of metric used\n\nvec2 worley(int type, vec3 p)\n{\n    vec2 dl = vec2(20.0);\n    ivec3 iv = ivec3(floor(p));\n    vec3 fv = fract(p);\n    \n    int j = 0; // initialization for Knuth's \"algorithm L\"\n    ivec3 di = ivec3(1), ki = -di;\n    ivec4 fi = ivec4(0, 1, 2, 3);\n    \n    // instead of writing a triply nested loop (!!)\n    // generate the indices for the neighbors in Gray order (Knuth's \"algorithm L\")\n    // see section 7.2.1.1 of TAOCP, Volume 4A or https://doi.org/10.1145/360336.360343\n    \n\tfor (int k = 0; k < 27; k++) // loop through all neighbors\n    { \n\t\t // seeding\n        int s = permp(permp(permp(0, iv.z + ki.z), iv.y + ki.y), iv.x + ki.x); LCG(s);\n            \n\t\t for (int m = 0; m < 2; m++) // two points per cell\n             {\n                // generate feature points within the cell\n                LCG(s); float sz = lr(s);\n                LCG(s); float sy = lr(s);\n                LCG(s); float sx = lr(s);\n                \n                vec3 tp = vec3(ki) + vec3(sx, sy, sz) - fv;\n                float c = 0.0;\n                if (type == 1) c = dot(tp, tp); // Euclidean metric\n                if (type == 2) c = abs(tp.x) + abs(tp.y) + abs(tp.z); // Manhattan metric\n                if (type == 3) c = max(abs(tp.x), max(abs(tp.y), abs(tp.z))); // Chebyshev metric\n                \n                float m1 = min(c, dl.x); // ranked distances\n                dl = vec2(min(m1, dl.y), max(m1, min(max(c, dl.x), dl.y)));\n             }\n        \n        // updating steps for Knuth's \"algorithm L\"\n        j = fi[0]; fi[0] = 0; ki[2 - j] += di[j];\n        if ((ki[2 - j] & 1) == 1) {\n            di[j] = -di[j];\n            fi[j] = fi[j + 1]; fi[j + 1] = j + 1;\n        }\n\t}\n    \n    if (type == 1) dl = sqrt(dl); // don't forget to root at the end for Euclidean distance\n        \n    return dl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= DISP_SCALE;\n        uv += iTime;\n    \n        vec2 w = worley(int(0.05 * iTime) % 3 + 1, vec3(uv, -0.2 * iTime));\n\n        // split image adapted from Inigo Quilez; https://www.shadertoy.com/view/ll2GD3\n        float ry = fragCoord.y / iResolution.y;\n        vec3                  col = lake(rescale(w.x, vec2(0.0, 1.0)));\n        if ( ry > (1.0/3.0) ) col = lake(rescale(length(w.xy)/(w.y + w.x) - w.x, vec2(0.0, 1.4)));\n        if ( ry > (2.0/3.0) ) col = lake(rescale((2.0 * w.y * w.x)/(w.y + w.x) - w.x, vec2(0.0, 0.3)));\n\n        // borders\n        col *= smoothstep( 0.5, 0.48, abs(fract(3.0 * ry) - 0.5) );\n\n        fragColor = vec4( vec3(col), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ls3RX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1288, 1288, 1324, 1324, 1391], [1393, 1393, 1435, 1435, 1544], [1566, 1566, 1588, 1588, 1694], [1803, 1803, 1831, 1831, 1921], [2021, 2021, 2052, 2052, 3830], [3832, 3832, 3889, 3889, 4685]], "test": "ok"}
{"id": "3ls3z2", "name": "stillness illusion 2", "author": "FabriceNeyret2", "description": "Moves while seeming motionless.  click to see references.\nInspired from [url]https://www.shadertoy.com/view/3ll3z2[/url] + paper [url]http://www.cse.yorku.ca/~kosta/Motion_Without_Movement/Motion_Without_Movement.html[/url]", "tags": ["illusion", "perception", "motionwithoutmovement"], "likes": 3, "viewed": 286, "published": "Public API", "date": "1556961183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3ts3z2\n// variant from https://shadertoy.com/view/3ll3z2\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 2.* u / R.y,\n         D = cos(.3*0.-vec2(0,1.57));              // custom dir\n\n    int i =int(U.y/.66);                           // pannel id\n    U.y = mod(U.y,.66)-.33;                        // pannel coords\n    \n    float t = 10.*iTime,\n          kl = 100., kr=.05;                       // wavelenght\n    U.x -= t/kl +.5*float(i);\n    i = (  int(U.x)+ 2*i ) % 4;\n    U.x = fract( U.x ) -.5;\n    t = float(i-2)*t;\n    float l = length(U), r = .2,\n          m = smoothstep(-kr,kr,r-l),              // disk mask\n          b = .5-.5*cos(6.28*m),                   // border zone (where effect occurs)\n          x = dot(U,D),                            // pos along D\n          d = x*x+r*r-l*l, s = -x+sign(x)*sqrt(d), // distance to disk in dir D\n        phi =   i>0 ? d > 0. ? kl*s : t            // axial from disk\n              : t;\n    \n    O = vec4( m + .25*b*sin(phi-t) );              // magic draw\n  //O.r += .2+.2*sin(kl*U.x+t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ls3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "3lSGD1", "name": "Quadrupole", "author": "hirak99", "description": "Electric potential of four charges facing off each other.\n\nAlso gave me the excuse to demonstrate a pseudo-random function that is continuous over time - tricky without persistent variables.", "tags": ["field", "charge"], "likes": 1, "viewed": 77, "published": "Public", "date": "1559280040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float seed, float t) {\n    vec2 p = vec2(seed, t);\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat smooth_random(in float seed, in float t) {\n    float s1 = floor(t);\n    float s2 = s1 + 1.;\n    return hash(seed, s1) * (1. - fract(t)) + hash(seed, s2) * fract(t) - 0.5;\n}\n\nfloat rvec2_seed = 1.;\nvec2 rvec2(in float x, in float y) {\n    rvec2_seed += 0.1;\n    return vec2(x + smooth_random(rvec2_seed + 0., iTime * 10.) / 20.,\n                y + smooth_random(rvec2_seed + 0.05, iTime * 10.) / 20.);\n}\n\n\nfloat potential_at(in vec2 coord) {\n    coord /= 100.;\n    return 1. / length(coord - rvec2(1., -1.)) - 1./length(coord - rvec2(1., 1.)) +\n        1. / length(coord - rvec2(-1., 1.)) - 1./length(coord - rvec2(-1., -1.));\n    // return 1. / length(coord) + coord.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    float p = potential_at(uv) * 2.;\n\n    //int c = mod(p, 1.) < 0.02 ? 0 : 1;\n    float c = sin(3.1415926535 * mod(p, 1.));\n\n    vec3 col;\n    if (p < 0.) {\n    \tcol = vec3(1, 0, 0) * c;\n    } else {\n    \tcol = vec3(0, .5, 1) * c;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 141], [143, 143, 191, 191, 321], [346, 346, 382, 382, 552], [555, 555, 590, 590, 821], [823, 823, 878, 878, 1221]], "test": "ok"}
{"id": "3lsGRl", "name": "[00003] sphere + variable fog", "author": "samel", "description": "[00003] sphere + variable fog", "tags": ["raymarching", "basic", "shadow", "fog", "diffuse", "variable"], "likes": 2, "viewed": 97, "published": "Public", "date": "1557307972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat plane(vec3 p, float y)\n{\n return p.y-y;\n}\n\nfloat sphere(vec3 p,vec3 pos,float r)\n{\n return length(pos-p)-r;\n}\n\nfloat scene(vec3 p)\n{\n float sphere1=sphere(p,vec3(1.0,1,6),1.0);\n float sphere2=sphere(p,vec3(0.0,1.0,10),1.0);\n float sphere3=sphere(p,vec3(-4.0,1.0,20),1.0);\n float plane=plane(p,0.0);\n return min(sphere3,min(sphere1,min(sphere2,plane)));\n}\n\nfloat raymarch(vec3 origin,vec3 direction)\n{\n float traveled=0.0;\n float distance=0.0;\n for(int i=0;i<100;i++)\n {\n  vec3 p=origin+traveled*direction;\n  distance=scene(p);\n  if(distance<=0.01 || traveled>100.0)\n  {\n   break;\n  }\n  traveled+=distance;\n }\n return traveled;\n}\n\nvec3 normalAt(vec3 p)\n{\n vec2 epsilon=vec2(0.01,0);\n float distanceAtP=scene(p);\n return normalize(vec3(distanceAtP-scene(p-epsilon.xyy),\n                       distanceAtP-scene(p-epsilon.yxy),\n                       distanceAtP-scene(p-epsilon.yyx)));\n}\n\nfloat diffuse(vec3 p)\n{\n vec3 sunPos=vec3(sin(iTime),5,cos(iTime)+6.0);\n vec3 normal=normalAt(p);\n vec3 lightDir=normalize(sunPos-p);\n if(raymarch(p+lightDir*0.1,lightDir)<length(sunPos-p))\n {\n  return 0.0;\n }\n return clamp(dot(lightDir,normal),0.0,1.0);\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in vec3 p ) // camera to point distance\n{\n    float distance=length(p);\n    //float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float fogAmount = (1.0 - exp( p.y-1.5 ))*(p.y<1.5?1.0:0.0)*(noise(p.xz*0.2+(vec2(iTime*0.7))));\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 applyFog2( in vec3  rgb,      // original color of the pixel\n               in vec3 p, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float distance=length(p);\n    float fogAmount = 1.0 - exp( -distance*(pow(1.0/p.y,2.0)) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x-0.5;\n    \n    vec3 color=vec3(0,0,0);\n    vec3 origin=vec3(0.0,3.0,-2);\n    vec3 direction=normalize(vec3(uv,1));\n    float traveled=raymarch(origin,direction);\n    color=vec3(diffuse(origin+direction*traveled));\n    vec3 sunPos=vec3(sin(iTime),25,cos(iTime)+6.0);\n    vec3 lightDir=normalize(sunPos-origin+traveled*direction);\n    color=applyFog(color,origin+traveled*direction);\n    /*color=applyFog2(color,\n                    origin+traveled*direction,\n                   direction,\n                    lightDir\n                   );*/\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 159, 159, 676], [678, 678, 708, 708, 725], [727, 727, 766, 766, 793], [795, 795, 816, 816, 1038], [1040, 1040, 1084, 1084, 1312], [1314, 1314, 1337, 1337, 1569], [1571, 1571, 1594, 1594, 1827], [1829, 1829, 1951, 1951, 2235], [2237, 2237, 2475, 2475, 2837], [2839, 2839, 2896, 2896, 3510]], "test": "ok"}
{"id": "3lsGRX", "name": "Exploding Colour", "author": "mosaic", "description": "The default \"new\" shadertoy, combined with a distance field", "tags": ["distancefield"], "likes": 3, "viewed": 132, "published": "Public", "date": "1557120765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st  = fragCoord/iResolution.y;\n    vec2 uv  = fragCoord/iResolution.y;\n float pct = 0.0;\n    pct =distance(st,vec2(0.9,0.5))*5.;\n    vec3 col = 0.5 + 0.5*cos(iTime*3.+uv.xyx+vec3(0,2,6));\n    col=col/pct;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 334]], "test": "ok"}
{"id": "3lsGW2", "name": "Constellation", "author": "zhangvisual", "description": "Followed a tutorial on Youtube. https://www.youtube.com/watch?v=3CycKKJiwis&t=158s", "tags": ["universe", "constellation"], "likes": 9, "viewed": 286, "published": "Public", "date": "1557716316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distLine( vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat noiseFloat(vec2 p){\n    p = fract(p * vec2(213.53, 970.19));\n    p = p + dot(p, p+548.23);\n    return fract(p.x * p.y);\n}\n\nvec2 noiseVector(vec2 p){\n\tfloat n = noiseFloat(p);\n    return vec2(n, noiseFloat(p+n));\n}\n\n\nvec2 GetPos(vec2 id, vec2 offsets){\n\tvec2 n = noiseVector(id + offsets) * iTime;\n    return sin(n) * 0.4 + offsets;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p, a, b);\n    float m = smoothstep(0.03, 0.002, d);\n    m = m * smoothstep(1.5, 0.1, length(a-b));\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -1.0*iResolution.xy)/iResolution.y;\n\t\n    float m = 0.0;\n    uv = uv * 10.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for(float y = -1.0; y<=1.0; y++){\n    \tfor(float x = -1.0; x<=1.0; x++){\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    for(int i=0; i<9; i++){\n    \tm = m + Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 28.0;\n        float sparkle = 1.0/dot(j, j);\n      \n        m = m + sparkle * (sin((iTime+p[i].x)*3.0)*0.5 + 0.5);\n    }\n    \n    m = m + Line(gv, p[1], p[3]);\n    m = m + Line(gv, p[1], p[5]);\n    m = m + Line(gv, p[7], p[3]);\n    m = m + Line(gv, p[7], p[5]);\n    \n    vec3 col = vec3(0.0, m, 0.0);    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 167], [169, 169, 194, 194, 296], [298, 298, 323, 323, 388], [391, 391, 426, 426, 508], [510, 510, 545, 545, 680], [683, 683, 740, 790, 1601]], "test": "ok"}
{"id": "3lsGWj", "name": "Soft shadow example", "author": "_A_", "description": "Shadow ray marching algorithm additionally searches for \\/ and \\__ patterns and calculates minimal distance at this points.\nMay be used for shadow anti-aliasing and fake soft shadows.", "tags": ["example", "simple", "basic", "raymarch"], "likes": 4, "viewed": 461, "published": "Public API", "date": "1557695586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// forked from https://www.shadertoy.com/view/Wtf3Wj\n\n#define MAX_STEPS 200\n#define MAX_DIST 250.\n#define SURF_DIST .01\n\n\nfloat sphereDist(vec3 p) {\n    float sphere = length(p) - 1.;\n\treturn sphere;\n}\n\n\n//get the distance to the closest\n//point on the closest object\nfloat sceneDist(vec3 p) {\n\tfloat planeDist = p.y;\n    vec3 spherePos = vec3(0,1,8);\n    float sphereRadius = 1.;\n    \n    float objDist = sphereDist(p-spherePos);\n    \n    float dist = min(planeDist, objDist);\n    \n    return dist;\n}\n\n\nfloat rayMarch(vec3 rayOrig, vec3 rayDir) {\n\tfloat dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = rayOrig + dist * rayDir;\n\t\tfloat sceneDist = sceneDist(p);\n        \n        dist += sceneDist;\n       \n        if (dist > MAX_DIST || sceneDist < SURF_DIST) {\n        \tbreak;\n        }\n\t}\n    \n    return dist;\n}\n\n\n//get the normal of a point in 3d space,\n//only valid if the point is on the surface\n//of an object\nvec3 getNormal(vec3 p) {\n\tfloat d = sceneDist(p);\n    \n    //just a helper variable\n    vec2 e = vec2(.01, 0);\n    \n    //shift the point by a small\n    //amount along each axis\n    vec3 n = d - vec3(\n        sceneDist(p - e.xyy),\n        sceneDist(p - e.yxy),\n        sceneDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\n\n//get the strength of the light\n//at a 3d point\nfloat getLight(vec3 p) {\n\tvec3 lightPos = vec3(-2, 5, 8);\n    \n    //move the light in a circle\n    lightPos.xz += vec2(cos(iTime), sin(iTime)) * 10.;\n    \n \tvec3 normal = getNormal(p);\n    vec3 toLight = normalize(lightPos - p);\n    \n    float angle = dot(normal, toLight);\n    angle = clamp(angle, 0., 1.);\n    \n    vec3 rayOrig = p+normal*.02;\n    vec3 rayDir = toLight;\n    float dist = 0.;\n    float maxDist = length(p-lightPos)+0.1;\n    \n    // contains last 3 distances\n\tvec3 history = vec3(0.);\n    \n    const float maxDistToObject = 0.3;\n    \n    // minimal distance to object for penumbra calculation\n\tfloat md = 1.0e+10;\n    \n    //add shadows\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = rayOrig + dist * rayDir;\n        \n        history.yz = history.xy;\n\t\thistory.x = sceneDist(p);\n        dist += history.x;\n     \n        // detect V pattern\n        if (history.y < maxDistToObject && history.x >= history.y && history.z > history.y)\n            md = min(md, history.y);\n        \n        if (dist < 0.0 || dist > maxDist) {\n        \tbreak;\n        }\n        \n        if (history.x < SURF_DIST) {\n            md = 0.0;\n            break;\n        }\n\t}\n    \n    angle = angle * smoothstep(0.0, maxDistToObject, md);\n    return angle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //ray origin is the camera position\n    vec3 rayOrig = vec3(0, 5, -12);\n    vec3 rayDir = vec3(uv.x, uv.y, 1.0);\n    \n    float dist = rayMarch(rayOrig, rayDir);\n    \n    //get the point that the ray hit\n    //to use for lighting\n    vec3 rayHitPos = rayOrig + rayDir * dist;\n    float diff = getLight(rayHitPos);\n    \n    //grayscale colour based on lighting value\n    vec3 col = vec3(diff);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 148, 148, 201], [204, 268, 293, 293, 501], [504, 504, 547, 547, 835], [838, 938, 962, 962, 1266], [1269, 1317, 1341, 1341, 2571], [2574, 2574, 2631, 2631, 3129]], "test": "ok"}
{"id": "3lSGWz", "name": "PBR RenderMode", "author": "littlebird", "description": "pbr brdf ", "tags": ["pbrbrdf"], "likes": 2, "viewed": 358, "published": "Public API", "date": "1559038322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define GAMMA 2.2\n#ifdef LOC_SHADER\nuniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D tex_ao;\nuniform sampler2D tex_basecolor;\nuniform sampler2D tex_metallic;\nuniform sampler2D tex_normal;\nuniform sampler2D tex_roughness;\nuniform sampler2D tex_specular;\nuniform sampler2D tex_height;\n\nuniform samplerCube skybox;\nuniform vec3 iCameraPos;\nuniform vec3 iCameraDir;\nuniform vec3 iCameraUp;\nout vec4 FragColor;\n#else \n#define skybox iChannel0\n#define tex_basecolor iChannel1\n#endif\n\n#define PI 3.1415926\n#define float3 vec3\n\nfloat rand(float p){return fract(sin(p) * 43758.5453123);}\nfloat rand (in vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123); }\nfloat rcp(float a){\n    return 1.0/a;\n}\n\n//随机数生成\n//返回 [0.0f, 1.0f) 的随机数\nfloat rand(float x, float y){\n    return fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453);\n}\n\nfloat rndSeed = 1.;//iRandSeed;\nfloat rand(){\n    return rand(rand(gl_FragCoord.x, gl_FragCoord.y), rndSeed++);\n}\n\nvec3 rand(vec3 p){\n \tconst vec3 k = vec3( 3.1415926, 2.71828,6.62607015);\n \tp = p*k + p.yzx;\n \treturn -1.0 + 2.0*fract( 2.0 * k * fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    //随机梯度\n    vec3 g1 = rand(i+vec3(0.0,0.0,0.0));\n    vec3 g2 = rand(i+vec3(1.0,0.0,0.0));\n    vec3 g3 = rand(i+vec3(0.0,1.0,0.0));\n    vec3 g4 = rand(i+vec3(1.0,1.0,0.0));\n    vec3 g5 = rand(i+vec3(0.0,0.0,1.0));\n    vec3 g6 = rand(i+vec3(1.0,0.0,1.0));\n    vec3 g7 = rand(i+vec3(0.0,1.0,1.0));\n    vec3 g8 = rand(i+vec3(1.0,1.0,1.0));\n    \n    //方向向量\n    vec3 d1 = f - vec3(0.0,0.0,0.0);\n    vec3 d2 = f - vec3(1.0,0.0,0.0);\n    vec3 d3 = f - vec3(0.0,1.0,0.0);\n    vec3 d4 = f - vec3(1.0,1.0,0.0);\n    vec3 d5 = f - vec3(0.0,0.0,1.0);\n    vec3 d6 = f - vec3(1.0,0.0,1.0);\n    vec3 d7 = f - vec3(0.0,1.0,1.0);\n    vec3 d8 = f - vec3(1.0,1.0,1.0);\n    \n    //点积求权重\n    float n1 = dot(g1, d1);\n    float n2 = dot(g2, d2);\n    float n3 = dot(g3, d3);\n    float n4 = dot(g4, d4);\n    float n5 = dot(g5, d5);\n    float n6 = dot(g6, d6);\n    float n7 = dot(g7, d7);\n    float n8 = dot(g8, d8);\n    \n    //加权求和\n    float a = mix(n1,n2,u.x);\n    float b = mix(n3,n4,u.x);\n    float c1 = mix(a,b,u.y);\n    a = mix(n5,n6,u.x);\n    b = mix(n7,n8,u.x);\n    float c2 = mix(a,b,u.y);\n    float c = mix(c1,c2,u.z);\n    \n    \n    return c;\n}\n\nfloat fbm(vec3 p){\n p *= 2.0; //这里调整频率\n float f = 0.;\n f += 1.0 * abs(noise(p)); p=2.*p;\n f += 0.5 * abs(noise(p)); p=2.*p;\n f += 0.25 * abs(noise(p)); p=2.*p;\n f += 0.125 * abs(noise(p)); p=2.*p;\n f += 0.0625 * noise(p); p=2.*p;\n return f;\n}\n\n\n#define MAT_TYPE_SOLID 1\n#define MAT_TYPE_PBR   2\n#define MAT_TYPE_TEX   3\nstruct Mat{int type; vec3 col; float roughness; float metalness; float ao; vec3 F0;};\nstruct Hit{ float t; vec3 p; vec3 n; Mat mat; vec2 uv; };\nstruct Light{vec3 o; vec3 col;};\nstruct Sphere{ vec3 o; float r; Mat mat; };\nstruct Ray { vec3 o, d; }; \nstruct Camera{\n    vec3 pos, dir, up, right;\n    vec3 ll_corner, horizontal, vertical;};\n\nSphere sphere;\nCamera camera;\nLight lights[4];\n\n\nvoid BuildCamera(vec3 pos, vec3 dir, vec3 up, float hfov, float aspect){\n    camera.pos = pos;\n    camera.dir = normalize(dir);\n    camera.up = normalize(up);\n    camera.right = cross(camera.dir, camera.up);\n    camera.up = cross(camera.right, camera.dir);\n    \n    vec3 center = camera.pos + camera.dir;\n    float h = tan(hfov/180.0*PI) * 2.0;\n    float w = h * aspect;\n    \n    camera.horizontal = w * camera.right;\n    camera.vertical = h * camera.up;\n    camera.ll_corner = center - 0.5 * camera.horizontal - 0.5 * camera.vertical;\n}\n\nRay BuildRay(vec2 fragCoord){\n    vec2 uv = fragCoord / vec2(iResolution.x, iResolution.y);\n    vec3 position = camera.pos;\n    return Ray(position, camera.ll_corner + uv.x*camera.horizontal + uv.y*camera.vertical - position);\n}\n\nvec2 GetShpereUV(vec3 p, vec3 n){\n    float u = atan(n.x, n.z) / (2.*PI) + 0.5;\n    float v = n.y * 0.5 + 0.5;\n    return vec2(u,v);\n\n/*  float phi = atan(p.z, p.x);\n    float theta = asin(p.y);\n    vec2 uv;\n    uv.x = (phi + PI)/(2.*PI);\n    uv.y = (theta + PI/2.) / PI;\n    return uv;*/\n}\n\nbool Intersect(Sphere s, Ray r, inout Hit ht){\n    vec3 so = s.o;\n    vec3 oc = r.o - so;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, oc);\n    float c = dot(oc, oc) - s.r * s.r;\n    float delt = b * b - 4.0 * a * c;\n    float t = ht.t;\n    if(delt > 0.0) {\n        float t = 0.;\n        t = (-b - sqrt(delt)) / (2.0 * a);\n        if(t < 0.001){\n            t = (-b + sqrt(delt)) / (2.0 * a);\n        }\n        if(t > 0.001 && t < ht.t){\n            ht.t = t;\n            ht.p = r.o + ht.t * r.d;\n            ht.mat = s.mat;\n            ht.n = normalize(ht.p - so);\n            ht.uv = GetShpereUV(ht.p, ht.n);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n//漫反射模型\nfloat3 Diffuse_Lambert( float3 DiffuseColor )\n{\n\treturn DiffuseColor * (1. / PI);\n}\n\n//高光\nfloat NDF_DistributionGGX(float noh, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float noh2 = noh*noh;\n\n    float nom   = a2;\n    float denom = (noh2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\nfloat G_SchlickGGX(float nov, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float nom   = nov;\n    float denom = nov * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat G_Smith(float nov, float nol, float roughness)\n{\n    return G_SchlickGGX(nov, roughness) * G_SchlickGGX(nol, roughness);\n}\n\nfloat saturate(float x){\n    if(x < 0.) return 0.;\n    if(x > 1.) return 1.;\n}\n\nvec3 F_Schlick(float hov, vec3 F0)\n{\n    //float Fc = pow( 1. - hov , 5.0);// 1 sub, 3 mul\n\t//return clamp(50.0 * F0.g, 0., 1.) * Fc + (1 - Fc) * F0;\n    return F0 + (1.0 - F0) * pow(1.0 - hov, 5.0);\n}\n/////////////\nvec3 CalcLight(Ray r, Hit ht, Light lt){\n    vec3 col = vec3(0);\n    vec3 n = normalize(ht.n);          //法线\n    vec3 v = normalize(r.o - ht.p);    //观察方向\n    vec3 l = normalize(lt.o - ht.p);   //光线方向\n    vec3 h = normalize(v+l);           //中间向量\n\tfloat nov = max(dot(n,v), 0.);\n    float nol = max(dot(n,l),0.);\n    float noh = max(dot(n,h), 0.);\n    float hov = max(dot(h,v), 0.);\n\n    vec3 F0 = ht.mat.F0;\n\tF0 = mix(F0, ht.mat.col, ht.mat.metalness);\n    \n    //辐射强度,按照距离衰减\n    float dis = length(lt.o - ht.p);\n    float attenuation = 1.0 / (dis * dis);\n    vec3 radiance = lt.col * attenuation * nol;\n    \n    //漫反射\n    vec3 diff = Diffuse_Lambert(ht.mat.col);\n\n    //高光\n\tfloat D = NDF_DistributionGGX(noh, ht.mat.roughness);\n    float G = G_Smith(nov,nol,ht.mat.roughness);\n\tvec3 F  = F_Schlick(hov, F0);\n    vec3 specular = (D*G*F) / (4.0*nov*nol+0.001);\n    \n    //brdf\n    vec3 Ks = F;\n    vec3 Kd = vec3(1.) - Ks;\n    Kd *= 1.0 - ht.mat.metalness;\n    vec3 brdf = Kd * diff + specular;\n\n    return brdf * radiance;\n}\n\n//copy from https://www.shadertoy.com/view/XtyyDh\nvec4 quat(vec3 axis, float angle) { return vec4(axis*sin(angle*0.5), cos(angle*0.5)); }\nvec4 quat_i() { return vec4(0,0,0,1); }\nvec4 quat_conj(vec4 q) { return vec4(-q.xyz,q.w); }\nvec4 quat_mul(vec4 a, vec4 b) { return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz)); }\nvec3 quat_mul(vec4 q, vec3 v) { return v-2.0*cross(cross(q.xyz,v)-q.w*v,q.xyz); }\n\n\n//http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\nfloat3 ReinhardToneMapping(float3 color, float adapted_lum) \n{\n    const float MIDDLE_GREY = 1.;\n    color *= MIDDLE_GREY / adapted_lum;\n    return color / (1.0f + color);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nfloat3 ACESToneMapping(float3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n\n\tcolor *= adapted_lum;\n\treturn clamp((color * (A * color + B)) / (color * (C * color + D) + E), vec3(0.), vec3(1.));\n}\n\nvec3 CalcLights(Ray r, Hit ht){\n    vec3 col = vec3(0);\n\n    //计算所有光源\n    Light lt = Light(vec3(3,3,3), vec3(100,100,100));\n    lt.o = quat_mul(quat(normalize(vec3(0,1,0)),iTime), lt.o);\n\n    \n    col += CalcLight(r, ht, lights[0]);\n    //col += CalcLight(r, ht, Light(vec3(-5,1,5), vec3(100,0,0)));\n    //col += CalcLight(r, ht, Light(vec3(-5,-3,1), vec3(0,100,100)));\n    //col += CalcLight(r, ht, Light(vec3(-3,-1,-5), vec3(0,100,0)));\n    //col += CalcLight(r, ht, Light(vec3(-1,3,-3), vec3(40,100,100)));\n\n    //叠加环境光，后续用IBL\n    vec3 ambient = vec3(0.01) * ht.mat.col * ht.mat.ao;\n    col = ambient+ col;\n    \n    //hdr tonemapping\n    col = ACESToneMapping(col, 1.0);\n\n    //gamma correct\n    col = pow(col, vec3(1.0/GAMMA)); \n    return col;\n}\n\nvec3 GetNormalFromMap(sampler2D normalMap, vec3 Normal, vec3 WorldPos, vec2 TexCoords)\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(Normal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Set Camera\n    #ifdef LOC_SHADER\n \tBuildCamera(iCameraPos, iCameraDir, iCameraUp, 45.0, iResolution.x/iResolution.y);\n    #else\n    vec3 pos = vec3(0,3,4);//quat_mul(quat(normalize(vec3(0,1,0)),iTime), vec3(0,0,5));\n    BuildCamera(pos, vec3(0,0,-1) - pos, vec3(0,1,0), 45.0, iResolution.x/iResolution.y);\n    #endif\n    \n    //Set Main Light\n    lights[0].o = vec3(4,4,4);\n    lights[0].col = vec3(100,100,100);\n    lights[0].o = quat_mul(quat(normalize(vec3(0,1,0)),iTime), lights[0].o);\n    \n    Sphere spheres[3];\n    //球1，从外部材质获得属性\n    spheres[0].o = vec3(-2,0,-2);\n    spheres[0].r = 1.0;\n    spheres[0].mat.type = MAT_TYPE_TEX;\n    spheres[0].mat.col = vec3(1);\n    spheres[0].mat.F0 = vec3(0.04);\n    \n    //球2，使用设置的pbr属性\n    spheres[1].o = vec3(2,0,-2);\n    spheres[1].r = 1.0;\n    spheres[1].mat.type = MAT_TYPE_PBR;\n    spheres[1].mat.col = vec3(1,1,0);\n    spheres[1].mat.metalness = 0.2;\n    spheres[1].mat.roughness = 0.8;\n    spheres[1].mat.F0 = vec3(0.04);\n\n    //球3，显示光源\n    spheres[2].o = lights[0].o;\n    spheres[2].r = 0.5;\n    spheres[2].mat.type = MAT_TYPE_SOLID;\n    spheres[2].mat.col = lights[0].col;\n    spheres[2].mat.F0 = vec3(0.04);\n    spheres[2].mat.ao = 0.;\n\n    vec3 col = vec3(0);\n    \n    Hit ht;\n    const float MAX_DIS = 99999999.;\n    ht.t = MAX_DIS;\n    const int samplerCount = 1;\n    for(int i = 0; i < samplerCount; i++){\n        Ray ray = BuildRay(fragCoord + vec2(rand(), rand()));\n        Intersect(spheres[0], ray, ht);\n        Intersect(spheres[1], ray, ht);\n        Intersect(spheres[2], ray, ht);\n        if(ht.t == MAX_DIS){\n            col += vec3(0);//texture(skybox, ray.d).xyz;\n        }\n        else {\n            if(ht.mat.type == MAT_TYPE_TEX){\n                #ifdef LOC_SHADER\n                ht.mat.roughness = texture(tex_roughness, ht.uv).r;\n                ht.mat.metalness = texture(tex_metallic, ht.uv).r;\n                //ht.mat.F0 = texture(tex_specular, ht.uv).xyz;\n                ht.mat.col = pow(texture(tex_basecolor, ht.uv).xyz, vec3(GAMMA));\n                ht.mat.ao = texture(tex_ao, ht.uv).r;\n                ht.n = GetNormalFromMap(tex_normal, ht.n, ht.p, ht.uv);\n                #else\n                ht.mat.col = texture(tex_basecolor, ht.uv).xyz * 1.;\n                ht.mat.roughness = fbm(ht.p);\n                ht.mat.metalness = 1. - fbm(ht.p);\n                ht.mat.ao = 0.0;\n                #endif\n\n                col += CalcLights(ray, ht);\n            }\n            else if(ht.mat.type == MAT_TYPE_PBR){\n                ht.mat.roughness = fbm(ht.p);\n                ht.mat.metalness = 1. - fbm(ht.p);\n                col += CalcLights(ray, ht);\n            }\n            else if(ht.mat.type == MAT_TYPE_SOLID){\n                col += ht.mat.col;\n            }\n        }\n    }\n\n    col /= float(samplerCount);\n    fragColor = vec4(col,1.0);\n}\n\n#ifdef LOC_SHADER\nvoid main(){\n    mainImage(FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n//https://freepbr.com/materials/rock-infused-with-copper-pbr-material/\n//http://artisaverb.info/PBT.html\n//https://www.cnblogs.com/timlly/p/10631718.html#lambert1760%E5%B9%B4\n//https://zhuanlan.zhihu.com/p/34473064\n//https://zhuanlan.zhihu.com/p/33464301\n//https://zhuanlan.zhihu.com/p/21983679\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 558, 558, 596], [597, 597, 621, 621, 691], [692, 692, 711, 711, 731], [733, 786, 815, 815, 883], [904, 917, 930, 930, 998], [1000, 1000, 1018, 1018, 1160], [1162, 1162, 1182, 1182, 2439], [2441, 2441, 2459, 2459, 2695], [3161, 3161, 3233, 3233, 3698], [3700, 3700, 3729, 3729, 3928], [3930, 3930, 3963, 3963, 4220], [4222, 4222, 4268, 4268, 4911], [4913, 4931, 4978, 4978, 5014], [5016, 5025, 5080, 5080, 5358], [5360, 5360, 5408, 5408, 5556], [5558, 5558, 5612, 5612, 5686], [5688, 5688, 5712, 5712, 5766], [5768, 5768, 5804, 5917, 5969], [5970, 5984, 6024, 6024, 7067], [7069, 7119, 7154, 7154, 7206], [7207, 7207, 7222, 7222, 7246], [7247, 7247, 7271, 7271, 7298], [7299, 7299, 7330, 7330, 7417], [7418, 7418, 7449, 7449, 7499], [7502, 7583, 7645, 7645, 7756], [7758, 7836, 7893, 7893, 8133], [8135, 8135, 8166, 8166, 8915], [8917, 8917, 9005, 9005, 9400], [9402, 9402, 9459, 9476, 12351]], "test": "error"}
{"id": "3lsGzX", "name": "Cylinder pipe", "author": "edo_m18", "description": "Cylinder pipe.", "tags": ["cylinder", "pipe"], "likes": 2, "viewed": 126, "published": "Public", "date": "1557131532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 trans(vec3 p, float space)\n{\n    return mod(p, space) - space * 0.5;\n}\n\nfloat distSphere(vec3 p, float size)\n{\n    return length(p) - size;\n}\n\nfloat distCylinderXY(vec3 p, vec3 c)\n{\n    return length(p.xy - c.xy) - c.z;\n}\n\nfloat distCylinderXZ(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat distCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat distFunc(vec3 p)\n{\n    float s = 4.0;\n    float d1 = distCylinderXY(p, vec3(0.0, 0.0, s));\n    float d2 = distCylinderXY(p, vec3(0.0, 0.0, s - 0.2));\n    float d3 = distCappedCylinder(trans(p, 4.0), vec2(1.0, 3.5));\n\t//return d3;\n    return max(max(d1, -d2), -d3);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0.01, 0.0);\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                     \t  distFunc(p + d.yxy) - distFunc(p - d.yxy),\n \t                      distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nmat3 camera(in vec3 ro, vec3 ta, float cr)\n{\n    vec3 up = vec3(sin(cr), cos(cr), 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    float z = iTime * 10.0;\n    vec3 ro = vec3(0, 0, z);\n    vec3 ta = vec3(0, 10.0, z + 10.0);\n    \n    vec3 ray = camera(ro, ta, iTime) * normalize(vec3(uv, 1.5));\n    \n    float d = 0.0;\n    vec3 p = ro;\n    \n    for (int i = 0; i < 256; i++)\n    {\n        d = distFunc(p);\n        \n        if (d < 0.01)\n        {\n            break;\n        }\n        \n        p += ray * d;\n    }\n    \n    vec3 col = vec3(0.0);\n    vec3 light = normalize(vec3(1.0, 1.0, 0.5));\n    \n    if (d < 0.01)\n    {\n    \tvec3 nor = getNormal(p);\n        float d = dot(nor, light);\n        d = clamp(d, 0.05, 1.0);\n        col = vec3(d) * nor;\n        col = pow(col, vec3(0.4545));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 76], [78, 78, 116, 116, 147], [149, 149, 187, 187, 227], [229, 229, 267, 267, 307], [309, 309, 351, 351, 458], [460, 460, 484, 484, 732], [734, 734, 758, 758, 995], [997, 997, 1041, 1041, 1224], [1226, 1226, 1283, 1283, 2052]], "test": "ok"}
{"id": "3lX3Rf", "name": "Bloxel Sea", "author": "MrsBeanbag", "description": "the distance function is exact within range so you can change the curve of the \"bloxels\"\n\ninternal distance is not correct so some boolean functions on this SDF come out looking a bit wrong, union is fine but intersection reveals weirdness", "tags": ["raymarch", "voxels", "shadows"], "likes": 3, "viewed": 524, "published": "Public API", "date": "1557063202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment this line to get mouse control rofl\n//#define MOUSE_CONTROL\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.002;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\n\nconst vec3 sky_colour = vec3(0.2, 0.1, 0.4);\nconst vec3 clouds_colour = vec3(1.0);\nconst vec3 sun_colour = 32.0 * vec3(1.0, 1.0, 0.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 35.0, 25.0 ));\n\n/*vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}*/\n\n// this isn't very random but it's a good deal quicker than the above\nfloat random( vec2 p ) {\n    return fract(dot(p, vec2(98.61, 35.28)));\n}\n\nfloat cell_height(vec2 cell) {\n\treturn 0.5 + 0.5 * sin(iTime + random(cell) * 2.0 * PI);\n}\n\nconst float block_radius = 0.1;\nfloat blockie(vec3 p, vec2 cell) {\n    float height = p.y + cell_height(cell) + block_radius;\n    vec3 pr = vec3( clamp(p.xz, cell, cell+1.0)-p.xz, max(0.0, height)).xzy;\n    return dot(pr,pr);\n}\n\nfloat dist_field(vec3 p) {\n    vec2 mpos = vec2(0.0);\n    vec2 cell = floor(p.xz);\n    \n    float height = p.y + cell_height(cell) + block_radius;\n    float nearest = height * height;\n    \n    nearest = min(nearest, blockie(p, cell + vec2(-1.0, 0.0)));\n    nearest = min(nearest, blockie(p, cell + vec2( 1.0, 0.0)));\n    nearest = min(nearest, blockie(p, cell + vec2( 0.0,-1.0)));\n    nearest = min(nearest, blockie(p, cell + vec2( 0.0, 1.0)));\n\n    // corners could have a slightly optimised version\n    nearest = min(nearest, blockie(p, cell + vec2(-1.0, -1.0)));\n    nearest = min(nearest, blockie(p, cell + vec2(-1.0,  1.0)));\n    nearest = min(nearest, blockie(p, cell + vec2( 1.0, -1.0)));\n    nearest = min(nearest, blockie(p, cell + vec2( 1.0,  1.0)));\n\n    diffuse_colour = vec3(0.1, 0.7, 0.9);\n    return sqrt(nearest) - block_radius;\n}\n\nvec3 skybox(vec3 dir) {\n    float horizon = smoothstep(0.0, 0.25, dir.y);\n    float cloud = mix(0.8, 0.0, horizon);\n    return mix(sky_colour, clouds_colour, cloud);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    const vec2 kg = vec2(grad_step,-grad_step);\n    return vec3( k.xyy*dist_field( p + kg.xyy) +\n                 k.yyx*dist_field( p + kg.yyx) +\n                 k.yxy*dist_field( p + kg.yxy) +\n                 k.xxx*dist_field( p + kg.xxx) );\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\tfloat shininess = 80.0;\n\t\n\tvec3 ref = reflect( dir, n );\n\tfloat specular = max( 0.0, dot( sun_pos, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn final_diff_colour * diffuse + vec3(specular);\n}\n\n// ray marching\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n\n    // give the ray a bit of a head start by jumping\n    // straight to the upper bounding plane!\n    float t = 0.0;\n    if (dir.y < 0.0) {\n        t = -o.y/dir.y;\n    } else {\n        return skybox(dir);\n    }\n\tt = max(t, min_dist*2.0);\n\n    vec3 v;\n    for (int i = 0; i < max_iterations; i++) {\n       \tfloat d = dist_field(v = o + dir * t);\n\n        if (d <= min_dist) {\n            break;\n        }\n\t\tif ((t+=d) >= clip_far) {\n            return skybox(dir);\n\t    }\n    }\n\tfinal_diff_colour = diffuse_colour;\n    \n    vec3 n = normalize( gradient(v) );\n    colour += shading( v, n, dir, o );\n    if (dot(n, sun_pos) < 0.0) {\n        return colour;\n    }\n\n    // shadows\n    t = 0.1;\n    for (int i = 0; i < max_iterations; i++) {\n        vec3 r = v + sun_pos * t;\n\t\tif (r.y > 0.0) {\n            break;\n\t    }\n\n        float d = dist_field(r);\n        if (d <= min_dist) {\n            colour *= 0.3;\n            break;\n        }\n        t+=d;\n    }\n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nconst vec2 spin = vec2(0.005, 0.0041);\nconst float radius = 120.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n#ifdef MOUSE_CONTROL\n\tmat3 rot = rotationXY( vec2(PI, -PI) * ((iMouse.xy - iResolution.xy * 0.5)/iResolution.xy).yx );\n#else\n\tmat3 rot = rotationXY( vec2( -0.6, iTime * 0.2 ) );\n#endif\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 1.0, 0.0 );\n\teye = rot * eye;\n    \n    // move in a sinusoidal path so we don't end up in floating point hell!\n    vec2 camera = radius * cos(iTime * spin);\n    \n    eye += vec3(camera, 1.0).xzy;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n    fragColor = vec4(color, 1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lX3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 750, 774, 774, 822], [824, 824, 854, 854, 914], [948, 948, 982, 982, 1143], [1145, 1145, 1171, 1171, 1991], [1993, 1993, 2016, 2016, 2160], [2162, 2191, 2216, 2216, 2494], [2496, 2521, 2573, 2573, 2833], [2835, 2851, 2888, 2888, 3923], [3925, 3946, 3994, 3994, 4168], [4170, 4202, 4233, 4233, 4388], [4457, 4457, 4514, 4532, 5135]], "test": "error"}
{"id": "3lX3Rl", "name": "Pleinvrees festival logo", "author": "flyingrub", "description": "Pleinvrees festival logo", "tags": ["noise", "logo", "simplex", "pleinvrees"], "likes": 2, "viewed": 405, "published": "Public", "date": "1557220754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pixel_width 3./iResolution.y\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r;\n}\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t vec4 w, d;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t w = max(0.6 - w, 0.0);\n\t \n\t d.x = dot(random3(s)-.5, x);\n\t d.y = dot(random3(s + i1)-.5, x1);\n\t d.z = dot(random3(s + i2)-.5, x2);\n\t d.w = dot(random3(s + 1.0)-.5, x3);\n\t \n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t return pow(dot(d, vec4(52.0)),2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2.-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float circleSDF = length(uv);\n    float radius = .6 + simplex3d(vec3(uv,iTime*.5))*.1;\n    vec3 palette = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n    vec3 col = smoothstep(pixel_width,0.0,circleSDF-radius) * palette;\n    radius = .3 + simplex3d(vec3(uv,1000.+iTime*.3))*.05;\n    col += smoothstep(pixel_width,0.0,circleSDF-radius);\n    radius = .07 +simplex3d(vec3(uv,2000.+iTime*.2))*.05;\n    col = clamp(col,vec3(0),vec3(1));\n    col *= smoothstep(pixel_width,0.0,radius-circleSDF);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lX3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 60, 60, 229], [289, 289, 314, 314, 935], [938, 938, 995, 995, 1639]], "test": "ok"}
{"id": "3sjXWw", "name": "Beto produit vectorielle 3D", "author": "msafadi", "description": "beto", "tags": ["beto"], "likes": 3, "viewed": 138, "published": "Public", "date": "1557418220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 X = vec3(1., 0., 0.);\nconst vec3 Y = vec3(0., 1., 0.);\nconst vec3 Z = vec3(0., 0., 1.);\n\n// YOURS\n\nconst vec3 FOOT_O = vec3(0);\nconst vec3 FOOT_X = X;\nconst vec3 FOOT_Y = Y;\nconst vec3 FOOT_Z = Z;\n\nconst vec3 BODY_O = vec3(0,4,0);\nconst vec3 BODY_X = X;\nconst vec3 BODY_Y = Y;\nconst vec3 BODY_Z = Z;\n\nconst vec3 HEAD_O = vec3(0,7,0);\nconst vec3 HEAD_X = X;\nconst vec3 HEAD_Y = Y;\nconst vec3 HEAD_Z = Z;\n\nconst vec3 BUTTON_1_O = vec3(0,4.8,1.8);\nconst vec3 BUTTON_1_X = X;\nconst vec3 BUTTON_1_Y = Y;\nconst vec3 BUTTON_1_Z = Z;\n\nconst vec3 BUTTON_2_O = vec3(0,3.8,1.9);\nconst vec3 BUTTON_2_X = X;\nconst vec3 BUTTON_2_Y = Y;\nconst vec3 BUTTON_2_Z = Z;\n\nconst vec3 EYE_1_O = vec3(-0.5,7.3,1.2);\nconst vec3 EYE_1_X = X;\nconst vec3 EYE_1_Y = Y;\nconst vec3 EYE_1_Z = Z;\n\nconst vec3 EYE_2_O = vec3(0.5,7.3,1.2);\nconst vec3 EYE_2_X = X;\nconst vec3 EYE_2_Y = Y;\nconst vec3 EYE_2_Z = Z;\n\nconst vec3 ARM_1_O = vec3(2.2,4,0);\nconst vec3 ARM_1_X = Y;\nconst vec3 ARM_1_Y = X;\nconst vec3 ARM_1_Z = Z;\n\nconst vec3 ARM_2_O = vec3(-2.2,4,0); // tilt arm by normalizing -X Y, then get orthonormal vector of new Y\nconst vec3 ARM_2_X = X;\nconst vec3 ARM_2_Y = Y;\nconst vec3 ARM_2_Z = Z;\n\nconst vec3 NOZE_O = vec3(0,7,1.2);\nconst vec3 NOZE_X = -X;\nconst vec3 NOZE_Y = Z;\nconst vec3 NOZE_Z = Y;\n\nconst vec3 HAT_O = vec3(0,8,0);\nconst vec3 HAT_X = X;\nconst vec3 HAT_Y = Z;\nconst vec3 HAT_Z = Y;\n\n// ENDOF YOURS\n\n\n\n\n\n\n\n\n\n\n\nconst float Z_NEAR = 1.0;\nconst float Z_FAR  = 400.0;\n\nconst float EPSILON = 0.01;\n\nconst float FOCAL_LENGTH = 2.0;\nconst vec3 EYE_LOOK_POINT = vec3(0, 5, 0);\n\nconst vec3 WHITE = vec3(1, 1, 1);\nconst vec3 BLACK = vec3(0, 0, 0);\nconst vec3 RED =   vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, 1, 0);\nconst vec3 BLUE =  vec3(0, 0, 1);\n\nconst vec3 TOP_BG_COLOR = WHITE;\nconst vec3 BOT_BG_COLOR = GREEN;\nconst vec3 AMBIANT_COLOR = WHITE;\nconst vec3 SPECULAR_COLOR = WHITE;\n\nconst float AMBIANT_RATIO = 0.3;\nconst float DIFFUSE_RATIO = 0.4;\nconst float SPECULAR_RATIO = 0.3;\nconst float SPECULAR_ALPHA = 10.;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(1, -1, -1));\n\nvec2 normalizeAndCenter(in vec2 coord) {\n    return (2.0 * coord - iResolution.xy) / iResolution.y;\n}\n\nvec3 rayDirection(vec3 eye, vec2 uv) {    \n    vec3 z = normalize(eye - EYE_LOOK_POINT);\n    vec3 x = normalize(cross(Y, z));\n    vec3 y = cross(z, x);\n    \n    return normalize(\n          x * uv.x \n        + y * uv.y \n        - z * FOCAL_LENGTH);\n}\n\n//\n// Rotations\n//\n\nvec3 rotX(vec3 point, float angle) {\n    mat3 matRotX = mat3(\n        1.0, 0.0, 0.0, \n        0.0, cos(angle), -sin(angle), \n        0.0, sin(angle), cos(angle));\n    return matRotX * point;\n}\n\nvec3 rotY(vec3 point, float angle) {\n    mat3 matRotY = mat3( \n        cos(angle*0.5), 0.0, -sin(angle*0.5),\n        0.0, 1.0, 0.0, \n        sin(angle*0.5), 0.0, cos(angle*0.5));\n    return matRotY * point;\n}\n\nvec3 rotZ(vec3 point, float angle) {\n    mat3 matRotZ = mat3(\n        cos(angle*0.1), -sin(angle*0.1), 0.0, \n        sin(angle*0.1), cos(angle*0.1), 0.0,\n    \t0.0, 0.0, 1.0);\n    return matRotZ * point;\n}\n\n//\n// Positioning\n//\n\nvec3 randomOrtho(vec3 v) {\n    if (v.x != 0. || v.y != 0.) {\n    \treturn normalize(vec3(v.y, -v.x, 0.));\n    } else {\n    \treturn normalize(vec3(0., v.z, -v.y));\n    }\n} \n\nvec3 atPosition(vec3 point, vec3 position) {\n\treturn (point - position);\n}\n\nvec3 atCoordSystem(vec3 point, vec3 center, vec3 dx, vec3 dy, vec3 dz) {\n\tvec3 localPoint = (point - center);\n    return vec3(\n        dot(localPoint, dx),\n        dot(localPoint, dy),\n        dot(localPoint, dz));\n}\n\nvec3 atCoordSystemX(vec3 point, vec3 center, vec3 dx) {\n    vec3 dy = randomOrtho(dx);\n    vec3 dz = cross(dx, dy);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\nvec3 atCoordSystemY(vec3 point, vec3 center, vec3 dy) {\n    vec3 dz = randomOrtho(dy);\n    vec3 dx = cross(dy, dz);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\nvec3 atCoordSystemZ(vec3 point, vec3 center, vec3 dz) {\n    vec3 dx = randomOrtho(dz);\n    vec3 dy = cross(dz, dx);\n    \n    return atCoordSystem(point, center, dx, dy, dz);\n}\n\n//\n// Shapes\n//\n\nfloat sphere(vec3 coord, float radius) {\n\treturn length(coord) - radius;\n}\n\nfloat capsule(vec3 coord, float height, float radius)\n{\n    coord.y -= clamp( coord.y, 0.0, height );\n    return length( coord ) - radius;\n}\n\nfloat ellipsoid(vec3 coord, vec3 r )\n{\n    float k0 = length(coord/r);\n    float k1 = length(coord/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat roundCone(vec3 coord, in float radiusTop, float radiusBot, float height)\n{\n    vec2 q = vec2( length(coord.xz), coord.y );\n    \n    float b = (radiusBot-radiusTop)/height;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - radiusBot;\n    if( k > a*height ) return length(q-vec2(0.0,height)) - radiusTop;\n        \n    return dot(q, vec2(a,b) ) - radiusBot;\n}\n\nfloat hatt(vec3 coord) {\n    return min(\n        max(\n            ellipsoid(coord, vec3(3., 2., 0.3)),\n            -ellipsoid(coord - vec3(0.,0.,0.2), vec3(3., 1.5, 0.3))),\n        max(sphere(coord, 1.),\n           -sphere(coord + vec3(0.,0.,0.2), 1.)));\n}\n\n//\n// Boolean ops\n//\n\nvec4 shape(float dist, vec3 color) {\n\treturn vec4(color, dist);\n}\n\nvec4 join(vec4 shape1, vec4 shape2) {\n    if (shape1.a < shape2.a) {\n    \treturn shape1;\n    } else {\n    \treturn shape2;\n    }\n}\n\nvec4 join(vec4 shape1, vec4 shape2, vec4 shape3) {\n    return join(join(shape1, shape2), shape3);\n}\n\nvec4 join(vec4 shape1, vec4 shape2, vec4 shape3, vec4 shape4) {\n    return join(join(shape1, shape2, shape3), shape4);\n}\n\n\n//\n// Scene\n//\n\nvec4 dist(in vec3 coord) {\n    float headY = 7.5;\n    float bodyY = 4.5;\n    float footY = 0.;    \n    \n    vec4 hat = shape(hatt(atCoordSystem(coord, HAT_O, HAT_X, HAT_Y, HAT_Z)), GREEN);\n    \n    vec4 head = shape(sphere(atCoordSystem(coord, HEAD_O, HEAD_X, HEAD_Y, HEAD_Z), 1.5), WHITE);\n    vec4 body = shape(sphere(atCoordSystem(coord, BODY_O, BODY_X, BODY_Y, BODY_Z), 2.), WHITE);\n    vec4 foot = shape(sphere(atCoordSystem(coord, FOOT_O, FOOT_X, FOOT_Y, FOOT_Z), 3.), WHITE);\n    \n    vec4 snow = join(hat, head, body, foot);\n            \n    vec4 leftEye = shape(sphere(atCoordSystem(coord, EYE_1_O, EYE_1_X, EYE_1_Y, EYE_1_Z), 0.3), BLUE);\n    vec4 rightEye = shape(sphere(atCoordSystem(coord, EYE_2_O, EYE_2_X, EYE_2_Y, EYE_2_Z), 0.3), BLUE);    \n    vec4 noze = shape(roundCone(atCoordSystem(coord, NOZE_O, NOZE_X, NOZE_Y, NOZE_Z), 0.1, 0.4, 2.), RED);\n    \n    vec4 face = join(leftEye, rightEye, noze);\n       \n    vec4 leftArm = shape(capsule(atCoordSystem(coord, ARM_1_O, ARM_1_X, ARM_1_Y, ARM_1_Z), 5., 0.2), RED);\n    vec4 rightArm = shape(capsule(atCoordSystem(coord, ARM_2_O, ARM_2_X, ARM_2_Y, ARM_2_Z), 5., 0.2), RED);\n    vec4 arms = join(leftArm, rightArm);\n        \n    vec4 buttonTop = shape(sphere(atCoordSystem(coord, BUTTON_1_O, BUTTON_1_X, BUTTON_1_Y, BUTTON_1_Z), 0.3), RED);\n    vec4 buttonBot = shape(sphere(atCoordSystem(coord, BUTTON_2_O, BUTTON_2_X, BUTTON_2_Y, BUTTON_2_Z), 0.3), RED);\n    vec4 buttons = join(buttonTop, buttonBot);\n    \n    return join(snow, face, arms, buttons);\n}\n\n//\n//\n//\n\nbool rayMarching(in vec3 startPoint, in vec3 direction, out vec3 lastPoint, out vec3 color) {\n    lastPoint = startPoint;\n    for (int i = 0; i < 50; ++i) {\n        vec4 d = dist(lastPoint);\n        if (d.a < EPSILON) {\n            color = d.xyz;\n            return true;\n        } else {\n            lastPoint += d.a * direction;\n        }\n        if (lastPoint.z < -Z_FAR) {\n            break;\n        }\n    }    \n    return false;\n}\n\nvec3 norm(in vec3 coord) {\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    dist(coord+eps.xyy).a - dist(coord-eps.xyy).a,\n\t    dist(coord+eps.yxy).a - dist(coord-eps.yxy).a,\n\t    dist(coord+eps.yyx).a - dist(coord-eps.yyx).a);\n\treturn normalize(nor);\n}\n\n\nvec3 cellShadingObjColor(vec3 point, vec3 ray, vec3 objColor) {\n    vec3 n = norm(point);\n    \n    float diffuseValue = max(dot(-LIGHT_DIRECTION, n), 0.);\n    float specularValue = pow(max(dot(-reflect(LIGHT_DIRECTION, n), ray), 0.), SPECULAR_ALPHA);        \n    \n    return AMBIANT_COLOR * AMBIANT_RATIO\n        + objColor * DIFFUSE_RATIO * diffuseValue\n        + SPECULAR_COLOR * SPECULAR_RATIO * specularValue;\n}\n\n\nvec3 computeColor(vec2 fragCoord) {\n    vec2 uv = normalizeAndCenter(fragCoord);\n    vec3 eye = rotY(vec3(0, 12, 18), cos(iTime*0.5)*2.);\n        \n    vec3 ray = rayDirection(eye, uv);\n    \n    vec3 intersection;\n    vec3 color;\n    bool intersected = rayMarching(eye, ray, intersection, color);\n    \n    if (intersected) {\n    \treturn cellShadingObjColor(intersection, ray, color);\n    } else {\n    \treturn uv.y > 0. ? TOP_BG_COLOR : BOT_BG_COLOR;\n    }\n}\n\n//#define SUPERSAMPLING\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    #ifdef SUPERSAMPLING\n    fragColor = vec4(0);\n    float count = 0.;\n    for(float dx=-0.5; dx<=0.5; dx+=0.5) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.5) {\n            fragColor += vec4(computeColor(fragCoord + vec2(dx, dy)), 1.0);\n            count += 1.;\n        }\n    }\n    \n    fragColor /= count;\n    \n    #else\n    fragColor = vec4(computeColor(fragCoord),1.0);\n    #endif\n} \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2068, 2068, 2108, 2108, 2169], [2171, 2171, 2209, 2209, 2420], [2442, 2442, 2478, 2478, 2634], [2636, 2636, 2672, 2672, 2844], [2846, 2846, 2882, 2882, 3050], [3074, 3074, 3100, 3100, 3243], [3246, 3246, 3290, 3290, 3320], [3322, 3322, 3394, 3394, 3538], [3540, 3540, 3595, 3595, 3715], [3717, 3717, 3772, 3772, 3892], [3894, 3894, 3949, 3949, 4069], [4088, 4088, 4128, 4128, 4162], [4164, 4164, 4219, 4219, 4304], [4306, 4306, 4344, 4344, 4441], [4443, 4443, 4523, 4523, 4859], [4861, 4861, 4885, 4885, 5117], [5141, 5141, 5177, 5177, 5206], [5208, 5208, 5245, 5245, 5337], [5339, 5339, 5389, 5389, 5438], [5440, 5440, 5503, 5503, 5560], [5579, 5579, 5605, 5605, 7097], [7109, 7109, 7202, 7202, 7544], [7546, 7546, 7572, 7572, 7812], [7815, 7815, 7878, 7878, 8230], [8233, 8233, 8268, 8268, 8689], [8691, 8715, 8772, 8772, 9160]], "test": "error"}
{"id": "3t2GR1", "name": "Here exists the 3D blue/cyan -", "author": "cmarangu", "description": "lol used primitive 3D projection. the scaling of lengths is inversely proportional to the radius of a vision cone, so yea divide by y.", "tags": ["3d", "raytracing", "projection", "cyan"], "likes": 3, "viewed": 107, "published": "Public", "date": "1558488962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float x = (fragCoord.x-iResolution.x/2.0)*0.5;\n    float y = (fragCoord.y-iResolution.y/2.0)*0.25;\n    \n    float zy = iTime                   + 160.0/abs(y);\n    float zx = 1.0+2.0*cos(iTime/4.0)  + 1.0*x/abs(y);\n    \n    float a = zx;\n    float b = zy;\n    \n    // makes it diagonal\n    zx = a+b;\n    zy = a-b;\n    \n    // it makes it be all checkerboardy\n    zy = floor(zy*1.0)/2.0;\n    zx = floor(zx*1.0)/2.0;\n    \n    float parx = 0.5 + 0.5*cos(zx*6.0);\n    float pary = 0.5 + 0.5*cos(zy*6.0);\n    \n    // a differet textrue thingy\n    parx = mod(abs(zx+1e4), 1.0)*2.0;\n    pary = mod(abs(zy+1e4), 1.0)*2.0;\n    \n    \n    // ugly cyan fog at the horizon. yuck.\n    /*\n\tfloat fog = 15.0;\n    fog = 0.0;\n    \n    float p1 = abs(y)/fog;\n    p1 = p1*p1;\n    \n    if (p1 < 1.0) {\n    \tparx = 1.0-(1.0-parx)*p1;\n        pary = 0.0+(0.0+pary)*p1;\n    }\n    */\n    \n    // much much better fog\n    \n    float fog = 2.0+iTime/2.0;\n    if (zx > fog) {\n        parx = parx/(zx-fog);\n    }\n    fog = -5.0-iTime/2.0;\n    if (zy < fog) {\n        pary = abs(pary/(zy-fog));\n    }\n    fog = iTime/2.0+20.0;\n    if (zx > fog) {\n        pary = abs(pary/(zx-fog));\n    }\n    fog = -iTime/2.0-20.0;\n    if (zy < fog) {\n        parx = abs(parx/(zy-fog));\n    }\n    \n    \n    vec3 col = vec3(min(parx, pary), parx, max(parx, pary));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2GR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1438]], "test": "ok"}
{"id": "3tB3zw", "name": "[liliilli] RayMarching Test 1", "author": "liliilli", "description": "😏🍙", "tags": ["liliilli"], "likes": 2, "viewed": 881, "published": "Public API", "date": "1558786646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// @brief Rotate position (pos) with radian on counter-clockwise.\nvec3 RotateY(vec3 pos, float radian)\n{\n    return vec3(\n        cos(radian) * pos.x + sin(radian) * pos.z, \n        pos.y,\n        -sin(radian) * pos.x + cos(radian) * pos.z);\n}\n\n/// @brief Get shortest distance from point to infinity line.\nfloat DistLineToPoint(vec3 ro, vec3 rd, vec3 pos)\n{\n    vec3 ap = pos - ro;\n    return length(cross(ap, rd)) / length(rd);\n}\n\n/// @brief Directional light structure.\nstruct DLight \n{\n    vec3 mDir;\n    vec3 mCol;\n};\n\n/// @brief Plane structure.\nstruct DPlane\n{\n    vec3 mCenterPos;\n    vec3 mNormal;\n    vec3 mCol;\n};\n\n/// @brief Get signed-distance funciton weight value of plane.\nfloat sdfPlane(vec3 pos, DPlane plane)\n{\n    // Calculus Early Transcendentals 7th p823.\n    float denom = length(plane.mNormal);\n    float numem = abs(dot(plane.mNormal, pos - plane.mCenterPos));\n    return numem / denom;\n}\n\n/// @brief Get normal vector of plane.\nvec3 GetNormalPlane(vec3 pos, vec3 dir, DPlane plane)\n{\n    return plane.mNormal;\n}\n\n/// @brief Sphere structure.\nstruct DSphere\n{\n    vec3 mPos;\n    vec3 mCol;\n    float mRadius;\n};\n\n/// @brief Get signed-distance function weight value of sphere.\n/// 0 is isosurface, and negative value is in sphere.\nfloat sdfSphere(vec3 pos, DSphere sphere)\n{\n    return distance(pos, sphere.mPos) - sphere.mRadius;\n}\n\n/// @brief Get proper normal vector from intersection of ray with sphere,\n/// when ray is intersected with sphere.\nvec3 GetNormalSphere(vec3 pos, vec3 dir, DSphere sphere)\n{\n    float longHypot  = distance(pos, sphere.mPos);\n    float shortDist2 = pow(DistLineToPoint(pos, dir, sphere.mPos), 2.0);\n    \n    float t = sqrt(pow(longHypot, 2.0) - shortDist2);\n    float minusT = sqrt(pow(sphere.mRadius, 2.0) - shortDist2);\n    t -= minusT;\n    \n    return normalize((pos + t * dir) - sphere.mPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    uv.x -= (iResolution.x - iResolution.y) / (2. * min(iResolution.x, iResolution.y)); \n    uv -= 0.5;\n    \n    vec3 camera = RotateY(vec3(0, 3, 5), iTime);\n    vec3 view   = vec3(0, 0, 0);\n    vec3 up     = vec3(0, 1, 0);\n    \n    // Setting up View matrix (don't make view matrix itself, We just need v,s,u element).\n    vec3 forward = normalize(view - camera);\n    vec3 side    = cross(forward, up);\n    vec3 camUp   = cross(side, forward);\n\n    float zoom = 2.0f;\n\n    // Setting up virtual screen, and lay direction of virtual screen pixel.\n    vec3 scrOrg = camera + zoom * forward;\n    vec3 pxlPos = scrOrg + (side * uv.x) + (camUp * uv.y);\n    vec3 rayDir = normalize(pxlPos - camera);\n    \n    DPlane far;\n    far.mCenterPos = camera + 10.0 * forward;\n    far.mNormal = -forward;\n    \n    // Setting up light\n    DLight dirLight;\n    dirLight.mDir = normalize(vec3(0, 1, 1));\n    dirLight.mCol = vec3(1, 1, 1);\n    \n    // Setting up background color.\n    vec3 result = vec3(0);\n    result = vec3(0., 56. / 255., 91. / 255.);\n    \n    // Setting up structure (model)\n    DPlane plane;\n    plane.mCenterPos = vec3(0, -1, 0);\n    plane.mNormal = vec3(0, 1, 0);\n    plane.mCol = vec3(1, .5, 0);\n    \n    DSphere sphere;\n    sphere.mPos = vec3(0, 0, 1);\n    sphere.mCol = vec3(0, .5, 1);\n    sphere.mRadius = 0.5;\n    \n    DSphere sphere2;\n    sphere2.mPos = RotateY(vec3(0, 0, 1), 0.78);\n    sphere2.mCol = vec3(0, 1, 0);\n    sphere2.mRadius = 0.25;\n    \n    DSphere sphere3;\n    sphere3.mPos = RotateY(vec3(0, 0, 1), 1.17);\n    sphere3.mCol = vec3(1, 0, 0);\n    sphere3.mRadius = 0.125;\n\n    // Raycasting & marching & rendering.\n    for (int i = 0; i < 64 && sdfPlane(camera, far) > 0.5f; ++i)\n    {\n        float shortestDist = sdfPlane(camera, far);\n        shortestDist = min(shortestDist, sdfSphere(camera, sphere));\n        if (shortestDist < 0.01)\n        {\n            vec3 normal = GetNormalSphere(camera, rayDir, sphere);\n            vec3 qLambert = \n                clamp(dot(dirLight.mDir, normal) * sphere.mCol * dirLight.mCol, 0., 1.) \n              * 0.75 + 0.25;\n            result = qLambert;\n            break;\n        }\n        \n        shortestDist = min(shortestDist, sdfSphere(camera, sphere2));\n        if (shortestDist < 0.01)\n        {\n            vec3 normal = GetNormalSphere(camera, rayDir, sphere2);\n            vec3 qLambert = \n                clamp(dot(dirLight.mDir, normal) * sphere2.mCol * dirLight.mCol, 0., 1.) \n              * 0.75 + 0.25;\n            result = qLambert;\n            break;\n        }\n        \n        shortestDist = min(shortestDist, sdfSphere(camera, sphere3));\n        if (shortestDist < 0.01)\n        {\n            vec3 normal = GetNormalSphere(camera, rayDir, sphere3);\n            vec3 qLambert = \n                clamp(dot(dirLight.mDir, normal) * sphere3.mCol * dirLight.mCol, 0., 1.) \n              * 0.75 + 0.25;\n            result = qLambert;\n            break;\n        }\n        \n        shortestDist = min(shortestDist, sdfPlane(camera, plane));\n        if (shortestDist < 0.01)\n        {\n            vec3 normal = GetNormalPlane(camera, rayDir, plane);\n            vec3 qLambert = \n                clamp(dot(dirLight.mDir, normal) * plane.mCol * dirLight.mCol, 0., 1.) \n              * 0.75 + 0.25f;\n            result = qLambert;\n            break;\n        }\n        \n        camera += shortestDist * rayDir;\n    }\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 105, 105, 244], [246, 308, 359, 359, 432], [627, 690, 730, 778, 914], [916, 955, 1010, 1010, 1038], [1139, 1257, 1300, 1300, 1358], [1360, 1475, 1533, 1533, 1857], [1859, 1859, 1914, 1914, 5410]], "test": "ok"}
{"id": "3tBGzw", "name": "SmartNoise Demo (v3)", "author": "Bapho", "description": "This is neither a fixed pattern nor a temporal noise/grain shader. I tried a new approach, so that the noise pattern is only changing when the color of the position is changing.", "tags": ["noise", "goldenratio", "grain", "golden", "goldennoise"], "likes": 4, "viewed": 548, "published": "Public API", "date": "1558777075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// SmartNoise Demo by Bapho\n// https://github.com/Bapho/reshade-shaders/blob/master/Shaders/SmartNoise.fx\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nfloat noise = 2.0;\n\n//----------------------------------------------------------------------\nprecision lowp float;\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouse;\n    if (iMouse.x <= 0.0 || iMouse.x >= iResolution.x){\n\t\tmouse = iResolution.x / 2.0;\n    } else {\n        mouse = iMouse.x;\n    }\n                             \n    if (mouse > fragCoord.x - 4.0 && mouse < fragCoord.x + 4.0){\n        fragColor = vec4(0.4, 0.0, 0.0, 1.0);\n    } else {\n\n        vec2 uv = fragCoord/iResolution.xy;\n\n        vec3 color;\n        if (fragCoord.x < iResolution.x * 0.05\n            || fragCoord.x > iResolution.x * 0.95){\n            color = vec3(0.0);\n            \n        } else if (fragCoord.y < iResolution.y * 0.15){\n        \tcolor = texture(iChannel1, uv).rgb;\n            \n        } else if (fragCoord.y < iResolution.y * 0.85){\n            color = texture(iChannel0, uv).rgb;\n            \n        } else {\n            color = 0.5 + 0.25*cos(iTime*0.5+uv.xyx+vec3(0,4,8));\n            //color = vec3(0.0, 0.8, 0.2);\n        }\n\n        if ((mouse <= 0.0 && fragCoord.x < iResolution.x / 2.0) \n\t\t\t\t|| mouse > fragCoord.x){\n            \n            float luminance = (0.2126 * color.r) \n                + (0.7152 * color.g) + (0.0722 * color.b);\n            \n            float uniquePos = (iResolution.x * fragCoord.y) + fragCoord.x;\n\n            float amount = noise * 0.08;\n            \n            // adjusting \"noise contrast\"\n            if (luminance < 0.5){\n                amount *= (luminance / 0.5);\n            } else {\n                amount *= ((1.0 - luminance) / 0.5);\n            }\n            \n            // reddish pixels will get less noise\n            float redDiff = color.r - ((color.g + color.b) / 2.0);\n            if (redDiff > 0.0){\n                amount *= (1.0 - (redDiff * 0.5));\n            }\n\n            // a very low unique seed will lead to slow noise\n            // pattern changes on slow moving color gradients\n            float uniqueSeed = ((luminance * iResolution.y) + uniquePos) * 0.00000001;\n            \n            // using a fictive coordinate as a workaround to fix a pattern bug\n\t\t\tvec2 coordinate = vec2(fragCoord.x, fragCoord.y * 1.001253543);\n            \n            // average noise luminance to subtract\n            float sub = (0.5 * amount);\n\n            // \"noise clipping\"\n            if (luminance - sub < 0.0){\n                amount *= (luminance / sub);\n                sub *= (luminance / sub);\n            } else if (luminance + sub > 1.0){\n                if (luminance > sub){\n                    amount *= (sub / luminance);\n                    sub *= (sub / luminance);\n                } else {\n                    amount *= (luminance / sub);\n                    sub *= (luminance / sub);\n                }\n            }\n\n            // calculating and adding/subtracting the golden noise\n            float ran = gold_noise(coordinate, uniqueSeed);\n            float add = clamp(ran * amount, 0.0, 1.0);\n            color += (add - sub);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 636, 636, 713], [715, 715, 772, 772, 3687]], "test": "error"}
{"id": "3tfGDs", "name": "Flowing Margarita", "author": "tpfto", "description": "An adaptation of the [url=http://www.peda.com/grafeq/gallery/margarita.html]classical GrafEq example[/url]. Thanks to Shane for inspiring a modification of my original take.", "tags": ["2d"], "likes": 5, "viewed": 148, "published": "Public", "date": "1557984068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// originally adapted from http://www.peda.com/grafeq/gallery/margarita.html\n\n#define PI 3.14159265359\n#define SCALE 60.0\n\nfloat f(float a, vec2 p)\n{\n      float cf = 2.0 - cos(0.1 * iTime);\n      float d = (length(p) - 3.5 * atan(p.y, p.x) + sin(cf * p.x) + cos(cf * p.y))/(a * PI);\n     \n      return smoothstep(0.0, 0.2, 0.5 * cos(PI * (2.0 * d - iTime)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= SCALE;\n        \n        vec3 col = mix(vec3(0.29, 0.22, 0.48), vec3(0.88, 0.03, 0.11), f(7.0, uv));\n        col = mix(vec3(0.9, 0.87, 0.63), col, f(1.0, uv));\n\n        col *= 1.0 - 0.1 * length(fragCoord/iResolution.xy - 0.5); // vignetting\n        fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 149, 149, 361], [363, 363, 420, 420, 836]], "test": "ok"}
{"id": "3tj3Rw", "name": "OTM", "author": "lennyjpg", "description": "OTM", "tags": ["2d", "flat", "pattern", "panel", "mono"], "likes": 6, "viewed": 436, "published": "Public API", "date": "1558970352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool tick(int i, int s){\n    return (i-s+6)%6 == 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - iResolution.xy ) / iResolution.y; \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    uv+=mouse*2.;\n    float t = iTime * 5.0;\n    //t += sin(t)+1.0;\n    float res = 5., speed = 0.0137, offset = t * .1;\n    offset *= ceil(uv.y * res) *.25 + 1.5;\n    float flip =  round( fract(uv.y * .5 * res ));\n    uv.x += (flip-.5) * offset;\n    float pw = res*1.5/iResolution.y;\n    \n    vec2 u = uv * res; \n    int i = int(ceil(u.x) + ceil(u.y));\n    u = fract(u);\n    float k = 0.,\n        a = u.y + u.x, b = u.y - u.x,\n        c = length(u - .5);\n\n    if(tick(i, 2)){\n        float g = step(.0, u.y - .5);\n        k += smoothstep(.5 - pw, .5, c) + step(.8, b + .2);\n        k += smoothstep(.15, .15 - pw, c+g);\n        k += smoothstep(.05, .05 - pw,  length(vec2(abs(u.x - .5), u.y - .5) - .1));\n    }else if(tick(i, 3)){\n        k += step(1. - abs(b), .7) - step(.5 - u.y, 0.) + step(.9 - b, .1);\n    }else if(tick(i, 5) || tick(i , 4)){\n        k += step(.3, abs(b)) - step(1.3 - u.x, .4);        \n    }\n    \n    if(tick(i, 4)){\n        k-= step(abs(1. - b), .6);\n    }else if(tick(i, 0)){\n        k += step( abs(b + 1.), .5);\n    }else if(tick(i, 1) ){\n        k += 1.;\n    }\n\n    if(flip == 1.) k = 1. - k;\n    vec3 front = vec3(1., .1, .3), back = vec3(.2, .1, .2);\n    fragColor = vec4(mix(front, back, clamp(k, 0., 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 53], [55, 55, 112, 112, 1462]], "test": "ok"}
{"id": "3tj3zD", "name": "Fuzz-flakes", "author": "mmclin", "description": "Flurries of fuzzy flakes are falling.", "tags": ["circles", "dots", "falling", "snow", "pastel", "flakes"], "likes": 3, "viewed": 152, "published": "Public", "date": "1558687757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fuzz-flakes by Matt McLin\n\n// random func based on one found here: https://thebookofshaders.com/10/\n// @patriciogv - 2015, http://patriciogonzalezvivo.com\nfloat rand (float seed) \n{\n    return fract(sin(dot(vec2(seed, seed*0.5926535897),\n                         vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat flake(in vec2 uv, in vec2 pos, float speed, float size, float wind)\n{\n    uv.x *= 1.6;\n    vec2 drop;\n    drop.y = 1.0 - fract(((iTime+pos.y)*speed) / iResolution.y);\n    drop.x = (pos.x * 1.6) + sin(drop.y*wind)*0.1;\n    float d = distance(uv, drop);\n    d = clamp(d, 0.0, 0.28);\n    if (d < size) return 1.0;\n    if (d > (size+0.02)) return 0.0;\n    return mix(1.0,0.0, 50.0*(d - size));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.3,0.1,0.7) - 0.2*cos(iTime+uv.xyx);\n    \n    for (float i=0.0; i<200.0; i += 1.0) {\n        vec3 flakecol = vec3(0.3+0.3*rand(i*0.9),0.7+0.3*rand(i*0.3),0.8+0.2*rand(i*0.6));\n        vec2 pos = vec2(rand(i), rand(i*0.887787)*1.6 + 0.1);\n        float speed = 150.0 + 100.0*rand(i*0.728734);\n        float size = 0.005 + 0.02*rand(i*0.1415926);\n        float wind = 4.0*rand(i*0.314159);\n        col = mix(col, flakecol, flake(uv, pos, speed, size, wind));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 158, 184, 184, 306], [308, 308, 383, 383, 705], [707, 707, 764, 764, 1322]], "test": "ok"}
{"id": "3tj3zh", "name": "fan / spotlight mask", "author": "aferriss", "description": "Quick fan sketch", "tags": ["triangle", "gradient", "atan", "spotlight", "smoothstep", "mask", "fan"], "likes": 1, "viewed": 393, "published": "Public API", "date": "1558473202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0 - uv.y + 0.5;\n\t\n    vec2 n = normalize(uv + uv - vec2(1.0));\n\n    \n\tfloat amt = sin(iTime)*0.25 + 0.25;\n    float feather = 0.01;\n    float base = 0.5;\n    \n    \n    float grad = smoothstep(base + amt, base + amt + feather, n.y);\n    grad = smoothstep(0.0, feather*10.0, grad);\n    fragColor = vec4(grad);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tj3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 420]], "test": "ok"}
{"id": "3tjGR1", "name": "Mandel Man", "author": "JohnShadow", "description": "Mandel Man\nTook a while to do this mash up, this is for a world / story I'm making.\nI had to learn about Mandel Brot / bulb in 3d.\nI looked at several sources and the head is one I found on here.", "tags": ["raymarch", "mandelbrot", "mandelbulb", "ao", "head", "man", "huaman"], "likes": 25, "viewed": 359, "published": "Public", "date": "1558486483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PI2 1.5707963268\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\nvec3 lerp3(vec3 a, vec3 b, float t)\n{\n    return a * t + b * (1.0-t);\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nbool isEye = false;\n\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    p.y -= .11;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n    \n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n\tisEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\nfloat sstep(float t) {\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\n}\nfloat sphere(vec3 x, vec3 pos, float r)\n{\n    return length(x - pos) - r;\n}\nfloat bulb(vec3 pos)\n{\n    vec3 x = pos;\n    float p = 2.;\n    float dz = 1.0;\n    float r = 0.0;\n    for(int i = 0; i < 10; ++i)\n    {\n        r = length(x);\n        if (r > 4.5)\n            break;\n        float rp = pow(r, p);\n        float phi = p*atan(x.y, x.x);\n\t\tfloat theta = p*acos(x.z/r);\n        dz = pow(r, p - 1.0) * p * dz + 1.0;\n        \n        x = rp * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));  \n        x += pos;\n    }\n    return 0.5*log(r)*r/dz;\n}\nfloat map(vec3 p) {\n    \n    float scale = 0.8;\n    float s = .2;\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\n    float rx = sin(iTime * .33) * .2;\n\n    if (iMouse.z > 0. && iMouse.w > 0.) {\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\n        scale = 0.8;\n    }\n    \n    pR(p.yz, rx);\n    pR(p.xz, ry);\n    p /= scale;\n    \n    //float s1 = sphere(p, vec3(0,1.0,0), 0.2);\n    \n    vec3 bp = p;\n    pR(bp.xy, PI2);\n    pR(bp.xz, -0.31);\n    bp -= vec3(0.3, 0, -0.6);\n   \tfloat lf = min(bulb(bp), mHead(p*0.75));\n   \treturn lf * scale;\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat march(vec3 pos, vec3 dir)\n{\n    float cd = 0.0, fd = 0.0;\n    vec3 x;\n    for(int i = 0; i < 200; ++i)\n    {\n        x = pos + dir * fd;\n        cd = map(x);\n        fd += cd;\n        if(cd < 0.001)\n            return fd;\n        if(fd > 1000.0)\n            return 0.0;\n    }\n    pos = normalize(x);\n    return 0.0;\n}\nfloat getao (vec3 pos, vec3 normal)\n{\n\treturn clamp(map(pos+normal*0.01)/0.01, 0.0, 1.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float l = march(eye, dir);\n    vec3 n = vec3(0);\n    vec3 c = vec3(0);\n    if(l > 0.0)\n    {\n        vec3 p = eye + dir * (l-0.005);\n    \tn = normal(p);\n        float lam = dot(n, vec3(0.707, 0.707, 0.707));\n        float ao = getao(p, n);\n    \tc = vec3(max(lam, 0.3));\n        c *= lerp3(vec3(0.6, 0.6, 0.9), vec3(0.9, 0.6, 0.4), abs(dot(vec3(0,1.,0), n))) * ao;\n    }\n    else\n        c = lerp3(vec3(0.6, 0.6, 0.9), vec3(0.9, 0.6, 0.4), abs(dot(vec3(0,1.,0), dir)));\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 83, 83, 128], [130, 130, 157, 157, 187], [189, 189, 226, 226, 260], [300, 300, 320, 320, 348], [350, 350, 370, 370, 408], [410, 410, 430, 430, 468], [470, 470, 490, 490, 518], [520, 520, 548, 548, 635], [637, 637, 661, 661, 723], [725, 725, 755, 755, 842], [845, 845, 882, 882, 948], [951, 995, 1059, 1059, 1337], [1339, 1339, 1379, 1379, 1470], [1472, 1472, 1512, 1512, 1604], [1606, 1606, 1644, 1644, 1755], [1757, 1757, 1796, 1796, 1827], [1829, 1829, 1868, 1868, 1939], [1941, 1941, 1980, 1980, 2051], [2054, 2054, 2083, 2083, 2150], [2152, 2152, 2181, 2181, 2248], [2272, 2272, 2293, 2293, 11473], [11474, 11474, 11496, 11496, 11539], [11540, 11540, 11581, 11581, 11615], [11616, 11616, 11638, 11638, 12100], [12101, 12101, 12120, 12120, 12752], [12753, 12753, 12775, 12775, 13012], [13013, 13013, 13046, 13046, 13336], [13337, 13337, 13374, 13374, 13428], [13429, 13429, 13494, 13494, 13626], [13627, 13627, 13684, 13684, 14316]], "test": "timeout"}
{"id": "3tjGRz", "name": "Cookie Collective - V2", "author": "Fusion", "description": "cookie", "tags": ["cookie"], "likes": 2, "viewed": 377, "published": "Public API", "date": "1558291791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Les formes - https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat direction = 1.0;\n\nvec3 rotatingColor (float time) {\n    float pi = 3.141592;\n    float demiPi = pi / 2.0;\n    \n    vec3 color = vec3(0.0);\n    vec3 index = vec3(mod(time, pi + demiPi) - demiPi,\n                      mod(time + demiPi, pi + demiPi) - demiPi,\n                      mod(time + pi, pi + demiPi) - demiPi);//Goes from -1 to 2\n    \n    if (index.x < demiPi)\n    color.x = abs(cos(index.x));\n   \n    if (index.y < demiPi)\n    color.z = abs(cos(index.y));\n    \n    if (index.z < demiPi)\n    color.y = abs(cos(index.z));\n\n\treturn color;\n}\n\n\nmat2 rotation(float a){\n \tfloat c = cos(a);\n    float s = sin (a);\n    \n    return mat2(c,s,-s,c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat map (vec3 pos)\n{\n    pos.xy *= rotation(pos.z * .3); //Faire une rotation\n \tpos.z -= direction * iTime * .5; //Fait avancer en profondeur\n    \n    float size = 2.;\n    pos = mod(pos, size)-size/2.; //position de la \"boite\" Modulo\n    \n    float distanceToGeometry = sdBox(pos, vec3(.40 + abs(sin((iTime + 60.0) / 5.0) * .6 * pos.z))); //Taille de la sphère\n    return distanceToGeometry;\n}\n    \n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = fragCoord/iResolution.xy;\n    position = position *2. -1.; //Remet la position au centre \n    \n    position.x *= iResolution.x / iResolution.y;\n    \n    //float circle = length(position)-0.5;\n    //circle = step(abs(sin(iTime))/2., circle);\n    //circle = step(1., circle);\n    \n    \n    \n    vec3 eye = vec3(0,0,-2);\n    vec3 ray = normalize(vec3(position, 1.));\n    vec3 currPos = eye;\n    float shade = 0.0;\n    for (int index = 0; index < 75; ++index)\n    {\n        float dist = map(currPos);\n        if (dist < 0.0001) {\n            shade = 1.0-float(index)/75.;\n            break;\n        }\n        currPos += ray * dist *.5;\n    }\n    \n    \n    \n    \n    \n    \n    //fragColor = vec4(pow(1.-length(pos - eye) /3., 2.));\n    //fragColor= vec4(pow(shade, 2.));\n    fragColor = vec4(shade); //shade,pow(shade/2., .7),0.,0.);\n    \n    float invertedShade = abs(shade - 1.0);\n    fragColor = vec4(fragColor.xyz * rotatingColor(iTime - (currPos.z / 10.) * direction),  0.0);\n    fragColor += vec4(vec3 (invertedShade),  0.0);\n    \n    \n    //fragColor *= (currPos.z) * (abs(sin(iTime) / 2.) + 0.5);\n    \n    //fragColor.r = fragColor.r * (currPos.z) * (abs(sin(iTime) / 2.) + 0.5);\n\t//fragColor.g *= (abs(sin(iTime)) /3. + 0.6);\n    //fragColor.g = sin(currPos.y);\n    \n    \n    //fragColor = vec4(abs(position),10.*fract(iTime/5.)/5.,10.);\n}\n\n\n\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.);", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 141, 141, 636], [639, 639, 662, 662, 739], [741, 741, 776, 776, 800], [802, 802, 833, 833, 983], [986, 986, 1008, 1008, 1382], [1392, 1392, 1449, 1449, 2813]], "test": "ok"}
{"id": "3tjGz1", "name": "Wave Tracing", "author": "JohnShadow", "description": "A 3d waves bouncing off a vertical plain and a sphere.", "tags": ["wave", "simulation", "tracing"], "likes": 1, "viewed": 124, "published": "Public", "date": "1558578812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nfloat opTwist(in vec3 p, float twist, float sc)\n{\n    float c = cos(twist*p.y);\n    float s = sin(twist*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdOctahedron(q, sc);\n}\nvec3 reflplain(vec3 p, vec4 n)\n{\n    vec3 ac = (n.xyz * n.w);\n\tif(dot(p, ac) >= 0.0)\n\t\t return vec3(0);\n\tvec3 a = p - ac;\n\tfloat dist = dot(a, n.xyz);\n\tvec3 pp = p + (n.xyz - 2.0*dist*n.xyz);\n\treturn pp;\n}\nvec3 reflsphere(vec3 p, vec4 n)\n{\n\tvec3 a = p - n.xyz;\n\tfloat dist = length(a);\n   \treturn p - (a * (n.w/dist));\n}\nvec3 refltriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 n = -normalize(cross(b - a, c - a)); \n\tfloat dist = dot(p - a, n);\n    if(dist >= 0.0)\n\t\t return p;\n\tvec3 pp = p + (n - dist*n);\n\tif (dot(n, cross(b - a, a - pp)) > 0.0 && \n    dot(n, cross(c - b, b - pp)) > 0.0 && \n    dot(n, cross(a - c, c - pp)) > 0.0)\n\t\treturn p + (n - 2.0*dist*n);\n\treturn vec3(0);\n}\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat sphere(vec3 x, vec3 c, float r)\n{\n    return abs(length(x-c)-r);             // sphere DE\n}\n#define PI_2 1.57079632679\n#define PI 3.14159265359\nfloat fsinf(float x)\n{\n\tfloat s = sign(mod((x - PI_2) * 0.5, PI) - PI_2);\n\tx = (mod(x - PI_2, PI) - PI_2) * 0.0123456790123;\n\tx = 4.0*x*x*x - 3.0*x;\n\tx = 4.0*x*x*x - 3.0*x;\n\tx = 4.0*x*x*x - 3.0*x;\n\tx = 4.0*x*x*x - 3.0*x;\n\treturn x * s;\n}\nfloat wave(vec3 p, vec3 location)\n{\n    p = p - location;\n    float prefl = sqrt(dot(p, p)) * 10.0; \n    return fsinf(prefl)/prefl;\n}\nfloat reflections(vec3 p, vec4 n)\n{\n    float b4 = dot(p, n.xyz) + n.w;\n    vec3 rp = p;\n    float dt = 20.*sin(iTime*0.5);\n    p.y -= wave(p, vec3(0,0,dt));\n    rp.xz = reflsphere(p, vec4(0.0, -2.0, 5.0, 1.0)).xz;\n    if(rp.xz != vec2(0))\n    \tp.y -= wave(rp, vec3(0,0,dt));\n    rp.xz = reflplain(p, vec4(0.0, 0.0, 1.0, 1.0)).xz;\n    if(rp.xz != vec2(0))\n    \tp.y -= wave(rp, vec3(0,0,dt));\n    float cdt = 5.0 * cos(iTime * 0.5);\n    rp.xz = refltriangle(p, vec3(-2.5, -2.5, cdt), vec3(0, 2.5, cdt), vec3(2.5, -2.5, cdt)).xz;\n    if(rp.xz != vec2(0))\n    \tp.y -= wave(rp, vec3(0,0,dt));\n    p.y -= wave(p, vec3(0,0,dt));\n    return (dot(p, n.xyz) + n.w);\n}\nfloat rplain(vec3 p, vec4 n)\n{\n    return abs(dot(p,n.xyz) + n.w);\n}\nfloat map(vec3 position)\n{\n    vec3 sp = position - vec3(3.14159265359, 0, 0);\n    float r = reflections(position, vec4(0,1,0, 2.0));\n    float s = sphere(position, vec3(0, -2., 5.0), 1.0);\n\tfloat o = sdOctahedron(position, 0.2);\n    float d = -cos(iTime * 2.0);\n    float dt = 5.0 * cos(iTime * 0.5);\n    float t = udTriangle(position, vec3(-2.5, -2.5, dt), vec3(0, 2.5, dt), vec3(2.5, -2.5, dt));\n    float a = rplain(position, vec4(0.0, 0.0, 1.0, 0.0));\n    if(d < 0.0)\n    \treturn min(min(min(s, r), o), t);\n    else\n\t\treturn min(min(min(min(s, r), o), a), t);\n}\nvec3 normal (vec3 p)\n{\n const float eps = 0.0001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nfloat march(vec3 pos, vec3 dir)\n{\n    float cd = 0.0, fd = 0.0;\n    for(int i = 0; i < 1000; ++i)\n    {\n        cd = map(pos + dir * fd);\n        fd += cd;\n        if(fd > 100.0)\n            return 0.0;\n        if(cd < 0.0001)\n            return fd;\n    }\n    return 0.0;\n}\nfloat getao (vec3 pos, vec3 normal)\n{\n\treturn clamp(map(pos+normal*0.2)/0.2, 0.0, 1.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(30.0, 10.0, 30.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float l = march(eye, worldDir);\n    vec3 n = vec3(0);\n    vec3 c = vec3(0);\n    if(l != 0.0)\n    {\n        vec3 p = eye + worldDir * (l - 0.005);\n    \tn = normal(p);\n        float ao = getao(p, n);\n    \tc = ao * (vec3(min(max(dot(n, vec3(0.707, 0.707, 0.707)),0.0),0.9)) + vec3(0.15));\n    }\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 69, 69, 367], [368, 368, 417, 417, 573], [574, 574, 606, 606, 779], [780, 780, 813, 813, 894], [895, 895, 946, 946, 1261], [1262, 1262, 1287, 1287, 1306], [1307, 1307, 1359, 1359, 1866], [1867, 1867, 1906, 1906, 1964], [2017, 2017, 2039, 2039, 2254], [2255, 2255, 2290, 2290, 2388], [2389, 2389, 2424, 2424, 3047], [3048, 3048, 3078, 3078, 3116], [3117, 3117, 3143, 3143, 3683], [3684, 3684, 3706, 3706, 3943], [3944, 3944, 3977, 3977, 4217], [4218, 4218, 4255, 4255, 4307], [4308, 4308, 4373, 4373, 4505], [4506, 4506, 4555, 4590, 4816], [4817, 4817, 4874, 4874, 5466]], "test": "timeout"}
{"id": "3tl3Ds", "name": "My first 3d shader", "author": "icecreamsandwich", "description": "Learned how to manipulate a point in 3d space and visualize it from this tutorial: https://www.youtube.com/watch?v=dKA5ZVALOhs", "tags": ["point", "3dspace"], "likes": 1, "viewed": 62, "published": "Public", "date": "1558099010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 camera, vec3 cameraDistToPixel, vec3 point) {\n\treturn length(cross(point-camera, cameraDistToPixel))/length(cameraDistToPixel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // make origin in center of the screen\n    uv -= .5;\n    \n    // adjusting screen to aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camera = vec3(.0, .0, -2.0);\n    vec3 cameraDistToPixel = vec3(uv.x, uv.y, 0.0) - camera;\n\n    float time = iTime;\n    \n    vec3 point = vec3(sin(time), .0, 3.*cos(time)+2.);\n    float distanceToPoint = DistLine(camera, cameraDistToPixel, point);\n    if (distanceToPoint > .1) {\n    \tdistanceToPoint = 0.0;\n    } else {\n    \tdistanceToPoint = 1.0;\n    }\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(distanceToPoint, col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tl3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 149], [151, 151, 208, 258, 973]], "test": "ok"}
{"id": "3tl3Wl", "name": "Quasicrystal Experiment", "author": "tpfto", "description": "An experiment with quasicrystal-like patterns.", "tags": ["2d", "quasicrystal"], "likes": 5, "viewed": 117, "published": "Public", "date": "1558058544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 p = ( 20.0 * fragCoord.xy / iResolution.y ) - 10.0 * aspect;\n        \n        float s = 0.0, t = 0.1 * iTime;\n    \n        for( int k = 1; k < 9; k++)\n        {\n            // adapted from Fabrice Neyret's \"smoothfloor\", https://www.shadertoy.com/view/4t3SD7\n            float q = abs(mod(0.5 * t + 5.5, 12.0) - 6.0) - 3.5;\n            float mm = floor(q);\n            \n            mm += smoothstep(0.0, 1.0, 10.0 * (q - mm) - 9.0) + 7.0;\n            \n            float th = PI * float(k)/mm;\n            s += cos((2.5 + 1.5 * cos(2.0 * t)) * dot(p, vec2(cos(th), -sin(th))) + 4.5 * t) * smoothstep(-0.05, 0.0, mm - float(k));\n        }\n    \n        s = ((int(floor(s)) & 1) == 1) ? 1.0 - fract(s): fract(s);\n        vec3 col = 0.5 + 0.5 * tanh(1.0 - cos(PI * (2.0 * s + vec3(3, 1, -1)/3.0)));\n\n        fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tl3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "3ts3D2", "name": "cychedelic waves", "author": "takumifukasawa", "description": "cychedelic waves", "tags": ["noise", "sin", "hsv", "wavs"], "likes": 2, "viewed": 106, "published": "Public", "date": "1557812696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------------------------------------\n// noise from: https://thebookofshaders.com/12/\n//------------------------------------------------------------------------------------------------------\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//------------------------------------------------------------------------------------------------------\n// hsv2rgb\n// https://qiita.com/keim_at_si/items/c2d1afd6443f3040e900\n//------------------------------------------------------------------------------------------------------\n\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\n//------------------------------------------------------------------------------------------------------\n// contents\n//------------------------------------------------------------------------------------------------------\n\nfloat wave(vec2 st, float c, float s) {\n    float f = smoothstep(c - s, c, st.y) * smoothstep(c, c + s, st.y);\n\treturn 1. - clamp(f, 0., 1.);\n}\n\nfloat waves(vec2 st, float i) {\n\tfloat off = -.04 + i * .075;\n    float wave1 = wave(\n        st + vec2(0., -off + noise(st * 5. + iTime * .6) * .05),\n        sin((st.x + iTime * .15 + .00) * 20.) * .01,\n        .01\n    );\n    float wave2 = wave(\n        st + vec2(0., off + noise(st * 5. + iTime * .6) * .05),\n        sin((st.x + iTime * .15 + .15) * 20.) * .01,\n        .01\n    );\n    return wave1 * (1. - wave2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 16; i++) {\n        vec3 c = hsv2rgb(iTime * .15 + float(i) * .06, .9, .8) * .105;\n        float w = waves(uv, float(i));\n        col += c * w;\n    }\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ts3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 272, 299, 299, 416], [418, 505, 531, 531, 1048], [1331, 1331, 1372, 1372, 1448], [1673, 1673, 1712, 1712, 1816], [1818, 1818, 1849, 1849, 2235], [2237, 2237, 2294, 2294, 2590]], "test": "ok"}
{"id": "3ts3DS", "name": "Five-pointed star, polar form", "author": "tpfto", "description": "Demonstrating a polar equation that generates a five-pointed star.", "tags": ["2d", "math", "star", "polar"], "likes": 5, "viewed": 368, "published": "Public", "date": "1557490840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Polar equation of a star-shaped decagon (pentagram)\n// adapted from Inigo Quilez's shader, https://www.shadertoy.com/view/lsccR8\n\n/*\nfloat sdfStar5( in vec2 p ) // iq's function\n{\n    // repeat domain 5x\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292); // pi/5\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    \n    // draw triangle\n    const vec2 k3 = vec2(0.951056516295,  0.309016994375); // pi/10\n    return dot( vec2(abs(p.x)-0.3,p.y), k3);\n}\n*/\n\nfloat polarStar( in vec2 p )\n{\n    const float pi5 = 0.628318530718; // pi/5\n    const float ph2 = 3.2360679775; // 2 * phi\n    \n    float m2 = mod(atan(p.y, p.x)/pi5 + 1.0, 2.0);\n    \n    return ph2 * length(p) * cos(pi5 * (m2 - 4.0 * step(1.0, m2) + 1.0)) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coords\n    float px = 2.0/iResolution.y;\n\tvec2 q = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    // rotate\n    float t = 0.2 * iTime;\n    q = mat2(cos(t), -sin(t), sin(t), cos(t)) * q;\n\n\t// star shape    \n\tfloat d = polarStar( q );       \n\n    // colorize\n    vec3 col = mix(vec3(0.6, 0.4, 0.8), vec3(0.2, 0.4, 0.6), smoothstep(-2.0 * px, 2.0 * px, d));\n\tcol *= smoothstep(0.02, 0.02 + 2.0 * px, abs(d));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ts3DS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1620, 1620, 1650, 1650, 1886], [1888, 1888, 1945, 1959, 2404]], "test": "ok"}
{"id": "3ts3z2", "name": "stillness illusion", "author": "FabriceNeyret2", "description": "Moves while seeming motionless.  click to see references.\nInspired from [url]https://www.shadertoy.com/view/3ll3z2[/url] + paper [url]http://www.cse.yorku.ca/~kosta/Motion_Without_Movement/Motion_Without_Movement.html[/url]", "tags": ["illusion", "perception", "motionwithoutmovement"], "likes": 0, "viewed": 278, "published": "Public API", "date": "1556958418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://shadertoy.com/view/3ll3z2\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 2.* u / R.y,\n         D = cos(.3*0.-vec2(0,1.57));              // custom dir\n\n    int i =int(U.y/.66);                           // pannel id\n    if (iMouse.z <=0. && i!=1) return;\n    U.y = mod(U.y,.66)-.33;                        // pannel coords\n    \n    float t = 10.*iTime,\n          kl = 100., kr=.05;                       // wavelenght\n    U.x = mod( U.x-t/kl -.5*float(i), 2.) -1.;\n    if (i==2) t = -t;\n    float l = length(U), r = .25,\n          m = smoothstep(-kr,kr,r-l),              // disk mask\n          b = .5-.5*cos(6.28*m),                   // border zone (where effect occurs)\n          x = dot(U,D),                            // pos along D\n          d = x*x+r*r-l*l, s = -x+sign(x)*sqrt(d), // distance to disk in dir D\n        phi =   i>0 ? d > 0. ? kl*s : t            // axial from disk\n              : t;\n    \n    O = vec4( m + .25*b*sin(phi-t) );              // magic draw\n  //O.r += .2+.2*sin(kl*U.x+t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ts3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 81, 81, 1063]], "test": "ok"}
{"id": "3ts3zf", "name": "shadows_v1", "author": "JabberSnatch", "description": "Experimenting with shadow rays and glitch screen effects", "tags": ["sdf", "glitch", "hardshadows"], "likes": 3, "viewed": 105, "published": "Public", "date": "1557159412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ================================================================================\n// MATHS\n// ================================================================================\n\n#define PI 3.1415926535\n\nmat3 rotateX(float alpha)\n{\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(alpha), sin(alpha),\n\t\t0.0, -sin(alpha), cos(alpha)\n\t);\n}\n\nmat3 rotateY(float alpha)\n{\n\treturn mat3(\n\t\tcos(alpha), 0.0, -sin(alpha),\n\t\t0.0, 1.0, 0.0,\n\t\tsin(alpha), 0.0, cos(alpha)\n\t);\n}\n\n// ================================================================================\n// PRIMITIVES\n// ================================================================================\n\nfloat sdCube(vec3 p, float side)\n{\n\tvec3 rm_dist = abs(p) - vec3(side * 0.5);\n\tvec3 sqrRmDist = rm_dist * rm_dist;\n\treturn max(rm_dist.x, max(rm_dist.y, rm_dist.z)) -\n\t\t   sqrt(abs(sqrRmDist.x + sqrRmDist.y + sqrRmDist.z)) * 0.5;\n}\n\nfloat sdOctahedron(vec3 p, float side)\n{\n\tvec3 rm_dist = abs(p) - vec3(side * 0.5);\n\treturn (rm_dist.x + rm_dist.y + rm_dist.z) / 3.0;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat stride = 3.0;\n    vec3 cp = vec3(3.0, 3.0, 5.0);\n\tp.x = mod(p.x - cp.x + stride, stride*2.0) - stride + cp.x;\n\tp.y = mod(p.y - cp.y + stride, stride*2.0) - stride + cp.y;\n    p.z = mod(max(p.z, 0.0), stride*4.0);\n\n\tfloat time = iTime * 10.0;\n\tfloat x_angle = mod(time, 360.0) * PI / 180.0;\n\tfloat y_angle = mod(time, 360.0) * PI / 180.0;\n\tmat3 local_space = inverse(rotateX(x_angle) * rotateY(y_angle));\n\tmat3 static_rotation = rotateX(PI / 4.0) * rotateY(PI / 4.0);\n\n    return sdCube(local_space * (p - cp), 2.0);\n}\n\nvec3 scene_color(vec3 p)\n{\n\treturn vec3(0.2, 0.3, 0.5) * 2.0;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.0001;\n\treturn normalize(\n\t\t   vec3(scene(p + vec3(delta, 0.0, 0.0)) - scene(p - vec3(delta, 0.0, 0.0)),\n\t\t   \t\tscene(p + vec3(0.0, delta, 0.0)) - scene(p - vec3(0.0, delta, 0.0)),\n\t\t\t\tscene(p + vec3(0.0, 0.0, delta)) - scene(p - vec3(0.0, 0.0, delta))));\n}\n\n// ================================================================================\n// RAYCASTING\n// ================================================================================\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\n// ================================================================================\n// LIGHTING\n// ================================================================================\n\nfloat fresnel_term(vec3 l, vec3 n, float ior_out, float ior_in)\n{\n\tfloat c = abs(dot(-l, n));\n\tfloat g_squared = ((ior_in * ior_in) / (ior_out * ior_out)) - 1.0 + (c * c);\n\tif (g_squared < 0.0) return 1.0;\n\tfloat g = sqrt(g_squared);\n\tfloat gmc = g - c;\n\tfloat gpc = g + c;\n\tfloat T0 = c*gpc - 1.0;\n\tfloat T1 = c*gmc + 1.0;\n\tfloat result = 0.5 * ((gmc * gmc)/(gpc * gpc)) * (1.0 + ((T0 * T0) / (T1 * T1)));\n\treturn result;\n}\n\n// ================================================================================\n// MAIN\n// ================================================================================\n\n#define SHADOW_RAYS\nconst int kMaxStep = 256;\nconst int kShadowStep = 64;\nconst float kStepMultiplier = 1.0;\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    if (floor(mod(iTime * 6.0, 3.0)) <= 1.0 &&\n       floor(mod(iTime * 0.5, 2.0)) == 0.0 &&\n       floor(mod(iTime * 0.8, 2.0)) == 0.0)\n    {\n        if (floor(mod(frag_coord.y, 15.0 * (sin(iTime * 5.0) + 2.0))) < 1.0 ||\n           floor(mod(frag_coord.y, 17.0)) < 2.0)\n           frag_coord.x += 10.0 * (sin(iTime * 100.0) + 1.0);\n    }\n\n\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 60.0 * PI / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_hfov(near, fov, aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\tvec3 ray = compute_ray_plane(half_diagonal, clip_coord);\n    ray = rotateX(-sin(iTime) * PI / 64.0) * ray;\n\n\tvec3 position = vec3(cos(iTime), 0.0, -20.0);\n    vec3 start_pos = position;\n\tfloat rm_dist = scene(position);\n\n    int rm_step = 0;\n\tfor (; rm_step < kMaxStep; rm_step++)\n\t{\n\t\tposition += ray * rm_dist * kStepMultiplier;\n\t\trm_dist = scene(position);\n        if (rm_dist < 0.005)\n           break;\n\t}\n\n\tvec3 bg_color = vec3(0.2);\n\n\tfloat light_intensity = 5.0;\n\tvec3 lp = vec3(sin(iTime) * 7.0, cos(iTime) * 7.0, 3.0);\n\n\tvec3 n = normal(position);\n\tvec3 l = normalize(lp - position);\n\tfloat Li = dot(n, l) * light_intensity / distance(lp, position);\n\tfloat F = fresnel_term(l, n, 1.0, 2.0);\n\tvec3 base_color = scene_color(position);\n\n#ifdef SHADOW_RAYS\n    vec3 sp = lp;\n    int srm_step = 0;\n    float srm_dist = scene(sp);\n\tfor (; srm_step < kShadowStep; srm_step++)\n\t{\n\t\tsp -= l * srm_dist;\n        srm_dist = scene(sp);\n        if (srm_dist < 0.005)\n           break;\n   \t}\n\tfloat occlusion = clamp(1.0 - distance(position, sp), 0.0, 1.0);\n    occlusion += 1.0 - step(srm_dist, 0.1);\n    occlusion = min(occlusion, 1.0);\n#else\n    float occlusion = 1.0;\n#endif\n\n\tfrag_color.xyz = base_color * (Li * (1.0 + F)) * occlusion;\n    if (floor(mod(iTime * 6.0, 3.0)) <= 1.0 &&\n       floor(mod(iTime * 0.5, 2.0)) == 0.0 &&\n       floor(mod(iTime * 0.8, 2.0)) == 0.0)\n    {\n        frag_color.xyz = vec3((float(rm_step) / float(kMaxStep)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ts3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 230, 230, 329], [331, 331, 358, 358, 457], [642, 642, 676, 676, 873], [875, 875, 915, 915, 1011], [1013, 1013, 1046, 1046, 1071], [1073, 1073, 1094, 1094, 1619], [1621, 1621, 1647, 1647, 1684], [1686, 1686, 1707, 1707, 1981], [2166, 2166, 2234, 2234, 2362], [2364, 2364, 2425, 2425, 2508], [2691, 2691, 2756, 2756, 3115]], "test": "error"}
{"id": "3tsGDf", "name": "kali-doze-cope", "author": "StrangerintheQ", "description": "kali fractal colored // use mouse to change it", "tags": ["kalifractal"], "likes": 6, "viewed": 79, "published": "Public", "date": "1557923068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float n){return fract(sin(n) * 43758.54523);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fract(p));\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n \n    p = (p + p - iResolution.xy) / iResolution.y;\n    vec2 m = vec2(-iTime/2. , iTime/3.);\n    vec2 noised = vec2(noise(m.x), noise(m.y))/2.;\n    for(int i = 0; i < 11; i++)\n        p = abs(p) / dot(p,p) - noised-iMouse.xy/iResolution.xy*0.5;\n    \n    fragColor = vec4(noise(p.x)*p.y, noise(p.y)*p.x, noise(p.x+p.y),1.);\n         \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 56], [58, 58, 79, 79, 152], [156, 156, 205, 205, 540]], "test": "ok"}
{"id": "3tSGRD", "name": "yet another mandelbrot zoomer", "author": "biki73", "description": "nothing to see here, move along.", "tags": ["fractal", "mandelbrot"], "likes": 5, "viewed": 126, "published": "Public", "date": "1558609438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 Iter(vec2 ab,float zoom,vec2 trapp) {\nint i;\n    vec2 xy;\n    vec2 xy2;\n    vec2 trp;\n    xy=vec2(0,0);\n    xy2=vec2(0,0);\n    float trap=1e30;\n    float lxy;\n    float t;\n    for (i=0;i<1024;i++) {\n       xy2=vec2(2.0*(xy.x*xy2.x-xy.y*xy2.y)+1.0,2.0*(xy.x*xy2.y+xy.y*xy2.x));\n       xy=vec2(xy.x*xy.x-xy.y*xy.y+ab.x,2.0*xy.x*xy.y+ab.y);\n       trp=xy-trapp;\n       t=dot(trp,trp);\n       if (t<trap) trap=t;\n       if (length(xy)>10000.0) break;\n    }\n    if (i==1024) return vec4(0,0,0,0);\n    lxy=length(xy);\n    float dis2=2.0*zoom*(lxy/length(xy2))*log(lxy);\n    dis2=clamp(dis2,0.0,1.0);\n    float clr=0.1*(float(i)-((log(lxy)/log(10000.0))-1.0));\n    clr=10.0*sqrt(trap);\n    vec4 color=dis2*(vec4(0.5,0.5,0.5,0)+0.5*vec4(cos(clr),cos(clr*3.0),cos(clr*7.0),1.0));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n float zoom=1000000.0*exp(-0.1+3.5*sin(iTime*0.3));\n float rot=iTime*0.5;\n vec2 center=vec2(-0.7490,0.1006+0.0002*sin(iTime*0.0423));\n vec2 trap=vec2(-1.0+0.2*sin(iTime*4.0),-1.0+0.2*cos(iTime*4.0));\n vec2 xy=(fragCoord-(iResolution.xy/2.0))/zoom;\n\n vec2 xy2=center+vec2(xy.x*cos(rot)-xy.y*sin(rot),xy.x*sin(rot)+xy.y*cos(rot));\n fragColor = Iter(xy2,zoom,trap);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[797, 797, 854, 854, 1219]], "test": "ok"}
{"id": "3tsGWB", "name": "Snake Donut", "author": "z0rg", "description": "Don't judge the code, i did it a while ago :p", "tags": ["raymarching", "bezier", "donut"], "likes": 4, "viewed": 179, "published": "Public API", "date": "1557495717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat minDotSize = 0.005;\nfloat maxDotSize = 0.01;\nfloat dotSpacing = 0.02;\nint marchSteps = 64;\nfloat marchDist = 12.0;\nconst int bezierSphCnt = 15;\nvec3 bezierCol = vec3(0.978, 0.13, 0.57);\n\nfloat EPS = 0.0001;\n\nstruct bezier\n{\n  vec3 p0;\n  vec3 p1;\n  vec3 p2;\n  vec3 p3;\n};\nfloat sat(float a)\n{\n    return clamp(a, 0.0,1.0);\n}\nvec3 sat(vec3 v)\n{\n    return vec3(sat(v.x), sat(v.y), sat(v.z));\n}\n    \nvec2 rot(vec2 v, float a)\n{\n    float cosa=cos(a);float sina=sin(a);\n    mat2 r=mat2(cosa,-sina,sina,cosa);\n    return v*r;\n}\n\nvec3 calculateBezierPoint(bezier bz, float t)\n{\n  float oneMt = 1.0 - t;\n\n  return bz.p0 * pow(oneMt,3.0) +\n     3.0 *bz.p1*t*pow(oneMt,2.0) +\n       3.0*bz.p2*t*t*oneMt +\n         bz.p3*t*t*t;\n}\n\nfloat sdf_sphere(vec3 p, vec3 orig, float rad)\n{\n  return distance(p, orig) - rad;\n}\n\nfloat sdf_torus(vec3 p, vec3 orig, vec2 size)\n{\n  vec3 pt = p-orig;\n  vec2 q = vec2(length(pt.xz)-size.x,pt.y);\n  return length(q)-size.y;\n}\n\nfloat sdf_union(float d1, float d2)\n{\n  return min(d1,d2);\n}\n\nvec3 sdf_torus_normal(vec3 p, vec3 o, vec2 s)\n{\n  vec3 xeps = vec3(EPS, 0.0, 0.0);\n  vec3 yeps = vec3(0.0, EPS, 0.0);\n  vec3 zeps = vec3(0.0, 0.0, EPS);\n  vec3 n = vec3(sdf_torus(p+xeps, o, s) - sdf_torus(p-xeps, o, s),\n    sdf_torus(p+yeps, o, s) - sdf_torus(p - yeps, o, s),\n    sdf_torus(p+zeps, o, s) - sdf_torus(p- zeps, o, s));\n  return normalize(n);\n}\n\n\nvec2 render(vec2 uv, vec3 orig, vec3 dir)\n{\n  float gradient = clamp(0.0,1.0, sin(uv.y));\n  vec3 p = orig;\n\nvec3 light = vec3(5.0*sin(iTime), 5.0*cos(iTime),0.0);\n  int step = 0;\n  float totalDist = 0.0;\n  while (step < marchSteps && totalDist < marchDist)\n  {\n    float d = sdf_torus(p, vec3(0.0), vec2(2.0, 1.0));\n    //float d = sdf_sphere(p, vec3(0.0), 2.0);\n    if (d < EPS)\n    {\n      vec3 n = sdf_torus_normal(p, vec3(0.0), vec2(2.0, 1.0));\n      return vec2(dot(n, p-light)*0.2 + 0.2,totalDist+d);\n    }\n    p += dir * d;\n    step++;\n    totalDist += d;\n  }\n\n  return vec2(gradient,0.0);\n}\n\nvec4 renderAsDot(vec2 uv, vec2 center, float angle, vec3 orig, vec3 vec)\n{\n  float cosA = cos(angle);\n  float sinA = sin(angle);\n  mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n  uv -= center;\n  vec2 rdrV = render(uv, orig, vec);\n  float curSize = mix(minDotSize, maxDotSize, rdrV.x);\n  uv = uv * rot;\n  vec2 uvMod = mod(uv, dotSpacing);\n  float size = minDotSize;\n  return vec4(sat(vec3(-(length(uvMod-(dotSpacing/2.0))-curSize)/size)*5.),rdrV.y);\n}\n\nvec4 renderBezier(vec2 uv, vec3 orig, vec3 dir)\n{\n  bezier bz;\n  vec3 bezierPts[bezierSphCnt];\n  float distSph[bezierSphCnt];\n  vec3 p = orig;\n  vec3 off = vec3(2.0,0.0,0.0);\n  float cosA = cos(-0.3);\n  float sinA = sin(-0.3);\n  float exce = 1.9;\n  mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n  bz.p0 = off + vec3(sin(iTime), cos(iTime), 0.0)*exce;\n  bz.p1 = off + vec3(sin(iTime+1.0), cos(iTime+1.0), 0.0)*exce;\n  bz.p2 = off + vec3(sin(iTime+2.0), cos(iTime+2.0), 0.0)*exce;\n  bz.p3 = off + vec3(sin(iTime+3.0), cos(iTime+3.0), 0.0)*exce;\n\n  vec2 p02 = bz.p0.xz * rot;\n  vec2 p12 = bz.p1.xz * rot;\n  bz.p0 = vec3(p02.x, bz.p0.y, p02.y);\n  for (int iBz = 0; iBz < bezierSphCnt; ++iBz)\n    bezierPts[iBz] = calculateBezierPoint(bz, float(iBz) / float(bezierSphCnt));\n\n  int step = 0;\n  float totalDist = 0.0;\n  while (step < marchSteps && totalDist < marchDist)\n  {\n    float nearest = -1.0;\n    int idxHit = -1;\n    for (int iBz = 0; iBz < bezierSphCnt; ++iBz)\n    {\n      float d = sdf_sphere(p, bezierPts[iBz], 0.2);\n      if (idxHit == -1 || (d < nearest))\n      {\n        nearest = d;\n        idxHit = iBz;\n      }\n    }\n    if (nearest < EPS)\n    {\n    //  vec3 n = sdf_torus_normal(p, vec3(0.0), vec2(2.0, 1.0));\n      return vec4(bezierCol,totalDist+nearest);//dot(n, p-light)*0.2 + 0.2;\n    }\n    p += dir * nearest;\n    step++;\n    totalDist += nearest;\n  }\n  return vec4(0.0);\n}\n\nvec3 renderAnim(vec2 uv, vec2 center, vec3 orig, vec3 vec)\n{\n  float theta = 3.1415927 * sin(0.1*iTime);\n  float way = (sin(iTime)-sin(iTime+0.1))*0.1;\n  vec4 outCol = renderAsDot(uv,center,theta, orig, vec);\n    \n  vec4 bzCol = renderBezier(uv - center, orig, vec);\n  if (outCol.w < EPS)\n    return bzCol.xyz;\n  if(bzCol.w < EPS || outCol.w < bzCol.w)\n     return outCol.xyz;\n  return bzCol.xyz;\n}\n\nvec3 negate(vec3 c)\n{\n  return vec3(1.0) - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float ratio = iResolution.x/iResolution.y;\n  uv = vec2(uv.x * ratio, uv.y);\n\n\n  vec3 origin =vec3(0.0, 10.0, 0.0);\n  vec3 vec = vec3(1.0, 0.0, 0.0);\n  vec3 rightVec = vec3(0.0,0.0,-1.0);\n  vec3 upVec = vec3(0.0,1.0,0.0);\n\n  float yaw = 3.1415927/2.0;\n  float pitch = 0.0;\n\n  float cosYaw = cos(yaw);\n  float sinYaw = sin(yaw);\n  float cosPitch = cos(pitch);\n  float sinPitch = sin(pitch);\n\n  mat3 rotY = mat3(cosPitch,  0.0, sinPitch,\n                   0.0, 1.0, 0.0,\n                   -sinPitch,  0.0, cosPitch);\n  mat3 rotZ = mat3(cosYaw, -sinYaw, 0.0,\n                   sinYaw, cosYaw, 0.0,\n                   0.0,  0.0, 1.0);\n  vec2 center = vec2(0.5*ratio, 0.5);\n  vec2 cuv = uv -center;\n    cuv *= sin(iTime)*0.5+1.;\n    cuv = rot(cuv, -iTime*0.5);\n  vec = rotZ * (rotY * (vec + rightVec * cuv.x + upVec * cuv.y));\n  vec = normalize(vec);\n\n    \n  vec3 col = renderAnim(uv,center, origin, vec);\n    col += vec3(0.22,0.12,0.42)*pow(1.-length(cuv),0.5);\n  fragColor = vec4((col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsGWB.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[674, 674, 694, 694, 726], [727, 727, 745, 745, 794], [800, 800, 827, 827, 925], [927, 927, 974, 974, 1122], [1124, 1124, 1172, 1172, 1208], [1210, 1210, 1257, 1257, 1350], [1352, 1352, 1389, 1389, 1412], [1414, 1414, 1461, 1461, 1772], [1775, 1775, 1818, 1818, 2373], [2375, 2375, 2449, 2449, 2821], [2823, 2823, 2872, 2872, 4210], [4212, 4212, 4272, 4272, 4610], [4612, 4612, 4633, 4633, 4659], [4661, 4661, 4718, 4718, 5757]], "test": "ok"}
{"id": "3tSGWz", "name": "Happy Cactus", "author": "Del", "description": "happy cactus! - made some changes / improvements - use mouse to look around.", "tags": ["noise", "raymarch", "sdf", "animation", "trippy", "happy", "cactus"], "likes": 12, "viewed": 649, "published": "Public API", "date": "1559001827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Happy Cactus - Del - 27/05/2019\n// mouthblend / eye / arm updates 03/06/2019\n\n#define PI 3.14159\n#define\tTAU 6.28318\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    vec2 mouse2 = vec2(0.0);\n    \n    mouse2.y = 0.25;\n    mouse2.x = sin(time*0.75)*0.05;\n    if (iMouse.z > 0.5)\n    {\n        mouse2 = mouse;\n        mouse2.y -= 0.1;\n    }\n    float an = 10.0*mouse2.x;\n\tcamPos = vec3(7.5*sin(an),0.0+mouse2.y*8.0,7.5*cos(an));\n    camTar = vec3(0.0,sin(iTime*0.85),0.0);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//------------------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r)\n{\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v )\n{\n    return dot(v,v);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 opUnionRound(const in vec2 a, const in vec2 b, const in float r)\n{\n    vec2 res = vec2(smin(a.x,b.x,r),(a.x<b.x) ? a.y : b.y);\n    return res;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nfloat TimerInOut(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n\n// model\nvec2 pot(vec2 res, vec3 p)\n{\n    float rimh = 0.05;\n    float poth = 1.7;\n   \tfloat d2 = sdCappedCylinder(p+vec3(0.0,rimh,0.0),vec2(2.1,rimh))-0.05;\n   \tfloat d3 = sdCappedCone(p+vec3(0.0,poth,0.0), poth, 1.6,2.1);\n    d2 = onion(d2-0.8,0.02);\n    d3 = onion(d3-0.8,0.02);\n    d2 = smin(d2,d3,0.15);\n    d2 = max( d2, p.y+0.05 );\n\tvec2 res1 = vec2(d2,3.0);\n    // dirt\n   \tfloat d4 = sdCappedCylinder(p+vec3(0.0,0.4,0.0),vec2(2.65,0.02));\n    vec2 res2 = vec2(d4,1.0);\n\tres1 = opUnionRound(res1,res2,0.6);     \n \tres = opUnionRound(res,res1,0.15);  \n    return res;\n}\n\nfloat mouthblend = 0.0;\nfloat blink = 0.0;\n\nvec2 sdCactusXZ(vec3 p, float w, float h, float offset)\n{\n    float d1 = sdEllipsoid(p,vec3(w,h,w));\n\td1+=abs(sin(atan(p.x/p.z)*8.0)*(offset*(h-abs(p.y))));\n    return vec2(d1,2.0);\n}\nvec2 sdCactusXY(vec3 p, float w, float h, float offset)\n{\n    float d1 = sdEllipsoid(p,vec3(h,w,w));\n\td1+=abs(sin(atan(p.z/p.y)*8.0)*(offset*(h-abs(p.x))));\n    return vec2(d1,2.0);\n}\n\nvec2 Arm(vec3 p)\n{\n\tvec2 a1 = sdCactusXY(p-vec3(1.4,0.2,0.0),0.35,1.0,0.0125);\n\tvec2 a2 = sdCactusXZ(p-vec3(2.1,1.0,0.0),0.35,1.0,0.0125);\n    return opUnionRound(a1,a2, 0.15);\n}\n\n\nvec2 doModel( vec3 p )\n{\n    p-=vec3(0.0,0.7,0.0);\n    \n    // body\n\tvec2 res = sdCactusXZ(p,1.3,2.6, 0.0225);\n    // arms\n \tres = opUnionRound(Arm(p),res, 0.15);    \n    vec3 p2 = p;\n    p2.x = -p2.x;\n \tres = opUnionRound(Arm(p2-vec3(0.0,0.7,0.0)),res, 0.15);\n    \n    // mouth\n    vec3 q = p;\n    q.x = abs(q.x);\n    q.yz *= rot(-pow(q.x, 2.8));\n    q.z -= 1.25;\n    vec2 mouth1 = vec2(sdCapsule(q, vec3(0.35, 0.0, 0.0), vec3(-0.35, 0.0, 0.0), .025)-0.115, 4.0);\n\n    mouth1.x = mix(sdSphere(q,0.25),mouth1.x,mouthblend);\n    res = opS(mouth1,res);\n        \n\t// eyes    \n    p.x = abs(p.x);\n    float d2 = sdSphere(p+vec3(-0.3,-1.0,-1.1),0.2);\n    res = opUnionRound(vec2(d2,5.0),res, 0.025);\n    // pot\n\tres = pot(res,p+vec3(0.0,1.1,0.0));\n    return res;\n}\n\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\n// c.a == specular val fudged in...\n\nvec4 EyeTest(vec3 n)\n{\n    n = normalize( n );\n    n.zy *= rot(sin(iTime*1.15)*0.3);\n    vec2 uv = vec2(atan(n.z,n.x) / TAU, asin(n.y) / TAU);\n    uv.x -= 0.25;\n    float d1 = length(uv)-0.02;\t\n    float d2 = smoothstep(0.0,0.02, d1-0.05);\n    d1 = smoothstep(0.0,0.02, d1);\n    vec3 col = vec3(0.05,0.15,0.4)*d1;\n    col = mix(col,vec3(0.24,0.24,0.24),d2);\n    return blink > 0.0 ? vec4(col.xyz,2.0) : vec4(0.03,0.2,0.05,0.25);\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\nvec4 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=2.0)\n    {\n\t\tvec3 q = pos*12.0;\n\t\tfloat f  = 0.5*noise( q ); q = m*q;\n\t\tf += 0.2500*noise( q ); q = m*q;\n\t\tf += 0.1250*noise( q ); q = m*q;\n\t\tf += 0.0625*noise( q ); q = m*q;        \n        if (c<=1.0)\n\t\t\treturn vec4(0.08, 0.05, 0.03,0.1)*f;\t// dirt\n        f=0.5+(f*0.4);\n        return vec4(0.03,0.2,0.05,0.5)*f;\t\t\t// cactus\n    }\n    else if (c<=3.0)\n    {\n\t\treturn vec4(0.2, 0.06, 0.03,0.4);\t// pot\n    }\n    else if (c<=4.0)\n    {\n\t\treturn vec4(0.1, 0.08, 0.03, 0.8);\t// mouth\n    }\n    \n    return EyeTest(nor);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.7,0.875,0.89));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n\tfloat spec = pow(dif, 160.0) *mat.a;\n    \n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mat.xyz*lin;\n    col+=spec;\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.002*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<60; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h*0.95;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 background(vec2 pos)\n{\n    pos.x = abs(pos.x);\n    float d = length(pos*pos);\n    pos+=vec2(0.5);\n\tfloat vv = pos.y*pos.y;\n\tvv+=sin(exp(1.0-pos.x));\n\tfloat v = sin(sin(pos.x*16.0)+(vv+iTime*.1) * 42.0)+0.95;\n    v*=0.9-d*d;\n    \n    v = clamp(v,0.1,1.0);\n    \n\treturn vec3( v*1.1,0.05+v*.6, 0.2+v*0.45);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // anims\n    blink = step(sin(iTime * 2.8 + cos(iTime * 2.0) * 2.0), 0.98);\n\tmouthblend = TimerInOut(vec4(mod(iTime,4.5),0.0,3.7,0.3));\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, sin(iTime)*0.25 );\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n  \t//vec3 col = mix( vec3(0.2, 0.2, 0.5), vec3(0.5, 0.7, 1.0), fragCoord.y / iResolution.y );\n    vec3 col = background((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec4 mat = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mat );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 202, 202, 512], [683, 683, 718, 718, 742], [860, 860, 902, 902, 1001], [1003, 1003, 1028, 1028, 1051], [1053, 1053, 1124, 1124, 1457], [1459, 1459, 1511, 1511, 1638], [1640, 1640, 1661, 1661, 1729], [1731, 1731, 1772, 1772, 1865], [2018, 2018, 2048, 2048, 2100], [2102, 2102, 2128, 2128, 2200], [2202, 2202, 2241, 2241, 2264], [2266, 2275, 2303, 2303, 2842], [2888, 2888, 2945, 2945, 3071], [3072, 3072, 3129, 3129, 3255], [3257, 3257, 3275, 3275, 3435], [3438, 3438, 3462, 3462, 4198], [4585, 4585, 4607, 4607, 5015], [5017, 5017, 5037, 5037, 5132], [5134, 5134, 5160, 5160, 5634], [5762, 5762, 5815, 5815, 6347], [6560, 6560, 6644, 6644, 7304], [7306, 7306, 7355, 7355, 7856], [7858, 7858, 7890, 7890, 8310], [8312, 8312, 8360, 8360, 8788], [8790, 8790, 8854, 8854, 9032], [9034, 9034, 9061, 9061, 9348], [9350, 9350, 9407, 9407, 10777]], "test": "error"}
{"id": "3tX3WX", "name": "asfagf", "author": "theepicsnail", "description": "adfadfadf", "tags": ["afadfadf"], "likes": 2, "viewed": 50, "published": "Public", "date": "1557788617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.141592\n#define TAU 6.283184\n\n\nvec2 cs(float a){\n    return vec2(cos(a),sin(a));\n}\n\nvec2 rot(vec2 v, float a) {\n    vec2 c = cs(a);\n    return v * mat2x2(c.x, -c.y, c.y, c.x);\n}\n\nvec2 sp(float t){\n    return vec2(floor(t), fract(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfragColor.b=0.;\n    for(float i = 0. ; i < 6. ; i++) {\n\t    vec2 t = sp(iTime*.15 - i*.1);\n\t    vec4 c = vec4(\n\t        rand(vec2(t.x, i+0.))*2.0-1.0,\n\t        rand(vec2(t.x, i+1.))*2.0-1.0,\n\t        rand(vec2(t.x, i+2.))*0.5+0.5,\n            rand(vec2(t.x, i+3.))*2.0-1.0\n\t    );\n\t    \n        c.w = mod(t.x, 2.)*2.-1.;\n\t    \n\t    uv -= c.xy;\n        if(length(uv)<c.z) {\n\t        uv = rot(uv, smoothstep(0.,1.,t.y)*TAU*sign(c.w));\n        } else if(length(uv)<c.z+.01) {\n            fragColor.b+=sin(t.y*PI);\n        }\n        uv += c.xy;\n    }\n    \n    fragColor = texture(iChannel0, uv)+fragColor.b;\n    //fragColor.g =1.0-20.*rand(floor(uv*150.0));\n    //fragColor = max(fragColor, vec4(fragColor.g));\n    return;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 61, 61, 95], [97, 97, 124, 124, 190], [192, 192, 209, 209, 248], [250, 250, 270, 270, 340], [351, 351, 408, 408, 1189]], "test": "error"}
{"id": "3tXGDB", "name": "Tunnel and wave", "author": "Tezza48", "description": "Testing Sound and API", "tags": ["tunnel", "sound"], "likes": 3, "viewed": 363, "published": "Public API", "date": "1557424603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 nUV = fragCoord / iResolution.xy;\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n\tuv.x += cos(iTime) * 0.3;\n    uv.y += -sin(iTime) * 0.3;\n    \n    int tx = int(nUV * 512.0);\n    int ty = int(nUV * 512.0);\n    \n    float fft = texelFetch(iChannel0, ivec2(tx, 0.0), 0).x;\n    float wave = texelFetch(iChannel0, ivec2(ty, 1), 0).x;\n    \n    float a = atan(uv.x/uv.y);\n    float r = length(uv);\n    \n    vec2 polar = vec2(0.25 / r + iTime + (fft * 0.5), (a / (2.0 * 3.14)) + (iTime * 0.2) + (fft * 0.05));\n    \n    ivec2 iCoord = ivec2(mod(polar * 512.0, 256.0));\n    float xor = float(iCoord.x ^ iCoord.y) / 256.0;\n    \n    float d = smoothstep(0.01, 0.03, abs(wave - nUV.y));\n    \n    vec3 tunnelCol = vec3(xor) * pow(length(uv), 0.8);\n    \n    // Output to screen\n    fragColor = vec4(mix(tunnelCol, vec3(uv, 0.5), 1.0 - d),1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 972]], "test": "error"}
{"id": "3tXGDs", "name": "Night Stroll", "author": "ShnitzelKiller", "description": "Somewhere, a rover has a restless night.", "tags": ["voronoi", "space", "moon", "night", "rover"], "likes": 7, "viewed": 376, "published": "Public API", "date": "1557995883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HEIGHT 0.8\n#define SCALE 0.25\n#define FDIST 0.5\n#define GRADIENT_EPS 0.01\n#define ITERS 30\n#define TOL 0.01\n#define LEVELS 4\n#define CRATER_RADIUS 0.15\n#define CRATER_HEIGHT 35.\n#define CRATER_SCALE 0.05\n#define CRATER_LEVELS 2\n#define SPEED 2.\n\nvec2 noise2D(vec2 uv) {\n    vec2 k = vec2(2234.4, 18100.1);\n    return fract(k*sin(dot(k, uv)));\n}\n\nfloat noise1D(float t) {\n    return fract(14950.5*sin(1905.1*t));\n}\n\nfloat cubemix(float a, float b, float t) {\n    float c = t*t*(3.-2.*t);\n    return mix(a, b, c);\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    int i;\n    int j;\n    float d = 2.;\n    for (i=-1;i<=1;i++) {\n        for (j=-1;j<=1;j++) {\n            d = min(d, length(fuv-vec2(i,j)-noise2D(iuv+vec2(i,j))));\n        }\n    }\n    \n    return d*d;\n}\n\nfloat voronoifract(vec2 uv) {\n    float d = 0.;\n    int i;\n    float fac = 1.;\n    for (i=0; i<LEVELS; i++) {\n        d += fac*voronoi(uv);\n        uv *= 4.;\n        fac *= 0.25;\n    }\n    return d;\n}\n\nfloat craters(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 pos = noise2D(iuv)*(1.-2.*CRATER_RADIUS)+CRATER_RADIUS;\n    float d = length(pos-fuv);\n    d*=d;\n    return min(d, CRATER_RADIUS*CRATER_RADIUS)-CRATER_RADIUS*CRATER_RADIUS;\n}\n\nfloat cratersfract(vec2 uv) {\n    float d = 0.;\n    int i;\n    float fac = 1.;\n    for (i=0; i<CRATER_LEVELS; i++) {\n        d += fac*craters(uv);\n        uv *= 8.;\n        fac *= 0.125;\n    }\n    return d;\n}\n\nfloat map(vec3 pos) {\n    float h = pos.y;\n    h -= HEIGHT*voronoifract(pos.zx*SCALE);\n    h -= CRATER_HEIGHT*cratersfract(pos.zx*CRATER_SCALE);\n    return h;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float d=0.;\n    int i;\n    for (i=0; i<ITERS; i++) {\n        float dist = map(ro+d*rd);\n        d += dist;\n        if (dist < TOL) {\n\t\t\treturn vec2(d, 1.);\n        }\n    }\n    return vec2(d, 0.);\n}\n\nvec3 gradient(in vec3 pos) {\n    vec3 offset = vec3(-GRADIENT_EPS, 0.0, GRADIENT_EPS);\n    float dx0 = map(pos+offset.xyy);\n    float dxf = map(pos+offset.zyy);\n    float dy0 = map(pos+offset.yxy);\n    float dyf = map(pos+offset.yzy);\n    float dz0 = map(pos+offset.yyx);\n    float dzf = map(pos+offset.yyz);\n    return normalize(vec3(dxf - dx0, dyf - dy0, dzf - dz0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = SPEED*iTime;\n    float height1 = -map(vec3(0.,0.,t));\n    float height2 = -map(vec3(0.,0.,t-0.2));\n    vec3 ro = vec3(0., 3.+0.11*(height1+height2), t);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 w = normalize(vec3(0., -0.7+0.11*(height1-height2), 1.));\n    vec3 u = cross(w, up);\n    vec3 v = cross(u, w);\n    vec2 coord = fragCoord/iResolution.xy-0.5;\n    vec3 rd = normalize(w*FDIST+u*coord.x+v*coord.y);\n    \n    vec2 d = raymarch(ro, rd);\n    vec3 n = gradient(ro+d.x*rd);\n    vec3 col = vec3(pow(dot(rd, w), 10.)*dot(n, -rd));\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 277, 277, 352], [354, 354, 378, 378, 421], [423, 423, 465, 465, 521], [523, 523, 547, 547, 804], [806, 806, 835, 835, 1006], [1008, 1008, 1032, 1032, 1268], [1270, 1270, 1299, 1299, 1478], [1480, 1480, 1501, 1501, 1640], [1642, 1642, 1675, 1675, 1877], [1879, 1879, 1907, 1907, 2250], [2252, 2252, 2309, 2309, 2891]], "test": "ok"}
{"id": "3tXGRX", "name": "SonOfAnotherRaymarchPracticeJr", "author": "bignobody", "description": "Third generation of my practice raymarcher. ollj sassed me and hit me with the clue-stick because I was doing reflections a stupid way. This one is smarter, faster and has no limits on the number of reflections. It does crash my WebGL sometimes, though.", "tags": ["raymarch", "reflections"], "likes": 3, "viewed": 176, "published": "Public", "date": "1557009341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the previous generation https://www.shadertoy.com/view/WsfSDB\n// Thanks as always to iq, Jamie Wong, BigWIngs (Art of Code) for the tutorials\n// Special thanks to ollj for the motivation and direction.\n// -----------------------------------------------------------------------------\n// Update: Fixed bug in the reflections (wasn't updating the correct cam origin variable)\n// Limited the number of reflection bounces to 20 for safety.\n// Update: Fixed shadow march logic. I was trying to march from the light to the surface instead of from the surface towards the light\n\n#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\nvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float d = sdfPlane(p,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n    float so = opUnion( sdfBox(p, vec3(0.0), vec3(4.0,6.0,1.0)), sdfBox(p, vec3(0.0), vec3(1.0,6.0,4.0)) );\n    if (so < d)\n    {\n        pick = 2;\n        d = so;\n    }\n    \n    float offset = 0.0;\n    float offset2 = 0.0;\n    float offsetinc = 6.28318 / float(NUM_SPHERES);\n\t\n\tfor (int s = 0; s < NUM_SPHERES; s ++)\n    {\n        so = sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0);\n\t\toffset += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n        so = sdfSphere(p,vec3(8.5 * cos(-iTime+offset2),0.95*cos(-iTime*offset2 * 0.33),8.5 * sin(-iTime+offset2)),1.2);\n\t\toffset2 += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n    }\n\n    return d;\n    \n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(-8.0 * cos(iTime * 0.25),3.5,-8.0 * sin(iTime * 0.25)),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(surfacePoint,lightOrigin);\n    for( float s=0.01; s < end; )\n    {\n        vec3 marchStep = surfacePoint + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.00085)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n//    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1),6.5 * cos(iTime * 0.5)+4.2,-10.0 * sin(iTime * 0.1));\n    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1),6.5 * cos(iTime * 0.5)+4.2,-10.0 * sin(iTime * 0.1));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const float MAX_DISTANCE = 500.0;\n    const float CLOSE_ENOUGH = 0.001;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n\tfloat bounceCount = 0.0;\n\tfloat refMixVal = 0.35; // don't start with a solid mix\n//initialize with sky colour\n    pickTarget = 0;\n\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n\n\tfor (marchDistance = 0.0; marchDistance < MAX_DISTANCE;)\n\t{\n\t\tmarchStep = marchVec + rayDirection * marchDistance;\n\t    distNow = distanceToClosest(marchStep, pickTarget);\n\n\t\tmarchDistance += distNow;        \n\t\tif (distNow <= CLOSE_ENOUGH)\n       \t{\n\t\t\t// hit something!\n   \t\t\tsurfaceNormal = estimateNormal(marchStep, pickTarget);\n\t\t\t// calculate colour accumulation\n\t\t\tcolAccum = mix(colAccum,lightSurfacePoint(marchVec , marchStep, surfaceNormal, AMBIENT_LIGHT, pickTarget),\n\t\t\t\t\tclamp(reflectivity[pickTarget] + refMixVal + bounceCount * 0.1,0.0,1.0));\n\t\t\t\t\t//mix(reflectivity[pickTarget], clamp(0.0,1.0,refMixVal + bounceCount * 0.1), 0.5) );\n            rayDirection = normalize(reflect((rayDirection ), surfaceNormal));\n            bounceCount += 1.0;\n            marchDistance = 0.01;\n\t\t\t// move camera origin to reflection location\n\t\t\tmarchVec = marchStep; // + rayDirection * marchDistance;\n\t\t}\n\n        if (marchDistance >= MAX_DISTANCE || bounceCount >= 20.0)\n        {\n          // sky colour\n                int lastPick = pickTarget;\n        \t\tpickTarget = 0;\n\t\t\t\tcolAccum = mix(colAccum,colours[pickTarget] - rayDirection.y * 0.5,\n\t\t\t\t\t\t\tclamp(reflectivity[lastPick]+bounceCount*0.1,0.0,1.0));\n\n            \tbreak;   \n        }\n        \t\t\t\t\n\t}\n\n    col = colAccum;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1412, 1443, 1485, 1485, 1513], [1514, 1514, 1554, 1554, 1708], [1709, 1709, 1751, 1777, 1810], [1811, 1811, 1854, 1854, 1930], [1931, 1931, 1968, 1968, 1990], [1992, 1992, 2027, 2027, 2049], [2051, 2051, 2088, 2088, 2109], [2120, 2135, 2184, 2184, 3198], [3200, 3200, 3245, 3245, 3672], [4322, 4357, 4415, 4415, 5048], [5049, 5049, 5160, 5160, 6487], [6489, 6489, 6546, 6586, 9238]], "test": "timeout"}
{"id": "4dVfW1", "name": "wrwerwerwrewerwrw", "author": "lennyjpg", "description": "agfdsgfsdfgsdfg", "tags": ["dfsfd"], "likes": 3, "viewed": 280, "published": "Public API", "date": "1558202875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv.y+=0.2;\n    float t = 3.7 + iTime*0.002;  \n    float p = 20.0;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m+=0.5;\n    \n    float angle = atan(m.y-m.x);\n    \n    uv -= vec2(0.5);\n    uv = rotate2d( .35*PI ) * uv;\n    uv += vec2(0.5);\n    uv*=p;\n   float e = t*floor(mod(uv.x,p));\n   float f = t*floor(mod(uv.y,p));\n    uv = rotate2d( sin(angle+e-f*1.5)*PI ) * uv;\n    uv += vec2(0.15);\n//    float k = floor(fract(uv.x-uv.y)*2.0);\n    float k = (sin(uv.x*uv.y*1.3))*2.5;\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dVfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 53, 53, 139], [141, 141, 198, 198, 748]], "test": "ok"}
{"id": "4dyfWh", "name": "test112", "author": "Glim888", "description": "tt", "tags": ["tt"], "likes": 2, "viewed": 70, "published": "Public", "date": "1557415194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Ray_tracer v1\n\n#define ITER 100\n#define BILLBOARD_SIZE 5.0\n#define NUMBER_OF_REFLECTIONS 3\n\nstruct ray_t{\n \n    // origin of ray\n    vec3 o;\n    // direction of ray\n    vec3 d;\n    \n};\n\nstruct sphere_t{\n    \n    // position in room\n    vec3 pos;\n    // color \n    vec3 col;\n    // radius\n    float r;\n    // reflection value\n    float ref;\n    \n};\n    \n  \nsphere_t sphere[5];\n\n/*\nmat3 rotY (float ang) {\n    return mat3(cos(ang) ,0.0, sin(ang),\n                0.0, 1.0, 0.0,\n                -sin(ang), 0.0, cos(ang));\n}\n*/\n\n\n// returns the distance to the radius of the shpere\n// if it is <0, then we are inside of that shere\nfloat distance_from_sphere(vec3 pos, sphere_t sphere) {\n \treturn length(pos - sphere.pos) - sphere.r;  \n}   \n    \nvec3 trace(ray_t r, vec3 cam) {\n    \n    vec3 current_position, current_color = vec3(0);\n    float way_done = 0.0, dist, temp_dist; \n    int nearest_sphereN, refelctionN = 0;\n    sphere_t s;\n\n    \n    for (int i=0; i<ITER; i++) {\n        \n        current_position = r.o + r.d * way_done;\n        \n        // find nearest sphere index and distance to it\n        dist = 10000000.0;\n        nearest_sphereN = 0;\n        \n        for (int j=0; j<sphere.length(); j++) {\n                  \n            temp_dist = distance_from_sphere(current_position, sphere[j]);\n            \n            if (temp_dist < dist) {               \n                dist = temp_dist;\n                nearest_sphereN = j;                \n            }\n         }\n        \n         way_done += dist;\n        \n         // reflect\n         if (dist < 0.001) {             \n             \n\n             current_color += sphere[nearest_sphereN].col*sphere[nearest_sphereN].ref;\n             \n             \n             if (refelctionN++ >= NUMBER_OF_REFLECTIONS) break;\n                         \n             //if (refelctionN > 1) current_color *= (current_color + oldCol) * 0.5;\n                            \n             current_position = r.o + r.d * (way_done);\n             \n             way_done = 0.3;\n             vec3 dir = reflect(r.d, normalize(current_position-sphere[nearest_sphereN].pos));\n             r = ray_t (current_position, dir);\n         }\n                         \n    }\n    \n    if (current_color != vec3(0.0)) {\n              \n        vec3 norm = normalize(current_position-sphere[nearest_sphereN].pos);\n        float shading = dot(normalize(vec3(-1.0, 1.0, 0.0)), norm);\n\n        float shading1 = current_position.y > 0. ? 0.5 : 0.1; \n        \n        return current_color*0.5 + shading * 0.25 + shading1*0.25;\n    }else{\n        current_color = vec3(0.7, 0.7, 0.7) * smoothstep(-0.5, 0.5, r.o.y + r.d.y*5.0 - cam.y);   \n    }\n     \n    return current_color;  \n    \n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // set FOV (-0.3 to  0.3) and create uv\n    vec2 uv = fragCoord/iResolution.xy *0.3 -0.15;\n    \n    // remove distortion \n    // (-0.53 -> X -> 0.53)\n    // (-0.3  -> Y -> 0.3)\n\tuv.x *= (iResolution.x/iResolution.y);\n    \n    // we cast rays from here\n    vec3 cam = vec3(0.0,sin(iTime) * 1.5, -10.0);\n    \n    // sending direction\n    vec3 dir = vec3(uv*BILLBOARD_SIZE, 1.0);\n    \n    // Spheres in Room\n    sphere[0] = sphere_t(vec3(0.0), vec3(0.0, 0.0, 0.0), 2.0, .1);\n    sphere[1] = sphere_t(vec3(5.0 * sin(iTime),1.0,3.0 * cos(iTime)), vec3(1.0, 1.0, 0.0), 1.0, 1.);\n    sphere[2] = sphere_t(vec3(0.0, -5.0+cam.y, 5.0), vec3(0.0, 1.0, 1.0), abs(2.0 * sin(iTime)), 1.);\n    sphere[3] = sphere_t(vec3(8.0, 0.0+cam.y, 8.0), vec3(1.0, 1.0, 1.0), 5.0, 1.0);\n    sphere[4] = sphere_t(vec3(-5.0, 5.0+cam.y, 3.0), vec3(1.0, 0., 0.0), 2.0, 1.0);  \n    \n    // create a ray & send it  \n    ray_t r = ray_t (cam, dir);\n    \n    vec3 col = trace(r, cam);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\n    \nvec3 trace(ray_t r, vec3 cam) {\n    \n    vec3 current_position, current_color;\n    float way_done = 0.0, dist, temp_dist; \n    int nearest_sphereN, refelctionN = 0;\n    sphere_t s;\n\n    \n    for (int i=0; i<ITER; i++) {\n        \n        current_position = r.o + r.d * way_done;\n        dist = 10000000.0;\n        nearest_sphereN = 0;\n        \n        for (int j=0; j<sphere.length(); j++) {\n         \n            s = sphere[j];           \n            temp_dist = distance_from_sphere(current_position, s);\n            \n            if (temp_dist < dist) {\n                \n                dist = temp_dist;\n                nearest_sphereN = j;                \n            }\n         }\n        \n         way_done += dist;\n            \n         if (dist < 0.0001) {\n             \n             if (refelctionN++ > 3) break;\n             \n             vec3 oldCol = current_color;\n             current_color += (sphere[nearest_sphereN].col);\n             \n             if (refelctionN > 1) current_color -= (current_color - oldCol) * 0.5;\n                            \n             current_position = r.o + r.d * (way_done+0.01);\n             \n             way_done = 0.3;\n             vec3 dir = reflect(r.d, normalize(current_position-sphere[nearest_sphereN].pos));\n             r = ray_t (current_position, dir);\n         }\n                         \n    }\n    \n    if (current_color != vec3(0.0)) {\n        vec3 norm = normalize(current_position-sphere[nearest_sphereN].pos);\n        float shading = dot(normalize(vec3(-1.0, 1.0, 0.0)), norm);\n\n        return current_color*0.5 + shading * 0.5;\n    }else{\n        \n        //current_color = vec3(0.7, 0.7, 0.7) * smoothstep(-0.5, 0.5, r.o.y + r.d.y*5.0 - cam.y);\n      \treturn current_color;  \n    }\n} \n*/\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyfWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[530, 631, 686, 686, 736], [745, 745, 776, 776, 2706], [2712, 2712, 2769, 2814, 3781]], "test": "ok"}
{"id": "4tdfDj", "name": "Coffee Journey", "author": "BeardThings", "description": "A cup within a cup? What is this?!? And the small cup doesn't even have any coffee!\n", "tags": ["procedural", "sdf", "coffee", "water", "adventure", "boat", "beautiful", "journey"], "likes": 6, "viewed": 396, "published": "Public API", "date": "1557012354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float waveI(in vec3 p)\n{\n    float w = dot(p.xz, vec2(0.707, 0.707)) + iTime * 0.8;\n   \tfloat f = -abs(sin(w * 0.2)) * 0.5;\n    \n    w = dot(p.xz, normalize(vec2(-1.0, 0.3))) + iTime;\n    f += -(sin(w + 4.33)) * 0.1;\n    \n    w = dot(p.xz, normalize(vec2(0.5, -1.5))) + iTime * 0.5;\n    f += -abs(cos(w * 0.8)) * 0.3;\n    \n    f += textureLod(iChannel0, p.xz + iTime * 0.2, 8.5).x * 0.5;\n    \n    return f * (40.0 - p.z) / 40.0;\n}\n\nfloat wave(in vec3 p)\n{\n    float w = waveI(p);\n    w += waveI(p + vec3(0.0, 0.0, 0.1));\n    w += waveI(p + vec3(0.0, 0.0, -0.1));\n    \n    return w / 3.0;\n}\n\nfloat cof_sdf(in vec3 p)\n{\n    return p.y + 0.5- wave(p);\n}\n\nvec3 cof_norm(in vec3 p)\n{\n    const float e = 0.01;\n    vec3 n = vec3(\n        cof_sdf(p + vec3(e, 0.0, 0.0)) - cof_sdf(p - vec3(e, 0.0, 0.0)),\n        cof_sdf(p + vec3(0.0, e, 0.0)) - cof_sdf(p - vec3(0.0, e, 0.0)),\n        cof_sdf(p + vec3(0.0, 0.0, e)) - cof_sdf(p - vec3(0.0, 0.0, e)));\n    n += textureLod(iChannel0, (p.xz - iTime * 0.1) * 0.1, 0.0).xyz * 0.25;\n    return normalize(n);\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(in vec3 p, in vec3 b)\n{\n    vec3 d = abs(p) - b;\n\treturn length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 rotate(in vec3 p, in float a)\n{\n    mat3x3 m = mat3x3(vec3(cos(a), -sin(a), 0.0), vec3(sin(a), cos(a), 0.0), vec3(0.0, 0.0, 1.0));\n    return m * p;\n}\n\nvec3 cup_c = vec3(0.0, -0.1, 2.0);\nfloat cup_sdf(in vec3 p)\n{\n    vec3 c = cup_c;\n    \n    float w1 = wave(c + vec3(0.0, 0.0, -0.2));\n    float w2 = wave(c + vec3(0.0, 0.0, 0.0));\n    float w3 = wave(c + vec3(0.0, 0.0, -0.1));\n    c.y += (w1 + w2 + w3) / 3.0;\n    \n    p = rotate(p, 3.1415 / 16.0 + sin(iTime) * 0.1);\n    p -= c;\n    \n    \n    float o = max(-box(p - vec3(0.0, 1.2, 0.0), vec3(5.0, 1.0, 5.0)), sphere(p, 0.9));\n    o = max(-sphere(p, 0.8), o);\n    o = smoothUnion(o, torus(p - vec3(1.0, -0.2, 0.0), vec2(0.3, 0.075)), 0.1);\n    \n    return o;\n}\n\nfloat cup_mask(in vec3 p)\n{\n    vec3 c = cup_c;\n    \n    float w1 = wave(c + vec3(0.0, 0.0, -0.2));\n    float w2 = wave(c + vec3(0.0, 0.0, 0.0));\n    float w3 = wave(c + vec3(0.0, 0.0, -0.1));\n    c.y += (w1 + w2 + w3) / 3.0;\n    \n    p = rotate(p, 3.1415 / 16.0 + sin(iTime) * 0.1);\n    p -= c;\n    \n    return sphere(p, 0.8);\n}\n\nvec3 cup_norm(in vec3 p)\n{\n    const float e = 0.01;\n    vec3 n = vec3(\n        cup_sdf(p + vec3(e, 0.0, 0.0)) - cup_sdf(p - vec3(e, 0.0, 0.0)),\n        cup_sdf(p + vec3(0.0, e, 0.0)) - cup_sdf(p - vec3(0.0, e, 0.0)),\n        cup_sdf(p + vec3(0.0, 0.0, e)) - cup_sdf(p - vec3(0.0, 0.0, e)));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n    \n    vec3 o = vec3(0.0, 2.0, -1.5),\n        f = normalize(cup_c - o),\n        r = vec3(1.0, 0.0, 0.0),\n        u = normalize(cross(f, r));\n    float a = iResolution.y / iResolution.x;\n    \n    fragColor = vec4(0.0);\n    \n    vec3 d = normalize(f + u * uv.y * a + r * uv.x);\n    \n    vec3 l = normalize(vec3(0.707, 2.0, 0.0));\n    \n    fragColor = vec4(1.0) * 0.8;\n    \n    float cp = 100000.0;\n    {\n        float s = 0.0;\n        for(int i = 0; i < 32; i++)\n        {\n            vec3 p = o + d * s;\n            float m = cup_sdf(p);\n            if(m < 0.005)\n            {\n                vec3 n = cup_norm(p);\n                vec4 c = min(vec4(1.2) * (textureLod(iChannel1, n.xy, 2.0).r + 0.4), vec4(1.0));\n                fragColor = c * max(dot(n, l), 0.2);\n                cp = s;\n                break;\n            }\n            s += m;\n        }\n    }\n    \n    {\n        float s = 0.0;\n        for(int i = 0; i < 128; i++)\n        {\n            vec3 p = o + d * s;\n            float m = cof_sdf(p);\n            if(m < 0.05)\n            {\n                if(s > cp || cup_mask(p) < 0.05)\n                {\n                    return;\n                }\n                \n                float cup = cup_sdf(p);\n\n                vec3 c = vec3(0.18, 0.12, 0.05) * 0.5;\n                vec3 n = cof_norm(p);\n                vec3 d = c * dot(n, l);\n                vec3 sp = c * pow(max(dot(n, normalize(l + -d)), 0.0), 10.0) * 10.0;\n\n                float cupAmb = (1.0 - min(cup * 5.0, 1.0));\n                d += cupAmb * 3.0 * c;\n                d += c * max(s - 20.0, 0.0) * 0.75;\n                \n                fragColor = vec4(d + sp, 1.0);\n                break;\n            }\n            s += m;\n            \n            if(s > 30.0)\n            {\n                vec3 n = normalize(d);\n                vec4 c = min(vec4(1.2) * (textureLod(iChannel1, n.xy, 0.0).r + 0.4), vec4(2.0));\n                fragColor = c * max(dot(n, l), 0.2) * 1.3;\n                return;\n            }\n        }\n    }\n    \n    fragColor = pow(fragColor, vec4(1.4));\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdfDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 430], [432, 432, 455, 455, 589], [591, 591, 617, 617, 650], [652, 652, 678, 678, 1046], [1048, 1048, 1082, 1082, 1110], [1112, 1112, 1145, 1145, 1242], [1244, 1244, 1275, 1275, 1340], [1342, 1342, 1392, 1392, 1491], [1493, 1493, 1529, 1529, 1648], [1685, 1685, 1711, 1711, 2210], [2212, 2212, 2239, 2239, 2541], [2543, 2543, 2569, 2569, 2861], [2863, 2863, 2920, 2920, 5033]], "test": "error"}
{"id": "4tGBz3", "name": "edited thing", "author": "AKCESSIVE", "description": "an colourful thing", "tags": ["color"], "likes": 4, "viewed": 308, "published": "Public API", "date": "1556950744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_DELTA 0.015625\nfloat rand(vec3 n) { \n    return fract(sin(dot(n, vec3(95.43583, 93.323197, 94.993431))) * 65536.32);\n}\n\nfloat perlin2(vec3 n)\n{\n    vec3 base = floor(n / N_DELTA) * N_DELTA;\n    vec3 dd = vec3(N_DELTA, 0.0, 01.0);\n    float\n        tl = rand(base + dd.yyy),\n        tr = rand(base + dd.xyy),\n        bl = rand(base + dd.yxy),\n        br = rand(base + dd.xxy);\n    vec3 p = (n - base) / dd.xxx;\n    float t = mix(tl, tr, p.x);\n    float b = mix(bl, br, p.x);\n    return mix(t, b, p.y);\n}\n\nfloat perlin3(vec3 n)\n{\n    vec3 base = vec3(n.x, n.y, floor(n.z / N_DELTA) * N_DELTA);\n    vec3 dd = vec3(N_DELTA, 0.0, 0.0);\n    vec3 p = (n - base) / dd.xxx;\n    float front = perlin2(base + dd.yyy);\n    float back = perlin2(base + dd.yyx);\n    return mix(front, back, p.z);\n}\n\nfloat fbm(vec3 n)\n{\n    float total = 0.0;\n    float m1 = 1.0;\n    float m2 = 0.1;\n    for (int i = 0; i < 6; i++)\n    {\n        total += perlin3(n * m1) * m2;\n        m2 *= 2.1;\n        m1 *= 0.6;\n    }\n    return total;\n}\n\nfloat cloudAtmosphere(vec2 uv)\n{\n    float n1 = fbm(vec3(uv * 2.0, 0.0));\n    float n2 = fbm(vec3(uv,  1.0) + n1 * 0.05);   \n    float n3 = fbm(vec3(uv, 2.0) + n2 * 0.3);\n    return n3;\n}\n\nfloat nebula1(vec3 uv)\n{\n    float n1 = fbm(uv * 2.9 - 1000.0);\n    float n2 = fbm(uv + n1 * 0.05);   \n    return n2;\n}\n\nfloat nebula2(vec3 uv)\n{\n    float n1 = fbm(uv * 1.3 + 115.0);\n    float n2 = fbm(uv + n1 * 0.35);   \n    return fbm(uv + n2 * 0.17);\n}\n\nfloat nebula3(vec3 uv)\n{\n    float n1 = fbm(uv * 5.0);\n    float n2 = fbm(uv + n1 * 0.15);   \n    return n2;\n}\n\nvec3 nebula(vec3 uv)\n{\n    uv *= 10.0;\n\treturn nebula1(uv * 0.5) * vec3(-5.0, 1.1, 7.0) -\n        \tnebula2(uv * 0.4) * vec3(-3.5, 1.0, 8.0) -\n        \tnebula3(uv * 0.6) * vec3(0.0, 0.0, -1.0);\n        \n}\n\nfloat altitude(vec3 pos)\n{\n    return (cloudAtmosphere(pos.xz * 0.03) + 2.0) * 24.0;\n}\n\nfloat map(vec3 pos, vec3 rd)\n{\n    return (pos.y - altitude(pos)) * 0.7;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 dd = vec3(0.01, 0.0, 1.0);\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    return normalize(vec3(map(pos + dd.xyy, n) - map(pos - dd.xyy, n),\n                          map(pos + dd.yxy, n) - map(pos - dd.yxy, n),\n                          map(pos + dd.yyx, n) - map(pos - dd.yyx, n)));\n                          \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 xy = (fragCoord.xy - iResolution.xy * 0.5)  / size * 2.0;\n    vec3 rayDir = normalize(vec3(xy, 1.0));\n    vec2 uv = xy * 0.5 + 0.5;\n    \n    fragColor = vec4(vec3((nebula(vec3(uv * 5.1, iTime * 0.1) * 0.1) - 1.0)), 1.0);\n    \n    //float ca = cloudAtmosphere(uv) * 0.5;\n    //fragColor = vec4(ca, ca, ca, 1.0);\n    \n    /*\n    vec3 ro = vec3(cos(iTime), 0.0, iTime * 10.0);\n    ro.y = altitude(ro) + 30.0;\n    //vec3 fwd = normalize(-ro);\n    //vec3 ro = vec3(0.0, 10.0, 0.0);\n    vec3 fwd = normalize(vec3(0.0, -10.0, 50.0));\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 left = normalize(cross(fwd, up));\n    vec3 rd = rayDir.x * left + rayDir.y * up + rayDir.z * fwd;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 pos = ro;\n    float stepSize = 1.1;\n    for (int i = 1; i < 50; i++)\n    {\n        //stepSize += stepSize * 0.1;\n        float dist = map(pos, rd);\n        pos += rd * max(dist, 0.0);\n        if (dist < 0.01)\n        {\n            fragColor = vec4(calcNormal(pos) * 0.5 + 0.5, 1.0);\n            break;\n        }\n        pos += rd * max(dist * float(i) / 30.0, 0.0);\n    }\n\t*/\n    //fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGBz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 128], [130, 130, 153, 153, 512], [514, 514, 537, 537, 793], [795, 795, 814, 814, 1018], [1020, 1020, 1052, 1052, 1207], [1209, 1209, 1233, 1233, 1328], [1330, 1330, 1354, 1354, 1465], [1467, 1467, 1491, 1491, 1577], [1579, 1579, 1601, 1601, 1782], [1784, 1784, 1810, 1810, 1870], [1872, 1872, 1902, 1902, 1946], [1948, 1948, 1975, 1975, 2289], [2291, 2291, 2348, 2348, 3546]], "test": "ok"}
{"id": "MlGczG", "name": "Capsule - soft shadow", "author": "iq", "description": "Fake/approximated soft shadow for a capsule.", "tags": ["3d", "shadow", "capsule"], "likes": 11, "viewed": 1201, "published": "Public API", "date": "1558008345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Fake/approximated soft shadow for a capsule.\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n// Other soft-shadow functions:\n//\n// Sphere:    https://www.shadertoy.com/view/4d2XWV\n// Ellipsoid: https://www.shadertoy.com/view/llsSzn\n// Box:       https://www.shadertoy.com/view/WslGz4\n// Capsule:   https://www.shadertoy.com/view/MlGczG\n\n#define AA 3\n\n//================================================================\n\n// fakesoft shadow occlusion\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k )\n{\n    vec3 ba =  b - a;\n\tvec3 oa = ro - a;\n\n    // closest distance between ray and segment\n#if 1\n    // naive way to solve the 2x2 system of equations\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n#else\n    // fizzer's way to solve the 2x2 system of equations\n    vec3 th = inverse(mat3(-rd,ba,cross(rd,ba))) * oa;\n#endif\t\n    \n    \n\tth.x = max(   th.x, 0.0001 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3  p =  a + ba*th.y;\n\tvec3  q = ro + rd*th.x;\n    float d = length( p-q )-r;\n\n    // fake shadow\n    float s = clamp( k*d/th.x+0.5, 0.0, 1.0 );\n    return s*s*(3.0-2.0*s);\n}\n\n\n//================================================================\n// intersect capsule\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = 1.0 - max(0.0,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n\n        vec3 col = vec3(0.0);\n\n        const vec3 lig = normalize(vec3(-0.8,0.8,0.2));\n\n        float tmin = 1e20;\n        float sha = 1.0;\n        float occ = 1.0;\n        vec3 nor;\n\n        // plane (floor)\n        {\n            float t = (-0.3-ro.y)/rd.y;\n            if( t>0.0 && t<tmin )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = vec3(0.0,1.0,0.0);\n                // fake soft shadow!\n                sha = capShadow( pos+0.001*nor, lig, capA, capB, capR, 4.0 ); \n                // fake occlusion \n                occ = capOcclusion( pos, nor, capA, capB, capR ); \n            }\n        }\n\n        // capsule\n        {\n            float t = capIntersect( ro, rd, capA, capB, capR );\n            if( t>0.0 && t<tmin )\n            {\n                tmin = t;\n                vec3 pos = ro + t*rd;\n                nor = capNormal(pos, capA, capB, capR );\n                occ = 0.5 + 0.5*nor.y;\n                sha = 1.0;\n            }\n        }\n\n        // lighting\n        if( tmin<1e19 )\n        {\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 )*sha;\n            float amb = 1.0*occ;\n            col =  vec3(0.2,0.3,0.4)*amb;\n            col += vec3(0.7,0.6,0.5)*dif*0.8;\n        }\n\n        tot += sqrt( col );\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGczG.jpg", "access": "shaders20k", "license": "mit", "functions": [[1739, 1768, 1857, 1857, 2579], [2582, 2670, 2752, 2752, 3483], [3485, 3503, 3568, 3568, 3694], [3697, 3715, 3793, 3793, 4007]], "test": "ok"}
{"id": "tdXSDS", "name": "Ocean shore shader test", "author": "sergei_am", "description": "Ocean shore waves effect relying on distance to shore field. The foam perturbation is inspired by the Quake water. Wave height (power) is constructed using two powers for X and 1-X functions in the [0;1] range.", "tags": ["water", "ocean", "shore"], "likes": 2, "viewed": 78, "published": "Public", "date": "1558823024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat get_foam_for_position(in vec2 pos)\n{\n    // foam perturbed coordinates\n    vec2 foam_uv = pos*8.0;\n    \n    float pos_noise = abs(sin(pos.x*1.0)*sin(pos.y*1.0));\n    \n    float fx = pos.y;\n    float fy = pos.x;\n    \n    foam_uv.x += cos(fx*20.0 + iTime*1.0)*0.17;\n    foam_uv.y += sin(fy*20.0 + iTime*1.0)*0.17;\n    \n    // process blob texture to produce foam-like pattern\n    float foam = texture(iChannel0, foam_uv).x;\n    foam = 1.0 - foam;\n    foam = min( foam*1.2, 1.0 );\n    foam = pow( foam, 4.0 );\n    foam = min( foam*1.5, 1.0 );\n    \n    return foam;\n}\n\nvec4 get_water_surface(in vec2 pos, in float sdf)\n{\n    // coastal pulse wave\n    float wave_pulse = sdf + iTime * 0.2;\n    wave_pulse = fract(wave_pulse);\n    \n    // construct wave shape\n    float wave_front = pow(wave_pulse, 64.0);\n    wave_front = min((wave_pulse - 0.95) * 20.0, 1.0);\n    float wave_back = pow(1.0 - wave_pulse, 8.0);\n    //wave_back = min( 1.0, ((1.0 - wave_pulse) - 0.6) * 4.0 );\n    \n    float wave_height = max(wave_front, wave_back);\n    \n    float wave_fadeoff = 1.0 - min(1.0, max((sdf - 0.6)*5.0, 0.0));\n\n\tfloat foam = get_foam_for_position(pos);\n    \n    float wave = max( 0.0, wave_height*1.5 - 1.0 + foam );\n    wave *= wave_fadeoff;\n    \n    vec3 water = vec3(0.1, 0.3, 0.8);\n    vec3 wave_foam = vec3(wave, wave, wave);\n    \n    vec3 color = water + wave_foam;\n    return vec4(color, wave_height);\n}\n\n\nfloat df(float x, float y)\n{\n    return 1.0 - x - y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    vec4 color = get_water_surface(pos, df(pos.x, pos.y));\n    fragColor = vec4(color.xyz, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 44, 78, 571], [573, 573, 624, 650, 1407], [1410, 1410, 1438, 1438, 1464], [1466, 1466, 1523, 1573, 1713]], "test": "error"}
{"id": "tlB3D1", "name": "Mandelbrot <=> Julia", "author": "illinad", "description": "Representation of changing state of one fractal to another.", "tags": ["fractal"], "likes": 3, "viewed": 188, "published": "Public", "date": "1559327894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ISJ 1\n\n# define SQR(x) ((x) * (x))\nconst vec4 bitEnc = vec4(1. ,255. ,65025. ,16581375.);\nconst vec4 bitDec = 1. / bitEnc;\n\nvec4 myt(float ij)\n{\n float a;\n float r;\n float g;\n float b;\n\n a = ij - mod(ij, 65536. * 256.);\n r = (ij - a) - mod(ij, 65536.);\n g = (ij - a - r) - mod(ij, 256.);\n b = (ij - a - r - g);\n return (vec4(r / 16581375., g / 65535., b / 255., 1.));\n}\n\nvec2 cidef(vec2 fragCoord, vec2 cf, float zoom)\n{\n if (ISJ == 1)\n {\n  return cos(iTime * 0.5) * (vec2(0.92, 0.0))\n  + sin(iTime * 0.5) * (fragCoord.xy / zoom - cf);\n  //return (gl_FragCoord.xy / zoom - cf);\n }\n else\n {\n  return (fragCoord.xy / zoom - cf);\n }\n}\n\nvec2 zidef(vec2 fragCoord, vec2 c, vec2 cf, float zoom)\n{\n if (ISJ == 1)\n {\n  //==return sin(iTime) * (vec2(cos(iTime), sin(iTime)))\n  //+ cos(iTime) * (gl_FragCoord.xy / zoom - cf);\n  //return (vec2(sin(iTime), cos(iTime)));\n  return (fragCoord.xy / zoom - cf);\n  }\n  else\n  {\n  return (fragCoord.xy / zoom - cf);\n  }\n}\n\n#define MSAA 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n float zoom = iResolution.y * 0.4;\n int maxk = 50;\n float o1 = -0.25;\n float o2 = 0.25;\n vec2 msaa[4];\n    \n msaa[0] = vec2( o1,  o2);\n msaa[1] = vec2( o2, -o1);\n msaa[2] = vec2(-o1, -o2);\n msaa[3] = vec2(-o2,  o1);\n vec3 color = vec3(0.);\n\n int k = 0;\n vec2 ct; \n vec2 c;\n vec2 z;\n vec2 zsq;\n for (int i = 0; i < MSAA; ++i)\n {\n  ct = iResolution.xy / 2. / zoom;\n  c = cidef(fragCoord - msaa[i], ct, zoom);\n  z =(zidef(fragCoord - msaa[i], c, ct, zoom));\n  zsq = z * z;\n  k = 0;\n  while (k < maxk)\n  {\n   z = vec2(zsq.x, (SQR((z.x) + (z.y)) - zsq.x)) - zsq.y + c;\n   zsq = z * z;\n   if (zsq.x + zsq.y > 4.)\n    break;\n   k++;\n  }\n  if (k >= maxk)\n   color += vec3(0.);\n  else\n   color += vec3(myt(float(k * 50000000)).rgb);\n }\n fragColor = vec4(color / float(MSAA), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlB3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 152, 152, 377], [379, 379, 428, 428, 639], [641, 641, 698, 698, 961], [979, 979, 1036, 1036, 1810]], "test": "ok"}
{"id": "tlBGzm", "name": "SSSSSSS", "author": "lennyjpg", "description": "aasdfasdfasdf", "tags": ["2d", "lines", "pattern"], "likes": 8, "viewed": 397, "published": "Public API", "date": "1558879350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv =  ( fragCoord - .5* iResolution.xy ) / iResolution.y; \n\n  float t = iTime * 7.;\n  t+=sin(t*.5)*2.0+1.6;\n  uv.y += sin(t*0.5+uv.x*7.0)*0.1;\n    \n  float d = .2;\n  uv.y -= d;\n  float s = ceil(uv.x);\n  uv.y += s * d * 2.;\n  \n  t *= s * 2. - 1.;\n  //t+= s*3.2;\n    \n  float k = sin(t + length(uv) * 55.);\n  fragColor = vec4( k/fwidth(k) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 406]], "test": "ok"}
{"id": "tlBGzR", "name": "ksjhgfghkjfdgfhdkjfgdjkhl", "author": "lennyjpg", "description": "kfdkljdfgkjhblkjdjkhldasdhkjlsdaöl\n", "tags": ["mfdgsdjkhslsdfghjkgdfhk"], "likes": 3, "viewed": 322, "published": "Public API", "date": "1558243938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col =  0.7*cos(iTime*0.3+uv.xyy+vec3(0,2,11));\n    \n    uv.y = fract(uv.x+0.01+uv.y-0.2);\n    \n    //uv = fract(uv*1.98)-0.01;\n    vec2 u = uv;\n\n    \n    if(uv.y>0.37){\n        uv.x=fract(uv.x-0.9)*1.0;\n    }\n    \n    if(uv.x<0.12345){\n        col = vec3(0.0,0.0,uv.y+fract(iTime*0.01));\n    }\n    if(uv.x < 0.3){\n        uv.x+=rand(u)*0.15;\n    }\n\n    if(uv.x>0.75){\n        col = vec3(1.0,0.0,uv.y);\n    }\n    if(uv.y>0.123456){\n        col.r += u.y;\n    }\n \n    if(u.x<0.03){\n        col = vec3(1.);\n    }\n\n    if(u.x>0.28){\n        col.g *= rand(uv)*0.1;\n    }\n\n    if(u.y>0.28 && mod(fragColor.y,3.0)<0.5){\n        col.g += 0.5;\n    }\n\n    if(u.y>0.9){\n        col.b *= sin(iTime*.1);\n    }\n         //  u = rotate2d( sin(iTime*0.2)*PI ) * uv;\n\n    if(u.x>0.9){\n        col.rb-= uv.y*0.33;\n    }\n    \n    if(u.x>0.99 && u.y < 0.9){\n        col.rgb /= mod(fragCoord.x,2.0); \n    }\n    \n    vec2 e = fract(iTime*0.1+abs(uv-0.2)*2.0);\n    \n    if(e.x>u.y){\n        col.rgb  = 0.7 + col.brg;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 162, 162, 234], [235, 235, 292, 292, 1374]], "test": "ok"}
{"id": "tlf3zX", "name": "3D Hilbert Curve", "author": "tpfto", "description": "3D rendering of a [url=https://en.wikipedia.org/wiki/Hilbert_curve]Hilbert spacefilling curve[/url] using Skilling's algorithm.", "tags": ["3d", "geometry", "hilbert", "spacefilling"], "likes": 10, "viewed": 687, "published": "Public", "date": "1558282294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Display a 3D Hilbert curve (https://en.wikipedia.org/wiki/Hilbert_curve)\n\n// colors\n\n#define BG vec3(0.18, 0.28, 0.23)\n#define COL vec3(0.12, 0.56, 1.0)\n\n// Skilling's algorithm, https://doi.org/10.1063/1.1751381 and https://doi.org/10.1063/1.1751382\n// see also http://www.inference.org.uk/bayesys/test/hilbert.c and compare with https://www.shadertoy.com/view/3tl3zl\n\nvec3 hilbert( in int k, in int s )\n{\n\tint bb = 1 << s, b = bb;\n    ivec3 t = ivec3(k ^ (k >> 1)), hp = ivec3(0);\n    \n    for( int j = s - 1; j >= 0; j-- )\n    {\n        b >>= 1;\n        hp += (t >> (2 * j + ivec3(2, 1, 0))) & b;\n    }  \n\n    for( int p = 2; p < bb; p <<= 1 )\n    {\n        int q = p - 1;\n\n        if( (hp.z & p) != 0 ) hp.x ^= q;\n        else hp.xz ^= (hp.x ^ hp.z) & q;\n\n        if( (hp.y & p) != 0 ) hp.x ^= q;\n        else hp.xy ^= (hp.x ^ hp.y) & q;\n\n        if( (hp.x & p) != 0 ) hp.x ^= q;\n    }\n    \n    return 2.0 * (vec3(hp)/float(bb - 1)) - 1.0;\n}\n\n// line segment distance\n\nfloat segment(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n\treturn length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));\n}\n\n// rotation matrix\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n    \n// 3D -> 2D projection\n\nvec2 proj( in float p, in float c, in vec3 P )\n{\n    float q = -p * sqrt(1.0 - c * c);\n\n    return mat3x2(-p, q, 0.0, c, p, q) * P;\n}\n\n// 3D curve drawing, adapted from https://www.shadertoy.com/view/4lyyWw by Fabrice Neyret\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ep = 5.0/iResolution.y;\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= 3.2;\n    \n    int s = (int(floor(0.1 * iTime)) % 4) + 1; // iteration stage of Hilbert curve\n    int n = 1 << (3 * s); // Hilbert curve points\n    vec3 P, Pn;\n    vec2 pb, p;\n    float d = 100.0, dt;\n    \n    for (int i = 0; i < n; i++)\n    {\n        P = hilbert(i, s);\n \n        P.xz *= rot(2.0 * iTime); // rotation\n        p = proj(sqrt(0.5), 0.9, P); // screen projection\n\n        if (i > 0)\n        {\n            dt = segment(uv, pb, p) * ((5.0 - P.z)/9.0); // draw segment with thickening factor\n            if (dt < d) { d = dt; Pn = P; } // keep nearest\n        }\n        \n        pb = p;\n    }\n    \n    float da = 0.5 + 0.5 * mix(0.8, 1.0, Pn.y); // darkening at the bottom\n    fragColor = vec4(mix(BG, mix(vec3(0.0), COL, da), smoothstep(ep, 0.0, d)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlf3zX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1444, 1444, 1480, 1480, 2019], [2047, 2047, 2085, 2085, 2172], [2276, 2276, 2324, 2324, 2409]], "test": "ok"}
{"id": "tlfGWX", "name": "Newton-Raphson & Mollweide", "author": "tpfto", "description": "[url=https://en.wikipedia.org/wiki/Mollweide_projection]Mollweide projection[/url] of the Newton-Raphson fractal on the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url].", "tags": ["2d", "fractal", "complex", "mollweide"], "likes": 3, "viewed": 113, "published": "Public", "date": "1558017485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mollweide-projected Newton-Raphson fractal\n\n// some constants\n#define PI 3.14159265359\n\n// from Fabrice Neyret, \n#define cis(a) vec2( cos(a), sin(a) )\n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// Newton-Raphson fractal for z^n - 1\nvec3 NewtonFractal(int n, vec2 z) {\n    \n    vec2 ld = vec2(0.0);\n    float k = 0.0;\n    \n    for(int i = 0; i < 20; i++) {\n        ld = cdiv(cpow(z, n) - vec2(1.0, 0.0), float(n) * cpow(z, n - 1));\n        if (dot(ld, ld) < 0.001) break;\n        z = z - ld;\n        k += 1.0;\n    }\n    \n    // multiplier highlights the positions of the roots\n    return pow((k + 0.1)/20.0, 0.18) * smooth_dlmf(0.1 + 0.5 * atan(z.y, z.x)/PI);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= 2.3;\n    \n        vec3 col = vec3(0.0);\n        \n        float ee = 1.0 - length(uv/vec2(2.0, 1.0));\n        if ( ee > 0.0)\n        {\n            float s2 = sqrt((1.0 - uv.y) * (1.0 + uv.y)), as = 2.0 * (uv.y * s2 + asin(uv.y));\n            vec2 zz = sqrt((PI + as)/(PI - as)) * cis(0.2 * iTime - 0.5 * PI * uv.x/s2); // Mollweide variable\n        \n            col = NewtonFractal(4, zz);\n        }\n\n        col = mix(vec3(0.19, 0.28, 0.23), col, smoothstep(0.0, 4.0/iResolution.y, ee));\n        fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 380, 409, 409, 607], [609, 649, 683, 683, 1070], [1072, 1110, 1145, 1145, 1539], [1541, 1541, 1598, 1598, 2261]], "test": "ok"}
{"id": "tlj3RR", "name": "Hypnotic Owl", "author": "mosaic", "description": "Learning how to use different colour channels, fract and mirror effect\n\nOwl? Frog? Garfield the cat? What shapes do you see", "tags": ["2d"], "likes": 1, "viewed": 117, "published": "Public", "date": "1558330502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat random(vec2 st) {\n\treturn fract(sin(dot(st, vec2(15.13123, 45.56251))) * 45666.12) *2.-1.;\n}\n\nfloat noise2(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t// Create grid to spread out our noise\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t// Create our hermite cubic interpolation\n\tvec2 h = f * f * (3.0 - 2.0 * f);\n\t// Do our bilinear interpolation:\n\treturn \tmix(a, b, h.x) + \n\t\t\t(c - a) * h.y * (1.0 - h.x) +\n\t\t\t(d - b) * h.x * h.y;\n}\nfloat fbm(vec3 p){\n\tfloat amp = 2.0;\n\tfloat fbm = 0.;\n\tfloat scale = 2.0;\n\tfor(int i = 0; i < 5; i++){\n\t\tfbm += noise2(p.xy) * amp;\n\t\tp *= scale;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm/12.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st  = fragCoord/iResolution.y;\n    \n    //this line creates the  mirror\n \tst.x = 0.8 - abs(0.9 - st.x );\n    \n    float blue = distance(st,vec2(0.2,0.4))*3.;\n    \n    float red = distance(st,vec2(0.5,0.7))*3.;\n    \n    float yellow =distance(st,vec2(0.4,0.2))*3.;\n\n    \n    vec3 colour= vec3(blue,red,yellow)-(iTime)/5.;\n    \n       \n    //uncomment line 52 and comment out line 53 for fbm effect\n   // colour = fract(colour*1.1+fbm(st.xxx))/vec3(0.31);\n    colour = fract(colour*1.1)/vec3(0.31);\n    \n    \n    // Output to screen\n    fragColor = 1.-vec4(colour,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlj3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 99], [101, 101, 124, 124, 544], [545, 545, 563, 563, 726], [729, 729, 786, 786, 1365]], "test": "ok"}
{"id": "tlj3Wz", "name": "Cubeonblue", "author": "Nikilean", "description": "Rotating cube is made on materials of http://fabricecastel.github.io/blog/2016-02-11/main.html", "tags": ["cube"], "likes": 3, "viewed": 112, "published": "Public", "date": "1559221586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\n\n// epsilon-type values\nconst float S = 0.01;\nconst float EPSILON = 0.01;\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n\tfloat s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\n\n// better normal implementation with half the sample points\n// used in the blog post method\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0, 0.0, 0.5);\n    for(int i = 0; i < 20; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < EPSILON){\n            vec3 hit = p+dir*dist;\n            vec3 light = vec3(100.0*sin(iTime), 30.0*cos(iTime), 50.0*cos(iTime));\n            result = computeLambert(hit, computeSurfaceNormal(hit), light);\n            break;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0*sin(iTime), 0.0, 10.0*cos(iTime));\n\tvec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n  \n    // generate the ray for this pixel\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec3 pixelColour = intersectWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlj3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 346, 346, 469], [472, 564, 598, 598, 815], [818, 818, 862, 862, 905], [907, 907, 949, 949, 1432], [1434, 1434, 1491, 1491, 2325]], "test": "ok"}
{"id": "tljGzD", "name": "Munker Illusion", "author": "blevin", "description": "These spheres are all the same color.\nA Shadertoy version of a Munker illusion, as investigated by Prof David Novick:\nhttp://www.cs.utep.edu/novick/colors/explanation/", "tags": ["illusionperception"], "likes": 12, "viewed": 351, "published": "Public", "date": "1558733160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A Shadertoy version of a Munker illusion, as investigated by Prof David Novick:\n// http://www.cs.utep.edu/novick/colors/explanation/\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// cosine palette from: iq, https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 pal_1(in float t)\n{\n  return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n    \nstruct Ray {\n    vec3 r0;\n    vec3 rd;\n};    \nstruct Material {\n    vec3 c;\n};\nstruct Hit {\n    float dist;\n    vec3 normal;\n    Material material;\n    int id;\n};    \nstruct Sphere {\n    int id;\n    vec3 s0;\n    float sr;\n    Material material;\n};\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\nHit traceSphere(Ray r, Sphere s)\n{\n    float dist = raySphereIntersect(r.r0, r.rd, s.s0, s.sr);    \n    if (dist > 0.0) {\n        vec3 p = r.r0 + r.rd * dist;\n        vec3 n = normalize(p-s.s0);\n        return Hit(dist, n, s.material, s.id);\n    }\n    return Hit(-1.0, vec3(0.0), s.material, -1);\n}\n\nvec3\npos(int id)\n{\n    // TODO return a whole sphere not just center\n    float fx = 2.0;\n    float fy = 2.0;\n    float fz = 2.0;\n    float num = 3.0;\n    float t = (iTime*0.05+float(id)/num) * 3.14159 * 2.0;\n    return vec3(\n        sin(fx*t) * 2.5,\n        cos(fy*t) * 1.5,\n        sin(fz*t) * 1.5 + 9.0);\n}\n\nHit trace(Ray r)\n{\n    // TODO should be a loop\n    Sphere s1 = Sphere(0, pos(0), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Sphere s2 = Sphere(1, pos(1), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Sphere s3 = Sphere(2, pos(2), 0.7, Material(vec3(0.8, 0.7, 0.6)) );\n    Hit h1 = traceSphere(r,s1);\n    Hit h2 = traceSphere(r,s2);\n    Hit h3 = traceSphere(r,s3);\n    \n    // Find closest ray hit\n    Hit h;\n    h.dist = -1.0;\n    h = h1;\n    if ((h2.dist > 0.0 && h2.dist < h.dist) || (h.dist < 0.0)) h = h2;\n    if ((h3.dist > 0.0 && h3.dist < h.dist) || (h.dist < 0.0)) h = h3;\n    \n    // Shade hit\n    if (h.dist > 0.0) {\n        h.material.c = vec3(0.0);\n        float direct = dot(h.normal, normalize(vec3(0.5, 0.5, -1)));\n        vec3 albedo = pal_1(0.9);\n        h.material.c += albedo * direct;\n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (0..1)\n    vec2 ndc = fragCoord/iResolution.xy;\n    \n    const float fov_x_deg = 60.0;\n    const float screen_distance = 1.0/tan(radians(fov_x_deg/2.0));\n    \n    // \"Screen\" space coordinates (-1..+1 in max dimension)\n    vec2 sp = 2.0*(fragCoord-iResolution.xy/2.0)/max(iResolution.x, iResolution.y);\n    \n    // Left-handed camera ray: +X right, +Y up, +Z into scene\n    Ray cr;\n    cr.r0 = vec3(0.0);\n    cr.rd = vec3(sp.x, sp.y, screen_distance);\n\n    // Sample radiance\n    vec3 c = vec3(0.0);\n    Hit h = trace(cr);\n    if (h.dist >= 0.0) {\n        c += h.material.c;\n    } else {\n        //c += vec3(abs(sp.x), abs(sp.y), 0.0);\n    }\n    \n    // Comp stripes\n    if (true) {\n        float x = ( sp.y) * 70.0;\n        int n = int(mod(x, 4.0));\n        vec3 c2 = c;\n        if (h.id == -1 || (h.id == n || h.id == n+1)) {\n          c2 = pal_1(float(n)*0.25 + iTime*0.2);\n        }\n\t\tfloat on = 5.0;\n        float off = 3.0;\n        float cycle_time = mod(iTime, on+off);\n        if (cycle_time < on) {\n            c = c2;\n        } else {\n          c = mix(c, c2, cos((cycle_time-on)/off*3.14159*2.0)*0.5+0.5);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(c.x, c.y, c.z, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 229], [231, 297, 365, 365, 408], [409, 409, 433, 433, 529], [783, 783, 846, 1067, 1310], [1311, 1311, 1345, 1345, 1609], [1611, 1611, 1629, 1679, 1919], [1921, 1921, 1939, 1968, 2748], [2750, 2750, 2807, 2851, 4050]], "test": "ok"}
{"id": "tljGzz", "name": "Pattern07_", "author": "Del", "description": "sin", "tags": ["sin", "pattern"], "likes": 3, "viewed": 272, "published": "Public API", "date": "1558358339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    pos*=0.5;\n    pos+=vec2(0.5);\n\tfloat vv = pos.y*pos.y;\n\tvv+=sin(pos.x*3.14);\n\tfloat v = sin(sin(pos.x*16.0)+(vv+iTime*.1) * 12.0)+0.95;\n\tfragColor = vec4( v*1.2, .5*v, 0.5*v, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 315]], "test": "ok"}
{"id": "tll3Dl", "name": "mandelbrot_zoom_test", "author": "Noahiscool13", "description": "basic Mandelbrot zoom.\nmy first glsl shader!", "tags": ["math"], "likes": 1, "viewed": 58, "published": "Public", "date": "1558128467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int mandel(float x0, float y0, int its){\n    float x = 0.0;\n    float y = 0.0;\n    float x_tmp;\n    \n    int it = 0;\n    while (x*x+y*y<4.0 && it<its){\n        x_tmp = x*x-y*y+x0;\n        y = 2.0*x*y+y0;\n        x = x_tmp;\n        it++;\n    }\n    return it;\n}\n\nvec3 setup(vec2 uv, int its){\n    float x = uv.x;\n    float y = uv.y;\n    \n    x = x*3.5-2.5;\n    y = y*2.0-1.0;\n    \n    vec2 center = vec2(-0.7615720,-0.0847596);\n    float time_bias = tanh(min(31.0,iTime)/5.0);\n    \n\tx = time_bias*center.x+(1.0-time_bias)*x;\n    y = time_bias*center.y+(1.0-time_bias)*y;\n    \n    int res = mandel(x, y, its);\n    if (res==its) {\n        return vec3(0.6,0.2,0.2);\n    }\n    //float col_r = (float(res%51))/255.0;\n    //float col_g = (float(res%255))/255.0;\n    float col_g = (sin(float(res/3))+1.0)/2.0;\n    float col_b = (sin(float(res/37))+1.0)/2.0;\n    //float col_b = (float((res/9)%255))/255.0;\n    return vec3(0,col_g,col_b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = setup(uv, 1000);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tll3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 259], [261, 261, 290, 290, 930], [932, 932, 989, 1039, 1202]], "test": "ok"}
{"id": "tll3Dr", "name": "RayMarching - first attempt", "author": "dghez", "description": "Raymarching first attempt.\nThanks to https://www.youtube.com/watch?v=PGtv-dBi2wE&t=963s", "tags": ["raymarching"], "likes": 1, "viewed": 51, "published": "Public", "date": "1556800793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0.0, 1.0, 6.0, 1.0); // sphere xyz radius\n    float sphereDist = length(p-s.xyz) - s.w; // point - sphere origin - radius\n    float planeDist = p.y; // plane distance, easy because same axes\n    float d = min(sphereDist, planeDist);\n    return d;\n    \n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST  || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 point){\n   float dist = GetDist(point);\n   vec2 e = vec2(0.01, 0.0);\n    vec3 n = dist - vec3(\n        GetDist(point-e.xyy), // same as p- vec3(0.01, 0.0, 0.0);\n        GetDist(point-e.yxy),\n        GetDist(point-e.yyx)\n    );\n    \n    return normalize(n);\n    \n}\n\nfloat GetLight(vec3 point){\n    vec3 lightPos = vec3(0.0, 5.0, 6.0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 lightVec = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    float dif = clamp(dot(n, lightVec), 0.0, 1.0);\n    float distancePointLight = RayMarch(point + n * SURF_DIST * 2.0, lightVec);\n    if(distancePointLight < length(lightPos - point)) dif *= 0.1; // i'm in the shadow\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    // origin camera (ray origin)\n    vec3 ro = vec3(0.0, 1.0, 0.0);\n    \n    //camera direction (ray direction)\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float d = RayMarch(ro, rd); \n    vec3 point = ro + rd * d;\n    \n    float diffuse = GetLight(point);\n    col = vec3(diffuse);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tll3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 92, 92, 364], [367, 367, 400, 400, 621], [623, 623, 650, 650, 906], [908, 908, 935, 935, 1341], [1344, 1344, 1401, 1401, 1856]], "test": "ok"}
{"id": "tll3zB", "name": "Warp Tunnel", "author": "fizzer", "description": "One of the rare occasions that I actually make a tunnel effect. It's the old camera-in-scrolling-torus trick, but this torus is made of 6 cones so it can be efficiently raytraced with many rays per pixel.", "tags": ["raytracing", "tunnel", "fast", "warp"], "likes": 45, "viewed": 1446, "published": "Public", "date": "1556910072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.);\nconst float innerR = 1.;\nconst float outerR = 12.;\n\nfloat globalTime = 0.;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Adapted from IQ's iCappedCone: https://www.shadertoy.com/view/llcfRf\n// Simplified with the assumption that the cone's axis is always the Z axis, and\n// that the caps are not needed.\n// Also, it automatically returns either the near or far intersection depending on\n// the Z order of the endpoints.\nfloat intersectCone( in vec3  ro, in vec3  rd, \n                    in float ra, in float rb,\n                    in float  paz, in float pbz)\n{\n    float ba = pbz - paz;\n    vec3  oa = ro - vec3(0, 0, paz);\n    vec3  ob = ro - vec3(0, 0, pbz);\n\n    float m0 = ba * ba;\n    float m1 = oa.z * ba;\n    float m2 = ob.z * ba; \n    float m3 = rd.z * ba;\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n\n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n\n    float t0 = (-k1-sqrt(h))/k2;\n    float t1 = (-k1+sqrt(h))/k2;\n\n    float y0 = m1 + t0*m3;\n    float y1 = m1 + t1*m3;\n\n    if(paz>pbz)\n        return ( y0>0.0 && y0<m0 ) ? (-k1-sqrt(h))/k2 : -1.;\n    else\n        return ( y1>0.0 && y1<m0 ) ? (-k1+sqrt(h))/k2 : -1.;\n}\n\n\nfloat trace(vec3 ro, vec3 rd, out vec3 nearN, out vec2 nearUV)\n{\n    const int N = 6;\n\n    float minT = 1e4;\n    float outTh0 = 0., outTh1 = 0.;\n\n    float twist = globalTime / 2.5;\n\n    // Make a torus from cones\n    \n    for(int i = 0; i < N; ++i)\n    {\n        float th0 = pi * 2. / float(N) * float(i + 0) + twist;\n        float th1 = pi * 2. / float(N) * float(i + 1) + twist;\n\n        float z0 = sin(th0) * innerR;\n        float z1 = sin(th1) * innerR;\n\n        float r0 = outerR + cos(th0) * innerR;\n        float r1 = outerR + cos(th1) * innerR;\n\n        float t = intersectCone(ro, rd, r0, r1, z0, z1);\n\n        if(t > 0. && t < minT)\n        {\n            // Save only the pertinent data for later construction\n            // of shading inputs.\n            outTh0 = th0;\n            outTh1 = th1;\n            minT = t;\n        }\n    }\n\n    if(minT > 1e3)\n        return -1.;\n\n    float th0 = outTh0;\n    float th1 = outTh1;\n    float th2 = (th0 + th1) / 2.;\n\n    vec3 rp = ro + rd * minT;\n\n    float phi = atan(rp.y, rp.x);\n\n    // Get the surface differentials and a reference point for texturing\n    \n    vec3 tangent = \tnormalize(vec3(cos(phi) * cos(th1), sin(phi) * cos(th1), sin(th1)) -\n                              vec3(cos(phi) * cos(th0), sin(phi) * cos(th0), sin(th0)));\n\n    float incircleRadius = innerR * cos(pi / float(N));\n\n    vec3 midPoint = vec3(cos(phi) * (outerR + cos(th2) * incircleRadius),\n                         sin(phi) * (outerR + cos(th2) * incircleRadius), sin(th2) * incircleRadius);\n\n    nearUV.x = (phi + pi) / pi * 16.;\n    nearUV.y = dot(rp - midPoint, tangent);\n\n    nearN = vec3(cos(phi) * cos(th2), sin(phi) * cos(th2), sin(th2));\n\n    return minT;\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n\nvec4 render(vec2 fragCoord)\n{    \n    vec4 jitter = texelFetch(iChannel0, ivec2(fragCoord * 2.) & 1023, 0);\n\n    // Motion blur jitter\n    globalTime = iTime + jitter.x * 1. / 50.;\n    \n    jitter = jitter.yzxw;\n\n    // Set up primary ray, including ray differentials\n\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(outerR, sin(globalTime / 7.) * .3, cos(globalTime / 5.) * .3);\n    vec3 rd = normalize(vec3(p, -1.5));\n    \n    // Rotation transformation. There is no translation here, because the tunnel\n    // motion is faked with texture scrolling.\n\n    mat3 m = rotZ(globalTime / 2.) * rotX(cos(globalTime / 4.) * .2) * rotY(sin(globalTime / 3.) * .2);\n\n    m = rotX(pi/2.)*m;\n\n    rd = m * rd;\n\n    vec3 nearN = vec3(0);\n    vec2 nearUV = vec2(0);\n\n    vec3 transfer = vec3(1);    \n    vec4 fragColor = vec4(0);\n\n    // Trace ray bounces\n    for(int j = 0; j < 3; ++j)\n    {\n        float t0 = trace(ro, rd, nearN, nearUV);\n\n        if(t0 < 0.)\n            break;\n\n        vec3 rp = ro + rd * t0;\n\n        vec3 c = vec3(0);\n\n        // Fake motion-blurred camera motion by blurring the\n        // surface shading. Note that the non-jittered time value\n        // is used here as a base time for the blur offset.\n        \n        const int motionBlurSamples = 5;\n\n        for(int i = 0; i < motionBlurSamples; ++i)\n        {\n            // Tunnel surface shading\n            float time = iTime + (float(i) + jitter.x) / float(motionBlurSamples) * (1. / 60.);\n            vec2 uv = nearUV;\n            uv.x += time * 5.;\n            c += vec3(pow(1. - smoothstep(0.1, .4, length(fract(uv + vec2(.25, .5)) - .5)),8.)) * vec3(.3, .5, 1.) * 2.;\n            c += vec3(1. - smoothstep(0.1, .11, length(fract(uv + vec2(.25, .5)) - .5))) * vec3(.3, .5, 1.) * 4.;\n            c += vec3(step(.9, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 3.;\n            c += vec3(step(.95, fract(uv.x - .3))) / 2. * vec3(.4, .4, 1.) * 6.;\n            c += step(abs(textureLod(iChannel1, uv / 15. + time / 10. * vec2(1, 0), 0.).r - .6), .2) / 4. * vec3(.4, .4, 1.);\n            c += step(abs(textureLod(iChannel1, uv / 15. + time / 10. * vec2(1, 0), 0.).r - .6), .02) * 2. * vec3(.4, .4, 1.);\n            c += step(abs(uv.y), .01) * 1.5;\n            c += step(abs(uv.y - .5), .01) * 1.5;\n        }\n\n        c /= float(motionBlurSamples);\n\n        // Fog\n        c = mix(vec3(1) * vec3(.5,.5,1), c, exp2(-t0 / 13.));\n\n        // Tint\n        c *= vec3(.6, .6, 1) / 1.3;\n\n        // Accumulate\n        fragColor.rgb += c * transfer;\n        \n        // Reflection amount\n        transfer *= .8 * pow(clamp(1. - dot(-nearN, -rd), 0., 1.), 4.);\n\n        if(max(max(transfer.x, transfer.y), transfer.z) < 1e-3)\n            break;\n        \n        // Reflect\n        ro = rp + nearN * 1e-4;\n        rd = reflect(rd, nearN);\n\n        jitter = jitter.yzxw;\n    }\n\n    fragColor.a = 1.;\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec3 backg = vec3(.07);\n\n    // Anti-aliasing loop\n\n    for(int y = 0; y < 2; ++y)\n        for(int x = 0; x < 2; ++x)\n        {\n            vec4 r = render(fragCoord + vec2(x,y) / 2.);\n            r.rgb = mix(backg, r.rgb, r.a);\n            fragColor.rgb += clamp(r.rgb, 0., 1.);\n        }\n\n    fragColor /= 4.;\n\n\t// Tonemap and \"colourgrade\"\n    \n    fragColor /= (fragColor + .4) / 1.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1,1.4,1.8));\n\n    // Gamma correction\n    \n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tll3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 129, 129, 148], [150, 452, 596, 596, 1414], [1417, 1417, 1481, 1481, 3115], [3117, 3117, 3137, 3137, 3241], [3243, 3243, 3263, 3263, 3367], [3369, 3369, 3389, 3389, 3493], [6446, 6446, 6503, 6503, 7104]], "test": "error"}
{"id": "tllGRB", "name": "Blue Rock", "author": "ArmanD", "description": "I still don't know what happened !", "tags": ["3d", "raymarching", "ray", "normals", "light", "marching", "red", "blue", "wtf", "rock", "movinglight", "mehnir"], "likes": 1, "viewed": 44, "published": "Public", "date": "1556803641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color = vec3(1);\nfloat getDist (vec3 p ){\nvec4 s = vec4 (0. ,1. ,6. ,1.);\n//  s.xz  *= rot (time);\nfloat sphereDist =length (p-s.xyz)-s.w\n-sin (p.x)*3.;\nfloat planeDist = p.y;\nfloat d = min ( planeDist ,sphereDist );\n    if(d == planeDist){ color = vec3(0,0,1);}\n    else{color = vec3 (1,0,0);}\nreturn d;\n}\n  float rayMarch (vec3 ro , vec3 rd){\nfloat  d = 0.0;\nfor ( int i = 0 ; i < 100 ; i++){\n  vec3 p = ro + rd * d;\n  float ds = getDist(p);\n  d += ds;\n    if ( d > 100. || ds < 0.0000001){//1./iTime){\n  break;\n  }}\nreturn d;\n}\nvec3 getNormal (vec3 p){\nfloat d = getDist(p);\nvec2 e = vec2 (.01 , 0. );\n \nvec3 n = d-vec3 (\ngetDist(p-e.xyy) ,\ngetDist(p-e.yxy) ,\ngetDist(p-e.yyx) );\nreturn normalize (n);\n}\n\n  float getLight(vec3 p){\n  vec3 lightPos = vec3 (0 , 100. , 6);\nlightPos.xz += 50. * vec2  (sin (iTime),cos (iTime));\n  vec3 l = normalize (lightPos-p);\n  vec3 n = getNormal (p);\n  float dif = max (dot (l,n),0.);\n    float d = rayMarch (p+n*iTime, l);\n    if (d < length (lightPos-p)) dif *= .1;\n  return dif;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   float ratio = iResolution.y / iResolution.x;\nvec2 uv = (fragCoord.xy  / iResolution.x)\n- vec2 (0.5 , 0.5 *  ratio);\n\n    vec3 ro = vec3 (0. ,1. ,-10.);\n    vec3 rd = normalize (vec3 (uv.xy ,1.));\n\n\n    float d = rayMarch (ro ,rd);\n\n    vec3 p= ro + rd * d;\n    float dif = getLight (p);\n\n  vec3  col = vec3 (dif*color);\n \n\n\tfragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 46, 46, 311], [314, 314, 349, 349, 535], [536, 536, 560, 560, 711], [715, 715, 738, 738, 1027], [1029, 1029, 1086, 1086, 1449]], "test": "ok"}
{"id": "tllGWj", "name": "3D Voronoi-textured Spheres", "author": "clepirelli", "description": "Lit raytraced spheres from https://www.shadertoy.com/view/tdBXDc with voronoi texture. \n\nUse mouse input to scramble the noise.\n\nCredit to Ronja's tutorial https://www.ronja-tutorials.com/2018/09/29/voronoi-noise.html", "tags": ["raytracing", "voronoi", "texture", "sphere"], "likes": 3, "viewed": 415, "published": "Public API", "date": "1557748122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define E 2.71828\n\n//ray data, used to get the pixel color by sending (or casting) a ray per pixel into the scene\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//material represents the way light bounces off the surface of a primitive\nstruct material\n{\n\tfloat kSpecular;\n    float kDiffuse;\n    float glossiness;\n};\n    \n//one-color sphere\nstruct sphere\n{\n\tvec3 origin;\n    vec3 color;\n    float radius;\n    material mat;\n};\n    \n//point light\nstruct light\n{\n    vec3 origin;\n  \tfloat intensity;\n};\n    \nstruct directionalLight\n{\n    vec3 direction;\n    float intensity;\n};\n\nstruct intersection\n{\n    //distance from the origin of the ray to the intersection\n    float dist;\n    //color of the primitive at the intersection\n    vec3 color;\n    //normal of the primitive at the intersection\n    vec3 normal;\n    //material of the primitive at the intersection\n    material mat;\n};\n\nvec3 pseudorandPos(vec3 randseed)\n{\n    return abs(cos(fract(randseed * dot(sin(randseed * 242.589), vec3(42.48391588, 24.47571723, .91711988))) * 294419.4857));\n}\n\nfloat pseudorandScalar(float randseed)\n{\n\treturn fract(dot(vec3(sin(randseed*194.0154)), vec3(1043.94219, 4920.22948, 744.2918)));\n}\n\nvec3 getCell(vec3 pos)\n{\n    vec3 baseCell = floor(pos);\n    float minDistToCell = 10000.0;\n    vec3 closestCell = vec3(.0);\n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            for(int k = -1; k <=1; k++)\n            {\n            \tvec3 cell = baseCell + vec3(i,j,k);\n                vec3 cellPos = cell + pseudorandPos(cell);\n                vec3 toCell = cellPos - pos;\n                float distToCell = length(toCell);\n                minDistToCell = mix(distToCell, minDistToCell, float(distToCell > minDistToCell));\n            \tclosestCell = mix(cell, closestCell, float(distToCell > minDistToCell));\n            }\n        \t\n        }\n    }\n    \n\treturn pseudorandPos(closestCell);\n}\n\nconst float renderDistance = 1.0;\n\n//return value if a ray misses a primitive\nconst intersection miss = intersection(9999.0, vec3(.0), vec3(.0), material(.0, .0, .0));\n\n\n\nconst int sphereCount = 6;\n\nconst int lightCount = 3;\n\nconst float ambientLight = .1;\n\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(.0, 1.0, .0);\nconst vec3 RED = vec3(1.0, .0,.0);\nconst vec3 TEAL = vec3(.0, 1.0, 1.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, .0);\n\n\n//gets the intersection between a ray and a sphere\n//from : https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/minimal-ray-tracer-rendering-spheres\nintersection sphereIntersect(in ray pRay, in sphere pSphere)\n{\n    float radius2 = pSphere.radius*pSphere.radius;\n    vec3 L = pSphere.origin - pRay.origin; \n    float tca = dot(L, pRay.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss; \n    float thc = sqrt(radius2 - d2); \n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float t = min(t0, t1);\n    \n    vec3 hit = pRay.origin + pRay.direction * t;\n    vec3 coords = hit - pSphere.origin;\n    //return the distance from the ray's origin to the point\n    return intersection(t, pSphere.color, normalize(pSphere.origin - hit), pSphere.mat);\n}\n\nfloat lightAura(in ray pRay, in light pLight, sphere[sphereCount] spheres)\n{\n\t//distance from the ray's origin to the light's origin\n    float distanceToLightOrigin = distance(pLight.origin, pRay.origin);\n    \n    //projection of the ray on the light, aka the point on the ray which is the closest to the light's origin\n    vec3 rayProjection = pRay.origin + pRay.direction * distanceToLightOrigin;\n    \n    return pLight.intensity /(distance(pLight.origin, rayProjection)*100.0);\n}\n\n//mixes two intersection\nintersection mixIntersections(intersection a, intersection b, float mixRatio)\n{\n\treturn intersection\n            (\n            mix(a.dist, \tb.dist, \tmixRatio),\n            mix(a.color, \tb.color, \tmixRatio),\n            mix(a.normal, \tb.normal, \tmixRatio),\n            material\n                (\n                mix(a.mat.kSpecular, \tb.mat.kSpecular, \tmixRatio),\n                mix(a.mat.kDiffuse, \tb.mat.kDiffuse, \tmixRatio),\n                mix(a.mat.glossiness, \tb.mat.glossiness, \tmixRatio)\n\t\t\t\t)\n            );\n}\n\nfloat getDiffuse(intersection pIntersection, vec3 lightDirection)\n{\n    //clamp the dot product of the normal of the point and of the origin of the light\n\treturn clamp(dot(pIntersection.normal, lightDirection), .0, 1.0) * pIntersection.mat.kDiffuse;\n}\n\n\nfloat getSpecular(vec3 point, intersection pIntersection, ray pRay, vec3 lightDirection)\n{\n    //reflection of the light on the surface\n    vec3 reflection = reflect(lightDirection, pIntersection.normal);\n    \n    //specular term\n    //Thanks to UglySwedishFish#3207 on discord for their help with this :\n    //dot products range from -1 to 1, so the dot product of the reflection and the ray's direction\n    //has to be clamped so that a negative value doesn't get squared into a positive value\n    return pow(clamp(dot(normalize(reflection), pRay.direction), .0, 1.0), pIntersection.mat.glossiness) * pIntersection.mat.kSpecular;\n}\n\nconst float CELL_SIZE = .1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    directionalLight SUN = directionalLight(normalize(vec3(-.5, -1.5, 1.5)), 2.0);\n    \n    ray currentRay = ray(vec3(uv.xy, .0), normalize(vec3(uv, 1.))); \n    \n    material mat = material(.7, .2, 32.);    \n    \n    //sphere definitions\n    sphere spheres[sphereCount] = sphere[sphereCount]\n\t(\n\t\tsphere(vec3(cos(time), .2, .5), \tWHITE,\t\t.2, mat),\n\t    sphere(vec3(.5, .2 * cos(iTime), .45), \t\tWHITE,\t.4,mat),\n        sphere(vec3(.1, sin(iTime), .5), \t\tWHITE,\t.2,mat),\n        sphere(vec3(-.7, .0, .3), \t\t\t\tWHITE,\t.1, mat),\n        sphere(vec3(sin(time), .0, .4), WHITE,\t.1, mat),\n        sphere(vec3(.0, sin(iTime), .6), \t\t\t\tWHITE,\t.5,mat)\n\t);\n    \n    //light definitions\n    light lights[lightCount] = light[lightCount]\n    (\n        light(vec3(1.0, .2, 10.0 + abs(sin(iTime)*10.0)), 1.),\n        light(vec3(.0, -2.0, 10.0), 1.),\n        light(vec3(1.0, 1.0, .0), 5.)\n    );    \n    \n    intersection finalIntersection = miss;\n    \n    //for every sphere, see whether the ray intersects it\n    for(int i = 0; i < sphereCount; i++)\n    {\n        //sphere intersection returns the distance at which the sphere is intersected\n        intersection currentIntersection = sphereIntersect(currentRay, spheres[i]);\n        \n        //if the current distance is smaller than the final distance\n        //set the final intersection to be the current intersection\n        float distanceSmaller = float(currentIntersection.dist < finalIntersection.dist);\n        finalIntersection = mixIntersections(finalIntersection, currentIntersection, distanceSmaller);\n    }\n    \n    //whether the ray missed or not\n    bool rayMissed = finalIntersection.dist >= miss.dist;\n    \n    //the point where the ray hit a primitive\n    vec3 hit = currentRay.origin + currentRay.direction * finalIntersection.dist;\n    \n    vec3 finalCol = vec3(.0);\n    \n    //sun light\n    finalCol += min(finalIntersection.color * \n        (\n            getDiffuse(finalIntersection, SUN.direction) + \n            getSpecular(hit, finalIntersection, currentRay, SUN.direction)\n            + ambientLight\n        ) * \n        SUN.intensity ,1.0)*\n        clamp(dot(finalIntersection.normal, SUN.direction), ambientLight, 1.0);\n    \n    for(int i = 0; i < lightCount; i++)\n    {        \n        //the light's intensity is its intensity variable divided by its attenuation over distance\n        float lightIntensity = lights[i].intensity / pow(distance(hit, lights[i].origin), 2.0);                \n        vec3 lightDirection = normalize(hit - lights[i].origin);\n        \n        //final color\n    \tfinalCol +=\n        \t//color of the primitive\n        \tfinalIntersection.color *\n            //lighting terms\n        \t(\n            getDiffuse(finalIntersection, lightDirection)\n            + getSpecular(hit, finalIntersection, currentRay, lightDirection)\n            + ambientLight\n            ) *\n            //intensity of the light\n            lightIntensity *\n            clamp(dot(finalIntersection.normal, lightDirection), ambientLight, 1.0);\n    }\n    \n    vec3 col = getCell((hit + iMouse.xyx)/CELL_SIZE);\n    finalCol *= col;\n\n\t//background color\n\tvec3 bgCol = vec3(.4, .2, .9);\n    bgCol = clamp(bgCol, .0, 1.0);\n    //select between the background color (if the ray missed) and the final color (if the ray hit)\n    finalCol = mix(finalCol, bgCol, float(rayMissed));\n    \n    // Output to buffer\n    fragColor = vec4(finalCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[890, 890, 925, 925, 1053], [1055, 1055, 1095, 1095, 1187], [1189, 1189, 1213, 1213, 1925], [2368, 2565, 2627, 2627, 3199], [3685, 3710, 3789, 3789, 4227], [4229, 4229, 4296, 4382, 4480], [4483, 4483, 4573, 4618, 5116], [5147, 5147, 5204, 5204, 8793]], "test": "ok"}
{"id": "tllGWX", "name": "Stutter Circle", "author": "ssell", "description": "Circle with simulated poor FPS on the left in red, circle with good FPS on the right in green.\n\nUsed in an answer to https://stackoverflow.com/questions/56149670/glsl-shader-circle-is-wobbling-as-it-changes-size-in-libgdx", "tags": ["circle"], "likes": 1, "viewed": 113, "published": "Public", "date": "1557935562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smoothCircle(vec2 pos, vec2 center, float radius)\n{ \n    float smoothness = 2.0 / iResolution.x;\n    float distFromCenter = distance(pos, center);\n    float col = smoothstep(radius, radius + smoothness, distFromCenter);\n\n    return 1.0 - col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float stutterTime = floor(iTime * 10.0) / 10.0;\n\n    float stutterRadius = abs(sin(stutterTime)) * 0.25 + 0.05;\n    float smoothRadius  = abs(sin(iTime)) * 0.25 + 0.05;\n    \n    float stutterCover = smoothCircle(uv, vec2(0.5, 0.5), stutterRadius);\n    float smoothCover  = smoothCircle(uv, vec2(1.25, 0.5), smoothRadius);\n    \n    vec4 stutterColor = vec4(1.0, 0.0, 0.0, 0.5);\n    vec4 smoothColor  = vec4(0.0, 1.0, 0.0, 0.5);\n    \n    fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    fragColor = mix(fragColor, smoothColor, smoothCover);\n    fragColor = mix(fragColor, stutterColor, stutterCover);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 250], [252, 252, 307, 307, 993]], "test": "ok"}
{"id": "tls3Dl", "name": "Pattern08_", "author": "Del", "description": "pattern", "tags": ["sin", "pattern"], "likes": 4, "viewed": 324, "published": "Public API", "date": "1558129183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = 3.0-length(1.5*pos)*4.0;\n    pos*=rot(pos.x*4.0+iTime+log(d));\n    pos*=0.5;\n    pos+=vec2(0.5);\n\tfloat vv = (pos.y*pos.y*pos.y*d);\n\tvv+=sin(pos.x*3.14);\n\tfloat v = sin(sin(pos.x*15.0)*4.0+(vv) * 2.5 + iTime * 2.0);\n\tfragColor = vec4( v*0.54, .25+.2*v, 0.3, 1.0 )*d;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tls3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 89], [91, 91, 148, 148, 506]], "test": "ok"}
{"id": "tls3WB", "name": "Recursive Donut", "author": "ShnitzelKiller", "description": "Everything is chrome in the future. Also mousable.", "tags": ["fractal", "interactive", "torus", "mousable"], "likes": 25, "viewed": 562, "published": "Public API", "date": "1557704405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define fdist 0.3\n#define iters 40\n#define tol 0.005\n#define maxdist 5.\n#define gradient_eps 0.01\n\n//shape parameters\n//#define ring_count 7\n//#define ringdiff 5.\n#define min_rings 3.\n#define max_rings 10.\n#define levels 4\n#define ratio 0.4\n#define ring_offset 1.5\n#define offsetdiff 0.8\n#define indent 0.2\n#define base_radius 2.\n#define ao_radius 0.05\n#define ao_min 0.2\n#define repeat_offset 8.\n#define laplace_factor 100.\n#define reflections 1\n#define reflection_eps 0.01\n#define reflection_albedo 0.3\n#define light_dir vec3(0.436436,0.872872,0.218218)\n#define n1 1.0\n#define n2 1.0\n#define plane_height -2.\n#define shadow_step 0.05\n#define shadow_eps 0.01\n#define shadow_iters 10\n#define shadow_maxdist 1.5\n#define shadow_sharpness 2.\n#define ambient 0.2\n\n\nfloat R0 = (n1-n2)/(n1+n2);\n\nvec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nvec2 sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    \n    float theta = atan(p.x, p.z); //outer angle\n    return vec2(d, theta);\n}\n\nfloat delay_sin(float t) {\n    return cos(PI*((abs(mod(t, 2.)-1.)+t)*0.5-0.5));\n}\nfloat map(vec3 p) {\n    //p = mod(p+0.5*repeat_offset, repeat_offset)-0.5*repeat_offset;\n    //time-varying parameters (maybe replace with some inputs, or remove)\n    float final_offset;\n    if (iMouse.w < 1.)\n        final_offset = offsetdiff*delay_sin(iTime*0.5+1.) + ring_offset;\n    else\n        final_offset = (iMouse.y/iResolution.y-0.5)*3.+2.;\n    float final_ratio = ratio/final_offset;\n    \n    float ringdiff = (max_rings-min_rings)*0.5;\n    float ring_count = (max_rings+min_rings)*0.5;\n    float final_ringcount;\n    if (iMouse.z < 1.)\n    \tfinal_ringcount = ringdiff*delay_sin(iTime*0.5)+ring_count;\n    else\n    \tfinal_ringcount = ringdiff*(iMouse.x/iResolution.x-0.5)*2. + ring_count;\n    float sector = 2.*PI/(final_ringcount);\n    float outerrad = base_radius;\n    float innerrad = outerrad*final_ratio;\n    vec2 h = sdTorus(p, vec2(outerrad, innerrad));\n    int i;\n    float currindent = indent;\n    vec2 minh = h;\n    \n    for (i=0; i<levels; i++) {\n        \n        //mod polar coordinates\n        float theta = mod(abs(h.y), sector)-sector/2.;\n        \n        //new cartesian coords\n        float s = length(p.zx);\n        p.z = cos(theta)*s - outerrad;\n        p.x = sin(theta)*s;\n        p = p.zxy;\n        \n        //new torus\n        outerrad = innerrad*final_offset;        \n        innerrad = outerrad*final_ratio;\n        h = sdTorus(p, vec2(outerrad, innerrad));\n        \n        minh.x = max(minh.x, currindent-h.x);\n        if (h.x < minh.x) {\n            minh = h;\n        }\n        \n        currindent = currindent * final_ratio * final_offset;\n    }\n    return minh.x;\n}\n\nvec4 gradient(in vec3 pos) {\n    vec3 offset = vec3(-gradient_eps, 0.0, gradient_eps);\n    float dx0 = map(pos+offset.xyy);\n    float dxf = map(pos+offset.zyy);\n    float dy0 = map(pos+offset.yxy);\n    float dyf = map(pos+offset.yzy);\n    float dz0 = map(pos+offset.yyx);\n    float dzf = map(pos+offset.yyz);\n    float ddd = map(pos);\n    return vec4(normalize(vec3(dxf - dx0, dyf - dy0, dzf - dz0)), dx0+dxf+dy0+dyf+dz0+dzf-6.*ddd);\n}\n\nvec2 raymarch(vec3 pos, vec3 dir) {\n    int i;\n    float d = 0.;\n    float dist;\n    for (i=0; i<iters; i++) {\n        dist = map(pos+d*dir);\n        d += dist;\n        if (dist < tol) {\n            return vec2(d, 2.);\n        } else if (dist > maxdist) {\n            break;\n        }\n    }\n\td = (plane_height-pos.y) / dir.y;\n    return vec2(d, step(-d, 0.)*step(length((pos+d*dir).zx), 50.));\n}\n\n//softer soft shadows\n//see https://www.shadertoy.com/view/4tBcz3\nfloat shadowtrace(vec3 pos, vec3 dir) {\n    int i;\n    float d = shadow_eps;\n    float dist = map(pos+d*dir);\n    float fac = 1.0;\n    for (i=0; i<shadow_iters; i++) {\n        d += max(0.01, dist);\n        dist = map(pos+d*dir);\n        fac = min(fac, dist * shadow_sharpness / d);\n    }\n    return mix(mix(0.5, 0., -fac), mix(0.5, 1., fac), step(fac, 0.));\n}\n\nvec3 skycol(vec3 rd) {\n    return vec3(0.6, 0.7, 0.8)*(1.+pow(max(dot(rd, light_dir), 0.), 2.)) + pow(max(0.,dot(rd, light_dir)), 5.);\n}\n\nfloat schlick(vec3 rd, vec3 n) {\n    return 1.-(R0+(1.-R0)*pow(max(dot(n.xyz, -rd), 0.), 5.0));\n}\n\nvec3 material(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    if (record.y > 1.5) {\n        float edgefac = abs(n.w*laplace_factor);\n        vec3 color = 1.-viridis_quintic(edgefac).yxz*0.5;\n        float fac = max(ambient, dot(light_dir, n.xyz));\n        //float ao = min(1.,ao_min+(record.z > ao_radius ? 1. : record.z/(ao_radius)));\n        return fac*color;\n    } else if (record.y > 0.5) {\n        vec2 uv = (ro+rd*record.x).zx;\n        uv = abs(mod(uv, 4.)-2.);\n        float checker = abs(step(uv.x, 1.) - step(uv.y, 1.));\n        return vec3(light_dir.y*(0.5+0.5*checker));\n    } else {\n        return skycol(rd);\n    }\n}\n\n//materials with reflections\nvec3 shade(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    vec3 shadedcolor = material(ro, rd, n, record);\n    if (record.y > 0.5) {\n        float fac = shadowtrace(ro+rd*record.x, light_dir);\n        shadedcolor *= max(ambient, fac);\n    }\n    if (record.y > 1.5) {\n        int i;\n        float final_albedo = reflection_albedo;\n        for (i=0; i<reflections; i++) {\n            if (record.y < 1.5) break;\n            final_albedo *= schlick(rd, n.xyz);\n            ro = ro+rd*record.x;\n            rd = reflect(rd, n.xyz);\n            ro += reflection_eps*rd;\n            record = raymarch(ro, rd);\n            n = gradient(ro+rd*record.x);\n            shadedcolor += final_albedo * material(ro, rd, n, record);\n        }\n        //compute last reflections with just envmap\n        if (record.y > 1.5) {\n            final_albedo *= schlick(rd, n.xyz);\n            shadedcolor += final_albedo * skycol(reflect(rd, n.xyz));\n        }\n    }\n    return shadedcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    R0*=R0;\n    //camera position\n    float s = sin(iTime*0.5);\n    float ww = iTime*0.2;\n    vec3 ro = (3.-s)*vec3(cos(ww),0.5+0.5*s,sin(ww));\n    vec3 w = normalize(vec3(0.,-1.5-s,0.)-ro);\n    vec3 u = normalize(cross(w, vec3(0., 10., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*fdist+(fragCoord.x/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y/2.0)/iResolution.x*v);\n\t\n    vec2 record = raymarch(ro, rd);\n    vec4 n = gradient(ro+rd*record.x);\n    vec3 shadedcolor = shade(ro, rd, n, record);\n    \n    fragColor = vec4(shadedcolor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tls3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[811, 811, 844, 844, 1391], [1393, 1393, 1424, 1424, 1576], [1578, 1578, 1604, 1604, 1659], [1660, 1660, 1679, 1822, 3265], [3267, 3267, 3295, 3295, 3702], [3704, 3704, 3739, 3739, 4099], [4101, 4167, 4206, 4206, 4526], [4528, 4528, 4550, 4550, 4664], [4666, 4666, 4698, 4698, 4763], [4765, 4765, 4819, 4819, 5391], [5393, 5422, 5473, 5473, 6386], [6388, 6388, 6445, 6445, 7007]], "test": "timeout"}
{"id": "tls3WX", "name": "in the soup", "author": "elenzil", "description": "working towards an understanding of heightmaps.\ncurrently just equating Altitude Above Surface with Distance To It, with expected artifacts.", "tags": ["mandelbrot", "heightmap", "grimoire"], "likes": 7, "viewed": 352, "published": "Public API", "date": "1557940633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// common stuff\nconst vec3  fv3_1   = vec3(1.0, 1.0, 1.0);\nconst vec3  fv3_0   = vec3(0.0, 0.0, 0.0);\nconst vec3  fv3_x   = vec3(1.0, 0.0, 0.0);\nconst vec3  fv3_y   = vec3(0.0, 1.0, 0.0);\nconst vec3  fv3_z   = vec3(0.0, 0.0, 1.0);\nconst vec2  fv2_1   = vec2(1.0, 1.0);\nconst vec2  fv2_0   = vec2(0.0, 0.0);\nconst vec2  fv2_x   = vec2(1.0, 0.0);\nconst vec2  fv2_y   = vec2(0.0, 1.0);\nconst float PI      = 3.14159265359;\nconst float TAU     = PI * 2.0;\n\n// less common\nconst float rmMaxSteps = 100.0;\nconst float rmMaxDist  = 180.0;\nconst float rmEpsilon  =   0.001;\nconst float grEpsilon  =   0.001;\n#define SMOOTH_MANDEL 1\n\nvec2 complexMul(in vec2 A, in vec2 B) {\n  return vec2((A.x * B.x) - (A.y * B.y), (A.x * B.y) + (A.y * B.x));\n}\n\nstruct POI {\n  vec2  center;\n  float range;\n  float maxIter;\n};\nvec4 poiToVec4(in POI poi) {return vec4(poi.center, poi.range, poi.maxIter);}\nPOI vec4ToPOI(in vec4 v) {return POI(v.xy, v.z, v.w);}\n\n\nfloat mandelEscapeIters(in vec2 C, in float maxIters) {\n  vec2 Z = C;\n  for (float n = 0.0; n < maxIters; n += 1.0) {\n    Z  = complexMul(Z, Z) + C;\n    if (dot(Z, Z) > 4.0) {\n      return n;\n    }\n  }\n  return maxIters;\n}\n\n// adapted from IQ\n// http://iquilezles.org/www/articles/distancefractals/distancefractals.htm\nfloat mandelDist(in vec2 c, float numIters)\n{\n  vec2  z = vec2(0.0, 0.0);\n  vec2 dz = vec2(0.0, 0.0);\n  \n  float m2;\n  for (float n = 0.0; n < numIters; ++n) {\n    dz = 2.0 * complexMul(z, dz) + fv2_x;\n    z  = complexMul(z, z) + c;\n\n    m2 = dot(z, z);\n    if (m2 > 1.0e10) {\n      break;\n    }\n  }\n  \n  // distance estimation: G/|G'|\n  return sqrt(m2 / dot(dz, dz)) * 0.5 * log(m2);\n}\n\n// based on https://www.shadertoy.com/view/Wtf3Df\nvec3 getRayDirection(in vec3 ro, in vec3 lookAt, in vec2 uv, float zoom) {\n  vec3 ol       = normalize(lookAt - ro);\n  vec3 screenRt = cross(ol      , fv3_y); // world Up\n  vec3 screenUp = cross(screenRt, ol   );\n  vec3 rd       = normalize(uv.x * screenRt + uv.y * screenUp + ol * zoom);\n  return rd;\n}\n\nmat2 rot2(float t) {\n  float s = sin(t);\n  float c = cos(t);\n  return mat2(s, c, -c, s);\n}\n\nfloat sdfCircle2D(in vec2 p, in vec2 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat sdf(in vec3 p, out float bright) {\n  float mi = 20.0;\n  vec2 mp = p.xz;\n  mp.x += 0.35;\n  mp *= rot2(iTime * -0.2);\n  mp *= 0.05;\n  mp.x -= 0.25;  \n  bright = 1.0;\n  #if SMOOTH_MANDEL\n  float iters        = mandelDist(mp, mi);\n  bright = smoothstep(-0.001, 0.001, iters);\n  iters = max(0.0, iters);\n  iters = 1.0 / (iters + 0.1);\n  float mandelHeight = 0.4 * mi;\n  #else\n  float iters        = mandelEscapeIters(mp, mi);\n  float mandelHeight =  2.0;\n  #endif\n\n  // altitude above plane\n  float dist = p.y;\n\n  // some waves\n  dist += sin(p.x * 0.1 + iTime) * 2.0;\n\n  // the mandelbrot set\n  dist -= iters/mi * mandelHeight;\n\n  /*\n  // some pillars\n  const float pillarDist = 60.0;\n  const float pillarRad  = 10.0;\n  dist = min(dist, sdfCircle2D(p.xz, pillarDist * vec2(-1.0, -1.0), pillarRad));\n  dist = min(dist, sdfCircle2D(p.xz, pillarDist * vec2(-1.0,  1.0), pillarRad));\n  dist = min(dist, sdfCircle2D(p.xz, pillarDist * vec2( 1.0,  1.0), pillarRad));\n  dist = min(dist, sdfCircle2D(p.xz, pillarDist * vec2( 1.0, -1.0), pillarRad));\n  */\n\n  return dist;\n}\n\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\nvec3 estimateNormal(vec3 p) {\n  const float e = grEpsilon;\n  float unused;\n  return normalize(vec3(\n    sdf(vec3(p.x + e, p.y    , p.z     ), unused) - sdf(vec3(p.x - e, p.y    , p.z    ), unused),\n    sdf(vec3(p.x    , p.y + e, p.z     ), unused) - sdf(vec3(p.x    , p.y - e, p.z    ), unused),\n    sdf(vec3(p.x    , p.y    , p.z  + e), unused) - sdf(vec3(p.x    , p.y    , p.z - e), unused)\n  ));\n}\n\n\nvec3 march(in vec3 p, in vec3 rd, out float numSteps, out float bright) {\n  float distTotal = 0.0;\n  for (numSteps = 0.0; numSteps < rmMaxSteps; ++numSteps) {\n    float d = sdf(p, bright);\n    if ((d < rmEpsilon) || (distTotal > rmMaxDist)) {\n      return p;\n    }\n    p += rd * d;\n    distTotal += d;\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n  RGBA.a   = 1.0;\n\n  float smallWay = min(iResolution.x, iResolution.y);\n  vec2  uv = (XY * 2.0 - fv2_1 * iResolution.xy)/smallWay;\n  float t  = iTime * TAU * 0.01;\n  vec3  ro = vec3( vec2(cos(t), sin(t)) * 40.0, 10.0).xzy;\n  vec3  la = vec3( 0.0, 0.0,  0.0);\n  const float zoom = 3.2;\n  vec3  rd = getRayDirection(ro, la, uv, zoom);\n\n  float numSteps;\n  float sdfBright;\n  vec3 surf = march(ro, rd, numSteps, sdfBright);\n  float dist = length(ro - surf);\n\n  const float checkSize = 20.0;\n  // float bright = float((mod(surf.x, checkSize * 2.0) > checkSize) ^^ (mod(surf.z, checkSize * 2.0) > checkSize));\n  float bright = 1.0;\n  bright = bright * 0.05 + 0.95;\n // bright = 0.95;\n\n  // shading\n  bright *= max(0.3, dot(fv3_x, estimateNormal(surf)));\n\n  vec3 rgb = vec3(bright);\n\n  rgb.rg *= sdfBright * 0.7 + 0.3;\n  rgb.b  *= sdfBright * 0.3 + 0.7;\n\n\n  // fog\n  rgb *= 1.0 + surf.y * 0.2 - 0.5;\n  rgb = mix(rgb, vec3(0.5), clamp(dist/rmMaxDist - 0.1, 0.0, 1.0));\n\n  // gamma\n  rgb = pow(rgb, vec3(0.4545));\n  \n  // ray steps\n  // RGBA.r += numSteps / rmMaxSteps;\n\n  RGBA.rgb = rgb;\n\n}\n\n\n// grimoire bindings\n// out vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tls3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 664, 664, 735], [801, 801, 829, 829, 878], [879, 879, 905, 905, 933], [936, 936, 991, 991, 1158], [1160, 1255, 1300, 1300, 1641], [1643, 1693, 1767, 1767, 1996], [1998, 1998, 2018, 2018, 2088], [2090, 2090, 2140, 2140, 2170], [2172, 2172, 2212, 2212, 3237], [3239, 3319, 3348, 3348, 3719], [3722, 3722, 3795, 3795, 4041], [4043, 4043, 4086, 4086, 5171]], "test": "ok"}
{"id": "tls3zX", "name": "[twitch] Jewel Surface", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nYou can also try the color and shape options", "tags": ["3d", "reflection", "refraction"], "likes": 18, "viewed": 424, "published": "Public", "date": "1557179162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nYou can also try the color and shape options\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/JewelSurface.glsl\nInspired by https://www.shadertoy.com/view/ttl3R2\n*/\n\n#define MARCH_STEPS 100\n\n#define COLOR_GEM 1\n#define RED_GEM 0\n#define CHROMATIC 0\n\n#define SHAPE sphere\n//#define SHAPE box\n//#define SHAPE diamon\n//#define SHAPE cylinder\n\n#define time iTime\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*724.355)*685.655);\n}\n\nfloat bx(vec3 p) {\n  p=abs(p);\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n}\n\nfloat mat=1.;\nfloat id=0.;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float s=5.;\n  float mm=10000.;\n  id=0.;\n  for(int i=0; i<4; ++i) {\n    \n    float t=rnd1(float(i)+12.7)*75.842 + 122.845;\n    //t += time*(.1+i*.05);\n    p.xy *= rot(t);\n    p.yz *= rot(t*.7);\n    \n    id += dot(sign(p), vec3(1.72,3.84,12.94)*(float(i)+1.));\n    p=abs(p);\n    \n    float mp=min(p.x, min(p.y,p.z));\n    mm=min(mm,mp);\n    \n    p-=s;\n    \n    s*=0.7;\n  }\n    \n  \n  float d = mm;\n  \n  float dist=0.6;\n  vec3 rp=(fract(p/dist-.5)-.5)*dist;\n  float d3 = length(rp);\n  \n  float sphere = length(bp)-20.;\n  float box = bx(bp)-14.;\n  float diamon = box;\n  bp.xy *= rot(3.141592*.25);\n  bp.xz *= rot(3.141592*.25);\n  diamon = max(diamon, bx(bp)-12.);\n  \n  float cylinder = max(length(bp.xz)-14., length(bp.xy)-18.);\n  //shape = smin(length(bp+7 * sin(time*.5))-12, length(bp-7)-12, 12);\n  \n  float shape = SHAPE;\n    \n  float d4 = length(vec2(d, shape));\n  d = d4-0.17;\n  \n  d3 = length(vec2(d3, d4))-0.39;\n  \n  \n  \n  d = min(d,d3);\n  \n  \n  float d2 = abs(shape) - min(mm-.2, 1.0) * .7;\n  \n  \n  \n  mat=(d<d2)?1.:0.;\n  \n  d=min(d, d2);\n  \n  //d*=0.7;\n  \n  return d;\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd1(floor(g)), rnd1(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvoid cam(inout vec3 p) {\n  float t=time*.15 + curve(time+97.4, 2.5*4.)*2.;\n  p.yz *= rot(sin(t)*.5);\n  p.xz *= rot(sin(t*1.3)*.9);\n}\n\nvec3 rnd(float t) {\n  return fract(sin(t*vec3(423.745,384.912,542.877))*725.945);\n}\n\nvec3 sky(vec3 r) {\n  \n  vec3 col=vec3(0.3);\n  \n  float dist=0.3;\n  vec2 amask=abs(fract(r.yz/dist-.5)-.5)*dist;\n  float mask=clamp(((1.3-(max(amask.x,amask.y))*10.))*2.,0.,1.);\n  \n  col = mix(col, vec3(7), pow(max(0.,-r.y),12.));\n  col = mix(col, vec3(7), pow(max(0.,-r.z),12.));\n  col = mix(col, mask * vec3(10), pow(abs(r.x),10.));\n  \n  return col * 1.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  #if CHROMATIC\n  float fsize=1.0;\n  float fringe = fract(floor(gl_FragCoord.y/fsize)*fsize/3.);\n  vec3 fcol = (1.-abs(fringe*3.-vec3(0,1,2)))*3.;\n  #else\n  float fringe = 0.;\n  vec3 fcol = vec3(1.0);\n  #endif\n  \n  //uv *= 2.0/(1.0+length(uv));\n\n  float delay=2.5;\n  float zoom=curve(time, delay);\n  vec3 s=vec3((curve(time+12.75, delay)-.5)*13., (curve(time+37.15, delay)-.5)*12.,-27.-zoom*10.);\n  vec3 r=normalize(vec3(-uv, 0.9 - zoom * 0.4));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 col=vec3(0);\n  vec2 off=vec2(0.01,0);\n  \n  vec3 p=s;\n  float side=1.;\n  vec3 prevhit=s;\n  vec3 prod=vec3(1);\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p)*side;\n    if(abs(d)<0.001) {\n      \n      float curmat=mat;\n      float curid=id;\n      \n      vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))) * side;\n              \n      vec3 rn = reflect(r,n);\n      \n      float fre=pow(1.-abs(dot(n,r)), 2.);\n      \n      if(curmat<0.5) {\n        #if RED_GEM\n        vec3 diff=vec3(1,0,0.2);\n        #elif COLOR_GEM\n        vec3 diff=rnd(curid);\n        diff=1.-step(diff, vec3(0.8));\n        if(dot(diff,vec3(1))<0.2) diff=vec3(1);\n        #else\n        vec3 diff=vec3(1);\n        #endif\n        \n        vec3 depth = exp(-distance(prevhit,p) / diff*0.04);\n        \n        col += diff * sky(rn) * fre * prod;\n        \n        float ior=1.2 - fringe*0.1;\n        vec3 ref = refract(r,n, side<0.0? ior : 1.0/ior);\n        if(dot(ref,ref)>0.1) {\n          \n          r=ref;\n        } else {\n          \n          r=rn;\n        }\n        prod *= depth;\n        prod *= 1.-fre;\n        \n        side = -side;\n        p-=n*0.1;\n      } else {\n        r=rn;\n        \n        prod *= pow(fre,0.5);\n        //prod *= pow(1-fre,10);\n        //prod *= 0.0;\n        p+=n*.1;\n        //break;\n      }\n      \n      d = 0.1;\n      prevhit = p;\n      //break;\n    }\n    if(d>50.) break;\n    p+=r*d;\n  }\n  \n  col *= fcol;\n  \n  col += sky(r)*prod;\n  \n  //col *= 1.2-length(uv);\n  \n  col *= pow(col, vec3(0.4545));\n  \n  col=clamp(col, 0.,1.);\n  col *= 1.2-length(uv)*1.1;\n    \n  fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tls3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 539, 539, 610], [612, 612, 633, 633, 675], [677, 677, 695, 695, 741], [743, 743, 782, 782, 854], [1999, 1999, 2030, 2030, 2134], [2136, 2136, 2160, 2160, 2268], [2270, 2270, 2289, 2289, 2353], [2355, 2355, 2373, 2373, 2713], [2715, 2715, 2772, 2772, 5012]], "test": "ok"}
{"id": "tlsGRj", "name": "Zooming in the Mandelbrot set", "author": "StormCreeper", "description": "My first implementation of the Mandelbrot Set in GLSL", "tags": ["fractal"], "likes": 1, "viewed": 67, "published": "Public", "date": "1556971895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getColor(float n) {\n\tvec3 col = vec3(0);\n    float l = 1./log(2.);\n    col.x = (1.-cos(l*n))/2.;\n    col.y = (1.-cos(1./(3.*sqrt(2.))*l*n))/2.;\n    col.z = (1.-cos(1./(7.*pow(3., 1./8.))*l*n))/2.;\n    \n    /*vec3 palette[4];\n    palette[0] = vec3(0.);\n    palette[1] = vec3(0., 0., 1.);\n    palette[2] = vec3(1.);\n    palette[3] = vec3(0., 1., 0.);\n    \n    return palette[n%4];\n\t*/\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float size = pow(10., -iTime/3. + 0.5);\n    vec2 pos = vec2(-0.743643887037151, 0.13182590420533);\n    float limit = 800.;//(iMouse.y*iMouse.y);\n    vec2 res = normalize(iResolution.xy);\n    float ca = map(fragCoord.x, 0., iResolution.x, pos.x-size*res.x, pos.x+size*res.x);\n    float cb = map(fragCoord.y, 0., iResolution.y, pos.y-size*res.y, pos.y+size*res.y);\n    float a = 0.;//iMouse.x / iResolution.x * 2. - 1.;\n    float b = 0.;//iMouse.y / iResolution.y * 2. - 1.;\n    float n = 0.; \n    float log2 = log(2.);\n    while(n < limit) {\n        float aa = a*a - b*b;\n        float bb = 2.*a*b;\n        a = aa+ca;\n        b = bb+cb;\n        n++;\n        if(a*a+b*b > 4.) { \n            n = n + 1. - log((log(a*a+b*b)/2.)/log2)/log2;\n        \tbreak;\n        }\n        \n        \n    }\n\tvec3 col;\n    if(n < limit) {\n        col = getColor(n);\n        \n    } else {\n    \tcol = vec3(0.);\n    }\n    fragColor = vec4(col, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 138], [139, 139, 165, 165, 397], [399, 399, 423, 423, 804], [805, 805, 862, 862, 1797]], "test": "ok"}
{"id": "tlsGz2", "name": "Torus Tunnel", "author": "kaneta", "description": "Inspired by https://www.shadertoy.com/view/tll3zB", "tags": ["3d", "raymarching", "tunnel"], "likes": 11, "viewed": 546, "published": "Public API", "date": "1556996135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tr = 50.0;\n#define P(t,tt) vec3(cos(ti+t) * tr, sin(ti) * 0.1, sin(ti+tt) * tr);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float ti = iTime * 2.;\n    vec3 ro = P(0.,0.);\n    vec3 ta = P(sin(ti), cos(ti));\n    vec3 fo = normalize(ta-ro);\n    vec3 ri = normalize(cross(vec3(cos(ti*0.5),sin(ti*0.5),0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    vec3 ray = mat3(ri,up,fo) * normalize(vec3(p, 1.5));\n    \n    float t = 0.0;\n    vec3 col = vec3(0.);\n    float a = 1.0;\n    for(int i=0;i<300;i++) {\n        vec3 pos = ro + ray * t;\n    \tfloat d = -length(vec2(length(pos.xz) - tr, pos.y)) + 5.0;\n        if (d < 0.001) {\n    \t\tvec2 uv = vec2(atan(pos.z, pos.x), atan(pos.y, length(pos.xz) - tr)) / (acos(-1.)*2.) + 0.5;\n            float c = smoothstep(0.05, 0.00, abs(fract(uv.y * 5.0) - 0.5));\n            c = mix(c, 1.0, smoothstep(0.1, 0.00, abs(fract(uv.x * 10.0) - 0.5)));\n            col += mix(vec3(c), mix(vec3(7., 4., 2.), vec3(2., 4., 7.), sin(ti) * 0.5 + 0.5), 1.0-exp(-t * 0.005)) * a;\n            a *= 0.25;\n            t = 0.002;\n            ro = pos;\n            ray = reflect(ray, normalize((normalize(vec3(pos.x, 0., pos.z)) * tr) - pos));\n        }\n        t += d;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 144, 144, 1337]], "test": "ok"}
{"id": "tlSGzR", "name": "Voroni Stars", "author": "BradyInstead", "description": "Star walker. Renderer and noise function based on iq's. ", "tags": ["noise", "space", "trippy", "voroni"], "likes": 16, "viewed": 937, "published": "Public API", "date": "1558409975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// noise by IQ\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n    n = abs(n);\n\tfloat x = texture( iChannel3, p.yz ).x;\n\tfloat y = texture( iChannel3, p.zx ).x;\n\tfloat z = texture( iChannel3, p.xy ).x;\n\n\treturn (x*n.x + y*n.y + z*n.z);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 random3f( vec3 p )\n{\n#if 1\n\treturn textureLod( iChannel0, (p.xy + vec2(3.0,1.0)*p.z+0.5)/256.0, 0.0 ).xyz;\n#else\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n#endif\t\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float res = 1.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + random3f( p + b );\n        float d = dot( r, r );\n\t\tres = min(d, res);\t\t\t\n    }\n\n    return res;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float zoom = 4.;\n\tcamPos = vec3(0.,0.,iTime);\n    camTar = camPos + vec3(0.0, 0.0, 5.0);\n}\n\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\n\nfloat doModel( vec3 p )\n{\n    float no = noise(p*2.);\n    return pow(no, .7)*.6;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    nor.x = 1.0;\n    nor.y = 1.0;\n    return vec3(.5, 0., 1.) * nor;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<50; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        \n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,.25));\t// lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3( 0.0, 0.0, 0.0); // background color\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        // lighting\n        col = mal*2.5;\n\t\tcol *= exp(-0.03*t*t);\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.8) );\n    col = hueShift(col, -length(col*1.1));\n    col*= 2.;\n\t   \n    fragColor = vec4( col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 15, 44, 44, 231], [233, 233, 256, 256, 295], [297, 297, 320, 320, 414], [416, 416, 441, 441, 726], [727, 727, 753, 753, 1111], [1113, 1445, 1528, 1528, 1623], [1909, 1909, 1934, 1934, 1991], [1993, 2346, 2391, 2391, 3165], [3167, 3167, 3212, 3212, 3283], [3448, 3448, 3498, 3498, 3924], [3926, 3926, 3958, 3958, 4370], [4372, 4372, 4436, 4436, 4614], [4616, 4616, 4673, 4673, 5961]], "test": "error"}
{"id": "tlX3WS", "name": "Erell at Oberkampf", "author": "eliemichel", "description": "Shaderization of https://www.instagram.com/p/BxJmvadl4Ht/\nTry changing the branch count at line 6.\n\nIf someone has a good idea for the elbow() I'm interested, because the turn is not so perfect", "tags": ["2d", "streetart"], "likes": 18, "viewed": 508, "published": "Public API", "date": "1557598014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Erell at Oberkampf\"\n// Copyright (c) May 2019 - Alt144 (Elie Michel)\n// License: CC 3.0 BY - Please notify me when using it\n\n// Parameters\nconst float branches = 3.;\n\n#define PI 3.14159265\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(vec2 co) {\n    vec2 q = floor(co);\n    vec2 r = co - q;\n    r = r * r * (3. - 2. * r);\n    vec2 e = vec2(0.,1.);\n    return mix(\n    \tmix(rand(q + e.xx), rand(q + e.yx), r.x),\n        mix(rand(q + e.xy), rand(q + e.yy), r.x),\n        r.y);\n}\n\nmat2 rot(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\n\nvec2 moda(vec2 uv, float n, out float idx) {\n    float a = atan(-uv.y, -uv.x) + PI;\n    float r = 2.*PI/n;\n    idx = floor(a/r);\n    a = mod(a, r);\n    return vec2(cos(a), sin(a)) * length(uv);\n}\n\nvec2 elbow90(vec2 uv) {\n    vec2 tuv = vec2(-uv.y+.295, uv.x);;\n    float a = atan(uv.x, uv.y);\n    vec2 ruv = vec2(2.*PI*a*.03, length(uv));\n    return mix(tuv, mix(uv, ruv, step(0., uv.x)), step(0., uv.y));\n}\n\nvec2 elbow(vec2 uv, float angle) {\n    vec2 tuv = rot(angle) * uv;\n    vec2 thuv = rot(angle/2.) * uv;\n    \n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    vec2 ruv = vec2(2.*PI*a*.03, length(uv));\n    \n    vec2 toff = vec2(+.19 * angle, 0.);\n    return mix(mix(uv, ruv, step(0., uv.x)), mix(tuv + toff, ruv, step(tuv.x, 0.)), step(0., thuv.x));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k - abs(b - a))/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat gate(float a, float b, float t) {\n    return max(a-t, t-b);\n}\n\nfloat sinstep(float x)\n{\n    return (1. - cos(PI * x)) * .5;\n}\n\nvec4 worm5(vec2 uv, float len) {\n    vec2 uv0 = uv;\n    uv.x = -abs(uv.x - len/2.) + len/2.; // symmetry\n    float head = length(uv*2.-1.) - 1.;\n    float h = gate(.5, len-.5, uv.x);\n    float v = gate(.0, 1., uv.y);\n    float d = max(h, v);\n    d = min(d, head*.5);\n    vec3 color = vec3(1.-pow(sinstep(smoothstep(.5, len, uv0.x)), 1.));\n    color *= vec3(.9,.92,.95);\n    return vec4(color, d);\n}\n\nfloat fill(float d) {\n    return smoothstep(.05, .0, d);\n}\n\nvec4 straitWorms(vec2 uv, float len, vec2 m, float n) {\n    float margin = m.x;\n    float ymargin = m.y;\n    uv.y += ymargin*.3*.5;\n    vec2 udx = vec2(1., floor(uv.y/.3/(1.+ymargin)));\n    uv.x += udx.y*.7;\n    float way = (fract(udx.y/2.)*2.-.5);\n    uv.x += iTime * way;\n    uv.x *= way*2.;\n    vec2 guv = vec2(fract(uv.x * 3./(len+margin))*(len+margin)-margin*.5,fract(uv.y/.3/(1.+ymargin))*(1.+ymargin)-ymargin*.5);\n    vec4 w = worm5(guv, len);\n    //w.rgb *= vec3(1.,0.5,0.);\n    w.a = max(w.a, gate(.0, .3*n, -uv.y/(1.+ymargin))*5.);\n    return w;\n}\n\nvec4 secondElbowWorms(vec2 uv, float angle, float len, float margin) {\n    uv += rot(angle*.5)*vec2(.39/sin(angle*.5),.0);\n    uv += rot(angle)*vec2(.96/sin(angle),.0);\n    vec2 euv = elbow(uv, PI-angle);\n    euv.x += iTime;\n    vec2 guv = vec2(fract(euv.x * 3./(len+margin))*(len+margin)-margin*.5,euv.y/.3);\n    vec4 w = worm5(guv, len);\n    return w;\n}\n\nvec4 compOver(vec4 under, vec4 over) {\n    under.rgb = mix(under.rgb, over.rgb, fill(over.a));\n    return under;\n}\n\nvec4 compAdd(vec4 under, vec4 over) {\n    under.rgb += mix(vec3(0.), over.rgb, fill(over.a));\n    return under;\n}\n\nvec4 line(vec2 uv, float angle, float d3, float margin) {\n    vec2 diag = rot(PI-angle)*uv;\n    float mdiag = (diag.y+margin*d3)*3.;\n    vec4 w;\n    w.rgb = vec3(.8,.6,.2);\n    w.a = gate(margin*d3,margin*d3*2.,-uv.y)*5.;\n    w.a = max(w.a, mdiag*2.)*1.5;\n    return w;\n}\n\nfloat sat(float x) { return clamp(x, 0.,1.); }\n\nfloat select(float id, float target) {\n    return sat(1.-abs(id-target));\n}\n\nvec4 hex(vec2 uv)\n{\n    float odd = floor(uv.x*2.);\n    float cid = floor(uv.x*2.+.5);\n    uv.y += odd*sqrt(3.)/2.;\n    uv.x = fract(uv.x*2.)*.5;\n    \n    vec2 uv2 = 2./3. * rot(PI/3.) * uv;\n    vec2 uv3 = 2./3. * rot(PI/3.) * (vec2(-1., 1.) * uv + vec2(0., sqrt(3.)/3.));\n    float gx = floor(uv2.x*2.);\n    vec2 udx = vec2(floor(fract(uv2.x)*3.), floor(fract(uv3.x)*3.));\n    float h = sat(udx.x - udx.y);\n    float s2 = dot(mix(vec2(3., -1.), vec2(2., 1.), h), vec2(1., (udx.x + udx.y)));\n    vec2 nuv = uv*sqrt(3.)/3.*2.;\n    float sl = -1./sqrt(3.) * (select(udx.y, 1.)*2.-1.);\n    nuv.y = fract(nuv.y+1./3.+.5+nuv.x*sl-sl*.5/sqrt(3.))-nuv.x*sl-.5+sl/3.45; // 3.45 is magick :/\n    nuv.x = mix(-sqrt(3.)/3.+nuv.x, nuv.x, h);\n    \n    nuv = rot(s2*PI/3.+PI/6.) * nuv;\n    return vec4(nuv, s2, cid);\n}\n\nfloat patternD8(vec2 uv) {\n    float r1 = perlin(uv*1.+iTime);\n    float r3 = (perlin(uv*1.+iTime*.1+r1) + perlin(uv*1.+vec2(-2.*iTime, 0.)))*.5;\n    \n    vec4 huv = hex(uv);\n    uv = huv.xy;\n    \n    float r2 = rand(huv.ww);\n    float circles = length((uv-vec2(.0,-.33))*vec2(1.2,1.))-mix(.02, .04, mod(huv.z,2.)) * mix(1.,3.,r1);\n    float center = length(uv)-mix(.04, .06, r2);\n    float lines = max((abs(fract(uv.x*6.)-.5)-.2)*2.5, abs(uv.y+.6)-.03 * mix(5.,.5,r3));\n    \n    float d = min(circles*2., center*2.);\n    d = min(d, lines);\n    \n    return d*2.;\n}\n\n\nfloat pattern1(vec2 uv) {\n    //return fill(patternD4(uv)) + fill(patternD4(uv)+.5)*.5;\n    return fill(patternD8(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 uv0 = uv;\n    \n    float angle = 2.*PI/branches;\n    float d3 = .3;\n    \n    // Frame\n    float zoom = 5.;\n    float ratio = iResolution.y/iResolution.x;\n    float z = step(ratio, uv.x);\n    uv -= vec2(-ratio*.5-.2,.2);\n    uv *= 1.6;\n    uv = rot(angle*.25) * uv;\n    \n    vec2 closeup = uv / zoom;\n    closeup -= vec2(.1,0.);\n    \n    uv = mix(uv, closeup, z);\n    zoom = mix(1., zoom, z);\n    vec4 zm = vec4(1.,1.,1.,zoom);\n    vec2 fuv = uv;\n    \n    float ridx = 0.;\n    uv = moda(uv, branches, ridx);\n    uv.xy = -uv.xy;\n    \n    float isFirst = sat(1. - mod(ridx, 3.));\n    float isSecond = sat(1. - abs(mod(ridx, 3.) - 1.));\n    float isThird = sat(1. - abs(mod(ridx, 3.) - 2.));\n    \n    mat2 mat = rot(PI-angle);\n    uv += rot(angle*.5)*vec2(.35/sin(angle*.5),.0);\n    vec2 euv = elbow(uv, PI-angle);\n    \n    // Symmetry\n    vec2 vy = rot(angle*.5)*vec2(0.,1.);\n    uv = mix(uv, uv - 2.*dot(uv, vy)*vy, isThird);\n    \n    float pattern = -patternD8(fuv*20.)/20.*zoom+.02*zoom;\n    \n    float mlen = 4.;\n    float margin = .3;\n    euv.x += iTime*.4;\n    vec2 guv = vec2(fract(euv.x * 3./(mlen+margin))*(mlen+margin)-margin*.5,euv.y/.3);\n    vec4 w = worm5(guv, mlen);\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    \n    vec4 col = vec4(.01, .01, .03, 1.0);\n    col = compAdd(col, w * zm);\n    \n    w = straitWorms(uv+vec2(.0,mix(0.,margin*d3*2., isThird)), mlen, vec2(margin), 2.);\n    vec2 diag = rot(PI-angle)*uv;\n    float mdiag = (diag.y+margin*d3)*3.;\n    w.rgb *= mix(vec3(1.), vec3(.7,.75,.88), smoothstep(-.7, 0., mdiag));\n    w.rgb = mix(w.rgb, vec3(.0), smoothstep(-.3, 0., mdiag));\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    w.a = max(w.a, mdiag);\n    col = compAdd(col, w * zm);\n    \n    w = secondElbowWorms(uv+vec2(.21,.0), angle, mlen, margin);\n    w.a = mix(1., w.a, isThird);\n    w.rgb = pow(w.rgb, vec3(mix(2., .5, fill(pattern))));\n    col = compAdd(col, w * zm);\n    \n    vec2 uv2 = uv;\n    uv2 += mix(vec2(0.), rot(angle)*vec2(.8/sin(angle),.0), isSecond);\n    w = line(uv2, angle, d3, margin);\n    w.a = mix(w.a, 1., isFirst);\n    w.rgb = pow(w.rgb, vec3(mix(1.5, 0.8, fill(pattern+.03))));\n    col = compOver(col, w * zm);\n    \n    uv2 = uv;\n    uv2 = uv2 - 2.*dot(uv2, vy)*vy;\n    uv2.x += 1.11;\n    w = line(uv2, angle, d3, margin);\n    w.a = mix(1., w.a, isThird);\n    w.rgb = pow(w.rgb, vec3(mix(1.5, 0.8, fill(pattern+.03))));\n    col = compAdd(col, w * zm);\n    \n    col = mix(col, vec4(1.), step(ratio, uv0.x)*step(uv0.x, ratio + .04));\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlX3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 214, 214, 286], [288, 288, 311, 311, 542], [544, 544, 563, 563, 639], [642, 642, 686, 686, 837], [839, 839, 862, 862, 1049], [1051, 1051, 1085, 1085, 1412], [1414, 1414, 1453, 1453, 1536], [1538, 1538, 1577, 1577, 1605], [1607, 1607, 1631, 1631, 1669], [1671, 1671, 1703, 1703, 2069], [2071, 2071, 2092, 2092, 2129], [2131, 2131, 2186, 2186, 2688], [2690, 2690, 2760, 2760, 3045], [3047, 3047, 3085, 3085, 3161], [3163, 3163, 3200, 3200, 3276], [3278, 3278, 3335, 3335, 3549], [3551, 3551, 3571, 3571, 3597], [3599, 3599, 3637, 3637, 3674], [3676, 3676, 3695, 3695, 4480], [4482, 4482, 4508, 4508, 5046], [5049, 5049, 5074, 5136, 5170], [5172, 5172, 5229, 5229, 7856]], "test": "ok"}
{"id": "tlX3zB", "name": "[4kb] Night Mist - Revision 2019", "author": "NuSan", "description": "Night Mist - by NuSan & Valden\n\n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music", "tags": ["raymarching", "intro", "demoscene", "volumetric", "demo", "4kb"], "likes": 69, "viewed": 3361, "published": "Public", "date": "1556706569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n----- Night Mist ------\n-- by NuSan & Valden --\n    \n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music\n\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\n*/\n\n#define time iTime\n#define bpm (time*1.5)\n#define section (bpm/16.)\nint section2 = 0;\nfloat pi = acos(float(-1));\n\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\n\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\n#define c0(a) clamp(a,0.,1.)\n\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\n\nfloat noi2(vec2 p) {\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\n  vec2 v2=mix(v.xz,v.yw,p.x);\n  return mix(v2.x,v2.y,p.y);\n}\n\nint scene=0;\nfloat mont=0.;\nfloat decal=0.;\nfloat anim=0.;\n\n// shift the world on x/y axis according to z axis value\nvec3 tunnel(vec3 p) {\n  vec3 o=vec3(0);\n  if(scene==1) {\n  \to.x+=sin(p.z*0.05)*6.;\n  \to.x+=sin(p.z*0.15)*3.;\n  \to.y+=sin(p.z*0.07)*7.;\n  }\n  return o;\n}\n\n// morph the world into plane, cylinder or sphere\nvec3 morph(vec3 p) {\n\n\tp+=tunnel(p);\n\tvec3 rop=p; // plane\n\t\n\t// cylinder\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\n\n\tif(scene==3) {\n\t\t// sphere\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\n\t}\n\t\n\treturn rop;\n}\n\n// kaleidoscopic folding for the city\nvec3 kalei(vec3 p, inout vec2 ad) {\n\t\n\tfloat s=10.+fract(section*4.)*anim;\n\tfor(int i=0;i<5;++i) {\n\t\tp.xz *= rot(float(i)+12.7);\n\t\tfloat freq=100.0;\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\n\t\tp.xz = repa(p.xz,freq);\n\t\tp.xz -=s;\n\t\ts*=0.5;\n\t}\t\n\t// change scene\n\tp.x += decal;\n\treturn p;\n}\n\nfloat at=0.;\nfloat mat=0.;\nvec3 localp;\n// give signed distance field at position p\nfloat map2(vec3 p) {\n\tp=morph(p); // morph the world into plane, cylinder or sphere\n\n\tvec3 bp=p;\n\tvec2 uv=p.xz;\n\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\n\t\n\tvec2 ad=vec2(0);\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\n\t\n\tfloat d=box(p, vec3(0.4));\n\t\n\tat+=1./(d+0.1);\n\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\n\n\td=min(d,city);\n\tlocalp=p;\n\n\tvec3 rp=p;\n\trp.xz=rep(rp.xz,0.5);\n\trp.xz+=off*0.05;\n\t// fields\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\n\t\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\n\t\t\t\n\t\t\t\n\t// terrain/mountain\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\n\t\t\t\n\tmat=abs(d-city)<0.01?1.:0.;\n\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\n\t\n\treturn d;\n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*478.556)*8522.412);\n}\n\nfloat rnd2(vec2 t) {\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\n}\n\n// give volumetric amount at position p\nfloat atspeed=1.;\nfloat gridsize=5.;\nvec3 atmo(vec3 p) {\n\tvec3 bp=p;\n\tp=morph(p); // morph the world into plane, cylinder or sphere\n\tvec2 ad=vec2(0,10);\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\n\t\n\tvec3 col=vec3(0);\n\n\tvec3 back=vec3(0.5,0.2,1.0);\n\tback.xy*=rot(ad.x);\n\tback=abs(back);\n\tfloat fade=c0((p.y+8.)*0.03);\n\tfloat ff=rnd2(floor(p.xz*gridsize));\n\tfloat pulse=0.7;//fract(bpm*0.25);\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\n\t\n\treturn col;\n}\n\nvec3 sky(vec3 r) {\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    section2 = int(section);\n    \n\tfloat fov=.4;\n\tfloat shad = 1.;\n\t\n    // change scenes according time\n\tif(section2>3 && section<4.) anim=30.;\n\tmont=(section2>1 && section2<10)?100.:0.;\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\n\tif(section2>3&&section2<8) scene=1;\n\tif(section2>9) {scene=3;atspeed=2.;}\n\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\n\t\n\tvec3 s = vec3(0,-2,-10); // distance cam\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\n\t\t\n\tvec3 t = vec3(0.3,0.5,0);\n\n    // camera setting by scenes\n\tfloat div=1.;\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\n\n\tfloat mav=time*0.5+camoff*50.;\n\tfloat piv=.2;\n\tfloat az=0.7;\n\tif(scene==0) {\n\t\ts.y=camoff*(section2>6?12.5:14.);\n\t}\n\tif(scene==1) {\n\t\ts.z=6.;\n\t\taz=2.3*sin(section*5.);\n\t\tmav=10.;\n\t}\n\tif(scene==3) {\n\t\taz=0.2;\n\t\ts.z=20.;\n\t\tt=vec3(0,0,10);\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\n\t\tmav*=c0(-mav);\n\t\tpiv*=c0(-mav);\n\t\tmav+=3.5;\n\t}\n\tfloat muvol=.2;\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\n\n\tfloat rand = rnd2(uv);\n\tfloat dither=0.9+0.1*rand;\n\t\n\ts.yz*=rot(az);\n\ts.xz *= rot(mav);\n\n\tif(scene==0) {\n\t\ts.z-=max(20.-time,0.)*3.;\n\t}\n\t\n\tfloat avance=0.;\n\tfloat tar=10.;\n\tif(scene==1) {\n\t\tavance=fract(section)*80.-40.; // traveling\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\n\t}\n\ts.z -= avance;\n\tt.z -= avance+tar; // cam dir\n\ts -= tunnel(s);\n\tt -= tunnel(t);\n\t\n\tvec3 cz = normalize(t-s);\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\n\tvec3 cy = cross(cz, cx);\n\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\n\t\n\t// main raymarching loop\n\tvec3 p = s;\n\tfloat dd=0.;\n\tfor(int i=0; i<100; ++i) {\n\t\tfloat d = map2(p)*0.7*dither;\n\t\tif(d<0.001) {break;}\n\t\tif(dd>100.) {dd=100.;break;}\t\t\n\t\tp+=r*d;\n\t\tdd+=d;\n\t}\n\n\tfloat curmat=mat;\n\tvec3 lop=localp;\n\n\tvec2 off=vec2(0.01,0);\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\n\t\t\n\tif(scene==1){\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\n\t}\n\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\n\t\n\tfloat deg = 1.-c0(dd/100.);\n\tfloat fog = c0(deg*deg);\n\n    // shadow raymarching (cheap)\n\tvec3 sp = p + n * 0.5 - r * 0.2;\n\tfor(int i=0; i<10; ++i) {\n\t\tfloat d=map2(sp);\n\t\tshad=min(shad,d);\n\t\tsp+=d*light*0.6*dither;\n\t}\n\t\t\t\t\n\tshad=c0((shad-.02)*3.);\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\n\t\t\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\n\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\n\n\t/*\n\t// maximized version\n\t// diffuse and spec\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\n\t\n\t// fresnel\n\tfloat fre=pow(1-abs(dot(n,r)),5);\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\n\t\n\t// night color mood\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\n\n\t// sky reflection inside the windows\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\n\t\n\t// emissive from the ground during night\n\tcol += atmo(p)*6*fog*fx;\n\t\n\t// sky fog and atmosphere\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\n\t*/\n\t\n    // \"volumetric\" for night scenes\n\tvec3 rp=r*muvol;\n\tvec3 vp=s+rp*rand;\n\tfor(int i=0; i<100; ++i) {\n\t\tif(length(vp-s)>dd) break;\n\t\tcol+=atmo(vp)*fx;\n\t\tvp+=rp;\n\t}\n\t\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\n\t/*\n\t// maximised version\n\t// filmic lol\n\tcol = 1-exp(-col*2.5);\n\tcol = c0(pow(col,vec3(2.1)));\n\t\n\t// fade in/out\n\tcol *= c0(time/5);\n\tcol *= c0((11.3-section)*10);\n\t*/\n\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "llX3zB", "previewfilepath": "https://soundcloud.com/antoine-zanuttini/night-mist-soundtrack", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/antoine-zanuttini/night-mist-soundtrack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlX3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 416, 442, 442, 483], [484, 484, 520, 520, 559], [560, 560, 597, 597, 662], [846, 846, 865, 865, 920], [922, 922, 942, 942, 1126], [1188, 1245, 1266, 1266, 1397], [1399, 1449, 1469, 1469, 1735], [2151, 2195, 2215, 2215, 3281], [3283, 3283, 3304, 3304, 3347], [3349, 3349, 3369, 3369, 3439], [3518, 3518, 3537, 3537, 4035], [4037, 4037, 4055, 4055, 4133], [4135, 4135, 4192, 4192, 8581]], "test": "timeout"}
{"id": "tlXGDj", "name": "My Seascape Documented ", "author": "takahiroando", "description": "Seascape Documented with my experiments based on https://www.shadertoy.com/view/llsXD2  I just changed getSeaColor for my understanding.  This is mostly not my job", "tags": ["sea"], "likes": 11, "viewed": 262, "published": "Public", "date": "1557650486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A documented version of \"Seascape\" for learning purposes.  Original shader page here:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME;\n\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    float f0 = 0.1;\n    fresnel = f0 + (1.0 - f0) * pow(fresnel,5.0) * 0.65;  // andotakahiro: more standard fresnel equation\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n)) + 10.0 * vec3(specular(n,l,eye,80.0));    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = 1.0;//max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    refracted += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    // takahiroando: combine here at the end\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n\n        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     float EPSILON_NRM\t= 0.1 / iResolution.x;\n    float SEA_TIME = iTime * SEA_SPEED;\n\n\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 0.3 + iMouse.x*0.01; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n\n    // bteitler: Calculated a vector that smoothly changes over time in a sinusoidal (wave) pattern.  \n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5, at x 0 (zero), and flies over the ocean in the z axis over time.\n    vec3 ori = vec3(0.0,3.5,time*5.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    // post\n    \n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[683, 757, 783, 783, 1129], [1131, 1597, 1619, 1619, 1702], [1704, 1965, 1991, 1991, 3625], [3627, 3709, 3747, 3747, 3789], [3791, 3859, 3905, 3905, 4009], [4011, 4101, 4127, 4127, 4265], [4267, 4790, 4831, 5233, 8385], [8387, 8556, 8575, 8575, 10857], [10859, 11029, 11057, 11057, 13347], [13349, 13591, 13654, 13790, 14757], [14759, 15099, 15134, 15477, 16517], [16519, 16582, 16638, 16638, 19952], [19954, 19962, 20019, 20019, 24084]], "test": "timeout"}
{"id": "tlXGDs", "name": "Dancing Moire", "author": "Peregrine", "description": "Simple moire.", "tags": ["2d", "interference", "moire"], "likes": 3, "viewed": 69, "published": "Public", "date": "1558037853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 moire(in vec2 p) {\n    float t = iTime;\n    const int ringwidth = 4;\n    const float a = 0.6, b = 0.5;\n\tvec2 focus1 = vec2(a*cos(t/2.)+b, a*sin(t/4.)+b);\n    vec2 focus2 = vec2(a*cos(t/3.)+b, a*sin(t)+b);\n\n\tint interf = int(100.*distance(p,focus1)) ^ int(100.*distance(p,focus2));\n    interf /= ringwidth;\n    interf %= 2;\n    \n    if (interf == 0)\n        return vec4(vec3(0.),1.);\n    else\n        return vec4(1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = 2.*fragCoord.xy/iResolution.xy - 0.5;\n    \n    fragColor = moire(p);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 423], [425, 425, 480, 480, 564]], "test": "ok"}
{"id": "tlXGWX", "name": "Color segments", "author": "avin", "description": "colors experiment", "tags": ["colors", "hue"], "likes": 9, "viewed": 626, "published": "Public API", "date": "1557828157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\n#define SF 1./min(iResolution.x,iResolution.y)\n\nfloat remap(float v, float oMin, float oMax, float rMin, float rMax){\n\tfloat result = (v - oMin)/(oMax - oMin);\n    result = (rMax - rMin) * result + rMin;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    vec2 mult = vec2(30., 5.); // blocks aspect ratio\n    vec2 guv = uv*mult;\n    vec2 id = floor(guv);\n    \n    float t = iTime + 100.;\n    float pS = remap(rand1(id.x), 0., 1., 0.8, 1.0); // prepare offset speed\n    guv.y += pS * t; // make offset\n    id = floor(guv); // update ID after offset\n    guv = fract(guv);\n    \n    vec2 sf = mult * SF;\n            \n    vec2 bw = vec2(.5) - mult/250.; // border width\n        \n    float m = smoothstep(bw.x, bw.x - sf.x, abs(guv.x - .5)) * smoothstep(bw.y, bw.y - sf.y, abs(guv.y - .5));    \n    \n    vec3 col = hue(rand1(id.x + id.y)).rgb * m;      \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 250, 250, 357], [359, 359, 416, 416, 1121]], "test": "ok"}
{"id": "tsBGzz", "name": "Broken phong", "author": "bitsofcode", "description": "play", "tags": ["sdf"], "likes": 2, "viewed": 54, "published": "Public", "date": "1558848280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 4.7;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sphereSDF( vec3 samplePoint ) {\n    return length( samplePoint ) - 1.0;\n}\n\nfloat sceneSDF( vec3 samplePoint ) {\n    return sphereSDF( samplePoint );\n}\n\nfloat shortestDistanceToSurface( vec3 eye, vec3 marchingDirection, float start, float end ) {\n    float depth = start;\n    for ( int i = 0; i < MAX_MARCHING_STEPS; i++ ) {\n        float dist = sceneSDF( eye + depth * marchingDirection );\n        if ( dist < EPSILON ) {\n            return depth;\n        }\n        depth += dist;\n        if ( depth >= end ) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection( float fieldOfView, vec2 size, vec2 fragCoord ) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan( radians( fieldOfView ) / 2.0 );\n    return normalize( vec3( xy, -z ));\n}\n\nvec3 estimateNormal( vec3 p ) {\n    return normalize( vec3 (\n        sceneSDF(vec3(p.x + EPSILON,p.y,p.z)) - sceneSDF(vec3(p.x - EPSILON,p.y,p.z)),\n        sceneSDF(vec3(p.x,p.y + EPSILON,p.z)) - sceneSDF(vec3(p.x,p.y - EPSILON,p.z)),\n        sceneSDF(vec3(p.x,p.y,p.z + EPSILON)) - sceneSDF(vec3(p.x,p.y,p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L,N));\n    \n    float dotLN = dot(L,N);\n    float dotRV = dot(R,V);\n    \n   // if (dotLN < 0.0) {\n   //     return vec3(0.0);\n   // }\n    \n  //  if (dotRV < 0.0) {\n   //     return lightIntensity * (k_d * dotLN);\n   // }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4,0.6,0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.2);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection( 45.0, iResolution.xy, fragCoord );\n    vec3 eye = vec3( 0.0, 0.0, 5.0 );\n    float dist = shortestDistanceToSurface( eye, dir, MIN_DIST, MAX_DIST);\n    \n    if( dist > MAX_DIST - EPSILON ) {\n        fragColor = vec4( 0.0 );\n        return;\n    }\n    \n    vec3 p = eye + dist * dir;\n    vec3 K_a = vec3( 0.2 );\n    vec3 K_d = vec3( 0.7, 0.2, 0.2 );\n    vec3 K_s = vec3( 1.0 );\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination( K_a, K_d, K_s, shininess, p, eye );\n    fragColor = vec4(color, 1.0);\n}\n    \n    \n    \n    \n    \n    \n    \n        \n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 162, 162, 204], [206, 206, 242, 242, 281], [283, 283, 376, 376, 699], [701, 701, 768, 768, 907], [909, 909, 940, 940, 1239], [1241, 1241, 1381, 1381, 1813], [1815, 1815, 1900, 1900, 2543], [2545, 2545, 2602, 2602, 3148]], "test": "ok"}
{"id": "tslSWl", "name": "Produit Scalaire 3", "author": "msafadi", "description": "exo beto", "tags": ["betomaths"], "likes": 2, "viewed": 52, "published": "Public", "date": "1557418199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////\n// EXERCICE 1.3\n// a - retourner true si collision entre droite (orientée) et cercle\n// b - retourner le point de collision\n//////////////////////////////////////////////////////////////////\nbool isCollision(vec2 p1, vec2 p2, vec2 center, float radius, out vec2 hitPoint) {\n    vec2 d = normalize(p2-p1);\n    vec2 n = vec2(-d.y, d.x);\n    float distance = dot( (center - p1), n);\n\n    float l = sqrt(radius * radius - distance * distance);\n    hitPoint = center - distance * n - l * d;\n    return abs(distance) <= radius ;  \t \n}\n\n\n\n\n///////////////////////////////////////////////////\n// PRIVATE\n///////////////////////////////////////////////////\nconst float zNear = 1.0;\nconst float zFar  = 400.0;\n\nbool segment(vec2 p1, vec2 p2, vec2 p) {\n\n    vec2 v1 = p1-p;\n    vec2 v2 = p2-p;    \n    \n    return length(cross(vec3(v1,0), vec3(v2,0))) < 0.002;\n}\n\nbool circle(vec2 origin, float radius, vec2 p) {\n    return length(p-origin) < radius;\n}\n\n\nbool drawCross(vec2 p, vec2 center) {\n    \n    vec2 dv = p - center;\n \tfloat hdist = abs(dv.x);   \n \tfloat vdist = abs(dv.y);       \n    \n    return length(dv) < 0.02 && (hdist < 0.005 || vdist < 0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n\n    const float radius = 0.20;\n    const vec2  origin = vec2(0);\n    \n    vec2 p1 = vec2(0.2 , cos(iTime)/5.0);\n    vec2 p2 = vec2(0.8, sin(iTime)/5.0);\n    \n    vec2 collisionPoint;\n    bool collision = isCollision(p1, p2, origin, radius, collisionPoint);\n\n    if( collision && drawCross(viewportCoord.xy, collisionPoint)) {\n        fragColor = vec4(0,1,1,1);\n    }\n    else if(segment(p1, p2, viewportCoord.xy)) {\n        if(collision) fragColor = vec4(1,0,0,1);\n        else \t\t  fragColor = vec4(0,1,0,1);\n    }\n\telse if(circle(origin, radius, viewportCoord.xy)) {\n    \tfragColor = vec4(1.0,0.5,0.0,1.0);\n    }\n    else {\n\t\tfragColor = vec4(0);        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 259, 341, 341, 596], [769, 769, 809, 809, 919], [921, 921, 969, 969, 1009], [1012, 1012, 1049, 1049, 1217], [1219, 1219, 1276, 1276, 2083]], "test": "ok"}
{"id": "ttB3zz", "name": "basic_raytracer", "author": "lqt0223", "description": "my practice of implementing a basic raytracer", "tags": ["raytracer"], "likes": 3, "viewed": 84, "published": "Public", "date": "1558269715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate2d(vec2 st, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    mat2 t = mat2(c,-s,s,c);\n    return t*st;\n}\n\nbool ray_sphere_sect (vec3 ro, vec3 rd, vec3 sc, float r, out vec3 normal, out vec3 hp, out float dist){\n    vec3 sr = sc - ro;\n    float d = sqrt(pow(length(sr), 2.)-pow(r, 2.));\n    vec3 cp = ro + d * rd;\n    vec3 t = cp-sc;\n    if (length(t) < r) {\n        float lpt = sqrt(pow(r, 2.)-pow(length(t), 2.));\n        vec3 p = ro + (d - lpt) * rd;\n        hp = p;\n        dist = length(hp - ro);\n        normal = normalize(p-sc);\n    }\n    return length(t) < r;\n}\n\nbool ray_yplane_sect(vec3 ro, vec3 rd, float y, float x1, float x2, float z1, float z2, out vec3 hp, out float dist) {\n    vec3 rb = vec3(0.0,y,0.0);\n    vec3 bd=normalize(rb);\n    float a = dot(bd, rd);\n    float lrb = length(rb);\n    float lrd = lrb/a;\n    vec3 hitpoint = ro + lrd * rd;\n    hp = hitpoint;\n    dist = lrd;\n    return hitpoint.x > x1 && hitpoint.x < x2 && hitpoint.z > z1 && hitpoint.z < z2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 st = vec3(fragCoord / iResolution.xy, 0.);\n    st = st * 2.-1.;\n    st.z = 0.;\n    st.x*=iResolution.x/iResolution.y;\n\n    vec3 c_light = vec3(3.,3.,-1.);\n    vec3 c_light2 = vec3(-3.,2.,-1.);\n    c_light = normalize(c_light);\n    c_light2 = normalize(c_light2);\n    st.xz = rotate2d(st.xz, -iTime*1.);\n    vec3 camera = vec3(0,0,-1.5);\n    camera.xz = rotate2d(camera.xz, -iTime*1.);\n    vec3 ray = st-camera;\n    ray = normalize(ray);\n    vec3 ns,np;\n    vec3 hps,hpp;\n    float hds,hdp;\n    bool rsr = ray_sphere_sect(camera, ray, vec3(0.),.35, ns, hps, hds);\n    bool rpr = ray_yplane_sect(camera, ray, -.45 + .1*sin(iTime), -1., 1., -1.,1., hpp,hdp);\n    vec3 temp, tempns,temp2,tempns2;\n    float tempf,tempf2;\n    vec3 light = normalize(c_light-hps);\n    vec3 lightp = normalize(c_light-hpp);\n    vec3 light2 = normalize(c_light2-hps);\n    vec3 lightp2 = normalize(c_light2-hpp);\n    vec3 camerav = normalize(camera - hps);\n    vec3 camerapv = normalize(camera - hpp);\n\n    float diff = clamp(dot(light, ns), 0.,1.) + .2;\n    float diff2 = clamp(dot(lightp, vec3(0,1,0)), 0.,1.) + .1;\n    float diff3 = clamp(dot(light2, ns), 0.,1.) + .2;\n    float diff4 = clamp(dot(lightp2, vec3(0,1,0)), 0.,1.) + .1;\n\n    float spec = pow(max(dot(reflect(-light, ns), camerav), .0), 64.);\n    float spec2 = pow(max(dot(reflect(-lightp, vec3(0,1,0)), camerapv), .0), 64.);\n    float spec3 = pow(max(dot(reflect(-light2, ns), camerav), .0), 64.);\n    float spec4 = pow(max(dot(reflect(-lightp2, vec3(0,1,0)), camerapv), .0), 1024.);\n\n    if (rsr && rpr) {\n        if (hds < hdp) {\n            fragColor = vec4(vec3(.4*diff + .4*diff3 + spec + spec3), 1.);\n\t    fragColor.rgb *= vec3(.99,.2,.2);\n\t} else {\n\t    fragColor = vec4(vec3(.4*diff2 + .4*diff4 + spec2 + spec4), 1.);\n\t    fragColor.rgb *= vec3(.0,.6,.99);\n\t}\n    } else if (rsr) {\n\tfragColor = vec4(vec3(.4*diff + .4*diff3 + spec + spec3), 1.);\n\tfragColor.rgb *= vec3(.99,.2,.2);\n    } else if (rpr) {\n\tbool shadow = ray_sphere_sect(hpp, lightp, vec3(0.), .25,tempns, temp, tempf);\n\tbool shadow2 = ray_sphere_sect(hpp, lightp2, vec3(0.), .25,tempns2, temp2, tempf2);\n\ttempf = 1./tempf;\n\ttempf = .15*tempf;\n\ttempf = pow(tempf, 3.);\n\ttempf2 = 1./tempf2;\n\ttempf2 = .15*tempf2;\n\ttempf2 = pow(tempf2, 3.);\n\tif (shadow) {\n\t    fragColor = vec4(vec3(.4*diff2 + .4*diff4 + spec2 + spec4), 1.);\n\t    fragColor.rgb *= vec3(.0,.6,.99);\n\t    fragColor.rgb -= tempf;\n\t    fragColor.rgb -= tempf2;\n\t} else {\n\t    fragColor = vec4(vec3(.4*diff2 + .4*diff4 + spec2 + spec4), 1.);\n\t    fragColor.rgb *= vec3(.0,.6,.99);\n\t}\n    } else {\n        fragColor = vec4(vec3(.4), 1.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttB3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 125], [127, 127, 231, 231, 589], [591, 591, 709, 709, 1002], [1004, 1004, 1059, 1059, 3684]], "test": "ok"}
{"id": "ttBGRD", "name": "Shaderwave", "author": "kosua20", "description": "Inspired by that synthwave meme.", "tags": ["80s", "retro", "synthwave"], "likes": 12, "viewed": 1191, "published": "Public API", "date": "1558631749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\tShaderWave - A recreation of a 80's nostalgia-fueled meme image.\n\tSimon Rodriguez, 2019.\n\tFeel free to reuse this code for any non-commercial purpose.\n*/\n\n/// Noise helpers.\n\n// 1-D noise.\nfloat noise(float p){\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\tfloat rand0 = fract(sin(fl) * 43758.5453123);\n\tfloat rand1 = fract(sin(fl+1.0) * 43758.5453123);\n\treturn mix(rand0, rand1, fc);\n}\n\n// 4 channels 1-D noise.\nvec4 noise(vec4 p){\n\tvec4 fl = floor(p);\n\tvec4 fc = fract(p);\n\tvec4 rand0 = fract(sin(fl) * 43758.5453123);\n\tvec4 rand1 = fract(sin(fl+1.0) * 43758.5453123);\n\treturn mix(rand0, rand1, fc);\n}\n\n// 2D to 1D hash, by Dave Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * 0.2831);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\n/// Background utilities.\n\n// Generate starfield.\nfloat stars(vec2 localUV, float starsDens, float starsDist){\n\t// Cenetr and scale UVs.\n\tvec2 p = (localUV-0.5) * starsDist;\n\t// Use thresholded high-frequency noise.\n\tfloat brigthness = smoothstep(1.0 - starsDens, 1.0, hash(floor(p)));\n\t// Apply soft transition between the stars and the background.\n\tconst float startsTh = 0.5;\n\treturn smoothstep(startsTh, 0.0, length(fract(p) - 0.5)) * brigthness;\n}\n\n// Distance from point to line segment.\nfloat segmentDistance(vec2 p, vec2 a, vec2 b){\n\t// Project the point on the segment.\n\tvec2 dir = b - a;\n\tfloat len2 = dot(dir, dir);\n\tfloat t = clamp(dot(p-a, dir)/len2,0.0,1.0);\n\tvec2 proj = a + t * dir;\n\t// Distance between the point and its projection.\n\treturn distance(p, proj);\n}\n\n// Distance from point to triangle edges.\nfloat triangleDistance(vec2 p, vec4 tri, float width){\n\t// Point at the bottom center, shared by all triangles.\n\tvec2 point0 = vec2(0.5, 0.37);\n\t// Distance to each segment.\n\tfloat minDist = \t   segmentDistance(p, point0, tri.xy) ;\n\tminDist = min(minDist, segmentDistance(p, tri.xy, tri.zw));\n\tminDist = min(minDist, segmentDistance(p, tri.zw, point0));\n\t// Smooth result for transition.\n\treturn 1.0-smoothstep(0.0, width, minDist);\n}\n\n/// Text utilities.\n\nfloat getLetter(int lid, vec2 uv){\n\t// If outside, return arbitrarily high distance.\n\tif(uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0){\n\t\treturn 1000.0;\n\t}\n\t// The font texture is 16x16 glyphs.\n\tint vlid = lid/16;\n\tint hlid = lid - 16*vlid;\n\tvec2 fontUV = (vec2(hlid, vlid) + uv)/16.0;\n\t// Fetch in a 3x3 neighborhood to box blur\n\tfloat accum = 0.0;\n\tfor(int i = -1; i < 2; ++i){\n\t\tfor(int j = -1; j < 2; ++j){\n\t\t\tvec2 offset = vec2(i,j)/1024.0;\n\t\t\taccum += texture(iChannel0, fontUV+offset, 0.0).a;\n\t\t}\n\t}\n\treturn accum/9.0;\n}\n\nvec3 textGradient(float interior, float top, vec2 alphas){\n\t// Use squared blend for the interior gradients. \n\tvec2 alphas2 = alphas*alphas;\n\t// Generate the four possible gradients (interior/edge x upper/lower)\n\tvec3 bottomInterior = mix(vec3(0.987,0.746,0.993), vec3(0.033,0.011,0.057), alphas2.x);\n\tvec3 bottomExterior = mix(vec3(0.633,0.145,0.693), vec3(0.977,1.000,1.000),  alphas.x);\n\tvec3 topInterior \t= mix(vec3(0.024,0.811,0.924), vec3(0.600,0.960,1.080), alphas2.y);\n\tvec3 topExterior \t= mix(vec3(0.494,0.828,0.977), vec3(0.968,0.987,0.999),  alphas.y);\n\t// Blend based on current location.\n\tvec3 gradInterior \t= mix(bottomInterior, topInterior, top);\n\tvec3 gradExterior \t= mix(bottomExterior, topExterior, top);\n\treturn mix(gradExterior, gradInterior, interior);\n}\n\n\n/// Main render.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates.\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvCenter = 2.0 * uv - 1.0; \n\n\t/// Background.\n\t// Color gradient.\n\tvec3 finalColor = 1.5*mix(vec3(0.308,0.066,0.327), vec3(0.131,0.204,0.458), uv.x);\n\t\n\tconst float gridHeight = 0.3;\n\tif(uv.y < gridHeight){\n\n\t\t/// Bottom grid.\n\t\t// Compute local cflipped oordinates for the grid.\n\t\tvec2 localUV = uv*vec2(2.0, -1.0/gridHeight) + vec2(-1.0, 1.0);\n\t\t// Perspective division, scaling, foreshortening and alignment.\n        localUV.x = localUV.x/(localUV.y+0.8);\n\t\tlocalUV *= vec2(10.0, 20.0);\n\t\tlocalUV.y = sqrt(localUV.y);\n\t\tlocalUV.x += 0.5;\n\t\t// Generate grid smooth lines (translate along time).\n\t\tvec2 unitUV = fract(localUV-vec2(0.0, 0.3*iTime));\n\t\tvec2 gridAxes = smoothstep(0.02, 0.07, unitUV) * (1.0 - smoothstep(0.93, 0.98, unitUV));\n\t\tfloat gridAlpha = 1.0-clamp(gridAxes.x*gridAxes.y, 0.0, 1.0);\n\n\t\t/// Fixed star halos.\n\t\t// Loop UVs.\n\t\tvec2 cyclicUV = mod(localUV-vec2(0.0, 0.3*iTime), vec2(9.0, 5.0));\n\t\t// Distance to some fixed grid vertices.\n\t\tconst float haloTh = 0.6;\n\t\tfloat isBright1 = 1.0-min(distance(cyclicUV, vec2(6.0,3.0)), haloTh)/haloTh;\n\t\tfloat isBright2 = 1.0-min(distance(cyclicUV, vec2(1.0,2.0)), haloTh)/haloTh;\n\t\tfloat isBright3 = 1.0-min(distance(cyclicUV, vec2(3.0,4.0)), haloTh)/haloTh;\n\t\tfloat isBright4 = 1.0-min(distance(cyclicUV, vec2(2.0,1.0)), haloTh)/haloTh;\n\t\t// Halos brightness.\n\t\tfloat spotLight = isBright1+isBright2+isBright3+isBright4;\n\t\tspotLight *= spotLight;\n\t\t// Composite grid lines and halos.\n\t\tfinalColor += 0.15*gridAlpha*(1.0+5.0*spotLight);\n\t\t\n\t} else {\n\t\t/// Starfield.\n\t\t// Compensate aspect ratio for circular stars.\n\t\tvec2 ratioUVs = uv*vec2(1.0, iResolution.y / iResolution.x);\n\t\t// Decrease density towards the bottom of the screen.\n\t\tfloat baseDens = clamp(uv.y-0.3, 0.0, 1.0);\n\t\t// Three layers of stars with varying density, cyclic animation.\n        float deltaDens = 20.0*(sin(0.05*iTime-1.5)+1.0);\n\t\tfinalColor += 0.50*stars(ratioUVs, 0.10*baseDens, 150.0-deltaDens);\n\t\tfinalColor += 0.75*stars(ratioUVs, 0.05*baseDens,  80.0-deltaDens);\n\t\tfinalColor += 1.00*stars(ratioUVs, 0.01*baseDens,  30.0-deltaDens);\n\t}\n\t\n\t/// Triangles.\n\t// Triangles upper points.\n\tvec4 points1 = vec4(0.30,0.85,0.70,0.85);\n\tvec4 points2 = vec4(0.33,0.83,0.73,0.88);\n\tvec4 points3 = vec4(0.35,0.80,0.66,0.82);\n\tvec4 points4 = vec4(0.38,0.91,0.66,0.87);\n\tvec4 points5 = vec4(0.31,0.89,0.72,0.83);\n\t// Randomly perturb based on time.\n\tpoints2 += 0.04*noise(10.0*points2+0.4*iTime);\n\tpoints3 += 0.04*noise(10.0*points3+0.4*iTime);\n\tpoints4 += 0.04*noise(10.0*points4+0.4*iTime);\n\tpoints5 += 0.04*noise(10.0*points5+0.4*iTime);\n\t// Intensity of the triangle edges.\n\tfloat tri1 = triangleDistance(uv, points1, 0.010);\n\tfloat tri2 = triangleDistance(uv, points2, 0.005);\n\tfloat tri3 = triangleDistance(uv, points3, 0.030);\n\tfloat tri4 = triangleDistance(uv, points4, 0.005);\n\tfloat tri5 = triangleDistance(uv, points5, 0.003);\t\n\tfloat intensityTri = 0.9*tri1+0.5*tri2+0.2*tri3+0.6*tri4+0.5*tri5;\n\t// Triangles color gradient, from left to right.\n\tfloat alphaTriangles = clamp((uv.x-0.3)/0.4, 0.0, 1.0);\n\tvec3 baseTriColor = mix(vec3(0.957,0.440,0.883), vec3(0.473,0.548,0.919), alphaTriangles);\n\t// Additive blending.\n\tfinalColor += intensityTri*baseTriColor;\n\n\t/// Horizon gradient.\n\tconst float horizonHeight = 0.025;\n\tfloat horizonIntensity = 1.0-min(abs(uv.y - gridHeight), horizonHeight)/horizonHeight;\n\t// Modulate base on distance to screen edges.\n\thorizonIntensity *= (1.0 - 0.7*abs(uvCenter.x)+0.5);\n\tfinalColor += 2.0*horizonIntensity*baseTriColor;\n\t\n\t/// Letters.\n\t// Centered UVs for text box.\n\tvec2 textUV = uvCenter*2.2-vec2(0.0, 0.5);\n\tif(abs(textUV.x) < 1.0 && abs(textUV.y) < 1.0){\n\t\t// Rescale UVs.\n\t\ttextUV = textUV*0.5+0.5;\n\t\ttextUV.x *= 3.5;\n\t\t// Per-sign UV, manual shifts for kerning.\n\t\tconst vec2 letterScaling = vec2(0.47,0.93);\n\t\tvec2 uvLetter1 = (textUV - vec2(0.60,0.50)) * letterScaling + 0.5;\n\t\tvec2 uvLetter2 = (textUV - vec2(1.50,0.50)) * letterScaling + 0.5;\n\t\tvec2 uvLetter3 = (textUV - vec2(2.15,0.54)) * letterScaling * 1.2 + 0.5;\n\t\tvec2 uvLetter4 = (textUV - vec2(2.70,0.50)) * letterScaling + 0.5;\n\t\t// Get letters distance to edge, merge.\n\t\tfloat let1 = getLetter(200, uvLetter1);\n\t\tfloat let2 = getLetter(192, uvLetter2);\n\t\tfloat let3 = getLetter(215, uvLetter3);\n\t\tfloat let4 = getLetter(131, uvLetter4);\n\t\t// Merge and threshold.\n\t\tfloat finalDist = 0.52 - min(let1, min(let2, min(let3, let4)));\n\t\t// Split between top and bottom gradients (landscape in the reflection).\n\t\tfloat localTh = 0.49+0.03*noise(70.0*uv.x+iTime);\n\t\tfloat isTop = smoothstep(localTh-0.01, localTh+0.01, textUV.y);\n\t\t// Split between interior and edge gradients.\n\t\tfloat isInt = smoothstep(0.018, 0.022, finalDist); \n\t\t// Compute relative heights along the color gradients (both bottom and up (shifted)), rescale.\n\t\tvec2 localUBYs = vec2(1.8*(textUV.y-0.5)+0.5);\n\t\tlocalUBYs.y -= isTop*0.5;\n\t\tvec2 gradientBlend = localUBYs / localTh;\n\t\t// Evaluate final mixed color gradient.\n\t\tvec3 textColor = textGradient(isInt, isTop, gradientBlend);\n\t\t// Add sharp reflection along a flat diagonal.\n\t\tif(textUV.x-20.0*textUV.y < -14.0 || textUV.x-20.0*textUV.y > -2.5){\n\t\t\ttextColor += 0.1;\n\t\t}\n\t\t// Soft letter edges.\n\t\tfloat finalDistSmooth = smoothstep(-0.0025, 0.0025,finalDist);\n\t\tfinalColor = mix(finalColor, textColor, finalDistSmooth);\n\t}\n\t\n\t/// Vignetting.\n\tconst float radiusMin = 0.8;\n\tconst float radiusMax = 1.8;\n\tfloat vignetteIntensity = (length(uvCenter)-radiusMin)/(radiusMax-radiusMin);\n\tfinalColor *= clamp(1.0-vignetteIntensity, 0.0, 1.0);\n\n\t/// Exposure tweak, output.\n\tfragColor = vec4(pow(finalColor, vec3(1.2)),1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBGRD.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[180, 194, 215, 215, 390], [392, 417, 436, 436, 607], [609, 683, 702, 702, 814], [844, 867, 927, 953, 1269], [1271, 1311, 1357, 1395, 1595], [1597, 1639, 1693, 1750, 2073], [2096, 2096, 2130, 2180, 2631], [2633, 2633, 2691, 2742, 3408], [3429, 3429, 3486, 3520, 9152]], "test": "error"}
{"id": "ttf3W2", "name": "Particle walls", "author": "ciphered", "description": "Messing up with the raytracing algorithm, not looking really good", "tags": ["raymarchingraytracing"], "likes": 2, "viewed": 210, "published": "Public", "date": "1557666922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Basic raytracing algorithm \n */\n\n#define NEAR 0.001\n#define FAR 100.0\n#define FOG 0.00008\n#define FOV 0.5\n#define RT_ITERATIONS 128\n#define TARGET vec3(0.0)\n#define PI 3.14159265359\n\n\n\nfloat glow = 0.0, ttpi;\n\nvec3 cw, cu, cv, rd;\nvec3 np;\n\nvec2 e = vec2(0.00035, -0.00035);\n\n// useful functions\nmat2 r2 (float r) { return mat2(cos(r), sin(r), -cos(r), cos(r)); }\nfloat noise (vec3 p) {\n\tvec3 ip = floor(p),\n         s = vec3(7.0, 157.0, 113.0);\n    p-= ip;\n    vec4 h = vec4(0.0, s.yz, s.y+s.z) + dot(ip, s);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n\n/**\n * Distance functions for primitives \n */\n// box\nfloat bo (vec3 p, vec3 r) { \n    p = abs(p)-r; \n    return max(max(p.x, p.y), p.z); \n}\n// rounded box\nfloat roBo (vec3 p, vec3 b, float r) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n// capsule, a, b are the extremity points of the capsule\nfloat ca (vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n/**\n * this function generates a scene, distance based\n */\nvec2 fb (in vec3 p) {\n    /*vec2 h, t = vec2(ca(p+vec3(0.0,2.0,0.0), 4.0, 1.0), 5.0);\n    t.x = min(bo(abs(p)-vec3(4.8,4.8,4.8), vec3(1.2, 1.2, 1.2)), t.x);\n    \n    h = vec2(ca(p, 10.0, 0.2), 3.0);\n    \n    t = t.x < h.x ? t : h;\n    */\n    \n    vec2 t = vec2(roBo(p, vec3(3.9, 3.9, 3.9), 0.8), 5.0);\n    \n    t.x = max(-ca(p, vec3(-8.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0), 3.0), t.x);\n    t.x = max(-ca(p, vec3(0.0, -8.0, 0.0), vec3(0.0, 8.0, 0.0), 3.0), t.x);\n    t.x = max(-ca(p, vec3(0.0, 0.0, -8.0), vec3(0.0, 0.0, 8.0), 3.0), t.x);\n    \n    t.x*= 0.5;\n    \n    glow+= 0.1 / (0.1+t.x*t.x*100.0);\n    \n    return t;\n}\n\n\n/**\n * MAPPING FUNCTION\n */\nvec2 mp (vec3 p) {\n    float bass = texture(iChannel0, vec2(0.0, 0.0)).r;\n    \n    p.xy*= r2(iTime/3.0);\n    \n    p.z = mod(p.z-iTime*9.0, 20.0)-8.0;\n    \n    // this breaks the ray marching, giving the particule texture to the scene\n    p.xy*= r2(p.z * (iTime*bass));\n    \n    np = p;\n    \n    float s = sin(p.z*2.0-5.0)*0.1;\n    \n    for (float i = 0.0; i < 7.0; i++) {\n    \tnp = abs(np) - vec3(2.8, 1.0-bass*1.2, 2.5);\n        np.xz*= r2(0.1+s);\n    }\n    \n    vec2 h, t = fb(np.xyz);\n    \n    return t;\n}\n\n\n/**\n * RAY TRACING METHOD \n */\nvec2 tr (in vec3 ro, in vec3 rd) {\n    vec2 h, t = vec2(0.1);\n    for (int i = 0; i < RT_ITERATIONS; i++) {\n        h = mp(ro+rd*t.x);\n        if (h.x < NEAR || t.x > FAR) break;\n        t.x+= h.x;\n        t.y = h.y;\n    }\n    if (t.x > FAR) t.x = 0.0;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv/= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // a bit naive but enough\n    float bassLevel = (texture(iChannel0, vec2(0.0, 0.0)).r+texture(iChannel0, vec2(0.2, 0.0)).r)/2.0;\n    \n    // time \n    float tt = mod(iTime, 100.0),\n          bb = 0.5 + clamp(sin(tt), -0.5, 0.5);\n    \n    // background\n    vec3 col, fo, ld = normalize(vec3(0.1,0.5,-0.5));\n    col = fo = vec3(0.4)*cos(iTime/8.0) + vec3(0.1) * (1.0 - length(uv)*1.5 - 0.1);\n    \n    // camera \n    ttpi = mod(tt, 2.0*PI);\n    ttpi = ttpi > PI ? 2.0*PI-ttpi : ttpi;\n    //vec3 ro = vec3(cos(ttpi)*15.0, 0.0, sin(ttpi)*16.0);\n    vec3 ro = vec3(0.0,0.0,20.0);\n    cw = normalize(TARGET-ro);\n    cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    cv = normalize(cross(cu, cw));\n    rd = mat3(cu, cv, cw) * normalize(vec3(uv, FOV));\n    \n    // raytracer algorithm is called\n    vec2 sc = tr(ro, rd);\n    \n    // distance camera / object\n    float d = sc.x;\n    \n    // if d > 0, we compute the color of the pixel based on the scene \n    if (d > 0.0) {\n   \t\tvec3 po = ro + rd*d,\n             no = normalize(e.xyy*mp(po+e.xyy).x + e.yyx*mp(po+e.yyx).x + e.yxy*mp(po+e.yxy).x + e.xxx*mp(po+e.xxx).x),\n             al = mix(vec3(1.0-d/12.0, 1.0,1.0), vec3(1.0, 0.0, 0.32), 0.0);\n        \n        if (sc.y < 5.0) {\n            al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.8),abs(cos(iTime/5.0)));\n        }\n        \n        // lighting\n        \n        float dif = max(0.0, dot(no, ld)),\n              aor = d / 50.0,\n              ao = exp2(-2.0*pow(max(0.0, 1.0-mp(po+no*aor).x/aor), 2.0)),\n              spo = exp2(1.0+3.0*noise(np/vec3(0.4, 0.8, 0.6)) + noise(np/vec3(0.2))),\n              fr = pow(1.0+dot(no, rd), 4.0);\n        \n        vec3 sss = vec3(1.5) * smoothstep(0.0, 1.0, mp(po+ld*0.4).x/0.4),\n             sp = vec3(1.0) * pow(max(dot(reflect(-ld, no), -rd), 0.0), spo);\n            \n        \n        col = mix(sp + al * (0.8*ao+0.2) +al*(dif+sss), fo, min(fr, 0.5));\n        col = mix(col, fo, 1.0 - exp(-FOG*d*d*d));\n    }\n    \n    // we add the glow\n    //bassLevel*= bassLevel;\n    col+= vec3(0.0,.9,.3)*glow*0.05*bassLevel;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttf3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 303, 322, 322, 370], [371, 371, 393, 393, 650], [653, 706, 733, 733, 792], [793, 808, 846, 846, 1000], [1001, 1058, 1102, 1102, 1229], [1232, 1291, 1312, 1528, 1909], [1912, 1940, 1958, 1958, 2448], [2451, 2482, 2516, 2516, 2750], [2753, 2753, 2810, 2860, 5095]], "test": "error"}
{"id": "ttf3Wl", "name": "Sacred Computer Logo", "author": "twenkid", "description": "Логото на \"Свещеният сметач\". Създаден на основата на шейдъра ми за \"Хакафе\". ", "tags": ["computer", "sacred", "ezine", "bulgarian"], "likes": 2, "viewed": 474, "published": "Public", "date": "1558145056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  СВЕЩЕНИЯТ СМЕТАЧ - Sacred Computer Logo ... \n  #16-5-2019 - 18-5-2019 \n   \n  Свещеният\n   сметач\n\n  А - като Я, но горното изместено вляво\n\n   ####\n   #  #\n   ####\n  #   #\n  #   #\n\n  ###    ###\n  #  #  #  #\n  #  ####  #\n  #        #\n  \n   ####\n   #  #\n  ######\n  #    #\n  #    #\n\n  #   #\n  #   #\n   ####\n      #\n      #\n\n  Modified[\"Hackafe Logo\"]. Vers. 18/5/2019\n  Ugly dist code - whatever.\n\n  [Author]: Todor \"Tosh\" Arnaudov (Twenkid) http://artificial-mind.blogspot.bg | http://research.twenkid.com\n  [Credits and Thanks]: Shadertoy community, iq, Dave Hoskins, rear, LeGuignon; BigWings etc.\n                       \n  [История]\n  Свещненият сметач\", списанието на юнаците се възражда. Създадено в края на 2000 г.\n  от младия творчески хакер (юнак) Тош. Там са публикувани авангардни философски статии, проза, поезия,\n  технически статии, публицистика, исторически статии, сатра, юнашки разкази (технически-художествен),\n  Дружество за защита на българския език, дружество \"Разум\", класически български компютърни игри,\n  безплатен софтуер като синтезатора на реч \"Глас 2004\", текстовият редактор \"Писар\", речникът на юнашкото\n  наречие \"Езикотворец\" и др.\n\n  http://eim.twenkid.com  \n                        \n*/\n\nfloat z = 0.015;//5;\nfloat StepDiv = 35.;\nfloat StepBase = 0.30; //Blocks\nconst float cube = 3.; //(~) distance to distinguish the cube from space\nfloat step = 0.8; //Blocks\nconst vec2 cameraYz = vec2(2.5,-6.5); //vec2(2.65,-5.5); //the X is animated\nfloat cameraSpeed = 1.5; //2.4; //2.7;\n\nconst int STEPS = 50; //ray marching steps\nconst float EPS = 0.001; //precision (epsilon)\nconst float PI = 3.1415926;\n\n// from iq's \"Anels\", from Kali's Lonely Tree shader, from Analytical geometry textbooks - rotation around axis\nmat3 rotationMat(in vec3 v, in float angle) //, in out vec3 vOut)\n{\n    float c = cos(angle), s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, \n                (1.0 - c) * v.x * v.y - s * v.z,\n                (1.0 - c) * v.x * v.z + s * v.y,\n                \n                (1.0 - c) * v.x * v.y + s * v.z,\n                c + (1.0 - c) * v.y * v.y,\n                (1.0 - c) * v.y * v.z - s * v.x,\n                \n                (1.0 - c) * v.x * v.z - s * v.y,\n                (1.0 - c) * v.y * v.z + s * v.x,\n                c + (1.0 - c) * v.z * v.z);\n}\n\n// jerome, Electricity\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm8(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 8; i++) {\n        total += noise(n)/2. * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n//Based on Electricity, but modified by Twenkid to look somewhat like a burst of hot gas.\n//Should be optimized and varied - e.g. arrays and cycles/more streams/more adjustible\nvec3 electricity(vec2 uv ){    \n   vec2 t = uv * vec2(2.0,1.0) - iTime*4.0;      \n   float ybase = 0.30, ystep = 0.03;\n   float ycenter = ybase+fbm8(t)*0.35;\n    \n   float ycenter2 = ybase+ystep+fbm8(t)*0.5;\n   float ycenter3 = ybase-ystep+fbm8(t)*0.5;    \n   float diff = abs(uv.y - ycenter);\n   float c1 = 1.0 - mix(0.0,0.3,diff*21.0);\n     \n    c1 = clamp(c1, 0., 1.);\n    vec3 col = vec3(c1*0.9, 0.9*c1,c1*0.2);\n        \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.0,0.2,diff2*21.0);    \n    col = mix(col, vec3(c2*0.7, 0.4*c2, c2*0.1), 0.7);\n    \n    float d3 = abs(uv.y - ycenter3);\n    float c3 = 1.0 - mix(0.0,0.3,diff2*21.0);\n    col = mix(col, vec3(c3*0.5, 0.3*c3, c3*0.1), 0.5);\n    //col = mix(col, vec3(c3*0.7+abs(noise(uv)/5.), 0.3*c3, c3*0.1), 0.5); //noise - no, too jaggy\n   // col = min(col, vec3(c3*0.7+abs(fbm8(uv)/5.), 0.3*c3, c3*0.1));\n    col = max(vec3(0.), col); //avoid negative color - electricity is multiplied in the render\n    return col;\n}\n// jerome's end\n\n//// Dave Hoskins's? noise\nfloat N1(float t) { return fract(sin(t*10234.324)*123423.23512);  }\n\nvec2 N22(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW   //modified to vec2, vec2\n\tvec2 p2  = fract(vec2(p.xyx) * vec2(443.897, 441.423)); // 437.195));\n    p2 += dot(p2, p2.yx + 19.19);\n    return fract(vec2((p2.x + p2.y)*p2.x, (p2.y+p2.y)*p2.x));\n}\n\nvec2 fbm(vec2 v){ return N22(v)*0.5 + vec2(0.25*N1(v.x)) + vec2(0.25*N1(v.y)); }\n\n//iq's box\nfloat sdBox( vec3 p, vec3 b ) { // float zoom = 3.;   \n    vec3 d = (abs(p) - b);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxAngle( vec3 p, vec3 b, vec3 axis, float angle ) { // float zoom = 3.;      \n    axis = normalize(axis);\n    p = p*rotationMat(axis, angle);\n    float d = sdBox((p-b), b);//(abs(p) - b);\n    return d;\n    //d = d*rotationMat(d,a);\n    //return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//float sdPlane(vec3 p){return p.y;} //future use - grid plane?\n\nfloat distLimitBorder(vec3 r){ //26-12-2017\n   //float step = StepBase + sin(iTime)/STEPDIV;\n   //float d3 = sdBox(r-vec3(1.0,0.25, 0.0), vec3(0.1, 0.1, z));\n   //return d3;\n    \n   vec3 axis = normalize(vec3(1.0, 0.25, 0.0));  \n   r*= rotationMat(axis, mod(fract(iTime)*6.28, 6.28));    \n   float d1 = sdBox(r-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));  \n   return d1;    \n}  \n/*\nfloat distLimitBig(vec3 r){ //26-12-2017 - right border/curtain\n   float step = StepBase+ sin(iTime)/StepDiv;\n   float d3 = sdBox(r-vec3(10.0,StepBase, 0.0), vec3(9., 10., z));\n   return d3;\n}\n*/\n  \n//Distance from the objects. Should be optimized, could use one or a few common formulas,\n//except for the rotating block.\nfloat dist(vec3 r)\n{      \n    float d9, d10, d11, d12,d13,d14,d15,d16, d17, d18,d19;\n   float step = StepBase + sin(iTime)/StepDiv;           \n    vec3 axis = normalize(vec3(1.0, 0.25, 0.0));     \n    vec3 r1 = r * rotationMat(axis, mod(fract(iTime)*6.28, 6.28)); \n    float d;\n    float d1,d2,d3,d4,d5,d6,d7,d8;\n    float d20,d21,d22,d23,d24,d25,d26,d27,d28,d29,d30,d31,d32,d33,d34,d35,d36,d37,d38,d39,d40;\n    float d41,d42,d43,d44,d45,d46,d47,d48,d49,d50,d51,d52,d53,d54,d55;\n    \n    /*\n    float d1 = sdBox(r1-vec3( 1.0,0.25, 0.0), vec3(0.1, 0.1, z));      \n    float d2 = sdBox(r-vec3(1.0-step,0.25, 0.0), vec3(0.1, 0.1, z));\n    float d3 = sdBox(r-vec3(1.0-step-step,0.25, 0.0), vec3(0.1, 0.1, z));\n        \n    float d4 = sdBox(r-vec3(1.0,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d5 = sdBox(r-vec3(1.0-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    float d6 = sdBox(r-vec3(1.0-step-step,0.25+step, 0.0), vec3(0.1, 0.1, z));\n    \n    float d7 = sdBox(r-vec3(1.0,0.25-step, 0.0), vec3(0.1, 0.1, z));   \n    float d8 = sdBox(r-vec3(1.0-step-step,0.25-step, 0.0), vec3(0.1, 0.1, z));\n    */\n    \n    //С    \n    d1 = sdBox(r-vec3( 0.2,0.6, 0.0), vec3(0.12, 0.03, z));  //HORIZ    \n    d2 = sdBox(r-vec3( 0.09,0.465, 0.0), vec3(0.03, 0.13, z));  //VERT\n    d3 = sdBox(r-vec3( 0.2,0.33, 0.0), vec3(0.12, 0.03, z));  //HORIZ\n    \n    \n    //В\n    d4 = sdBox(r-vec3( 0.44, 0.5, 0.0), vec3(0.05, 0.01, z));  //HORIZ    \n    \n    d5 = sdBox(r-vec3( 0.375,0.42, 0.0), vec3(0.02, 0.09, z));  //VERTICAL LEFT\n    \n    d6 = sdBox(r-vec3( 0.43,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    \n    d7 = sdBox(r-vec3( 0.43,0.42, 0.0), vec3(0.07, 0.01, z)); //HORIZ MIDDLE\n    \n    d8 = sdBox(r-vec3( 0.47,0.46, 0.0), vec3(0.02, 0.05, z)); //VERTICAL RIGHT UP\n    d9 = sdBox(r-vec3( 0.49,0.37, 0.0), vec3(0.02, 0.04, z)); //VERTICAL RIGHT DOWN    \n    \n    \n    float s = 0.18;\n    //Е\n    d10 = sdBox(r-vec3( 0.44+s, 0.5, 0.0), vec3(0.045, 0.01, z));  //z+ is UP!\n    //d2 = sdBox(r-vec3( 0.2,0.6, 0.0), vec3(0.03, 0.12, z));  //z+ is UP! +\n    //+\n    d11 = sdBox(r-vec3( 0.375+s,0.42, 0.0), vec3(0.02, 0.09, z));  //z+ is UP!    \n    d13 = sdBox(r-vec3( 0.435+s,0.41, 0.0), vec3(0.045, 0.01, z));\n    d12 = sdBox(r-vec3( 0.415+s,0.32, 0.0), vec3(0.06, 0.01, z));\n    \n    //Щ\n    float st = 0.44+s/2.;\n    float s1 = 0.07;\n    st+=s;\n    \n    d14 = sdBox(r-vec3(st ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d15 = sdBox(r-vec3(st + s1 ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d16 = sdBox(r-vec3(st + s1*2. ,0.42, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d17 = sdBox(r-vec3(st + s1, 0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    \n    d18 = sdBox(r-vec3(st + s1*2. + 0.03, 0.34, 0.0), vec3(0.02, 0.01, z)); //HORIZ DOWN RIGHT\n    //d19 = sdBox(r-vec3(st + s1*2. + 0.03 + 0.03, 0.34, 0.0), vec3(0.01, 0.03, z)); //HORIZ DOWN RIGHT - MIDDLE\n    d19 = sdBox(r-vec3(st + s1*2. + 0.03 + 0.012, 0.33, 0.0), vec3(0.01, 0.03, z)); //HORIZ DOWN RIGHT - MIDDLE\n    \n    \n    float sm = s + s/2.0 + 0.09 + s + 0.03;\n    //Е\n    d20 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.045, 0.01, z));  \n   \n    d21 = sdBox(r-vec3( 0.375+sm,0.42, 0.0), vec3(0.02, 0.09, z));   \n    d22 = sdBox(r-vec3( 0.435+sm,0.41, 0.0), vec3(0.045, 0.01, z));\n    d23 = sdBox(r-vec3( 0.415+sm,0.32, 0.0), vec3(0.06, 0.01, z));\n    \n    sm += 0.09;\n    //Н\n    //d24 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.045, 0.01, z));\n    d24 = sdBox(r-vec3( 0.44+sm,0.41, 0.0), vec3(0.02, 0.10, z));\n    d25 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d26 = sdBox(r-vec3( 0.44+sm+0.04,0.41, 0.0), vec3(0.06, 0.01, z));\n    \n    sm+=0.09+0.075;\n    //И\n    d27 = sdBox(r-vec3( 0.44+sm,0.41, 0.0), vec3(0.02, 0.10, z));\n    d28 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d29 = sdBox(r-vec3( 0.44+sm+0.04,0.32, 0.0), vec3(0.06, 0.01, z)); //HOR DOWN\n    \n    sm +=0.09+0.15;\n    float cor = 0.05;\n    //Я\n    d30 = sdBox(r-vec3( 0.44+sm, 0.5, 0.0), vec3(0.036, 0.01, z));  //HORIZ TOP    \n    \n    d31 = sdBox(r-vec3( 0.375+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));  //VERTICAL RIGHT\n    \n    //d32 = sdBox(r-vec3( 0.43+sm,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    d32 = d31;\n    \n    d33 = sdBox(r-vec3( 0.41+sm,0.41, 0.0), vec3(0.06, 0.01, z)); //HORIZ MIDDLE\n    \n    d34 = sdBox(r-vec3( 0.39+sm,0.45, 0.0), vec3(0.013, 0.05, z)); //VERTICAL LEFT UP\n    d35 = sdBox(r-vec3( 0.36+sm,0.36, 0.0), vec3(0.02, 0.050, z)); //VERTICAL LEFT DOWN\n    float dq1 = min(d30,d31), dq2 = min(d32,d33), dq3 = min(d34,d35);\n    dq2 = min(dq2, dq3);\n    dq1 = min(dq1, dq2);\n    \n    //Т\n    sm+=0.09+0.03;    \n    d36 = sdBox(r-vec3( 0.44+sm+0.04,0.41, 0.0), vec3(0.02, 0.10, z)); //VER\n    //d37 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49, 0.0), vec3(0.09, 0.02, z)); //HOR MID   \n    d = min(d36,d37);\n    dq1 = min(dq1,d);\n    //dq1 = min(dq1, d38);\n    \n    float sy = 0.3;\n    sm = 0.2;\n    //SECOND LINE\n    //С   \n    /*\n    d38 = sdBox(r-vec3( 0.2 + sm,0.5-sy, 0.0), vec3(0.09, 0.015, z));    \n    d39 = sdBox(r-vec3( 0.11 + sm,0.41-sy, 0.0), vec3(0.02, 0.09, z));  //z+ is UP!\n    d40 = sdBox(r-vec3( 0.2 + sm,0.32-sy, 0.0), vec3(0.09, 0.015, z));  //VERT\n    d = min(d38, d39);\n    d = min(d, d40);\n    dq1 = min(dq1, d);\n    */\n    d38 = sdBox(r-vec3( 0.2 + sm + 0.02,0.5-sy, 0.0), vec3(0.06, 0.015, z));    \n    d39 = sdBox(r-vec3( 0.11 + sm + 0.04,0.41-sy, 0.0), vec3(0.02, 0.09, z)); //VERT\n    d40 = sdBox(r-vec3( 0.2 + sm +0.02,0.32-sy, 0.0), vec3(0.06, 0.015, z));  \n    d = min(d38, d39);\n    d = min(d, d40);\n    dq1 = min(dq1, d);\n    \n    /*\n    //М - не, 16:50\n    //Наклонени линии - остри. НЕ, по-добре правоъгълни като другите!\n    //vec3(0.0,1.0,0.0)  ---- \n    sm = 0.15;\n    float angle = -PI/2.5; // fract(iTime)*6.28;\n    d41 = sdBoxAngle(r-vec3( 0.2+sm,-0.07, 0.0), vec3(0.12, 0.015, z), vec3(0.0, 0.0,1.0), angle);  \n    d42 = sdBoxAngle(r-vec3( 0.2+sm+0.05,0.15, 0.0), vec3(0.09, 0.015, z), vec3(0.0, 0.0,1.0), -angle);  \n    d43 = sdBoxAngle(r-vec3( 0.2+sm+0.14,-0.01, 0.0), vec3(0.09, 0.015, z), vec3(0.0, 0.0,1.0), angle);  \n    d44 = sdBoxAngle(r-vec3( 0.2+sm+0.17,0.15, 0.0), vec3(0.11, 0.015, z), vec3(0.0, 0.0,1.0), -angle); \n    //d45 = sdBox(r-vec3( 0.2+sm+0.12,0.0, 0.01), vec3(0.02, 0.015, z));\n    d = min(d41,d42);   \n    d = min(d, d43);\n    d = min(d, d44);\n    //d = min(d,d45);\n    dq1 = min(d,dq1);\n     */\n    \n    sm += -0.11;\n    //М\n    d41 = sdBox(r-vec3( 0.44+sm,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.18,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d43 = sdBox(r-vec3( 0.44+sm+0.09,0.41-sy-0.03, 0.0), vec3(0.025, 0.01, z)); //HORIZ down   \n    d = min(d41,d42);   \n    dq1 = min(dq1, d);\n    dq1 = min(dq1,d43);\n    d43 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy+0.07, 0.0), vec3(0.03, 0.01, z)); //HORIZ\n    d44 = sdBox(r-vec3( 0.44+sm+0.18-0.04,0.41-sy+0.07, 0.0), vec3(0.03, 0.01, z)); //HORIZ\n    dq1 = min(dq1,d43);\n    dq1 = min(dq1,d44);\n    \n    d41 = sdBox(r-vec3( 0.44+sm+0.065,0.41-sy+0.02, 0.0), vec3(0.015, 0.04, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.18-0.065,0.41-sy+0.02, 0.0), vec3(0.015, 0.04, z)); //VERT\n    dq1 = min(dq1,d41);\n    dq1 = min(dq1,d42);\n\n    \n    //Е\n    sm+=0.32;\n    d40 = sdBox(r-vec3( 0.44+sm, 0.5-sy, 0.0), vec3(0.05, 0.01, z));  \n   \n    d41 = sdBox(r-vec3( 0.375+sm,0.42-sy, 0.0), vec3(0.02, 0.09, z));   \n    d42 = sdBox(r-vec3( 0.435+sm,0.41-sy, 0.0), vec3(0.045, 0.01, z));\n    d43 = sdBox(r-vec3( 0.415+sm,0.32-sy, 0.0), vec3(0.06, 0.01, z));\n    d = min(dq1, d40);\n    d = min(d, d41);\n    d = min(d,d42);\n    d = min(d,d43);\n    dq1 = min(d, dq1);\n    \n    //T\n    sm+=0.13;    \n    d36 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VER\n    //d37 = sdBox(r-vec3( 0.44+sm+0.09,0.41, 0.0), vec3(0.02, 0.10, z));\n    //d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49-sy, 0.0), vec3(0.09, 0.02, z)); //HOR MID THICK 0.02\n    d37 = sdBox(r-vec3( 0.44+sm+0.04,0.49-sy+0.01, 0.0), vec3(0.09, 0.015, z)); //HOR MID THINNER 0.015\n    d = min(d36,d37);\n    dq1 = min(dq1,d);\n    \n    //A    \n    sm += 0.24;        \n    d30 = sdBox(r-vec3( 0.44+sm-0.03, 0.5-sy, 0.0), vec3(0.035, 0.01, z));  //HORIZ TOP    \n    d34 = sdBox(r-vec3( 0.39+sm-0.02,0.45-sy, 0.0), vec3(0.013, 0.05, z)); //VERTICAL LEFT UP\n    \n    //d31 = sdBox(r-vec3( 0.375+sm+0.09,0.41-sy, 0.0), vec3(0.02, 0.10, z));  //VERTICAL RIGHT //LONG for Я\n    d31 = sdBox(r-vec3( 0.375+sm+0.09, 0.41-sy-0.05, 0.0), vec3(0.02, 0.05, z));  //VERTICAL RIGHT DOWN //LONG for Я        \n    d36 = sdBox(r-vec3( 0.375+sm+0.09-0.01, 0.41-sy+0.05, 0.0), vec3(0.013, 0.04, z)); //VERTICAL RIGHT UP\n    \n    //d32 = sdBox(r-vec3( 0.43+sm,0.32, 0.0), vec3(0.075, 0.01, z)); //HORIZ DOWN\n    d32 = d31;\n    \n    d33 = sdBox(r-vec3( 0.41+sm+0.005,0.41-sy, 0.0), vec3(0.065, 0.01, z)); //HORIZ MIDDLE    \n    d35 = sdBox(r-vec3( 0.36+sm,0.36-sy, 0.0), vec3(0.02, 0.050, z)); //VERTICAL LEFT UP\n    \n    dq1 = min(dq1, d30);\n    dq2 = min(d31,d32); dq3 = min(d33,d34);\n    dq1 = min(dq1,dq2);\n    dq1 = min(dq1,dq3);\n    dq1 = min(dq1,d35);\n    dq1 = min(dq1,d36);\n           \n    sm += 0.09;\n    //Ч\n    d41 = sdBox(r-vec3( 0.44+sm,0.41-sy+0.05, 0.0), vec3(0.02, 0.05, z)); //VERT\n    d42 = sdBox(r-vec3( 0.44+sm+0.09,0.41-sy, 0.0), vec3(0.02, 0.10, z)); //VERT\n    d43 = sdBox(r-vec3( 0.44+sm+0.05,0.41-sy, 0.0), vec3(0.05, 0.01, z)); //HORIZ //A little step\n   // d43 = sdBox(r-vec3( 0.44+sm+0.04,0.41-sy, 0.0), vec3(0.06, 0.01, z)); //HORIZ //RECT connection\n    d = min(d41,d42);   \n    dq1 = min(dq1, d);\n    dq1 = min(dq1,d43);\n    //dq = min(d, d44);\n\n    //Е\n    \n    //Т\n    \n    //А\n    \n    //Ч\n        \n    \n       \n    d = min(d1,d2);\n    d = min(d, min(d3,d4));\n    d = min(d, min(d5,d6));\n    d = min(d, min(d7,d8));       \n    d = min(d, d9);\n    d = min(d, d10);\n    d = min(d, d11);\n    d = min(d, d12);\n    d = min(d, d13);\n    float dx = min(d14, d15);\n    d = min(d,dx);\n    dx = min(d16,d17);\n    d = min(d,dx);\n    float dy = min(d18,d19);\n    d = min(d,dy);\n    dx = min(d20,d21);\n    dy = min(d22,d23);\n    d = min(d,dx);\n    d = min(d,dy);\n   // dx = min(d24,d25);\n   // d = min(d,dx);\n    // = min(d,d26);\n    dx = min(d24,d25);\n    d = min(d,dx);\n    d = min(d26,d);\n    dx = min(d27,d28);\n    dy = min(d,d29);\n    d = min(dx,dy);\n    d = min(d, dq1);\n       \n    return d;\n}\n\n// Normal vector - http://www.pouet.net/topic.php?which=7920&page=10 by rear\nvec3 normal(vec3 p)\n{\n\t#define dr 1e-5\n\tvec3 drx = vec3(dr,0,0);\n\tvec3 dry = vec3(0,dr,0);\n\tvec3 drz = vec3(0,0,dr);\n\treturn ( vec3( dist(p+drx), dist(p+dry), dist(p+drz) ) - dist(p)) / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(0.);    \n    vec2 r = (fragCoord.xy / iResolution.xy);\n\tr.x*=(iResolution.x/iResolution.y);\t           \n    r -=vec2(0.1, 0.8);    \t\t    \n    //r -=vec2(0.1, 0.6);  \n    //vec3 camera = vec3(1.05+(sin(iTime))*cameraSpeed,cameraYz); //more to the center      \t\n    vec3 camera = vec3(1.75+(sin(iTime)*0.6)*cameraSpeed,cameraYz); //\n    \n    //vec3 ro =  vec3(r.x, r.y+1.0, -1.0);    \n    //vec3 ro =  vec3(r.x+0.3, r.y+1.0 - cos(iTime)/4., -1.0 +sin(iTime)/3.);   \n    vec3 ro =  vec3(r.x+0.3, r.y+1.0, -1.0 +sin(iTime)/3.);   //Slight zoom\n    vec3 p = ro;  //ray origin          \n\tvec3 dir = normalize(p-camera); //ray direction\n    float d; //distance\n    \n\tfor(int i=0; i<STEPS; i++) //Ray marching\n\t{\n\t\td = dist(p);\n\t\tif(d < EPS) break;\n\t\tp = p+dir*d;\n\t}\n\n    vec3 materialcolor=vec3(0.);        \n    int m;  \n    if (d<=cube) { m = 0; materialcolor = vec3(0.9,.9,.2);} //cube;\n    else { m = 1; } //materialcolor = vec3(0.);}\n            \n\tvec3 nor = normal(p);  // normal vector\n    vec3 lightpos = vec3(1.5-sin(iTime)*5., 0.1+sin(iTime), 3.5+sin(iTime)*5.);           \n    lightpos.y +=sin(iTime); // [-1., +1]\n         \n    vec3 lightdir = normalize(vec3(0.3,0.3,0.3)-lightpos);\n   \t\n    float light = 1.0 + 0.01*(dot(nor,lightpos)); //intensity\n    \n    light *=  pow(dist(lightdir-p), 2.);\n    \n\t//vec3 color = vec3(light);\n    vec3 color = vec3(1.0-light/5.); //vec3(1.0, 1.0, 1.0);\n    color = clamp( materialcolor*color, 0., 1.0);\n    \n    //Phong\n    float dif = clamp( dot( nor, lightdir ), 0.0, 1.0 ); //iq diffuse\n    vec3  ref = reflect( dir, nor );  //reflection\n    float spe = pow(clamp( dot( ref, lightdir ), 0.0, 1.0 ),16.0); //specular component\n        \n    color+=dif/3. + spe/2.;\n        \n\tfragColor = vec4(color, 1.0);\n    fragColor.xyz = vec3(color);\n    fragColor.w = m ==0 ? 1. : 0.; //\n             \n    vec2 pos = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n   //The space, stars... #28-11-2017 & electricity\n   if ( fragColor.r < 0.001 && m==1)\n    {     \n        //To do: add more effects: specific stars, nebullas, planets, comets, black hole etc.... had meteors, but were removed;    \n        vec2 n1 = N22(pos);\n        float star = n1.x < 0.07 ? 0.1 : 0.;        \n        star+= n1.y > 0.97 ? N1(n1.x)/1.0*(max(star, sin(iTime))) : 0.0;\n        vec2 fb = fbm(pos);\n        star*=max(fb.x, fb.y);       \n        fragColor += star*1.4; //brighter stars\n        fragColor.a = 1.0;                                 \n        fragColor.xyzw+=vec4(clamp(abs(cos(iTime/3.5))*4.28, 1., 3.)*electricity(uv), 1.0); //thick line        \n    }\n    else //The blocks\n    {\n        \n     const float EPSLIMIT = EPS*5.; //0.06;\n        /*\n     float limit = 0.0;     \n     ro =  vec3(r.x, r.y+1.0, -1.0);    \n     p = ro;\n\t dir = normalize(p-camera);                     \n\t for(int i=0; i<STEPS/3; i++)  //Second marching for the rotating block and the burst. Fewer steps and lower precision are enough.\n\t {\n        d = distLimitBorder(p);\n\t\tif(d < EPSLIMIT) break;\n\t\tp = p + dir * d;\n\t  }\n        */\n        \n      if (d<EPSLIMIT) fragColor.xyz += electricity(uv);\n            \n      fragColor.w = 1.0; //Alpha\n      \n    }\n   \n    //Gamma correction\n     fragColor.xyz=pow(fragColor.xyz, vec3(1.4));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttf3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2110, 2222, 2289, 2289, 2792], [2794, 2817, 2837, 2837, 2906], [2908, 2908, 2929, 2929, 3135], [3137, 3137, 3157, 3157, 3341], [3343, 3520, 3547, 3547, 4513], [4531, 4558, 4577, 4577, 4625], [4627, 4627, 4645, 4728, 4897], [4899, 4899, 4916, 4916, 4979], [4981, 4992, 5023, 5046, 5139], [5141, 5141, 5201, 5227, 5449], [5516, 5516, 5546, 5689, 5890], [6095, 6218, 6238, 6238, 16660], [16662, 16739, 16760, 16760, 16930], [16932, 16932, 16989, 16989, 20317]], "test": "timeout"}
{"id": "ttf3Ws", "name": "Primitive Sphere", "author": "sakthig", "description": "Simple primitive sphere with raymarching", "tags": ["sphere", "primitive"], "likes": 2, "viewed": 70, "published": "Public", "date": "1558033458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code from https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttf3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 148, 148, 316], [318, 318, 352, 352, 558], [560, 560, 584, 584, 773], [775, 775, 799, 799, 1104], [1106, 1106, 1163, 1163, 1489]], "test": "ok"}
{"id": "ttfGz2", "name": "TwistedHyperboloids", "author": "bignobody", "description": "Found the hyperboloid equation the other day. Since I figured out how to raymarch a gyroid, I figured I should be able to do the same with a hyperboloid. But a hyperboloid isn't as fun a surface as a gyroid so I though it would be fun to distort it more.", "tags": ["raymarch", "domaindistortion", "hyperboloid"], "likes": 1, "viewed": 65, "published": "Public", "date": "1556906101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/WsfSDB\n#define NUM_LIGHTS 1\n#define MAX_REFLECTIONS 2\n#define AMBIENT_LIGHT 1.61\n\nvec3 colours[9] = vec3[](vec3(0.2,0.05,0.33), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,100.0,1.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\nfloat hyperboloidSDF( vec3 p, vec3 q, float s)\n{\n//Hyperboloid eq\n\t// x2/a2 + y2/b2 - z2/c2 = 1\n    // I swapped the z/y axis\n\tfloat g = pow(p.x,2.0)/ pow(q.x,2.0) - pow(p.y,2.0)/ pow(q.y,2.0) + pow(p.z,2.0)/ pow(q.z,2.0);\n    return length(normalize(p) * g * s);\n}\n\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n\n\tfloat t = cos(iTime) * 0.05 + p.z;   \n    float ev = length(p) * t;\n\tmat3 ry = mat3(cos(ev), 0.0, sin(ev),\n                   0.0,1.0,0.0,\n                   -sin(ev), 0.0, cos(ev));\n\tmat3 rz = mat3(cos(ev), sin(ev), 0.0,\n                   -sin(ev), cos(ev), 0.0,\n                   0.0,0.0,1.0);\n    \n    vec3 q = inverse(rz) * p;\n\n    float d = hyperboloidSDF(q, vec3(2.0,2.0,2.0), sin(iTime*0.02)* 0.5);\n\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n\tfloat s = sdfSphere(p, vec3(0.0,0.0,0.0), 0.5);\n    if (s < d)\n    {\n     \td = s;\n        pick = 2;\n    }\n    return d;\n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n    return vec3(0.0,4.0,-10.0);\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(surfacePoint,lightOrigin);\n    for( float s=0.01; s < end; )\n    {\n        vec3 marchStep = surfacePoint + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.00085)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n  //          shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n    //        shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n\tfloat ext = iTime * 0.28;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    vec3 camOrigin = vec3(0.0,0.0,-3.0 + (cos(ext) * 0.5));\t\n    vec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    int numReflections = MAX_REFLECTIONS;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 96;\n    const float MAX_DISTANCE = 96.0;\n    const float CLOSE_ENOUGH = 0.0001;\n\tconst int MAX_REFLECT_STEPS = 96;\n\tconst float MAX_REFLECT_DISTANCE = 64.0;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n  \n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + rayDirection * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            \n            colAccum = lightSurfacePoint(camOrigin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, pickTarget);\n\n            vec3 lastDirection = rayDirection;\n            vec3 lastSurfacePoint = surfacePoint;\n            vec3 lastSurfaceNormal = surfaceNormal;\n\t\t\t\n            for(int r = 0; r < numReflections; r ++)\n            {\n\t\t\t\t\n                vec3 reflectOrigin = lastSurfacePoint;\n                vec3 reflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                float reflectDistance = 0.001;\n    \t\t\tvec3 reflectVec = reflectOrigin;\n    \t\t\tvec3 reflectNormal = vec3(0.0);\n    \n        \t\tfloat reflectDist = 0.0;\n                float refMixVal = 0.35;\n\t\t    \tfor (int k = 0; k < MAX_REFLECT_STEPS; k ++)\n    \t\t\t{\n                    // march again from our new origin and accumulate colour from hit materials\n        \t\t\treflectVec = reflectOrigin + reflectDirection * reflectDistance;\n     \t\t\t\treflectDist = distanceToClosest(reflectVec, pickTarget);\n        \n        \t\t\tif (reflectDist <= CLOSE_ENOUGH)\n        \t\t\t{\n\t\t\t\t\t\t// hit something else!\n            \t\t\tlastSurfacePoint = reflectVec;\n    \t\t\t\t\tlastSurfaceNormal = estimateNormal(lastSurfacePoint, pickTarget);\n                        lastDirection = reflectDirection;\n                        colAccum = mix (colAccum, lightSurfacePoint(reflectOrigin, lastSurfacePoint, lastSurfaceNormal, AMBIENT_LIGHT, pickTarget), mix(reflectivity[pickTarget],refMixVal,0.5));\n                \t\trefMixVal = min(0.95, refMixVal+0.1);\n\t\t\t\t\t\t\n                        reflectDistance = 0.001;\n                        reflectDist = 0.0;\n                        reflectOrigin = lastSurfacePoint;\n                \t\treflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                        break;\n       \t\n        \t\t\t}\n        \t\t\telse\n                    {\n        \t\t\t\treflectDistance += reflectDist;   \n        \n        \t\t\t\tif (reflectDistance >= MAX_REFLECT_DISTANCE)\n        \t\t\t\t{\n            \t\t\t\t// sky colour\n            \t\t\t\t pickTarget = 0;\n        \t\t\t\t\tcolAccum = mix(colAccum, colours[pickTarget] - reflectDirection.y * 0.5, mix(reflectivity[pickTarget],refMixVal,0.5));\n                        \tbreak;\n        \t\t\t\t}\n                    }\n        \n    \t\t\t}\n\n            }\n\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \tpickTarget = 0;\n\t\t\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n            break;\n        }\n    }\n    \n    col = colAccum;\n\n\tvec3 fog = colours[0];\n\tfloat fogamt = 1.0 - exp(-marchDistance*0.01);\n\t\n\tcol = mix(col,fog,clamp(fogamt,0.0,1.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[884, 884, 932, 1009, 1149], [1151, 1151, 1193, 1193, 1221], [1223, 1238, 1287, 1287, 1924], [1926, 1926, 1971, 1971, 2398], [2400, 2400, 2430, 2430, 2464], [2465, 2500, 2558, 2558, 3191], [3192, 3192, 3303, 3303, 4636], [4638, 4638, 4695, 4735, 9038]], "test": "error"}
{"id": "ttjGDz", "name": "Circular noise movement", "author": "bozhkov", "description": "Circular noise exercise", "tags": ["2d", "noise", "circle"], "likes": 9, "viewed": 341, "published": "Public", "date": "1559226625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat circle(vec2 st, vec2 center, float radius) {\n    return smoothstep(1., 1.-0.025, distance(st, center) / radius);\n}\n\nfloat ring(vec2 st, vec2 center, float radius) {\n\treturn circle(st, center, radius) - circle(st, center, radius - 0.020);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    float r = 0.67,\n        a = atan(st.y, st.x),\n        noiseA = a + iTime;\n    \n    vec2 nPos = vec2(cos(noiseA), sin(noiseA));\n    \n    float n = noise(nPos),\n        n2 = noise(nPos + iTime);\n    \n    r += sin(a*10.) * n*.18;\n    r += sin(a*30.) * n2*.08;\n    \n    float pct = ring(st, vec2(0.), r); \n    color = vec3(0.3, 0.9, 0.9) * pct + vec3(0.3, 0.9, 0.5) * pct * n * 2.;\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 162], [164, 246, 268, 268, 672], [674, 674, 724, 724, 794], [796, 796, 844, 844, 919], [921, 921, 978, 978, 1492]], "test": "ok"}
{"id": "ttl3Rj", "name": "Voronoi Choco Wave", "author": "MrsBeanbag", "description": "gotta love Voronoi cells", "tags": ["voronoi", "shadows", "chocolate"], "likes": 3, "viewed": 346, "published": "Public API", "date": "1556966938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment this line to get mouse control rofl\n//#define MOUSE_CONTROL\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.002;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\n\nconst vec3 sky_colour = vec3(0.2, 0.1, 0.4);\nconst vec3 clouds_colour = vec3(1.0);\nconst vec3 sun_colour = 32.0 * vec3(1.0, 1.0, 0.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 30.0, 30.0 ));\n\n//get a scalar random value from a 3d value\nfloat rand2dTo1d(vec2 value, vec2 dotDir) {\n    //make value smaller to avoid artefacts\n    vec2 smallValue = sin(value);\n    //get scalar value from 3d vector\n    float random = dot(smallValue, dotDir);\n    //make value more random by making it bigger and then taking the factional part\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand2dTo3d(vec2 value){\n    return vec3(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135)),\n        rand2dTo1d(value, vec2(73.156, 52.235))\n    );\n}\n\n/*vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}*/\n\n// this isn't very random but it's a good deal quicker than the above\nvec2 random2( vec2 p ) {\n    return fract(p * vec2(9.61, 3.28) - p.yx * vec2(5.85, 7.11));\n}\n\n// http://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k ) {\n    return -smin(-a, -b, k);\n}\n\nvec2 cell_position(vec2 cell) {\n    vec2 point = random2(cell);\n    point = 0.1 + 0.8*fract(6.2831*point);\n    return cell + point;\n}\n\nfloat cell_height(vec2 cell) {\n    return 1.0 + cos(dot(cell, vec2(0.3, 0.2)) + iTime);\n\t//return 2.0*rand2dTo1d(cell, vec2(52.235, 09.151));\n}\n\nfloat dist_field(vec3 p) {\n    float md = 1000.0;\n    vec2 mcell = vec2(0.0);\n    vec2 mpos = vec2(0.0);\n    vec2 fuv = floor(p.xz);\n    for (int i = -1; i <= 1; ++i) {\n\t    for (int j = -1; j <= 1; ++j) {\n            vec2 cell = fuv + vec2(float(i), float(j));\n            vec2 pos = cell_position(cell);\n    \t\tvec2 mid = p.xz - pos;\n            float d = dot(mid, mid);\n            if (d < md) {\n                md = d;\n                mcell = cell;\n                mpos = pos;\n            }\n        }\n    }\n    \n    float mheight = cell_height(mcell);\n    float plane = p.y;\n    float outer = p.y + 2.1;\n    for (int i = -1; i <= 1; ++i) {\n\t    for (int j = -1; j <= 1; ++j) {\n            vec2 cell = fuv + vec2(float(i), float(j));\n            if (cell != mcell) {\n\t            vec2 pos = cell_position(cell);\n\t\t\t    vec2 n = normalize(mpos - pos);\n\t\t\t    vec2 pt = (mpos + pos) * 0.5;\n           \t    float boundary = dot(n, p.xz - pt);\n                float height = cell_height(cell);\n\t            float wall = smax(boundary, p.y + height, 0.1);\n                outer = smin(outer, wall, 0.1);\n\t\t\t    plane = smax(plane, -boundary, 0.1);\n            }\n        }\n    }\n    if (outer >= 0.0) {\n        plane = smax(plane, p.y + mheight, 0.1);\n        plane = smin(plane, outer, 0.1);\n    }\n    diffuse_colour = vec3(0.9, 0.4, 0.1);\n    return plane;\n}\n\nvec3 skybox(vec3 dir) {\n    float horizon = smoothstep(0.0, 0.25, dir.y);\n    float cloud = mix(0.8, 0.0, horizon);\n    return mix(sky_colour, clouds_colour, cloud);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    const vec2 kg = vec2(grad_step,-grad_step);\n    return vec3( k.xyy*dist_field( p + kg.xyy) +\n                 k.yyx*dist_field( p + kg.yyx) +\n                 k.yxy*dist_field( p + kg.yxy) +\n                 k.xxx*dist_field( p + kg.xxx) );\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\tfloat shininess = 80.0;\n\t\n\tvec3 ref = reflect( dir, n );\n\tfloat specular = max( 0.0, dot( sun_pos, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn final_diff_colour * diffuse + vec3(specular);\n}\n\n// ray marching\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n\n    // give the ray a bit of a head start by jumping\n    // straight to the upper bounding plane!\n    float t = 0.0;\n    if (dir.y < 0.0) {\n        t = -o.y/dir.y;\n    } else {\n        return skybox(dir);\n    }\n\tt = max(t, min_dist*2.0);\n\n    vec3 v;\n    for (int i = 0; i < max_iterations; i++) {\n       \tfloat d = dist_field(v = o + dir * t);\n\n        if (d <= min_dist) {\n            break;\n        }\n\t\tif ((t+=d) >= clip_far) {\n            return skybox(dir);\n\t    }\n    }\n\tfinal_diff_colour = diffuse_colour;\n    \n    vec3 n = normalize( gradient(v) );\n    if (dot(n, sun_pos) < 0.0) {\n        return colour;\n    }\n\n    // shadows\n    t = 0.1;\n    for (int i = 0; i < max_iterations; i++) {\n        vec3 r = v + sun_pos * t;\n\t\tif (r.y > 0.0) {\n\t\t    colour += shading( v, n, dir, o );\n            break;\n\t    }\n\n        float d = dist_field(r);\n        if (d <= min_dist) {\n            break;\n        }\n        t+=d;\n    }\n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nconst vec2 spin = vec2(0.005, 0.0041);\nconst float radius = 120.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n#ifdef MOUSE_CONTROL\n\tmat3 rot = rotationXY( vec2(PI, -PI) * ((iMouse.xy - iResolution.xy * 0.5)/iResolution.xy).yx );\n#else\n\tmat3 rot = rotationXY( vec2( -0.8, iTime * 0.2 ) );\n#endif\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 1.0, 0.0 );\n\teye = rot * eye;\n    \n    // move in a sinusoidal path so we don't end up in floating point hell!\n    vec2 camera = radius * cos(iTime * spin);\n    \n    eye += vec3(camera, 1.0).xzy;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n    fragColor = vec4(color, 1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttl3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[557, 601, 644, 688, 956], [958, 958, 986, 986, 1158], [1283, 1353, 1377, 1377, 1445], [1447, 1539, 1580, 1580, 1666], [1668, 1668, 1709, 1709, 1740], [1742, 1742, 1773, 1773, 1875], [1877, 1877, 1907, 1907, 2020], [2022, 2022, 2048, 2048, 3378], [3380, 3380, 3403, 3403, 3547], [3549, 3578, 3603, 3603, 3881], [3883, 3908, 3960, 3960, 4220], [4222, 4238, 4275, 4275, 5285], [5287, 5308, 5356, 5356, 5530], [5532, 5564, 5595, 5595, 5750], [5819, 5819, 5876, 5894, 6497]], "test": "error"}
{"id": "ttlGDf", "name": "WARP", "author": "alro", "description": "Position distortion with sin/cos", "tags": ["distort", "sin", "cos", "warp"], "likes": 34, "viewed": 1403, "published": "Public", "date": "1557947954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    float strength = 0.4;\n    float t = iTime/3.0;\n    \n    vec3 col = vec3(0);\n    vec2 fC = fragCoord;\n\n    #ifdef AA\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n\n            fC = fragCoord+vec2(i,j)/3.0;\n            \n            #endif\n            \n            //Normalized pixel coordinates (from 0 to 1)\n            vec2 pos = fC/iResolution.xy;\n\n            pos.y /= iResolution.x/iResolution.y;\n            pos = 4.0*(vec2(0.5) - pos);\n\n            for(float k = 1.0; k < 7.0; k+=1.0){ \n                pos.x += strength * sin(2.0*t+k*1.5 * pos.y)+t*0.5;\n                pos.y += strength * cos(2.0*t+k*1.5 * pos.x);\n            }\n\n            //Time varying pixel colour\n            col += 0.5 + 0.5*cos(iTime+pos.xyx+vec3(0,2,4));\n            \n            #ifdef AA\n        }\n    }\n\n    col /= 9.0;\n    #endif\n    \n    //Gamma\n    col = pow(col, vec3(0.4545));\n    \n    //Fragment colour\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "ttlGW4", "name": "Magnetik Atome", "author": "Gijlf", "description": "one 3d fractal with glowing\ni want made different background but i dont know how to do dat if you have any suggestion tell me in  comment ;)\nwork allways in progres. have fun !", "tags": ["geometryfoldfractalglowing"], "likes": 5, "viewed": 138, "published": "Public", "date": "1556982334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){float s=sin(a);float c=cos(a);return mat2(c,s,-s,c);}\nvec3 hash(float p)\n{\n    vec3 pp = vec3(fract(cos(p*87.)),p*25., p*93.25);\n    return fract((sin(dot(pp.yx, pp.xz*34.)*583.+pp*456.)*.5+.5)*562.);\n}\nfloat fbm(vec2 p)\n{\n    float n = texture(iChannel1, p/iResolution.xy).r * .5; p *= 2.;\n    n += texture(iChannel1, p/iResolution.xy).r * .25; p *= 2.;\n\tn += texture(iChannel1, p/iResolution.xy).r * .125; p *= 2.;\n\tn += texture(iChannel1, p/iResolution.xy).r * .0625; p *= 2.;\n\treturn n/.9735;\n}\nfloat fft(float p)\n{ return texelFetch(iChannel0, ivec2(floor(p*512.), 0.), 0).r;}\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));//+length(max(vec3(0.),d));\n}\nfloat portal(vec3 p, float a)\n{\n    p = abs(p);\n    p.x -= 2.5;\n    p.xy *= rot(a);\n    return box(p, vec3(.25,4.,.25));\n}\nfloat at = 0.;\nfloat mat = 0.;\nfloat map(vec3 p)\n{\n    vec3 sp = p;\n    float pl = p.y + 0.5;\n \tfloat s = 7.;\n    float r = length(p)*.07;//*(.6+.5*sin(iTime*.5));\n    float rr = pow(r, 2.5);\n    for(int i=0; i<3; i++)\n    {\n        p.xz *= rot(float(i)*.7);\n        p.yz *= rot(float(i)*.3*iTime*.3);\n        p = abs(p);\n        p -= s*rr;\n        s *= .65;\n    }\n    float b = portal(p, .8*rr)/(r*1.6);\n    float c = length(p)-.4/r;\n    at += .25/(.4+c);\n    mat = c < b ? 1. : 0.;\n    return min(c, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col; vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    float time = iTime*.3;\n    vec3 p = vec3(0.,0.,-60.);\tvec3 t;\n    p.xz = vec2(sin(time), cos(time))*60.;\n    vec3 cz = normalize(t-p); vec3 up = normalize(vec3(0.,1.,0.));\n    vec3 cx = normalize(cross(cz, up));\n    vec3 cy = normalize(cross(cz, cx));\n    vec3 rd = normalize(uv.x*cx + uv.y*cy + cz);\n\n    float td; int i;\n    for(; i<100; i++)\n    {\n        float d = map(p);\n        if(d<.001) break;\n        if(td>100.){td=100.;break;}\n        td += d; p += d*rd;\n    }\n    float atmos = at; float curmat = mat;\n    float fog = (100.-td)/100.;\n    vec3 ld = normalize(vec3(.5,1.,-.5));\n    vec2 o = vec2(.001,0.); vec3 n = normalize(map(p)-vec3(map(p-o.xyy),map(p-o.yxy),map(p-o.yyx)));\n    vec3 h = normalize(ld-rd);\n    float lum = dot(n,ld)*.5+.5;\n    float spec = pow(max(0., dot(n,h)), 5.);\n    float f = pow(max(0.,dot(-n,rd)), 5.);\n    float r = length(p);\n    vec3 sky = max(0.,dot(ld, rd))*vec3(.3, .0, .6);// * fbm(p.xy*.1);\n    vec3 glow = pow(atmos*.2, 2.2)*vec3(.2,.0,.7);//*(r*.08)*/ * fft(r*.05) *2.;\n    vec3 diff = mix(vec3(.9, .0, .2) + vec3(2.8, .0, 1.)*f, vec3(.0, .8, .4)*spec, curmat);\n    col += lum*fog*diff;\n    col += glow*.5;\n    col += sky;\n    //col = vec3(fbm(p.xz));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XtlGzS", "previewfilepath": "https://soundcloud.com/amaciejewski/gipsy-jazz-track-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/amaciejewski/gipsy-jazz-track-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 71], [72, 72, 92, 92, 220], [221, 221, 240, 240, 516], [517, 517, 537, 537, 599], [600, 600, 627, 627, 710], [711, 711, 742, 742, 833], [865, 865, 884, 884, 1341], [1342, 1342, 1399, 1399, 2711]], "test": "error"}
{"id": "tts3Dl", "name": "Pattern06_", "author": "Del", "description": "pattern", "tags": ["sin", "pattern"], "likes": 2, "viewed": 259, "published": "Public API", "date": "1558127400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    pos*=0.5;\n    pos+=vec2(0.5);\n\tfloat vv = pos.y*pos.y;\n\tvv+=sin(pos.x*3.14);\n\tfloat v = sin(sin(pos.x*15.0)*4.0+(vv) *50.0 + iTime * 2.0);\n\tv+=0.65;\n\tfragColor = vec4( v*1.3, 0.25+.3*v, 0.5, 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 336]], "test": "ok"}
{"id": "ttS3Rm", "name": "metball in room", "author": "aadebdeb", "description": "metall with fresnel reflection", "tags": ["raymarching", "metaball"], "likes": 8, "viewed": 95, "published": "Public", "date": "1558869420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BPM 120.0\n\nconst float GRID_SPACING = 5.0;\nconst vec3 WALL_SIZE = vec3(10.0, 5.0, 10.0) * GRID_SPACING + 0.5 * GRID_SPACING;\n\n#define LIGHT_BLUE vec3(0.05, 0.3, 1.2)\n#define LIGHT_ORANGE vec3(1.2, 0.15, 0.05)\n\nfloat timeToBeat(float time) {\n    return time / 60.0 * BPM;\n}\n\n// 1 bar = 4 beat\nfloat timeToBar(float time) {\n    return timeToBeat(time * 0.25);\n}\n\nfloat random(float x){\n    return fract(sin(x * 12.9898) * 43758.5453);\n}\n\nfloat random(vec4 x){\n    return fract(sin(dot(x,vec4(12.9898, 78.233, 39.425, 27.196))) * 43758.5453);\n}\n\nmat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat usin(float x) {\n    return sin(x) * 0.5 + 0.5;\n}\n\nvoid setNormalEnvironmentStatus(out vec3 color0, out vec3 color1, out float borderEdge0, out float borderEdge1, out ivec3 lines) {\n    color0 = vec3(0.75);\n    color1 = vec3(0.0, 0.075, 0.185);\n    borderEdge0 = 0.01;\n    borderEdge1 = 0.05;\n    lines = ivec3(1, 1, 1);\n}\n\nvoid setUnlightedEnvironmentStatus(out vec3 color0, out vec3 color1, out float borderEdge0, out float borderEdge1, out ivec3 lines) {\n    color0 = vec3(0.0);\n    color1 = vec3(0.0);\n    borderEdge0 = 0.0;\n    borderEdge1 = 0.0;\n    lines = ivec3(0, 0, 0);\n}\n\nvoid setLightBorderEdge(out float borderEdge0, out float borderEdge1) {\n    borderEdge0 = 0.0;\n    borderEdge1 = 0.1;\n}\n\nvoid setEnvironmentStatus(vec3 pos, int hit, out vec3 color0, out vec3 color1, out float borderEdge0, out float borderEdge1, out ivec3 lines) {\n    float beat = timeToBeat(iTime);\n    beat = mod(beat, 32.0);\n    float bar = timeToBar(iTime);\n\n    if (beat < 8.0) {\n        if (beat < 7.0) {\n            setNormalEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n            return;\n        } else {\n            float r = random(ceil(fract(beat) * 20.0) / 20.0);\n            if (r > fract(beat)) {\n                setNormalEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n                return;\n            } else {\n                setUnlightedEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n                return;\n            }\n        }\n    } else if (beat < 16.0) {\n        if (hit == 0 || hit == 2) {\n            color0 = vec3(0.0);\n            color1 = mix(LIGHT_ORANGE, LIGHT_BLUE, usin(pos.y * 0.05 + iTime * 10.0));\n            setLightBorderEdge(borderEdge0, borderEdge1);\n            lines = ivec3(0, 1, 0);\n            return;\n        } else { \n            setUnlightedEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n            return;\n        }\n    } else if (beat < 24.0) {\n        if (hit == 0 || hit == 1) {\n            color0 = vec3(0.0);\n            float end0 = WALL_SIZE.z - max(fract(bar) * 2.0 - 1.0, 0.0) * 2.0 * WALL_SIZE.z;\n            float end1 = WALL_SIZE.z - min(fract(bar) * 2.0, 1.0) * 2.0 * WALL_SIZE.z;\n            color1 = mix(LIGHT_ORANGE, LIGHT_BLUE, smoothstep(-WALL_SIZE.z, WALL_SIZE.z, pos.z));\n            color1 = mix(vec3(0.0), color1, (1.0 - step(end0, pos.z)) * step(end1, pos.z));\n            setLightBorderEdge(borderEdge0, borderEdge1);\n            lines = ivec3(0, 0, 1);\n            return;\n        } else { \n            setUnlightedEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n            return;\n        }\n    } else if (beat < 32.0) {\n        if (beat < 31.0) {\n            color0 = vec3(0.0);\n            color1 = mix(LIGHT_ORANGE, LIGHT_BLUE, usin(pos.y * 0.05 - iTime * 8.0));\n            setLightBorderEdge(borderEdge0, borderEdge1);\n            lines = ivec3(1, 1, 1);\n            return;\n        } else {\n            float r = random(ceil(fract(beat) * 20.0) / 20.0);\n            if (r < fract(beat)) {\n                setNormalEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n                return;\n            } else {\n                setUnlightedEnvironmentStatus(color0, color1, borderEdge0, borderEdge1, lines);\n                return;\n            }\n        }\n    }\n}\n\nvec3 environment(vec3 ro, vec3 rd) {\n    float t = 1e6;\n    int hit = 0;\n    for (int i = 0; i < 3; i++) {\n        if (rd[i] != 0.0) {\n            float tn = (-WALL_SIZE[i] - ro[i]) / rd[i];\n            if (tn > 0.0 && tn < t) {\n                t = tn;\n                hit = i;\n            }\n            float tp = (WALL_SIZE[i] - ro[i]) / rd[i];\n            if (tp > 0.0 && tp < t) {\n                t = tp;\n                hit = i;\n            }\n        }\n    }\n    if (t == 1e6) {\n        return vec3(0.0);\n    }\n    vec3 p = ro + t * rd;\n\n    vec3 color0, color1;\n    float borderEdge0, borderEdge1; // 0 <= borderEdge0 <= birderEdge1 <= 0.5\n    ivec3 lines;\n    setEnvironmentStatus(p, hit, color0, color1, borderEdge0, borderEdge1, lines);\n\n    float v = 0.0;\n    for (int i = 0; i < 3; i++) {\n        if (lines[i] == 1) {\n            v = max(v, smoothstep(borderEdge1, borderEdge0, 0.5 - abs(fract(p[i] / GRID_SPACING) - 0.5)));\n        }\n    }\n\n    return mix(color0, color1, v);\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat random(float x, inout float seed) {\n    seed += 0.1;\n    return random(x + seed);\n}\n\nfloat map(vec3 p) {\n    float d = 1e6;\n    float seed = 0.0;\n    for (float i = 1.0; i <=15.0; i += 1.0) {\n        vec3 c = vec3(20.0 * sin(iTime + 100.0 * random(i, seed)), 0.0, 0.0);\n        c.xy *= rotate(iTime * random(i, seed) + 100.0 * random(i, seed));\n        c.xz *= rotate(iTime * random(i, seed) + 100.0 * random(i, seed));\n        float r = mix(1.0, 10.0, smoothstep(0.0, 1.0, random(i, seed)));\n        d = smoothUnion(d, length(p - c) - r, 6.0);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    float d = 0.01;\n    return normalize(vec3(\n        map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n        map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n        map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n    ));\n}\n\nvec3 schlickFresnel(vec3 f90, float cosine) {\n    return f90 + (1.0 - f90) * pow(1.0 - cosine, 5.0);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    vec3 p = ro;\n    for (int i = 0; i < 64; i++) {\n        float d = map(p);\n        p += d * rd;\n        if (d < 0.01) {\n            vec3 n = calcNormal(p);\n            vec3 reflectDir = reflect(rd, n);\n            float dotNR = max(0.0, dot(n, reflectDir));\n            vec3 specColor = vec3(0.001);\n            vec3 fresnel = schlickFresnel(specColor, dotNR);\n            return fresnel * environment(p, reflectDir);\n        }\n    }\n    return environment(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(20.0, -10.0, 38.0);\n    vec3 ta = vec3(0.0);\n    vec3 z = normalize(ta - ro);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = normalize(x * st.x + y * st.y + z * 1.5);\n\n    vec3 c = raymarch(ro, rd);\n\n    fragColor = vec4(pow(c, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttS3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 248, 248, 280], [282, 300, 329, 329, 367], [369, 369, 391, 391, 442], [444, 444, 465, 465, 549], [551, 551, 573, 573, 649], [651, 651, 672, 672, 705], [707, 707, 837, 837, 978], [980, 980, 1113, 1113, 1237], [1239, 1239, 1310, 1310, 1358], [1360, 1360, 1503, 1503, 4011], [4013, 4013, 4049, 4049, 5002], [5004, 5004, 5052, 5052, 5159], [5161, 5161, 5202, 5202, 5250], [5252, 5252, 5271, 5271, 5733], [5735, 5735, 5760, 5760, 6011], [6013, 6013, 6058, 6058, 6115], [6117, 6117, 6150, 6150, 6621], [6623, 6623, 6678, 6678, 7118]], "test": "timeout"}
{"id": "ttS3W1", "name": "loophole", "author": "Dananddy", "description": "going through hole", "tags": ["loops"], "likes": 2, "viewed": 305, "published": "Public API", "date": "1559314546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat td = iTime*.5;\n    vec3 col = vec3(0);\n\t\n\tvec3 ro = vec3(1,0 , -1);\n    vec3 lookat = vec3(-6,0,0);\n    float zoom = mix(.68, 1., abs(sin(td))*2.);\n    \n    vec3 f = normalize(lookat-ro),\n    \tr= normalize(cross(vec3(0,1,0),f)),\n        u = cross (f,r),\n        c =  ro + f * zoom,\n        i = c+uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n    float dS, dO;\n    vec3 p;\n     \n    for (int i=0; i<100; i++){\n    \tp=ro + rd* dO;\n        dS =-( length(vec2(length(p.xz)-1.,p.y))-mix(.5,.7, abs(sin(td))*2.));\n        if (dS<0.001) break;\n        dO+=dS;\n    }\n    if (dS<0.001) {\n        float x = atan(p.x, p.z)+td*1.2;\n        float y = atan(length(p.xz)-1.,p.y);\n        float bands =sin(x*5.+y*100.);\n        float waves = sin(y*10.+ x*70.);\n        float b1 = smoothstep(.3,.04,bands);\n        float b2 = smoothstep(.02,.05,bands-.5);\n        float m = b2 * (1.-b1);\n        m = max(m, waves);\n        col+=1.-m;\n    }\n    col += 0.5 + 0.5*sin(td+uv.xyx+vec3(2,2,2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttS3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1133]], "test": "ok"}
{"id": "tts3WB", "name": "Squareable WallpaperGroup", "author": "ollj", "description": "I want all wallpaper groups in one shader\n12/17 done (all those, that (easily) make sense in charthesian coordinates) (180deg and 90deg symmetry)\n\nthe ones that only make sense in barycentric|hex are next. (120deg symmetry)\n", "tags": ["tiling", "tiles", "lattice", "skew", "wallpapergroup", "p1", "p2", "wallpapergoup", "cmm", "pmm", "p4g", "p4m", "pmg", "pg"], "likes": 0, "viewed": 39, "published": "Public", "date": "1557577640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//the skew barely makes sense for many cases.\n//#define skewIt\n//you might want to pause time at iTime==0\n\n//2d zoom\n#define ViewZoom 5.2\n\n/*\n2 lines of code for editing are named:\n- [[12 of 17 wallpaper group function names]]\n- [[change function name here              ]]\n\n\n\n--- Tags:\nWallpaperGoup,cmm,pmm,p1,p2,p4g,p4m,pmg,pg,tiling,lattice,skew,tiles\n\n12 of 17 included\n 5 of 17 missing\n, the ones that only make sense in barycentric|hex coordinates: \n, p3, p3m1, p31m, p6,p6m\n\nthis shader is a preview bacup, that is likely obsolete soon\n\nself        : https://www.shadertoy.com/view/tts3WB\nparent skew : https://www.shadertoy.com/view/lltcR7\nparent glide: https://www.shadertoy.com/view/XsfBDH\nrecipe      : https://twitter.com/ollj/status/112690634711778508\n\ngoal is to have the complete wallpaper group in one shader\nfirst implement each of the 17 cases, then have them share as many subroutines as possible.\nthen make them parametric and interpolateable\nrecipe:\nhttps://twitter.com/ollj/status/112690634711778508\nis still missing some ingredients:\n*/\n\n//do 3x3 taps for a shape with kerning (it repeats AND overlaps skewing AND rotating tile borders)\n#define doNeighborhood\n\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n//color of outlined shape (bound by tile borders)\n#define cOutlined vec3(0,0,0)\n\n//color of cursor\n#define cCursor vec3(u5(cos(iTime*2.)))\n\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 ad(v3 a){return dot(v3(1),a);}\nv0 ad(v2 a){return dot(v2(1),a);}\nv0 ad(v1 a){return a.x+a.y;}//aka suv()\nv0 ma(v1 a){return max(a.y,a.x);}\nv0 ma(v2 a){return max(a.z,ma(a.xy));}\nv0 ma(v3 a){return max(ma(a.zw),ma(a.xy));}\n#define mi(a)-ma(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c)((a)*(b)+(c))\n#define ab012(a,b)mad(vec3(0,1,2),b,a)\n#define c11(a,b)clamp(a/b,-1.,1.)*b\n\n#define pi acos(-1.)\n//float TAU=6.28318530718;\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define u2(a)((a)*2.-1.)\n#define u3(a)((a)*2.+1.)\n#define u4(a)((a)*.5-.5)\n#define u5(a)((a)*.5+.5)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\nvec2   skew(vec2 u){return u+ad(u)*ske;}\nvec2 unskew(vec2 u){return u-ad(u)*reSke;}\n\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for:0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;,for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\",range [-.159 ...159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green)blue;try;p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n//;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds,sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n//;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*iResolution.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing,whould actually be constant\n//;c=gradVis(c,u,v)//a graph plotter,not included here.\n ;return c;}\nvec3 rainbowN11(vec2 u){return rainbowN(u,vec2(1),vec3(1));}\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5//parametric j-shape m sets limb lengths.\n ;if(!(u.y-1.>0.||u.x+1.<0.))return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;c=.5*u.y*(b+c)-c//c=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(c);}\n\nfloat ff(vec2 u,vec2 m//parametric f-shape m sets limb lengths.\n){vec2 v=u\n ;v.x=abs(abs(v.x-.75)-1.)+1.//-.2\n ;//v.x/=2.\n ;//u.x=abs(u.x+2.)\n ;float a=length(v-m+vec2(0,4))\n ;return min(a,jj(-u,m))\n ;}\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\nvec4 greyBorderCoss(vec2 U,vec4 o){\n ;U=abs(U)\n ;return smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o;}\n\nfloat neighborhood(vec4 o,float t,vec2 u,mat2 r,vec2 m,vec2 U,vec2 K\n#ifndef doNeighborhood\n){return 0.;}           \n#else\n){float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++ //[kerning] 3x3 neighborhood\n ){vec2 a=u-m+vec2(i,j)\n  ;if(U.y<0.)a=mix(a,unskew(a),t)\n  ;a=r*a\n  ;d+=smoothstep(.01,-.01,ff(a*19.,K)-.3)\n  ;}};return d;;}\n#endif\n\nfloat smoothFf(vec2 U,vec2 K){\n ;return smoothstep(.1,-.1,abs(ff(U*19.,K)-.6)-.3);}\n\nvec4 cursor(vec2 U,vec2 M,vec2 K,vec4 o,vec3 c\n){U=(U-M)/iResolution.xy\n ;U.y*=iResolution.y/iResolution.x\n ;U*=3.*iResolution.x/vec2(512.) //very hacky     \n ;o.xyz=mix(o.xyz\n           ,c\n           ,smoothstep(.1,-.1\n                       ,abs(ff(U*19.,K)-.6)-.3))\n ;return o;}\n\n/*\n//I know this is sloppy, all good prototypes are designed to learn from experimental failures:\n//parent shader was an older semi mess, but full of useful subroutines\nvec4 parent(vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty,usually alternating complemenraty colors,avoids a mixing to grey.\n ;u     =u        -.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy\n ;vec2 U=u\n ;vec2 M=m;\n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t);}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;u=u-floor(u+.5)//floor,with offset\n ;m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){//additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  ;//if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  ;//if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n ;vec2 k=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))))//wiggly j-shape proportions tile dependent\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9 times,witzhin the O(n*n)loop below,not doing that\n ;o.xyz=rainbowN11((a+a.yx)*vec2(phi,.5))//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)//changes diagonal half to complementary color.\n ;//if(u.x>u.y)o.xyz=1.-o.xyz//grey line over diagonal instead of complemenraty color on other half.     \n ;float                                 e=neighborhood(o,t,u,r,m,U,K)\n ;o.xyz=mix(o.xyz,vec3(u5(cos(U*.1)),1),e)\n ;if(U.y<0.)u=mix(u,unskew(u),t)//if(lower half of screen) unskew()\n ;//u=r*u //optional rotate of hollow repeated shape\n ;o.xyz=mix(o.xyz\n           ,cOutlined\n           ,smoothstep(.1,-.1\n                       ,abs(ff((u-r*vec2(0,0))*19.,k)-.361)-.1))\n ;o=greyBorderCoss(U,o)\n ;o=cursor(U,M,K,o,cCursor)\n ;return o;}\n/**/\n\n//below are subroutines for WallpaperGroup\n\nvec2 md0(vec2 u//mirror diagonally\n){if(u.x<u.y)u=u.yx//*vec2(1,-1)\n ;return u;}\n\nvec2 md1(vec2 u//mirror diagonally\n){u.y=-u.y\n ;u=md0(u)\n ;u.y=-u.y\n ;return u;}\n\nvec2 mh(vec2 u//glideReflect horizontally\n){u.y=abs(u.y)\n ;return u;}\n\n\nvec2 gh(vec2 u//glideReflect horizontally\n){if(u.y<0.)u.x=-u.x\n ;u.y=abs(u.y)\n ;return u;}\n\nvec2 gd0(vec2 u//glideReflect diagonally\n){if(u.x<u.y)u.xy=-u.yx\n ;u=md0(u)\n ;return u;}\n\nvec2 gd1(vec2 u//glideReflect diagonally\n){u.y=-u.y\n ;u=gd0(u)\n ;u.y=-u.y  \n ;return u;}\n\nvec2 pmgs(vec2 u){if(u.x<.0)return vec2(u.x,abs(u.y))\n               ;return vec2(0,1)-abs(u);}//pmg is a special snowflake\n\n\n\n/*\nvec2 p4mss(vec2 u){\n    //;vec2 f=vec2(1)\n    //;if(sign(u.x)!=sign(u.y))f=vec2(-1,1)\n    ;if(u.x>0.){\n        if(u.y>0.){return u\n        ;}else{return u.yx*vec2(-1,1) \n        ;}\n    }else{\n      if(u.y>0.){return u.yx*vec2(-1,1).yx\n        ;}else{return -u \n          ;}}}*/\n\nvec2 p4S(vec2 u){\n       /* ;     if(!((u.x>0.||u.y<0.)&&(u.x<0.||u.y>0.)))*/\n            \n         if(sign(u.x)!=sign(u.y))           u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1)\n  \n  //  ;     if(u.x<0.&&u.y>0.)u=u.yx*vec2(-1,1) \n   // ;else if(u.x>0.&&u.y<0.)u=u.yx*vec2(-1,1) \n;return gh(u);}\n\nvec2 p4gs(vec2 u){return md1(p4S(u)*2.-.5);}\n\nvec2 pggs(vec2 u\n){//u=u.yx*vec2(1,-1)\n ;u=gh(u)\n ;vec2 d=vec2(u.x,-u.x)+u.y-1.;\n ;d.x=max(d.x,d.y)\n ;if(d.x>0.)return mix(vec2(1)-gd1(u),gd0(u)+vec2(-1,1),step(u.x,0.))\n ;return u;}\n\nvec2 pggsbackup(vec2 u){//this one was hard, this was my first sucess to getting pggs()\n    ;u=gh(u)\n    ;if(u.x+u.y-1.>0.)return (gd1(u)*vec2(-1,-1)+vec2(1,-1)*vec2(-1,-1))+vec2(2,0)\n    ;if(u.x-u.y+1.<0.)return gd0(u)+vec2(-1,1)\n    ;return u;}\n\nvec2 pmod2(vec2 u){return fract(u-.5)-.5;}//no floor returned\n\n\n//vec2 pm(vec2 u){return pmod2(u);}//just a wrapper for now\n\n\n\n//below are beta-wrappers of the abive\n//i have not yet decided on how to unify them \n//as scaling are a bit off between a few of them\n\n//[[12 of 17 wallpaper group function names]]\nvec2 cmm(vec2 u){return    md1(md0(pmod2(u)));}\nvec2 cm (vec2 u){return        md0(pmod2(u));}\nvec2 pm (vec2 u){return        mh (pmod2(u));}\nvec2 pmm(vec2 u){return     mh(mh (pmod2(u).yx).yx);}//swivel gallore.\nvec2 p1 (vec2 u){return           (pmod2(u));}\nvec2 p2 (vec2 u){return        gd0(pmod2(u));}\nvec2 p4 (vec2 u){return        p4S(pmod2(u));}\nvec2 p4g(vec2 u){return       p4gs(pmod2(u));}\nvec2 pmg(vec2 u){return       pmgs(pmod2(u/2.)*2.);}//pmg is a special snowflake\nvec2 pgg(vec2 u){return       pggs(pmod2(u   )*2.);}\nvec2 pg (vec2 u){return        gh (pmod2(u));}\nvec2 p4m(vec2 u){return mh(md1(md0(pmod2(u))));}\n\n\n\n//vec2 pgg(vec2 u){return pggsbackup(pmod2(u)*2.);}\n\n/*\n//learning mostly how to NOT intertpolate things\n//i guess mixing of polar coords makes moresense here.\nvoid misstuff(inout vec2 u,inout vec2 m\n){vec2 U=md0(u)\n ;vec2 M=md0(m)\n ;     u=pmg(u)\n ;     m=pmg(m)   \n ;float t=cos(iTime)*.5+.5\n ;u=mix(u,U,t)\n ;m=mix(m,M,t)\n ;}*/\n\nvoid mainImage(out vec4 o,vec2 u\n){o=vec4(1)\n ;vec2 m=fra(iMouse.xy)\n ;u=fra(u)\n ;//o=parent(o,u)\n ;vec2 K=(vec2(1,4)+u5(vec2(.5,2)*cs(iTime*8.                    )))//wiggly j-shape proportions\n\n ;float s=-cos(iTime)*.5+.5\n ;//s=0.\n //#if 1\n  #ifdef skewIt\n  ;u=mix(u,skew(u),s)\n  ;m=mix(m,skew(m),s)\n  #endif\n  ;u=pmg(u)//[[change function name here]]\n  ;m=pmg(m)//[[change function name here]]\n  #ifdef skewIt\n  ;u=mix(u,unskew(u),s)\n  ;m=mix(m,unskew(m),s) \n  #endif\n     /*\n  ;u=gd1(u)\n  ;m=gd1(m)  \n  ;u=md0(u)\n  ;m=md0(m)*/\n// #else\n//  ;misstuff(u,m)\n// #endif\n ;o.xyz=vec3(smoothFf((u-m)*1.5,K))\n ;if(u.x>iResolution.y-u.y)o.x=0.\n ;o.xz=u+.5\n ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1702, 1702, 1714, 1714, 1735], [1736, 1736, 1748, 1748, 1769], [1770, 1770, 1782, 1782, 1798], [1798, 1810, 1822, 1822, 1843], [1844, 1844, 1856, 1856, 1882], [1883, 1883, 1895, 1895, 1926], [2010, 2010, 2027, 2027, 2055], [2056, 2056, 2073, 2073, 2111], [2682, 2795, 2815, 2815, 2835], [2836, 2836, 2856, 2856, 2878], [2880, 3141, 3162, 3162, 3252], [3253, 3253, 3283, 3283, 3309], [3310, 3364, 3386, 3386, 3425], [3426, 3426, 3453, 3453, 3533], [3533, 3593, 3623, 3623, 3658], [3658, 3685, 3716, 3716, 3750], [3750, 3869, 3900, 3900, 3942], [3974, 4280, 4317, 4317, 4966], [4967, 4967, 4991, 4991, 5027], [5617, 5617, 5683, 5683, 5819], [5821, 5821, 5844, 5844, 5887], [5889, 5889, 5924, 5924, 6005], [6362, 6362, 6392, 6392, 6445], [6447, 6447, 6496, 6496, 6728], [8835, 8835, 8872, 8872, 8915], [8917, 8917, 8954, 8954, 8997], [8999, 8999, 9043, 9043, 9068], [9071, 9071, 9115, 9115, 9161], [9163, 9163, 9206, 9206, 9251], [9253, 9253, 9296, 9296, 9341], [9343, 9343, 9361, 9361, 9438], [9752, 9752, 9769, 9829, 10070], [10072, 10072, 10090, 10090, 10116], [10118, 10118, 10137, 10156, 10300], [10302, 10302, 10326, 10389, 10548], [10550, 10550, 10569, 10569, 10592], [10813, 10859, 10876, 10876, 10906], [10907, 10907, 10924, 10924, 10953], [10954, 10954, 10971, 10971, 11000], [11001, 11001, 11018, 11018, 11054], [11054, 11072, 11089, 11089, 11118], [11119, 11119, 11136, 11136, 11165], [11166, 11166, 11183, 11183, 11212], [11213, 11213, 11230, 11230, 11259], [11260, 11260, 11277, 11277, 11312], [11312, 11341, 11358, 11358, 11393], [11394, 11394, 11411, 11411, 11440], [11441, 11441, 11458, 11458, 11489]], "test": "ok"}
{"id": "tts3zl", "name": "RayMarcing Tree", "author": "ankd", "description": "I want to create tree from http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html \nbut my implementation (maybe particularly branch part) is wrong so there is many distortion...\n(2019/05/09) add \"tree\" function that include Intersect function.", "tags": ["raymarching", "tree"], "likes": 3, "viewed": 148, "published": "Public", "date": "1557360529", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Reference ... http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n//\nconst float PI = 3.1415926;\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate(in float r){\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float offset){\n    return dot(p, n) - offset;\n}\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 r){\n    vec2 q = vec2(length(p.xz)-r.x, p.y);\n    return length(q) - r.y;\n}\nfloat sdCylinder(in vec3 p, in float r){\n    return length(p.xz) - r;\n}\nfloat sdCone(in vec3 p, in vec2 n){\n    return dot(vec2(length(p.xz), p.y), n);\n}\n\nvec2 opU(in vec2 d1, in vec2 d2){\n    return d1.x<d2.x ? d1 : d2;\n}\nvec2 opS(in vec2 d1, in vec2 d2){\n    return vec2(\n            (d1.x<-d2.x ? -d2.x : d1.x),\n            d1.y\n        );\n}\nvec2 opI(in vec2 d1, in vec2 d2){\n    return vec2(\n        (d1.x<d2.x ? d2.x : d1.x),\n        d1.y\n    );\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p, c)-0.5*c;\n}\nvec2 opRepAngle(in vec2 p, in float n){\n    float angle = 2.0*PI / n;\n    float sector = floor(atan(p.x,p.y)/angle + 0.5);\n    p *= rotate(sector * angle);\n    return p;\n}\nvec3 opRepAngleS(in vec2 p, in float n){\n    float angle = 2.0*PI / n;\n    float sector = floor(atan(p.x,p.y)/angle + 0.5);\n    p *= rotate(sector * angle);\n    return vec3(p, mod(sector, n));\n}\n\nfloat star(in vec3 p, in float r){\n    p.xy = opRepAngle(p.xy, 5.0);\n    p = abs(p);\n    vec3 n = vec3(0.5, 0.25, 0.8);\n    return sdPlane(p, n, r);\n}\nfloat topper(in vec3 p){\n    float s = star(p, 0.3);\n    float c = max(sdCylinder(p, 0.2), sdPlane(abs(p-vec3(0., -0.5, 0.)), vec3(0.,1.,0.), 0.5));\n    // return c;\n    return min(s, c);\n}\nvec2 bauble(in vec3 p){\n    float t = sdTorus(p.yxz-vec3(0.7, 0., 0.), vec2(0.1, 0.02));\n    float c = max(sdCylinder(p, 0.08), sdPlane(abs(p-vec3(0., 0.55, 0.)), vec3(0., 1., 0.), 0.1));\n    float s = sdSphere(p, 0.5);\n    vec2 res = opU(\n            vec2(min(t,c), 0.8),\n            vec2(s, 1.0)\n        );\n    return res;\n}\n#define NEEDLE_LENGTH           0.5\n#define NEEDLE_SPACING          0.2\n#define NEEDLE_THICKNESS        0.02\n#define NEEDLES_RADIAL_NUM      17.0\n#define NEEDLE_BEND             0.99\n#define NEEDLE_TWIST            1.6\n#define NEEDLE_GAIN             1.5\nfloat needles(in vec3 p){\n    p.xy *= rotate(-length(p.xz)*NEEDLE_TWIST);    // 7. twist the needles\n    p.xy = opRepAngle(p.xy, NEEDLES_RADIAL_NUM);         // 6. replicate the needles radially\n    p.yz *= rotate(-NEEDLE_BEND);                  // 5. rotate the row of needles to align back with Z axis\n    p.y -= p.z*NEEDLE_GAIN;                             // 4. skew the row of needles down along Y\n    p.z = min(p.z, 0.0);                                // 3. remove the Z+ part\n    p.z = opRep(p, vec3(NEEDLE_SPACING)).z;                  // 2. clone the needle along Z\n    return max(\n            sdCone(p-vec3(0., NEEDLE_LENGTH, 0.), vec2(NEEDLE_LENGTH, NEEDLE_THICKNESS)),\n            -sdPlane(p, vec3(0.,1.,0.), 0.)\n        );    // 1. A single needle (cone)\n}\n#define STEM_THICKNESS          0.05\nvec2 branch(in vec3 p) {\n    vec2 res = vec2(needles(p), 1.0);\n    float s = sdCylinder(p.xzy, STEM_THICKNESS);\n    s = max(s, sdPlane(p, vec3(0.0, 0.0, 1.0), 0.0));\n    vec2 stem = vec2(s, 0.3);\n    res = opU(res, stem);\n    return res;\n}\n#define BRANCH_ANGLE            0.5\n#define BRANCH_ANGLE_FADE  0.11\n#define BRANCH_SPACING          1.3\n#define BRANCH_NUM_MAX          9.0\n#define BRANCH_NUM_FADE         2.2\n#define BRANCH_CURVATURE      0.08\n\n#define TREE_H                  4.0\n#define TREE_R                  1.0\n#define TRUNK_WIDTH             0.025\n#define TREE2_ANGLE             0.4\n#define TREE2_OFFSET            0.4\n#define TREE2_SCALE             0.9\n\nvec2 halfTree(vec3 p) {\n    float section = floor(p.y/BRANCH_SPACING);\n    float numBranches =  max(2.0, BRANCH_NUM_MAX - section*BRANCH_NUM_FADE);\n    // 6. Revolve/clone around Y:\n    p.xz = opRepAngle(p.xz, numBranches); \n    // 5. Offset to get the tree foundation:\n    p.z -= TREE_R; \n    // 4. Rotate to get the tree slope:\n    p.yz *= rotate(BRANCH_ANGLE); \n    // 3. Clone vertically:\n    p.y = opRep(p, vec3(BRANCH_SPACING)).y; \n    // Offset to compensate for the bend:\n    p.y -= BRANCH_SPACING*0.2; \n    // 2. Bend it to a parabolic shape:\n    p.yz *= rotate(-length(p.yz)*BRANCH_CURVATURE + BRANCH_ANGLE + section*BRANCH_ANGLE_FADE); \n    // 1. A branch:\n    vec2 b =  branch(p); \n    return b;\n}\nvec2 tree(vec3 p) {\n    //  the first bunch of branches\n    vec2 res = halfTree(p); \n    \n    // the second bunch of branches (to hide the regularity)\n    p.xz *= rotate(TREE2_ANGLE);\n    p.y -= BRANCH_SPACING*TREE2_OFFSET;\n    p /= TREE2_SCALE;\n    vec2 t2 = halfTree(p);\n    t2.x *= TREE2_SCALE;\n    res = opU(res, t2);\n\n    // trunk    \n    vec2 tr = vec2(sdCone(p.xyz, vec2(TREE_H*2.0, TRUNK_WIDTH)), 0.);\n    res = opU(res, tr);\n\n    res = opI(res, vec2(sdSphere(p - vec3(0.0, TREE_H*0.5 + 1.0, 0.0), TREE_H + 0.8), 0.0));    \n    return res;\n}\n\nvec2 map(in vec3 p){\n    vec2 res = tree(p-vec3(0., -3.0, 0.));\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD = 0.0;\n    float maxD = 20.0;\n    \n    float d = minD, m = -2.0;\n    for(int i=0;i<100;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<0.00001 || maxD<tmp.x) break;\n        d += tmp.x*0.7;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0)*0.0001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 ld = normalize(vec3(1.0));\n    \n    vec3 color = vec3(0.);\n    if(0.<=m)color = vec3(dot(ld, nor)) * hsv(m/5.0, 1.0, 1.0);\n\n    color *= exp(-0.01*d);\n\n    return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar-eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cp, cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu, cv, cw);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = 10.0*sin(iTime*0.4)*vec3(cos(iTime*0.2), 0.2, sin(iTime*0.2));\n    vec3 tar = vec3(0.);\n    vec3 rd = normalize(lookAt(ro, tar, 0.)*vec3(p, 1.0));\n    \n    vec3 color = render(ro, rd);\n    \n    color = pow(color, vec3(2.2));    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 152, 152, 331], [332, 332, 356, 356, 422], [424, 424, 477, 477, 510], [511, 511, 549, 549, 575], [576, 576, 612, 612, 684], [685, 685, 725, 725, 756], [757, 757, 792, 792, 838], [840, 840, 873, 873, 907], [908, 908, 941, 941, 1029], [1030, 1030, 1063, 1063, 1137], [1139, 1139, 1172, 1172, 1202], [1203, 1203, 1242, 1242, 1374], [1375, 1375, 1415, 1415, 1569], [1571, 1571, 1605, 1605, 1721], [1722, 1722, 1746, 1746, 1911], [1912, 1912, 1935, 1935, 2238], [2494, 2494, 2519, 2519, 3264], [3302, 3302, 3326, 3326, 3541], [3973, 3973, 3996, 3996, 4682], [4683, 4683, 4702, 4738, 5232], [5234, 5234, 5254, 5254, 5315], [5317, 5317, 5354, 5354, 5667], [5669, 5669, 5696, 5696, 5912], [5914, 5914, 5950, 5950, 6273], [6275, 6275, 6325, 6325, 6510], [6513, 6513, 6570, 6570, 6922]], "test": "timeout"}
{"id": "ttsGDf", "name": "mfdaslkfamslkfj", "author": "lennyjpg", "description": "asdfasdfasdf", "tags": ["asdfasdfasdf"], "likes": 5, "viewed": 300, "published": "Public API", "date": "1557958809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y-0.5;\n    float k = fract(length(uv+sin(fragCoord*90.6+iTime*.01)*0.5)*7.0);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 198]], "test": "ok"}
{"id": "ttsGDl", "name": "pattern05_", "author": "Del", "description": "pattern", "tags": ["sin", "pattern"], "likes": 4, "viewed": 246, "published": "Public API", "date": "1558121217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    pos*=0.5;\n    pos+=vec2(0.5);\n    \n\tfloat vv = pos.y*pos.y;\n\tvv*=sin(pos.x*3.14);\n\tfloat v = sin(sin(pos.x*15.0)*4.0+(vv) *50.0 + iTime * 2.0);\n    \n\tv+=0.65;\n\tfloat stime = 0.5+sin(iTime*4.0)*0.5;\n\tfragColor = vec4( v*1.3, 0.25+.3*v, 0.5, 1.0 ) * (1.0-stime*0.3);\n\n    if (iMouse.z>0.5)\n    \tfragColor=vec4(v);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 460]], "test": "ok"}
{"id": "ttsGRs", "name": "Raymarching Dice", "author": "WillKillU", "description": "raymarching practice creating a dice", "tags": ["raymarching", "sdf", "dice", "spheremarching"], "likes": 3, "viewed": 121, "published": "Public", "date": "1557368179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution\n\nfloat box(vec3 p, vec3 c)\n{\n    //p = mod(p, 2.5) - 2.5 * 0.5;\n    vec3 q = abs(p)-c;\n    return min(0.0, max(q.x, max(q.y, q.z))) + length(max(q,0.0));\n}\n\nfloat map(vec3 p)\n{\n\t//p.x = mod(p.x, 2.5) - 2.5 * 0.5;\n\tfloat cube = box(p, vec3(0.6));\n\t\n\tfloat one = length(p + vec3(0.,-0.6,.0)) - 0.1;\n\tfloat two = min(length(p + vec3(0.6,-0.3,0.3)) - 0.1, \n\t\t\tlength(p + vec3(0.6,0.3,-0.3)) - 0.1);\n\tfloat three = min(length(p + vec3(0.0, 0.0,0.6)) - 0.1,\n\t\t\t  min(length(p + vec3(0.3, 0.3,0.6)) - 0.1,\n\t\t\t      length(p + vec3(-0.3, -0.3,0.6)) - 0.1));\n\tfloat four = min(length(p + vec3(0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,0.3,-0.6)) - 0.1,\n\t\t\t     length(p + vec3(0.3,0.3,-0.6)) - 0.1)));\n\t\n\tfloat five = min(length(p + vec3(-0.6,-0.3,0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,-0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,0.3)) - 0.1,\n\t\t\t     length(p + vec3(-0.6,0.0,0.0)) - 0.1))));\n\t\n\tfloat finalNumbers = min(one, min(two, min(three, min(four, five))));\n\t\n\treturn max((length(p) - 1.0), max(-finalNumbers, cube));\n}\n\nvec3 minVec4(vec4 a, vec4 b) \n{\n    return (a.a < b.a) ? a.rgb : b.rgb;\n}\n\nvec3 mapColor(vec3 p)\n{\n    //p.x = mod(p.x, 2.5) - 2.5 * 0.5;\n\tfloat cube = box(p, vec3(0.6));\n\t\n\tfloat one = length(p + vec3(0.,-0.6,.0)) - 0.1;\n\tfloat two = min(length(p + vec3(0.6,-0.3,0.3)) - 0.1, \n\t\t\tlength(p + vec3(0.6,0.3,-0.3)) - 0.1);\n\tfloat three = min(length(p + vec3(0.0, 0.0,0.6)) - 0.1,\n\t\t\t  min(length(p + vec3(0.3, 0.3,0.6)) - 0.1,\n\t\t\t      length(p + vec3(-0.3, -0.3,0.6)) - 0.1));\n\tfloat four = min(length(p + vec3(0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,0.3,-0.6)) - 0.1,\n\t\t\t     length(p + vec3(0.3,0.3,-0.6)) - 0.1)));\n\tfloat five = min(length(p + vec3(-0.6,-0.3,0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,-0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,0.3)) - 0.1,\n\t\t\t     length(p + vec3(-0.6,0.0,0.0)) - 0.1))));\n\t\n\tfloat finalNumbers = min(one, min(two, min(three, min(four, five))));\n\t\n\treturn minVec4(\n\t\tvec4(vec3(0.0,0.0,0.0), finalNumbers),\n\t\tvec4(vec3(0.8,0.8,0.8), max((length(p) - 1.0), max(-finalNumbers, cube))));\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 eps = vec2(0.001, 0);\n\treturn normalize(vec3(\n\t\t             map(p + eps.xyy) - map(p - eps.xyy),\n\t\t\t     map(p + eps.yxy) - map(p - eps.yxy),\n\t\t\t     map(p + eps.yyx) - map(p - eps.yyx)\n\t\t\t     )\n\t\t\t);\n}\n\nfloat light(vec3 n, vec3 l)\n{\n\treturn dot(n,normalize(l)) * 0.5 + 0.5;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n\tfloat c = cos(b);\n\tfloat s = sin(b);\n\t\n\treturn vec2(\n\t\t\ta.x * c - a.y *s,\n\t\t\ta.x * s + a.y *c\n\t\t   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y/iResolution.x, 1.0);\n\t\n\tvec3 ro = vec3(0.0, 4.0, -8.0);\n    //ro = vec3(0.0,0.0,-5.0);\n\tvec3 p = ro;\n\tvec3 rd = normalize(vec3(uv, 2.0) + vec3(0.0,-1.0,0.0));\n    //rd = normalize(vec3(uv,2.0));\n\t\n\tro.xz = rotate(ro.xz,iTime * 0.1);\n\tp.xz = rotate(p.xz, iTime * 0.1);\n\trd.xz = rotate(rd.xz, iTime * 0.1);\n\t\n\tfloat hit = 0.0;\n\t\n\tfor(float i = 0.; i < 50.0; ++i)\n\t{\n\t\tfloat df = map(p);\n\t\t\n\t\tif(df < 0.001)\n\t\t{\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tp += df * rd;\n\t}\n\tvec3 n = normal(p);\n\tvec3 l = vec3(1.0,2.0,1.0);\n\tl.xz = rotate(l.xz, iTime);\n\t\n\tvec3 finalColor = mix(vec3(0.0,0.0,0.0), mapColor(p), vec3(light(n,l)));\n\t\n\tfloat fresnel = pow(1.-dot(n,-rd), 2.0);\n\t\n\tvec3 fresnelColor = vec3(1.0,1.0,1.0);\n\t\n\tfinalColor = mix(finalColor, fresnelColor, fresnel);\n    \n\t\n\tfragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 78, 113, 205], [207, 207, 226, 262, 1185], [1187, 1187, 1218, 1218, 1260], [1262, 1262, 1285, 1324, 2323], [2325, 2325, 2346, 2346, 2557], [2559, 2559, 2588, 2588, 2631], [2633, 2633, 2663, 2663, 2768], [2770, 2770, 2827, 2827, 3742]], "test": "ok"}
{"id": "ttSGWh", "name": "Conic Sections", "author": "wyatt", "description": "There's definitely a connection between the intersection of a plane and a cone and the solution space of linear differential equations. Why?  ( For example, any trajectory of a light object in a massive object's gravity field )", "tags": ["geometry"], "likes": 5, "viewed": 539, "published": "Public API", "date": "1559287825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\nmat2 r (float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\nvec4 ro (vec2 U) {\n    vec3 v = vec3(2.*U,1);\n    v.yz *= r (iTime);\n    v.zx *= r (iTime);\n    return vec4(v,(length(v.xy)-abs(v.z)));\n}\nvoid mainImage( out vec4 Q,vec2 U )\n{\n \tU = 2.*(U-0.5*R)/R.y;\n    \n    vec4 \n        v = ro(U),\n    \tn = ro(U+vec2(0,1)/R),\n    \te = ro(U+vec2(1,0)/R),\n    \ts = ro(U-vec2(0,1)/R),\n    \tw = ro(U-vec2(1,0)/R);\n    vec3 g = normalize(vec3(e.w-w.w,n.w-s.w,.01));\n    float h = dot(g,ro(vec2(1,0)).xyz);\n    Q = .2*vec4(0.5+0.5*h*h*h)*smoothstep(0.,-0.1,v.w);\n    Q.xz += smoothstep(.1,.05,abs(v.w));\n    Q += smoothstep(.05,0.025,abs(v.x));\n    Q += smoothstep(.05,0.025,abs(v.y));\n    Q += smoothstep(.05,0.025,abs(v.z));\n    Q.xy += smoothstep(.25,.2,length(v.xy-v.z*vec2(cos(3.*iTime),sin(3.*iTime))));\n    Q.yz += smoothstep(.25,.2,length(v.xy-v.z*vec2(-cos(3.*iTime),-sin(3.*iTime))));\n\tQ *= exp(-length(U));\n    \n    \n    \n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 43, 43, 103], [104, 104, 122, 122, 241], [242, 242, 279, 279, 968]], "test": "ok"}
{"id": "ttsGWN", "name": "Regular Deltahedra Family", "author": "anneka", "description": "sdf, raymarching, geometry, regular deltahedra (and sphere)\npenner easing function\nAnti-aliasing and some SDF functions adapted from\nVaporwave Polyhedra by yx\nhttps://www.shadertoy.com/view/3d2XD1", "tags": ["sdf", "geometry", "deltahedra"], "likes": 2, "viewed": 376, "published": "Public API", "date": "1557693314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tAnti-aliasing and some SDF functions adapted from\n\tVaporwave Polyhedra by yx\n\thttps://www.shadertoy.com/view/3d2XD1\n*/\n\n#define pi (acos(-1.))\n#define tau 6.28318530717958647692\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define NUM_SHAPES 4.\n\nconst float DURATION = .25;\nconst float REFLECTION_STRENGTH = 1.;\nconst float FRESNEL_STRENGTH = .5; // 0. - 1.\n\nconst float phi = (1.+sqrt(5.))*.5;\n\nvec3 BLUE = vec3(0., 0., 1.);\nvec3 WHITE = vec3(1.);\nvec3 RED = vec3(1., 0. ,0.);\nvec3 BLACK = vec3(0.);\nvec3 GREEN = vec3(0., 1., 0.);\n\nvec3 SKY_COLOR;\nvec3 SHAPE_COLOR;\nvec3 CAGE_COLOR;\n\nint mat;\nint matB;\nvec3[3] colorScheme1;\nvec3[3] colorScheme2;\nvec3[3] colorScheme3;\nvec3[3] colorScheme4;\n\n// Order is always [sky, shape, cage]\nvoid initColorSchemes() {\n    colorScheme1 = vec3[](BLUE, RED, WHITE);\n    colorScheme2 = vec3[](RED, WHITE, BLUE);\n    colorScheme3 = vec3[](GREEN, BLACK, WHITE);\n    colorScheme4 = vec3[](BLACK, WHITE, GREEN);\n}\n\nmat2 matRotation(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec3 lerpVecs(vec3 a, vec3 b, float amount) {\n  float x = mix(a.x, b.x, amount);\n  float y = mix(a.y, b.y, amount);\n  float z = mix(a.z, b.z, amount);\n  return vec3(x,y,z);\n}\n\nfloat easeInOutQuad (float time, float start, float end, float duration) {\n    if ((time/=duration/2.) < 1.) return end/2.*time*time + start;\n    return -end/2. * ((--time)*(time-2.) - 1.) + start;\n}\n\nfloat sdTetrahedron(vec3 p, float r) {\n    float x = abs(p.x+p.y)-p.z;\n    float y = abs(p.x-p.y)+p.z;\n    float m = max(x,y);\n    return (m-r)/sqrt(3.);\n}\n\nfloat sdOctahedron(vec3 p, float r) {\n    p = abs(p);\n    float m = p.x+p.y+p.z-r;\n    return m*0.57735027;\n}\n    \nfloat sdIcosahedron(vec3 pos, float r) { \n    vec3 p = pos;\n    p = abs(p/r);\n    \n    const float q = (sqrt(5.)+3.)/2.;\n    const vec3 n1 = normalize(vec3(q,1,0));\n    const vec3 n2 = vec3(sqrt(3.)/3.);\n    \n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2.xyz)-n1.x;\n    return max(max(max(a,b),c)-n1.x,d)*r;\n}\n\nfloat sdDodecahedron(vec3 p, float r) {\n    p = abs(p);\n    p += phi*p.zxy;\n    return (max(max(p.x,p.y),p.z)-r*phi) / sqrt(phi*phi+1.);\n}\n\n\nfloat sdRhombicTriacontahedron(vec3 p, float r)\n{\n    const float l = phi*2.;\n    p = abs(p);\n    float a = max(max(p.x,p.y),p.z);\n    p += (p+p.yzx)*phi+p.zxy;\n    return max(a, max(p.x,max(p.y,p.z))/l)-r;   \n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat outerCage(vec3 p, float size) {\n    return max(\n        min(\n\t\t\tsdDodecahedron(p.zyx,1.03*size),\n\t\t\tsdIcosahedron(p,1.025*size)\n        ),\n\t\t-sdRhombicTriacontahedron(p,1.019*size)\n    );\n}\n\nfloat tetraCage(vec3 p, float size, float weight) {\n    float a = max(\n        -sdTetrahedron(p + vec3(0.,-weight,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float b = max(\n        -sdTetrahedron(p + vec3(0.,weight,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float c = max(\n         -sdTetrahedron(p + vec3(weight,0.,0.), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float d = max(\n         -sdTetrahedron(p + vec3(0.,0.,weight), size),\n        sdTetrahedron(p, size)\n    );\n    \n    float n = max(b, a);\n    float o = max(c, d);\n        \n    return min(\n        max(\n            -sdTetrahedron(p + vec3(-weight, 0., 0.), size),\n            min(n,o)\n        ),\n        n\n    );\n}\n\nfloat octaCage(vec3 p, float size, float weight) {\n    return max(\n        max(\n            sdOctahedron(p, size+weight),\n            -sdTetrahedron(p, size)\n        ),\n        -sdTetrahedron(p*vec3(-1.), size)\n    );\n}\n\nfloat icoCage(vec3 p, float size, float weight) {\n    return max(\n\t\tsdIcosahedron(p,size*(1.+weight)),\n        -sdRhombicTriacontahedron(p,size)\n    );\n}\n\nfloat cage1(vec3 p, vec2 t) {\n    return min(\n        sdTorus(p, t*vec2(1., 2.)),\n        sdTorus(p.yxz, t*vec2(1., 2.))\n    );\n}\n\nfloat cage2(vec3 p, vec2 t) {\n    vec3 tetraP = p;\n    tetraP.xy *= matRotation(pi * 0.);\n    tetraP.xz *= matRotation(pi * -.25);\n\treturn tetraCage(tetraP, t.x, t.y);\n}\n\nfloat displacedCage2(vec3 p, float size, float width, float width2, float noise) {\n    float displacement = (sin(10.*noise*p.x+iTime)*sin(10.*noise*p.y+iTime)*sin(10.*noise*p.z+iTime)*.02);\n    return max(\n        cage2(p, vec2(size, width))+displacement,\n        cage2(p, vec2(size*1.001, width2))\n    );\n}\n\nfloat cage3(vec3 p, float size, float weight) {\n    return octaCage(p, size, weight);\n}\n\nfloat cage4(vec3 p, float size, float weight) {\n    return icoCage(p, size, weight);\n}\n\nvec2 makeShapes(vec3 pos, float multiplier) {\n    vec3 p = pos;\n    \n    vec2 pRot = vec2(iTime*.1,0)+1.0*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n        p.yz = cos(pRot.y)*p.yz + sin(pRot.y)*p.zy*vec2(1,-1);\n        p.xz = cos(pRot.x)*p.xz + sin(pRot.x)*p.zx*vec2(1,-1);\n    \n    float baseSize = .7 * multiplier;\n    float maxCageSize = baseSize * 2.;\n    float baseCageSize = baseSize * 1.01;\n    \n    float finalShape;\n    float finalCage;\n    \n    float sphere = (length(p)-baseSize);\n    float shape1 = sphere;\n    \n    vec3 tetraP = p;\n    tetraP.xy *= matRotation(pi * 0.);\n    tetraP.xz *= matRotation(pi * -.25);\n \tfloat shape2 = sdTetrahedron(tetraP, baseSize);\n    \n    float shape3 = sdOctahedron(p, baseSize*1.5);\n    \n    float shape4 = sdIcosahedron(p, baseSize);\n    \n    float timeBlock = mod(iTime*.5, NUM_SHAPES);\n    \n\n    float CAGE_DURATION = DURATION / 2.;\n    \n    float easedTime;\n    float cageSize;\n    float cageWidth;\n    \n    finalCage = cage1(p, vec2(5., -.1));\n    float noise = texture(iChannel0, (pos.xz*.5)+iTime*.1, 0.).r;\n    float minWidth = .000001*noise;\n \tfloat maxWidth1 = .025*noise;\n    \n    \n    if (timeBlock <= DURATION) {\n        easedTime = easeInOutQuad(timeBlock, 0., 1., DURATION);\n        SKY_COLOR = colorScheme1[0];\n        SHAPE_COLOR = mix(colorScheme4[1], colorScheme1[1], easedTime);\n        CAGE_COLOR =  colorScheme1[2];\n        finalShape = mix(shape1, shape2, easedTime);\n        \n         if (timeBlock >= CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-CAGE_DURATION, 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                ease\n            );\n            cageWidth = mix(\n                0.01,\n                1.,\n                ease\n            );\n            finalCage = displacedCage2(p, cageSize, .04, cageWidth, noise);\n        }\n\n        \n    } else if (timeBlock <= 1.) {\n        finalShape = shape2;\n        finalCage = displacedCage2(p, baseCageSize, .04, 1., noise);\n        SKY_COLOR = colorScheme1[0];\n        SHAPE_COLOR = colorScheme1[1];\n        CAGE_COLOR = colorScheme1[2];\n        \n        if (timeBlock >= 1.-CAGE_DURATION) {\n            cageWidth = mix(\n                maxCageSize,\n                0.01,\n                easeInOutQuad(timeBlock-(1.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = displacedCage2(p, baseCageSize, .04, cageWidth, noise);\n        }\n        \n    } else if (timeBlock <= 1.+DURATION) {\n        easedTime = easeInOutQuad(timeBlock - 1., 0., 1., DURATION);\n        finalShape = mix(shape2, shape3, easedTime); \n        SKY_COLOR = colorScheme2[0];\n        SHAPE_COLOR = mix(colorScheme1[1], colorScheme2[1], easedTime);\n        CAGE_COLOR =  colorScheme2[2];\n        \n        if (timeBlock >= 1.+CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-(1.+CAGE_DURATION), 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize*1.5,\n                baseCageSize*1.5,\n                ease\n            );\n            cageWidth = mix(\n                minWidth,\n                .075*noise,\n                ease\n            );\n            finalCage = cage3(p, cageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 2.) {\n        finalShape = shape3;\n        finalCage = octaCage(p, baseCageSize*1.5, .075*noise);\n        SKY_COLOR = colorScheme2[0];\n        SHAPE_COLOR = colorScheme2[1];\n        CAGE_COLOR = colorScheme2[2];\n        \n        \n        if (timeBlock >= 2.-CAGE_DURATION) {\n            cageWidth = mix(\n                .075*noise,\n                minWidth,\n                easeInOutQuad(timeBlock-(2.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage3(p, baseCageSize*1.5, cageWidth);\n        }\n    } else if (timeBlock <= 2.+DURATION) {\n        easedTime = easeInOutQuad(timeBlock - 2., 0., 1., DURATION);\n        finalShape = mix(shape3, shape4, easedTime);\n        SKY_COLOR = colorScheme3[0];\n        SHAPE_COLOR = mix(colorScheme2[1], colorScheme3[1], easedTime);\n        CAGE_COLOR =  colorScheme3[2];\n        \n        \n        if (timeBlock >= 2.+CAGE_DURATION) {\n            float ease = easeInOutQuad(timeBlock-(2.+CAGE_DURATION), 0., 1., CAGE_DURATION);\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                ease\n            );\n            cageWidth = mix(\n                minWidth,\n                .01*noise,\n                ease\n            );\n            finalCage = cage4(p, cageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 3.) {\n        finalShape = shape4;\n        finalCage = cage4(p, baseCageSize, .01*noise);\n        SKY_COLOR = colorScheme3[0];\n        SHAPE_COLOR = colorScheme3[1];\n        CAGE_COLOR = colorScheme3[2];\n        \n        if (timeBlock >= 3.-CAGE_DURATION) {\n            cageWidth = mix(\n                .01*noise,\n                minWidth,\n                easeInOutQuad(timeBlock-(3.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage4(p, baseCageSize, cageWidth);\n        }\n        \n    } else if (timeBlock <= 3.+DURATION) { \n        easedTime = easeInOutQuad(timeBlock - 3., 0., 1., DURATION);\n        finalShape = mix(shape4, shape1, easedTime);\n        SKY_COLOR = colorScheme4[0];\n        SHAPE_COLOR = mix(colorScheme3[1], colorScheme4[1], easedTime);\n        CAGE_COLOR =  colorScheme4[2];\n        \n        if (timeBlock >= 3.+CAGE_DURATION) {\n            cageSize = mix(\n                maxCageSize,\n                baseCageSize,\n                easeInOutQuad(timeBlock-(3.+CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            cageWidth = mix(\n                minWidth,\n                maxWidth1,\n                easeInOutQuad(timeBlock-(3.+CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage1(p, vec2(cageSize, cageWidth));\n        }\n        \n    } else if (timeBlock <= 4.) {\n        finalShape = shape1;\n        finalCage = cage1(p, vec2(baseCageSize, maxWidth1));\n        SKY_COLOR = colorScheme4[0];\n        SHAPE_COLOR = colorScheme4[1];\n        CAGE_COLOR = colorScheme4[2];\n        \n        if (timeBlock >= 4.-CAGE_DURATION) {\n            cageWidth = mix(\n                maxWidth1,\n                minWidth,\n                easeInOutQuad(timeBlock-(4.-CAGE_DURATION), 0., 1., CAGE_DURATION)\n            );\n            finalCage = cage1(p, vec2(baseCageSize, cageWidth));\n        }\n\n    }\n    \n    return vec2(finalShape, finalCage);\n}\n\nfloat scene(vec3 p) {      \n    vec3 cP = p;\n    \n    vec2 pRot = vec2(0,iTime*.2);\n    cP.yz = cos(pRot.y)*p.yz + sin(pRot.y)*p.zy*vec2(1,-1);\n    \n    float outerCage = outerCage(cP, 10.);\n    \n    vec2 shapes = makeShapes(p, 1.);\n    float shape = shapes.x;\n    \n    float cage = shapes.y;\n    \n    float scene = min(shape, cage);\n    scene = min(scene, outerCage);\n    scene = min(scene, shape*1.5); // Glossy warp\n    \n    float cageDistance = abs(scene - cage);\n    float outerCageDistance = abs(scene - outerCage);\n                        \n    if (cageDistance <= .001) {\n        mat = 1;\n    } else if (outerCageDistance <= .001) {\n        mat = 2;\n    } else {\n        mat = 0;\n    }\n\n    return scene;\n}\n\n\nvec3 trace(vec3 cam, vec3 dir) {    \n    float hasBounced = 0.;\n    float fresnel = 0.;\n    \n    vec3 accum = vec3(1.);\n    for(int bounce=0;bounce<2;++bounce) {\n        float t;\n        float k;\n        for(int i=0;i<100;++i)\n        {\n            k = scene(cam+dir*t);\n            t += k;\n            if (k < .001 || k > 10.)\n                break;\n        }\n\n        vec3 h = cam+dir*t;\n        vec2 o = vec2(.001, 0);\n        vec3 n = normalize(vec3(\n            scene(h+o.xyy)-scene(h-o.xyy),\n            scene(h+o.yxy)-scene(h-o.yxy),\n            scene(h+o.yyx)-scene(h-o.yyx)\n        ));\n        \n        vec3 weightedReflection = lerpVecs(vec3(1.), accum, REFLECTION_STRENGTH);\n      \n        vec3 shapeSurfaceColor = mix(SKY_COLOR, SHAPE_COLOR*weightedReflection, hasBounced);\n        \n        if (k > 10.) {\n            return SKY_COLOR + shapeSurfaceColor;    \n        } \n        \n        else if (mat == 1) {\n            return CAGE_COLOR;\n        }\n        else if (mat == 2) {\n            return mix(SKY_COLOR, SHAPE_COLOR, hasBounced);\n        }\n        \n        else {\n            fresnel = min(.7,pow(max(0.,1.-dot(-dir,n)),5.))/(1. - FRESNEL_STRENGTH);\n            fresnel=mix(.04,1.,fresnel);\n            cam=h+n*.01;\n            dir=reflect(dir,n);\n            accum *= fresnel;\n            hasBounced = 1.;\n        }\n    }\n\n   \treturn SKY_COLOR;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    out_color=vec4(0);\n    initColorSchemes();\n    \n\t//Anti-aliasing\n    for(int i=0;i<4;++i){\n        vec2 offset=vec2(i/2,i%2)*.5/iResolution.y;\n    \n        vec3 cam = vec3((uv+offset)*3.,-5.);\n        vec3 dir = vec3(0,0,1);\n\t\t\n        out_color.rgb += trace(cam,dir);\n    }\n    out_color *= .25;\n    out_color *= 2.; // exposure\n\tout_color.rgb = pow(out_color.rgb,vec3(.65)); // gamma\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[941, 941, 972, 972, 1046], [1048, 1048, 1093, 1093, 1222], [1224, 1224, 1298, 1298, 1423], [1425, 1425, 1463, 1463, 1580], [1582, 1582, 1619, 1619, 1691], [1697, 1697, 1737, 1737, 2074], [2076, 2076, 2115, 2115, 2214], [2217, 2217, 2266, 2266, 2428], [2430, 2430, 2461, 2461, 2533], [2535, 2535, 2572, 2572, 2730], [2732, 2732, 2783, 2783, 3450], [3452, 3452, 3502, 3502, 3671], [3673, 3673, 3722, 3722, 3826], [3828, 3828, 3857, 3857, 3957], [3959, 3959, 3988, 3988, 4128], [4130, 4130, 4212, 4212, 4437], [4439, 4439, 4486, 4486, 4526], [4528, 4528, 4575, 4575, 4614], [4616, 4616, 4661, 4661, 11187], [11189, 11189, 11210, 11210, 11902], [11905, 11905, 11937, 11937, 13273], [13275, 13275, 13327, 13327, 13811]], "test": "error"}
{"id": "ttsGzX", "name": "Something mechanically alive", "author": "avin", "description": "random experiment", "tags": ["circles", "rotation", "liquid"], "likes": 17, "viewed": 530, "published": "Public API", "date": "1557173207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Play with F values to get something other\n#define F1 .115\n#define F2 .75\n#define F3 1.5\n\n#define PI 3.1415926\n#define PI2 6.2831852\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    \n    float m = 0.;\n    float stp = PI/5.;\n    float odd = -1.;\n    for(float n=1.; n<2.5; n+=0.5){        \n        odd *= -1.;\n        float t = iTime * odd * .3;\n        for(float i=0.0001; i<PI2; i+=stp){\n            \n            vec2 uvi = uv*n + vec2(cos(i + n*stp*.5 + t)*.4, sin(i + n*stp*.5 + t)*.4);\n            float l = length(uvi);\n            m += smoothstep(F1 * n, .0, l)*F3;        \n        }    \n    }\n    \n    m = step(F2, fract(m*F3));\n    \n    vec3 col = vec3(1.) * m;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 193, 193, 791]], "test": "ok"}
{"id": "ttX3D2", "name": "Asensio - Ray", "author": "Asensio12", "description": "Procedural generated ray.", "tags": ["ray", "electricity"], "likes": 5, "viewed": 246, "published": "Public", "date": "1557693235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nCos(x)\t\t(cos(x)+1.0)*0.5\n//#define bell(x)\t\t(1.0/((x*x+1.0)*(x*x+1.0)))\n#define bell(x)\t\t(1.0/((1.0+abs(x))*(1.0+abs(x))))\n#define rayGen(x) \t((abs((fract(x)-0.5)*2.0)-0.5)*2.0)\n\n\n#define ITERATIONS 6\n\n//#define USE_BLUE\n#define USE_RED\n//#define USE_GREEN\n\nfloat rand(in int x) {\n    return fract(sin(0.123456 + 9.87654*float(x))*10000.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Ray\n    float speed     = 1.5;\n    float amplitude = 0.10;\n    float freq      = 1.0;\n    float parity    = 0.0;\n    float dir       = 1.0;\n    \n    float halo = 0.7 * amplitude;\n    \n    float ray = 0.0;\n    \n    // Generate ray that evolve in X and Time with alternative directions (X+, X-)\n    for (int i = 0; i < ITERATIONS; i++) {\n        ray += amplitude * rayGen(rand(i) + uv.x * (freq + parity) + dir*speed*iTime);\n        \n        amplitude *=  0.5;\n        freq\t  *=  2.0;\n        parity     =  0.5 - parity;\n        dir       *= -1.0;\n    }\n    \n    float intensity = bell(abs(uv.y - ray)/halo);\n    \n    vec4 color = vec4(0.0,0.0,0.0, 1.0);\n    \n    #ifdef USE_RED\n    \tcolor.x = intensity;\n    #endif\n    #ifdef USE_GREEN\n    \tcolor.y = intensity;\n    #endif\n    #ifdef USE_BLUE\n    \tcolor.z = intensity;\n    #endif\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttX3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 289, 289, 351], [352, 352, 409, 459, 1435]], "test": "ok"}
{"id": "ttX3Dl", "name": "marble pattern", "author": "ankd", "description": "marble pattern", "tags": ["marble"], "likes": 4, "viewed": 150, "published": "Public", "date": "1558017366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(in vec2 p, in float r){\n\tfloat c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c)*p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p  = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    for(int i=0;i<5;i++){\n        p = rotate(p, iTime*0.2+sin(length(p)));\n\t\tp.x += p.y*sin(p.x*1.97+iTime*0.45 + sin(p.y*1.25+iTime*0.97));\n\t\tp.y += p.x*sin(p.y*1.36+iTime*0.45 + sin(p.y*1.82+iTime*0.97));\n    }\n    \n    vec3 col1 = vec3(0.2, 0.5, 0.9);\n    vec3 col2 = vec3(0.9, 0.95, 1.0);\n    vec3 col = clamp(mix(col1, col2, min(2.0, (0.5*length(p)))), 0., 1.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttX3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 96], [98, 98, 155, 155, 643]], "test": "ok"}
{"id": "ttX3zS", "name": "circle jam", "author": "benhardy", "description": "anti-aliasing experiment. was very adamant about breaking things up into separate functions for organization and it seems to have helped.", "tags": ["circles", "antialiasing"], "likes": 10, "viewed": 395, "published": "Public API", "date": "1556666081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat holegrid(vec2 pos, float ang, float zoom, vec2 delta) {\n    \n    vec2 tr1 = vec2(cos(ang), -sin(ang));\n    vec2 tr2 = vec2(sin(ang), cos(ang));\n    pos *= zoom;\n    pos += delta;\n    pos = vec2(\n        pos.x * tr1.x + pos.y * tr1.y,\n        pos.x * tr2.x + pos.y * tr2.y\n    );\n    //pos.y *= (1.0 + pos.y * pos.y * 0.03);\n    float dt = max(0.0, fract(iTime) * 2.0 - 1.0);\n    int row = int(floor(pos.y + 0.5));\n    int isRowZero = 1- min(row*row, 1);\n    float dt2 = max(0.0, fract(iTime + 0.5) * 2.0 - 1.0);\n    int col = int(floor(pos.x + 0.5));\n    int isColZero = 1- min(col*col, 1);\n    pos.x += float(isRowZero) * dt;\n    pos.y += float(isColZero) * dt2;\n    // Time varying pixel color\n    pos = mod(pos + 0.5, 1.0) -0.5;\n    float d = length(pos);\n    return 1.0-floor(clamp(d* 6.0 - 1.9, 0.0, 1.0));\n}\nvec3 calc(vec2 pos) {\n    float completion = 6.283185307179586 * iTime / 15.0;\n    float ang = completion;\n    float zoom = 3.0;\n    vec2 delta = vec2(cos(completion), sin(completion));\n    float d = holegrid(pos, ang, zoom, delta);\n    vec3 col1 = vec3(d, d, d);\n    \n    float ang2 = completion / 4.0;\n    float zoom2 = 12.0 + sin(completion);\n    vec2 delta2 = vec2(0.0, 0.0);\n    float d2 = holegrid(pos, ang2, zoom2, delta2);\n    vec3 col2 = vec3(1.0, d2, d2);\n    return min(col1, col2);\n}\nvec2 pixelToLocal(vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.y = uv.y * iResolution.y / iResolution.x;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0,0,0);\n    for (int dy = 0; dy < 4; dy++) {\n        \n\t    for (int dx = 0; dx < 4; dx++) {\n        \tvec2 delta = vec2(float(dx)/4.0, float(dy)/4.0);\n\t\t    vec2 uv = pixelToLocal(fragCoord+delta);\n                \n\t\t\tcol += calc(uv);\n        }\n    }\n    fragColor = vec4(col / 16.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttX3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 62, 62, 820], [821, 821, 842, 842, 1316], [1317, 1317, 1352, 1402, 1514], [1516, 1516, 1573, 1573, 1884]], "test": "ok"}
{"id": "ttXGWf", "name": "Interference Pattern", "author": "tpfto", "description": "Simulation of an interference pattern", "tags": ["2d", "simulation", "interference", "physics"], "likes": 5, "viewed": 353, "published": "Public API", "date": "1557884397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// simulated interference patterns\n\n//some constants\n\n#define PI 3.14159265359\n\n// XY range of the display.\n\n#define DISP_SCALE 8.0\n\n// custom colormap\n\nvec3 marine( float t )\n{\n\t return vec3(max(3.0 * t + 3.0, 19.0 * t - 5.0)/18.0, max(10.0 * t, 18.0 * t - 4.0)/15.0, min(3.0 * t + 1.0, t + 2.0)/3.0);\n}\n\n// function for simulated interference pattern\n\nfloat interf(vec2 p)\n{\n      float t = 4.0 * iTime; // phase\n      vec2 p1 = vec2(-4.0, 0.0), p2 = vec2(4.0, 0.0); // sources\n    \n      if (iMouse.xy != vec2(0.0))\n      {\n          p2 = DISP_SCALE * ( iMouse.xy - 0.5 * iResolution.xy) / iResolution.y; // move one source\n      }\n\n      return cos(2.0 * PI * distance(p, p1) - t) + cos(2.0 * PI * distance(p, p2) - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= DISP_SCALE;\n        \n        float z = interf(uv);\n        fragColor.rgb = marine(0.25 * (z + 2.0));\n    \n        // gradient using forward differences\n        float h = 0.5 * DISP_SCALE/iResolution.y;\n        vec2 grad = z - vec2(interf(uv + vec2(h, 0.0)), interf(uv + vec2(0.0, h)));\n\n        // lighting angles for shading\n        float th = 0.75 * PI, ph = 0.25 * PI;\n        \n        // shading factor\n        fragColor.rgb *= 1.0 - 0.25 * (1.0 + cos(ph) * dot(vec2(cos(th), sin(th)), grad)/(pow(h, 1.4) + length(grad)));\n\n        fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGWf.jpg", "access": "shaders20k", "license": "mit", "functions": [[1224, 1224, 1248, 1248, 1375], [1425, 1425, 1447, 1447, 1796], [1798, 1798, 1855, 1855, 2547]], "test": "ok"}
{"id": "ttXGzl", "name": "ScaredFish", "author": "bignobody", "description": "Implicit Surface wiki page had a surface of genus 2 equation, so I thought I would try to raymarch it. Wasn't entirely successful but I got some fun results by animating large EPSILON values... Reminds me of a fish face from SpongBob Squarepants!", "tags": ["raymarch", "genus"], "likes": 1, "viewed": 97, "published": "Public", "date": "1557334156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// branch of my Rainbow Crocs shader: https://www.shadertoy.com/view/3d2SRD\n#define MAX_STEPS 64\n\n#define MAX_DIST 256.0\n\nfloat gyroidSDF(vec3 p , float s)\n{\n//\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    float g = dot(cos(p),sin(p.yzx));\t// shorthand suggested by Shane\n    return length(normalize(p) * g * s);\n}\n\nfloat genusSDF(vec3 p, vec3 q, float s)\n{\n //2y(y2-3x2)(1-z2)+(x2+y2)2 - (9z2-1)(1-z2) = 0   \n\t//float g = 2.0 * p.y * (pow(p.y,2.0)- pow(3.0 * p.x,2.0)) * (1.0-pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - (pow(9.0*p.z,2.0)-1.0)*(1.0-pow(p.z,2.0));\n//\tfloat g = q.y * 2.0 * p.y * (pow(p.y,2.0)-  pow(q.x * 3.0 * p.x,2.0)) * (q.z * 1.0 -pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - ( pow(q.z * 9.0 * p.z,2.0)-1.0)*(q.z-pow(p.z,2.0));\n\tfloat g = q.y * p.y * (pow(p.y,2.0)-  pow(q.x * p.x,2.0)) * (q.z-pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - ( pow(q.z * p.z,2.0)-1.0)*(q.z-pow(p.z,2.0));\n//\tfloat g = p.y * (pow(p.y,2.0)- pow(p.x,2.0)) * (pow(p.z,2.0)) + pow(pow(p.x,2.0)+pow(p.y,2.0),2.0) - (pow(p.z,2.0)-1.0)*(1.0-pow(p.z,2.0));\n\n    return length(normalize(p) * g * s);\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereSDF(q, 0.11);\n}\n\nfloat getInRange(float a, float b, float d)\n{\n\treturn (d-a)/(b-a);   \n}\n\nfloat remapValue(float originStart, float originEnd, float remapStart, float remapEnd, float v)\n{\n \treturn getInRange(originStart,originEnd,v) * (remapEnd-remapStart) + remapStart;   \n}\n\nfloat sceneSDF(vec3 p)\n{\n\t//float t = mod(iTime,10.0);\n    float t = iTime * 1.1;\n    float ev = remapValue(-1.0,1.0, 1.6,2.0, cos(t))+1.25;\n    \n\tmat3 rz = mat3(cos(ev), sin(ev), 0.0,\n                   -sin(ev), cos(ev), 0.0,\n                   0.0,0.0,1.0);\n    \n    vec3 q = inverse(rz) * p;\n    return genusSDF(normalize(q), vec3(3.0,2.0,9.0), 0.1);\n}\n\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist, float EPSILON )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p, float EPSILON) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n  //  vec3 camOrigin = vec3(-180.0 * sin(ext),0.0,-180.0* cos(ext));\n    vec3 camOrigin = vec3(0.0,0.0,-80.0 + sin(ext));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n\tfloat EPSILON = 5.9 + cos(ext);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST,EPSILON);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d,EPSILON);\n  //  d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        //discard;\n        return;\n    }\n\tvec3 bc = vec3(-0.1+g.x,-0.9+g.y,1.0-g.x);\n\t//vec3 bc = vec3(-0.4+g.y,-0.3+g.x,1.0-g.x);\n    vec3 col = vec3(clamp(d,0.0,0.99))*(bc+g);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 157, 235, 348], [350, 350, 391, 798, 1150], [1152, 1152, 1186, 1186, 1213], [1216, 1216, 1253, 1253, 1275], [1277, 1277, 1312, 1312, 1334], [1336, 1336, 1373, 1373, 1394], [1397, 1397, 1433, 1433, 1495], [1497, 1497, 1542, 1542, 1568], [1570, 1570, 1667, 1667, 1755], [1757, 1757, 1781, 1811, 2113], [2116, 2116, 2206, 2206, 2617], [2619, 2619, 2664, 2664, 2974], [2977, 2977, 3034, 3075, 4313]], "test": "error"}
{"id": "wd2SWR", "name": "rothkore", "author": "lennyjpg", "description": "asdfasdfasdfasdf", "tags": ["asdfasdfsd"], "likes": 1, "viewed": 265, "published": "Public API", "date": "1558282214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(a)  vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 U = (f-iMouse.xy) / iResolution.y;\n    \n    \n U.x*=step(U.y,0.0)*0.5;\n    for(float i=2., t = iTime*.7;i<38.;i++){\n        U += i/20. * SC(i*11.1+t*.1);\n\n        \n             \n\n        U.y += cos(U.x*U.y*1.2);\n        \n       \n        \n        //U.y -= abs(U.y*10.5);\n  //              U.x -= cos(U.y*1.2);\n        \n\n\t\tO[int(i)%3] += sin(atan(U.x,U.y) + i * 111.32 + t) * .33;\n    }\n    O += vec4(.7,.4,.4,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2SWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 75, 75, 497]], "test": "ok"}
{"id": "wl23R1", "name": "coworker's tune", "author": "mds2", "description": "slight modification of an older shader to go along with a coworker's band's track.", "tags": ["music", "copypasta", "tunes"], "likes": 2, "viewed": 488, "published": "Public API", "date": "1558559369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 1500.0\n\n#define INTEGRATE_UNBOUNDED_STUFF 1\n// set to 0 to make the density of the glowy stuff 1/(distance^2)\n// by default it's 1/distance, which means the total glow contribution grows with MAX_DIST\n// I think it looks better with 1/distance\n// but, hey, neither of these functions come from \"physics\"\n// (or, if they do, it is only by coincidence)\n//\n// p.s. looks really nice when MAX_DIST is huge (thanks @CLPB for pointing this out)\n\nconst vec3 light = vec3(0.48, 0.64, -0.6);\n\nvec3 ball1;\nvec3 ball2;\nvec3 ball3;\n\nvec3 radii;\n\nvec3 s_max_v3(in vec3 x, in vec3 y, in float s) {\n    vec3 bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nvec3 s_abs(in vec3 x, in float s) {\n    return s_max_v3(x, -x, s);\n}\n\nfloat sdf1(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball1) - 0.25 * radii.x)) - 0.5 * radii.x;\n}\n\nfloat sdf2(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball2) - 0.375 * radii.y)) - 0.375 * radii.y;\n        //dot(s_abs(pt - ball2, 0.25 * radii.y), vec3(0.5)) - 0.5 * radii.y;\n}\n\nfloat sdf3(in vec3 pt) {\n    return length(max(vec3(0.0), abs(pt - ball3) - 0.5 * radii.z)) - 0.25 * radii.z;\n}\n\nvec3 sdfs(in vec3 pt) {\n    return vec3(sdf1(pt), sdf2(pt), sdf3(pt));\n}\n\nfloat sdf(in vec3 pt) {\n    return min(sdf1(pt), min(sdf2(pt), sdf3(pt)));\n}\n\nfloat min_comp(in vec3 comps) {\n    return min(comps.x, min(comps.y, comps.z));\n}\n\nvec3 sdf_grad(in vec3 pt) {\n    float f = sdf(pt);\n    const float h = 0.001;\n    const float h_inv = 1000.0;\n    \n    return vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                sdf(pt + vec3(0.0, h, 0.0)) - f,\n                sdf(pt + vec3(0.0, 0.0, h)) - f);\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir, out vec3 integral) {\n    integral = vec3(0.0);\n    float curr = 0.0;\n    const float step_ratio = 0.25;\n    vec3 curr_sdf = sdfs(orig);\n    float dist = step_ratio * min_comp(curr_sdf);\n    vec3 next_sdf = sdfs(orig + dir * dist);\n    // integral from 0 to d of 1/(a+bx) =\n    // screw it, just average some things.\n    integral = dist * (0.25 / curr_sdf + 1.0 / (curr_sdf + next_sdf) + 0.25 / next_sdf);\n    float total_dist = dist;\n    const vec3 thresh = vec3(0.004);\n    for (int i = 0; i < 128; ++i) {\n        curr_sdf = next_sdf;\n        dist = step_ratio * min_comp(curr_sdf);\n        total_dist += dist;\n        next_sdf = sdfs(orig + total_dist * dir);\n        vec3 mid = 0.5 * (curr_sdf + next_sdf);\n#if INTEGRATE_UNBOUNDED_STUFF        \n        integral += dist * (0.25 / max(thresh, curr_sdf) + \n                            0.5 / max(thresh, mid ) + \n                            0.25 / max(thresh, next_sdf));\n#else\n        integral += dist * (0.25 / max(thresh, curr_sdf * curr_sdf) + \n                            0.5 / max(thresh , mid * mid ) + \n                            0.25 / max(thresh, next_sdf * next_sdf));\n#endif        \n        if (min_comp(next_sdf) < 1.0e-3 || total_dist > MAX_DIST) {\n            return total_dist;\n        }\n    }\n    return total_dist;\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 orig = vec3(0.0, 0.1, -1.25);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                0.0, 0.28, -0.96,\n                0.0, 0.96, 0.28); \n    orig = tilt * orig;\n    dir = tilt * dir;\n    \n    float theta = 0.6 * iTime;\n    float ct = cos(theta);\n    float st = sin(theta);\n    \n    float rad = 0.6;\n\n    ball1 = rad * vec3(ct, st, 0.0);\n\n    ct = cos(theta + 2.0 * 3.141592654 / 3.0);\n    st = sin(theta + 2.0 * 3.141592654 / 3.0);\n    ball2 = rad * vec3(ct, st, 0.0);\n    \n    ct = cos(theta - 2.0 * 3.141592654 / 3.0);\n    st = sin(theta - 2.0 * 3.141592654 / 3.0);\n    ball3 = rad * vec3(ct, st, 0.0);\n\n    vec3 integral;\n    \n    radii = 0.3 + 0.2 * vec3(texture(iChannel0, vec2(0.0, 0.0)).r,\n                             texture(iChannel0, vec2(0.5, 0.0)).r,\n                             texture(iChannel0, vec2(1.0, 0.0)).r);\n    \n    float raydist = raymarch(orig, dir, integral);\n\n#if INTEGRATE_UNBOUNDED_STUFF    \n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 0.45/(integral));\n#else\n    vec3 col = smoothstep(0.15 * (1.0 *  radii), vec3(0.0), 1.5/(integral));    \n#endif    \n    \n    col = mat3(0.7, 0.6, 0.3,\n               0.5, 0.1, 0.7,\n               0.0, 0.0, 1.1) * col.zyx;\n    if (raydist < MAX_DIST) {\n        vec3 pt = orig + raydist * dir;\n        vec3 norm = normalize(sdf_grad(pt));\n        vec3 bounce = normalize(reflect(dir, norm));\n        col += 0.5 * smoothstep(0.45, 1.0, dot(bounce, light)) * vec3(0.9, 0.8, 1.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtsGRj", "previewfilepath": "https://soundcloud.com/lucien-es/undertaker", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lucien-es/undertaker", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[551, 551, 600, 600, 723], [725, 725, 760, 760, 793], [795, 795, 819, 819, 906], [908, 908, 932, 932, 1099], [1101, 1101, 1125, 1125, 1212], [1214, 1214, 1237, 1237, 1286], [1288, 1288, 1311, 1311, 1364], [1366, 1366, 1397, 1397, 1447], [1449, 1449, 1476, 1476, 1713], [1715, 1715, 1777, 1777, 3042], [3053, 3053, 3110, 3160, 4807]], "test": "error"}
{"id": "wl23Rw", "name": "Mercury boiling", "author": "jblanper", "description": "Two spheres and crazy parametric equations rendered using ray marching.", "tags": ["3d", "raymarching", "abstract"], "likes": 7, "viewed": 209, "published": "Public", "date": "1558961623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define EPSILON 1.\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  // http://www.iquilezles.org/www/articles/smin/smin.htm\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat displacement(vec3 p, float n) {\n  return sin(p.x * n) * sin(p.y * n) * sin(p.z * n);\n}\n\nfloat sceneSDF (vec3 p) {\n  float s1 = sphereSDF(p - vec3(-.8 * sin(iTime) * .2, .3, -.10 * cos(iTime) * .5), .5 + sin(cos(dot(p, vec3(p.y)) * 1.2 - iTime * .3) * 8. + iTime * .2) * .5 + .5);\n  float s2 = sphereSDF(p - vec3(-.8 * sin(iTime) * .2, .5, -.10 * cos(iTime) * .5) * sin(length(p * sin(iTime * .01)) * 15. + cos(iTime)), 1.);\n\n  return smin(s1 * 1.1, s2 * .8 + displacement(p - cos(atan(p.y, p.z) - iTime * .01) * .5 + .5, 5.), 1.2);\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    depth += dist;\n    if (depth >= MAX_DIST) return 0.;\n  }\n  return 0.;\n}\n\nfloat getLight (vec3 lightPos, vec3 p) {\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  float diff = clamp(dot(normal, light), 0., 1.);\n\n  return diff;\n}\n\nvec3 getRayDir (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n   \n  // camera\n  vec3 ro = vec3(-.3, 1., 8.);\n  ro.xz *= rotate(iTime * .02);\n  vec3 rd = getRayDir(uv, ro, vec3(-.3), 2.5);\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 lightPos1 = vec3(4. * sin(iTime * .5), 4., 6. * cos(iTime * .5));\n    vec3 lightPos2 = vec3(-6., -3. * sin(iTime * .5), -1. * cos(iTime * .5));\n    float diff = getLight(lightPos1 * d, p);\n    color += diff * vec3(.2, .4, .8);\n    color += diff * .5;\n    diff = getLight(lightPos2 * d, p);\n    color += diff * vec3(.8, .4, .2);\n    color += diff * .4;\n    color -= d * .002;\n\n  } else {\n    color += 1. - length(uv * .6);\n    color *= 1. - cos(length(uv * (uv.x - uv.y)) * 20. - iTime);\n    color = mix(color, vec3(0.), cos(length(uv) * 120. + iTime) * .5 + .5) * vec3(.5);\n  }\n\n  fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 106, 106, 156], [158, 158, 199, 257, 339], [341, 341, 376, 376, 402], [404, 404, 441, 441, 496], [498, 498, 523, 523, 943], [945, 945, 970, 970, 1130], [1132, 1132, 1167, 1167, 1385], [1387, 1387, 1427, 1427, 1566], [1568, 1568, 1635, 1684, 1976], [1978, 1978, 2035, 2035, 2977]], "test": "timeout"}
{"id": "wl23zm", "name": "First Run", "author": "sgiobairog", "description": "First time playing with shaders at Creative Coding meetup in Zürich", "tags": ["shaders"], "likes": 1, "viewed": 303, "published": "Public API", "date": "1558979958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 5.0;\n    \n    for(float i = 1.0; i < 8.0; i+= 1.0) {\n    \tuv.x += sin(uv.y + 2.0 + iTime) * sin(iMouse.y);\n    \tuv.y += cos(uv.x + 1.0 + iTime) * atan(iMouse.x);\n    }\n    \n    vec3 colour = vec3(0.5 + 0.5 * tan(uv.xxy + atan(iTime) + vec3(0, 5, 10)));\n    \n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 402]], "test": "ok"}
{"id": "wl23zR", "name": "Tiled rainbow explosions", "author": "mosaic", "description": "Thanks to  https://thebookofshaders.com/09/ for ideas ", "tags": ["2d"], "likes": 5, "viewed": 310, "published": "Public", "date": "1558387535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 st  = fragCoord/iResolution.y;\n    vec2 uv  = fragCoord/iResolution.y;\n \n    //these two lines create the tile pattern\n    //scale the coordinate space by a certain number\n    st*=4.;\n    //repeat the image\n    st=fract(st);\n    \n    //circle\n    float pct =abs(distance(st,vec2(0.5,0.5))*5.);\n    \n    //this line adds colour\n    vec3 col = 0.5 + 0.5*cos(iTime*3.+uv.xyx+vec3(0,2,6));\n    \n    col=(col/pct);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n//the wave pattern is beacuse st is tiled, but uv is not ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl23zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 544]], "test": "ok"}
{"id": "Wl2GRh", "name": "Sphere split", "author": "plosique", "description": "splits a sphere in half", "tags": ["raymarching", "metric", "amoeba"], "likes": 2, "viewed": 79, "published": "Public", "date": "1558499376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS=255; \nconst float MAX_DIST=100.0; \nconst float MIN_DIST=0.0; \nconst float EPS=0.001; \nconst float a=1.0; \nconst vec3 ls=vec3(1.0,1.0,-1.0); \nconst vec3 ia=vec3(1.0,1.0,1.0);\nconst vec3 id=vec3(0.5,0.5,0.5); \nconst vec3 is=vec3(0.5,0.5,0.5); \nconst float kd=0.5; \nconst float ks=0.2; \nconst float ka=0.4; \nvec3 c=vec3(0.0,0.0,1.0); \nfloat r=1.3; \n\nfloat dist(vec3 pt,mat3 mat){ \n    return pow(dot(pt,mat*pt),0.5); \n}\n\nfloat sphereSDF(in vec3 pt,in mat3 mat){ \n    return dist(pt-c,mat)-r; \n}\n\n\nfloat craterSDF(in vec3 pt){ \n    vec3 cent=c+vec3(0.0,0.0,-r); \n    float radius=0.4;\n    return length(pt-cent)-radius; \n} \n\nfloat diff(in float A,in float B){ \n    return max(A,-B); \n}\n\nfloat sceneSDF(in vec3 pt,mat3 mat){   \n    return sphereSDF(pt,mat); \n}\n\n\nvec4 ray_march(in vec3 eye, in vec3 dir,mat3 mat){\n    vec4 bkg=vec4(0.0,0.0,0.0,1.0); \n    vec3 pt; \n\tpt=eye;\n    float step_size=0.0;\n    for(int i=0;i<MAX_STEPS;i++){\n        step_size=sceneSDF(pt,mat); \n        \n        pt=pt+step_size*dir;\n        \n        if (step_size>MAX_DIST){  \n            return bkg ;\n        } \n        if (step_size<EPS){\n            vec3 N=(pt-c); \n            vec3 L=(ls-pt); \n            vec3 V=(eye-pt); \n            vec3 R=reflect(-L,N);\n            vec3 ret=ka*ia+kd*(dot(L,N))*id+ks*pow(dot(R,V),a)*is;\n            vec4 ret2=vec4(ret,1.0);\n            return ret2;\n                \n            \n        } \n       \n    }return bkg ;\n}\n\nvec3 ray_dir(vec3 eye,vec3 pix_loc){ \n    return normalize(pix_loc-eye); \n        }\n\nfloat det(mat3 mat){  \n    return mat[0][0]*mat[1][1]*mat[2][2]; \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 r1=fragCoord-0.5*iResolution.xy; \n    vec2 r=r1.xy/(0.5*iResolution.y); \n    mat3 mat=mat3(1.0-sin(3.14*r.y)*cos(iTime),0.0,0.0,\n                  0.0,1.0-cos(3.14*r.x)*cos(iTime),0.0,\n                  0.0,0.0,1.0-sin(3.14*r.y)*cos(3.14*r.x)*cos(iTime)); \n    mat=mat/det(mat); \n    vec3 eye=vec3(0.0,0.0,-1.0); \n    vec3 pix_loc=vec3(r,0.0); \n    vec3 dir=ray_dir(eye,pix_loc);  \n    vec4 pix_val=ray_march(eye,dir,mat); \n     \n    fragColor=pix_val;\n \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 396, 396, 436], [438, 438, 478, 478, 511], [514, 514, 542, 542, 638], [641, 641, 675, 675, 701], [703, 703, 739, 739, 775], [778, 778, 828, 828, 1449], [1451, 1451, 1487, 1487, 1534], [1536, 1536, 1556, 1556, 1603], [1607, 1607, 1664, 1664, 2131]], "test": "ok"}
{"id": "Wl2GRz", "name": "Jump to lightspeed (Star Wars)", "author": "nyri0", "description": "The version from dmmn is quite cartoony, and the one from sickbow is slow and only black and white. This is my attempt to make a fast version closer to the original material.\nChange AA to 1 if it's too slow.", "tags": ["space", "starwars", "lightspeed"], "likes": 17, "viewed": 1128, "published": "Public API", "date": "1558392723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Created by Louis Sugy, 2019\n * You can use it under the terms of the MIT license\n * (free to use even in commercial projects, attribution required)\n */\n\n// Change the anti-aliasing to 1 if it's too slow\n#define AA 2\n#define PI 3.14159265\n#define ATAN5 1.37340076695\n\nvec2 cart2polar(vec2 cart) {\n    return vec2(atan(cart.y, cart.x), length(cart));\n}\n\n// From https://www.shadertoy.com/view/4sc3z2\n// and https://www.shadertoy.com/view/XsX3zB\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat simplexNoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n\nfloat linearstep(float low, float high, float val)\n{\n    return clamp((val-low) / (high-low), 0.0, 1.0);\n}\nfloat jumpstep(float low, float high, float val)\n{\n    if(2.0 * val < high + low) {\n        return clamp(atan(10.0 * (val-low) / (high-low) - 5.0) / (2.0 * ATAN5) + 0.5, 0.0, 1.0);\n    }\n    else {\n        return (10.0 * (val-low) / (high-low) - 5.0) / (2.0 * ATAN5) + 0.5;\n    }\n}\n\nvec3 pixelVal(vec2 coord)\n{    \n    // Pixel to point (the center of the screen is (0,0)\n    vec3 resolution = iResolution * float(AA);\n    vec2 uv = (2.0*coord - resolution.xy) / resolution.x;\n    vec2 ad = cart2polar(uv);\n    \n    // Loop forever\n    float time = mod(iTime, 8.0);\n    \n    vec3 bg = vec3(0,0,0.05);\n    vec3 col = bg;\n \n    // Initial step, just roaming in space\n    if(time < 3.5) {\n        float r = ad.y / (1.0+0.042*time);\n    \tfloat noiseVal = simplexNoise(vec3(60.0*ad.x,50.0*r, 0.0));\n        float whiteIntensity = smoothstep(0.7, 1.0, noiseVal)\n                               * (1.0 - smoothstep(2.8,3.5,time));\n        col = mix(col, vec3(1,1,1), whiteIntensity);\n    }\n    // The effect starts\n    if(time >= 2.8 && time < 4.5) {\n        float blueTime = 1.0 - 1.0*smoothstep(2.8, 5.0, time);\n        float whiteTime = 1.0 - 0.6*smoothstep(3.0, 5.0, time);\n        float r = ad.y / (1.0+0.15*linearstep(0.0, 3.5, time))\n                  *(40.0 / (3.0 + 20.0*jumpstep(2.8, 6.0, 0.5*pow(time,1.5))));\n        float noiseVal = simplexNoise(vec3(40.0*ad.x,r, 0.0));\n        col = mix(col, vec3(0.5,0.7,1), smoothstep(2.8, 3.5, time)\n                                        *smoothstep(0.4*blueTime, blueTime, noiseVal));\n        col = mix(col, vec3(1,1,1), smoothstep(2.8, 3.5, time)\n                                    *smoothstep(0.7 * whiteTime, whiteTime, noiseVal));\n        \n        // Dark at the center\n    \tcol = mix(col, bg, smoothstep(2.8, 3.4, time) * (1.0 - ad.y));\n    }\n    // Fade to white\n    if(time > 4.2 && time < 4.5) {\n        col = mix(col, vec3(0.9,0.95,1.0), smoothstep(4.2,4.5, time));\n    }\n    // Fade to black with stars (decelerating)\n    else if(time > 4.5) {\n        float r = ad.y / (1.0 + 2.0/PI*atan(-0.042*(8.0-time))/cos((8.0-time)/2.2));\n    \tfloat noiseVal = simplexNoise(vec3(60.0*ad.x,50.0*r, 0.0));\n        float whiteIntensity = smoothstep(0.7, 1.0, noiseVal);\n        col = mix(col, vec3(1,1,1), whiteIntensity);\n        col = mix(col, vec3(0.9,0.95,1.0), 1.0-smoothstep(4.5,5.0, time));\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 avgcol = vec3(0.0);\n    \n    for(int i = 0; i < AA; i++)\n        for(int j = 0; j < AA; j++)\n            avgcol += pixelVal(float(AA)*fragCoord + vec2(i, j));\n        \n    avgcol /= float(AA*AA);\n    \n    \n    // Output to screen\n    fragColor = vec4(avgcol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[270, 270, 298, 298, 353], [485, 485, 507, 507, 659], [660, 660, 688, 688, 1348], [1351, 1351, 1403, 1403, 1457], [1458, 1458, 1508, 1508, 1739], [1741, 1741, 1768, 1829, 3824], [3826, 3826, 3883, 3883, 4159]], "test": "ok"}
{"id": "Wl2Gz1", "name": "mandelbrot orbit trap periods", "author": "elenzil", "description": "inspired by [url=https://www.shadertoy.com/view/wtfGWS]Plento's Orbits[/url].\nstill to explore: coloring traps based on the simpleness or self-overlapping ness of the orbit polygons. eg a pentagon vs. a five-pointed star.", "tags": ["mandelbrot", "orbittrap", "grimoire"], "likes": 72, "viewed": 1314, "published": "Public API", "date": "1558505991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// orion elenzil 20190521\n// inspired by https://www.shadertoy.com/view/wtfGWS\n\nconst float PI        = 3.14159265359;\nconst float TAU       = PI * 2.0;\n\n#define AA 2.0\n\n// todo 1: rewrite as mat2(A,-A.y,A.x) * B.\n// todo 2: replace with complexSqr(A).\nvec2 complexMul(in vec2 A, in vec2 B) {\n    return vec2((A.x * B.x) - (A.y * B.y), (A.x * B.y) + (A.y * B.x));\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(in vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// point of interest\nstruct POI {\n    vec2    center;\n    float range;\n    float maxIter;\n};\n\n\nfloat mandelEscapeIters(in vec2 C, in float maxIter, in vec2 ocOff, out float cycleLength1, out float cycleLength2) {\n    vec2 Z = C;\n    vec2 orbitCenter1 = 0.3 * vec2(cos(iTime * 1.00), sin(iTime * 1.00));\n    vec2 orbitCenter2 = orbitCenter1 / 0.3 * 0.2;\n    orbitCenter1 += ocOff;\n    orbitCenter2 += ocOff;\n    cycleLength1 = 0.0;\n    cycleLength2 = 0.0;\n    for (float n = 0.0; n < maxIter; ++n) {\n        Z    = complexMul(Z, Z) + C;\n        if (cycleLength1 == 0.0 && abs(1.0 - length(Z - orbitCenter1)) < 0.015) {\n            cycleLength1 = n;\n        }\n        if (cycleLength2 == 0.0 && abs(0.2 - length(Z - orbitCenter2)) < 0.01) {\n            cycleLength2 = n;\n        }\n        if (dot(Z, Z) > 4.0) {\n            return n;\n        }\n    }\n    return maxIter;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a  = 1.0;\n    float smallWay = min(iResolution.x, iResolution.y);\n    vec2 uv = (XY * 2.0 - iResolution.xy)/smallWay;\n    float t = iTime * TAU / 5.0;\n\n    vec2 ocOff = vec2(0.0);\n    if (any(greaterThan(iMouse.xy, vec2(50.0)))) {\n        ocOff = (iMouse.xy * 2.0 - iResolution.xy)/smallWay;\n    }\n\n    const POI poi1 = POI(vec2(-.7105, 0.2466), 0.04, 90.0);\n    const POI poi2 = POI(vec2(-.600, 0.0000), 1.200, 70.0);\n    const POI poi  = poi2;\n\n    float rng = poi.range;// * (1.0 + sin(t) * 0.1);\n    \n    float cycleLength1;\n    float cycleLength2;\n\n    vec3 col = vec3(0.0);\n\n    for( float m = 0.0; m < AA; ++m) {\n    for( float n = 0.0; n < AA; ++n) {\n        vec2  C   = (uv + vec2(m, n) / (AA * smallWay)) * rng + poi.center;\n        float escapeIters = mandelEscapeIters(C, poi.maxIter, ocOff, cycleLength1, cycleLength2);\n        float f   =  escapeIters / poi.maxIter;\n        if (escapeIters == poi.maxIter) {\n            f = 0.0;\n        }\n        f = pow(f, 0.6);\n        f *= 0.82;\n\n        vec3 rgb  = vec3(f * 0.2, f * 0.6, f * 1.0);\n\n        if (cycleLength1 > 0.0) {\n            const float spectrumSamples = 20.0;\n            rgb += vec3(cos(cycleLength1 / spectrumSamples * TAU) * 0.2 + 0.3);\n        }\n        if (cycleLength2 > 0.0) {\n            const float spectrumSamples = 30.0;\n            rgb += hsv2rgb(vec3(fract(cycleLength2/ spectrumSamples), 0.9, 0.8));\n        }\n\n        col += rgb;\n    }}\n\n    col /= (AA * AA);\n\n    RGBA.rgb = col;\n}\n\n// grimoire bindings\n// out vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2Gz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 253, 292, 292, 365], [367, 432, 457, 457, 626], [724, 724, 841, 841, 1498], [1500, 1500, 1543, 1543, 3025]], "test": "ok"}
{"id": "Wl2GzW", "name": "Ripples and a light", "author": "hirak99", "description": "Shadertoy is cool!", "tags": ["ripples", "mouse", "light", "pond"], "likes": 2, "viewed": 173, "published": "Public", "date": "1558658157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ripple_size = 0.2;\nfloat speed = 2.5;\nvec3 waterColor = vec3(.3, .7, 1.);\n\nvec3 light1 = vec3(100, 200, 200);\n\nfloat lightIntensity(in vec3 normal, in vec3 light, in vec2 uv) {\n    vec3 to_light = light - vec3(uv, 0);\n    float dist2 = dot(to_light, to_light)/62500.;\n    // Light on the surface of pool. Generaly would be due to particles floating on it.\n    float intensity = dot(normal, normalize(to_light)) / dist2;\n    \n    // Specular reflection of the light source on water.\n    vec3 reflected = reflect(vec3(0, 0, -1), normal);\n    float dist = distance(dot(to_light, reflected) * reflected, to_light);\n    intensity += smoothstep(100., 30., dist) * .9;\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    float rad2 = dot(uv, uv);\n    float rad = sqrt(rad2);\n    float elevation = sin(rad * ripple_size - speed * iTime);\n    \n    // Normal along the radius.\n    vec2 normalr = normalize(vec2(-ripple_size * elevation, 1.));\n\n    vec2 uvn = normalize(uv);\n    // 3D normal.\n    vec3 normal = vec3(normalr.x * uvn.x, normalr.x * uvn.y, normalr.y);\n    \n    vec2 lightxy = iMouse.xy - iResolution.xy / 2.;\n    vec3 mouseLight = vec3(lightxy, 250);\n\n    fragColor.rgb += lightIntensity(normal, mouseLight, uv) * vec3(1, .95, .8) * .5;\n    fragColor.rgb += lightIntensity(normal, light1, uv) * vec3(1, .95, .8) * .5;\n\n    // Refraction.\n    vec3 refracted = refract(vec3(0, 0, -1), normal, 1.5);\n    vec2 delta = -refracted.xy / refracted.z * 20.;\n    fragColor.rgb += texture(iChannel0, (fragCoord + delta) / 150.).xxx * waterColor;\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2GzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 182, 182, 691], [693, 693, 750, 750, 1627]], "test": "error"}
{"id": "WlBGR1", "name": "[twitch] Space Jelly", "author": "NuSan", "description": "Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SpaceJelly.glsl\nThe idea was to accumulate when near the surface to make the translucent p", "tags": ["3d", "raymarching", "fuzzy"], "likes": 12, "viewed": 347, "published": "Public", "date": "1558386107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/SpaceJelly.glsl\n\nThe idea was to accumulate when near the surface to make the translucent parts.\n*/\n\nfloat time = 0.0;\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*467.355)*541.988);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return mix(rnd(floor(g)), rnd(floor(g)+1.), it);\n}\n\nfloat tick(float t, float d) {\n  float g=t/d;\n  float it=fract(g);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  it=smoothstep(0.,1.,it);\n  return floor(g) + it;\n}\n\nvec3 lp=vec3(0);\nfloat map(vec3 p) {\n  \n  p.xz *= rot(p.y*sin(time*12.5 + length(p.xz)*max(0.2,sin(time))*0.8)*0.02 * smoothstep(0.0,0.5,abs(fract(time*0.2)-.5)));\n    \n  float dist=100.0;\n  p = (fract(p/dist+.5)-.5)*dist;\n\n  float d=10000.0;\n  float s=8.0 + curve(time, 0.7)*10.0;\n  for(int i=0; i<5; ++i) {\n    \n    float t=tick(time, 0.8 + 0.7*float(i)) * 0.25;\n    p.xy *= rot(t);\n    p.yz *= rot(t*.7);\n    p.xy=abs(p.xy);\n    d=min(d, length(p.xz)-.1);\n    p-=s;\n    s *= 0.4;\n  } \n  \n  float d2 = box(p, vec3(1.5, 0.7, 0.3)*.5);\n  lp=p;\n    \n  return min(d, d2);\n}\n\nfloat rnd(vec2 uv) {\n  \n  return fract(dot(sin(uv*784.565 + uv.yx*568.655), vec2(438.724)));\n}\n\nvoid cam(inout vec3 p) {\n  \n  float t=time*.4 + curve(time, 1.9) * 3.0;\n  p.xy *= rot(t);\n  p.yz *= rot(t*1.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  uv *= 2.0/(0.7+length(uv));\n  \n  float time2 = iTime*1.0 + 23.0;\n  time = tick(time2*0.3, 1.7) + time2*0.3;\n\n  vec3 s=vec3(0,0,-50);\n  vec3 r=normalize(vec3(-uv, 0.5 + curve(time, 0.8)));\n  \n  cam(s);\n  cam(r);\n  \n  float dither = mix(1.0,rnd(uv + fract(time)),0.1);\n  \n  vec3 col = vec3(0);\n   \n  vec3 l=normalize(-vec3(1,3,2));\n  vec2 off=vec2(0.01,0.0);\n  \n  float t2 = time*10.3;\n  \n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p)*dither;\n    float limit = sin(p.z*0.13 + t2) * 1.5 + 2.0;\n    if(dd>200.0) break;\n    if(d<limit) {\n      float dist = 30.0;\n      vec3 lp2 = (fract(lp/dist+.5)-.5)*dist;\n      float factor = 0.02;\n      //factor = (d<0.001) ? 0.5 : 0.02;\n      vec3 n=normalize(map(p) - vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n      if(dot(n,l)<0.0) l=-l;\n      vec3 h=normalize(l-r);\n      float f=pow(1.0-abs(dot(n,r)), 10.0);\n      col += max(dot(n,l), 0.0) * factor * (0.3 + vec3(0.6,0.3,0.9)*5.0*pow(max(0.0,dot(n,h)), 10.0));\n      col += vec3(0.2,0.5,1.0) * 4.0 * f * factor * (n.y*.5+.5);\n      col += smoothstep(0.2,0.1, length(lp2.xz)) * factor * 10.0;\n      if(d<0.01) {\n        break;\n      }\n      d=0.2;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  float fog = pow(1.0-clamp(dd/200.0,0.0,1.0), 2.0);\n  float turn = fog*0.9 + time*.3;\n  col.xy *= rot(turn);\n  col.yz *= rot(turn*1.3);\n  col = abs(col);\n  col = mix(col, vec3(0.3,0.5,1.0)*dot(col, vec3(0.333)), 0.7);\n  \n  col *= 2.0;\n  col *= 1.2 - length(uv);\n    \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 314, 314, 363], [365, 365, 384, 384, 453], [455, 455, 475, 475, 517], [519, 519, 550, 550, 720], [722, 722, 752, 752, 895], [914, 914, 933, 933, 1468], [1470, 1470, 1490, 1490, 1564], [1566, 1566, 1590, 1590, 1679], [1682, 1682, 1739, 1739, 3396]], "test": "ok"}
{"id": "Wlf3Rs", "name": "SOARP with OverRelaxing", "author": "bignobody", "description": "Fourth generation of my practice raymarcher. Integrates some suggestions I received (conditional free object map, no global arrays) and integrates a first try at the \"Over Relaxing\" technique (which brought big speed increases to my older machine).", "tags": ["raymarching", "reflection"], "likes": 4, "viewed": 178, "published": "Public", "date": "1557320734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the previous generation https://www.shadertoy.com/view/3tXGRX\n// Thanks as always to iq, Jamie Wong, BigWIngs (Art of Code) for the tutorials\n// Special thanks to ollj and shau for their suggestions on the previous iteration\n// -----------------------------------------------------------------------------\n// Limited the number of reflection bounces to 20 for safety.\n// Update: Fixed bug in shadow march (thanks ollj!)\n// Update: added Mouse camera control by request (hi Mitch!)\n\n\n#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\n\n//From Shane (via shau) to avoid conditionals\nvec2 nearest(vec2 a, vec2 b) \n{    \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;    \n}\n// As refactored by shau to demonstrate the above nearest function:\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    //floor\n    vec2 d = vec2(sdfPlane(p,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0))), 1.);\n    \n    //cross\n    d = nearest(d, vec2(opUnion( sdfBox(p, vec3(0.0), vec3(4.0,6.0,1.0)), sdfBox(p, vec3(0.0), vec3(1.0,6.0,4.0))), 2.)); \n\n    float offset = 0.0; \n    float offsetinc = 6.28318 / float(NUM_SPHERES);\n    for (int s = 0; s < NUM_SPHERES; s ++) {\n        d = nearest(d, vec2(sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0), float(s) + 3.));\n        d = nearest(d, vec2(sdfSphere(p,vec3(8.5 * cos(-iTime+offset),0.95*cos(-iTime*offset * 0.33),8.5 * sin(-iTime+offset)),1.2), float(s) + 3.));\n        offset += offsetinc;\n    }\n\n    pick = int(d.y);\n    return d.x;\n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.00085;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(-8.0 * cos(iTime * 0.25),3.5,-8.0 * sin(iTime * 0.25)),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(surfacePoint,lightOrigin);\n    for( float s=0.01; s < end; )\n    {\n        vec3 marchStep = surfacePoint + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.00085)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\tvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\n\tvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\n\tfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0);\n\n\tvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\tfloat mx = iMouse.x/iResolution.x * 3.14159;\n    // camera setup and ray cast\n    float zoom = 1.0;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    float camTime = (length(iMouse.zw) > 0.0) ? mx : iTime * 0.1;\n    float upTime = camTime * 5.0;\n    vec3 camOrigin = vec3(10.0 * cos(camTime),6.5 * cos(upTime)+4.2,-10.0 * sin(camTime));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const float MAX_DISTANCE = 128.0;\n    const float CLOSE_ENOUGH = 0.00085;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\tfloat overEstimate = 10.2;\n    float errorAmount = 99999.;\n    float previousDistance = 0.0;\n    vec3 colAccum = vec3(0.0);\n\tfloat bounceCount = 0.0;\n\tfloat refMixVal = 0.35; // don't start with a solid mix\n//initialize with sky colour\n    pickTarget = 0;\n\tcolAccum =  vec3(0.2,0.4,0.6) - rayDirection.y * 0.5;\n\tfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\tfloat stepLength = 0.0;\n\tfloat pixelRadius = 0.00000001;\n    \n\tfor (marchDistance = 0.0; marchDistance < MAX_DISTANCE;)\n\t{\n\t\tmarchStep = marchVec + rayDirection * marchDistance;\n\t    distNow = distanceToClosest(marchStep, pickTarget);\n\t\tbool failCondition = overEstimate > 1.0 && (abs(distNow)+previousDistance) < stepLength;\n        if (failCondition)\n        {\n        \tstepLength -= overEstimate * stepLength;\n            overEstimate = 1.0;\n        }\n        else\n        {\n        \tstepLength = distNow * overEstimate;\n            overEstimate += 1.0;\n        }\n        previousDistance = distNow;\n\n        float errorNow = distNow / marchDistance;\n\t\tif (!failCondition && errorNow < errorAmount)\n        {\n        \terrorAmount = errorNow;\n        }\n\n\t\tmarchDistance += distNow;\n\n\t\tif (marchDistance >= MAX_DISTANCE || bounceCount >= 20.0 || errorAmount < pixelRadius)\n        {\n          // sky colour\n                int lastPick = pickTarget;\n        \t\tpickTarget = 0;\n\t\t\t\tcolAccum = mix(colAccum,vec3(0.2,0.4,0.6) - rayDirection.y * 0.5,\n\t\t\t\t\t\t\tclamp(reflectivity[lastPick]+bounceCount*0.1,0.0,1.0));\n\n            \tbreak;   \n        }\n        \n\t\tif (distNow <= CLOSE_ENOUGH)\n       \t{\n\t\t\t// hit something!\n   \t\t\tsurfaceNormal = estimateNormal(marchStep, pickTarget);\n\t\t\t// calculate colour accumulation\n\t\t\tcolAccum = mix(colAccum,lightSurfacePoint(marchVec , marchStep, surfaceNormal, AMBIENT_LIGHT, pickTarget),\n\t\t\t\t\tclamp(reflectivity[pickTarget] + refMixVal + bounceCount * 0.1,0.0,1.0));\n          \trayDirection = normalize(reflect((rayDirection ), surfaceNormal));\n            bounceCount += 1.0;\n            marchDistance = 0.01;\n\t\t\t// move camera origin to reflection location\n\t\t\tmarchVec = marchStep; // + rayDirection * marchDistance;\n\t\t}\n\t\t\t\t\n\t}\n    col = colAccum;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlf3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[566, 597, 639, 639, 667], [668, 668, 708, 708, 862], [863, 863, 905, 931, 964], [965, 965, 1008, 1008, 1084], [1085, 1085, 1122, 1122, 1144], [1146, 1146, 1181, 1181, 1203], [1205, 1205, 1242, 1242, 1263], [1290, 1336, 1367, 1367, 1440], [1441, 1509, 1558, 1570, 2286], [2288, 2288, 2333, 2333, 2762], [3412, 3447, 3505, 3505, 4138]], "test": "timeout"}
{"id": "WlfGRj", "name": "mandellost", "author": "Pyramid", "description": "i don't even any more", "tags": ["mandelbrot"], "likes": 2, "viewed": 87, "published": "Public", "date": "1556830865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Real-Imaginary multiplication\nvec2 rIMult(vec2 complex, vec2 other)\n{\n    float r=complex.x;\n    float i=complex.y;\n    \n    float or=other.x;\n    float oi=other.y;\n    \n    return vec2(r*or-i*oi,r*oi+i*or);\n}\n\n//Real-Imaginary addition\nvec2 rIAdd(vec2 complex, vec2 other)\n{\n\tfloat r=complex.x;\n    float i=complex.y;\n    \n    float or=other.x;\n    float oi=other.y;\n    \n    return vec2(r+or, i+oi);\n}\n\n//Real-Imaginary square magnitude\nfloat SqrMagnitude(vec2 complex)\n{\n    float r=complex.x;\n    float i=complex.y;\n    \n    return r*r+i*i;\n}\n\n//Get stability\nint steps(vec2 complex, int iterations)\n{\n    int n=0;\n    vec2 z=vec2(0);\n    while(n<iterations && SqrMagnitude(z)<=5.)\n    {\n        z=rIMult(z,z);\n        z=rIAdd(z,complex);\n        ++n;\n    }\n    \n    if(n==iterations)\n    {\n        return iterations;\n    }else{\n        return n;\n    }\n}\n\n#define hue(h) abs(fract(h + vec3(3,2,1)/3.) * 6. - 3.) -1.\n#define eel(h) abs(fract(h + vec3(3,2,1)/6.) * 7. - 3.) -1.4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=iTime/2.;\n    vec2 target=vec2(-.60992,.464297);\n    //float zoom=mix(10.,.,abs(sin(t)));\n    float zoom=mix(1000.,12480.,abs(sin(t)));\n    //float zoom=40.;\n    int maxIt=40000;\n    float magic=float(maxIt/8);\n    \n    \n    \n    vec2 uv;\n    float sRatio=iResolution.x/iResolution.y;\n    uv.x=sRatio * (fragCoord.x / iResolution.x -.5);\n    uv.y=sRatio * (fragCoord.y / iResolution.y -.5);\n    uv/=zoom;\n    uv+=target;\n    \n    \n    \n    int amSteps=steps(uv, maxIt);\n    //float fSteps=mix(0.,1.,float(amSteps)/float(maxIt));\n    float fSteps=mix(.1,1.6,float(amSteps)/float(maxIt/8));\n    vec3 c=vec3(amSteps==maxIt?vec3(0):hue(fSteps*magic));\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 71, 71, 211], [213, 239, 277, 277, 405], [407, 441, 475, 475, 548], [550, 566, 607, 607, 860], [984, 984, 1041, 1041, 1732]], "test": "ok"}
{"id": "WlfGWS", "name": "mandala pattern 1", "author": "ankd", "description": "my shader mandala pattern 1", "tags": ["mandala"], "likes": 7, "viewed": 255, "published": "Public", "date": "1557400128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define WHITE vec3(1.0)\n#define BLACK vec3(0.0)\n#define RED vec3(1.0, 0.,0.)\n#define BLUE vec3(0.,0.,1.)\n#define YELLOW vec3(1.,1.,0.)\n#define HANADA vec3(39., 146., 195.)/255.0\n\n\n\nconst float PI = 3.14159265359;\n\nfloat rand(in vec2 n){\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat rand(in float n){\n    return rand(vec2(n));\n}\nfloat noise(in float x){\n    float f = fract(x);\n    float i = floor(x);\n    //return mix(rand(i), rand(i+1.0), f);\n    return mix(rand(i), rand(i+1.0), f*f*(3.0-2.0*f));\n    //return mix(rand(i), rand(i+1.0), smoothstep(0., 1., f));\n}\nfloat noise(in vec2 st){\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(1.,0.));\n    float c = rand(i + vec2(0.,1.));\n    float d = rand(i + vec2(1.,1.));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a,b,u.x)+\n        \t\t(c-a)*u.y*(1.0-u.x) +\n        \t\t(d-b)*u.x*u.y;\n}\n\nmat2 rotate(in float r){\n    float c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c);\n}\nfloat usin(in float x){\n    return 0.5+0.5*sin(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    float t = 0.2*iTime;\n    for(int i=0;i<5;i++){\n        float a = atan(uv.x, uv.y);\n        float b = floor(5.0+4.*fract(iTime*0.25));\n\t    a *= b / (2.0*PI);\n        a = abs(fract(a*0.5-b*0.5)*2.0-1.0);\n        a *= (2.0*PI)/b;\n        uv = length(uv)*vec2(sin(a+t*0.7), cos(a+t*0.8));\n        uv -= vec2(0.2+1.8*usin(iTime*0.3), 0.);\n        uv = fract(uv)*2.0-1.0;\n    }\n    \n\tfloat v = noise(uv);\n    \n    vec3 col1 = mix(RED, YELLOW, usin(iTime*0.4));\n    vec3 col2 = mix(BLACK, HANADA, usin(iTime*0.9));\n    vec3 col = mix(col1, col2, v);\n    \n    col *= clamp(length(uv), 0., 1.);\n    \n\tuv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    col *= exp(-0.8*length(uv));\n    col += 1.1*usin(iTime*0.4)*exp(-1.2*length(uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 236, 236, 303], [304, 304, 327, 327, 355], [356, 356, 380, 380, 591], [592, 592, 616, 616, 923], [925, 925, 949, 949, 1011], [1012, 1012, 1035, 1035, 1064], [1066, 1066, 1123, 1123, 2032]], "test": "ok"}
{"id": "wlfGzB", "name": "Fuzzies Attack", "author": "eiffie", "description": "My first Shadertoy contribution and the last I need to re-upload unless I find 1 that was useful... yeah last re-upload.\n", "tags": ["joint"], "likes": 6, "viewed": 330, "published": "Public API", "date": "1556702536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Fuzzies Attack by eiffie - some furry creatures running from the northern lights\nfloat time;//made some changes cause it seemed long-winded\nfloat noyz(vec3 co){return sin(co.x+1.3*sin(co.y+2.4*sin(co.z)))*0.5;} \nfloat Limb2(vec3 p, vec3 p0, vec3 p2, vec3 rt, float d, float r){ \n vec3 p1=(p2-p0)*0.5;//a simple joint solver, corrected the math after iq's version \n p1+=p0+normalize(cross(p1,rt))*sqrt(d*d-dot(p1,p1)); \n vec3 v=p1-p0;v*=clamp(dot(p-p0,v)/dot(v,v),0.0,1.0); \n vec3 v2=p1-p2;v2*=clamp(dot(p-p2,v2)/dot(v2,v2),0.0,1.0); \n return min(distance(p-p0,v),distance(p-p2,v2))-r; \n}\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float r){//connect 2 points \n vec3 v=p1-p0;v*=clamp(dot(p-p0,v)/dot(v,v),0.0,1.0);return distance(p-p0,v)-r; \n} \nconst vec3 p1=vec3(0.0,-0.15,0.0),p2=vec3(0.0,-0.5,0.05); \nconst vec3 p3=vec3(-0.08,-0.15,0.0),p6=vec3(0.08,-0.15,0.0); \nconst vec3 p9=vec3(-0.05,-0.5,0.05),p12=vec3(0.05,-0.5,0.05),rt=vec3(1.0,0.0,0.0); \nfloat DE(vec3 z){z+=noyz(z*200.0)*0.01; \n z.z+=time*0.1; \n int i=int(floor(z.z)+floor(z.x)); \n z.xz=mod(z.xz,1.0)-vec2(0.5,0.7)+0.25*vec2(sin(float(i))); \n float tim=(time+float(i)),arm=sin(float(i))*0.25;//0.2 \n vec3 p5=vec3(-0.38+abs(arm),arm-0.1-abs(-sin(tim)*0.05),-0.15-cos(tim)*0.1); \n vec3 p8=vec3(0.38-abs(arm),arm-0.1-abs(sin(tim+3.1416)*0.05),-0.15+cos(tim)*0.1); \n vec3 p11=vec3(-0.075,-0.975+max(0.0,cos(tim+3.1416)*0.05),sin(tim)*0.2); \n vec3 p14=vec3(0.075,-0.975+max(0.0,cos(tim)*0.05),-sin(tim)*0.2); \n float d=min(z.y+1.0,min(length(z*vec3(1.5,1.0,1.25))-0.08,Segment(z,p1,p2,0.065))); \n d=min(d,min(Limb2(z,p3,p5,rt,0.21,0.01),Limb2(z,p6,p8,rt,0.21,0.01))); \n d=min(d,min(Limb2(z,p9,p11,-rt,0.27,0.025),Limb2(z,p12,p14,-rt,0.27,0.025)));//-noyz(z*100.0)*0.02; \n return min(d-0.015,0.125); \n} \nvoid mainImage(out vec4 O, in vec2 U){\n  vec3 ro=vec3(0.1,-0.25,-3.0),rd=normalize(vec3((2.0*U.xy-iResolution.xy)/iResolution.y,0.4));\n  time=iTime*6.0; \n  float t=DE(ro)*noyz(vec3(U.xy,iTime)),d,a=0.0; \n  for(int i=0;i<48;i++){ \n    t+=d=DE(ro+t*rd); \n    a+=0.02;\n    if(t>6.0 || d<0.01)break; \n  }\n  t*=1.0/6.0*(noyz(rd*2.0+vec3(0.0,-time,iTime))+noyz(rd*7.3+vec3(0.0,-time*0.3,0.0))); \n  O=vec4(mix(vec3(0.3,0.0,0.3+rd.y*0.5),vec3(0.3,0.9,0.4),(t*t+a)*0.5)*pow(dot(rd,vec3(0.3,0.1,1.0)),3.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 162, 162, 212], [214, 214, 279, 279, 589], [590, 590, 639, 658, 741], [948, 948, 965, 965, 1757], [1759, 1759, 1797, 1797, 2262]], "test": "ok"}
{"id": "wlj3zW", "name": "basic_raytracer_2", "author": "lqt0223", "description": "the phase 2 of raytracer, with additional features such as ray marching, ssao and soft shadow. The noise is due to unoptimized ssao.", "tags": ["raymarching", "ssao", "softshadow"], "likes": 3, "viewed": 172, "published": "Public", "date": "1558715166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float epsilon = 1e-4;\n\nstruct Hit {\n    bool miss;\n    vec3 position;\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct PointLight {\n    vec3 position;\n    float intensity;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct YPlane {\n    float y;\n    float x1;\n    float x2;\n    float z1;\n    float z2;\n    vec3 color;\n};\n\nconst Hit miss = Hit(true, vec3(0.), 1000., vec3(0.), vec3(0.));\n\nvec2 rotate2d(vec2 st, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    mat2 t = mat2(c,-s,s,c);\n    return t*st;\n}\n\nHit sdf_sphere(vec3 p, Sphere sphere) {\n    float d = length(p - sphere.center) - sphere.radius;\n    return Hit(false, p, d, normalize(p - sphere.center), sphere.color);\n}\n\nbool inBound(vec2 p, float x1, float x2, float y1, float y2) {\n    return p.x > x1 && p.x < x2 && p.y > y1 && p.y < y2;\n}\n\nbool inStripX(vec2 p, float x1, float x2) {\n    return p.x > x1 && p.x < x2;\n}\n\nbool inStripZ(vec2 p, float z1, float z2) {\n    return p.y > z1 && p.y < z2;\n}\n\nHit sdf_yplane(vec3 p, YPlane plane) {\n    float d;\n    vec3 hp = p;\n    hp.y = plane.y;\n    if (inBound(p.xz, plane.x1, plane.x2, plane.z1, plane.z2)) {\n        d = abs(p.y - plane.y);\n    } else if (inStripX(p.xz, plane.x1, plane.x2)) {\n        float l1 = length(p.yz - vec2(plane.y, plane.z1));\n        float l2 = length(p.yz - vec2(plane.y, plane.z2));\n        d = min(l1, l2);\n        hp.z = l1 < l2 ? plane.z1 : plane.z2;\n    } else if (inStripZ(p.xz, plane.z1, plane.z2)) {\n        float l1 = length(p.xy - vec2(plane.x1, plane.y));\n        float l2 = length(p.xy - vec2(plane.x2, plane.y));\n        d = min(l1, l2);\n        hp.x = l1 < l2 ? plane.x1 : plane.x2;\n    } else {\n        d = 1000.;\n        float l1 = length(p- vec3(plane.x1, plane.y, plane.z1));\n        if (l1 < d) {\n            hp.x = plane.x1;\n            hp.z = plane.z1;\n            d = l1;\n        }\n        float l2 = length(p- vec3(plane.x2, plane.y, plane.z1));\n        if (l2 < d) {\n            hp.x = plane.x2;\n            hp.z = plane.z1;\n            d = l2;\n        }\n        float l3 = length(p- vec3(plane.x1, plane.y, plane.z2));\n        if (l3 < d) {\n            hp.x = plane.x1;\n            hp.z = plane.z2;\n            d = l3;\n        }\n        float l4 = length(p- vec3(plane.x2, plane.y, plane.z2));\n        if (l4 < d) {\n            hp.x = plane.x2;\n            hp.z = plane.z2;\n            d = l4;\n        }\n    }\n    return Hit(false, hp, d, vec3(0.,1.,0.), plane.color);\n}\n\nHit sdf_scene(vec3 p) {\n    Sphere isphere1 = Sphere(vec3(0.,0.,.0), .4, vec3(1.));\n    Sphere isphere2 = Sphere(vec3(.4,-.2,.4), .2, vec3(1.));\n    Sphere sphere1 = isphere1;\n    Sphere sphere2 = isphere2;\n    sphere2.center.xz = rotate2d(isphere2.center.xz, iTime);\n    YPlane yplane = YPlane(-.4, -1.2,1.2,-1.2,1.2, vec3(1.));\n\n    Hit result = miss;\n\n    Hit sphere1Hit = sdf_sphere(p, sphere1);\n    if (sphere1Hit.dist < result.dist) {\n        result = sphere1Hit;\n    }\n    Hit sphere2Hit = sdf_sphere(p, sphere2);\n    if (sphere2Hit.dist < result.dist) {\n        result = sphere2Hit;\n    }\n    Hit yplaneHit = sdf_yplane(p, yplane);\n    if (yplaneHit.dist < result.dist) {\n        result = yplaneHit;\n    }\n    return result;\n}\n\nHit ray_march_scene(vec3 ro, vec3 rd) {\n    float depth = 0.;\n    Hit hitResult = miss;\n    for (int i = 0; i < 200; i++) {\n        Hit hit = sdf_scene(ro + depth * rd);\n        if (hit.dist < epsilon) {\n            hitResult = hit;\n            return hitResult;\n        }\n        depth += hit.dist;\n        if (depth >= 100.) {\n            return miss;\n        }\n    }\n    return miss;\n}\n\nconst float k = 8.;\n\nfloat softshadow(vec3 ro ,vec3 rd) {\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0;i < 200;i++) {\n        float h = sdf_scene(ro + t * rd).dist;\n        if (h < epsilon) {\n            return 0.0;\n        }\n        res = min(res, k*((h)/t));\n        t += h;\n        if (t >= 100.) {\n            return res;\n        }\n    }\n    return res;\n}\n\nvec3 random3d(vec3 p){\n    p = vec3(\n        dot(p,vec3(127.1,311.7, 456.1)),\n        dot(p,vec3(269.5,183.3, 823.2)),\n        dot(p,vec3(329.5,83.3, 513.2))\n    );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat ssao(Hit p) {\n    p.position += 2. * epsilon * p.normal;\n    float result = 0.;\n    for (int i = -1; i <= 0; i++) {\n        for (int j = -1; j <= 0; j++) {\n            for (int k = -1; k <= 0; k++) {\n                vec3 disp = p.position + vec3(float(i), float(j), float(k));\n                vec3 rv = random3d(disp);\n                rv = normalize(rv);\n                disp = p.position + .1*rv;\n                Hit h = sdf_scene(disp);\n                if (h.dist < 0.0125) {\n                    result += 0.02;\n                }\n            }\n        }\n    }\n    return result;\n}\n\nconst PointLight light = PointLight(vec3(5.), .8);\nconst vec3 ambient_c = vec3(.5);\n\nvec3 calcColor(Hit h, PointLight light, vec3 camera) {\n    vec3 light_pos = normalize(light.position - h.position);\n    vec3 camera_pos = normalize(camera - h.position);\n\n    vec3 ambient = ambient_c * h.color;\n\n    float diff = clamp(dot(light_pos, h.normal), 0.,1.);\n    vec3 diffuse = diff * h.color;\n\n    vec3 refl = reflect(-light_pos, h.normal);\n    float spec = pow(max(dot(refl, camera_pos), .0), 64.);\n    vec3 specular = spec * h.color;\n\n    vec3 color = ambient + .1*diffuse + specular;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 st = vec3(gl_FragCoord.xy / iResolution.xy, 0.);\n    st = st * 2.-1.;\n    st.z = 0.;\n    st.x*=iResolution.x/iResolution.y;\n    st.xz = rotate2d(st.xz, iTime*.15);\n\n    vec3 camera = vec3(0,0,-2.);\n    camera.xz = rotate2d(camera.xz, iTime*.15);\n    vec3 ray = st-camera;\n    ray = normalize(ray);\n\n    Hit sceneHit = ray_march_scene(camera, ray);\n    vec3 light_pos = normalize(light.position - sceneHit.position);\n    vec3 hitColor = calcColor(sceneHit, light, camera);\n    // remember when ray tracing again from hit point, the start point needs to be biased\n    if (!sceneHit.miss) {\n        vec3 reflLight = reflect(ray, sceneHit.normal);\n        Hit reflectHit = ray_march_scene(sceneHit.position + 2.*epsilon * sceneHit.normal, reflLight);\n        vec3 reflColor = calcColor(reflectHit, light, camera);\n        hitColor += .1 * reflColor;\n\n        float shadow = softshadow(sceneHit.position - 2.*epsilon*sceneHit.normal, light_pos);\n        shadow = shadow - 1.;\n        shadow = shadow / 8.;\n        hitColor += shadow;\n\n        float ao = ssao(sceneHit);\n        hitColor -= ao;\n        fragColor = vec4(hitColor,1.);\n    } else {\n        fragColor = vec4(vec3(.4),1.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlj3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 468, 468, 560], [562, 562, 601, 601, 733], [735, 735, 797, 797, 856], [858, 858, 901, 901, 936], [938, 938, 981, 981, 1016], [1018, 1018, 1056, 1056, 2486], [2488, 2488, 2511, 2511, 3222], [3224, 3224, 3263, 3263, 3612], [3635, 3635, 3671, 3671, 3987], [3989, 3989, 4011, 4011, 4206], [4208, 4208, 4227, 4227, 4796], [4883, 4883, 4937, 4937, 5400], [5402, 5402, 5457, 5457, 6654]], "test": "ok"}
{"id": "wljGzD", "name": "[0001] mirror spheres", "author": "Meow8p", "description": "[0001] mirror spheres", "tags": ["raymarching", "sphere", "mirror", "reflect"], "likes": 4, "viewed": 100, "published": "Public", "date": "1558731786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS (128)\n#define MAX_DIST (100.0)\n#define SURFACE_DIST (0.001)\n   \nint mat=0;\n   \nvec2 rotate(vec2 p, float a)\n{\n   float s=sin(a);\n   float c=cos(a);\n   mat2 r=mat2(c, -s, s, c);\n   return p*r;\n}\n\nfloat sphereDist(vec3 p, vec3 origin, float radius)\n{\n   return length(p-origin)-radius;\n}\n\nfloat planeDist(vec3 p, float position)\n{\n   return p.y-position;\n}\n   \nfloat sceneDistance(vec3 p)\n{\n   float s1=sphereDist(p, vec3(0.0, 0.5, 0.0), 0.2);\n   if(s1<SURFACE_DIST)\n   {\n      mat=1;\n   }\n   float p1=planeDist(p, 0.0);\n   if(p1<SURFACE_DIST)\n   {\n      mat=2;\n   }\n   p.xz=rotate(p.xz, iTime);\n   float s2=sphereDist(p, vec3(1.0, 0.5, 0.0), 0.2);\n   if(s2<SURFACE_DIST)\n   {\n      mat=3;\n   }\n   return min(p1, min(s1, s2));\n}\n\nvec3 normalAt(vec3 p)\n{\n   float dist=sceneDistance(p);\n   vec2 epsilon=vec2(0.01,0.0);\n   return normalize(vec3(dist-sceneDistance(p-epsilon.xyy), \n                         dist-sceneDistance(p-epsilon.yxy),\n                         dist-sceneDistance(p-epsilon.yyx)));\n}\n   \nfloat lightAt(vec3 p)\n{\n   vec3 lightPosition=vec3(0.0,2.0,0.0);\n   vec3 n=normalAt(p);\n   vec3 lightDirection=normalize(lightPosition-p);\n   \n   float diffuse=clamp(dot(n, lightDirection), 0.0, 1.0);\n   return diffuse;\n}\n\nvec3 pixelColor(vec2 uv)\n{\n   vec3 direction=normalize(vec3(uv,1.0));\n   vec3 color=vec3(0.0,0.0,0.0);\n   float distance=0.0;\n   vec3 camera=vec3(0.0,0.5,-0.5);\n   float sceneDist=0.0;\n   vec3 p;\n   int reflectCount=0;\n   \n   for(int i=0;i<MAX_STEPS;i++)\n   {\n      p=camera+distance*direction;\n      sceneDist=sceneDistance(p);\n      distance+=sceneDist;\n      if(distance>=MAX_DIST)\n      {\n         break;\n      }\n      if(sceneDist<=SURFACE_DIST)\n      {\n         if(reflectCount<=1)\n         {\n            color=vec3(lightAt(p));         \n            vec3 n=normalAt(p);\n            distance=0.0;\n            direction=reflect(direction,n);\n            camera=p+direction/2.0;\n            reflectCount++;\n         }\n         else\n         {\n            break;\n         }\n      }\n   }\n   \n   if(sceneDist<=SURFACE_DIST)\n   {\n      color=vec3(lightAt(p));\n   }\n   \n   if(mat==1)\n   {\n      color*=vec3(1.0,0.0,0.0);\n   }\n   else if(mat==2)\n   {\n      color*=vec3(0.0,1.0,0.0);\n   }\n   else if(mat==3)\n   {\n      color*=vec3(0.0,0.0,1.0);\n   }\n   \n   return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    fragColor = vec4(pixelColor(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 127, 127, 211], [213, 213, 266, 266, 303], [305, 305, 346, 346, 372], [377, 377, 406, 406, 744], [746, 746, 769, 769, 1018], [1023, 1023, 1046, 1046, 1244], [1246, 1246, 1272, 1272, 2314], [2317, 2317, 2374, 2374, 2477]], "test": "ok"}
{"id": "WljGzW", "name": "Circle animation 2D", "author": "Gallo", "description": "Circle animation", "tags": ["2d"], "likes": 3, "viewed": 161, "published": "Public", "date": "1558654842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat ci(vec2 _st, float _radius, float _start, float _end, float _div)\n{\n    vec2 dist = _st-vec2(0.5);\n    float lAngle = _start + atan(dist.y, dist.x);\n    float lDivision = M_PI / _div;\n    float lMod = mod(lAngle, lDivision);\n    float lCuts = (_div > -1.0) ? ( smoothstep(lDivision, lDivision - 0.02, lMod) * \n                          smoothstep(_end - 0.02, _end, lMod)) : 1.0;\n    \n\treturn 1.-smoothstep(- 0.001 + _radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0)*lCuts; //smoothstep(0.48, 0.5, lMod)\n}\n\nfloat mandala(vec2 uv, float time)\n{\n    return ( ci(uv, 0.85 + sin(iTime * 2.0) * 0.05, -1.42 - time, 0.6, 3.0f) - \n            ci(uv, 0.65 + sin(iTime * 2.0) * 0.05, -1.42 - time, 0.6, 3.0f)) +\n\n        ( ci(uv, 0.7 + 0.05 + cos(time * 2.0) * 0.05, 0.2 - time, 0.7, 3.0f) - \n         ci(uv, 0.55 + 0.05 + cos(time * 2.0) * 0.05, 0.2 - time, 0.7, 3.0f)) +\n        ( ci(uv, 0.5, 0.0 + time, 0.3, 3.0f) - \n         ci(uv, 0.3, 0.0 + time, 0.3, 3.0f)) -\n        ( ci(uv, 0.46, 0.0 + time, 0.3, 3.0f) - \n         ci(uv, 0.34, 0.0 + time, 0.3, 3.0f)) +\n\n        ( ci(uv, 0.44, 0.0 - time * 0.5, 0.05, 26.0f) - \n         ci(uv, 0.36, 0.0 - time * 0.5, 0.05, 26.0f)) +\n\n        ( ci(uv, 0.25, 0.0 - time * 2.5, 0.5, 3.0f) - \n         ci(uv, 0.15, 0.0 - time * 2.5, 0.5, 3.0f)) +\n        ( ci(uv, 0.12, 0.3 + time * 1.5, 0.2, 8.0f) - \n         ci(uv, 0.07, 0.3 + time * 1.5, 0.2, 8.0f)) +\n        ( ci(uv, 0.05, 0.3 - time * 1.1, 0.4, 3.0f) - \n         ci(uv, 0.025, 0.3 - time * 1.1, 0.4, 3.0f)) +\n        ( ci(uv, 0.015, 0.5 + time * 3.1, 1.8, 1.0f) - \n         ci(uv, 0.0075, 0.5 + time * 3.1, 1.8, 1.0f));\n}\n\n/*\nfloat por(in vec2 _st, in float _radius, in float _start, in float _end)\n{\n    vec2 dist = _st-vec2(0.5);\n \n\treturn 1.-smoothstep(- 0.001 + _radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy - vec2(0.4, 0.0);\n    \n    // Time varying pixel color\n    float lCircles = mandala(uv, iTime);\n        ;\n    vec3 col = vec3(lCircles);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 121, 121, 627], [629, 629, 665, 665, 1733], [1735, 2002, 2059, 2109, 2343]], "test": "ok"}
{"id": "Wll3Df", "name": "Simple rainbow sound viz", "author": "avin", "description": "Colors + Soundviz\nTrack: https://soundcloud.com/bakeyofficial/bakey-bezdelnik-prod-kipah", "tags": ["colors", "soundviz"], "likes": 9, "viewed": 1084, "published": "Public API", "date": "1557928908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n#define BLACK_COL vec3(32,43,51)/255.\n\nfloat line(vec2 p,vec2 size){\n\tfloat mask = \n        smoothstep(size.x, size.x-.1, abs(p.x)) * \n        smoothstep(size.y, size.y-.1, abs(p.y));\n    \n    return smoothstep(.45, .5, mask);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 aRatio = vec2(30., 1.);\n    vec2 guv = uv * aRatio;    \n    vec2 id = floor(guv);\n    guv = fract(guv);\n    guv -= .5;\n    \n    vec2 muzUV = floor(uv * aRatio) / aRatio;\n    vec4 muz = texture(iChannel0, muzUV * .5);\n    muz.x +=  (sin(iTime + id.x*.25)*.5+.5)*.25;\n    vec2 size = vec2(0.75, muz.x*.3 + .05);\n    \n    vec2 sf = aRatio * .025;\n    float mask = \n        smoothstep(size.x, size.x-sf.x, abs(guv.x)) * \n        smoothstep(size.y, size.y-sf.y, abs(guv.y));\n        \n    float m = smoothstep(.25, .5, mask);         \n    \n    vec3 col = hue(fract(size.y*5. + iTime*.05)).rgb;        \n    \n    col = mix(BLACK_COL, col, m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4lsGzB", "previewfilepath": "https://soundcloud.com/bakeyofficial/bakey-bezdelnik-prod-kipah", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bakeyofficial/bakey-bezdelnik-prod-kipah", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 148, 148, 312], [314, 314, 371, 371, 1101]], "test": "error"}
{"id": "wll3DN", "name": "AVAVAVAV", "author": "lennyjpg", "description": "asdfasdfasdf", "tags": ["asdfasdfa"], "likes": 2, "viewed": 262, "published": "Public API", "date": "1558202984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 p, vec2 res){\n    p = mod(p,res.y);\n    float d = length(p-res.y*.5);\n    return smoothstep(d,d+1.5/iResolution.y, res.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 res = vec2(.05,0.1);\n    vec2 u = uv;\n    u.x +=  mod( u.y, res.x);\n    u.x -=u.y;\n    u.x+=iTime*0.1;    \n    res.x+=uv.y * -0.04;\n    fragColor = vec4(grid(u,res));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wll3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 140], [142, 142, 199, 199, 416]], "test": "ok"}
{"id": "Wll3WB", "name": "Discrepancy logo", "author": "z0rg", "description": "Test", "tags": ["retrowave"], "likes": 3, "viewed": 135, "published": "Public API", "date": "1557501758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float cMin = 0.05;\nconst float cMax = 0.07;\nfloat thick = cMax - cMin;\nvec3 colTypo = vec3(0.191, 0.387, 0.734)*1.2;\nvec3 colA = vec3(151.0,95.0,180.0)/255.0*1.6;\nvec3 colB = vec3(240.0,149.0,55.0)/255.0*1.6;\nvec3 black = vec3(0.0);\nvec3 flareCol = vec3(0.123, 0.234, 0.789)*0.5;\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat sat(float a)\n{\n    return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n    return vec3(sat(v.x), sat(v.y), sat(v.z));\n}\n\nbool inRange(float a, float mi, float ma)\n{\n  return a > mi && a < ma;\n}\n\nfloat lengthNY(vec2 v)\n{\n  return abs(v.x) + abs(v.y);\n}\n\nfloat drawD(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(inRange(uv.y, -cMax, cMax) && inRange(uv.x,-thick*2.0, -thick));\n  float val2 = float(inRange(length(uv), cMin, cMax) && uv.x > 0.0);\n  return val + val2;\n}\n\nfloat drawY(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float valA = float(inRange(length(uv+vec2(0.0, -cMax)), cMin, cMax) && uv.y < cMax && !inRange(uv.x, -thick, thick));\n  float valB = float(inRange(uv.x, -thick*0.5,thick*0.5) && inRange(uv.y, -cMax, 0.0));\n  return valA +valB;\n}\n\nfloat drawN(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(inRange(length(uv), cMin, cMax) && uv.y > 0.0);\n  float valB = float(inRange(uv.y, -cMax, 0.0) && (inRange(uv.x, -cMax, -cMin) || inRange(uv.x, cMin, cMax)));\n  return val+valB;\n}\n\nfloat drawI(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  return float(inRange(uv.y, -cMax, cMax) && inRange(uv.x, -thick*0.5,thick*0.5));\n}\n\nfloat drawS(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n//  float ref = float(inRange(length(uv), cMin, cMax));\n  float valA = float(inRange(length(uv), cMin, cMax) && !inRange(uv.y, -thick, thick));\n  float valB = float(inRange(-uv.y - uv.x*0.4, -thick*0.5, thick*0.5) &&\n    length(uv) < cMax);\n  return valA + valB;\n}\n\n\nfloat drawC(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = inRange(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !inRange(uv.y, -thick, thick) ||\n    uv.x <= 0.0 && onCir);\n\n  return valA;\n}\n\n\nfloat drawP(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(inRange(uv.y, -cMax, cMax) && inRange(uv.x,-thick*2.0, -thick));\n  float val2 = float(inRange(length(uv+vec2(0.0, -0.02)), cMin - thick, cMin) && uv.x > 0.0);\n\n  return val + val2;\n}\n\nfloat drawR(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  float val = float(inRange(uv.y, -cMax, cMax) && inRange(uv.x,-thick*2.0, -thick));\n  float val2 = float(inRange(length(uv+vec2(0.0, -0.02)), cMin - thick, cMin) && uv.x > 0.0);\n  uv -= vec2(0.0, -0.02);\n  float  val3 = float(inRange(-uv.y-uv.x, -thick*0.5,thick*0.5) &&\n    inRange(uv.y, -0.05, -0.02));\n  return val + val2 + val3;\n}\n\nfloat drawE(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = inRange(length(uv), cMin, cMax);\n  float valA = float(onCir && uv.x > 0.0 && !inRange(uv.y, -thick, thick) ||\n    uv.x <= 0.0 && onCir);\n  float valB = float(inRange(uv.y, -thick*0.5, thick*0.5) &&\n    inRange(uv.x, -cMin + thick*0.5, cMin - thick*0.5));\n  return valA+valB;\n}\n\nfloat drawA(vec2 uv, vec2 pos, float scale)\n{\n  uv = (uv - pos)*(1.0/scale);\n  bool onCir = inRange(length(uv), cMin, cMax);\n  float valA = float((onCir && uv.x > 0.0 && !inRange(uv.y, -thick, thick) ||\n    uv.x <= 0.0 && onCir) && uv.y > 0.0);\n  float valB = float(inRange(uv.y, -thick*0.5, thick*0.5) &&\n    inRange(uv.x, -cMin + thick*0.5, cMin - thick*0.5));\n  float valC = float(inRange(uv.x, -cMax, -cMin) && inRange(uv.y, -cMax, 0.0));\n  float valD = float(inRange(uv.x, cMin, cMax) && inRange(uv.y, -cMax, -thick));\n  return valA+valB+valC+valD;\n}\n\nvec3 drawTxt(vec2 uv, vec2 pos)\n{\n  float scale =0.9;\n  float res;\n  float offX = -0.25;\n  float sp =3.3;\n\n  uv.y *= (sin(10.0*uv.x+iTime)+1.5)*0.5;\n\n  res += drawD(uv, pos+vec2(sp*-0.1+offX,0.0), scale);\n  res += drawI(uv, pos+vec2(sp*-0.07+offX,0.0), scale);\n  res += drawS(uv, pos+vec2(sp*-0.04+offX,0.0), scale);\n  res += drawC(uv, pos+vec2(offX,0.0), scale);\n  res += drawR(uv, pos+vec2(sp*0.037+offX,0.0), scale);\n  res += drawE(uv, pos+vec2(sp*0.075+offX,0.0), scale);\n  res += drawP(uv, pos+vec2(sp*0.11+offX,0.0), scale);\n  res += drawA(uv, pos+vec2(sp*0.15+offX,0.0), scale);\n  res += drawN(uv, pos+vec2(sp*0.195+offX,0.0), scale);\n  res += drawC(uv, pos+vec2(sp*0.235+offX,0.0), scale);\n  res += drawY(uv, pos+vec2(sp*0.275+offX,0.0), scale);\n\n  return vec3(clamp(res,0.0,1.0));\n}\n\nvec3 drawTxtChroma(vec2 uv, vec2 pos)\n{\n  float spread= 0.0005;\n  vec2 dir=vec2(1.0,0.0);\n  vec3 col;\n  col.r = drawTxt(uv+dir*spread, pos).r;\n  col.g = drawTxt(uv, pos).g;\n  col.b = drawTxt(uv-dir*spread, pos).b;\n  return sat(col)+rand(.1*uv+vec2(iTime,.0))*.7;\n}\n\n\nvec3 renderBack(vec2 uv, float uvYO)\n{\n  if (length(uv) > 0.4)\n     return black;\n  vec3 grad = mix(colA, colB, uvYO);\n\n  float val = 0.005*pow(1.0-uvYO,2.0)+(sin(iTime+uv.x*10.0)+1.0)*0.0001;\n  float modV = val *2.0;\n  float coefGrnd = float(uv.y > 0.0) + uv.y+float(uv.y < 0.0 && mod(uv.y, modV)<val);\n  return sat(mix(mix(grad, black,0.1-uv.y*4.0), grad, coefGrnd));\n}\n\nvec3 render(vec2 uv, float uvYO)\n{\n  return renderBack(uv, uvYO);\n}\n\nvec3 rdr(vec2 uv, float buUvY)\n{\n  vec3 col = render(uv, buUvY);\n  col=max(col, vec3(0.0));\n  int samples = 2;\n  vec3 acc;\n\n  for (int i=0;i < samples;++i)\n  {\n    float iF = float(i - samples/2);\n    iF /= float(samples/2);\n    vec2 off = (.2*vec2(rand(uv),rand(uv.yx))-0.5)*0.01;\n   iF = (1.0-iF)*(length(off)+0.4);\n    acc+=render(uv+off, buUvY)*iF;\n\n  }\n  return col+acc;\n}\n\nvec3 rdrChroma(vec2 uv, float uvY)\n{\n  vec3 col;\n  float sa = sin(iTime*13.0);\n  float sb = sin(iTime*13.0+0.1);\n  float beat = (sa > sb ? 1.0 : 0.0)*(sa+1.0);\n  float spread= 0.01*beat;\n  vec2 dir=vec2(1.0,0.0);\n  col.r = rdr(uv+dir*spread, uvY).r;\n  col.g = rdr(uv, uvY).g;\n  col.b = rdr(uv-dir*spread, uvY).b;\n  return col;\n}\n\nvec3 rdrDiscrepancy(vec2 uv)\n{\n  vec3 col = drawTxtChroma(uv, vec2(0.0))*colTypo;\n  if (col.r>0.1)\n    return col;\n  return vec3(0.0);\n}\n\nvec3 rdrFlare(vec2 uv)\n{\n  float ln = lengthNY(vec2(uv.x+sin(iTime*0.5)*5.0,uv.y));\n  float flare = (1.0-(ln / 3.0));\n\n  float flareB = 1.0-(pow(ln,2.0)/2.0);\n  return flareCol* flare+max(flareB,0.0)*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float buUvY = uv.y;\n\n  float ratio = iResolution.x / iResolution.y;\n  uv.x *= ratio;\n  uv -= vec2(0.5 * ratio, 0.5);\n\n  vec3 outCol = rdrChroma(uv, buUvY);\n\n  vec3 discCol = rdrDiscrepancy(uv);\n\n  if(true)//discCol.r > 0.05)\n  {\n    float ld = length(discCol);\n    if (uv.y < 0.0 && mod(uv.y,0.005) < 0.0025)\n      discCol = black;\n    outCol = mix(outCol, discCol, ld);\n\n  }\n  outCol += rdrFlare(uv) + flareCol.zyy*pow(1.-length(uv*0.2),5.)*2.;\n  fragColor = vec4(outCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3WB.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[684, 684, 704, 704, 772], [774, 774, 794, 794, 823], [824, 824, 842, 842, 891], [893, 893, 936, 936, 965], [967, 967, 991, 991, 1023], [1025, 1025, 1070, 1070, 1278], [1280, 1280, 1325, 1325, 1587], [1589, 1589, 1634, 1634, 1865], [1867, 1867, 1912, 1912, 2028], [2030, 2030, 2075, 2075, 2371], [2374, 2374, 2419, 2419, 2620], [2623, 2623, 2668, 2668, 2902], [2904, 2904, 2949, 2949, 3316], [3318, 3318, 3363, 3363, 3686], [3688, 3688, 3733, 3733, 4243], [4245, 4245, 4278, 4278, 5036], [5038, 5038, 5077, 5077, 5302], [5305, 5305, 5343, 5343, 5676], [5678, 5678, 5712, 5712, 5745], [5747, 5747, 5779, 5779, 6124], [6126, 6126, 6162, 6162, 6454], [6456, 6456, 6486, 6486, 6592], [6594, 6594, 6618, 6618, 6800], [6802, 6802, 6859, 6859, 7385]], "test": "ok"}
{"id": "Wll3Wl", "name": "uiuiuiuiuiui", "author": "lennyjpg", "description": "nonononononono", "tags": ["2d", "spiral", "circle", "loop", "mono"], "likes": 5, "viewed": 413, "published": "Public API", "date": "1558057023", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 pos, float radius){\n    float dx = 1./iResolution.y;\n    return clamp(.5*(radius - length(pos)+dx) / dx, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 u = uv;\n    u.x*=iResolution.x/iResolution.y;\n    float k = 1.;\n    for(float i = 1.; i < 40.; i++){\n        float a = .1*i*iTime;\n        u += vec2(sin(a),cos(a))*.05;\n        k += circle(u, 2.0 - 0.05*i);\n    } \n    fragColor = vec4(1.-abs(1.-mod( k, 2.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 133], [135, 135, 192, 192, 509]], "test": "ok"}
{"id": "wll3z2", "name": "Wobbly Jellyland", "author": "MrsBeanbag", "description": "Wibbly wobbly, jelly on an infinite plate lmaoooo", "tags": ["raymarching", "implicitsurface"], "likes": 1, "viewed": 326, "published": "Public API", "date": "1557002798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment this line to get mouse control rofl\n//#define MOUSE_CONTROL\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.002;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\n\nconst vec3 sky_colour = vec3(0.2, 0.1, 0.4);\nconst vec3 clouds_colour = vec3(1.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 30.0, 30.0 ));\n\n\nvec4 dist_sin(vec3 p, vec2 k, float a, float t) {\n    float kx = dot(k, p.xz) + t;\n    float d = a * sin(kx);\n    vec2 g = k * (a * cos(kx));\n    return vec4(g.x, 0.0, g.y, d);\n}\n\nvec4 sea(vec3 p) {\n\n    diffuse_colour = vec3(1.0, 0.7, 0.2);\n    vec4 h = vec4(0.0);\n    h += dist_sin(p, vec2(0.112, 0.215), 2.0, iTime * 0.23);\n    h += dist_sin(p, vec2(-0.163, 0.243), 1.7, iTime * 1.8);\n    h += dist_sin(p, vec2(-0.378, -0.317), 1.0, iTime * 2.1);\n    h += dist_sin(p, vec2(0.433, -0.451), 1.8, iTime * 3.6);\n    \n    h.w += p.y;\n    h.y = 1.0;\n    \n    // technique from\n    // http://www.iquilezles.org/www/articles/distance/distance.htm\n    h.w /= length(h.xyz);\n\n    return h;\n}\n\nfloat dist_field(vec3 p) {\n    return sea(p).w;\n}\n\nvec3 skybox(vec3 dir) {\n    float horizon = smoothstep(0.0, 0.25, dir.y);\n    float cloud = mix(0.8, 0.0, horizon);\n    return mix(sky_colour, clouds_colour, cloud);\n}\n\nvec3 gradient(vec3 p) {\n    return sea(p).xyz;\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\tfloat shininess = 80.0;\n\t\n\tvec3 ref = reflect( dir, n );\n\tfloat specular = max( 0.0, dot( sun_pos, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn final_diff_colour * diffuse + vec3(specular);\n}\n\n// ray marching\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n\n    // give the ray a bit of a head start by jumping\n    // straight to the upper bounding plane!\n    float t = 0.0;\n\n    vec3 v;\n    for (int i = 0; i < max_iterations; i++) {\n       \tfloat d = dist_field(v = o + dir * t);\n\n        if (abs(d) <= min_dist) {\n            break;\n        }\n        // sometimes it seems to overestimate the distance,\n        // so i put this fudge factor in, rofl\n\t\tif ((t+=d*0.8) >= clip_far) {\n            return skybox(dir);\n\t    }\n    }\n\tfinal_diff_colour = diffuse_colour;\n    \n    vec3 n = normalize( gradient(v) );\n\n    if (dot(n, sun_pos) < 0.0) {\n        return colour;\n    }\n\n    // shadows\n    t = 0.1;\n    for (int i = 0; i < max_iterations; i++) {\n        vec3 r = v + sun_pos * t;\n\t\tif (r.y > 6.5) {\n\t\t    colour += shading( v, n, dir, o );\n            break;\n\t    }\n\n        float d = dist_field(r);\n        if (d <= min_dist) {\n            break;\n        }\n        t+=d;\n    }\n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nconst vec2 spin = vec2(0.005, 0.0041);\nconst float radius = 120.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n#ifdef MOUSE_CONTROL\n\tmat3 rot = rotationXY( vec2(PI, -PI) * ((iMouse.xy - iResolution.xy)/iResolution.xy).yx );\n#else\n\tmat3 rot = rotationXY( vec2( -0.5, iTime * 0.1 ) );\n#endif\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 0.0 );\n\teye = rot * eye;\n    eye.y += 20.0;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n    fragColor = vec4(color, 1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wll3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 555, 555, 684], [686, 686, 704, 704, 1190], [1192, 1192, 1218, 1218, 1241], [1243, 1243, 1266, 1266, 1410], [1412, 1412, 1435, 1435, 1460], [1462, 1487, 1539, 1539, 1799], [1801, 1817, 1854, 1854, 2860], [2862, 2883, 2931, 2931, 3105], [3107, 3139, 3170, 3170, 3325], [3394, 3394, 3451, 3469, 3919]], "test": "error"}
{"id": "Wll3zB", "name": "voronoia3", "author": "benhardy", "description": "not bad ehh?", "tags": ["voronoa"], "likes": 3, "viewed": 139, "published": "Public", "date": "1556835528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Ray marching parameters\n */\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define EPSILON 0.01\n#define STEP_RATIO 0.5\n\n#define AA_STEP 1\n#define AA_DIV  1.0\n\n/**\n * For x, return something random-looking.\n */\nfloat pseudorandom(float x) {\n    return fract(10000.0 * sin(x * 12345.0));\n}\n\n/**\n * Where's the center of this cell?\n */\nvec2 cellpoint(ivec2 pos) {\n    float id = float(pos.y*47 + pos.x);\n    float ang = iTime* (0.1 + pseudorandom(id));\n    return vec2(\n        0.5 + 0.35 * cos(ang),\n        0.5 + 0.35 * sin(ang)\n    );\n}\n\n/**\n * Give each cell in the grid its own height.\n */\nfloat cellheight(ivec2 pos) {\n    float id = float(pos.y*47 + pos.x);\n    return 0.5*sin(iTime+6.2*pseudorandom(id));\n}\n\n/**\n * Calculate distance to voronai cell border for a plane position.\n * Also return the cell height. Each one has a different height.\n */\nvec2 voronai(vec2 pos) {\n    ivec2 address = ivec2(floor( pos ));\n    vec2  f = fract( pos );\n    float best_dist = 10.0;\n    ivec2 closest_cell;\n    vec2 closest_center;\n    for (int i = -2; i < 2; i++) {\n\t    for (int j = -2; j < 2; j++) {\n            ivec2 delta = ivec2(i, j);\n            ivec2 cell = address + delta;\n            vec2 cp = cellpoint(cell) + vec2(delta) -f;\n        \tfloat d = dot(cp, cp);\n            if (d < best_dist) {\n            \tbest_dist = d;\n                closest_cell = delta;\n                closest_center = cp;\n            }\n        }\n    }\n    float res = 10.0;\n    for (int i = -2; i < 2; i++) {\n\t    for (int j = -2; j < 2; j++) {\n\n            ivec2 b = closest_cell + ivec2( i, j );\n            vec2  other_center = vec2( b ) + cellpoint( address + b ) - f;\n            float d = dot( \n                0.5*(closest_center+other_center), \n                normalize(other_center-closest_center)\n            );\n            if (d > 0.0) {\n\t            res = min(res, d);\n            }\n        }\n    }\n    return vec2(res, cellheight(closest_cell + address));\n}\n\n/**\n * Blended union\n */\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n/**\n * Blended intersection\n */\nfloat blend_int( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return max( a, b ) + h*h*0.25/k;\n}\n\n#define OBJECT_ID_FLOOR 1\n\n/**\n * Measure the distance to objects in the scene\n * return the distance to the nearest object and its object id\n */\nvec2 measure(vec3 where) {\n    vec2 zoomed = where.xz;\n    vec2 vores = voronai(zoomed);\n    float vd = -(vores.x - 0.00);\n    float d= blend_int(vd, where.y + vores.y*0.3, 0.2);\n    return vec2(d, OBJECT_ID_FLOOR);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvec3 trace(vec2 pixel) {\n    vec3 eye = vec3(0,10,-10);\n    vec3 look = vec3(0,-1,1);\n    vec3 up = vec3(0,1,0);\n    vec3 right = vec3(1,0,0);\n    \n    vec3 actual_up = cross(look, right);\n    vec3 ray = normalize(look + pixel.x * right + pixel.y * actual_up);\n    \n    vec2 current;\n    float total_dist = 0.0;\n    int who;\n    vec3 where = eye;\n    for(int steps = 0; steps < MAX_STEPS; steps++) {\n        \n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n    vec3 color = vec3(0,0,0);\n    if (who == OBJECT_ID_FLOOR) {\n\t\tcolor = vec3(0.8, 0.7, 0.6) * (1.0+vec3(where.y));\n        vec3 to_light = normalize(vec3(-5,15,-10));\n    \t//float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    \tvec3 surface_normal = calc_surface_normal(where);\n    \tfloat dotty = dot(to_light, surface_normal);\n\t\tcolor *= dotty;\n        vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    \tvec3 toEye = normalize(-ray);\n\t\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n        color += vec3(specular);\n\n    }\n    return clamp(color, 0.0, 1.0);\n}\nvec2 pixelToLocal(vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.y = uv.y * iResolution.y / iResolution.x;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0,0,0);\n    for (int dy = 0; dy < AA_STEP; dy++) {\n        \n\t    for (int dx = 0; dx < AA_STEP; dx++) {\n        \tvec2 delta = vec2(float(dx)/AA_DIV, float(dy)/AA_DIV);\n\t\t    vec2 uv = pixelToLocal(fragCoord+delta);\n                \n\t\t\tcol += trace(uv);\n        }\n    }\n    fragColor = vec4(col / (AA_DIV*AA_DIV), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 215, 244, 244, 292], [294, 338, 365, 365, 541], [543, 597, 626, 626, 716], [718, 858, 882, 882, 1954], [1956, 1981, 2023, 2023, 2100], [2102, 2134, 2180, 2180, 2257], [2286, 2405, 2431, 2431, 2622], [2652, 2652, 2688, 2688, 3030], [3032, 3032, 3056, 3056, 4379], [4380, 4380, 4415, 4465, 4577], [4579, 4579, 4636, 4636, 4977]], "test": "timeout"}
{"id": "wllGD2", "name": "Spinning dots", "author": "theepicsnail", "description": "spinning dots", "tags": ["spinningdots"], "likes": 6, "viewed": 123, "published": "Public", "date": "1557774413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.141592\n#define TAU 6.283184\n\n\nvec2 cs(float a){\n    return vec2(cos(a),sin(a));\n}\n\nvec2 rot(vec2 v, float a) {\n    vec2 c = cs(a);\n    return v * mat2x2(c.x, -c.y, c.y, c.x);\n}\n\nvec2 sp(float t){\n    return vec2(floor(t), fract(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfragColor.b=0.;\n    for(float i = 0. ; i < 6. ; i++) {\n\t    vec2 t = sp(iTime*.15 - i*.1);\n\t    vec4 c = vec4(\n\t        rand(vec2(t.x, i+0.))*2.0-1.0,\n\t        rand(vec2(t.x, i+1.))*2.0-1.0,\n\t        rand(vec2(t.x, i+2.))*0.5+0.5,\n            rand(vec2(t.x, i+3.))*2.0-1.0\n\t    );\n\t    \n        c.w = mod(t.x, 2.)*2.-1.;\n\t    \n\t    uv -= c.xy;\n        if(length(uv)<c.z) {\n\t        uv = rot(uv, smoothstep(0.,1.,t.y)*TAU*sign(c.w));\n        } else if(length(uv)<c.z+.01) {\n            fragColor.b+=sin(t.y*PI);\n        }\n        uv += c.xy;\n    }\n    \n    \n    fragColor.g =1.0-20.*rand(floor(uv*150.0));\n    fragColor = max(fragColor, vec4(fragColor.g));\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 61, 61, 95], [97, 97, 124, 124, 190], [192, 192, 209, 209, 248], [250, 250, 270, 270, 340], [351, 351, 408, 408, 1138]], "test": "ok"}
{"id": "wllGDs", "name": "hazyrect", "author": "Del", "description": "hazy", "tags": ["sin", "hazy"], "likes": 2, "viewed": 286, "published": "Public API", "date": "1558141170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = 3.0-length(3.0*pos*pos)*4.0;\n    pos*=rot(pos.x*5.0+iTime*0.6+log(d));\n    //pos*=0.5;\n    pos+=vec2(0.5);\n\tfloat vv = (pos.y*pos.y+pos.x*d*d*1.61);\n\tvv+=sin(pos.x*12.14);\n\tfloat v = sin(sin(pos.x*2.6)*1.0+(vv) * 0.5 + iTime * 2.0);\n\tfragColor = vec4( v*1.44, .05+0.3*v, 0.0, 1.0 )*d;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 89], [91, 91, 148, 148, 524]], "test": "ok"}
{"id": "wllGRf", "name": "Smooth minimum on color and dist", "author": "MacSlow", "description": "An interesting result from playing around with smooth minimum variation applied to distance and color.", "tags": ["3d", "sdf", "ao", "smooth", "pbr", "minimum"], "likes": 11, "viewed": 490, "published": "Public API", "date": "1557184034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Smooth minimum on color and distance - An interesting result from messing\n// around with smin().\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER    = 96;\nconst float STEP_SIZE = .5;\nconst float EPSILON   = .0001;\nconst float PI = 3.14159265359;\n\nstruct Result {\n\tfloat d;\n\tvec3 col;\n\tint id;\n};\n\nfloat udRoundBox (vec3 p, vec3 size, float r)\n{\n    return length (max (abs (p) - (size - r), .0)) - r;\n}\n\nfloat sdSphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\n// PBR toolbox\nfloat DistributionGGX (vec3 N, vec3 H, float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (float NdotV, float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (float cosTheta, vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec4 smin (vec4 d1, vec4 d2, float k)\n{\n\tfloat h = clamp (.5 + .5*(d2.a - d1.a)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat vary (float value, float speed)\n{\n\treturn value*(.5 + .5*cos(speed*iTime));\n}\n\n// ray-marching stuff\nResult scene (in vec3 p)\n{\n    float floor = p.y + .35;\n\n\tvec3 sphereCenter = p;\n\tvec3 boxCenter = p;\n\tfloat offsetX = 1. - vary (1., 1.);\n\tfloat offsetZ = 1. - vary (1., 1.);\n\tsphereCenter -= vec3 (offsetX, .25, offsetZ);\n\tboxCenter -= vec3 (.0, .0, .5);\n\n\tfloat sphere = sdSphere (sphereCenter, .6);\n\tfloat box = udRoundBox (boxCenter, vec3 (.35, .35, .7), .05);\n\tfloat r = .1 + .4*(.5 + .5*cos(5.*boxCenter.x*5.*boxCenter.y*5.*boxCenter.z));\n\tvec3 col1 = vec3 (vary (.5, 2.), vary (1., 1.), vary (.25, 2.));\n\tvec3 col2 = vec3 (1. - vary (.5, 2.), 1. - vary (1., 1.), vary (1., 1.));\n    vec4 colorAndDistance = smin (vec4 (col1, box), vec4 (col2, sphere), r);\n    float d = colorAndDistance.a;\n\tvec3 col = colorAndDistance.rgb;\n\n    Result res = Result (.0, vec3 (.0), 0);\n\tres.d = min (d, floor);\n    res.id = (res.d == floor) ? 1 : 2;\n    res.col = (res.d == floor) ? vec3 (.2) : col;\n    return res;\n}\n\nResult raymarch (in vec3 ro, in vec3 rd)\n{\n    Result res = Result (.0, vec3 (.0), 0);\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + res.d * rd;\n        Result tmp = scene (p);\n        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;\n        res.d += tmp.d * STEP_SIZE;\n        res.id = tmp.id;\n\t\tres.col = tmp.col;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene (p).d;\n    vec3 n = vec3 (scene (p + e.xyy).d - d,\n                   scene (p + e.yxy).d - d,\n                   scene (p + e.yyx).d - d);\n    return normalize(n);\n}\n\nfloat shadow (in vec3 ro, in vec3 rd)\n{\n    float result = 1.;\n    float t = .1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        float h = scene (ro + t * rd).d;\n        if (h < 0.00001) return .0;\n        result = min (result, 8. * h/t);\n        t += h;\n    }\n\n    return result;\n}\n\nfloat ao (vec3 p, vec3 n, float d) {\n    return clamp (scene (p + d*n).d/d, .0, 1.);\n}\n\nvec3 shadePBR (vec3 ro, vec3 rd, float d, int id, vec3 col)\n{\n    vec3 p = ro + d*rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo1 = vec3 (1.);\n    vec3 albedo2 = col;\n    vec3 albedo = (id == 1) ? albedo1 : albedo2;\n    float metallic  = (id == 1) ? .1 : .9;\n    float roughness = (id == 1) ? .9 : .1;\n    float ao = ao (p, nor, .25);\n\n    // lights hard-coded as well atm\n    vec3 lightColors[3];\n    lightColors[0] = vec3 (.7, .8, .9)*20.;\n    lightColors[1] = vec3 (.9, .8, .7)*20.;\n    lightColors[2] = vec3 (.9, .3, .2)*20.;\n\n    vec3 lightPositions[3];\n    lightPositions[0] = p + vec3 (.5, .75, -1.5);\n    lightPositions[1] = p + vec3 (-.5, .25, 1.);\n    lightPositions[2] = p + vec3 (-.1, 1., .1);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 3; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i] - p);\n        float attenuation = 1. / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;\n\t        \n        // cook-torrance brdf\n        float aDirect = .125 * pow (roughness + 1., 2.);\n        float aIBL = .5 * roughness * roughness;\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);\n\t        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n\t        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p, L);\n    }\n\n    vec3 ambient = (kD * albedo) * ao;\n\n    return ambient + Lo;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 f = normalize (vec3 (aim - ro));\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n\n    return normalize (c + uv.x*r + uv.y*u - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3 (-2.*cos(iTime), 1.5, -2.*sin(iTime));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    Result res = raymarch (ro, rd);\n    float fog = 1. / (1. + res.d * res.d * .1);\n    vec3 c = shadePBR (ro, rd, res.d, res.id, res.col);\n\n\tc *= fog;\n\tc = c / (1. + c);\n    c = .2 * c + .8 * sqrt (c);\n    c *= vec3 (.9, .8, .7);\n    c *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n\tfragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGRf.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1150, 1150, 1197, 1197, 1255], [1257, 1257, 1291, 1291, 1320], [1322, 1337, 1394, 1394, 1647], [1649, 1649, 1706, 1706, 1814], [1816, 1816, 1882, 1882, 2101], [2103, 2103, 2167, 2167, 2247], [2249, 2249, 2288, 2288, 2382], [2384, 2384, 2423, 2423, 2467], [2469, 2491, 2517, 2517, 3398], [3400, 3400, 3442, 3442, 3770], [3772, 3772, 3797, 3797, 4014], [4016, 4016, 4055, 4055, 4299], [4301, 4301, 4337, 4337, 4387], [4389, 4389, 4450, 4450, 6583], [6585, 6585, 6639, 6639, 6871], [6873, 6873, 6930, 6930, 7539]], "test": "timeout"}
{"id": "wllGzB", "name": "metafall", "author": "FabriceNeyret2", "description": "Metaball variant of \"Perlinfall\" [url]https://www.shadertoy.com/view/ttfGzj[/url]", "tags": ["metaballs", "short", "isovalue", "jittering", "motionwithoutmovement"], "likes": 17, "viewed": 508, "published": "Public API", "date": "1556815890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Metaball variant of \"Perlinfall\" https://www.shadertoy.com/view/ttfGzj\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, P,D,\n         U = u / R.y, V = 15.*U; V.y += iTime;\n    float p = 0.;\n    \n    for (int k=0; k<9; k++)                            // neigborhood\n        P = vec2(k%3-1,k/3-1),                         // cur. cell \n        D = fract(1e4*sin(ceil(V-P)*mat2(R.xyyx)))-.5, // node = random offset in cell\n        P = fract(V) -.5 + P+ D,                       // node rel. coords\n        p += smoothstep( 1.3*U.y,0.,length(P) );       // its potential\n\n  //p = sqrt(p);\n  //p = sin(10.*p); \n    O = vec4( (p -.5) / fwidth(p) ); // * vec4(.5,.7,1.2,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 114, 114, 693]], "test": "ok"}
{"id": "wllGzS", "name": "Sphere Swirls", "author": "TekF", "description": "Inspired by animations by [url=https://twitter.com/beesandbombs]beesandbombs[/url].", "tags": ["raymarching", "lighting", "abstract", "animation"], "likes": 24, "viewed": 599, "published": "Public API", "date": "1556823509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere Swirls\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// reduce this to improve frame rate in windowed mode (0 disables anti-aliasing)\n#define AA_QUALITY 2\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\nfloat Torus( vec3 position, float majorRadius, float minorRadius )\n{\n    float majorCircle = length(position.xy) - majorRadius;\n    vec2 crossSection = vec2( position.z, majorCircle );\n    return length( crossSection ) - minorRadius;\n}\n\n\nfloat SDF( vec3 pos )\n{\n    float thickness = .02;\n    const int n = 50;\n    float f = 1e20;\n    for ( int i=0; i < n; i++ ) // can make this faster by using pos.z as an index, but then need to have bounds on adjacent rings\n    {\n        float fi = (float(i)+.5)/float(n);\n        float a = 6.283*(fi*.5-.25);\n        float h = sin(a);\n        float r = cos(a);\n        \n        float sliceAngle = -iTime*1.618 + (fi-.5)*6.283*(1.8*cos(iTime*.6) + 49.*smoothstep(.5,1.,-cos(iTime*.1)));\n        vec2 slice = vec2(cos(sliceAngle),sin(sliceAngle));\n        \n        f = min( f,\n                max(\n                    Torus( pos-vec3(0,0,h), r, thickness),\n                    dot(pos.xy,slice) // plane\n                )\n            );\n        \n        // add sphere end caps\n        vec3 end = vec3( slice.y*r, -slice.x*r, h );\n        f = min( f, length(pos - end) - thickness );\n        end.xy = -end.xy;\n        f = min( f, length(pos - end) - thickness );\n    }\n    \n    return f;\n}\n\n\nconst float epsilon = .0004;\nfloat Trace( vec3 rayStart, vec3 rayDirection, float near, float far )\n{\n    float t = near;\n    \n    float h = 0.;\n    float lasth = 0.;\n    float bestt = 0.;\n    float bestDist = 1e30;\n    float sdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        lasth = h;\n        sdf = SDF( rayDirection*t+rayStart );\n        h = sdf + epsilon*.5;\n\t\tt += h;\n        if ( t > far ) return 1e10;\n        if ( sdf < bestDist ) { bestt = t; bestDist = sdf; } // not sure if all these conditionals will compile well, could flip to use step and mix\n        if ( h < epsilon ) break;\n    }\n\n    if ( sdf == bestDist )\n    {\n        // improve precision\n\t\tfloat lastt = t-epsilon;\n\t\tfloat lastsdf = SDF( rayDirection*lastt+rayStart );\n\t\tfloat sdf = SDF( rayDirection*t+rayStart );\n       \tt = mix( lastt, t, (0.-lastsdf)/(sdf-lastsdf) );\n    }\n    else if ( t < bestt*2. )\n    {\n        // use the closest sample we had, to avoid sampling back-sides and things\n        t = bestt;\n\t\t// this can add a fringe, but maybe better than the alternative\n    }\n    \n    return t;\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*epsilon;\n    return normalize(\n        \tSDF(p+d.xxx)*d.xxx +\n        \tSDF(p+d.yyx)*d.yyx +\n        \tSDF(p+d.yxy)*d.yxy +\n        \tSDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvec3 HDRtoLDR( vec3 col )\n{\n\tconst float whiteSoftness = 0.15; // this mostly affects the diffuse light - rewind to recompute it!\n    \n    // soft clamp to white (oh this is so good)\n    float w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n    \n    col = clamp( col, 0., 1. );\n\n    // linear to sRGB (approx)\n    //col = pow( col, vec3(1./2.2) ); // moved to after anti-aliasing\n\n    return col;\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,2.3);\n    \n    vec3 camPos = vec3(4,0,-3);\n    \n    float time2 = iTime*.2;\n    vec2 rot = vec2(0);\n    \n    // wandering camera\n    rot += sin(vec2(1,-.618)*(time2-sin(time2))*.5)*vec2(.5,.2);\n    \n//    if ( max(iMouse.x,iMouse.y) > .0 ) // use last mouse position (unless 0,0 => never clicked)\n    if ( iMouse.z > .0 ) // snap back when mouse released\n    {\n        rot = (iMouse.xy/iResolution.xy-.5);\n    }\n    rot *= vec2(1,.5)*6.283185;\n    camPos.xz = camPos.xz*cos(rot.x) + sin(rot.x)*vec2(1,-1)*camPos.zx;\n    float l = length(camPos.xz);\n    camPos.xz *= cos(rot.y) + sin(rot.y)*camPos.y/l;\n    camPos.y = camPos.y*cos(rot.y) - sin(rot.y)*l;\n    \n    vec3 camK = normalize(vec3(0)-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    // jump ahead because we know the object is inside a 1+thickness sphere\n    float near = (length(camPos)-1.1);\n    float far = (length(camPos)+1.1);\n    \n\tfloat t = Trace( camPos, ray, near, far );\n    \n    vec3 pos = camPos+t*ray;\n    \n    if ( t >= far )\n    {\n        // background\n        \n        // make it consistent with ambient light direction\n        fragColour.rgb = (vec3(.5,.6,.8)-.25) * smoothstep(-.3,.3,dot(ray,normalize(vec3(-4,-3.5,3)))) + .25;\n    }\n    else\n    {        \n        vec3 normal = GetNormal(pos);\n\n        // ambient light\n\t\t// this looks pretty nice, it implies a studio where the camera is on the dark side\n        fragColour.rgb = (dot(normal,normalize(vec3(-4,-3.5,3)))*.5+.5)*(vec3(.5,.6,.8)-.25);\n        fragColour.rgb += vec3(.25);\n        \n        // some rough AO\n        float aoDist = .1;\n        fragColour.rgb *= smoothstep(-aoDist*2.,.0,SDF(pos+normal*aoDist)-aoDist);\n        \n        vec3 lightDir = normalize(vec3(-2,3,-1));\n        vec3 lightCol = vec3(1);\n\n        float shadowT = Trace( pos, lightDir, .001, 2. );\n        if ( shadowT >= 2. )\n        {\n            fragColour.rgb += max(0.,dot(normal,lightDir))*lightCol;\n        }\n    }\n\n    fragColour.rgb = HDRtoLDR(fragColour.rgb);\n    fragColour.a = 1.;\n}\n\n\n// Anti-aliasing\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( AA_QUALITY == 0 )\n    mainImage2( fragColour, fragCoord );\n#else\n    int numSamples = max( 1, int((1920.*1080.*float(AA_QUALITY)*.15) / (iResolution.x*iResolution.y)) );\n\n    vec4 colSum = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        colSum += col;\n    }\n   \n    fragColour = colSum/float(numSamples);\n#endif\n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[459, 459, 527, 527, 694], [1716, 1716, 1788, 1788, 2774], [2777, 2777, 2803, 2803, 2989], [2992, 2992, 3019, 3019, 3455], [3458, 3458, 3517, 3517, 5721], [5724, 5741, 5799, 5799, 6998]], "test": "ok"}
{"id": "Wls3DB", "name": "Metallic liquid dive", "author": "ciphered", "description": "First time I ever use the raytracing algorithm. Could not find a way to optimise this, everytime I try to optimise it the quality gets too low to be sufficient :(", "tags": ["raytracingfractalmetallicalien"], "likes": 7, "viewed": 529, "published": "Public", "date": "1557573924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Basic raytracing algorithm \n */\n\n#define NEAR 0.001\n#define FAR 40.0\n#define FOG 0.00005\n#define FOV 0.5\n#define RT_ITERATIONS 128\n#define TARGET vec3(0.0)\n#define PI 3.14159265359\n\n\n\nfloat glow = 0.0, ttpi;\n\nvec3 cw, cu, cv, rd;\nvec4 np;\n\nvec2 e = vec2(0.00035, -0.00035);\n\n// useful functions\nmat2 r2 (float r) { return mat2(cos(r), sin(r), -cos(r), cos(r)); }\nfloat noise (vec3 p) {\n\tvec3 ip = floor(p),\n         s = vec3(7.0, 157.0, 113.0);\n    p-= ip;\n    vec4 h = vec4(0.0, s.yz, s.y+s.z) + dot(ip, s);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// primitives\nfloat bo (vec3 p, vec3 r) { p = abs(p)-r; return max(max(p.x, p.y), p.z); } // box\nfloat ca (vec3 p, float h, float r) { p.y-= clamp(p.y, 0.0, h); return length(p)-r; } // capsule\n\n\n/**\n * this function generates a scene, distance based\n */\nvec2 fb (in vec3 p) {\n    vec2 h, t = vec2(ca(p+vec3(0.0,2.0,0.0), 4.0, 1.0), 5.0);\n    t.x = min(bo(abs(p)-vec3(4.8,4.8,4.8), vec3(1.2, 1.2, 1.2)), t.x);\n    \n    h = vec2(ca(p, 10.0, 0.2), 3.0);\n    \n    t = t.x < h.x ? t : h;\n    \n    glow+= 0.1 / (0.1+t.x*t.x*100.0);\n    \n    t.x*= 0.1;\n    \n    return t;\n}\n\n\n/**\n * MAPPING FUNCTION\n */\nvec2 mp (vec3 p) {\n    p.z = mod(p.z+iTime*12.0, 20.0)-8.0;\n    \n    \n    np = vec4(p, 1.0);\n    \n    float s = sin(p.z*0.1+ttpi*2.0-5.0)*0.1;\n    \n    for (float i = 0.0; i < 6.0; i++) {\n    \tnp = abs(np) - vec4(4.0, 0.0, max(4.0*s, 2.2), 0.0);\n        np.xy*= r2(0.4+s);\n        np.zy*= r2(0.1+s*abs(cos(iTime/6.0)));\n        np.xz*= r2(0.4*s*cos(iTime/10.0));\n    }\n    \n    vec2 h, t = fb(np.xyz);\n    return t;\n}\n\n\n/**\n * RAY TRACING METHOD \n */\nvec2 tr (in vec3 ro, in vec3 rd) {\n    vec2 h, t = vec2(0.1);\n    for (int i = 0; i < RT_ITERATIONS; i++) {\n        h = mp(ro+rd*t.x);\n        if (h.x < NEAR || t.x > FAR) break;\n        t.x+= h.x;\n        t.y = h.y;\n    }\n    if (t.x > FAR) t.x = 0.0;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv/= vec2(iResolution.y/iResolution.x, 1.0);\n    uv.x/= 2.6; // looks better if upscaled on x\n    \n    // a bit naive but enough\n    float bassLevel = (texture(iChannel0, vec2(0.0, 0.0)).r+texture(iChannel0, vec2(0.2, 0.0)).r)/2.0;\n    \n    // time \n    float tt = mod(iTime, 100.0),\n          bb = 0.5 + clamp(sin(tt), -0.5, 0.5);\n    \n    // background\n    vec3 col, fo, ld = normalize(vec3(0.1,0.5,-0.5));\n    col = fo = vec3(0.4)*cos(iTime/8.0) + vec3(0.1) * (1.0 - length(uv)*1.5 - 0.1);\n    \n    // camera \n    ttpi = mod(tt, 2.0*PI);\n    ttpi = ttpi > PI ? 2.0*PI-ttpi : ttpi;\n    //vec3 ro = vec3(cos(ttpi)*15.0, 0.0, sin(ttpi)*16.0);\n    vec3 ro = vec3(0.0,0.0,-10.0);\n    cw = normalize(TARGET-ro);\n    cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    cv = normalize(cross(cu, cw));\n    rd = mat3(cu, cv, cw) * normalize(vec3(uv, FOV));\n    \n    // raytracer algorithm is called\n    vec2 sc = tr(ro, rd);\n    \n    // distance camera / object\n    float d = sc.x;\n    \n    // if d > 0, we compute the color of the pixel based on the scene \n    if (d > 0.0) {\n   \t\tvec3 po = ro + rd*d,\n             no = normalize(e.xyy*mp(po+e.xyy).x + e.yyx*mp(po+e.yyx).x + e.yxy*mp(po+e.yxy).x + e.xxx*mp(po+e.xxx).x),\n             al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.32),abs(cos(iTime/5.0)));\n        \n        if (sc.y < 5.0) {\n            al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.8),abs(cos(iTime/5.0)));\n        }\n        \n        // lighting\n        \n        float dif = max(0.0, dot(no, ld)),\n              aor = d / 50.0,\n              fr = pow(1.0+dot(no, rd), 4.0);\n        \n        vec3 sss = vec3(1.5) * smoothstep(0.0, 1.0, mp(po+ld*0.4).x/0.4);\n            \n        \n        col = mix(al*0.2+al*(dif+sss), fo, min(fr, 0.5));\n        col = mix(col, fo, 1.0 - exp(-FOG*d*d*d));\n    }\n    \n    // we add the glow\n    //bassLevel*= bassLevel;\n    col+= vec3(0.0,.9,.3)*glow*0.05*bassLevel;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wls3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 302, 321, 321, 369], [370, 370, 392, 392, 649], [651, 665, 692, 692, 740], [741, 748, 785, 785, 833], [847, 906, 927, 927, 1218], [1221, 1249, 1267, 1267, 1666], [1669, 1700, 1734, 1734, 1968], [1971, 1971, 2028, 2078, 4114]], "test": "error"}
{"id": "Wls3DS", "name": "[Wan] Underwater spheres", "author": "wan", "description": "\"No, we still haven't found the ship wrecks. But we found something.\"", "tags": ["raymarching", "reflection", "perlinnoise"], "likes": 6, "viewed": 386, "published": "Public API", "date": "1557491487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n\nfloat rand(vec2 p) {\n\treturn fract(sin(p.x*12.9898+p.y*78.233)*43758.543);\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\t\n\tvec2 o = vec2(0.,1.);\n\tfloat a = rand(i+o.xx);\n\tfloat b = rand(i+o.yx);\n\tfloat c = rand(i+o.xy);\n\tfloat d = rand(i+o.yy);\n\t\n\treturn mix(mix(a,b,f.x), mix(c,d,f.x), f.y);\n}\n\nfloat fractNoise(vec2 p) {\n\tfloat r = noise(p);\n\tfor (float i = 1.; i < 7.; i++) {\n\t\tr += noise(p*pow(2., i)) / pow(i, 2.5);\n\t}\n\treturn r;\n}\n\nfloat artifacts(vec3 p) {\n\tp = vec3(mod(p.x, 4.)-2.,p.y-1.5,mod(p.z, 2.6)-1.3);\n\tp.y /= 2.;\n\tp.x /= 2.;\n\treturn length(p) - .5;\n}\n\nfloat terrain(vec3 p) {\n\treturn p.y - fractNoise(p.xz/1.8)*1.2;\n}\n\nfloat map(vec3 p) {\n\treturn min(\n\t\tterrain(p),\n\t\tartifacts(p));\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(EPS, 0.);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyy)-map(p-e.xyy),\n\t\tmap(p+e.yxy)-map(p-e.yxy),\n\t\tmap(p+e.yyx)-map(p-e.yyx)\n\t\t));\n}\n\nvec3 lightdir = normalize(vec3(.5,-5.,-2.));\nvec3 terrainColor(vec3 p, float hit) {\n\treturn mix(\n\t\tvec3(.0,.2,.0),\n\t\tvec3(.3,.8,.6),\n\t\tdot(normal(p), -lightdir) - hit/100.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y * 5.;\n\tuv += (sin(uv.x*10.+iTime/4.)+cos(uv.y*5.+iTime/4.))/50.;\n\t\n\tvec3 eye = vec3(0.,3.,iTime);\n\tvec3 p = eye;\n\tvec3 phit = eye;\n\tvec3 raydir = normalize(vec3(uv.x, uv.y-2.5, 4.));\n\tfloat hit = -1.;\n\tfloat reflectionHit = -1.;\n\t\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tfloat d = (hit > -1.) ? terrain(p) : map(p);\n\t\tif (d < EPS) {\n\t\t\tif (hit == -1.) {\n\t\t\t\thit = i;\n\t\t\t\tphit = p;\n\t\t\t\tvec3 n = normal(p);\n\t\t\t\traydir = raydir - 2.*dot(raydir,n)*n;\n\t\t\t\tif (terrain(p) < EPS) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treflectionHit = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp += d * raydir * .7;\n\t}\n\t\n\t\n\tvec3 color;\n\tif (hit > 0.) {\n\t\tif (artifacts(phit) < EPS) {\n\t\t\tcolor = mix(\n\t\t\t\tvec3(.7,.2,.1),\n\t\t\t\tvec3(.9,.8,.6),\n\t\t\t\tdot(normal(phit), -lightdir) - hit/100.);\n\t\t\tcolor += clamp(terrainColor(p, hit)/2., 0.1, .5) * length(terrainColor(p, hit))/3. * 5.;\n\t\t} else {\n\t\t\tcolor = terrainColor(p, hit);\n\t\t}\n\t}\n\tcolor -= smoothstep(0.7,1.,p.y)/5.;\n\tcolor -= pow(length(p.z-eye.z), 0.2)/10.;\n\tcolor /= clamp(length(p.z-eye.z)/1.5, .5, 1.5);\n\tcolor = clamp(color, vec3(0.), vec3(1.));\n\tcolor += vec3(.02,.02,.15);\n\tcolor += vec3(.2,.4,.8)*clamp(uv.y/8.-.5,0.,.3);\n\tcolor = vec3(pow(color.x, .9), pow(color.y, .9), pow(color.z, .9));\n\t\n\n\tfragColor = vec4(color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wls3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 39, 39, 95], [97, 97, 118, 118, 333], [335, 335, 361, 361, 475], [477, 477, 502, 502, 606], [608, 608, 631, 631, 673], [675, 675, 694, 694, 740], [742, 742, 763, 763, 906], [953, 953, 991, 991, 1083], [1086, 1086, 1143, 1143, 2452]], "test": "timeout"}
{"id": "wls3Rj", "name": "raymarched 4d grid fork", "author": "slerpy", "description": "asdf", "tags": ["asdf"], "likes": 0, "viewed": 61, "published": "Public", "date": "1556973757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"raymarched 4d grid\" by yx\n// https://shadertoy.com/view/3lsGR2\n\nint mat;\nfloat time;\nvec4 rv;\n\nvoid shuffle()\n{\n    rv=fract(1e4*sin(rv)+rv.wxyz);\n}\n\nmat2 R(float a)\n{\n    return mat2(\n        cos(a),-sin(a),\n        sin(a), cos(a)\n    );\n}\n\nvoid rotate(inout vec4 v)\n{\n    float a = 0.06 * time;\n    v.xy*=R(a);\n    v.xw*=R(a);\n    v.yz*=R(a);\n    v.yw*=R(a);\n    v.zx*=R(a);\n    v.zw*=R(a);\n}\n\nvoid translate(inout vec4 v)\n{\n    float t = 0.2 * time;\n    v[int(t)%4] += 3.*cos(acos(-1.)*fract(t));\n}\n\nfloat box(vec3 p, float r)\n{\n    p=abs(p);\n    return max(\n        max(max(p.x,p.y),p.z)-r,\n        abs(length(p)-r*1.2)-.02\n    );\n}\n\nfloat scene(vec4 p)\n{\n    p=mod(p,3.)-1.5;\n    \n    const float r1 = .1;\n    float cxy=length(p.xy)-r1;\n    float cxz=length(p.xz)-r1;\n    float cxw=length(p.xw)-r1;\n    float cyz=length(p.yz)-r1;\n    float cyw=length(p.yw)-r1;\n    float czw=length(p.zw)-r1;\n    \n    const float r2 = .4;\n    float sxyz=box(p.xyz,r2);\n    float sxyw=box(p.xyw,r2);\n    float sxzw=box(p.xzw,r2);\n    float syzw=box(p.yzw,r2);\n    \n    float d1 = min(min(min(cxy,cxz),min(cxw,cyz)),min(cyw,czw));\n    float d2 = min(min(sxyz,sxyw),min(sxzw,syzw));\n    float dx = min(d1, d2);\n    \n    mat = (dx == d1) ? 0 : 1;\n    \n    return dx;\n}\n\nvec4 normal(vec4 p)\n{\n    vec2 o=vec2(.01,0);\n    return normalize(scene(p)-vec4(\n\t\tscene(p-o.xyyy),scene(p-o.yxyy),\n\t\tscene(p-o.yyxy),scene(p-o.yyyx)\n\t));\n}\n\n\nvec4 noise(vec4 p)\n{   \n    p = mod(p, 3.) - 1.5;\n    p = round(3.*p);\n    \n    for(int i=0; i<13; i++)\n        p = fract(1e4*sin(p) + p.wxyz);\n    \n    return p;\n}\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n    n *= n;\n    p /= 3.;\n    \n    vec4 acc = vec4(0);\n    acc += n.x * texture(iChannel1, p.yzw);\n    acc += n.y * texture(iChannel1, p.xzw);\n    acc += n.z * texture(iChannel1, p.xyw);\n    acc += n.w * texture(iChannel1, p.xyz);\n    return acc;\n}\n*/\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n\tp = mod(p, 3.) - 1.5;\n    n *= n / dot(n,n);\n    vec4 acc = vec4(0);\n    \n    acc += n.x * texture(iChannel0, p.yz);\n    acc += n.x * texture(iChannel0, p.yw);\n    acc += n.x * texture(iChannel0, p.zw);\n    \n    acc += n.y * texture(iChannel0, p.xz);\n    acc += n.y * texture(iChannel0, p.xw);\n   \tacc += n.y * texture(iChannel0, p.zw);\n    \n    acc += n.z * texture(iChannel0, p.xy);\n    acc += n.z * texture(iChannel0, p.xw);\n    acc += n.z * texture(iChannel0, p.yw);\n    \n    acc += n.w * texture(iChannel0, p.xy);\n    acc += n.w * texture(iChannel0, p.yz);\n    acc += n.w * texture(iChannel0, p.xz);\n    \n    return acc / 3.;\n}\n*/\n\n/*\nvec4 tex(vec4 p, vec4 n)\n{\n    p = mod(p, 3.) - 1.5;\n    n *= n / dot(n,n);\n    n += n.wxyz;\n    \n    vec4 acc = vec4(0);\n    acc += n.x * texture(iChannel0, p.yz);\n   \tacc += n.y * texture(iChannel0, p.zw);\n    acc += n.z * texture(iChannel0, p.yw);\n    acc += n.w * texture(iChannel0, p.xy);\n    return acc / 2.;\n}\n*/\n\n\nfloat badao(vec4 p, vec4 n)\n{\n    const float d = 0.35;\n    return pow(max(scene(p+d*n) / d, .0), 1.2);\n}\n\nfloat badsss(vec4 p, vec4 n)\n{\n    const float d = -0.03;\n    return .4+.6*pow(max(scene(p+d*n) / d, .0), .7);\n}\n\nvec4 render(vec2 coord)\n{\n    shuffle();\n    \n    vec2 uv = (coord+rv.xy-.5*iResolution.xy) / iResolution.y;\n    time = iTime + .5 * rv.z * iTimeDelta;\n    \n    float fisheye = .9;\n    if (fisheye != 0.)\n    \tuv = normalize(uv) * tan(asin(length(uv) * fisheye)) / fisheye;\n\n    float a = 0.05 * time;\n    vec2 zw = vec2(cos(a),sin(a));\n    \n    vec4 cam=vec4(0);\n    vec4 dir=normalize(vec4(uv,zw));\n\n    rotate(dir);\n    translate(cam);\n    \n    float k, t=.2;\n    for(int i=0;i<80;++i){\n\t\tt+=k=scene(cam+dir*t);\n        if(k<.01)break;\n    }\n\n    vec4 h=cam+dir*t;\n    vec4 n=normal(h);\n    \n    cam = h;\n    dir = reflect(dir, n);\n    \n    float t2 = .0;\n    for(int i=0;i<40;++i){\n\t\tt2+=k=scene(cam+dir*t);\n        if(k<.05)break;\n    }\n    \n    vec4 col = 4. * pow(.7, t) * badao(h,n) * badsss(h,n) * (noise(h) + pow(.7, t2 + 2.));\n    \n    return pow(clamp(col, .0, 1.), vec4(.454545454545454545454545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rv = vec4(fragCoord, iFrame, 1);\n    for(int i=0;i<8;i++)shuffle();\n    \n    vec4 acc = vec4(0);\n    \n    const int n = 2;\n    \n    for(int i=0; i<n; i++)\n        acc += render(fragCoord);\n    \n    fragColor = acc / float(n);\n}\n\n\n\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wls3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 123, 123, 160], [162, 162, 179, 179, 252], [254, 254, 281, 281, 406], [408, 408, 438, 438, 513], [515, 515, 543, 543, 648], [650, 650, 671, 671, 1264], [1266, 1266, 1287, 1287, 1423], [1426, 1426, 1446, 1446, 1590], [2867, 2867, 2896, 2896, 2972], [2974, 2974, 3004, 3004, 3086], [3088, 3088, 3113, 3113, 4000], [4002, 4002, 4059, 4059, 4291]], "test": "ok"}
{"id": "wls3WB", "name": "Riemann Sphere Domain Coloring", "author": "tpfto", "description": "Domain coloring plot over the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url]. The function shown above is the example of [url=https://math.dartmouth.edu/~doyle/docs/icos/icos/icos.html]Doyle and McMullen[/url].", "tags": ["math", "sphere", "complex", "domaincoloring"], "likes": 10, "viewed": 201, "published": "Public", "date": "1557568900", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// domain coloring of the Doyle-McMullen iteration function on the Riemann sphere\n\n// domain coloring code from https://www.shadertoy.com/view/wtf3DN\n// sphere rendering forked from https://www.shadertoy.com/view/MssGRl by asalga\n\n// some constants\n\n#define PI 3.14159265359\n\n// range of the display\n\n#define SCALE 8.0\n\n// grid line spacing\n\n#define SPACING 0.125\n\n// from Fabrice Neyret, \n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n#define cis(a) vec2( cos(a), sin(a) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\n\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\n\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified DLMF coloring, from https://www.shadertoy.com/view/WtXGWN\n\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// sphere normal\n\nvec3 getNormal(in vec2 c, in float r, in vec2 point)\n{\n\treturn mix(vec3(0.0, 0.0, 1.0), normalize(vec3(point - c, 0.0)), length(point - c)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= SCALE;\n    float r = 3.0; // sphere radius\n\t\n\tif( length(uv) < r)\n    {\n\t\tvec3 sphereNormal = vec3(getNormal(vec2(0.0), r, uv));\n\t\tvec3 dirLight = normalize(vec3(0.0, 0.0, 1.0));\n\t\tvec3 col = normalize(vec3(1.0)) * dot(sphereNormal, dirLight);\n\t\t\n\t\tfloat xa = sphereNormal.x, ya = sphereNormal.y;\n        float s = sqrt((1.0 - ya) * (1.0 + ya)), sx = sqrt((s - xa) * (s + xa));\n\n        // Riemann sphere variable\n        vec2 zz = sqrt((1.0 + ya)/(1.0 - ya)) * normalize(vec2(xa, sx));\n        // animate the variable, anticlockwise rotation\n        zz = cmul(zz, cis(0.1 * PI * iTime));\n        \n        // two steps of the Doyle-McMullen iteration; https://doi.org/10.1007/BF02392735\n        vec2 w = zz - cmul(12.0 * zz, cdiv(cmul(cpow(zz, 5) + vec2(11.0, 0.0), cpow(zz, 5)) - vec2(1.0, 0.0), cmul(11.0 * cpow(zz, 5), cpow(zz, 5) + vec2(6.0, 0.0)) - vec2(1.0, 0.0)));\n        w = w - cmul(12.0 * w, cdiv(cmul(cpow(w, 5) + vec2(11.0, 0.0), cpow(w, 5)) - vec2(1.0, 0.0), cmul(11.0 * cpow(w, 5), cpow(w, 5) + vec2(6.0, 0.0)) - vec2(1.0, 0.0)));\n        \n        float ph = atan(w.y, w.x), lm = log(0.0001 + length(w));\n    \n        vec3 c = smooth_dlmf(0.5 * (ph / PI));\n\n        c *= my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95);\n\t\t\n\t\tfragColor = vec4(0.2 + 2.5 * col * c, 1.0);\n\n\t} else {\n\n\t\tfragColor = vec4(0.16, 0.14, 0.13, 1.0);\n\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wls3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[669, 669, 701, 701, 751], [773, 773, 807, 807, 943], [1016, 1016, 1045, 1045, 1243], [1245, 1285, 1319, 1319, 1706], [1726, 1726, 1780, 1780, 1870], [1872, 1872, 1929, 1929, 3429]], "test": "ok"}
{"id": "Wls3Wj", "name": "Axis Aligned Bounding Hedron", "author": "Wunkolo", "description": "2D Implementation and visualization of Bryan McNett's Axis Aligned Bounding Octahedron\nhttps://github.com/bryanmcnett/aabo", "tags": ["collision", "math"], "likes": 0, "viewed": 107, "published": "Public", "date": "1557696336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 SomePoints[5] = vec2[5](\n    vec2(  0.25,  0.17), vec2( -0.37, 0.32),\n    vec2( -0.54,  0.12), vec2( -0.01, 0.41),\n    vec2( -0.25, -0.31)\n);\n\nconst float PointRadius = 0.0125;\n\nconst vec2 Basis[3] = vec2[3](\n\tvec2(  sqrt(8.0/9.0),           0.0),\n\tvec2( -sqrt(2.0/9.0), sqrt(2.0/3.0)),\n\tvec2( -sqrt(2.0/9.0),-sqrt(2.0/3.0))\n);\n\nvec3 Project(vec2 Coord)\n{\n    return vec3(\n        dot(Coord,Basis[0]),\n        dot(Coord,Basis[1]),\n        dot(Coord,Basis[2])\n    );\n}\n\nstruct AABO\n{\n    vec3 Min;\n    vec3 Max;\n};\n\nvec3 SweepTest(AABO Bounds, vec3 Test)\n{\n    return \n        vec3(greaterThanEqual(Bounds.Min,Test))\n        - vec3(lessThanEqual(Bounds.Max,Test));\n}\nfloat LineDist(vec2 p1, vec2 p2, vec2 Point)\n{\n    float a = p1.y - p2.y;\n    float b = p2.x - p1.x;\n    return\n        abs(a * Point.x + b * Point.y + p1.x * p2.y - p2.x * p1.y)\n        / sqrt(a * a + b * b);\n}\n\nmat2 Rotation(float Angle)\n{\n\tfloat Sin = sin(Angle);\n\tfloat Cos = cos(Angle);\n\treturn mat2(Cos, -Sin, Sin, Cos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat2 CurRotation = Rotation(iTime * 0.25);\n    vec2 Coord = fragCoord/iResolution.xy;\n    vec2 Mouse = iMouse.xy/iResolution.xy;\n    Coord = mix(vec2(-1),vec2(1),Coord);\n    Mouse = mix(vec2(-1),vec2(1),Mouse);\n    Coord.x *= iResolution.x/iResolution.y;\n    Mouse.x *= iResolution.x/iResolution.y;\n    \n    vec3 MouseProj = Project(Mouse);\n    vec3 CoordProj = Project(Coord);\n    \n    // Draw the \"mesh\" (vertex soup)\n    float MinDist = 1e9;\n    for( uint i = 0u; i < 5u; ++i)\n    {\n        float CurDist = distance(CurRotation * SomePoints[i],Coord) - PointRadius;\n        MinDist = min(MinDist,CurDist);\n    }\n    float MouseDist = 1.0 - step(0.0,distance(Coord,Mouse) - PointRadius * 2.0);\n    float Dots = 1.0 - step(0.0,MinDist);\n    \n    // Calculate AABO of \"mesh\"\n    AABO Bounds;\n    // Project points onto basis\n    vec3 CurProject = Project(CurRotation * SomePoints[0]);\n    Bounds.Min = CurProject;\n    Bounds.Max = CurProject;\n    for( uint i = 1u; i < 5u; ++i)\n    {\n        vec3 CurProject = Project(CurRotation * SomePoints[i]);\n        Bounds.Min = min(Bounds.Min,CurProject);\n        Bounds.Max = max(Bounds.Max,CurProject);\n    }\n    vec3 MouseSweep = SweepTest(Bounds,MouseProj);\n    vec3 CoordSweep = SweepTest(Bounds,CoordProj);\n    \n    vec3 BasisLines;\n    BasisLines.r = LineDist(vec2(0.0),Basis[0],Coord);\n    BasisLines.g = LineDist(vec2(0.0),Basis[1],Coord);\n    BasisLines.b = LineDist(vec2(0.0),Basis[2],Coord);\n    BasisLines = mix(vec3(0.025),vec3(0.005),abs(CoordSweep)) - BasisLines;\n    BasisLines = step(vec3(0.0),BasisLines);\n   \n    \n    fragColor = vec4(vec3(Dots),0.0);\n    vec3 CoordBoundMax = mix(MouseSweep * -0.25,vec3(0.125),lessThanEqual(CoordProj,Bounds.Max));\n    vec3 CoordBoundMin = mix(MouseSweep * +0.25,vec3(0.125),greaterThanEqual(CoordProj,Bounds.Min));\n    fragColor.rgb += CoordBoundMax; fragColor.rgb += CoordBoundMin;\n    fragColor.rgb += BasisLines;\n    fragColor.rgb += all(equal(MouseSweep,vec3(0.0)))\n        ? vec3(0.0,MouseDist,0.0)\n        : vec3(MouseDist,0.0,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wls3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 340, 366, 366, 478], [526, 526, 566, 566, 676], [677, 677, 723, 723, 888], [890, 890, 918, 918, 1005], [1007, 1007, 1064, 1064, 3106]], "test": "error"}
{"id": "WlS3zD", "name": "demodemodemo", "author": "lennyjpg", "description": "ödfjygöldkjfgöslkdjgödlkfj", "tags": ["hi"], "likes": 1, "viewed": 73, "published": "Public", "date": "1558617859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime;\n    \n    float k = floor(fract(t+uv.y*10.0)*2.0);\n    \n    vec3 img = texture(iChannel0,uv).rgg;\n    \n    vec3 col = vec3(k);\n    \n    col -= img;\n    \n    float cut = fract(t*0.5);\n    cut = (sin(t)+1.0)*0.5;\n    if(uv.x > cut){\n        col = img;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlS3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 412]], "test": "error"}
{"id": "wlsGDl", "name": "Testing Selection", "author": "iq", "description": "Hopefully this shader debunks some of the misconceptions and myths about conditional operations in GLSL, which wrongly preach that ternary operations (?:) and branching (if) should be avoided and arithmetic replacements (step, *) should be used instead.", "tags": ["2d", "test", "performance"], "likes": 25, "viewed": 3102, "published": "Public API", "date": "1558122776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Hopefully this shader debunks some of the misconceptions and myths\n// about how to perform conditional operations in GLSL, which wrongly \n// preach that all ternary operations (?:) and branching (if) should\n// be avoided at all cost in favor of arithmetic replacements (step, *).\n// \n// While the topic of conditional branching is complex and has much to\n// do with the work done in the body of the conditional and the coherency\n// of computations across neighbor pixels, most of the simple conditional\n// operations clearly benefit from using simple and straighforward ternary\n// operations.\n//\n// This shader shader shows how, in particular, painting a single pixel\n// in white is actually twice as fast when done with a ternaty operation\n// instead of arithmetics. Here are results for my PC:\n\n\n// change this to see different results\n#define METOD 0\n\n//                                   LAPTOP   PHONE\n//                                   ------   --------\n// METHOD 0 : ternary operation:     83 fps   10.6 fps\n// METHOD 1 : step arithmetic:       57 fps    9.9 fps\n// METHOD 2 : float to bool:         71 fps    8.9 fps\n// METHOD 3 : conditional braching:  83 fps   10.5 fps\n\n\n// number of tests per frame. Reduce this if your machine is too slow\nconst int num = 15000;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = floor(fragCoord);\n    \n    vec3 tmp = 0.5 + 0.5*sin(iTime+vec3(0.0,2.0,4.0));\n\t\n    vec3 col = vec3(0.0);\n    float h = 127.0 + 0.0001*iTime;\n    \n\t#define ZERO min(iFrame,0)\n    for( int i=ZERO; i<num; i++ )\n    {\n        // conditional move\n        #if METOD==0\n        col = (p.x<h && p.y<h+h) ? col+tmp : col;\n        #endif\n        \n        // \"smart\" way\n        #if METOD==1\n        col += tmp*step(p.x,h)*step(p.y,h+h);\n        #endif\n        \n        // even \"smarter\" way\n        #if METOD==2\n        col += tmp*float(p.x<h && p.y<h+h);\n        #endif\n\n        // conditional branching\n        #if METOD==3\n        if( p.x<h && p.y<h+h ) col += tmp;\n        #endif\n\n    \th += 0.000013;\n    }\n    col /= float(num);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsGDl.jpg", "access": "shaders20k", "license": "mit", "functions": [[2360, 2360, 2417, 2417, 3193]], "test": "ok"}
{"id": "WlSGRD", "name": "kalidoscope v2", "author": "StrangerintheQ", "description": "click anywhere to change it\n\n\nv1: https://www.shadertoy.com/view/3tsGDf", "tags": ["fractal"], "likes": 3, "viewed": 83, "published": "Public", "date": "1558610250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float n){return fract(sin(n) * (1.+iMouse.x + iMouse.y/10000.));}\n\nfloat noise(float p){\n\tfloat f = floor(p);\n\treturn mix(rand(f), rand(f + 1.0), fract(p));\n}\n\t\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n \n    p = (p + p - iResolution.xy) / iResolution.y;\n    vec2 m = vec2(-iTime/2. , iTime/3.);\n    vec2 noised = vec2(noise(m.x), noise(m.y))/2.;\n    for(int i = 0; i < 11; i++)\n        p = abs(p) / dot(p,p) - noised-iMouse.xy/iResolution.xy*0.5;\n    \n    fragColor = vec4(noise(p.x)*p.y, noise(p.y)*p.x, noise(p.x+p.y),1.);\n         \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 76], [78, 78, 99, 99, 169], [173, 173, 222, 222, 557]], "test": "ok"}
{"id": "WlsGRl", "name": "[00002] sphere", "author": "samel", "description": "[00002] sphere", "tags": ["raymarching", "basic", "shadow", "diffuse"], "likes": 1, "viewed": 56, "published": "Public", "date": "1557308017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plane(vec3 p, float y)\n{\n return p.y-y;\n}\n\nfloat sphere(vec3 p,vec3 pos,float r)\n{\n return length(pos-p)-r;\n}\n\nfloat scene(vec3 p)\n{\n float sphere=sphere(p,vec3(0.0,1,6),1.0);\n float plane=plane(p,0.0);\n return min(sphere,plane);\n}\n\nfloat raymarch(vec3 origin,vec3 direction)\n{\n float traveled=0.0;\n float distance=0.0;\n for(int i=0;i<128;i++)\n {\n  vec3 p=origin+traveled*direction;\n  distance=scene(p);\n  if(distance<=0.001 || traveled>100.0)\n  {\n   break;\n  }\n  traveled+=distance;\n }\n return traveled;\n}\n\nvec3 normalAt(vec3 p)\n{\n vec2 epsilon=vec2(0.01,0);\n float distanceAtP=scene(p);\n return normalize(vec3(distanceAtP-scene(p-epsilon.xyy),\n                       distanceAtP-scene(p-epsilon.yxy),\n                       distanceAtP-scene(p-epsilon.yyx)));\n}\n\nfloat diffuse(vec3 p)\n{\n vec3 sunPos=vec3(sin(iTime),5,cos(iTime)+6.0);\n vec3 normal=normalAt(p);\n vec3 lightDir=normalize(sunPos-p);\n if(raymarch(p+lightDir*0.1,lightDir)<length(sunPos-p))\n {\n  return 0.0;\n }\n return clamp(dot(lightDir,normal),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x-0.5;\n    \n    vec3 color=vec3(0,0,0);\n    vec3 origin=vec3(0.0,2.0,0);\n    vec3 direction=normalize(vec3(uv,1));\n    float traveled=raymarch(origin,direction);\n    color=vec3(diffuse(origin+direction*traveled));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 47], [49, 49, 88, 88, 115], [117, 117, 138, 138, 237], [239, 239, 283, 283, 512], [514, 514, 537, 537, 769], [771, 771, 794, 794, 1027], [1029, 1029, 1086, 1086, 1372]], "test": "ok"}
{"id": "WlsGRS", "name": "Keep Calm and Slow Motion", "author": "Sot", "description": "A small shader written to test some new simple skills.\nThis is my first one.", "tags": ["spheres", "blend", "rotation", "tranlsation"], "likes": 5, "viewed": 100, "published": "Public", "date": "1556720571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_DIST  10000.0\n#define RM_DIST 0.01\n\nfloat PI = 3.14159;\n\nmat2 Rot(float deg)\n{ \n    float rad = ((2.*PI)/360.)*deg;\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat plane(vec3 p)\n{\n  return p.y;\n}\n\nfloat box(vec3 p, vec3 center, vec3 size)\n{\n    vec3 centeredPos = p-center;\n    return length(max(abs(centeredPos)-size, 0.));\n}\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n  return length(p-center)-radius;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5+0.5*(b-a)/k,0.,1.);\n  return mix(b,a,h)-k*h*(1.-h);\n}\n\nfloat map(vec3 pos)\n{\n  // sphere ring\n  // pos = pos + vec3(0.0, 1.0, 0.0);\n  // pos = pos * RotXY(fGlobalTime);\n  float count = 12.;\n  float spheres[12];\n  float ds = 0.;\n  for (float i=0.; i < count; ++i)\n  {\n      vec3 spherePos = pos;\n      spherePos += vec3(-2,0,0);  //translate          \n      spherePos.xz *= Rot(30.*i+2.*iTime);  //rotate  \n      spherePos += vec3(2,0,0);  //translate    \n      spheres[int(i)] = sphere(spherePos, vec3(0.,0.15,0.), 0.35);    \n\n      if (i==0.)\n        ds = spheres[int(i)];\n      else\n        ds = smin(spheres[int(i)], ds,0.2);\n  }\n  \n  for (float i=0.; i < count; ++i)\n  {\n      vec3 spherePos = pos;\n      spherePos += vec3(2,0,0);  //translate          \n      spherePos.yz *= Rot(90.);  //rotate  \n      spherePos.xz *= Rot(30.*i+10.*iTime);  //rotate  \n      spherePos += vec3(2,0,0);  //translate    \n      \n      spheres[int(i)] = sphere(spherePos, vec3(0.,0.5,0.), .35);    \n\n      ds = smin(spheres[int(i)], ds,.2);\n  }\n  \n  \n  \n  float dp = plane(pos);\n  \n  float db = box(pos, vec3(-2.,0.5,0.), vec3(.25));\n  \n  // float dmix = mix (ds, db, sin(fGlobalTime));\n\n  float d = smin(dp,ds,.2);\n  \n\n  return d;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n  vec3 pos = ro;\n  float dist = 0.;\n\n  for (int i=0; i<100; ++i)\n  { \n    pos += dist*rd;\n    dist = map(pos);\n    \n    if ((dist < RM_DIST) || dist > MAX_DIST)\n    {\n      break;\n    }\n  }\n\n  return pos;\n}\n\nvec3 getNormal(vec3 pos)\n{\n  vec2 eps = vec2(0.0001,0);\n  vec3 normal = normalize(vec3(map(pos + eps.xyy)-map(pos - eps.xyy),map(pos + eps.yxy)-map(pos - eps.yxy),map(pos + eps.yyx)-map(pos - eps.yyx)));\n\n  return normal;\n}\n\nvec3 applyFog(vec3 color, float dist)\n{ \n   float fogColor = (exp(1.-10./(dist*dist)))/exp(1.);\n   return mix(color, vec3(0.), fogColor);\n}\n\nfloat getDiffuse(vec3 pos)\n{\n  vec3 lightPos = vec3(2,5,-4);\n  // lightPos.xz *= Rot(30.*iTime);\n  vec3 light = normalize(lightPos - pos);\n  vec3 normal = getNormal(pos);\n  \n  float dimFactor=1.0;\n\n  vec3 sd = normalize(lightPos-pos);\n  vec3 so = pos + 0.05*sd;\n  \n  vec3 surface = RayMarch(so, sd);\n  if (length(surface-pos) < length(lightPos-pos))\n      dimFactor = 0.2;\n\n  return dimFactor * dot(normal,light)*0.5+0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y /iResolution.x, 1);\n  \n  vec3 ro = vec3(0,1,-5.5);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  vec3 pos = RayMarch(ro, rd);\n  vec3 myColor = vec3(getDiffuse(pos));\n  myColor = applyFog(myColor, pos.z);\n  fragColor  = vec4(myColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 91, 91, 208], [210, 210, 231, 231, 247], [249, 249, 292, 292, 378], [380, 380, 429, 429, 465], [468, 468, 507, 507, 583], [585, 585, 606, 698, 1747], [1749, 1749, 1782, 1782, 1989], [1991, 1991, 2017, 2017, 2214], [2216, 2216, 2255, 2255, 2355], [2357, 2357, 2385, 2385, 2781], [2783, 2783, 2840, 2840, 3191]], "test": "ok"}
{"id": "wlSGRW", "name": "Bliem_001", "author": "onebus", "description": "This is just some basic step testing, dont worry\n", "tags": ["hajde"], "likes": 1, "viewed": 253, "published": "Public API", "date": "1558621818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \tCreated for a GLSL Shader Whorksop\n\t23.05.2019 \n\tBenedikt Schlaeppi || Leander Herzog\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tfloat t = iTime*1.0;\n\t// invert the half of the screen movement\n    if(uv.x>0.5){\n    \t\tt*=-1.0;\t\n\t}\n    if(uv.x>0.25){\n    \tt*=-1.0;\n    }\n    if(uv.x>0.75){\n    \tt*=-1.0;\n    }\n    \n\tfloat demo = sin(t+uv.y*100.0);\n    \n    //Mouse input\n \tif(uv.x > iMouse.x/1000.0){\n \t\tdemo *=20.0;\n         \n\t}\n    \n    vec3 img = texture(iChannel0, uv).rgb;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n   // foo = mix(img, demo, mouse.x);\n    \n\tfragColor = vec4(demo);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 201, 704]], "test": "error"}
{"id": "wlSGRz", "name": "Lattice Convolution Noise", "author": "tpfto", "description": "Demonstrating an experimental implementation of lattice convolution noise, by texturing a sphere and a plane.", "tags": ["procedural", "noise", "convolution"], "likes": 7, "viewed": 428, "published": "Public API", "date": "1558339631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// experimental implementation of lattice convolution noise\n\n// permutation polynomial\n\nint permp (int i1, int i2)\n{\n      int t = (i1 + i2) & 255;\n        \n      return ((112 * t + 153) * t + 151) & 255;\n}\n\n// lattice convolution noise; adapted from Ebert et al., Texturing & Modeling: A Procedural Approach 3rd ed.\n\nfloat lcnoise(vec3 p)\n{\n    float f = 0.0;\n    ivec3 iv = ivec3(floor(p));\n    vec3 fv = fract(p) + 1.0;\n    \n    int m = 0; // initialization for Knuth's \"algorithm H\"\n    ivec3 di = ivec3(1), ki = ivec3(0);\n    ivec4 fi = ivec4(0, 1, 2, 3);\n    \n    // instead of writing a triply nested loop (!!)\n    // generate the indices for the neighbors in Gray order (Knuth's \"algorithm H\")\n    // see section 7.2.1.1 of TAOCP\n    \n\tfor (int k = 0; k < 64; k++) // loop through all neighbors\n    { \n\t\t // seeding\n        int s = permp(permp(permp(0, iv.z + ki.z), iv.y + ki.y), iv.x + ki.x) + 531;\n        \n        // L'Ecuyer simple LCG\n        s = (2469 * s) % 65521;\n        float c = 2.0 * (float(s)/65521.0) - 1.0;\n    \n        // Mitchell-Netravali cubic, https://doi.org/10.1145/54852.378514\n        float r = length(vec3(ki) - fv);\n        f += c * (( r < 1.0 ) ? (16.0 + r * r * (21.0 * r - 36.0)) : (( r < 2.0 ) ? (32.0 + r * ((36.0 - 7.0 * r) * r - 60.0)) : 0.0))/18.0;\n        \n        // updating steps for Knuth's \"algorithm H\"\n        m = fi[0]; fi[0] = 0; ki[2 - m] += di[m];\n        if ((ki[2 - m] % 3) == 0) {\n            di[m] = -di[m];\n            fi[m] = fi[m + 1]; fi[m + 1] = m + 1;\n        }\n\t}\n        \n    return f;\n}\n\n// modified MATLAB bone colormap\n\nvec3 bone( float t )\n{\n\t return 0.875 * t + 0.125 * clamp(vec3(4.0, 3.0, 3.0) * t - vec3(3.0, 1.0, 0.0), 0.0, 1.0);\n}\n\n// adapted from Inigo Quilez's demo, https://www.shadertoy.com/view/Xsl3Dl\n\nconst mat3 m = mat3( 0.00, -0.80,  0.70,\n                     0.80, -0.86, -0.48,\n                    -0.70,  0.48, -0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5 * iTime;\n\tvec3 ro = vec3( 2.5 * cos(an), 1.0, 2.5 * sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross(uu, ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x * uu + p.y * vv + 1.5 * ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0, 1.0, 0.0);\n\n    // raytrace\n\tfloat tmin = 1.0e3;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = -ro.y/rd.y;\n\tif( h > 0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0, 1.0, 0.0); \n\t\tpos = ro + h * rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor, di/l)/(l * l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b * b - c;\n\tif( h > 0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h < tmin ) \n\t\t{ \n\t\t\ttmin = h; \n\t\t\tnor = normalize(ro + h * rd - sc); \n\t\t\tocc = 0.5 + 0.5 * nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.85);\n\tif( tmin < 100.0 )\n\t{\n\t    pos = ro + tmin * rd;\n\t    float f = 0.0;\n\t\t\n\t\tif( p.x < 0.0 )\n\t\t{\n\t\t\tf = lcnoise( 18.0 * pos );\n\t\t}\n\t\telse\n\t\t{\n            vec3 q = 7.5 * pos;\n            f  = 0.5000 * lcnoise( q ); q = m * q * 2.02;\n            f += 0.2500 * lcnoise( q ); q = m * q * 2.03;\n            f += 0.1250 * lcnoise( q ); q = m * q * 2.01;\n            f += 0.0625 * lcnoise( q );\n\t\t}\n\t\t\n\t\t\n\t\tf = smoothstep( -0.7, 0.7, f ) * occ;\n\t\tcol = bone(sqrt(f));\n\t\tcol = mix( vec3(0.85), col, exp( -0.005 * tmin * tmin ) );\n\t}\n\t\n\tfragColor = vec4(col * smoothstep( 0.006, 0.008, abs(p.x) ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSGRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1159, 1159, 1187, 1187, 1277], [2661, 2661, 2683, 2683, 2778], [2982, 2982, 3039, 3039, 4766]], "test": "ok"}
{"id": "WlX3Rj", "name": "[TWITCH] Knitting dance", "author": "Flopine", "description": "Here is the result from a live coding session I did on Twitch here: https://www.twitch.tv/flopine\nThis is a improved version of the shader I did during the Semifinals of the Revision 2019 Shader Showdown. Credits for the music in comments", "tags": ["raymarching", "intersection", "twitch", "knit"], "likes": 6, "viewed": 260, "published": "Public", "date": "1556833080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Music provided by Pellicus, massive thank you to him :)\n// Music by Asyntote/JapoTek\n\n#define time iTime\n\nfloat PI = 3.141592;\nfloat BPM = 138./60.;\n\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per*0.5,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;  \n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y >p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x, max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat set (vec3 p)\n{\n    float per = 4.;\n    p.xy *= rot(p.z*0.3);\n    p.z = mod(p.z-per*0.5, per)-per*0.5;\n    mo(p.xy, vec2(5.,1.));\n    moda(p.xy, 5.);\n    p.x -= 2.;\n    mo(p.xy, vec2(2.,1.));\n    p.xz *= rot(time);\n    p.xy *= rot(-time);\n    float b1 = box(p, vec3(0.18,5., 0.18));\n    moda(p.xz, 5.);\n    p.x -= 1.;\n    moda(p.xy, 5.);\n    p.x -= 1.;\n    return stmin(b1,box (p, vec3(0.15, 5., 0.15)),1.2, 3.);\n}\n\nfloat c1_id = 0.;\nfloat c2_id = 0.;\nfloat knitting (vec3 p)\n{\n    p.z += time*0.5;\n    p.x += sin(p.y*2.+time)*0.2;\n    float per = 0.22;\n    vec3 pp = p;\n\n    c1_id = floor((p.x-per*.5)/per);\n    p.x = mod(p.x-per*.5, per)-per*.5;\n    float c1 = cyl(p.xzy, 0.05, 1e10); \n\n    p = pp;\n\n    c2_id = floor((p.y-per*.5)/per);\n    p.y = mod(p.y-per*.5, per)-per*.5;\n    p.z = mod(c2_id-.5, 2.) == 0. ? p.z-cos((p.x+.5)*PI)*0.3 : p.z-sin((p.x)*PI)*0.3;\n    float c2 = cyl(p.yzx, 0.05, 1e10);\n    return min(c1,c2);\n}\n\nfloat SDF(vec3 p)\n{\n    p.xy *= rot(floor(time*BPM)*(PI/5.));\n    return max(knitting(p),set(p));\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sorry Fabrice Neyret! Maybe next time I'll be brave enough to change it ^^\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.001,0.001,-12.-time*0.5); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    bool hit = false;\n\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if(d<0.01)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 c1 = palette (c1_id*c2_id, vec3(0.5), vec3(0.5), vec3(0.08), vec3(0.,0.36,0.74));\n        vec3 c2 = palette (c1_id*c2_id, vec3(0.5), vec3(0.5), vec3(0.08), vec3(0.5));\n        col = mix(c1, c2, clamp(floor(sin(time*(BPM/2.)*PI))+1.,0.,1.));\n    }\n    else col = vec3(0.,0.,0.01);\n\n    fragColor = vec4(pow(col,vec3(0.4545)), 1.);\n}", "image_inputs": [{"id": "MlX3zB", "previewfilepath": "https://soundcloud.com/user-978077894/japotek_theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-978077894/japotek_theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 485, 485, 528], [530, 530, 567, 567, 720], [722, 722, 754, 754, 801], [803, 803, 853, 853, 957], [959, 959, 987, 987, 1076], [1078, 1078, 1115, 1115, 1154], [1156, 1156, 1212, 1212, 1243], [1245, 1245, 1265, 1265, 1664], [1702, 1702, 1727, 1727, 2177], [2179, 2179, 2198, 2198, 2278], [2282, 2282, 2339, 2421, 3253]], "test": "ok"}
{"id": "WlX3z2", "name": "NR fractal transitions", "author": "tpfto", "description": "Generate the Newton-Raphson fractal for a general cubic polynomial, using Horner's method.", "tags": ["2d", "fractal", "math", "complex"], "likes": 2, "viewed": 151, "published": "Public", "date": "1556876495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Newton-Raphson fractal implementation, using Horner's method\n\n#define PI 3.14159265359\n#define SCALE 7.5 // plot scale\n\n// from Fabrice Neyret, \n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// order and coefficients of base polynomial, constant term first\n#define ORDER 3\nconst float[] P = float[](0.0, -2.0, 0.2, 1.0);\n\n// use Horner's method to evaluate the Newton-Raphson update\nvec2 Horner( in vec2 z )\n{\n    vec2 w = vec2(P[ORDER], 0.0);\n    vec2 d = vec2(0.0, 0.0);\n    \n    for(int k = ORDER - 1; k >= 0; k--)\n    {\n        d = cmul(d, z) + w;        \n        w = cmul(w, z) + vec2(P[k], 0.0);\n    }\n    \n    w += vec2(7.5, 2.0) * cos(0.2 * iTime); // jiggle the constant term a bit for animation\n        \n    return cdiv(w, d);\n}\n\nvec3 NewtonFractal( vec2 z) {\n    \n    vec2 ld = vec2(0.0);\n    float k = 0.0;\n    \n    for(int i = 0; i < 20; i++) {\n        ld = Horner(z);\n        if (dot(ld, ld) < 0.001) break;\n        z = z - ld;\n        k += 1.0;\n    }\n    \n    // multiplier highlights the positions of the roots\n    return pow((k + 0.1)/20.0, 0.18) * smooth_dlmf(0.5 * atan(z.y, z.x)/PI);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec3 c = NewtonFractal(z);\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlX3z2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1367, 1445, 1474, 1474, 1672], [1805, 1866, 1892, 1892, 2221], [2223, 2223, 2252, 2252, 2589], [2591, 2591, 2648, 2648, 2845]], "test": "error"}
{"id": "wlXGWX", "name": "High Precision 3D Gradient Noise", "author": "nelstuff", "description": "Left: New. Right: IQ's 3D Grad Noise\n\nEvery 2 secs: distances 0 -> 10 mil -> 1 bil\n\nGoal:\n- 3D gradient noise at very far distances\n- Generate roughly the same values across all high-end GPU hardware\n\n\n", "tags": ["procedural", "3d", "noise", "gradient", "hash"], "likes": 8, "viewed": 661, "published": "Public API", "date": "1557838280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n2019 Nel (@nelstuff)\nBased on IQ's https://www.shadertoy.com/view/Xsl3Dl and https://www.shadertoy.com/view/XlXcW4\n\nGoal:\n- 3D gradient noise at very far distances\n- Generate roughly the same values across all high-end GPU hardware (so no \"fract(sin)\")\n\nAssumption:\n- Able to provide a true integer coordinate and a float offset to this coordinate\n\n*/\n\n\n//===============================================================================================\n// High Precision 3D Gradient Noise\n//===============================================================================================\n\n\n// Based on IQ's Integer Hash - II  https://www.shadertoy.com/view/XlXcW4\nvec3 inthash( uvec3 x ){\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    //Convert uvec3 to vec3\n    // Insert the result into a float's mantissa: https://stackoverflow.com/a/17479300\n    const uvec3 ieeeMantissa = uvec3(0x007FFFFFu); \t// binary32 mantissa bitmask\n    const uvec3 ieeeOne      = uvec3(0x3F800000u); \t// 1.0 in IEEE binary32\n    x &= ieeeMantissa;                     \t\t\t// Keep only mantissa bits (fractional part)\n    x |= ieeeOne;                          \t\t\t// Add fractional part to 1.0\n    vec3  f = uintBitsToFloat( x );       \t\t\t// Range [1:2]\n    return -3.0+2.0*f;                        \t\t// Range [-1:1]\n    \n    // Other method to convert uvec3 to vec3\n    //return -1.0 + 2.0 * vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n// High Precision 3D Gradient Noise\n// ix: integer coordinate, fx: float offset to the integer coordinate\nfloat newnoise(in ivec3 ix, in vec3 fx){\n    // grid\n    uvec3 p = uvec3(ix + ivec3(floor(fx)) );\n    vec3 w = fract(fx);\n    vec3 u = w*w*(3.0-2.0*w);\n    return mix( mix( mix( dot( inthash( p  ), w  ), \n                      dot( inthash( p + uvec3(1,0,0) ), w - vec3(1.0,0.0,0.0) ), u.x),\n                 mix( dot( inthash( p + uvec3(0,1,0) ), w - vec3(0.0,1.0,0.0) ), \n                      dot( inthash( p + uvec3(1,1,0) ), w - vec3(1.0,1.0,0.0) ), u.x), u.y),\n            mix( mix( dot( inthash( p + uvec3(0,0,1) ), w - vec3(0.0,0.0,1.0) ), \n                      dot( inthash( p + uvec3(1,0,1) ), w - vec3(1.0,0.0,1.0) ), u.x),\n                 mix( dot( inthash( p + uvec3(0,1,1) ), w - vec3(0.0,1.0,1.0) ), \n                      dot( inthash( p + uvec3(1,1,1) ), w - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// Fractal Brownian Motion \nfloat newfractal(ivec3 ixyz, vec3 fxyz){ \n    // instead of floats, we need to use integer period and integer lacunarity\n    const int period = 2; \n    const int octaves=3;\n    const int lacunarity = 2; \n    const float persistence = 0.6;\n    \n    float value = 0.0;\n    float curpersistence = 1.0;\n\n    ivec3 ispace = ixyz / period;\n    vec3 fspace = vec3(ixyz - ispace * period) / vec3(period) + fxyz / vec3(period);\n\n    for (int i = 0; i < octaves; i++){\n        value += newnoise(ispace, fspace) * curpersistence;\n        curpersistence *= persistence;\n        ispace *= lacunarity;\n        fspace *= float(lacunarity);\n    }\n    return value;\n}\n\n//===============================================================================================\n// Baseline: IQ's 3D Gradient Noise  https://www.shadertoy.com/view/Xsl3Dl\n//===============================================================================================\n\nvec3 hash( vec3 p ){ // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat oldnoise( in vec3 p ){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\tvec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat oldfractal(vec3 xyz){ \n    const float frequency = 0.5; \n    const int octaves=3;\n    const float lacunarity = 2.0; \n    const float persistence = 0.6;\n    \n    float value = 0.0;\n    float curpersistence = 1.0;\n\n    vec3 space = xyz * frequency;\n\n    for (int i = 0; i < octaves; i++){\n        value += oldnoise(space) * curpersistence;\n        curpersistence *= persistence;\n        space *= lacunarity;\n    }\n    return value;\n}\n\n//===============================================================================================\n// Image (https://www.shadertoy.com/view/Xsl3Dl)\n//===============================================================================================\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) { \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 ){\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) { \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t    float f = 0.0;\n        \n        // varying distance every 2 secs\n        int dist = 0;\n        int t = int(floor(iTime*0.5));\n        if(t % 3 == 1){\n            dist = int(1e+7);\n        }else if(t % 3 == 2){\n            dist = int(1e+9);\n        }\n\t\t\n        //left\n\t\tif( p.x<0.0 ){\n\t\t\tf = newfractal(ivec3(0, 0, dist), 16.0*pos );\n\t\t}\n        //right\n\t\telse{\n            f = oldfractal(vec3(0, 0, dist) + 16.0*pos );\n\t\t}\n\t\t\n\t\t\n\t\tf = smoothstep( -0.7, 0.7, f );\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[592, 666, 690, 690, 1494], [1497, 1603, 1643, 1655, 2422], [2424, 2452, 2492, 2572, 3102], [3376, 3376, 3396, 3432, 3600], [3602, 3602, 3630, 3630, 4452], [4454, 4454, 4481, 4481, 4891], [5265, 5265, 5321, 5321, 7131]], "test": "ok"}
{"id": "wlXGzB", "name": "weird_smiley", "author": "s_das", "description": " ", "tags": ["raytracing", "raymarching", "glsl", "recursive", "shader", "smiley", "trignometry", "satisfying"], "likes": 2, "viewed": 280, "published": "Public API", "date": "1556695121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s(a,b,t) smoothstep(a,b,t)\n#define sat(x) clamp(x, 0., 1.)\n#define da iTime\nfloat remap01(float a, float b, float t){\n    return sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t){\n    return sat((t-a)/(b-a))*(d-c) + c;\n}\nvec2 within(vec2 uv, vec4 rect){\n    return (uv - rect.xy)/(rect.zw - rect.xy);\n} \n\nvec4 Eye(vec2 uv){\n    uv -= .5;\n    vec4 col = vec4(0.);\n    vec4 iris = vec4(.3,.5,1.,1.);\n    \n    float d = length(uv);\n    col = mix(vec4(1.), iris, s(.1,.7,d)*.5);\n\n    col.rgb *= 1. - s(0.45, 0.5, d)*.5*sat(-uv.x-uv.y);\n\n    col.rgb = mix(col.rgb, vec3(0.), s(.3,.25,d));\n\n    iris.rgb *= 1. + s(.3, .05, d);\n    //if(da>5.)\n    d = length( uv*cos(da-uv) + atan(uv.y*-tan(da)*uv.x));\n    d = atan(d);\n    d = pow(d,(sin(da)+1.)/4.);\n    col.rgb = mix(col.rgb, iris.rgb, s(.28, .25, d));\n\n    col.rgb = mix(col.rgb, vec3(0.), s(.16, 0.14, d));\n    \n    float highlight = s(.1, .05, length(uv - vec2(-.15,.15)));\n    highlight += s(.09, 0.03, length(uv + vec2(-.08,.08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    col.a = s(.5, .48, d);\n\n    return col;\n}   \n\nvec4 Mouth(vec2 uv){\n    uv -= .5;\n    vec4 col = vec4(0.5, .18, .05, 1.);\n    uv.y *= atan(da,uv.y);\n    uv.y -=  tan(uv.x+da)*uv.x*uv.x*uv.x*sin(iTime*2.)*5. ;\n    uv.y += uv.x*uv.x*sin(da*2.)*tan(uv.x*-uv.y-da);\n    float d = length(uv);\n    col.a = s(.5,.48,d);\n\n    float td = length(uv - vec2(0., .6));\n    vec3 tc = vec3(1.)*s(.6, .35, d);\n    col.rgb = mix(col.rgb, tc, s(.4, .39,td));\n    \n    td = length(uv + vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5),s(.5,.4,td));\n    return col;\n}\n\nvec4 Head(vec2 uv){\n    vec4 col = vec4(1.);\n    \n    float d = length(uv);\n    \n    col.a = s(0.5, 0.49, d);\n\n    float edge = remap01(0.35, 0.5, d);\n    edge *= edge;\n    col.rgb *=  1. - edge*.5;\n\n    col.rgb = mix(col.rgb, vec3(.2,.5,.9), s(.485,.49,d));\n\n    float highlight = s(0.41, 0.405, d) ;\n    highlight *= remap(0.41, 0.0, .75, 0., uv.y);\n    col.rgb = mix(col.rgb, vec3(1.),highlight);\n\n    d = length(uv - vec2(.25, -.2) );\n    float cheek = s(0.2, 0.01,d)*.3;\n    cheek *= s(0.18, 0.17, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n\n\n    return col;\n}\n\nvec4 Smiley(vec2 uv){\n    vec4 col = vec4(0.);\n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye( within(uv, vec4(0.03, -0.1, .37, .24)) );\n    vec4 mouth = Mouth( within(uv, vec4(-.3, -0.4, .3, -.1)) );\n    \n    col = mix(col, head, head.r);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord ){\n    vec2 uv = FragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\n    vec4 col = Smiley(uv+dot((sin(da)+1.)/2.,uv.x));\n\n    if(da<5.)\n        col = Smiley(uv);\n\n    FragColor = col;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 125, 125, 156], [158, 158, 215, 215, 256], [257, 257, 289, 289, 338], [341, 341, 359, 359, 1113], [1118, 1118, 1138, 1138, 1628], [1630, 1630, 1649, 1649, 2209], [2211, 2211, 2232, 2232, 2561], [2563, 2563, 2618, 2618, 2838]], "test": "error"}
{"id": "ws2XRh", "name": "Com Truise - Existence Schematic", "author": "OccamsLaser", "description": "had originally planned to flesh this out more\n\nbased on: https://www.youtube.com/watch?v=6AsC6IQFXZ4", "tags": ["visual", "song", "cover", "schematic", "album", "synthwave", "com", "truise", "existence"], "likes": 1, "viewed": 350, "published": "Public API", "date": "1557985172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DARK_BLUE \t0x6169AE\n#define PURPLE \t\t0x5C3489\n#define CYAN \t\t0x83C9E3\n#define ORANGE \t\t0xE86B62\n\n#define C_PURPLE \t0x694098\n#define C_RED \t\t0xE0323F\n#define C_BLUE\t\t0x3EB4DD\n#define C_DGREEN\t0x3EC677\n#define C_ORANGE\t0xF4AD52\n#define C_LGREEN\t0xB3DB58\n\nvoid box(inout vec3 col, vec2 coord, vec4 bounds, vec3 color) {\n    bool bb = \tall(greaterThanEqual(coord, bounds.xy)) &&\n        \t\tall(lessThan(coord, bounds.zw));\n    col=bb?color:col;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec3 hex2rgb(int hex) {\n\treturn vec3(hex>>16&0xFF,hex>>8&0xFF,hex&0xFF)/255.;\n}\n\nvoid base(inout vec3 col, vec2 ndc) {\n    box(col, ndc, vec4(-0.25,-0.25,0.25,0.25), vec3(1.));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275), hex2rgb(C_PURPLE));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.025,0.,0.025,0.), \thex2rgb(C_RED));\n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.,-0.025,0.,-0.025), \thex2rgb(C_RED));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.05,0.,0.05,0.), \t\thex2rgb(C_BLUE));\n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.,-0.05,0.,-0.05), \thex2rgb(C_BLUE));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.075,0.,0.075,0.), \thex2rgb(C_DGREEN));\n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.,-0.075,0.,-0.075), \thex2rgb(C_DGREEN));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.1,0.,0.1,0.), \t\thex2rgb(C_ORANGE));\n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.,-0.1,0.,-0.1), \t\thex2rgb(C_ORANGE));\n    \n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.125,0.,0.125,0.), \thex2rgb(C_LGREEN));\n    box(col, ndc, vec4(-0.275,0.25,-0.25,0.275)+vec4(0.,-0.125,0.,-0.125), \thex2rgb(C_LGREEN));   \n}\n\nvoid pattern0(inout vec3 col, vec2 ndc) {\n    for(float j=1.; j<9.; j+=1.) {\n        box(col, ndc, vec4(-0.20,-0.25,-0.15,-0.20)+vec4(0.,j*0.05,0.,j*0.05), hex2rgb(ORANGE));\n        box(col, ndc, vec4( 0.15,-0.25, 0.20,-0.20)+vec4(0.,j*0.05,0.,j*0.05), hex2rgb(ORANGE));\n    }\n    \n    for(float i=1.; i<5.; i+=1.) {\n        if(ndc.y > -0.2 && ndc.y < 0.2) {\n            vec2 ndcmod = ndc;\n            ndcmod.y = mod(ndcmod.y-0.5*iTime, 0.2) - 0.2;\n\n            vec4 coord = vec4(-0.15+i*0.05, 0.00-i*0.05,\n                              -0.10+i*0.05, 0.05-i*0.05);\n\n            if(coord.y >= -0.2 && coord.y <= 0.2) {\n                box(col, ndcmod, coord, hex2rgb(ORANGE));\n            }\n\n            if(i==1.) {\n                coord += vec4(0.2,0.0,0.2,0.0);\n                box(col, ndcmod, coord, hex2rgb(ORANGE));\n            } else if(i==4.) {\n                coord -= vec4(0.2,0.0,0.2,0.0);\n                box(col, ndcmod, coord, hex2rgb(ORANGE));\n            }\n        }\n    }\n}\n    \n\nvoid mainImage(out vec4 O, in vec2 I) {\n    vec2 uv = I/iResolution.xy;\n    vec2 ndc = I/iResolution.yy - vec2(16./9.,1.)/2.;\n    \n    \n    float mixval = random(uv);\n    \n    vec3 col = mix(hex2rgb(PURPLE), hex2rgb(DARK_BLUE), uv.y);\n    \n    base(col, ndc);\n    pattern0(col, ndc);\n    \n\n\tO = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xll3DN", "previewfilepath": "https://soundcloud.com/com-truise/existence-schematic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/com-truise/existence-schematic", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2XRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 324, 324, 449], [451, 451, 474, 474, 547], [549, 549, 572, 572, 628], [630, 630, 667, 667, 1760], [1762, 1762, 1803, 1803, 2751], [2758, 2758, 2797, 2797, 3069]], "test": "ok"}
{"id": "Wt23R1", "name": "Sphere Amoeba", "author": "plosique", "description": "Turns sphere into ameoba by chainging SDF", "tags": ["raymarching", "geoemetry"], "likes": 1, "viewed": 122, "published": "Public", "date": "1558493987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS=255; \nconst float MAX_DIST=100.0; \nconst float MIN_DIST=0.0; \nconst float EPS=0.001; \nconst float a=1.0; \nconst vec3 ls=vec3(1.0,1.0,-1.0); \nconst vec3 ia=vec3(1.0,1.0,1.0);\nconst vec3 id=vec3(0.5,0.5,0.5); \nconst vec3 is=vec3(0.5,0.5,0.5); \nconst float kd=0.5; \nconst float ks=0.2; \nconst float ka=0.4; \nvec3 c=vec3(0.0,0.0,1.0); \nfloat r=1.3; \nfloat dist(vec3 pt,mat3 mat){ \n    return pow(dot(pt,mat*pt),0.5); \n}\n\nfloat sphereSDF(in vec3 pt,in mat3 mat){ \n    return dist(pt-c,mat)-r; \n}\n\n\nfloat sceneSDF(in vec3 pt,mat3 mat){   \n    return sphereSDF(pt,mat); \n}\n\n\nvec4 ray_march(in vec3 eye, in vec3 dir,mat3 mat){\n    vec4 bkg=vec4(0.0,0.0,0.0,1.0); \n    vec3 pt; \n\tpt=eye;\n    float step_size=0.0;\n    for(int i=0;i<MAX_STEPS;i++){\n        step_size=sceneSDF(pt,mat); \n        \n        pt=pt+step_size*dir;\n        \n        if (step_size>MAX_DIST){  \n            return bkg ;\n        } \n        if (step_size<EPS){\n            vec3 N=(pt-c); \n            vec3 L=(ls-pt); \n            vec3 V=(eye-pt); \n            vec3 R=reflect(-L,N);\n            vec3 ret=ka*ia+kd*(dot(L,N))*id+ks*pow(dot(R,V),a)*is;\n            vec4 ret2=vec4(ret,1.0);\n            return ret2;\n                \n            \n        } \n       \n    }return bkg ;\n}\n\nvec3 ray_dir(vec3 eye,vec3 pix_loc){ \n    return normalize(pix_loc-eye); \n        }\n\nfloat det(mat3 mat){  \n    return mat[0][0]*mat[1][1]*mat[2][2]; \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 r1=fragCoord-0.5*iResolution.xy; \n    vec2 r=r1.xy/(0.5*iResolution.y); \n    mat3 mat=mat3(1.0,sin(3.14*r.y)*cos(iTime),0.0,\n                  0.0,1.0,cos(3.14*r.x)*cos(iTime),\n                  -sin(3.14*r.y)*cos(3.14*r.x)*cos(iTime),0.0,1.0); \n    mat=mat/det(mat); \n    vec3 eye=vec3(0.0,0.0,-1.0); \n    vec3 pix_loc=vec3(r,0.0); \n    vec3 dir=ray_dir(eye,pix_loc);  \n    vec4 pix_val=ray_march(eye,dir,mat); \n     \n    fragColor=pix_val;\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 395, 395, 435], [437, 437, 477, 477, 510], [513, 513, 549, 549, 585], [588, 588, 638, 638, 1259], [1261, 1261, 1297, 1297, 1344], [1346, 1346, 1366, 1366, 1413], [1417, 1417, 1474, 1474, 1930]], "test": "ok"}
{"id": "wt23z1", "name": "Traced Columns", "author": "Hamneggs", "description": "A *very* long time ago there was something like this on the site. I can't find it anymore, and I decided to make something similar to test out tracing over marching. (I didn't quite escape raymarching though).", "tags": ["raytracing", "raytracing", "ray", "tracing", "interior", "columns", "boxes", "dystopian", "novels"], "likes": 8, "viewed": 195, "published": "Public", "date": "1558567069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * This just traces through a field of cubes that make a box, plus two\n * extra cubes plus lightsources.\n */\n\n// #define ENABLE_SHADOWS /* Compute intensive */\n#define ENABLE_NORMAL_MAPPING\n#define ENABLE_SPECULAR\n\n#define MAT_REFLECTANCE 3.0\n#define BRIGHTNESS 10.0\n#define ID_NONE 0.0\n#define ID_TUNNEL 1.0\n#define ID_LIGHT1 2.0\n#define ID_LIGHT2 4.0\n#define LIGHT1_COLOR vec3(.8,.05,.667)\n#define LIGHT2_COLOR vec3(.05,.05,2.0)\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, vec3(0,1,0))*uv.x + vec3(0,1,0)*uv.y)-ro);\n}\n\n/**\n * Minimum of two 2D vectors.\n */\nvec2 min2( in vec2 a, in vec2 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 3D vectors.\n */\nvec3 min4( in vec3 a, in vec3 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 4D vectors.\n */\nvec4 min4( in vec4 a, in vec4 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Takes the minimum of two intersections.\n */\nvoid minInt(in float distA,  in vec3 normA,  in vec2 uvA,\n            in float distB,  in vec3 normB,  in vec2 uvB,\n            out float distM, out vec3 normM, out vec2 uvM)\n{\n    if ( distA < distB ) { distM = distA; normM = normA; uvM = uvA; }\n    else                 { distM = distB; normM = normB; uvM = uvB; }\n}\n\n/**\n * That random function off of SF.\n */\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n/**\n * 3D version.\n */\nfloat rand3( in vec3 co )\n{\n    return fract(sin(dot(co ,vec3(12.9898,78.233,-53.1234))) * 43758.5453);\n}\n\n/**\n * Sorta the usual FBM, but without using a noise texture and adding\n * high frequency noise at the end.\n */\nfloat fbm( in vec2 x )\n{\n    float r = texture(iChannel0, x     ).x*.5;\n    r += texture(iChannel0, x*2.0 ).x*.25;\n    r += texture(iChannel0, x*4.0 ).x*.125;\n    r += texture(iChannel0, x*8.0 ).x*.0625;\n    r += rand(x)*.0325;\n    return r;\n}\n    \n\n/**\n * Reference function for light positions.\n */\nvec3 lightpos1() { return vec3(sin(iTime*.5)*3., cos(iTime), 2.+sin(iTime)); }\nvec3 lightpos2() { return vec3(sin(iTime)*3.0, -cos(iTime*.5)*.5, 0); }\n\n/**\n * A kinda sorta smoothsquare function.\n */\nfloat smoothSquare(in float x) { return smoothstep(.3, .7, pow(sin(x),2.)); }\n\n/**\n * IQ Really nailed this one.\n */\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/**\n * IQ's sphere intersection.\n */\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(99999.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/**\n * IQ's Box intersection.\n */\nfloat iBox( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    // compute normal (in world space), face and UV\n    if( t1.x>t1.y && t1.x>t1.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t1.x; }\n    else if( t1.y>t1.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t1.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t1.z; }\n\n    return tN; // maybe min(tN,tF)?\n}\n\n\n/**\n * A simplified version.\n */\n#ifdef ENABLE_SHADOWS\nfloat iBoxSimple( in vec3 row, in vec3 rdw, in mat4 txx, in vec3 rad ) \n{\t\t\t\t \n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    return tN;\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Takes a ray, walks it forward, and see if it intersects\n * any columns near it.\n */\nvoid tunnel( in vec3 ro, in vec3 rd, out float dist, out vec3 n, out vec2 uv )\n{\n    dist = 9999999.0; // nearest intersection distance, normal, and UV.\n    n = vec3(0,1,0);\n    uv = vec2(0);\n    \n    float intersect = 0.0; // Did we hit something?\n    \n    vec3 p = ro; // Copy of the ray origin.\n    \n    // March the ray forward.\n    for(float i = 0.0; i < 9.0; ++i)\n    {\n        for(int x = -1; x < 2; ++x) // Left and right neighbors.\n        for(int z = -1; z < 2; ++z) // Front and back neighbors.\n        {\n            \n            \n            vec3 off = vec3(x,0,z); // Create an offset vector.\n\n\t\t\t\n            vec3 g = floor(p); // Floor the ray position.\n\n            // Get the columns' height.\n            float h_b = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz)    );\n            float h_t = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz-1.0));\n            float h_l = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz)    );\n            float h_r = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz-1.0));\n            float h_f = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy)    );\n            float h_d = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy-1.0)); // derriere for back, since b is taken for \"bottom\".\n            \n            // Create the required translation matrices.\n            mat4 t_b = translate(off.x-g.x-.5,  3.0+h_b, off.z-g.z-.5); \n            mat4 t_t = translate(off.x-g.x-.5, -3.0-h_t, off.z-g.z-.5); \n            mat4 t_l = translate(-4.0-h_l, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_r = translate( 4.0+h_r, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_f = translate(off.x-g.x-.5, off.z-g.y-.5, -4.0-h_f); \n            mat4 t_d = translate(off.x-g.x-.5, off.z-g.y-.5,  4.0+h_d);\n            \n            // And their inverses.\n            mat4 t_bi = inverse(t_b), t_ti = inverse(t_t), t_li = inverse(t_l);\n            mat4 t_ri = inverse(t_r), t_fi = inverse(t_f), t_di = inverse(t_d);\n            \n            vec3 n_b, n_t, n_l, n_r, n_f, n_d; \t\t // Places to store surface normals.\n            vec2 uv_b, uv_t, uv_l, uv_r, uv_f, uv_d; // And more places to store UVs.\n\n            // Finally we can check some intersections.\n            float dist_b = iBox(p, rd, t_b, t_bi, vec3(.5), n_b, uv_b) + i;\n            float dist_t = iBox(p, rd, t_t, t_ti, vec3(.5), n_t, uv_t) + i;\n            float dist_l = iBox(p, rd, t_l, t_li, vec3(.5), n_l, uv_l) + i;\n            float dist_r = iBox(p, rd, t_r, t_ri, vec3(.5), n_r, uv_r) + i;\n            float dist_f = iBox(p, rd, t_f, t_fi, vec3(.5), n_f, uv_f) + i;\n            float dist_d = iBox(p, rd, t_d, t_di, vec3(.5), n_d, uv_d) + i;\n            \n            // Find the nearest intersection.\n            minInt( dist, n, uv, dist_t, n_t, uv_t, dist, n, uv );\n            minInt( dist, n, uv, dist_b, n_b, uv_b, dist, n, uv );\n            minInt( dist, n, uv, dist_l, n_l, uv_l, dist, n, uv );\n            minInt( dist, n, uv, dist_r, n_r, uv_r, dist, n, uv );\n            minInt( dist, n, uv, dist_f, n_f, uv_f, dist, n, uv );\n            minInt( dist, n, uv, dist_d, n_d, uv_d, dist, n, uv );\n        }\n        \n        // All boxes have a grid size of 1, and ||rd|| = 1.\n        // This allows us to use our marching step index as the distance\n        // traveled from origin.\n        p += rd;\n    }\n    \n    // Now it's time to get the two feature cubes in the middle.\n    \n    vec3 n_f1, n_f2; // Surface normals.\n    vec2 uv_f1, uv_f2; // Texcoords.\n    \n    // Translation matrices.\n    mat4 t_f1 = translate(-.6,-.6,-.6); mat4 t_f1i = inverse(t_f1);\n    mat4 t_f2 = translate( .6, .6, .6); mat4 t_f2i = inverse(t_f2);\n    \n    // Check for intersection.\n    float dist_f1 = iBox(ro, rd, t_f1, t_f1i, vec3(.5), n_f1, uv_f1);\n    float dist_f2 = iBox(ro, rd, t_f2, t_f2i, vec3(.5), n_f2, uv_f2);\n    \n    // Factor them into the equation.\n    minInt( dist, n, uv, dist_f1, n_f1, uv_f1, dist, n, uv );\n    minInt( dist, n, uv, dist_f2, n_f2, uv_f2, dist, n, uv );\n    \n    // Perturb the surface normal.\n    #ifdef ENABLE_NORMAL_MAPPING\n    p = ro+dist*rd;\n    vec2 texCoord = uv+rand3(floor(p)); \n    vec3 diff = vec3(fbm(texCoord), fbm(texCoord+12348.3), 0);\n    diff = 2.0*diff - 1.0;\n    diff *= .125;\n    vec3 an = abs(n);\n    if( an.x > .5 ) \t n = normalize(n+diff.zxy*sign(n.x));\n    else if( an.y > .5 ) n = normalize(n+diff.xzy*sign(n.y));\n    else\t\t\t\t n = normalize(n+diff.xyz*sign(n.z));\n    #endif // ENABLE_NORMAL_MAPPING\n}\n\n/**\n * Traces a ray through the field. This trace function includes\n * two spheres for the light soruces.\n */\nvoid trace( in vec3 ro, in vec3 rd, out float id, out float dist, out vec3 n, out vec2 uv)\n{\n    tunnel(ro, rd, dist, n, uv);\n    float si1 = iSphere(ro, rd, lightpos1(), .05).x;\n    float si2 = iSphere(ro, rd, lightpos2(), .05).x;\n   \t\n    vec2 minElement = vec2(9999999.0, ID_NONE);\n    minElement = min2(minElement, vec2(dist, ID_TUNNEL));\n    minElement = min2(minElement, vec2(si1,  ID_LIGHT1));\n    minElement = min2(minElement, vec2(si2,  ID_LIGHT2));\n   \tdist = minElement.x;\n    id = minElement.y;\n            \n}\n\n/**\n * Marches a ray forward through a simplified geometry field, since\n * we don't need the UV or normal vector of where the shadow ray\n * collides.\n */\n#ifdef ENABLE_SHADOWS\nvoid tunnelShadow( in vec3 ro, in vec3 rd, out float dist )\n{\n    dist = 9999999.0;    \n   \tint face;\n    float intersect = 0.0;\n    vec3 p = ro;\n    \n    for(float i = 0.0; i < 9.0; ++i)\n    {\n        for(int x = -1; x < 2; ++x)\n        for(int z = -1; z < 2; ++z)\n        {\n            vec3 off = vec3(x,0,z);\n            vec3 g = floor(p);\n\n            float h_b = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz)    );\n            float h_t = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xz-1.0));\n            float h_l = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz)    );\n            float h_r = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.yz-1.0));\n            float h_f = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy)    );\n            float h_d = .5*smoothSquare(.25*iTime + 3.14*rand(off.xz-g.xy-1.0));\n            \n            mat4 t_b = translate(off.x-g.x-.5,  3.0+h_b, off.z-g.z-.5); \n            mat4 t_t = translate(off.x-g.x-.5, -3.0-h_t, off.z-g.z-.5); \n            mat4 t_l = translate(-4.0-h_l, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_r = translate( 4.0+h_r, off.x-g.y-.5, off.z-g.z-.5); \n            mat4 t_f = translate(off.x-g.x-.5, off.z-g.y-.5, -4.0-h_f); \n            mat4 t_d = translate(off.x-g.x-.5, off.z-g.y-.5,  4.0+h_d);\n\n            float dist_b = iBoxSimple(p, rd, t_b, vec3(.5)) + i;\n            float dist_t = iBoxSimple(p, rd, t_t, vec3(.5)) + i;\n            float dist_l = iBoxSimple(p, rd, t_l, vec3(.5)) + i;\n            float dist_r = iBoxSimple(p, rd, t_r, vec3(.5)) + i;\n            float dist_f = iBoxSimple(p, rd, t_f, vec3(.5)) + i;\n            float dist_d = iBoxSimple(p, rd, t_d, vec3(.5)) + i;\n            \n            dist = min(dist, dist_b);\n            dist = min(dist, dist_t);\n            dist = min(dist, dist_l);\n            dist = min(dist, dist_r);\n            dist = min(dist, dist_f);\n            dist = min(dist, dist_d);\n        }\n        p += rd;\n    }\n    mat4 t_f1 = translate(-.6,-.6,-.6);\n    mat4 t_f2 = translate( .6, .6, .6);\n    \n    float dist_f1 = iBoxSimple(ro, rd, t_f1, vec3(.5));\n    float dist_f2 = iBoxSimple(ro, rd, t_f2, vec3(.5));\n    \n    dist = min(dist, dist_f1);\n    dist = min(dist, dist_f2);\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Traces a shadow ray through the distance field.\n */\n#ifdef ENABLE_SHADOWS\nvoid traceShadow( in vec3 ro, in vec3 rd, out float dist)\n{\n    tunnelShadow(ro, rd, dist);\n}\n#endif // ENABLE_SHADOWS\n\n/*\n\tOren-Nayar reflectance modeling. I use this everywhere. Just looks good.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/**\n * Models a point light.\n */\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 lp, in vec3 rd, in vec3 texel, in vec3 lc )\n{\n    \n    vec3 ld = lp-p; \t\t\t\t\t\t\t\t// Direction of light.\n    float dist = length(ld); \t\t\t\t\t\t// Distance to the light.\n    ld = normalize(ld); \t\t\t\t\t\t\t// Normalize for correct trig.\n    float base = orenNayar(n, rd, ld)*BRIGHTNESS; \t// Base lighting coefficient.\n    float falloff = clamp(1.0/(dist*dist),0.0,1.0); // Quadratic coefficient.\n    \n    // Specular.\n    #ifdef ENABLE_SPECULAR\n    vec3 reflection = normalize(reflect(rd,n));\n    float specular = clamp(pow(clamp(dot(ld, reflection),0.0,1.0),25.0),0.0,1.0);\n    #else\n    float specular = 0.0;\n    #endif // ENABLE_SPECULAR\n    \n    // Optionally do shadows.\n    #ifdef ENABLE_SHADOWS\n    float shadowDist;\n    traceShadow(p+ld*.01, ld, shadowDist);\n    float shadow = smoothstep(dist*.99, dist*1.01,shadowDist);\n    #else\n    float shadow = 1.0;\n    #endif // ENABLE_SHADOWS\n    \n    return lc*specular*shadow + base*falloff*shadow*lc*texel + lc*.0125;\n}\n\n/**\n * Lights the entire scene by tracing both point lights.\n */\nvec3 lightScene( in vec3 p, in vec3 n, in vec3 rd, in vec3 texel )\n{\n    \n    return clamp( pointLight(p, n, lightpos1(), rd, texel, LIGHT1_COLOR) +\n              \t  pointLight(p, n, lightpos2(), rd, texel, LIGHT2_COLOR),\n              \t  vec3(0),vec3(1) );\n}\n\n/**\n * Takes it a step further by coloring based on object ID.\n */\nvec3 shade( in vec3 p, in vec3 n, in vec3 rd, in float dist, in float id )\n{\n    if(id == ID_NONE) return vec3(0);\n    else if(id == ID_TUNNEL) return vec3( lightScene(p+rd*dist, n, rd, vec3(1)) );\n    else if(id == ID_LIGHT1) return LIGHT1_COLOR*BRIGHTNESS*2.0;\n    else if(id == ID_LIGHT2) return LIGHT2_COLOR*BRIGHTNESS*2.0;\n    else return vec3(0);\n}\n\n/**\n * Some quick tonemapping and vignetting.\n */\nvec4 postProcess( in vec3 c, in vec2 uv )\n{\n    float vig = 1.0-dot(uv,uv)*.6;\n    c = pow(clamp(c, 0., 1.), vec3(.4545));\n    return vec4(c*vig,1);\n}\n\n/**\n * Entrypoint.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Set up the camera.\n    \n    // Position.\n    vec3 cp =  vec3(3.0*cos(iTime*.5), sin(iTime*.25), 3.0*sin(iTime*.25));\n    \n    // Direction.\n    vec3 cd = normalize(vec3(-cos(iTime*.5), .5*cos(iTime*.25), -sin(iTime*.25)));\n    \n    // Places to store results.\n    vec3 p, d;\n    \n    // Create the view ray.\n    camera(uv, cp, cd, .667, p, d);\n    \n    // Do the traces.\n    float id; float dist; vec3 n; vec2 texCoord;\n    trace(p, d, id, dist, n, texCoord);\n    \n    // Shade the point.\n    vec3 c = shade(p, n, d, dist, id);\n    \n    \n    \n    // Based on the results of that trace, we shade accordingly.\n    fragColor = postProcess(c, uv);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt23z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 614, 701, 701, 795], [797, 835, 870, 870, 920], [922, 960, 995, 995, 1045], [1047, 1085, 1120, 1120, 1170], [1172, 1223, 1399, 1399, 1541], [1543, 1586, 1612, 1612, 1684], [1687, 1710, 1737, 1737, 1815], [1817, 1930, 1954, 1954, 2173], [2180, 2231, 2249, 2249, 2309], [2310, 2310, 2328, 2328, 2381], [2383, 2431, 2463, 2463, 2508], [2510, 2548, 2593, 2593, 2709], [2711, 2748, 2810, 2810, 3033], [3035, 3069, 3175, 3219, 4002], [4601, 4692, 4772, 4772, 9161], [9163, 9273, 9365, 9365, 9794], [12410, 12490, 12545, 12545, 12846], [12848, 12881, 12973, 12973, 13888], [13890, 13955, 14023, 14023, 14214], [14216, 14283, 14359, 14359, 14637], [14639, 14689, 14732, 14732, 14839], [14841, 14864, 14921, 14921, 15684]], "test": "error"}
{"id": "wt23zz", "name": "Perlin Noise Explained", "author": "DanielMz25", "description": "Shader of perlin noise and auxiliary scripts to explain how perlin noise works.\nIt's not original perlin noise algorithm. It uses array of diagonal gradient vectors instead of random and cosinus interpolation.", "tags": ["perlinnoise"], "likes": 11, "viewed": 772, "published": "Public", "date": "1558360518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 gradients[4] = vec2[4](\n    vec2(1.0,1.0),vec2(1.0,-1.0),\n    vec2(-1.0,-1.0),vec2(-1.0,1.0));\n\nconst float pi = 3.141592653589793238462643383279502884157169399375105820974944592307816406286208998628034825342117067982148086513282;\n\nconst vec3 rainbowColors[6] = vec3[6](\n    vec3(1.0,0.0,0.0),vec3(1.0,0.5,0.0),vec3(1.0,1.0,0.0),\n    vec3(0.0,0.75,0.0),vec3(0.0,0.75,1.0),vec3(0.5,0.0,1.0));\n    \nfloat hash(vec2 v)\n{\n    float h = v.x * 1.0071 + v.y * 0.9873;\n    h = fract((h+0.00103)*v.x*0.927) + fract((h+0.0010421)*v.y*1.0219);\n    h = fract(h*2184.72427142 + 1.732);\n    h = fract(h * 21982.623632 + 4.637235);\n    return h;\n}\n\nfloat sFac(float f)\n{\n    return 0.5-cos(clamp(f,0.0, 1.0)*pi)*0.5;\n}\n\nfloat aastep(float x, float y, float px)\n{\n\treturn clamp(y-x,0.0,1.0/px)*px;\n}\n\nfloat grid(vec2 uv, vec2 size)\n{\n\tvec2 uv0 = floor(uv);\n    \n    return aastep(uv.x - uv0.x, size.x, 40.0)\n         + aastep(1.0 + uv0.x - uv.x, size.x, 40.0)\n         + aastep(uv.y - uv0.y, size.y, 40.0)\n         + aastep(1.0 + uv0.y - uv.y, size.y, 40.0);\n}\n\nfloat vector(vec2 v0, vec2 v, vec2 uv, float dotSize, float lineWidth)\n{\n    lineWidth *= 0.7;\n    v *= 0.45;\n    \n    vec2 v1 = uv - v0;\n    float v1Len = length(v1);\n    \n    float dotVal = aastep(v1Len, dotSize, 40.0);\n    \n    vec2 vDot = vec2(dot(v1,v) , dot(vec2(-v.y,v.x),v1));\n    \n    float vecVal = aastep(vDot.x,0.0,40.0)*aastep(abs(vDot.y), lineWidth, sqrt(2.0)*40.0)*aastep(v1Len, length(v), 40.0);\n        \n    return max(dotVal, vecVal);\n}\n\nfloat gradient(vec2 v0, vec2 v, vec2 uv)\n{\n    vec2 v1 = v0 - uv;   \n    return dot(v1,v);\n}\n\nfloat pNoiseTransition(vec2 uv)\n{\n    //calculate positions of quad corners\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n    //calculate colors of gradient for four vectors\n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    //calculate x and y distance to interpolate between four gradients\n    vec2 fac = uv-v0;\n\n    //calculate transition between gradients view and noise view.\n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //use transition to calculate final mix curve.\n    //(stretch fac relative to 0.5, from normal - 1.0 scale, for noise, to 32.0 for gradients view)\n    fac = (fac-0.5)*pow(32.0,transition)+0.5;\n    \n    //use clamped cosine interpolation to get smoothed step for gradient\n    //and smooth transition for noise view\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    //Use fac.x to mix gradients in x\n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    //Use fac.y to mix gradients in y (already mixed in x)\n    float g = mix(g01,g23,fac.y);\n    \n    //Move result from <-0.5,0.5> range to <0.0,1.0>\n    return g*0.5+0.5;\n}\n\nfloat pNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/50.0 + 2.0*iTime*0.1;\n\n    //grid and vectors alpha (1.0 - transparency)\n    float transition = (clamp(sin(iTime*0.5)*0.25+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //draw grid\n    float gridRet = grid(uv,vec2(0.025,0.025))*transition;\n    \n    //draw gradient vectors (red ones)\n    vec2 v0 = floor(uv+0.5);\n    float vecRet = vector(v0 , gradients[int(hash(v0)*4.0)], uv, 0.06, 0.03)*transition;\n    \n    \n    //draw perlin noise with [gradient - noise] transition\n    float gradRet = pNoiseTransition(uv);\n    \n\t//calculate alpha for noise\n    float NoGrad = clamp(1.0 - gridRet - vecRet, 0.0 ,1.0);\n    \n    fragColor = vec4(vec3(gradRet)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt23zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 428, 428, 643], [645, 645, 666, 666, 714], [716, 716, 758, 758, 794], [796, 796, 828, 828, 1055], [1057, 1057, 1129, 1129, 1511], [1513, 1513, 1555, 1555, 1605], [1607, 1607, 1640, 1682, 2986], [2988, 2988, 3011, 3011, 3584], [3586, 3586, 3643, 3693, 4435]], "test": "ok"}
{"id": "Wt2GDz", "name": "Sin move", "author": "avin", "description": "simple for+sin experiment", "tags": ["wave", "sin"], "likes": 23, "viewed": 668, "published": "Public API", "date": "1559160828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n#define BLACK_COL vec3(16,21,25)/255.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime*2.;\n    for(float i = 0.; i< 30.;i+=1.){\n        float sv = sin(uv.x*10. + cos(t+i*.4))*.1;\n        float y = uv.y + i*.025 - .15;\n        m += (SS(y, sv) - SS(y + .001 * (0. + i*.5), sv)*.975)*(.75+i*.01) ;\n    }\n           \n    vec3 col = mix(BLACK_COL, (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))), m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2GDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 182, 182, 631]], "test": "ok"}
{"id": "Wt2GRh", "name": "Snake deform", "author": "eliemichel", "description": "Study around the snake() function, to build uv-space shaped like a snake, where each section is half a circle.", "tags": ["2d", "distancefield", "spacebending"], "likes": 7, "viewed": 467, "published": "Public API", "date": "1558574865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Released under the MIT licence\n// Copyright (c) 2019 - Alt144 (Élie Michel)\n// Study around the snake() function, to build uv-space shaped like a snake,\n// where each section is half a circle.\n\n#define PI 3.141593\n\nfloat pbeat(float t, float p)\n{\n    return pow(1. - fract(t), p);\n}\n\nmat2 rot(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, s, -s, c);\n}\n\nfloat fill(float d)\n{\n    return smoothstep(.01, .0, d);\n}\n\nfloat sat(float x) { return clamp(x, 0., 1.); }\n\nfloat triangle(vec2 uv, float radius)\n{\n    return min(\n        fill(abs(uv.y) + (uv.x - radius) * tan(PI/6.)),\n    \tfill(-uv.x - radius)\n    );\n}\n\nfloat pattern(vec2 uv)\n{\n    vec2 udx = floor(uv*5.);\n    uv.y += mod(udx.x, 2.)/5. * 0.5;\n    udx = floor(uv*5.);\n    vec2 guv = fract(uv*5.)-.5;\n    guv = rot(0.) * guv;\n    return triangle(guv, mix(0.25, 0.45, pbeat(iTime + udx.x*.01, 10.0)));\n}\n\nfloat lstep(float a, float b, float x)\n{\n    return (x - a) / (b - a);\n}\n\nvec2 ring(vec2 uv, float innerRadius, float outerRadius)\n{\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    uv = vec2(a / PI, sat(smoothstep(innerRadius, outerRadius, r)));\n    return uv;\n}\n\n/**\n * uv: us-space to deform\n * rad1: Radius of the top arcs\n * rad2: Radius of the bottom arcs\n * th: Thickness of the snake\n */\nvec2 snake(vec2 uv, float rad1, float rad2, float th)\n{\n    float radsum = rad1 + th + rad2;\n    vec2 uv0 = uv;\n    vec2 uv2 = uv;\n    \n    uv.x = mod(uv.x - radsum, 2. * radsum) - radsum;\n    uv2.x = mod(uv2.x, 2. * radsum) - radsum;\n    \n    uv = ring(uv, rad1, rad1 + th);\n    uv2 = ring(uv2 * vec2(-1.,1.), rad2, rad2 + th);\n    float mid = (rad2+th/2.)/radsum;\n    uv2.x = mix(0.0, mid, lstep(-1.0, 0.0, uv2.x));\n    uv.x = mix(mid, 1.0, lstep(0.0, 1.0, uv.x));\n    uv2.y = 1. - uv2.y;\n    vec2 uv3 = mix(uv, uv2, step(0., -uv0.y));\n\n    uv = mix(uv, uv2, step(0., -uv0.y));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.x;\n    vec2 uv0 = uv;\n    float rad = 0.3;\n    float th = 0.1;\n    \n    uv = snake(uv, rad - th, rad, th);\n    uv.x *= 4./5.;\n    \n    float ss = 0.05;\n    float t = mix(0., 1., fract(iTime * .5));\n    float test = step(t,uv.x) * step(uv.x, t+ss);\n    test *= step(.1, uv.y) * step(uv.y, 0.9);\n    \n    vec2 tuv = uv - vec2(iTime*0.1,0.);\n    vec3 col = vec3(0., pattern(tuv), test);\n    \n    col = vec3(1.,1.,.9);\n    col = mix(col, vec3(.95, 0.15, 0.1), fill((abs(fract(tuv.x*5.-.05)-0.5)-0.15)*2.0));\n    col = mix(col, vec3(.9, 0.7, 0.2), fill((abs(fract(tuv.x*5.+.05)-0.5)-0.15)*2.0));\n    col = mix(col, vec3(.05, 0.35, 0.9), fill((abs(fract(tuv.x*5.)-0.5)-0.15)*2.0));\n    \n    col = mix(col, vec3(.1), pattern(tuv * vec2(15.,1.)) * step(.001, tuv.y) * step(tuv.y, .999));\n    \n    float o = 0.07;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    col = mix(col, vec3(.1), fill(max(.45 - uv.y, uv.y - .55) * 0.35));\n    \n    o = -o;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    col = mix(col, vec3(.1), fill(max(.45 - uv.y, uv.y - .55) * 0.35));\n    \n    o -= 0.01;\n    uv = snake(uv0, rad-th - o, rad + o, th);\n    //col = mix(col, vec3(.1), fill((.55 - uv.y) * 0.35));\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2GRh.jpg", "access": "shaders20k", "license": "mit", "functions": [[219, 219, 250, 250, 286], [288, 288, 307, 307, 383], [385, 385, 406, 406, 443], [445, 445, 465, 465, 492], [494, 494, 533, 533, 640], [642, 642, 666, 666, 890], [892, 892, 932, 932, 964], [966, 966, 1024, 1024, 1168], [1170, 1301, 1356, 1356, 1897], [1899, 1899, 1956, 1956, 3241]], "test": "ok"}
{"id": "wt2GzW", "name": "Random Circles Gen", "author": "onepride", "description": "random circles generation", "tags": ["noise", "circle", "random"], "likes": 12, "viewed": 388, "published": "Public", "date": "1558719916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define lerp   mix\n#define frac   fract\n#define fmod   mod\n\nfloat  noise(float param)   { return frac(sin(param) * 43758.937545312382); }\n\nfloat2 noise2(float2 param) { return frac(sin(param) * 43758.937545312382); }\n\nfloat3 circle(float2 uv, float seed)\n{\n    float rnd = noise(seed);\n    float period = 2.0 + 2.0*rnd;\n    float age = fmod(iTime + seed, period);\n    float nAge = age / period;\n    float t = floor(iTime - age + 0.5) + seed;\n    \n    float2 n = noise2(float2(t, t + 42.34231));\n    \n    float grad = length((uv*2.0-1.0) - n);\n    \n    nAge = sqrt(nAge);\n    \n    //shape\n    float r = 1.0;\n    r *= smoothstep(0.3*nAge, 0.8*nAge, grad);\n    r *= 1.0-smoothstep(0.8*nAge, 1.0*nAge, grad);\n    \n    //opacity\n    r *= sin(nAge*3.1415);\n    //r *= 1.0-nAge*nAge;\n    \n    float3 clr = float3(1.0, 0.5, 0.3);\n    \n    float3 clrBase = float3(1.0, 0.8, 0.3);\n    float3 clrOpposite = float3(1.0) - clrBase;\n    \n    return float3(r) * mix(clrBase, clrOpposite, 0.5 + sign(n.x-0.5) * (0.5+0.5*n.y) );\n    \n    return float3(r);// * clr * (0.3+0.7*frac(100.0*float3(n.x, n.y, 1.0-n.x*n.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    uv.x *= iResolution.x / iResolution.y;\n\n    float3 c = float3(0.0);\n    c.rgb  = circle(uv, 0.321517);\n    c.rgb += circle(uv, 1.454352);\n    c.rgb += circle(uv, 2.332126);\n    c.rgb += circle(uv, 3.285356);\n    c.rgb += circle(uv, 4.194621);    \n    \n    //tone mapping\n    float lum = dot(c.rgb, float3(0.3333));\n    if(c.r>1.0) c.r = 2.0 - exp(-c.r + 1.0);\n    if(c.g>1.0) c.g = 2.0 - exp(-c.g + 1.0);\n    if(c.b>1.0) c.b = 2.0 - exp(-c.b + 1.0);\n    \n    fragColor.rgb = c*0.7;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2GzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 149, 149, 197], [199, 199, 228, 228, 276], [278, 278, 316, 316, 1163], [1165, 1165, 1222, 1222, 1753]], "test": "ok"}
{"id": "Wt2Gzz", "name": "MultiPat", "author": "Del", "description": "pattern", "tags": ["sin", "pattern"], "likes": 4, "viewed": 307, "published": "Public API", "date": "1558305421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2xpatterns (mod overlay) - del 20/05/2019 - sin for the win.\n\nvec3 pat1(vec2 pos)\n{\n    pos*=0.5;\n    pos+=vec2(0.5);\n\tfloat vv = pos.y*pos.y;\n\tvv*=sin(pos.x*3.14);\n\tfloat v = (sin(sin(pos.x*15.0)*4.0+(vv) *50.0 + iTime * 2.0))+0.65;\n\tfloat stime = 0.5+sin(iTime*4.0)*0.5;\n\tvec3 col = vec3( v*0.45, .35*v, 0.25+0.2*v) * (1.5-stime*0.4);\n    return col;\n}\n\nmat2 rot(float a)\n{\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 back = pat1(pos);\n    \n    float ns = 0.5+sin(iTime*0.7)*0.5;\n    pos*=1.5+(ns*1.1);\n    pos.x+=iTime*0.4;\n    float c = pMod1(pos.x,0.58);\n    pos.y+= cos(iTime*0.2+c);\n    float c2 = pMod1(pos.y,0.58);\n    pos  *= rot(iTime+c2*3.0);\n    float d = 3.0-length(6.0*pos*pos)*7.0;\n    \n    pos*=rot(pos.x*5.0+iTime*0.6+log(d));\n    pos+=vec2(0.5);\n\tfloat vv = (c2+pos.y*pos.y+pos.x*d*d*1.61) + sin(pos.x*12.14);\n\tvv = sin(sin(pos.x*22.6)*1.0+(vv) * 0.5 + iTime * 2.0);\n    \n    float s = sign(vv);\n    vv = abs(vv);\n\tvec3 col1 = s>0.0 ? vec3( vv*.5, .05+0.3*vv, 0.0) : vec3( vv*0.14, 0.2*vv, 0.1*vv);\n    col1 = clamp(col1*d,0.0,1.0);\n    fragColor = vec4(mix(back, col1, smoothstep(0.5,1.0,d)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2Gzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 86, 86, 357], [359, 359, 378, 378, 448], [450, 450, 490, 490, 611], [613, 613, 670, 670, 1449]], "test": "error"}
{"id": "wtB3RD", "name": "Traced Columns - Hamneggs fork", "author": "abje", "description": "a fork of [url=https://www.shadertoy.com/view/wt23z1]Traced Columns[/url]\nThis is faster.", "tags": ["raytracing", "ray", "tracing", "interior", "columns", "towers", "boxes"], "likes": 8, "viewed": 466, "published": "Public API", "date": "1558718760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nhttps://shadertoy.com/view/wt23z1\nthe original is a shader by hamneggs and looks identical,\nbut i only modified the tunnel and tunnelshadow function so it is faster\n*/\n\n// Fork of \"Traced Columns\" by Hamneggs. https://shadertoy.com/view/wt23z1\n// 2019-05-23 18:02:02\n\n/**\n * This just traces through a field of cubes that make a box, plus two\n * extra cubes plus lightsources.\n */\n\n\n\n#define ENABLE_SHADOWS /* Compute intensive */\n#define ENABLE_NORMAL_MAPPING\n#define ENABLE_SPECULAR\n\n#define MAT_REFLECTANCE 3.0\n#define BRIGHTNESS 10.0\n#define ID_NONE 0.0\n#define ID_TUNNEL 1.0\n#define ID_LIGHT1 2.0\n#define ID_LIGHT2 4.0\n#define LIGHT1_COLOR vec3(.8,.05,.667)\n#define LIGHT2_COLOR vec3(.05,.05,2.0)\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, vec3(0,1,0))*uv.x + vec3(0,1,0)*uv.y)-ro);\n}\n\n/**\n * Minimum of two 2D vectors.\n */\nvec2 min2( in vec2 a, in vec2 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 3D vectors.\n */\nvec3 min4( in vec3 a, in vec3 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Minimum of two 4D vectors.\n */\nvec4 min4( in vec4 a, in vec4 b )\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\n/**\n * Takes the minimum of two intersections.\n */\nvoid minInt(in float distA,  in vec3 normA,  in vec2 uvA,\n            in float distB,  in vec3 normB,  in vec2 uvB,\n            out float distM, out vec3 normM, out vec2 uvM)\n{\n    if ( distA < distB ) { distM = distA; normM = normA; uvM = uvA; }\n    else                 { distM = distB; normM = normB; uvM = uvB; }\n}\n\n/**\n * That random function off of SF.\n */\nfloat rand( in vec2 co )\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n/**\n * 3D version.\n */\nfloat rand3( in vec3 co )\n{\n    return fract(sin(dot(co ,vec3(12.9898,78.233,-53.1234))) * 43758.5453);\n}\n\n/**\n * Sorta the usual FBM, but without using a noise texture and adding\n * high frequency noise at the end.\n */\nfloat fbm( in vec2 x )\n{\n    float r = texture(iChannel0, x     ).x*.5;\n    r += texture(iChannel0, x*2.0 ).x*.25;\n    r += texture(iChannel0, x*4.0 ).x*.125;\n    r += texture(iChannel0, x*8.0 ).x*.0625;\n    r += rand(x)*.0325;\n    return r;\n}\n    \n\n/**\n * Reference function for light positions.\n */\nvec3 lightpos1() { return vec3(sin(iTime*.5)*3., cos(iTime), 2.+sin(iTime)); }\nvec3 lightpos2() { return vec3(sin(iTime)*3.0, -cos(iTime*.5)*.5, 0); }\n\n/**\n * A kinda sorta smoothsquare function.\n */\nfloat smoothSquare(in float x) { return smoothstep(.3, .7, pow(sin(x),2.)); }\n\n/**\n * IQ Really nailed this one.\n */\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n/**\n * IQ's sphere intersection.\n */\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(99999.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n/**\n * IQ's Box intersection.\n */\nfloat iBox( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    // compute normal (in world space), face and UV\n    if( t1.x>t1.y && t1.x>t1.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t1.x; }\n    else if( t1.y>t1.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t1.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t1.z; }\n\n    return tN; // maybe min(tN,tF)?\n}\n\n\n/**\n * A simplified version.\n */\n#ifdef ENABLE_SHADOWS\nfloat iBoxSimple( in vec3 row, in vec3 rdw, in mat4 txx, in vec3 rad ) \n{\t\t\t\t \n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return 99999.0;\n\n    return tN;\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Takes a ray, walks it forward, and see if it intersects\n * any columns near it.\n */\nvoid tunnel( in vec3 ro, in vec3 rd, out float d, out vec3 n, out vec2 uv )\n{\n    uv = vec2(0);\n    \n    d = 0.0;\n    float d2 = 9999.0;\n    vec3 fp = floor(ro);\n    vec3 lp = ro-fp;\n    vec3 ird = 1.0/abs(rd);\n    vec3 srd = sign(rd);\n    \n    vec3 lens = abs(step(0.0,rd)-lp)*ird;\n    \n    for (int i = 0; i < 20; i++) {\n        \n        //towers pointing in negative x,y,z direction (the ceiling and two walls)\n        vec3 a = vec3( 0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))+3.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))+2.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))+3.5);\n        \n        //towers pointing in positive x,y,z direction (the floor and two walls)\n        vec3 b = vec3(-0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))-3.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))-2.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))-3.5);\n        \n        // center of opposing towers\n        vec3 e = (a+b)*0.5;\n        // gap between opposing towers\n        vec3 c = e-b;\n        \n        // position in each direction relative to\n        // the tower centers\n        vec3 p = (ro+rd*d)-e;\n        \n        // the intersection distance to each tower\n        // not from the sides, just the top\n        // clamped to 0\n        vec3 f = (c-srd*p)*ird*step(abs(p),vec3(c));\n        \n        //mask finds the smallest number in f\n        vec3 mask2;\n        if (f.x < min(f.y,f.z)) {\n        \tmask2 = vec3(1,0,0);\n        } else if (f.y < f.z) {\n            mask2 = vec3(0,1,0);\n        } else {\n            mask2 = vec3(0,0,1);\n        }\n        \n        // dot(mask2,f) is the same as min(min(f.x,f.y),f.z)\n        float d2 = dot(mask2,f);\n        \n        // since d2 is clamped to 0,\n        // if it is 0 you hit a tower from the side\n        // the normal is already set\n        // exit the loop\n        if (d2 == 0.0) {\n            break;\n        }\n        \n        d2 += d;\n        \n        // finds the closest voxel the ray intersects\n        vec3 mask;\n        if (lens.x < min(lens.y,lens.z)) {\n        \tmask = vec3(1,0,0);\n        } else if (lens.y < lens.z) {\n            mask = vec3(0,1,0);\n        } else {\n            mask = vec3(0,0,1);\n        }\n        \n        // dot(mask, lens) is the same as min(min(f.x,f.y),f.z)\n        d = dot(mask,lens);\n        \n        // if the distance to the closest tower is less than\n        // that to the next voxel, set the normal to the direction\n        // the tower is facing, and exit the loop\n        if (d2 < d) {\n            d = d2;\n            n = mask2*srd;\n            break;\n        }\n        \n        n = mask*srd;\n        \n        fp += n;\n        \n        lens += mask*ird;\n    }\n    \n    // the normal is flipped,\n    // so i flip it back\n    n = -n;\n    vec3 p = ro+rd*d;\n    \n    uv = vec2(dot(n.yzx,p),dot(n.zxy,p));\n    \n    // Now it's time to get the two feature cubes in the middle.\n    \n    vec3 n_f1, n_f2; // Surface normals.\n    vec2 uv_f1, uv_f2; // Texcoords.\n    \n    // Translation matrices.\n    mat4 t_f1 = translate(-.6,-.6,-.6); mat4 t_f1i = inverse(t_f1);\n    mat4 t_f2 = translate( .6, .6, .6); mat4 t_f2i = inverse(t_f2);\n    \n    // Check for intersection.\n    float dist_f1 = iBox(ro, rd, t_f1, t_f1i, vec3(.5), n_f1, uv_f1);\n    float dist_f2 = iBox(ro, rd, t_f2, t_f2i, vec3(.5), n_f2, uv_f2);\n    \n    // Factor them into the equation.\n    minInt( d, n, uv, dist_f1, n_f1, uv_f1, d, n, uv );\n    minInt( d, n, uv, dist_f2, n_f2, uv_f2, d, n, uv );\n    \n    // Perturb the surface normal.\n    #ifdef ENABLE_NORMAL_MAPPING\n    p = ro+d*rd;\n    vec2 texCoord = uv+rand3(floor(p)); \n    vec3 diff = vec3(fbm(texCoord), fbm(texCoord+12348.3), 0);\n    diff = 2.0*diff - 1.0;\n    diff *= .125;\n    vec3 an = abs(n);\n    if( an.x > .5 ) \t n = normalize(n+diff.zxy*sign(n.x));\n    else if( an.y > .5 ) n = normalize(n+diff.xzy*sign(n.y));\n    else\t\t\t\t n = normalize(n+diff.xyz*sign(n.z));\n    #endif // ENABLE_NORMAL_MAPPING\n}\n\n/**\n * Traces a ray through the field. This trace function includes\n * two spheres for the light soruces.\n */\nvoid trace( in vec3 ro, in vec3 rd, out float id, out float dist, out vec3 n, out vec2 uv)\n{\n    tunnel(ro, rd, dist, n, uv);\n    float si1 = iSphere(ro, rd, lightpos1(), .05).x;\n    float si2 = iSphere(ro, rd, lightpos2(), .05).x;\n   \t\n    vec2 minElement = vec2(9999999.0, ID_NONE);\n    minElement = min2(minElement, vec2(dist, ID_TUNNEL));\n    minElement = min2(minElement, vec2(si1,  ID_LIGHT1));\n    minElement = min2(minElement, vec2(si2,  ID_LIGHT2));\n   \tdist = minElement.x;\n    id = minElement.y;\n            \n}\n\n/**\n * Marches a ray forward through a simplified geometry field, since\n * we don't need the UV or normal vector of where the shadow ray\n * collides.\n */\n#ifdef ENABLE_SHADOWS\nvoid tunnelShadow( in vec3 ro, in vec3 rd, out float d )\n{\n    \n    d = 0.0;\n    float d2 = 9999.0;\n    vec3 fp = floor(ro);\n    vec3 lp = ro-fp;\n    vec3 ird = 1.0/abs(rd);\n    vec3 srd = sign(rd);\n    \n    vec3 lens = abs(step(0.0,rd)-lp)*ird;\n    \n    for (int i = 0; i < 20; i++) {\n        \n        //towers pointing in negative x,y,z direction (the ceiling and two walls)\n        vec3 a = vec3( 0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))+3.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))+2.5,\n                       0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))+3.5);\n        \n        //towers pointing in positive x,y,z direction (the floor and two walls)\n        vec3 b = vec3(-0.5*smoothSquare(.25*iTime + 3.14*rand(fp.yz+1.0))-3.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xz+1.0))-2.5,\n                      -0.5*smoothSquare(.25*iTime + 3.14*rand(fp.xy+1.0))-3.5);\n        \n        // center of opposing towers\n        vec3 e = (a+b)*0.5;\n        // gap between opposing towers\n        vec3 c = e-b;\n        \n        // position in each direction relative to\n        // the tower centers\n        vec3 p = (ro+rd*d)-e;\n        \n        // the intersection distance to each tower\n        // not from the sides, just the top.\n        // clamped to 0\n        vec3 f = (c-srd*p)*ird*step(abs(p),vec3(c));\n        \n        //mask finds the smallest number in f\n        vec3 mask2;\n        if (f.x < min(f.y,f.z)) {\n        \tmask2 = vec3(1,0,0);\n        } else if (f.y < f.z) {\n            mask2 = vec3(0,1,0);\n        } else {\n            mask2 = vec3(0,0,1);\n        }\n        \n        // dot(mask2,f) is the same as min(min(f.x,f.y),f.z)\n        float d2 = dot(mask2,f);\n        \n        // since d2 is clamped to 0,\n        // if it is 0 you hit a tower from the side\n        // so you just exit the loop\n        if (d2 == 0.0) {\n            break;\n        }\n        d2 += d;\n        \n        // finds the closest voxel the ray intersects\n        vec3 mask;\n        if (lens.x < min(lens.y,lens.z)) {\n        \tmask = vec3(1,0,0);\n        } else if (lens.y < lens.z) {\n            mask = vec3(0,1,0);\n        } else {\n            mask = vec3(0,0,1);\n        }\n        \n        // dot(mask, lens) is the same as min(min(f.x,f.y),f.z)\n        d = dot(mask,lens);\n        \n        // if the distance to the closest tower is less than\n        // that to the next voxel, exit the loop\n        if (d2 < d) {\n            d = d2;\n            break;\n        }\n        \n        fp += mask*srd;\n        \n        lens += mask*ird;\n    }\n    \n    mat4 t_f1 = translate(-.6,-.6,-.6);\n    mat4 t_f2 = translate( .6, .6, .6);\n    \n    float dist_f1 = iBoxSimple(ro, rd, t_f1, vec3(.5));\n    float dist_f2 = iBoxSimple(ro, rd, t_f2, vec3(.5));\n    \n    d = min(d, dist_f1);\n    d = min(d, dist_f2);\n}\n#endif // ENABLE_SHADOWS\n\n/**\n * Traces a shadow ray through the distance field.\n */\n#ifdef ENABLE_SHADOWS\nvoid traceShadow( in vec3 ro, in vec3 rd, out float dist)\n{\n    tunnelShadow(ro, rd, dist);\n}\n#endif // ENABLE_SHADOWS\n\n/*\n\tOren-Nayar reflectance modeling. I use this everywhere. Just looks good.\n*/\nfloat orenNayar( in vec3 n, in vec3 v, in vec3 ldir )\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/**\n * Models a point light.\n */\nvec3 pointLight( in vec3 p, in vec3 n, in vec3 lp, in vec3 rd, in vec3 texel, in vec3 lc )\n{\n    \n    vec3 ld = lp-p; \t\t\t\t\t\t\t\t// Direction of light.\n    float dist = length(ld); \t\t\t\t\t\t// Distance to the light.\n    ld = normalize(ld); \t\t\t\t\t\t\t// Normalize for correct trig.\n    float base = orenNayar(n, rd, ld)*BRIGHTNESS; \t// Base lighting coefficient.\n    float falloff = clamp(1.0/(dist*dist),0.0,1.0); // Quadratic coefficient.\n    \n    // Specular.\n    #ifdef ENABLE_SPECULAR\n    vec3 reflection = normalize(reflect(rd,n));\n    float specular = clamp(pow(clamp(dot(ld, reflection),0.0,1.0),25.0),0.0,1.0);\n    #else\n    float specular = 0.0;\n    #endif // ENABLE_SPECULAR\n    \n    // Optionally do shadows.\n    #ifdef ENABLE_SHADOWS\n    float shadowDist;\n    traceShadow(p+ld*.01, ld, shadowDist);\n    float shadow = smoothstep(dist*.99, dist*1.01,shadowDist);\n    #else\n    float shadow = 1.0;\n    #endif // ENABLE_SHADOWS\n    \n    return lc*specular*shadow + base*falloff*shadow*lc*texel + lc*.0125;\n}\n\n/**\n * Lights the entire scene by tracing both point lights.\n */\nvec3 lightScene( in vec3 p, in vec3 n, in vec3 rd, in vec3 texel )\n{\n    \n    return clamp( pointLight(p, n, lightpos1(), rd, texel, LIGHT1_COLOR) +\n              \t  pointLight(p, n, lightpos2(), rd, texel, LIGHT2_COLOR),\n              \t  vec3(0),vec3(1) );\n}\n\n/**\n * Takes it a step further by coloring based on object ID.\n */\nvec3 shade( in vec3 p, in vec3 n, in vec3 rd, in float dist, in float id )\n{\n    if(id == ID_NONE) return vec3(0);\n    else if(id == ID_TUNNEL) return vec3( lightScene(p+rd*dist, n, rd, vec3(1)) );\n    else if(id == ID_LIGHT1) return LIGHT1_COLOR*BRIGHTNESS*2.0;\n    else if(id == ID_LIGHT2) return LIGHT2_COLOR*BRIGHTNESS*2.0;\n    else return vec3(0);\n}\n\n/**\n * Some quick tonemapping and vignetting.\n */\nvec4 postProcess( in vec3 c, in vec2 uv )\n{\n    float vig = 1.0-dot(uv,uv)*.6;\n    c = pow(clamp(c, 0., 1.), vec3(.4545));\n    return vec4(c*vig,1);\n}\n\n/**\n * Entrypoint.\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Set up the camera.\n    \n    // Position.\n    vec3 cp =  vec3(3.0*cos(iTime*.5), sin(iTime*.25), 3.0*sin(iTime*.25));\n    \n    // Direction.\n    vec3 cd = normalize(vec3(-cos(iTime*.5), .5*cos(iTime*.25), -sin(iTime*.25)));\n    \n    // Places to store results.\n    vec3 p, d;\n    \n    // Create the view ray.\n    camera(uv, cp, cd, .667, p, d);\n    \n    // Do the traces.\n    float id; float dist; vec3 n; vec2 texCoord;\n    trace(p, d, id, dist, n, texCoord);\n    \n    // Shade the point.\n    vec3 c = shade(p, n, d, dist, id);\n    \n    \n    \n    // Based on the results of that trace, we shade accordingly.\n    fragColor = postProcess(c, uv);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[707, 885, 972, 972, 1066], [1068, 1106, 1141, 1141, 1191], [1193, 1231, 1266, 1266, 1316], [1318, 1356, 1391, 1391, 1441], [1443, 1494, 1670, 1670, 1812], [1814, 1857, 1883, 1883, 1955], [1958, 1981, 2008, 2008, 2086], [2088, 2201, 2225, 2225, 2444], [2451, 2502, 2520, 2520, 2580], [2581, 2581, 2599, 2599, 2652], [2654, 2702, 2734, 2734, 2779], [2781, 2819, 2864, 2864, 2980], [2982, 3019, 3081, 3081, 3304], [3306, 3340, 3446, 3490, 4273], [4872, 4963, 5040, 5040, 9014], [9016, 9126, 9218, 9218, 9647], [12909, 12989, 13044, 13044, 13345], [13347, 13380, 13472, 13472, 14387], [14389, 14454, 14522, 14522, 14713], [14715, 14782, 14858, 14858, 15136], [15138, 15188, 15231, 15231, 15338], [15340, 15363, 15420, 15420, 16183]], "test": "error"}
{"id": "wtB3Rz", "name": "Gravy Wave CC", "author": "pestrov", "description": "Optimized for Synesthesia ", "tags": ["copy2"], "likes": 4, "viewed": 605, "published": "Public API", "date": "1558260178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* (Fictional) visual of B-mode polarization, indirect evidence of \"primordial\" gravity waves.\n\n  Inspired by http://bicepkeck.org/visuals.html\n \"Gravitational waves from inflation generate a faint but distinctive twisting pattern in\n the polarization of the CMB, known as a \"curl\" or B-mode pattern. For the density\n fluctuations that generate most of the polarization of the CMB, this part of the primordial\n pattern is exactly zero. Shown here is the actual B-mode pattern observed with the BICEP2\n telescope, with the line segments showing the polarization from different spots on the sky.\n The red and blue shading shows the degree of clockwise and anti-clockwise twisting of this\n B-mode pattern.\"\n\n For explanatory info, see:\n http://wwwphy.princeton.edu/cosmology/capmap/polscience.html\n http://physics.stackexchange.com/questions/103934/what-do-the-line-segments-on-the-bicep2-b-mode-polarization-map-mean\n\n*/\n\n/* Overall plan:\n x generate scalar noise f(x, y, t) for each point on the plane, varying over time.\n x for each pixel, color red for positive or blue for negative, white in the middle.\n   => bgcolor\n - for each pixel, find out what grid point we're nearest.\n   - find the degree of twisting for that grid point (a separate noise function?)\n     g(x, y, t) => (m, a) magnitude and angle\n     or maybe that's two separate functions. Anyway...\n   - compute the line segment(rotated rectangle) representing the twisting.\n   - decide whether current pixel is inside, outside, or on the edge of that rectangle.\n   - mix bgcolor and black accordingly.\n     \n*/\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nconst float cellSize = 0.14; // size of each grid cell as portion of viewport\nconst float scale = 1.5;\nfloat time;\nconst float lineThick = 0.01, borderThick = 0.005;\nconst int nSamples = 20;\n\nfloat sampleVolume() {\n\tfloat total = 0.0;\n\tfor (int i=0; i < nSamples; i++) {\n\t\ttotal += texture(iChannel0, vec2(float(i) * 0.5 / float(nSamples), 0.25)).x;\n\t}\n\treturn total / float(nSamples);\n}\n\n// Generate red/white/blue value representing \"twist\" of B-mode polarization.\n// TODO: wish I could get more of the \"loopy\" shape that the real thing has.\n// Could do that using a sort of ripples-from-several-charges effect.\nvec4 twistColor(vec2 p) {\n\tfloat intens = snoise(vec3(p.x, p.y, time)) * 0.9;\n\t// Modify the shape of the curve, keeping it closer to zero longer:\n\t// intens *= intens * intens * 8.0;\n\tfloat i2 = pow(intens, 1.7) * 1.7;\n\n\tif (iChannelTime[0] > 32.0) {\n\t\tfloat sv = sampleVolume();\n\t\ti2 *= (sv * sv + 1.0);\n\t}\n\t\n\tvec4 color;\n\tif (intens > 0.0) {\n\t\tcolor = vec4(1.0, 1.0 - i2, 1.0 - i2, 1.0);\n\t} else {\n\t\tcolor = vec4(1.0 - i2, 1.0 - i2, 1.0, 1.0);\n\t}\n\treturn color;\n}\n\n/*\n// antialias coefficient\n#define aa(d) ((linethick - (d)) / linethick)\n*/\nfloat aa(float d) {\n\treturn (lineThick - d) / lineThick;\n}\n\n// Compute whether p is inside, outside, or on the edge of\n// a rotated rectangle representing blah blah ...\n// Where <= 0 is inside, >= 1 is outside.\nfloat barDist(vec2 p) {\n\t// Find center of grid cell.\n\tvec2 c = floor(p / cellSize + 0.5) * cellSize;\n\n\t// generate amplitude and angle\n\tfloat amp = abs(snoise(vec3(c.xy, time))) * 0.125;\n\tfloat alpha = snoise(vec3(c.xy, time)) * 3.14159;\n\t\n\t//## Here is where I need to write the code for the rotated rectangle\n\t// and its distance test.\n\t\n\tfloat d = distance(p, c);\n\tif (d > amp) return 1.0;\n\t// angle to current pixel from center of circle\n\tfloat a = atan(p.y - c.y, p.x - c.x);\n\t// dist from p to line\n\tfloat dd = abs(sin(alpha - a) * d);\n\tif (dd < lineThick) {\n\t\treturn dd/lineThick;\n\t}\n\t\n\treturn 1.0;\n\t\n}\n\nconst vec4 black = vec4(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (-1.0 + 2.0*q) * scale;\n    p.x *= iResolution.x / iResolution.y;\n\n    time = iTime * 0.1;\n    \n\tvec4 bgColor = twistColor(p);\n\t\n\tfloat d = barDist(p);\n\tfragColor = mix(black, bgColor, d);\n\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3Rz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1913, 1913, 1934, 1934, 1983], [1985, 1985, 2006, 2006, 2055], [2057, 2057, 2079, 2079, 2119], [2121, 2121, 2149, 2149, 2201], [2203, 2203, 2227, 2227, 4342], [4537, 4537, 4559, 4559, 4732], [4734, 4959, 4984, 4984, 5425], [5427, 5504, 5523, 5523, 5562], [5564, 5715, 5738, 5768, 6325], [6358, 6358, 6415, 6415, 6662]], "test": "error"}
{"id": "WtB3W1", "name": "Bouncy Spring ", "author": "mosaic", "description": "Simple Plot function borrowed from https://thebookofshaders.com/05/\n\n\nBonus: stretch the spring with the mouse :)", "tags": ["2d"], "likes": 1, "viewed": 111, "published": "Public", "date": "1559277035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat plot(vec2 st, float b){\n  return  smoothstep( b-0.02, b, st.y) -\n          smoothstep( b, b+0.02, st.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n       \n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.x;\n    vec4 m = iMouse / iResolution.xxxx;\n \n\tfloat pct = 0.2;\n    float y = uv.x;\n    \n    if (m.z > 0.){\n       pct += plot(uv,((sin(y*30.*sin(1.-m.x))/10.)+0.3))+0.3*uv.y*2.;\n    }  else     {\n       pct += plot(uv,((sin(y*30.*sin(iTime))/10.)+0.3))+0.3*uv.y*2.;\n         \n     }\n    \n    \n    // Output to screen\n    fragColor = vec4(pct+.0,pct+.0,pct+.6,1.0)*vec4(0.95,0.5,0.,0.)+vec4(0.2,0.2,0.5,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtB3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 30, 113], [116, 116, 173, 236, 686]], "test": "ok"}
{"id": "wtB3zw", "name": "computer grid", "author": "tristanwhitehill", "description": "grid", "tags": ["simple"], "likes": 1, "viewed": 132, "published": "Public", "date": "1558854002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*tan( (iTime*.004)*130.0 * k*fract( cos (x.x/x.y/(x.x*x.y))) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p*  floor(iTime*.4)*10. );\n\t\n\tvec2 u = f*f*floor(1.0-8.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\n    float mathy =cos(iTime*.07)*mod(r.y,iTime);\n     float n= floor(noise(10.*r));\n\tvec3 backgroundColor = vec3(0.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.0,1.0,.3);\n    \n\n\tvec3 pixel = backgroundColor;\n\t\n\n\tconst float tickWidth = .005;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\n\t\tif(fract(sin((iTime+.05)+r.x + i))<0.002) pixel = gridColor;\n\t\tif(fract(cos((iTime+.03)+r.y - i))<0.002) pixel = gridColor;\n    }\n  \n\tfragColor = vec4(pixel/(n/r.x), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 178], [180, 180, 206, 206, 631], [632, 632, 689, 689, 1226]], "test": "ok"}
{"id": "WtBGRm", "name": "Meta Cubes", "author": "jblanper", "description": "It uses 4 primitives (2 cubes and 2 spheres, one with some displacement).", "tags": ["3d", "raymarching", "bw"], "likes": 1, "viewed": 79, "published": "Public", "date": "1558792558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define EPSILON .001\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sphereSDF (vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sceneSDF (vec3 p) {\n  p.xz *= rotate(iTime * .2);\n  p.yz *= rotate(iTime * .2);\n\n  float s = sphereSDF(p - vec3(0.), 1.);\n  s += sin(cos(iTime) + 5.*p.x) * sin(5.*p.y) * sin(5.*p.z) * .25;\n\n  float c = boxSDF(p - vec3(0.), vec3(.8));\n\n  p.xz *= rotate(iTime * .6);\n  p.yz *= rotate(iTime * .5);\n\n  float s2 = sphereSDF(p - vec3(0.), .3);\n  float c2 = boxSDF(p - vec3(0.), vec3(.25));\n  float d = max(c2, -s2);\n\n  return min(max(c, -s * .4), d);\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.001, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    if (depth >= MAX_DIST) break;\n    depth += dist;\n  }\n  return 0.;\n}\n\nfloat getLight (vec3 lightPos, vec3 p, float britghness) {\n  vec3 light = normalize(lightPos - p) * britghness;\n  vec3 normal = getNormal(p);\n\n  float diff = clamp(dot(normal, light), 0., 1.);\n\n  return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 ro = vec3(0., 0., -5.);\n  ro.z *= sin(iTime * .2) * .5 + .8;\n  vec3 rd = normalize(vec3(uv, 2.));\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 light2 = vec3(2., 0., 2.);\n    light2.xz *= rotate(iTime);\n    vec3 light1 = vec3(0., 0., 0.);\n    color += getLight(light1, p, .8);\n    color += getLight(light2, p, 1.);\n  } \n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 138], [140, 140, 175, 175, 201], [203, 203, 233, 233, 318], [320, 320, 345, 345, 772], [774, 774, 799, 799, 960], [962, 962, 997, 997, 1211], [1213, 1213, 1271, 1271, 1423], [1425, 1425, 1482, 1482, 2002]], "test": "timeout"}
{"id": "WtBGWR", "name": "Second Shot", "author": "sgiobairog", "description": "Partway to a hypno circle then just winged it.", "tags": ["shaders"], "likes": 2, "viewed": 315, "published": "Public API", "date": "1558981599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centre = vec2(0.5 * sin(iTime), 0.5 * sin(iTime));\n    \n    uv = uv * 10.0;\n    \n    vec2 pos = uv - centre;\n    pos.y /= iResolution.x/iResolution.y;\n    \n    float dist = length(pos);\n    \n    dist = pow(dist, 0.5);\n    dist -= iTime*0.1;\n    dist *= 10.0;\n    dist *= fract(dist);\n    \n        \n    float angle = atan(pos.x, pos.y);\n    // Normalized pixel coordinates (from 0 to 1)\n\n    dist += angle;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(dist + uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 664]], "test": "ok"}
{"id": "wtBGz1", "name": "Gas clouds", "author": "skythedragon", "description": "A simple gas cloud testing ground", "tags": ["raymarching", "clouds"], "likes": 2, "viewed": 185, "published": "Public", "date": "1558455470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEPS = 64;\nconst float STEP_SIZE = 1.0;\nconst float STEP_INCREMENT = 1.0;\n\n\n// noise and random\n// =============================================================================================================================\n\n// random float\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// these hash functions are by dave hoskins\n\n// random vector\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// noise\n// =============================================================================================================================\n\n// by iq, https://www.shadertoy.com/view/4sfGzS\n\nfloat fnoise(vec3 x) {\n\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(p+vec3(0,0,0)), \n                        hash13(p+vec3(1,0,0)),f.x),\n                   mix( hash13(p+vec3(0,1,0)), \n                        hash13(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(p+vec3(0,0,1)), \n                        hash13(p+vec3(1,0,1)),f.x),\n                   mix( hash13(p+vec3(0,1,1)), \n                        hash13(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 vnoise(vec3 x) {\n\n\tvec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash33(p+vec3(0,0,0)), \n                        hash33(p+vec3(1,0,0)),f.x),\n                   mix( hash33(p+vec3(0,1,0)), \n                        hash33(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash33(p+vec3(0,0,1)), \n                        hash33(p+vec3(1,0,1)),f.x),\n                   mix( hash33(p+vec3(0,1,1)), \n                        hash33(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Raymarching\n// =============================================================================================================================\n\n// get the color at the current position\nvec3 get_color(vec3 pos) {\n\t// gas cloud color\n    float n = fnoise(pos/1000.0);\n   \treturn (fnoise(pos/10.0) * vnoise(pos/50.0) ) * cos(n*10.0) * sin(n*10.0) * 2.0;\n}\n\nvec3 march(vec3 eye, vec3 dir) {\n\tvec3 pos = eye;\n    vec3 col = vec3(0.0);\n    float step_size = STEP_SIZE;\n    float step_contribution = 1.0/float(STEPS);\n    // loop\n    for (int i = 0; i < STEPS; ++i) {\n        // increment the position\n        pos += dir*step_size;\n        // decrease the step contribution\n        step_size *= STEP_INCREMENT;\n        // step_contribution /= STEP_INCREMENT;\n        // get the color\n    \tcol += get_color(pos)*step_contribution;\n    }\n    return col;\n}\n\n// ray direction\nvec3 ray_dir(vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( radians(22.5) );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // default ray dir\n\tvec3 dir = ray_dir(iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3(100.0, 100.0, -iTime*8.0 - 100.0);\n    \n    // get the color\n    vec3 col = march(eye, dir);\n\n    // Output to screen\n    fragColor = vec4(col, 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 253, 276, 276, 379], [552, 569, 590, 590, 739], [741, 741, 763, 763, 888], [1078, 1078, 1100, 1100, 1588], [1590, 1590, 1611, 1611, 2099], [2246, 2287, 2313, 2333, 2454], [2456, 2456, 2488, 2488, 2948], [2950, 2967, 3002, 3002, 3158], [3160, 3160, 3217, 3240, 3486]], "test": "ok"}
{"id": "wtBGzD", "name": "Point line noise", "author": "bozhkov", "description": "Exercise on points, repetition and noise", "tags": ["noise", "line", "points"], "likes": 2, "viewed": 162, "published": "Public", "date": "1558639783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define circle(st, center, radius) smoothstep(1., .7, distance(st, center) / radius)\n#define random(x) fract(sin(x) * 1e6)\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    \n    float y = mix(random(i), random(i + 1.), smoothstep(0., 1., f));\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.y;\n    \n    float r = .015,\n        d = .006,\n        i = floor(st.x / (2.*r + d)),\n        nIndex = i * .11 + iTime * 2.,\n        nScale = .15,\n        y = noise(nIndex) - .5;\n    \n    vec2 pos = vec2(d*i + r + 2.*r*i, .5 + y * nScale);\n    \n    fragColor = circle(st, pos, r) * vec4(.5, .9, .4, 1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 146, 146, 284], [286, 286, 343, 343, 685]], "test": "ok"}
{"id": "wtBGzw", "name": "Liquid Polka Dots", "author": "marcelliino", "description": "Simple liquid distortion", "tags": ["dots", "polka"], "likes": 4, "viewed": 139, "published": "Public", "date": "1558840778", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n        uv = (1.0 - 2.0 * uv) * vec2(iResolution.x / iResolution.y, 1);\n    \n    vec2 uv_n = uv*2.2;\n    float len;\n    const int mult = 13;\n    for(int i = 0; i < mult; i++){\n        len = length(uv_n);\n        uv_n.x += sin(uv_n.y - cos(len)) + cos(iTime/9.0);\n        uv_n.y += cos(uv_n.x - sin(len)) + sin(iTime/12.0);\n    }\n    \n    uv = fract(uv*2.0)-0.5;\n    uv = mix(uv, uv*sin(len), 0.4);\n    float shape = step(0.25, length(uv));\n    \n    vec3 col = vec3(shape);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBGzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 663]], "test": "ok"}
{"id": "wtf3DB", "name": "Fractal Tree - 2D", "author": "ikuto", "description": "reference:\nhttps://someuser-321.github.io/TreeGenerator/index.html\nhttps://www.shadertoy.com/view/Xds3zM", "tags": ["2d", "fractal", "tree", "recursion"], "likes": 14, "viewed": 832, "published": "Public API", "date": "1557500580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n#define SIZE \t\t\t\t0.2\n#define MAX_DEPTH \t\t\t7\n#define SPLIT_ANGLE \t\tPI / 6.0\n#define LENGTH_VARIATOPN\t0.5\n#define FLOWER_PROBABILITY\t0.7\n\nstruct Branch\n{\n\tvec2  pos;\n    float len;\n    float angle;\n    float width;\n    int   depth;\n};\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n#define V2(len, angle) vec2(len*sin(angle), len*cos(angle))\nfloat udFlower(in vec2 p, float id)\n{\n    float sz = 0.003*(1.0+0.5*hash11(1436.986*id));\n    float angle = PI * hash11(7491.143*id);\n    float d = udLine(p, -V2(sz, angle), V2(sz, angle));\n    d = min(d, udLine(p, -V2(sz, angle+PI*0.25), V2(sz, angle+PI*0.25)));\n    d = min(d, udLine(p, -V2(sz, angle+PI*0.5), V2(sz, angle+PI*0.5)));\n    d = min(d, udLine(p, -V2(sz, angle+PI*0.75), V2(sz, angle+PI*0.75)));\n    return d;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 color = vec3(0.0);\n    \n    Branch stack[MAX_DEPTH + 1];\n    stack[0] = Branch(vec2(0.5, 0.0), SIZE, 0.0, 0.01, 0); //push\n\tfloat branchID = 0.0;\n    \n    for (int stackPos = 0; stackPos >= 0; branchID += 1.0) //execute loop until the stack is empty\n    {\n        Branch branch = stack[stackPos--]; //pop\n        float prob = hash11(9375.264*branchID);\n        branch.angle += 0.05*(sin(iTime)*prob);\n        \n        float len = branch.len * (1.0 + LENGTH_VARIATOPN * (prob-0.5));\n        vec2 start = branch.pos;\n        vec2 end = start + vec2(len*sin(branch.angle), len*cos(branch.angle));\n        float ud =  udLine(uv, start, end);\n        \n        color += vec3(1.0 - smoothstep(0.0, branch.width, ud));\n        \n        if (branch.depth < MAX_DEPTH)\n        {\n            float len = branch.len * (0.67);\n        \tfloat width = max(0.001, branch.width * 0.7);\n        \tstack[++stackPos] = Branch(end, len, branch.angle+SPLIT_ANGLE, width, branch.depth+1); //push\n        \tstack[++stackPos] = Branch(end, len, branch.angle-SPLIT_ANGLE, width, branch.depth+1); //push\n        }\n        \n        if (branch.depth == MAX_DEPTH)\n        {\n            float ud = udFlower(uv - end, branchID);\n            if (ud < 0.001 && prob < FLOWER_PROBABILITY)\n        \t\tcolor = vec3(1.0, 0.7, 0.8) * (1.0 - smoothstep(0.0, 0.001, ud));\n        }\n    }\n \t\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(fragCoord/iResolution.x), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtf3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 279, 279, 364], [366, 366, 413, 413, 528], [590, 590, 627, 627, 1015], [1017, 1017, 1042, 1042, 2418], [2420, 2420, 2475, 2475, 2537]], "test": "ok"}
{"id": "Wtf3Df", "name": "Cube anime", "author": "BaconPapa", "description": "A cube anime created by ray marching", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 145, "published": "Public", "date": "1557824824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ZOOM 1.5\n#define MAX_STEPS 100\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 50.\nconst vec3 _lightPos = vec3(-2., 5., -1.);\nconst vec3 _lightPos2 = vec3(2., 5., 1.);\nconst vec3 _lightDir = vec3(0., -.5, 1.);\nconst vec3 _lightColor = vec3(.92, 0.85, 0.99);\nconst float _pointIntense = .3;\nconst float _parallelIntense = 0.4;\nconst float _shadowMin = .01;\nconst float _shadowMax = 50.;\nconst float _shadowIntense = 1.;\nconst float _sphereSmooth = .15;\nconst float _k = 15.;\n\nvec3 getRay(in vec3 ro, in vec3 lookAt, in vec2 uv) {\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    return normalize(uv.x * r + uv.y * u + f * ZOOM);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat opSU ( float d1, float d2, float k ) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdf(in vec3 p) {\n    vec3 c1 = vec3(0., 1. + .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    vec3 c2 = vec3(0., .5 - .25 * sin(4. * iTime) + 0.25 * sin(iTime * 4.), 0.);\n    vec3 c3 = vec3(.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    vec3 c4 = vec3(-.25 * sin(2. * iTime), .75 + 0.25 * sin(iTime * 4.), 0.);\n    vec3 b = vec3(0., .75 + 0.25 * sin(iTime * 4.), 0.);\n    float r = .5;\n    float sphere1 = sdSphere(p, c1, r);\n    float sphere2 = sdSphere(p, c2, r);\n    float sphere3 = sdSphere(p, c3, r);\n    float sphere4 = sdSphere(p, c4, r);\n    float plane = sdPlane(p);\n    float box = sdBox(b - p, vec3(.5, .5, .5)); \n    float d = opSU(sphere1, sphere2, _sphereSmooth);\n    d = opSU(d, sphere3, _sphereSmooth);\n    d = opSU(d, sphere4, _sphereSmooth);\n    d = opSS(d, box, .1);\n    d = opSU(d, plane, .8);\n    return d;\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i ++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdf(p);\n        dO += dS;\n        if(dS < MIN_DISTANCE || dO > MAX_DISTANCE) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(in vec3 p) {\n    float d = sdf(p);\n    vec2 e = vec2(MIN_DISTANCE, 0);\n    return normalize(vec3(\n        sdf(p + e.xyy) - d,\n        sdf(p + e.yxy) - d,\n        sdf(p + e.yyx) - d\n        ));\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0;\n    for(float h = mint;h<maxt;){\n        vec3 p = ro + rd * h;\n        float s = sdf(p);\n        h += s;\n        if (s <= MIN_DISTANCE) {\n            return 0.0;\n        }\n        res = min(res, k * s / h);\n    }\n    return res;\n}\n\nvec3 getLight(in vec3 p) {\n    vec3 n = getNormal(p);\n    vec3 ld = normalize(_lightPos - p);\n    vec3 ld2 = normalize(_lightPos2 - p);\n    float lParallel = clamp(dot(n, -_lightDir), 0., 1.) * _parallelIntense;\n    float lPoint = clamp(dot(n, ld), 0., 1.) * _pointIntense;\n    float lPoint2 = clamp(dot(n, ld2), 0., 1.) * _pointIntense;\n    lParallel = lParallel * pow(shadow(p, -_lightDir, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint = lPoint * pow(shadow(p, ld, _shadowMin, _shadowMax, _k), _shadowIntense);\n    lPoint2 = lPoint2 * pow(shadow(p, ld2, _shadowMin, _shadowMax, _k), _shadowIntense);\n    \n    return (lPoint + lParallel + lPoint2) * _lightColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(5. * sin(iTime / 2.), 4. , 5. * cos(iTime / 2.));\n    vec3 lookAt = vec3(0., .5, 0.);\n    vec3 col = vec3(0., 0., 0.);\n    vec3 rd = getRay(ro, lookAt, uv);\n\tfloat d = rayMarching(ro, rd);\n    vec3 p = ro + d * rd;\n    // Output to screen\n    fragColor = vec4(getLight(p), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 537, 537, 697], [699, 699, 725, 725, 743], [745, 745, 795, 795, 827], [829, 829, 860, 860, 956], [958, 958, 1002, 1002, 1098], [1100, 1100, 1143, 1143, 1244], [1246, 1246, 1268, 1268, 2104], [2106, 2106, 2149, 2149, 2368], [2370, 2370, 2397, 2397, 2579], [2581, 2581, 2661, 2661, 2913], [2915, 2915, 2941, 2941, 3591], [3593, 3593, 3650, 3700, 4087]], "test": "ok"}
{"id": "wtf3RX", "name": "Sargadelos", "author": "jblanper", "description": "The design is similar to the decorative patterns of the Spanish ceramic from Sargadelos.", "tags": ["2d", "geometric", "tiles"], "likes": 1, "viewed": 100, "published": "Public", "date": "1557082163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  \tfloat n = (cos(iTime * .2) * 1.5 + 2.);\n  \tuv = fract(uv * n) - .5;\n\n  \tfloat t = sin(iTime * 1.5) * .05 + .05;\n  \tfloat r = length(uv);\n\n  \tvec3 color = vec3(0.);\n  \tcolor += smoothstep(.1, .8, cos(dot(uv.y * uv.x, uv.x) * 2. + iTime * .2)) * 1.5;\n\n  \tcolor -= cos(cos(uv.x * uv.y * 25.) * 15. - iTime) * 3.5;\n  \tcolor = mix(color, vec3(.3, .4, .8) * 1.3, r + .55 - t * 3.5) * 2.2;\n\n  \tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtf3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 547]], "test": "error"}
{"id": "WtfGDB", "name": "Tunnel and Music v2", "author": "Tezza48", "description": "This is a HLSL ps 3.0 compatable version of the v1.\nBasically did this so i can use it in VDJ 2018.\n", "tags": ["tunnel", "music"], "likes": 3, "viewed": 420, "published": "Public API", "date": "1557429634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 nUV = fragCoord / iResolution.xy;\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n\tuv.x += cos(iTime) * 0.3;\n    uv.y += -sin(iTime) * 0.3;\n    \n    int tx = int(nUV * 512.0);\n    int ty = int(nUV * 512.0);\n    \n    float wave = texelFetch(iChannel0, ivec2(ty, 1), 0).x;\n    \n    float a = atan(uv.x/uv.y) + sin(0.25 / length(uv));\n    float r = length(uv);\n    \n    vec2 polar = vec2(0.25 / r + iTime, (a / (2.0 * 3.14)));\n    \n    float d = step(0.1, abs(wave - nUV.y));\n    \n    vec3 tunnelCol = texture(iChannel1, polar).xxx * pow(length(uv), 0.8);\n    \n    // Output to screen\n    fragColor = vec4(mix(tunnelCol, vec3(uv, 0.5), 1.0 - d),1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 789]], "test": "error"}
{"id": "wtfGDs", "name": "dizzychess", "author": "donda", "description": "[b]photosensitivity warning[/b]\nA dizzyingly rotating checkerboard pattern.\nWatch at fullscreen and stare at the center.", "tags": ["checkerboard", "illusion", "rotation"], "likes": 2, "viewed": 309, "published": "Public API", "date": "1558041211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// dizzychess\n// CA 2019-5-16\n\n// number of checkerboard units along shorter edge\nconst float no = 40.;\n// time for one cycle (in seconds)\nconst float period = 60.;\n// rotation speed at height of cycle (in degrees per second)\nconst float speed = radians(360.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates\n    vec2 c = (fragCoord - iResolution.xy / 2.0) /\n        min(iResolution.x, iResolution.y) * 2.0;\n\n    // rotation angle\n    const float a = 2. * radians(180.) / period;\n    float angle = speed * (iTime - sin(a * iTime) / a);\n\n    // rotation\n    c = vec2(c.x * cos(angle) + c.y * sin(angle),\n             c.x * sin(angle) - c.y * cos(angle));\n\n    // 2d rectangle wave\n    c = mod(floor(c * no), 2.0);\n\n    // checkerboard\n\tfloat checker = (c.x - 0.5) * (c.y - 0.5) * 2.0 + 0.5;\n\n    // make fields red and white\n    fragColor = vec4(1.0, 1.0 - checker, 1.0 - checker, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 319, 349, 928]], "test": "error"}
{"id": "WtfGDX", "name": "Triangle Grid Contouring", "author": "Shane", "description": "Utilizing a 2D simplex grid to construct the isolines of a noise function.", "tags": ["grid", "triangle", "marching", "contour"], "likes": 218, "viewed": 8611, "published": "Public API", "date": "1559137994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\n\tTriangle Grid Contouring\n\t------------------------\n\n\tUsing a 2D simplex grid to construct the isolines of a 2D field function, namely\n    gradient noise. I'm not entirely sure what to call the process. Since it's the \n\ttriangular version of the marching squares algorithm, you'd think it'd be called \n\t\"marching triangles,\" but that term is used to describe grid point cloud related \n    triangulation. Therefore, \"triangle grid contouring\" will do. :)\n\n\tI've been coding up some Wang tile related patterns on square grids lately, which got \n\tme thinking about attempting the same on a triangle grid. Whilst doing that, I got \n\tsidetracked and wondered what contour lines created with the triangular equivalent of \n\ta marching squares algorithm would look like, and here we are. :)\n\n    I put this together for novelty purposes, but I'd imagine there'd be some practical \n\taspects associated with it; Vector contour point lists would be an obvious one, and\n\tto a lesser extent, triangulated height maps. However, rendering smooth curves would\n\tbe one of the main benefits. Only one unique linear interpolant is rendered through \n\teach triangle, which means that Bezier point information via neighboring triangles \n\twith shared edges would be easy to obtain.... I might demonstrate that at a later \n\tdate, but for now, a novel proof of concept will do.\n\t \n \n*/\n\n// If you were rendering from a vertex shader, or just pushing out a triangle list \n// general, then you'd need to triangulate the triangles that have been split into \n// quads. The process is almost trivial with just one contour, and slightly more \n// involved with two, but not too difficult. Anyway, here's a visual representation.\n// Aesthetically, I kind of like it, but it's a little busy, so is off by default.\n//#define TRIANGULATE_CONTOURS\n\n// Filling the cells with a concentric triangle pattern. I couldn't decide whether\n// to include it, or not, so it's here as an option.\n#define TRIANGLE_PATTERN\n\n// Render green grass on the terrain. Uncommented leaves dry terrain.\n#define GRASS\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard vec2 to float hash - Based on IQ's original.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime); \n    \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n// The isofunction. Just a single noise function, but it can be more elaborate.\nfloat isoFunction(in vec2 p){ return n2D3G(p/4. + .07); }\n\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 a, vec2 b){\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\n\n// Based on IQ's signed distance to the segment joining \"a\" and \"b\".\nfloat distEdge(vec2 a, vec2 b){\n    \n    //if(abs(dot(a, a) - dot(b, b))>1e-5) \n    \n\n    \n    return dot((a + b)*.5, normalize((b - a).yx*vec2(-1, 1)) );\n    //else return 1e5;\n \n}\n\n \n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec2 inter(in vec2 p1, in vec2 p2, float v1, float v2, float isovalue){\n     \n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    //\n    // If you're wondering about the weird numerical hacks on the end, it's a fudge keep the \n    // lines away from the triangle edges. Because this is a per grid cell implementation,\n    // there's neighboring cell overlap to deal with, which basically means rendering more\n    // cells. Typically, that's not particularly difficult to deal with, but can be slower.\n    // Either way, I wanted to keep things simple... and I'm lazy. Hence, the fugde. :)\n    return mix(p1, p2, (isovalue - v1)/(v2 - v1)*.75 + .25/2.); \n    \n    // The mix bit -- without the numberical hacks -- is equivalent to:\n    //return p1 + (isovalue - v1)/(v2 - v1)*(p2 - p1);\n    \n    // This is probably more correct, but we seem to be getting away with the line above.\n    //float inter = v1 == v2 ? .5 : (isovalue - v1) /(v2 - v1); \n    //return mix(p1, p2, inter);\n}\n\n// Isoline function.\nint isoLine(vec3 n3, vec2 ip0, vec2 ip1, vec2 ip2, float isovalue, float i, \n          inout vec2 p0, inout vec2 p1){\n    \n    \n    // Points where the lines cut the edges.\n    p0 = vec2(1e5), p1 = vec2(1e5);\n    \n    // Marching triangles.. Is that a thing? Either way, it's similar to marching\n    // squares, but with triangles. In other words, obtain the underlying function\n    // value at all three vertices of the triangle cell, compare them to the \n    // isovalue (over or under), then render a line between the corresponding edges.\n    //\n    // The line cuts each edge in accordance with the isovalues at each edge, which\n    // means interpolating between the two.\n    \n    // Bitwise accumulation to produce a unique index number upon which to make \n    // decisions. It's a pretty standard technique.\n    //\n    // Minumum threshold value... It's an ID, of sorts.\n    int iTh = 0;\n    //\n    // If the first vertex is over the isovalue threshold, add four, etc.\n    if(n3.x>isovalue) iTh += 4;\n    if(n3.y>isovalue) iTh += 2;\n    if(n3.z>isovalue) iTh += 1;\n    \n    \n    // A value of 1 or 6 means constructing a line between the\n    // second and third edges, and so forth.\n    if(iTh == 1 || iTh == 6){ // 12-20         \n        \n        p0 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.\n     \n    }\n    else if(iTh == 2 || iTh == 5){ // 01-12 \n        \n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\n        p1 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\n        \n    }\n    else if(iTh == 3 || iTh == 4){ // 01-20 \n        \n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.       \n        \n    }\n     \n    \n    // For the last three cases, we're after the other side of\n    // the line, and this is a quick way to do that. Uncomment\n    // to see why it's necessary.\n    if(iTh>=4 && iTh<=6){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\n    \n    // Just to make things more confusing, it's necessary to flip coordinates on \n    // alternate triangles, due to the simplex grid triangle configuration. This \n    // line basically represents an hour of my life that I won't get back. :D\n    if(i == 0.){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\n    \n    \n    // Return the ID, which will be used for rendering purposes.\n    return iTh;\n \n    \n}\n\n/*\nvec3 softLight(vec3 s, vec3 d){\n\n    vec3 a = d - (1. - 2.*s)*d*(1. - d), b = d + (2.*s - 1.)*d*((16.*d - 12.)*d + 3.), \n         c = d + (2.*s - 1.)*(sqrt(d) - d);\n    \n    return vec3(s.x<.5? a.x : d.x<.25? b.x : c.x, s.y<.5? a.y : d.y<.25? b.y : c.y,\n    \t\t\ts.z<.5? a.z : d.z<.25? b.z : c.z);\n\t\n}\n*/\n\nvec3 simplexContour(vec2 p){\n    \n    \n    \n    // Scaling constant.\n    const float gSc = 8.;\n    p *= gSc;\n    \n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\n    p += vec2(n2D3G(p*3.5), n2D3G(p*3.5 + 7.3))*.015;\n\n    \n    \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269); \n    \n    \n    // Centralize everything, so that vec2(0) is in the center of the triangle.\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n    //\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\n     \n     \n     \n    // Take a function value (noise, in this case) at each of the vertices of the\n    // individual triangle cell. Each will be compared the isovalue. \n    vec3 n3;\n    n3.x = isoFunction(s);\n    n3.y = isoFunction(s + ioffs);\n    n3.z = isoFunction(s + 1.);\n    \n    \n    // Various distance field values.\n    float d = 1e5, d2 = 1e5, d3 = 1e5, d4 = 1e5, d5 = 1e5; \n  \n    \n    // The first contour, which separates the terrain (grass or barren) from the beach.\n    float isovalue = 0.;\n    \n    // The contour edge points that the line will run between. Each are passed into the\n    // function below and calculated.\n    vec2 p0, p1; \n    \n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\n    int iTh = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\n      \n    // The minimum distance from the pixel to the line running through the triangle edge \n    // points.\n    d = min(d, distEdge(p - p0, p - p1)); \n    \n    \n    \n    //if(iTh == 0) d = 1e5;\n    \n    // Totally internal, which means a terrain (grass) hit.\n    if(iTh == 7){ // 12-20  \n \t\t\n        // Triangle.\n        //d = min(min(distEdge(p - ip0, p - ip1), distEdge(p - ip1, p - ip2)), \n                  //distEdge(p - ip0, p - ip2));\n        \n        // Easier just to set the distance to a hit.\n        d = 0.;\n    } \n    \n \n    \n    // Contour lines.\n    d3 = min(d3, distLine((p - p0), (p - p1))); \n    // Contour points.\n    d4 = min(d4, min(length(p - p0), length(p - p1))); \n    \n    \n    \n    \n    \n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    \n    // Adding the triangle grid to the d5 distance field value.\n    d5 = min(d5, tri);\n     \n    \n    // Dots in the centers of the triangles, for whatever reason. :) Take them out, if\n    // you prefer a cleaner look.\n    d5 = min(d5, length(p) - .02);   \n    \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    vec2 oldP0 = p0;\n    vec2 oldP1 = p1;\n\n    // Contour triangles: Flagging when the triangle cell contains a contour line, or not.\n    float td = (iTh>0 && iTh<7)? 1. : 0.;\n    \n    // Subdivide quads on the first contour.\n    if(iTh==3 || iTh==5 || iTh==6){\n\n        // Grass (non-beach land) only quads.\n        vec2 pt = p0;\n        if(i==1.) pt = p1;\n        d5 = min(d5, distLine((p - pt), (p - ip0))); \n        d5 = min(d5, distLine((p - pt), (p - ip1)));  \n        d5 = min(d5, distLine((p - pt), (p - ip2))); \n    }\n    #endif\n    ////////\n    \n \n    // The second contour: This one demarcates the beach from the sea.\n    isovalue = -.15;\n   \n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\n    int iTh2 = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\n   \n    // The minimum distance from the pixel to the line running through the triangle edge \n    // points.   \n    d2 = min(d2, distEdge(p - p0, p - p1)); \n    \n    // Make a copy.\n    float oldD2 = d2;\n    \n    if(iTh2 == 7) d2 = 0.; \n    if(iTh == 7) d2 = 1e5;\n    d2 = max(d2, -d);\n\n     \n    // Contour lines - 2nd (beach) contour.\n    d3 = min(d3, distLine((p - p0), (p - p1)));\n    // Contour points - 2nd (beach) contour.\n    d4 = min(d4, min(length(p - p0), length(p - p1))); \n                \n    d4 -= .075;\n    d3 -= .0125;\n     \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    // Triangulating the contours.\n    \n    // This logic was put in at the last minute, and isn't my finest work. :)\n    // It seems to work, but I'd like to tidy it up later. \n\n    // Flagging when the triangle contains a second contour line, or not.\n    float td2 = (iTh2>0 && iTh2<7)? 1. : 0.;\n     \n    \n    if(td==1. && td2==1.){\n        // Both contour lines run through a triangle, so you need to do a little more\n        // subdividing. \n        \n        // The beach colored quad between the first contour and second contour.\n        d5 = min(d5, distLine(p - p0, p - oldP0)); \n        d5 = min(d5, distLine(p - p0, p - oldP1));  \n        d5 = min(d5, distLine(p - p1, p - oldP1));\n         \n        // The quad between the water and the beach.\n        if(oldD2>0.){\n            vec2 pt = p0;\n            if(i==1.) pt = p1;\n            d5 = min(d5, distLine(p - pt, p - ip0)); \n            d5 = min(d5, distLine(p - pt, p - ip1));  \n            d5 = min(d5, distLine(p - pt, p - ip2)); \n        }\n    }   \n    else if(td==1. && td2==0.){\n        \n        // One contour line through the triangle.\n        \n        // Beach and grass quads.\n        vec2 pt = oldP0;\n        if(i==1.) pt = oldP1;\n        d5 = min(d5, distLine(p - pt, p - ip0)); \n        d5 = min(d5, distLine(p - pt, p - ip1));  \n        d5 = min(d5, distLine(p - pt, p - ip2)); \n    }\n    else if(td==0. && td2==1.){ \n        \n        // One contour line through the triangle.\n        \n        // Beach and water quads.\n        vec2 pt = p0;\n        if(i==1.) pt = p1;\n        d5 = min(d5, distLine(p - pt, p - ip0)); \n        d5 = min(d5, distLine(p - pt, p - ip1));  \n        d5 = min(d5, distLine(p - pt, p - ip2));  \n    }\n    \n    #endif\n    ////////\n    \n    \n    // The screen coordinates have been scaled up, so the distance values need to be\n    // scaled down.\n    d /= gSc;\n    d2 /= gSc;\n    d3 /= gSc;\n    d4 /= gSc;    \n    d5 /= gSc; \n    \n    \n    \n    // Rendering - Coloring.\n        \n    // Initial color.\n    vec3 col = vec3(1, .85, .6);\n    \n    // Smoothing factor.\n    float sf = .004; \n   \n    // Water.\n    if(d>0. && d2>0.) col = vec3(1, 1.8, 3)*.45;\n     // Water edging.\n    if(d>0.) col = mix(col, vec3(1, 1.85, 3)*.3, (1. - smoothstep(0., sf, d2 - .012)));\n    \n    // Beach.\n    col = mix(col, vec3(1.1, .85, .6),  (1. - smoothstep(0., sf, d2)));\n    // Beach edging.\n    col = mix(col, vec3(1.5, .9, .6)*.6, (1. - smoothstep(0., sf, d - .012)));\n    \n    #ifdef GRASS\n    // Grassy terrain.\n    col = mix(col, vec3(1, .8, .6)*vec3(.7, 1., .75)*.95, (1. - smoothstep(0., sf, d))); \n    #else\n    // Alternate barren terrain.\n    col = mix(col, vec3(1, .82, .6)*.95, (1. - smoothstep(0., sf, d))); \n    #endif \n    \n   \n     \n \n    // Abstract shading, based on the individual noise height values for each triangle.\n    if(d2>0.) col *= (abs(dot(n3, vec3(1)))*1.25 + 1.25)/2.;\n    else col *= max(2. - (dot(n3, vec3(1)) + 1.45)/1.25, 0.);\n    \n    // More abstract shading.\n    //if(iTh!=0) col *= float(iTh)/7.*.5 + .6;\n    //else col *= float(3.)/7.*.5 + .75;\n\n    \n    ////////\n    #ifdef TRIANGULATE_CONTOURS\n    //if(td==1. || td2==1.) col *= vec3(1, .4, .8); \n    #endif\n    ////////\n    \n    ////////\n    #ifdef TRIANGLE_PATTERN\n    // A concentric triangular pattern.\n    float pat = abs(fract(tri*12.5 + .4) - .5)*2.;\n    col *= pat*.425 + .75; \n    #endif\n    ////////\n    \n \n    \n    \n    // Triangle grid overlay.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d5))*.95);\n    \n     \n    \n    // Lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d3)));\n    \n    \n    // Dots.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d4)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, d4 + .005)));\n  \n  \n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying grey scale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = oP*1.5;\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = sqrt(dot(col, vec3(.299, .587, .114)))*1.25;\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a rotated layer.\n    q *= rot2(3.14159/3.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(ns, ns2)); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    col = mix(col, col*(ns + .35), .4);\n    // Has more of a colored pencil feel. \n    //col *= vec3(.8)*ns + .5;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //col = vec3(ns);\n    \n    \n    /*\n    // Just some line overlays.\n    vec2 pt = p;\n    float offs = -.5;\n    if(i<.5) offs += 2.;//pt.xy = -pt.xy;\n    pt = rot2(6.2831/3.)*pt;\n    float pat2 = clamp(cos(pt.x*6.2831*14. - offs)*2. + 1.5, 0., 1.);\n    col *= pat2*.4 + .8;\n    */\n    \n    \n    // Cheap paper grain.\n    //oP = floor(oP/gSc*1024.);\n    //vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    //col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\n\n    \n    // Return the simplex weave value.\n    return col;\n \n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\n    // the pattern looking too blurred out.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(650., iResolution.y);\n   \n    // Position with some scrolling, and screen rotation to level the pattern.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(.8660254, .5)*iTime/16.; \n    \n    // The simplex grid contour map... or whatever you wish to call it. :)\n    vec3 col = simplexContour(p);\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    //col = mix(col.zyx/2., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n  \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfGDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2064, 2097, 2119, 2119, 2177], [2180, 2237, 2258, 2258, 2320], [2323, 2345, 2366, 2715, 2914], [2917, 2958, 2983, 2983, 3506], [3509, 3589, 3618, 3618, 3646], [3649, 3706, 3737, 3737, 3837], [3840, 3909, 3940, 3988, 4090], [4095, 4187, 4258, 4937, 5329], [5331, 5352, 5469, 5524, 7782], [8091, 8091, 8119, 8159, 19270], [19274, 19274, 19331, 19454, 20123]], "test": "timeout"}
{"id": "WtfGW2", "name": "orthographic projection", "author": "ankd", "description": "orthographic projection test.\nmouse x - interpolate between perspective and orthographic.\nmouse y - orthographic rectangle size.", "tags": ["raymarching", "orthographic"], "likes": 9, "viewed": 499, "published": "Public", "date": "1557597118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float usin(float x){\n    return 0.5+0.5*sin(x);\n}\nmat2 rotate(in float r){\n    float c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c);\n}\n\n\n// sign distance functions\nfloat sdSphere(in vec3 p, in float r){\n    return length(p)-r;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\nfloat sdPlane(in vec3 p, in vec3 n, in float o){\n    return dot(p, n)-o;\n}\n\n// operator\nvec2 opU(in vec2 d1, in vec2 d2){\n    return d1.x<d2.x ? d1 : d2;\n}\n\nvec2 map(in vec3 p){\n    vec3 q = p;\n    vec2 res = vec2(sdPlane(q, vec3(0., 1., 0.), -1.5), 0.);\n    \n    q = clamp(q, -5.0, 5.0);\n    \n    res = opU(res, vec2(sdSphere(q-vec3(-0.4, 0., 2.), 0.5), 1.0));\n    res = opU(res, vec2(sdSphere(q-vec3(0.4, 0., -2.), 0.5), 2.0));\n\n    q.xy *= rotate(iTime);\n    res = opU(res, vec2(sdBox(q, vec3(0.5)), 3.));\n    \n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0., maxD=200.0;\n    float threshold = 0.0001;\n    \n    float d=minD, m=-1.0;\n    for(int i=0;i<100;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<threshold || maxD<tmp.x) break;\n        d += tmp.x * 0.7;\n        m = tmp.y;\n    }\n    if(maxD<d) m=-1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n\tvec2 e = vec2(1.0, -1.0)*0.00001;\n    return normalize(vec3(\n    \te.xyy*map(p+e.xyy).x +\n    \te.yxy*map(p+e.yxy).x +\n    \te.yyx*map(p+e.yyx).x +\n    \te.xxx*map(p+e.xxx).x\n    ));\n}\n\n\nfloat calcShadow(in vec3 ro, in vec3 rd){\n    float res = 1.0;\n    float d = 0.05;\n    float h;\n    for(int i=0;i<8;i++){\n        h = map(ro + rd*d).x;\n        res = min(6.0*h/d, res);\n        d += h;\n    }\n    return clamp(max(res, 0.), 0., 1.);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 lp =  vec3(15.0);\n    vec3 ld = normalize(lp-pos);\n    \n   \tvec3 color;\n    if(m<0.0) color = vec3(0.);\n    else color = vec3(clamp(dot(ld, nor), 0., 1.));\n    color *= m==1.0 ? vec3(1.0, 0.0, 0.0) :\n    \t\t m==2.0 ? vec3(0.0, 1.0, 0.0) :\n    \t\t m==3.0 ? vec3(0.0, 0.0, 1.0) : vec3(1.0);\n    \n    //float shadow = calcShadow(pos, normalize(lp-pos));\n    //color *= shadow;\n    \n    color = pow(color, vec3(2.2));\n    return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    // camera setting\n    vec3 ro = vec3(1., 1., 4.);// ray origin (camera pos)\n    vec3 tar = vec3(0.);// eye target\n    \n    float f = iMouse.x/iResolution.x;\n\t//float f = usin(iTime);\n    //f = f*f*(3.0-2.0*f);\n    \n    vec3 rd = lookAt(ro, tar, 0.)*normalize(vec3(p, 1.0));// ray direction\n    vec3 rd_orth = lookAt(ro, tar, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    float orthRectSize = 2.0 + 3.0*iMouse.y/iResolution.y;\n    vec3 ro_orth = ro + vec3(p * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    \n    // rendering\n    vec3 col = render(ro, rd);\n    \n        fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 49], [50, 50, 74, 74, 136], [139, 166, 204, 204, 230], [231, 231, 265, 265, 358], [359, 359, 407, 407, 433], [435, 447, 480, 480, 514], [516, 516, 536, 536, 890], [892, 892, 929, 929, 1256], [1258, 1258, 1285, 1285, 1467], [1470, 1470, 1511, 1511, 1718], [1720, 1720, 1756, 1756, 2339], [2341, 2341, 2391, 2391, 2623], [2625, 2625, 2682, 2682, 3457]], "test": "ok"}
{"id": "WtfGWf", "name": "Warm Tunnel", "author": "mosaic", "description": "Pulsating colourful tunnel", "tags": ["2d"], "likes": 7, "viewed": 177, "published": "Public", "date": "1557814087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st  = fragCoord/iResolution.y;\n    vec2 uv  = fragCoord/iResolution.y;\n    \n    \n    //circle\n    float pct =distance(st,vec2(0.9,0.5))*19.;\n   \n    //cycling colour \n    vec3 col = 01.5 + 0.5*cos(iTime*1.+uv.xyx+vec3(2.5,1,0.3));\n  \n    //combining the circle and cycling colour\n    col=col/pct;\n        \n    //this line adds tunnel effect \n    col *= 1.8 + 0.2*cos(140.0*col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 512]], "test": "ok"}
{"id": "WtjGRw", "name": "bleek peaks", "author": "Imsure1200q_1UWE130", "description": "i just give up ok..\n", "tags": ["raymarching"], "likes": 3, "viewed": 324, "published": "Public API", "date": "1558970945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define PI 3.141593\n#define PHI 1.618033\n\n//#define HAS_REFLECTION\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n   \nstruct Light {\n    vec3 c;\n    vec3 o;\n    float s;\n};\n    \n    struct DC {\n        float dist;\n        vec3 col;\n    };\n\n//Dist Funcs http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s ) {\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  \tvec3 d = abs(p) - b;\n    return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  \tvec3 d = abs(p) - b;\n \treturn length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdOctahedronBound( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n//Inter -------------------------------------------------------------------------------\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nvec2 opUnion2( vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 opRepP( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sinnoise ( float p ) {\n    \n    //int n = 0;\n    float s = 0.;\n    \n    for(int n = 0; n < 3; n++) {\n        float nf = float(n);\n        s += ( cos(pow(2., nf)*p) * sin(pow(nf, 2.)*p/10.) + sin(pow(nf, 2.)*p/10.) ) / pow(2., nf);\n    }\n    \n    return s;\n}\n\nfloat lnoise ( vec2 p ) {\n    \n    float s = 0.;\n    float f = 0.1, a = 0.1, ps = 0.5, l = 2.;\n    \n    for(int n = 0; n < 4; n++) {\n        float height = texture(iChannel0, p.xy*f).r*a;\n        s += height;\n        f *= l;\n        a *= ps;\n    }\n    \n    return s;\n    \n}\n\n\n\nvec2 map (vec3 pos) {\n    \n    vec3 p = pos;\n    //vec2 x = vec2(sdPlane(vec3(pos.x, pos.y, pos.z)), 1.1);\n    vec2 x = vec2(0.);\n    float d = 0.;\n    \n    //d = sdRoundBox( p-vec3(0.,0.5,0.), vec3(1., 1., 1.), 0.1);\n    d = opSmoothUnion(sdSphere(p, 0.1), sdPlane(p)-lnoise(p.xz/64.)*8., 2.);\n    //d = sdPlane(p)-lnoise(p.xz/256.)*16.;\n    //d = sdPlane(p);\n    \n    x = vec2(d, 1.1);\n    \n    //d = sdPlane(p+vec3(lnoise(p.xz),lnoise(p.xz/16.)-3.,lnoise(p.xz)));\n    //d = sdPlane(p)-texture(iChannel0, pos.xz).r-2000.;\n    \n    //x = opUnion2(vec2(d, 1.4), x);\n    \n    //vec2 asdf = vec2(3.0,0.0)*mat2x2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n    \n    //d = sdSphere(p-vec3(asdf.x,1.0,asdf.y), 1.);\n    //x = opUnion2(vec2(d, 1.1), x);\n    return x;\n    \n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.01;\n    float tmax = 60.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin; //distance travelled\n    float m = -1.0; //color id\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t ); //smallest distance\n        if( res.x<precis || t>tmax ) break; //break if ray goes too far or too near.\n        t += res.x;  //otherwise add small distance for new march position\n\t    m = res.y; //get best color id\n    }\n\n    if( t>tmax ) m=-1.0; //if ray went too far, there is no color id.. just air.\n    return vec2( t, m );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nDC render ( vec3 ro, vec3 rd ) {\n    \n    vec3 col = vec3(1.0, 1.0, 0.9); //default color\n    float gl = 256.; //default gloss\n    vec2 res = castRay(ro, rd); //cast ray, get stuff\n    \n    float t = res.x, m = res.y;\n    \n    if(m != -1.0) {\n        \n        //preset variables\n        vec3 pos = ro+t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        \n        vec3 colref = vec3(0.3, 0.5, 0.7);\n        \n        //strengths\n        float sAmb = 0.1, sSpec = 0.5;\n        \n        #ifdef HAS_REFLECTION\n        vec2 refres = castRay(pos, ref);\n        float tref = refres.x, mref = refres.y;\n        \n        if(mref != -1.0) {\n            vec3 posref = pos+tref*ref;\n            vec3 norref = calcNormal(posref);\n            vec3 refref = reflect(ref, norref);\n            if( mref == 1.1 ) {\n                colref = vec3(1.0, 1.0, 1.0);\n            }\n            \n            const int LIGHT_AMOUNT = 4;\n            Light[LIGHT_AMOUNT] lights = Light[LIGHT_AMOUNT] (\n                Light( vec3(1.0,0.5,0.0), vec3(0.0, 3.0, -6.0), 0.9),\n                Light( vec3(1.0,1.0,0.0), vec3(6.0, 3.0, 0.0), 0.7 ),\n                Light( vec3(0.0,0.5,1.0), vec3(0.0, 3.0, 6.0), 1. ),\n                Light( vec3(0.5,0.0,1.0), vec3(-6.0, 3.0, 0.0), 0.7 )\n            );\n\n            vec3 viewdir = normalize(pos - posref);\n\n            vec3 dcol = colref;\n            vec3 totalAmb = vec3(0.);\n            vec3 totalLigCol = vec3(0.);\n\n            //per-light rendering\n\n            for(int i = 0; i < LIGHT_AMOUNT; i++) {\n                Light cLight = lights[i];\n                vec3 ligcN = cLight.c*cLight.s, ligoN = cLight.o;\n                vec3 ligdirN = normalize(ligoN - posref);\n                vec3 inligrefN = reflect(-ligdirN, norref);\n\n                float dif = max(dot(norref, ligdirN), 0.);\n                float spec = 0.5*pow(max(dot(viewdir, inligrefN), 0.0), gl);\n\n                totalAmb += 0.1 *ligcN;\n                totalLigCol += (dif + spec) * ligcN;\n\n            }\n\n            totalLigCol += totalAmb / vec3(LIGHT_AMOUNT);\n\n            colref *= totalLigCol;\n        }\n        \n        #endif\n        \n        \n        \n        if(m == 1.1) {\n            col = smoothstep(vec3(0.31),vec3(0.2,1.0,0.9),vec3(pos.y/2.))*(lnoise(pos.xz)+0.6);\n        } else if(m == 1.2) {\n            col = pow(colref,vec3(1.0/2.2));\n            sSpec = 1.0;\n        } else if(m == 1.3) {\n            col = mix(colref, vec3(1.0), 0.5);\n        } else if(m == 1.4) {\n            col = vec3(1.0);\n        }\n        \n        const int LIGHT_AMOUNT = 3;\n        /*Light[LIGHT_AMOUNT] lights = Light[LIGHT_AMOUNT] (\n            Light( vec3(1.0,0.5,0.0), vec3(0.0, 3.0, -6.0), 0.9),\n            Light( vec3(1.0,1.0,0.0), vec3(6.0, 3.0, 0.0), 0.7 ),\n            Light( vec3(0.0,0.5,1.0), vec3(0.0, 3.0, 6.0), 1. ),\n            Light( vec3(0.5,0.0,1.0), vec3(-6.0, 3.0, 0.0), 0.7 )\n        );*/\n        \n        Light[LIGHT_AMOUNT] lights = Light[LIGHT_AMOUNT] (\n            Light( vec3(1.0,1.0,0.5), vec3(1000., 400., 100.), 1.4),\n            Light( vec3(0.3,0.5,0.7), vec3(-100., 256, -100.), 0.2),\n            Light( vec3(0.1), pos, 0.3)\n        );\n        \n        vec3 viewdir = normalize(ro - pos);\n        \n        vec3 dcol = col;\n        vec3 totalAmb = vec3(0.);\n        vec3 totalLigCol = vec3(0.);\n        \n        //per-light rendering\n        \n        for(int i = 0; i < LIGHT_AMOUNT; i++) {\n            Light cLight = lights[i];\n            vec3 ligcN = cLight.c*cLight.s, ligoN = cLight.o;\n            vec3 ligdirN = normalize(ligoN - pos);\n            vec3 inligrefN = reflect(-ligdirN, nor);\n            \n            float dif = max(dot(nor, ligdirN), 0.) * calcSoftshadow(pos, ligdirN, 0.01, 0.3, 1);\n            float spec = sSpec*pow(max(dot(viewdir, inligrefN), 0.0), gl);\n            \n            totalAmb += sAmb *ligcN;\n            totalLigCol += (dif + spec) * ligcN;\n            \n        }\n        \n        totalLigCol += totalAmb / vec3(LIGHT_AMOUNT);\n        \n        col *= totalLigCol;\n        \n        //col = smoothstep(col, vec3(1.0, 1.0, 0.9), vec3(t/100.-3.));\n        //col = pow(col, vec3(t*-0.02+1.));\n        //col *= exp( 0.0005*t );\n        col = mix(col, vec3(1.0, 1.0, 0.9), length(pos-ro)/24.);\n        //col = mix(col, vec3(0.8, 0.0, 0.1), -clamp(pos.y-iTime,-10.0,0.0));\n        \n        \n    }\n    \n    //col = mix(col, vec3(0.8, 0.0, 0.1), -clamp(ro.y+t*rd.y-iTime,-10.0,0.0));\n    \n    return DC(length(ro+t*rd), clamp(col, vec3(0.0), vec3(1.0)));\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Reposition origin\n    uv = -1.0+2.0*uv;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // Get ray origin, ray direction\n    \n    vec3 ro = vec3( 5.*cos(0.1*iTime + 6.0*mo.x), 1.0 + 2.0*mo.y,5.*sin(0.1*iTime + 6.0*mo.x) );\n    \n    mat3 ca = setCamera( ro, vec3(0.0, 2.0, 0.), 0.01);\n    vec3 rd = ca*normalize(vec3(uv, 2.0)); //normalization is unneccessary...\n    \n    DC dc = render(ro, rd);\n    vec3 col = dc.col;\n    \n    //col = pow(col, vec3(1.0/2.2));\n    //col *= sqrt(1.5-0.5*length(uv));\n    //col *= 0.5 + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y);\n    vec2 bp = fragCoord.xy/iResolution.xy*2.-1.;\n    float vgn1 = pow(smoothstep(0.0,.3,(bp.x + 1.)*(bp.y + 1.)*(bp.x - 1.)*(bp.y - 1.)),.5);\n    float vgn2 = 1.-pow(dot(vec2(bp.x*.3, bp.y),bp),3.);\n    col *= mix(vgn1,vgn2,.4)*.5+0.5;\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 89, 114, 114, 133], [134, 134, 159, 159, 178], [346, 430, 465, 465, 488], [490, 490, 521, 521, 674], [676, 676, 721, 721, 876], [878, 878, 911, 911, 980], [982, 982, 1018, 1018, 1054], [1056, 1056, 1088, 1116, 1177], [1179, 1179, 1212, 1238, 1269], [1271, 1271, 1296, 1296, 1311], [1313, 1313, 1349, 1349, 1632], [1634, 1634, 1670, 1670, 1757], [1759, 1759, 1811, 1811, 1938], [1940, 1940, 1993, 1993, 2056], [2058, 2058, 2100, 2100, 2203], [2205, 2205, 2269, 2269, 2390], [2392, 2392, 2463, 2463, 2801], [2803, 2803, 2867, 2867, 3145], [3147, 3147, 3190, 3190, 3279], [3281, 3281, 3325, 3325, 3623], [3625, 3625, 3674, 3674, 3731], [3822, 3822, 3859, 3859, 3881], [3883, 3883, 3917, 3917, 3949], [3951, 3951, 3994, 3994, 4016], [4018, 4018, 4062, 4062, 4083], [4085, 4085, 4137, 4137, 4236], [4238, 4238, 4296, 4296, 4396], [4398, 4398, 4457, 4457, 4556], [4558, 4558, 4595, 4595, 4640], [4642, 4642, 4670, 4692, 4905], [4907, 4907, 4932, 4932, 5180], [5184, 5184, 5205, 5205, 5954], [5956, 5956, 5996, 5996, 6811], [6814, 6814, 6846, 6846, 7066], [7068, 7068, 7110, 7110, 7409], [7411, 7411, 7504, 7504, 8328], [12869, 12869, 12921, 12921, 13098], [13100, 13100, 13157, 13207, 14190]], "test": "error"}
{"id": "wtjGWR", "name": "Royal Red", "author": "Yusef28", "description": "Another pattern.", "tags": ["fun", "pattern", "rotation", "tile"], "likes": 2, "viewed": 101, "published": "Public", "date": "1559224087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 2.\n\nmat2 rot(float a)\n{\n    \n return mat2 (cos(a), -sin(a), sin(a), cos(a) );   \n}\n\nvec2 tiles(vec2 p)\n{\n    float tile = 0.0;\n    \n    p = p*scale; //scale space to 0.0 - 3.0\n    p = fract(p); // create 3x3 of 0.0-1.0\n    vec2 st = fract(p*2.);\n     p = p*2.0; //scale 3x3s each to 0.0 - 2.0, needed for square wave in next step\n    float index = step(1.0, mod(p.x, 2.0) ); //create a square wave on x axis from 0.0 - 1.0 for index\n    index += step(1.0, mod(p.y, 2.0) )*2.0; //adds a second square wave (0.0 - 2.0) based on y position\n    //so now in each 3x3 sqaure you get for quadrants based on indexes 0 - 3\n    \n    p-=1.;\n    // rotation \n    if(index == 1.0)\n    {\n    \tp =  rot(3.14/2.)*p;  //90 degree rotation left\n    }\n    else if(index == 2.0)\n    {\n        p =  rot(-3.14/2.)*p; //90 degree rotation right\n    }\n    else if(index == 3.0)\n    {\n        p =  rot(3.14)*p; ///180 degree rotation\n    }\n    float str = sin(p.y*29.)-0.15;\n    tile = smoothstep(0.0, 0.5, str);//return the triangle //or not, I changed the pattern \n    \n    \n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.5);    \n        //the tricky thing to remember is that this isn't rotating the space\n    \t// of each quadrant individually to get the four triangle things. \n    //It doesn't need to! It just rotates teh same 2 balck and white triangle\n    //but the result of that in each quadrant LOOKS LIKE it created 4 white and 4 black\n    //triangles because the quadrant determines the shape\n    //to prove this you have to kind of imagine one of teh 3x3 squars cut down the diagonal\n    //into black and white, and then the same black and white triangle is rotated differenlt\n    // in each ofhte 4 quads OF the one square of 3x3 and it only shows SOME black and some \n    //white of the larger two triangles but the result of that in each quad \n    //ends up looking like 8.\n    \n    \n return vec2(tile,vig);   \n}\n\nfloat borders (vec2 p)\n{\n    \n p = p*scale;\n    p = fract(p);\n    float left =  smoothstep(0.0, 0.0, p.x) - smoothstep(0.01, 0.01, p.x);\n    float right =  smoothstep(0.995, 0.995, p.x) - smoothstep(1.0, 1.0, p.x); \n    \n    float top =  smoothstep(0.995, 0.995, p.y) - smoothstep(1.0, 1.0, p.y); \n    float bottom =  smoothstep(0.0, 0.0, p.y) - smoothstep(0.01, 0.01, p.y);\n    return left+right+top+bottom;\n    \n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    uv+=iTime/8.;\n\tvec3 gold = vec3(159., 138., 66.)/255.;\n    vec2 stuff = tiles(uv);\n    float tile = stuff.x;\n    float v = stuff.y;\n    float tex0 = texture(iChannel0, uv/1.).x;\n    float tex1 = texture(iChannel1, uv).x;   \n    // Time varying pixel color\n    vec3 col = mix(vec3(pow(tex0*1.0, 1.)*1.,.0,.0)/1.5+pow(1.0-tex0*1.3, 4.),\n                   vec3(gold)*clamp(sin(uv.x*6.+iTime)*2., 0.9, 2.)-(1.0-tex1)/9., \n                   tile)*(v);\n  \n\n    col = mix(col, vec3(0.), clamp(borders(uv), 0.0, 1.) );//just to make sure the borders are all black\n    // Output to screen\n    fragColor = vec4(col*1.5,1.0);\n}\n\n\n\n\n\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 37, 37, 96], [98, 98, 118, 118, 1946], [1948, 1948, 1972, 1972, 2363], [2369, 2369, 2426, 2476, 3178]], "test": "error"}
{"id": "wtjGz1", "name": "amateur hour", "author": "mds2", "description": "originally made this to go to an acquaintance's tune on soundcloud.  Said tune has since been taken down.  So I replaced it with the one and only thing I've ever uploaded to soundcloud.  Modified (very slightly) from https://www.shadertoy.com/view/3sBGWW", "tags": ["music", "recycled"], "likes": 3, "viewed": 436, "published": "Public API", "date": "1558559578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLOCKSIZE 0.5\n\n#define EXTENT 15.0\n\n#define MULTI_SAMPLE 2 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\nfloat waffle_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n        float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.1733, 0.1321)), 1.0);\n\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - BLOCKSIZE * vec3(0.05, 0.1 + 2.0 * samp, 0.075));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 96; ++i) {\n    \tfloat d = 0.8 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    float distort = 0.85 + 0.65 * dot(uv, uv);\n    vec3 ray_dir = normalize(vec3(uv * distort - vec2(0.0, 0.1), -0.2));\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, 0.8, -0.6,\n             0.0, 0.6, 0.8) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    float mouseness = step(iMouse.y, fragCoord.y);\n    return vec4(subsurface * mouseness, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.025 * iTime);\n    float s_theta = sin(0.025 * iTime);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": "MtsXzn", "previewfilepath": "https://soundcloud.com/mds/21-rubber_band_dance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mds/21-rubber_band_dance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3684, 3684, 3720, 3720, 6437], [6786, 6786, 6843, 6843, 7744]], "test": "error"}
{"id": "Wtl3D2", "name": "RGB ribbons", "author": "takumifukasawa", "description": "RGB ribbons", "tags": ["ribbon", "rgb"], "likes": 5, "viewed": 144, "published": "Public", "date": "1557740341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------\n// noise from: https://thebookofshaders.com/12/\n//-----------------------------------------------------\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//-----------------------------------------------------\n// end\n//-----------------------------------------------------\n\nfloat wave(vec2 st, float c) {\n    float f = smoothstep(c - .02, c, st.y) * smoothstep(c, c + .02, st.y);\n\treturn 1. - clamp(f, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n    \n    vec3 col = vec3(0.);\n    \n    float wave1 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .00) * 20.) * .05\n    );\n    float wave2 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .01) * 20.) * .05\n    );\n    float wave3 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .20) * 20.) * .05\n    );\n    float wave4 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .21) * 20.) * .05\n    );\n    float wave5 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .40) * 20.) * .05\n    );\n    float wave6 = wave(\n        uv + vec2(0., noise(uv * 5. + iTime * .6) * .05),\n        sin((uv.x + iTime * .2 + .41) * 20.) * .05\n    );\n\n    col = vec3(1., 0., 0.) * (1. - wave1) * wave2;\n    col += vec3(0., 1., 0.) * (1. - wave3) * wave4;\n    col += vec3(0., 0., 1.) * (1. - wave5) * wave6;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 174, 201, 201, 318], [320, 407, 433, 433, 950], [1072, 1072, 1102, 1102, 1210], [1212, 1212, 1269, 1269, 2385]], "test": "ok"}
{"id": "Wtl3Rl", "name": "Roller-Coaster", "author": "dr2", "description": "Roller-coaster ride; update of \"Ride the Loop\" (mouseable, with selectable views)", "tags": ["raymarch", "fun", "train", "ride"], "likes": 14, "viewed": 612, "published": "Public API", "date": "1557310064", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Roller-Coaster\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA   0  // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRound2BoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nmat3 AxToRMat (vec3 vz, vec3 vy);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CAR 5\n#define N_SEG 12\n\nmat3 carMat[N_CAR];\nvec3 cPt[N_SEG], carPos[N_CAR], cPtOrg, cUpCirc, cDnCirc, sunDir, oDir, oNorm, qHit;\nfloat tLen[N_SEG + 1], tCur, dstFar, hTop, rLoop, sLoop, sHzRamp, rDnCirc, rUpCirc,\n   sDnRamp, sUpRamp, sHzStr, trkDir, hTrk, wTrk, tWait, vfFast, vfLoop;\nint idObj;\nbool riding, isSh;\nconst int idTrk = 1, idPyl = 2, idTrnk = 3, idLeaf = 4, idPlat = 5, idArch = 6,\n   idTun = 7, idCar = 8;\nconst float pi = 3.14159;\n\nvoid TrkSetup ()\n{\n  cPtOrg = vec3 (2. * trkDir, 0., -3.);\n  hTop = 1.5;\n  rLoop = 2.2;\n  sLoop = 0.3;\n  sHzRamp = 0.5;\n  rDnCirc = 2.;\n  rUpCirc = rDnCirc + sLoop;\n  sDnRamp = 1.5;\n  sUpRamp = 1.3 * sDnRamp;\n  sHzStr = sDnRamp - sUpRamp + 3. * sHzRamp;\n  wTrk = 0.015;\n  hTrk = 0.015;\n  tWait = 2.;\n  vfFast = 5.;\n  vfLoop = 0.6;\n  cDnCirc = cPtOrg + vec3 ((- rDnCirc - sLoop) * trkDir, 0., -2. * sHzRamp);\n  cUpCirc = cPtOrg + vec3 ((- rUpCirc + sLoop) * trkDir, 2. * hTop, 2. * sDnRamp +\n     6. * sHzRamp);\n  cPt[0] = cDnCirc;   cPt[0].xz += vec2 (- rDnCirc * trkDir, sHzStr);\n  cPt[1] = cPt[0];    cPt[1].z += sHzStr;\n  cPt[3] = cUpCirc;   cPt[3].x -= rUpCirc * trkDir;\n  cPt[4] = cUpCirc;   cPt[4].x += rUpCirc * trkDir;\n  cPt[2] = cPt[3];    cPt[2].z -= 2. * sHzRamp;\n  cPt[5] = cPt[4];    cPt[5].z -= 2. * sHzRamp;\n  cPt[7] = cPtOrg;    cPt[7].x += sLoop * trkDir;\n  cPt[8] = cPtOrg;    cPt[8].x -= sLoop * trkDir;\n  cPt[6] = cPt[7];    cPt[6].z += 4. * sHzRamp;\n  cPt[9] = cDnCirc;   cPt[9].x += rDnCirc * trkDir;\n  cPt[10] = cDnCirc;  cPt[10].x -= rDnCirc * trkDir;\n  cPt[N_SEG - 1] = cPt[0];\n  tLen[0] = 0.;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] = length (cPt[k] - cPt[k - 1]);\n  tLen[4] = pi * rUpCirc;\n  tLen[6] /= 0.5 * (1. + vfFast);\n  tLen[8] = length (vec2 (2. * pi * rLoop, 2. * sLoop)) * (1. + vfLoop);\n  tLen[10] = pi * rDnCirc;\n  for (int k = 7; k < N_SEG - 1; k ++) tLen[k] /= vfFast;\n  for (int k = 1; k < N_SEG; k ++) tLen[k] += tLen[k - 1];\n  tLen[N_SEG] = tLen[N_SEG - 1] + tWait;\n}\n\nvec3 TrkPath (float t)\n{\n  vec3 p, p1, p2, u;\n  float w, ft, s;\n  int ik;\n  t = mod (t, tLen[N_SEG]);\n  ik = -1;\n  for (int k = 1; k < N_SEG; k ++) {\n    if (t < tLen[k]) {\n      t -= tLen[k - 1];\n      p1 = cPt[k - 1];\n      p2 = cPt[k];\n      w = tLen[k] - tLen[k - 1];\n      ik = k;\n      break;\n    }\n  }\n  oNorm = vec3 (0., 1., 0.);\n  ft = t / w;\n  if (ik < 0) {\n    p = cPt[0];\n    oDir = vec3 (0., 0., 1.);\n  } else if (ik == 2 || ik == 6) {\n    oDir = p2 - p1;\n    if (ik == 6) ft *= (2. + (vfFast - 1.) * ft) / (vfFast + 1.);\n    p.xz = p1.xz + oDir.xz * ft * vec2 (trkDir, 1.);\n    p.y = p1.y + oDir.y * smoothstep (0., 1., ft);\n    oDir.y *= 6. * ft * (1. - ft);\n    oDir = normalize (oDir);\n  } else if (ik == 4) {\n    ft *= pi;\n    p = cUpCirc;\n    u = vec3 (- cos (ft) * trkDir, 0., sin (ft));\n    p.xz += rUpCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= trkDir;\n  } else if (ik == 8) {\n    ft = (ft < 0.5) ? ft * (1. + vfLoop * (1. - 2. * ft)) :\n       ft * (1. + 2. * vfLoop * (ft - 1.5)) + vfLoop;\n    p = 0.5 * (cPt[7] + cPt[8]);\n    p.x += sLoop * (1. - 2. * ft) * trkDir;\n    ft *= 2. * pi;\n    u = vec3 (0., cos (ft), sin (ft));\n    p.yz += rLoop * (vec2 (1., 0.) - u.yz);\n    oNorm = u;\n    oDir = normalize (vec3 (-2. * sLoop * trkDir, 2. * pi * rLoop *\n       vec2 (sin (ft), - cos (ft))));\n  } else if (ik == 10) {\n    ft *= pi;\n    p = cDnCirc;\n    u = vec3 (cos (ft) * trkDir, 0., - sin (ft));\n    p.xz += rDnCirc * u.xz;\n    oDir = cross (oNorm, u);\n    oDir.xz *= trkDir;\n  } else if (ik < N_SEG) {\n    oDir = p2 - p1;\n    p = p1 + oDir * ft;\n    oDir = normalize (oDir);\n  }\n  return p;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat TrkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 trCs;\n  float d, f, tGap, tWid, rt, x;\n  tGap = 0.7 * wTrk;\n  tWid = 0.3 * wTrk;\n  rt = 0.5 * tWid;\n  trCs = vec2 (tWid, hTrk) - rt;\n  q = p - cPtOrg;\n  q.y -= rLoop;\n  f = smoothstep (0., 1., atan (abs (q.z), - q.y) / pi);\n  x = q.x * trkDir;\n  q.xy = vec2 (q.x - sign (q.z) * sLoop * f * trkDir, length (q.yz) - rLoop);\n  d = 0.9 * max (max (PrRoundBox2Df (vec2 (abs (q.x - sLoop * trkDir) - tGap, q.y), trCs, rt),\n     q.z), x - (sLoop + wTrk));\n  DMINQ (idTrk);\n  d = 0.9 * max (max (PrRoundBox2Df (vec2 (abs (q.x + sLoop * trkDir) - tGap, q.y), trCs, rt),\n     - q.z), - x - (sLoop + wTrk));\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[5] + cPt[6]);\n  f = 0.5 * clamp (q.z / sDnRamp + 1., 0., 2.);\n  q.y -= hTop * (2. * smoothstep (0., 1., f) - 1.);\n  d = 0.6 * PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs.x, trCs.y * (1. +\n     2. * abs (f * (1. - f))), sDnRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[1] + cPt[2]);\n  f = 0.5 * clamp (q.z / sUpRamp + 1., 0., 2.);\n  q.y -= hTop * (2. * smoothstep (0., 1., f) - 1.);\n  d = 0.6 * PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs.x,\n     trCs.y * (1. + 2. * abs (f * (1. - f))), sUpRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[2] + cPt[3]);\n  d = PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs, sHzRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[4] + cPt[5]);\n  d = PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs, sHzRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[6] + cPt[7]);\n  d = PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs, 2. * sHzRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[8] + cPt[9]);\n  d =  PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs, sHzRamp), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[1] + cPt[10]);\n  d = PrRound2BoxDf (vec3 (abs (q.x) - tGap, q.yz), vec3 (trCs, sHzStr), rt);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[9] + cPt[10]);\n  q.xy = vec2 (length (q.xz) - rDnCirc, q.y);\n  d = max (PrRoundBox2Df (vec2 (abs (q.x) - tGap, q.y), trCs, rt), q.z);\n  DMINQ (idTrk);\n  q = p - 0.5 * (cPt[3] + cPt[4]);\n  q.xy = vec2 (length (q.xz) - rUpCirc, q.y);\n  d = max (PrRoundBox2Df (vec2 (abs (q.x) - tGap, q.y), trCs, rt), - q.z);\n  DMINQ (idTrk);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, colRad;\n  dMin = dstFar;\n  dMin = TrkDf (p, dMin);\n  colRad = 0.02;\n  q = p - cUpCirc;\n  q.yz -= vec2 (- hTop, - 2. * sHzRamp);\n  q.x = abs (q.x) - rUpCirc;\n  q.xz = abs (q.xz) - 20. * colRad * max (- q.y / hTop - 0.75, 0.);\n  d = 0.6 * PrCylDf (q.xzy, colRad, hTop);\n  q = p - cUpCirc;\n  q.xz = Rot2D (q.xz, (0.5 + floor (atan (q.z, - q.x) * (4. / pi))) * pi / 4.);\n  q.xy -= vec2 (- rUpCirc, - hTop);\n  q.xz = abs (q.xz) - 20. * colRad * max (- q.y / hTop - 0.75, 0.);\n  d = min (d, 0.6 * max (PrCylDf (q.xzy, colRad, hTop), cUpCirc.z - p.z));\n  q = p - 0.5 * (cPt[1] + cPt[2]);\n  q.y -= -0.5 * (hTop + colRad);\n  d = min (d, PrCylDf (q.xzy, colRad, 0.5 * hTop));\n  q = p - 0.5 * (cPt[5] + cPt[6]);\n  q.y -= -0.5 * hTop;\n  d = min (d, PrCylDf (q.xzy, colRad, 0.5 * hTop - colRad));\n  q = p - cPtOrg;\n  q.y -= rLoop + 0.03;\n  q.x = abs (q.x) - sLoop - wTrk - 0.25;\n  q.xz = abs (q.xz) - 20. * colRad * max (- q.y / rLoop - 0.75, 0.);\n  d = min (d, 0.6 * PrCylDf (q.xzy, colRad, rLoop + 0.03));\n  q = p - cPtOrg;\n  q.y -= 2. * (rLoop + 0.03);\n  d = min (d, PrCylDf (q.yzx, colRad, sLoop + wTrk + 0.28));\n  DMINQ (idPyl);\n  for (int k = 0; k < N_CAR; k ++) {\n    if (riding && k == N_CAR - 1) continue;\n    q = p - carPos[k];\n    if (! isSh) d = PrSphDf (q - vec3 (0., hTrk + 0.04, 0.), 0.25);\n    if (isSh || d < 0.1) {\n      q = carMat[k] * q;\n      q.y -= hTrk + 0.04;\n      d = max (PrCapsDf (q, 0.085, 0.125),\n         - max (PrCapsDf (q + vec3 (0., -0.03, 0.), 0.075, 0.1), -0.015 - q.y));\n      DMINQ (idCar + k);\n    } else dMin = min (dMin, d);\n  }\n  q = p;\n  q.y -= 0.5;\n  q.xz = Rot2D (q.xz, (0.5 + floor (atan (q.z, - q.x) * (16. / pi))) * pi / 16.);\n  q.x += 10.;\n  d = 0.9 * PrCylDf (q.xzy, 0.04 - 0.03 * q.y, 0.5);\n  DMINQ (idTrnk);\n  q.y -= 0.6;\n  d = 0.9 * PrCapsDf (q.xzy, 0.2 - 0.2 * q.y, 0.2);\n  DMINQ (idLeaf);\n  q = p - cPt[0];\n  q.y -= 0.5 * hTrk;\n  q.x = abs (q.x) - 0.24;\n  d = PrBoxDf (q, vec3 (0.17, 0.5 * hTrk, 0.4));\n  DMINQ (idPlat);\n  q = p - cPt[0];\n  q.y -= 0.07;\n  q.z = abs (q.z) - 0.3;\n  d = max (PrTorusDf (q, 0.01, 0.35), - q.y - 0.1);\n  DMINQ (idArch);\n  q = p - 0.5 * (cPt[9] + cPt[10]);\n  q.y -= 0.07;\n  d = 0.6 * max (max (abs (length (vec2 (length (q.xz) - rDnCirc, q.y)) - 0.3) - 0.02,\n     abs (q.x) + q.z), - q.y - 0.07);\n  DMINQ (idTun);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.8 + 0.2 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (8. * atan (rd.z, - rd.x))) {\n    col = 0.9 * mix (vec3 (0.4, 0.55, 0.7), vec3 (0.3, 0.45, 0.55),\n       smoothstep (-0.02, 0.01, rd.y));\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 q;\n  float f;\n  vec2 e = vec2 (0.01, 0.);\n  ro -= (ro.y / rd.y) * rd;\n  f = Fbm2 (ro.xz);\n  vn = normalize (vec3 (f - vec2 (Fbm2 (ro.xz + e.xy), Fbm2 (ro.xz + e.yx)), 0.1).xzy);\n  col = mix (vec3 (0.4, 0.35, 0.1), vec3 (0.4, 0.5, 0.2), f) * (1. - 0.1 * Noisefv2 (ro.xz));\n  f = smoothstep (7., 8., 0.15 * length (ro.xz * ro.xz * vec2 (2.8, 1.)));\n  if (f < 1.) {\n    col = mix (vec3 (0.6, 0.5, 0.3) * (1. - 0.4 * Fbm2 (64. * ro.xz)), col, f);\n    vn = normalize (mix (vec3 (0., 1., 0.), vn, f));\n    q = ro.xz - cUpCirc.xz;\n    q.y -= -2. * sHzRamp;\n    q.x = abs (q.x) - rUpCirc;\n    f = length (q);\n    if (ro.z > cUpCirc.z) {\n      q = ro.xz - cUpCirc.xz;\n      q = Rot2D (q, (0.5 + floor (atan (q.y, - q.x) * (4. / pi))) * pi / 4.);\n      q.x -= - rUpCirc;\n      f = min (f, length (q));\n    }\n    f = min (f, 2. * length (ro.xz - 0.5 * (cPt[1] + cPt[2]).xz));\n    f = min (f, 2. * length (ro.xz - 0.5 * (cPt[5] + cPt[6]).xz));\n    q = ro.xz - cPtOrg.xz;\n    q.x = abs (q.x) - sLoop - wTrk - 0.25;\n    f = min (f, length (q));\n    col = mix (vec3 (0.6) * (1. - 0.4 * Fbm2 (512. * ro.xz)), col, smoothstep (0.1, 0.3, f));\n    q = ro.xz - 0.5 * (cPt[9] + cPt[10]).xz;\n    f = 99.;\n    if (q.y < 0.) f = abs (length (q) - rDnCirc);\n    if (abs (q.y - 1.) < 1.05) f = min (f, abs (abs (q.x) - rDnCirc));\n    if (abs (ro.z + 2.5) < 1.5) f = min (f, abs (ro.x - cPtOrg.x - sLoop));\n    col = mix (vec3 (0.6) * (1. - 0.4 * Fbm2 (512. * ro.xz)), col,\n       smoothstep (7., 8., f / wTrk));\n  } else if (abs (length (ro.xz) - 10.) < 0.2) {\n    q = ro.xz;\n    q = Rot2D (q, (0.5 + floor (atan (q.y, - q.x) * (16. / pi))) * pi / 16.);\n    q.x += 10.;\n    col *= 0.7 + 0.3 * smoothstep (0.1, 0.2, length (q));\n  }\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstObj, dstGrnd, nDotS, sh;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idTrk) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.3);\n    } else if (idObj == idPyl) {\n      col4 = vec4 (0.8, 0.5, 0.2, 0.1) * (0.7 + 0.3 *\n         SmoothBump (0.05, 0.95, 0.01, mod (32. * qHit.y, 1.)));\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.8, 0.5, 0.2, 0.1) * (1. - 0.2 * Fbm2 (64. * ro.xz));\n    } else if (idObj == idArch) {\n      col4 = vec4 (mix (vec3 (0., 0., 1.), vec3 (1., 1., 0.),\n         step (mod (32. * (atan (qHit.y, - qHit.x) / pi + 1.), 1.), 0.5)), 0.2);\n    } else if (idObj == idTun) {\n      col4 = vec4 (0.6, 0.5, 0.3, 0.) * (1. - 0.2 * Fbm2 (32. * ro.xz));\n    } else if (idObj >= idCar) {\n      col4 = (idObj == idCar + N_CAR - 1) ? vec4 (1., 1., 0., 0.5) : vec4 (1., 0., 0., 0.5);\n      if (qHit.y < -0.05) col4.rgb = vec3 (0.7);\n      if (qHit.z > 0.18) col4.rgb = vec3 (0., 1., 0.);\n    } else if (idObj == idTrnk) {\n      col4 = vec4 (0.5, 0.3, 0., 0.1) * (0.7 + 0.3 * SmoothBump (0.1, 0.9, 0.003,\n         mod (8. * atan (qHit.z, - qHit.x) / pi, 1.)));\n    } else if (idObj == idLeaf) {\n      col4 = vec4 (0., 0.8, 0.2, 0.1);\n      vn = VaryNf (32. * ro, vn, 4.);\n    }\n    nDotS = max (dot (vn, sunDir), 0.);\n    if (idObj == idTrk || idObj == idArch || idObj >= idCar) nDotS *= nDotS;\n    sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotS) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else if (rd.y < 0.) {\n    roo = ro;\n    col = GrndCol (ro, rd);\n    dstGrnd = - ro.y / rd.y;\n    if (dstGrnd < dstFar) col *= ObjSShadow (ro + dstGrnd * rd, sunDir);\n    col = mix (col, SkyBgCol (roo, rd), pow (1. + rd.y, 32.));\n  } else col = SkyBgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvs, uvw, ori, ca, sa, mMid[2], ut[2], mSize, msw;\n  float az, el, asp, zmFac, pDist, sr, vel, vuId, regId, winHt;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.85;\n  trkDir = (mod (floor (dateCur.w / 3600.), 2.) > 0.) ? 1. : -1.;\n  mSize = (1./5.) * vec2 (asp, 1.) * winHt;\n  mMid[0] = vec2 (asp * (1. - mSize.y), winHt - mSize.y) * vec2 (- trkDir, -1.);\n  mMid[1] = vec2 (asp * (1. - mSize.y), winHt - mSize.y) * vec2 (- trkDir, 1.);\n  ut[0] = abs (uv - mMid[0]) - mSize;\n  ut[1] = abs (uv - mMid[1]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = mPtr.xy + 0.5 * vec2 (- trkDir, winHt);\n    if (trkDir * msw.x < - (1. - mSize.x / asp)) {\n      if (msw.y < mSize.y) {\n        regId = 1.;\n      } else if (msw.y > winHt - mSize.y) {\n        regId = 2.;\n        msw.y -= winHt - mSize.y;\n      }\n      msw.x = (msw.x + trkDir * (1. - 0.5 * mSize.x / asp)) / (mSize.x / asp);\n      msw.y = (msw.y / mSize.y - 0.5);\n    }\n    if (abs (mPtr.y) > 0.5 * winHt) regId = -1.;\n  }\n  vuId = 0.;\n  for (int k = 0; k < 2; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId == 1.) {\n    if (vuId == 0. || vuId == 1.) vuId = 1. - vuId;\n  } else if (regId == 2.) {\n    if (vuId == 0. || vuId == 2.) vuId = 2. - vuId;\n  }\n  riding = (vuId == 0.);\n  TrkSetup ();\n  vel = 0.5;\n  for (int k = 0; k < N_CAR; k ++) {\n    carPos[k] = TrkPath (vel * tCur - tWait + tLen[N_SEG] *\n       float (N_CAR - 1 - k) / float (N_CAR));\n    carMat[k] = AxToRMat (oDir, oNorm);\n  }\n  uvw = uv;\n  if (vuId == 0.) {\n    ro = carPos[N_CAR - 1];\n    ro += (hTrk + 0.3) * oNorm - 0.3 * oDir;\n    uvw = vec2 ((1./0.5) * sin (0.5 * uv.x), uv.y);\n    zmFac = 3.;\n    az = 0.;\n    el = -0.02 * pi;\n    if (regId == 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.5 * pi * mPtr.y;\n    }\n    zmFac = 3.;\n  } else if (vuId == 1.) {\n    az = 0.5 * pi;\n    el = -0.02 * pi;\n    if (regId == 1.) {\n      az -= 2. * pi * msw.x;\n      el -= 0.5 * pi * msw.y;\n      el = clamp (el, -0.45 * pi, 0.);\n    }\n    zmFac = 3.;\n  } else if (vuId == 2.) {\n    ro = 0.5 * (cDnCirc + cUpCirc);\n    vd = carPos[N_CAR - 1] - ro;\n    pDist = length (vd);\n    vd = normalize (vd);\n    az = 0.5 * pi + atan (- vd.z, vd.x);\n    el = asin (vd.y);\n    if (regId == 2.) {\n      az += 0.5 * pi * msw.x;\n      el += 0.5 * pi * msw.y;\n    }\n    zmFac = 2. + 0.3 * pDist;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  if (vuId == 1.) ro = vuMat * vec3 (0., 1., -15.);\n  sunDir = normalize (vec3 (sin (0.02 * tCur - 0.5 * pi + vec2 (0.5 * pi, 0.)), 1.).xzy);\n  dstFar = 60.;\n  col = vec3 (0.);\n  if (abs (uvs.y) < winHt) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = normalize (vec3 (uvw + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n          sr * (0.667 * a + 0.5) * pi), zmFac));\n      rd = vuMat * rd;\n      if (vuId == 0.) rd = rd * carMat[N_CAR - 1];\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (max (ut[k].x, ut[k].y) < 0. && min (abs (ut[k].x), abs (ut[k].y)) * canvas.y < 2.)\n       col = vec3 (0.4, 0.4, 0.);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRound2BoxDf (vec3 p, vec3 b, float r)\n{\n  return max (length (max (abs (p.xy) - b.xy, 0.)) - r, abs (p.z) - b.z);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 AxToRMat (vec3 vz, vec3 vy)\n{\n  vec3 vx;\n  vx = normalize (cross (vy, vz));\n  vy = cross (vz, vx);\n  return mat3 (vec3 (vx.x, vy.x, vz.x), vec3 (vx.y, vy.y, vz.y), vec3 (vx.z, vy.z, vz.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3Rl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1140, 1140, 1158, 1158, 2653], [2655, 2655, 2679, 2679, 4284], [4357, 4357, 4391, 4391, 6615], [6617, 6617, 6639, 6639, 8967], [8969, 8969, 9002, 9002, 9243], [9245, 9245, 9266, 9266, 9456], [9458, 9458, 9495, 9495, 9732], [9734, 9734, 9768, 9768, 10601], [10603, 10603, 10636, 10636, 12430], [12432, 12432, 12467, 12467, 14366], [14368, 14368, 14424, 14424, 18186], [18188, 18188, 18220, 18220, 18320], [18322, 18322, 18369, 18369, 18416], [18418, 18418, 18465, 18465, 18541], [18543, 18543, 18576, 18576, 18603], [18605, 18605, 18647, 18647, 18698], [18700, 18700, 18743, 18743, 18807], [18809, 18809, 18855, 18855, 18912], [18914, 18914, 18948, 18948, 19110], [19112, 19112, 19142, 19142, 19255], [19257, 19257, 19314, 19314, 19397], [19431, 19431, 19455, 19455, 19508], [19510, 19510, 19534, 19534, 19664], [19666, 19666, 19691, 19691, 19837], [19839, 19839, 19864, 19864, 20050], [20052, 20052, 20074, 20074, 20228], [20230, 20230, 20251, 20251, 20406], [20408, 20408, 20437, 20437, 20649], [20651, 20651, 20690, 20690, 20870]], "test": "error"}
{"id": "Wtl3Wf", "name": "Blob bands", "author": "ThaRemo", "description": "Moving blob with banding", "tags": ["banding", "blob", "bands"], "likes": 3, "viewed": 98, "published": "Public", "date": "1557915536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Counts amount of bits in 8 bit int\n// Seems to be built-in for Nvidia GPUs (at least not available on my AMD RX480, Chrome)\nuint bitCount(in uint num) {\n  uint n = num;\n  n = ((0xaau & n) >> 1) + (0x55u & n);\n  n = ((0xccu & n) >> 2) + (0x33u & n);\n  n = ((0xf0u & n) >> 4) + (0x0fu & n);\n  return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    // Bit attr\n    uint attr = 0u;\n    for (int i = 0; i < 8; ++i) {\n        if (length(uv - vec2(0.5) - 0.1 * sin(uv * 5.0 * sin(iTime + iMouse.xy / iResolution.xy))) * 2.0 < float(i) / 8.0) {\n         \tattr |= 1u << i;   \n        }\n    }\n    \n    uint nBits = bitCount(attr);\n    \n    float t = (float(attr) / 255.0);\n\tcol = vec3(float(nBits) / 8., t * uv.x, t * uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 155, 155, 305]], "test": "ok"}
{"id": "Wtl3zS", "name": "Disk-tortion", "author": "tpfto", "description": "Hexagonally packed disks deformed by a Möbius transformation.", "tags": ["2d", "math", "complex"], "likes": 9, "viewed": 137, "published": "Public", "date": "1556737961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Use a (complex) Möbius transformation to distort a set of hexagonally packed disks\n\n#define IS3 1.0/sqrt(3.0)\n\n// some colors\n#define C1 vec3(0.18, 0.31, 0.31)\n#define C2 vec3(0.1, 0.8, 0.6)\n\n// XY range of the display.\n#define DISP_SCALE 4.0 \n\n// from Fabrice Neyret, \n#define cis(a) vec2( cos(a), sin(a) )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cdiv(A,B) ( cmul( A, vec2( (B).x, -(B).y ) ) / dot(B, B) )\n\n// uncomment to see a square packing instead\n// #define SQUARE\n\n// Möbius transformation parametrized by its fixed points g1, g2 and pole zi, https://en.wikipedia.org/wiki/M%C3%B6bius_transformation#Poles_of_the_transformation\n\nvec2 moebius( in vec2 g1, in vec2 g2, in vec2 zi, in vec2 z )\n{\n\treturn cdiv(cmul(g1 + g2 - zi, z) - cmul(g1, g2), z - zi);\n}\n\n#ifndef SQUARE\n\n// generate hexagonally packed disks\n\nfloat hexpack(vec2 p)\n{\n      float sc = 3.0 * DISP_SCALE / iResolution.y;\n      float x = p.x, y = p.y * IS3;\n\n      float u = mod(x - y, 1.0), v = mod(2.0 * y, 1.0);\n      float qf = 4.0 * (u + v) * (u + v) - 4.0 * u * v - 1.0;\n      float qu = 4.0 * (1.0 - 2.0 * u - v);\n      float qv = 4.0 * (1.0 - u - 2.0 * v);\n    \n      return min(min(smoothstep(0.0, sc, qf), smoothstep(0.0, sc, qu + qf)),\n                 min(smoothstep(0.0, sc, qv + qf), smoothstep(0.0, sc, 4.0 + qu + qv + qf)));\n}\n\n#else\n\n// generate square packed disks\n\nfloat sqrpack(vec2 p)\n{\n      float sc = 0.75 * DISP_SCALE / iResolution.y;\n      vec2 u = 0.5 - mod(p, 1.0);\n    \n      return 1.0 - smoothstep(0.0, sc, 0.25 - dot(u, u));\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= DISP_SCALE;\n\n        // specify the fixed points; vary the pole's position\n        vec2 w = moebius(vec2(1.0, 1.0), -vec2(1.0, 1.0), vec2(8.0, 6.0) * cis(iTime), uv);\n    \n        // generate the packed disks\n        #ifndef SQUARE\n        float c = hexpack(w);\n        #else\n        float c = sqrpack(w);\n        #endif\n\n        vec3 col = mix(C2, C1, c);\n\n        fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3zS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1733, 1733, 1796, 1796, 1858], [2635, 2635, 2692, 2692, 3225]], "test": "ok"}
{"id": "wtl3zX", "name": "Cellular Tiling mod", "author": "etown36", "description": "Creating a Voronoi feel with minimal instructions by way of a tileable cellular texture.\nvia Shane\nhttps://www.shadertoy.com/view/4scXz2", "tags": ["2d", "voronoi", "cellular"], "likes": 8, "viewed": 203, "published": "Public", "date": "1557176547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tCellular Tiling\n\t---------------\n\n    Creating a Voronoi feel with minimal instructions by way of a tileable texture constructed \n\tvia a simplistic cellular pattern algorithm... That description was a bit verbose, but the \n\tmethod is really easy to understand. This is the 2D version, but I have a simple 3D example \n\tthat I'll put up pretty soon.\n\n\tThere's an old texture generation routine that involves drawing a bunch of random gradient \n\tcircles (or other shapes) onto a texture using the darken (min(src, dst)) blend. The result \n\tis a cellular looking texture reminiscent of Voronoi, which is hardly surprising, given the\n\tsimilar methods of construction.\n\n\tBy applying various colors, shapes and sizes, you can make some really cool looking images, \n\tbut it's not particularly suitable for realtime generative purposes, due to the fact that \n\tyou need to draw a lot of shapes (normally circles) to cover the area, etc.\n\n\tAnyway, I figured I could cheapen the process by doing it in repeatable tile form, since a\n\tsmaller area requires fewer circles for coverage, etc. I had the idea after working with \n\tTruchet tiles. It worked pretty well, so then I got to wondering how few operations I could \n\tget away with without it looking too repetitive. As it turns out, very few. In fact, it can \n\tbe a particularly cheap process.\n\n\tNaturally, there are a few restrictions. The obvious one is that small repeatable tiles look \n\tvery repetitive when you zoom out, so that has to be considered. The upside was the entire\n    point of doing this, which is that it requires virtually no extra effort to produce 3D tiles. \n\tThat means quasi 3D celluar surfaces that are fast enough to include in a distance \n\tfunction... under certain restrictions, of course.\n\n\tThe code in this particular example comprises mostly bumping and lighting, which I added out \n\tof sheer boredom, so you'll probably only want to look it if you're equally bored. :) The \n\t\"cellTex\" routine and the accompanying \"drawShape\" function are all that are required, for \n\tanyone interested. Both\tcontain just a few self explanatory lines.\n\n*/\n\n// Layer rotation: For the cost of an extra 2x2 matrix by vec2 multiply, you can drastically \n// increase the randomness. I came up with this when experimenting. The idea can be extended\n// to the 3D version as well.\n#define LAYER_ROTATION\n\n\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat noise3D(vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(1, 113, 57);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (eight circles, in this case) using \n// the darken (min(src, dst)) blend at various locations on a tile. Make the tile wrappable by \n// ensuring the shapes wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four circles. Of course, there is 4-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's lower overall. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// However, the main reason you'd bother in the first place is the ability to extrapolate\n// to a 3D setting (swap circles for spheres) for virtually no extra cost. The result isn't\n// perfect, but 3D cellular tiles can enable you to put a Voronoi looking surface layer on a \n// lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawShape(in vec2 p){\n    \n    // Wrappable circle distance. The squared distance, to be more precise.\n    p = fract(p)-.50;    \n    return dot(p, p);\n    \n    // Other distance metrics.\n    \n    p = abs(fract(p)-.50);\n    p = pow(p, vec2(8.));\n    return pow(p.x+p.y, .125)*.25;\n    \n    p = abs(fract(p)-.50);\n    p *= p;\n    return max(p.x, p.y);\n    \n    p = fract(p)-.50;\n    float n = max(abs(p.x)*.866 + p.y*.50, -p.y);\n    return n*n;\n    \n}\n\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\n//\nfloat cellTex(in vec2 p){   \n    \n \n    float c = 2.9; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5);  \n    #endif\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    //p *= 1.4142;  \n    p = p.yx; // Extra option, or addition.\n    \n    \n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    #ifdef LAYER_ROTATION\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.50, -.866, .866, .5)*(p - .50);\n    #endif\n    \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);\n    \n}\n///////////\n\n// Colored cellular texture.\n//\nvec3 tex2D(vec2 p){\n    \n    float c = cellTex(p*2.)*.95 + .05;\n\t//vec3 col = vec3(c*c*.7, c, c*c*.2) + (cellTex(p*6.))*.05 - .025; // Bio green.\n    vec3 col = vec3(c*c, c*sqrt(c), c) + (cellTex(p*3.))*.05 - .025; // Blueish.\n    col = clamp(col, 0., 1.);\n    // Sinusoidally mixing in a complimentary color, of sorts, for a bit of variance.\n    return mix(col, col.yzx, dot(sin(p*12. - sin(p.yx*12. + c*6.283)), vec2(.5))*.15 + .2);\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, we're returning \n// some combined cellular texture values that coincide with the texture value above.\n//\nfloat bumpFunc(vec2 p){ \n\n    \n\treturn cellTex(p*2.)*.99 + (cellTex(p*6.))*.15;// Range: [0, 1]\n\t\n    // Grayscale version of the colored function.\n\t//return dot(tex2D(p), vec3(.299, .587, .114)); // Range: [0, 1]\n\n\n}\n\n// Standard bump function.\n//\nvec3 bump(vec3 sp, vec3 sn, float bumpFactor){\n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n   \n \t\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    vec3 grad = vec3(fx, fy, 0);\n    grad -= sn*dot(sn, grad);\n    //sn = normalize( sn + grad*bumpFactor ); \n   sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor ); \n    \n    return sn;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinate  .\n\tvec2 uv = (fragCoord - iResolution.xy*.55)/iResolution.y;  \n    \n     uv *= iResolution.y/450.; // Maintaining cellular size.\n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane. \n    vec3 ro = vec3(vec2(iTime*.35, sin(iTime*.05)*2.), -1);\n    vec3 sp = vec3(uv + ro.xy, 0.); // Surface posion. Hit point, if you prefer.\n    vec3 rd = normalize(sp - ro); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = ro + vec3(cos(iTime)*0.66, sin(iTime)*0.33, -1); // Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n     \n  \n    // Bump mapping. Perturbing the normal.\n    sn = bump(sp, sn, 0.05);\n    \n    // LIGHTING\n    //\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;\n\n    // Light attenuation.    \n    float atten = min(11./(.75 + lDist*0.15 + lDist*lDist*0.05), 1.);\n\t//float atten = min(1./(lDist*lDist*40.), 1.);\n\n\t\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 64.);\n    float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n\n    \n\t\n    // TEXTURE COLOR\n    //\n\t// Using the position to index into the texture.\n    vec3 texCol = tex2D(sp.xy);\n    \n    \n    \n    // Applying some unrealistic refraction.\n    vec3 ref = sp + refract(rd, sn, 1./1.425)*.85;\n    float b = bumpFunc(ref.xy);\n    ref = vec3(.5, .05, .5)*b;\n    \n    // Equally unrealistic, cloudy reflection. Just for fun. Not important.\n    vec3 rfl = sp + reflect(rd, sn)*2.;\n    b = noise3D(rfl)*.86 + noise3D(rfl*2.)*.34;\n    b = smoothstep(.3, 1., b);\n    ref += mix(vec3(.125, .2, .25), vec3(1, .8, 1), b*b)*.55;\n    ref *= ref;\n\n\n\n\n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = texCol*(diff + 0.5) + ref +  texCol.zxy*spec*.5; + vec3(.5, .8, 1)*fre*fre*2.;\n    col *= atten;\n    \n    \n    // Apply a vignette. The point light already does this, but this sets off the\n    // edges a little more.\n    uv = fragCoord/iResolution.xy; \n    col *= pow( 8.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125/2.);\n\n    // Done. \n\tfragColor = vec4(sqrt(max(col, 0.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtl3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2357, 2617, 2639, 2732, 3683], [3695, 4646, 4673, 4754, 5101], [5103, 5262, 5287, 5287, 6643], [6657, 6689, 6708, 6708, 7130], [7132, 7305, 7328, 7328, 7522], [7524, 7554, 7600, 7962, 8916], [8920, 8920, 8976, 9005, 11575]], "test": "ok"}
{"id": "WtlGDB", "name": "Stars travel", "author": "z0rg", "description": "Still work to do, trails were working properly in another context", "tags": ["2d", "space", "stars"], "likes": 8, "viewed": 635, "published": "Public API", "date": "1557502831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 highlightRed = vec3(255,233,161)/155.0;\nvec3 redStr =vec3(255.0,39.0,49.0)/255.0;// vec3(0.8793, 0.213,0.421);\nconst float PI = 3.1415927;\nconst float EPS = 0.001;\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat lenSqr(vec2 v)\n{\n  return v.x*v.x+v.y*v.y;\n}\n\nfloat lenNY(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nfloat getAngle(vec2 uv)\n{\n  return atan(uv.y, uv.x)/PI;\n}\n\nfloat sat(float a)\n{\n  return clamp(a,0.0,1.0);\n}\n\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y),sat(v.z));\n}\n\nfloat mypow(float a)\n{\n  return pow(a,15.0);\n}\n\n\nvec3 rdrStar(vec2 uv, vec3 pos)\n{\n  float val = 1.0-clamp(length(uv-pos.xy)/pos.z,0.0,1.0);\n  return vec3(pow(val,5.0));\n}\n\n\nvec3 rdrStarTrail(vec2 uv, vec3 pos)\n{\n  //return vec3(0.0);\n  float len = length(uv);\n  float trailLen = length(pos.xy);\n  float flen = 1.0-sat(dot(-uv+pos.xy, -pos.xy));//sat(len/trailLen);\n\treturn vec3(flen)*0.01;\n  float ftrail = 1.0-sat(trailLen / (.05));//end of trail\n  return ftrail*2.2*len*len*pow(flen,50.0)*vec3(sat(mypow(dot(normalize(pos.xy), normalize(uv)))));\n}\n\n\n\nfloat renderStars(vec2 uv, float speed, float sz, float offset)\n{\n  float angle = getAngle(uv);\n  int cntStars = 20;\n  vec3 res;\n\n  for(int i = 0; i < cntStars; ++i)\n  {\n    float fi = float(i);\n    float maxRad = 1.5;\n    float r = mod(fi/float(cntStars)+iTime*speed,maxRad);\n    float a =fi*offset+offset;\n    vec2 pos = vec2(r*cos(a),r*sin(a));\n    res+= rdrStarTrail(uv, vec3(pos,sz));\n    res+= rdrStar(uv, vec3(pos,0.1*r*sz));\n  }\n  return res.x;\n  //return vec3(1.0)-sat(mix(highlightRed, redStr, res.x));\n}\n\nvec3 rdrBg(vec2 uv)\n{\n  vec3 bg = 0.6*vec3(72,12,66)/255.0;\n  float lenny = sat(lenNY(uv));\n  vec3 sun = 0.7*mix(highlightRed, vec3(0.0), sqrt(sat(lenny*1.2)));\n  vec3 sun2 = 0.2*mix(highlightRed, vec3(0.0), lenny*0.7);\n\n  return bg+sun+sun2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 cuv = uv - (iResolution.xy/iResolution.xx)*0.5;\n  if (abs(cuv.x) > EPS && abs(cuv.y) > EPS)\n  cuv = normalize(cuv)*pow(length(cuv),0.5);\n  float noise = 0.1*sat(rand(10.0*uv+vec2(iTime*0.0001,0.0)));\n  vec3 bg = rdrBg(cuv);\n  float spd = 0.5;\n\n  float str1 = renderStars(cuv,1.0*spd, 5.0, 1.0);\n  vec3 outCol = 0.5*(vec3(1.0)-sat(mix(highlightRed, redStr, str1)));\n  vec3 outCol2 = 0.5*vec3(highlightRed)*renderStars(cuv,2.0*spd, 0.7, 3.53);\n  fragColor = vec4(bg+outCol+noise+outCol2, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlGDB.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[566, 566, 586, 586, 654], [656, 656, 678, 678, 706], [708, 708, 729, 729, 759], [761, 761, 786, 786, 818], [820, 820, 840, 840, 869], [871, 871, 889, 889, 934], [936, 936, 958, 958, 982], [985, 985, 1018, 1018, 1107], [1110, 1110, 1148, 1170, 1486], [1490, 1490, 1555, 1555, 2004], [2006, 2006, 2027, 2027, 2250], [2253, 2253, 2310, 2310, 2854]], "test": "ok"}
{"id": "WtlGRf", "name": "Reflectionsion Raymarching", "author": "Hendiadyoin", "description": "Raymarching-shader with recursive reflections\nPlease click in the Center of the screen to get a propper view\n\nNotes:\n- work on a more realistic way to show the light", "tags": ["raymarching"], "likes": 10, "viewed": 290, "published": "Public", "date": "1557138558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MaxSteps 1000\n#define MinDist .0005\n#define MaxDist 100.\n\n#define PI 3.1415926535897931\n\n//diffuse factor\n#define dc .9\n//reflection factor\n#define rc .1\n#define reflection_cutof 0.000000001\n\n#define glight vec3(sin(iTime)*1.9,.5,cos(iTime)*1.9+6.)\n\nfloat getDist(vec3 p){\n    //a sphere with repeating x.axis f=3\n\tfloat dist = length(mod(p+vec3(1.5,0,0),vec3(3,0,0))\n                        -vec3(0,1,6)-vec3(1.5,0,0)) - 1.;\n    //the plane\n    dist = min(dist,p.y);\n    \n    return dist;\n}\n\nvec3 estNormal(vec3 p){\n\tvec2 sstep = vec2(.001,0);\n    float gradx = getDist(p+sstep.xyy)-getDist(p-sstep.xyy);\n    float grady = getDist(p+sstep.yxy)-getDist(p-sstep.yxy);\n    float gradz = getDist(p+sstep.yyx)-getDist(p-sstep.yyx);\n    \n\treturn normalize(vec3(gradx,grady,gradz));\n}\n\nfloat castRay(vec3 ro,vec3 rd){\n\tfloat dist = 0.;\n    for(int i = 1;i<MaxSteps;i++){\n    \tfloat d = getDist(ro + dist*rd);\n        if(d<MinDist) break;\n        dist += d;\n        if(dist > MaxDist) break;\n    }\n    return dist;\n}\n\nfloat getDiff(vec3 p,vec3 light){ //defuse lighting\n\tvec3 lv = normalize(light-p);\n    vec3 n = estNormal(p);\n    float rd = castRay(p+n*MinDist*2.,lv);\n    float b = (dot(n,lv));\n    if(rd<length(light-p)){\n    \tb*=.1;\n    }\n    return max(b,0.); \n}\n\nfloat FresnelReflectAmount ( vec3 p, vec3 vr)\n{// n1:refl, n2:refr ,incident:vr\n    \tvec3 normal = estNormal(p);\n\t\tfloat n1 = 2.;\n    \tfloat n2 = 1.7;\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, vr);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        ret = (rc + (1.0-rc) * ret);\n        return ret;\n}\n\nfloat getRefl(vec3 p,vec3 vr, vec3 light){//reflective ligthing\n    float c = 0.;\n    float fact = 1.;\n    for(;;){\n        if (fact<0.000000001)\n            break;\n        vec3 n = estNormal(p);\n   \t\tp += n*MinDist;\n    \tfloat s = dot(n,vr);\n        \n    \tvec3 r = normalize(vr - 2. * s * n);\n    \t\n    \tfloat d = castRay(p,r);\n    \t\n        \n        if(d>length(light-p)){\n    \t\tc += pow(smoothstep(.5,.0,length(r-normalize(light-p))),5.);\n        }\n        if(d>MaxDist) break;\n        fact*= rc;\n    \tvr = normalize((p+r*d)-p);\n        p = p+r*d;\n       \n        \n   \t\tc += getDiff(p,light)*dc*fact;\n    }\n    return c;\n    \n}\n\n\nfloat getBright(vec3 p,vec3 vr,vec3 light){//general lighting\n\tfloat diff = getDiff(p,light);\n    float refl = getRefl(p,vr, light);\n\tfloat b = diff*dc + refl;\n    //float sp = spec(p,vr);\n    return clamp(b,0.,1.);\n}\n\nmat3 mouseRotX(){\n    float th = -(iMouse.x/iResolution.x)*PI;\n\treturn mat3(sin(th),0,cos(th),\n               0,1,0,\n               cos(th),0,-sin(th));\n}\nmat3 mouseRotY(){\n    float th = (1.-iMouse.y/iResolution.y-.5)*PI;\n\treturn mat3(1,0,0,\n               0,cos(th),-sin(th),\n               0,sin(th),cos(th));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 light = glight;\n        \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,2,0);\n    vec3 rd = normalize(vec3(uv,1))*mouseRotX()*mouseRotY();\n    \n    float d = castRay(ro,rd);\n    //coloring\n    if(d<MaxDist){\n        col = vec3(getBright(ro+rd*d,rd,light));\n    }\n    if(d>length(ro-light))\n    col += pow(smoothstep(0.1,.0,length(rd-normalize(light-ro))),5.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 280, 321, 499], [501, 501, 524, 524, 786], [788, 788, 819, 819, 1017], [1019, 1019, 1052, 1070, 1269], [1271, 1271, 1318, 1350, 1992], [1994, 1994, 2036, 2057, 2624], [2627, 2627, 2670, 2688, 2844], [2846, 2846, 2863, 2863, 3000], [3001, 3001, 3018, 3018, 3160], [3162, 3162, 3218, 3271, 3764]], "test": "ok"}
{"id": "wtlGRl", "name": "Acid Egyptians", "author": "polymonster", "description": "I just needed something animated with different colours quickly so I could implement animated area lights in my engine: https://github.com/polymonster/pmtech", "tags": ["pyramids"], "likes": 6, "viewed": 346, "published": "Public", "date": "1557435091", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14\n#define MOD2 vec2(3.07965, 7.4235)\n\nfloat hash( float p )\n{\n\tvec2 p2 = fract(vec2(p) / MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\nfloat hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nmat3 create_camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n    \n    return mat3( cu, cv, cw );\n}\n\nfloat sd_sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sd_box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sd_octahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n\nfloat bsin(float v)\n{\n    return sin(v) * 0.5 + 1.0;\n}\n\nfloat bcos(float v)\n{\n    return cos(v) * 0.5 + 1.0;\n}\n\nfloat op_union( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat map(vec3 p)\n{\n\tfloat scale = 10.0;\n    float rep = 2.0;\n    float pyr_rep = 300.0;\n    \n    float y = noise(p.xz / 20.0) * 8.0;\n    \n    vec3 q = mod(p - vec3(0.0, y, 0.0), vec3(rep, 0.0, rep)) - 0.5 * rep;\n    vec3 b = mod(p / vec3(1.0, 10.0, 1.0), vec3(0.0, 0.0, 200.0)) - 0.5 * vec3(0.0, 0.0, 200.0);\n    vec3 c = mod(p, vec3(0.0, 0.0, pyr_rep)) - 0.5 * vec3(0.0, 0.0, pyr_rep);\n    \n \tfloat terrain = sd_box(q - vec3(0.0, 5.0, 0.0), vec3(2.5));\n    float pillars_left = sd_box(b - vec3(40.0, 0.0, 0.0), vec3(10.0));\n    float pillars_right = sd_box(b - vec3(-40.0, 0.0, 0.0), vec3(10.0));\n    float pyramids_left = sd_octahedron(c - vec3(-400.0, 0.0, 0.0), 100.0);\n    float pyramids_right = sd_octahedron(c - vec3(400.0, 0.0, 0.0), 100.0);\n    \n    float res = op_union(terrain, pillars_left);\n    res = op_union(res, pillars_right);\n    res = op_union(res, pyramids_left);\n    res = op_union(res, pyramids_right);\n        \n    return res;\n}\n\nvec3 sky(vec3 v)\n{\n    vec3 grad_a = vec3(0.5, 0.5, 0.0);\n    vec3 grad_b = vec3(0.5, 0.0, 1.0);\n    \n    grad_a = vec3(bcos(iTime), 0.2, bcos(-iTime));\n    grad_b = vec3(bsin(iTime), bsin(-iTime), 0.2);\n    \n    float grad_t = v.y * 0.5 + 0.5;\n    \n    return mix(grad_b, grad_a, grad_t);\n}\n\nvec3 calc_normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    \n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    \n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float eps = 0.005;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n    \n    float yp = 20.0 + bsin(iTime) * 20.0;\n    float xp = -0.0;\n    float zp = -10.0 + iTime * 50.0;\n\n    vec3 ro = vec3(xp, yp, zp);\n    \n    vec3 ta = vec3( xp, yp, zp + 10.0);\n    mat3 cam = create_camera( ro, ta, 0.0 );\n        \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;  \n    \n    vec3 rd = cam * normalize( vec3(p.xy,2.0) );\n    \n    float d = 10.0;\n    float xt = 0.0;\n    vec3 pp = ro;\n   \n    vec3 l = normalize(vec3(0.0, 1.0, 1.0));\n    \n    for(float t = 0.0; t < 200.0; ++t)\n    {\n        pp = ro + rd * xt;\n        \n        vec3 qq = pp;\n        d = map(qq);\n        \n        if(d < eps)\n            break;\n        \n        xt += d;\n    }\n    \n    vec3 n = calc_normal(pp);\n    \n    float nv = dot(n, -rd);\n    \n    vec3 csky = sky(rd);\n    vec3 lsky = sky(-rd);\n    \n    vec3 ir = vec3(1.0, 0.0, 0.0) * lsky;\n    vec3 ig = vec3(0.0, 1.0, 0.0) * lsky;\n    vec3 ib = vec3(0.0, 0.0, 1.0) * lsky;\n\n    col += sin(nv * ig * 10.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * ir * 20.0 * 1.5) * 0.5 + 0.5;  \n    col += sin(nv * ib * 5.0 * 1.5) * 0.5 + 0.5;\n    col = clamp(normalize(col), 0.0, 1.0);\n    \n    float mask = step(d, eps);\n    float inv_mask = 1.0 - mask;\n    \n    fragColor = vec4(csky * inv_mask + col * mask, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 75, 75, 174], [176, 176, 196, 196, 282], [284, 284, 310, 310, 554], [556, 556, 612, 612, 781], [783, 783, 819, 819, 845], [847, 847, 879, 879, 966], [968, 968, 1008, 1008, 1071], [1073, 1073, 1094, 1094, 1127], [1129, 1129, 1150, 1150, 1183], [1185, 1185, 1223, 1223, 1248], [1250, 1250, 1269, 1269, 2202], [2204, 2204, 2222, 2222, 2495], [2497, 2497, 2528, 2528, 2766], [2768, 2768, 2825, 2825, 4260]], "test": "ok"}
{"id": "wtlGRX", "name": "a basic lattice", "author": "Cewein", "description": "first raymarching ever\n\nThanks a lot to Shane, \n- no more black dot\n- some fog is added", "tags": ["raymaching"], "likes": 5, "viewed": 453, "published": "Public API", "date": "1557217721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.001;\nconst float RADIANT = 0.0174533;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    float k = .5;\n    return smin(distA, distB, k);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sphereSDF(vec3 samplePoint, float p, float s) {\n    return length(samplePoint - p) - s;\n}\n\nfloat cylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat torusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat CappedCylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n   \tfloat modu = 3.0;\n    \n    samplePoint = mod(samplePoint, modu);\n    \n    float result = sphereSDF(samplePoint, modu/2., .75);\n    result = unionSDF(result, CappedCylinderSDF( samplePoint - modu/2., vec2(0.25,50.)));\n    \n    vec4 rot = rotationMatrix(vec3(1.,0.,0.), 90. * RADIANT) * vec4(samplePoint- modu/2.,1.);\n   \tresult = unionSDF(result, CappedCylinderSDF( rot.xyz, vec2(0.25,50.)));\n    \n    rot = rotationMatrix(vec3(.0,0.,1.), 90. * RADIANT) * vec4(samplePoint- modu/2.,1.);\n   \tresult = unionSDF(result, CappedCylinderSDF( rot.xyz, vec2(0.25,50.)));\n    \n    return result;\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.6 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0., 0.0, 10.0 - (iTime * 5.));\n    \n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n  \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0., 0.0, 15.0 - (iTime * 5.));\n    //vec3 eye = vec3(0.0, 0.0, 15.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.5, 0.5, 0.5);\n    vec3 K_d = vec3(1., 1., 1.);\n    vec3 K_s = vec3(.5, .5, .5);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    vec3 fog = vec3(.5, .7, 1);\n    color = mix(fog, color, 1./(1. + dist*dist*.0005));\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 199, 199, 292], [294, 294, 340, 340, 372], [374, 374, 416, 416, 470], [472, 472, 519, 519, 552], [554, 554, 599, 599, 1227], [1229, 1229, 1282, 1282, 1324], [1326, 1326, 1363, 1363, 1397], [1399, 1399, 1433, 1433, 1498], [1500, 1500, 1543, 1543, 1642], [1644, 1644, 1678, 1678, 2275], [2278, 2278, 2369, 2369, 2675], [2689, 2689, 2754, 2754, 2886], [2889, 2889, 2918, 2918, 3228], [3231, 3231, 3371, 3371, 3961], [3963, 3963, 4048, 4048, 4441], [4444, 4444, 4501, 4501, 5304]], "test": "ok"}
{"id": "Wts3DB", "name": "Synth waves", "author": "avin", "description": "experiment with simplex noise", "tags": ["noise", "wave", "lines", "perlin", "simplex"], "likes": 69, "viewed": 2488, "published": "Public API", "date": "1557505047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COUNT 20.\n#define COL_BLACK vec3(23,32,38) / 255.0 \n\n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\n// Original noise code from https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime *.5;\n    vec3 col;\n    for(float i=COUNT; i>=0.; i-=1.){\n        float edge = simplex_noise(vec3(uv * vec2(2., 0.) + vec2(0, t + i*.15), 1.))*.2 + (.5/COUNT)*i + .25;\n        float mi = SS(edge, uv.y) - SS(edge + .005, uv.y);        \n        m *= SS(edge, uv.y+.015);\n        m += mi;        \n        \n        if(mi > 0.){\n        \tcol = hue(i/COUNT).rgb;\n        }        \n    }           \n    \n    col = mix(COL_BLACK, col, m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 356, 356, 508], [510, 510, 539, 539, 1203], [1205, 1205, 1262, 1262, 1817]], "test": "ok"}
{"id": "Wts3DS", "name": "[Wan] Alien egg", "author": "wan", "description": "May 3rd, 2019. Exploring texture creation with several layers of Voronoi noise.", "tags": ["voronoi", "noise", "texture"], "likes": 5, "viewed": 336, "published": "Public API", "date": "1557490946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CELLS 30.\n\nfloat rand(vec2 p) {\n\treturn fract(sin(p.x*61.21+p.y*45.58)*4001.0);\n}\n\nvec2 cell(vec2 p) {\n\treturn floor(p.xy*CELLS);\n}\n\nvec2 cellorigin(vec2 ij) {\n\treturn ij/CELLS;\n}\n\nvec2 cellcenter(vec2 ij) {\n\tvec2 offset = vec2(rand(ij.xy*10.), rand(ij.yx*10.))/CELLS;\n\tfloat movSpeed = .3;\n\toffset += vec2(sin(iTime*movSpeed+rand(ij.xy)*10.), cos(iTime*movSpeed+rand(ij.yx)*10.) )/CELLS/2.;\n\treturn cellorigin(ij) + clamp(offset, 0., 1./CELLS);\n}\n\nfloat voronoi(vec2 p) {\n\tvec2 ij = cell(p);\n\t\n\tvec2 nearest = ij;\n\tfloat nearestdist = 999.;\n\tfor (float i = -1.; i <= 1.; i++) {\n\tfor (float j = -1.; j <= 1.; j++) {\n\t\tvec2 ijneighbor = ij.xy + vec2(i,j);\n\t\tfloat ijcenterdist = length(p - cellcenter(ijneighbor));\n\t\tif (ijcenterdist  < nearestdist) {\n\t\t\tnearest = ijneighbor;\n\t\t\tnearestdist = ijcenterdist;\n\t\t}\n\t}}\n\treturn nearestdist*CELLS;\n}\n\nfloat map(vec3 p) {\n\tp += voronoi(p.xy/6.)/30.;\n\treturn length(p) - 3.;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(0.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyy)-map(p-e.xyy),\n\t\tmap(p+e.yxy)-map(p-e.yxy),\n\t\tmap(p+e.yyx)-map(p-e.yyx)));\n}\n\nvec3 lightdir = normalize(vec3(.5,-.5,1.));\nfloat lightAt(vec3 p) {\n\treturn dot(-lightdir, normal(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = ( 2.*fragCoord.xy-iResolution.xy ) / iResolution.y;\n\tuv.y /= 1.2;\n\tuv.x *= 1. + uv.y/5.;\n\t\n\tvec3 eye = vec3(0.,0.,-5.);\n\tvec3 raydir = normalize(vec3(uv.x, uv.y, 1.));\n\t\n\tvec3 p = eye;\n\tint hit = -1;\n\t\n\tfor (int i = 0; i < 50; i++) {\n\t\tfloat d = map(p);\n\t\tif (d < 0.001) {\n\t\t\thit = i;\n\t\t\tbreak;\n\t\t}\n\t\tp += d * raydir;\n\t}\n\n\tfloat light =  lightAt(p);\n\tfloat texture = voronoi(p.xy*2.) * lightAt(p)/2.5;\n\ttexture += voronoi(p.xy/10.+11.)*0.5;\n\ttexture /= voronoi(p.xy/50.+20.)*2.0;\n\tvec3 color = mix(vec3(0.0,0.0,0.0), vec3(0.3,0.4,0.5), uv.y);\n\tif (hit > -1) {\n\t     color = mix(vec3(.0,.0,.2), vec3(.4,.9,1.), texture) * (1. - float(hit)/100.) * lightAt(p);\n\t} \n\t\n\t\n\tfragColor = vec4(color, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 39, 39, 89], [91, 91, 110, 110, 139], [141, 141, 167, 167, 187], [189, 189, 215, 215, 455], [457, 457, 480, 480, 851], [853, 853, 872, 872, 926], [928, 928, 949, 949, 1091], [1137, 1137, 1160, 1160, 1197], [1199, 1199, 1256, 1256, 1968]], "test": "timeout"}
{"id": "WtS3RD", "name": "Circles intersection", "author": "ivanguinea", "description": "Circle Colors", "tags": ["color"], "likes": 2, "viewed": 118, "published": "Public", "date": "1558612910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float shape(vec2 st, float radius) {\n\tst = vec2(0.5)-st;\n    float r = length(st)*2.0;\n    float a = atan(st.y,st.x);\n    float m = abs(mod(a+iTime*2.,3.14*2.)-3.14)/3.6;\n    float f = radius;\n    f += (sin(a*10.)*.1*pow(m,2.));\n    return 1.-step(f,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 yellow = vec3(1.0,1.0,.0);\n  \tvec3 red = vec3(1.0,0.0,.0);\n  \tvec3 blue = vec3(0.0,0.0,1.0);\n  \tvec3 pink = vec3(1.0,0.0,1.0);\n    \n\tvec2 st = fragCoord.xy/iResolution.y;\n\tvec3 color = vec3(shape(st,0.8)) * blue;\n    color += vec3(shape(st - vec2(0.2),0.8)) * yellow;\n    color += vec3(shape(st - vec2(0.1, 0.0),0.8)) * pink;\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtS3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 255], [257, 257, 314, 314, 685]], "test": "ok"}
{"id": "WtS3Rm", "name": "Wavy Hills", "author": "samwarren", "description": "Mouse click to look left and right. :)", "tags": ["noise", "raymarch", "sky", "rayleigh"], "likes": 7, "viewed": 162, "published": "Public", "date": "1558831961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Rayleigh Mie Skydome approximation based off Scratchapixel article and Nvidia GPU Gems.\n//Use mouse click to look left and right.\n\n#define PI 3.141592\n\n//-------------------------------------SKYDOME STUFF---------------------------------------------\n\n//Atmosphere parameters:\n//Constants that multiply the phase functions.\n#define rpv  0.0596831\n#define mpv  0.1193662\n//Mie phase function g constant.\n#define g 0.76\n//Earth radius and centre.\n#define earthRad 6320e3\n#define earthCen vec3(0,0,0)\n//Radius of atmosphere limit (space).\n#define atmosRad 6420e3\n//Sun intensity (biased slightly towards red wavelength).\n#define sunPow vec3(10,10, 10)\n//Scale height values for both scatter types.\n#define Hr 8e3\n#define Hm 12e2\n//Beta values at sea level (peak rgb intensities).\n#define Bs0Rayleigh vec3(58e-7, 135e-7, 250e-7)\n#define Bs0Mie vec3(210e-6)\n//Samples for numerical integration.\n#define samples 15\n#define sunSamples 6\n\n//Fractal noise paramters.\n#define FRACTAL_NOISE\n#define octaves 4\n#define WAVEY\n//Raymarch parameters.\n#define ep .02\n#define smallEp .0001\n#define maxIterations 120\n\n//Camera FOV constants.\n#define fov 1.05\n#define asp vec2(1.0, .5625)\n#define tanTheta tan(fov)\n#define tanTheta2 2.0*tanTheta\n#define tanThetaAspY asp.y*tanTheta\n#define tanTheta2AspY 2.0*tanThetaAspY\n\n//Camera parameters.\n#define skyCamO vec3(0, earthRad+1.0,0)\n#define camO vec3(0)\n#define fExposure 2.5\nconst float theta = 0.0;\nfloat phi = 0.0;\n\nvec3 sunDir = vec3(0,1,0);\n\nstruct Ray { vec3 o, d; };\n\nRay PinholeCamera(vec2 uv, in vec3 origin) {\n    float cosTheta = cos(theta);\n\tvec3 zH = vec3(cosTheta*sin(phi), sin(theta), cosTheta*cos(phi));\n    vec3 xH = cross(zH, vec3(0,1,0));\n    vec3 yH = cross(zH, xH);\n    vec3 p = xH*(uv.x*-tanTheta2+tanTheta) + yH*(uv.y*-tanTheta2AspY + tanThetaAspY) + zH;\n    return Ray(origin, normalize(p));\n}\n    \nbool SphereRayIntersect(Ray r, vec3 o, float rad, inout float t) {\n\tvec3 l = o - r.o;\n    float rl = dot(l, r.d);\n    float a2 = dot(l,l) - rl*rl;\n    float rad2 = rad*rad;\n    if(a2 > rad2) { return false; }\n\tt = sqrt(rad2 - a2) + rl;\n    return true;\n}\n\nfloat RayleighPhaseFunction(float cosTheta) {\n    return rpv*(1.0+cosTheta*cosTheta);\n}\n\nfloat MiePhaseFunction(float cosTheta) {\n\treturn mpv*( (1.0-g*g)*(1.0+cosTheta*cosTheta) ) / ( (2.0+g*g)*pow(1.0+g*g-2.0*g*cosTheta, 1.5) );\n}\n\n//Returns unfinished transmittance: the non exponent version for optimisation purposes.\nvoid Transmittance(vec3 Pa, vec3 Pb, inout vec3 tr, inout vec3 tm) {\n    vec3 d = Pb-Pa;\n    float dLen = length(d);\n    float ds = dLen / float(sunSamples);\n    d /= dLen;\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float ms = 0.0;\n    for(int i = 1; i < sunSamples; i++) {\n        vec3 p = Pa + d*(ms + .5 * ds);\n        float h = length(p - earthCen) - earthRad;\n    \topticalDepthR += exp(-h/Hr)*ds;\n        opticalDepthM += exp(-h/Hm)*ds;\n        ms += ds;\n    }\n    tr = Bs0Rayleigh*opticalDepthR;\n    tm = Bs0Mie*opticalDepthM;\n}\n\nvec3 SkyColour(Ray r) {\n    float t;\n    if(SphereRayIntersect(r, earthCen, atmosRad, t)) {\n        vec3 Pa = r.o + r.d*t;\n        float ds = length(Pa-r.o) / float(samples);\n        \n        // T(Pc,X) * T(X, Ps) * Bs(h)ds between Pc and Pa:\n        vec3 integralR = vec3(0);\n        vec3 integralM = vec3(0);\n        float ms = 0.0;\n        for(int j = 1; j < samples; j++) {\n            vec3 X = r.o + r.d*(ms + .5 * ds);\n            \n            float ts;\n            SphereRayIntersect(Ray(X, sunDir), earthCen, atmosRad, ts);\n            vec3 Ps = X + sunDir*ts;\n            float h = length(X-earthCen) - earthRad;\n            \n            vec3 T1r, T1m, T2r, T2m;\n            Transmittance(r.o, X, T1r, T1m);\n            Transmittance(X, Ps, T2r, T2m);\n\n            //Optimisation here due to lots of exponents...\n            //For each integral: += T(Pc, X) * T(X, Os) * Bs(h)\n            //\t\t\t\t\t  = e^(-T1r-T2r -h/H)\n            integralR += exp(-(T1r+T2r) -h/Hr) * ds;\n            integralM += exp(-(T1m+T2m) -h/Hm) * ds;\n            ms += ds;\n        }\n        float mu = dot(r.d, sunDir);\n        integralR *= RayleighPhaseFunction(mu) * Bs0Rayleigh;\n        integralM *= MiePhaseFunction(mu) * Bs0Mie;\n        return sunPow * (integralR + integralM);\n    }\n    return vec3(1,0,1);\n}\n\n//-----------------------------NOISE SURFACE STUFF------------------------------\n\n#define invep 1.0 / ep\n#define invsmallEp 1.0 / smallEp\n\nfloat Hash1(in float n ) { return fract(sin(n)*43758.5453); }\n\nvec2 Hash(in vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\n\nfloat Lerp(in float a, in float b, in float r) { return a + (b-a)*r; }\n\nfloat Quintic(in float x) { return x*x*x*(x*(x*6.0 - 15.0) + 10.0); }\n\nfloat GradDot(in vec2 gd, in vec2 p) { return dot(gd-p, Hash(gd*.00018)*2.0-vec2(1.0)); }\n\nfloat Perlin(in vec2 p) {\n\tfloat ix0 = floor(p.x), ix1 = ix0+1.0;\n    float iy0 = floor(p.y), iy1 = iy0+1.0;\n    float sx = Quintic(p.x - ix0);\n    float v1 = Lerp(GradDot(vec2(ix0,iy0), p), GradDot(vec2(ix1,iy0), p), sx);\n    float v2 = Lerp(GradDot(vec2(ix0,iy1), p), GradDot(vec2(ix1,iy1), p), sx);\n    return Lerp(v1,v2, Quintic(p.y - iy0));\n}\n\nfloat FractalPerlin(in vec2 p) {\n    float o = 0.0;\n    float a  = .5;\n    for(int i = 1; i < octaves; i++) {\n        o += a * Perlin(p);\n        p *= 2.0;\n        a *= .5;\n    }\n    return o;\n}\n\nfloat D(in vec3 p) {\n    #ifdef WAVEY\n    p.xz += iTime*.25;\n    #endif\n    #ifdef FRACTAL_NOISE\n    return p.y - FractalPerlin(p.xz)+1.1;\n\t#else\n\treturn p.y - Perlin(p.xz)+1.1;\t\n    #endif\n}\n\nfloat DirectionalDerivative(in vec3 x, in vec3 l, in float dep) {\n\treturn clamp((D(x+l*dep) - D(x)) / dep, 0.0, 1.0);\n}\n\nbool SphereMarch(in Ray r, out float t, out float dep) {\n    int i = 0;\n    t = 0.0;\n    float d = ep+1.0;\n    dep = ep;\n    while(i < maxIterations && d > dep) {\n    \td = D(r.o+r.d*t);\n        t += d * .5;\n        i++;\n        dep = ep + t*t*3.5e-4;\n    }\n    if(i >= maxIterations) { return false; }\n    return true;\n}\n\nvoid ToneMap(inout vec4 c) {\n\tc.xyz = 1.0 - exp(-fExposure*c.xyz);\n}\n\n#define sr1 normalize(vec3(.5,.01,-1.0))\n#define sr2 normalize(vec3(.5,.01,1.0))\n#define sr4 normalize(vec3(.5,.01,0))\n#define sr5 normalize(vec3(-.5,.01,0))\n#define SURFACE_RAY(dir) Ray(vec3(0,earthRad,0), normalize(dir))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    bool onBase = uv.y < .5;\n    \n    sunDir = normalize(vec3(0,abs(sin(iTime*.1+smallEp)),cos(iTime*.1+smallEp)));\n    phi = (iMouse.x / iResolution.x - .5) * PI;\n    \n    Ray r = PinholeCamera(uv, camO);\n    \n    float t, dep;\n    if(onBase && SphereMarch(r, t, dep)) {\n   \t\tvec3 p = r.o + r.d*t;\n        \n        float check = (fract(p.x)<.5 == fract(p.z)<.5) ? .95 : .1;\n        \n        vec3 s1 = DirectionalDerivative(p, sunDir, dep) * SkyColour(SURFACE_RAY(sunDir));\n        vec3 s2 = DirectionalDerivative(p, sr1, dep) * SkyColour(SURFACE_RAY(sr1));\n        vec3 s3 = DirectionalDerivative(p, sr2, dep) * SkyColour(SURFACE_RAY(sr2));\n        vec3 s5 = DirectionalDerivative(p, sr4, dep) * SkyColour(SURFACE_RAY(sr4));\n        vec3 s6 = DirectionalDerivative(p, sr5, dep) * SkyColour(SURFACE_RAY(sr5));\n        \n        fragColor.xyz = (s1+s2+s3+s5+s6) * check;\n        fragColor.xyz = mix(fragColor.xyz, SkyColour(SURFACE_RAY(r.d)), clamp(t*t*5e-4,0.0,1.0));\n    }\n    else {\n        r.o = skyCamO;\n  \t\tfragColor.xyz = SkyColour(r);\n    }\n    ToneMap(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtS3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1506, 1506, 1550, 1550, 1848], [1854, 1854, 1920, 1920, 2108], [2110, 2110, 2155, 2155, 2197], [2199, 2199, 2239, 2239, 2341], [2343, 2431, 2499, 2499, 2988], [2990, 2990, 3013, 3013, 4286], [4427, 4427, 4453, 4453, 4488], [4490, 4490, 4512, 4512, 4601], [4603, 4603, 4651, 4651, 4673], [4675, 4675, 4702, 4702, 4744], [4746, 4746, 4784, 4784, 4835], [4837, 4837, 4862, 4862, 5184], [5186, 5186, 5218, 5218, 5380], [5382, 5382, 5402, 5402, 5573], [5575, 5575, 5640, 5640, 5694], [5696, 5696, 5752, 5752, 6016], [6018, 6018, 6046, 6046, 6086], [6312, 6312, 6367, 6367, 7482]], "test": "timeout"}
{"id": "wtS3RR", "name": "whodis", "author": "lennyjpg", "description": "a", "tags": ["2d", "color", "gradient"], "likes": 0, "viewed": 276, "published": "Public API", "date": "1558236966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime*0.3+uv.xyx+vec3(0,2,4));\n    vec2 u = uv;\n\n    \n    if(uv.y>0.37){\n        uv.x=fract(uv.x-0.9)*1.0;\n    }\n    \n    if(uv.x<0.12345){\n        col = vec3(0.0,0.0,uv.y+fract(iTime*0.1));\n    }\n    if(uv.x < 0.3){\n        uv.x+=rand(u)*0.15;\n    }\n\n    if(uv.x>0.75){\n        col = vec3(1.0,0.0,uv.y);\n    }\n    if(uv.y>0.123456){\n        col.r += u.y;\n    }\n \n    if(u.x<0.03){\n        col = vec3(1.);\n    }\n\n    if(u.x>0.28){\n        col.g *= rand(uv)*0.1;\n    }\n\n    if(u.y>0.28 && mod(fragColor.y,3.0)<0.5){\n        col.g += 0.5;\n    }\n\n    if(u.y>0.9){\n        col.b *= sin(iTime*.1);\n    }\n    //  u = rotate2d( sin(iTime*0.2)*PI ) * uv;\n\n    if(u.x>0.9){\n        col.rb-= uv.y*0.33;\n    }\n\n    if(u.x>0.99 && u.y < 0.9){\n        col.rgb /= mod(fragCoord.x,2.0); \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtS3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 162, 162, 234], [236, 236, 293, 293, 1175]], "test": "ok"}
{"id": "wtS3Wh", "name": "Embellished Rotation pattern", "author": "Yusef28", "description": "Another Pattern", "tags": ["2d", "basic", "circle", "red", "shapes", "pattern", "gold"], "likes": 7, "viewed": 195, "published": "Public", "date": "1559308317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n#define scale 4.\n\nfloat rnd (vec2 p)\n{\n return fract(sin(dot(p ,vec2(12.9898, 75.233)))*43563.234);   \n}\n\nmat2 rot(float a )\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a) );    \n}\n\nvec2 tilerot (vec2 p)\n    \n{\n    //From the book of shaders https://thebookofshaders.com/10/\n    vec2 ipos = floor(p*scale);   \n     //-0.5 to get -0.5 to 0.5 for rotation\n    vec2 fpos = fract(p*scale)-0.5; \n    float index = rnd(ipos);\n        \n    if(index >= 0.75){ p = fpos*rot(PI/2.);}\n    else if (index >= 0.50){ p = fpos*rot(-PI/2.);}\n    else if (index >= 0.25){ p = fpos*rot(PI);}\n    else p = fpos;//<---need this!\n   \n //+0.5 to reverse the earlier process so you for 0.- 1 again\n return p+0.5;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //resolution correction \n    uv.x*=iResolution.x/iResolution.y;\n    \n   /// uv+=iTime/16.;  //to move the pattern\n    uv = tilerot(uv);\n    \n    //textures\n    vec3 tx0 = vec3(texture(iChannel0, uv));\n    vec3 tx1 = vec3(texture(iChannel1, uv));\n    vec3 tx2 = vec3(texture(iChannel2, uv));\n    \n    //moving light aroud the gold borders\n    vec3 gold = vec3(202., 165., 55.)/255.-abs(sin(uv.x*4.+iTime))/2.;\n    //initial color will be the greyish background\n    vec3 col = vec3(0.)+tx1.x/5.;\n    \n    float circ = length(vec2(uv.x+0.1, uv.y-0.5));\n    \n    //the shape of the red circle\n    float redC = 1.0-step(0.5,circ );\n    \n    //coloring the red circle\n    col = mix(col, vec3(1.0,0.,0.)*tx0.x, redC);\n\t//sq += step(0.5, abs(sin(dot(uv, vec2(0., 0.5))*28.)));\n    \n    //the shape of the gold borders\n    float sq = step(0.98, uv.x)+step(uv.x, 0.02)\n        \t\t+step(0.98, uv.y)+step(uv.y, 0.02);\n    \n    //coloring the gold borders\n    col = mix(col, gold+tx2.x/3., min(sq, 1.));\n    \n    //the gold ring around the red circles\n    float ring =  smoothstep(0.5, 0.5+0.009, circ) -  \n        smoothstep(0.55, 0.55+0.009, circ);\n    \n    //makes the bend in the metal like the straight gold  borders have\n    float ring2 =  smoothstep(0.5, 0.5+0.009, circ) -  \n        smoothstep(0.525, 0.525+0.009, circ);\n    \n    //adding the two rings together with color\n    col = mix(col, gold, ring+ring2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtS3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 72, 72, 138], [140, 140, 160, 160, 214], [216, 216, 244, 308, 728], [730, 730, 787, 837, 2353]], "test": "error"}
{"id": "WtS3zw", "name": "Water Mites", "author": "Radical_Ed", "description": "beta Water Mites", "tags": ["beta", "hackerspace", "rebop"], "likes": 3, "viewed": 133, "published": "Public", "date": "1558781093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a rework of https://www.shadertoy.com/view/3lSGz1, \n// created by sschmidtix, with sound, by Radical Ed\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define PERIOD 2.\n#define REPETITIONS 2\n\nconst float PI = 3.1415926535;\n\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat cross2(in vec2 _st, float _size){\n    return  box(_st, vec2(_size,_size/4.)) +\n            box(_st, vec2(_size/4.,_size));\n}\n\nvec3 shadeBlob(vec2 p, float index, float value, float scale)\n{\n    float screenRatio = iResolution.x / iResolution.y;\n    vec2 pc = vec2(0.1 + (screenRatio - 0.2) * value, index);\n    \n    float d = length(pc - p) / 0.015*scale/0.3;\n    \n    return vec3(3. * vec3(0.2, 0.5, 0.7) / (max(d * d, 1.)));\n}\n\nfloat step_interp(float x) {\n    return step(0.5, x);\n}\n\nfloat linear_interp(float x) {\n    float c = clamp(x, 0., 1.);\n    \n    return c;\n}\n\nfloat cosine_interp(float x) {\n    float c = clamp(x, 0., 1.);\n    \n    return 0.5 * (1. - cos(PI * c));\n}\n\nfloat smoothstep_interp(float x) {\n//    return smoothstep(0., 1., x);\n\n    float c = clamp(x, 0., 1.);\n    \n    return c * c * (3. - 2. * c);\n}\n\nfloat quintic_interp(float x) {\n    float c = clamp(x, 0., 1.);\n    \n    return c * c * c * ((6. * c - 15.) * c + 10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.yy;\n    vec2 q = fragCoord.xy / iResolution.yy;\n    \n    \n    // per lo Spectrum Audio\n    vec4 spec = vec4(0.1,0.1,0.1,0.1);\n    \n    vec2 translate = vec2(cos(iTime),sin(iTime));\n    vec2 translate2 = vec2(sin(iTime),cos(iTime));\n    p += translate*0.35*sin(iTime);\n    q += translate2*1.35*sin(iTime);\n    \n    float t = abs(2. * fract(iTime / PERIOD) - 1.);\n    //int sel = int(6. * fract(time / (float(REPETITIONS) * PERIOD) / 6.));\n    int sel = 5;\n    \n    // Background pattern\n    \n    vec3 col = vec3(0.0 + 0.000 * mod(floor(p.x * 10.0) + floor(p.y * 10.0), 2.0));\n    vec3 col2 = vec3(0.0 + 0.000 * mod(floor(q.y * 5.0) + floor(q.x * 5.0), 2.0));\n    //vec3 col = vec3(0.0,0.0,0.0,0.0));\n    \n    \n    col += shadeBlob(p, 0.1, smoothstep_interp(t)*spec.x+0.5, 0.1/0.1);\n    col2 += shadeBlob(q, 0.3+spec.z, linear_interp(t)*spec.y+0.5, 0.1);\n    col += shadeBlob(p, 0.5+spec.x, cosine_interp(t)*spec.z+0.7, 0.1/0.3);\n    col2 += shadeBlob(q, 0.7, smoothstep_interp(t)*spec.z+0.1, 0.1/0.6);\n    col += shadeBlob(p, 0.9-spec.y, quintic_interp(t)*spec.z+0.3, 0.1/0.9);\n    \n    \n    col = pow(col, vec3(0.45));\n    col2 = pow(col2, vec3(0.45));\n    \n    fragColor = vec4(col+col2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtS3zw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[278, 278, 316, 316, 583], [585, 585, 624, 624, 715], [717, 717, 780, 780, 1019], [1021, 1021, 1049, 1049, 1076], [1078, 1078, 1108, 1108, 1161], [1163, 1163, 1193, 1193, 1269], [1271, 1271, 1305, 1341, 1415], [1417, 1417, 1448, 1448, 1538], [1540, 1540, 1597, 1597, 2834]], "test": "ok"}
{"id": "wtS3zz", "name": "Rössler Attractor", "author": "tpfto", "description": "Plot the [url=https://en.wikipedia.org/wiki/R%C3%B6ssler_attractor]Rössler attractor[/url] by integrating the defining differential equations.", "tags": ["3d", "math", "differential", "ode"], "likes": 6, "viewed": 423, "published": "Public API", "date": "1558399990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Plotting the Rössler attractor (https://en.wikipedia.org/wiki/R%C3%B6ssler_attractor) by integrating the ODEs\n\n// colors\n\n#define BG vec3(0.18, 0.28, 0.23)\n#define COL vec3(0.86, 0.15, 0.27)\n\n// maximum number of steps\n\n#define MAXSTEPS 990\n\n// ODE for Rössler attractor\n\nvec3 rhs( float t, vec3 p )\n{\n    float x = p.x, y = p.y, z = p.z;\n    const float a = 0.25, b = 0.2, c = 4.6; // parameters\n    \n    return vec3(-y - z, b + y * (x - c), x + a * z);\n}\n\n// line segment distance\n\nfloat segment(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n\treturn length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));\n}\n\n// rotation matrix\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n    \n// 3D -> 2D projection\n\nvec2 proj( in float p, in float c, in vec3 P )\n{\n    float q = -p * sqrt(1.0 - c * c);\n\n    return mat3x2(-p, q, 0.0, c, p, q) * P;\n}\n\n// 3D curve drawing, adapted from https://www.shadertoy.com/view/4lyyWw by Fabrice Neyret\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ep = 40.0/iResolution.y;\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv = 35.0 * uv + vec2(0.0, 5.5); // shift and scale to fit in window\n    \n    vec3 P = vec3(0.0, 0.0, 1.0); // initial conditions\n    float t = 0.0, tmax = 60.0; // integration interval\n    \n    vec3 Pn, Pt, P1;\n    vec2 pb, p;\n    float d = 1.0e3, dt;\n    \n    float h = tmax/float(MAXSTEPS); // step size\n    \n    for (int i = 0; i <= MAXSTEPS; i++)\n    {\n        if (i > 0) // explicit midpoint method, https://en.wikipedia.org/wiki/Midpoint_method\n        {\n            P1 = P + 0.5 * h * rhs(t, P);\n            P += h * rhs(t + 0.5 * h, P1);\n            t += h;\n        }\n \n        Pt = P;\n        Pt.xz *= rot(2.2 * iTime); // rotation\n        p = proj(sqrt(0.5), 0.8, Pt); // screen projection\n\n        if (i > 0)\n        {\n            dt = segment(uv, pb, p) * (( 35.0 - Pt.z )/45.0); // draw segment with thickening factor\n            if (dt < d) { d = dt; Pn = Pt; } // keep nearest\n        }\n        \n        pb = p;\n    }\n    \n    float da = 0.5 + 0.5 * mix(0.8, 1.0, Pn.y); // darker at the bottom\n    fragColor = vec4(mix(BG, mix(vec3(0.0), COL, da), smoothstep(ep, 0.0, d)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtS3zz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1348, 1348, 1377, 1377, 1532], [1560, 1560, 1598, 1598, 1685], [1789, 1789, 1837, 1837, 1922], [2015, 2015, 2072, 2072, 3322]], "test": "ok"}
{"id": "wtsGDB", "name": "pattern20190510", "author": "edapx", "description": "pattern", "tags": ["2d", "patterns"], "likes": 2, "viewed": 66, "published": "Public", "date": "1557561504", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n    \nvec2 squareFrame(vec2 res, vec2 coord){\n    vec2 uv = 2.0 * coord.xy / res.xy - 1.0;\n    uv.x *= res.x / res.y;\n    return uv;\n}\n\nfloat plot(vec2 st, float pct, float th){\n  return  smoothstep( pct-th, pct, st.y) -\n          smoothstep( pct, pct+th, st.y);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n    _st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n    _st = fract(_st);\n\n    if(index == 1.0){\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        _st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\n// inigo gain function\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lime = vec3(0.733, 1.0, 0.31);\n  \tvec3 red = vec3(1.0, 0.353, 0.208);\n    vec3 blu = vec3(0.086, 0.29, 0.8);\n\n    vec2 st = squareFrame(iResolution.xy,fragCoord);\n\t\n    //net\n    vec2 uv = st;\n    uv *= 2.0;\n    uv = fract(uv);\n    uv = rotateTilePattern(uv);\n    float y = gain(uv.x, 0.49 + tan(iTime*0.10)* 0.1);\n    float net = plot(uv, y, 0.07);\n    \n    //segments\n    vec2 uv2 = rotateTilePattern(st) *2.0;\n    uv2 = fract(uv2);\n    uv2 += vec2(sin(iTime), cos(iTime)) * 0.05;\n    float segments = plot(uv2, y, 0.09);\n    \n    //texture\n    vec3 texc = texture(iChannel0, st).xyz;\n\n    //compose\n    float l = net + segments;\n    vec3 bgColor = blu * (1.0 - l);\n    bgColor += red * net;\n    bgColor += texc * segments;\n\n    bgColor = pow(bgColor, vec3(1.1545)); // gamma corr\n\n    // Output to screen\n    fragColor = vec4(bgColor,1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 65, 65, 205], [211, 211, 250, 250, 339], [341, 341, 382, 382, 469], [471, 471, 504, 504, 858], [860, 883, 914, 914, 993], [996, 996, 1053, 1053, 1907]], "test": "error"}
{"id": "WtSGDz", "name": "sakuraa", "author": "asis5528", "description": "leaves...", "tags": ["leaves"], "likes": 10, "viewed": 387, "published": "Public", "date": "1559033113", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define asp iResolution.x/iResolution.y\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat circle1(vec2 uv,float radius,float blur){\n\tfloat d = length(uv);\n    float c = clamp(max(sqrt(radius*radius-uv.x*uv.x-uv.y*uv.y)/radius,0.000001),0.0,1.);\n    //c = smoothstep(radius,radius-blur,d);\n    return c;\n}\nfloat circle(vec2 uv,float radius,float blur){\n\tfloat d = length(uv);\n    return smoothstep(radius,radius-blur,d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 l = uv;\n    //float pitch = texture(iChannel0,uv).r/5.;\n    vec2 st = uv;\n\t\n    uv-=vec2(0.5,1.1);\n    uv.x*=asp;\n    float d = length(uv);\n    float radius = 0.6;\n    float blur = 0.49;\n    float c = smoothstep(radius+sin(iTime)*.1,radius-blur+sin(iTime)*.05,d);\n    float dd = smoothstep(radius-0.3,radius-0.3-0.04,d);\n    // Time varying pixel color\n   \n\tfloat n = c-dd;\n    // Output to screen\n    fragColor +=clamp(n,0.,1.)*1.2*vec4(0.2,0.5,0.9,1.);\n    fragColor += dd*vec4(0.2,0.5,(1.-dd),1.);\n    fragColor+=dd;\n    fragColor +=vec4( st.y)*vec4(0.2,0.5,0.9,1.)*0.6*(1.-fragColor.b);\n     \n    st.y+= sin(st.x*6.+iTime*3.)*0.1;\n        \n    float col = smoothstep(0.2,0.15,st.y);\n    float factor = fract(l.x)/6.5;\n    float co = smoothstep(0.25+factor,0.15+factor,st.y);\n  \tst.y-=0.1;\n    //fragColor += vec4((co-col)*fract((1.-st.y)*3.))*vec4(0.1,0.7,0.9,1.);\n     \n    \n    uv = fragCoord/iResolution.xy;\n\tuv-=vec2(0.5,1.1);\n    //uv.x*=asp;\n  \n   \n         d = length(uv);\n    \t c = smoothstep(0.3,0.27,d);\n\n \n    float s = 0.0035;\n    vec3 coll = vec3(0.0);\n    float t = iTime/4.;\n    float vl = 0.0;\n    for(float f = 0.0;f<1.0;f+=s){\n    \tvec2 st = uv;\n       \n       st.x+=fract((sin(f*1245.))*114.)-0.5;\n    st.y+=fract(t*sin(f+0.1)+f*2.)*1.2;\n        //st.y*=0.4;\n        \n      \tst*=mix(f,0.9,2.);\n       \n        //st.x+=sin(st.y+iTime+f)*f/2.;\n        //st.y += (fract(t*.2+f*7.64)-.5)*15.;\n        st.x*=asp; \n        float si = sign(sin(f*175.));\n        st = rotate2d(si*iTime+sin(f*175.)*1854.)*st; \n        st.y*=1.82;\n        //float angle = atan(st.x,st.y);\n        //float r = 0.05-cos(angle*7.)/50.;\n        float r = 0.05;\n        st.y-=abs(st.x/3.+sin(iTime+fract(f))*0.01);\n       vl =max( circle(st,r,0.027)+(circle(st,0.12,0.127)*0.4),vl);\n      \n        coll=vl*vec3(1.0,0.5,0.7);\n    }\n    fragColor=max(vec4(coll,1.),fragColor);\n\n    \n    /*\n        st -=vec2(0.5,0.5);\n    st.x*=asp;\n        fragColor += vec4(circle(st,0.1,0.09))*vec4(0.6,0.5,0.9,1.)*1.5;\n    st.x/=asp;\n    st-=vec2(0.2,-0.3);\n    st.y+=abs(sin(st.x*12.+1.5)*0.1);\n    st.x*=asp;\n    fragColor += vec4(circle(st,0.2,0.19))*vec4(0.0,0.2,0.9,1.)*0.8;\n*/\n}", "image_inputs": [{"id": "XtX3Rj", "previewfilepath": "https://soundcloud.com/joe-hisaishi/spirited-away-reprise-by-joe-hisaishi", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/joe-hisaishi/spirited-away-reprise-by-joe-hisaishi", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 68, 68, 154], [155, 155, 202, 202, 375], [376, 376, 422, 422, 492], [495, 495, 552, 602, 2813]], "test": "ok"}
{"id": "wtsGR2", "name": "大龙猫 -:x!", "author": "totetmatt", "description": "Following the really good Revision Seminar Shader from @flopine and @evvvvil and tweaking it .\nhttps://www.twitch.tv/videos/414382208\n\nFinally understand the base of Ray Marching, still exploring and unknowledgeable on lightning , shading and color", "tags": ["notag"], "likes": 13, "viewed": 434, "published": "Public API", "date": "1556982894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// \n/***********************\nDefinition of the objects we want to use\n***********************/\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    // Slice shift effect (only applied on instance of capsule)\n    p.x += clamp(sign(cos(iTime*10.+p.y*10.))/5.,0.,0.1)*.7  ;\n    \n    // Capsule formula\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sphere(vec3 p, float radius)\n{\n    p += vec3(sin(iTime),cos(iTime),cos(iTime))/10.; // Sphere will move\n    return length(p)- radius;\n}\n\nfloat box(vec3 p,vec3 c){\n   \n\tvec3 q = abs(p) - c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\n/***********************\nThe Map / Signed distance function.\nWhere you weld all your objects on the scene\n\nBasically, we are only interested to know how far we are from any points in the overall objects in the scene.\nThe function take the current position of the ray and return a float representing the distance of \nthis point compare to the overall structure\n***********************/\nfloat SDF(vec3 p){\n\n///// Pre effects that will affect all the objects\n \n     // Here the camera travelling\n     // Cicle on X and Y, Going Forward on Z (and some visual effect)         \n     p += vec3(p.z*sin(-iTime)/4.,cos(iTime)/4., sin(p.y+iTime)+iTime*4.);\n     //         ^ Yaw\n     //             ^ Translation X\n     //                               ^ Translation Y\n     //                      ^-------------^ \n     //                             |\n     //                            Circular movement on XY\n     //                                              ^ Wave effect on Z\n     //                                                            ^ Going Foward\n \n     // Repetition\n     // If you remove it, only display an element (but remove also the iTime on Z to avoid going forward)\n     p = mod(p,3.) -3.*.5;\n     \n\n///// Object definition\n    \n    // The capsule\n    // Sort of long enough to loop via the repetiton\n    float q = sdVerticalCapsule(p+vec3(.0,4.,.0),8.,.2);\n    \n    // A sphere and a Box Mixed\n    // The 2.5 value makes \"Knucklebones\" \n    // The mix + sphere motion gives some \"organic\" feeling\n    float m = 0.5*mix(sphere(p ,.55),box(p,vec3(0.5)),2.5);\n    \n \n    return min(q,m);\n\n}\n\n// Compute the normal vector at a position p on the surface of our objects\nvec3 get_normal(vec3 p){\n\n  // swizzling technics.\n  // eps.xyy <=> vec3(0.001, 0.   , 0.)\n  // eps.yxy <=> vec3(0.   , 0.001, 0.)\n  // eps.yyx <=> vec3(0.   , 0.   , 0.001)\n  vec2 eps = vec2(0.001,0.);\n    return normalize(\n             vec3(\n                  SDF(p+eps.xyy) - SDF(p-eps.xyy), // Diff in X\n                  SDF(p+eps.yxy) - SDF(p-eps.yxy), // Diff in Y\n                  SDF(p+eps.yyx) - SDF(p-eps.yyx)  // Diff in Z\n             )\n            );  // Math Vector\n}\n\n// Lighting part, still confusing\nfloat diffuse_directional(vec3 n,vec3 l,float d){\n                                      //      ^ Not conventional but I needed it to change the lighing compare to the distance\n    float a =  max(0.,dot(n,normalize(l))); // realistic lighting\n    float b =  dot(n,normalize(l))*.5+.5;   // less realistic lighting\n    return (a+b)/2.+0.1*abs(tan(d+iTime));  ; // Why not both ?\n// Experimental ^ Average \n//                      ^ Wanted a sort of wave of light based on Z , \n//                        but the wavy things on Z changes the effect (still cool)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    /* Camera Filter Effect */\n    // Slice shift effect again but on X and Y to generate unaligned square\n    uv.y += sign(sin(uv.x*50.))/100.* sin(uv.x*uv.x +uv.y*uv.y) ;//*sin(iTime*2.);\n    uv.x += sign(cos(uv.y*50.))/100. * sin(uv.x*uv.x +uv.y*uv.y);//*cos(iTime*2.);\n   \n  \n    // Ray origin / Ray direction\n    vec3 ro = vec3(0.,0.,-5.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,0.6));\n                             // ^ FOV / Zoom ?\n    vec3 color = vec3(0.);\n    \n    bool hit = false;\n    float shading = 0.; // Not used on seminar ?\n\n    for(float i = -0.;i<200.;i++) { // March little ray, even if it's May\n       float d = SDF(p);  // How far from my overall object\n        if(d < 0.0001) {   // did it hit ?\n        \thit = true;\n            shading = i/100.;\n            break;\n       \n        }\n        p += d * rd;    // Ray is one step further\n    }\n    float t = length(ro-p);           \n    if(hit) { // If it hits, need to color & light\n         vec3 n = get_normal(p); \n         vec3 l = vec3(0.001,-1.5,-5.); // light origin \n          \n         color =  vec3(diffuse_directional(n,l,t)); // light diffuse\n         color = mix(vec3(0.1,0.2,0.3), vec3(0.999,0.6,0.45), color)*(1.-shading); \n        \n    } else { // If not, it's darkness\n        color = vec3(0.0);\n    }\n    \n    // Creating some Fog\n    color = mix(color,vec3(0.1,0.1,0.2),1.-exp(-0.0051*t*t)); \n    //                                             ^ Distance of fog \n\n    // \"Vignetting\" of the camera\n    if(true){ // Original idea to create a Vignetting\n    \tcolor *= 1.-pow(length(uv)+0.05,2.);\n    } else { // another intersting effect\n    \tcolor *= 1.-pow(length(uv),0.1);\n   \t\tcolor = smoothstep(0.001,0.07,color);\n    }\n    // Output to screen\n    fragColor = vec4(color*1.4,1.0);\n}\n                    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 166, 219, 283, 437], [439, 439, 475, 475, 580], [582, 582, 607, 607, 697], [699, 1084, 1102, 1270, 2304], [2306, 2381, 2405, 2554, 2864], [2866, 2900, 2949, 3076, 3460], [3462, 3462, 3519, 3569, 5414]], "test": "ok"}
{"id": "wtSGRR", "name": "Beneath The Surface", "author": "Yusef28", "description": "A cool pattern. ", "tags": ["red", "stripes", "pattern", "gold"], "likes": 6, "viewed": 250, "published": "Public", "date": "1558562794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 3.\n#define tileNum 1.\n#define PI 3.14159265358979323846\n\n\nfloat stripes(vec2 p, float s)\n{\n    p = fract(p*s);\n    return floor(p.y*s)/s;\n}\n\nfloat border(vec2 p, float th, float s)\n{\n p = fract(p*s*3.+0.0); //I figured out that I can creaate the border lines by scaling the fract, but I'm\n    //still confused about the other way with steps where they need to be.\n float str = smoothstep(0.02,0.03, 1.0-p.y)*smoothstep(0.02,0.03, p.y);\n   // str = step(p.y, 0.2);\n \n return str;\n    \n}\n\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \t vec2 st2 = uv; //forvignette\n    uv.x=fract(uv.x*tileNum);\n    uv.y*=tileNum;\n    uv.x -=0.50001;//for rotations!\n    //uv=uv*2.0-1.0;\n    \n    vec2 st = uv;//to reuse the original uv when rotating teh second half\n   \n    uv = rot(-PI/3.*step(uv.x, 0.0))*uv;\n    uv = rot(PI/3.*step(0.0, st.x))*uv;\n    \n    vec3 col1 = vec3(1.0, 0.0, 0.0)*texture(iChannel0, uv).x;\n    col1 = vec3(0.8, .1, .1)*texture(iChannel0, uv*1.).x/1.;\n    vec3 col2 = vec3(texture(iChannel1, uv*2.))/6.;\n    //col2 = vec3(0., 1.0, 0.);\n    st.y-=(iTime/2.+sin(iTime/1.)/2.);\n    vec3 col3 = vec3(texture(iChannel2, st));//vec3(0., 0., 1.0);\n    \n    //col2 = vec3(0.0);   //for a jet black second row\n    \n    vec3 gold = vec3(159., 138., 66.)/255.;\n    float met = texture(iChannel3, uv/100.).x;\n    \n    vec3 col = vec3(0.0);\n    \n    //vec3(stripes(uv, 3.));\n    col = mix(col, col1, step(stripes(uv, scale), 0.33) );\n    col = mix(col, col2, step(0.33, stripes(uv, scale))*step(stripes(uv, scale), 0.66) ); \n    col = mix(col, col3, step(0.66, stripes(uv, scale)) );\n    col = mix(col, gold*(1.0+sin(st.x*8.+iTime))/1., (1.0-border(uv, 0.9, scale))*2. );\n    \n\n    st2 *=  1.0 - st2.yx;\n    float vig = st2.x*st2.y*15.;\n    vig = pow(vig, 0.15);\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "lllGzS", "previewfilepath": "https://soundcloud.com/yusef-curtis-clarke/examining-the-shadows", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/yusef-curtis-clarke/examining-the-shadows", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 104, 104, 153], [155, 155, 196, 196, 499], [501, 501, 520, 520, 572], [575, 575, 632, 682, 2012]], "test": "error"}
{"id": "wtsGRs", "name": "3d Fractal", "author": "WillKillU", "description": "little practice raymarching practice on 3d fractal visualization using raymarching", "tags": ["3d", "fractal", "visualization", "psychoraymarching"], "likes": 2, "viewed": 496, "published": "Public", "date": "1557369358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat Power = 1.0;\n\nfloat rotationSpeed = 0.03;\n\nvec2 rotate(vec2 a, float b)\n{\n\tfloat c = cos(b);\n\tfloat s = sin(b);\n\treturn vec2(\n\t\ta.x * c - a.y * s,\n\t\ta.x * s + a.y * c\n\t\t);\n}\n\nfloat DE(vec3 pos) \n{\n    vec3 \tz \t= pos;\n    float \tdr \t= 1.0;\n    float \tr \t= 0.0;\n    \n    for (int i = 0; i < 15 ; i++) \n    {\n        r = length(z);\n        if (r>2.0) break;\n        \n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi \t= atan(z.y,z.x);\n        dr \t\t\t=  pow( r, Power - 1.)*Power*dr + 1.0;\n        \n        // scale and rotate the point\n        float zr \t= pow( r,Power);\n        theta \t\t= theta*Power;\n        phi \t\t= phi*Power;\n        \n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n//SDF\nfloat map(vec3 p)\n{\n    return DE(p);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(vec3(map(p + eps.xyy) - map(p-eps.xyy),\n                  map(p + eps.yxy) - map(p-eps.yxy),\n                  map(p + eps.yyx) - map(p-eps.yyx)\n                 )\n            );\n}\n\nfloat light(vec3 n, vec3 l)\n{\n    //return dot(n,normalize(l))*.5+.5;\n    return max(dot(n,normalize(l)),0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Power += mod(iTime*0.1 ,20.0);\n\n    vec2 position = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    position -= 0.5;\n    position /= vec2(iResolution.y/iResolution.x,1.);\n    \n    vec3 ro = vec3(0., 0., -4.);\n    vec3 p = ro;\n    vec3 rd = normalize(vec3(position, 1.5));\n\t\n\tro.xz = rotate(ro.xz, iTime * rotationSpeed);\n\tp.xz = rotate(p.xz, iTime * rotationSpeed);\n\trd.xz = rotate(rd.xz, iTime * rotationSpeed);\n    \n    bool hit = false;\n\n    \n\tvec3 fogColor = vec3(1.0,.1, 1.0);\n\t\n    for(float i = 0.0; i < 100.0; ++i)\n    {\n        float df = map(p);\n        \n        if(df < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += df * rd * 0.95;\n    }\n    float t = length(ro - p);\n    \n    vec3 finalColor = !hit ? vec3(0.1) : normal(p);\n    \n    if(hit)\n    {\n        vec3 n = normal(p);\n\t    \n\tfloat fresnel = pow(1.-dot(n, -rd), 0.5);\n\t    \n        vec3 l = vec3(1.0, 0.0, -0.1);\n\t    l.xz = rotate(l.xz, iTime * rotationSpeed);\n        \n        finalColor = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, 0.5), vec3(light(n,l)));\n\tfinalColor = mix(finalColor, vec3(0.,0.5,0.1),fresnel);\n    }\n    else\n    {\n\tfinalColor = vec3(.0,0.1,0.2);\n     \tfogColor = vec3(0.2);\n    }\n    \n    finalColor = mix(finalColor, fogColor, 1.-exp(-0.01*t*t));\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 81, 81, 181], [183, 183, 204, 204, 860], [862, 868, 887, 887, 907], [909, 909, 930, 930, 1163], [1165, 1165, 1194, 1234, 1276], [1278, 1278, 1335, 1335, 2679]], "test": "ok"}
{"id": "wtsGRX", "name": "Webcam Fun With Colors!", "author": "chaz303", "description": "Some colors, some inversion, lots of fun.", "tags": ["webcam"], "likes": 1, "viewed": 197, "published": "Public", "date": "1557163642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Chaz Wilson\n\nfloat restrict0to1 (float sig) {\n    return max(-1.0, min(1.0, sig));\n}\n\n\nfloat rgba_blend (float src, float alpha){\n\talpha = restrict0to1(alpha);\n    float blend = -src+1.0;\n    return (blend * alpha) + (src * (-alpha + 1.0));\n}\n\nvec4 filterMod(float[3] compAlphas, vec4 video1){ \n\tvec4 pixel;\n    for (int i = 0; i < 4; i++) {\n        pixel[i] = rgba_blend(video1[i], compAlphas[i]);\n    }\n\treturn pixel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvStore = uv;\n    vec4 video1 = texture(iChannel0,uv);\n    vec4 pixel;\n        float alpha = 1.0;\n        float rAlpha = (sin(uv.x*uv.y+iTime*0.9)*0.5+0.5);\n        float gAlpha = (sin(uv.x*uv.y+iTime*0.75)*0.5+0.5);\n        float bAlpha = (sin(uv.x*uv.y+iTime*1.5)*0.7+0.5);\n        float[3] compAlphas = float[3](rAlpha, gAlpha, bAlpha);\n    \tpixel = filterMod(compAlphas, video1);\n\tfragColor = pixel;\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 59, 59, 98], [101, 101, 143, 143, 256]], "test": "error"}
{"id": "WtsGWj", "name": "depth z fake axis..", "author": "asis5528", "description": "just playing", "tags": ["equations"], "likes": 1, "viewed": 114, "published": "Public", "date": "1557733764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.x/iResolution.y;\n    \n\tuv-=0.5;\n    uv.x*=asp;\n    //uv.y+=0.2;\n    //uv.y-=sqrt(abs(uv.x))*(sin(iTime/2.)/2.+0.5);\n    /// Time varying pixel color\n    uv.x+=sin(iTime)*0.5;\n    float z = sqrt(sqrt(0.2*0.2*0.2*0.2-uv.x*uv.x*uv.x*uv.x-uv.y*uv.y*uv.y*uv.y))/0.2;\n    //uv.y+=sin(iTime)*0.5+0.5;\n    uv.x-=sin(iTime)*0.5;\n    float c = (sqrt(pow(0.3*0.3,sin(iTime)/2.+1.)-pow(uv.x*uv.x,sin(iTime)/2.+1.)-pow(uv.y*uv.y,sin(iTime)/2.+1.)))/(0.3-sin(iTime)*0.1);\n   uv*=2.5;\n    uv.x/=asp;\n    float x =-uv.y;\n    float y =uv.x;\n    \n    x+=(sin(iTime)*0.5);\n    y+=(cos(iTime)*0.5);\n    \n    x*=2.;y*=2.;\n     y*=asp;\n    vec2 dis = vec2(0.4,0.4);\n    dis+=sin(iTime)/2.+0.1;\n    \n     float b =((1.-sign(-x-.9+abs(y*2.)))/3.*(sign(.9-x)+1.)/3.)*(sign(x+.65)+1.)/2. - ((1.-sign(-x-.39+abs(y*2.)))/3.*(sign(.9-x)+1.)/3.) + ((1.-sign(-x-.39+abs(y*2.)))/3.*(sign(.6-x)+1.)/3.)*(sign(x-.35)+1.)/2.;\n\tz = max(b,z);\n    z=max(c,z);\n    // Output to screen\n    fragColor += z;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1143]], "test": "ok"}
{"id": "WtSGz1", "name": " fibonacci spiral", "author": "mosaic", "description": "If you wait long enough, it completely unspirals, then begins to spiral in the opposite direction :)\n\n\nThis was made by Derzo :   https://www.shadertoy.com/view/ttjGzR  , I just animated it. \n\n", "tags": ["2d"], "likes": 3, "viewed": 249, "published": "Public", "date": "1558392377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fibonacci(in vec2 uv)\n{\n    float s = 0.0;\n    \n    for (int n = 0; n < 2000; n++)\n    {\n        float numb = float(n);\n        \n        float angle = numb * radians(137.51+iTime/50.);\n        float r = 0.02 * sqrt(numb*1.);\n        vec2 circlePos = r * vec2(cos(angle), sin(angle));\n        \n        s += (1.0 - r) * smoothstep(-1.5/iResolution.y, 0.0, 0.01 - length(circlePos - uv));\n    }\n\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord  - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3( fibonacci(uv) );\n\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 414], [416, 416, 473, 473, 619]], "test": "ok"}
{"id": "wtsGz2", "name": "BB9", "author": "Aljen", "description": "Edited version of BB8", "tags": ["code", "starwars", "bb8"], "likes": 1, "viewed": 78, "published": "Public", "date": "1556995385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A modificated version of https://www.shadertoy.com/view/ltSXDR\n\nmat2 rot (float a) {\n \treturn mat2(cos(a), sin(a), -sin(a), cos(a));   \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sphere (vec3 p, float r) {\n \treturn length(p) - r;   \n}\n\nvec2 add(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 scene (vec3 p) {\n  \n    float plane = p.y + 1.0;\n    float body = sphere(p, 1.0);\n    \n    vec3 hp = (p);\n    hp.xy = rot(-0.3 + sin(iTime*2.0)*0.2) * hp.xy;\n    hp = hp-vec3(-0.25*0.0, 0.95, 0.0);\n    float head = sphere(hp, 0.5);\n    \n    head = min(head, sdCapsule(hp+vec3(-0.1,0.0,0.0), vec3(0.0, 0.7, 0.0), vec3(0.0), 0.025));\n    head = min(head, sdCapsule(hp+vec3(-0.1,0.0,0.1), vec3(0.0, 0.9, 0.0), vec3(0.0), 0.0125));\n    \n    float eye = sphere(hp-vec3(-0.375, 0.265, 0.0), 0.1125);\n    eye = min(eye, sphere(hp-vec3(-0.375, 0.2, -0.2), 0.06));\n   \t\n    \n    \n    if (plane < body) {\n     \tif (plane < head) return vec2(plane, 1.0);\n        if (head < eye)\n        \treturn vec2(head, 3.0);\n        else return vec2(4.0);\n    } else {\n     \tif (body < head) return vec2(body, 2.0);\n        if (head < eye)\n        \treturn vec2(head, 3.0);\n        else return vec2(eye, 4.0);\n    }\n}\n\nvec3 normal (vec3 p) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n    \tscene(p+eps.xyy).x - scene(p-eps.xyy).x,\n        scene(p+eps.yxy).x - scene(p-eps.yxy).x,\n        scene(p+eps.yyx).x - scene(p-eps.yyx).x\n    ));\n}\n\nvec4 raymarch (vec3 ro, vec3 rd) {\n    float h = 0.0;\n    for (int i = 0; i < 175; ++i) {\n        vec3 p = ro+h*rd;\n        vec2 test = scene(p);\n        h += test.x;\n        if (h < 0.01) break;\n        if (h > 64.0) break;\n        if (test.x < 0.001)\n            return vec4(p, test.y);\n    }\n    return vec4(-1.0);\n}\n\nfloat shadow (vec3 ro, vec3 rd) {\n \tfloat smax = 1.0;\n    float smin = 100.0;\n    float h = 0.0;\n    float shadow = 1.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = ro+h*rd;\n        float test = scene(p).x;\n        h += test;\n        if (test < 0.0001)\n            return 0.0;\n        else\n            shadow = min(2.5*test/h, shadow);\n    }\n    \n    return shadow;\n    \n}\n\nfloat ppp (float x) {\n \tif (abs(x) > 0.85) return 0.0;\n    return 1.0;\n}\n\nmat3 camera () {\n    float a =  iMouse.x*0.05 + 2.0;\n    vec3 right =\tvec3(1.0, 0.0, 0.0);\n \tvec3 up =\t\tnormalize(vec3(0.0, 1.0, 1.8 + (iMouse.y/iResolution.y*2.0-1.0)*1.5)); \n    \n    mat2 ra = rot(a);\n    right.xz *= ra;\n    up.xz *= ra;\n        \n    return mat3(right, up, cross(right, up));\n}\n\nconst float orgl = 0.5;\n\nvec4 bb8Body (vec3 raym) {\n    float a = iTime;\n    float b = 42.0;\n    raym.xy *= rot(a);\n    raym.xz *= rot(b);\n    vec4 rust = texture(iChannel1, raym.xz*0.5) + texture(iChannel1, raym.zy*0.5);\n    rust.w = 0.0;\n    vec4 wh = vec4(0.9, 0.9, 0.9, 0.0);\n    vec4 color;\n    color = vec4(1.0, 1.0, 1.0, 0.0);\n        \n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.1, length(raym.xy)-0.575));\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.1, length(raym.zy)-0.575));\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.1, length(raym.xz)-0.575));\n\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.075, abs(raym.x)-0.01));\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.075, abs(raym.y)-0.01));\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.075, abs(raym.z)-0.01));\n    \n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(raym.x)-0.0075));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(raym.y)-0.0075));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(raym.z)-0.0075));\n    \n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.xy)-0.5));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(length(raym.xy)-0.5)-0.095));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.z)+abs(raym.x+raym.y)*0.1/(-abs(raym.z)+1.05)-0.1125));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.z)+abs(raym.x-raym.y)*0.1/(-abs(raym.z)+1.05)-0.1125));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, abs(length(raym.xy)-0.5)-0.07));\n    color = mix(color*0.75, color, smoothstep(0.0, 0.0125, abs(length(raym.xy)-0.5)-0.005));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.025, ppp(raym.z)+abs(raym.x+raym.y)*0.1/(-abs(raym.z)+1.05)-0.08));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.025, ppp(raym.z)+abs(raym.x-raym.y)*0.1/(-abs(raym.z)+1.05)-0.08));\n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.xy)-0.25));\n    color = mix(vec4(0.5, 0.5, 0.5, 0.0), color, smoothstep(0.0, 0.025, length(raym.xy)-0.2));\n\n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.zy)-0.5));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(length(raym.zy)-0.5)-0.095));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.x)+abs(raym.z+raym.y)*0.1/(-abs(raym.x)+1.05)-0.1125));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.x)+abs(raym.z-raym.y)*0.1/(-abs(raym.x)+1.05)-0.1125));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, abs(length(raym.zy)-0.5)-0.07));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, ppp(raym.x)+abs(raym.z+raym.y)*0.1/(-abs(raym.x)+1.05)-0.08));\n    color = mix(color*0.75, color, smoothstep(0.0, 0.0125, abs(length(raym.zy)-0.5)-0.005));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, ppp(raym.x)+abs(raym.z-raym.y)*0.1/(-abs(raym.x)+1.05)-0.08));\n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.zy)-0.25));\n    color = mix(vec4(0.5, 0.5, 0.5, 0.0), color, smoothstep(0.0, 0.025, length(raym.zy)-0.2));\n\n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.xz)-0.5));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(length(raym.xz)-0.5)-0.095));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.y)+abs(raym.x+raym.z)*0.1/(-abs(raym.y)+1.05)-0.1125));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.025, ppp(raym.y)+abs(raym.x-raym.z)*0.1/(-abs(raym.y)+1.05)-0.1125));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, abs(length(raym.xz)-0.5)-0.07));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, ppp(raym.y)+abs(raym.x+raym.z)*0.1/(-abs(raym.y)+1.05)-0.08));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, ppp(raym.y)+abs(raym.x-raym.z)*0.1/(-abs(raym.y)+1.05)-0.08));\n    color = mix(wh, color, smoothstep(0.0, 0.025, length(raym.xz)-0.25));\n    color = mix(vec4(0.5, 0.5, 0.5, 0.0), color, smoothstep(0.0, 0.0125, length(raym.xz)-0.2));\n    if (raym.y > 0.0) color = mix(wh, color, smoothstep(0.0, 0.0125, length(raym.xz)-0.13));\n\t\n    return color*mix(rust.r*rust.r, 1.0, color.w);\n}\n\nvec4 bb8Head (vec3 p) {\n    \n    p.xy = rot(-0.3 + sin(iTime*2.0)*0.2) * p.xy;\n    vec4 rust = texture(iChannel1, p.xz*0.5) + texture(iChannel1, p.zy*0.5);\n    rust.w = 0.0;\n    vec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n    \n   // color = mix(vec3(0.0), color, smoothstep(0.0, 0.0125, p.y-0.95));\n    color = mix(vec4(0.25, 0.25, 0.25, 0.0), color, smoothstep(0.0, 0.0125, abs(p.y-0.925)-0.05));\n    color = mix(vec4(0.5, 0.5, 0.5, 0.0), color, smoothstep(0.0, 0.0125, abs(p.y-0.925)-0.03));\n\n    color = mix(vec4(1.0,0.8,0.4, 0.0), color, smoothstep(0.0, 0.025, abs(p.y-1.3)-0.04));\n    color = mix(vec4(1.0,0.5,0.0, 0.0)*0.75, color, smoothstep(0.0, 0.0125, abs(p.y-1.3)-0.03));\n    color = mix(vec4(1.0,0.5,0.0, orgl), color, smoothstep(0.0, 0.0125, abs(p.y-1.3)-0.02));\n\n    float angle = atan(p.x/p.z);\n    float t = mod(angle, 3.1415/8.0);\n    color = mix(mix(vec4(0.25, 0.25, 0.25, 0.0), vec4(1.0, 1.0, 1.0, 0.0), smoothstep(0.0, 0.075, abs(t-0.2)-0.3)), color, smoothstep(0.0, 0.0075, abs(p.y-1.39)-0.025));\n    color = mix(mix(vec4(0.5, 0.5, 0.5, 0.5), vec4(0.25), smoothstep(0.0, 0.075, abs(t-0.2)-0.1)), color, smoothstep(0.0, 0.0075, abs(p.y-1.39)-0.02));\n\n    if (p.x < 0.0) {\n    \tcolor = mix(vec4(1.0, 1.0, 1.0, 0.0), color, smoothstep(0.0, 0.0125, length((p.zy-vec2(0.0, 1.225))*vec2(1.0, 1.3))-0.175));\n    \tcolor = mix(vec4(0.75, 0.75, 0.75, 0.0), color, smoothstep(0.0, 0.0125, abs(length((p.zy-vec2(0.0, 1.225))*vec2(1.0, 1.3))-0.15)));\n    }\n    \n    return color*mix(1.0, rust.r*rust.r, color.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    mat3 cam = camera();\n    vec3 ro = cam * vec3(uv, -1.5-iMouse.y/iResolution.y);\n    vec3 rd = cam * normalize(vec3(uv, 1.0));\n    \n    vec4 raym = raymarch(ro, rd);\n    if (raym.w > 0.0) {\n        \n        vec3 light = ro+vec3(-2.0, 4.0, -1.0);\n        \n        vec3 n = normal(raym.xyz);\n        \n        float spec = 0.0;\n        vec3 droidColor = vec3(0.0);\n        if (raym.w == 1.0) {\n            spec = 0.25;\n            droidColor.rgb = texture(iChannel0, rot(1.0)*(raym.xz*0.05 + vec2(-iTime*0.05, 0.0))).rgb;\n        } else if (raym.w == 2.0) {\n            vec4 bc = bb8Body(raym.xyz);\n            droidColor.rgb = bc.rgb;\n            spec = bc.a;\n        } else if (raym.w == 3.0) {\n            vec4 bc = bb8Head(raym.xyz);\n            droidColor.rgb = bc.rgb;\n            spec = bc.a;\n            \n        } else if (raym.w == 4.0) {\n         \tdroidColor.rgb = vec3(0.0);\n            if (raym.z < -0.15 && mod(iTime, 1.0) < 0.1) {\n                droidColor.rgb = vec3(0.0, 4.1, 0.2);\n                spec = 4.0;\n            } else spec = 1.0;\n        }\n        fragColor.rgb = droidColor;\n        float shadoww = shadow(raym.xyz+n*0.01, normalize(light-raym.xyz));\n        float diff = clamp(dot(n, normalize(light-raym.xyz)), 0.0, 1.0);\n        \n        if (raym.w == 1.0) {\n         \tdiff = 1.0; \n        }\n        \n        fragColor *= mix(0.125, 1.0, shadoww);\n        fragColor *= mix(0.125, 1.0, diff);\n                \n        vec3 sur2light = normalize(light-raym.xyz);\n        vec3 sur2eye = normalize(ro - raym.xyz);\n        vec3 ref = reflect(sur2eye, n);\n        float sp = clamp(dot(ref, -sur2light), 0.0, 1.0);\n                \n        fragColor.rgb += vec3(pow(sp, 64.0) * shadoww * spec);\n        fragColor.rgb += vec3(pow(sp, 128.0) * shadoww * spec);\n        fragColor.rgb += vec3(pow(sp, 256.0) * shadoww * spec);\n        fragColor.rgb += vec3(pow(sp, 1.0) * shadoww * spec)*0.1;\n\n        fragColor.rgb = mix(vec3(1.0), fragColor.rgb, exp(-length(raym.xyz)*0.05));\n        \n        if (raym.w != 1.0) {\n        \tfloat asd = clamp(dot(n, sur2eye), 0.0, 1.0);\n        \tasd = smoothstep(0.25, 0.35, asd);\n        \tfragColor.rgb = mix(vec3(0), fragColor.rgb, asd);\n        }\n    } else {\n    \tfragColor = vec4(1.0);\n    }\n   \n    vec4 c = step(texture(iChannel0, fragCoord/8.), fragColor);\n    fragColor = mix(fragColor, c, 0.0);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.77));\n\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 87, 87, 140], [142, 142, 194, 194, 321], [323, 323, 355, 355, 384], [386, 386, 418, 418, 450], [452, 452, 473, 473, 1349], [1351, 1351, 1373, 1373, 1586], [1588, 1588, 1622, 1622, 1907], [1909, 1909, 1942, 1942, 2289], [2291, 2291, 2312, 2312, 2363], [2365, 2365, 2381, 2381, 2661], [2688, 2688, 2714, 2714, 7215], [7217, 7217, 7240, 7240, 8734], [8736, 8736, 8793, 8793, 11308]], "test": "error"}
{"id": "WtsGzS", "name": "rayMarching Mehnir", "author": "ArmanD", "description": "I DON'T UNDERSTAND MY CODE ;", "tags": ["3d", "raymarching", "ray", "light", "rock", "marcing", "movinglight"], "likes": 1, "viewed": 101, "published": "Public", "date": "1556738439", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat getDist (vec3 p ){\nvec4 s = vec4 (0. ,1. ,6. ,1.);\n//  s.xz  *= rot (time);\nfloat sphereDist =length (p-s.xyz)-s.w\n-sin (p.x)*3.;\nfloat planeDist = p.y;\nfloat d = min ( planeDist ,sphereDist );\nreturn d;\n}\n  float rayMarch (vec3 ro , vec3 rd){\nfloat  d = 0.0;\nfor ( int i = 0 ; i < 100 ; i++){\n  vec3 p = ro + rd * d;\n  float ds = getDist(p);\n  d += ds;\n  if ( d > 100. || ds < 1./iTime){\n  break;\n  }}\nreturn d;\n}\nvec3 getNormal (vec3 p){\nfloat d = getDist(p);\nvec2 e = vec2 (.01 , 0. );\n \nvec3 n = d-vec3 (\ngetDist(p-e.xyy) ,\ngetDist(p-e.yxy) ,\ngetDist(p-e.yyx) );\nreturn normalize (n);\n}\n\n  float getLight(vec3 p){\n  vec3 lightPos = vec3 (0 , 100. , 6);\nlightPos.xz += 50. * vec2  (sin (iTime),cos (iTime));\n  vec3 l = normalize (lightPos-p);\n  vec3 n = getNormal (p);\n  float dif = max (dot (l,n),0.);\n    float d = rayMarch (p+n*0.01, l);\n    if (d < length (lightPos-p)) dif *= .1;\n  return dif;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   float ratio = iResolution.y / iResolution.x;\nvec2 uv = (fragCoord.xy  / iResolution.x)\n- vec2 (0.5 , 0.5 *  ratio);\n\n    vec3 ro = vec3 (0. ,1. ,-10.);\n    vec3 rd = normalize (vec3 (uv.xy ,1.));\n\n\n    float d = rayMarch (ro ,rd);\n\n    vec3 p= ro + rd * d;\n    float dif = getLight (p);\n\n  vec3  col = vec3 (dif);\n \n\n\tfragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 212], [215, 215, 250, 250, 421], [422, 422, 446, 446, 597], [601, 601, 624, 624, 912], [914, 914, 971, 971, 1328]], "test": "ok"}
{"id": "wtSGzW", "name": "[liliilli] Camera Test", "author": "liliilli", "description": "Camera Test :thinking:", "tags": ["liliilli"], "likes": 1, "viewed": 375, "published": "Public API", "date": "1558622555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nstruct DPoint\n{\n    vec3 mPos;\n    vec3 mCol;\n};\n\nfloat DistLineToPoint(vec3 ro, vec3 rd, vec3 pos)\n{\n    vec3 ap = pos - ro;\n    return length(cross(ap, rd)) / length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 pos)\n{\n    float dist = DistLineToPoint(ro, rd, pos);\n    return smoothstep(0.1, 0.09, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    uv.x -= (iResolution.x - iResolution.y) / \n        (2.0 * min(iResolution.x, iResolution.y)); \n    uv -= 0.5;\n    \n    vec3 camera = vec3(0, 3, 5);\n    camera = vec3(\n        cos(iTime) * camera.x + sin(iTime) * camera.z, \n        camera.y,\n        -sin(iTime) * camera.x + cos(iTime) * camera.z);\n    vec3 view   = vec3(0, 0, 0);\n    vec3 up     = vec3(0, 1, 0);\n    \n    // Setting up View matrix (don't make view matrix itself, We just need v,s,u element).\n    vec3 forward = normalize(view - camera);\n    vec3 side    = cross(forward, up);\n    vec3 camUp   = cross(side, forward);\n\n    float zoom = 2.0f;\n\n    // Setting up virtual screen, and lay direction of virtual screen pixel.\n    vec3 scrOrg = camera + zoom * forward;\n    vec3 pxlPos = scrOrg + (side * uv.x) + (camUp * uv.y);\n    vec3 rayDir = normalize(pxlPos - camera);\n    \n    vec3 result = vec3(0);\n    \n    DPoint point;\n    point.mPos = vec3(1, 0, 0); point.mCol = vec3(1, 1, 0);\n    {\n        float v = DrawPoint(camera, rayDir, point.mPos);\n        result += point.mCol * v;\n    }\n    point.mPos = vec3(0, 0, 1); point.mCol = vec3(0, .5, 1);\n    {\n        float v = DrawPoint(camera, rayDir, point.mPos);\n        result += point.mCol * v;\n    }\n    point.mPos = vec3(0, 0, -1); point.mCol = vec3(0, 1, 0);\n    {\n        float v = DrawPoint(camera, rayDir, point.mPos);\n        result += point.mCol * v;\n    }\n    point.mPos = vec3(-1, 0, 0); point.mCol = vec3(1, .5, 0);\n    {\n        float v = DrawPoint(camera, rayDir, point.mPos);\n        result += point.mCol * v;\n    }\n    \n    fragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 102, 102, 175], [177, 177, 222, 222, 311], [313, 313, 368, 368, 2024]], "test": "ok"}
{"id": "wtX3z2", "name": "Flying Sonic's head", "author": "yasuo", "description": "I'm not a big fan of the sonic the hedgehog, but something I wanted to create like this anyway.", "tags": ["raymerching"], "likes": 8, "viewed": 326, "published": "Public API", "date": "1556906375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.045\n#define PI 3.14159265359\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.08;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 sonicFaceTex(vec3 p) {\n    vec2 uv = p.xy;\n    vec3 col = vec3(0.0,0.0,1.0);\n    float eyeL = length(uv+vec2(-0.17,0.0))-0.1;\n    float eyeL2 = length(uv+vec2(-0.14,0.03))-0.09;\n    float eyeL3 = length(uv+vec2(-0.11,0.05))-0.08;\n    float eyeL4 = length(uv+vec2(-0.08,0.06))-0.07;\n    float eyeL5 = length(uv+vec2(-0.05,0.07))-0.06;\n    float eyeL6 = length(uv+vec2(-0.02,0.08))-0.04;\n    float eyeL7 = length(uv+vec2(0.00,0.08))-0.03;\n    float mouth = length(uv+vec2(-0.2,0.17))-0.025;\n    float mouth2 = length(uv+vec2(-0.17,0.18))-0.035;\n    float mouth3 = length(uv+vec2(-0.14,0.19))-0.04;\n    float mouth4 = length(uv+vec2(-0.11,0.2))-0.045;\n    float mouth5 = length(uv+vec2(-0.08,0.2))-0.05;\n    float mouth6 = length(uv+vec2(-0.05,0.2))-0.05;\n    float mouth7 = length(uv+vec2(-0.02,0.2))-0.05;\n    float nose = length(uv+vec2(0.00,0.16))-0.02;\n    \n    uv.y*=0.6;\n    float eyeball = dot(uv+vec2(-0.17,-0.01),uv+vec2(-0.17,-0.01))*20.0;\n    uv = p.xy;\n    float eyeball2 = dot(uv+vec2(-0.17,-0.03),uv+vec2(-0.17,-0.03))*50.0;\n    uv.y*=0.6;\n    float eyeball3 = dot(uv+vec2(-0.17,-0.01),uv+vec2(-0.17,-0.01))*10.0;\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL2) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL3) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL4) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL5) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL6) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL7) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth2) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth3) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth4) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth5) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth6) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth7) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,nose) );\n    col = mix( col, vec3(0.2,1.0,0.2), 1.0-smoothstep(0.01,0.015,eyeball3) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeball) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeball2) );\n    \n\n    col = (p.z>0.01)? col:vec3(0.0,0.0,1.0);\n    \n    return col;\n}\n\nvec4 sdSonic(vec3 p) {\n    vec3 uv = p;\n    float sonicD = sdRoundCone((p+vec3(0.0,0.15,0.0))*matRotateX(radians(120.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.45);\n    float sonicD2 = sdRoundCone((p+vec3(0.0,0.0,0.0))*matRotateX(radians(90.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.5);\n    float sonicD3 = sdRoundCone((p+vec3(0.0,-0.15,0.0))*matRotateX(radians(70.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.3);\n    float sonicF = length(p+vec3(0.0,0.0,-0.15))-0.35;\n    p.x = abs(p.x);\n    float ears = sdRoundCone((p+vec3(-0.2,-0.17,-0.2))*matRotateZ(radians(20.0)),0.1,0.02,0.2);\n\n    float sonicD4 = sdRoundCone((p+vec3(-0.2,-0.1,0.0))*matRotateX(radians(70.0+sin(iTime*5.9993)*20.0))*matRotateZ(radians(30.0)),0.15,0.03,0.5);\n    float sonicD5 = sdRoundCone((p+vec3(-0.2,0.1,0.0))*matRotateX(radians(120.0+sin(iTime*5.9993)*20.0))*matRotateZ(radians(30.0)),0.15,0.03,0.5);\n    \n    uv.x = abs(uv.x);\n    vec4 sonic = vec4(sonicFaceTex(uv),min(min(min(min(min(min(sonicD,sonicD2),sonicD3),sonicF),ears),sonicD4),sonicD5));\n\treturn sonic;\n}\n\nvec3 floorTex(vec2 uv) {\n    \n    vec3 colA = vec3(0.9,0.6,0.0);\n    vec3 colB = vec3(0.8,0.4,0.0);\n    vec3 col = vec3(mix(colA,colB,mod((floor(uv.x*5.0) + floor(uv.y*5.0))*0.5, 2.0)));\n    \n    float w = 0.7;\n    col = (uv.x>=-w && uv.x< w)? vec3(0.6,0.9,0.6):col;\n    \n    return col;\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    \n    vec3 spPos = vec3(0.0);\n   \n    float sdist = 2.1;\n    float srotVal = radians((iTime*60.0));\n\tfloat sy = spPos.y+cos(srotVal)*(sdist);\n    float sz = spPos.z+sin(srotVal)*(sdist);\n    \n\tfloat sdeg = (atan(sy,sz)*180.0/PI);\n    vec3 sonicPos = (p+vec3(0.0,sy,sz))*matRotateX(radians(45.0+sdeg));\n    vec4 sonic = sdSonic(sonicPos);\n    vec4 sp = vec4(floorTex(uv),length((p+spPos))-1.5);\n    \n    float numCoin = 10.0;\n    float deg = 360.0/numCoin;\n    vec4 coin = vec4(1.0,1.0,0.0,1.0);\n    \n    float coinD = 8.0;\n    for(float i = 0.0; i<numCoin; i+=1.0) {\n        float rotVal = radians(i*deg);\n        mat3 m = matRotateX(rotVal);\n        mat3 mrot = matRotateZ(rotVal*iTime*0.3);\n        float cdist = 1.9;\n        float y = spPos.y+cos(rotVal)*(cdist);\n        float z = spPos.z+sin(rotVal)*(cdist);\n        vec3 coinPos = (p+vec3(spPos.x,z,y))*m*mrot;\n        coinD = min(coinD,sdTorus(coinPos,vec2(0.15,0.03)));\n        coin = vec4(1.0,1.0,0.0,coinD);\n    }\n    \n    return combine(combine(sp,coin),sonic);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 2.5*cos(0.1*time + 6.0), 3.5, 2.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n        }\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.94*max(mix(vec3(0.5,1.1,1.2)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.0,0.0,0.3),edge);\n   \n    \n    fragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtX3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 546, 577, 577, 669], [671, 671, 701, 701, 751], [753, 753, 789, 789, 864], [866, 866, 930, 930, 1208], [1210, 1210, 1241, 1241, 1310], [1312, 1312, 1339, 1339, 3803], [3805, 3805, 3827, 3827, 4828], [4830, 4830, 4854, 4854, 5119], [5121, 5121, 5138, 5138, 6209], [6211, 6211, 6234, 6234, 6511], [6513, 6513, 6547, 6547, 6857], [7228, 7228, 7280, 7280, 7469], [7471, 7471, 7527, 7527, 9398]], "test": "timeout"}
{"id": "wtX3zB", "name": "Almost My First Shader", "author": "dr2", "description": "See the source...", "tags": ["raymarch", "landscape", "flight", "car"], "likes": 10, "viewed": 602, "published": "Public API", "date": "1556704447", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Almost My First Shader\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  We all know that Shadertoy is a great resource for learning shader programming. \n  Before my first contribution nearly five years ago I found many examples by the \n  Shadertoy pioneers that were helpful in learning what could be done and how to \n  do it. The second of the two shaders below is one of my initial attempts, but\n  because much of it is a cut-and-paste job based on their work I never bothered\n  to publish it. Since the visuals are not bad (ignoring artifacts) I have now\n  rewritten it in the usual style, and this is the first of the shaders here.\n*/\n\n#if 1   // shader version (1/0)\n\n// The new version\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 carMat;\nvec3 carPos, sunDir;\nfloat dstFar, szFac, carRoll, fanAng;\nint idObj;\nbool isRefl;\nconst int idRd = 1, idGrnd = 2, idTun = 3, idCar = 4;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (1.5 * cos (cos (0.2 * t) + 0.16 * t) * cos (0.1 * t),\n     2. * sin (0.11 * t) + 0.8 * cos (cos (0.07 * t) + 0.11 * t) * cos (0.03 * t), t);\n}\n\nfloat CarDf (vec3 p)\n{\n  float d;\n  p = carMat * (p - carPos) / szFac;\n  p.y -= -26.;\n  p.xy = Rot2D (p.xy, carRoll);\n  d = max (length (max (vec3 (abs (p.x) - 3.5,\n     length (vec2 (p.y + 12., p.z)) - 20., - (p.y - 1.6)), 0.)) - 0.5, p.z - 12.);\n  p.yz -= vec2 (2.2, -3.9);\n  p.xz = abs (p.xz) - vec2 (7.2, 10.6);\n  d = min (SmoothMin (d, length (vec2 (max (abs (p.z) - 2.4, 0.), length (p.xy) - 2.8)) - 0.2, 3.),\n     (length (vec3 (p.xy, 0.35 * p.z)) - 0.8));\n  return d * szFac;\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, r;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  d = max (q.y + 1., abs (q.x) - 0.75);\n  DMIN (idRd);\n  d = mix (q.y + 1.1, q.y - 36. * Fbm2 (0.03 * q.xz) + 12., smoothstep (3., 30., abs (q.x)));\n  DMIN (idGrnd);\n  r = q;\n  r.z = mod (r.z + 25., 50.) - 25.;\n  d = max (abs (r.y - 1. + 0.4 * r.x * r.x) - 0.1, abs (r.z) - 10.);\n  r.y += 0.7;\n  r.z = mod (r.z, 2.5) - 1.25;\n  d = max (d, 0.6 - length (r.yz));\n  DMIN (idTun);\n  if (! isRefl) {\n    d = CarDf (p);\n    DMIN (idCar);\n  }\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 350; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat FanDf (vec3 p)\n{\n  float d;\n  p = carMat * (p - carPos) / szFac;\n  p.y -= -26.;\n  p.xy = Rot2D (p.xy, carRoll);\n  p.yz -= vec2 (2.2, -3.9);\n  p.xz = abs (p.xz) - vec2 (7.2, 10.6);\n  p.xy = Rot2D (p.xy, fanAng);\n  d = max (max (min (abs (p.x), abs (p.y)) * 0.15 - 0.05,\n     abs (p.z) - 2.), length (p.xy) - 2.8);\n  return d * szFac;\n}\n\nfloat FanRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = FanDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjCol (vec3 p, vec3 rd, vec3 vn)\n{\n  vec3 q, col, m;\n  float c, f, sh, spec;\n  q = p - vec3 (TrackPath (p.z).xy, 0.);\n  spec = 0.;\n  if (idObj == idRd) {\n    c = max (0., 1. - 5. * abs (0.4 - abs (q.x))) * step (0.5, cos (32. * pi * q.z / 50.));\n    col = vec3 (0.5) + 2. * pow (c, 8.) * vec3 (1., 0.8, 0.);\n  } else if (idObj == idGrnd) {\n    f = 0.55 * (clamp (Noisefv2 (p.xz * 0.1), 0., 1.) +\n       Noisefv2 (p.xz * 0.2 + vn.yz * 1.08) * 0.85);\n    m = mix (vec3 (0.63 * f + 0.2, 0.7 * f + 0.1, 0.7 * f + 0.1),\n       vec3 (f * 0.43 + 0.1, f * 0.3 + 0.2, f * 0.35 + 0.1), f * 0.65);\n    col = m * (f * m + vec3 (0.36, 0.30, 0.28));\n    if (vn.y < 0.5) {\n      c = (0.5 - vn.y) * 4.;\n      c = clamp (c * c, 0.1, 1.);\n      f = Noisefv2 (vec2 (p.x * 0.2, p.z * 0.2 + p.y * 0.3)) +\n         Noisefv2 (vec2 (p.x * 4.5, p.z * 4.5)) * 0.5;\n      col = mix (col, vec3 (0.4 * f), c);\n    }\n    if (p.y < 5. && vn.y > 0.65) {\n      m = vec3 (Noisefv2 (p.xz * 7.) * 0.4 + 0.1, Noisefv2 (p.xz * 11.) * 0.6 + 0.3, 0.);\n      m *= (vn.y - 0.55) * 0.85;\n      col = mix (col, m, clamp ((vn.y - 0.65) * (5. - p.y) * 0.13, 0., 1.));\n    }\n    if (p.y > 5. && vn.y > 0.2) {\n      col = mix (col, 1.3 * vec3 (0.95, 0.95, 1.),\n         clamp ((p.y - 5. - Noisefv2 (p.xz * 1.2)) * 0.2, 0., 1.));\n      spec = 0.1;\n    }\n  } else if (idObj == idTun) {\n    col = vec3 (0.8, 0., 0.);\n    if (abs (q.x) < 0.6 && vn.y < 0.) col += pow (max (0., 1.5 - 2.5 * abs (q.x)) *\n       step (0., cos (64. * pi * q.z / 50.)), 8.) * vec3 (0.8, 0.4, 0.7);\n  } else if (idObj == idCar) {\n    q = carMat * (p - carPos) / szFac;\n    q.y -= -26.;\n    q.xy = Rot2D (q.xy, carRoll);\n    q.xz = abs (q.xz);\n    col = ((abs (q.y - 6.5) < 1. - q.z * 0.1 && q.z < 3.5 ||\n       length (max (abs (vec2 (q.x - q.z * 0.03, q.z - 5.)) -\n       vec2 (1.5 + q.z * 0.03, 4.), 0.)) < 1.) ? 0.4 : 1.) * vec3 (0.2, 0.6, 1.);\n    spec = 0.5;\n  }\n  sh = ObjSShadow (p, sunDir);\n  return col * (0.2 + sh * 0.8 * max (0., dot (sunDir, vn))) +\n     spec * step (0.95, sh) * pow (max (0., dot (rd, reflect (sunDir, vn))), 32.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  float sd;\n  rd.y = abs (rd.y);\n  sd = max (0., dot (rd, sunDir));\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y) - 0.1) * rd.y, 0., 1.)) + (pow (sd, 64.) * 0.15 +\n     pow (sd, 256.) * 0.15) * vec3 (1., 0.8, 0.5);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, vn;\n  float dstObj, dstFan, dstObjT;\n  int idObjT;\n  dstFan = FanRay (ro, rd);\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObjT = idObj;\n    dstObjT = dstObj;\n    col = ObjCol (ro, rd, vn);\n  } else {\n    col = SkyCol (rd);\n  }\n  if (dstObj < dstFar && idObjT == 4) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    isRefl = true;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      colR = ObjCol (ro, rd, vn);\n    } else {\n      colR = SkyCol (rd);\n    }\n    col = mix (col, colR, 0.2);\n  }\n  if (dstFan < min (dstObjT, dstFar)) col += mix (col, vec3 (1., 0.5, 0.2), 0.5);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, col, dir, u;\n  vec2 canvas, uv;\n  float tCur, spd, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  szFac = 0.025;\n  spd = 8.;\n  fanAng = mod (20. * tCur, 2. * pi);\n  carPos = TrackPath (spd * tCur);\n  dir = normalize ((TrackPath (spd * tCur + 1.) - carPos));\n  u = normalize (vec3 (dir.z, 0., - dir.x));\n  carMat = mat3 (u, cross (u, - dir), - dir);\n  carRoll = dir.x * 0.8;\n  carPos.xy -= vec2 (dir.x, 0.2);\n  ro = TrackPath (spd * tCur - 1.7) - vec3 (1.5 * dir.x, 0.5, 0.);\n  vd = normalize (carPos - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  dstFar = 200.;\n  sunDir = normalize (vec3 (1., 1., 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 1.5));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#else\n\n// The ancient version\n\nconst float pi = 3.14159;\n\nvec4 Hashv4f (float p) {\n  return fract (sin (vec4 (p + 0., p + 1., p + 57., p + 58.)) * 43758.5453);\n}\n\nfloat Noisefv2 (vec2 s) {\n  vec2 p = floor (s);\n  vec2 f = fract (s);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (p.x + 57. * p.y);\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p) {\n  const mat2 mr = mat2 (0.6, -0.8, 0.8, 0.6);\n  float f = 0.;\n  float a = 1.;\n  float am = 0.5;\n  float ap = 2.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    p *= mr * ap;\n    a *= am;\n  }\n  return f;\n}\n\nvec3 colSky (vec3 rd) {\n  vec3 col;\n  if (rd.y < 0.) rd.y *= -1.;\n  vec2 xy = 1. * rd.xz / rd.y;\n  float w = 0.65;\n  float f = 0.;\n  for (int i = 0; i < 4; i ++) {\n    f += Noisefv2 (xy) * w;\n    w *= 0.5;\n    xy *= 2.3;\n  }\n  col = mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (f - 0.2) * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 carPos;\nmat3 carMat;\nmat2 carRoll;\nfloat fanDist;\nint isRefl;\nbool carOnly = false;\nbool needFan;\nvec3 lightDir;\nmat2 spinMat;\n\nfloat SmoothMin (float a, float b, float k)\n{\n  float h = clamp (.5 + .5 * (b - a) / k, 0., 1.);\n  return mix (b, a, h) - k * h * (1. - h);\n}\n\nvec3 path (float t)\n{\n  t *= 0.6;\n  float x = cos (cos (t * 0.36) + t * 0.28) * cos (t * 0.13) * 1.5;\n  float y = sin (t * 0.17) * 2. + cos (cos (t * 0.12) + t * 0.19) *\n     cos (t * 0.051) * 0.8;\n  return vec3 (x, y, t / 0.6);\n}\n\nfloat DfTunnel (vec3 p)\n{\n  p.z = mod (p.z, 50.) - 25.;\n  float d = max (abs (p.y - 1. + 0.4 * p.x * p.x) - 0.1, abs (p.z) - 10.);\n  p.z = mod (p.z, 2.5) - 1.25;\n  p.y += 0.7;\n  d = max (d, - (length (p.yz) - 0.6));\n  return d;\n}\n\nfloat DfCar (vec3 p)\n{\n  p *= 40.;\n  float d = max (length (max (vec3 (abs (p.x) - 3.5,\n     length (vec2 (p.y + 12., p.z)) - 20., - (p.y - 1.6)), 0.)) - 0.5, p.z - 12.);\n  vec3 q = p + vec3 (0., -2.2, 3.9);\n  q.xz = abs (q.xz) - vec2 (7.2, 10.6);\n  d = SmoothMin (d,\n     length (vec2 (max (abs (q.z) - 2.4, 0.), length (q.xy) - 2.8)) - 0.2, 3.);\n  d = min (d, (length (vec3 (q.xy, 0.35 * q.z)) - 0.8));\n  return d / 40.;\n}\n\nfloat DfFan (vec3 p)\n{\n  p *= 40.;\n  vec3 q = p + vec3 (0., -2.2, 3.9);\n  q.xz = abs (q.xz) - vec2 (7.2, 10.6);\n  q.xy *= spinMat;\n  float df = max (max (min (abs (q.x), abs (q.y)) * 0.15 - 0.05,\n     abs (q.z) - 2.), length (q.xy) - 2.8);\n  df = min (df, (length (q) - 0.5) * 0.07);\n  return min (fanDist, df / 40.);\n}\n\nfloat colCar (vec3 p)\n{\n  p *= 40.;\n  p.xz = abs (p.xz);\n  return (abs (p.y - 6.5) < 1. - p.z * 0.1 && p.z < 3.5 ||\n     length (max (abs (vec2 (p.x - p.z * 0.03, p.z - 5.)) -\n     vec2 (1.5 + p.z * 0.03, 4.), 0.)) < 1.) ? 0.4 : 1.;\n}\n\nint hitObj, hitObjP;\n\nfloat de (vec3 p)\n{\n  float d, dd;\n  float gd = p.y + 12. - 20. * Fbm2 (0.04 * p.xz);\n  hitObj = 0;\n  vec3 q = p;\n  if (! carOnly) q.xy -= path (q.z).xy;\n  d = q.y + 1.;\n  if (! carOnly) {\n    d = max (d, abs (q.x) - 0.75);\n    hitObj = 1;\n    float b = smoothstep (3., 25., abs (q.x));\n    dd = (q.y + 1.1) * (1. - b) + gd * b;\n    if (dd < d) {\n      d = dd;\n      hitObj = 2;\n    }\n    dd = DfTunnel (q);\n    if (dd < d) {\n      d = dd;\n      hitObj = 3;\n    }\n  }\n  if (isRefl == 0) {\n    q = p;\n    if (! carOnly) {\n      q -= carPos;\n      q = carMat * q;\n      q.y += 0.7;\n      q.xy *= carRoll;\n    }\n    dd = DfCar (q);\n    if (needFan) fanDist = DfFan (q);\n    if (dd < 0.001) hitObj = 4;\n    d = min (d, dd);\n  }\n  return d;\n}\n\nvec3 evalNorm (vec3 p)\n{\n  const vec3 e = 0.001 * vec3 (1., -1., 0.);\n  float v0 = de (p + e.xxx);\n  float v1 = de (p + e.xyy);\n  float v2 = de (p + e.yyx);\n  float v3 = de (p + e.yxy);\n  return normalize (vec3 (v0) + vec3 (v1 - v3 - v2, v3 - v1 - v2, v2 - v3 - v1));\n}\n\nfloat shadow (vec3 pos, vec3 sdir)\n{\n  float sh = 1.0;\n  float totdist = 0.004 * 10.;\n  float d;\n  for (int steps = 0; steps < 40; steps++) {\n    vec3 p = pos + totdist * sdir;\n    d = de (p);\n    sh = min (sh, 10. * max (0.0, d) / totdist);\n    sh *= sign (max (0., d - 0.004));\n    totdist += max (0.02, d);\n    if (totdist > 35. || d < 0.004) break;\n  }\n  return clamp (sh, 0., 1.0);\n}\n\n#define AMBIENT_COLOR vec3(.7,.85,1.)\n\nvec3 shade (vec3 p, vec3 dir, vec3 n)\n{\n  vec3 col = vec3 (0.);\n  if (hitObjP == 1) col = vec3 (0.5, 0.5, 0.5);\n  else if (hitObjP == 2) {\n    float f = 0.55 * (clamp (Noisefv2 (p.xz * 0.1), 0., 1.) +\n        Noisefv2 (p.xz * 0.2 + n.yz * 1.08) * 0.85);\n    vec3 m = mix (vec3 (0.63 * f + 0.2, 0.7 * f + 0.1, 0.7 * f + 0.1),\n\t    vec3 (f * 0.43 + 0.1, f * 0.3 + 0.2, f * 0.35 + 0.1), f * 0.65);\n    col = m * (f * m + vec3 (0.36, 0.30, 0.28));\n    if (n.y < 0.5) {\n      float c = (0.5 - n.y) * 4.;\n      c = clamp (c * c, 0.1, 1.);\n      f = Noisefv2 (vec2 (p.x * 0.2, p.z * 0.2 + p.y * 0.3)) +\n          Noisefv2 (vec2 (p.x * 4.5, p.z * 4.5)) * 0.5;\n      col = mix (col, vec3 (0.4 * f), c);\n    }\n    if (p.y < 5. && n.y > 0.65) {\n      m = vec3 (Noisefv2 (p.xz * 7.) * 0.4 + 0.1,\n\t\tNoisefv2 (p.xz * 11.) * 0.6 + 0.3, 0.);\n      m *= (n.y - 0.55) * 0.85;\n      col = mix (col, m, clamp ((n.y - 0.65) * 1.3 * (5. - p.y) * 0.1, 0., 1.));\n    }\n    if (p.y > 5. && n.y > 0.2) {\n      float snow = clamp ((p.y - 5. - Noisefv2 (p.xz * 1.2) * 1.) * 0.2, 0., 1.);\n      col = mix (col, vec3 (0.7, 0.7, 0.8), snow);\n    }\n  }\n  else if (hitObjP == 3) col = vec3 (0.8, 0., 0.);\n  vec3 q = p;\n  if (! carOnly) q -= vec3 (path (p.z).xy, 0.);\n  if (hitObjP == 1) {\n    float c = max (0., 0.2 - abs (0.4 - abs (q.x))) * 5. * abs (sin (q.z * 1.));\n    c *= c;\n    c *= c;\n    col += c * c * vec3(1.,.6,.25) * 2.4;\n  }\n  if (hitObjP == 3) {\n    if (abs (q.x) < 0.6 && n.y < 0.) {\n      float c = max (0., 0.3 - 0.5 * abs (q.x)) * 5. * abs (sin (q.z * 2.));\n      c *= c;\n      c *= c;\n      col += c * c * vec3(.8,.4,.7);\n    }\n  }\n  q = p;\n  if (! carOnly) {\n    q -= carPos;\n    q = carMat * q;\n    q.y += 0.7;\n    q.xy *= carRoll;\n  }\n  if (DfCar (q) < 0.001) {\n    col = colCar (q) * vec3 (1., 0.6, 0.3);\n  }\n  float diff, spec;\n  float sh = shadow (p, lightDir);\n  diff = max (0., dot (lightDir, n)) * 1.3;\n  float amb = (0.4 + 0.6 * max (0., dot (dir, - n))) * 0.6;\n  spec = pow (max (0., dot (dir, reflect (lightDir, n))), 20.) * 0.4;\n  return col * (amb * AMBIENT_COLOR + sh * (diff + spec) * vec3(1.,.85,.6));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec2 canvas, uv;\n  float tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bool riding = true;\n  if (carOnly) riding = false;\n  lightDir = normalize (vec3 (-0.7, 0.7, 0.7));\n  fanDist = 250.;\n  float t = mod (tCur, 500.) * 8.;\n  spinMat = mat2 (cos (t * 2.), - sin (t * 2.), sin (t * 2.), cos (t * 2.));\n  vec3 ro, rd, col;\n  if (riding) {\n    vec3 trkCar, dirCar, fwc, rtc;\n    trkCar = path (t);\n    dirCar = normalize ((path (t + 1.) - trkCar));\n    fwc = normalize (- dirCar);\n    rtc = normalize (cross (fwc, vec3 (0., 1., 0.)));\n    carMat = mat3 (rtc, cross (rtc, fwc), fwc);\n    float a = - dirCar.x * 0.8;\n    carRoll = mat2 (cos (a), sin (a), -sin (a), cos (a));\n    carPos = vec3 (trkCar.xy - vec2 (dirCar.x, 0.2), t);\n    ro = path (t - 0.6) + vec3 (- dirCar.x * 2., -0.5, -0.6);\n    vec3 fw = normalize (carPos - ro);\n    vec3 rt = normalize (cross (fw, vec3 (0., 1., 0.)));\n    rd = mat3 (rt, cross (rt, fw), fw) * normalize (vec3 (uv, 1.2));\n  } else {\n    float az, el;\n    el = 0.4;\n    az = 1.;\n    if (mPtr.z > 0.) {\n      el -= 0.3 * pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n    float cEl = cos (el);\n    float sEl = sin (el);\n    float cAz = cos (az);\n    float sAz = sin (az);\n    rd = normalize (vec3 (uv, 6.));\n    rd = vec3 (rd.x, rd.y * cEl - rd.z * sEl, rd.z * cEl + rd.y * sEl);\n    rd = vec3 (rd.x * cAz + rd.z * sAz, rd.y, rd.z * cAz - rd.x * sAz); \n    ro = - 4. * vec3 (cEl * sAz, - sEl, cEl * cAz);\n  }\n  float d;\n  vec3 carHitPt;\n  vec3 carHitN;\n  vec3 rdo = rd;\n  isRefl = 0;\n  float dist = 0.;\n  for (int i = 0; i < 200; i ++) {\n    needFan = true;\n    d = de (ro + dist * rd);\n    needFan = false;\n    dist += d;\n    if (d < 0.001) {\n      if (hitObj == 4 && isRefl == 0) {\n        ro += dist * rd;\n        carHitN = evalNorm (ro);\n        carHitPt = ro;\n        rd = reflect (rd, carHitN);\n        dist = 0.01;\n        isRefl = 1;\n      } else break;\n    } else {\n      if (dist > 100.) break;\n    }\n  }\n  hitObjP = hitObj;\n  if (d < 0.5) {\n    ro += dist * rd;\n    col = shade (ro, rd, evalNorm (ro));\n  } else {\n    float ldDot = max (0., dot (normalize (rd), lightDir));\n    col = colSky (rd) +\n      (pow (ldDot, 50.) * 0.15 + pow (ldDot, 200.) * 0.15) * vec3(1.,.8,.5);\n  }\n  if (isRefl == 1) col = shade (carHitPt, rdo, carHitN) + col * 0.3;\n  fanDist *= 100.;\n  if (fanDist < 0.4) {\n    float mFan = 1. / (1. + fanDist * fanDist * 10.);\n    col += vec3 (0.2, 0.3, 0.4) * mFan * (mFan + 0.5);\n  }\n  col = pow (abs (clamp (col, vec3 (0.), vec3 (1.))), vec3 (1.1)) * 0.9;\n  col = mix (vec3 (length (col)), col, 0.85);\n  fragColor = vec4 (col, 1.);\n}\n\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtX3zB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "error"}
{"id": "WtX3zX", "name": "pop up lines ", "author": "guowei", "description": "floating lines ", "tags": ["lines", "moving"], "likes": 0, "viewed": 66, "published": "Public", "date": "1557048189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    const float col = 7.0;\n    uv.y *= col;\n    \n    float fractV = fract(uv.y);\n    \n    float counter = abs(cos(iTime))/2.0;\n    \n    float startPoint = 0.0 + counter;\n    float gap = 0.1;\n    \n    float edge = fwidth(uv.y) * 2.0;\n    \n    float startLine = smoothstep(startPoint, startPoint + edge, fractV);\n    float endLine = smoothstep(startPoint + gap, startPoint + gap + edge, fractV);\n    \n    float line = startLine - endLine;\n    \n    vec4 defaultCOlor = vec4(0.0, 0.7, 0.8, 1.0);\n\n    // Output to screen\n    fragColor = vec4(defaultCOlor.xyz * line, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtX3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 814]], "test": "ok"}
{"id": "wtXGDB", "name": "Newton-Raphson fractal on sphere", "author": "tpfto", "description": "Newton-Raphson fractal for the polynomial z^3 - 1 embedded on the [url=https://en.wikipedia.org/wiki/Riemann_sphere]Riemann sphere[/url].", "tags": ["fractal", "math", "sphere", "complex"], "likes": 5, "viewed": 175, "published": "Public", "date": "1557466170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Newton-Raphson fractal of z^3 - 1 embedded on the Riemann sphere\n\n// Newton-Raphson routines from https://www.shadertoy.com/view/wllGRB\n// sphere rendering forked from https://www.shadertoy.com/view/MssGRl by asalga\n\n// some constants\n#define PI 3.14159265359\n\n// range of the display\n#define SCALE 8.0 \n\n// from Fabrice Neyret, \n#define cmul(A, B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A, B) cmul( A, cinv(B) )\n#define cis(a) vec2( cos(a), sin(a) )\n\n// modified DLMF coloring, from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// exponentiation using binary powering\nvec2 cpow( in vec2 z, in int n )\n{\n    if (n == 0) return vec2(1.0, 0.0);\n    if (n == 1) return z;\n    \n    if (n < 0) z = cinv(z);\n    n = abs(n);\n    \n    vec2 w = vec2(1.0, 0.0);\n    \n    for(int k = 0; k < 11; k++) { // should cover up to n == 1000\n        \n        if ((n & 1) == 1) w = cmul(w, z);\n\n        z = cmul(z, z);        \n        n >>= 1;\n\n        if (n < 2) break;\n    }\n        \n    return cmul(z, w);\n}\n\n// Newton-Raphson fractal for z^n - 1\nvec3 NewtonFractal(int n, vec2 z) {\n    \n    vec2 ld = vec2(0.0);\n    float k = 0.0;\n    \n    for(int i = 0; i < 20; i++) {\n        ld = cdiv(cpow(z, n) - vec2(1.0, 0.0), float(n) * cpow(z, n - 1));\n        if (dot(ld, ld) < 0.001) break;\n        z = z - ld;\n        k += 1.0;\n    }\n    \n    // multiplier highlights the positions of the roots\n    return pow((k + 0.16)/20.0, 0.18) * smooth_dlmf(0.3 + 0.5 * atan(z.y, z.x)/PI);\n\n}\n\n// sphere normal\n\nvec3 getNormal(in vec2 c, in float r, in vec2 point)\n{\n\treturn mix(vec3(0.0, 0.0, 1.0), normalize(vec3(point - c, 0.0)), length(point - c)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= SCALE;\n    float r = 3.0;\n\t\n\tif( length(uv) < r)\n    {\n\t\tvec3 sphereNormal = vec3(getNormal(vec2(0.0), r, uv));\n\t\tvec3 dirLight = normalize(vec3(0.0, 0.0, 1.0));\n\t\tvec3 col = normalize(vec3(1.0)) * dot(sphereNormal, dirLight);\n\t\t\n\t\tfloat xa = sphereNormal.x, ya = sphereNormal.y;\n        float s = sqrt((1.0 - ya) * (1.0 + ya)), sx = sqrt((s - xa) * (s + xa));\n\n        // Riemann sphere variable\n        vec2 zz = sqrt((1.0 + ya)/(1.0 - ya)) * normalize(vec2(xa, sx));\n        // animate the variable, anticlockwise rotation\n        zz = cmul(zz, cis(0.1 * PI * iTime));\n\t\t\n\t\tfragColor = vec4(0.2 + 3.0 * col * NewtonFractal(3, zz), 1.0);\n\n\t} else {\n\n\t\tfragColor = vec4(0.16, 0.14, 0.13, 1.0);\n\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 589, 618, 618, 816], [818, 858, 892, 892, 1279], [1281, 1319, 1354, 1354, 1749], [1769, 1769, 1823, 1823, 1913], [1915, 1915, 1972, 1972, 2796]], "test": "ok"}
{"id": "wtXGDl", "name": "Speed lines / lights", "author": "Neebz", "description": "This is my first ever shader. I had a hard time understanding everything, but used the videos from \"The Art of Code\" to great help. His line generation code is what I am using, so all credit to him for that method, as well as the noise generation.", "tags": ["lines", "space", "lights", "firstshader", "speed"], "likes": 8, "viewed": 424, "published": "Public", "date": "1558009879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define minOffset .01\n#define maxOffset .45\n#define simulationSpeed .5\n#define elementsToDisplay 100.\n#define maxDistFromCam 10.\n#define minDistFromCam 0.01\n#define glowAlpha .5\n\n//My first ever real shader!\n\n//Performance is not the best when the resolution (number of lines)\n//is increased too much, and I cannot find any way to improve it. If\n//anyone has some tips and/or tricks, I would be very greatful.\n\n//Any critique is welcome as I am a big noob in this field :)\n\nvec4 glowColor = vec4(0.);\n\n//Noise, 2 in 1 out\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n//Noise, 2 in 2 out\nvec2 N22(vec2 p){\n    float n = N21(p);\n\treturn vec2(n, (N21(p + n)));\n}\n\n//Creates a line between a and b, from texture coord at p\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    //Vector from texture coord to line start\n    vec2 pa = a - p;\t\t\t\n    //Vector from texture coord to line end\n    vec2 ba = a - b;\t\t\t\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * t);\n}\n\n//p - currentPoint, a - startPoint, b - endPoint\nvec3 LineVec(vec2 p, vec2 a, vec2 b){\n    //Create a line from a to b, using uv coords at p\n\tfloat d = DistLine(p, a, b);\t\t\t\t\n    //Distance to start point\n    float dFactor = length(p - a);\t\t\t    \n    //Multiplicative inverse distance to start point     \n    float pFactor = 1. / length(p - a);\t\t\t\n\t\n    //Calculate the size and deformation of the line\n    float mask \t\t= S(.03, 0.02, d * pFactor + dFactor * 0.01);\t\n    //Calculate the size and deformation of the glow\n\tfloat glow \t= S(.2, 0., d * pFactor + dFactor * .5);\t\t\t\n    \n\t//Return the result\n    return vec3(1) * mask + glow * vec3(glowColor.x * glowColor.a, glowColor.y * glowColor.a, glowColor.z * glowColor.a);\n}\n\nvec3 SpeedLine(vec2 uv, vec2 direction, float depth){\n\treturn LineVec(uv - direction * depth , vec2(0.0), direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; //Sets origin in the middle\n    uv.x *= iResolution.x/iResolution.y;  //\"Sqaures\" the uv input \n\n\t//Calculate the current frame's speed line glow color\n\tvec3 glowColorValue = 0.5 + 0.5*cos(iTime * 2. +uv.xyx+vec3(0,2,4));\n\tglowColor = vec4(glowColorValue, glowAlpha);\n\n    //Creates a time variable, adjusted for the sim speed\n    float t = (iTime * simulationSpeed)\t+ 1.;\t\t\n    //Creates an empty mask to contain the effect\n    vec3 vecMask = vec3(0);\t\t\t\t\t\t\t\n\n\t\n    //Loop to draw every line. \"Re-uses\" lines for simplicity\n    for(float u = 0.; u < 1.; u += 1./elementsToDisplay){\t\t\n        //Gets time decimals, between 0.0 and 1.0\n        float z = fract(t + u);\t\t\t\t\t\t\t\t\t\n        //Get time in seconds, only integers\n        float g = floor(t + u);\t\t\t\t\t\t\t\t\t\n        //Creates depth\n        float size = mix(maxDistFromCam, minDistFromCam, z);\t\n        //fades in the lines, accoring to the time they have existed / depth of the object\n        float fade = S(0., .5, z);\t\t\t\t\t\t\t\t\n\t\t\t\t\n        //Generate a random vector. Subtract .5 to make it between -.5 & .5\n\t\tvec2 randomPoint = (N22(vec2(g*u,-g*u)) - .5);\t\t\t\n        //Normalize the vector, to get an even size for all \n\t\tvec2 randomDirection = normalize(randomPoint);\t\t\t\n\t\t\n\t\t//Choose a spawn point for the lines, by using the direction they should spawn in\n\t\t//multiplied by a random factor, between two offset values\n\t\tvec2 spawnPosition = randomDirection * mix(minOffset, maxOffset, N21(vec2(u,u)));\n\n        //Calculates the uv offset (spawn distance from center)\n\t\tvec2 uvOffset = uv + spawnPosition;\t\t\n        //Calculates the direction the lines should fly\n        vec2 flyDirection = -spawnPosition;\t\t\n\n\t\t//Runs the function to create the lines, with the calculated values\n\t\tvec3 currentMask = SpeedLine(uvOffset * size, flyDirection, z) * fade;\n        //Applies the generated line to the line mask\n\t\tvecMask += currentMask;\t\t\n\t}\n    fragColor += vec4(vecMask, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 557, 575, 575, 673], [675, 695, 712, 712, 767], [769, 827, 866, 912, 1094], [1096, 1145, 1182, 1236, 1822], [1824, 1824, 1877, 1877, 1943], [1945, 1945, 2002, 2052, 4039]], "test": "ok"}
{"id": "wtXGRl", "name": "Liquid tail", "author": "avin", "description": "liquid experiment", "tags": ["2d", "liquid"], "likes": 2, "viewed": 413, "published": "Public API", "date": "1557258090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// !!! Size not whole number to get around the problem with lines glitch\n//\n#define SIZE 20.001\n#define BLACK_COL vec3(32,43,51)/255.\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 ouv = fragCoord.xy/iResolution.xy;\n    vec2 uv = fragCoord.xy/iResolution.y;    \n              \n    float m = 0.;\n    float t = iTime*2.2 + 100.;\n    \n    for(float i=0.; i<=1.0; i+=0.25){\n        vec2 iuv = uv + vec2(i*.05, 0.);\n        vec2 ruv = iuv*SIZE;    \n    \tvec2 id = ceil(ruv);\n        \n        for(float y=-1.; y<=1.; y+=1.){\n            for(float x=-1.; x<=1.; x+=1.0){\n                vec2 nuv = ruv + vec2(x,y);\n                vec2 nid = id + vec2(x,y);\n\n                nuv.y += t*2. * (rand(vec2(nid.x))*0.5+.5) * i; // move \n                nuv.y += ceil(mod(nid.x, 2.))*0.3 * t;\n\n                vec2 guv = fract(nuv); \n\n                nuv = floor(nuv) ;    \n                float g = length(guv - vec2(x,y));\n\n                float v = rand(nuv);\n                v *= step(0.8, v); \n                m += smoothstep(v,v-.8, g);\n            }\n        }    \t\n    }\n    \n    float om = m;    \n    m = m*.2 + step(1.25, m) *.2 + step(2.0, m) *.1;\n    \n    vec3 col = mix(BLACK_COL, vec3(om*.5, 1., 1.), m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 159, 159, 234], [237, 237, 294, 294, 1372]], "test": "ok"}
{"id": "wtXGWl", "name": "RaymarchTuto", "author": "Daalvehn", "description": "First try at raymarching", "tags": ["test", "raymarch"], "likes": 3, "viewed": 379, "published": "Public", "date": "1557996031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotation (float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sphere( vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat map(vec3 pos)\n{\n    pos.xy *= rotation(pos.z * .1);\n    pos.xy *= rotation(cos(iTime*10.) * 0.01);\n    pos.yz *= rotation(sin(iTime*3.) * 0.05);\n    pos.z += iTime ;\n\tpos.y += texture(iChannel0,abs(pos.xz) * .51).r;\n        \n    float size = 2.5;\n    vec3 altPos = pos;\n    altPos.yz *= rotation(iTime*.001);\n    altPos = mod(altPos, size) - size/2.;\n        \n    pos = mod(pos, size) - size/2.;\n    \n\tfloat radius = 0.5;\n    float geometry = sphere(pos, radius*0.5*sin(iTime * 5.0 + cos(pos.z)) * 0.5 +.5);\n    geometry = min(geometry, sdBox(pos, vec3(.1,.1,50) * radius));\n    geometry = min( geometry, sdBox(pos, vec3(50,.1,.1) * radius));\n    \n    geometry = min( geometry, sdBox(altPos*2., vec3(.1,50,.1) * radius*0.5));\n        \n    return geometry; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 position = fragCoord / iResolution.xy;\n    position = position * 2. - 1.;\n    position.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0., 0., -2.);\n    vec3 ray = normalize(vec3(position, 1.));\n    float shade = 0.0;\n    \n    const float rayStep = 40.;\n    \n    for (float index = 0.; index < rayStep; ++index)\n    {\n        float dist = map(eye) ;\n        if (dist < 0.0001)\n        {\n            shade = 1. - float(index) / rayStep;\n            break;\n        }\n        \n        eye += ray * dist;\n    }\n     \n\n    fragColor = vec4(shade );\n    fragColor.rg *= rotation(eye.z) ;\n    \n    //fragColor.gb *= rotation(eye.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 101], [103, 103, 142, 142, 177], [179, 179, 210, 210, 264], [266, 266, 287, 287, 1030], [1032, 1032, 1089, 1089, 1747]], "test": "error"}
{"id": "XlKcD1", "name": "FBM Test", "author": "maeln", "description": "Just some test around FBM.", "tags": ["test", "fbm"], "likes": 4, "viewed": 354, "published": "Public API", "date": "1557475481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.5;\n    //\n    // Loop of octaves\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 4.0;\n    //uv.x += iTime;\n    \n    float fbm1 = fbm(uv);\n    vec2 q = vec2(0.0, 0.0);\n    q.x = fbm(uv + 0.3*iTime);\n    q.y = fbm(uv + 0.05*iTime);\n    float fbm2 = fbm(uv + q);\n    float fbm3 = fbm(vec2(fbm1, fbm2));\n    \n    vec3 c = vec3(0.0);\n    c += fbm3;\n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [622, 622, 646, 668, 891], [893, 893, 950, 1000, 1418]], "test": "ok"}
{"id": "XsK3DV", "name": "ripples246987", "author": "Talon876", "description": "ripples", "tags": ["2d", "ripples"], "likes": 18, "viewed": 307, "published": "Public", "date": "1557426374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 color = vec3(0.1, 0.6, 0.4);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy / iResolution.xy * 10.0 - vec2(19.0);\n    vec2 i = p;\n    float c = 1.0;\n    float inten = 0.05;\n    \n    for (int n = 0; n < 8; n++) {\n    \tfloat t = iTime * (0.7 - (0.2 / float(n+1)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c += 1.0 / length(vec2(p.x / (2.0 * sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));\n    }\n    \n    c /= 8.0;\n    c = 1.5 - sqrt(pow(c, 2.0));\n    color.g = coords.x;\n    fragColor = vec4(color * c * c * c * c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsK3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 666]], "test": "ok"}
