{"id": "3d3GW4", "name": "Truchet_015151515", "author": "Toctave", "description": "b", "tags": ["a"], "likes": 4, "viewed": 62, "published": "Public", "date": "1597312138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    float scale = 10.;\n    vec2 uv = fragCoord/iResolution.y + iTime * .05;\n    \n    vec2 id = floor(uv * scale);\n    uv = fract(uv * scale) - .5;\n    //col += vec3(abs(uv), 0.);\n    \n    if (rand(id) < .5 * (1. + sin(iTime))) uv.x *= -1.;\n    //if (rand(id) < .5) uv.x *= -1.;\n    \n    float d = distance(uv, vec2(.5, .5) * sign(uv.x + uv.y + .0001));\n    col += smoothstep(.02, -.02, abs(d - .5) - .05);\n    \n    //col += 1. - smoothstep(-.01, .01, abs(uv.x + uv.y + (uv.x + uv.y < 0. ? .5 : -.5)) - .1);\n    //col += floor(uv.x + uv.y + 1.) - .5;\n    \n    bool border = max(abs(uv.x), abs(uv.y)) > .48;\n    //if (border) col = vec3(1, 0, 0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3GW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 863]]}
{"id": "3l2BWz", "name": "Red Julia", "author": "DaleyPaley", "description": "Yet another Julia fractal.", "tags": ["fractal", "julia", "mandelbrot"], "likes": 5, "viewed": 106, "published": "Public", "date": "1598684267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2\n\n#define product(a,b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define divide(a,b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n\nvec2 calcDist(vec2 Z0,vec2 C)\n{\n\tvec2 dC = vec2(1,0);\n    vec2 Z = Z0;\n\tvec2 dZ = dC;\n    float dotZ = 0.0;\n    int i=0;\n    for(; i<256; ++i)\n    {\n        dZ = product(Z,dZ)*2.0 + dC;\n        Z = product(Z,Z) + C;\n        dotZ = dot(Z,Z);\n        if(dotZ>1024.0) break;\n    }\n\n    if(i>=256) return vec2(-1.0,0);\n\n\tvec2 u = normalize(divide(Z,dZ));\n\tvec2 v = normalize(vec2(4,1));\n\tfloat h2 = 5.0;\n\tfloat diff = clamp((dot(u,v)+h2) / (1.2+h2), 0.0, 1.0);\n\n    float d = float(i) + 1.0 - log(log(length(Z))) / log(2.0);\n    d = 1.0 - d / 600.0;\n    d = pow(d,1.5);\n    return vec2(d,diff);\n}\n\nvec3 colour(float d)\n{\n return pow(vec3(d),vec3(0.5,5.0,5.0));\n//\treturn vec3(pow(smoothstep(0.0,1.0,d),1.5), pow(d,5.0), pow(d,5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ang = 5.5;\n    float scl = 0.5;\n    float sa = sin(ang)*scl*2.0, ca = cos(ang)*scl*2.0;\n    float aspect = iResolution.x/iResolution.y;\n    mat2 m = mat2(ca*aspect,sa*aspect,-sa,ca);\n    vec3 col = vec3(0.0);\n    vec2 C = vec2(-0.05+sin(iTime*1.37)*0.01,0.6805+cos(iTime)*0.01);\n    for(int y=0; y<AA; y++)\n    {\n        for(int x=0; x<AA; x++)\n        {\n            vec2 offset = (vec2(x,y)+0.5)/float(AA);\n            vec2 p = (uv + offset/vec2(iResolution.x,iResolution.y))*2.0-1.0;\n            vec2 Z0 = m*p;\n            vec2 d = calcDist(Z0,C);\n            if(d.x>=0.0) col += colour(d.x) * d.y;\n        }\n    }\n    fragColor = vec4(col/float(AA*AA), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 208, 208, 769], [771, 771, 793, 793, 907], [909, 909, 966, 966, 1678]]}
{"id": "3l2Bzw", "name": "2020 - 🤮 Revision", "author": "PixelPhil", "description": "So yeah... I made a shader on new year's eve 2020 and I think it deserved a small revision.", "tags": ["fire", "corona", "hell", "2020"], "likes": 18, "viewed": 343, "published": "Public API", "date": "1598614168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// 2020 - 🤮 Revision; by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n//\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// outputs a colored shape with a black border from distance field (RGBA premultiplied)\nvec4 border(vec3 color, float dist)\n{\n    vec4 res;\n    \n    float aa = 30. / iResolution.x;\n    \n    res.a = S(0.25 + aa, 0.25, dist); \n    res.rgb = color *  S(0.2, 0.2 - aa, dist); \n    \n    return res;\n}\n\n// Blend a premultiplied rbga color onto rgb\nvec3 premulBlend(vec4 src, vec3 dst)\n{\n    return dst * (1.0 - src.a) + src.rgb;\n}\n\n// Blend a premultiplied rbga color onto rgba (accurate alpha handling)\nvec4 premulBlend(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = dst.rgb * (1.0 - src.a) + src.rgb;\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a); \n    \n    return res;\n}\n\n\n// Distance field to the digit 0\nfloat zeroDst(vec2 uv)\n{\n    float dist;\n    \n    uv.y -= 0.5;\n    \n    if (uv.y > 0.0) // upper part\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    else if (uv.y > -1.1) // middle part\n    {\n        dist = abs(uv.x);\n    }\n    else  // lower part\n    {\n        uv.y += 1.1;\n        uv.y = pow(-uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    \n    return (abs(dist - 0.725) - 0.275);\n}\n\n// a box distance function\nfloat box(vec2 p, vec2 b )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// Distance field to the digit 2\nfloat twoDst(vec2 uv)\n{\n    uv.y -= 0.5;\n    \n    float topBar = box((uv + vec2(0.725, 0.0)) * vec2(1.0, 1.4), vec2(0.275, 0.0));\n    \n    if (uv.y > 0.0) // Top 'curve'\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tfloat dist = length(uv);\n        return max(-topBar, (abs(dist - 0.725) - 0.275));\n    }\n    else\n    {\n        float bottomBar = box((uv + vec2(0.0, 1.83)) * vec2(1.0, 1.4), vec2(0.95, 0.299));\n        \n        float two = min(topBar, bottomBar);\n        \n        if (uv.y > -1.8)\n        {    \n            float curve = (cos(uv.y * 2.0) - 1.0) * 0.7;\n            float x = 0.0 + uv.x - curve;\n            float mid = abs(uv.y + 0.4) * 0.7;\n            float x2 = 0.0 + uv.x - curve - mid * mid * 0.15 + 0.01;\n         \n            two = min(two, max(-x + 0.45, x2 -1.0));\n        }\n    \treturn two;\n    }\n\n}\n\n\n// Coordinate transform from global uv space to charcter space with poition and rotation\nvec2 letterUVs(vec2 uv, vec2 pos, float angle)\n{\n    float c = sin(angle);\n    float s = cos(angle);\n    float sc = 1.35;\n    uv -= pos;\n    return uv.x * vec2(s * sc, c) + uv.y * vec2(-c * sc, s);\n}\n\n\n// Borrowed from BigWIngs (random 1 -> 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat embersSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            vec2 cellUV = uv - offset + rnd.yz * 1.0;\n\n            float dst = length(cellUV);\n\n            //float radSeed = sin(iTime * 0.02 + rnd.x * 40.0);\n            //float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n            \n      \t\tfloat rad = rnd.y * 0.5;\n\n            float intensity = S(rad, rad - 0.8, dst);\n            \n            accum += intensity;\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat emberLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = embersSpot(cellUV, id, decimation);\n    \n    return intensity;\n}\n\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://www.iquilezles.org/www/articles/voronoise/voronoise.htm\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\n\n// Computes the fire background\nvec3 fire(vec2 uv)\n{\n    uv.x += sin(uv.y * 0.3 + iTime * 0.5)  + sin(uv.y * 0.8 + iTime * 1.23) * 0.25 - uv.y * 0.5;\n    \n    //accumulates several layers of bokeh\n    float fire = VoroNoise(uv * vec2(1.0, 0.3) - vec2(0.0, iTime), 0.0, 1.0) * 0.8;// * 0.2;\n    fire += VoroNoise(uv  * vec2(2.3, 1.68) - vec2(0.0, iTime * 3.0), 0.0, 1.0) * 0.5;\n    fire += VoroNoise(uv * vec2(4.3, 3.3) - vec2(0.0, iTime * 6.0), 0.0, 1.0) * 0.1;\n \n    \n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 1.6 - vec2(0.0, iTime) , 1.0) * 0.5;\n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 3.3 - vec2(0.0, iTime) , 1.0) * 0.25;\n    \n    //return vec3(fire);\n    \n    vec3 col = mix(vec3(2.0, 0.90, 0.55),  vec3(0.1, 0.0, 0.0), min(1.0, uv.y * 0.3 + fire));\n    \n    \n    return col;\n}\n\n\n\nfloat shadowsIntensity = 0.74;\nfloat shadowRadius = 1.1;\n\n\n\nvec3 reflection(vec3 normal, vec2 uv)\n{\n    uv.x = -uv.x;\n    uv += normal.xz * 3.0;\n    return fire(uv);\n}\n\n\nfloat flatPart = -0.06;\nfloat bevel = 0.065;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\n\n// Character two with outline and shadow (premultiplied RGBA)\nvec4 twoCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = twoDst(uv);\n    float dstR = smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, bevel);\n    vec3 n = normalize(vec3(dstR - clampedDst, 0.01, dstU - clampedDst));\n    \n    //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    col += reflection(n, uvIn) * 0.8;\n    \n    vec4 res = border(col, dst);\n    \n   \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, twoDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\n\n\n// Character zero with outline and shadow (premultiplied RGBA)\nvec4 zeroCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    //uv = letterUVs(uv, pos, angle);\n    \n    \n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = zeroDst(uv);\n    float dstR = smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, 0.01);\n    vec3 n = normalize(vec3(dstR - clampedDst, bevel, dstU - clampedDst));\n    \n   \n        //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    if (dst < 0.21)\n    {   \n   \t col += reflection(n, uvIn) * 0.8;\n    }\n    \n    vec4 res = border(col, zeroDst(uv));\n    \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, zeroDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\nvec3 red = vec3(0.9, 0.01, 0.16);\nvec3 yellow = vec3(0.96, 0.70, 0.19); // 248, 181, 51\nvec3 green = vec3(0.00, 0.63, 0.34);  //1, 162, 88\nvec3 blue = vec3(0.01, 0.57, 0.76);   //5, 142, 197\n\n// 2020 with colors and shadows (premultiplied rgba)\nvec4 yearCol(vec2 uv)\n{\n    float angle = sin(iTime) * 0.3;\n    \n    vec4 date = twoCol(uv, green, vec2(-2.5, 0.0), angle);\n    date = premulBlend(zeroCol(uv, green, vec2(-0.8, 0.0), angle), date);\n    date = premulBlend(twoCol(uv, green, vec2(0.8, 0.0), angle), date);\n    date = premulBlend(zeroCol(uv, green, vec2(2.5, 0.0), angle), date);\n    \n    return  date;\n}\n\n\n\nfloat corona(vec2 uv, float blur)\n{\n      \n    float angle = atan(-uv.x, -uv.y) / 6.2831 + 0.5;\n    \n    float copies = 9.0;\n    //float step = (1.0 / copies);\n    float quarter = floor(angle * copies + 0.5);\n    \n    float rot = -quarter * 6.2831 / copies;\n    \n    float s = sin(rot);\n    float c = cos(rot);\n    \n    uv *= mat2(c, s, -s, c);\n    \n    float dst = length(uv) - 0.4;\n    \n    \n    float dst2 = length((uv - vec2(0.0, 0.63)) * vec2(1.0, 1.2)) - 0.13;\n    \n    if (uv.y < 0.63)\n    {\n        dst = min(dst, abs(uv.x) - 0.06);// + 0.1, 0.1);\n    }\n    \n    dst = smin(dst, dst2, 0.1);\n    \n    return S(-0.01 - blur, 0.01 + blur , dst);\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat coronaSpot(vec2 uv, vec2 id)\n{\n    float accum = 1.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            float t = iTime;\n            \n            vec2 cellUV = uv - offset + rnd.yz * 1.0 + vec2(sin(t * (rnd.x + 0.3)), cos(t * (rnd.z + 0.2))) * 0.2;\n\n            \n            float rot = rnd.y * rnd.x * 456.0 + iTime * (0.3 * (rnd.y - 0.5)) ;\n            float c = cos(rot);\n            float s = sin(rot);\n            cellUV *= mat2(c,s,-s,c);\n\n            float dst = rnd.y;\n            \n            float intensity = corona(cellUV * (1.5 + dst), dst * 0.2);\n            \n            accum *= mix(intensity, 1.0, dst);\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat coronaLayer(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    return coronaSpot(cellUV, id);\n}\n\n\n\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.0;\n    \n    vec4 dateCol =  yearCol(uv); // 2020\n    \n    vec3 bg = fire(uv);\n    \n    \n    float corona = coronaLayer(uv * 1.1);\n    \n    \n    bg.rgb += mix(0.0,  corona, S(-2.0, 7.0, uv.y)) * 0.8;\n \n    \n    //add a bit of light\n    dateCol.rgb -= uv.y * 0.15 * dateCol.a;\n    bg.rgb -= uv.y * 0.03;\n    \n    // blend 2020 and BG\n    vec3 col = premulBlend(dateCol, bg);\n    \n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2Bzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[441, 529, 566, 566, 736], [738, 783, 821, 821, 865], [867, 939, 977, 977, 1113], [1116, 1149, 1173, 1173, 1556], [1558, 1585, 1613, 1613, 1689], [1691, 1724, 1747, 1747, 2545], [2548, 2637, 2685, 2685, 2836], [2839, 2881, 2900, 2900, 2982], [2985, 3039, 3093, 3093, 3824], [3826, 3869, 3914, 3914, 4074], [4078, 4078, 4100, 4100, 4251], [4253, 4320, 4368, 4368, 4846], [4849, 4881, 4901, 4901, 5639], [5703, 5703, 5742, 5742, 5810], [5859, 5859, 5900, 5900, 5993], [5995, 5995, 6036, 6036, 6125], [6129, 6191, 6248, 6248, 6921], [6926, 6989, 7047, 7085, 7820], [8015, 8068, 8091, 8091, 8435], [8439, 8439, 8474, 8474, 9091], [9094, 9148, 9184, 9184, 10061], [10063, 10106, 10134, 10134, 10244], [10249, 10270, 10327, 10377, 10978]]}
{"id": "3l2fD1", "name": "Pillar-Studded Landscape", "author": "Giraugh", "description": "practicing making terrain", "tags": ["raymarch"], "likes": 0, "viewed": 45, "published": "Public", "date": "1598860487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Slightly Better Raymarcher */\n/* By Giraugh */\n\n#define MAX_STEPS 50\n#define MAX_DIST 1000.\n#define SURF_DIST 0.1\n#define AMBIENT_LIGHT 0.\n#define SUN_STRENGTH 1.\n#define FOG_DENSITY .01\n#define FOG_COL vec3(.45, .55, .65)\n#define SKY_COL vec3(0.5,0.6,0.8)\n#define SUN_COL vec3(1.0,0.9,0.9)\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv) {\n    uv *= .02;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    f += 0.01125*noise( uv ); uv = m*uv;\n    f += 0.005*noise( uv ); uv = m*uv;\n    return f;\n}\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nfloat DBox(vec3 p, vec3 o, vec3 r) {\n \treturn length(max(abs(p - o) - r, 0.));   \n}\n\nfloat Terrain(vec3 p) {\n \tfloat a = 7.;\n    vec2 samp = p.xz - vec2(-5,0);// + vec2(sin(iTime), cos(iTime));\n    //samp += 3. * fbm(samp);\n    samp.y += 4. * iTime;\n    return a * fbm(samp);\n}\n\nfloat GetBuildingDist(vec3 point) {\n    vec3 bp = point;\n    bp.z -= 60.;\n    bp.z += 4. * iTime;\n    bp.x += 40.;\n    bp.z = mod(bp.z + 100., 200.) - 100.;\n    bp.x = mod(bp.x + 40., 80.) - 40.;\n    float boxD = DBox(vec3(bp.x, 0, bp.z), vec3(0), vec3(4., 1., 4.));\n    return boxD;\n}\n\n// Return the distance to the nearest point in the scene\n// from (point)\nfloat GetDist(vec3 point) {\n    // Ground\n    float planeD = point.y - Terrain(point);\n    \n    \n    // Trees\n    vec3 tp = point;\n    tp.z -= 12.;\n    tp.z += 4. * iTime;\n    tp.x += 16. * fbm(floor((tp.xz - .4) / .8));\n    tp.z += 16. * fbm(floor((tp.xz - .4) / .8));\n    tp.x = mod(tp.x + .4, .8) - .4;\n    tp.z = mod(tp.z + .4, .8) - .4;\n\ttp.y -= Terrain(point);\n    float treeN = fbm(vec2(-80., 380. - 4. * iTime));\n    float s = .15;\n    s *= smoothstep(-1., 1., Terrain(point));\n    s *= (1. - smoothstep(1.6, 2.1, Terrain(point)));\n    tp.y -= s * .75;\n    float treeD = length(tp) - s;\n    \n    \n    // Buildings\n    float boxD = GetBuildingDist(point);\n    \n    return min(min(planeD, treeD), boxD);\n}\n\n// March a ray forwards into the scene determined by (GetDist)\n// Returns the distance the ray travelled before getting\n// below (SURF_DIST) distance from a surface or too far away \nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayOrigin + rayDirection * d;\n        float d_delta = GetDist(p);\n        d += d_delta;\n        if (d > MAX_DIST || abs(d_delta) < SURF_DIST) break; \n    }\n    return d;\n}\n\n// Calculate the surface normal at (point)\n// can reduce (off) to improve accuracy\nvec3 GetNormal(vec3 point) {\n    float d = GetDist(point);\n    float off = .01;\n    vec3 n = vec3(\n    \td - GetDist(point - vec3(off,0,0)),\n        d - GetDist(point - vec3(0,off,0)),\n        d - GetDist(point - vec3(0,0,off))\n    );\n    return normalize(n);\n}\n\n\n// Get how lit (not in shadow) the given point is. (With Penumbra)\nfloat GetShadowSoft(vec3 ro, vec3 rd, float dmin, float dmax, float k) {\n    float res = 1.;\n    for (float d = dmin; d < dmax; ) {\n        float sceneDist = GetDist(ro + rd * d);\n        if (sceneDist < SURF_DIST) return AMBIENT_LIGHT;\n        d += sceneDist;\n        res = min(res, k * sceneDist / d);\n    }\n    return min(1., res + AMBIENT_LIGHT);\n}\n\n// Get how lit (not in shadow) the given point is.\nfloat GetShadow(vec3 ro, vec3 rd, float dmin, float dmax) {\n    for (float d = dmin; d < dmax; ) {\n        float sceneDist = GetDist(ro + rd * d);\n        if (sceneDist < SURF_DIST) return 0.0;\n        d += sceneDist;\n    }\n    return 1.;\n}\n\n// Determine degree of lighting (0 to 1) at (pos) by (lightPos)\nfloat GetLightingPoint(vec3 point, vec3 lightPos) {\n    vec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    float diff = clamp(dot(l, n), 0., 1.);\n    \n    float shadow = GetShadowSoft(point, l, SURF_DIST * 30., length(lightPos - point), 25.);\n    \n    return diff * shadow;\n}\n\n\nfloat GetLightingSun(vec3 point, vec3 sunDir) {\n    vec3 n = GetNormal(point);\n    float diff = clamp(dot(sunDir, n), 0., 1.);\n    float shadow = GetShadowSoft(point, sunDir, SURF_DIST * 30., MAX_DIST, 25.);\n    return diff * shadow;\n}\n\nvec3 GetFog(vec3 col, float dist) {\n    float fogAmount = 1. - exp(-dist * FOG_DENSITY);\n    return mix(col, FOG_COL, fogAmount);\n}\n\nvec3 GetFogSky(vec3 col, float dist, vec3 rayDir, vec3 sunDir) {\n    float fogAmount = 1. - exp(-dist * FOG_DENSITY);\n    float sunAmount = .5 * max(0., dot(rayDir, sunDir));\n    vec3 fogCol = mix(SKY_COL, SUN_COL, pow(sunAmount, 1.));\n    return mix(col, fogCol, fogAmount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (square) (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    // Declare camera position in terms of ray origin and direction\n    vec3 rayOrigin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    rayOrigin.y = max(7., Terrain(rayOrigin) + 2.);\n    \n    // RayMarch to find point\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    // Determine colour\n\tvec3 col = vec3(0, 0, 0);\n    \n    float yy = hitPoint.y;\n    float ff = 90.;\n    yy += .7 * fbm(ff * hitPoint.xz + vec2(0, 4. * ff * iTime));\n    \n    col += (1. - smoothstep(-1., 0., yy)) * vec3(1, 1, 0);\n    col += (1. - smoothstep(-.5, 1.2, yy)) * vec3(0, 1, 0); \n    col += (smoothstep(0., 1., yy)) * vec3(0, .7, .2);\n    //col += (smoothstep(1.4, 1.8, yy)) * vec3(1, 1, 1);\n    \n    if (yy > 1.6) {\n        col = mix(col, vec3(1), smoothstep(1.7, 2.2, yy));\n    }\n    \n    if (hitPoint.y <= -1.) {\n     \tcol = mix(col, .4 * SKY_COL, min(1., pow(-hitPoint.y - 1., .2)));\n    }\n    \n    // determine if is a building\n    float bd = GetBuildingDist(hitPoint + 7. * SURF_DIST * rayDirection);\n    if (bd <= 0.) {\n        col = vec3(.1, .1, .12);\n    }\n    \n    \n    // Determine lighting\n    vec3 sunDir = vec3(-1, -.3, 0); //vec3(-1, -.6, -0.3);\n    vec3 lightPos = vec3(2. * cos(iTime), 4, 2. * sin(iTime));\n    float lighting = 3. * AMBIENT_LIGHT + GetLightingSun(hitPoint, -sunDir);\n    col *= min(1., lighting);\n    \n    if (hitPoint.y <= -1.) {\n     \tcol = mix(col, SKY_COL, max(0., dot(rayDirection, -sunDir)));   \n    }\n    \n    // Fog\n    col = GetFogSky(col, dist, rayDirection, -sunDir);\n    \n    // Ouput colour at full transparency\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 295, 316, 316, 431], [433, 433, 459, 459, 938], [940, 940, 960, 960, 1281], [1283, 1283, 1302, 1302, 1380], [1382, 1382, 1418, 1418, 1465], [1467, 1467, 1490, 1490, 1659], [1661, 1661, 1696, 1696, 1946], [1948, 2021, 2048, 2062, 2732], [2734, 2916, 2967, 2967, 3216], [3218, 3301, 3329, 3329, 3561], [3564, 3631, 3703, 3703, 3983], [3985, 4036, 4095, 4095, 4276], [4278, 4342, 4393, 4393, 4639], [4642, 4642, 4689, 4689, 4877], [4879, 4879, 4914, 4914, 5010], [5012, 5012, 5076, 5076, 5289], [5291, 5291, 5348, 5407, 7135]]}
{"id": "3l2fzh", "name": "lr94/ditheringWithNoise", "author": "lucasrumney94", "description": "dithering with noise \nhttps://www.youtube.com/watch?v=RdN06E6Xn9E", "tags": ["dithering"], "likes": 1, "viewed": 61, "published": "Public", "date": "1598321639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_BANDS 256.0f\n#define NOISE_INTENSITY 1.0f/20.0f;\n\nfloat rand(float n){\n    return fract(sin(n) * 982457.4908571);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // create banding so that I can test dithering effectiveness\n    vec3 col = vec3(trunc((uv.x+1./NUM_BANDS)*NUM_BANDS)/NUM_BANDS);\n    \n    // Isolate the middle and apply noise dithering\n    float middlethird = step(uv.y, 2./3.) * step(1./3., uv.y);  \n    float random =  rand(iTime + fragCoord.x * fragCoord.y);\n    // scale the noise to be [-1, 1] so the average perceived value is the same\n\tfloat noise = ((random*2.0f)-1.0f)*NOISE_INTENSITY;\n    \n    col += noise*middlethird; \n    \n    // bottom is a smooth gradient\n    float bottomthird = step(uv.y, 1./3.);\n    col *= (1.0-bottomthird);\n    col += bottomthird*uv.x;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 82, 82, 127], [129, 129, 186, 236, 967]]}
{"id": "3l2fzw", "name": "Polar Weave Pattern - simple 2", "author": "FabriceNeyret2", "description": "golfed variant of [url]https://shadertoy.com/view/wtBfRm[/url]\nreproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\n- s: change s = 2Pi / N by any N you like\n- D: without final .5 is nice too", "tags": ["2d", "repetition", "pattern", "polar", "2tweets", "short", "weave"], "likes": 7, "viewed": 156, "published": "Public API", "date": "1598550461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// golfed variant of https://shadertoy.com/view/wtBfRm\n// < 2 tweets if no time and injecting r.\n// reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D(S) ( m = r*abs(  sin(s/2.)                        \\\n                          - sqrt( l*l + 1. - 2.*l* cos( S l * cos(a-s/2.) > S cos(s/2.) ? a-s : a ) ) \\\n                        ) -.1,                              \\\n               m = clamp(1.- R.y/4.* m, 0.,1.),             \\\n               m * fract(S.5*A/s) )                        //\n            /* m * ( .2+fract(S A/s) ) ) */                //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float s = 6.28 / 8., r = .5, m, T,\n          A = atan(U.y,U.x) + iTime/2.,\n          a = mod(A,s),\n          l = length(U) / R.y / r;\n    O += D( );  T = 1.-m;\n    O += D(-) * T;}                                        /*\n\n\n\n\n\n// --- 293 chars\n\n#define D(S) ( m = abs(   sin(s/2.)                    \\\n                        - sqrt( l*l + 1. - 2.*l*cos( S l * cos(a-s/2.) > S cos(s/2.) ? a-s : a ) ) ),  \\\n               m = clamp(1.- R.y/4.* (r*m-.1), 0.,1.), \\\n               T * m * fract(S.5*A/s) )               //\n#define mainImage(O,u)                                 \\\n    vec2  R = iResolution.xy,                          \\\n          U = u+u - R;                                 \\\n    float s = 6.28 / 8., r = .5, m, T = 1.,            \\\n          A = atan(U.y,U.x) + iTime/2.,                \\\n          a = mod(A,s),                                \\\n          l = length(U) / R.y / r;                     \\\n    O += D();  T -= m;                                 \\\n    O += D(-)                                         /*\n\n\n\n\n\n// --- 311 chars\n\n#define D(S) ( U = l *cos( ( S( l * cos(a-s/2.) - r*cos(s/2.) ) > 0.? a-s : a ) + vec2(0,11) ),\\\n               U.x -= r,     m = abs( length(U) - r*sin(s/2.) ), \\\n               m = clamp(1.- R.y/4.* (m-.1), 0.,1.),             \\\n               T * m * fract(S.5*A/s) )                         //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, m, T = 1.,      \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y;                   \\\n    O += D();  T -= m;                           \\\n    O += D(-)                                   /*\n\n\n\n\n\n// --- 324 chars\n\n#define D(c) ( U = l *cos( ( l * cos(a-s/2.) c r*cos(s/2.) ? a-s : a ) + vec2(0,11) ),\\\n               d = abs( length(U-vec2(r,0) ) - r*sin(s/2.) ), \\\n               m = clamp(1.- R.y/4.* (d-.1),0.,1.),           \\\n               T * m * A )                                   //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, d, m, T = 1.,   \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y;                   \\\n    A = fract(.5*A/s);                           \\\n    O += D(>);                                   \\\n    A = 1.-A;  T = 1.-m;                         \\\n    O += D(<)                                   /*\n\n\n\n\n\n// --- 331 chars\n\n#define D(c) ( U = l *cos( a+ ( c ? -s : 0. ) + vec2(0,11) ), \\\n               d = abs( length(U-vec2(r,0)) - r*sin(s/2.) ),  \\\n               m = clamp(1.- R.y/4.* (d-.1),0.,1.),           \\\n               T * m * A )                                   //\n#define mainImage(O,u)                           \\\n    vec2  R = iResolution.xy,                    \\\n          U = u+u - R;                           \\\n    float s = 6.28 / 8., r = .5, d, m, T = 1.,   \\\n          A = atan(U.y,U.x) + iTime/2.,          \\\n          a = mod(A,s),                          \\\n          l = length(U) / R.y,                   \\\n          L = l * cos(a-s/2.) / cos(s/2.);       \\\n    A = fract(.5*A/s);                           \\\n    O += D(L>r);                                 \\\n    A = 1.-A;  T = 1.-m;                         \\\n    O += D(L<r)                                 /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2fzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[594, 597, 633, 633, 870]]}
{"id": "3lBBDh", "name": "landline", "author": "lennyjpg", "description": "alksdjfjasdf", "tags": ["line", "spiral", "phone", "cable"], "likes": 3, "viewed": 189, "published": "Public API", "date": "1598746293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.y,\n        u = vec2(fract(uv.x * 3. - iTime * .2), uv.y * 1.6 - .3);\n    if(u.y > .5){\n        u.x = abs(u.x - .5);\n    }\n    float k = length(u - .5),\n        e = smoothstep(k, k * .99, .5);\n    vec3 a = vec3(1.,0.,0.),\n        b = u.y > .5 ? vec3(1.) : vec3(0.,0.,.2);\n    O = vec4(mix(a,b,e),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 373]]}
{"id": "3lBBzm", "name": "Bulma-by @301z", "author": "jorge2017a1", "description": "Bulma-by @301z", "tags": ["bulmaby301z"], "likes": 28, "viewed": 286, "published": "Public", "date": "1598495551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by @301z\n// best viewed in 0.5\n\n\nvec3 rgb(int r, int g, int b) {\n  return vec3(float(r) / 255.0, float(g) / 255.0, float(b) / 255.0);\n}\n\n\nfloat borderWidth ;\nconst vec3 borderColor = vec3(32.0/255.0, 32.0/255.0, 32.0/255.0);\nconst vec3 hairColor0 = vec3(151.0/255.0, 200.0/255.0, 234.0/255.0);\nconst vec3 hairColor1 = vec3(77.0/255.0, 135.0/255.0, 192.0/255.0);\nconst vec3 hairColor2 = vec3(58.0/255.0, 103.0/255.0, 151.0/255.0);\nconst vec3 faceColor0 = vec3(0.0/255.0, 223.0/255.0, 204.0/255.0);\nconst vec3 faceColor1 = vec3(209.0/255.0, 173.0/255.0, 159.0/255.0);\nconst vec3 faceColor2 = vec3(183.0/255.0, 148.0/255.0, 133.0/255.0);\nconst vec3 eyeColor0 = vec3(145.0/255.0, 164.0/255.0, 176.0/255.0);\nconst vec3 eyeColor1 = vec3(207.0/255.0, 216.0/255.0, 218.0/255.0);\nconst vec3 eyeColor2 = vec3(255.0/255.0, 255.0/255.0, 255.0/255.0);\nconst vec3 eyeColor3 = vec3(0, 0, 0);\nvec3 eyeColor4 = hairColor0;\nvec3 eyeColor5 = hairColor2;\nvec3 eyeColor6 = hairColor1;\nconst vec3 mouthColor0 = vec3(78.0/255.0, 53.0/255.0, 40.0/255.0);\nconst vec3 mouthColor1 = vec3(152.0/255.0, 78.0/255.0, 69.0/255.0);\nconst vec3 mouthColor2 = vec3(170.0/255.0, 92.0/255.0, 83.0/255.0);\nconst vec3 backgroundColor = vec3(51.0/255.0, 124.0/255.0, 221.0/255.0);\n\nvec2 fragCoordd;\n\nvec2 position() \n{\n  return vec2((fragCoordd.x - iResolution.x), fragCoordd.y) / iResolution.y;\n}\n\nfloat cross2(vec2 v0, vec2 v1) {\n  return v0.x * v1.y - v0.y * v1.x;\n}\n\nfloat circle(vec2 centre, float radius) {\n  return distance(centre, position()) - radius;\n}\n\nfloat ellipse(vec2 focus0, vec2 focus1, float radius) {\n  vec2 p = position();\n  return distance(p, focus0) + distance(p, focus1) - distance(focus0, focus1) * radius;\n}\n\nbool inside(float f) {\n  return f < -borderWidth;\n}\n\nbool outside(float f) {\n  return f > borderWidth;\n}\n\nbool hair0(out vec3 color) {\n  float upper = circle(vec2(-1.06, 0.795), 0.64);\n  float lower = circle(vec2(-0.851, -0.011), 1.001);\n  float right = circle(vec2(-0.84, 0.74), 0.5);\n  if (outside(upper) || inside(lower) || inside(right))\n    return false;\n  if (!inside(upper) || !outside(lower))\n    color = borderColor;\n  else {\n    float upper = circle(vec2(-1.01, 0.74), 0.6);\n    float lower = circle(vec2(-1.07, 0.13), 0.77);\n    color = (inside(upper) && outside(lower)) ? hairColor1 : hairColor0;\n  }\n  return true;\n}\n\nbool hair1(out vec3 color) {\n  float upper = circle(vec2(-0.84, 0.74), 0.5);\n  float lower = circle(vec2(-1.8, 1.62), 0.9);\n  if (outside(upper) || outside(lower))\n    return false;\n  color = (inside(upper) && inside(lower)) ? hairColor1 : borderColor;\n  return true;\n}\n\nbool hair2(out vec3 color) {\n  float upper = circle(vec2(-0.695, 0.74), 0.5);\n  float lower = circle(vec2(-3.5, 8.46), 8.1);\n  if (outside(upper) || outside(lower))\n    return false;\n  if (!inside(upper) || !inside(lower))\n    color = borderColor;\n  else {\n    float left = circle(vec2(-0.675, 0.78), 0.502);\n    if (outside(left))\n      color = hairColor0;\n    else {\n      float right = circle(vec2(-1.77, 2.99), 2.4);\n      color = inside(right) ? hairColor1 : hairColor2;\n    }\n  }\n  return true;\n}\n\nbool hair3a(out vec3 color) {\n  float left = circle(vec2(-2.77, 1.86), 2.5);\n  float right = circle(vec2(-1.544, 1.777), 1.44);\n  if (inside(left) || outside(right))\n    return false;\n  color = hairColor1;\n  return true;\n}\n\nbool hair3b(out vec3 color) {\n  float upper = circle(vec2(-2.654, 1.92), 2.39);\n  float lower = circle(vec2(-1.44, 1.777), 1.388);\n  float right = circle(vec2(-0.5, 0.5), 0.515);\n  if (inside(upper) || outside(lower) || outside(right))\n    return false;\n  color = (outside(upper) && inside(lower)) ? hairColor2 : borderColor;\n  return true;\n}\n\nbool hair4a(out vec3 color) {\n  vec2 p0 = vec2(1.332, 0.8), p1 = vec2(-1.5, 0.36);\n  float r0 = 1.7, r1 = distance(p0, p1) - r0;\n  float left0 = circle(p0, r0), left1 = circle(p1, r1);\n  float right = circle(vec2(-0.5, 0.97), 0.78);\n  bool upper = cross2(position() - p1, p0 - p1) < 0.0;\n  if ((upper && outside(left0)) || (!upper && inside(left1)) || outside(right))\n    return false;\n  color = ((upper && inside(left0)) || (!upper && outside(left1))) && inside(right) ? hairColor2 : borderColor;\n  return true;\n}\n\nbool hair4b(out vec3 color) {\n  vec2 p0 = vec2(0.504, 0.91), p1 = vec2(-1.7, 0.25);\n  float r0 = 0.79, r1 = distance(p0, p1) - r0;\n  float left0 = circle(p0, r0), left1 = circle(p1, r1);\n  float right = circle(vec2(-0.62, 0.98), 0.78);\n  bool upper = cross2(position() - p1, p0 - p1) < 0.0;\n  if ((upper && outside(left0)) || (!upper && inside(left1)) || outside(right))\n    return false;\n  color = hairColor1;\n  return true;\n}\n\nbool hair5(out vec3 color) {\n  float left = circle(vec2(1.13, -1.07), 2.02);\n  float right = circle(vec2(-1.505, 1.15), 1.66);\n  if (outside(left) || outside(right))\n    return false;\n  if (!inside(left) || !inside(right))\n    color = borderColor;\n  else {\n    float upper = circle(vec2(1.205, 0.28), 1.58);\n    float lower = circle(vec2(-0.57, 0.78), 0.69);\n    float right = circle(vec2(-1.52, 1.10), 1.6);\n    color = ((inside(upper) && inside(lower)) || outside(right)) ? hairColor2 : hairColor1;\n  }\n  return true;\n}\n\nbool layer0(out vec3 color) {\n  if (hair3a(color))\n    return true;\n  if (hair2(color))\n    return true;\n  if (hair3b(color))\n    return true;\n  if (hair4b(color))\n    return true;\n  if (hair4a(color))\n    return true;\n  if (hair5(color))\n    return true;\n  if (hair1(color))\n    return true;\n  return hair0(color);\n}\n\nbool face0(out vec3 color) {\n  if (inside(circle(vec2(-0.7, 0.0), 0.2)))\n    color = faceColor1;\n  else {\n    vec2 p3 = vec2(-1.02, 0.25);\n    float r3 = 0.41, c3 = circle(p3, r3);\n    vec2 p2 = vec2(-1.12, 0.203);\n    float r2 = r3 - distance(p2, p3), c2 = circle(p2, r2);\n    vec2 p1 = vec2(-2.7, 0.87);\n    float r1 = distance(p1, p2) - r2, c1 = circle(p1, r1);\n    vec2 p0 = vec2(-0.5, 0.66);\n    float r0 = distance(p0, p1) - r1, c0 = circle(p0, r0);\n    if (cross2(position() - p0, p1 - p0) > 0.0) {\n      if (outside(c0))\n        return false;\n      color = inside(c0) ? (inside(circle(vec2(-1.8, 1.57), 0.9)) ? faceColor2 : faceColor1) : borderColor;\n   } else if (cross2(position() - p1, p2 - p1) < 0.0) {\n      if (inside(c1))\n        return false;\n      color = outside(c1) ? (((inside(circle(vec2(-0.95, 0.31), 0.49))) && (c1 < 0.035)) ? faceColor0 : faceColor1) : borderColor;\n    } else if (cross2(position() - p2, p3 - p2) < 0.0) {\n      if (outside(c2))\n        return false;\n      color = inside(c2) ? ((c2 > -0.035) ? faceColor0 : faceColor1) : borderColor;\n    } else {\n      if (outside(c3))\n        return false;\n      color = inside(c3) ? ((c3 > -0.035) ? faceColor0 : faceColor1) : borderColor;\n    }\n  }\n  return true;\n}\n\nbool face1(out vec3 color) {\n  float upper = circle(vec2(-0.6, 0.72), 0.5);\n  float lower = circle(vec2(-3.5, 8.004), 7.7);\n  if (outside(upper) || outside(lower))\n    return false;\n  color = faceColor2;\n  return true;\n}\n\nbool face2(out vec3 color) {\n  float upper = circle(vec2(-3.182, 1.75), 2.8);\n  float lower = circle(vec2(-1.44, 1.777), 1.388);\n  if (inside(upper) || outside(lower))\n    return false;\n  color = faceColor2;\n  return true;\n}\n\nbool face3(out vec3 color) {\n  vec2 p0 = vec2(1.332-0.044, 0.8), p1 = vec2(-1.5, 0.36);\n  float r0 = 1.7, r1 = distance(p0, p1) - r0;\n  float left0 = circle(p0, r0), left1 = circle(p1, r1);\n  bool upper = cross2(position() - p1, p0 - p1) < 0.0;\n  if ((upper && outside(left0)) || (!upper && inside(left1)))\n    return false;\n  color = faceColor2;\n  return true;\n}\n\nbool layer1(out vec3 color) {\n  if (outside(circle(vec2(-1.2, 0.7), 1.0)))\n    return false;\n  if (face3(color))\n    return true;\n  if (face2(color))\n    return true;\n  if (face1(color))\n    return true;\n  return face0(color);\n}\n\nbool layer2(out vec3 color) {\n  if (inside(circle(vec2(0.0, 0.0), 0.5))) {\n    color = hairColor1;\n    return true;\n  }\n  vec2 p2 = vec2(-0.42, -0.1);\n  float r2 = 1.14, c2 = circle(p2, r2);\n  vec2 p1 = vec2(-3.5, 1.56);\n  float r1 = distance(p1, p2) - r2, c1 = circle(p1, r1);\n  bool b1 = inside(circle(vec2(-0.847, 0.5), 0.55));\n  bool b2 = inside(circle(vec2(-0.94, -0.06), 0.56));\n  if (cross2(position() - p1, p2 - p1) < 0.0) {\n    if (inside(c1))\n      return false;\n    color = outside(c1) ? (b1 ? hairColor1 : hairColor0) : borderColor;\n  } else {\n    if (outside(c2))\n      return false;\n    color = inside(c2) ? ((b1 || b2) ? hairColor1 : hairColor0) : borderColor;\n  }\n  return true;\n}\n\nbool leftEye0(out vec3 color) {\n  float top = circle(vec2(-0.866, 0.4899), 0.428);\n  float left = circle(vec2(-0.986, 0.6), 0.3);\n  float bottom = circle(vec2(-1.14, 0.604), 0.2);\n  float right = circle(vec2(-1.54, 0.7), 0.51);\n  if (outside(top) || outside(left) || outside(bottom) || outside(right))\n    return false;\n  if (outside(circle(vec2(-0.919, 0.53), 0.344)))\n    color = borderColor;\n  else if (outside(circle(vec2(-0.918, 0.5), 0.338)))\n    color = eyeColor0;\n  else if (inside(circle(vec2(-1.05, 0.77), 0.1)) && outside(circle(vec2(-1.101, 0.67), 0.08)))\n    color = eyeColor0;\n  else\n    color = eyeColor1;\n  return true;\n}\n\nbool leftEye1(out vec3 color) {\n  if (outside(circle(vec2(-1.0, 0.7), 0.08))\n      || inside(circle(vec2(-1.092, 0.667), 0.1))\n        || inside(circle(vec2(-0.919, 0.8), 0.1)))\n    return false;\n  if (outside(circle(vec2(-1.101, 0.69), 0.1)) && outside(circle(vec2(-0.879, 0.9), 0.2)))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool leftEye2(out vec3 color) {\n  if (outside(ellipse(vec2(-1.156, 0.435), vec2(-1.091, 0.75), 1.074)))\n    return false;\n  if (inside(ellipse(vec2(-1.156, 0.636), vec2(-1.122, 0.726), 1.16))) {\n    color = eyeColor2;\n    return true;\n  }\n  if (inside(ellipse(vec2(-1.121, 0.593), vec2(-1.116, 0.614), 1.168))\n     || inside(ellipse(vec2(-1.113, 0.488), vec2(-1.111, 0.505), 1.23))) {\n    color = eyeColor4;\n    return true;\n  }\n  if (inside(ellipse(vec2(-1.154, 0.45), vec2(-1.1, 0.75), 1.05))\n      && inside(ellipse(vec2(-1.163, 0.445), vec2(-1.121, 0.552), 1.3))\n        && outside(ellipse(vec2(-1.13, 0.501), vec2(-1.116, 0.614), 1.177))) {\n    color = eyeColor6;\n    return true;\n  }  if (inside(ellipse(vec2(-1.152, 0.445), vec2(-1.091, 0.75), 1.067))\n      && inside(ellipse(vec2(-1.163, 0.445), vec2(-1.121, 0.565), 1.3))\n        && outside(ellipse(vec2(-1.128, 0.52), vec2(-1.116, 0.614), 1.177))) {\n    color = eyeColor5;\n    return true;\n  }\n  color = eyeColor3;\n  return true;\n}\n\nbool leftEye(out vec3 color) {\n  if (leftEye2(color))\n    return true;\n  if (leftEye1(color))\n    return true;\n  return leftEye0(color);\n}\n\nbool rightEye0(out vec3 color) {\n  if (outside(circle(vec2(-0.609, 0.542), 0.129))\n    && inside(circle(vec2(-0.61, 0.584), 0.101))) {\n    color = borderColor;\n    return true;\n  }\n  if (inside(circle(vec2(-2.654, 1.92), 2.39))\n    || outside(circle(vec2(-0.685, 0.42), 0.285))\n      || inside(circle(vec2(-0.683, 0.432), 0.262))\n        || outside(circle(vec2(-0.638, 0.516), 0.3)))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool rightEye1(out vec3 color) {\n  if (outside(circle(vec2(-2.654, 1.92), 2.39))\n    || outside(circle(vec2(-0.627, 0.583), 0.11))\n      || inside(circle(vec2(-0.65, 0.582), 0.11)))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool rightEye2(out vec3 color) {\n  if (outside(circle(vec2(-0.57, 0.38), 0.3))\n    || outside(circle(vec2(-0.166, 0.34), 0.59))\n      || outside(circle(vec2(-0.34, 0.6), 0.505))\n        || outside(circle(vec2(-0.47, 0.763), 0.54))\n          || outside(circle(vec2(-0.638, 0.52), 0.3))\n            || outside(circle(vec2(-0.685, 0.42), 0.285)))\n    return false;\n  color = inside(ellipse(vec2(-0.625, 0.23), vec2(-0.59, 0.576), 1.38)) ? eyeColor1 : eyeColor0;\n  return true;\n}\n\nbool rightEye3(out vec3 color) {\n  if (outside(ellipse(vec2(-0.61, 0.29), vec2(-0.538, 0.5844), 1.23)))\n    return false;\n  if (outside(ellipse(vec2(-0.584, 0.355), vec2(-0.56, 0.518), 1.24))\n      && inside(ellipse(vec2(-0.611, 0.31), vec2(-0.574, 0.42), 1.575))\n        && inside(ellipse(vec2(-0.701, 0.09), vec2(-0.58, 0.38), 1.17))) {\n    color = eyeColor6;\n    return true;\n  }\n  if (outside(ellipse(vec2(-0.584, 0.367), vec2(-0.546, 0.518), 1.2))\n      && inside(ellipse(vec2(-0.611, 0.299), vec2(-0.56, 0.48), 1.37))\n        && inside(ellipse(vec2(-0.68, 0.09), vec2(-0.58, 0.42), 1.17))) {\n    color = eyeColor5;\n    return true;\n  }\n  color = eyeColor3;\n  return true;\n}\n\nbool rightEye4(out vec3 color) {\n  if (inside(ellipse(vec2(-0.627, 0.49), vec2(-0.589, 0.583), 1.35))) {\n    color = eyeColor2;\n    return true;\n  }\n  if (inside(circle(vec2(-0.576, 0.445), 0.01)) || inside(circle(vec2(-0.54, 0.32), 0.01))) {\n    color = eyeColor4;\n    return true;\n  }\n  return false;\n}\n\nbool rightEye(out vec3 color) {\n  if (rightEye0(color))\n    return true;\n  if (rightEye1(color))\n    return true;\n  if (rightEye4(color))\n    return true;\n  if (rightEye3(color))\n    return true;\n  return rightEye2(color);\n}\n\nbool layer3(out vec3 color) {\n  if (leftEye(color))\n    return true;\n  return rightEye(color);\n}\n\nbool mouth(out vec3 color) {\n  if (outside(ellipse(vec2(-1.01, -0.04), vec2(-1.095, 0.02), 1.44)))\n    return false;\n  if (inside(ellipse(vec2(-1.01, -0.04), vec2(-1.095, 0.02), 1.4))\n     && inside(circle(vec2(-1.04, -0.045), 0.102))) {\n    color = inside(ellipse(vec2(-1.0, -0.09), vec2(-1.092, 0.002), 1.34)) ? mouthColor2 : mouthColor1;\n    return true;\n  }\n  color = mouthColor0;\n  return true;\n}\n\nbool nose(out vec3 color) {\n  if (inside(circle(vec2(-1.061, 0.228), 0.1))\n    && inside(circle(vec2(-1.107, 0.304), 0.019))\n      && outside(circle(vec2(-1.058, 0.29), 0.045))) {\n    color = (inside(circle(vec2(-1.007, 0.31), 0.1)) && outside(circle(vec2(-1.176, 0.379), 0.1))) ? borderColor : faceColor2;\n    return true;\n  }\n  return false;\n}\n\nbool leftEyebrow(out vec3 color) {\n  float c = circle(vec2(-0.85, 0.586), 0.502);\n  if (outside(c) || inside(c) || !inside(circle(vec2(-1.1, 1.072), 0.202)))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool rightEyebrow(out vec3 color) {\n  if (inside(circle(vec2(-0.77, 0.42), 0.56)))\n    return false;\n  vec2 p0 = vec2(-0.66, 0.601), p1 = vec2(-0.57, 0.742);\n  float r0 = 0.397, r1 = r0 - distance(p0, p1);\n  float c0 = circle(p0, r0), c1 = circle(p1, r1);\n  float f = cross2(position() - p0, p1 - p0);\n  if ((f < 0.0) ? (outside(c1) || inside(c1)) : (outside(c0) || inside(c0)))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool layer4(out vec3 color) {\n  if (leftEyebrow(color))\n    return true;\n  if (rightEyebrow(color))\n    return true;\n  if (mouth(color))\n    return true;\n  return nose(color);\n}\n\nbool ear0(out vec3 color) {\n  vec2 p0 = vec2(-0.249, 0.192), p1 = vec2(-0.09, 0.25);\n  float r0 = 0.202, r1 = r0 - distance(p0, p1);\n  float c0 = circle(p0, r0), c1 = circle(p1, r1);\n  float c = (cross2(position() - p0, p1 - p0) < 0.0) ? c1 : c0;\n  if (outside(c))\n    return false;\n  color = inside(c) ? faceColor1 : borderColor;\n  return true;\n}\n\nbool ear1(out vec3 color) {\n  vec2 p1 = vec2(-0.155, 0.23), p2 = vec2(-0.11, 0.21);\n  float c1 = circle(vec2(-0.14, 0.397), 0.204);\n  float c2 = circle(p1, 0.06);\n  float e = ellipse(vec2(-0.144, 0.16), vec2(-0.099, 0.235), 1.18);\n  if (outside(c1) || outside(e))\n    return false;\n  if (!inside(e))\n    color = borderColor;\n  else {\n    if (outside(c2))\n      return false;\n    color = (inside(c1) && ((cross2(position() - p1, p2 - p1) < 0.0) || inside(c2))) ? faceColor2 : borderColor;\n  }\n  return true;\n}\n\nbool ear2(out vec3 color) {\n  vec2 p1 = vec2(-0.2, -0.155);\n  float r1 = 0.2, c1 = circle(p1, r1);\n  vec2 p2 = vec2(-0.2, 0.1);\n  float r2 = distance(p1, p2) - r1, c2 = circle(p2, r2);\n  if (cross2(position() - p1, p2 - p1) < 0.0) {\n    if (inside(c1))\n      return false;\n    color = outside(c1) ? faceColor2 : borderColor;\n  } else {\n    vec2 p = vec2(-0.144, 0.156);\n    bool e = inside(ellipse(p, vec2(-0.36, -0.1), 1.04)) || inside(ellipse(p, vec2(-0.36, 0.1), 1.04));\n    if ((cross2(position() - p2, vec2(-0.15, 0.075) - p2) < 0.0)) {\n      if (!e)\n        return false;\n      color = faceColor2;\n    } else if (inside(c2)) {\n      if (!e)\n        return false;\n      color = faceColor2;\n    } else {\n      if (outside(c2))\n        return false;\n      color = borderColor;\n    }\n  }\n  return true;\n}\n\nbool ear3(out vec3 color) {\n  if (inside(circle(vec2(-0.2, -0.155), 0.2)))\n    return false;\n  vec2 p1 = vec2(-0.64, 0.28);\n  float r1 = 0.5, c1 = circle(p1, r1);\n  vec2 p2 = vec2(-0.172, 0.144);\n  float r2 = r1 - distance(p1, p2), c2 = circle(p2, r2);\n  float c = (cross2(position() - p1, p2 - p1) < 0.0) ? c2 : c1;\n  if (inside(c) || outside(c))\n    return false;\n  color = borderColor;\n  return true;\n}\n\nbool layer5(out vec3 color) {\n  if (inside(circle(vec2(-1.505, 1.15), 1.66)))\n    return false;\n  if (ear3(color))\n    return true;\n  if (ear2(color))\n    return true;\n  if (ear1(color))\n    return true;\n  return ear0(color);\n}\n\nbool ikachan(out vec3 color)\n{\n  if (layer4(color))\n    return true;\n  if (layer0(color))\n    return true;\n  if (layer5(color))\n    return true;\n  if (layer3(color))\n    return true;\n  if (layer1(color))\n    return true;\n  return layer2(color);\n}\n\t\nvec3 filterr(vec3 color,vec4 fragColor,  vec2 fragCoord ) \n{\n  return color * 0.5 * (2.0 - fragCoord.x / iResolution.x + fragCoord.y / iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 color;\n    //borderWidth = 0.5 / iResolution.y;\n    borderWidth = (1.5+1.0*sin(iTime)) / iResolution.y;\n    vec3 col;\n    \n    fragCoordd=fragCoord;\n    \n     if (ikachan(color) )\n         col=color ;\n         else\n         col=backgroundColor;\n\t \n    col=filterr(col,fragColor,fragCoord);\n  \n    fragColor = vec4(col , 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBBzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 67, 67, 138], [1262, 1262, 1280, 1280, 1359], [1361, 1361, 1393, 1393, 1431], [1433, 1433, 1474, 1474, 1524], [1526, 1526, 1581, 1581, 1694], [1696, 1696, 1718, 1718, 1747], [1749, 1749, 1772, 1772, 1800], [1802, 1802, 1830, 1830, 2325], [2327, 2327, 2355, 2355, 2596], [2598, 2598, 2626, 2626, 3100], [3102, 3102, 3131, 3131, 3324], [3326, 3326, 3355, 3355, 3668], [3670, 3670, 3699, 3699, 4184], [4186, 4186, 4215, 4215, 4613], [4615, 4615, 4643, 4643, 5136], [5138, 5138, 5167, 5167, 5455], [5457, 5457, 5485, 5485, 6701], [6703, 6703, 6731, 6731, 6923], [6925, 6925, 6953, 6953, 7149], [7151, 7151, 7179, 7179, 7514], [7516, 7516, 7545, 7545, 7744], [7746, 7746, 7775, 7775, 8442], [8444, 8444, 8475, 8475, 9081], [9083, 9083, 9114, 9114, 9427], [9429, 9429, 9460, 9460, 10420], [10422, 10422, 10452, 10452, 10560], [10562, 10562, 10594, 10594, 11003], [11005, 11005, 11037, 11037, 11244], [11246, 11246, 11278, 11278, 11721], [11723, 11723, 11755, 11755, 12402], [12404, 12404, 12436, 12436, 12708], [12710, 12710, 12741, 12741, 12934], [12936, 12936, 12965, 12965, 13032], [13034, 13034, 13062, 13062, 13435], [13437, 13437, 13464, 13464, 13782], [13784, 13784, 13818, 13818, 13999], [14001, 14001, 14036, 14036, 14437], [14439, 14439, 14468, 14468, 14616], [14618, 14618, 14645, 14645, 14965], [14967, 14967, 14994, 14994, 15475], [15477, 15477, 15504, 15504, 16283], [16285, 16285, 16312, 16312, 16690], [16692, 16692, 16721, 16721, 16919], [16921, 16921, 16951, 16951, 17167], [17170, 17170, 17230, 17230, 17322], [17324, 17324, 17381, 17381, 17716]]}
{"id": "3lBfRD", "name": "#857 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiments", "daily"], "likes": 5, "viewed": 173, "published": "Public API", "date": "1598383644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by: https://www.youtube.com/watch?v=-adHIyjIYgk\n// From BigWIngs: https://www.shadertoy.com/user/BigWIngs\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t 1.25 * iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 128.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 rotate2d(vec2 uv, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, -s, s, c) * uv;\n}\n\nfloat circleSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat gyroidSDF(vec3 p, float s, float th) {\n  p *= s;\n  return abs(dot(sin(t + p), cos(-t + p.zxy))) / s - th;\n}\n\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p;\n\n  float circle = circleSDF(p, 3.0);\n\n  p.y += t + cos(t);\n  p.z += t + sin(t);\n  float gyroid = gyroidSDF(p, 2.5, 0.025);\n\n  return max(circle, 0.5 * gyroid);\n}\n\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(1.0, 2.0, 3.0);\n  vec3 lightColor = vec3(0.3922, 0.6157, 0.8275);\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.1255, 0.0039, 0.0667);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return fog * light * lightColor + ambient;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.8235, 0.9608, 0.9373);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -7.5);\n\n  float angle = -0.5 * QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 424, 498, 498, 570], [572, 572, 621, 621, 677], [679, 679, 712, 712, 787], [789, 789, 823, 823, 849], [851, 851, 895, 895, 964], [966, 966, 990, 990, 1167], [1169, 1169, 1197, 1197, 1414], [1416, 1416, 1456, 1456, 1761], [1763, 1763, 1818, 1818, 2386]]}
{"id": "3lBfW1", "name": "Wave Interference Simulation", "author": "BattleDawnNZ", "description": "A simple visualization of wave interference\n\n(you can click with and drag with the mouse to adjust the spacing between wave origins)", "tags": ["wave"], "likes": 4, "viewed": 51, "published": "Public", "date": "1598761313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979323846264338327950288;\n\nfloat mag(vec2 origin,vec2 coord) {\n \treturn sqrt(pow(coord.x-origin.x,2.0)+pow(coord.y-origin.y,2.0));\n}\n\nfloat intensity (vec2 origin, vec2 coord) {\n    float amplitude = 1.0;\n    float frequency = 0.1;\n \treturn amplitude * sin(2.0*PI *frequency * mag(origin,coord) - iTime);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy/2.0;\n    float spacing = (iMouse.y <= 1.0) ? 5.0 : iMouse.y/8.0;\n    \n\tvec2 point1 = vec2(center.x,center.y-spacing*1.5);\n\tvec2 point2 = vec2(center.x,center.y-spacing*0.5);\n\tvec2 point3 = vec2(center.x,center.y+spacing*0.5);\n\tvec2 point4 = vec2(center.x,center.y+spacing*1.5);\n    \n    float value = (intensity(point1,fragCoord)\n        \t\t+ intensity(point2,fragCoord)\n        \t\t+ intensity(point3,fragCoord)\n        \t\t+ intensity(point4,fragCoord))/4.0;\n    \n    vec3 col = vec3(value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 92, 92, 162], [164, 164, 207, 207, 339], [341, 341, 398, 398, 978]]}
{"id": "3lBfzz", "name": "Blunderbuss", "author": "z0rg", "description": "a simple 2d animation", "tags": ["2d", "blunderbuss"], "likes": 11, "viewed": 246, "published": "Public API", "date": "1598180979", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat sat(float a)\n{\n    return clamp(a, 0.,1.);\n}\n\nfloat lenny(vec2 v)\n{\n    vec2 a = abs(v);\n    return a.x+a.y;\n}\n\n\n// Thanks iq :) Box - exact   (https://www.youtube.com/watch?v=62-pRVZuS5c)\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cir(vec2 p, float r)\n{\n    float an = atan(p.y, p.x);\n    float rad = \n        \n        sin(an*5.)*.5;\n    return length(p)-r;\n}\nfloat loz(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat add(float a, float b)\n{\n    return min(a, b);\n}\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\nconst float PI = 3.141592653;\nfloat spd = 12.;\nfloat chara(vec2 uv)\n{\n    //float spd = 15.;\n    uv -= vec2(0.,.1715);\n    vec2 uvB = (uv)*r2d(sin(iTime*spd*2.)*.02);\n    float body = sdBox(uvB, vec2(.008,.01));\n    vec2 lLeg = vec2(0.002+0.002*sin(-iTime*spd),-.01-((cos(-iTime*spd)))*0.001);\n    float leftLeg = sdBox(uv-lLeg, vec2(.001,.01));\n    leftLeg = add(leftLeg, sdBox(uv- lLeg-vec2(0.001,-.01), vec2(.002, 0.001)));\n    \n    vec2 rLeg = vec2(0.002+0.002*sin(-iTime*spd+PI),-.01-((cos(-iTime*spd+PI)))*0.001)-vec2(0.003,0.);\n    float rightLeg = sdBox(uv-rLeg, vec2(.001,.01));\n    rightLeg = add(rightLeg, sdBox(uv- rLeg-vec2(0.001,-.01), vec2(.002, 0.001)));\n    uvB -= vec2(0.,.01);\n    float ears = loz(vec2(abs(uvB.x)*3.-.0145, uvB.y), 0.01);\n    \n    return add(add(body, ears), add(leftLeg, rightLeg));\n}\n\nfloat tree(vec2 uv, float n)\n{\n    uv -= vec2(0.,.27);\n    float t = sub(loz(uv,.03), uv.y);\n    uv += vec2(0.,.03+0.005*sin(n));\n    t = add(t, sub(loz(uv, .04), uv.y));\n    uv += vec2(0.,.035+0.005*sin(n*2.+1.2));\n    t = add(t, sub(loz(uv, .05), uv.y));\n    uv += vec2(0.,.03);\n    t = add(t, sub(loz(uv, .06+0.005*sin(n+.3)), uv.y));\n    t = add(t, sdBox(uv, vec2(0.01, 0.05)));\n    return t;\n}\n\n\nvec3 lerp4(vec3 grad[4], float i)\n{\n    float idx = sat(i)*3.0;\n    int prevIdx = int(idx);\n    int nextIdx = min(prevIdx+1, 3);\n    vec3 prev = grad[prevIdx];\n    vec3 next = grad[nextIdx];\n    float lrp = idx - float(prevIdx);\n    return mix(prev, next, smoothstep(0.,1.,lrp));\n}\n\n\n\nvec3 rdrWind(vec2 uv)\n{\n    float halo = abs(uv.y-.2-sin(uv.x*4.)*.02);\n\treturn .3*(sin(uv.x*2.-iTime)*.5+.5)*texture(iChannel1, vec2(-iTime*.01, 0.)+uv*vec2(.05,20.)).xxx*(1.-sat(halo*25.));\n}\n\n\nvec3 rdr(vec2 uv)\n{\n    vec2 uvSky = uv*r2d(iTime*.1);\n    float sharp = iResolution.x*2.;\n    vec3 gradient[4];\n    gradient[0] = vec3(9,5,75)/255.;\n    gradient[1] = vec3(182,97,17)/255.;\n    gradient[2] = vec3(91,217,222)/255.;\n    gradient[3] = vec3(0,164,255)/255.;\n    \n    float an = abs(atan(uvSky.y, uvSky.x))-.2;\n    vec3 col = pow(lerp4(gradient, an*.4+.1*distance(vec2(0.,1.), uv)), vec3(1./1.))*smoothstep(0.,1.,1.-sat(cir(uv, .2)*5.));\n\n    float stars = (texture(iChannel1, uvSky*8.).x+texture(iChannel1, uvSky*8.*r2d(.1)).x)/2.;\n    float rate = .80;\n\tcol += vec3(texture(iChannel1, uv*5.).x*.5+.5,.8,.9)*sat(sat(stars - rate)/(1.-rate)-.1);\n    \n    col = mix(col, vec3(0.), 1.-sat(cir(uv, .15)*sharp));\n\n    col = mix(col, vec3(0.), 1.-sat(chara(uv)*sharp));\n    vec2 eyeP = uv-vec2(0.002,.175);\n    mat2 rot = r2d(sin(iTime*spd*2.)*.05);\n    float eyes = add(cir((eyeP*rot-vec2(0.005,0.)), 0.001), cir((eyeP*rot)-vec2(0.0025,0.), 0.001));\n    col = mix(col, vec3(255,188,0)/255., 1.-sat(eyes*sharp));\n    \n    float tre = tree((uvSky-vec2(0.,.08))*2., 5.);\n    col = mix(col, col*.2, 1.-sat(tre*sharp));  \n    float tree2 = tree((uvSky*r2d(1.)-vec2(0.,.08))*2., 1.);\n    col = mix(col, col*.2, 1.-sat(tree2*sharp));  \n        float tree3 = tree((uvSky*r2d(5.)-vec2(0.,.1))*3., 5.);\n    col = mix(col, col*.2, 1.-sat(tree3*sharp));     \n    \n    \n    float fog = sin(10.*an+iTime+length(uv))*.2+(sin(iTime-length(uv)*25.)*.2+.1)+.3;\n    col = mix(col, col*.2, fog); \n    col += (vec3(255,245,130)/255.)*smoothstep(0.,1.,1.-sat(cir(uvSky-vec2(-.5,0.), .1)*2.));\n    \n    float snd = texelFetch(iChannel0, ivec2(int(an*5.), 0), 0).x;\n    col += rdrWind(vec2(an, length(uv)));\n    col += mix(vec3(1.),.5+0.5*cos(iTime+uv.xyx+vec3(0,2,4)), snd)*.5*sat(abs(uv.x)*5.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\tuv *= .3;\n    uv -= vec2(0.,-.2);\n    \n    vec3 col = rdr(uv);\n    \n    if (iFrame > 5)\n    \tcol *= sat(iTime/2.);\n    //col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "llj3DG", "previewfilepath": "https://soundcloud.com/henrikjose/henrik-jose-blunderbuss", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/henrikjose/henrik-jose-blunderbuss", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBfzz.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 397, 415, 415, 490], [492, 492, 512, 512, 542], [544, 544, 565, 565, 608], [611, 687, 724, 724, 804], [806, 806, 834, 834, 940], [941, 941, 969, 969, 994], [996, 996, 1025, 1025, 1049], [1050, 1050, 1079, 1079, 1104], [1152, 1152, 1174, 1197, 1926], [1928, 1928, 1958, 1958, 2326], [2329, 2329, 2364, 2364, 2610], [2614, 2614, 2637, 2637, 2807], [2810, 2810, 2829, 2829, 4608], [4610, 4610, 4667, 4667, 4918]]}
{"id": "3lfBR7", "name": "test  20200801", "author": "beherca", "description": "a test", "tags": ["test"], "likes": 0, "viewed": 47, "published": "Public", "date": "1596258363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// By iq: https://www.shadertoy.com/user/iq  \n// license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    vec3 i = cos(iTime) + uv.xyx;\n    vec3 a = vec3(0.9,0.2,0.3);\n    // Output to screen\n    fragColor = vec4(a/i,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1, 135, 192, 242, 497]]}
{"id": "3lfBWN", "name": "Waves Remix 2 Color", "author": "gchipunov", "description": "\n\nfrom waves, sound, wave, music, colors, beginner, audio, visualizer, easy, sounds\nCreated by ADOB in 2015-04-10\n", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "soundscreatedbyadobin20150410"], "likes": 4, "viewed": 311, "published": "Public API", "date": "1596687261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// oringal createor https://www.shadertoy.com/user/ADOB\n// remixer coder: https://www.shadertoy.com/user/gchipunov\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n       // float k = i;\n        if(i== 0.0f)\n       {\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\n                       glowWidth * (2.0 - tan(iTime * 0.19)));\n       }\n           else   if(i== 1.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.01)),\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n         else   if(i== 2.0f)\n        {\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        else\n        {\n \t\tcolor += vec3(glowWidth/2.0 * (2.0 + tan(iTime * 0.13)),\n                      glowWidth/2.0 * (2.0 - sin(iTime * 0.23)),\n                      glowWidth/2.0 * (2.0 - cos(iTime * 0.19)));\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));           \n        }\n        \n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "llS3Dy", "previewfilepath": "https://soundcloud.com/zubnid/zeldabetamax", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/zubnid/zeldabetamax", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 115, 143, 143, 167], [169, 169, 200, 200, 259], [261, 261, 287, 287, 385], [387, 387, 444, 444, 2227]]}
{"id": "3lffD4", "name": "OrbAttract(SST)", "author": "Del", "description": "cheap vfx shader", "tags": ["2d", "circles", "vfx"], "likes": 5, "viewed": 296, "published": "Public API", "date": "1596679522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// orb attract shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n    //float v1 = 1.0+ sin(iTime+p.x*250.0)*0.3;\n    //float v2 = 1.0+ cos(iTime+p.y*250.0)*0.3;\n    \n    \n    p.y += sin(iTime*1.5+p.x*12.0)*0.05;\t// wibble\n    //p.x = sin(p.y*12.0)*0.05;\n    \n    \n    float speed = 0.45;\n    float d = length(p);\n    p*= 0.8;\t\t// scale\n\tfloat r = (p.x*p.x + p.y*p.y)*4.0;\n    //r+=sin(d*4.0);\t//*0.5;\n\tfloat v = 1.0 + .5*sin((r+iTime*speed)/0.08);\n    v =(v*d)*4.0;\n    v*=1.0-d;\n    v = clamp(v,0.0,4.0);\n    v*=v;\n\tvec3 col = vec3(0.6,0.5,0.9)*v;\n    //col*=v1*v2;\t// dotty\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 79, 79, 684]]}
{"id": "3lffWX", "name": "Oceanic Storm", "author": "jdspugh", "description": "In the ocean at night. Impending moon.\n\n(pause and play if the sound effects don't work for you)", "tags": ["ocean", "glass", "rain", "drop", "storm", "droplets", "drops", "raining"], "likes": 13, "viewed": 468, "published": "Public", "date": "1597836872", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----\n// drops\n// -----\n// drops are based on this shader:\n//\n// Heartfelt - by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec3 N13(float p) {\n //  from DAVE HOSKINS\n vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n p3 += dot(p3, p3.yzx + 19.19);\n return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n  return fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n  return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 DropLayer2(vec2 uv, float t) {\n  vec2 UV = uv;\n    \n  uv.y += t*0.75;\n  vec2 a = vec2(6., 1.);\n  vec2 grid = a*2.;\n  vec2 id = floor(uv*grid);\n    \n  float colShift = N(id.x); \n  uv.y += colShift;\n    \n  id = floor(uv*grid);\n  vec3 n = N13(id.x*35.2+id.y*2376.1);\n  vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n  float x = n.x-.5;\n    \n  float y = UV.y*20.;\n  float wiggle = sin(y+sin(y));\n  x += wiggle*(.5-abs(x))*(n.z-.5);\n  x *= .7;\n  float ti = fract(t+n.z);\n  y = (Saw(.85, ti)-.5)*.9+.5;\n  vec2 p = vec2(x, y);\n    \n  float d = length((st-p)*a.yx);\n    \n  float mainDrop = S(.4, .0, d);\n    \n  float r = sqrt(S(1., y, st.y));\n  float cd = abs(st.x-x);\n  float trail = S(.23*r, .15*r*r, cd);\n  float trailFront = S(-.02, .02, st.y-y);\n  trail *= trailFront*r*r;\n    \n  y = UV.y;\n  float trail2 = S(.2*r, .0, cd);\n  float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n  y = fract(y*10.)+(st.y-.5);\n  float dd = length(st-vec2(x, y));\n  droplets = S(.3, 0., dd);\n  float m = mainDrop+droplets*r*trailFront;\n    \n  return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n  uv *= 40.;\n    \n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n  vec3 n = N13(id.x*107.45+id.y*3543.654);\n  vec2 p = (n.xy-.5)*.7;\n  float d = length(uv-p);\n    \n  float fade = Saw(.025, fract(t+n.z));\n  float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n  return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n  float s = StaticDrops(uv, t)*l0; \n  vec2 m1 = DropLayer2(uv, t)*l1;\n  vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n  float c = s+m1.x+m2.x;\n  c = S(.3, 1., c);\n    \n  return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainDrops( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n  vec2 UV = fragCoord.xy/iResolution.xy;\n  vec3 M = iMouse.xyz/iResolution.xyz;\n  float T = 100.0 + iTime+M.y*2.; // make drop move up/down faster/slower if we move the \"glass\" up/down, like in reality\n    \n  float t = T*.2;\n    \n  float rainAmount = 1.0;\n  float maxBlur = mix(3., 6., rainAmount);\n  float minBlur = 1.0;\n    \n  float story = 0.;\n\n  float zoom = -0.8;\n  uv *= .7+zoom*.3;\n  UV = (UV-.5)*(.9+zoom*.1)+.5;\n    \n  float staticDrops = S(-.5, 1., rainAmount)*2.;\n  float layer1 = S(.25, .75, rainAmount);\n  float layer2 = S(.0, .5, rainAmount);\n    \n    \n  vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n  vec2 e = vec2(.001, 0.);\n  float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n  float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n  vec2 n = vec2(cx-c.x, cy-c.x); // expensive normals\n    \n  float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n  vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    \n  // post processing\n  t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightning\n  float colFade = sin(t*.2)*.5+.5+story;\n  //col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n  float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n  float lightning = sin(t*sin(t*10.));\t\t\t\t\t// lighting flicker\n  lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n  col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\n  col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette\n  col *= fade;\t\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    \n  fragColor = vec4(col, 1.);\n}\n// -----\n\n\n// -----\n// waves\n// -----\n// waves are based on this shader:\n// \n// Very fast procedural ocean by afl_ext\n//\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n  float x = dot(direction, position) * frequency + timeshift * speed;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n  float iter = 10.0;\n  float phase = 6.0;\n  float speed = 0.5;\n  float weight = 1.0;\n  float w = 0.0;\n  float ws = 0.0;\n  for(int i=0;i<iterations;i++){\n    vec2 p = vec2(sin(iter), cos(iter));\n    vec2 res = wavedx(position, p, speed, phase, Time);\n    position += normalize(p) * res.y * weight * DRAG_MULT;\n    w += res.x * weight;\n    iter += 12.0;\n    ws += weight;\n    weight = mix(weight, 0.0, 0.2);\n    phase *= 1.18;\n    speed *= 1.07;\n  }\n  return w / ws;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n  vec3 pos = start;\n  float h = 0.0;\n  float hupper = depth;\n  float hlower = 0.0;\n  vec2 zer = vec2(0.0);\n  vec3 dir = normalize(end - start);\n  for(int i=0;i<318;i++){\n    h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\n    if(h + 0.01 > pos.y) {\n      return distance(pos, camera);\n    }\n    pos += dir * (pos.y - h);\n  }\n  return -1.0;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n  vec2 ex = vec2(e, 0);\n  H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\n  vec3 a = vec3(pos.x, H, pos.y);\n  return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \n                         normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\n\nmat3 rotmat(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n  oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n  oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n  uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n  if(Resolution.x < 400.0) return proj;\n    \n    vec2 mouse = vec2(0.5,0.5); // use these default mouse cooridnates so we're not staring at into the water before clicking\n    if (0.0 != Mouse.x) {mouse.x = Mouse.x;} // follow mouse if not at default position\n    if (0.0 != Mouse.y) {mouse.y = Mouse.y;} // follow mouse if not at default position\n  \n  vec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;\n  return ray;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n  sundir.y = max(sundir.y, -0.07);\n  float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n  float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n  float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n  float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n  float mymie = sundt * special_trick * 0.2;\n  vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n  vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n  vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n  bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n  return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\n} \n\nvec3 getatm(vec3 ray){\n  return extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n}\n\nfloat sun(vec3 ray){\n  vec3 sd = normalize(vec3(1.0));   \n  return pow(max(0.0, dot(ray, sd)), 64.0) * 1100.0; // <moon smaller>) * <moon bigger>;\n}\n\nvec3 aces_tonemap(vec3 color){\t\n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;    \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainWaves(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n \t\n  float waterdepth = 2.1;\n  vec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n  vec3 wceil = vec3(0.0, 0.0, 0.0);\n  vec3 orig = vec3(0.0, 0.0, 0.0); // (<>, <viewer's height above water>, <>)\n  vec3 ray = getRay(uv);\n  float hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n  if(ray.y >= -0.01){\n    // above the horizon\n    vec3 C = getatm(ray) * 1.5 + sun(ray); // <> * <horizon lightness> + <>\n    C = aces_tonemap(C);\n    fragColor = vec4(C,1.0);   \n  } else {\n    // below the horizon\n    float lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth); // (<>, <water roughness>, <>)\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\n    //tonemapping\n    C = aces_tonemap(C);\n    \n\tfragColor = vec4(C,1.0);\n  }\n}\n// -----\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // waves\n  vec4 fragColorWaves;\n  mainWaves(fragColorWaves, fragCoord); \n    \n  // drops\n  vec4 fragColorDrops;\n  mainDrops(fragColorDrops, fragCoord);\n    \n  // combine\n  fragColor = fragColorWaves - fragColorDrops;\n    \n  // make b&w\n  //fragColor = vec4(fragColor.x, fragColor.x, fragColor.x, fragColor.x);\n  fragColor = vec4(fragColor.y, fragColor.y, fragColor.y, fragColor.y);\n  //fragColor = vec4(fragColor.z, fragColor.z, fragColor.z, fragColor.z);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "Mt23WG", "previewfilepath": "https://soundcloud.com/monie-thach/ocean-thunderstorm-sounds-for-sleeping-relaxing-thunder-rain-storm-waves-sea-lightning-ambience", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/monie-thach/ocean-thunderstorm-sounds-for-sleeping-relaxing-thunder-rain-storm-waves-sea-lightning-ambience", "ctype": "musicstream"}, {"id": "Ml23WG", "previewfilepath": "https://soundcloud.com/arimnaes/lightning-storm", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/arimnaes/lightning-storm", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 307, 326, 349, 515], [517, 517, 536, 536, 625], [627, 627, 645, 645, 689], [691, 691, 720, 720, 755], [757, 757, 792, 792, 1825], [1827, 1827, 1864, 1864, 2125], [2127, 2127, 2187, 2187, 2394], [2396, 2396, 2453, 2453, 4073], [4085, 4381, 4472, 4472, 4632], [4634, 4634, 4680, 4680, 5147], [5149, 5149, 5217, 5217, 5576], [5593, 5593, 5637, 5637, 6011], [6013, 6013, 6050, 6050, 6471], [6473, 6473, 6494, 6494, 7168], [7170, 7170, 7246, 7246, 7337], [7339, 7339, 7393, 7393, 8119], [8122, 8122, 8144, 8144, 8212], [8214, 8214, 8234, 8234, 8362], [8364, 8364, 8394, 8394, 8825], [8827, 8827, 8882, 8882, 10109], [10110, 10120, 10175, 10186, 10635]]}
{"id": "3lffz2", "name": "Curl Boundary", "author": "yuyujunjun", "description": "Show 2D Curl with collision avoidance boundary. Use radius to control the range of fields affected.\nArrow drawing algorithm is from https://www.shadertoy.com/view/MdK3zy", "tags": ["2d", "curl", "boundary"], "likes": 6, "viewed": 79, "published": "Public", "date": "1597138499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TILE_SIZE = 0.045;\nconst float radius=0.3;\nvec2 velocity(){\n\t//return vec2(0);\n\treturn 0.1*vec2(sin(iTime),cos(iTime));\n}\nfloat sdfSphere(vec2 pos){\n\treturn length(pos)-0.2;\n}\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\nfloat sdf( vec2 p)\n{\n\tp+=vec2(-1,-0.5)+0.3*vec2(sin(.5*iTime),cos(.2*iTime));\n\t//p+=velocity();\n\tfloat sphereDis=sdfSphere(p+0.1);\n\tfloat dis=sdPentagon(p,0.2);\n\t//return dis;\n\tif(sphereDis<dis){\n\t\treturn sphereDis;\n\t}else{\n\t\treturn dis;\n\t}\n\n}\nfloat ramp(float r){\n\tif(r>1.)return 1.;\n\tif(r<-1.)return -1.;\n\treturn r*15./8.-r*r*r*10./8.+3./8.*r*r*r*r*r;\n}\n\nvec2 sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n//\tif(l<0.000000000000001)return 0.;\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n\tfloat dis=length(p-a);\n\tfloat dis1=length(p-b);\n\tvec2 result;\n\tresult.x=length(max(q,0.0001)) + min(max(q.x,q.y),0.0);\n\tresult.y=dis>dis1?-1.:1.;\n    return     result;\n}\n// get the arrow color under pos (transparent if no hit)\nvec3 arrowColor(vec2 p, vec2 arrow_center, vec2 arrow_vec) \n{\n    float scale = TILE_SIZE;\n    //arrow_vec = normalize( arrow_vec );\n\t\n\tvec2 darrow = sdOrientedBox(p, arrow_center - arrow_vec*scale, arrow_center + arrow_vec*scale,0.1*scale);\n\tif( darrow.x> 0.0 )\n        return vec3(0.0);\n    return darrow.y>0.?vec3(1,0,0):vec3(0,1,1);\n    return vec3( 1 );\n}\n// comp\n// computes arrow center location from given pos\nvec2 arrowTilePos(vec2 p) \n{\n\treturn ((floor(p / TILE_SIZE)+0.5)*TILE_SIZE) ;\n}\nvec2 field2d(vec2 p)\n{\n\tvec2 field;\n    field.x = cos(3.0*p.x)* sin(5.0*p.y);\n\tp+=vec2(0.001);\n\tfield.y= cos(3.0*p.x)* sin(5.0*p.y);\n    return (field);\n}\n\n\n\nvec2 curl2d(vec2 p)\n{\n    vec3 e = vec3(0.01,-0.01,0.0);\n\n    float fxp = field2d(p + e.xz).x;\n\tfxp*=ramp(sdf(p+e.xz)/radius);\n\t\n    float fxm = field2d(p + e.yz).x;\n\tfxm*=ramp(sdf(p+e.yz)/radius);\n\n    float fyp = field2d(p + e.zx).x;\n\tfyp*=ramp(sdf(p+e.zx)/radius);\n\t\n    float fym = field2d(p + e.zy).x;\n\tfym*=ramp(sdf(p+e.zy)/radius);\n\t\n    vec2 c = vec2( \t(fyp - fym) / (2.*e.x),\n                 \t(-fxp + fxm) / (2.*e.x) );\n\treturn c;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2( (fragCoord.xy / iResolution.xx ) * 2.0 );\n    \n    vec3 col = vec3(0.0);\n    col = arrowColor( p, arrowTilePos(p), curl2d( arrowTilePos(p) ) );\n\tfloat a=sdf(p);\n\tif(a<0.003&&a>-0.003)col=vec3(0.8,0.3,0.4);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lffz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 71, 90, 133], [134, 134, 160, 160, 187], [188, 188, 231, 231, 513], [514, 514, 534, 534, 757], [758, 758, 778, 778, 869], [871, 871, 936, 936, 1301], [1302, 1359, 1420, 1420, 1719], [1720, 1777, 1805, 1805, 1856], [1857, 1857, 1879, 1879, 2011], [2015, 2015, 2036, 2036, 2460], [2463, 2463, 2520, 2520, 2779]]}
{"id": "3ljBD1", "name": "Spinning Torus", "author": "milesWaugh", "description": "Raymarched torus with fresnel reflectance, blinn-phong specular model, shadows, and reflections. 2.2 gamma corrected. ", "tags": ["raymarching", "torus", "shadows", "reflections", "fresnel", "blinnphongspecularity"], "likes": 9, "viewed": 289, "published": "Public API", "date": "1598850644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s sin(iTime)\n#define c cos(iTime)\n#define dist 4.0\n\nfloat sd(vec3 pos, float d){\n    vec3 p = pos - vec3(0,0,d);\n    float py = p.y;\n    p.y = p.y*c - p.z*s;\n    p.z = p.z*c + py*s;\n    vec2 t = vec2(1.0,.4);\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ambient = vec3(0.4,0.7,1.0)/5.0;\n    vec3 light = normalize(vec3(0.8,0.5,-0.5));\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.x;\n\tint iters = 0;\n    float raylength = 0.0;\n    vec3 incoming = normalize(vec3(uv,1));\n    float SDE = 1.0;\n    vec3 z = vec3(0.0);\n    while(iters<5000&&abs(raylength)<100.0&&abs(SDE)>0.00001){\n        z = raylength*incoming;\n        SDE = sd(z,dist);\n        raylength+=SDE;\n        iters++;\n    }\n    vec3 col = ambient;\n    if(abs(SDE)<=0.00001){\n        vec3 inVec = incoming;\n        vec3 z1 = z;\n        raylength = 0.0;\n        incoming = normalize(vec3(uv.x+0.0001,uv.y,1));\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        while(iters<5000&&abs(raylength)<100.0&&abs(SDE)>0.00001){\n            z = raylength*incoming;\n            SDE = sd(z,dist);\n            raylength+=SDE;\n            iters++;\n        }\n        vec3 z2 = z;\n        raylength = 0.0;\n        incoming = normalize(vec3(uv.x,uv.y+0.0001,1));\n        SDE = 1.0;\n        iters = 0;\n        while(iters<5000&&abs(raylength)<100.0&&abs(SDE)>0.00001){\n            z = raylength*incoming;\n            SDE = sd(z,dist);\n            raylength+=SDE;\n            iters++;\n        }\n        vec3 z3 = z;\n        raylength = 0.0001;\n        incoming = light;\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        while(iters<5000&&abs(raylength)<100.0&&abs(SDE)>0.00001){\n            z = raylength*incoming;\n            SDE = sd(z+z1,dist);\n            raylength+=SDE;\n            iters++;\n        }\n        vec3 a = z3-z1;\n        vec3 b = z2-z1;\n        vec3 color = vec3(1.5,1.0,0.5);\n        vec3 normal = normalize(vec3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x));\n        vec3 reflection = normal*2.0*dot(normal, inVec) - inVec;\n        raylength = 0.01;\n        incoming = -reflection;\n        SDE = 1.0;\n        z = vec3(0.0);\n        iters = 0;\n        while(iters<5000&&abs(raylength)<100.0&&abs(SDE)>0.00001){\n            z = raylength*incoming;\n            SDE = sd(z+z1,dist);\n            raylength+=SDE;\n            iters++;\n        }\n        vec3 diffuse = (vec3(max(dot(normal,light)*5.0,0.0)*color)+ambient)*0.1;\n        vec3 specular = pow(max(dot(normalize(light-inVec),normal),0.0),200.1)*9.0+ambient;\n        if(abs(SDE)<=0.00001){\n            specular = ((1.0*color)+ambient)*0.1;\n        }\n        float fresnel = 0.05+0.95*pow(1.0+dot(inVec, normal),5.0);\n        col = diffuse*(1.0-fresnel) + specular*fresnel;\n    }\n\n    fragColor = vec4(pow(col.x,0.4545),pow(col.y,0.4545),pow(col.z,0.4545),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 284], [286, 286, 343, 343, 2932]]}
{"id": "3ljBRR", "name": "Limited", "author": "JacobC", "description": "Faking IL/GI with ray marching and some reflections\nYou can move the camera by clicking the canvas and drag with the mouse", "tags": ["3d", "raymarching", "sdf", "gi", "reflections", "ao"], "likes": 6, "viewed": 82, "published": "Public", "date": "1598652132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Limited\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n#define T iTime\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 i_col;\n    float ao;\n    float ref;\n};\n    \nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 2.8, 4.2);\n    s = map(s, 1., 1.4, 3.6);\n    return mat\n        (\n            min(a.depth, b.depth),\n            a.depth < b.depth ? a.col : b.col,\n            a.i_col * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s),\n            a.ao * ao,\n            a.depth < b.depth ? a.ref : b.ref\n        );\n}\n\n#define op0 vec3(cos(T)*6., 1., -sin(T)*6.)\n#define op1 vec3(0., 1., cos(T)*6.)\n#define op2 vec3(-cos(T)*6., 1., -sin(T)*6.)\n#define op3 vec3(0., -101., 0.)\n#define op4 vec3(0., -.5, 0.)\n\n#define oc0 vec3(.5, 1., 0.)\n#define oc1 vec3(1., 1., 1.)\n#define oc2 vec3(.5, 0., 1.)\n#define oc3 vec3(.5)\n\nvec3 h23(in vec2 p)\n{\n    return vec3\n        (\n            fract(sin(dot(p, vec2(90.12, 89.1))) * 41.),\n            fract(sin(dot(p, vec2(87.28, 76.3))) * 92.),\n            fract(sin(dot(p, vec2(40.61, 44.5))) * 65.)\n        );\n}\n\nmat scene(in vec3 p)\n{\n    vec3 icol = vec3(1.);\n    \n    mat o0 = mat(cube(p - op0, vec3(2.), max(abs(sin(T) * 2.), .4)), oc0, icol, 1., .25);\n    mat o1 = mat(cube(p - op1, vec3(2.), 2.), oc1, icol, 1., 0.);\n    mat o2 = mat(cube(p - op2, vec3(2.), max(abs(sin(T) * 2.), .4)), oc2, icol, 1., .001);\n    mat o3 = mat(cube(p - op3, vec3(100.), 1.), oc3, icol, 1., 0.);\n    \n    vec3 q = p;\n    bvec2 b = equal(greaterThan(q.xz, vec2(-60.)), lessThan(q.xz, vec2(60.)));\n    float s = 10.;\n    vec2 iq = floor(q.xz / s);\n    vec3 cq = h23(iq);\n    q.xz = b.x && b.y ? mod(q.xz, s) - s * .5 : q.xz;\n    \n    mat o4 = mat(cube(q - op4, vec3(.5), .5), cq  * 1.5, icol, 1., 0.);\n    \n    mat o = uop(o0, o2);\n    o = uop(o, o3);\n    o = uop(o, o1);\n    o = uop(o, o4);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define STEPS 99\n#define MIN_DIST .01\n#define MAX_DIST 99.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n            return mat(t, s.col, s.i_col, s.ao, s.ref);\n        if (t > MAX_DIST)\n            return mat(t, vec3(-1.), vec3(-1.), -1., -1.);\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1., -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2.\n#define gd vec3(1., 1., 1.)\n#define sk vec3(.5, .7, 1.)\n#define R 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st - n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            float sn = sin(ms.x);\n            vec3 o;\n            if (iMouse.z > 0.)\n            \to = vec3(ms.x * 3., max(ms.y * 3., 0.), 2.) * 8.;\n            else\n                o = vec3(12., 8., 20.);\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                back = mix(gd, sk, n.y * .5 + .5);\n                \n                col += m.col * m.i_col * m.ao * back;\n                if (m.ref > .0)\n                {\n                    vec3 i = normalize(p - o);\n                    d = reflect(i, n);\n                    o = p + d * .05;\n                    m = marcher(o, d);\n                    for (int r = 0; r < R; r++)\n                    {\n                        if (m.ao >= 0.)\n                        {\n                            \n                            if (m.ref > 0.)\n                            {   \n                                p = o + d * m.depth;\n                \t\t\t\tn = normal(p);\n                                \n                            \tcol *= m.col * m.i_col * m.ao * back;\n                                \n                                i = normalize(p - o);\n                                d = reflect(i, n);\n                                o = p + d * .05;\n                                m = marcher(o, d);\n                            }\n                            else\n                               col *= m.col * m.i_col * m.ao * back;\n                        }\n                        else\n                            col *= back;\n                    }\n                }\n            }\n            else\n                col = back;\n            \n            f_col += col;\n        }\n    }\n\n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 289, 332, 332, 395], [397, 397, 444, 444, 492], [494, 494, 523, 523, 891], [1190, 1190, 1211, 1211, 1420], [1422, 1422, 1444, 1444, 2205], [2207, 2207, 2231, 2231, 2411], [2473, 2473, 2508, 2508, 2856], [2858, 2858, 2904, 2904, 3049], [3134, 3134, 3191, 3191, 5502]]}
{"id": "3ljBzh", "name": "castle45", "author": "lennyjpg", "description": "asdfasdf", "tags": ["adfasdf"], "likes": 3, "viewed": 185, "published": "Public API", "date": "1598354001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.x;\n    float t = iTime * .1;\n    //float cc = length(uv-0.5)*0.8;\n    uv.x += t;\n    vec2 u = uv;\n    u *= 7.0; \n    u *= floor(u.y + 1.);\n    u.x += step(1.,mod(u.y,2.))*.5; // x offset\n   // float g = rand(vec2(floor(u.x),floor(u.y)));\n   // g+=sin(uv.x*20.0+t*10.0)*0.2;\n    u = fract(u);\n    float h = .35;\n    if(u.y < h){\n        u.y = h;  \n    }\n    vec2 off = vec2(0.5,h);\n    float d = length(u - off);  \n    float r = smoothstep(d , d*1.1, .45);\n    float k = r;\n    if(uv.y > .38){\n        float q = fract(uv.x*5.0+uv.y*3.0) - uv.y * 6. + 2.3;\n        k = step(q,0.0);\n    }\n    //k=min(k,step(cc,0.5));\n    vec3 colorA = vec3(1.,.9,.8),\n     colorB = vec3(.05,0.,.1),\n     colorC = mix(colorA, colorB, k);\n    fragColor = vec4(colorC, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 944]]}
{"id": "3ljfR1", "name": "Polar Weave Pattern", "author": "Shane", "description": "A simple polar weave pattern.", "tags": ["2d", "repetition", "pattern", "polar", "weave"], "likes": 38, "viewed": 535, "published": "Public API", "date": "1598443725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPolar Weave Pattern\n\t-------------------\n\n\tOne of my favorite nerd related hobbies is to recreate a simple \n    pattern I've come across on the internet. If I really feel like \n    geeking out, I'll render the exact pattern using several different \n    approaches. :)\n\t\n    Anyway, this particular pattern and its derivatives are all over \n    the net, and although I couldn't find any, there are probably \n    examples on here too. There are several ways to produce it. In this \n    case, I'm minimizing rendering calls by using a single pass repeat \n    polar approach, which means no neighboring cells need be considered. \n\n    It took me longer to put together than I anticipated, but the idea \n    is pretty simple: Partition space into repeat polar cells, then \n    render two circular arcs on each cell edge with radii such that \n    their edges completely overlap. This will result in what look like \n    a bunch of overlapping circles. The final step is to flip the \n    bottom half of each cell to produce a weave.\n\n\n\n    Related examples:\n\n    // When Fabrice first posted these, I wasted way too much\n    // time playing around with the code. :)\n    rosace 3c - FabriceNeyret2\n    https://www.shadertoy.com/view/Ms3SzB\n\n    // Related in the sense that it uses polar coordinates only,\n    // but it's really cool, so I included it anyway. :)\n    Rose - Dave_Hoskins\n    https://www.shadertoy.com/view/ldBGDh\n\n    // An unlisted bare bones polar coordinate example, for \n\t// anyone who's not quite sure how the polar thing works.\n    Polar Repetition - Shane\n\thttps://www.shadertoy.com/view/wdtGDM\n\n\n*/\n\n// Display the radial cell boundaries on the background.\n//#define SHOW_CELLS\n\n// Adds the weave effect: If you comment in the SHOW_CELLS define\n// above, then scroll down to the WEAVE define, you'll see that it \n// involves a very simple trick.\n#define WEAVE\n\n// Random ordering. I prefer the ordered look, but the option\n// is here to show it can be done. The pattern changes every two\n// seconds. By the way, this can occasionally produce discontinous\n// results when using odd cell numbers... which I'll fix later. \n//#define RANDOM_ORDER\n\n// Number of cells: Integers between 4 and 10 work. Beyond that,\n// some tweaking will be necessary. Interestingly, odd numbers will\n// produce a single weave, whereas even numbers will produce two\n// separate interlocked weaves.\n#define CELL_NUM 8.\n\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Hacky globals, put in as an afterthought. Struct containers are tidier, but \n// sometimes they can be even less readable. In addition, WebGL can throw all\n// kinds of errors when you're trying to used them inside raymarching loops,\n// which can be extra annoying.\n//\n// Anyway, there's an alternate cell variable and edge width. The vec2 is a \n// global local cell coordinate variable, which is kind of a contradiction \n// in terms. :)\nfloat gDir, gEw;\nvec2 gP;\n\nvec4 dist(vec2 p){\n    \n    // Rotation performed here.\n    p *= r2(-iTime/4.);\n    \n\t\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    // Number of cells.\n    const float aNum = CELL_NUM;\n    \n    // Partitioning the angle into \"aNum\" cells.\n    float ia = floor(a/6.2831853*aNum);\n \n    // Used to generate a random number for each cell, and consequently,\n    // a random rendering order.\n    float svIA = ia;\n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(ia, 2.)<.5? -1. : 1.;\n    \n    \n    // Centering and converting back to radians... If you do this often enough,\n    // it'll become second nature.\n    ia = (ia + .5)/aNum*6.2831853;\n    \n    // Converting the radial centers to their positions.\n    p *= r2(ia);\n    // Above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n\n    // Hacky global coordinate save.\n    gP = p;\n    \n    \n    // Producing the objects: In this case, two circles at the mid edges of each cell.\n\n    \n    // Setting the radial distance: We achive this by setting one of the polar \n    // coordinates to this value, which effectively moves the points out a bit along \n    // the radial line. If you didn't perform this, all objects would be superimposed \n    // on one another in the center. Repeat radial coordinates are possible too.\n    const float rad = .265;\n  \n    #ifdef WEAVE\n    // This is the trick you use to turn circles into a weave. It's very simple, but it\n    // took me a while to figure out. Simply reverse the rendering order of the circles\n    // on the bottom half of each cell. Just remember that the X and Y vector positions\n    // (selected members, or whatever they're called) represent the polar coordinates of \n    // the cell. The don't literally mean X and Y... I've been doing this stuff for years \n    // and I still make that mistake. :) Anyway, the easiest way to see how it works is\n    // to comment the line out, then comment it back in again.\n    //\n    // The halfway point on the cell edge occurs at the apothem, which is the radial\n    // distance multiplied by the cosine expression below... and I knew this because \n    // I'm a good guesser. :D Seriously though, look at the geometry of a regular \n    // polygon, and the following should make sense.\n    if(p.x<rad*cos(3.14159/aNum)) p.y = -p.y;  \n    #endif\n  \n    \n    // Far left and right sides of the cells. Each point is rotated back half a \n    // cell, then edged out by the radial distance... Polar coordinate stuff... You get \n    // used to it after a while... Kind of. :D\n    vec2 p1 = p*r2(-3.14159/aNum) - vec2(rad, 0);\n    vec2 p2 = p*r2(3.14159/aNum) - vec2(rad, 0);\n\n    \n    \n    // The arc radius should be half the cell width, or half the side length of the  \n    // regular polygon that the pattern is based on... I think this is right, but I was \n    // in a hurry, so if you have time, I'd double check it. It seems to work visually \n    // though, so that's a good sign. :)\n    float offs = rad*sin(3.14159/aNum);\n    \n    \n    // Two circles. We're rendering one over the other, so we need a distance for each.\n    vec2 d = vec2(length(p1), length(p2)) - offs;\n\n    // The polar angle for respective positions on each circle. If you're doing stuff\n    // with circles, you'll want angles. In this case, they're being used to light up\n    // different parts of the circles.\n    vec2 ang = vec2(atan(p1.y, p1.x), atan(p2.y, p2.x));\n    \n    // Turning circles into arcs -- It's a standard CSG move. The centeral arc line\n    // will occur at the original outer circle radius. Because of the absolute \n    // function, the width will be double, so you just halve what you want it to be.\n    const float ew = rad/2.; // Arc width. \n    d = abs(d) - ew/2.; // Arc.\n    \n    \n    #ifdef RANDOM_ORDER\n    // Random rendering order, arranged to change every two seconds.\n    if(fract(sin(svIA + floor(iTime/2. + 37.)*.083)*45758.5453)<.5) {\n        d = d.yx;\n        ang = ang.yx;\n    }\n    #endif\n\n    // Save the alternate cell and edge width for use outside the function.\n    gDir = dir;\n    gEw = ew;\n    \n    \n    // Returning the two arc distances and their respective angles.\n    return vec4(d, ang);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y; // min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n   \n    // Scaling... Trivial in this case.\n    vec2 p = uv;\n    \n     // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 2.5/iRes; \n    \n    // Taking two samples.\n    //\n    // Drop shadow fields and angles.\n    vec4 dSh = dist(p - normalize(vec2(-1.5, -1))*.03);\n    // Distance fields and angles.\n    vec4 d = dist(p);\n    \n    // Distance field angles.\n    vec2 ang = d.zw;\n    \n\n    // RENDERING \n    \n    // Producing two line patterns.\n    //\n    // Multiple dark lines for that cliche record look. The expression, \n    // \"abs(fract(x*N - shift) - .5),\" is a repeat triangle formula of sorts and \n    // useful when you want to produce repeat edge lines... There are heaps of \n    // other ways to produce concentric lines, but I find it's the most reliable.\n    //\n    const float lnN = 8.; // Number of concentric pattern lines.\n    vec2 pat = abs(fract(d.xy/gEw*lnN - .5) - .5)*2. - .07;\n    pat = smoothstep(0., sf/gEw*lnN, pat);\n    // The darkish outer arc lines.\n    vec2 pat2 = abs(fract(d.xy/gEw/2. - .5) - .5)*2. - 1./lnN;\n    pat2 = smoothstep(0., sf/gEw/2., pat2);\n    \n    // Lighting: Using the respective arc angles to add or take away light from\n    // the surface. The light and darker sections add to the illusion. The numbers\n    // themselves are a bit of science mixed in with trial and error.\n    vec2 shad;\n\tshad.x = clamp((cos(ang.x*1.8))*1.35, 0., 1.);\n\tshad.y = clamp((1. - cos(ang.y*1.6))*1.25, 1., 2.);\n    shad = shad*.5 + .5;\n  \n    \n    // Background: Very simple, but you can make it more elaborate.\n    vec3 bg = mix(vec3(1, .9, .5), vec3(1, .85, .8), uv.y*.5 + .5)*(1. - length(uv)*.35);\n    \n    \n    #ifdef SHOW_CELLS \n    // Display the radial cell boundaries on the background. Seeing each \n    // individual cell pattern can be helpful for debug purposes.\n    float ln = min(abs(r2(-3.14159/CELL_NUM)*gP).y, abs(r2(3.14159/CELL_NUM)*gP).y);\n    bg = mix(bg, bg*1.7, 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .003));\n    bg = mix(bg, bg/12., 1. - smoothstep(0., sf*CELL_NUM/6.2831, ln*CELL_NUM/6.2831 - .0007));\n    // Alternate cell shading for even cell numbers. When the number is odd, alternate\n    // cell coloring doesn't really make sense.\n    if(mod(CELL_NUM, 2.)<.5 && gDir<0.) bg = mix(bg, bg.zzz, .25);\n    else bg = bg = mix(bg, bg.xxx, .25);\n    #endif \n    \n     \n    // Setting the scene color to that of the background.\n    vec3 col = bg;\n    \n    // Drop shadows and arc edge shadows for that fake ambient occlusion look\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y)))*.25);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y)))*.25);\n    \n    // The ring colors. We're using the same color for each, but different colors\n    // are possible.\n    vec3 col1 = vec3(.62, .6, .58);\n    vec3 col2 = col1;\n    \n    /*\n    // If using different ring colors, alternate cells need to be swapped, but\n    /// we're not, so it doesn't matter.\n    if(gDir<0.) {\n        vec3 tmp = col1; col1 = col2; col2 = tmp;\n    }\n    */\n    \n    // Applying the dark lines, edges lines and shading to each arc.\n    col1 *= (pat2.x*.3 + .7)*pat.x*shad.x;\n    col2 *= (pat2.y*.3 + .7)*pat.y*shad.y;\n    // Colored stripes, if you prefer.\n    //col1 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.x)*pat.x*shad.x;\n    //col2 *= mix(vec3(1), bg*vec3(1.1, 1, .9), 1. - pat2.y)*pat.y*shad.y;\n\n    \n    \n    // Rendering the bottom arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.x));\n    col = mix(col, col1, 1. - smoothstep(0., sf, d.x + .0035));\n    \n    // Laying down some shadowing from the top arc onto the bottom one.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.y, d.x)))*.25);\n    \n    // Rendering the top arc. Dark lines and color.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d.y));\n    col = mix(col, col2, 1. - smoothstep(0., sf, d.y + .0035));\n    \n    \n    // Extra sutble gradient coloring.\n    //col = mix(col.yxz, col, uv.y*.5 + .5);\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2417, 2450, 2470, 2470, 2528], [2530, 2996, 3014, 3051, 7264], [7267, 7267, 7321, 7369, 11658]]}
{"id": "3ljfRD", "name": "Metaball dance", "author": "dub", "description": "silly things", "tags": ["metaballs"], "likes": 3, "viewed": 90, "published": "Public", "date": "1598457153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define quad 0.70710678118\n\n#define R2 .6\n#define ct cos(iTime*.2)\n#define st sin(iTime*.3)\n#define rot mat2(ct,st,-st,ct)\n#define rot4 mat2(quad,quad,-quad,quad)\n\nfloat ball(vec2 p, float r)\n{\n    float d=length(p);\n    return (d<r)?smoothstep(0., 1.,(r-d)/r):0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord*2.0/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec2 u= vec2(sin(iTime),0.);\n    float h=0.;\n\n    h+=ball(uv, R2);\n    for (float i=8.;i>0.;i-=1.)\n        h+=ball(uv-(u*=rot4),R2*.5);\n\n    u= vec2(sin(-iTime),0.);\n    u*=inverse(rot);\n    for (float i=8.;i>0.;i-=1.)\n        h+=ball(uv-(u*=rot4),R2*.5);\n\n    fragColor.rgb = vec3(smoothstep(.41, .4,h));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 218, 218, 291], [293, 293, 350, 350, 751]]}
{"id": "3ljfzm", "name": "BC: Shifting Coordinates", "author": "BackwardsCap", "description": "Shifting coordinates\n\nInspired by this tweet: https://twitter.com/KangarooPhysics/status/1299049072771371010", "tags": ["warping"], "likes": 2, "viewed": 190, "published": "Public API", "date": "1598630586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CLEAN\n#define S 2.\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 R = iResolution.xy, p = (2.*f-R)/R.y*20.0;\n    vec2 d=iTime/S*floor(p.yx);\n    #ifdef CLEAN\n        bool b=mod(iTime,S*2.)-S>0.;\n        d*=vec2(!b,b);\n    #endif\n    c.rgb = vec3(pow(1.0-length(fract(p+d)-.5),10.*f.x/R.x));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 69, 69, 305]]}
{"id": "3llBDX", "name": "wave test test", "author": "cnwander", "description": "wave band test", "tags": ["waveband"], "likes": 1, "viewed": 39, "published": "Public", "date": "1597926046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0, 0.4, 0.6);\n    vec3 bg = vec3(0, 0.3, 0.6);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv.x += sin(uv.y * 10.0+ iTime * 5.) * 0.002;\n    uv.y += sin(uv.x * 10.0+ iTime * 5.) * 0.002;\n    \n    \n    // base\n    float d = length(uv);\n    d -= iTime * 0.2;\n    float n = 7.;\n    d = fract(d * n);\n    float w = 0.3 * length(uv);\n    float b = 0.03;\n    float r = 0.5 / n;\n    float e = smoothstep(r, r-b, d);\n\tfloat s = smoothstep(r+w, r+w-b, d) - e;\n    \n    // light\n    float l = max(uv.x*uv.y, 0.)*2. * s ;\n    \n    // highlight\n    float w2 = 0.02+sin(l)*0.1;\n    float h = smoothstep(r, r-b, d);\n\th = smoothstep(r+w2, r+w2-b, d) - h;\n    h *= l*10. + 0.2;\n    \n    \n    col *= s;\n    col += l;\n    col += h;\n    col += bg;\n    \n \n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 911]]}
{"id": "3llBWj", "name": "BC: Circles", "author": "BackwardsCap", "description": "Sort of ford circles\n\nBased off of https://www.shadertoy.com/view/3sSyDG to gain better understanding of whats going on", "tags": ["fractal", "fordcircles"], "likes": 17, "viewed": 369, "published": "Public API", "date": "1597775708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define SS(U) smoothstep(0.,PX,U)\n#define T iTime/5.\n#define S ((1.+sin(T/2.))/4.+.5)\n#define PX (S*6.)/R.y\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = S*(2.*f-R)/R.y;\n    p+=vec2(cos(T),sin(T));\n    \n    float s = 1., l;\n    \n    for(int i=0;i<20;i++)\n    {\n        l = dot(p,p)/2.;\n        \n        s /= l;\n        p /= l;\n        \n        p.xy = p.yx;\n        \n        p.x = mod(p.x,2.)-1.;\n    }\n    \n    p/=s;\n    \n    c.rgb = vec3(SS(length(p)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 175, 175, 491]]}
{"id": "3llBWS", "name": "descompuesto apollonian-v2", "author": "jorge2017a1", "description": "descompuesto apollonian-v2", "tags": ["descompuestoapollonianv2"], "likes": 4, "viewed": 84, "published": "Public", "date": "1597624517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n\n// Created by inigo quilez - iq/2013---\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n    vec3 pp=p;\n\torb = vec4(1000.0); \n    \n    float dps=0.5;\n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t\n                \n        p = -1.0 + 2.0*fract(0.5*p+0.5);\n        \n        \n        float r2 = dot(p,p);\n\t\t\n        \n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n       \n        float k = 1.5/(r2);\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n    return 0.23*abs(p.y)/scale;\n   \n}\n\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.4,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(1.0,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.01,0.02), clamp(6.0*tra.y,0.0,1.0) );\n      \n        rgb = mix( rgb, vec3(0.0,1.0,0.5), pow(clamp(1.0-2.0*tra.x,0.0,1.0),8.0) );\n        \n\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.0 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[288, 380, 410, 410, 804], [807, 807, 855, 855, 1108], [1110, 1110, 1166, 1166, 1417], [1419, 1419, 1473, 1487, 2487], [2489, 2489, 2546, 2546, 3549], [3551, 3551, 3645, 3645, 3872]]}
{"id": "3llfRl", "name": "Bending an SDF", "author": "blackle", "description": "a way to bend space that (kinda) preserves distances", "tags": ["sdf", "curve", "angle", "bend", "bending", "spacefolding", "kink"], "likes": 25, "viewed": 573, "published": "Public API", "date": "1597469877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d, float k) {\n    vec3 q = abs(p)-d;\n    vec3 e = max(vec3(0), q);\n    return mix(super(e),length(e),k) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    //to polar coordinates\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    //warp angle with sigmoid function\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    //to cartesian coordiantes\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//smin modified to expose the \"h\" variable so we can use it to texture the place where the objects meet differently\nvec2 smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return vec2(min(a,b)-h*h*h*k/6., h);\n}\n\nvec3 local_coords;\nfloat edges;\nfloat scene(vec3 p) {\n    p.z -= 2.;\n    p.yz = kink(p.yz, vec2(0,-.4), mix(1.,.0,sin(iTime)*.5+.5));\n    local_coords = p;\n    \n    float warp = dot(sin(erot(p,vec3(1,0,0),.5)*20.),cos(p*15.));\n    warp += dot(sin(erot(p,vec3(0,1,0),.5)*40.),cos(p*35.))*.5;\n    warp = smoothstep(-.5,.5,warp);\n    \n    float bar = linedist(p,vec3(0,4,0),vec3(0,-4,0))-.1;\n    float bar2 = linedist(p,vec3(0.3,4,.15),vec3(-.2,-2,.15))-.035;\n    float knob = box(p-vec3(0,4,0),vec3(.35,.9,.2), warp)-.05;\n    float knob2 = box(p-vec3(.5,4,0),vec3(.35,.35,.5), warp)-.05;\n    vec3 bc = abs(p-vec3(0,-3,0))-vec3(0,.8,0);\n    float bob = mix(length(bc), super(bc),length(sin(bc*32.)*.5+.5)*.1)-.5;\n    float sm = .05+warp*warp*.05;\n    vec2 boxes = smin(knob,knob2,sm);\n    vec2 obj = smin(min(bar,bar2),min(boxes.x,bob),sm);\n    edges = max(boxes.y, obj.y);\n    return obj.x;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])) );\n}\n\n\nvec3 fancy_mapping(vec3 p) {\n    vec3 d1 = textureLod(iChannel0,p.xz*.5, 4.).xyz;\n    vec3 d2 = textureLod(iChannel0,p.yz*.5, 3.).xyz;\n    return textureLod(iChannel0,p.xy + d2.yz*3. + d1.xy*2.,1.).xyz;\n}\n\nfloat bayer(vec2 fragCoord) {\n    return texelFetch(iChannel1, ivec2(fragCoord) % 8, 0).x;\n}\n\n#define AO(p,n,k) smoothstep(-k,k,scene(p+n*k))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-10,0,0);\n\n   \tfloat yrot = 0.1;\n    float zrot = iTime*.25;\n    if (iMouse.z > 0.) {\n        yrot = -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 50.) break;\n    }\n    vec3 lcrd = local_coords;\n    float ledg = edges;\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    vec3 tex = fancy_mapping(lcrd*.8) + fancy_mapping(lcrd*.5) + fancy_mapping(lcrd*.3);\n    ledg = smoothstep(0.,.5,ledg);\n\n    float ao = AO(p,n,.1) * AO(p,n,.3) * AO(p,n,.7);\n    float specao = AO(p,r,.1) * AO(p,r,.3) * AO(p,r,.7);\n    float spec = length(sin(r*vec3(3,2,2))*0.4+0.6)/sqrt(3.);\n    float diff = length(sin(n*vec3(2,1,1))*0.4+0.6)/sqrt(3.);\n    float specex = mix(20.+sin(tex.x*14.)*12., 3., ledg);\n  \n    tex = smoothstep(0.,1.,tex*.25);\n    vec3 col = pow(spec, specex)*specao + mix(spec,diff,ledg*.5)*ao*tex;\n    float bg = pow(length(sin(cam*vec3(3,2,2))*0.4+0.6)/sqrt(3.), 10.);\n    bg = smoothstep(-0.05,1.5,bg);\n    fragColor.xyz = hit ? col : vec3(bg);\n    fragColor.xyz = sqrt(fragColor.xyz) + bayer(fragCoord)/128.;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfRl.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 194, 215, 215, 247], [249, 249, 285, 285, 413], [415, 415, 451, 451, 705], [708, 708, 748, 748, 840], [842, 842, 880, 880, 944], [946, 1062, 1100, 1100, 1180], [1214, 1214, 1235, 1235, 2072], [2074, 2074, 2093, 2093, 2210], [2213, 2213, 2241, 2241, 2417], [2419, 2419, 2448, 2448, 2511], [2561, 2561, 2618, 2618, 4185]]}
{"id": "3llfRS", "name": "P.Gerdes & Tchokwe sand drawing5", "author": "FabriceNeyret2", "description": "not drawing isolated circles ( [url]https://shadertoy.com/view/tlXBRS[/url] variant)\nClick for dots.\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]", "tags": ["tiles", "short", "truchets"], "likes": 17, "viewed": 270, "published": "Public API", "date": "1597083627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/tlXBRS\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n#define h(i) fract(4e4*sin(i))\n#define H(i) int(2.*h(i))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / 360. + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    if (iMouse.z>0.) O -= S( length(F) - .1 );       // dots\n\n    float i = I.x + 10.*I.y +99.,                    // edge id (float)\n          r = h(i);                                  // rand(id)\n    \n    O -= r < .5\n        ? f = abs( abs(F) - .2 ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        : (                                          // )( at edge\n            f = sign(F+1e-5),\n            H(i)+H(i-f.x)+H(i-10.*f.y-f.x)+H(i-10.*f.y) < 4 // don't draw isolated circles\n              ? i = abs( length(F) - .2 ),\n                S( i -.1 ) * s(i) \n              : 0. \n           ); \n  //O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 242, 280, 280, 1406]]}
{"id": "3llfW8", "name": "Voronoise (Readability Edit)", "author": "TEttinger", "description": "Voronoise by iq ( https://www.shadertoy.com/view/Xd23Dh ) is great, but the original shadertoy seems to have changed behavior recently. API_Beast kept the desired behavior ( https://www.shadertoy.com/view/ltfSzr ). This fixes his version.", "tags": ["voronoi", "noise", "perlin", "worley", "voronoise"], "likes": 1, "viewed": 219, "published": "Public API", "date": "1596587921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Original by iq: https://www.shadertoy.com/view/Xd23Dh (seems to have been edited)\n// Made more readable and understandable by Manuel Riecke/API_Beast\n// Edit by API_Beast: https://www.shadertoy.com/view/ltfSzr\n// A reserved word, sample, was used in code in API_Beast's version, and this corrects it.\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\n\tvec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n\n\tif(iMouse.w > 0.001)\n        p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n    p = p*p*(3.0-2.0*p);\n\n\tfloat f = iqnoise( 24.0*uv, p.x, p.y );\n\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 429, 449, 449, 556], [558, 558, 578, 578, 641], [643, 643, 706, 706, 1756], [1758, 1758, 1815, 1815, 2150]]}
{"id": "3llfWM", "name": "raymarching test01", "author": "eclypse", "description": "raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 90, "published": "Public", "date": "1596886720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sineCrazy(vec3 p){\n    return (sin(p.x) + sin(p.y) + sin(p.z)) / 3.0;\n}\n\nfloat sphere(vec3 p){\n\treturn length(p) - 0.75;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat scene(vec3 p){\n    vec3 p1 = rotate(p, vec3(1.0), iTime);\n    \n    float scale = 10.0 + 10.0 * abs(sin(iTime * 0.5));\n    \n    return max( sphere(p), sineCrazy(p1 * scale) / scale );\n}\n\nvec3 getNormal(vec3 p){\n    vec2 o = vec2(0.001, 0.0);\n    \n    return normalize(vec3( \n        scene(p + o.xyy) - scene(p - o.xyy),\n    \tscene(p + o.yxy) - scene(p - o.yxy),\n    \tscene(p + o.yyx) - scene(p - o.yyx)\n    ));\n    \n}\n\nvec3 getColor(float amount){\n\tvec3 col = 0.5 + 0.5 * cos(6.28318530718 * (vec3(0.2, 0.0, 0.0) + amount * vec3(1.0, 1.0, 0.5)));\n\treturn col * amount;\n}\n\nvec3 getColorAmount(vec3 p){\n    float amount = clamp((1.5 - length(p)) / 2.0, 0.0, 1.0);\n\tvec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2, 0.0, 0.0) + amount * vec3(1.0, 1.0, 0.5)));\n\treturn col * amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec3 camPos = vec3(0.0, 0.0, 2.);\n    \n    vec3 ray = normalize(vec3(uv, -1.0));\n    \n    vec3 rayPos = camPos;\n    \n    vec3 light = vec3(-1.0, 1.0, 1.0);\n    \n    float curDist = 0.0;\n    float rayLen = 0.0;\n    \n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i <= 64; i++){\n    \tcurDist = scene(rayPos);\n        rayLen += 0.6 * curDist;\n        \n        rayPos = camPos + ray * rayLen;\n\n        color += 0.2 * vec3(getColorAmount(rayPos));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 673], [675, 675, 720, 720, 793], [795, 795, 819, 819, 872], [874, 874, 895, 895, 923], [925, 925, 956, 956, 1043], [1045, 1045, 1065, 1065, 1235], [1237, 1237, 1260, 1260, 1467], [1469, 1469, 1497, 1497, 1620], [1622, 1622, 1650, 1650, 1828], [1831, 1831, 1888, 1938, 2561]]}
{"id": "3llfzl", "name": "Dithering Boze", "author": "kaiware007", "description": "Dithering test", "tags": ["raymarching"], "likes": 6, "viewed": 80, "published": "Public", "date": "1597477309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.5, 0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\nsurface map(vec3 p)\n{\n\tsurface result;\n    /*\n    vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    float bg = sdCappedCylinder(q, 0.5, 100.);\n    \n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    result = SURF_BG1(bg, p);\n    */\n    // boze    \n    //result = opU(result, sdBozeFullBody(p));\n    result = sdBoze(p, vec3(1), 1.);\n    \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n*/\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nfloat drawLine(vec2 uv, vec2 a, vec2 b) {\n\tfloat len = smoothstep(1.0,0.5,length(b - a));\n    return smoothstep(0.025,0.001,sdSegment(uv, a, b)) * len;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    \n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //uv += vec2(M_PI);\n    uv = abs(uv);\n    vec2 suv = uv * 20.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    vec2 p[9];\n    int i = 0;\n    for (float y = -1.0; y <= 1.0; y++) {\n        for (float x = -1.0; x <= 1.0; x++) {\n        \tp[i++] = getPoint(id, vec2(x,y));\n        }\n    }\n    \n    for (int i = 0; i < 9; i++) {\n    \tcol += drawLine(fuv, p[4], p[i]);\n        float sparkle = 1.0 / pow(length(fuv - p[i]), 1.75) * 0.001;\n        //col += sparkle * (sin(t + fract(p[i].x) * 12.23) * 0.4 + 0.6);\n        col += sparkle;\n    }\n    \n    col += drawLine(fuv, p[1], p[3]);\n    col += drawLine(fuv, p[1], p[5]);\n    col += drawLine(fuv, p[7], p[3]);\n    col += drawLine(fuv, p[7], p[5]);\n    /*\n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t*/\n    return col * sinebow(uv.x);\n\t\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nfloat luminance(vec3 col)\n{\n\treturn 0.299*col.r + 0.587*col.g + 0.114*col.b;\n}\n\n#define COL1 vec3(0.156, 0.188, 0.145)\n#define COL2 vec3(0.647, 0.701, 0.364)\n\nvec3 ditherEffect(vec2 uv, vec3 col)\n{\n    const mat4x4 ditherPattern4x4 = mat4x4(\n\t\t15., 135., 45., 165.,\n\t\t195., 75., 225., 105.,\n\t\t60., 180., 30., 150.,\n\t\t240., 120., 210., 90.)/255.;\n\n    float lum = luminance(col);\n    vec2 iuv = mod(uv, 4.);\n    float th = ditherPattern4x4[int(iuv.x)][int(iuv.y)];\n    return mix(COL1, COL2, ceil(lum - th));\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    \n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 reso = floor(iResolution.xy * 0.5);\n    vec2 coord = floor(fragCoord.xy * 0.5);\n    //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec2 p = (coord.xy * 2.0 - reso.xy) / min(reso.x, reso.y);\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 5.) * 0.5 + 0.75;\n    float y = 0.;\n    //float r = 2.0 + sin(t * 0.5);\n    float r = 1.;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n    //float theta = 0.;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    float phi   = (mouseUV.y) * RAD90;\n    //float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0.1, 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    col = ditherEffect(coord, col);\n                     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[947, 1196, 1219, 1219, 1292], [1336, 1832, 1874, 1874, 2015], [3185, 3261, 3283, 3283, 3614], [3617, 3805, 3828, 3828, 3913], [3915, 3934, 3956, 3956, 4073], [4075, 4094, 4117, 4117, 4220], [4222, 4242, 4263, 4263, 4397], [4399, 4418, 4440, 4440, 4573], [4575, 4595, 4617, 4617, 4742], [4744, 4744, 4781, 4846, 5287], [5289, 5289, 5310, 5310, 5380], [5382, 5382, 5405, 5405, 5484], [5487, 5487, 5509, 5509, 5926], [6037, 6037, 6058, 6058, 6199], [6201, 6201, 6231, 6231, 6361], [6363, 6363, 6424, 6424, 6562], [6564, 6564, 6590, 6590, 6899], [6901, 6961, 6987, 6987, 7853], [7855, 7935, 7976, 7976, 8147], [8149, 8249, 8285, 8285, 8313], [8315, 8315, 8361, 8361, 8417], [8419, 8419, 8450, 8450, 8541], [8543, 8543, 8593, 8593, 8711], [8713, 8713, 8774, 8774, 8905], [8907, 8907, 8944, 8944, 9033], [9035, 9035, 9105, 9105, 9239], [9241, 9241, 9305, 9305, 9422], [9424, 9424, 9476, 9476, 9583], [9585, 9585, 9618, 9644, 9675], [9677, 9677, 9702, 9702, 9721], [9722, 9722, 9747, 9747, 9766], [9767, 9767, 9803, 9803, 9831], [9833, 9833, 9892, 9892, 10205], [10207, 10207, 10240, 10240, 10305], [10307, 10331, 10383, 10383, 10502], [10504, 10614, 10646, 10646, 10740], [10742, 10742, 10776, 10776, 10927], [10929, 10929, 10963, 10963, 11111], [11113, 11113, 11147, 11147, 11282], [11284, 11284, 11312, 11312, 11397], [11398, 11456, 11527, 11527, 11855], [11857, 11857, 11939, 11939, 12307], [12309, 12394, 12438, 12438, 12662], [12664, 12721, 12758, 12799, 12882], [12884, 12884, 12923, 13095, 13204], [13206, 13206, 13255, 13255, 13814], [13816, 13816, 13855, 13901, 13986], [13988, 13988, 14029, 14139, 14253], [14268, 14319, 14356, 14356, 14378], [14380, 14380, 14423, 14423, 14445], [14447, 14447, 14491, 14491, 14512], [14514, 14514, 14557, 14557, 14656], [14659, 14659, 14704, 14704, 15133], [15135, 15135, 15156, 15156, 15220], [15222, 15222, 15262, 15262, 15387], [15390, 15390, 15425, 15425, 15573], [15575, 15575, 15609, 15609, 15785], [15787, 15787, 15822, 15822, 15857], [15859, 15859, 15896, 15896, 15931], [15933, 16104, 16189, 16189, 16266], [16268, 16311, 16386, 16386, 16805], [16807, 17385, 17469, 17469, 17812], [17814, 17820, 17872, 17872, 18028], [18030, 18030, 18090, 18090, 18131], [18133, 18348, 18379, 18379, 18428], [18430, 18430, 18457, 18457, 18495], [18497, 18497, 18526, 18526, 18564], [18566, 18566, 18593, 18593, 18642], [18645, 18874, 18895, 18895, 19034], [19060, 19060, 19092, 19092, 19205], [19207, 19207, 19239, 19239, 19379], [19381, 19381, 19414, 19414, 19646], [19648, 19648, 19671, 19671, 20250], [20252, 20252, 20277, 20277, 20438], [20440, 20440, 20483, 20483, 21496], [21497, 22405, 22490, 22565, 23014], [23016, 23016, 23048, 23048, 26713], [26715, 26932, 26953, 26953, 27490], [28864, 28864, 28913, 28913, 29211], [29214, 31001, 31038, 31038, 31128], [31130, 31130, 31171, 31171, 31283], [31285, 31285, 31311, 31311, 33875], [33880, 34051, 34072, 34072, 34120], [34122, 34122, 34183, 34268, 34467], [34469, 34469, 34542, 34634, 34834], [34836, 34836, 34878, 34958, 35012], [35014, 35014, 35063, 35063, 35111], [35113, 35113, 35186, 35243, 35458], [35460, 35460, 35480, 35480, 35505], [35508, 35692, 35742, 35826, 36184], [36186, 36186, 36241, 36298, 36558], [36560, 36560, 36656, 36656, 38051], [38053, 38255, 38288, 38344, 38530], [38532, 38532, 38571, 38571, 38614], [38616, 41108, 41187, 41187, 43602], [43604, 43604, 43644, 43644, 45838], [45840, 45840, 45867, 45867, 45918], [45999, 45999, 46037, 46037, 46354], [46355, 46945, 46987, 46987, 47165], [47168, 47168, 47225, 47225, 49246]]}
{"id": "3lsBD2", "name": "17. Using Polar Coordinates", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=r1UOB8NVE8I\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI understand it ! ", "tags": ["polarcoordinates"], "likes": 1, "viewed": 213, "published": "Public API", "date": "1597800160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n\t \n    // atan( uv.x , uv.y ) : -pi ~ pi so it have to remap 0 ~ 1 by diving 6.2813 + 0.5f\n    vec2 st = vec2( atan(uv.x , uv.y ) , length(uv) );\n    uv = vec2( st.x / 6.2831f + 0.5f + iTime * 0.1f + st.y * 2.0f , st.y );\n    \n    float x = uv.x * 8.0f;\n    float m = min( fract(x) , fract(1.0-x) ); // 0.0f ~ 0.5f : remember this expression\n    float c = smoothstep( 0.0f, 0.01f , m * 0.3f + 0.1f - uv.y );\t// zig zag partten\n    \n    \n    // Zig zag pattern\n    //float c = smoothstep( 0.0f, 0.1f , m - uv.y );\t// zig zag partten\n    \n    // Line pattern\n    //float c = smoothstep( 0.0f , 0.1f , m);\n    \n    \n    //fragColor = vec4(st.x / 6.2831f + 0.5f );\t// -pi ~ pi => Remap 0  ~ 1\n    fragColor = vec4(c );\t// -pi ~ pi => Remap 0  ~ 1\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 874]]}
{"id": "3lsBD8", "name": "crater noise", "author": "okelly4408", "description": "crater noise", "tags": ["noise", "sphere", "craters"], "likes": 7, "viewed": 120, "published": "Public", "date": "1596597807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\nconst vec3 BOX = vec3(0.5);\nconst float eps = 0.0001;\nfloat hash(\n\tin float n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nvec3 getColor(vec3 pos, vec3 normal){\n\tfloat slope = abs(normal.y);\n\tvec3 mainColor = vec3( 0.75 *vec3(0.9647, 0.3843, 0.23549));\n\tvec3 orangeRust = vec3(195.0, 88.0, 23.0)/255.0;\n\tvec3 mid  = vec3(0.75686276,0.6039216,0.41960785) * 0.8;\n\tvec3 col = mix(mid * 0.75, orangeRust * 0.65, slope * .75 );\n\treturn col * 0.5;\n}\n\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm (in vec3 p, in int octaves)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < octaves; i++)\n    {\n        float n = noise((p * m) * freq) / freq;\n        f += n;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n\n\nvec4 gpuGetCell3D(const in int x, const in int y, const in int z)\n{\n\tfloat u = float(x + y * 31) / 256.0;\n\tfloat v = float(z - x * 3) / 256.0;\n\treturn(texture(iChannel1, vec2(u, v)));\n}\n\nvec2 gpuCellNoise3D(const in vec3 xyz)\n{\n\tint xi = int(floor(xyz.x));\n\tint yi = int(floor(xyz.y));\n\tint zi = int(floor(xyz.z));\n\n\tfloat xf = xyz.x - float(xi);\n\tfloat yf = xyz.y - float(yi);\n\tfloat zf = xyz.z - float(zi);\n\n\tfloat dist1 = 9999999.0;\n\tfloat dist2 = 9999999.0;\n\tvec3 cell;\n\n\tfor (int z = -1; z <= 1; z++)\n\t{\n\t\tfor (int y = -1; y <= 1; y++)\n\t\t{\n\t\t\tfor (int x = -1; x <= 1; x++)\n\t\t\t{\n\t\t\t\tcell = gpuGetCell3D(xi + x, yi + y, zi + z).xyz;\n\t\t\t\tcell.x += (float(x) - xf);\n\t\t\t\tcell.y += (float(y) - yf);\n\t\t\t\tcell.z += (float(z) - zf);\n\t\t\t\tfloat dist = dot(cell, cell);\n\t\t\t\tif (dist < dist1)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist1;\n\t\t\t\t\tdist1 = dist;\n\t\t\t\t}\n\t\t\t\telse if (dist < dist2)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec2(sqrt(dist1), sqrt(dist2));\n}\n\nfloat f2mf1(vec3 p)\n{\n\tvec2 c = gpuCellNoise3D(p);\n\n\treturn c.y - c.x;\n}\n\n\nfloat craterNoise3D(in vec3 p){\n\t\n    \n    const float radius = 0.25;\n    const float slope = .095;\n    const float frequency = 2.35;\n    const float depth = -0.982;\n    const float rimWidth = 0.125;\n    \n\tfloat fractal = fbm(p * frequency * 2.0, 4) * 0.07;\n\tfloat cell = gpuCellNoise3D((p * frequency) + fractal ).x;\n\tfloat r = radius + fractal;\n\tfloat crater = smoothstep(slope, r, cell);\n\t  \t  crater = mix(depth, crater, crater);\n\tfloat rim = 1.0 - smoothstep(r, r + rimWidth, cell);\n\t      crater = rim - (1.0 - crater);\n\treturn crater * 0.08;\n}\n\n  \nfloat sdSphere(vec3 p, vec3 c, float r) {\n    \n    return length(p - c) - (r + (fbm(p * 2.15, 6) * 0.25) + (craterNoise3D(p / 2.0)));\n}\n\nfloat map(in vec3 p){\n    return sdSphere(p, vec3(0.0), 4.0);\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.0; \n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd;\n        float h = map(p);\n        if(abs(h)<MIN_DIST) break;\n        t+=h*0.75;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return t;\n}\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 li = normalize(vec3(0.5, .8, 3.0));\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0;\n    vec3 ro = vec3( 8.0 * sin(a + float(iTime * 0.25)), 7.0, 8.0* cos(a + float(iTime * 0.25)));\n    vec3 ta = vec3(0,0,0);\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    float t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 normal = sNormal(pos);\n        //col =mix(vec3(0.6, 0.4, 0.3), vec3(0.2), smoothstep(4.5, 5.5, length(pos))) + 0.25*pow(max(dot(li, normal)*1.2, 0.05), .75);\n        col = (dot(li, normal) + 1.15) * getColor(pos, normal);\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 145, 145, 182], [184, 184, 221, 221, 504], [506, 506, 529, 529, 889], [1016, 1016, 1055, 1055, 1247], [1251, 1251, 1318, 1318, 1436], [1438, 1438, 1478, 1478, 2198], [2200, 2200, 2221, 2221, 2272], [2275, 2275, 2306, 2306, 2825], [2830, 2830, 2871, 2871, 2965], [2967, 2967, 2988, 2988, 3030], [3031, 3031, 3055, 3055, 3254], [3255, 3255, 3287, 3287, 3531], [3532, 3532, 3587, 3587, 3922], [3923, 3923, 3980, 3980, 4746]]}
{"id": "3lsBDS", "name": "SchwarzChristoffel tiling", "author": "cyperus", "description": "SchwarzChristoffel tiling\n\nbased on mla@[url]https://www.shadertoy.com/view/tsfyRj[/url]", "tags": ["complex", "conformal", "tiling", "schwarzchristoffel"], "likes": 7, "viewed": 333, "published": "Public API", "date": "1597622161", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"SchwarzChristoffel tiling\"\n//\n// created by Colling Patrik (cyperus) in 2020-08-16\n//\n// based on code from\n// - \"The Schwarz-Christoffel mapping:\" by Matthew Arcus in 2020\n//   https://www.shadertoy.com/view/tsfyRj\n//\n// FEATURES:\n// - inverse Mobius (use mouse)\n// - Schwarz-Christoffel\n// - square and hexagonal tiling with cyclic mirroring\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359,\n    PI_2 = PI/2., PI_3 = PI/3., PI_4 = PI/4., PI_6 = PI/6.,\n    SQRT2 = sqrt(2.), SQRT_2 = 1./SQRT2,  \n    SQRT3 = sqrt(3.), SQRT_3 = 1./SQRT3;\n\n// 1D-transformations: float => float\nfloat csteps(float x,float b){\n    //centered step, step width b\n    return b*floor((x/b+0.5));\n}\nfloat signeveodd(float x){\n    return sign(mod(x-0.5,2.)-1.);\n}\nfloat smoothpuls(float x,float b){\n    return smoothstep(abs(b),0.,abs(x));\n}\n    \n// 2D-transformations: vec2 => vec2\n// complex operations\nvec2 cmul(vec2 z, vec2 w) {\n\treturn vec2(z.x*w.x-z.y*w.y,\n                z.x*w.y+z.y*w.x);\n}\nvec2 cinv(vec2 z) {\n\treturn z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w) {\n\treturn cmul(z,cinv(w));\n}\nvec2 cpow(vec2 z, int n) {\n\tfloat r = length(z);\n\tfloat theta = atan(z.y,z.x);\n\treturn pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\nvec2 crot(vec2 z,float a){\n\tfloat si = sin(a), co = cos(a);\n\treturn mat2(co,-si,si,co)*z;\n}\n// grid's\nvec2 recgrid2rec(in vec2 Z, out vec2 Z_id, out float  z_sr){  \n    // maps a grid of unit-squares to one unit-square\n    // The unit-square is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,PI_4);\t\t// F:orientation-offset of cell\n    Z/= SQRT_2;\t\t\t\t// F:scale cell\n    Z_id = 2.*floor(Z*.5+0.5);\t// global cell offset id (...,-4,-2,0,+2,+4,...)\n    vec2 Z_lo = Z-Z_id;\t\t\t// local cell coord's\n    Z = Z_lo;\t\t\t\t// mape grid-cell to unit-cell\n    z_sr = signeveodd(0.5*(Z_id.x+Z_id.y));// sense of rotation of local cell    \n    Z_id = vec2(signeveodd(Z_id.x*0.5),signeveodd(Z_id.y*0.5));//(...,-2,-1,0,+1,+2,...)\n    Z.x *= Z_id.x;//mirror x\n    Z.y *= Z_id.y;//mirror y\n    Z *= SQRT_2;\t\t\t// B:scale cell\n    return crot(Z,-PI_4);\t// B:orientation-offset of cell\n}\nvec2 hexgrid2hex(in vec2 Z, out vec3 U_id){        \n    // maps a grid of unit-hexagons to one unit-hexagon\n    // with edge orientation pointing in x plus direction\n    // using cubic coordinates\n    // The unit-hexagon is inside of the unit-circle    \n    // ==> https://www.redblobgames.com/grids/hexagons/\n\t// ==> https://bl.ocks.org/patricksurry/0603b407fa0a0071b59366219c67abca\n\tconst mat2 M = mat2(SQRT_3,-1.,-SQRT_3,-1.),\n        iM = 0.5*mat2(SQRT3,-SQRT3,-1.,-1.);\n    Z = crot(Z,PI_6);\t\t// F:orientation-offset of cell     \n    Z = iM*Z/0.75;          // F:scale cell\n    vec3 U = vec3(Z.x,-Z.x-Z.y,Z.y);// plane: x+y+z=0\n    U_id = 2.*floor(U*0.5+0.5);\t\t// global cell offset id \n    vec3 U_lo = U-U_id;\t\t\t\t// local cell coord's\n    vec3 aU_lo = abs(U_lo);\n    if (aU_lo.x > aU_lo.y && aU_lo.x > aU_lo.z) U_lo.x = -U_lo.y-U_lo.z;\n    if (aU_lo.y > aU_lo.z) U_lo.y = -U_lo.x-U_lo.z;\n    else U_lo.z = -U_lo.x-U_lo.y;\n    Z = U_lo.rb; \t\t\t// mape grid-zell to unit-zell\n    Z = M*Z*0.75; \t\t\t// B:scale of cell\n    return crot(Z,-PI_6);\t// B:orientation-offset of cell  \n}\nvec2 hex2tri(in vec2 Z, out float a_id, out float a_cy){\n    // maps 6 triangles inside a unit-hexagon to one unit-triangle\n    // The unit-hexagon is inside of the unit-circle\n    // with edge orientation pointing in x plus direction    \n    Z = crot(Z,-PI_6); \t\t// orientation adaption  tri2hex ==> hexgrid2hex \n    Z = crot(Z,PI_3);\t\t// F:orientation-offset of simplex  \n    float a = atan(Z.y,Z.x);   \n    a_id = floor(a/PI_3+0.5);// triangle offset id ((-3),-2,-1,0,1,2,(3))\n    float a_lo = a-PI_3*a_id;\t\t\t// local coord's angle\n    a_cy = signeveodd(a/PI_3);\t\t\t// cycle even +1, odd -1\n    Z = crot(Z,PI_3*a_id);\t\t\t\t// mape grid-zell to unit-triangle\n    Z = (Z-vec2(SQRT_3,0.))*SQRT3; \t\t// translation,scale unit-triangle\n    Z.y *= a_cy;\t\t\t\t\t\t// y-mirror cyclic\n    return crot(Z,-PI_3);\t\t\t\t// B:orientation-offset of unit-triangle\n    }\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v){\t\t// hue, saturation, value\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// inface: vec2 => bool\nbool inudisk(vec2 z){\n    // in unit disk\n\treturn (length(z)<1.);\n}\n\nbool inupoly(vec2 z,int k){\n    const float PI = 3.14159265359;\n    // in unit polygon\n    k = abs(k);\t\t\t//poly-num-edges\n    bool m = true;\t\t//bit-mask    \n    if (k<3) m = false;\n    else{   \n    \tfloat a = PI/float(k);\n    \tfloat h = cos(a);//\n    \tfor (int i=0; i<k; i++){\n        \tfloat a1 = 2.*a*float(i);\n        \tvec2 w = vec2(cos(a1),sin(a1));\n        \tif(dot(w,z)>h) m = false;\n        }\n    }\n    return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// This code is from Matthew Arcus, 2020. \"The Schwarz-Christoffel mapping:\"\n// https://www.shadertoy.com/view/tsfyRj\n////////////////////////////////////////////////////////////////////////////////\nfloat binomial(float a, int n) {\n   float s = 1.0;\n   for (int i = n; i >= 1; i--,a--) {\n     s *= float(a)/float(i);\n   }\n   return s;\n}\n\n// The Lanczos approximation, should only be good for z >= 0.5,\n// but we get the right answers anyway.\nfloat gamma(float z) {\n  const float[8] p = float[](\n    676.5203681218851,\n    -1259.1392167224028,\n    771.32342877765313,\n    -176.61502916214059,\n    12.507343278686905,\n    -0.13857109526572012,\n    9.9843695780195716e-6,\n    1.5056327351493116e-7\n  );\n  z -= 1.0;\n  float x = 0.99999999999980993; // Unnecessary precision\n  for (int i = 0; i < 8; i++) {\n    float pval = p[i];\n    x += pval/(z+float(i+1));\n  }\n  float t = z + 8.0 - 0.5;\n  return sqrt(2.0*PI) * pow(t,z+0.5) * exp(-t) * x;\n}\n\n// The Beta function\nfloat B(float a, float b) {\n  return (gamma(a)*gamma(b))/gamma(a+b);\n}\n\n// Original Octave/Matlab code for main function:\n// w=z(inZ).*( 1-cn(1)*h+(-cn(2)+(K+1)*cn(1)^2)*h.^2+\n// (-cn(3)+(3*K+2)*(cn(1)*cn(2)-(K+1)/2*cn(1)^3))*h.^3+\n// (-cn(4)+(2*K+1)*(2*cn(1)*cn(3)+cn(2)^2-(4*K+3)*(cn(1)^2*cn(2)-(K+1)/3*cn(1)^4)))*h.^4+\n// (-cn(5)+(5*K+2)*(cn(1)*cn(4)+cn(2)*cn(3)+(5*K+3)*(-.5*cn(1)^2*cn(3)-.5*cn(1)*cn(2)^2+\n//   (5*K+4)*(cn(1)^3*cn(2)/6-(K+1)*cn(1)^5/24))))*h.^5./(1+h/C^K) );\n\nvec2 inversesc(vec2 z, int K) {\n  float cn[6];\n  for (int n = 1; n <= 5; n++) {\n    cn[n] = binomial(float(n)-1.0+2.0/float(K),n)/float(1+n*K); // Series Coefficients\n  }\n  float C = B(1.0/float(K),1.0-2.0/float(K))/float(K); // Scale factor\n  z *= C; // Scale polygon to have diameter 1\n  vec2 h = cpow(z,int(K));\n  float T1 = -cn[1];\n  float T2 = -cn[2]+float(K+1)*pow(cn[1],2.0);\n  float T3 = -cn[3]+float(3*K+2)*(cn[1]*cn[2]-float(K+1)/2.0*pow(cn[1],3.0));\n  float T4 = -cn[4]+float(2*K+1)*(2.0*cn[1]*cn[3]+pow(cn[2],2.0)-float(4*K+3)*\n                                  (pow(cn[1],2.0)*cn[2]-float(K+1)/3.0*pow(cn[1],4.0)));\n  float T5 = -cn[5]+float(5*K+2)*(cn[1]*cn[4]+cn[2]*cn[3]+float(5*K+3)*\n            (-0.5*pow(cn[1],2.0)*cn[3]-0.5*cn[1]*pow(cn[2],2.0)+float(5*K+4)*\n            (pow(cn[1],3.0)*cn[2]/6.0-float(K+1)*pow(cn[1],5.0)/24.0)));\n  vec2 X = vec2(1,0)+h/pow(C,float(K));\n  vec2 w = cmul(z,vec2(1,0) + T1*h + T2*cpow(h,2) + T3*cpow(h,3) + T4*cpow(h,4) + cdiv(T5*cpow(h,5),X));\n  return w;\n}\n\nvec3 getcolor(vec2 z, int K) {\n  if (iMouse.x > 0.0) {\n    // Apply an inversion/Mobius transformation\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/min(iResolution.x,iResolution.y); \n    m /= dot(m,m); // m inverted in unit circle\n    z -= m;\n    z *= (dot(m,m)-1.0)/dot(z,z);\n    z += m;\n  }\n  // And a rotation (also a Mobius transformation)\n  z = crot(z,0.5*iTime);\n  float r = length(z);\n  float theta = atan(z.y,z.x); //CHANGE: frequenz!!\n  vec3 col = hsv2rgb(theta/(2.0*PI),1.0,1.0);\n  float A = 4.0;\n  float B = 2.0*float(K);\n  float a = -log(r)*A;\n  float ds = 0.07;\n  if (a <= 6.0+ds) {\n    a = fract(a);\n    float b = fract(theta/PI*B);\n    float d = min(min(a,1.0-a),min(b,1.0-b));\n    col *= mix(0.2,1.0,smoothstep(-ds,ds,d));\n  }\n  return col;\n}\n////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = 2.*(2.*fragCoord.xy - iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n  int K = (3+int(0.1*iTime)%2); \n  //  \n  if (K==4){\n  \tvec2 recgrid_id = vec2(0.); float recgrid_sr;\n  \tz = recgrid2rec(z, recgrid_id, recgrid_sr);\n  }\n  //  \n  if (K==3){\n  vec3 U_id = vec3(1.,1.,1.); float a_id = 1.; float a_cy = 0.;\n  z = hexgrid2hex(z, U_id);\n  z = hex2tri(z, a_id, a_cy);\n  }      \n  //\n  z = inversesc(z,K);  \n  // color  \n  vec3 col = vec3(0.5); \n  col = getcolor(z,K);\n  fragColor = vec4(0.6*col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[796, 834, 864, 898, 931], [932, 932, 958, 958, 995], [996, 996, 1030, 1030, 1073], [1079, 1137, 1164, 1164, 1230], [1231, 1231, 1250, 1250, 1283], [1284, 1284, 1311, 1311, 1338], [1339, 1339, 1365, 1365, 1501], [1502, 1502, 1528, 1528, 1593], [1594, 1604, 1664, 1834, 2424], [2425, 2425, 2468, 2808, 3505], [3506, 3506, 3562, 3744, 4352], [4353, 4397, 4437, 4464, 4640], [4642, 4666, 4687, 4707, 4733], [4735, 4735, 4762, 4762, 5154], [5156, 5436, 5468, 5468, 5573], [5575, 5679, 5701, 5701, 6176], [6178, 6199, 6226, 6226, 6269], [6271, 6681, 6712, 6712, 7691], [7693, 7693, 7723, 7723, 8450], [8451, 8532, 8589, 8589, 9105]]}
{"id": "3lsBzr", "name": "Waves v.7", "author": "pli", "description": "More random boat moves.", "tags": ["learning"], "likes": 5, "viewed": 251, "published": "Public API", "date": "1598087005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n\n#define SHARK_COLOR vec3(.5, .5, .5)\n\n#define SHADOW_COLOR vec3(1.0)\n\n\n#define BOAT_INITIAL_X -0.25\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distWaves(vec3 pos) {\n     vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n\n\treturn dist;\n}\n\nvec3 transformedFlotterPosition(vec3 position) {\n    position.xz = rot(0.35 * cos(iTime)) * position.xz;\n    vec3 translation = vec3(BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime), 0., BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime)); \n    vec3 transformedFlotterPosition = position + translation;\n\treturn transformedFlotterPosition;\n}\n\nfloat distBoat(vec3 pos, out vec3 headPosition) {\n\n    vec3 position = transformedFlotterPosition(vec3(0., 0., 0.));\n    vec3 p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    float distBoat = distSphere(pos, p, 0.05);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    \n    position = transformedFlotterPosition(vec3(0.0, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.05));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n\n\n    position = transformedFlotterPosition(vec3(0.0, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.05, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.1, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    position = transformedFlotterPosition(vec3(0.15, 0., 0.1));\n    p = vec3(position.x, boatYAt(gridFromCoords(position)), position.z);\n    distBoat = smoothmin(distBoat, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    headPosition = transformedFlotterPosition(vec3(0.05, 0., 0.05));\n\n    \n\treturn distBoat;\n}\n\nfloat distHead(vec3 pos, vec3 headPosition) {\n    vec3 p = vec3(headPosition.x, boatYAt(gridFromCoords(vec3(headPosition.x - 0.05, headPosition.y, headPosition.z))) + 0.05, headPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n\n    return headDist;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  float d = sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    \n\treturn d;\n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n\n    float dist = distWaves(pos);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    vec3 headPosition;\n\tfloat boatDist = distBoat(pos, headPosition);\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .6;\n    }\n    \n    \n    // head \n    float headDist = distHead(pos, headPosition);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.19, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch to the scene\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totalDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totalDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totalDist += dist;\n    }\n    \n    if(totalDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n    col = colorVariation * (1. + dot(normal, light));\n    \n    \n    // raymarch back toward the light to compute the shadows\n    light = normalize(vec3(1., 1.3, -3)); // tweak light to avoid the waves casting shadows on themselves\n\n    float shadow = 1.;\n    totalDist = 0.01;\n    dist = 0.0;\n\tfloat sv;\n    vec3 cv;\n    for(float s = 0.; s < STEPS; s++){\n        dist = distScene(pos + light * totalDist, cv, sv);\n        totalDist += dist;\n        shadow = min( shadow, 10.0*dist/totalDist );\n        if(shadow < 0.001 || totalDist > maxDist){\n            break;\n        }\n    }\n    shadow = clamp(shadow, 0., 1.);\n    col = col * (0.5 + 0.5*shadow);\n    \n    \n    //white highlight\n    if (shadow > 0.9) { // we don't want highlights in the shade, notably from the boat\n\t\tlight = normalize(vec3(1., 0.5, -3)); // tweak light to get higher shine\n        float shine = 10.;\n        vec3 refl = reflect(normalize(pos - light), normal);\n        float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n        spec = smoothstep(0.25, 0.45, spec - 0.4);\n        col = mix(col, vec3(1.), (shineVariation -  0.8 * colorVariation) * spec);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 539, 557, 557, 606], [608, 608, 651, 651, 759], [762, 762, 815, 815, 855], [858, 858, 890, 890, 915], [917, 917, 951, 951, 978], [980, 980, 1013, 1013, 1200], [1203, 1203, 1231, 1231, 1276], [1279, 1279, 1306, 1306, 1596], [1598, 1598, 1646, 1646, 1939], [1941, 1941, 1990, 1990, 4200], [4202, 4202, 4247, 4247, 4463], [4466, 4466, 4491, 4491, 4510], [4511, 4511, 4536, 4536, 4555], [4556, 4556, 4592, 4592, 4620], [4622, 4622, 4674, 4674, 5190], [5193, 5193, 5270, 5325, 5909], [5911, 5911, 5934, 5934, 6272], [6275, 6275, 6296, 6296, 8489], [8491, 8491, 8548, 8548, 8676]]}
{"id": "3lsBzS", "name": "12'' Clock", "author": "akanarika", "description": "12 seconds, I guess", "tags": ["2d"], "likes": 1, "viewed": 59, "published": "Public", "date": "1597042060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWOPI 6.28318530718\n\nbool disk(in vec2 p, in vec2 center, in float r) {\n    if (length(p - center) < r) {\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = .1 + .5 * vec3(abs(sin(iTime / 12.)), abs(cos(iTime / 12.)), abs(sin(iTime / 12.) + cos(iTime / 12.)) / 2.);\n\n    float angle = 0.;\n    for (int i = 1; i <= 12; i++) {\n        float x = sin(angle);\n        float y = cos(angle);\n        vec2 p = vec2(x, y) * .8;\n        float r = smoothstep(.2, 0., 1. + sin(float(i) / 2. + iTime / 2.)) * .05 + .1;\n        if (disk(uv, p, r)) {\n        \tcol = vec3(sin(iTime) + 1., cos(iTime) + 1., .2) * .6 + vec3(r * 4.);\n        }\n        angle += TWOPI / 12.;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 79, 79, 160], [162, 162, 219, 219, 874]]}
{"id": "3lsfD7", "name": "orb_sea", "author": "slackmage", "description": "orb sea", "tags": ["tunnel"], "likes": 2, "viewed": 187, "published": "Public API", "date": "1596912488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lowlands juggernauts - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n// Thankx to Flopine for the octan mirror method suggestion, and thanks to Mercury for writing it.\n\n// \"Fortnite is cool, but don't forget who the real fascists are.\" - Woody Guthrie\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,gg,tnoi;vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec2 mo(vec2 p, vec2 d) {p=abs(p)-d;if(p.y>p.x) p=p.yx;return p;} //FLOPINE MULTI OCTAN MIRROR THINGY WRITEN BY MERCURY IN THEIR SDF LIB  https://www.shadertoy.com/view/ttffWH\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{ \n  np=p; p.z=mod(p.z+tt*5.,40.)-20.;  \n  op=p; //Originally thought I would do a sort of bounce animation but i found this slow forward crawl more menacing:\n  p.y+=sin(op.z*.2+tt)*3.-5.; //Flopine pointed out a really good bounce ease function like this: p.y -= bouncy(fract(tt))*10.; using this function: float bouncy (float T){return sqrt(abs(sin(T*PI)));} \n  pp=p; //Thankx again Flopine\n  pp.xz=mo(pp.xz, vec2(1.)); \n  pp.yz*=r2(1.2+sin(p.y*.5+tt)*.3);\n  pp.yz=mo(pp.yz,vec2(0.5,1.));\n  pp.xy=mo(pp.xy,vec2(2.5));  \n  tnoi=texNoise((np.xz+vec2(20,tt*2.))*.018).r;    \n  vec2 h,t=vec2(length(p)-5.,5); //SHELL BLUE\n  t.x=max(abs(t.x)-.4,abs(pp.z)-.5);    \n  t.x=min(t.x,9.5*(op.y+tnoi*2.+4.)); //TERRAIN BLUE\n  bp=pp; bp.xy*=r2(-.9);\n  t.x=smin(t.x,0.1*max(length(bp.xz)-max(1.4-tnoi*4.,1.45),p.y-6.),2.); //TENTACLES BLUE    \n  float frill=sin(pp.y*15.)*0.03;    \n  h=vec2(length(p)-5.5,9); //SHELL WHITE\n  h.x=max(h.x,abs(pp.z)-.2);\n  h.x=max(h.x,-(length(p)-4.+frill));\n  bp=pp; bp.xy*=r2(.4585);\n  h.x=min(0.8*length(bp.yz+vec2(2,0.))-.1+abs(bp.x)*.02,h.x);\n  t=t.x<h.x?t:h;  \n  h=vec2(length(p)-5.4,1); //SHELL BLACK\n  h.x=abs(h.x)-.2;\n  h.x=max(h.x,abs(pp.z)-.3);  \n  h.x=max(h.x,abs(abs(abs(pp.x)-1.)-.5)-.25);  \n  t=t.x<h.x?t:h;    \n  h=vec2(length(p)-3.+frill,5); //CORE \n  pp.xy*=r2(-.6); h.x=smin(h.x,.8*length(pp.xz-vec2(.2,1.+tnoi*3.))-.4+frill,3.);  \n  t=t.x<h.x?t:h;   \n  h.x=min(h.x,0.2*length(cos(op*.2)-5.5)); //TERRAIN SOFT ORBS\n  g+=0.1/(0.1+h.x*h.x*40.);  \n  h=vec2(length(p)-10.+frill,5); //RED CORE   \n  pp.xy*=r2(-.1);\n  h.x=smin(h.x,length(pp.xz-vec2(.2,1.1+tnoi*3.))-.2+frill,3.);\n  h.x=smin(h.x,.6*length(abs(bp+vec3(2,2.+tnoi*5.,0.))-2.)-.7,1.);    \n  gg+=0.1/(0.1+h.x*h.x*(80.-79.9*sin(op.y*.2+tt+1.)));\n  t=t.x<h.x?t:h; t.x*=0.7;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0);\n  for(int i=0;i<228;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,12.82);\n  vec3 ro=mix(vec3(0,-4,-15.),vec3(10,2,-15.),ceil(sin(tt))),\n  cw=normalize(vec3(0,0,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.15,.1,.14)-length(uv)*.2;\n  ld=normalize(vec3(.3,.1,-.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=vec3(.1,.2,.4);\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif*vec3(1.1,.2,.4)*3.+s(.5)),fo,min(fr,1.5));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.31,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 456, 480, 480, 522], [523, 523, 540, 540, 583], [584, 584, 626, 626, 691], [692, 692, 717, 717, 757], [758, 868, 891, 891, 1164], [1165, 1165, 1184, 1184, 2961], [2962, 2962, 2990, 2990, 3159], [3249, 3249, 3306, 3306, 4200]]}
{"id": "3lsfDN", "name": "theyaremanycolors 1 - black", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 1, "viewed": 93, "published": "Public API", "date": "1596784981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(pow(hash(vec3(fragCoord.xy, iTime)), 3.0) * 0.2 + 0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 124], [126, 126, 183, 183, 274]]}
{"id": "3lsfW2", "name": "Tartan Pattern", "author": "gunthern", "description": "Tartan exercise for book of shaders ch. 09 & ch. 11", "tags": ["2d", "pattern", "tartan"], "likes": 4, "viewed": 105, "published": "Public", "date": "1597783971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat grid(in float _offset, in vec2 _uv){\n\tfloat gridx = smoothstep(0.01,0.01,sin(_uv.x-_offset));\n    float gridy = smoothstep(0.01,0.01,sin(_uv.y-_offset));\n    return gridx * gridy;\n}\n\nfloat lines(in float _offset, in vec2 _uv){\n\tfloat lines = smoothstep(0.0,0.1,sin(_uv.x-_offset));\n    return lines;\n}\n\nfloat stripes(in float _offset, in vec2 _uv){\n    float stripes = step(smoothstep(0.2,0.5,sin(_uv.y-_offset)),.5);\n    return stripes;\n}\n\nfloat box(vec2 _uv, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_uv);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_uv);\n    return uv.x*uv.y;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec2 tile(in float _zoom, in vec2 _uv){ \n    _uv *= _zoom;\n    \n     _uv.x += step(1.0, mod(_uv.y,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.004),cos(iTime*.033)));\n    _uv.x += step(1.0, mod(_uv.y+1.0,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.01),cos(iTime*.027)));\n    _uv.y += step(1.0, mod(_uv.x,2.0) * snoise(_uv*.02*vec2(sin(iTime*.001),cos(iTime*.012))));\n    _uv.y += step(1.0, mod(_uv.x+1.0,2.0)) * snoise(_uv*.25*vec2(sin(iTime*.006),cos(iTime*.02)));\n\n    return fract(_uv);\n}\n\nvec2 rotate2d(in float _angle, in vec2 _uv){\n\t_uv -= .5;\n    _uv *=  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    _uv += 0.5;\n    return _uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 1.735;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    uv = rotate2d(PI*-.45, uv);\n    \n    uv += snoise((uv*.1)+vec2(sin(iTime*.01),(uv*.05)+cos(iTime*.02)));\n    \n    //Tile for grids\n\tvec2 uv0 = tile(4.1, uv);\n    vec2 uv01 = tile(4.1, uv + vec2(2.5));\n    vec2 uv02 = tile(4.1, uv + vec2(5.0));\n    \n    vec2 uv03 = tile(4.1, uv + vec2(7.245));\n    \n    //Grids\n    float grid0 = grid(.1, uv0);\n    float grid01 = grid(.1,uv01);\n    float grid02 = grid(.1,uv02);\n    \n    float grid03 = grid(.025,uv03);\n    \n    //Boxes\n    float box0 = box(uv0-vec2(.05), vec2(.125), .01);\n    float box01 = box(uv01+vec2(.445), vec2(.125), .01);\n    float box02 = box(uv02-vec2(.05), vec2(.125), .01);\n    float box03 = box(uv02-vec2(-0.2,.05), vec2(.125), .01);\n    float box04 = box(uv02-vec2(-0.45,.05), vec2(.125), .01);\n    float box05 = box(uv01+vec2(-0.3,.445), vec2(.125), .01);\n    float box06 = box(uv01+vec2(.2,.445), vec2(.125), .01);\n    float box07 = box(uv0-vec2(.3,.05), vec2(.125), .01);\n    float box08 = box(uv0-vec2(-.45,.05), vec2(.125), .01);\n    \n    //lines to subtract from grids\n    vec2 uv0rot = rotate2d(PI*.2,uv);\n    float lines0 = lines(0.5, uv0rot*500.0);\n    \n    //stripes\n    float stripes0 = 1.0 - stripes(0.335, uv*vec2(25.75));\n    \n    col += clamp(grid0 * grid01 * grid02 + (1.0-lines0),0.0,1.0);\n    col -= box0 + box01 + box02 + box03 + box04 + box05 + box06 + box07 + box08;\n    col -= stripes0 * .5;\n    col *= clamp(1.0 - (vec3(1.0-grid03) - (1.0-lines0)),0.0,1.0);\n    col += clamp(vec3(1.0-grid03,0.0,0.0) - (1.0-lines0),0.0,1.0);\n    col *= clamp((1.0-lines0),0.9,1.0);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 77, 77, 222], [224, 224, 267, 267, 342], [344, 344, 389, 389, 480], [482, 482, 534, 534, 727], [729, 729, 750, 750, 797], [798, 798, 819, 819, 866], [867, 867, 889, 889, 924], [926, 926, 948, 948, 1996], [1998, 1998, 2037, 2037, 2478], [2480, 2480, 2524, 2524, 2655], [2657, 2657, 2714, 2764, 4507]]}
{"id": "3lsfW7", "name": "Plyworld", "author": "ruojake", "description": "Plywood terrain", "tags": ["3d", "raymarching", "terrain"], "likes": 13, "viewed": 322, "published": "Public API", "date": "1597487906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plyworld by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nfloat hash13(vec3 p)\n{\n\treturn fract(sin(dot(p, vec3(3.5341, 2.9413, 3.1533))) * 4321.123);\n}\n\nvec2 hash22(vec2 p)\n{\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\n#define sat(x) clamp((x), 0., 1.)\n#define LAYERS 60.\n\nfloat noise(vec2 p)\n{\n\tvec2 i = floor(p);\n    vec2 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(mix(hash12(i), hash12(i + o), f.x),\n               mix(hash12(i + o.yx), hash12(i + 1.), f.x),\n               f.y);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., p - i);\n    const vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(\n            mix(hash13(i), hash13(i + o.xyy), f.x),\n            mix(hash13(i + o.yxy), hash13(i + o.xxy), f.x),\n            f.y),\n        mix(\n            mix(hash13(i + o.yyx), hash13(i + o.xyx), f.x),\n            mix(hash13(i + o.yxx), hash13(i + 1.), f.x),\n            f.y),\n        f.z);\n}\n\nfloat fbm(vec2 p)\n{\n    const float per = .45;\n    const float oct = 5.;\n    \n    float res = 0.;\n    float amp = .4;\n    \n\tfor(float i = 1.; i <= oct; i += 1.)\n    {\n    \tres += amp * noise(p);\n        p += p;\n        amp *= per;\n    }\n    return smoothstep(1., 0., res);\n}\n\nvec2 noise21(float v)\n{\n\tfloat i = floor(v);\n    float f = smoothstep(0., 1., v - i);\n    return mix(hash21(i), hash21(i + 1.), f);\n}\n\nfloat stairstep(float v, float s, float b)\n{\n\tfloat i = floor(v * s);\n    float f = v * s - i;\n    f = smoothstep(b - 1., b, f * b);\n    return mix(i, i + 1., f) / s;\n}\n\nfloat pattern(vec3 p)\n{\n    float i = floor(p.y * LAYERS + .5);\n    float f = fract(p.y * LAYERS);\n\tvec2 o = hash21(i * 31. + .4) * 2. - 1.;\n    vec2 xz = p.xz;\n    p.xz += noise(p.xz * 5. + i * 3.) * .125 - .0625;\n    p.xz += mix(sin(dot(xz * 1000., o)), sin(dot(xz * 1301., o)), hash12(xz * 900.)) * .002;\n    \n    return mix( \n        fract(sin(dot(p.xz * 20. * (1. + sin(i * 1312.41) * .2), o))),\n        (cos(f * 25.1327) * 2. + 1.) * sat(1. - 100. * fwidth(p.x)),\n        smoothstep(.24, .25, min(f, 1. - f)));\n}\n\nfloat scene(vec3 p)\n{\n\tfloat res = fbm(p.xz);\n    res *= 2.5 - res * res;\n    res = mix(stairstep(res, LAYERS, 30.), res, sat(length(fwidth(p)) * 75.));\n    return .45 * (p.y + res - 2.);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t) * 2.;\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .0001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.00001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 v = vec3(0, 0, iTime * .1);\n    vec3 md = vec3(m.x * 2., m.y, -max(abs(m.x), abs(m.y) * .5));\n    \n    vec3 tgt = vec3(10., 1., 2.) + v + md;\n    vec3 ro = vec3(10.,1.5, 0.) + v;\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n\n    for(float i = 0.; i < 60.; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p);\n        if (d < 0.) d /= (i * .75 + 1.);\n        \n        if (abs(d) < .00005) break;\n        t += d;\n    }\n\n    vec3 lDir = normalize(vec3(4,4,3));\n    vec3 n = normal(p);\n    float l = sat(dot(n,lDir));\n    l *= shadow(p + n * .01, lDir, 5., 1.5);\n    \n    vec3 col = mix(vec3(.95,.92,.76), vec3(.81,.72,.45), pattern(p));\n\t\n    col *= 1. + sin(floor(p.y * LAYERS) * 5123.23) * vec3(-.06,0.,.06);\n    col *= n.y * .6 + .4;\n    \n    col *= mix(vec3(.2,.25, .35), vec3(1.2,1.17,1.), l);\n    col = mix(mix(vec3(.96,.97,1.) * sat(1.3 - rd.y), vec3(.4,.4,.42), rd.y), col, sat(1.2 - t * .1));\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfW7.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 109, 131, 131, 244], [246, 246, 268, 268, 331], [333, 333, 355, 355, 426], [428, 428, 449, 449, 517], [573, 573, 594, 594, 823], [825, 825, 846, 846, 1265], [1267, 1267, 1286, 1286, 1541], [1543, 1543, 1566, 1566, 1676], [1678, 1678, 1722, 1722, 1846], [1848, 1848, 1871, 1871, 2366], [2368, 2368, 2389, 2389, 2557], [2559, 2559, 2615, 2615, 2963], [2965, 2965, 2986, 2986, 3151], [3153, 3153, 3206, 3206, 3364], [3366, 3366, 3423, 3423, 4710]]}
{"id": "3lsfz7", "name": "many circles", "author": "butadiene", "description": "many rings", "tags": ["raymarching"], "likes": 2, "viewed": 177, "published": "Public API", "date": "1596365198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution\n  float pi = 3.1415926535;\n  mat2 rot(float r){\n      return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n  \n  float cube(vec3 p,vec3 s){\n      vec3 q = abs(p);\n      vec3 m = max(s-q,0.0);\n      return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n\n  float ring(vec3 p,float r,vec2 s){\n      vec2 q = abs(vec2(length(p.xz)-r,p.y));\n      vec2 m = max(s-q,0.);\n      return length(max(q-s,0.))-min(m.x,m.y);\n  }\n  float rings(vec3 p){\n      float cd = length(p.xz)-6.;\n      vec2 skr = vec2(length(p.xz),atan(p.x,p.z));\n      for(int i =0;i<4;i++){\n          float fi =float(i);\n          float es = skr.x-9.2/pow(2.,fi);\n          skr.x = abs(es);\n          skr.y += (fi+2.)*0.1*sign(es)*(time);\n      }\n      p.xz = skr.x*vec2(cos(skr.y),sin(skr.y));\n      float d2 = ring(p,0.2,vec2(0.2,0.3));\n      p -= vec3(0.3,0,0);\n      p.xz *= rot(pi/4.);\n      d2 = max(d2,-cube(p,vec3(0.3,0.5,0.3)));\n      d2 = max(d2,-cd);\n      return d2;\n  }\nfloat dist(vec3 p){\n\n  return rings(p);\n}\nvec3 gn (vec3 p){\n  vec2 e = vec2(0.0001,0.0);\n  return normalize(vec3(\n    dist(p+e.xyy)-dist(p-e.xyy),\n    dist(p+e.yxy)-dist(p-e.yxy),\n    dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\nvec3 lighting(vec3 p,vec3 rd){\n  vec3 n = gn(p);\n  vec3 ld = normalize(vec3(0.2,0.1,1.0));\n  float ndl = max(dot(n,ld),0.0);\n  vec3 R = normalize(-ld+2.0*n*ndl);\n  float spec = pow(max(dot(-rd,R),0.0)*sign(ndl),10.0);\n  vec3 col = vec3(0.8*ndl+spec)+0.1;\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (fragCoord.xy * 2. - resolution.xy) / min(resolution.x, resolution.y);\n    float kt =time*0.+1.;\n    float ra =25.0;\n    vec3 ro =vec3(ra*cos(kt),10,ra*sin(kt));\n    vec3 ta =vec3(0.,0,0.);\n    vec3 cdir =normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side= cross(cdir,up);\n    up = cross(side,cdir);\n    float fov =3.0;\n    vec3 rd =normalize(side*p.x+up*p.y+fov*cdir);\n    float d;\n    float t =1.001;\n    float hit =0.001;\n    for(int i=0;i<99;i++){\n      d = dist(ro+rd*t);\n      t+=d;\n      if(hit>d||t>1000.)break;\n    }\n    vec3 col =vec3(0.);\n    if(hit>d){\n      col = lighting(ro+rd*t,rd);\n    }\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 97, 97, 150], [156, 156, 182, 182, 294], [298, 298, 332, 332, 457], [460, 460, 480, 480, 986], [987, 987, 1006, 1006, 1028], [1029, 1029, 1046, 1046, 1208], [1209, 1209, 1239, 1239, 1479], [1480, 1480, 1537, 1537, 2198]]}
{"id": "3lSfzR", "name": "colored voronoi", "author": "soggymongoose", "description": "voronoi", "tags": ["voronoi"], "likes": 3, "viewed": 75, "published": "Public", "date": "1598143700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 10.\n\nfloat random21 (vec2 uv) {\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43958.5453123);\n}\n\nvec2 random22(vec2 uv) {\n    return fract(sin(vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(269.5,183.3))))*43958.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //divide screen into tiles\n    uv *= scale;\n    vec2 tUV = fract(uv);\n    vec2 tID = floor(uv); \n    \n    float minDist = 2.; //declared early to save during for loop\n    vec2 minPoint;\n    \n    //get closest dist with neighbor checking\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            //calc neighbor \n            vec2 neighbor = vec2(x,y);\n            \n            //calc neighbor point\n            vec2 point = random22(tID + neighbor);\n            \n            //animate point location\n            if (random21(point) > .5) {\n            \tpoint = 0.5 + 0.5*sin(iTime + 3.2831*point);\n            } else {\n                point = 0.5 + 0.5*cos(iTime + 4.2831*point);\n            }\n            \n            //calc dist between neighbor point and current\n            vec2 diff = (neighbor + point) - tUV; //length(neighbor offset + pos in neighbor - home tile UV)\n            float dist = length(diff); \n            \n            //update minimun distance and point \n            if( dist < minDist ) {\n        \t\tminDist = dist;\n                \n        \t\tminPoint = point;\n    \t\t} \n        }\n    }\n    \n    vec3 col = vec3(0.);\n\n    // tint acording the closest point position\n    col = vec3(vec2(minPoint),.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 45, 45, 114], [116, 116, 140, 140, 235], [237, 237, 294, 344, 1766]]}
{"id": "3lXBDB", "name": "#847 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiment", "daily"], "likes": 4, "viewed": 121, "published": "Public API", "date": "1597570058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.05\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat sceneSDF(vec3 p) {\n  // distance from the point `p` to the center of the XZ plane\n  float d = length(p.xz);\n    \n  // amplitude of the wave (height), smoothly decreased relatively to the center of the plane\n  float amp = S(25.0, 0.0, d);\n  \n  // offset of the frequency, based on the `z` coord of the plane\n  float offset = sin(-t + 0.1 * (p.z));\n  // frequency of the wave\n  float freq = map(\n    S(0.125, 0.875, abs(2.0 * fract((t + offset) / TP) - 1.0)),\n    0.0, 1.0, 0.4, 1.0\n  );\n   \n  /* main equation of the render\n\tcombination of some cos/sin based of `d`, `p.x` and `p.z`\n  */\n  float wave = amp * cos(-t\n    + freq * d\n    + sin(2.0 * t)\n    - 0.5 * cos(-2.0 * t + 0.25 * d)\n    + 0.5 * cos(t + 0.1 * TP * p.x)\n    + 0.25 * sin(-t + 0.125 * TP * p.z)\n  );\n  // sdf of a horizontal plane deformed by a wave\n  float plane = p.y + wave;\n  \n  return plane;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n/* compute surface of the object, combining normales, light, ambient etc. */\nvec3 computeSurface(vec3 pos, float f) {\n  vec3 normal = computeNormal(pos);\n\n  vec3 lightPos = vec3(2.5, -25.0, 25.0 * sin(t + 0.05 * (pos.x + pos.z)));\n  float light = max(0.0, dot(normal, lightPos));\n\n  vec3 ambient = vec3(0.2078, 0.2, 0.7725);\n\n  float fog = 5.0 / pow(f, 2.0);\n\n  return vec3(fog * light) + ambient;\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -25.0);\n\n  // rotate camera\n  float angle = map01(sin(t + P * uv.y), 0.75, 1.25) * -QP;\n  rd.yz = rotate2d(rd.yz, angle);\n  ro.yz = rotate2d(ro.yz, angle);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      color = computeSurface(pos, f);\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [998, 1069, 1093, 1156, 1940], [1973, 2187, 2215, 2215, 2432], [2434, 2511, 2551, 2551, 2833], [2835, 2862, 2917, 2917, 3543]]}
{"id": "3lXBzr", "name": "Worst shader ever - I am new", "author": "Khola", "description": "I'm one of these people who had pretty spiteful Match teachers and I'm kicking mysekf now for paying less attention. I come for an emerge from a self taught 3D design and modelling are and have really taken a scattergun approach to my learning.", "tags": ["newbie"], "likes": 0, "viewed": 69, "published": "Public", "date": "1596812456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .5\n#define iGlobalTime iTime\nfloat GetDist(vec3 p) {\nvec4 s = vec4(2, 1, 1, 2);\n\nfloat sphereDist = length(p-s.xyz)-s.w;\nfloat planeDist = p.y;\nfloat d = min(sphereDist, planeDist);\n\n\n\n\nreturn d;\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=5.;\n    \nfor(int i=1; i<MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd*dO;\n\t\tfloat dS =GetDist(p);\n\t\tdO += dS;\n\t\tif(dO>MAX_DIST || dS<SURF_DIST) break;\n    \n}\n\nreturn dO;\n\n    \n//wanting to move the camera but how?\n{\n    \n//vec3 camPos\t= vec3(.0, .0, 20.);\n    \n    }\n\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d= GetDist(p);\n\tvec2 e = vec2(1, 1);\n\nvec3 n = d - vec3(\n\tGetDist(p-e.xyy),\n\tGetDist(p-e.yxy),\n\tGetDist(p-e.yyx));\n\nreturn normalize(n);\n\n}\n\nfloat GetLight(vec3 p) {\n\tvec3 lightPos = vec3(1, 3, 1);\n\tlightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n\tvec3 l = normalize(lightPos-p);\n\tvec3 n = GetNormal(p);\n\n\nfloat dif = clamp(dot(n, l), 0., 1.);\nfloat d = RayMarch(p+n*SURF_DIST*2., l);\nif(d<length(lightPos-p)) dif *= .4;\n\nreturn dif;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) /iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(3);\n\n  //setting up Camera  \n// can move camera with iTime?\nvec3 ro = vec3(1, 3, 1)*cos(iTime);\nvec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n\n\n\n\nfloat d = RayMarch(ro, rd);\n\nvec3 p = ro + rd * d;\nfloat dif = GetLight(p);\n//?? d/=6.;\ncol = vec3(dif);\n\n\n\n\n\n// Output to screen\n    fragColor = vec4(col,1.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 114, 114, 260], [262, 262, 296, 296, 567], [569, 569, 593, 593, 740], [742, 742, 766, 766, 1037], [1039, 1039, 1097, 1147, 1566]]}
{"id": "3lXfRl", "name": "Interactive Planet", "author": "obvious_condition", "description": "Forked from: https://www.shadertoy.com/view/tltXWM", "tags": ["planet"], "likes": 6, "viewed": 192, "published": "Public", "date": "1597392358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(0.0, 0.0, 1.0);\n    vec3 col_bot = vec3(1.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.0);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) \n{\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n    \n    float alpha = (fragColor.r + fragColor.g + fragColor.b)/3.0;\n    fragColor.a = alpha;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1058, 1132, 1153, 1153, 1220], [1222, 1222, 1243, 1243, 1826], [1828, 1828, 1847, 1847, 2023], [2025, 2295, 2318, 2318, 2334], [2335, 2335, 2365, 2365, 2396], [2398, 2473, 2529, 2529, 2803], [2805, 2837, 2858, 2858, 2896], [2898, 2898, 2937, 2974, 5512], [5514, 5514, 5571, 5571, 6152]]}
{"id": "3lXfRs", "name": "Flubbers", "author": "_pwd_", "description": "It´s like Charlies Chocolate Factory is now producing rainbow flubber candy deluxe", "tags": ["raymarching", "reflection", "wobble", "rubber"], "likes": 5, "viewed": 156, "published": "Public", "date": "1597412636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n//\n// Rubbercube \n// -> Charlies Chocolate Factory´s now producing rainbow flubber candy \n//\n//\n//\n//\n//\n// references\n// \"Rubbercube\" based on Demoscene Passivist´s\n// https://bit.ly/3akEOP7\n//\n// distfunctions\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\n// Sound via soundcloud - Solar Fields: Unite\n//\n//\n//\n//    \n//\n//\n\n\nfloat m;\nfloat time;\nvec3 sync;\nvec3 n;\nint material = 0;\n\nconst vec3 materialdiffuse = vec3(1.0, 1.0, 1.0);\nconst float materialspecularexponent = 256.0;\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// displacement(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat displace(vec3 p) \n{\n\treturn ((cos(2.*p.x)*sin(4.*p.y)*sin(2.*p.z))*cos(30.1 + sin(time)*0.01));\n}\n\n\nfloat displace1(vec3 p) \n{\n\treturn ((cos(2.*p.x)*sin(4.*p.y)*sin(2.*p.z))*cos(30.1 + sin(time)*0.01));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// x,y,z rotation(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 rotXaxis(vec3 p, float rad)\n{\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\n\tp.z = z2;\n\tp.y = y2;\n\treturn p;\n}\n\nvec3 rotYaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\n\tp.x = x2;\n\tp.z = z2;\n\treturn p;\n}\n\nvec3 rotZaxis(vec3 p, float rad) \n{\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\n\tp.x = x2;\n\tp.y = y2;\n\treturn p;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// polyomial smooth min (IQ)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// cylinder\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n\treturn length(p.xz-c.xy)-c.z;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// round-box\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat pRoundBox(vec3 p, vec3 b, float r) \n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// boxes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat boxes(vec3 pos) \n{\n    float deform1 = displace1(pos);\n    \n\tm = pRoundBox(rotYaxis(rotXaxis(vec3(2.0+0.45*sin(0.8*iTime+1.2),0.77,-1.5-0.40*sin(0.8*iTime+1.2)) + pos, iTime*0.3),iTime), vec3(0.21,0.21,0.21), 0.05);\n\tm = smin (m, pRoundBox(rotYaxis(rotXaxis(vec3(-2.0+0.45*sin(0.8*iTime+1.2),0.77,-1.5+0.40*sin(0.8*iTime+1.2)) + pos, iTime*0.3),iTime), vec3(0.21,0.21,0.21), 0.05),1.4);\n\n\treturn m + deform1 * 0.45;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// union\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid fUnion(inout float d1, float d2) \n{\n    d1 = smin(d1,d2,0.5);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// map\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat map(vec3 hitpoint, vec2 fragCoord) {\n\n\tfloat d = 1.0;\n\tfloat c = 1.0;\n\n    float rubberfactor = 0.0035;\n    float phi = (1.25 + sync.r) * (time+(fragCoord.y*rubberfactor));\n    mat4 xrot = mat4(\n        vec4(1.0,       0.0,      0.0, 0.0),\n        vec4(0.0,  cos(phi), sin(phi), 0.0),\n        vec4(0.0, -sin(phi), cos(phi), 0.0),\n        vec4(0.0,       0.0,      0.0, 1.0)\n    );\n    float theta = 0.75*(time+(fragCoord.y*rubberfactor));\n    mat4 yrot = mat4(\n        vec4(cos(theta), 0.0, -sin(theta), 0.0),\n        vec4(       0.0, 1.0,         0.0, 0.0),\n        vec4(sin(theta), 0.0,  cos(theta), 0.0),\n        vec4(       0.0, 0.0,         0.0, 1.0)\n    );\n    float psi = 0.15*(time+(fragCoord.y*rubberfactor));   \n    mat4 zrot = mat4(\n        vec4( cos (psi), sin (psi), 0.0, 0.0),\n        vec4(-sin (psi), cos (psi), 0.0, 0.0),\n        vec4(       0.0,       0.0, 1.0, 0.0),\n        vec4(       0.0,       0.0, 0.0, 1.0)        \n    );  \n\n    vec3 rubberPos = vec3(yrot*xrot*zrot*vec4(hitpoint,1.0));\n\tvec3 rubberPos1 = rubberPos + vec3( 2.1, 0.0, 0.0);\n\n\tfloat m = 1.75; float s = 0.13;  \n\n    float deform  = displace(rubberPos);\n    float deform1 = displace1(rubberPos);\n    \n\tfUnion(d, pRoundBox( rubberPos, vec3(0.69,0.69,0.69), 0.35) );\n\tfUnion(d, sdCylinder(vec3(1.95*cos(0.2*iTime+1.2),1.9,-1.95*sin(0.2*iTime+1.2)) + hitpoint,vec3(0.0,0.0,0.22) ) + /*noise1(hitpoint) * 0.1*/deform );\n\n\tm = boxes(hitpoint); \n    d = sminPoly (m, d, 0.99); \n        \n    fUnion(c, pRoundBox(vec3(0.5,1.9,0.5) + hitpoint, vec3(14,0.2,14) + deform * 0.15, 0.02));\n\tfUnion(c, pRoundBox(vec3(0.5,0.5,1.95) + hitpoint, vec3(12,5,0.2) + deform1 * 0.03, 0.02));   \n    \n    if( c < d ) material = 1;\n\telse material = 0;\n    \n    fUnion(c, d);  \n    return c;\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// particles ( --> by Andrew Baldwin)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat particles(vec3 direction)\n{\n\tfloat help = 0.0;\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec2 uvx = vec2(direction.x,direction.z)+vec2(1.,iResolution.y/iResolution.x)*gl_FragCoord.xy / iResolution.xy;\n\tfloat acc = 0.0;\n\tfloat DEPTH = direction.y*direction.y-0.3;\n\tfloat WIDTH =0.1;\n\tfloat SPEED = 0.1;\n\tfor (int i=0;i<10;i++) \n\t{\n\t\tfloat fi = float(i);\n\t\tvec2 q = uvx*(1.+fi*DEPTH);\n\t\tq += vec2(q.y*(WIDTH*mod(fi*7.238917,1.)-WIDTH*.5),SPEED*iTime/(1.+fi*DEPTH*.03));\n\t\tvec3 n = vec3(floor(q),31.189+fi);\n\t\tvec3 m = floor(n)*.00001 + fract(n);\n\t\tvec3 mp = (31415.9+m)/fract(p*m);\n\t\tvec3 r = fract(mp);\n\t\tvec2 s = abs(mod(q,1.)-.5+.9*r.xy-.45);\n\t\tfloat d = .7*max(s.x-s.y,s.x+s.y)+max(s.x,s.y)-.01;\n\t\tfloat edge = .04;\n\t\tacc += smoothstep(edge,-edge,d)*(r.x/1.0);\n\t\thelp = acc;\n\t}\n\treturn help;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// ambient occlusion\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat ao(vec3 p, vec3 n, float d, vec2 fragCoord) {\n\n\tfloat s = sign(d);\n\tfloat o = s*.5+.5;\n\tfor (float i = 5.0; i > 0.; --i) {\n\t\to -= (i*d - map(p+n*i*d*s, fragCoord)) / exp2(i);\n\t}\n\treturn o;\n\t\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// normals\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(vec3 pos, vec2 fragCoord) {\n\tvec3 e = vec3(0.0,0.001,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tmap(pos+e.yxx,fragCoord)-map(pos-e.yxx,fragCoord),\n\t\t\tmap(pos+e.xyx,fragCoord)-map(pos-e.xyx,fragCoord),\n\t\t\tmap(pos+e.xxy,fragCoord)-map(pos-e.xxy,fragCoord)\n\t\t\t)\n\t);\t\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// diffuse lightning(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 diffuse(vec3 p, vec3 col, vec3 n, vec3 lightDir)\n{\n    vec3 color = col.rgb;\n    color *= vec3(max(dot(-lightDir.xyz, n), 0.0));\n    \n    return color;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// reflection(s)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 reflective(vec3 p, vec3 col, vec3 n, vec3 v, vec3 lightDir, vec2 fragCoord)\n{\n    vec3 color = col;\n    \n    vec3 r  = reflect(v, n);\n    vec3 rr = reflect(-lightDir, n);\n    \n    float ks = 0.6;\n    \n    color += ks * max(0.0, dot(rr, v));\n    \n    float t = 0.0;\n    \n    for (float i = 0.0; i < 64.0; i++)\n    {\n        vec3 q = p + r * (0.2 + t);\n        float m = map(q, fragCoord);\n        vec3 refCol = vec3(m);\n        \n        if (m < 0.001)\n        {\n            vec3 n = normal(q,fragCoord);\n\n            refCol = diffuse(p, col, n, lightDir);\n            color += (1.0 - ks) * refCol * (1.0 / (1.0 + t * t * 0.1));\n\n            break;\n        }\n        \n        t += m * 0.8;\n        \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\ttime = iTime; \n\n\t\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: sound´s sync\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n\tfloat fft = texture(iChannel1, vec2(.4, .25)).r * 2.; \n\tsync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: uv\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n\tvec2 uv      = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tuv.y        *= iResolution.y / iResolution.x;\n\tfloat fov    = min(( time*.2+.05),0.6 ); //animate fov at start\n    \n\n    //////////////////////////////////////////////////////////////////////////////////////\n    // light(s)\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n    int numlights = 8;\n    \n    vec3 lightsposition[8];\n    lightsposition[0] = vec3( 3.0,-3.0,-3.0);\n    lightsposition[1] = vec3( 3.0,-3.0, 3.0);\n    lightsposition[2] = vec3(-3.0,-3.0, 3.0);\n    lightsposition[3] = vec3(-3.0,-3.0,-3.0);\n    lightsposition[4] = vec3( 3.0, 3.0,-3.0);\n    lightsposition[5] = vec3( 3.0, 3.0, 3.0);\n    lightsposition[6] = vec3(-3.0, 3.0, 3.0);\n    lightsposition[7] = vec3(-3.0, 3.0,-3.0);\n    \n    vec3 lightsdiffuse[8];\n    lightsdiffuse[0] = vec3( 1.0,1.0,1.0);\n    lightsdiffuse[1] = vec3( 1.0,1.0,0.0);\n    lightsdiffuse[2] = vec3( 1.0,0.0,1.0);\n    lightsdiffuse[3] = vec3( 0.0,1.0,1.0);\n    lightsdiffuse[4] = vec3( 1.0,0.0,0.0);\n    lightsdiffuse[5] = vec3( 0.0,1.0,0.0);\n    lightsdiffuse[6] = vec3( 0.0,0.0,1.0);\n    lightsdiffuse[7] = vec3( 0.5,0.25,0.75);\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: ray\n\t//////////////////////////////////////////////////////////////////////////////////////\n    \n    vec2 position = -1.0+2.0*fragCoord.xy/iResolution.xy;\n    position.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.35, 4.9);\n    vec3 rd = vec3(position,0.0) + vec3(0.0, 0.0,3.5);\n    \n    \n    vec3 cw = normalize(rd - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\n    rd = normalize(rd-ro);\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////\n    // setup: raymarching params\n\t//////////////////////////////////////////////////////////////////////////////////////\n\n    const float baseaccuracy     = 0.05;\n    const float marchingstepsize = baseaccuracy;\n    const float marchingaccuracy = baseaccuracy/100.0;\n\tconst float maxdist          = 65.0;\n    float currentstep            = marchingstepsize;\n    float total                  = currentstep;\n    vec3 hitpoint                = ro+total*rd;\n    bool currentevaluation       = (map(hitpoint, fragCoord)<0.0);\n    \n    total += currentstep;\n    \n    bool startevaluation = currentevaluation;\n\tvec3 light_dir;\n    vec3 rColor;\n\t\n    while ( total < maxdist ) {\n        \n           hitpoint  = ro+total*rd;\n           currentevaluation = (map(hitpoint,fragCoord)<0.0);\n\t\t   \n\t\t   if (currentevaluation!=startevaluation) {\n\n               float temppos = total-marchingstepsize;\n\n               while (currentstep>marchingaccuracy) {\n                      currentstep *= 0.5;\n                      total = temppos+currentstep;\n                      hitpoint = ro+total*rd;\n                      currentevaluation = (map(hitpoint,fragCoord)<0.0);\n                      if (currentevaluation==startevaluation) {\n                          temppos = total;\n                      }                \n               }\n\n\t\t\t   n = normal(hitpoint,fragCoord); \n               n = normalize(n);  \n               \n               vec3 color = vec3(0, 0, 0);\n               \n               vec3 camera_direction = normalize(ro-hitpoint);\n               \n               for (int i=0; i<numlights; i++) {\n\n                    light_dir = normalize(lightsposition[i]-hitpoint);\n                    float diffuse  = max(dot(light_dir, n),0.0);\n                    float specular = max(dot(reflect(-light_dir, n), camera_direction),0.0);\n                    color += (lightsdiffuse[i]*diffuse).xyz*materialdiffuse.xyz;\n                    color += pow(specular, materialspecularexponent);\n                   \n               } \n               \n               if( material == 1 ) {\n                   \n                   color = reflective(hitpoint, color, n, rd, light_dir, fragCoord) * 0.65;\n                   \n               }\n               \n               float a = ao(hitpoint, n, 0.15,fragCoord);\n               vec3 cB = vec3(a);\n\t\t\t   color  *= cB;\n\n               vec2 uv2  = -0.3+2.*fragCoord.xy/iResolution.xy;\n\t\t\t   float scr = 1.-dot( uv2, uv2 ) * 0.15;\n\t\t\t\t\n\t\t\t   color *= cB;\n               \n\t\t\t   fragColor = vec4(color * 1.0 * scr-0.4 * particles(cv), 1.0);\n\t\t\t   return;\n\n           }\n\n\t\t   total += currentstep;\n        \n    }\n    \n    fragColor = vec4(vec3(0.0),1.0);\n    return;    \n\n}", "image_inputs": [{"id": "4l2GWy", "previewfilepath": "https://soundcloud.com/vozdra/solar-fields-unite", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vozdra/solar-fields-unite", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 717, 742, 742, 820], [823, 823, 849, 849, 927], [930, 1126, 1160, 1160, 1285], [1287, 1287, 1322, 1322, 1447], [1449, 1449, 1484, 1484, 1609], [1613, 1613, 1654, 1654, 1747], [1750, 1954, 1999, 1999, 2092], [2095, 2282, 2318, 2318, 2351], [2354, 2542, 2585, 2585, 2627], [2630, 2814, 2838, 2838, 3237], [3240, 3424, 3464, 3464, 3492], [3496, 3678, 3720, 3720, 5440], [5443, 5656, 5689, 5689, 6514], [6517, 6713, 6764, 6764, 6911], [6914, 7100, 7139, 7139, 7369], [7372, 7571, 7626, 7626, 7729], [7732, 7924, 8006, 8006, 8656], [8658, 8658, 8715, 8715, 13807]]}
{"id": "3lXfWB", "name": "Hexagonal", "author": "shirokko", "description": "animated loading icon", "tags": ["hexagon"], "likes": 5, "viewed": 136, "published": "Public", "date": "1597563616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ramp\n#define freeze_stationary_points\n// NOT WORKING\n//#define take_shortest_direction \n#define annulus1\n#define annulus2\n\n#define pi 3.14159265\n#define aspectratio iResolution.y/iResolution.x\n#define nloops 10\n#define T1 1.0\n#define T2 1.0\n#define T3 0.5\n#define T4 0.3\n\nfloat normDist(vec2 a, vec2 b)\n{\n    vec2 c = a-b;\n    return sqrt(c.x*c.x + c.y*c.y*aspectratio*aspectratio);\n}\n\nvec3 drawLine (vec2 p1, vec2 p2, vec2 uv, float a, vec3 c)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = normDist(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = normDist(p1, uv);\n\n    // if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+normDist(mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r*c;\n}\n\nvec3 drawGradientLine (vec2 p1, vec2 p2, vec2 uv, float a, vec3 c1, vec3 c2)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = normDist(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = normDist(p1, uv);\n\n    // if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+normDist(mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n    \n    // get fraction of length along the line\n    float wc = duv/d;\n        \n    return r*((1.-wc)*c1 + wc*c2);\n}\n\nvec3 drawCircle(vec2 p, float d, vec2 uv)\n{\n    return ((normDist(p, uv) <= d) ? 1. : 0.) * vec3(1.0);\n}\n\nfloat gauss(float x)\n{\n    return exp(-10000.*x*x);\n}\n\nvec3 drawGradientCircle(vec2 p, float d, vec2 uv, vec3 c1, vec3 c2)\n{\n    float r = normDist(p, uv);\n    float nr = gauss(r);\n    return ((r <= d) ? 1. : 0.) * (nr*c1 + (1.-nr)*c2);\n}\n\nvec3 drawAnnulus(vec2 p, float d1, float d2, vec2 uv, vec3 c)\n{\n    return (normDist(p, uv)>d1 && normDist(p,uv)<d2) ? c : vec3(0.);\n}\n\nint imod(int n, int m) {\n    return n >= m ? n-m*int(floor(float(n/m))) : n;\n}\n\nfloat fmod(float n, float m) {\n    return n >= m ? n - m*floor(n/m) : n;\n}\n\nfloat rand(vec2 co)\n{ // pseudorandom real [0, 1]\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nint intRand(vec2 co, int m)\n{ // pseudorandom integer [0, m)\n    return imod(int(rand(co)*100.), m);\n}\n\nbool isNeighbour(int a, int b)\n{\n    return abs(a-b)==1 || abs(a-b) == 5 ? true : false;\n}\n\nbool isComplement(int a, int b)\n{\n    return abs(a-b)==3 ? true : false;\n}\n\nint smd(int a, int b, int m)\n{ // signed modulo distance\n    return b-a > m/2 ? a-b+m : b-a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lc = vec3(129., 216., 208.);\n    vec3 hc = vec3(255.);\n    hc /= vec3(255.);\n    lc /= vec3(255.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    \n    // setup a normalized time in [0.,1.]\n    float nt = fmod(t, 1.);\n    // optional: smooth start and end\n#ifdef ramp\n    nt = (cos(nt*pi)+1.)/2.;\n#endif\n    \n    //define unit hexagon\n    vec2 hex[6];\n    for (int i=0; i<6; i++) {\n        float n = float(i)*2.;\n        hex[i] = vec2(sin(n*pi/6.), cos(n*pi/6.));\n    }\n    \n    // scale unit hexagon to center of screen\n    vec2 points[6];\n    for (int i=0; i<6; i++) {\n        points[i] = hex[i];\n        points[i] *= vec2(aspectratio, 1.);\n        points[i] *= vec2(0.5, 0.5);\n        points[i] += vec2(1.0, 1.0);\n        points[i] /= vec2(2.0, 2.0);\n    }\n    \n    // animate points\n    vec2 p[6];\n    int q[] = int[6](0, 1, 2, 3, 4, 5);\n    \n    // randomize a destination point\n    for (int i=0; i<6; i++) {\n        // setup a consistent seed for each \"loop\"\n        float ft = floor(t);\n        // number of unique \"loops\" until it does a global loop\n        ft = fmod(ft, float(nloops));\n        // choose a number to swap with\n        int a = intRand(vec2(ft, i), 6);\n        // swap those two entries\n        int t=q[a];\n        q[a] = q[i];\n        q[i] = t;\n    }\n    \n    for (int i=0; i<6; i++) {\n        // choose the endpoints\n        int j = 1;\n        int a = i;\n        int b = q[a];\n        \n#ifdef freeze_stationary_points\n        if (a != b) {\n#endif\n            // weights for a and b\n            float wa = 1.-nt;\n            float wb = nt;\n\n            // setup velocities to be the tangent\n            vec2 va = vec2(-hex[a].y, hex[a].x);\n            vec2 vb = vec2(-hex[b].y, hex[b].x);\n            // check to see if we're rotating the right way\n#ifdef take_shortest_direction\n            if (smd(a,b,6) > 0) {\n                va *= -1.; vb *= -1.;\n            }\n#endif\n            \n            float s = 0.5;\n            va *= vec2(s);\n            vb *= vec2(s);\n            //va = vec2(0.,0.);\n            //vb = vec2(0.,0.);\n            // setup 4-point stencil\n            vec2 pi0 = points[a];\n            vec2 pi1 = points[a]+va/3.;\n            vec2 pi2 = points[b]-vb/3.;\n            vec2 pi3 = points[b];\n            // define bezier curve\n            p[i] = wa*wa*wa*pi0 + 3.*wa*wa*wb*pi1 + 3.*wa*wb*wb*pi2 + wb*wb*wb*pi3;\n#ifdef freeze_stationary_points\n        } else {\n            p[i] = points[a];\n        }\n#endif\n    }\n    \n    vec3 lines;\n    for (int i=0; i<6; i++) {\n        // connect all other points\n        for (int j=0; j<6; j++) {\n            if (i==j) continue;\n        \t//int a = i; int b = imod(i+1, 6);\n            int a=i; int b=j;\n            \n            float aa = isNeighbour(a,b) ? 0.8 : 0.0; // start neighbours\n            float ba = isNeighbour(a,b) ? 0.0 : 0.2; // start interior\n            float ab = isNeighbour(q[a], q[b]) ? 0.8 : 0.0; // end neighbours\n            float bb = isNeighbour(q[a], q[b]) ? 0.0 : 0.2; // end interior\n            \n            float ta = isComplement(a,b) ? T2 : T3;\n            float tb = isComplement(q[a], q[b]) ? T2 : T3;\n            ta += isNeighbour(a,b) ? T1 : 0.0;\n            tb += isNeighbour(q[a], q[b]) ? T1 : 0.0;\n            \n        \tlines += drawLine(p[a], p[b], uv, (1.-nt)*ta + nt*tb, (1.-nt)*aa*hc+(1.-nt)*ba*lc + nt*ab*hc+nt*bb*lc);\n        }\n        \n        // connect to complement midpoints (loop start)\n        for (int j=0; j<6; j++) {\n            int a=i; int b=j;\n            if (!isComplement(a, b)) continue;\n            \n            // look for neighbours of j\n            for (int k=0; k<6; k++) {\n                int c=k;\n                if (!isNeighbour(b, c)) continue;\n                vec2 midpoint = (p[b]+p[c])/2.;\n                lines += drawGradientLine(p[a], midpoint, uv, T4, (1.-nt)*vec3(0.3), vec3(0.));\n            }\n        }\n        // connect to complement midpoints (loop end)\n        for (int j=0; j<6; j++) {\n            int a=i; int b=j;\n            if (!isComplement(q[a], q[b])) continue;\n            \n            // look for neighbours of j\n            for (int k=0; k<6; k++) {\n                int c=k;\n                if (!isNeighbour(q[b], q[c])) continue;\n                vec2 midpoint = (p[b]+p[c])/2.;\n                lines += drawGradientLine(p[a], midpoint, uv, T4, nt*vec3(0.3), vec3(0.));\n            }\n        }\n    }\n        \n    vec3 annulus;\n    for (int i=0; i<6; i++) {\n#ifdef annulus1\n        {\n            int a = i;\n            int b = q[a];\n\n            float alpha = 0.;\n            if (a == b) alpha = 1. + min(min(3.*nt, 3.-3.*nt), 1.);\n            else alpha = max(1.0+(nt-1.)*3.,0.) + max(1.0+(-nt)*3.,0.);\n\n          \tannulus += drawGradientCircle(p[i], 0.05, uv, alpha*vec3(0.5), vec3(0.));\n        }\n#endif\n#ifdef annulus2\n        {\n            // find closest point\n            float closestDist = 10000.;\n            float alpha = 0.;\n            if (i == q[i]) alpha = 2.;\n            else {\n                for (int j=0; j<6; j++)\n                    closestDist = min(normDist(points[i], p[j]), closestDist);\n                //alpha = max(1./(100.*closestDist+1.),0.);\n                alpha = exp(-30.*closestDist);\n            }\n\n            annulus += drawAnnulus(points[i], 0.025, 0.027, uv, alpha*vec3(0.4));\n        }\n#endif\n    }\n    \n\tfragColor = vec4(lines + annulus, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 282, 314, 314, 394], [396, 396, 456, 456, 870], [872, 872, 950, 950, 1455], [1457, 1457, 1500, 1500, 1561], [1563, 1563, 1585, 1585, 1616], [1618, 1618, 1687, 1687, 1801], [1803, 1803, 1866, 1866, 1937], [1939, 1939, 1963, 1963, 2017], [2019, 2019, 2049, 2049, 2093], [2095, 2095, 2116, 2144, 2216], [2218, 2218, 2247, 2278, 2320], [2322, 2322, 2354, 2354, 2412], [2414, 2414, 2447, 2447, 2488], [2490, 2490, 2520, 2546, 2584], [2586, 2586, 2643, 2643, 8041]]}
{"id": "3lXfWM", "name": "trying to create Sierpinski", "author": "CoolerZ", "description": "trying to create Sierpinski", "tags": ["fractal", "sdf", "sierpinski"], "likes": 2, "viewed": 45, "published": "Public", "date": "1596976579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sierpinski triangle fractal https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle\n\n#define NUM_LEVELS 7\n\nconst float PI = radians(180.);\nconst float PI2 = 2.*PI;\nconst float Aoff = PI2/3.;\nconst float A1 = PI/2.;\nconst float A2 = A1+Aoff;\nconst float A3 = A2+Aoff;\n\nconst vec2 ax1 = normalize(vec2(cos(A1), sin(A1)));\nconst vec2 ax2 = normalize(vec2(cos(A2), sin(A2)));\nconst vec2 ax3 = normalize(vec2(cos(A3), sin(A3)));\nconst float doff = 1./sqrt(3.);\n\nfloat tri(in vec2 p)\n{\n    //Taken from https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nbool is_outside(vec2 p)\n{\n    vec2 tpos = vec2(0.);\n    if(tri(p-tpos) > 0.)return true;\n    float scale1 = 1.;\n    float scale2 = 2.;\n    bool outside = false;\n    for(int i=1;i<=NUM_LEVELS;i++)\n    {\n        vec2 p1 = tpos + ax1*doff*scale1;\n        vec2 p2 = tpos + ax2*doff*scale1;\n        vec2 p3 = tpos + ax3*doff*scale1;\n\n        if(tri((p-p1)*scale2)<0.)tpos = p1;\n        else if(tri((p-p2)*scale2)<0.)tpos = p2;\n        else if(tri((p-p3)*scale2)<0.)tpos = p3;\n        else\n        {\n            outside = true;\n            break;\n        }\n        scale1 *= .5;\n        scale2 *= 2.;\n    }\n    return outside;\n}\n\nvec2 rot2d(vec2 p, float angle)\n{\n    mat2 r = mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle)\n    );\n    return r*p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv = rot2d(uv, iTime);\n    vec3 col = is_outside(uv) ? vec3(0.) : vec3(uv,1);\n    if(uv.x<-1. || uv.x > 1.)col = vec3(0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 459, 481, 574, 785], [787, 787, 812, 812, 1409], [1411, 1411, 1444, 1444, 1552], [1554, 1554, 1611, 1611, 1830]]}
{"id": "3sSfDz", "name": "Make Fun With Sky Simulation", "author": "shicz86", "description": "simulation of sky for learning purpose.\n[reference]\n//https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//https://www.shadertoy.com/view/3dBSDW", "tags": ["skysimulation"], "likes": 4, "viewed": 134, "published": "Public", "date": "1598447959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//https://www.shadertoy.com/view/3dBSDW\n\n#define PI 3.14159265359\n#define USE_HENYEY 1\n#define SWITCH_COLOR 0\n\n#define u_res iResolution\n#define u_time iTime\n\nvec3 sunDir = vec3(0.,1.,0.);\nfloat sunPower = 20.;\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst int numSamples = 16;\n//光线与大气层顶端交点到采样点的采样数量\n#if SWITCH_COLOR\nconst int numSamplesLIght = 8;\nconst float hR = 7994.;//rayleigh\nconst float hM = 1200.;//mie\nconst vec3 betaR = vec3(5.5e-6,13.0e-6,22.4e-6);//rayleigh\nconst vec3 betaM = vec3(21e-6);//mie\n#else\nconst int numSamplesLIght = 8;\nconst float hR = 7994.;//rayleigh\nconst float hM = 1200.;//mie\nconst vec3 betaR = vec3(1.5e-6,40.0e-6,7.4e-6);//rayleigh\nconst vec3 betaM = vec3(21e-6);//mie\n#endif\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\nstruct sphere\n{\n\tvec3 center;\n    float radius;\n}; \n//表示大气层的球\nconst sphere atmosphere = sphere(vec3(0.,0.,0.),atmosphereRadius);\nbool raySphereIntersect(const in ray r,const in sphere s,inout float t0,inout float t1)\n{\n\tvec3 oc = r.origin-s.center;\n    float a = dot(r.direction,r.direction);\n    float b = dot(oc,r.direction);\n    float c = dot(oc,oc)-s.radius*s.radius;\n    float discriminant = b*b-(a*c);\n    if(discriminant>0.0)\n    {\n        float tmp = sqrt(discriminant);\n        t0 = (-b-tmp)/a;\n        t1 = (-b+tmp)/a;\n        return true;\n    }\n    return false;\n}\n\n//绕x轴的旋转矩阵\nmat3 rotate_around_x(const in float degrees)\n{\n    float angle = radians(degrees);\n    float _sin = sin(angle);\n    float _cos = cos(angle);\n    return mat3(1.,0.,0.,\n                0.,_cos,-_sin,\n                0.,_sin,_cos);\n}\n\nray getPrimaryRay(in vec2 camLocalPoint,inout vec3 camOrigin,inout vec3 camLookAt)\n{\n\tvec3 fwd = normalize(camLookAt-camOrigin);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(up,fwd);\n    up = cross(fwd,right);\n    ray r = ray(camOrigin,normalize(fwd+camLocalPoint.x*right+camLocalPoint.y*up));\n    return r;\n}\n\n//----------------phase function----------------\nfloat rayleighPhaseFunc(float mu)\n{\n\treturn 3.*(1.+mu*mu)/(16.*PI);\n}\n\nconst float g = 0.76;\nfloat henyeyGreensteinPhaseFunc(float mu)\n{\n\treturn (1.-g*g)/((4.*PI)*pow(1.+g*g-2.*g*mu,1.5));\n}\n\nconst float k = 1.55*g-0.55*(g*g*g);\nfloat schlickPhaseFunc(float mu)\n{\n\treturn (1.-k*k)/(4.*PI*(1.+k*mu)*(1.+k*mu));\n}\n//----------------phase function----------------\n\n//计算光学深度\nbool getSunLight(const in ray r,inout float opticalDepthR,inout float opticalDepthM)\n{\n\tfloat t0,t1;\n    raySphereIntersect(r,atmosphere,t0,t1);\n    float marchPos = 0.;\n    float marchStep = t1/float(numSamplesLIght);\n    for(int i = 0;i<numSamplesLIght;i++)\n    {\n        //相邻两个采样点的中点\n    \tvec3 s =r.origin+r.direction*(marchPos+0.5*marchStep);\n        float height = length(s)-earthRadius;\n        if(height<0.)\n            return false;\n        opticalDepthR += exp(-height/hR)*marchStep;\n        opticalDepthM += exp(-height/hM)*marchStep;\n        marchPos += marchStep;\n    }\n    return true;\n}\n\nvec3 getIncidentLight(const in ray r)\n{\n\tfloat t0,t1;\n    if(!raySphereIntersect(r,atmosphere,t0,t1))\n    {\n    \treturn vec3(0.);\n    }\n\tfloat marchStep = t1/float(numSamples);\n    float mu = dot(r.direction,sunDir);\n    float phaseR = rayleighPhaseFunc(mu);\n    float phaseM = \n#if USE_HENYEY\n    henyeyGreensteinPhaseFunc(mu);\n#else\n    schlickPhaseFunc(mu);\n#endif\n    float opticalDepthR = 0.;\n    float opticalDepthM = 0.;\n    \n    vec3 sumR = vec3(0.);\n    vec3 sumM = vec3(0.);\n    float marchPos = 0.;\n    for(int i=0;i<numSamples;i++)\n    {\n    \tvec3 s = r.origin+r.direction*(marchPos+0.5*marchStep);\n        float height = length(s)-earthRadius;\n        //计算光学深度累加和\n        float hr = exp(-height/hR)*marchStep;\n        float hm = exp(-height/hM)*marchStep;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        ray lightRay = ray(s,sunDir);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        bool bOverGround = getSunLight(lightRay,opticalDepthLightR,opticalDepthLightM);\n    \tif(bOverGround)\n        {\n        \tvec3 t = betaR*(opticalDepthR+opticalDepthLightR)+\n                betaM*1.1*(opticalDepthM+opticalDepthLightM);\n            vec3 attenuation = exp(-t);\n            sumR += hr*attenuation;\n            sumM += hm*attenuation;\n        }\n        marchPos += marchStep;\n    }\n    return sunPower*(sumR*phaseR*betaR+sumM*phaseM*betaM);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord/iResolution.xy-1.)*vec2(iResolution.x/iResolution.y,1.);\n    float viewScale = 1.;\n    vec2 p = uv*viewScale;\n\n    vec3 color = vec3(0.);\n    \n     //sun position\n    float rotSpeedFactor = 3.;\n    mat3 sunRot = rotate_around_x(-abs(sin(u_time/rotSpeedFactor))*90.);\n    sunDir *= sunRot;\n    \n    if(iMouse.z<0.1)\n    {\n        //单位圆的点映射到半球面\n        float z2 = p.x*p.x+p.y*p.y;\n        float phi = atan(p.y,p.x);\n        float theta = acos(1.-z2);\n        vec3 dir = vec3(sin(theta)*cos(phi),\n                        cos(theta),\n                        sin(theta)*sin(phi));\n        ray r = ray(vec3(0.,earthRadius+1.,0.),dir);\n        color = getIncidentLight(r);\n    }else\n    {\n    \tvec3 from = vec3(0.,earthRadius+1.,0.);\n        vec3 lookat = vec3(0.,earthRadius+1.5,-1.);\n        ray r = getPrimaryRay(p,from,lookat);\n        if(dot(r.direction,vec3(0.,1.,0.))>0.)\n           color = getIncidentLight(r);\n        else\n           color = vec3(0.33,0.33,0.33);\n        \n    }\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[975, 1066, 1155, 1155, 1512], [1514, 1539, 1585, 1585, 1769], [1771, 1771, 1855, 1855, 2088], [2090, 2139, 2174, 2174, 2208], [2232, 2232, 2275, 2275, 2329], [2368, 2368, 2402, 2402, 2450], [2501, 2522, 2608, 2608, 3142], [3144, 3144, 3183, 3183, 4574], [4576, 4576, 4633, 4633, 5695]]}
{"id": "3sVXRR", "name": "2D clouds experiment", "author": "Zombye", "description": "Started on this quite a while ago but never got around to actually finishing it.\nWanted a good approximation of volumetric clouds for cases where those would be too expensive or simply unnecessary.\nThere's definitely a lot of room for improvement.", "tags": ["clouds"], "likes": 11, "viewed": 428, "published": "Public API", "date": "1596966831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float fieldOfView = 60.0;\n\nconst float lightAngle = 70.0;\n\nconst uint raySteps = 10u;\nconst uint noiseIterations = 7u;\n\nconst float cloudsFrequency = 1.0;\nconst float cloudsThickness = 0.15;\nconst float cloudsAltitude = 1.0;\n\nfloat GetCloudNoise(vec2 position, float e0) {\n    position *= cloudsFrequency;\n    position /= iChannelResolution[0].xy;\n    float noise = 0.0, weightSum = 0.0;\n    for (uint i = 0u; i < noiseIterations; ++i) {\n        float iterationWeight = exp2(-float(i));\n        vec2 noisePosition = position * exp2(float(i)) + 0.1 * iTime / iChannelResolution[0].xy;\n        noise += texture(iChannel0, noisePosition).r * iterationWeight;\n        weightSum += iterationWeight;\n    } noise /= weightSum;\n    return smoothstep(e0, 1.0, noise);\n}\n\nvoid PlanarClouds(\n    vec3 viewPosition,\n    vec3 viewDirection,\n    vec3 lightDirection,\n    float rand,\n    out float scattering,\n    out float transmittance\n) {\n    scattering = 0.0;\n    transmittance = 1.0;\n    \n    //--// Find current point on cloud\n    \n    float tPlane = (cloudsAltitude - viewPosition.z) / viewDirection.z;\n    if (tPlane < 0.0) { return; }\n    vec2 cloudPosition = viewPosition.xy + viewDirection.xy * tPlane;\n    \n    //--// Set up self-shadowing raymarch\n    \n    float rayLength3D = cloudsThickness / lightDirection.z;\n    vec3 rayVector3D = rayLength3D * lightDirection;\n    \n    vec2 rayStep  = lightDirection.xy * cloudsThickness / lightDirection.z;\n         rayStep -= viewDirection.xy  * cloudsThickness / viewDirection.z;\n         rayStep /= float(raySteps);\n    vec2 rayPosition = cloudPosition + rayStep * rand;\n    \n    //--// Self-shadowing raymarch\n    \n    float e0 = 0.5 / (0.5 * cloudsThickness / (cloudsAltitude * viewDirection.z) + (1.0 - 0.5 * cloudsThickness / cloudsAltitude));\n    \n    float lightOpticalDepth = 0.0;\n    for (uint i = 0u; i < raySteps; ++i, rayPosition += rayStep) {\n        float cloudNoise = GetCloudNoise(rayPosition, e0);\n        lightOpticalDepth += max(cloudNoise, 0.0);\n    }\n    lightOpticalDepth *= 4.0 * cloudsFrequency / cloudsThickness * rayLength3D / float(raySteps);\n    \n    float cloudNoise = GetCloudNoise(cloudPosition, e0);\n    float cloudOpticalDepth = 4.0 * cloudsFrequency * cloudNoise / abs(viewDirection.z);\n        \n    transmittance = exp(-cloudOpticalDepth);\n    scattering = exp(-lightOpticalDepth) * (1.0 - transmittance);\n}\n\nmat3 GetRotationMatrix(vec3 unitAxis, float angle) {\n\tfloat cosine = cos(angle);\n\n\tvec3 axis = unitAxis * sin(angle);\n\tvec3 tmp = unitAxis - unitAxis * cosine;\n\n\treturn mat3(\n\t\tunitAxis.x * tmp.x + cosine, unitAxis.x * tmp.y - axis.z, unitAxis.x * tmp.z + axis.y,\n\t\tunitAxis.y * tmp.x + axis.z, unitAxis.y * tmp.y + cosine, unitAxis.y * tmp.z - axis.x,\n\t\tunitAxis.z * tmp.x - axis.y, unitAxis.z * tmp.y + axis.x, unitAxis.z * tmp.z + cosine\n\t);\n}\nvec3 LinearToSrgb(vec3 color) {\n\treturn mix(1.055 * pow(color, vec3(1.0 / 2.4)) - 0.055, color * 12.92, step(color, vec3(0.0031308)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zrot =  radians(360.0) * iMouse.x / iResolution.x;\n    float xrot = -radians(90.0) * ((iMouse.x + iMouse.y) < 1.5 ? 0.2 : (iMouse.y / iResolution.y)) - radians(90.0);\n    mat3 viewRot = GetRotationMatrix(vec3(0.0, 0.0, 1.0), zrot)\n                 * GetRotationMatrix(vec3(1.0, 0.0, 0.0), xrot);\n    vec3 viewDirection;\n    viewDirection.xy = (2.0 * fragCoord - iResolution.xy) * tan(radians(fieldOfView) / 2.0) / iResolution.y;\n    viewDirection.z = -1.0;\n    viewDirection = viewRot * normalize(viewDirection);\n    vec3 viewPosition = vec3(0.0);\n    \n    vec3 lightDirection = vec3(vec2(cos(iTime + 2.0), sin(iTime + 2.0)) * sin(radians(lightAngle)), cos(radians(lightAngle)));\n    \n    // sky\n    const vec3 rlHor = vec3(0.3, 0.4, 0.5), rlUp = vec3(0.1, 0.2, 0.4);\n    const vec3 mieHor = vec3(0.2), mieUp = vec3(0.05);\n    float phaseRl = pow(dot(viewDirection, lightDirection), 2.0) * 0.5 + 1.0;\n    float phaseMie = pow((dot(viewDirection, lightDirection) + 1.0) * 0.55, 16.0) * 0.5 + 1.0;\n    fragColor.rgb  = phaseRl * mix(rlUp, rlHor, pow(1.0 - max(viewDirection.z, 0.0), 4.0));\n    fragColor.rgb += phaseMie * mix(mieUp, mieHor, pow(1.0 - max(viewDirection.z, 0.0), 4.0));\n    \n    // clouds\n    vec2 noise = texture(iChannel0, fragCoord / iChannelResolution[0].xy).xy;\n    \n    float cloudsScattering; float cloudsTransmittance;\n    PlanarClouds(viewPosition, viewDirection, lightDirection, noise.x, cloudsScattering, cloudsTransmittance);\n    \n    // fade distant clouds\n    cloudsScattering *= exp(-0.05 / abs(viewDirection.z));\n    cloudsTransmittance = mix(1.0, cloudsTransmittance, exp(-0.05 / abs(viewDirection.z)));\n    \n    fragColor.rgb = fragColor.rgb * cloudsTransmittance + phaseMie * cloudsScattering;\n    \n    // basic tonemap\n    fragColor.rgb *= inversesqrt(fragColor.rgb * fragColor.rgb + 1.0);\n    \n    // convert to srgb & dither\n    fragColor.rgb = LinearToSrgb(fragColor.rgb);\n    fragColor.rgb += (noise.x - noise.y) / 255.0;\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 278, 278, 766], [768, 768, 932, 932, 2388], [2390, 2390, 2442, 2442, 2836], [2837, 2837, 2868, 2868, 2973], [2974, 2974, 3029, 3029, 5023]]}
{"id": "3tBBWh", "name": "Day 16 of #raymarching challenge", "author": "illus0r", "description": "Day 16 of #raymarching challenge. Sierpinski tetrahedron studies.", "tags": ["raymarching", "fractal"], "likes": 3, "viewed": 179, "published": "Public API", "date": "1598732180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define textureCube texture\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define iTime (iTime / 10.1)\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 polarToDecart(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 decartToPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nfloat DE(vec3 z)\n{\n    // FIXME\n    z.x += 5. * sin(iTime);\n    z.y += 5. * sin(iTime);\n    z.z += 5. * cos(iTime);\n    float r;\n    int n = 0;\n    float Scale = 1.1;\n    float Move = 10.;\n    while (n < 15) {\n        // z.xy *= Rot(0.3 * iTime);\n        z.yx *= Rot(iTime * .5);\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n        // z-=2.0 * min(0.0, 1.) * n1;\n       z = z*Scale - Move*(Scale-1.0);\n    //     vec3 n1 = vec3(0.4 * sin(iTime), 0.9, -0.1 * sin(iTime));\n    //    float t = dot(z,n1); if (t<0.0) { z-=5.0*t*n1; }\n    //     n1 = n1.zyx;\n    //    t = dot(z,n1); if (t<0.0) { z-=5.0*t*n1; }\n       n++;\n    }\n    return (length(z)) * pow(Scale, -float(n)) - 0.5;\n}\n\nfloat sdColumn(vec3 p, float width) {\n    // float box = sdBox(p, vec3(width, 10., width));\n    p *= 5.;\n    float fractal = DE(p) / 5.;\n    // float column = max(fractal, box);\n    // return column;\n    // return fractal + abs((p.x + p.z ) / 1.);\n    return fractal;\n}\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    vec2 ar = decartToPolar(p.xz);\n    float a = ar.x, r = ar.y;\n    float astep = 2. * PI / 8.; // number of rays\n    a = mod(a, astep);\n    a -= astep / 2.;\n    a = abs(a);\n    p.xz = polarToDecart(vec2(a, r));\n    // float cyl = length(p.xz - vec2(0, 2)) - 0.2;\n    p.xz *= Rot(iTime + p.y * 0.1);\n    float column = sdColumn(p, 2.5);\n    return vec2(column, RED);\n    // return cyl < column? vec2(cyl, BLACK) : vec2(column, IVORY);\n//   return vec2(max(DE(p), length(p.xz+vec2(1)) - 0.1), BLUE);\n//   return vec2(DE(p) + length(p) - 4., BLUE);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += abs(distToClosest.x);\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // ray origin\n    float camRadius = 7.;\n    vec3 ro = vec3(camRadius * sin(iTime * .0), 0, camRadius * cos(iTime * .0));\n    ro.xz *= Rot(iMouse.x / iResolution.x * PI * 2.);\n    float zoom = 1.100;\n\n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n\n    vec3 colorBg = vec3(.0);\n    vec3 color;\n    color = vec3(1);\n    // color = textureCube(iChannel0, rd).xyz;\n    vec3 light = vec3(camRadius * cos(iTime * .2), 20, camRadius * sin(iTime * .2));\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t// color = vec3( n * 0.5 + 0.5 );\n\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        // drop shadows\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .06, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color *=  0.;\n        // }\n\n        // smooth shadows\n        float shadow = smoothstep(0.0, .15, rayMarchLight.z / PI);\n        color += .1 + .9 * shadow;\n\n        // reflection\n        // vec3 ref = reflect(rd, n);\n        // color += textureCube(iChannel0, ref).xyz;\n\n        // // refraction\n        // float e = 0.2;\n        // for (int i = 0; i < 2; i++) {\n        //     rd = refract(rd, n, 1. - e);\n        //     // rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n\n        //     rd = refract(rd, -n, 1. + e);\n        //     // rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n        // }\n        // color *= textureCube(iChannel0, rd).xyz;\n\n        // // reflection\n        // for (int i = 0; i < 2; i++) {\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n\n        //     rd = reflect(rd, n);\n        //     ro = p + rd * 0.05;\n        //     rm = rayMarch(ro, rd);\n        //     d = rm[0];\n        //     if (d > MAX_DIST) break;\n        //     p = ro + rd * d;\n        //     n = getNormal(p);\n        // }\n        // color = mix(textureCube(iChannel0, rd).xyz, color, 0.5);\n\n        //rm = rayMarch(p + ref * 0.1, ref);\n        // color = vec3(d);\n\n\n\n        // tex *= color_bw;\n        // color = tex;\n        // color += 0.6 + vec3( color_bw );\n        // coloring\n        if (d < MAX_DIST) {\n            if (info == IVORY) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.832,0.800,0.849);\n            }\n            else if (info == BLUE) {\n                color *= vec3(0.810,0.256,0.397);\n            }\n           else if (info == RED) {\n                color = vec3(.4 * (dot(n, normalize(light - p))) + 1.);\n                color *= vec3(0.810,0.256,0.397);\n            }\n            else if (info == BLACK) {\n                color = vec3(0.);//vec3(.0 + 0.2 * (dot(n, normalize(light - p))) + 1.);\n                // color *= vec3(0.130,0.130,0.130);\n                // color *= 5. / length(p.xz);\n            }\n            // color = mix(color, colorBg, smoothstep(20., 28., d));\n        }\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 268, 268, 331], [333, 333, 364, 364, 451], [453, 453, 485, 485, 620], [622, 622, 655, 655, 758], [760, 760, 778, 791, 1535], [1537, 1537, 1574, 1628, 1806], [1808, 1887, 1909, 1909, 2459], [2460, 2548, 2581, 2581, 3055], [3057, 3057, 3081, 3081, 3299], [3303, 3303, 3357, 3357, 3584], [3586, 3586, 3636, 3636, 3827], [3830, 3830, 3886, 3886, 7859]]}
{"id": "3tBBzW", "name": "sinebounce", "author": "browric2", "description": "My first shader! Just a bouncy little boi", "tags": ["noise", "beginner", "sine"], "likes": 1, "viewed": 36, "published": "Public", "date": "1598373854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 np = uv+(0.5*sin(iTime)-0.5);\n       \n    // Time varying pixel color\n    vec3 col = vec3(0.3,rand(np*np*np*np*np*np*np)+cos(iTime)*0.5,cos(1.8*iTime)*0.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [95, 95, 152, 202, 472]]}
{"id": "3tBfDD", "name": "Minimalism #08", "author": "Flopine", "description": "Eighth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "animation", "motion", "minimalism", "daily"], "likes": 7, "viewed": 89, "published": "Public", "date": "1598908920", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define BPM (120./60.)\n#define dt(speed) fract(iTime*speed)\n#define SwitchAnim(speed) (floor(sin(dt(speed)*TAU))+1.)\n#define AnimOutExpoLoop(speed) easeOutExpo(abs(2.*dt(speed)-1.))\n#define AnimOutExpo(speed) easeOutExpo(dt(speed))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define circle(puv,s) (length(puv)-s)\n#define square(puv,s) (max(abs(puv.x),abs(puv.y))-s)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\nfloat easeOutExpo (float x)\n{ \treturn x >= 1. ? 1. : 1. - pow(2., -10. * x); }\n\nfloat equitri (vec2 p, float r)\n{\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/sqrt(3.);\n    if (p.x+sqrt(3.)*p.y>0.) p=vec2(p.x-sqrt(3.)*p.y,-sqrt(3.)*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2.*r, 0. );\n    return -length(p)*sign(p.y);\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 uu = uv;\n    uv.y += 0.6;\n    float size = 0.3;\n    float mask = 1.;\n    float offset = 0.;\n    uv.x = abs(uv.x);\n    vec2 suv = uv * vec2(1.,2.5);\n    for (int i=0; i<3; i++)\n    {\n        mask *= AAstep(0.01,square(suv,size));\n        suv.x -= AnimOutExpoLoop(BPM/2.+offset)*size*2.;\n        offset += 5.;\n        size -= 0.08;\n    }\n    vec2 cuv = uu;\n    cuv.y -= 0.25;\n    cuv *= rot(AnimOutExpo(BPM/2.+PI/8.)*PI);\n    cuv.y = abs(cuv.y)-0.3;\n    mask *= AAstep(0.02,abs(circle(cuv,0.25)))*AAstep(0.01,equitri(cuv,0.2));\n\n    uu.x = (SwitchAnim(BPM/4.+PI/4.) >= 1.)? uu.x : -uu.x;\n    return (uu.x <=0.) ? mask : (1.-mask);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 col = mix(vec3(0.7,0.4,0.5),vec3(0.9,0.9,0.35),frame(uv));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 822, 851, 851, 900], [902, 902, 935, 935, 1134], [1136, 1136, 1159, 1159, 1799], [1801, 1801, 1857, 1857, 2026]]}
{"id": "3tBfWz", "name": "Minimalism #05", "author": "Flopine", "description": "Fifth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "grid", "animation", "motion", "hexagons", "minimalist"], "likes": 24, "viewed": 311, "published": "Public", "date": "1598615794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define TAU 6.2831853\n\n#define BPM (120./60.)\n#define dt(speed) fract(iTime*speed)\n#define AnimOutExpoLoop(speed) easeOutExpo(abs(2.*dt(speed)-1.))\n#define AnimOutExpo(speed) easeOutExpo(dt(speed))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define square(puv,s) (max(abs(puv.x),abs(puv.y))-s)\n#define hexa(puv,s) (max(abs(puv.x),dot(abs(puv), normalize(vec2(1.,sqrt(3.))))))-s\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define moda(puv,r) float a=mod(atan(puv.x,puv.y),TAU/r)-(TAU/r)*0.5; puv=vec2(cos(a),sin(a))*length(puv)\n\n#define palette(t,c,d) (vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+d)))\n\nfloat easeOutExpo (float x)\n{ \treturn x == 1. ? 1. : 1. - pow(2., -10. * x); }\n\nfloat equitri (vec2 p, float r)\n{\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/sqrt(3.);\n    if (p.x+sqrt(3.)*p.y>0.) p=vec2(p.x-sqrt(3.)*p.y,-sqrt(3.)*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2.*r, 0. );\n    return -length(p)*sign(p.y);\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 hper = vec2(1.,sqrt(3.));\n    vec2 auv = mod(uv,hper)-hper*0.5;\n    vec2 buv = mod(uv-hper*0.5,hper)-hper*0.5;\n    vec2 guv = (dot(auv,auv)<dot(buv,buv)) ? auv : buv;\n    vec2 gid = uv-guv;\n\n    float cellsize = 0.4;\n    guv *= rot(AnimOutExpo(BPM/6.+length(gid.x+gid.y*.5))*TAU);\n    float mask = AAstep(0.02,abs(hexa(guv,cellsize)));\n    if(mod(gid.x+0.1,2.) < 1.) \n    {\n        moda(guv,3.);\n        float line = max(abs(guv.y)-0.02,abs(guv.x)-cellsize*1.1);\n        mask *= AAstep(0.01,line);\n    }\n    else mask *= AAstep(0.03,abs(equitri(guv,cellsize*0.95)));\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(frame(uv*3.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBfWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 958, 987, 987, 1036], [1038, 1038, 1071, 1071, 1270], [1272, 1272, 1295, 1295, 1890], [1892, 1892, 1949, 1949, 2080]]}
{"id": "3tfBDM", "name": "Sierpinski-5x5 Carpet-fork-fuzz", "author": "alvarobyrne", "description": "A Sierpinski-Carpet-like structure, but in a 5x5  arragement. At every iteration, the whole unit square is divided in 5x5 sub-squares and the subsquares subsquares at (1,1), (3,1), (1,3) and (3,3) get removed.", "tags": ["2d", "fractal", "sierpinksi"], "likes": 2, "viewed": 173, "published": "Public API", "date": "1596813929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Sierpinski - 5x5 Carpet\" by iq. https://shadertoy.com/view/XsSGRh\n// 2020-08-07 15:22:20\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\n// https://creativecommons.org/licenses/by-sa/3.0/\n\n\n// A Sierpinski Carpet like structure (2D Cantor). Instead of removing the central square \n// of a 3x3 subdivided square, in this shader I divide the square in 5x5 sub-squares and I \n// remove the four in the corners of the central one.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // unit square covering the whole screen\n\tvec2 z = fragCoord.xy / iResolution.xy;\n\n    // make it all white\n    float f = 1.0;\n\t\n    // iterate\t\n\tfor( int i=0; i<4; i++ ) \n\t{\n        //remove subsquares (1,1), (3,1), (1,3) and (3,3)\n\t\tf *= 1.0 - step( abs(abs(z.x-(0.5+0.36475*sin(iTime+sin(iTime*3./5.))))-0.15*(1.0+sin(iTime+sin(iTime)))), 0.1 )\n            *step( abs(abs(z.y-0.5+0.1*sin(iTime+sin(iTime)))-0.1*(1.0+cos(iTime+sin(iTime*7./5.)))), 0.1 );\n        // scale the shole thing down by a factor of 5\n\t\tz = fract( z*5.0 );\n\t}\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBDM.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[256, 494, 551, 601, 1136]]}
{"id": "3tfBWl", "name": "Deeper Zoom Mandelbrot", "author": "Ben1152000", "description": "Used deeper zoom concept from: https://www.shadertoy.com/view/3l2Xz3\nand shading technique based on distance from: https://www.shadertoy.com/view/lsX3W4", "tags": ["fractal", "mandelbrot", "zoom"], "likes": 6, "viewed": 101, "published": "Public", "date": "1598000699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318\n#define NUM_COLOR 50.0\n#define MAX_ITER 600\n#define ZOOM_RATE 1.5\n#define ORIGIN vec2(-0.05026782, 0.6721055)\n#define ORIGIN_SMALL vec2(1e-16, -1.5e-19)\n#define SHADE 12.5\n\nstruct iterdist {\n    int iter;\n    float dist;\n};\n\niterdist mandelbrot( vec4 c, int iterations ) {\n    // non-const iterations makes a cool growy animation\n    vec4 z = vec4(0);\n    vec2 dz = vec2(0);\n    iterdist i;\n    for (i.iter = 0; i.iter < iterations; i.iter++) {\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n        z.zw = vec2(z.z*z.z - z.w*z.w, z.z*z.w*2.0) \n            + 2.0 * vec2(z.x*z.z - z.y*z.w, z.x*z.w + z.y*z.z);\n        z.xy = vec2(z.x*z.x - z.y*z.y, z.x*z.y*2.0);\n        z += c;\n        if (length(z) >= 4.0) {\n            i.dist = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n            return i;\n        }\n        // Hack to allow for deeper zoom: https://www.shadertoy.com/view/3l2Xz3\n        if (length(z.zw) / length(z.xy) > 0.01) { // 0.01 seems about right\n            z.xy = z.xy + z.zw;\n            z.zw = vec2(0.0);\n        }\n    }\n    i.iter = -1;\n    i.dist = 0.0;\n    return i;\n}\n\nvec3 color( int i ) {\n    return 0.5 + 0.5*cos(2.7+(mod(float(i), NUM_COLOR) / NUM_COLOR)*TAU + vec3(0.0,.6,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2.0*fragCoord - iResolution.xy) * pow(ZOOM_RATE, -iTime) / iResolution.y;\n    iterdist i = mandelbrot(vec4(ORIGIN, coord + ORIGIN_SMALL), 2 + int(5.0 * iTime * ZOOM_RATE));\n    float shade = min(i.dist / pow(ZOOM_RATE, -(SHADE + iTime)), 1.0);\n    fragColor = vec4(sqrt(color(i.iter) * float(i.iter >= 0) * shade), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 292, 349, 1144], [1146, 1146, 1167, 1167, 1262], [1264, 1264, 1321, 1321, 1662]]}
{"id": "3tffDn", "name": "Whatever Waves", "author": "BGrater", "description": "\"Something cool\"", "tags": ["2d", "waves"], "likes": 1, "viewed": 50, "published": "Public", "date": "1596419061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 BG_COL = vec3(0.0,0.6,1.0);\nfloat WAVE_COUNT = 6.0;\nfloat WAVE_OFFSET = -0.3;\nfloat WAVE_SPACE = 0.1;\nfloat WAVE_INTENSITY = 30.0;\nfloat WAVE_GLOW = 0.5;\nfloat WAVE_PULSE = 2.0;\nfloat SPEED = 1.3;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    // Background\n    vec3 bgCol = (uv.y + abs(sin(iTime * SPEED * 0.3)) * 0.5 + 0.1) * BG_COL;\n    \n    \n    // Waves\n    vec3 waveCol = vec3(0.0);\n    float waveCenter = -1.0 + (uv.y * 2.0);\n    float waveWidth = abs(sin(iTime * SPEED * 0.5) * WAVE_INTENSITY * WAVE_PULSE) + WAVE_INTENSITY;\n    \n    for(float i= 0.0; i < WAVE_COUNT; i++)\n    {\n        float waveY = waveCenter + i * WAVE_SPACE + WAVE_OFFSET;\n        waveY += sin((uv.x + i * 0.5) + iTime * SPEED) * 0.5;\n        \n        float waveAlpha = abs(1.0 / (1000.0 / waveWidth * waveY));\n        waveAlpha *= smoothstep(0.0, 1.0 / WAVE_GLOW, waveAlpha);\n        waveCol += waveAlpha * vec3(0.1, 0.0, abs(sin(iTime * SPEED * 0.5) * 0.2));\n    }\n    \n    vec3 col = clamp(bgCol + waveCol, 0.0, 1.0);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 261, 311, 1191]]}
{"id": "3tffzl", "name": "Strawberry leaves", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 14, "viewed": 113, "published": "Public", "date": "1597405146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat orbit;\nfloat map(vec3 p)\n{\n    p.xz*=rot(iTime*.2);\n  \tfloat s = 4.;\n\tfor(int i = 0; i < 8; i++)\n    {\n\t\tp=mod(p-1.,2.)-1.;\n\t\tfloat r2=(i%3==0)?1.5:1.2/dot(p,p);\n        p*=r2;\n        s*=r2;\n\t}\n    orbit=log2(s*.05);\n\tvec3 q=p/s;\n\tq.xz=mod(q.xz-.002,.004)-.002;\n\treturn min(length(q.yx)-.0003,length(q.yz)-.0003);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n  \tvec3 ro=vec3(\n        mix(.9,.3,sin(iTime*.2+.3*sin(iTime*.5))*.5+.5),\n        mix(-.6,.6,cos(iTime*.1+.5*cos(iTime*.7))*.5+.5),\n        0);\n  \tvec3 w=normalize(-ro);\n  \tvec3 u=normalize(cross(w,vec3(0,1,0)));\n  \tvec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    vec3 p;\n    float h=0.,d,i;\n\tfor(i=1.;i<120.;i++)\n    {\n    \tp=ro+rd*h;    \n\t\td=map(p);\n    \tif(d<.0001)break;\n    \th+=d;\n\t}\n    fragColor.xyz=25.*vec3(cos(vec3(.3,.8,.7)*orbit))/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 82, 82, 372], [374, 374, 431, 431, 941]]}
{"id": "3tGXDt", "name": "Quick Cloud Test  Using Sin()", "author": "Delvar", "description": "just a quick test for simple clouds only using sin()", "tags": ["test", "sun", "cloud", "sin", "sky"], "likes": 3, "viewed": 129, "published": "Public", "date": "1597226227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.1415926535897932384626433832795\n\n#define DEBUG_CLOUDS\n\n#define CLOUD_OCCLUSION_STEPS 10.0\n#define CLOUD_OCCLUSION_DISTANCE 2.5\n#define CLOUD_OCCLUSION_SCALE 10.0/CLOUD_OCCLUSION_STEPS\n\n#define CLOUD_LOD_MIN_OCTAVES 4.0\n#define CLOUD_LOD_MAX_OCTAVES 64.0\n\n#define SUN_COLOUR vec3(1.6,1.2,0.8)\n\n#define OCEAN_REFLECTION_BASE vec3(0.06,0.24,0.36)\n\n#define AMBIENT_COLOUR vec3(0.3, 0.49, 0.54)\n\n#define HAZE_BASE_COLOUR vec3(2.85,2.5,2.2)\n#define SKY_BASE_COLOUR vec3(0.29,0.76,1.71)\n#define SKY_UPPER_COLOUR vec3(0.24,0.28,0.72)\n\nvec3 sunDir = normalize(vec3(5.0, 4.0, 5.0));\nconst vec3 sunColour=vec3(0.8,0.6,0.4);\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct rayMarch {\n    vec3 origin, direction;\n};\n    \nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\ncamera getTableCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n    camera.origin.y = max(camera.origin.y,1.0);\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec2 mouse, in float time) {\n    return getTableCamera(vec3(0.0,2.0,0.0), 2.5, 0.0, -mouse.y*PI, -mouse.x*2.0*PI,  0.5);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\n\n//#define VALUE_NOISE_FILTER_SMOOTH\n#define VALUE_NOISE_FILTER_QUINTIC\n\n#define HD 43758.5453123\n\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n#define HI 95.501775192\n#define HJ 45.043107817\n#define HK 22.671833926\n#define HL 25.490516071\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\nvec4 hash44(vec4 st) {\n    return fract(sin((st+vec4(HE,HF,HG,HH))*vec4(HI,HJ,HK,HL))*HD);\n    //return fract(sin(st*HE)*HD);\n}\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n}\n\n//New faster way to geneerate the height using vec math to reduce required instructions.\n// Clouds\n//New faster way to geneerate the height using vec math to reduce required instructions.\n// Clouds\nfloat getCloudNoise(vec2 position, float totalOctaves, float time) {\n    position+=vec2(1000,2000) + vec2(time)*vec2(0.05,0.1);\n\ttime=time*0.08;\n    \n    float maxHeight = 0.0;\n    float height = 0.0;\n    \n    for(float quadOctave = 0.0; quadOctave<totalOctaves; quadOctave+=4.0) {\n        vec4 octaves = vec4(0.0,1.0,2.0,3.0)+quadOctave;\n        //frequencies, PI2*0.03\n        vec4 fs = pow(vec4(1.095),octaves)*0.25;\n        //amplitudes\n        vec4 as = pow(vec4(0.9),octaves);\n \n        //Rotations\n        vec4 angles = (octaves*0.1)+hash44(octaves)*0.2;\n        vec4 cAngles = cos(angles), sAngles = sin(angles);\n        vec4 xs, ys;\n\n        for(int i;i<4;i++) {\n            position=position*mat2(cAngles[i],-sAngles[i], sAngles[i], cAngles[i]);\n            xs[i] = position.x;\n            ys[i] = position.y;\n        }\n\n        vec4 values = (sin(fs*xs+time)+sin(fs*ys));\n\n        //For runs where we dont want exactly multiple of 4 octaves.. to match the old output.\n        float octaivesRemaining = totalOctaves-quadOctave;\n        \n        if(octaivesRemaining<1.0) {\n            as*=vec4(fract(totalOctaves),0.0,0.0,0.0);\n        } else if(octaivesRemaining<2.0) {\n            as*=vec4(1.0,fract(totalOctaves),0.0,0.0);\n        } else if(octaivesRemaining<3.0) {\n            as*=vec4(1.0,1.0,fract(totalOctaves),0.0);\n        } else if(octaivesRemaining<4.0) {\n            as*=vec4(1.0,1.0,1.0,fract(totalOctaves));\n        }\n        \n        values *= as;\n        \n        height+=dot(values,vec4(1));\n        maxHeight+=dot(as,vec4(1));\n    }\n    return height/maxHeight;\n}\n\nvec4 getCloudsColour(vec3 direction, float sunDotProduct, float time) {\n    //Dont draw clouds very low on the horizon or ground.\n    if (direction.y<=0.04) {\n        return vec4(0.0);\n    }\n    vec2 samplePoint = direction.xz;\n    samplePoint *= (4000.0)/direction.y;\n    samplePoint *= 0.001;\n    \n    float occlusion = 0.0;\n    vec2 offsetDelta = (sunDir.xz * CLOUD_OCCLUSION_DISTANCE)/CLOUD_OCCLUSION_STEPS;\n    vec2 offset = vec2(0.0);\n    \n    //Simple LOD based on y direction. // limited to 0.04 above, 1.0/0.04 = 25.0 so dont need to clamp it\n    float t = 1.0/1.0-direction.y;\n    \n    //NOTE: the map values are backwards (1.0 to 0.0) to normal (0.0 to 1.0) because we flipped t to start with.\n\tfloat totalOctaves = map(t, 25.0, 0.0, CLOUD_LOD_MIN_OCTAVES , CLOUD_LOD_MAX_OCTAVES );\n     \n    float c1 = getCloudNoise(samplePoint, totalOctaves, time)*0.5+0.5;\n    \n    if(c1 <= 0.5) {\n\t\treturn vec4(0.0);\n    }\n    \n    for( float i=CLOUD_OCCLUSION_SCALE; i>0.0; i-=(CLOUD_OCCLUSION_SCALE/CLOUD_OCCLUSION_STEPS) )\n    {\n        offset += offsetDelta;\n        offsetDelta *= 1.25;\n        float c2 = getCloudNoise(samplePoint+offset, totalOctaves, time)*0.5+0.5;\n        float d = (c1-c2) * c2;\n        occlusion += d*i;\n    }\n    \n    //occlusion = smoothstep(0.0,1.0,clamp(map(occlusion, -1.0, 1.0, -2.0, 4.0),0.0,1.0));\n    occlusion = clamp(occlusion,0.0,1.0);\n        \n\t//We fake back lighting based off the sub dot product, make the fringes brighter\n    vec3 col=SUN_COLOUR * (mix(occlusion,clamp(5.0*(0.8-c1),0.0,1.0),pow(sunDotProduct,5.0)));\n\tc1 = clamp(map(c1, -1.0, 1.0, -6.0, 2.0),0.0,1.0)*clamp( (direction.y-0.04) * 10.0,0.0,1.0);\n    col *= 2.0;\n    #if defined(AMBIENT_COLOUR)\n\t\tcol += AMBIENT_COLOUR;\n    #endif\n    return vec4(col,c1);\n}\n    \nvec3 getSkybox(vec3 direction, float observerHeight, bool lowerWhite, bool upperSun, float time) {\n    vec3 skybox;\n    if (lowerWhite && upperSun) {\n        direction.y = abs(direction.y);\n    }\n    \n    float sunDotProduct=dot(direction,sunDir)*0.5+0.5;\n        \n    //ensure the skybox lower portion matches the OCEAN base colour with lighting etc.\n    if(direction.y<0.0) {\n        //Fog always has white on the lower side, just think it looks better\n        if (lowerWhite) {\n            #if defined(DEBUG_DISTANCE_FOG)\n            return HAZE_BASE_COLOUR;\n            #else \n            return OCEAN_REFLECTION_BASE;\n            #endif\n        } else {\n            direction.y = abs(direction.y);\n            skybox = OCEAN_REFLECTION_BASE;\n\n            #if defined(DEBUG_LIGHTING)\n            vec3 defuse = SUN_COLOUR * dot(sunDir,vec3(0.0,1.0,0.0));\n                #if defined(AMBIENT_COLOUR)\n                defuse += AMBIENT_COLOUR;\n                #endif\n            skybox*=defuse;\n            #endif\n\n            #if defined(DEBUG_DISTANCE_FOG)\n\t\t\tfloat haze = clamp(observerHeight/direction.y,0.0, RAY_MAX_DISTANCE)/RAY_MAX_DISTANCE;\n            skybox = mix(skybox,HAZE_BASE_COLOUR,haze);\n            \n            //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,4.0)));\n            #endif\n            return skybox;\n        }\n    } else {\n\t\tskybox=SKY_BASE_COLOUR;\n        skybox=mix(skybox,SKY_UPPER_COLOUR,smoothstep(0.0,1.0,direction.y));\n        \n        //Fog layer doesnt have the sun spot, jsut looks weird\n        if(upperSun) {\n            //Add Sun and Halo\n            skybox += SUN_COLOUR*((pow(sunDotProduct,1000.0)*20.0)+pow(sunDotProduct,10.0));\n            #if defined(DEBUG_CLOUDS)\n                vec4 clouds = getCloudsColour(direction, sunDotProduct, time);\n                skybox = mix(skybox, clouds.xyz, clamp(clouds.w,0.0,1.0));\n            #endif\n\t\t}\n        //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,20.0)));\n        skybox=mix(skybox,HAZE_BASE_COLOUR,pow(1.0-direction.y,20.0));\n        return skybox;\n    }\n}    \n\nrayMarch getRay(vec2 uv, camera camera) {\n    rayMarch ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    \n    float time = iTime + 45.0;\n   \n    //sunDir = normalize(vec3(sin(time)*5.0, abs(sin(time*0.03333)) * 3.0, cos(time)*5.0));\n    sunDir = normalize(vec3(sin(time*0.1)*5.0, 4.0, cos(time*0.1)*5.0));\n    \n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n    camera camera = getCamera(mouse, time);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\trayMarch ray = getRay(uv, camera);\n    \n    vec3 colour = getSkybox(ray.direction, ray.origin.y, true, true, time);\n  \n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n    colour = clamp(colour,0.0,1.0); \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 832, 858, 858, 1020], [1022, 1022, 1046, 1046, 1192], [1194, 1194, 1219, 1219, 1373], [1374, 1374, 1429, 1489, 1550], [1552, 1552, 1652, 1652, 2166], [2168, 2168, 2213, 2213, 2307], [2309, 2309, 2381, 2381, 2449], [2452, 2743, 2774, 2774, 2971], [2973, 2973, 2996, 2996, 3280], [3281, 3281, 3303, 3303, 3408], [3409, 3409, 3448, 3448, 3848], [3850, 4048, 4116, 4116, 5639], [5641, 5641, 5712, 5770, 7406], [7412, 7412, 7510, 7510, 9526], [9532, 9532, 9573, 9573, 9842], [9844, 9844, 9902, 9902, 10723]]}
{"id": "3tlBRj", "name": "Julia Set over Mandelbrot Set", "author": "BlockMaster", "description": "Just a visualization of Julia set using Mandelbrot set plane.", "tags": ["fractal", "julia", "mandelbrot"], "likes": 2, "viewed": 62, "published": "Public", "date": "1597175271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Visualization of Julia set using Mandelbrot set plane. (You can change its c value with the mouse.)\n/// The max zoom value (before it starts to look distorted) is about 93 500.\n\n//Gneral Variables\nint iterations = 50;\nvec2 center = vec2(0.);\n\n//Mandlebrot Set Propeerties\nfloat mandelbrotZoom = 0.5;\nfloat mandelbrotOpacity = 0.2;\nvec2 mandelbrotOffset = vec2(0.3, 0.);\n\n//Julia Set Properties\nfloat juliaZoom = 0.4;\nfloat juliaOpacity = 1.5;\n\n//Mandelbrot Set\nfloat mandelbrotSet(vec2 coordinates, int iterations)\n{\n    float value = 1.;\n    vec2 c = coordinates;\n    vec2 z = c;\t//do the first iteration (sqr(z) + c; z = 0 => z = c)\n    for (int i = 1; i < iterations; i ++)\n    {\n        if (pow(z.x, 2.) + pow(z.y, 2.) > 4.)\n        {\n            value = float(i) / float(iterations);\n            break;\n        }\n        \n        vec2 tempZ = z;\n        z = vec2(pow(tempZ.x, 2.) - pow(tempZ.y, 2.) + c.x,\t//next z's real component\n                 2. * tempZ.x * tempZ.y + c.y);\t\t\t\t//next z's complex component\n        \n    }\n    return value;\n}\n\n//Julia Set\nfloat juliaSet(vec2 coordinates, int iterations, vec2 cValue)\n{\n    float value = 1.;\n    vec2 c = cValue;\n    vec2 z = coordinates;\n    for (int i = 0; i < iterations; i ++)\n    {\n        if (pow(z.x, 2.) + pow(z.y, 2.) > 4.)\n        {\n            value = float(i) / float(iterations);\n            break;\n        }\n        \n        vec2 tempZ = z;\n        z = vec2(pow(tempZ.x, 2.) - pow(tempZ.y, 2.) + c.x,\t//next z's real component\n                 2. * tempZ.x * tempZ.y + c.y);\t\t\t\t//next z's complex component\n        \n    }\n    return value;\n}\n\n//HSV to RGB Converter (author: https://stackoverflow.com/users/111461/sam-hocevar)\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the fragCoord\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.x /= aspectRatio;\n    \n    //Mandelbrot Zoom\n    /*mandelbrotZoom = pow(2., iTime) * 0.3;\t//linear zoom\n    iterations = 100 + int(mandelbrotZoom * 10.);*/\n    \n    //Set the c Value for Julia Set\n    vec2 mousePosition = vec2(iMouse) / iResolution.y;\n    vec2 cValue = (iMouse.z > 0.) ? center + (mousePosition - vec2(0.5 / aspectRatio, 0.5)) * (1. / mandelbrotZoom) - mandelbrotOffset\n       \t\t\t\t\t \t\t  : vec2(sin(iTime * 0.8), cos(iTime * 0.5 + 0.5) * 0.7);\n    \n    //Get the Pixel's Value\n    float value = juliaSet(center + (uv - vec2(0.5 / aspectRatio, 0.5)) * (1. / juliaZoom), iterations, cValue) * juliaOpacity;\n    value += mandelbrotSet(center + (uv - vec2(0.5 / aspectRatio, 0.5)) * (1. / mandelbrotZoom) - mandelbrotOffset, iterations) * mandelbrotOpacity;\n    \n    //Set the fragColor\n    //vec3 colour = mix(vec3(0.), vec3(1.), value);\n    vec3 colour = mix(hsv2rgb(vec3(0., 0., 0.)), hsv2rgb(vec3(1., 0.5, 1.)), value);\n    fragColor = vec4(colour, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 465, 520, 520, 1055], [1057, 1069, 1132, 1132, 1618], [1620, 1704, 1726, 1726, 2057], [2059, 2059, 2114, 2140, 3216]]}
{"id": "3tlBWS", "name": "descompuesto apollonian-v1", "author": "jorge2017a1", "description": "descompuesto apollonian-v1", "tags": ["descompuestoapollonianv1"], "likes": 2, "viewed": 42, "published": "Public", "date": "1597624406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n\n// Created by inigo quilez - iq/2013---\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n    vec3 pp=p;\n\torb = vec4(1000.0); \n    \n    float dps=0.5;\n\t\n\tfor( int i=0; i<5;i++ )\n\t{\n\t\t\n       \n      p.x = -1.0 + 2.0*fract(0.5*p.x+0.5);\n        p.z = -1.0 + 2.0*fract(0.5*p.z+0.5);\n        p.y = -1.0 + 2.0*fract(0.6*p.y+0.5);\n        \n      \n        float r2 = dot(p,p*vec3(0.8));\n\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\n        float k = 1.5/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n    \n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.4,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(1.0,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.01,0.02), clamp(6.0*tra.y,0.0,1.0) );\n        //rgb = mix( rgb, vec3(0.0,0.055,1.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n        rgb = mix( rgb, vec3(0.0,1.0,0.5), pow(clamp(1.0-2.0*tra.x,0.0,1.0),8.0) );\n        \n\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime*0.25;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 1.0*cos(0.5+.33*time), 0.6 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 2.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[288, 381, 416, 416, 440], [443, 443, 473, 473, 935], [937, 937, 985, 985, 1238], [1240, 1240, 1296, 1296, 1547], [1549, 1549, 1603, 1617, 2698], [2700, 2700, 2757, 2757, 3749], [3751, 3751, 3845, 3845, 4072]]}
{"id": "3tlfD2", "name": "16. Unity Shader Coding For Noob", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=JfC_ye23MvY\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI Did It !", "tags": ["unityshader"], "likes": 1, "viewed": 155, "published": "Public API", "date": "1597800624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy ) /iResolution.y;\n\n\tfloat angle = iTime;\n    \n    vec2 p = vec2( cos( angle ) , sin(angle ) ) * 0.4f;\n    vec2 desort = uv - p;\n    float d = length( desort );\n    \n    float m = ( 0.07f , 0.0f , d );\n    \n    m *= 10.0f;\n    \n    \n    // Output to screen\n    fragColor = vec4(1.0 - m , 1.0 - m , 1.0 - m, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 469]]}
{"id": "3tlfDH", "name": "Fractal battery", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 17, "viewed": 259, "published": "Public", "date": "1596627353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Scale;\n\nfloat map(vec3 p)\n{\n\tfloat itr=10.,r=0.;\n\tif(fract(iTime*.3)>.7)\n\t{\n\t\titr=3.+3.*step(0.,sin(3.*iTime+.5*sin(iTime*.7)));\n\t\tr=mix(.01,.002,step(5.,itr));\n\t}\n\tp=mod(p-1.5,3.)-1.5;\n\tp=abs(p)-1.3;\n\tif(p.x<p.z)p.xz=p.zx;\n\tif(p.y<p.z)p.yz=p.zy;\n \tif(p.x<p.y)p.xy=p.yx;\n\tfloat s=1.;\n\tp-=vec3(.5,-.3,1.5);\n\tfor(float i=0.;i++<itr;)\n    {\n\t\tfloat r2=2./clamp(dot(p,p),.1,1.);\n\t\tp=abs(p)*r2;\n\t\tp-=vec3(.7,.3,5.5);\n\t\ts*=r2;\n\t}\n\tScale=log2(s);\n\treturn mix(length(p),length(p.xy),step(0.,sin(2.*iTime+.3*sin(iTime*.5))))/s-r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(0,0,iTime),\n  \t\tw=normalize(vec3(.3*sin(iTime*.5),.5,1)),\n  \t\tu=normalize(cross(w,vec3(cos(iTime*.1),sin(iTime*.1),0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\tfloat h=0.,d,i;\n\tfor(i=1.;i<80.;i++)\n    {\n    \tp=ro+rd*h;\n\t\td=map(p);\n    \tif(d<.001)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=12.*vec3(sin(Scale+p.yxx*.08)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 33, 33, 528], [530, 530, 587, 587, 999]]}
{"id": "3tlfDN", "name": "Offset Triangle Pattern", "author": "Shane", "description": "An offset triangle pattern.", "tags": ["triangle", "pattern", "offset", "zentangle"], "likes": 30, "viewed": 375, "published": "Public API", "date": "1596900332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tOffset Triangle Pattern\n\t-----------------------\n\n    Just something I coded for fun. It's an offset triangle pattern in the form \n    of an instant algorithmic Zentangle work, which completely defeats the purpose \n    of the Zentangle methodology, but here it is anyway. :)\n\t\n    The idea is pretty simple. Render an offset triangle grid, then with the minimum \n    returned triangle information, render a pattern inside it. I see this particular \n    arrangement a lot. The Zentangle crowd make things like this all the time... \n    Although, they have the benefit of hand drawing, whereas I had to make do with \n    time constraints, some rushed math and half the artistic talent. :D\n\n    You can happily ignore most of the code and just use the \"blocks\" function to\n\tobtain the required triangle information, then take it from there. I'm going\n\tto put up a few more examples along these lines. I might also put together an \n    offset triangle jigsaw pattern at some stage.\n\n\n\n\tRelated examples:\n\n\n\t// Mattz put one of these together ages ago.\n\tice and fire - mattz\n\thttps://www.shadertoy.com/view/MdfBzl\n\n\t// An offset triangle heightfield -- Very cool. I have one of these coming\n\t// that takes a different approach.\n\tTriangulated Heightfield Trick 3 - fizzer\n\thttps://www.shadertoy.com/view/ttsSzX\n\n    // An extruded offset triangle grid.\n\tExtruded Offset Triangle Grid - Shane\n\thttps://www.shadertoy.com/view/WtsfzM\n\n\n*/\n\n\n// Offsetting the triangle coordinates. The look is a lot cleaner without it.\n#define OFFSET_TRIS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime/2.); \n}\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(289, 41)));\n    p = fract(vec2(262144, 32768)*n)*2. - 1.; \n    return sin(p*6.2831853 + iTime); \n}\n\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.57 + n2D3G(p*2.)*.28 + n2D3G(p*4.)*.15; }\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .0002/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .0002;      \n        \n}  \n\n// Rectangle dimentions, and consequently, the grid dimensions.\n//const vec2 rect = vec2(1.25, .8)*scale;\n//const vec2 rect = vec2(1., 1.5)*scale;\n// Equilateral dimensions: Basically, the base needs to be lengthened by\n// a factor involving sqrt(3), which easily relates back to equilateral geometry.\n//const vec2 rect = (vec2(1./.8660254, 1))*scale; // \"1/.8660254 = 2*sqrt(3)/3\". \n\n// Skewing half way along X, and not skewing in the Y direction. Skewing is \n// inversely effected by scale.\n//const vec2 sk = vec2(rect.x*.5, 0)/scale;\n// Irregular skewing is possible too, since it's all just math.\n//const vec2 sk = vec2(rect.x*.5, -rect.y*.25)/scale;\n\n// From the the following example:\n// Random Delaunay Triangulation - Tomkh\n// https://www.shadertoy.com/view/4sKyRD\n//\n// Use \"parabolic lifting\" method to calculate if two triangles are about to flip.\n// This is actually more reliable than circumscribed circle method.\n// The technique is based on duality between Delaunay Triangulation\n// and Convex Hull, where DT is just a boundary of convex hull\n// of projected seeds onto paraboloid.\n// We project (h1 h2 h3) triangle onto paraboloid\n// and return the distance of the origin\n// to a plane crossing projected triangle.\nfloat flipDistance(vec2 h1, vec2 h2, vec2 h3){\n\n   // Projects triangle on paraboloid.\n   vec3 g1 = vec3(h1, dot(h1, h1));\n   vec3 g2 = vec3(h2, dot(h2, h2));\n   vec3 g3 = vec3(h3, dot(h3, h3));\n   // Return signed distance of (g1, g2, g3) plane to the origin.\n   //#if FLIP_ANIMATION\n    // return dot(g1, normalize(cross(g3-g1, g2-g1)));\n   //#else\n     // If we don't do animation, we are only interested in a sign,\n     // so normalization is unnecessary.\n   \t return dot(g1, cross(g3-g1, g2-g1));\n   //#endif\n}\n*/\n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./4.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 id = vec2(0), cntr;\n    \n    // For block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n    // Height scale.\n    const float hs = .5;\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0];\n        // Skewed local coordinates.\n        p = skewXY(q.xy, sk);// - cntr*s;\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        // Skewed rectangle vertices. \n        vec2[4] vert = ps4;  \n     \n        #ifdef OFFSET_TRIS\n        // Offsetting the vertices.\n        vert[0] += hash22B((idi + vert[0]/2.))*.2;\n   \t\tvert[1] += hash22B((idi + vert[1]/2.))*.2;\n        vert[2] += hash22B((idi + vert[2]/2.))*.2; \n        vert[3] += hash22B((idi + vert[3]/2.))*.2;\n        #endif\n        \n        \n        // Unskewing to enable rendering back in normal space.\n        vert[0] = unskewXY(vert[0]*dim, sk);\n        vert[1] = unskewXY(vert[1]*dim, sk);\n        vert[2] = unskewXY(vert[2]*dim, sk);\n        vert[3] = unskewXY(vert[3]*dim, sk); \n        \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi*s, sk);  \n  \n      \n        // Some triangle flipping to ensure a Delaunay triangulation... Further non-Delaunay\n        // subdivisions will occur, so it's probably redundant, but it's here for completeness.\n        //float f = flipDistance(vert[0] - vert[2], vert[1] - vert[2], vert[3] - vert[2])<0.? 1. : -1.;\n \n        \n        // Partioning the rectangle into two triangles.\n        \n        \n        // Triangle one.\n        tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n         //if(f>.5) tri1.v = vec2[3](vert[0], vert[1], vert[3]); // Delaunay flipping.\n        tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n        tri1.triID = float(i); // Triangle ID. Not used here.\n        tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n        tri1.p = p; // 2D coordinates.\n         \n        // Triangle two.\n        tri2.v = vec2[3](vert[0], vert[2], vert[3]);\n        //if(f>.5) tri2.v = vec2[3](vert[1], vert[2], vert[3]);  // Delaunay flipping.\n        tri2.id = idi + inCentRad(tri2.v[0], tri2.v[1], tri2.v[2]).xy; // Position Id.\n        tri1.triID = float(i + 4); // Triangle ID. Not used here.\n        tri2.dist = sdTri(p, tri2.v[0], tri2.v[1], tri2.v[2]); // Field distance.\n        tri2.p = p; // 2D coordinates.\n         \n        // Doesn't work, unfortunately, so I need to write an ugly \"if\" statement.\n        //triS gTi = tri1.dist<tri2.dist? tri1 : tri2;\n        triS gTi; \n        // Obtain the closest triangle information.\n        if(tri1.dist<tri2.dist) gTi = tri1; \n        else gTi = tri2;\n        \n        \n        // If applicable, update the overall minimum distance value,\n        // then return the correct triangle information.\n        if(gTi.dist<d){\n            d = gTi.dist;\n            gT = gTi;\n            //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n/*\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n*/\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*24.;\n    q += vec2(n2D3G(p*1.5), n2D3G(p*1.5 + 7.3))*.1;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3) + .6); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    //col = mix(col, col*(ns + .3), .5);\n    // Has more of a colored pencil feel. \n    //col *= vec3(.8)*ns + .4;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //if(mod(ip.x + ip.y, 2.)<.5) \n    // Grayscale override.\n    \n    col = vec3(ns); \n    \n \n    \n    return col;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n    // Warping the background ever so slightly. The idea is that\n    // pencil drawings don't have perfectly straight lines.\n    uv += vec2(fBm(uv*12.), fBm(uv*12. + .5))*.005;\n    \n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = uv*gSc;// + vec2(0, iTime/24.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    \n    // Take a function sample. \n    triS gT = blocks(p);\n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene color to black.\n    vec3 col = vec3(0);  \n     \n    // Triangle color.\n    vec3 tCol = vec3(0);\n    \n    \n  \n    // Bottom layer color, or shade.\n    vec3 lCol = vec3(.05);\n     \n    \n    \n    // The triangle pattern: Render three wedged triangles with vertex points\n    // at each line edge extreme and a third point on the adjacent tangential\n    // edge (look at the top layer for a visual). Slide the adjacent edge\n    // point back a bit, then render another layer. If you do this a few times,\n    // a triangular spiral pattern will appear. You can add to the effect by\n    // coloring and shading according to layer depth.\n    //\n    // The following is just the way I chose to effect the aforementioned, but \n    // there'd no doubt be better ways to go about it, so how you achieve the \n    // same is up to you.\n    //  \n    vec3 triPat = vec3(1e5);\n    \n    vec2[3] v = svV;\n    \n    vec2 rp = svP;\n    //rp = rot2(iTime)*rp;\n  \n    // Start and end nudge factors. The third point needs to be moved along\n    // a tangent edge. The further out it is, the more the triangles \n    // appear to rotate.\n    \n  \n    float nfs = .45, nff = .07;\n    const int iter = 4; // Iterations.\n    for(int i = 0; i<iter; i++){\n        \n        // Normalized edge tangent vectors.\n        vec2[3] tng = vec2[3](normalize(v[1] - v[0]), normalize(v[2] - v[1]),\n                           normalize(v[0] - v[2])); \n        \n        lCol *= 1.8; // Increase the color for each layer.\n        \n        // Interpolate the nudge point factor.\n        float nf = mix(nfs, nff, float(i)/float(iter));\n\n        // Three side triangles for this particular layer, which consist of \n        // two vertices and a third point that slides out from the adjoining\n        // side... Just refer to the outer layer for a visual reference.\n        \n        vec2 atp; // Third, adjacent tangential edge point.\n        float ndg;\n        \n        // Edge one triangle.\n        ndg = length(v[2] - v[1])*nf; // Nudge length (decreasing each iteration).\n        atp = v[1] + tng[1]*ndg; // Adjacent tangential edge point.\n        triPat[0] = sdTri(rp, v[0], v[1], atp); // Wedge triangle for this edge.\n \n        // Edge two triangle.\n        ndg = length(v[0] - v[2])*nf;\n        atp = v[2] + tng[2]*ndg;\n        triPat[1] = sdTri(rp, v[1], v[2], atp);\n        //vec2 nw1 = p2;\n\n        // Edge three triangle.\n        ndg = length(v[1] - v[0])*nf;\n        atp = v[0] + tng[0]*ndg;\n        triPat[2] = sdTri(rp, v[2], v[0], atp);\n       \n        // Rotated sprinkled noise for this layer.\n        mat2 r2 = rot2(3.14159*float(i)/float(iter));\n        float nsl = fBm((r2*(svP - svID.xy))*64.)*.5 + .5;//mix(tx, tx2, .8);\n    \n        // Fake shading and noise application.\n        float sh = float(iter - i - 1)/float(iter);\n        lCol = vec3(1)*1./(1. + sh*sh*2.5);\n        lCol *= nsl*.5 + .5;\n        \n        // Failed experiment with color.\n        //if((i&1)==0) lCol *= vec3(2, 0, 0);\n        \n        // Rendering the three triangle wedges to each side.\n        for(int j = 0; j<3; j++){\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., triPat[j] - .002))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., triPat[j]));// + .005/3.\n            col = mix(col, lCol, 1. - smoothstep(0., sf*2., triPat[j] + .0035));// .005*2./3.\n        }\n        \n    }\n    \n    // Outer layer noise. This is applied to the border cords and points.\n    float ns = fBm((svP - svID.xy)*64.)*.5 + .5;\n \n    // Outside lines.\n    float ln = 1e5;\n    ln = min(ln, lBox(svP, svV[0], svV[1], 0.));\n    ln = min(ln, lBox(svP, svV[1], svV[2], 0.));\n    ln = min(ln, lBox(svP, svV[2], svV[0], 0.));\n    ln -= .0055; \n     \n    \n    lCol = vec3(ns*.5 + .5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4.*iRes/450., ln - .002))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., ln)));\n    col = mix(col, lCol*clamp(-ln/.005, 0., 1.), (1. - smoothstep(0., sf, ln + .0035)));  \n     \n    \n    // Vertices.\n    vec3 cir = vec3(length(svP - svV[0]), length(svP - svV[1]), length(svP - svV[2]));\n    float verts = min(min(cir.x, cir.y), cir.z);\n    verts -= .016;\n \n    vec3 vCol = lCol*.7;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5.*iRes/450., verts))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., .005, verts)));  \n    col = mix(col, vCol, (1. - smoothstep(0., sf, verts + .0035))); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, verts + .011))); // Pin staple hole. \n    \n    \n    // Slight pencil effect: Based on Flockaroo's pencil effect, which is far superior, so\n    // I'd definitely refer to that one, if you're interested in that kind of thing.\n    col = mix(col, pencil(col, oP), .5);\n    \n    // Applying a touch of color. It's a design cliche, but it works.\n    col = mix(col, col*vec3(1, .05, .1)/.7, (1. - smoothstep(0., sf, verts)));\n   \n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1537, 1570, 1592, 1592, 1650], [1653, 1681, 1702, 1702, 1765], [1768, 1790, 1812, 2161, 2292], [2294, 2316, 2338, 2687, 2816], [2819, 2860, 2885, 2927, 3373], [3375, 3399, 3417, 3417, 3476], [3480, 3522, 3581, 3581, 4161], [4164, 4195, 4228, 4228, 4315], [4317, 4556, 4601, 4601, 4764], [4766, 4801, 4843, 4869, 5148], [5151, 5214, 5242, 5242, 5286], [5288, 5353, 5383, 5521, 5569], [7892, 8148, 8168, 8168, 12260], [12262, 12854, 12884, 13649, 15515], [15518, 15518, 15572, 15630, 21759]]}
{"id": "3tlfR7", "name": "Caustics Noise", "author": "myxy", "description": "A modification of David Hoskins's caustics shader\nhttps://www.shadertoy.com/view/MdKXDm\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n", "tags": ["2d", "water", "caustics", "watercaustics"], "likes": 9, "viewed": 381, "published": "Public", "date": "1596350103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A modification of David Hoskins's caustics shader\n// https://www.shadertoy.com/view/MdKXDm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat h12(vec2 p)\n{\n    return fract(sin(dot(p,vec2(32.52554,45.5634)))*12432.2355);\n}\n\nfloat n12(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f *= f * (3.-2.*f);\n    return mix(\n        mix(h12(i+vec2(0.,0.)),h12(i+vec2(1.,0.)),f.x),\n        mix(h12(i+vec2(0.,1.)),h12(i+vec2(1.,1.)),f.x),\n        f.y\n    );\n}\n\nfloat caustics(vec2 p, float t)\n{\n    vec3 k = vec3(p,t);\n    float l;\n    mat3 m = mat3(-2,-1,2,3,-2,1,1,2,2);\n    float n = n12(p);\n    k = k*m*.5;\n    l = length(.5 - fract(k+n));\n    k = k*m*.4;\n    l = min(l, length(.5-fract(k+n)));\n    k = k*m*.3;\n    l = min(l, length(.5-fract(k+n)));\n    return pow(l,7.)*25.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 col = vec3(0.);\n    col = vec3(caustics(4.*p,iTime*.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 182, 201, 201, 268], [270, 270, 289, 289, 508], [510, 510, 543, 543, 830], [832, 832, 889, 889, 1065]]}
{"id": "3tlfRs", "name": "Fast Noise - GPU Squares RNG", "author": "km", "description": "A GPU version of the Squares Random Noise Generator. The next step is to generate some terrain with it and try some raymarching.", "tags": ["procedural", "noise", "fast", "rng", "squaresrng", "statelessrng"], "likes": 6, "viewed": 379, "published": "Public API", "date": "1597480289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A webgl2 implementation of the Squares RNG\n// algorithm https://squaresrng.wixsite.com/rand\n//\n// Copyright (c) 2020 Bernard Widynski: original implementation in C\n// Copyright (c) 2020 Kyle Marshall: implementation in OpenGL ES 3   \n//                                                                          \n//  This code can be used under the terms of the GNU General Public License \n//  as published by the Free Software Foundation, either version 3 of the   \n//  License, or any later version. See the GPL license at URL               \n//  http://www.gnu.org/licenses\n//\n// Original source code is available here:\n// https://squaresrng.wixsite.com/rand\n//\n// I'm looking to use it as my go to noise function\n// It is simple and only uses mult/adds, bitshifts,\n// and bitwise ORs. With no state, it was trivially\n// parallelizable to the GPU.\n\nprecision highp float;\nprecision highp int;\n\n// provides 16 psuedo-random bits\n// conviently packaged in a float\n// in the [0,1] range.\nfloat squares16(uint ctr) {\n    const uint key = uint(0x7a1a912f);\n    const float two16 = 65536.0;\n\n    uint x, y, z;\n\n    // initialize\n    // ==================================\n    // Weyl sequence vars, y and z\n    y = ctr * key;\n    z = (ctr + uint(1)) * key;\n\n    // init the mixing var, x\n    x = y;\n\n    // begin the mixing rounds\n    // ===================================\n\n    // round 1\n    x = x*x + y; x = (x>>16) | (x<<16);\n\n    // round 2\n    x = x*x + z; x = (x>>16) | (x<<16);\n\n    // round 3\n    x = (x*x + y) >> 16;\n\n    return float(x)/two16;\n}\n\nfloat pixel_id(vec2 fragCoord) {\n    return dot(fragCoord.xy,\n               vec2(1, iResolution.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = pixel_id(fragCoord);\n    int cnt_pixels = int(iResolution.x * iResolution.y);\n\n    vec3 col = vec3(squares16(uint(id)+uint(iFrame*cnt_pixels)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfRs.jpg", "access": "shaders20k", "license": "gpl-2.0-plus", "functions": [[897, 988, 1015, 1015, 1552], [1554, 1554, 1586, 1586, 1657], [1659, 1659, 1716, 1716, 1934]]}
{"id": "3tlfW7", "name": "Radiance", "author": "kylehovey", "description": "Just some fun with interference patterns", "tags": ["interference", "array", "phased"], "likes": 7, "viewed": 252, "published": "Public", "date": "1596902702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n#define COUNT_RADIUS 5\n\nvec4 colorSin(float value) {\n    vec4 preNormal =  vec4(\n        sin(value),\n        sin(value - TAU/3.0),\n        sin(value - 2.0 * TAU/3.0),\n        1.0\n    );\n    \n    return 2.0 * preNormal - 1.0;\n}\n\nfloat sinSource(vec2 origin, float frequency, float phase, vec2 point) {\n    float t = distance(origin, point);\n\n    return sin(TAU * (frequency * t - phase) - iTime*5.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    float sum = 0.0;\n\n    for (int i = -COUNT_RADIUS; i < COUNT_RADIUS; ++i) {\n        sum += sinSource(vec2(100*i, 0.0), 0.02, sin(iTime / 5.0), xy);\n    }\n\n    \n    for (int i = -COUNT_RADIUS; i < COUNT_RADIUS; ++i) {\n        sum += sinSource(vec2(0.0, 100*i), 0.02, cos(iTime / 5.0), xy);\n    }\n    \n    float envelope = 1.0 / (1.0 + exp(pow(length(xy) / 300.0, 2.0)));\n\n    fragColor = colorSin(envelope * sum);\n    fragColor = vec4(vec3(sum / 6.0), 1.0) + 0.1 * fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 78, 78, 252], [254, 254, 326, 326, 427], [429, 429, 484, 484, 1012]]}
{"id": "3tlfWS", "name": "TSP length map Five Fixed Points", "author": "jayprich", "description": "Travelling Salesman Problem : Total length map.\nminimum tour length over 60 distinct permutations amongst Five Fixed Points.", "tags": ["tsp"], "likes": 0, "viewed": 66, "published": "Public", "date": "1597610300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec2 p1=vec2(.1,.1);\nconst vec2 p2=vec2(.3,.7);\nconst vec2 p5=vec2(.5,1.3);\n\nvoid mainImage(out vec4 col, in vec2 p)\n{\n    vec2 p3=vec2(.7+.4*cos(.3*iTime),.5+.4*sin(iTime));\n    vec2 p4=vec2(.7+.7*cos(1.5*iTime),.5+.1*sin(.2*iTime));\n    float d,e,f,g;\n    vec2 uv=p.xy/iResolution.y;\n    e=distance(uv,p1)+distance(p1,p2)+distance(p2,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,uv);f=0.;g=0.;\n    d=distance(uv,p2)+distance(p2,p1)+distance(p1,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.7;}\n    d=distance(uv,p2)+distance(p2,p3)+distance(p3,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.3;}\n    d=distance(uv,p1)+distance(p1,p3)+distance(p3,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,uv);if(d<e){e=d;f=.5;g=1.;}\n    d=distance(uv,p3)+distance(p3,p1)+distance(p1,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,uv);if(d<e){e=d;f=.6;g=.1;}\n    d=distance(uv,p3)+distance(p3,p2)+distance(p2,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,uv);if(d<e){e=d;f=.4;g=.6;}\n    d=distance(uv,p2)+distance(p2,p3)+distance(p3,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=.3;g=.7;}\n    d=distance(uv,p1)+distance(p1,p3)+distance(p3,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.9;g=.9;}\n    d=distance(uv,p3)+distance(p3,p1)+distance(p1,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.9;g=.2;}\n    d=distance(uv,p3)+distance(p3,p2)+distance(p2,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=1.;g=1.;}\n    d=distance(uv,p1)+distance(p1,p2)+distance(p2,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.6;}\n    d=distance(uv,p2)+distance(p2,p1)+distance(p1,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.2;g=.6;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p1)+distance(p1,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.6;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p2)+distance(p2,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=.1;g=.6;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p2)+distance(p2,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.3;g=.2;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p1)+distance(p1,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.6;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p3)+distance(p3,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=1.;g=.1;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p3)+distance(p3,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.7;g=.6;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p2)+distance(p2,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.9;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p1)+distance(p1,p3)+distance(p3,p5)+distance(p5,uv);if(d<e){e=d;f=.5;g=.2;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p3)+distance(p3,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.9;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p3)+distance(p3,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.6;g=.2;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p1)+distance(p1,p2)+distance(p2,p5)+distance(p5,uv);if(d<e){e=d;f=.3;g=.8;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p2)+distance(p2,p1)+distance(p1,p5)+distance(p5,uv);if(d<e){e=d;f=.8;g=.2;}\n    d=distance(uv,p2)+distance(p2,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.5;g=.5;}\n    d=distance(uv,p1)+distance(p1,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.4;g=.4;}\n    d=distance(uv,p3)+distance(p3,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.4;g=.6;}\n    d=distance(uv,p3)+distance(p3,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.7;g=.7;}\n    d=distance(uv,p1)+distance(p1,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.3;g=.9;}\n    d=distance(uv,p2)+distance(p2,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.4;g=.7;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.5;g=.3;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.3;g=.2;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.4;g=.5;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.4;g=.1;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.7;g=.1;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.5;g=.8;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p2)+distance(p2,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.9;g=.8;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p1)+distance(p1,p5)+distance(p5,p3)+distance(p3,uv);if(d<e){e=d;f=.9;g=.8;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p3)+distance(p3,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.9;g=.3;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p3)+distance(p3,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.2;g=.5;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p1)+distance(p1,p5)+distance(p5,p2)+distance(p2,uv);if(d<e){e=d;f=.1;g=.6;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p2)+distance(p2,p5)+distance(p5,p1)+distance(p1,uv);if(d<e){e=d;f=.6;g=.8;}\n    d=distance(uv,p1)+distance(p1,p2)+distance(p2,p3)+distance(p3,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.8;g=.3;}\n    d=distance(uv,p2)+distance(p2,p1)+distance(p1,p3)+distance(p3,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.9;g=.4;}\n    d=distance(uv,p2)+distance(p2,p3)+distance(p3,p1)+distance(p1,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.9;g=.5;}\n    d=distance(uv,p1)+distance(p1,p3)+distance(p3,p2)+distance(p2,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.9;g=.5;}\n    d=distance(uv,p3)+distance(p3,p1)+distance(p1,p2)+distance(p2,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.4;g=.9;}\n    d=distance(uv,p3)+distance(p3,p2)+distance(p2,p1)+distance(p1,p5)+distance(p5,p4)+distance(p4,uv);if(d<e){e=d;f=.6;g=.3;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,p1)+distance(p1,p2)+distance(p2,uv);if(d<e){e=d;f=.8;g=.8;}\n    d=distance(uv,p3)+distance(p3,p4)+distance(p4,p5)+distance(p5,p2)+distance(p2,p1)+distance(p1,uv);if(d<e){e=d;f=.4;g=.1;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,p2)+distance(p2,p3)+distance(p3,uv);if(d<e){e=d;f=.6;g=1.;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,p1)+distance(p1,p3)+distance(p3,uv);if(d<e){e=d;f=.9;g=.8;}\n    d=distance(uv,p2)+distance(p2,p4)+distance(p4,p5)+distance(p5,p3)+distance(p3,p1)+distance(p1,uv);if(d<e){e=d;f=.4;g=.6;}\n    d=distance(uv,p1)+distance(p1,p4)+distance(p4,p5)+distance(p5,p3)+distance(p3,p2)+distance(p2,uv);if(d<e){e=d;f=.1;g=.3;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,p2)+distance(p2,p3)+distance(p3,uv);if(d<e){e=d;f=.7;g=.8;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,p1)+distance(p1,p3)+distance(p3,uv);if(d<e){e=d;f=.5;g=.4;}\n    d=distance(uv,p4)+distance(p4,p2)+distance(p2,p5)+distance(p5,p3)+distance(p3,p1)+distance(p1,uv);if(d<e){e=d;f=.7;g=.7;}\n    d=distance(uv,p4)+distance(p4,p1)+distance(p1,p5)+distance(p5,p3)+distance(p3,p2)+distance(p2,uv);if(d<e){e=d;f=.5;g=1.;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,p1)+distance(p1,p2)+distance(p2,uv);if(d<e){e=d;f=.8;g=.5;}\n    d=distance(uv,p4)+distance(p4,p3)+distance(p3,p5)+distance(p5,p2)+distance(p2,p1)+distance(p1,uv);if(d<e){e=d;f=.7;g=1.;}\n\tcol=vec4(abs(mod(20.*e,2.)-1.),g,f,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 124, 124, 7881]]}
{"id": "3tsBDj", "name": "stargazer", "author": "inbisibler", "description": "circle orbit, and use random function", "tags": ["circleorbit"], "likes": 4, "viewed": 131, "published": "Public", "date": "1597760245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rd(float x){\n\treturn fract(sin(x)*50000.0);\n}\n\nfloat cc(float radius,vec2 center, vec2 pos, float b){\n\tfloat color = pow(radius/length(pos-center),b);    \n    return color;\n}\n\nvec2 rot(vec2 p, float th){\n\treturn vec2(p.x*cos(th)-p.y*sin(th),p.x*sin(th)+p.y*cos(th));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float th = 0.05*iTime;\n    vec2 p = vec2( uv.x*cos(th)-uv.y*sin(th), uv.x*sin(th)+uv.y*cos(th));\n    \n    float b = 0.;\n\tfor(float i = 0.0; i < 2000.0; i++){\n        b += cc(0.002*rd(i)*abs(sin(10.*rd(i+0.3)*th+rd(i+0.1)))+0.0005,vec2(rd(i+0.1),rd(i+0.2))*2.-1.,p,2.);\n    }\n    \n    for(float i = 0.0; i < 20.;i++){\n\t\tfloat r = 1.5*fract(-0.02*iTime*rd(i*0.03)+rd(i*0.02));\n        float th = 0.1*iTime*rd(i*0.04)+rd(i+0.03)*3.14*4.;\n        vec2 pc = rot(vec2(r,0.),th);\n    \tb += cc(0.03*fract(length(pc)/1.5),pc,uv,3.); \n    \n    }\n    \n    col = vec3(3.)*b;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 51], [53, 53, 107, 107, 180], [182, 182, 209, 209, 274], [277, 277, 333, 384, 1167]]}
{"id": "3tsBDX", "name": "Stacked layers of noise", "author": "enz0", "description": "I'm attempting to mimic this piece of work: https://jacobjoaquin.tumblr.com/post/188120374046/jacobjoaquin-volumetric-noise-20190225\n- Isometric stacked layers of animated 2d noise (so... 3d noise).\nThis is my first non-trivial shader!", "tags": ["noise", "layers"], "likes": 5, "viewed": 115, "published": "Public", "date": "1597927289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Trying to build stacked crosssectional plates of animated 3d noise, to mimic this gif: \n//https://jacobjoaquin.tumblr.com/post/188120374046/jacobjoaquin-volumetric-noise-20190225\n//\n// Using the noise algorithm from this shader by iq: https://www.shadertoy.com/view/4sfGzS\n// then making it have octaves.\n//\n// TODO: Make the plates square and isometric.\n// TODO: Fix the noise so that builds in from both up as well as down.\n// TODO: Correctly just overlay the colours of each upper disc on the lower discs, if the upper pixel is not transparent.  Need to model alpha.\n// TODO: don't calculate a noise value that is going to be thrown away!\n// DONE: add contour border colour to separate the layers of noise, and then make them opaque.\n//         - sort of.  Not sure of simulating blend mode blend and just overlaying the pixels.\n\n// DONE: add border colour to the rim of each plate (discs, for now), then make them otherwise transparent.\n\n\n\n//license from the noise sketch: https://www.shadertoy.com/view/4sfGzS\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\nfloat octaveNoise(in vec2 realuv, in float time){\n    float f = 0.0;\n    \n    //scale\n    vec2 uv = realuv * 8.0;\n    \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    \n    f  = 0.7 * noise( vec3(uv, time*0.6)  ); \n    \n    uv = m*uv;    \n\tf += 0.3 * noise( vec3(uv, time*0.2+100.)  ); \n\n\treturn 0.5 + 0.5*f;\n}\n\nfloat findEdgeOfNoise(in float n, in float a, in float b, in float borderWidth){\n    float f1 = smoothstep( a, b, n);\n\tfloat f2 = smoothstep( b, b+borderWidth, n);\n\treturn f1 - f2;\n}\n\n\nfloat circleMask(in float r, in vec2 realuv){\n    vec2 squishedUV = (realuv-vec2(0, .5))*vec2(1., 2);\n    float distToCentre =1.- length(squishedUV - vec2(1.,0.50));\n    return smoothstep(r, r+0.003, distToCentre);\n}\n\nfloat circleBorderMask(in float r, in vec2 realuv){\n    vec2 squishedUV = (realuv-vec2(0, .5))*vec2(1., 2);\n    float distToCentre =1.- length(squishedUV - vec2(1.,0.50));\n    return 1.-smoothstep(0., 0.005, abs(r- distToCentre));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tbool doSecondColour = false;\n\tbool doPlateBorders = true;\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 realuv = p*vec2(iResolution.x/iResolution.y,1.0);\n    \n\n    float discRadius =0.65;\n    int numLayers = 20;\n    float layerSpacing = 0.5 / float(numLayers);\n    float time = iTime;\n    \n    vec3 col = vec3(0.);\n    for(int i =0; i < numLayers; i++){\n\t    vec3 plateCol = vec3(0.);\n        vec2 plateOffset = vec2(0., 0.45-layerSpacing * float(i));\n\n        vec2 apparentUV = realuv.xy + plateOffset;\n        float apparentTime = time*1. + 0.3 * float(i);\n        \n\t\t//generate noise, find the stepped body of it, find the edge of it.\n        float f = octaveNoise(apparentUV, apparentTime);\t\n\t\tfloat n1 = smoothstep( 0.79, 0.791, f);\n\t\tfloat n2 = smoothstep( 0.62, 0.625, f);\n        \n        \n        float nBorder = findEdgeOfNoise(f, 0.782, 0.79, 0.001);\n        float nBorder2 = findEdgeOfNoise(f, 0.62, 0.625, 0.001);\n        \n        float discMaskV = circleMask(discRadius, realuv + plateOffset);\n        \n        // Mask the noise by the shape of the disk (and set alpha to 40%)\n        plateCol.xy += 1. * n1 * discMaskV;\n        \n        if (doSecondColour){\n            plateCol.xz += 1. * (1. - n2) * discMaskV;\n        }\n\n\t\t// Add a circular border/rim to each plate\n        // First, delete whatever was underneath - hacky.  just blend a top plate with black\n        if (doPlateBorders){\n            col *= 1. - vec3(circleBorderMask(discRadius, realuv + plateOffset));\n\t\t\tplateCol += 0.2 * vec3(circleBorderMask(discRadius, realuv + plateOffset));\n        }\n\n        // Add black border around noise\n        col *= 1. - nBorder* discMaskV;\n        if (doSecondColour){\n\t        // Add black border around second colour of noise\n        \tcol *= 1. - nBorder2* discMaskV;\n        }\n\n        //TODO: we want to draw the colours of this plate over the top of existing colours not add.  However, we need to track pixel alpha for that, too.\n        // Put the plate colour over the existing colours\n        col += plateCol;\n    }\n    \n \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBDX.jpg", "access": "shaders20k", "license": "mit", "functions": [[2830, 3125, 3182, 3182, 3277], [3279, 3279, 3305, 3305, 3779], [3782, 4400, 4449, 4449, 4709], [4711, 4711, 4791, 4791, 4893], [4896, 4896, 4941, 4941, 5112], [5114, 5114, 5165, 5165, 5346], [5348, 5348, 5405, 5405, 7496]]}
{"id": "3tSBRz", "name": "Deoxyribonucleic-Acid", "author": "akanarika", "description": "Deoxyribonucleic acid is a molecule composed of two polynucleotide chains that coil around each other to form a double helix carrying genetic instructions for the development, functioning, growth and reproduction of all known organisms and many viruses.", "tags": ["2d"], "likes": 6, "viewed": 100, "published": "Public", "date": "1598147303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3. * (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n\n    vec3 c;\n    for (int i = 0; i < 10; i++) {\n        float h = -0.88 + .22 * float(i);\n        float t = iTime * .9 + h;\n        vec2 p1 = vec2(.2 * sin(t * 2.), h);\n    \tvec2 p2 = vec2(.2 * sin(t * 2. + pi), h);\n    \tc += vec3(.2, .4, .5) * smoothstep(.1 + .02 * cos(t * 2.),\n                                           .08 + .02 * cos(t * 2.),\n                                           length(uv - p1))\n        + vec3(.6, .4, .5) * smoothstep(.1 - .02 * cos(t * 2.),\n                                           .08 - .02 * cos(t * 2.),\n                                           length(uv - p2));\n        c += vec3(.1) * smoothstep(0.012, 0.01, length(uv - p1))\n            + vec3(.1) * smoothstep(0.012, 0.01, length(uv - p2));\n        if ((abs(uv.x - p1.x) < abs(p1.x - p2.x)) && (abs(uv.x - p2.x) < abs(p1.x - p2.x))) {\n        \tc += vec3(.1) * smoothstep(0.012, 0.01, abs(uv.y - h));\n    \t}\n    }\n    \n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 1119]]}
{"id": "3tsBWS", "name": "DG Celtic Torc and reflection", "author": "DG622", "description": "this is all ray marched and based on the tutorial 'treefoil knots' from the Art of Code aka BigWings. Raymarched water reflecting on a ray  marched torus. I could not get the water to reflect off the torus though!!\nYou have to watch it for a minute or so ", "tags": ["toruswaterreflectionraymarch"], "likes": 3, "viewed": 110, "published": "Public", "date": "1598444035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is care of a torus tutorial 'trteefoil knots' from Art of Code Aug 2020\n//and i have attempted to get a reflection from a raymarched image rather\n//than a pre formed texture. I have managed this for the reflection of the Torc on the water but have not managed\n//to get it the other way round despite a number of attempts. Argh!!\n\n\nfloat N21 (vec2 p){\n \tp = fract(p* vec2( 273.53, 375.47));\n    p+=dot(p, p + 27.357);\n    return fract(p.x*p.y);\n}\n\nfloat smoothNoise (vec2 uv){// this is essentiually a mixing function /tiling\n  uv.xy -= iTime*.57;\n    vec2 lv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 id = floor(uv);  \n    lv = lv * lv *(3.0 - 2.0 *lv);//interpolation for dummies video but this is essentially a smoothstep\n    float bl =fract( N21(id));//bottom left// fract here for the sky goes with the N21 fract if using N21a dont need it\n    float br = N21(id + vec2(1, 0));//bottom right\n    float b = mix( bl, br, lv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float tl = N21(id + vec2(0, 1));//top left etc\n    float tr = N21(id + vec2(1, 1));\n    float t = mix( tl, tr, lv.x);       \n    return mix(b, t, lv.y);    \n}\n\nfloat smoothNoise2 (vec2 uv, float flag ){//layering\n   float c;\n    if(flag < 1.0){ c = smoothNoise(uv*4.);  // So (uv * frequency ) * Amplitude\n                  }else{c+= smoothNoise(uv* 8. ) * .5;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .25;\n    c+= smoothNoise(uv* 32. ) * .125;\n    c+= smoothNoise(uv* 65. ) * .0625;\n                  }\n   \n    return c/2.5;\t\t\t\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n}\n\n\nmat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n    \n}\n\nfloat Wave (vec3 p){//por the water\n    \tfloat v_time = iTime*0.5;   \t\t\t\n    \tfloat wave;         \n  \t\tp.xz*=0.07;\n    \tp.x -= v_time* 0.1751;\n    \tp.z -= v_time* 0.357;     \t\t\t\t\t\n    \twave = sin((p.x+p.z)*0.7751)*0.5351 ;//x direction separate out from z (freq)*amplitude\n \t\t//wave+=sin(p.x*0.937)*1.773;\n  \t\twave += smoothNoise2(vec2(sin(p.x), sin(p.z)), 3.0);//higher resolution   \t\t\n   \t\t wave+=smoothNoise2(vec2(sin(p.x+0.13), sin(p.z+0.57)), 0.0);  //low resolution \nreturn wave;\n}\n\n\tfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\nvec2 twister(vec3 p){//the torc\n    p.y -= 4.0;\n    \tfloat r1 = 2.6;//larger diameter\n        float r2 = 0.01;//thinner strands this for the band though\n    \t      \n    \tvec2 cp = vec2(length(p.xz*0.9)-r1, p.y);    \t  \n        float a;\n       \ta = atan(p.x, p.z);  \n    if(a  > -2.9 && a < 2.9 ){ //a runs form - pie to pie\n        cp*=Rot(a*19.0);//more curls\n        cp.y = abs(cp.y*1.5)-0.07;//* tighter (as in metal)twined, minus is closer/tighter\n    \tr2 = 0.1;\n        \n    } else cp = vec2(length(p.xz*0.9)-0.0, p.y);//so need to set cp diameter to zero;\n                 \n    cp.y = abs(cp.y) - 0.1;//this gives the central strand\n    return vec2(length(cp)-r2, 10.0);  //the y is just a fl;ag to identify this as thetorc  \n    \n}       \n    \n     vec2 GetDist(vec3 p, float flag){\n\t\tvec2 retVal;\n        vec2 torc;\n        float wave;\n        float sea;\n         \t\t\t//dome was going to have a raymarched dome over it all with cloud, did not get the right effect\n       \t\t\t\t//  float dSphere = sphere(vec4(0.0,8.0,0.0,20.5),p);\n       \t\t\t\t//  if(dSphere < 0.0){retVal.y = 3.0;//so if inside create a flag which will be liberated in main\n       \t\t\t\t//  }else retVal.y = 0.0;\n       \t\t\t\t//  dSphere = abs(dSphere);//make it hollow\n       \t\t\t\t\t\t\t//  float dPlane = dot(vec3(p.x,p.y+0.0,p.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane\n       \t\t\t\t// if(p.y < 8.0) retVal.y = 0.0;//re set the flag if we are below the dome bottom\n       \t\t\t\t//  float dome = max(dSphere, -p.y+8.0) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t \n        //the Torc\n         torc = twister(p);         \n        \n         float dSphereR = sphere(vec4(0.75,3.9,-2.6,0.4),p);\n         float dSphereL = sphere(vec4(-0.75,3.9,-2.6,0.4),p);\n         float dTPlane = dot(vec3(p.x,p.y+wave*5.0,p.z+2.9), normalize(vec3 (0.0,0.0,-1.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\t         \t\t       \n         float d = max(dSphereR, dTPlane) - 0.01;//max gives intersection of a plane, the number: thickness\n\t\t float d2 = max(dSphereL, dTPlane);        \n         d = min(d, d2); \n         torc.x = min(torc.x, d)/2.0;//divide to prevent artifact at cost to speed      \n                 \n\t\t//xxx water\n     \twave = Wave(p);\n    \tfloat dwPlane = dot(vec3(p.x,p.y-2.5-wave,p.z), normalize(vec3 (0.0,1.0,0.0))); \n    \tsea = min(dwPlane, p.y);        \n      \n        if(torc.x < sea )retVal.y = torc.y;\n        retVal.x = min(sea, torc.x);         \n                      \n        return retVal;\n        }\n\n\n     vec2 RayMarch(vec3 ro, vec3 rd, float flag){//0.0 low detail, 3.0 most\n            float dO = 0.0;\n            vec2 retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p, flag);\n               \n           \t\tfloat dS = retVal.x;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal.x = dO;\n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p, 0.0).x; //the y carries the flag for being inside the sphere not needed here         \t\n          \n            vec3 n = d - vec3(GetDist(p-e.xyy, 0.0).x,GetDist(p-e.yxy,0.0).x, GetDist(p-e.yyx,0.0).x);           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( -15.0, 10.0, -1.0);\n\n         \t\t\t\t\t// lightPos.xz += vec2(sin(iTime*2.0), cos(iTime*2.0));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0), 0.0);// so no negative numbers, last one just a value\n            //for the shadow\n            float retVal  = RayMarch(p + n * 0.01 * 3.0, light, 3.0).x;//this 3.0 is a work around second 3 is high detail\n            float d = retVal;\n            if (d < length (lightPos - p )) {dif.x *= 0.7;//faint shadow\n                                           \tdif.y = 10.0 ;//use as flag fopr reflectioon\n          }else dif.y = n.y;//ie normal elevation\n          \n           // dif.x*=0.8;//dimm it a little             \n            return dif;\n        }\n  \nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \t\tvec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \t\t\t                \n   \t\t\tvec2 m = iMouse.xy/iResolution.xy;   \n    \n    \t\tvec2 st = vec2( atan(uv.x, uv.y), length(uv));//the ploar coords\n    \n    \t\tvec3 RGB = vec3(0.0);\n    \t\tvec3 RGB1 = vec3(0.83, 0.69, 0.22);//gold\n    \t\tvec3 RGB2 = vec3(0.621, 0.273, 0.277);//reddish\n    \t\tvec3 RGBblue = vec3(0.05, 0.13, 0.29);\n    \t\tvec3 RGBgreen = vec3(0.05, 0.27, 0.35);\n    \t\tvec3 RGBwater = vec3(0.0);\n     \t\tfloat c;\n    \t\t\t\t\t// vec3 LightCol = vec3(0.15, 0.1, 0.1);\n    \t\tvec3 col = vec3(0.0);    \n    \t\t\n    \t\tvec3 ro = vec3(0.0+sin(iTime*0.2), 8.0, 2.0+cos(iTime*0.3));//    for the water was vec3 ro = vec3(15.0 , 15.0 ,-15.0  );\n    \t\t\t\t\t//\tro.yz *= Rot(-m.y*3.14+1.);\n    \t\t\t\t\t\t//ro.xz *= Rot(-sin(ro.x*iTime)*6.2831);    \n    \t\tvec3 rd = GetRayDir(uv, ro, vec3(0), 1.0);    \t\t\n            vec2 d = RayMarch(ro,rd, 0.0);\t//y is a flag 3.0 if inside the dome otherwise 0.0\t\t   \n            vec3 p= ro+rd*d.x;   \n            vec2 diff = GetLight(p);\n    \n    \t\tRGBwater = mix(RGBblue, RGBgreen, smoothstep(0.05, 0.6, diff.y));//mix green and blu via the normal    \n    \t\t\t\t\t\t\t\t//gives a dome but need to zoom out\n   \t\t\t\t\t\t\t\t\t//\tst = vec2(atan(p.x ,p.y), length(p.xy));//the polar coords for the dome        \n    \t\t\t\t\t\t\t\t//if (d.y>2.0 && d.y<4.0) \n        \t\t\t\t\t\t\t//\t{c = max(smoothstep(0.9,-.100,st.y),smoothNoise2(st, 3.0)); //inside the dome use polar coords for the cloud\n        \t\t\t\t\t\t\t//   \t col =vec3(c);//if in the dome show sky\n         \t\t\t\t\t\t\t//   } else {col += vec3(RGBwater+diff.x); //the water\n            col += vec3(RGBwater+diff.x); //the water\n    \t\n           \n    \t\t//reflection of torc on the water\n            vec3 n = GetNormal(p);\n       \t\tvec3 r = reflect (rd, n);\n            float ref = RayMarch(p+0.1, r, 0.0).x;// the 0.0 was a flag that i tried to use to get thje water reflected on the torc did not work\n            if (ref < length( p-r ))col=min(col, RGB1*ref);//blends better than just adding\n                  //xxx\n            //the torc                               \n    \t\tif(d.y > 9.0){col = vec3(RGB1+diff.x)*0.47; //ie d.y tells us this is the torc\n            float spec = max (0.0, r.y);\n    \t\tcol+=spec*spec*spec*0.5;\n                 }\n            \n    //try as i might could not get the water to reflect off the Torc        \n    \n    \t//col = pow(col, vec3(0.4545));   //gamma correction bit washed out for this                 \n            fragColor = vec4(col, 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 338, 357, 357, 452], [454, 454, 482, 531, 1236], [1238, 1238, 1280, 1290, 1762], [1765, 1765, 1784, 1784, 1865], [1867, 1867, 1887, 1902, 2354], [2357, 2357, 2389, 2389, 2462], [2463, 2463, 2484, 2494, 3201], [3219, 3219, 3252, 3252, 4997], [5005, 5005, 5049, 5075, 5512], [5516, 5516, 5540, 5540, 5895], [5904, 5904, 5926, 5926, 6754], [6758, 6758, 6808, 6808, 6999], [7001, 7001, 7058, 7058, 9532]]}
{"id": "3tSBzW", "name": "Box Field", "author": "scanlime", "description": "Could use some antialiasing and a floor, but what the hey. Just learning how to write a sphere tracer from scratch and playing with defining shapes on a grid.", "tags": ["grid", "sdf", "zoom", "boxes"], "likes": 6, "viewed": 76, "published": "Public", "date": "1598371860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 empty() { return vec4(0.,0.,0.,1e20); }\nvec4 inv(vec4 a) { return vec4(a.xyz, -a.w); }\nvec4 un(vec4 a, vec4 b) { return a.w < b.w ? a : b; }\nvec4 isect(vec4 a, vec4 b) { return a.w > b.w ? a : b; }\nvec4 diff(vec4 a, vec4 b) { return isect(a, inv(b)); }\n\nvec4 sphere(vec3 matl, vec3 p, float r) { return vec4(matl, length(p) - r); }\nvec4 box(vec3 matl, vec3 p, vec3 r, float o) { return vec4(matl, length(max(vec3(0.), abs(p)-r+o))-o); }\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\nvec4 repeating(vec3 p, vec2 grid)\n{\n    vec3 color = vec3(.2) + vec3(\n        fract(1e3*sin(dot(grid, vec2(1e2, 1e1)))),\n\t\tfract(1e3*sin(dot(grid, vec2(2e2, 6e1)))),\n\t\tfract(1e3*sin(dot(grid, vec2(3e2, 2e1)))));\n\n    float h = 1.*fract(1e3*sin(dot(grid, vec2(6e2, 3e1))));\n\n    p *= rotY(iTime*8.*pow(fract(sin(dot(grid, vec2(2e2, 8e2)))),1.5));\n    \n    return box(color, p, vec3(1.2, h, 1.2), .1);\n}\n\nvec4 scene(vec3 p)\n{\n    p -= vec3(0., -10., 3.);\n  \tp *= rotX(.4);\n    p *= rotY(iTime * 0.04);\n\n    vec3 sky = vec3(.9, .9, 1.2);\n    vec4 r = inv(sphere(sky, p, 800.));\n\n\tvec2 grid = floor(p.xz / 4.);\n    p.xz = mod(p.xz, 4.)-2.;\n\n\tr = un(r, repeating(p, grid));\n   \n    return r;\n}\n\nvec3 shade(vec3 p, vec4 r)\n{\n\tconst vec2 e = vec2(0.01, 0.);\n    const vec3 light = normalize(vec3(1.,1.,-2.));\n                    \n\tvec3 grad = (vec3(scene(p+e.xyy).w, scene(p+e.yxy).w, scene(p+e.yyx).w) - vec3(r.w)) / e.x;\n    float diff = .8 * dot(grad, light);\n    float spec = 2. * pow(dot(grad, light), 20.);\n    \n    return r.xyz * diff + r.xyz * spec;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    vec2 uv = (coord/iResolution.xy - vec2(.5)) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat fov = 1.1 + 0.9 * sin(iTime*.4);\n    vec3 view = normalize(vec3(uv.xy, 1./fov));\n    color = vec4(0.,0.,0.,1.);\n\n\tint iter = 0;\n    vec3 p = vec3(0.);\n    while (++iter < 300) {\n   \t  \tvec4 r = scene(p);\n        if (abs(r.w) < .001) {\n           \tcolor.xyz = shade(p, r);\n           \tbreak;\n\t    }\n        p += view * r.w;\n    }\n    \n    color.rgb *= sqrt(1.0 - dot(uv,uv));\n    color.rgb = pow(color.rgb, vec3(.8));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 44], [45, 45, 63, 63, 91], [92, 92, 117, 117, 145], [146, 146, 174, 174, 202], [203, 203, 230, 230, 257], [259, 259, 300, 300, 336], [337, 337, 383, 383, 441], [443, 443, 463, 463, 533], [534, 534, 554, 554, 624], [625, 625, 645, 645, 715], [717, 717, 752, 752, 1118], [1120, 1120, 1140, 1140, 1405], [1407, 1407, 1435, 1435, 1769], [1771, 1771, 1818, 1818, 2335]]}
{"id": "3tsBzX", "name": "noise and raymarch", "author": "zhengxiangkui", "description": "noise and raymarch", "tags": ["noise", "raymarch"], "likes": 7, "viewed": 253, "published": "Public", "date": "1597738277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEP 200.\n\nfloat hash(float x) {\n\treturn fract(sin(x * 13452.) * 1000.);\n}\n\nfloat hash2(vec2 v) {\n\treturn fract(sin(dot(v, vec2(64.24232, 87.873)))*10232.);\n}\n\nfloat hash3(vec3 v) {\n\treturn fract(sin(dot(v, vec3(64.24232, 87.873, 76.635)))*10232.);\n}\n\nfloat valueNoise(vec2 v) {\n\tvec2 f = floor(v);\n    vec2 r = smoothstep(vec2(0.), vec2(1.), fract(v));\n    \n    float lb = hash2(f);\n    float rb = hash2(f+vec2(1.,0.));\n    float lt = hash2(f+vec2(0.,1.));\n    float rt = hash2(f+vec2(1.,1.));\n    \n    float b_line = mix(lb, rb, r.x);\n    float t_line = mix(lt, rt, r.x);\n    \n    return mix(b_line, t_line, r.y);\n}\n\nfloat valueNoise3(vec3 v) {\n\tvec3 f = floor(v);\n    vec3 r = smoothstep(vec3(0.), vec3(1.), fract(v));\n    \n    return mix(\n    \tmix(mix(hash3(f), hash3(f+vec3(1.,0.,0.)), r.x), \n            mix(hash3(f + vec3(0.,1.,0.)), hash3(f + vec3(1.,1.,0.)), r.x), \n            r.y),\n        mix(mix(hash3(f+vec3(0.,0.,1.)), hash3(f+vec3(1.,0.,1.)), r.x), \n            mix(hash3(f + vec3(0.,1.,1.)), hash3(f + vec3(1.,1.,1.)), r.x), \n            r.y),\n        r.z\n    );\n}\n\nfloat sphere(vec3 p) {\n    // p.x += dot(p.yz, p.yz);\n    // p.z -= dot(p.xy, p.xy) * cos(iTime);\n    float fireK = smoothstep(0.9,.5,valueNoise3(p*10.+iTime*3.));\n    // vec3 fire = mix(vec3(1.,0.,0.), vec3(1., 1., 1.), fireK);\n    p.y -=  fireK;\t\n\treturn length(p) - 1.;\n}\n\nvec2 dist(vec3 p) {\n    vec2 sphereDist = vec2(sphere(p-vec3(0., 0., 0.)), 2.);\n\tvec2 tableDist = vec2(p.y + 1., 1.);\n    return tableDist.x < sphereDist.x?tableDist:sphereDist;\n}\n\nvec3 calNormal(vec3 p) {\n\tvec2 k = vec2(0.001, 0.);\n    return normalize(vec3(\n    \tdist(p + k.xyy).x - dist(p - k.xyy).x,\n        dist(p + k.yxy).x - dist(p - k.yxy).x,\n        dist(p + k.yyx).x - dist(p - k.yyx).x\n    ));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float y = -1.;\n    for(float i = 0.; i<STEP; i++) {\n    \tvec2 d = dist(ro + rd*t);\n        if(d.x < .001) {\n            y = d.y;\n        \tbreak;\n        }\n        if(t > STEP) {\n            t = -1.;\n            break;\n        }\n        t += d.x;\n    }\n    return vec2(t, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2. * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 skyCol = vec3(0.2, 0.6, 1.) - 0.3 * uv.y;\n\tvec3 col = skyCol;\n    vec3 ro = vec3(0.,0.,3.);\n    vec3 rd = normalize(vec3(uv.xy, -1.));\n    vec2 t = raymarch(ro, rd);\n    if(t.x > 0.) {\n        vec3 mate = vec3(0.2);\n        vec3 sunCol = vec3(1.);\n        vec3 p = ro + rd*t.x;\n        vec3 n = calNormal(p);\n        vec3 sunDir = normalize(vec3(0.8,0.4,0.2));\n        float sunDiff = max(0., dot(n, sunDir));\n        float skyDiff = clamp(0.5 + 0.5*dot(vec3(0.,1.,0.), n), 0., 1.);\n    \tfloat sunShadow = step(raymarch(p + n*0.01, sunDir).x, 0.);\n        \n        col = mate * vec3(8.0,5.0,3.0) * sunDiff * sunShadow;\n        col += mate * skyDiff * vec3(0.2, 0.6, 1.);\n        if(t.y > 1.) {\n            float fireK = smoothstep(0.2,.5,valueNoise3(p*10.+iTime*3.));\n            vec3 fire = mix(vec3(1.), vec3(1., 0.5, 1.), fireK);\n        \tcol *= fire;\n        } else {\n        \t// col += hash(uv.y);\n        }\n    }\n    col = pow(col, vec3(0.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 40, 40, 82], [84, 84, 105, 105, 166], [168, 168, 189, 189, 258], [260, 260, 286, 286, 625], [627, 627, 654, 654, 1089], [1091, 1091, 1113, 1188, 1365], [1367, 1367, 1386, 1386, 1546], [1548, 1548, 1572, 1572, 1773], [1775, 1775, 1808, 1808, 2107], [2109, 2109, 2166, 2217, 3338]]}
{"id": "3tsfD7", "name": "proceedural_track", "author": "slackmage", "description": "tunnel", "tags": ["tunnel"], "likes": 9, "viewed": 211, "published": "Public API", "date": "1596912423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot2(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s,-s, c);\n}\nvec3 rotate(vec3 p, vec3 a){\n    vec3 q=p;\n    q.yz=rot2(a.y)*q.yz;\n    q.xy=rot2(a.z)*q.xy;\n    q.xz=rot2(a.x)*q.xz;\n\treturn q;\n}\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat smax( in float a, in float b, in float s ){\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\nvec2 path(float z){\n    return vec2(.01*sin(z*40.)+.03*sin(z*13.),.03*cos(z*21.)+.08*cos(z*3.)+1.*z);\n}\nfloat de(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 50; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat deSM(vec3 p){\n    vec2 pth=path(p.z);\n    float t = max(abs(p.x+pth.x),abs(p.y+pth.y));\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.;\n    for (int i = 1 ; i <= 8; i++) {\n        float m = dot(p,p)*.7;\n        p/=m;\n        p.xy = fract(p.xy)-0.5;\n        s *= m;\n        p.xyz=p.yzx;\n    }\n    float f=1.0;\n    d=min(d,(length(p)-f)*s);\n    return smax(d,-t, 0.05);\n}\nfloat map(vec3 p){\n    float d=de(p);\n    p.xy+=path(p.z);\n    d=max(d,.01-max(abs(p.x),abs(p.y)));\n    p.y+=.01;\n    d=min(d,max(abs(p.x)-.001,abs(p.y)-.001));\n    return d;\n}\nconst float FAR_DIST=50.0;\nconst float NEAR_DIST=.0001;\nconst int ITERATIONS=128;\nvec3 trace(vec3 o, vec3 r){\n    float t = 0.;\n    vec3 p;\n    float steps=0.;\n    for (int i = 0; i < ITERATIONS; i++){\n        p = o + r * t;\n        float d = map(p);\n        t += d*.5;\n        if(d<NEAR_DIST){\n        \tbreak;\n        }\n        if(t>FAR_DIST){\n    \t\treturn vec3(0.0);\n    \t}\n        steps++;\n    }\n    vec2 eps = vec2(0.0, .0001);\n    vec3 normal = normalize(vec3(\n        map(p + eps.yxx) - map(p - eps.yxx),\n        map(p + eps.xyx) - map(p - eps.xyx),\n        map(p + eps.xxy) - map(p - eps.xxy)));\n    float diffuse = max(0.0, dot(-normalize(r), normal)*.5+.4);\n    //light in front of person\n    //vec3 p2=vec3(-path((iTime+1.)/20.),(iTime+1.)/20.);\n    //float diffuse = max(0.0, dot(-normalize(p-p2), normal));\n    float specular = pow(diffuse, 32.0);\n    //smooth color\n    vec3 albedo = hsv2rgb(vec3(40.*deSM(p),1.,1.));\n    //hard bands of color\n    //vec3 albedo = hsv2rgb(vec3(.1*floor(de8xSM(p)*400.),1.,1.));\n    return mix(albedo*(diffuse + specular),vec3(0.),steps/float(ITERATIONS));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 o = vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    //vec3 r = ca * normalize( vec3(uv.xy,1.5));\n    vec2 nMouse = vec2(10.0*(iMouse.x/iResolution.x)-5.,3.0*((iMouse.y/iResolution.y)-.5));\n    vec3 r;\n    if(iMouse.x==0.&&iMouse.y==0.){\n    \tr = ca *  normalize( vec3(uv.xy,1.5));\n    }else{\n    \tr = ca *  normalize( rotate(vec3(uv.xy,1.5),vec3(nMouse.x,nMouse.y,0.0)));\n    }\n    fragColor = vec4(trace(o, r),2.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ){\n    vec3 o = (fragRayOri/160.)+vec3(-path(iTime/20.),iTime/20.);\n    vec3 ta = (fragRayOri/160.)+vec3(-path(.01+(iTime/20.)),.01+(iTime/20.));\n    mat3 ca = setCamera( o, ta, 0.0 );\n    vec3 r = ca * fragRayDir;\n    vec3 col=trace(o, r);\n    fragColor = vec4(col,4.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [87, 87, 115, 115, 217], [218, 218, 239, 239, 408], [409, 409, 458, 458, 551], [552, 552, 571, 571, 655], [656, 656, 673, 673, 1041], [1042, 1042, 1061, 1061, 1428], [1429, 1429, 1447, 1447, 1605], [1688, 1688, 1715, 1715, 2709], [2710, 2710, 2761, 2761, 2938], [2939, 2939, 2995, 2995, 3603], [3604, 3604, 3697, 3697, 3968]]}
{"id": "3tSfDD", "name": "Voronoi Social Distancing", "author": "sariug", "description": "voronoi exercise", "tags": ["voronoi"], "likes": 2, "viewed": 42, "published": "Public", "date": "1598907404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 N22(vec2 p){\n\tvec3 a = fract(p.xyx*vec3(123.34, 234.34,345.65));\n    a += dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colarray[5] = vec3[](vec3(252./255., 48./255., 25./255.),vec3(255./255., 204./255., 0./255.),vec3(93./255., 27./255., 240./255.),vec3(95./255., 232./255., 89./255.),vec3(252./255., 177./255., 25./255.));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float minDist = 100.;\n    float t = iTime;\n    vec2 cellIndex =vec2(0.);\n    \n    \n    uv *=3.;\n    vec2 gridUV = fract(uv)-.5; \n    vec2 id = floor(uv);\n    for(int j = -1; j<2;j++)\n    {\n        for(int i = -1; i<2;i++){\n    \t\tvec2 offs = vec2(i,j);\n            vec2 n = N22(vec2(id+offs));\n            vec2 p = .5* sin(n*t)+offs;\n            float d = length(gridUV-p);\n        \n        \tif(d<minDist){\n        \t\tminDist = d;\n                cellIndex = id+offs;\n            }}\n    }\n    \n    // Time varying pixel color\n    vec3 col = vec3(.25/minDist);\n\n\tcol *=  colarray[ int(abs(cellIndex.x-cellIndex.y)) - 5 *  (abs(int(cellIndex.x-cellIndex.y))/5)];\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [93, 93, 110, 110, 230], [232, 232, 289, 289, 1342]]}
{"id": "3tSfDW", "name": "ProductLightIntensity", "author": "stevejtrettel", "description": "Light Intensity in the Product Geometries, default =S2xE.  Uncomment relevant line for H2xE", "tags": ["2d"], "likes": 1, "viewed": 239, "published": "Public", "date": "1598899295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float rng=5.+30.*(1.+cos(iTime/3.));//sets the size of the display\n  \n    //rescale coordinates\n    float L=rng*(uv.x-0.5);\n    float z=rng*(uv.y-0.5);\n    z=360./640.*z;//fix aspect ratio\n    float r2=L*L+z*z;\n    \n    \n    //area density\n    \n    \n    \n   //change this to change the geometry: sinh for hyperbolic, r for Euclidean\n\tfloat aDens=r2*sin(L)/(L);//Spherical Factor\n   \t//float aDens=r2*sinh(L)/(L);//Hyperbolic Factor\n    \n    float intensity=abs(1./aDens);\n    \n    float cappedIntensity=min(intensity,1.);\n\n    \n    // Time varying pixel color\n    vec3 blue=1.5*vec3(0.1,0.2,0.35);\n    vec3 orange=vec3(1.,177./255.,64./255.);\n    vec3 yellow=vec3(0.75,0.75,0.35);\n    vec3 mix=(1.-cappedIntensity)*blue+cappedIntensity*orange;\n    \n    vec3 col = (0.75+intensity/10.)*mix;\n        //intensity*vec3(1.,1.,0.5);\n       \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1049]]}
{"id": "3tsfRM", "name": "Happy Jumping With Sound", "author": "cascade256", "description": "Used boeroboy's suggestion of playing House of Pain's \"Jump Around\" with iq's shader \"Happy Jumping\". Playing the two together is great, but giving the shader a beat is even better!\n\nOriginal here: https://www.shadertoy.com/view/3lsSzf", "tags": ["procedural", "3d", "raymarching", "sdf", "animation", "soundcloud"], "likes": 3, "viewed": 1194, "published": "Public", "date": "1596321518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// An animation test - a happy and blobby creature jumping and\n// looking around. It gets off-model very often, but it looks\n// good enough I think.\n//\n// Making-of and related math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x-1.0 < pos.y ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n    \n    // ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5f = fract(atime+0.05);\n    float t5i = floor(atime+0.05); \n    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;\n    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    siz = siz - 0.25f + pow(texture(iChannel0, vec2(0.1, .25)).r, 3.0f) * 1.0f;\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // candy\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    ra *= pow(texture(iChannel0, vec2(id.x, .25)).r, 3.0f) * 2.0f;\n    d = sdSphere( vp, 0.35*ra)/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "llS3DG", "previewfilepath": "https://soundcloud.com/cafedelantaarn/house-of-pain-jump-around", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/cafedelantaarn/house-of-pain-jump-around", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfRM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[644, 696, 737, 737, 809], [811, 863, 901, 901, 998], [1000, 1052, 1093, 1093, 1165], [1167, 1241, 1276, 1276, 1302], [1304, 1378, 1437, 1437, 1526], [1528, 1528, 1602, 1602, 1755], [1757, 1809, 1839, 1839, 1872], [1974, 2069, 2107, 2107, 7222], [7224, 7224, 7276, 7276, 7778], [7780, 7842, 7902, 7902, 8340], [8342, 8406, 8450, 8450, 9013], [9015, 9015, 9076, 9076, 9369], [9371, 9371, 9422, 9439, 13083], [13085, 13085, 13137, 13137, 13314], [13316, 13316, 13373, 13373, 15335]]}
{"id": "3tSfRR", "name": "Practice Positioning", "author": "t420babe", "description": "A shader to practice position and color", "tags": ["gradient", "green", "practice"], "likes": 0, "viewed": 175, "published": "Public API", "date": "1598129002", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(1.0);\n  \tvec2 pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    pos.y -= 1.0;\n    float wrap_time = abs(sin(iTime)) * 2.0;\n    float f = pos.y + wrap_time;\n  \tcolor *= f * color - f * vec3(0.5235, 0.23451, 0.4348);\n    \n \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 375]]}
{"id": "3tsfRS", "name": "BON Boze", "author": "kaiware007", "description": "Obon or Bon Festival is a Buddhist festival in Japan to honor the spirit of our ancestors.", "tags": ["raymarching"], "likes": 7, "viewed": 88, "published": "Public", "date": "1597044588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 20.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-4;\nconst float EPS_N = 1e-5;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\n//const vec3 lightPos = vec3(0.50, 0.3, -0.5);\n//const vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdCucumber(vec3 p)\n{\n\tconst float w = 0.05;\n    const float angle = -radians(20.);\n    const float ds = 300.;\n    surface result = SURF_NOHIT(0.);\n\n    // body\n    vec3 b = p;\n    b.y -= 0.2;\n    \n    b = rotate(b, RAD90, vec3(1,0,0));\n    b = rotate(b, -RAD90, vec3(0,1,0));\n    b = rotate(b, -angle, vec3(0,0,1));\n    \n    float body = sdJoint3DSphere(b, 0.5, angle, w) + sin(ds * p.x) * sin(ds * p.y) * sin(ds * p.z) * 0.0025;\n    result = surface(body, vec4(0.01,0.1,0,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true);\n    \n    // leg\n    for(int i = 0; i < 4; i++) {\n        vec3 l = p;\n        float fx = i % 2 == 0 ? 1. : -1.;\n        float fz = float(i / 2);\n        float fz2 = (i / 2 == 0) ? 1. : -1.;\n        l.x += 0.025 * fx * fz2;\n        l.z += 0.1 * (fz > 0. ? 4. : 1.);\n        l.y -= 0.05;\n        l = rotate(l, radians(20.) * fz2, normalize(vec3(1,0,0.5 * fx)));\n\n    \tfloat leg = sdBox(l, vec3(0.01,0.15,0.01));\n    \tresult = opU(result, surface(leg, vec4(0.8,0.7,0.5,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true));\n    }\n    \n    return result;\n}\n\nsurface sdEggplant(vec3 p)\n{\n\tconst float w = 0.04;\n    const float angle = -radians(20.);\n    //const float ds = 300.;\n    surface result = SURF_NOHIT(0.);\n\n    // body\n    vec3 b = p;\n    b.y -= 0.1;\n    b.z += 0.15;\n    \n    b = rotate(b, RAD90, vec3(1,0,0));\n    b = rotate(b, -RAD90, vec3(0,1,0));\n    b = rotate(b, -angle, vec3(0,0,1));\n    \n    float body = sdJoint3DSphere(b, 0.25, angle, w, w+0.03) ;\n    result = surface(body, vec4(0.025,0,0.05,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true);\n    \n    // leg\n    for(int i = 0; i < 4; i++) {\n        vec3 l = p;\n        float fx = i % 2 == 0 ? 1. : -1.;\n        float fz = float(i / 2);\n        float fz2 = (i / 2 == 0) ? 1. : -1.;\n        l.x += 0.025 * fx * fz2;\n        l.z += 0.15 * (fz > 0. ? 2. : 1.);\n        l.y -= 0.0125;\n        l = rotate(l, radians(20.) * fz2, normalize(vec3(1,0,0.5 * fx)));\n\n    \tfloat leg = sdBox(l, vec3(0.01,0.125,0.01));\n    \tresult = opU(result, surface(leg, vec4(0.8,0.7,0.5,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true));\n    }\n    \n    return result;\n}\n\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    // boze\n    vec3 b = p;\n    b = rotate(b, M_PI, vec3(0,5,0));\n    \n    result = sdBoze(b - vec3(0, 0.0, 0), vec3(1, 1, 1), 1.);\n    \n    // Cucumber\n    vec3 c = p;\n    c.x += 0.5;\n    c.z -= 0.25;\n    \n    result = opU(result, sdCucumber(c));\n    \n    // Eggplant\n    vec3 e = p;\n    e.x += 1.0;\n    e.z -= 0.25;\n    \n    result = opU(result, sdEggplant(e));\n    \n    // background\n    //vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    result = opU(result, SURF_PLANETEX(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), p*0.5));\n    \n    //result = opU(result, bg1);\n    \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0,0.005,0.01);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\nvoid fireworkLight(out vec3 lightPos, out vec3 lightColor)\n{\n    float t = iTime * 0.5;\n    float index = floor(t);\n    float n = hash11(index);\n\tfloat d = 1. - fract(t);\n    lightPos = vec3(0.50, 0.3, -0.5) + hash31(index)*0.25 * d;\n\n    vec3 c = sinebow(n) * d;\n    lightColor = vec3(0.3, 0.6, 0.9) * 2.0 + c * 3.;\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        vec3 lightPos;\n\t\tvec3 lightColor;\n        fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    //float t = iTime * M_PI2 * -0.1;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 2.) * 0.25 + 0.5;\n    float y = 0.5;\n    //float r = 2.0 + sin(t * 0.5);\n    float r = 3.0;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float phi   = 0.;\n    float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0.06, 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1194, 1689, 1726, 1791, 2009], [2010, 2010, 2052, 2052, 2193], [2669, 2669, 2692, 2692, 2765], [3266, 3342, 3364, 3364, 3695], [3698, 3886, 3909, 3909, 3994], [3996, 4015, 4037, 4037, 4154], [4156, 4175, 4198, 4198, 4301], [4303, 4323, 4344, 4344, 4478], [4480, 4499, 4521, 4521, 4654], [4656, 4676, 4698, 4698, 4823], [4825, 4825, 4846, 4846, 4916], [4918, 4918, 4941, 4941, 5020], [5023, 5023, 5045, 5045, 5462], [5573, 5573, 5594, 5594, 5735], [5737, 5737, 5767, 5767, 5897], [5899, 5899, 5960, 5960, 6098], [6100, 6100, 6126, 6126, 6435], [6437, 6497, 6523, 6523, 7389], [7391, 7491, 7527, 7527, 7555], [7557, 7557, 7603, 7603, 7659], [7661, 7661, 7692, 7692, 7783], [7785, 7785, 7835, 7835, 7953], [7955, 7955, 8016, 8016, 8147], [8149, 8149, 8186, 8186, 8275], [8277, 8277, 8347, 8347, 8481], [8483, 8483, 8547, 8547, 8664], [8666, 8666, 8699, 8725, 8756], [8758, 8758, 8783, 8783, 8802], [8803, 8803, 8828, 8828, 8847], [8848, 8848, 8884, 8884, 8912], [8914, 8914, 8973, 8973, 9286], [9288, 9288, 9321, 9321, 9386], [9388, 9412, 9464, 9464, 9583], [9585, 9695, 9727, 9727, 9821], [9823, 9823, 9857, 9857, 10008], [10010, 10010, 10044, 10044, 10192], [10194, 10194, 10228, 10228, 10363], [10365, 10365, 10393, 10393, 10478], [10479, 10537, 10608, 10608, 10936], [10938, 10938, 11020, 11020, 11388], [11390, 11475, 11519, 11519, 11743], [11745, 11802, 11839, 11880, 11963], [11965, 11965, 12004, 12176, 12285], [12287, 12287, 12336, 12336, 12895], [12897, 12897, 12936, 12982, 13067], [13069, 13069, 13110, 13220, 13334], [13349, 13400, 13437, 13437, 13459], [13461, 13461, 13504, 13504, 13526], [13528, 13528, 13572, 13572, 13593], [13595, 13595, 13647, 13647, 13746], [13749, 13749, 13794, 13794, 14223], [14225, 14225, 14246, 14246, 14310], [14312, 14312, 14352, 14352, 14477], [14480, 14480, 14515, 14515, 14663], [14665, 14665, 14699, 14699, 14875], [14877, 14877, 14912, 14912, 14947], [14949, 14949, 14986, 14986, 15021], [15023, 15194, 15279, 15279, 15356], [15358, 15401, 15476, 15476, 15895], [15897, 16475, 16559, 16559, 16902], [16904, 16910, 16962, 16962, 17118], [17120, 17120, 17180, 17180, 17221], [17223, 17438, 17469, 17469, 17518], [17520, 17520, 17547, 17547, 17585], [17587, 17587, 17616, 17616, 17654], [17656, 17656, 17683, 17683, 17732], [17735, 17964, 17985, 17985, 18124], [18150, 18150, 18182, 18182, 18295], [18297, 18297, 18329, 18329, 18469], [18471, 18471, 18504, 18504, 18736], [18738, 18738, 18761, 18761, 19340], [19342, 19342, 19367, 19367, 19528], [19530, 19530, 19573, 19573, 20595], [20597, 20597, 20663, 20663, 20785], [20787, 20787, 20832, 20832, 21003], [21005, 21005, 21073, 21073, 21291], [21293, 21511, 21539, 21539, 22579], [22581, 22581, 22609, 22609, 23627], [23629, 23629, 23650, 23650, 24297], [24817, 24817, 24866, 24866, 25164], [25431, 25499, 25527, 25527, 25654], [25656, 25746, 25809, 25809, 26015], [26017, 26083, 26147, 26317, 26948], [26950, 26950, 26987, 26987, 27077], [27079, 27079, 27105, 27105, 28943], [28948, 29119, 29140, 29140, 29188], [29190, 29190, 29251, 29336, 29535], [29537, 29537, 29610, 29702, 29902], [29904, 29904, 29946, 30026, 30080], [30082, 30082, 30131, 30131, 30179], [30181, 30181, 30254, 30311, 30526], [30528, 30528, 30548, 30548, 30573], [30576, 30760, 30810, 30894, 31252], [31254, 31254, 31309, 31366, 31626], [31628, 31628, 31724, 31724, 33119], [33121, 33323, 33356, 33412, 33598], [33600, 33600, 33639, 33639, 33682], [33684, 33700, 33773, 33773, 33857], [33859, 33985, 34055, 34055, 34338], [34340, 34340, 34440, 34440, 35233], [35235, 35235, 35260, 35260, 35729], [35796, 35796, 35822, 35822, 36186], [36188, 36188, 36237, 36237, 37702], [37704, 37704, 37764, 37764, 38022], [38024, 38024, 38103, 38103, 40512], [40514, 40514, 40554, 40554, 42688], [42690, 42690, 42729, 42771, 43267], [43269, 43269, 43311, 43311, 43489], [43492, 43492, 43549, 43549, 45216]]}
{"id": "3tsfWB", "name": "open_your_eyes", "author": "caogtaa", "description": "Open your eyes", "tags": ["eye"], "likes": 1, "viewed": 92, "published": "Public", "date": "1597635022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 08/23, simplify code according to FabriceNeyret2's advise.\n// still in progress ..\n\n#define PI 3.141592653589793\n\nfloat Circle(vec2 uv, vec2 origin, float r2, float blur) {\n    vec2 len = uv - origin;\n    float d2 = dot(len, len);\n    return smoothstep(r2 + blur, r2 - blur, d2);\n}\n\n/*float Band(float v, float start, float end, float blur) {\n    float up = smoothstep(start - blur, start + blur, v);\n    float down = smoothstep(end + blur, end - blur, v);\n    return up * down;\n}*/\n\nfloat SymmetricBand(float v, float top, float blur) {\n    return smoothstep(top + blur, top - blur, abs(v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    // uv = uv * 2.0 - 1.0;\n    // uv.x *= iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    float blur = 2. / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 2.5*PI);\n    \n    float T1 = clamp(t, 0., PI);\n    float T2 = clamp(t, PI, 2.*PI);\n    float T3 = clamp(t, 2.*PI, 2.5*PI);\n\n    // part1, open\n    float part1 = sin(T1 * 0.5);\n\n    // part2，breath\n    float part2 = -sin(T2 * 2.0) * 0.05;\n\n    // part3，move forward\n    float part3 = sin(T3);\n    float scale = 1.0 + sin(T3) * 6.;\n\n    // float amp = abs(sin(u_time * 0.500));\n    float amp = part1 + part2 + part3;\n    amp *= scale;\n\n    float top = sin(uv.x / scale + PI / 2.0) * 0.5 * amp;\n    // float mask = Band(uv.y, -top, top, 0.01);\n    float mask = SymmetricBand(uv.y, top, blur);\n    \n    mask -= Circle(uv, vec2(0.), 0.25 * scale * scale, blur);\n    col.rgb = vec3(mask);\n\n    fragColor = vec4(col, 1.0 - mask);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 175, 175, 284], [286, 487, 540, 540, 597], [599, 599, 656, 823, 1706]]}
{"id": "3tSfzw", "name": "Bar Circular Equalizer", "author": "Gerard97", "description": "Custom Equalizer", "tags": ["music", "equalizer", "sfx"], "likes": 9, "viewed": 440, "published": "Public API", "date": "1598555401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nfloat rewrap(float r, float rep) {\n    \n    if (r < 0.) {\n        r = -r;\n    }\n    \n    r = mod(r*rep, PI);\n                  \n    return r/(PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = gl_FragCoord.xy / iResolution.xy;\n    \n    const int size = 24;\n                \n    float ar = iResolution.x / iResolution.y;\n    \n    px.y /= ar;\n    \n    vec2 pos = px-vec2(0.5, 0.5/ar);\n    \n    float len = length(pos);\n    \n\tvec3 color = vec3(0,0,0);\n    \n    float rep = 1.;\n    \n    float delta = rewrap(atan(pos.x, pos.y), rep);\n        \n    float div = 100./float(size);\n    \n    float modifier = sin(iTime*0.1);\n    \n    float index = float(int(mod(iTime*0.+delta+modifier, 1.) * 100. / div));\n    \n\tfloat f = texelFetch(iChannel0, ivec2(index/float(size)*512.,0), 0).x;\n    \n    float base = texelFetch(iChannel0, ivec2(0.*512.,0), 0).x;\n    \n    float cpi = smoothstep((0.1 + base*0.05), 0.15 + f * 0.01, len);\n       \n\tif (len < 0.15 + f * 0.1 && len > (0.1 + base*0.05) && mod(delta + modifier, 1./float(size)) < 0.035 && (delta) > 0.009)\n\t\tcolor = vec3(1.-delta, delta*0.3, delta);\n    \n    color *= cpi;\n    \n    if (len < 0.1 + base * 0.05 && len > 0.09 + base * 0.05)\n      color = vec3(1);\n    \n    float eq = texelFetch(iChannel0, ivec2(px.x*512.,1), 0).x;\n        \n    if (abs(px.y*ar-0.54+eq*0.1) < 0.008 && \n        px.x > 0.5-(0.1+base * 0.05-0.01) &&\n        px.x < 0.5+(0.1+base * 0.05-0.01)) {\n        color = vec3(eq,1.-eq,eq*eq);\n    }\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [{"id": "ltj3Dy", "previewfilepath": "https://soundcloud.com/nocopyrightsounds/jo-cohen-sex-whales-we-are-ncs-rellease", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/nocopyrightsounds/jo-cohen-sex-whales-we-are-ncs-rellease", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSfzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 171], [173, 173, 230, 230, 1545]]}
{"id": "3tXBRl", "name": "Swimming pool water", "author": "akanarika", "description": "that's so fake", "tags": ["voronoi"], "likes": 2, "viewed": 87, "published": "Public", "date": "1597386209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(452.6, 725.34, 921.2));\n    a += dot(a, a + 16.2);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    float m = 0.;\n    float t = iTime + 100.;\n    \n    float minDist = 200.;\n    \n    vec3 waterCol = vec3(0.1, 0.5, 0.7);\n    \n    for (float i = 0.; i < 50.; i++) {\n        vec2 n = N22(vec2(i));\n        vec2 p = rot(iTime * sqrt(.1 * (length(uv + n))) * 0.0008) \n            * sin(n * t * .3) \n            * vec2(iResolution.x / iResolution.y, 1.);\n        \n        float d = length(uv - p) * .5;\n        m += d * length(n);\n        \n        minDist = min(minDist, d);\n    }\n    \n\n    vec3 col = vec3(pow(minDist, 1.8)) * waterCol * 6. + waterCol * (.8 + 0.05 * length(N22(uv + iTime)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 149], [151, 151, 170, 170, 222], [224, 224, 281, 281, 980]]}
{"id": "3tXBRS", "name": "P.Gerdes & Tchokwe sand drawing2", "author": "FabriceNeyret2", "description": "colored variant of [url]https://shadertoy.com/view/wtsfWM[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets", "ethnomathematics"], "likes": 8, "viewed": 220, "published": "Public API", "date": "1596949670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// colored variant of https://shadertoy.com/view/wtsfWM\n\n#define S(v) smoothstep( 9./R.y , 0. , v )          // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                        // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                        // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;       // quad center to edge domain\n    \n    O -= .3* S( length(F) - .1 );                   // dots\n\n    float r = fract(4e4*sin(I.y + 10.*I.x +99.));   // rand( edge id )\n    r < .5\n      ?  f = S( abs( F = abs(F) - .35 ) -.01 ),     //  X at edge\n         O -= f.x + f.y,                            //    line\n         f = S(F), O.gb -= .3 - .3* abs(f.x-f.y)    //    area\n      :(                                            // )( at edge\n         O -= S( abs( r = length(F) - .35 ) -.01 ), //    line\n         O.gb -= .3*S(r) );                         //    area\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 121, 159, 159, 1010]]}
{"id": "3tXBWj", "name": "Perlin Hills", "author": "BlockMaster", "description": "A simple 2D landscape created using Perlin noise.", "tags": ["perlin", "parallax", "landscape", "tree", "mountain", "hill"], "likes": 12, "viewed": 173, "published": "Public", "date": "1597688586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// A simple 2D landscape created using Perlin noise.\n/// Plus some strange-looking trees. :)\n\n//Set the Tree Colours\nvec3 branchColour;\nvec3 leafColour;\n\n//USEFUL FUNCTIONS//\n//RNG Returning a Float (0. to 1.)\nfloat randomValue(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//RNG Returning a Vec2 (0. to 1.)\nvec2 randomVector(vec2 uv)\n{\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n//RNG Returning a Diagonal Vec2 (4 Directions)\nvec2 randomLimitedVector(vec2 uv)\n{\n    vec2 randomVector = randomVector(uv);\n    return vec2(round(randomVector.x) * 2. - 1.,\n                round(randomVector.y) * 2. - 1.);\n}\n\n//Map\nfloat map(float value, float currentMin, float currentMax, float targetMin, float targetMax)\n{\n    return targetMin + (targetMax - targetMin) * ((value - currentMin) / (currentMax - currentMin));\n}\n\n//Smootherstep\nfloat smootherstep(float value)\n{\n    return 6.0 * pow(value, 5.) - 15. * pow(value, 4.) + 10. * pow(value, 3.);\n}\n\nvec2 lengthdir(vec2 basePoint, float direction, float lngth)\n{\n    return basePoint + vec2(cos(direction) * lngth, sin(direction) * lngth);\n}\n\n//RGB to HSV Converter (Not My Code)\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//DRAW FUNCTIONS//\n//Draw a Line\nvoid drawLine(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, inout float value)\n{\n    //Get Sides of a Triangle\n    float a = distance(uv, point2);\n    float b = distance(uv, point1);\n    float c = distance(point1, point2);\n    \n    //Calculate Point's Distance from the Line\n    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));\n    \n\t//Get Pixel's Value\n    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);\n    pixelValue *= smoothstep(thickness + blur, thickness, a + b - c);\n    value = mix(value, 1., pixelValue);\n}\n\n//Draw a Disk\nvoid drawDisk(vec2 uv, vec2 position, float radius, float blur, vec3 colour, inout vec3 value)\n{\n    float pixelValue = smoothstep(radius + blur, radius, distance(position, uv));\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw a Disk with Return Value\nfloat diskValue(vec2 uv, vec2 position, float radius, float blur)\n{\n    return smoothstep(radius + blur, radius, distance(position, uv));\n}\n\n//Draw a Branch (Less Computationally Expensive drawLine)\nvoid drawBranch(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, vec3 colour, inout vec3 value)\n{\n    //Get Sides of a Triangle\n    float a = distance(uv, point2);\n    float b = distance(uv, point1);\n    float c = distance(point1, point2);\n    \n    //Calculate Point's Distance from the Line\n    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));\n    \n\t//Get Pixel's Value\n    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);\n    pixelValue *= float(a + b < c + thickness + blur);\n    value = mix(value, colour, pixelValue);\n}\n\n//Draw a Tree\nvoid drawTree(vec2 uv, vec2 basePoint, int branches, int iterations, float size, vec3 branchColour, vec3 leafColour, inout vec3 value)\n{\n    //Draw the Trunk\n    drawBranch(uv, basePoint, vec2(basePoint.x, basePoint.y + size), 0.003, 0.001, branchColour, value);\n    \n    //Draw the Branches\n    for (int i = 0; i < branches; i ++)\n    {\n        //Set Branch Properties\n        float randomFactor = map(randomValue(vec2(basePoint.y) * float(i)), 0., 1., 0.3, 1.);\n        float branchLength = size;\n        float branchAngle = 50.;\n        float branchThickness = 0.0015;\n        \n        //Set Previous && Current Branch Position\n        vec2 currentBranch;\n        vec2 previousBranch = lengthdir(basePoint, radians(90.), \n                                        distance(basePoint, vec2(basePoint.x, basePoint.y + size)) * randomFactor);\n        for (int j = 0; j < iterations; j ++)\n        {\n            //Change the Branch Properties\n            randomFactor = map(randomValue(vec2(previousBranch.y)), 0., 1., 0.5, 1.);\n            branchLength *= 0.8 * randomFactor;\n            branchAngle -= 15. * randomFactor;\n            branchThickness -= 0.00025;\n            \n            float angleSign = sign(float(mod(float(j) + float(i), 2.) == 0.) - 0.5);\n            float currentAngle = radians(90. + branchAngle * angleSign);\n            float currentLength = branchLength * randomFactor;\n            \n            //Set Current Branch Position for Draw\n\t\t\tcurrentBranch = lengthdir(previousBranch, currentAngle, branchLength);\n            drawBranch(uv, previousBranch, currentBranch, branchThickness, 0.001, branchColour, value);\n            drawDisk(uv, currentBranch, 1. / (currentBranch.y - basePoint.y) * size * 0.03, 0.0001, leafColour, value);\n            //drawDisk(uv, currentBranch, (currentBranch.y - basePoint.y) * 0.15, 0.0001, leafColour, value);\n            \n            //Set Current Branch Position for the Next Iteration\n            currentBranch = lengthdir(previousBranch, currentAngle, currentLength);\n            previousBranch = currentBranch;\n        }\n    }\n}\n\n//Perlin Noise\nfloat perlinNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float amplitude = 1.;\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    \n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get Pixel's Position Within the Cell && Cell's Position Within the Grid\n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get Gradient Vectors of the Cell's Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y));\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.));\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.));\n\n        //Calculate Distance Vectors from the Cell's Points to the Pixel\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n\n        //Calculate Dot Product of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\n        //Apply Smootherstep Function on the Pixel Position for Interpolation\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Dot Products\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        pixelValue += (interpolation3 * 0.5 + 0.5) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Draw a Hill\nvoid drawHill(vec2 uv, vec3 colour, float blur, float speed, float flatness, float xOffset, float yOffset, bool drawTrees, inout vec3 value, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float noiseValue = perlinNoise(vec2(uv.x + xOffset + iTime * speed, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n    float pixelValue = smoothstep(noiseValue, noiseValue - blur, uv.y - yOffset);\n    value = mix(value, colour, pixelValue);\n    \n    if (drawTrees && uv.y < 0.8)\n    {\n        float treeX = floor(uv.x + xOffset + iTime * speed);\n        treeX += map(randomValue(vec2(treeX)), 0., 1., 0.12, 0.88);\n        float treeY = perlinNoise(vec2(treeX, 0.5), frequency, octaves, lacunarity, persistence) * flatness;\n        drawTree(uv, vec2(treeX - xOffset - iTime * speed, treeY + yOffset - randomValue(vec2(treeX)) * 0.02), 4, 4, 0.17, branchColour, leafColour, value);\n    }\n}\n\n//Draw Fog\nvoid drawFog(vec2 uv, vec2 yBorders, float speed, float density, float contrast, float frequency, int octaves, float lacunarity, float persistence, inout vec3 value)\n{\n    //Get the Noise Value\n    float noiseValue = perlinNoise(vec2(uv.x * 0.8 + iTime * speed, uv.y), frequency, octaves, lacunarity, persistence);\n    \n    //Create Gradient Masks\n    float densityGradient = smoothstep(yBorders.y + 0.6, yBorders.y, uv.y);\n    float whiteGradient = smoothstep(yBorders.x + 0.3, yBorders.x - 0.2, uv.y) * 0.3 * density;\n    \n    //Adjust the Value\n    noiseValue = smoothstep(0.2, 0.7, noiseValue) * densityGradient * 0.75 * density + whiteGradient;\n    noiseValue = clamp(map(noiseValue, 0., 1., 0. - contrast, 1.1) * densityGradient, 0., 1.);\n    value = mix(value, vec3(noiseValue + 0.2), noiseValue);\n    //value = vec3(noiseValue);\n}\n\n\n//MAIN//\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the fragCoord\n    vec2 uv = fragCoord / iResolution.y;\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    //Set the Colours\n    vec3 skyColour1 = hsv2rgb(vec3(216. / 360., 17. / 100., 100. / 100.));\n    vec3 skyColour2 = hsv2rgb(vec3(37. / 360., 34. / 100., 92. / 100.));\n    \n    vec3 hillColour1 = hsv2rgb(vec3(200. / 360., 16. / 100., 59. / 100.));\n    vec3 hillColour2 = hsv2rgb(vec3(15. / 360., 6. / 100., 30. / 100.));\n    vec3 hillColour3 = hsv2rgb(vec3(194. / 360., 35. / 100., 28. / 100.));\n    \n    branchColour = hsv2rgb(vec3(30. / 360., 35. / 100., 40. / 100.));\n    leafColour = hsv2rgb(vec3(144. / 360., 50. / 100., 45. / 100.));\n    \n    vec3 sunColour = vec3(45. / 360., 0. / 100., 100. / 100.);\t//in HSV model\n    vec2 sunPosition = vec2(1.3, 0.7);\n    \n    //Set the Background Colour\n    vec3 colourValue = mix(skyColour2, skyColour1, uv.y);\n    \n    //Draw the Sun\n    sunColour.y = diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.2, 0.8) * 0.4;\n    colourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, vec2(sunPosition.x, sunPosition.y - 0.15), 0.1, 0.8) * 0.3;\n    drawDisk(uv, sunPosition, 0.02, 0.005, vec3(1., 1., 1.), colourValue);\n    \n    //Draw the Hills && Fog\n    drawHill(uv, hillColour1, 0.002, 0.1, 1., 6.8, 0.15, false, colourValue, 3., 6, 2., 0.5);\n    drawFog(uv, vec2(0.35, 0.5), 0.12, 1., 0., 1.3, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour2, 0.002, 0.2, 0.8, 2.0, 0.05, false, colourValue, 2., 5, 2., 0.5);\n    drawFog(uv, vec2(0.25, 0.3), 0.25, 0.6, 0., 1.4, 6, 2., 0.5, colourValue);\n    drawHill(uv, hillColour3, 0.002, 0.5, 0.6, 4.0, - 0.05, true, colourValue, 0.9, 5, 1.9, 0.45);\n    drawFog(uv, vec2(- 0.3, 0.2), 0.6, 0.4, 0., 1., 5, 2., 0.5, colourValue);\n    \n    //Find Out Wheter the Hills Are Overlaping the Sun\n    float hillNoiseValue = perlinNoise(vec2(sunPosition.x + 6.8 + iTime * 0.1, 0.5), 3., 6, 2., 0.5);\n    float sunIntensity = smoothstep(hillNoiseValue - 0.03, hillNoiseValue + 0.03, sunPosition.y - 0.15);\n    \n    //Draw the Sun Glow\n    sunColour.y = diskValue(uv, sunPosition, 0.2, 0.8) * 0.3 * sunIntensity;\n\tcolourValue *= hsv2rgb(sunColour);\n    colourValue += diskValue(uv, sunPosition, 0.3, 0.8) * 0.1 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.05, 0.5) * 0.15 * sunIntensity;\n    colourValue += diskValue(uv, sunPosition, 0.01, 0.3) * 0.2 * sunIntensity;\n    colourValue += hsv2rgb(sunColour) * 0.1 * sunIntensity;\n    float highlight = smoothstep(1., 0.7, (colourValue.r + colourValue.g + colourValue.b) / 3.);\n    \n    //Make the Scene Darker\n    colourValue -= ((1. - sunIntensity) * 0.1) * highlight;\n    colourValue -= (1. - diskValue(uv, vec2(0.89, 0.5), 0.4, 1.7)) * 0.3;\n    \n    //Set the fragColor\n    fragColor = vec4(colourValue, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 211, 239, 239, 312], [314, 348, 376, 376, 511], [513, 560, 595, 595, 738], [740, 746, 840, 840, 943], [945, 960, 993, 993, 1074], [1076, 1076, 1138, 1138, 1217], [1219, 1256, 1278, 1278, 1447], [1450, 1483, 1581, 1611, 2108], [2110, 2124, 2220, 2220, 2348], [2350, 2382, 2449, 2449, 2521], [2523, 2581, 2693, 2723, 3209], [3211, 3225, 3361, 3382, 5315], [5317, 5332, 5427, 5427, 7639], [7641, 7655, 7864, 7864, 8572], [8574, 8585, 8752, 8778, 9423], [9426, 9435, 9490, 9516, 12295]]}
{"id": "3tXBWS", "name": "The City At night", "author": "gilesruscoe", "description": "Late night VJ session", "tags": ["music", "lines", "audio", "glow", "glow", "dots"], "likes": 13, "viewed": 360, "published": "Public API", "date": "1597576471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 6.0 / iResolution.y\n\nfloat hash21(vec2 v) {\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\n{\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    uv = uv * 2.0 - 1.0;\n    uv *= 1.0 + sin(iTime * 0.5) * 0.35;\n    \n    uv.y *= ar;\n\n    \n    vec3 comp = vec3(0.0);\n    float lines = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n       \tfloat ifloat = float(i);\n        vec2 seed = vec2(ifloat * 1.0, ifloat * 3.0);\n        vec2 pos = (vec2((hash21(seed) * 2.0 - 1.0) * 2.0,\n                         (hash21(seed*2.0) * 2.0 - 1.0)) * 0.5);\n        \n        float soundsample = texture( iChannel0, vec2(floor(abs(pos.x*0.5) * 32.0) / 32.0,0.0) ).x * 1.10;\n        if(soundsample < 0.55)\n            continue;\n\n        float burst = pow(soundsample, 5.0) * 20.0;\n        \n        pos.x += sin(iTime + ifloat) * 0.25;\n        pos.y += cos(iTime * 2.0 + ifloat) * 0.15;\n        float value = length(uv + pos) * 4.25;\n        \n        // circles\n        vec3 col = normalize(vec3(sin(pos.x*5.0) + 0.25, 0.1, sin(pos.y*10.0))) * 3.0;\n    \tcomp += clamp(col * smoothstep(value - AA, value + AA, 0.01 + burst * 0.02) * 0.155, vec3(0.0), vec3(1.0));\n        comp += clamp(col * smoothstep(value - 0.5, value + 0.5, 0.01 + burst * 0.075) * 0.01, vec3(0.0), vec3(1.0)) * 2.0;\n        \n        // Lines\n        float L = 0.0;\n        for(int j = 0; j < int(pow(soundsample, 3.0) * 15.8); j++)\n        {\n            float jfloat = float(j);\n            vec2 Lseed = vec2(jfloat, jfloat);\n            vec2 Lpos = (vec2((hash21(Lseed) * 2.0 - 1.0) * 2.0,\n                         (hash21(Lseed*2.0) * 2.0 - 1.0)) * 0.5);\n            Lpos.x += sin(iTime + jfloat) * 0.25;\n        \tLpos.y += cos(iTime * 2.0 + jfloat) * 0.15;\n            L = max(L, line(uv, -pos, -Lpos, 0.001));\n        }\n        lines += L;\n\n    }\n    comp *= 0.25;\n    comp += lines * 0.01;\n    vec3 bg = vec3(0.35*(uv.y * 0.5 + 0.5), 0.0, 0.15);\n    fragColor = vec4(bg + vec3(comp)*12.0, 1.0);\n}", "image_inputs": [{"id": "4tB3DK", "previewfilepath": "https://soundcloud.com/clozee/evasion", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/clozee/evasion", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 126], [128, 128, 178, 178, 341], [344, 344, 401, 401, 2291]]}
{"id": "3tXBzS", "name": "Color waves", "author": "akanarika", "description": "Waves in different colors", "tags": ["2d"], "likes": 4, "viewed": 72, "published": "Public", "date": "1596959302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 TOKI = vec3(238, 169, 169) / 255.;\n    vec3 NANOHANA = vec3(247, 217, 76) / 255.;\n    vec3 SORA = vec3(88, 178, 220) / 255.;\n    vec3 ROKUSYOH = vec3(36, 147, 110) / 255.;\n    vec3 ENTAN = vec3(215, 84, 85) / 255.;\n    vec3 USUKI = vec3(250, 214, 137) / 255.;\n    vec3 BENIMIDORI = vec3(123, 144, 210) / 255.;\n    vec3 AKE = vec3(203, 84, 58) / 255.;\n    vec3 SHIRONEZUMI = vec3(189, 192, 186) / 255.;\n    vec3 TONOCHA2 = vec3(79, 114, 108) / 225.;\n    \n    \n    if (uv.y - .8 > .1 * sin(uv.x + iTime)) {\n        col = TOKI;\n    } else if (uv.y - .6 > .1 * cos(uv.x + iTime * .4)) {\n        col = NANOHANA;\n    } else if (uv.y - .4 > .1 * sin(uv.x + iTime * .6)) {\n        col = SORA;\n    } else if (uv.y - .2 > .1 * cos(uv.x + iTime * .9)) {\n        col = ROKUSYOH;\n    } else if (uv.y - 0. > .1 * sin(uv.x + iTime * .3)) {\n        col = USUKI;\n    } else if (uv.y + .2 > .1 * cos(uv.x + iTime * .5)) {\n        col = ENTAN;\n    } else if (uv.y + .4 > .1 * sin(uv.x + iTime * .7)) {\n        col = BENIMIDORI;\n    } else if (uv.y + .6 > .1 * cos(uv.x + iTime * .6)) {\n        col = AKE;\n    } else if (uv.y + .8 > .1 * sin(uv.x + iTime * .8)) {\n        col = SHIRONEZUMI;\n    } else {\n        col = TONOCHA2;\n    }\n    \n    if (uv.x - 1.6 > .1 * sin(uv.y + iTime)) {\n        col *= clamp(vec3(.4, .2, .9), vec3(0), vec3(1));\n    } else if (uv.x - 1.4 > .1 * cos(uv.y + iTime * .3)) {\n        col += clamp(vec3(.1, .8, .3), vec3(0), vec3(1));\n    }  else if (uv.x - 1.2 > .1 * sin(uv.y + iTime * .7)) {\n        col -= clamp(vec3(.2, .7, .1), vec3(0), vec3(1));\n    }  else if (uv.x - 1. > .1 * cos(uv.y + iTime * .4)) {\n        col *= clamp(vec3(.2, .7, .1), vec3(0), vec3(1));\n    }  else if (uv.x - .8 > .1 * sin(uv.y + iTime * .2)) {\n        col *= clamp(vec3(.9, .2, .1), vec3(0), vec3(1));\n    }  else if (uv.x - .6 > .1 * cos(uv.y + iTime * .6)) {\n        col += clamp(vec3(.1, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x - .4 > .1 * sin(uv.y + iTime * .4)) {\n        col -= clamp(vec3(.1, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x - .2 > .1 * cos(uv.y + iTime * .5)) {\n        col *= clamp(vec3(.1, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x - 0. > .1 * sin(uv.y + iTime * .9)) {\n        col *= clamp(vec3(.8, .4, .9), vec3(0), vec3(1));\n    }  else if (uv.x + .2 > .1 * cos(uv.y + iTime * .4)) {\n        col = col;\n    }  else if (uv.x + .4 > .1 * sin(uv.y + iTime * .6)) {\n        col *= clamp(vec3(.2, .4, .9), vec3(0), vec3(1));\n    }  else if (uv.x + .6 > .1 * cos(uv.y + iTime * .8)) {\n        col -= clamp(vec3(.2, .4, .9), vec3(0), vec3(1));\n    }  else if (uv.x + .8 > .1 * sin(uv.y + iTime * .8)) {\n        col += clamp(vec3(.4, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x + 1. > .1 * cos(uv.y + iTime * .3)) {\n        col *= clamp(vec3(.4, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x + 1.2 > .1 * sin(uv.y + iTime * .6)) {\n        col -= clamp(vec3(.5, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x + 1.4 > .1 * cos(uv.y + iTime * .2)) {\n        col += clamp(vec3(.5, .1, .2), vec3(0), vec3(1));\n    }  else if (uv.x + 1.6 > .1 * sin(uv.y + iTime * .7)) {\n        col *= clamp(vec3(.5, .1, .2), vec3(0), vec3(1));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 3364]]}
{"id": "3tXfRX", "name": "11. Drive Home 2 - Street Lights", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=tdwXMtnuuXg\nMy Onet Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 2, "viewed": 166, "published": "Public API", "date": "1597254144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke( float d , float lightDiameter , float blur ) {\n\t\n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n}\n\nfloat Noise(float t) {\n    float n;\n\n    n = sin( t + 2379. ) ;\n    \n    return n;\n}\n\n// Street Light\nfloat StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n    \tfloat d = GetDistance( ray , targetPos );\n    \t\n        //lightDiameter *= length( targetPos );\n\n        float expandLight = lightDiameter * length( targetPos );\n        c += Boke( d , expandLight , bokeBlur ) * ti * ti * ti;\n    }\n    \n    return c;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n    \n\n\tvec3 camPos = vec3( 0 , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0 , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    float lightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tfloat c = StreetLight( ray , lightDiameter , bokeBlur, iTime );\n    \n    \n    \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 129, 196, 196, 666], [669, 673, 723, 868, 949], [952, 956, 1003, 1003, 1088], [1091, 1099, 1157, 1157, 1328], [1330, 1330, 1352, 1352, 1414], [1416, 1432, 1513, 1513, 2144], [2146, 2154, 2211, 2211, 2717]]}
{"id": "3tXfW2", "name": "Repared Menger z", "author": "illus0r", "description": "This article helped to overcome the annoying problem with glitchy surfaces. The problem was in `mod` operator, which made SDF discontinuous: http://connorahaskins.com/menger_sponge.html", "tags": ["raymarching"], "likes": 3, "viewed": 265, "published": "Public API", "date": "1597701361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURF_DIST .0001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\nfloat random (float x) {\n    return fract(12345.67 * sin(x * 654.24));\n}\n\n\n\nfloat GetDist(vec3 p) {\n    \n\n\n    vec3 ps = p;\n    ps.y += iTime * -.4;\n    float sInterval = .2;\n    ps.xz += vec2(.1, 0.) * Rot(99.123 * random(floor((ps.y) / sInterval)));\n    //ps.xz *= 1. + 0.5 * random(floor((ps.y) / sInterval));\n    ps = mod(ps + sInterval / 2., sInterval) - sInterval / 2.;\n    float spheres = length(ps)-0.003;\n\n    p.y += iTime * 1.;\n    \n    p.xz = abs(p.xz);\n    p.xz *= Rot(p.y / 3.);\n    //p.xz *= Rot(sin(iTime / 10.));\n    p.xz += 0.69 * sin(iTime * 0.4 / vec2(1.7, 1.1));\n\n    \n\n    //p.z = abs(p.z);\n    //p.z += 0.1 * sin(iTime / 1.4);\n    //p.z -= 0.1 * sin(iTime);\n\n    float box = sdBox(p, vec3(4.4));\n    float box2 = sdBox(p, vec3(0.1, 0.1, 200000.));\n        \n    \n    float hole = 9999999990.;\n\n    float holiness = 1.258;//2. + 2. * (0.5 + 0.5 * sin(p.y + iTime));\n    float iterations = 5.;\n    for (float axes = 0.; axes <= 2.; axes++) {\n        p = p.zxy;\n\t    vec3 pm = p;\n   \t\tfor (float i = 1.; i <= iterations; i++) {\n            pm *= i;\n            pm += 1.;\n        \tpm.xy = mod(pm.xy, 2.);\n            pm -= 1.;\n\t\t    hole = min(hole, sdBox(pm, vec3(1./holiness/i, 1./holiness/i, 9999999999.)) / i);\n\t    }\n    }\n    \n    //hole /= 2. * iterations;\n    //hole *= 3.9;\n    \n    return min(spheres, max(0., -hole));\n    //return max(box, hole);\n    //return hole;\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\n//float sdBox( in vec2 p, in vec2 b )\n//{\n//    vec2 d = abs(p)-b;\n//    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //vec2 size = vec2(0.1, 0.1);\n    //uv = abs(uv);\n    //uv -= size;\n    //uv *= 10.;\n    \n    //uv = mod(uv + 0.2, 0.4);\n    //uv -= 0.2;\n    //uv *= Rot(3.1415 / 4.);\n    \n    //float col = 5. * sdBox(uv, size);\n    //col = fract(col);\n    \n    //fragColor = vec4(vec3(col), 1.0);\n\n    \n    ///////////////////////////////////////////////////\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    //vec3 ro = vec3(-0.0, -2.0, -0.0);\n    vec3 ro = vec3(.0, .0, .0);\n    vec3 camDir = vec3(0.001, 1., 0);\n    \n    //camDir.yz *= Rot(-m.y*3.14+1.);\n    //camDir.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + camDir, 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif;\n\t    //col = pow(col, vec3(.4545));\t// gamma correction\n        //col = n / 2. + 0.5;\n        //col *= n.x;\n        col = vec3(1.5 / d);\n    }\n    \n    \n    fragColor = vec4(vec3(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 340, 359, 359, 421], [423, 423, 445, 445, 539], [541, 541, 570, 570, 651], [655, 655, 679, 679, 727], [731, 731, 754, 754, 2050], [2057, 2057, 2091, 2091, 2302], [2304, 2304, 2328, 2328, 2518], [2520, 2520, 2570, 2570, 2761], [2765, 2894, 2951, 2951, 4080]]}
{"id": "ltcBz4", "name": "Cool Pattern Thingy", "author": "croebot", "description": "Cool Pattern Thingy", "tags": ["patterns"], "likes": 2, "viewed": 170, "published": "Public API", "date": "1596834757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"patterns-001\" by zwwgggbest. https://shadertoy.com/view/lltczB\n// 2018-10-05 15:03:56\n\n#define PI 3.141592653\n\nvec2 rotate2D(vec2 _uv, float _angle) \n{\n\tmat2 rotate = mat2(cos(_angle), -sin(_angle),\n        \t\t   sin(_angle), cos(_angle));\n    \n    _uv -= .5;\n    _uv = rotate * _uv;\n    _uv += .5;\n    \n    return _uv;\n}\n\nfloat box(vec2 _uv, vec2 _size, float _smoothEdge)\n{\t\n\t_size = vec2(.5) - _size * .5;\n    float aa = _smoothEdge * .5;\n    vec2 ret = smoothstep(_size, _size + vec2(aa), _uv);\n    ret *= smoothstep(_size, _size + vec2(aa), 1. - _uv);\n    return ret.x*ret.y;\n}\n\nfloat patterns1(vec2 _uv, vec2 _size, float _smoothEdge, float cnt, float t)\n{\n\t_uv *= cnt;\n    _uv = fract(_uv);\n    _uv = rotate2D(_uv, PI * t);\n   \n    return box(_uv, _size, _smoothEdge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float t = iTime; \n    float sz = iTime*.1;\n  \tcol += vec3(patterns1(uv, vec2(.7), .01, 5., cos(t) ) );\n  \tcol -= vec3(patterns1(uv, vec2(.7), .01, 10., 1. - floor(t)*.1 ));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 123, 163, 163, 332], [334, 334, 386, 386, 593], [595, 595, 673, 673, 788], [790, 790, 847, 897, 1308]]}
{"id": "tl2fR1", "name": "Mein march", "author": "akoskovacs", "description": "Ray marching", "tags": ["raymarch"], "likes": 0, "viewed": 65, "published": "Public", "date": "1598357279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MARCH_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .1\n\nfloat distance(vec3 p)\n{\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphereDist = length(p - sphere.xyz) - sphere.w; // len(p-sphere) - radius(sphere)\n    float planeDist = p.y;\n    \n    return min(sphereDist, planeDist);\n    \n}\n\nvec3 deriveNormal(vec3 p)\n{\n    float d = distance(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        distance(p - e.xyy),\n        distance(p - e.yxy),\n        distance(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 1);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*10.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = deriveNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    return dif;\n}\n\nfloat rayMarchDistance(vec3 rayOrig, vec3 rayDir)\n{\n\tfloat distOrig = 0.;\n    for (int i = 0; i < MARCH_STEPS; i++) {\n    \tvec3 p = rayOrig + rayDir * distOrig;\n        float sceneDist = distance(p);\n        distOrig += sceneDist;\n        if (distOrig > MAX_DIST || sceneDist < SURF_DIST) {\n            break;\n        }\n        \n    }\n    \n    return distOrig;\n}\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    vec3 col = vec3(0);\n        \n    vec3 camPos = vec3(0, 1, 0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n    float d = rayMarchDistance(camPos, rayDir);\n    vec3 p = camPos + rayDir * d;\n    float diffused = getLight(p);\n    \n    col = vec3(diffused);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 92, 92, 298], [300, 300, 327, 327, 524], [526, 526, 550, 550, 766], [768, 768, 819, 819, 1130], [1137, 1137, 1192, 1192, 1555]]}
{"id": "tl2fRm", "name": "Germany Flag 6031055321", "author": "enwee1998", "description": "Germany Flag\n2110479 Computer Graphics Exercise\n6031055321 Weerayut Thinchamlong", "tags": ["flag"], "likes": 7, "viewed": 127, "published": "Public", "date": "1598586319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n A very lazy and quick doodle of the Indian flag on this year's Indian Republic Day.\n Not the most efficient code, but I think it still looks cool. \n*/\n\n#define PI 3.1415926535\n\n#define ROT(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\n#define ORANGE vec3(255., 154., 48.) / 255.\n#define GREEN vec3(9., 137, 1.) / 255.\n#define NAVY_BLUE vec3(0., 0., 137.) / 255.\n#define BLACK vec3(0., 0., 0.) / 255.\n#define RED vec3(204., 43., 29.) / 255.\n#define YELLOW vec3(248., 207., 70.) / 255.\n\n#define RADIUS .7\n#define HALF_RADIUS RADIUS * .5\n\n// Hash by Dave_Hoskins\nfloat hash(vec2 p)\n{\n    uvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n    uint n = (q.x ^ q.y) * 1597334673U;\n    return float(n) / float(0xffffffffU);\n}\n\n// iq's 2d sdf for iscosceles triangles (https://www.shadertoy.com/view/MldcD7)\nfloat isoscelesTriangle(in vec2 q, in vec2 p)\n{\n    p.y -= .5;\n    p.x = abs(p.x);\n    \n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0., 1.);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0., 1.), 1.);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 st = fragCoord / iResolution.xy;\n    float w = sin((uv.x + uv.y - iTime * .75 + sin(1.5 * uv.x + 4.5 * uv.y) * PI * .3)\n                  * PI * .6); // fake waviness factor\n    \n    uv *= 1. + (.036 - .036 * w);\n    vec3 col = vec3(0.);\n    \n    // flag colors\n    col += RED;\n    col = mix(col, BLACK, smoothstep(.35, .36, uv.y));\n    col = mix(col, RED, smoothstep(.35, -.35, uv.y));\n    col = mix(col, YELLOW, smoothstep(-.35, -.36, uv.y));\n    col += w * .225;\n    \n    float v = 16. * st.x * (1. - st.x) * st.y * (1. - st.y); // vignette\n    col *= 1. - .6 * exp2(-1.75 * v);\n    col = clamp(col - hash(fragCoord) * .004, 0., 1.);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 561, 581, 581, 730], [732, 812, 859, 859, 1201], [1204, 1204, 1261, 1261, 2025]]}
{"id": "tl2fzD", "name": "Lucky buggy galaxy", "author": "mrange", "description": "License CC0: Lucky buggy galaxy\nWhen trying to create a galaxy for the: once upon a time... space I mistakenly put in s when I meant sqrt(0.5) and it turned out quite cool IMHO.\n So I thought I share my mistake\n", "tags": ["2d", "fbm"], "likes": 6, "viewed": 323, "published": "Public API", "date": "1598471006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Lucky buggy galaxy\n//  When trying to create a galaxy for the: once upon a time... space\n//\tI mistakenly put in s when I meant sqrt(0.5) and it turned out quite cool IMHO.\n//  So I thought I share my mistake\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise1(vec2 p) {\n  // Randomly coded \"noise\" function\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5));\n  float d = cos(p.y*sqrt(1.5));\n\n  return a*b*c*d;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  // Apply angular distort, there are probably better ways to do this\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*3.0 + a;\n  p = toRect(pp);\n  p *= z;\n  return noise1(p);\n}\n\nfloat height(vec2 p) {\n  // FBM with a twist (ie bug)\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  rot(p, 0.075*TIME);\n  for (int i = 0; i < 4; ++i) {\n    float g = a*galaxy(p, 0.15*float(i) + -TIME*( + 0.1*float(i)), f);\n    s += g;\n    a *= 0.5;\n    f *= s; // This is a bug that happens to look cool, intended to be sqrt(0.5) (boring), s much more fun\n    d += a;\n  }\n  \n  return 0.5 + 0.5*(s/d)*exp(-5.5*dot(p, p));\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  vec3 lp1 = vec3(-2.0, 0.5, 2.0);\n  vec3 ld1 = normalize(lp1 - vec3(p.x, 0.0, p.y));\n  vec3 lp2 = vec3(2.0, 0.5, 2.0);\n  vec3 ld2 = normalize(lp2 - vec3(p.x, 0.0, p.y));\n\n  float h = height(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n  col += 0.5*pow(diff1, 10.0);\n  col += 0.25*pow(diff2, 5.0);\n  col += vec3(1.0)*pow(sin(PI/2.0*th), 5.0);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fzD.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 345, 367, 367, 411], [413, 413, 434, 434, 475], [477, 477, 510, 510, 595], [597, 597, 619, 656, 786], [788, 788, 828, 898, 996], [998, 998, 1020, 1051, 1445], [1447, 1447, 1468, 1468, 1671], [1673, 1673, 1710, 1710, 1918], [1920, 1920, 1975, 1975, 2622]]}
{"id": "tl2fzw", "name": "Battle stage", "author": "gaz", "description": "ftactal", "tags": ["fractal"], "likes": 11, "viewed": 168, "published": "Public", "date": "1598607509", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(n) fract(sin(n*234.567+123.34))\n\nfloat Scale;\nfloat g=.0;\nfloat map(vec3 p){\n    float de=10.;\n    p.z-=iTime*1.5;\n    float seed=dot(floor((p.xz+4.)/8.),vec2(123.12,234.56));   \n    p.xz=mod(p.xz-4.,8.)-4.;\n    p=abs(p)-2.;\n    if(p.x<p.z)p.xz=p.zx;\n\tif(p.y<p.z)p.yz=p.zy;\n \tif(p.x<p.y)p.xy=p.yx;\n\tfloat scale=-5.+hash(seed)*.5;\n\tfloat mr2=.45+hash(seed+123.)*.05;\n\tfloat off=1.3+hash(seed+456.)*.1;\n\tfloat s=3.;\n\tvec3  p0 = p;\n\tfor (int i=0; i<9; i++){\n    \tp=1.-abs(p-1.);\n    \tfloat k=clamp(mr2*max(1.2/dot(p,p),1.),0.,1.);\n    \tp=p*scale*k+p0*off;\n        s=s*abs(scale)*k+off;\n        if(i==2){\n            float d=length(hash(seed+147.)<.5?p.xz:p.xy)/s-.001;\n            g += 1./max(1e-4,d*d*7e5); // Distance glow by balkhan\n        }\n\t}\n    Scale=log2(s);\n\treturn length(hash(seed+147.)>.5?p.xz:p.xy)/s-.001;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow(vec3 light, vec3 ld, float len){\n\tfloat depth = march(light,ld,0.0,len);\t\n\treturn step(len - depth, 0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(sin(iTime*.3+.3*sin(iTime*.2)),7,8);\n    vec3 ta = vec3(0,0,0);\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,normalize(vec3(0.3*sin(iTime*.1),1,0))));\n    vec3 rd = mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    vec3 bg = vec3(0.03,0.03,0.08);\n    vec3 col = bg;\n\tconst float maxd = 80.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=cos(vec3(1,3,6)+Scale*50.)*0.5+0.5;\n        col*=1.8;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.5, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.5,0.4,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 50.0);\n        col += vec3(0.7,0.3,0.1)*g*(1.5);\n        col = mix(bg,col,exp(-t*t*.002));\n        col = clamp(col,0.,1.);\n        \n    }\n    fragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 139, 139, 882], [884, 884, 910, 910, 1062], [1064, 1064, 1118, 1118, 1284], [1286, 1286, 1335, 1335, 1411], [1413, 1413, 1470, 1470, 2759]]}
{"id": "tlBfWz", "name": "simpleGlow", "author": "brunodev09", "description": "Just a simple glow", "tags": ["glow"], "likes": 2, "viewed": 183, "published": "Public API", "date": "1598647350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float generateCircle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    return smoothstep(r, r-blur, d);\n\t\n}\n\nvec2 repositionOriginToCenter(vec2 fragCoord) {\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv -= vec2(1, 0.5);\n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = repositionOriginToCenter(fragCoord);\n    \n    vec3 originalMask = vec3(generateCircle(uv, vec2(-0.5 * sin(iTime), 0.5 * cos(iTime)), 0.3, 0.5));\n    vec3 mask2 = vec3(generateCircle(uv, vec2(-0.2 * sin(iTime), -0.6 * cos(iTime)), 0.3, 0.4));\n    vec3 mask3 = vec3(generateCircle(uv, vec2(-0.2 * -0.5*cos(iTime), -0.0 * sin(iTime * 2.0)), 0.3, 0.4));\n    vec3 mask4 = vec3(generateCircle(uv, vec2(-0.2 * sin(iTime), -0.5 * sin(iTime * 2.0)), 0.5 * cos(iTime), 0.4));\n    \n    vec3 colorBlend = vec3(0.0, 0.0, 1.0) * originalMask;\n    colorBlend += vec3(1.0, 0.0, -1.0) * mask2;\n    colorBlend += vec3(0.0, 1.0, 0.0) * mask3;\n    colorBlend += vec3(1.0, 1.0, 0.0) * mask4;\n    \n   \n    fragColor = vec4(colorBlend, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 131], [133, 133, 180, 180, 305], [308, 308, 365, 365, 1101]]}
{"id": "tlBfz1", "name": "Parallax Nightsky", "author": "hugoaboud", "description": "Linear gradient background and 3 star layers, moving in parallax.", "tags": ["parallax", "sky", "stars", "night"], "likes": 5, "viewed": 396, "published": "Public API", "date": "1598302070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n\tParallax Stars\n\tshader by @hugoaboud\n\t\n\tLicense: GPL-3.0\n**/\n\n/**\n\tProperties\n**/\n\n// Background Gradient\nvec4 _TopColor = vec4(0.24,0.27,0.41,1);\nvec4 _BottomColor = vec4(0.07,0.11,0.21,1);\n\n// Star colors\nvec4 _Star1Color = vec4(1,0.94,0.72,0.7);\nvec4 _Star2Color = vec4(0.18,0.03,0.41,0.7);\nvec4 _Star3Color = vec4(0.63,0.50,0.81,0.7);\n\n// Star grid\nfloat _Grid = 40.0;\nfloat _Size = 0.15;\n\n// Parallax Speed\nvec2 _Speed = vec2(0, 3);\n\n/**\n\tUtilities\n**/\n\n// Generates a random 2D vector from another 2D vector\n// seed must be a large number\n// output range: ([0..1[,[0..1[)\nvec2 randVector(in vec2 vec, in float seed)\n{\n    return vec2(fract(sin(vec.x*999.9+vec.y)*seed),fract(sin(vec.y*999.9+vec.x)*seed));\n}\n\n/**\n\tStar shader\n**/\n\n// Draw star grid\nvoid drawStars(inout vec4 fragColor, in vec4 color, in vec2 uv, in float grid, in float size, in vec2 speed, in float seed)\n{\n    uv += iTime * speed;\n    \n    // Split UV into local grid\n    vec2 local = mod(uv,grid)/grid;\n    \n    // Random vector for each grid cell\n    vec2 randv = randVector(floor(uv/grid), seed)-0.5;\n    float len = length(randv);\n    \n    // If center + random vector lies inside cell\n    // Draw circle\n    if (len < 0.5) {\n        // Draw circle on local grid\n        float radius = 1.0-distance(local, vec2(0.5,0.5)+randv)/(size*(0.5-len));\n        if (radius > 0.0) fragColor += color*radius;\n    }\n}\n\n/**\n\tMain frag shader\n**/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Background\n    fragColor = mix(_TopColor, _BottomColor, fragCoord.y/iResolution.y);\n    \n    // Stars\n    drawStars(fragColor, _Star1Color, fragCoord, _Grid, _Size, _Speed, 123456.789);\n   \tdrawStars(fragColor, _Star2Color, fragCoord, _Grid*2.0/3.0, _Size, _Speed/1.2, 345678.912);\n    drawStars(fragColor, _Star3Color, fragCoord, _Grid/2.0, _Size*3.0/4.0, _Speed/1.6, 567891.234);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBfz1.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[464, 583, 628, 628, 718], [742, 760, 885, 885, 1389], [1391, 1418, 1474, 1496, 1869]]}
{"id": "tlfBDn", "name": "Pixelization gradient", "author": "zwegner", "description": "it's, like, pixelization and gradients, man", "tags": ["gradient", "pixelization"], "likes": 24, "viewed": 404, "published": "Public API", "date": "1596447854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on xxhash\nuint hash(uint x) {\n\tx *= 0xC2B2AE3Du;\n    x = x << 17 | x >> 15;\n    x ^= x >> 15;\n    x *= 0x85EBCA77u;\n    x ^= x >> 13;\n    x *= 0x165667B1u;\n    x ^= x >> 16;\n\treturn x;\n}\nfloat fhash2(vec2 xy) {\n    return float(hash(uint(1024.*xy.x) + hash(uint(1024.*xy.y)))) / float(0xFFFFFFFFu);\n}\nfloat fhash3(vec2 xy, uint z) {\n    return float(hash(uint(1024.*xy.x) + hash(uint(1024.*xy.y) +\n\t\t\thash(1024u*z)))) / float(0xFFFFFFFFu);\n}\n\nvec2 mask_coord(vec2 coord, int shift) {\n    uint mask = 0xFFFFu << shift;\n    return vec2(float(uint(coord.x) & mask),\n                float(uint(coord.y) & mask));\n}\n\nfloat get_sample(vec2 coord, int shift) {\n    coord = mask_coord(coord, shift);\n    vec2 uv = coord / iResolution.xy;\n    \n    float offset = 1.2 * (uv.x + uv.y - 1.);\n    float hxy = fhash2(coord);\n    float fshift = 6.*abs(uv.y - uv.x) + 1.8;\n    float tf = 13.*iTime/fshift + 1.*hxy;\n    uint t = uint(tf);\n    float h1 = fhash3(coord, t);\n    #if 1\n    float c = 1.2*h1 + offset;\n    #else\n\tfloat h2 = fhash3(coord, t+1u);\n    float f = clamp(1.8*(tf-float(t)), 0., 1.);\n    float c = 1.2*mix(h1, h2, f) + offset;\n    #endif\n\tc = (c - .5) * 2.5 / (1.5 + float(shift)) + .5;\n    return c;\n}\n\nfloat get_sample_t(vec2 coord, uint time) {\n    int shift = 0;\n    for (int s = 10; s >= 0; s--) {\n    \tvec2 xy = mask_coord(coord, s) / iResolution.xy;\n    \tfloat factor = 6.*abs(xy.y - xy.x)+1.;\n        if (s < int(factor + 1.*fhash3(xy, time))) {\n            shift = s;\n            break;\n        }\n    }\n    float c1 = get_sample(coord, shift);\n    float c2 = get_sample(coord, shift+1);\n    return (1.*c1+c2)/2.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float tf = .3*iTime;\n    uint t = uint(tf);\n    float c1 = get_sample_t(fragCoord, t);\n    float c2 = get_sample_t(fragCoord, t+1u);\n    float c = mix(c1, c2, tf-float(t));\n    fragColor = vec4(c,c,c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 38, 38, 195], [196, 196, 219, 219, 309], [310, 310, 341, 341, 450], [452, 452, 492, 492, 619], [621, 621, 662, 662, 1214], [1216, 1216, 1259, 1259, 1636], [1638, 1638, 1693, 1693, 1903]]}
{"id": "tlfBRj", "name": "Study rain postprocess", "author": "MrDevin", "description": "https://www.shadertoy.com/view/ltffzl", "tags": ["study"], "likes": 4, "viewed": 195, "published": "Public API", "date": "1597143562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 10.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //格式化uv，（-0.5~0.5大概范围)，除去屏幕比例影响\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    //正常UV，用于对背景图进行采样\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    \n    \n    float T = iTime;\n    \n    \n    float t = T*.2;\n    \n    \n    float rainAmount = sin(T*.05)*.3+.7;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;\n    \n    \n    \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    //float layer1 = S(.25, .75, rainAmount);\n    //float layer2 = S(.0, .5, rainAmount);\n    \n    //float staticDrops = 0.0;\n    float layer1 = 0.0;\n    float layer2 = 0.0;\n    \n    \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    \n    \n    \t//vec2 e = vec2(.001, 0.);\n    \t//float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    \t//float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    \t//vec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n\n    \n    \n\n    \n    //float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    //vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    \n   \n\n    \n    \n    vec3 col = vec3(c,0.0f);\n    //vec3 col = vec3(0.0f);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 61, 87, 259], [262, 262, 280, 280, 326], [328, 328, 357, 357, 392], [395, 395, 430, 430, 1582], [1584, 1584, 1621, 1621, 1897], [1899, 1899, 1959, 1959, 2178], [2180, 2180, 2237, 2309, 3442]]}
{"id": "tlfBW4", "name": "Buugeng", "author": "nixaboo", "description": "Buugeng - You can play around with the mouse ", "tags": ["buugeng"], "likes": 2, "viewed": 123, "published": "Public", "date": "1596711515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define S(a, b, c) smoothstep(a,b,c)\n\nmat2 Rot(float a) { \n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Rect(vec2 uv, float x1, float y1, float w, float h, float edge) {\n    \n    float x2 = x1 + w;\n    float y2 = y1 - h;\n    \n    float x = S(x1 - edge, x1, uv.x) * S(x2, x2-edge, uv.x);\n    float y = S(y1, y1-edge, uv.y) * S(y2, y2+edge, uv.y);\n    \n    return x*y;\n}\n\nfloat Circle(vec2 uv, float r, float edge) {\n    \n    float d = length(uv);\n    return S(r, r-edge, d);\n}\n\nfloat Blade(vec2 uv, float r) { \n    float circle1 = Circle(uv, r, 0.05);\n    float rect1 = Rect(uv, .15, 1., 1., 2., 0.01);\n    circle1 -= rect1;\n    \n    uv.y *= 1.15;\n    float circle2 = Circle(uv - vec2(.1, 0.), r, 0.01);\n  \n    return max(circle1 - circle2, 0.);\n}\n\nfloat HEIGHT = 2.5;\nfloat WIDTH = 1.;\n\nfloat Bugugeng(vec2 uv, float r, float t) { \n\n    uv.y += sin(t*2.) * HEIGHT;\n    uv.x -= sin(t*2. + 3.1418/2.) * WIDTH;\n    uv *=  Rot(-t*2. + 3.1418/2.);\n    \n    float rect = Rect(uv, -.5, .5, 1.0, 1.0, 0.05);\n    float circle = Circle(uv, 1., 0.05);\n    \n    float blade1 = Blade(uv - vec2(0., .91), 1.);\n\n    uv.x *= -1.;\n    float blade2 = Blade(uv + vec2(0., .91), 1.);\n    return min(blade1 + blade2, 1.);\n}\n\nvec3 TwoBug(vec2 uv, float t) { \n    vec3 col = vec3(.0);\n        \n    float bugugeng = Bugugeng(uv, .5, t);\n    col.rgb = mix(col.rgb, vec3(.1, .1, .8), bugugeng);\n\n    vec2 bug2uv = uv;\n    bug2uv.x *= -1.;\n    col.rgb = mix(col.rgb, vec3(.1, .1, .8),  Bugugeng(bug2uv, .5, t));\n    \n    return col;\n}\n\n#define TOTAL 5.\n#define TRAIL 5.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 iResolution = resolution;\n    //float iTime = time;\n    \n    float t = iTime * .25;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseC = (iMouse.xy - .5 * iResolution.xy)/iResolution.y;\n    uv *= 10.0;\n    WIDTH =  5. * mouseC.x * sin(t*2.);\n    HEIGHT = 5. *mouseC.y *  sin(t*3.);\n    vec3 col = vec3(0.);\n    \n    for(float i=0.; i < TOTAL; i+= 1.){\n        for(float n=0.; n < TRAIL; n+= 1.){\n            vec3 bugugeng = TwoBug(uv, t + i*2.5 + n * .02);\n            col.rgb += bugugeng;\n        }\n    }\n\n        \n    fragColor = vec4(col, 1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 58, 58, 125], [127, 127, 198, 198, 397], [399, 399, 443, 443, 504], [506, 506, 537, 537, 775], [816, 816, 859, 859, 1231], [1233, 1233, 1264, 1264, 1536], [1573, 1573, 1628, 1691, 2218]]}
{"id": "tlfBz7", "name": "aji's basic plasma", "author": "aji", "description": "just came to play around", "tags": ["basic", "plasma", "aji"], "likes": 2, "viewed": 64, "published": "Public", "date": "1596311983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lerp(float t0, float t1, float y0, float y1, float t) {\n    return y0 + (y1 - y0) * (t - t0) / (t1 - t0);\n}\nvec3 lerp(float t0, float t1, vec3 y0, vec3 y1, float t) {\n    return y0 + (y1 - y0) * (t - t0) / (t1 - t0);\n}\n\nfloat lerp2(float y0, float y1, float t) {\n    return y0 * (1.0 - t) + y1 * t;\n}\nvec3 lerp2(vec3 y0, vec3 y1, float t) {\n    return y0 * (1.0 - t) + y1 * t;\n}\n\nvec3 gradient(float f, float t) {\n    vec3 color = f + vec3(0.0, 0.3 + sin(3. * t) * 0.2, 0.7 + cos(4. * t) * -0.2);\n    color = cos(color * 3.14159 / 2.);\n    color = 1. - color * color;\n    return color;\n}\n\nvec3 bands(float f, float t) {\n    if (fract(f) < 0.1) {\n        return vec3(0., 0., 0.);\n    } else {\n        return vec3(1., 1., 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y * 3. / lerp(-1., 1., 1., 3., sin(t*0.2))\n        + vec2(t*0.1 + cos(t*0.4),\n               t*0.2 + sin(t*0.3));\n    vec3 col = gradient(\n        1.2 * cos(  8.4 * uv.x -  1.1 * uv.y + 0.8 * t + 1.) +\n        0.8 * cos(  1.5 * uv.x +  4.2 * uv.y - 0.1 * t + 5.) +\n        1.0 * cos( -4.6 * uv.x +  1.1 * uv.y - 0.4 * t + 6.) +\n        1.0 * cos( -1.2 * uv.x -  6.2 * uv.y + 0.6 * t + 9.) +\n        0.5 * cos( 14.1 * uv.x +  1.9 * uv.y + 3.2 * t + 1.) +\n        0.5 * cos( 12.1 * uv.x - 11.8 * uv.y - 2.8 * t + 7.) +\n        0.3 * cos( 27.2 * uv.x + 14.0 * uv.y + 0.1 * t + 0.) +\n        0.2 * cos( 14.2 * uv.x + 27.0 * uv.y + 0.3 * t + 0.),\n        t\n    );\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 113], [114, 114, 172, 172, 224], [226, 226, 268, 268, 306], [307, 307, 346, 346, 384], [386, 386, 419, 419, 593], [595, 595, 625, 625, 738], [740, 740, 797, 797, 1572]]}
{"id": "tlffWB", "name": "Razor Blossom", "author": "ruojake", "description": "A quick doodle inspired by BigWings' torus knot tutorial", "tags": ["3d", "raymarching", "torus"], "likes": 5, "viewed": 193, "published": "Public API", "date": "1597608927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Razor Blossom by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene(vec3 p)\n{\n    p.y *= 2.;\n    vec2 h2 = hash21(floor(p.y - .5));\n    p.xz += h2 * 3.;\n    float s = fract(dot(floor(p.xz - .5), vec2(1)) * .5) * 4. - 1.;\n    float h = hash12(floor(p.xz) + h2.x);\n    p.y -= .5;\n    p = abs(fract(p) * 2. - 1.);\n    float a = atan(p.x, p.z) * s;\n    float x = length(p) - .75;\n    vec2 cp = vec2(x, p.y);\n    cp *= rot(a * 2. + iTime * (6. + h * 7.));\n    cp.y = abs(abs(cp.y) - .0625) - .025;\n    \n\treturn (max(abs(cp.x), abs(cp.y)) - .025) * .3;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 v = vec3(.2, 0., .1) * iTime;\n    vec3 ro = vec3(0, .25, -2) + v;\n    vec3 tgt = vec3(-1) + v;\n    vec3 rd = ray(ro, tgt, uv, .7);\n    vec3 p;\n    float t = 0.;\n    \n    for(int i = 0; i < 200; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p) * (1. + rd.y * .5);\n        t += d;\n        if (abs(d) < .0001 || t > 10.) break;\n    }\n    \n    vec3 n = normal(p);\n    vec3 lDir = normalize(ro - p);\n    float l = dot(n, lDir) * .5 + .5;\n    l *= sat(2. - length(ro - p) * .4);\n    l *= sat(scene(p + n * .01) * 200.) * .5 + .5;\n    \n    vec3 col = mix(vec3(.05,.05,.3), vec3(.9, .4, .8), l);\n    col += l * l * l;\n    col *= sat(2. - t * .3);\n\n    col *= vec3(1., .97, .92);\n    \n    col = pow(col, vec3(1./2.2));\n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffWB.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[0, 147, 169, 169, 232], [234, 234, 256, 256, 369], [371, 371, 390, 390, 463], [465, 465, 486, 486, 957], [959, 959, 980, 980, 1143], [1145, 1145, 1198, 1198, 1356], [1358, 1358, 1415, 1415, 2338]]}
{"id": "tlffzS", "name": "Brute Force Box Filter", "author": "GregRostami", "description": "Brute force anti-aliasing using a box-filter.\nEnjoy in Full-Screen!\nHere's the golfed version of this shader:\n[url]https://www.shadertoy.com/view/tlsBzS[/url]", "tags": ["2d", "supersampling"], "likes": 3, "viewed": 305, "published": "Public API", "date": "1597007524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Brute Force Box Filter - Each pixel is super sampled 256 times!\n// This shader has been optimized for speed.\n// The golfed version of this shader has been optimized for size.\n// If you know about implementing a Gausian filter in Shadertoy, please help!\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    O-=O;\n    vec2 R = iResolution.xy, u, a = (U - .5*R)/R.y;\n        \n    float A = 16.,   //The A variable determines the level of Anti-Aliasing\n          s = 1./A,\n          t = .3 * iTime,\n          x, y;\n    \n        for (y=0.; y < 1.; y += s)\n            for (x=0.; x < 1.; x += s)\n                u = a + vec2(x,y)/R.y,\n                \n                u /= dot(u,u),\n                O += max( u=fract(3.*u + t), u.x-u ).y;\n            \n        O /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlffzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 257, 292, 292, 756]]}
{"id": "tljfzW", "name": "defaultshell", "author": "lennyjpg", "description": "sdfdfdsf", "tags": ["sdfdfdf"], "likes": 3, "viewed": 218, "published": "Public API", "date": "1598474127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 0.5 - fragCoord.xy/iResolution.x;\n    vec2 u = uv;\n    u.y-= 0.1;\n    float t = iTime * -0.1;\n    if(u.x < .0){\n        u.y = .5 - u.y;\n    }\n    vec3 a = vec3(255., 255., 225. );\n    a *= 1.0 - uv.y;\n    vec3 rot = vec3(255., .0, 91. );\n    float d = length(u)*4.0;\n    float c = fract(t + d );\n    \n    vec3 q = mix(a,rot,c)/255.0;\n    if(uv.x > uv.y){\n        q *= vec3(50.,100.,220.)/255.;\n    }\n    if(uv.x > uv.y){\n       float cc = length(uv-vec2(.5,.5));        \n       // float cc = (uv.x  + uv.y) - .84;\n        q += smoothstep(cc, cc * 1.02, .2);\n    }\n    fragColor = vec4(q,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 666]]}
{"id": "tllBD2", "name": "Blue Stripes", "author": "jamesjacobk", "description": "Just a random test. Could be used as a highlight shader.", "tags": ["blue", "stripes"], "likes": 1, "viewed": 43, "published": "Public", "date": "1597812907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float uvx = fragCoord.x/iResolution.x;\n    float uvy = fragCoord.y/iResolution.y;\n\t//fragColor = vec4(0., 0., sin(iTime+2.0* uvx)*sin(iTime +10. * 20. * uvx * uvy), 1.);\n    fragColor = vec4(0., 0., sin(iTime +2. *uvx * uvy) * sin(iTime + 12. * 20. * uvx * uvy), 1.);\n    //fragColor = vec4(abs(2.0/(200.0  *sin(iTime +2. *uvx * uvy))), 0., abs(2.0/(200.0  *sin(iTime +2. *uvx * uvy) * tan(iTime + 12. * uvx * uvy))), 1.);\n    //abs(1.0/(thinness * uv.y));\n    //fragColor = vec4(0., 0., sin((iTime * 5.) + 1.0  * uvx), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 588]]}
{"id": "tllBDX", "name": "sinCarve", "author": "TRASHTRASH", "description": "daily exercise", "tags": ["raymarching", "carve", "trashtrash"], "likes": 0, "viewed": 58, "published": "Public", "date": "1597972013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH is Josh deLorimier\n//learned polar texture mapping playing with the carving idea more for today\n#define MAX_STEPS 128\n#define MAX_DIST 8.\n#define SURF_DIST 0.001\n\n//simplex noise from Patricio Gonzalez Vivo\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0);} \n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//mercury------------------- \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat box(vec3 p, vec3 b) {\n    return vmax(abs(p)-b);\n}\n//--------------------------\n\nfloat map(vec3 p) {\n    vec2 uv = vec2(p.x*0.9+(iTime/2.),p.y);\n    vec3 tex = vec3(texture(iChannel0, uv));\n\tfloat s = sin((p.x*8.)+iTime/0.7)*sin(p.y*abs(sin(8.+iTime)*3.)+iTime)*sin(iTime+0.2);\n    float s1 = sin((p.x*4.392+(iTime*0.001))+iTime);\n \tfloat bb = box(p-vec3(0.,0.,3.), vec3(2.,1.5,1.));\n    float ss = length(p-vec3(0.,(s*s1+s)*0.5,2.))-.8;\n   \tfloat b = max(-ss, bb);\n    float c = max(-ss, b);\n    c+=length(tex*0.02)*2.;\n    return c;\n}\n\nfloat RM(vec3 ro, vec3 rd) {\n \tfloat t = 0.;\n    for(int i = 0;i<MAX_STEPS;i++) {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        \n        if(t > MAX_DIST || abs(s) < (SURF_DIST)) break;\n        t+=s;\n        \n      }\n   return t;\n}\n\n\nvec3 norm(vec3 p) {\n \tfloat d = map(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat shade(vec3 p, vec3 rd) {\n \tvec3 lp = vec3(4,3.,-15.);\n    vec3 l = normalize(lp -p);\n    vec3 n = norm(p);\n    float dif = clamp(dot(n,l),0.,.6);\n  \tfloat fr = pow(1.0+dot(n, rd),4.0);\n   \tfloat ao = (1.0 - fr);\n    float sp = pow(max(dot(reflect(-l, n),-rd),0.0),80.);\n   \treturn sp + max(fr,0.4)+dif*ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord -0.5 * iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 col = vec3(0.);\n    vec3 c1 = vec3(.5,0.2,0.);\n    float d = RM(ro, rd);\n    if(d<MAX_DIST) {\n      vec3 p = ro + rd *d;\n      float n4 = snoise(uv.xy+iTime); \n   \t  float dif = shade(p, rd);\n   \t  col = vec3(dif)*c1;\n    }\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 220, 242, 242, 280], [283, 283, 305, 305, 1125], [1126, 1156, 1176, 1176, 1211], [1213, 1213, 1240, 1240, 1269], [1270, 1300, 1319, 1319, 1755], [1757, 1757, 1785, 1785, 2001], [2004, 2004, 2023, 2023, 2165], [2167, 2167, 2197, 2197, 2480], [2483, 2483, 2540, 2540, 2981]]}
{"id": "tllBR2", "name": "Noise waves 1", "author": "RodzLabs", "description": "This shader was generated using Material Maker (that's why the code is horrible :D).", "tags": ["generated"], "likes": 2, "viewed": 67, "published": "Public", "date": "1597226343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fbm_value(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat p00 = rand(mod(o, size));\n\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));\n\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));\n\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlin(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat a00 = rand(mod(o, size)) * 6.28318530718;\n\tfloat a01 = rand(mod(o + vec2(0.0, 1.0), size)) * 6.28318530718;\n\tfloat a10 = rand(mod(o + vec2(1.0, 0.0), size)) * 6.28318530718;\n\tfloat a11 = rand(mod(o + vec2(1.0, 1.0), size)) * 6.28318530718;\n\tvec2 v00 = vec2(cos(a00), sin(a00));\n\tvec2 v01 = vec2(cos(a01), sin(a01));\n\tvec2 v10 = vec2(cos(a10), sin(a10));\n\tvec2 v11 = vec2(cos(a11), sin(a11));\n\tfloat p00 = dot(v00, f);\n\tfloat p01 = dot(v01, f - vec2(0.0, 1.0));\n\tfloat p10 = dot(v10, f - vec2(1.0, 0.0));\n\tfloat p11 = dot(v11, f - vec2(1.0, 1.0));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlinabs(vec2 coord, vec2 size, float seed) {\n\treturn abs(2.0*fbm_perlin(coord, size, seed)-1.0);\n}\n\nfloat fbm_cellular(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular2(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular3(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular4(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular5(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular6(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\nvec2 transform(vec2 uv, vec2 translate, float rotate, vec2 scale, bool repeat) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n    if (repeat) {\n\t\treturn fract(rv);\n\t} else {\n\t\treturn clamp(rv, vec2(0.0), vec2(1.0));\n\t}\t\n}vec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n    return uv;\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nconst float p_o52326_amount = 1.000000000;\nconst float p_o46873_translate_x = 0.059999999;\nconst float p_o46873_rotate = 0.000000000;\nconst float p_o46873_scale_x = 1.000000000;\nconst float p_o46873_scale_y = 1.000000000;\nconst float p_o70492_repeat = 1.000000000;\nconst float p_o70492_rotate = 90.000000000;\nconst float p_o70492_gradient_0_pos = 0.000000000;\nconst float p_o70492_gradient_0_r = 0.000000000;\nconst float p_o70492_gradient_0_g = 0.000000000;\nconst float p_o70492_gradient_0_b = 0.000000000;\nconst float p_o70492_gradient_0_a = 1.000000000;\nconst float p_o70492_gradient_1_pos = 0.500000000;\nconst float p_o70492_gradient_1_r = 1.000000000;\nconst float p_o70492_gradient_1_g = 1.000000000;\nconst float p_o70492_gradient_1_b = 1.000000000;\nconst float p_o70492_gradient_1_a = 1.000000000;\nconst float p_o70492_gradient_2_pos = 1.000000000;\nconst float p_o70492_gradient_2_r = 0.000000000;\nconst float p_o70492_gradient_2_g = 0.000000000;\nconst float p_o70492_gradient_2_b = 0.000000000;\nconst float p_o70492_gradient_2_a = 1.000000000;\nvec4 o70492_gradient_gradient_fct(float x) {\n  if (x < p_o70492_gradient_0_pos) {\n    return vec4(p_o70492_gradient_0_r,p_o70492_gradient_0_g,p_o70492_gradient_0_b,p_o70492_gradient_0_a);\n  } else if (x < p_o70492_gradient_1_pos) {\n    return mix(vec4(p_o70492_gradient_0_r,p_o70492_gradient_0_g,p_o70492_gradient_0_b,p_o70492_gradient_0_a), vec4(p_o70492_gradient_1_r,p_o70492_gradient_1_g,p_o70492_gradient_1_b,p_o70492_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o70492_gradient_0_pos)/(p_o70492_gradient_1_pos-p_o70492_gradient_0_pos)));\n  } else if (x < p_o70492_gradient_2_pos) {\n    return mix(vec4(p_o70492_gradient_1_r,p_o70492_gradient_1_g,p_o70492_gradient_1_b,p_o70492_gradient_1_a), vec4(p_o70492_gradient_2_r,p_o70492_gradient_2_g,p_o70492_gradient_2_b,p_o70492_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o70492_gradient_1_pos)/(p_o70492_gradient_2_pos-p_o70492_gradient_1_pos)));\n  }\n  return vec4(p_o70492_gradient_2_r,p_o70492_gradient_2_g,p_o70492_gradient_2_b,p_o70492_gradient_2_a);\n}\nconst int seed_o140551 = 65287;\nconst float p_o140551_scale_x = 8.000000000;\nconst float p_o140551_scale_y = 2.000000000;\nconst float p_o140551_iterations = 4.000000000;\nconst float p_o140551_persistence = 0.200000003;\nfloat o140551_fbm(vec2 coord, vec2 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += fbm_cellular2(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nconst float p_o13850_translate_x = 0.059999999;\nconst float p_o13850_rotate = 0.000000000;\nconst float p_o13850_scale_x = 1.000000000;\nconst float p_o13850_scale_y = 1.000000000;\nconst float p_o188138_cx = 0.000000000;\nconst float p_o188138_cy = 0.000000000;\nconst float p_o188138_scale_x = 1.000000000;\nconst float p_o188138_scale_y = -1.000000000;\nconst int seed_o147289 = 73358;\nconst float p_o147289_scale_x = 8.000000000;\nconst float p_o147289_scale_y = 2.000000000;\nconst float p_o147289_iterations = 4.000000000;\nconst float p_o147289_persistence = 0.200000003;\nfloat o147289_fbm(vec2 coord, vec2 size, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += fbm_cellular2(coord*size, size, seed) * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nfloat o70492_0_r = 0.5+(cos(p_o70492_rotate*0.01745329251)*((((UV))).x-0.5)+sin(p_o70492_rotate*0.01745329251)*((((UV))).y-0.5))/(cos(abs(mod(p_o70492_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o70492_0_1_rgba = o70492_gradient_gradient_fct(fract(o70492_0_r*p_o70492_repeat));\nfloat o140551_0_1_f = o140551_fbm((transform(((UV)), vec2(p_o46873_translate_x*(2.0*(dot((o70492_0_1_rgba).rgb, vec3(1.0))/3.0)-1.0), (iTime*0.3)*(2.0*1.0-1.0)), p_o46873_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o46873_scale_x*(2.0*1.0-1.0), p_o46873_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o140551_scale_x, p_o140551_scale_y), int(p_o140551_iterations), p_o140551_persistence, float(seed_o140551));\nvec4 o46873_0_1_rgba = vec4(vec3(o140551_0_1_f), 1.0);\nfloat o70492_2_r = 0.5+(cos(p_o70492_rotate*0.01745329251)*((scale((((UV))), vec2(0.5+p_o188138_cx, 0.5+p_o188138_cy), vec2(p_o188138_scale_x, p_o188138_scale_y))).x-0.5)+sin(p_o70492_rotate*0.01745329251)*((scale((((UV))), vec2(0.5+p_o188138_cx, 0.5+p_o188138_cy), vec2(p_o188138_scale_x, p_o188138_scale_y))).y-0.5))/(cos(abs(mod(p_o70492_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o70492_0_3_rgba = o70492_gradient_gradient_fct(fract(o70492_2_r*p_o70492_repeat));\nvec4 o188138_0_1_rgba = o70492_0_3_rgba;\nfloat o147289_0_1_f = o147289_fbm((transform(((UV)), vec2(p_o13850_translate_x*(2.0*(dot((o188138_0_1_rgba).rgb, vec3(1.0))/3.0)-1.0), (iTime*0.4)*(2.0*1.0-1.0)), p_o13850_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o13850_scale_x*(2.0*1.0-1.0), p_o13850_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o147289_scale_x, p_o147289_scale_y), int(p_o147289_iterations), p_o147289_persistence, float(seed_o147289));\nvec4 o13850_0_1_rgba = vec4(vec3(o147289_0_1_f), 1.0);\nvec4 o52326_0_0_rgba = vec4(blend_lighten((UV), o46873_0_1_rgba.rgb, o13850_0_1_rgba.rgb, p_o52326_amount*1.0*o46873_0_1_rgba.a), min(1.0, o13850_0_1_rgba.a+p_o52326_amount*1.0*o46873_0_1_rgba.a));\nfragColor = o52326_0_0_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 27, 27, 95], [97, 97, 117, 117, 229], [231, 231, 251, 251, 436], [438, 438, 460, 460, 757], [759, 759, 781, 781, 941], [943, 943, 995, 995, 1368], [1370, 1370, 1423, 1423, 2173], [2175, 2175, 2231, 2231, 2285], [2287, 2287, 2342, 2342, 2742], [2744, 2744, 2800, 2800, 3338], [3340, 3340, 3396, 3396, 3774], [3776, 3776, 3832, 3832, 4348], [4350, 4350, 4406, 4406, 4784], [4786, 4786, 4842, 4842, 5358], [5359, 5359, 5439, 5439, 5705], [5705, 5705, 5751, 5751, 5812], [5812, 5812, 5873, 5873, 5914], [5916, 5916, 5979, 5979, 6047], [6049, 6049, 6112, 6112, 6156], [6158, 6158, 6219, 6219, 6281], [6283, 6283, 6326, 6326, 6392], [6394, 6394, 6456, 6456, 6586], [6588, 6588, 6653, 6653, 6734], [6736, 6736, 6782, 6782, 6877], [6879, 6879, 6944, 6944, 7083], [7085, 7085, 7125, 7125, 7178], [7180, 7180, 7239, 7239, 7360], [7362, 7362, 7403, 7403, 7448], [7450, 7450, 7510, 7510, 7634], [7636, 7636, 7698, 7698, 7748], [7750, 7750, 7811, 7811, 7861], [7863, 7863, 7928, 7928, 8001], [9052, 9052, 9096, 9096, 10061], [10281, 10281, 10367, 10367, 10640], [11210, 11210, 11296, 11296, 11569], [11571, 11571, 11626, 11626, 13729]]}
{"id": "tllBR7", "name": "Growing Gyroid", "author": "Giraugh", "description": "Basic ray-marcher engine with a couple of shapes implemented.\nAdapted from a tutorial by `The Art of Code`", "tags": ["raymarching"], "likes": 0, "viewed": 41, "published": "Public", "date": "1596419224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define AMBIENT_LIGHT 0.3\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nfloat sdBox(vec3 point, vec3 origin, vec3 size) {\n    point = abs((point-origin)) - size;\n\treturn length(max(point, 0.))+min(max(point.x, max(point.y, point.z)), 0.);\n}\n\nfloat sdSphere(vec3 point, vec3 origin, float radius) {\n\treturn length(point - origin) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    float ss = iTime/30.;\n    p *= scale;\n\treturn abs(bias + dot(sin(p*ss), cos(p.zxy))) / (scale * max(1., ss)) - thickness;\n}\n\nfloat GetDist(vec3 p) {\n\t// plane at origin with normal of Y axis\n    float planeD = p.y;\n    \n    // Sphere\n    vec3 sphereO = vec3(0, 1, 0);\n    float sphereR = 1.;\n    float sphereD = sdSphere(p, sphereO, sphereR);\n    \n    // Box \n    vec3 boxO = vec3(0, 1, 0);\n    vec3 boxS = vec3(1);\n    float boxD = sdBox(p, boxO, boxS);\n    \n    // Blend the sphere and the box\n    float blendD = mix(sphereD, boxD, (1. + sin(iTime))/2.);\n    \n    \n    float container = sdBox(p, vec3(0), vec3(4));\n    float gyroid = sdGyroid(p, 2., .05, 1.);\n    \n    return max(container, gyroid*.7);\n    \n    // return min(min(blendD, planeD), gyroid);\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\tfloat d = 0.;\n    for (int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayOrigin + d*rayDirection;\n        float delta_d = GetDist(p);\n        d += delta_d;\n        if (d > MAX_DIST || abs(delta_d) < SURF_DIST) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 point) {\n    // We use 'e' to represent a small step\n    vec2 e = vec2(.001,0);\n    \n    // Get distance to scene at P\n    float d = GetDist(point);\n    \n    // Compute normal by sampling scene dist at\n    // small offsets\n    vec3 n = d - vec3(\n    \tGetDist(point - e.xyy),\n        GetDist(point - e.yxy),\n        GetDist(point - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLightingPoint(vec3 point) {\n\t// Define light position\n    vec3 lightPos = vec3(2, 6, 4); // vec3(sin(iTime*.5)*2., 4, 3. + cos(iTime*.5)*2.);\n    \n    // Calculate the normal\n\tvec3 normal = GetNormal(point);    \n    \n    // Direction to light\n    vec3 l = normalize(lightPos - point);\n \t\n    // Calculate Diffuse level\n    float diffuse = dot(l,normal);\n    \n    // In shadow? Raycast to the light to check\n    float lightD = RayMarch(\n        point+normal*SURF_DIST*2., l);\n    if (lightD < length(lightPos-point))\n    \tdiffuse *= 0.1;\n    \n    return clamp(diffuse, 0., 1.);\n}\n\nfloat GetLightingSun(vec3 point, bool shadow) {\n    vec3 lightDir = vec3(0.4, -1, 0);\n    \n    // Calculate the normal\n\tvec3 normal = GetNormal(point);   \n    \n    // Direction to light\n    vec3 l = normalize(-lightDir);\n \t\n    // Calculate Diffuse level\n    float diffuse = dot(l,normal);\n    \n    // In shadow? Raycast to the light to check\n    if (shadow) {\n        float lightD = RayMarch(\n            point+normal*SURF_DIST*2., l);\n        if (lightD < MAX_DIST * 0.9)\n            diffuse *= 0.1;\n    }\n    \n    return clamp(diffuse, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Re-Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 rayOrigin = vec3(0, 3, -13);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    rayOrigin = vec3(0,0,-13);\n    float rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n    \n    // RayMarch to find distance\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    vec3 normal = GetNormal(hitPoint);\n    \n    // Calculate Lighting\n    float diffuseP = GetLightingPoint(hitPoint);\n    float diffuseAmbient = AMBIENT_LIGHT * GetLightingSun(hitPoint, false);\n    vec3 col = vec3(diffuseP + diffuseAmbient);\n    \n    col += .3 * normal;\n    \n    // Output colour with full opacity\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 190], [192, 192, 241, 241, 360], [362, 362, 417, 417, 460], [462, 462, 528, 528, 656], [658, 658, 681, 723, 1292], [1294, 1294, 1345, 1345, 1584], [1586, 1586, 1614, 1658, 1982], [1984, 1984, 2020, 2046, 2571], [2573, 2573, 2620, 2620, 3122], [3125, 3125, 3182, 3235, 4239]]}
{"id": "tllBW4", "name": "theyaremanycolors 3 - red deep", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 0, "viewed": 90, "published": "Public API", "date": "1596786210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define alpha 0.0\n#define beta 10.0\n\n#define squareScale 3.0\n#define fisheye_amount -0.7\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nfloat spiral(vec2 m, float t) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(50.*(sqrt(r)-0.02*a-.3*t));\n\treturn clamp(v,0.,1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.0;\n    uv += 0.5;\n    uv = abs(uv);\n    \n    vec2 uvOrig = uv;\n    \n    uv = rotateVec(uv, iTime * 3.0);\n    \n    vec3 col = vec3(0.3, 0.3, 0.3);\n    col = spiral(uv + .4 + sin(iTime * .5 + uv.y * 5.) * (.3 + sin(iTime) * .1), iTime * 30.0) * vec3(1.0, 0.0, 0.0);\n    \n    col.r += 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + iTime * 45.5)).x - round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + squareScale/2.0 + iTime * 13.5)).y;\n    col.r -= 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + iTime * 13.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 33.5)).x;\n    col.r += 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 13.0) * squareScale + iTime * 24.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 13.5)).x;\n    col.r -= 0.1 * round(fract(rotateVec(uvOrig, iTime * 0.2 + 18.0) * squareScale + iTime * 73.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 12.5)).x;\n    \n    fragColor = vec4(col + 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 122, 122, 222], [224, 224, 255, 255, 374], [376, 376, 433, 433, 1928]]}
{"id": "tllBzj", "name": "Bouncy_Spherez_in_Wavez", "author": "TRASHTRASH", "description": "TRASHTRASH aka Josh deLorimier\nmy first ray marching design \n\n\"as you have seen, winds have a mind of their own.\" - a dead sailor\n", "tags": ["raymarching", "waves", "beginner", "smin"], "likes": 9, "viewed": 161, "published": "Public", "date": "1597266146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH\n//still WIP \n//so much to figure out lol\n//if anyone has ideas on why the specular is off on the mod copies I'd appreciate it cheers!\n\n//Learning RayMarching from CharStiles, BigWIngs, evvvvil, Patricio Gonzalez Vivo, iq \n\n//added camera rot\n//added fog from pjkarlik\n//thanks to you all this is mostly hacked from examples\n//I am getting the concepts though\n\n#define MAX_STEPS 128\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define MAX_HEIGHT 2.3\n#define SPH_RAD 1.25\n#define BLOB_SIZE 3.\n\n\n//simplex noise from Patricio Gonzalez Vivo\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0);} \n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//i think this is from a book about shaders or something like that\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//iq im pretty sure\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//geo                      \nfloat map(vec3 p) {\n   \tfloat pl = 10.0;\n    float gr = p.y + sin((iTime*2.0) + p.x * pl)/pl*0.5 + snoise(vec2((iTime*5.)+p.x,100.)/pl) + cos((-iTime*4.0)+p.z*pl)/pl+1.;\n    float n1 = abs(snoise(vec2(iTime*0.8,666.0)));\n\tfloat znoise = snoise(vec2(iTime*0.25,558.0))*3.0;\n\tfloat d = 0.0;\n\tvec2 size = vec2(10.);\n    vec2 c = floor((p.xz + size * 0.5)/size);\n    p.xz  = mod(p.xz + size * 0.5, size)-size*0.5;\n    vec2 r1 = vec2(random(c));\n    n1 = abs(snoise(vec2(iTime * r1.x * 0.15, 556.)));\n    vec4 sphere = vec4(cos((iTime+r1.x*0.0012)), abs(sin(-iTime*4.+(r1.x+0.03)))*MAX_HEIGHT*n1, znoise, 1.0)*SPH_RAD/2.0;\n    float distSphere = length(p-r1.x - sphere.xyz)-(sphere.w);\n \tfloat s1 = smin(gr, distSphere, BLOB_SIZE);\n    return s1;\n}\n//marcher\nfloat RM(vec3 ro, vec3 rd) {\n \tfloat or = 0.;\n    for(int i=0;i<MAX_STEPS;++i){\n     \tvec3 p = ro + rd * or;\n        float sc = map(p);\n        or += sc;\n        if(or>MAX_DIST || abs(sc)<SURF_DIST) break;\n    }\n    return or;\n}\n//BigWIngs\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 norm(vec3 p) {\n \tfloat d = map(p);\n    vec2 e = vec2(.001, 0.);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat shade(vec3 p, vec3 rd) {\n \tvec3 lp = vec3(-5.,6.,-2.);\n    vec3 l = normalize(lp-p);\n    vec3 n = norm(p);\n    float col = 0.;\n    float dif = clamp(dot(n,l)*.5+.5,0.,1.);\n   \tfloat fr = pow(1.0+dot(n, rd),4.0);\n    float sp = pow(max(dot(reflect(-l, n),-rd),0.0),80.);\n   \tfloat ao = (1.0 - fr);\n   \tfloat fd = 1.0 - dif;\n    col = sp + max(fr, 0.5) + dif * ao;\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n   \tvec3 col = vec3(0.0);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0.,1., 6.);\n     ro.yz *= Rot(-m.y*.2);\n    ro.xz *= Rot(iTime*.2-m.x*.2);\n    vec3 rd = R(uv, ro, vec3(0,0,0),1.);\n    float d = RM(ro, rd);\n    float n1 = snoise(((iTime/2.)+uv)*4.);\n    vec3 c1 = vec3(118./255.,220./255.,220./255.);\n    vec3 fog = mix(vec3(.001),c1+0.2,(uv.y+.9));\n    if(d<MAX_DIST) {\n       vec3 p = ro + rd * d;\n       float dif = shade(p, rd);\n       c1*=c1*c1;\n       vec3 c = vec3(c1.x + sin(p.y), c1.y, c1.y + cos(p.y));\n       col = vec3(dif)*c;\n       col *= col;\n    } else {\n    col += fog;\n   \n    }\n    col = mix(col, fog, 1.-exp(-0.000025*d*d*d));\n    col = pow(col, vec3(.4545));\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 554, 576, 576, 614], [617, 617, 639, 639, 1459], [1460, 1527, 1551, 1551, 1658], [1660, 1660, 1679, 1679, 1755], [1757, 1777, 1818, 1818, 1909], [1911, 1939, 1958, 1958, 2682], [2683, 2693, 2721, 2721, 2921], [2922, 2933, 2975, 2975, 3170], [3172, 3172, 3191, 3191, 3332], [3334, 3334, 3364, 3364, 3720], [3724, 3724, 3781, 3781, 4589]]}
{"id": "tllfRM", "name": "rotation/mask", "author": "tomoyanonymous", "description": "illusion test.\n", "tags": ["illusion"], "likes": 1, "viewed": 83, "published": "Public", "date": "1596369824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI=3.141595;\nfloat speed = 5.0;\nfloat size = 150.0;\nfloat border_dense = 0.6;\nint polygon_num = 5;\n\nfloat polygon(vec2 p, int n, float size){\n\tfloat a = atan(p.x, p.y) + PI;\n    float nf = float(n);\n\tfloat r = 2.0 * PI / nf;\n\treturn cos(floor(0.5 + a / r) * r - a) * length(p) - size; \n}\n\nfloat border(vec2 p,float rot){\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \t\n    vec2 rotp = m*(p-iResolution.xy/2.0)+iResolution.xy/2.0;\n\treturn max(0.0,min(1.0,cos(rotp.x*border_dense) *2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float penta = polygon(fragCoord.xy-iResolution.xy/2.0,polygon_num,size);\n    \n   \n   \tfloat mask = max(0.0,min(penta,1.0));\n    float bod = border(fragCoord.xy,iTime*speed);\n    float col = (1.0-mask) *bod; \n    // Output to screen\n    fragColor = vec4(vec3(1.0-col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 147, 147, 293], [295, 295, 326, 326, 511], [513, 513, 570, 620, 972]]}
{"id": "tllfRS", "name": "Electronic board by MareeBree", "author": "mareebree", "description": "Electronic board\n", "tags": ["digital"], "likes": 6, "viewed": 183, "published": "Public API", "date": "1597085668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define AR (iResolution.x/iResolution.y)\n\n#define pUP 0\n#define pEND 1\n#define pLEFT 2\n#define pRIGHT 3\n#define pFLEFT 4\n#define pFRIGHT 5\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dist(vec2 uv,vec2 x)\n{\n\treturn length(uv-x*vec2(1.0,1.0/AR));\n}\n\nvec3 circle(vec2 uv,float r, float lt)\n{\n    float lb = 0.005; // line blur\n    float d = dist(uv,vec2(0.5));\n    return vec3(min(S(r-lb-lt,r-lt,d),S(r+lb+lt,r+lt,d)));\n}\n\nvec3 lineUp(vec2 uv, float lt /*line thickness*/)\n{\n    float lb = 0.005; // line blur\n    return vec3(min(S(0.5-lb-lt,0.5-lt,uv.x),S(0.5+lb+lt,0.5+lt,uv.x)));\n}\n\nvec3 lineLeft(vec2 uv, float lt)\n{\n    vec3 colUp = lineUp(uv,lt);\n    float lb = 0.005; // line blur\n    \n    lt += 0.001;\n    vec3 colDiag = vec3(min(S(1.0-lb-lt,1.0-lt,uv.x+uv.y),S(1.0+lb+lt,1.0+lt,uv.x+uv.y)));\n    \n    return mix(colUp,colDiag,S(0.5,0.51,uv.y));\n}\n\nvec3 lineFromLeft(vec2 uv, float lt)\n{\n    uv.y = 1.0-uv.y;\n    return lineLeft(uv,lt);\n}\n\nvec3 lineRight(vec2 uv, float lt)\n{\n    uv.x = 1.0-uv.x;\n    return lineLeft(uv,lt);\n}\n\nvec3 lineFromRight(vec2 uv, float lt)\n{\n\tuv.y = 1.0-uv.y;\n    return lineRight(uv,lt);\n}\n\nvec3 lineEnd(vec2 uv, float lt, float lp /* line percent*/)\n{\n    lp /= AR;\n    vec3 lineCol = lineUp(uv,lt);\n    \n    float circleR = 0.1;\n    vec2 circleUV = uv;\n    circleUV.y += 0.5*(1.0/AR);\n    circleUV.y -= circleR+lt;\n    circleUV.y -= lp;\n    vec3 circleCol = circle(circleUV,circleR,lt);\n    \n    return mix(lineCol,circleCol,S(lp-0.01,lp,uv.y));\n}\n\nint calcType(vec2 id)\n{\n    float r = rand(id);\n    \n    if(r > 0.5) return pUP;\n    else if(r > 0.3) return pEND;\n    else if(r > 0.15) return pFLEFT;\n    else return pFRIGHT;\n}\n\nint getType2(vec2 id)\n{\n    return calcType(id);\n}\n\nint getType1(vec2 id)\n{\n    int upType = getType2(id+vec2(0.0,1.0));\n    int ulType = getType2(id+vec2(-1.0,1.0));\n    int urType = getType2(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nint getType0(vec2 id)\n{\n    int upType = getType1(id+vec2(0.0,1.0));\n    int ulType = getType1(id+vec2(-1.0,1.0));\n    int urType = getType1(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nint getType(vec2 id)\n{\n    int upType = getType0(id+vec2(0.0,1.0));\n    int ulType = getType0(id+vec2(-1.0,1.0));\n    int urType = getType0(id+vec2(1.0,1.0));\n    \n    int type = calcType(id);\n    \n    if(ulType == pFRIGHT) return pLEFT;\n    if(urType == pFLEFT)  return pRIGHT;\n    if(upType == pFLEFT || upType == pFRIGHT) return pUP;\n    if(upType == pUP && type == pUP) return pUP;\n    \n\treturn type;\n}\n\nvec3 getColor(vec2 id)\n{\n    int type = getType(id);\n    while(type != pEND)\n    {\n        id.y+=1.0;\n        if(type==pRIGHT) id.x += 1.0;\n        else if(type==pLEFT) id.x -= 1.0;\n        type = getType(id);\n    }\n    \n    float r = fract(rand(id)*231.0);\n    r = 0.5*r + 0.1;\n    \n    \n    vec3 hsvColor = vec3(r,0.7,0.9);\n    return hsv2rgb(hsvColor);\n}\n\nvec3 linesLayer(vec2 uv,vec2 id)\n{\n    vec3 col = vec3(0.0);\n    \n    int type = getType(id);\n    \n    float lt = 0.03;\n    \n    if(type==pUP) col = lineUp(uv,lt);\n    else if(type==pEND) col = lineEnd(uv,lt,0.5);\n    else if(type==pLEFT) col = lineLeft(uv,lt);\n   \telse if(type==pRIGHT) col = lineRight(uv,lt);\n   \telse if(type==pFRIGHT) col = lineFromRight(uv,lt);\n   \telse if(type==pFLEFT) col = lineFromLeft(uv,lt);\n    \n    col *= getColor(id);\n        \n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.15*iTime;\n    vec2 globalUV = fragCoord/iResolution.xy;\n    globalUV.y /= AR;\n    globalUV.x += 0.2*globalUV.y;\n    vec2 uv = globalUV;\n\n    uv.y -= t;\n    \n    uv *= vec2(10.0+2.5*globalUV.y,16.0);\n    \n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    float rnd = rand(id);\n    \n    vec3 col = vec3(0.0);\n    \n\tcol = linesLayer(uv,id);\n        \n    vec3 bgMask = vec3(1.0)-col;\n    \n    bgMask *= abs(sin(1.2*6.18*globalUV.x));\n    bgMask = clamp(bgMask,0.7,0.85);\n    \n    for(float y = 0.1;y<1.0;y+=0.2)\n    \tbgMask *= max(S(0.03,0.1,uv.y-y),S(0.1,0.05,uv.y-y));\n       \n    vec3 bgColor = hsv2rgb(vec3(0.3,0.7,0.4));\n    bgColor -= vec3(0.1 + 0.05*sin(id.x));\n    \n    col += bgMask*bgColor;    \n    \n    //if(uv.x > 0.98 || uv.y > 0.98) col.r = 1.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 313, 335, 335, 504], [506, 506, 526, 526, 598], [600, 600, 628, 628, 669], [671, 671, 711, 711, 841], [843, 843, 894, 894, 1004], [1006, 1006, 1040, 1040, 1275], [1277, 1277, 1315, 1315, 1366], [1368, 1368, 1403, 1403, 1454], [1456, 1456, 1495, 1495, 1544], [1546, 1546, 1607, 1607, 1904], [1906, 1906, 1929, 1929, 2084], [2086, 2086, 2109, 2109, 2136], [2138, 2138, 2161, 2161, 2545], [2547, 2547, 2570, 2570, 2954], [2956, 2956, 2978, 2978, 3362], [3364, 3364, 3388, 3388, 3721], [3723, 3723, 3757, 3757, 4199], [4201, 4201, 4258, 4258, 5072]]}
{"id": "tllfzB", "name": "The Corner", "author": "Kali", "description": "Fake 3D projection of a \"square cousin\" 2D kaliset fractal with orbit trap coloring.", "tags": ["2d", "fractal", "3dprojection"], "likes": 30, "viewed": 369, "published": "Public", "date": "1597625866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r iResolution.xy\nvec3 f(vec2 p) {\n    p.y+=cos(iTime*.25)*.3; // move camera up and down;\n    p.x=abs(p.x+.3); // offset and mirror x axis\n    p*=mat2(.7,.7,-.7,.7); // rotate ~45deg\n    float y=1.-abs(p.y*3.),l=1.-length(p), m=1e2; // used for: y=horizon, l=light, m=orbit trap\n\tp=fract(vec2(p.x/p.y,1./p.y+iTime*1.*sign(p.y))*.5); // 3D projection, tiling and and forward movement\n    for (int i=0; i<18; i++) p=abs(p*1.5)/(p.x*p.y)-2.,m=min(m,abs(p.y)+abs(.5-fract(p.x*.5+iTime))); // fractal & orbit trap\n    m=exp(-10.*m); // something like inverting and compressing the orbit trap result\n    return mix(min(vec3(1.),vec3(m,m*m,m*m*m)*3.+p.x*p.x*.1),vec3(1,.5,.3),y)+l*l*l*.8; // coloring\n}\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c=vec4(0);\n    vec2 u = (p-r*.5)/r.y,d;\n    // antialiasing\n    for (float i=-4.; i<4.; i++) for (float j=-4.; j<4.; j++) d=vec2(i,j)*.2/r,c.rgb+=f(u+d)/64.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 41, 41, 703], [704, 704, 740, 740, 904]]}
{"id": "tllfzf", "name": "Ray Marching experiments", "author": "illus0r", "description": "Experimenting with this code https://www.shadertoy.com/view/4tcGDr", "tags": ["raymarching"], "likes": 3, "viewed": 215, "published": "Public API", "date": "1597382112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    \n    for (int i = 0; i < 6; i++) {\n        p = abs(p);\n        p += vec3(-0.8);\n        p = p * rotateY(iTime*.3);\n        p = p * rotateX(iTime*.7);\n        p = p * rotateZ(iTime*1.1);\n    }\n    return boxSDF(p, vec3(3.1 + .9 * sin(iTime * 3.)));\n}\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy / 100.;\n    vec3 eye = vec3( 50. * sin(iTime), 50. * cos(iTime), 0.);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 440, 467, 467, 614], [616, 662, 689, 689, 836], [838, 884, 911, 911, 1058], [1060, 1151, 1197, 1197, 1229], [1231, 1315, 1357, 1357, 1389], [1391, 1480, 1527, 1527, 1560], [1562, 1670, 1703, 1703, 2133], [2135, 2222, 2256, 2256, 2284], [2286, 2403, 2448, 2517, 3123], [3139, 3393, 3458, 3458, 3590], [3595, 3922, 3971, 4006, 4137], [4139, 4379, 4403, 4403, 4657], [4660, 4749, 4778, 4778, 5088], [5090, 5582, 5722, 5722, 6312], [6315, 6685, 6770, 6770, 7570], [7574, 7995, 8086, 8086, 8392], [8394, 8394, 8451, 8451, 9401]]}
{"id": "tllfzN", "name": "FBM Tri", "author": "yungdaveboi", "description": "Based on https://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["fbm"], "likes": 2, "viewed": 68, "published": "Public", "date": "1596349013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float powShape(float x) {\n    float x2 = abs(x);\n    x2 *= x2;\n    return 1. - x2;\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\t\n}\n\nfloat sigmoid(float x) {\n    return tanh(x * 2.5);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nfloat fbm(vec2 x, float h, int iter) {\n    float g = exp2(-h);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < iter; i++) {\n        t += a * (-1.0 + 2.0 * noise(x*f));\n        f *= 2.01;\n        a *= g;\n    }\n    \n    return t;\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat fbmH(vec2 x) {\n \treturn fbm(x, 0.9, 5);   \n}\n\nfloat fbmH2(vec2 x) {\n \treturn fbm(x, 0.8, 4);   \n}\n\n// Harmonic Series Inspired Wave Synthesis\n// h_s := half-cycles per second (baseline)\n// gain_ratio := gain bias to tune distribution of normalized gain among frequencies\n// > Essentially, \"How much gain do I want to be allocated to base frequency?\"\n// > 0.5 is a solid default\n// > 0.6 gives g(f1) = 0.6, g(f2) = 0.20, g(f3) = 0.10, g(f4) = 0.05\n// > 0.4 gives g(f1) = 0.4, g(f2) = 0.30, g(f3) = 0.15, g(f4) = 0.08\n// > 0.1 gives g(f1) = 0.1, g(f2) = 0.45, g(f3) = 0.23, g(f5) = 0.12\n// > 0.9 gives g(f1) = 0.9, g(f2) = 0.05, g(f2) = 0.03, g(f1) = 0.01\n// > One can also use values x > 1, x < 0 though you're results might be wonky\n//\n// Total Gain(sum(x)) = 1.0,           for 0 <= gain_ratio <= 1.0\n// Gain g(1) = gain_ratio\n// Gain g(n) = 1.0 - gain_ratio^n      for n > 1\n// Base Freq = cycles_s * 2.0\n// Freq. of r(n) = base_freq * freq_ratio^n\n// sum(x) = E<n> [ g(n) * sin(x * r(n)) ]\nfloat h_synth(float x, float h_s, float freq_ratio, float gain_ratio) {\n    float PI = 3.1416;\n    float gain = gain_ratio;\n    float gain_numerator = abs(1.0 - gain_ratio);\n    float rem_gain = 1.0;\n    // 2 cancels out in 2.0*PI*x\n    // Since c_s is cycles per second\n    // (2 per period)\n    float w = 0.0;\n    float f = h_s;\n    float t = x * PI;\n    \n    for(int i = 1; i < 6; i++) {\n        float n = float(i);\n        w += gain * sin(t * f);\n        rem_gain -= gain;\n        gain = gain_numerator / 2.0;\n        gain_numerator /= 2.0;\n        f = f * freq_ratio;\n    }\n    w += rem_gain * sin(t * f);\n    return w;\n}\n\n/* Normal Distribution Inspired Wave Synthesis ( 100% Faked )\n * Z-score values picked pretty much at random in +0.4 intervals.\n *\n * base_f := Central frequency. In half-cycles per second (location parameter)\n * f_spread := Shape of distribution. 1.00 for default (scale parameter)\n * > Effectively controls the amount of gain at the mean (base frequency).\n * f_ratio := Ratio between base and high/low frequency e.g. ( base f. * 2.0 = high f. )\n */\nfloat norm_synth(float x, float base_f, float f_ratio, float f_spread) {\n    const int LOOP_MAX = 5;\n    float PI = 3.1416;\n    float w = 0.0;\n    float t = x * PI;;\n    float end = abs(base_f * f_ratio);\n    float ztable[6] = float[](\n        0.6554, 0.7881, 0.8849,\n        0.9452, 0.9772, 0.9918\n    );\n    float gdiff = 0.0;\n    for(int i = LOOP_MAX; i >= 0; i--) {\n        float fp = mix(base_f, end, float(i) / float(LOOP_MAX));\n        float fn = 2.0 * base_f - fp;\n        float gain = (1.0 - ztable[i] - gdiff) * f_spread;\n        gdiff += 2.0 * gain;\n        w += gain * sin(t * fp);\n        w += gain * sin(t * fn);\n    }\n    \n    w += (1.0 - gdiff) * sin(t * base_f);\n    return w;\n}\n\nvec2 fish(vec2 uv, float magic) {\n    float theta = atan(uv.y, uv.x);\n    float radius = length(uv);\n    radius = pow(radius, magic);\n    uv.x = radius * cos(theta);\n    uv.y = radius * sin(theta);\n    return 0.5 * (uv + 1.0);\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n    float s1 = h_synth(iTime + 3.145 * 6.0,  0.0410, 1.4,  0.35);\n    float s2 = h_synth(iTime + 3.145,  0.02295, 1.1,  0.50);\n    float s3 = h_synth(iTime + 3.145 / 8.0, 0.03175, 1.05, 0.50);\n    float s4 = h_synth(iTime + 3.145 / 4.0, 0.02265, 1.1,  0.50);\n    /*float s1 = norm_synth(iTime + 3.145 / 4.0 * 5.0,  0.00565, 150.0, 1.0);\n    float s2 = norm_synth(iTime + 3.145 / 8.0 * 10.0, 0.00595, 150.0, 1.0);\n    float s3 = norm_synth(iTime + 3.145 / 8.0 * 20.0, 0.00547, 150.0, 1.0);\n    float s4 = norm_synth(iTime + 3.145 / 4.0 * 30.0, 0.00596, 150.0, 1.0);*/\n \n    //p *= 0.97 + 0.03 * vec2(s1, -1.0 * s2);\n    //p += 0.03 * vec2(s1 * -1.0, s2);\n    \n    //p += vec2(0.29, 0.33);\n    //p = vec2(5.0 * h_synth(p.x, 0.1, 1.2, 0.4), 5.0 * h_synth(p.y, 0.1, 1.2, 0.4));\n    //p = vec2(cos(p.y * 2.0), cos(p.x * 2.0));\n    //p = fish(p, 1.5);\n  \t//p *= vec2(s2, s1);\n    q = 0.5 + 0.5 * vec2(\n        fbmH( p * 4.0 ), // + vec2(0.43, 0.37) * s4),\n        fbmH( p * 4.0 ) //+ vec2(0.35, 0.41) * s3)\n        );\n    \n    r = q * 0.85 + 0.15 * mix(s1, s2, cos(10.0*s3)); ;// + 0.025 * -1.0 * vec2(s3, s4);\n    r = 0.5 + 0.5 * vec2(\n        fbmH2(r * 6.2),// + s4 * vec2(0.29, 0.13)),\n        fbmH2(r * 6.2) // + s3 * vec2(0.14, 0.31))\n        );\n    \n    return fbmH(1.53 * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Pallette\n    /*\n    vec3 col1 = vec3(0.125, 0.251, 0.317);\n    vec3 col2 = vec3(0.231, 0.412, 0.471);\n    vec3 col3 = vec3(0.518, 0.662, 0.674);\n    vec3 col4 = vec3(0.894, 0.890, 0.890);\n    vec3 col5 = vec3(0.965, 0.859, 0.482);\n    */\n    vec3 col1 = vec3(0.952, 0.568, 0.537);\n    vec3 col2 = vec3(0.733, 0.501, 0.509);\n    vec3 col3 = vec3(0.431, 0.458, 0.509);\n    vec3 col4 = vec3(0.015, 0.396, 0.509);\n    vec3 col5 = vec3(0.965, 0.859, 0.482);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // FBM\n\tvec2 q, r;\n    float f = pattern(uv, q, r);\n    \n    // FBM Color Mixing\n    vec3 col = col1;\n    col = mix( col, col2, dot(q, q));\n    col = mix( col, col3, dot(r, q));\n    col = mix( col, col4, f);\n    //col = mix( col, col4, dot(r,r));\n    //col = mix( col, col5, f);\n    \n    \n    // Draw signed distance function (distance to edge)\n    vec2 uv_tri = uv * 4. - vec2(2.);\n    // Triangle Position\n    vec2 uv_t1 = vec2(uv_tri.x - 0.6, uv_tri.y - 0.6);\n    vec2 uv_t2 = vec2(uv_tri.x + 0.6, uv_t1.y + 0.6);\n    vec2 uv_t3 = vec2(uv_tri.x - 0.6, uv_t2.y + 0.6);\n    vec2 uv_t4 = vec2(uv_tri.x + 0.6, uv_t3.y + 0.6);\n    \n    vec4 uv_tir1 = 1.00 * vec4(uv_t1.x , uv_t1.y, 1.0, 1.0) * rotationZ(2.0*3.14/8.0 * iTime * -0.5);\n    vec4 uv_tir2 = 1.50 * vec4(uv_t2.x , uv_t2.y, 1.0, 1.0) * rotationZ(3.14 + 2.0*3.14/8.0 * iTime * 0.5);\n    vec4 uv_tir3 = 1.75 * vec4(uv_t3.x , uv_t3.y, 1.0, 1.0) * rotationZ(3.14 * 1.5 + 2.0*3.14/8.0 * iTime * -0.5);\n    vec4 uv_tir4 = 1.0 * vec4(uv_t4.x , uv_t4.y, 1.0, 1.0) * rotationZ(3.14 * 0.75 + 2.0*3.14/8.0 * iTime * -0.5);\n    uv_t1 = uv_tir1.xy;\n    uv_t2 = uv_tir2.xy;\n    uv_t3 = uv_tir3.xy;\n    uv_t4 = uv_tir4.xy;\n    \n    // SDF\n    float d1 = sdEquilateralTriangle(uv_t1);\n    float d2 = sdEquilateralTriangle(uv_t2);\n    float d3 = sdEquilateralTriangle(uv_t3);\n    float d4 = sdEquilateralTriangle(uv_t4);\n    // Quantize SDF output to [0, 1]\n    float s1 = ceil((1. - sign(d1)) / 2.);\n    float s2 = ceil((1. - sign(d2)) / 2.);\n    float s3 = ceil((1. - sign(d3)) / 2.);\n    float s4 = ceil((1. - sign(d4)) / 2.);\n    float tri_check = floor(s1 + s2 + s3 + s4);\n   \n    if(tri_check > 0.001) {\n        // Mix triangle colors\n        vec3 colsd = col;\n        colsd = mix(colsd, col1, s4);\n        colsd = mix(colsd, col2, s3);\n        colsd = mix(colsd, col5, s2);\n        colsd = mix(colsd, col3, s1);\n        colsd = mix(colsd, col5, pattern(uv * 0.1, r, q) * 0.5);\n        colsd = mix(colsd, col3, (1.0 - pattern(uv * 0.1, r, q)) * 0.1);\n        col = colsd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 84], [86, 86, 120, 120, 253], [255, 255, 289, 289, 428], [430, 430, 464, 464, 601], [603, 603, 627, 627, 655], [657, 657, 684, 684, 791], [794, 794, 820, 820, 1204], [1206, 1206, 1244, 1244, 1467], [1469, 1469, 1511, 1511, 1722], [1724, 1724, 1744, 1744, 1774], [1776, 1776, 1797, 1797, 1827], [1829, 2723, 2794, 2794, 3349], [3351, 3802, 3874, 3874, 4497], [4499, 4499, 4532, 4532, 4727], [4729, 4729, 4776, 4776, 6055], [6057, 6057, 6114, 6363, 8769]]}
{"id": "tllyD4", "name": "Corstiaan.ZebraCircles", "author": "Corstiaan", "description": "Playing with circles\ntrying to make this https://i.imgur.com/251HNu7.mp4", "tags": ["circles"], "likes": 10, "viewed": 118, "published": "Public", "date": "1596314093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.14159265359\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n\nfloat thresh(float base, float val, float blur)\n{\n    return smoothstep(val+(blur/2.), val-(blur/2.), base);\n}\n\nvec4 circle(vec2 uv, vec2 coord, float r, float col)\n{\n    // returns the circle in alpha\n    float mask = thresh(length(coord - uv), r, .005);\n    \n    // black has no border, just return mask in alpha\n    if (col < 0.5)\n        return vec4(vec3(0), mask);\n    else\n    {\n\t    float border = thresh(length(coord - uv), r-.001, .005);\n        return vec4(vec3(border), mask);\n    }\n}\n\nfloat easeOutExpo(float x) { return x == 1. ? 1. : 1. - pow(2., -10. * x); }\nfloat easeOutCube(float x) { return 1. - pow(1. - x, 3.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 R = iResolution.xy, UV = (fragCoord - .5 * R) / R.y;\n    vec3 col = vec3(0.);\n   \n    int amount = 60; // nr of circles\n    float maxSize = 1.4; // size of largest circle\n    float speed = 3.; // speed\n    \n    for(int i=0; i < amount; i++)\n    {\n        float norm = float(i) / float(amount); // 0 - 1 range, linear\n        \n        float cubed = easeOutCube(norm); // 0 - 1 range, cubed\n        float expo = easeOutExpo(norm); // 0 - 1 range, exponential\n        \n        float size = (1. - expo) * maxSize;\n        float t = iTime - cubed * speed;\n       \n        vec2 center = vec2(sin(t * 3.),sin(t * 2.)) * 0.25;\n        vec4 circ = circle(UV, center, size, float(i % 2));\n\n        // 'paint' using alpha channel\n        col = mix(col, circ.xyz, circ.w);\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 125, 125, 186], [188, 188, 242, 277, 571], [573, 573, 601, 601, 649], [650, 650, 678, 678, 709], [711, 711, 768, 768, 1578]]}
{"id": "tlSBDR", "name": "Value Noise 12414", "author": "DrGreencumber", "description": "value noise", "tags": ["noise"], "likes": 1, "viewed": 45, "published": "Public", "date": "1598820310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 pos)\n{\n    return fract(sin(dot(pos, vec2(13.324235f, 73.342523f))) * 39254.346f);\n}\n\nfloat valueNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv * lv * (3.0f - 2.0f * lv);\n    float bl = random(id);\n    float br = random(id + vec2(1.0f, 0.0f));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = random(id + vec2(0.0f, 1.0f));\n    float tr = random(id + vec2(1.0f, 1.0f));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat valueNoise2(vec2 uv, float frequency, int nOctaves)\n{\n    float c = 0.0f;\n    float nDivisions = 0.0f;\n    for (float i=0.0f; i<float(nOctaves); i++)\n    {\n        float divisor = pow(2.0f, -i);\n       \tc += valueNoise(uv * frequency) * divisor;\n        nDivisions += divisor;\n        frequency *= 2.0f;\n\t}\n    return c / nDivisions;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += iTime * 0.1f;\n    float c = valueNoise2(uv, 5.0f, 10);\n    \n    if (c > 0.60f)\n        fragColor = vec4(0.6f, 0.6f, 0.6f, 1.0f);\n    else if (c > 0.45f && c < 0.60f)\n    \tfragColor = vec4(0.0f, 0.6f, 0.0f, 1.0f);\n    else if (c < 0.45f && c > 0.40f)\n        fragColor = vec4(0.6f, 0.6f, 0.0f, 1.0f);\n    else\n        fragColor = vec4(0.0f, 0.0f, 0.6f, 1.0f);\n        \n    //fragColor = vec4(vec3(c), 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSBDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 102], [104, 104, 131, 131, 496], [498, 498, 557, 557, 839], [841, 841, 898, 898, 1357]]}
{"id": "tlsBWX", "name": "0thr's", "author": "entibo", "description": "https://old.reddit.com/r/GeometryIsNeat/comments/id3r87/my_newest_piece_isnt_perfect_or_as_crisp_as_i/", "tags": ["geometry"], "likes": 8, "viewed": 88, "published": "Public", "date": "1597947702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846264338327950288419716\n\nconst float SMOOTH = .005;\nfloat sstep(float v, float t) {\n \treturn smoothstep(v-SMOOTH, v+SMOOTH, t);\n}\n\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat stripe(float v, float freq, float phase) {\n \treturn mod(floor(v/freq - phase*2.), 2.);\n}\nfloat smoothstripe(float v, float freq, float phase) {\n    float t = mod(v/freq - phase*2., 2.);\n    float d = 0.1;\n    return smoothstep(1.-d, 1.+d, t)\n        + (1.-smoothstep(0.-d, 0.+d, t))\n        - smoothstep(2.-d, 2.+d, t);\n}\n\nfloat diamond(vec2 p, float width, float height) {\n    float m = height/width;\n    return sstep(p.y, height-m*abs(p.x))\n        * sstep(-height+m*abs(p.x), p.y);\n}\n#define bidiamond(p,w,h) max(diamond(p,w,h), diamond(vec2(p.y,-p.x),w,h))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = 2.*(fragCoord - .5*iResolution.xy) / minres;\n    uv *= 1.2;\n    \n    \n    float freq = .05;\n    float d = length(uv);\n    \n    float circleShape = sstep(d, 1.);//1. - smoothstep(0.995,1.005, d);\n    \n    float basePattern = smoothstripe(d, freq, 1.0*iTime);\n    \n    float starShape = bidiamond(uv, 0.6, 0.3);\n    \n    \n    float v = mix(basePattern, 1.-basePattern, starShape); // invert the pattern inside the star\n    \n    float a = atan(uv.y, uv.x) + PI; // [0, 2PI]\n    float octant = mod(floor(a/(PI/4.)), 2.); // 0, 1 in each quadrant\n    \n    float m = atan(0.25, 1.0); // slope of the large star\n    \n    float da = (octant == 0. ? -m : +m - PI/2.) // this does one quadrant\n        + floor(a/(PI/2.)) * PI/2.; // repeat for the other 3;\n    \n    float outsidePattern = smoothstripe(rotate(uv, da).y, freq, 1.0*iTime);\n    \n    float bigStarShape = bidiamond(uv, 1.0, 0.25);\n    \n    v = mix(v, outsidePattern, 1.-bigStarShape);\n    \n    v = mix(d, v, circleShape); // make everything outside the circle white\n    \n    \n    v = clamp(v, 0., 1.);\n    \n    \n    v -= max(0., (d-1.)/10.);\n    \n    float range = 0.85;\n    v = mix(.5, v, range);//range*v + (1.-range)/2.;\n    \n    vec3 col = v * vec3(1.0, 0.99, 0.99);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 114, 114, 160], [164, 164, 194, 194, 278], [280, 280, 328, 328, 374], [375, 375, 429, 429, 607], [609, 609, 659, 659, 772], [849, 849, 906, 906, 2231]]}
{"id": "tlsBzS", "name": "Golfing Box Filter - 149 chars", "author": "GregRostami", "description": "Golfing my previous Brute Force Box Filter.\n[url]https://www.shadertoy.com/view/tlffzS[/url]\nI removed one of the two \"for\" loops.\nPlease help me make it smaller ... Thank you.", "tags": ["2d", "onetweet", "golfing"], "likes": 4, "viewed": 240, "published": "Public API", "date": "1597086862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Golfing \"Brute Force Box Filter\" by removing a for loop\n// Hard coded to super sample a pixel 100 times!\n// 163 chars - Fabrice removed 11 chars by MAGIC!\nvoid mainImage(out vec4 O, vec2 U)\n{\n  for( vec2 R = iResolution.xy, u;\n       O.a++ < 1e2;\n       O += max( u = fract(3.*u + .3*iTime), u.x-u) .y / 1e2 )\n     u *= R.y / dot( u = U-.5*R + fract(O.a/vec2(10,100)), u );\n}\n/*\n            \n            \n// 160 chars - My original shader         \n#define mainImage(O,U)                                                            \\\n        for (vec2 R = iResolution.xy, u; O.a++ < 1e2;                             \\\n             u /= dot(u = ((U + vec2( fract(O.a*.1), O.a/1e2) ) - .5*R)/R.y, u))  \\\n                O += max(u=fract(3.*u + .3*iTime),u.x-u).y / 1e2\n*/", "image_inputs": [{"id": "4l23DG", "previewfilepath": "https://soundcloud.com/farooq-saeed-khan/inception-theme-hans-zimmer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/farooq-saeed-khan/inception-theme-hans-zimmer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 194, 194, 378]]}
{"id": "tlsfDf", "name": "descompuesto apollonian-v5", "author": "jorge2017a1", "description": "descompuesto apollonian-v5", "tags": ["descompuestoapollonianv5"], "likes": 4, "viewed": 97, "published": "Public", "date": "1597978315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n\n// Created by inigo quilez - iq/2013---\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\nfloat tau = atan(1.0) * 8.0;  \n\n///==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{ return min(d1,d2);  }\n\nfloat opS( float d1, float d2 )\n{  return max(-d1, d2);}\n\nfloat opI( float d1, float d2 )\n{ return max(d1,d2);  }\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n///==== Distance field operators/functions by iq. ====\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n    vec3 pp=p;\n\torb = vec4(1000.0); \n    \n    float dps=0.5;\n\t\n    \n    \n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t\n        float sdc1= sdSphere( p-vec3(0.0,0.8,0.0), 3.0 );\n        p = -1.0 + 2.0*fract(0.5*p+0.5+float(i));\n        \n        float r2 = dot(p,p);\n\t\tr2= opI( r2, sdc1 );\n        \n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n        float k = 1.7/(r2);\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n    return 0.23*abs(p.x)/scale;\n   \n}\n\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.4,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(1.0,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.01,0.02), clamp(6.0*tra.y,0.0,1.0) );\n      \n        rgb = mix( rgb, vec3(0.0,1.0,0.5), pow(clamp(1.0-2.0*tra.x,0.0,1.0),8.0) );\n        \n\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.0 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[411, 466, 499, 499, 521], [523, 523, 556, 556, 579], [581, 581, 614, 614, 636], [638, 666, 707, 707, 800], [801, 857, 893, 893, 996], [999, 999, 1034, 1034, 1058], [1062, 1062, 1092, 1092, 1549], [1552, 1552, 1600, 1600, 1853], [1855, 1855, 1911, 1911, 2162], [2164, 2164, 2218, 2232, 3232], [3234, 3234, 3291, 3291, 4294], [4296, 4296, 4390, 4390, 4617]]}
{"id": "tlsfDj", "name": "noise_sculpture_2", "author": "TRASHTRASH", "description": "8.12.20\ndaily GLSL exercise", "tags": ["raymarching", "shader", "vj", "trashtrash"], "likes": 1, "viewed": 66, "published": "Public", "date": "1597800857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH is Josh deLorimier 8.14.20\n//thanks BigWIngs, evvvvil for your tutorials\n#define MAX_STEPS 128\n#define MAX_DIST 10.\n#define SURF_DIST 0.001\n\n//simplex noise from Patricio Gonzalez Vivo\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0);} \n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//mercury------------------- \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat box(vec3 p, vec3 b) {\n    return vmax(abs(p)-b);\n}\n//--------------------------\nfloat smin(float d1, float d2, float k){\n \tfloat h = max(k-abs(d1-d2),0.0);\n    return min(d1,d2)-h*h*0.25/k;\n}\n\n\nfloat smax(float d1, float d2, float k) {\n \tfloat h = max(k-abs(-d1-d2),0.); \n    return max(-d1,d2)+h*h*0.25/k;  \n}\n\nfloat map(vec3 p) {\n\tfloat n1 = snoise(p.xy+iTime);\n    float n2 = snoise(p.yx+iTime+0.5);\n    \n    float n3 = abs(snoise(vec2(p.x,iTime)*2.));\n    float b = box(p-vec3(0.,0.,5.),vec3(8.,4.,5.));\n\tfloat s1 = length(p-(vec3(-2.,n1,0.)/1.3))-3.5;\n    float s2 = length(p-(vec3(2.,n2,0.)/1.3))-3.5;\n    float m = smin(s1,s2,2.);\n    return max(-m, b);\n}\n\nfloat RM(vec3 ro, vec3 rd) {\n \tfloat t = 0.;\n    for(int i = 0;i<MAX_STEPS;i++) {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        \n        if(t > MAX_DIST || abs(s) < (SURF_DIST)) break;\n        t+=s;\n        \n      }\n   return t;\n}\n\n\nvec3 norm(vec3 p) {\n \tfloat d = map(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat shade(vec3 p, vec3 rd) {\n \tvec3 lp = vec3(6,6.,-5.);\n    vec3 l = normalize(lp -p);\n    vec3 n = norm(p);\n    float dif = clamp(dot(n,l),0.,.4);\n  \tfloat fr = pow(1.0+dot(n, rd),4.0);\n   \tfloat ao = (1.0 - fr);\n   \treturn max(fr,0.4)+dif*ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord -0.5 * iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., -6.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 col = vec3(0.);\n    vec3 c1 = vec3(.5,0.2,0.)*2.;\n    float d = RM(ro, rd);\n    if(d<MAX_DIST) {\n    vec3 p = ro + rd *d;\n    vec3 c1 = vec3(1.0,0.4,0.7)+snoise(p.yy+iTime);\n  \t\n    float dif = shade(p, rd);\n   \tcol = vec3(dif)*c1;\n   \tcol*=col*col;\n    }\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 198, 220, 220, 258], [261, 261, 283, 283, 1103], [1104, 1134, 1154, 1154, 1189], [1191, 1191, 1218, 1218, 1247], [1248, 1277, 1317, 1317, 1388], [1391, 1391, 1432, 1432, 1507], [1509, 1509, 1528, 1528, 1859], [1861, 1861, 1889, 1889, 2105], [2108, 2108, 2127, 2127, 2269], [2271, 2271, 2301, 2301, 2520], [2523, 2523, 2580, 2580, 3054]]}
{"id": "tlSfDz", "name": "Circle.iamthebest", "author": "DrRedcumber", "description": "beeg surcul", "tags": ["surcul"], "likes": 1, "viewed": 32, "published": "Public", "date": "1598652467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 uv = fragCoord / iResolution.xy; \n    \n    float x = fragCoord.x; \n    float y = fragCoord.y; \n    \n    float r = sin(iTime); \n    float g = cos(iTime); \n    float b = 1.0 - sin(iTime); \n    \n    float r1 = 1.0 - sin(iTime); \n    float g1 = sin(iTime); \n    float b1 = cos(iTime); \n    \n    vec2 cc = vec2(400.0, 225.0); \n    float rad = 100.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(uv.x+ r,uv.y+ g, b, 1.0); \n    else \n        fragColor = vec4(uv.x+ r1,uv.y+ g1, b1, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 594]]}
{"id": "tlSfR1", "name": "Cacarisse's", "author": "entibo", "description": "https://old.reddit.com/r/loadingicon/comments/hnjp3p/kaleidoscopic_prism/", "tags": ["2d"], "likes": 5, "viewed": 66, "published": "Public", "date": "1598348892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265\n\nfloat pix;\n#define S(v) smoothstep(-pix, pix, v )\n\nfloat speed = 2.0;\n\n\nfloat diamond(vec2 p, float width, float height) {\n    float m = height/width;\n    return S(height-m*abs(p.x) - abs(p.y));\n}\n\nfloat cacarisse(vec2 p) {\n    float t = cos(iTime*speed);\n    t = sign(t)*pow(abs(t),1.8); // This line slows it down in the \"nested hexagon\" part\n    \n    float v = diamond(p+vec2(t/3.,0.), 1., 1./sqrt(3.));\n    v *= S(-abs(p.x-t/6.)+.5); // Cut-off on each side\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = 2.*(fragCoord - .5*iResolution.xy) / minres;    \n    \n    uv = vec2(-uv.y, uv.x); // Rotate 90°\n    \n    float v = 0.;\n    for(float k=0.; k < 4.; k++) {\n        float dir = mod(k,2.)==0. ? 1. : -1.;\n        float scale = pow(2., k); // Size is halved with each iteration\n        pix = 2.*scale/minres; // Adjust the anti-aliasing\n        vec2 p = uv * scale * vec2(dir, 1.); // Scale and mirror\n        v += dir*cacarisse(p);\n    } \n    \n    fragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 146, 146, 220], [222, 222, 247, 247, 501], [503, 503, 560, 560, 1095]]}
{"id": "tlsfWf", "name": "17. Using Polar Coordinates _ Op", "author": "altera0", "description": "Source Link : https://www.youtube.com/watch?v=r1UOB8NVE8I\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect\n\nI understand it ! ", "tags": ["usingpolarcoordinates"], "likes": 1, "viewed": 171, "published": "Public API", "date": "1597971453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 u )\n{ \n    vec2  R = iResolution.xy,\n          U = u - .5 *R;\n    \n    float l = length(U)/R.y,\n          a = atan(U.x , U.y ),\n          s = 8.*( a/6.2831  + iTime*.1 + l*2. );\n    \n    float m = min( fract(s) , fract(1.-s) ),\n          v = m * .3 + .1 - l;\n\n    O = vec4(smoothstep( -.7, .7 , v/fwidth(v) ) );\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 347]]}
{"id": "tlsfzs", "name": "Giza pyramids at sunset", "author": "hedyla2055", "description": "A simple 2d silhouette for Giza pyramids and some palm trees during sunset.\nOriginally, based on sunset shader by IQ: https://www.shadertoy.com/view/XssSRX but with some tweaks for the palm trees.\nOf course, open to feedback.", "tags": ["2d", "painting"], "likes": 4, "viewed": 165, "published": "Public", "date": "1598124357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 SUN = vec4(1.0, 0.870, 0.482, 1.0);\nconst vec4 SKY = vec4(0.525,0.78,0.86, 1.0);\nconst float PI = 3.14159265359;\n\n\nvoid PalmTree(inout vec4 col, vec2 p, vec2 c, float size, float leaf_count, \n               float orientation, float band, float leaf_size, \n              float trunk_width, float trunk_curve)\n{\n    // leaves\n    vec2 q = p - c;    \n    float r = size + leaf_size * cos(atan(q.x, q.y) * leaf_count - band * q.x + orientation);\n    col *= smoothstep(r, r + 0.02, length(q));\n    \n    // trunk\n    r = trunk_width * (1. + abs(sin(12. * q.y)));\n    r += 0.0015 * exp(-80. * p.y / 68.5); // the thick part at the end\n    col *= 1.0 - (1.0 - smoothstep(r, r + 0.02, abs(q.x + trunk_curve * sin(0.4 * q.y))) + 0.01)\n        * (1.0- smoothstep(0., 0.01, q.y));\n}\n\nvoid Pyramid(inout vec4 col, vec2 p, vec2 c, float h)\n{\n    // We are in 2D world, so a triangle will be used. \n\tp -= c;\n    p /= 9.0;\n    p.x /= 2.0;\n    int N = 3;\n    float a = (atan(p.x, p.y) + PI);\n    float r = 2.0 * PI/ float(N) ;\n    float d = cos(floor(0.5 + a / r) * r - a) * length(p);\n    col *= smoothstep(0.101, 0.102, d / h); \n}\n                                                                               \nvoid mainImage(out vec4 col, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;      \n    col = mix(SKY, SUN, (1.0 - uv.y * vec4(0.8, 0.8, 1.0, 1.0)) * 0.5);\n\n    uv *= 9.0;\n       \n    Pyramid(col, uv, vec2(0., -5.5), 2.8);\n\n    Pyramid(col, uv, vec2(3.7, -5.5), 2.2);\n\n    Pyramid(col, uv, vec2(-4., -5.5), 1.7);\n    \n\tPalmTree(col, uv, vec2(-3.0, 2.7), 0.7, 13., \n             0.7 * cos(iTime), 4.5, -1.2, 0.06, -1.5);\n\n \tPalmTree(col, uv, vec2(-5.5, 0.7), 0.3, 17., \n             0.5 * sin(iTime), 5.5, -1.9, 0.08, 1.8);   \n    \n    PalmTree(col, uv, vec2(4.8, 1.7), 0.6, 18., \n             1.1 * cos(iTime / 3.0), 8.0, -0.9, 0.06, -.5);\n\n    PalmTree(col, uv, vec2(6.3, 3.1), 0.8, 21., \n             1.1 * cos(iTime), 8.0, -0.9, 0.05, .5);\n    \n    PalmTree(col, uv, vec2(0.9, 2.2), 0.6, 14.,\n             0.9 * cos(iTime), 4.0, -0.9, 0.05, .6);\n\n    PalmTree(col, uv, vec2(-1.3, 0.5), 0.6, 14.,\n             0.9 * cos(iTime), 8.0, -0.7, 0.04, -.75);\n\n    PalmTree(col, uv, vec2(3.3, 3.3), 0.4, 9.,\n             0.5 * cos(iTime), 5.0, 0.6, 0.06, -.35);\n\n    PalmTree(col, uv, vec2(-7.3, 3.3), 0.8, 9.,\n             0.9 * sin(iTime), 5.0, -0.6, 0.06, 1.25);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 320, 334, 781], [783, 783, 838, 894, 1126], [1207, 1207, 1257, 1257, 2409]]}
{"id": "tlXBD4", "name": "Flower tunnel", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1291344713916616710", "tags": ["2tweets"], "likes": 20, "viewed": 261, "published": "Public", "date": "1596716992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tfloat i,g,e,s,l;\n    vec3 p,q;\n    for(i=0.;++i<50.;){\n        vec3 p=g*normalize(vec3((C-.5*iResolution.xy)/iResolution.y,1))\n        \t+vec3(1,1,iTime);\n        q=p;\n        s=1.;\n        for(int j=0;j++<4;)\n            p=mod(p-1.,2.)-1.,\n            l=2./dot(p,p),\n            p*=l,\n            s*=l;\n        g+=e=length(p.xy)/s;\n        if(e<.003)break;\n\t}\n    O.xyz+=cos(q*.3)*9./i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 426]]}
{"id": "tlXBRl", "name": "Raymarching - Soft Shadows", "author": "athibaul", "description": "An experiment of using raymarching to render soft shadows in a scene by marching toward the light.", "tags": ["raymarching", "illumination", "lighting", "softshadows"], "likes": 9, "viewed": 505, "published": "Public", "date": "1597421761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Experimenting with soft cast shadows in raymarching\n//\n// After the standard raymarching loop,\n// illumination is computed using a modified raymarching loop,\n// to detect whether there is any obstruction between\n// the point and the light source.\n// By detecting positive and negative values of the\n// distance field close to zero, a relative\n// occlusion value is computed, resulting in soft shadows.\n\n\n//#define SHOW_OBSTRUCTION // Uncomment to show the obstruction detection only\n\n\nvec3 bands(float x)\n{\n    // Debug function for displaying orange/blue bands for positive/negative numbers.\n    float y = x*5.;\n    vec3 cp = vec3(0.7,0.5,0.1);\n    vec3 cm = vec3(0.1,0.5,0.7);\n    if(y>0.){ if(y-floor(y)<0.5) return cp; return 0.8*cp; }\n    if(y-floor(y)<0.5) return cm; return 0.8*cm;\n}\n\nvec3 colorPattern(vec3 p)\n{\n    //vec3 q = p/length(p);\n    //vec3 col = bands(q.x) + bands(q.y) * bands(q.z);\n    vec3 col = vec3(1.);\n    return col;\n}\n\nfloat sphereSDF(vec3 pos)\n{\n    // Repeating pattern of spheres\n    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);\n    turned = 6.0*round(turned/6.0);\n    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;\n    /*pos.x -= 3.*round(pos.x/3.);\n    if(pos.y>-1.5)\n        pos.y -= 3.*round(pos.y/3.);\n\t*/\n    pos.xy -= turned.xy;\n    return length(pos-vec3(0.,0.,1.))-1.;\n}\n\nfloat planeSDF(vec3 pos)\n{\n    // Bottom plane\n    return pos.z+0.4;\n}\n\nfloat floorSDF(vec3 pos)\n{\n    // Just a few tiles\n    // Rounded box distance function by iq\n    // https://www.youtube.com/watch?v=62-pRVZuS5c\n    pos.xy -= 3.*round(pos.xy/3.);\n    vec3 c = vec3(0., 0., -0.2);\n    float rounded = 0.1;\n    vec3 r = vec3(0.75, 0.75, 0.2)-rounded;\n    vec3 q = abs(pos - c) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n}\n\nfloat cubeSDF(vec3 pos)\n{\n    // One more box..?\n    vec3 c = vec3(0., -2., 0.3);\n    float rounded = 0.1;\n    vec3 r = vec3(0.5, 0.5, 0.3)-rounded;\n    vec3 q = abs(pos - c) - r;\n    //return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n    return 1000.; // Nah.\n}\n\nfloat sceneSDF(vec3 pos)\n{\n    return min(min(sphereSDF(pos), cubeSDF(pos)), min(planeSDF(pos), floorSDF(pos)));\n}\n\n\nvec3 calculateNormal(vec3 pos)\n{\n    // Tetrahedral normal calculation method by iq\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * sceneSDF(pos+e.xxx)\n            + e.xyy * sceneSDF(pos+e.xyy)\n            + e.yxy * sceneSDF(pos+e.yxy)\n            + e.yyx * sceneSDF(pos+e.yyx));\n}\n\nvec3 rayDir(vec3 camFwd, float fov, vec2 uv)\n{\n    // In what direction to shoot?\n    vec3 camUp = vec3(0.,0.,1.);\n    camUp = normalize(camUp - camFwd*dot(camFwd, camUp)); // Orthonormalize\n    vec3 camRight = cross(camFwd, camUp);\n    return normalize(camFwd + (uv.x * camRight + uv.y * camUp)*fov);\n}\n\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*0.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = sceneSDF(pos + t*toLight);\n        obstruction = max(0.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // uv.y goes between +-1, and uv.x a bit more depending on the display format.\n\n    // Camera ray\n    vec3 ro = vec3(0., -8., 3.0);\n    vec3 ri = rayDir(normalize(vec3(0.,0.,1.)-ro), 0.5, uv);\n\n    // Normal raytracing\n    float d, t=0.;\n    int cause = -1;\n    int j;\n    for(j=0; j<128; j++)\n    {\n        d = sceneSDF(ro + t*ri);\n        if(d<0.001){break;}\n        if(d>1000.){t=1000.; break; }\n        t += d; // Should be a real metric, otherwise put a *.5 or so here\n    }\n    vec3 pos = ro + t*ri;\n    vec3 normal = calculateNormal(pos);\n    \n    // Compute lighting by marching again to detect obstruction\n    vec3 lpos = vec3(4.*cos(iTime*0.5), 4.*sin(iTime*0.5), 4.*(1.-0.5*cos(iTime*2.)));\n    float lightRadius = 0.6;\n    float lightStrength = 20.0;//length(lpos)*length(lpos);\n    float obstruction = calculateObstruction(pos, lpos, lightRadius);\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float diffuse = max(dot(normal, toLight), 0.)\n        /(distToLight*distToLight)\n        *lightStrength;\n    \n    float level = diffuse*(1.-obstruction);\n    vec3 col = level * colorPattern(pos);\n    // Tone mapping\n    col = 1.-exp(-2.*col);\n    \n    // Output to screen\n    #ifndef SHOW_OBSTRUCTION\n    fragColor.rgb = vec3(col);\n    #else\n    fragColor.rgb = vec3(1.-obstruction);\n    #endif\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 488, 509, 595, 793], [795, 795, 822, 905, 948], [950, 950, 977, 1013, 1324], [1326, 1326, 1352, 1372, 1396], [1398, 1398, 1424, 1542, 1788], [1790, 1790, 1815, 1838, 2075], [2077, 2077, 2103, 2103, 2191], [2194, 2194, 2226, 2277, 2489], [2491, 2491, 2537, 2572, 2794], [2796, 2796, 2857, 3223, 3764], [3766, 3766, 3823, 3823, 5276]]}
{"id": "tlXBz2", "name": "P.Gerdes & Tchokwe sand drawing6", "author": "FabriceNeyret2", "description": "For not mid-radius, closer to the spirit of sand drawings. tough part: handle large radius range.\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 10, "viewed": 235, "published": "Public API", "date": "1597170635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/tlXBRS\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99., j,                 // edge id (float)\n          r = fract(4e4*sin(i)),                     // rand(id)\n          t = 2.*fract(iTime/4.),\n          k = .4+ 1.2* min(t,2.-t);\n    I = mod(floor(U),2.); if (I.x==I.y) k = 2.-k;    // for not mid-radius, closer to the spirit of sand drawings    \n    \n    O.gb -= r < .5\n        ? f = abs( abs(F) - .353*k ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        :(                           \n          i = abs( length(F) - .353*k ),             // )( at edge\n          j = k<1. && r>=.5                          // handle overlapping of neighbor large radius \n                ? abs( length(.71*sign(F+1e-5)-F) - .353*(2.-k) ) \n                : 1.,\n          S( i -.1 ) * s(i)\n        + S( j -.1 ) * s(j) );\n            \n\n  //O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 185, 223, 223, 1610]]}
{"id": "tlXfDS", "name": "Mandala: Art Of Code", "author": "nixaboo", "description": "Messing around with a few techniques I learned in Art Of code \n", "tags": ["mandalaartofcode"], "likes": 8, "viewed": 110, "published": "Public", "date": "1597590522", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 COLOR_OUTLINE = vec3(0.);\nvec3 COLOR_1 = vec3(.807, .517, .678);\nvec3 COLOR_2 = vec3(0.807, 0.588, 0.650);\nvec3 COLOR_GREEN = vec3(0.698, 0.792, 0.568);\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\nconst float pi2 = 6.2831;\nconst float pi = 3.1415;\n\n#define S(a,b,c) smoothstep(a,b,c)\n\nmat2 Rot(float a) { \n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 Circle(vec2 uv, vec3 color, float r, float blur) { \n    float d = length(uv);\n    float a = S(r, r - blur, length(uv));\n    return vec4(color, a);    \n}\n\n\nfloat RectByWidth(vec2 uv, float wb, float wt, float h, float edge) {\n    \n    float width = (wt - wb) * (h - uv.y)/h;\n    float x1 = (width * .5);\n    float x2 = -width * .5; //wb at y = 0, and wt at y = wt        \n    float y1 = h;\n    float y2 = 0.;\n        \n    float x = S(x1 - edge, x1, uv.x) * S(x2, x2-edge, uv.x);\n    float y = S(y1, y1-edge, uv.y) * S(y2, y2+edge, uv.y);\n    \n    return x*y;\n}\n\nfloat Rect(vec2 uv, float x1, float y1, float w, float h, float edge) {\n    \n    float x2 = x1 + w;\n    float y2 = y1 - h;\n    \n    float x = S(x1 - edge, x1, uv.x) * S(x2, x2-edge, uv.x);\n    float y = S(y1, y1-edge, uv.y) * S(y2, y2+edge, uv.y);\n    \n    return x*y;\n}\n\nvec4 Flower(vec2 uv, vec2 pos, float angle, vec3 baseColor, float yScale) {             \n    uv -= pos;\n    uv *= Rot(angle);    \n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    uv = vec2(st.x / 6.2831+.5, st.y); //x will be 0 to 1 from bottom to bottom going clockwise \n                                       //y will be the distance from the center \n    uv.y *= yScale;\n    \n    float x = uv.x * 5.; //you go from 0 to 1\n    \n    float id = floor(x);\n    float m = min(fract(x), fract(1.-x)); //assuming going from 0 to 1 it will give it a num\n                                          //going from 0 to .5 and then back to .0\n                                          \n    float s = max(((m+.3) - uv.y), 0.); // * (id == 2. ? 1. : 0.);    \n    float c = smoothstep(.0, .01, s);\n    \n    return vec4(baseColor, c); //played with this to get a leaf I like\n}\n\n\nvec4 DrawCenterCircle(vec2 uv) { \n    vec4 color = vec4(0.);\n    vec4 center_bg = Circle(uv, vec3(0., 0., 0.), .22, .004);\n    vec4 center = Circle(uv, COLOR_1, .2, .004);\n    \n    color = mix(color, center_bg, center_bg.a);\n    color = mix(color, center, center.a);\n    \n    return color;\n}\n\nvec4 DrawRects(vec2 uv, float count, vec3 baseColor, float dist, float startAngle) { \n    vec4 col = vec4(0.);    \n    \n    for(float d = 0.; d < pi2; d+= pi2/count) {        \n        vec2 pos = uv;\n\n        pos -= vec2(sin(startAngle + d), cos(startAngle+ d)) * dist;\n        pos = pos * Rot(1./4. * pi + d + startAngle + 0.02);\n        \n        vec4 rect = vec4(baseColor, Rect(pos, -.2, .2, .3, .3, .01));\n        col = mix(col, rect, rect.a);\n    }\n    \n    return col;\n}\n\nvec4 DrawTriangles(vec2 uv, float count, vec3 baseColor, float dist, float startAngle) { \n    dist = 1.21;\n    startAngle += 0.26;\n//    float r = RectByWidth(uv, 1., .0, 1., 0.01);\n//    col = mix(col, vec4(.5, .5, .5, r), r); \n    vec4 col = vec4(0.);\n    for(float d = 0.; d < pi2; d+= pi2/count) {        \n        vec2 pos = uv;\n\n        pos -= vec2(sin(startAngle + d), cos(startAngle+ d)) * dist;\n        pos = pos * Rot(d - 0.405);\n        \n        vec4 rect = vec4(baseColor, RectByWidth(pos, .28, .0, .3 + sin(iTime)*.03, .02));\n        col = mix(col, rect, rect.a);\n    }\n    \n    return col;\n}\n\nvec4 DrawCircles(vec2 uv, float count, vec3 baseColor, float dist, float radius, float startAngle) { \n    vec4 col = vec4(0.);    \n    \n    for(float d = 0.; d < pi2; d+= pi2/count) {        \n        vec2 pos = uv;\n\n        pos -= vec2(sin(startAngle + d), cos(startAngle+ d)) * dist;\n        \n        vec4 rect = Circle(pos, baseColor, radius, .01);\n        col = mix(col, rect, rect.a);\n    }\n    \n    return col;\n}\n\nvec4 DrawHalfCircles(vec2 uv, float count, vec3 baseColor, float dist, float bigR, float lilR, float startAngle) { \n    vec4 col = vec4(0.);    \n    \n    for(float d = 0.; d < pi2; d+= pi2/count) {        \n        vec2 pos = uv;\n\n        pos -= vec2(sin(startAngle + d), cos(startAngle+ d)) * dist;\n        pos *= Rot(d + 1./4. * pi  + sin(iTime)*2.);\n        vec4 c1 = Circle(pos, baseColor, bigR, .01);\n        vec4 c2 = Circle(pos, baseColor, lilR, .01);\n        \n        float rect = Rect(pos, -bigR, 0., bigR * 2., bigR, .005);\n        \n        col = mix(col, c1, c1 * (1. - c2.a) * (1. - rect));\n    }\n    \n    return col;\n}\n\n\nvec4 DrawLeaves(vec2 uv, float leafCount, vec3 leafColor, float scale, float yScale) { \n    vec4 col = vec4(0.);    \n    \n    float leafDistanceScale = 0.;\n    float d = 0.;\n//    for(float d = 0.; d < pi2; d+= pi2/1.) {        \n        vec2 pos = uv;\n        \n        vec4 flower = Flower(pos * scale, vec2(sin(d), cos(d)) * leafDistanceScale, d, leafColor, yScale);\n        vec4 flower_outline = Flower(pos * (scale * .9), vec2(sin(d), cos(d)) * leafDistanceScale, d, vec3(0., 0., 0), yScale);\n\n        col = mix(col, flower_outline, flower_outline.a);\n        col = mix(col, flower, flower.a);\n//    }\n    \n    return col;\n}\n\nfloat sin01(float time) { \n    return sin(time)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    uv *= 3.3;    \n    \n    vec4 col = vec4(1.);    \n    \n    \n    vec4 half_circles_1 = DrawHalfCircles(uv , 5., vec3(.6, .3, .3), 1.25 +  + sin01(time - pi)*.15, .25, .17, 0.63);\n    \n    vec4 triangles_1 = DrawTriangles(uv, 5., COLOR_GREEN, 1., 0.);\n    \n    vec4 circles_1 = DrawCircles(uv , 5., vec3(.5, .2, .2), 1.25 + sin01(time - pi)*.15, .14, 0.63 );\n    \n    vec4 diamonds_1 = DrawRects(uv, 5., vec3(0.), .85 + sin01(time - pi)*.15, 0.369);\n    vec4 diamonds_2 = DrawRects(uv, 5., vec3(0.), .85 + sin01(time - pi)*.15, 0.369 + 0.519);\n    \n    vec4 leaf_1 = DrawLeaves(uv , 7., COLOR_2, 1., 1. + + sin01(time)*.2);\n    vec4 leaf_2 = DrawLeaves(uv * Rot(2./4. * pi2) , 10., COLOR_GREEN, .8, 1. + sin01(time)*.1);\n    vec4 leaf_3 = DrawLeaves(uv * Rot(4./4. * pi2) , 10., COLOR_GREEN, .7, 1. + + sin01(time)*.05);\n\n\n    col = mix(col, half_circles_1, half_circles_1.a);\n    \n    float a = S(1., .8, sin01(time - pi));\n    col = mix(col, triangles_1, triangles_1.a - a);\n    col = mix(col, circles_1, circles_1.a);\n//    col = mix(col, circles_2, circles_2.a);\n    \n    col = mix(col, diamonds_1, diamonds_1.a);\n    col = mix(col, diamonds_1, diamonds_2.a);\n    \n    col = mix(col, leaf_3, leaf_3.a);\n    col = mix(col, leaf_2, leaf_2.a);\n    col = mix(col, leaf_1, leaf_1.a);\n    \n    vec4 center = DrawCenterCircle(uv);\n    col = mix(col, center, center.a);\n\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 303, 303, 370], [373, 373, 428, 428, 530], [533, 533, 602, 602, 937], [939, 939, 1010, 1010, 1209], [1211, 1211, 1286, 1286, 2075], [2078, 2078, 2110, 2110, 2369], [2371, 2371, 2455, 2455, 2846], [2848, 2848, 2936, 2936, 3452], [3454, 3454, 3554, 3554, 3871], [3873, 3873, 3987, 3987, 4503], [4506, 4506, 4592, 4592, 5133], [5135, 5135, 5160, 5160, 5191], [5193, 5193, 5250, 5250, 6733]]}
{"id": "tlXfRM", "name": "v3Discs4.glsl", "author": "jorge2017a1", "description": " keijiro /ShaderSketches \nhttps://github.com/keijiro/ShaderSketches/blob/master/Fragment/Discs2.glsl", "tags": ["v3discs4glsl"], "likes": 6, "viewed": 55, "published": "Public", "date": "1596314654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 palette(float z)\n{\n    float g = 0.6 + 0.4 * sin(z * 8.0 + iTime * 2.0);\n    float b = 0.5 + 0.4 * sin(z * 5.0 + iTime * 3.0);\n    return vec3(1, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = iResolution.y / 5.0;\n    vec2 p = fragCoord.xy / scale;\n\n    vec2 offs1 = vec2(iTime * 0.53, sin(iTime * 1.35) * 0.2);\n    vec2 offs2 = vec2(iTime * 0.81, sin(iTime * 1.19) * 0.2);\n\n    vec2 p1 = p + offs1;\n    vec2 p2 = p + offs2 - 0.5;\n\n    float z1 = rand(0.19 * floor(p1));\n    float z2 = rand(0.31 * floor(p2));\n\n    p1 = fract(p1) - 0.5;\n    p2 = fract(p2) - 0.5;\n\n    float s1 = 0.9 + sin(iTime * (0.6 + z1)) * 0.6;\n    float s2 = 0.9 + sin(iTime * (0.6 + z2)) * 0.6;\n\n    float d1 = (0.25 - abs(0.5 - fract(length(p1) * s1 * 10.0 + 0.26))) / (s1 * 10.0);\n    float d2 = (0.25 - abs(0.5 - fract(length(p2) * s2 * 10.0 + 0.26))) / (s2 * 10.0);\n\n    vec3 c1 = palette(z1) * saturate(d1 * scale);\n    vec3 c2 = palette(z2) * saturate(d2 * scale);\n\n    float a1 = saturate((0.5 - length(p1)) * scale);\n    float a2 = saturate((0.5 - length(p2)) * scale);\n\n    vec3 c1on2 = mix(c2 * a2, c1, a1);\n    vec3 c2on1 = mix(c1 * a1, c2, a2);\n\n    fragColor = vec4(mix(c2on1, c1on2, step(z1, z2)), 1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 54], [56, 56, 77, 77, 147], [149, 149, 172, 172, 308], [310, 310, 367, 367, 1383]]}
{"id": "tlXfWj", "name": "Colorful Wave", "author": "linhow", "description": "sin colorful wave", "tags": ["simplewave"], "likes": 1, "viewed": 29, "published": "Public", "date": "1597725486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    if(uv.y<0.5*(1.0+0.5*sin(iTime+5.0*uv.x))+0.5*sin(iTime))\n    fragColor = vec4(col,1.0);\n    else  fragColor = vec4(0.5,0.9,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 401]]}
{"id": "tt2BzW", "name": "[TWITCH] Landmass z-morph", "author": "evvvvil", "description": "Landmass z-morph - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["mix", "terrain", "demoscene", "glow", "transition", "organic", "world", "dark", "morphing", "mountain", "lazer", "cathedral", "monument"], "likes": 22, "viewed": 1136, "published": "Public API", "date": "1598452487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Landmass z-morph - Result of an improvised live coding session on Twitch\n// Thankx to zblll, 5jeesus, stobeee and others for the ideas\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,mixer,g;vec3 np,modP,op,po,no,al,ld;\nfloat bo(vec3 p,vec3 r) {p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nfloat smax( float d1, float d2, float k ){  float h = max(k-abs(-d1-d2),0.0);return max(-d1,d2)+h*h*0.25/k; }\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 fbAngular( vec3 p )\n{\n    float mMix=mix(2.,1.,clamp(mixer,.5,1.)*2.-1.);//MATERIAL ID MIXER\n    vec2 h,t=vec2(bo(p,vec3(21,.5,.5)),mMix); \n    h=vec2(bo(p,vec3(20.8,.3,.7)),2.+mMix); \n    h.x=min(h.x,bo(p,vec3(20.6,.9,.1)));\n    t=t.x<h.x?t:h;\n    h=vec2(bo(p,vec3(20.8,.7,.3)),1); \n    p.x=mod(p.x,3.)-1.5;\n    h.x=min(h.x,length(p.xy)-.15+abs(p.z)*.1);\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 mp( vec3 p )\n{   \n    op=modP=p; //SCENE 1 ANGULAR SCENE\n    mixer=clamp(sin(tt*.65+p.z*.1),-.5,.5)+.5; //OVERALL SCENE MIXER \n    modP.z=mod(modP.z+tt*2.,40.)-20.; \n    np=modP; \n    for(int i=0;i<5;i++){\n        np.xz=abs(np.xz)-vec2(3.5,2);\n        np.xz*=r2(.785);\n        np.yz*=r2(-sin(-p.y*.1 )*.1);\n    }  \n    vec2 h,scene1=fbAngular(np);  \n    np.xz+=1.2;\n    np.xy*=r2(.785*2.);  \n    h=fbAngular(np*1.5); h.x/=1.5;\n    scene1=scene1.x<h.x?scene1:h;  \n    np.xz*=r2(-.785*2.);\n    np.x+=4.;\n    h=fbAngular(abs(np*.5)-vec3(0,0,5)); h.x/=.5;\n    scene1=scene1.x<h.x?scene1:h;\n    scene1.x*=0.8;  //SCENE 2 ORGANIC SCENE    \n    float tnoi=texNoise((p.xz+vec2(0,tt*2.))*.02).r*1.5; \n    float tDisp=sin((p.z+tt*2.)*.5+p.x*.2);\n    p.y+=tDisp;\n    vec2 scene2 =vec2(p.y+5.+tnoi*5.,1.); //TERRAIN  \n    scene2.x=smin(scene2.x,length(abs(modP.xz+tnoi*2.)-vec2(3.5,2))-2.+tnoi*2.+sin(p.y*.3)+sin(p.y*2.*p.x)*0.03,5.); //VERTICAL CYLINDERS\n    vec3 cylP=modP+vec3(0,5,0); cylP.x=abs(cylP.x)-8.+tDisp;\n    scene2.x=smin(scene2.x,length(cylP.xy+tnoi*2.)-2.+tnoi*2.+sin(p.y*.3)+sin(p.y*2.*p.x)*0.017,5.);//HORIZONTAL CYLINDERS\n    scene2.x=smax(length(modP+vec3(0,6,0)+tnoi*3.)-4.,scene2.x,5.);  //HOLE IN MIDDLE OF TERRAIN\n    //scene2.x=smax(length(modP+vec3(0,12,0))-3.4+tnoi,scene2.x,2.); //Dig hole where blue sphere with tentacle is, removed to optimize shader as design impact is minimal\n    scene2.x*=0.5;\n    h=vec2(length(np.yz+vec2(-.3,0.)),6);\n    h.x=min(h.x,max(length(cos(p*.5+sin(op.z*.2)+vec3(0,tt,tt))),abs(p.x)-3.));\n    modP.xz*=r2(sin(p.y*.2+tt));  \n    h.x=min(h.x,length(abs(modP.xz)-.5)-max(0.,.5-abs(p.y+10.)*.1));  \n    h.x=smin(h.x,length(modP+vec3(0,12,0))-3.+tnoi,1.5);\n    scene2.x=min(scene2.x,h.x);  \n    g+=0.1/(0.1+h.x*h.x*(40.-39.*sin(op.z*.7)));  \n    vec2 t=mix(scene1,scene2,vec2(mixer,0.));  \n    return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>60.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>60.) t.y=0.;  \n    return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=23.6+mod(iTime,62.82);\n    vec3 ro=mix(vec3(12.,5.,-9.),vec3(0.,-2.,-10.),ceil(sin(tt*.4))),\n         cw=normalize(vec3(0,-2.,0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n         rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    z=tr(ro,rd);t=z.x;  \n    float timeMixer=clamp(sin(tt*.65),-.5,.5)+.5;\n    ld=normalize(vec3(.3,.2,.5));\n    vec3 sun=vec3(pow(clamp(dot(ld,rd),0.,1.),32.))*mix(vec3(.7,.4,0.),vec3(0.2),timeMixer);  \n    co=fo=sun+(mix(vec3(.6,.3,.3),vec3(.1,.15,.2),timeMixer)-length(uv)*.1-rd.y*.2);\n    if(z.y>0.){ \n        po=ro+rd*t; \n        no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        al=vec3(1);\n        if(z.y>=1.) al=mix(vec3(.1,.2,.4),vec3(1),2.-z.y);\n        if(z.y>=3.) al=mix(vec3(0),vec3(1),4.-z.y);   \n        float dif=max(0.0,dot(no,ld)),    \n              fr=pow(1.+dot(no,rd),4.),    \n              spo=exp2(1.+25.*texNoise(.05*vec2(np.y,dot(np.xz,vec2(.7)))).r),\n              sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);\n        co=mix(sp*.5+al*(a(.05)*a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00005*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*mix(vec3(.7,.2,.1),vec3(.1,.2,.7),timeMixer),vec3(.45)),1);\n} ", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2BzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 328, 353, 353, 394], [395, 395, 412, 412, 455], [456, 456, 498, 498, 563], [564, 564, 606, 606, 673], [674, 674, 697, 697, 917], [918, 918, 944, 944, 1313], [1314, 1314, 1333, 1333, 3167], [3168, 3168, 3197, 3197, 3385], [3475, 3475, 3532, 3532, 4883]]}
{"id": "tt2fD1", "name": "scurcil", "author": "DrRedcumber", "description": "scurcil", "tags": ["scurcil"], "likes": 2, "viewed": 42, "published": "Public", "date": "1598887518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = fragCoord.x; \n    float y = fragCoord.y;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,0,0));\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,1,7));\n    vec3 col3 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,0,0));\n\n    //strips\n    if (x> 350.0 && x<450.0) \n        fragColor = vec4(col2,1.0);\n    \n    else if (x> 125.0 && x<225.0) \n        fragColor = vec4(col2,1.0);\n    \n    else if (x> 575.0 && x<675.0) \n        fragColor = vec4(col2,1.0); \n        \n    else if (y> 83.33 && y<183.33) \n        fragColor = vec4(col2,1.0);\n     \n     else if (y> 266.70 && y<366.70) \n        fragColor = vec4(col2,1.0);   \n        \n \telse\n        fragColor = vec4(col,1.0);\n         \n    //circles     \n    vec2 cc = vec2(400.0, 135.0); \n    float rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n        \n    cc = vec2(400.0, 320.0); \n    rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n    \n    cc = vec2(625.0, 320.0); \n    rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n    \n    cc = vec2(625.0, 135.0); \n    rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n  \n    cc = vec2(175.0, 320.0); \n    rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n    \n    cc = vec2(175.0, 135.0); \n    rad = 50.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col3, 1.0);\n    \n    \n    //inner strips\n    if (x> 390.0 && x<410.0) \n        fragColor = vec4(col,1.0);\n    \n    else if (x> 165.0 && x<185.0) \n        fragColor = vec4(col,1.0);\n    \n    else if (x> 615.0 && x<635.0) \n        fragColor = vec4(col,1.0); \n        \n    else if (y> 123.33 && y<143.33) \n        fragColor = vec4(col,1.0);\n     \n    else if (y> 306.33 && y<326.33) \n        fragColor = vec4(col,1.0);\n        \n    \n    //inner circles    \n    cc = vec2(400.0, 320.0); \n    rad = 30.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col2, 1.0);\n    \n    cc = vec2(625.0, 320.0); \n    rad = 30.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col2, 1.0);\n    \n    cc = vec2(625.0, 135.0); \n    rad = 30.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col2, 1.0);\n  \n    cc = vec2(175.0, 320.0); \n    rad = 30.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col2, 1.0);\n    \n    cc = vec2(175.0, 135.0); \n    rad = 30.0; \n    if (pow((x-cc.x), 2.0) + pow((y-cc.y), 2.0) <= rad*rad) \n        fragColor = vec4(col2, 1.0);\n         \n         \n     \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2931]]}
{"id": "tt2fDR", "name": "Minimalism #06", "author": "Flopine", "description": "Sixth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "grid", "animation", "motion", "hexagons", "minimalist"], "likes": 6, "viewed": 157, "published": "Public", "date": "1598713421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define BPM (120./60.)\n#define dt(speed) fract(iTime*speed)\n#define bouncy(speed) (abs(sqrt(sin(dt(speed)*PI))))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define hexa(puv,s) (max(abs(puv.x),dot(abs(puv), normalize(vec2(1.,sqrt(3.))))))-s\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define moda(puv,r) puv=vec2(cos(mod(atan(puv.x,puv.y),TAU/r)-(TAU/r)*0.5),sin(mod(atan(puv.x,puv.y),TAU/r)-(TAU/r)*0.5))*length(puv)\n\n#define xor(a,b) ((1.-b)*a+(1.-a)*b)\n\nfloat equitri (vec2 p, float r)\n{\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/sqrt(3.);\n    if (p.x+sqrt(3.)*p.y>0.) p=vec2(p.x-sqrt(3.)*p.y,-sqrt(3.)*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2.*r, 0. );\n    return -length(p)*sign(p.y);\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 ratio = vec2(1.,sqrt(3.));\n    vec2 ga = mod(uv,ratio)-ratio*0.5;\n    vec2 gb = mod(uv-ratio*0.5,ratio)-ratio*0.5;\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n\n    float mask = AAstep(0.02,abs(equitri(guv,0.47)));\n    mask *= AAstep(0.015,abs(hexa(guv,0.46)));\n    guv *= rot(PI);\n    mask *= AAstep(0.015,abs(equitri(guv,0.23)));\n    moda(guv,3.);\n    mask *= AAstep(0.02,abs(guv.y));\n\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= mix(1.,length(uv),(2.*bouncy(BPM/4.)-1.)*0.35); \n    \n    vec3 col = vec3(frame(uv*4.));\n    col = xor(col,vec3(0.,0.,0.2));\n    \n    fragColor = vec4(pow(col,vec3(0.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 867, 900, 900, 1099], [1101, 1101, 1124, 1124, 1547], [1549, 1549, 1606, 1606, 1856]]}
{"id": "tt2fRw", "name": "4D Julia Fractal Animation", "author": "xacer", "description": "Animated Julia fractal raymarcher, with hsb colors.", "tags": ["raymarching", "fractal", "julia", "animation"], "likes": 4, "viewed": 241, "published": "Public API", "date": "1598570269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPosition;\nmat3 cameraMatrix;\nvec4 offset;\nvoid qFold (inout vec4 a) {\n    a = vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w,2.0*a.x*a.y,2.0*a.x*a.z,2.0*a.x*a.w);\n}\nfloat map (vec3 pos) {\n    vec4 z = vec4(pos.xyz, 0.0);\n    float md2 = 1.0;\n    float radius2 = dot(z, z);\n    for (int i = 0; i < 25; i ++) {\n        qFold(z);\n        z += offset;\n        md2 *= 4.0 * radius2;\n        radius2 = dot(z, z);\n        if (radius2 > 4.0) break;\n    }\n    return 0.25 * sqrt(radius2 / md2) * log(radius2) - 0.001;\n}\nvec3 xDir = vec3(0.000001, 0, 0);\nvec3 yDir = vec3(0, 0.000001, 0);\nvec3 zDir = vec3(0, 0, 0.000001);\nvec3 surfaceNormal (vec3 pos) {\n    vec3 normal = vec3(\n        map(pos + xDir) - map(pos - xDir),\n        map(pos + yDir) - map(pos - yDir),\n        map(pos + zDir) - map(pos - zDir)\n    );\n    return normalize(normal);\n}\nvec3 lightDirection;\nfloat hue;\nvec3 tint;\nvec3 trace (vec3 origin, vec3 direction) {\n    float totalDistance = 0.0;\n    for (float steps = 0.0; steps < 100.0; steps ++) {\n        vec3 pos = origin + direction * totalDistance;\n        float distance = map(pos);\n        totalDistance += distance;\n        if (dot(pos, pos) > 25.0) break;\n        if (distance < 0.002) {\n            vec3 normal = surfaceNormal(pos);\n            float diffuse = max(-dot(normal, lightDirection), 0.0);\n            float specular = -dot(reflect(direction, normal), lightDirection);\n            specular = max(pow(specular, 5.0), 0.0);\n            float shade = diffuse * 0.7 + specular * 0.3;\n            return shade * tint;\n        }\n    }\n    return vec3(0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cameraPosition = 1.8 * vec3(cos(iTime), 0, sin(iTime));\n\tcameraMatrix = mat3(cos(iTime+3.14/2.0), 0, -sin(iTime+3.14/2.0), 0, 1, 0, sin(iTime+3.14/2.0), 0, cos(iTime+3.14/2.0));\n\toffset = vec4(cos(iTime), sin(iTime), cos(iTime * 2.0 + 3.14), sin(iTime * 1.61 + 3.14)) * 0.6;\n    lightDirection = vec3(cos(iTime + 3.14), 0.0, sin(iTime + 3.14));\n    tint = vec3(cos(iTime / 20.0 * 3.1415 * 2.0) + 1.0, cos(iTime / 20.0 * 3.1415 * 2.0 + 2.0 * 3.1415 / 3.0) + 1.0, cos(iTime / 20.0 * 3.1415 * 2.0 + 4.0 * 3.1415 / 3.0) + 1.0) / 2.0;\n    hue = iTime / 20.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0 - 2.0 * fragCoord/iResolution.xy;\n    vec3 ray = normalize(vec3(uv, 1.0)) * cameraMatrix;\n\n    // Time varying pixel color\n    vec3 col = trace(cameraPosition, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2fRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 80, 80, 165], [166, 166, 188, 188, 511], [614, 614, 645, 645, 836], [880, 880, 922, 922, 1583], [1585, 1585, 1642, 1642, 2497]]}
{"id": "ttBBzh", "name": "Encaged", "author": "Vectornaut", "description": "One of my ray-marching practice projects from the CODAME shaders workshops, April–May 2020. The five platonic solids are scaled to interlock as described in the summary comments. (Updated September 2021 to improve the antialiasing.)", "tags": ["raymarching", "sdf", "polyhedra", "codame"], "likes": 6, "viewed": 67, "published": "Public", "date": "1598289039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// in this demo, the five platonic solids are scaled to interlock as follows.\n// - the dodecahedron encages the icosahedron\n// - the icosahedron encages the tetrahedron and the cube\n// - the intersection of the cube and the dodecahedron encages the octahedron\n\n// --- euler angles ---\n\nmat3 rot_xy(float t) {\n    return mat3(\n         cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n            0.0,    0.0, 1.0\n    );\n}\n\nmat3 rot_yz(float t) {\n    return mat3(\n        1.0,     0.0,    0.0,\n        0.0,  cos(t), sin(t),\n        0.0, -sin(t), cos(t)\n    );\n}\n\n// attitude = vec3(precession, nutation spin)\nmat3 euler_rot(vec3 attitude) {\n    return rot_xy(attitude[0]) * rot_yz(attitude[1]) * rot_xy(attitude[2]);\n}\n\n// --- augmented signed distances ---\n\nstruct aug_dist {\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\naug_dist dmin(aug_dist a, aug_dist b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\naug_dist dmax(aug_dist a, aug_dist b) {\n    if (a.dist > b.dist) return a; else return b;\n}\n\n// --- polyhedra ---\n\nvec3 msign(vec3 v) {\n    return vec3(\n        v.x > 0. ? 1. : -1.,\n        v.y > 0. ? 1. : -1.,\n        v.z > 0. ? 1. : -1.\n    );\n}\n\nfloat argmax(vec3 v) {\n   return max(v.x, max(v.y, v.z));\n}\n\naug_dist plane_sdf(vec3 p, vec3 normal, float offset, vec3 color) {\n    return aug_dist(\n        dot(p, normal) - offset,\n        normal,\n        color\n    );\n}\n\nconst float pi = 3.141592653589793;\nconst float sqrt3 = sqrt(3.);\n\n// tetrahedron\naug_dist tetra_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // write down normals\n    vec3 normals [4];\n    normals[0] = vec3(-1., -1., -1.) / sqrt3;\n    normals[1] = vec3(-1.,  1.,  1.) / sqrt3;\n    normals[2] = normals[1].zxy;\n    normals[3] = normals[2].zxy;\n    \n    // find the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    for (int j = 1; j < 4; j++) {\n        dist = dmax(dist, plane_sdf(p, normals[j], inradius, color));\n    }\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// cube. inspired by Inigo Quilez's box SDF,\n//\n//   https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//   https://www.iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\n//\n// but different. in particular, this one is only a bound\naug_dist cube_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    vec3 p_abs = abs(p);\n    vec3 normal = msign(p) * vec3(\n        p_abs.x >= p_abs.y && p_abs.x >= p_abs.z ? 1. : 0.,\n        p_abs.y >= p_abs.z && p_abs.y >= p_abs.x ? 1. : 0.,\n        p_abs.z >= p_abs.x && p_abs.z >= p_abs.y ? 1. : 0.\n    );\n    \n    return aug_dist(\n        argmax(p_abs - vec3(inradius)),\n        orient * normal,\n        color\n    );\n}\n\n// octahedron\naug_dist octa_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normal in the positive orthant\n    vec3 normal = vec3(1.) / sqrt3;\n    \n    // reflect it into the orthant of p\n    normal *= msign(p);\n    \n    // now it's the normal of the side closest to p\n    aug_dist dist = plane_sdf(p, normal, inradius, color);\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\nconst float phi = (1.+sqrt(5.))/2.;\nconst float hyp = sqrt(2.+phi); // = sqrt(1+phi^2)\n\n// dodecahedron\naug_dist dodeca_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normals in the positive orthant\n    vec3 normals [3];\n    normals[0] = vec3(0., 1., phi) / hyp;\n    normals[1] = normals[0].zxy;\n    normals[2] = normals[1].zxy;\n    \n    // reflect them into the orthant of p\n    for (int k = 0; k < 3; k++) {\n        normals[k] *= msign(p);\n    }\n    \n    // now, one of them is the normal of the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    dist = dmax(dist, plane_sdf(p, normals[1], inradius, color));\n    dist = dmax(dist, plane_sdf(p, normals[2], inradius, color));\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// icosahedron\naug_dist icosa_sdf(vec3 p_scene, float inradius, vec3 color) {\n    vec3 attitude = vec3(1./(2.+pi), 1./pi, 1./2.) * vec3(iTime);\n    mat3 orient = euler_rot(attitude);\n    vec3 p = p_scene * orient; // = transpose(orient) * p_scene\n    \n    // take the side normals in the positive orthant\n    vec3 normals [4];\n    normals[0] = vec3(1.) / sqrt3;\n    normals[1] = vec3(0., phi-1., phi) / sqrt3;\n    normals[2] = normals[1].zxy;\n    normals[3] = normals[2].zxy;\n    \n    // reflect them into the orthant of p\n    for (int k = 0; k < 4; k++) {\n        normals[k] *= msign(p);\n    }\n    \n    // now, one of them is the normal of the side closest to p\n    aug_dist dist =  plane_sdf(p, normals[0], inradius, color);\n    for (int j = 1; j < 4; j++) {\n        dist = dmax(dist, plane_sdf(p, normals[j], inradius, color));\n    }\n    dist.normal = orient * dist.normal;\n    return dist;\n}\n\n// --- marcher ---\n\nconst int steps = 256;\nconst float eps = 0.001;\nconst float horizon = 30.0;\n\nfloat plateau(float t, float width) {\n    const float margin = 1./12.;\n    t = mod(t, 3.);\n    if (t < margin) {\n        float s = 1.-t/margin;\n        return 1. - s*s;\n    } else if (t < width-margin) {\n        return 1.;\n    } else if (t < width) {\n        float s = 1. - (width-t)/margin;\n        return 1. - s*s;\n    } else {\n        return 0.;\n    }\n}\n\nvec3 radiance(aug_dist dist, vec3 sky_color) {\n    return mix(sky_color, dist.color, (1.+dot(dist.normal, vec3(1.)/sqrt3))/2.);\n}\n\nconst vec3 sky_color = vec3(0.1, 0.1, 0.3);\nconst vec3 dark = vec3(0.5);\nconst vec3 neonlime = vec3(0.75, 0.90, 0.00);\nconst vec3 light = vec3(1.0);\n\nconst float sqrt5 = 2.*phi-1.;\n\n// with these inradii, the platonic solids interlock as desired\nconst float r_icosa = sqrt5/sqrt3;\nconst float r_dodeca = sqrt5/(hyp*(phi-2./3.));\nconst float r_octa = r_icosa/(phi-2./3.) - 1./(phi*sqrt3);\nconst float r_tetra = 5.*(2./phi-1.)/sqrt3;\n\nvec3 ray_color(vec3 place, vec3 dir) {\n    float r = 0.0;\n    for (int step_cnt = 0; step_cnt < steps; step_cnt++) {\n        // calculate easing functions\n        float t = iTime / 10.;\n        float dodeca_pop = plateau(t,    2.);\n        float octa_pop   = plateau(t,    1.);\n        float icosa_pop  = plateau(t-1., 2.);\n        float cube_pop   = plateau(t-2., 2.);\n        float tetra_pop  = plateau(t-2., 1.);\n        \n        // find scene distance\n        vec3 p_scene = place + r*dir;\n        aug_dist poly = dodeca_sdf(p_scene, r_dodeca * dodeca_pop, neonlime);\n        poly = dmin(poly, octa_sdf(p_scene, r_octa * octa_pop,  light));\n        poly = dmin(poly, icosa_sdf(p_scene, r_icosa * icosa_pop, light));\n        poly = dmin(poly, cube_sdf(p_scene, (1.-eps)*cube_pop, dark));\n        poly = dmin(poly, tetra_sdf(p_scene, r_tetra * tetra_pop, neonlime));\n        \n        // march\n        if (poly.dist < eps) {\n            return radiance(poly, sky_color);\n        } else if (r > horizon) {\n            return sky_color;\n        } else {\n            r += poly.dist;\n        }\n    }\n    return sky_color;\n}\n\n// --- main ---\n\nconst vec3 place = vec3(0., 0., 9.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // NVIDIA GF100 multisampling pattern\n    // https://www.anandtech.com/show/2918/5\n    vec2 jiggle[8];\n    jiggle[0] = vec2( 0.500,  0.125);\n    jiggle[1] = vec2( 0.625,  0.875);\n    jiggle[2] = vec2(-0.125,  0.500);\n    jiggle[3] = vec2(-0.875,  0.625);\n    jiggle[4] = vec2(-0.500, -0.000);\n    jiggle[5] = vec2(-0.625, -0.875);\n    jiggle[6] = vec2( 0.000, -0.500);\n    jiggle[7] = vec2( 0.875, -0.625);\n    \n    float small_dim = min(iResolution.x, iResolution.y);\n    vec3 color_sum = vec3(0.);\n    for (int k = 0; k < 8; k++) {\n        vec2 screen_pt = (2.*fragCoord + jiggle[k] - iResolution.xy)/small_dim;\n        vec3 dir = normalize(vec3(screen_pt, -3.5));\n        color_sum += ray_color(place, dir);\n    }\n    fragColor = vec4(color_sum/8., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 286, 308, 308, 423], [425, 425, 447, 447, 562], [564, 610, 641, 641, 719], [721, 831, 870, 870, 922], [924, 924, 963, 963, 1015], [1017, 1039, 1059, 1059, 1171], [1173, 1173, 1195, 1195, 1232], [1234, 1234, 1301, 1301, 1394], [1463, 1478, 1540, 1540, 2192], [2194, 2455, 2516, 2516, 3050], [3052, 3066, 3127, 3127, 3633], [3723, 3739, 3802, 3802, 4601], [4603, 4618, 4680, 4680, 5498], [5500, 5597, 5634, 5634, 5953], [5955, 5955, 6001, 6001, 6084], [6268, 6519, 6557, 6557, 7639], [7641, 7696, 7751, 7838, 8514]]}
{"id": "ttBfDh", "name": "div-free flownoise displacement", "author": "FabriceNeyret2", "description": "use divergence-free flownoise to distort a base function ( here, radial gradient )\n\nclick for color vs N&B version", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "divergencefree"], "likes": 7, "viewed": 238, "published": "Public API", "date": "1598801898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WtBBD1\n\n  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S,\n         D;\n    float v = Perlin( U );                    \n // O = vec4( .5 + .5 * v ); return;          // see Perlin noise\n    \n                                              // --- divergence-free displacement noise\n // D = vec2( v - Perlin( U+vec2(0,S.y) ), Perlin( U+vec2(S.x,0) ) - v ) *2./ S;\n    D = vec2( -dFdy(v), dFdx(v) ) / S;        // using hardware derivatives\n    D += sin(iTime) * U; \n    O = iMouse.z <= 0. \n          ? vec4( .5 + .5* atan(D.y,D.x)/3.14 )  // see noise direction\n          : .6 + .6 * cos( atan(D.y,D.x)  + vec4(0,23,21,0)  ); // dir as hue\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 726, 748, 787, 1112], [1114, 1114, 1152, 1152, 1813]]}
{"id": "ttfBD2", "name": "Bouncing gradient light", "author": "pixeljig", "description": "Playing around with light coming from the side.", "tags": ["pulse", "light", "gradient", "bounce", "overlay"], "likes": 1, "viewed": 77, "published": "Public", "date": "1597746651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMIT LICENSE\nCopyright 2020 Ahmed Harmouche\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float lightPos = 1.1;\n    \n    float dist = 1.0/(lightPos - uv.x);\n    \n    dist *= 0.1;\n    \n    float dist1 = dist;\n    \n    dist1 = pow(dist1, 0.5);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 outCol = vec3(mix(col*dist, col*dist1, sin(iTime*3.0)));\n                       \n    fragColor = vec4(outCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBD2.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1070, 1127, 1182, 1572]]}
{"id": "ttfBDH", "name": "Cave at the Edge of the Universe", "author": "jarble", "description": "This cave is based on the [url=https://www.shadertoy.com/view/tl2yDz]\"Edge of the Universe\"[/url] fractal.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "thorns"], "likes": 0, "viewed": 189, "published": "Public API", "date": "1596578266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n#define ITERATIONS 20\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat sceneSDF(vec3 p) {\n    p /= 20.0;\n\tvec2 uv = p.xy - vec2(.5);\n    float time = p.z * 2. + 15.+length(sin(uv/10.0));\n    uv = sin(uv/(20.0+sin(uv.yx/20.0+time)))*3.0;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time + vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;\n    return val;\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 1.0;\n    float t1 = iTime*speed;\n\tvec3 eye = vec3(-10.0-200.0,9.0-15.0,9.0*t1);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 612, 636, 636, 1092], [1095, 1095, 1123, 1123, 1241], [1244, 1665, 1756, 1756, 2062], [2077, 2331, 2396, 2396, 2528], [2530, 2619, 2648, 2648, 2958], [2960, 3452, 3592, 3592, 4202], [4204, 4574, 4659, 4659, 5074], [5076, 5403, 5452, 5487, 5618], [5620, 5620, 5677, 5677, 6794]]}
{"id": "ttfBDX", "name": "Volumetric Nebula with Rotation", "author": "Zi7ar21", "description": "Yeetus", "tags": ["volumetric", "nebula", "rotation", "rotationmatrix", "volumetricnebula"], "likes": 5, "viewed": 314, "published": "Public API", "date": "1597878972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN\n// 2020-08-19 23:12:29\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- August 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 96\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 16.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 6\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.1\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 1.0\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n\n// White Noise\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n// Convert Noise to 3D\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Noise for Dithering\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noised(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; ++i){\n\t\tv += a * noise(x);\n\t\tx = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat nebulanoise(vec3 raypos){\n\tfloat density = clamp(fbm(raypos)-0.5, 0.0, 1.0)/pow(distance(vec3(0.0), raypos),4.0);\n\treturn density;\n}\n\n// ##### RAYMARCHING #####\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n\tfloat distorigin=0.0;\n\tfloat density=0.0;\n    vec3 raypos = camerapos;\n\tvec3 raydirmod = (raydir+(raydir*(noised(coord+((sin(float(iFrame%60))+3.14159265)*sqrt(coord.x*coord.x+coord.y*coord.y))))*STEP_SIZE))*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++) {\n    \traypos = raypos + raydirmod;\n        float densityadd = nebulanoise(raypos)*DENSITY;\n        density = density+densityadd;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density*0.15;\n}\n\n// ##### RENDERING #####\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t// Dumb rotation matrix hecking Michael begged me to add\n\tfloat xrot = sin(-((iMouse.y/iResolution.y)-0.5)*3.14159265);\n\tfloat yrot = sin(((iMouse.x/iResolution.x)-0.5)*3.14159265);\n\tfloat zrot = 0.0;\n\t// Camera Orientation (Cursed)\n\tvec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\tvec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\tvec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n\tfloat FOV = 2.0;\n\tvec3 camerapos = vec3(-sin((iMouse.y/iResolution.y)-0.5)*3.14159265, 0.0, -3.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Pixel Color\n    vec3 col = vec3(raymarched);\n\t\n\t// Apply Tone Map\n    col = vec3(acesFilm(col));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1535, 1550, 1572, 1572, 1617], [1618, 1618, 1638, 1638, 1683], [1684, 1684, 1702, 1702, 1741], [1743, 1766, 1786, 1786, 2272], [2274, 2297, 2317, 2317, 2384], [2385, 2385, 2406, 2406, 2615], [2617, 2630, 2648, 2648, 2784], [2786, 2786, 2817, 2817, 2924], [2954, 2979, 3035, 3035, 3541], [3569, 3588, 3617, 3617, 3802], [3804, 3824, 3878, 3936, 4980]]}
{"id": "ttfBzf", "name": "Sphere_Noise_1", "author": "TRASHTRASH", "description": "my second ray marching shader\ntrying to learn and grow each day practice makes perfect", "tags": ["raymarching", "noise", "beginner", "perlin", "sphere", "simplex"], "likes": 1, "viewed": 49, "published": "Public", "date": "1597481708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH by Josh deLorimier\n//Praticing Ray Marching Daily\n//my niece's favorite color is RED\n//trying to post daily exercises keeping it simple today\n\n#define MAX_STEPS 60\n#define MAX_DIST 30.0\n#define SURF_DIST 0.001\n#define BPM 123.\n//simplex noise from Patricio Gonzalez Vivo\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0);} \n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n  return mat2(c,-s,s,c);\n}\n\n//geo                      \nfloat map(vec3 p) {\n    float b = iTime*BPM/60.;\n   float n1 = snoise(p.xy+b);\n   float n2 = snoise(p.xx+b);\n    float n3 = n1*n2;\n    vec3 sp = vec3(n1,n2*n3,n2)/6.;\n    sp.xz *= Rot(iTime*0.5);\n    sp.yz *= Rot(iTime*0.9);\n  \tfloat s = length(p-sp)-5.0;\n    return s;\n}\n\n                  \n//marcher\nfloat RM(vec3 ro, vec3 rd) {\n \tfloat or = 0.;\n    for(int i=0;i<MAX_STEPS;++i){\n     \tvec3 p = ro + rd * or;\n        float sc = map(p);\n        if(or>MAX_DIST || abs(sc)<SURF_DIST) break;\n        or += sc;\n    }\n    return or;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 norm(vec3 p) {\n \tfloat d = map(p);\n    vec2 e = vec2(.001, 0.);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat shade(vec3 p, vec3 rd, vec3 n) {\n \tvec3 lp = vec3(-5.,6.,-2.);\n    vec3 l = normalize(lp-p);\n   \tfloat col = 0.;\n    float dif = clamp(dot(n,l)*.5+.5,0.,1.);\n    float d = RM(p+n*SURF_DIST*2., l);\n    float fr = pow(1.0+dot(n, rd),4.0);\n    float sp = pow(max(dot(reflect(-l, n),-rd),0.0),80.);\n   \tfloat ao = (1.0 - fr);\n   \tfloat fd = 1.0 - dif;\n    col = sp + max(fr, 0.5) + dif * ao;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n   \tvec3 col = vec3(0.0);\n    vec3 ro = vec3(0., 4., 10.);\n    ro.yz *= Rot(-m.y);\n    ro.xz *= Rot(-m.x);\n   \tvec3 rd = R(uv, ro, vec3(0,0,0),1.);\n    float d = RM(ro, rd);\n    float n1 = snoise((uv.yx)+(iTime*BPM/60.));\n    vec3 fog = mix(vec3(SURF_DIST*3.), vec3(1.,0.,0.)+n1+0.4, (uv.y + .58)*2.);\n    float prod = 1.0;\n    if(d<MAX_DIST) {\n       vec3 p = ro + rd * d;\n       vec3 n = norm(p);\n       float dif = shade(p,rd, n);\n       vec3 c1 = vec3(1.,0.,0.)/2.;\n       col = vec3(dif)*c1;\n       col *= col;\n    } else {\n    \tcol += fog;\n        col*col;\n    }\n    col = pow(col, vec3(.4545));\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 284, 306, 306, 344], [347, 347, 369, 369, 1189], [1191, 1191, 1210, 1210, 1275], [1277, 1305, 1324, 1324, 1576], [1597, 1607, 1635, 1635, 1835], [1837, 1837, 1879, 1879, 2074], [2076, 2076, 2095, 2095, 2236], [2238, 2238, 2276, 2276, 2649], [2652, 2652, 2709, 2709, 3459]]}
{"id": "ttfBzS", "name": "Melting", "author": "t420babe", "description": "Trippy random tangent, log, sqrt.\nInspiration from chapter 10 of The Book of Shaders \nhttps://thebookofshaders.com/10/", "tags": ["colors", "tan"], "likes": 0, "viewed": 179, "published": "Public API", "date": "1597002807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspiration from https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(vec2 pos, float mod_time) {\n  float A = 30.0;\n  float w = 0.0200;\n  float phi = 0.0;\n  float wrap_time = A * cos(w * mod_time + phi);\n  wrap_time = -abs(wrap_time);\n  float arg0 = 12.9898;\n  float arg1 = 780.2333 / 10000.0 * log(mod_time);\n  float arg2 = 143758.5453123 / (10.0 * wrap_time);\n  return fract(sin(dot(pos.xy, vec2(arg0, arg1))) * arg2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 pos = fragCoord.xy / iResolution.xy;\n  pos.x *= 0.25;\n  pos.y *= 0.05;\n\n  vec3 color = vec3(0.0);\n  float time_limit = 160.0;\n  float mod_time = mod(iTime, time_limit);\n\n\n  float rnd = random( pos, mod_time ) * 0.4;\n  //color = vec3(cos(rnd), sin(rnd), atan(rnd));\n  color = vec3(tan(rnd), log(rnd), 1.0 - sqrt(rnd));\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 115, 115, 440], [442, 442, 498, 498, 858]]}
{"id": "ttffDj", "name": "z -> kz+cos(z)+z0", "author": "CyanMARgh", "description": "Mandelbrot-like visualization of z->kz+cos(z)+z0.", "tags": ["mandelbrot"], "likes": 1, "viewed": 69, "published": "Public", "date": "1597735815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265;\nconst vec3 e3 = vec3(1.,1.,1.);\nconst vec2 one = vec2(1.,0.);\n\n\nvec2 zmz(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nfloat arg(vec2 z){\n    return mod(atan(z.y,z.x),2.*pi);\n}\nvec2 epyi(float y){\n    return vec2(cos(y),sin(y));\n}\nvec2 logz(vec2 z){\n    return vec2(log(length(z)),arg(z));\n}\nvec2 epz(vec2 z){\n    return exp(z.x)*epyi(z.y);\n}\nvec2 cosz(vec2 z){\n    z=zmz(vec2(0.,1.),z);\n    return (epz(z)+epz(-z))/2.;\n}\nvec3 hsvTOrgb(float h, float s, float v){\n    float x = mod(h,1.);\n    int H = int(floor(h))%6;\n\n    vec3 rgb=vec3(0.);\n    switch(H){\n        case 0: rgb = vec3(1.,x,0.); break;\n        case 1: rgb = vec3(1.-x,1.,0.); break;\n        case 2: rgb = vec3(0.,1.,x); break;\n        case 3: rgb = vec3(0.,1.-x,1); break;\n        case 4: rgb = vec3(x,0.,1.); break;\n        case 5: rgb = vec3(1.,0.,1.-x); break;\n    }\n    return (e3-(e3-rgb)*s)*v;\n}\n\nvec2 f_(vec2 z, vec2 z0){\n    float k=1.2*sin(iTime);\n    return k*z+cosz(z)+z0;\n}\n\n\nvec2 f(vec2 z){\n    vec2 z0=z;\n    float i=0.,I=100.;\n    for(;i++<I;){\n        z=f_(z,z0);\n        if(length(z)>50.) break;\n    }\n    return epyi(i*.1);\n}\n\nvec3 mapping(vec2 p){\n    p=f(p);\n    float h = (atan(p.y,p.x))*3./pi + 6.; //scaled angle in [0;6]\n    float r = length(p);    \n    return hsvTOrgb(h,clamp(r*.6,0.,1.),1.);\n}\nvoid mainImage( out vec4 col, in vec2 p_ ){        \n    vec2 r=iResolution.xy;\n    vec2 p = p_/r;    \n    p=p*2.-vec2(1.,1.);\n    p.x *=r.x/r.y; \n    p*=2.5;\n    col = vec4(mapping(p),1.);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 112, 112, 164], [165, 165, 183, 183, 222], [223, 223, 242, 242, 276], [277, 277, 295, 295, 337], [338, 338, 355, 355, 388], [389, 389, 407, 407, 467], [468, 468, 509, 509, 912], [914, 914, 939, 939, 996], [999, 999, 1014, 1014, 1154], [1156, 1156, 1177, 1177, 1331], [1332, 1332, 1375, 1375, 1522]]}
{"id": "ttffRB", "name": "Creamsicle", "author": "t420babe", "description": "A modified voronoi function complete inspired by Chapter 12 of The Book of Shaders\n(https://thebookofshaders.com/edit.php#12/2d-voronoi.frag)", "tags": ["voronoi", "lines", "random", "orange", "creamsicle"], "likes": 0, "viewed": 182, "published": "Public API", "date": "1597012717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// From https://thebookofshaders.com/12/\nvec2 random( vec2 p ) {\n      return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\nvec3 voronoi(in vec2 pos) {\n  vec2 n = floor(pos);\n  vec2 f = fract(pos);\n\n  vec2 mg, mr;\n  float md = 8.0;\n  for (int j = -1; j <=1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 g = vec2(float(i), float(j));\n      vec2 o = random(n + g);\n      o = 0.5 + 0.5 * sin(iTime + 6.2831 * o);\n\n      vec2 r = g + o - f;\n      float d = dot(r, r);\n\n      if (d < md ) {\n        md = d;\n        mr = r;\n        mg = g;\n      }\n    }\n  }\n\n  return  vec3(mr, mg.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = fragCoord / iResolution.xy;\n\n    float y = smoothstep(0.2,0.5,pos.x) - smoothstep(0.5,0.8,pos.x);\n    pos.y += random(pos).y;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    vec3 c = voronoi(pos);\n    color = c.x * (1.5 + 1.0 * sin(164.0 * c.x)) * vec3(1.0);\n\n\n    fragColor = vec4(1.0, color.x + 0.1, color.y + 0.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 67, 90, 90, 185], [187, 252, 279, 279, 717], [721, 721, 778, 778, 1114]]}
{"id": "ttffWX", "name": "20200819_3", "author": "gweltou", "description": "earth texture proto3", "tags": ["random", "scrolling"], "likes": 3, "viewed": 50, "published": "Public", "date": "1597874835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random2d(vec2 coord)\n{\n    // D'après https://www.youtube.com/watch?v=nM320eVlLvQ\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nvec3 colNoise(vec2 st, vec3 c, float amp) {\n  float x = Random2d(st) * amp;\n  float y = Random2d(st) * (amp-x);\n  float z = Random2d(st) * (amp-x-y);\n  x -= amp/2.;\n  y-=amp/2.;\n  z-=amp/2.;\n  float tmp;\n  // Shuffle\n  for (int i=0; i<3; i++) {\n    switch (int(floor(Random2d(st) * 3.))) {\n      case 0: tmp=x; x=y; y=tmp;\n              break;\n      case 1: tmp=x; x=z; z=tmp;\n              break;\n      case 2: tmp=y; y=z; z=tmp;\n              break;\n      default: break;\n    }\n  }\n  //return vec3(red(c)+x, green(c)+y, blue(c)+z);\n    return c + vec3(x,y,z);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st *= 2. + 4. * (1. + sin(iTime/10.));\n    st.x *= iResolution.x/iResolution.y;\n    st.x += iTime/10.;\n    \n    vec3 color = vec3(0.9);\n    float rnd = .0;\n    \n    int i = 0;\n\t\n    while (rnd < .9 && i < 4) {\n        st *= 1.8 + 1.1 * cos(iTime*0.06);\n        vec2 zoneCoord = floor(st.xy);\n        rnd = Random2d(zoneCoord);\n    \ti++;\n    }\n    color = vec3(rnd);\n\t\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 88, 167], [170, 170, 213, 213, 733], [739, 739, 796, 796, 1247]]}
{"id": "ttffzS", "name": "pulse_orbit", "author": "slackmage", "description": "pulse orbit", "tags": ["orbit"], "likes": 1, "viewed": 160, "published": "Public API", "date": "1597006999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 2;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-43;\n#define EPSILON_NRM (0.1 / iResolution.x)\n#define AA\n\n// sea\nconst int ITER_GEOMETRY = 6;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 1.6;\nconst float SEA_CHOPPY = 5.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 1.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*2.6;\n#define SEA_TIME (.001 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*343758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.2 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 4.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*8.2;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 0.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 2.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.0000001;\n        choppy = mix(choppy,1.0,2.0);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 1.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.3; amp *= 1.22;\n        choppy = mix(choppy,2.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 2.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 12.18 * atten;\n    \n    color += vec3(specular(n,l,eye,10.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 4.0 - 2.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*2.0)*0.1,sin(time)*2.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*1.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.02,dir.y),2.2));\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + iMouse.x*0.01;\n\t\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 uv = fragCoord+vec2(i,j)/2.0;\n    \t\tcolor += getPixel(uv, time);\n        }\n    }\n    color /= 2.5;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(4.65)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttffzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[681, 689, 715, 715, 1061], [1062, 1062, 1084, 1084, 1165], [1166, 1166, 1192, 1192, 1493], [1495, 1507, 1545, 1545, 1587], [1588, 1588, 1634, 1634, 1734], [1736, 1743, 1769, 1769, 1878], [1880, 1887, 1928, 1928, 2099], [2101, 2101, 2120, 2120, 2569], [2571, 2571, 2599, 2599, 3043], [3045, 3045, 3108, 3108, 3603], [3605, 3616, 3651, 3651, 3842], [3844, 3844, 3900, 3900, 4412], [4414, 4414, 4456, 4456, 5162], [5164, 5172, 5229, 5229, 5625]]}
{"id": "ttjBD1", "name": "Fractal gutter", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 12, "viewed": 274, "published": "Public", "date": "1598883622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat orbit;\nfloat map(vec3 p){\n\tp.yz*=rot(iTime*0.05);\n\tp.xz*=rot(iTime*0.1);  \n\tp=abs(p)-3.;\n\tif(p.x<p.z)p.xz=p.zx;\n\tif(p.y<p.z)p.yz=p.zy;\n \tif(p.x<p.y)p.xy=p.yx;\n \tfloat s=2.;\n\tvec3  off=p*.5;\n\tfor(int i=0;i<12;i++){\n\t\tp=1.-abs(p-1.);\n  \t\tfloat k=-1.1*max(1.5/dot(p,p),1.5);\n    \ts*=abs(k);\n   \t\tp*=k;\n\t\tp+=off;\n    \tp.zx*=rot(-1.2);\n    }\n\torbit=log2(s);\n\tfloat a=2.5;\n\tp-=clamp(p,-a,a);\n\treturn length(p)/s;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,9.+sin(.3*iTime+.4*sin(.2*iTime)));\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(0);\n\tconst float maxd = 40.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=2.*clamp(mix(vec3(1),\n                3.*(cos(vec3(2,5,17)+orbit*2.+p*.3)*.5+.5),\n                .7),0.,1.);\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(10);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.5, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.7;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.5,0.4,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 60.0);\n        col = mix(vec3(0),col,exp(-t*t*.003));\n    }\n    fragColor.xyz = clamp(col,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 82, 82, 465], [467, 467, 493, 493, 645], [647, 647, 701, 701, 867], [869, 869, 921, 921, 1004], [1006, 1006, 1063, 1063, 2166]]}
{"id": "ttjBWR", "name": "Fractal try", "author": "sariug", "description": "fractal trial ", "tags": ["noob"], "likes": 4, "viewed": 67, "published": "Public", "date": "1598702081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 mnormal(float angle)\n{\n    return vec2(sin(angle),cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Pixel color\n    vec3 col = vec3(0);\n    uv *=iTime+2.;//*mat2(cos(iTime), sin(iTime),-sin(iTime),cos(iTime))*uv;\n    \n\tvec2 n;\n    float angle = 0.645;\n    for(int i = 0;i<3;i++){\n        uv.x = abs(uv.x);\n        if(i == 0)uv.y += .5* tan(3.1415*.64);\n        n = mnormal(3.1415*angle); // vector to point\n        float dd =  dot(n,uv-vec2(.5,0));\n        uv-=n*max(0.,dd)*2.; // Reflection\n    }\n\n\t\n    float scale = 1.0;\n    n = mnormal(1./3.*3.1415);\n    uv.x+=.5;\n    for(int i = 0;i<int(iTime/1.5)+1;i++  )  {\n        scale*=3.0;\n        uv *= 3.;\n        uv.x-=1.5;\n\n        uv.x = abs(uv.x); // mirroring\n        uv.x-=.5; \n        uv-=n*min(0., dot(n,uv))*2.; // Reflection\n    }\n\n    float d = length(uv-vec2(clamp(uv.x, -1., 1.), 0));\n    col+= smoothstep(3./iResolution.y,.0,d/scale); \n\tuv /=scale;\n\n    float time = -abs(cos(iTime));\n    uv *=  time;\n    float fft  = texelFetch( iChannel1, ivec2(uv.y,0), 0 ).x; \n    if(uv.y>0.)\n    col += texture(iChannel0, uv).rgb;\n    else\n        col+= texture(iChannel2, uv.xy).bgr+fft/10.;\n \tif(time>0.)\n        col = vec3(1.);\n\n    col+=fft/5.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4tB3WK", "previewfilepath": "https://soundcloud.com/fish-tales/fisher-losing-it", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fish-tales/fisher-losing-it", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjBWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 71], [73, 73, 130, 180, 1380]]}
{"id": "ttjfz1", "name": "Mandelbrot set alternate ending", "author": "matrefeytontias", "description": "It's a Mandelbrot set, but the value for i² just can't stay in place.", "tags": ["mandelbrot", "nonstandard"], "likes": 0, "viewed": 80, "published": "Public", "date": "1598359939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sq(vec2 z, float sq_imag)\n{\n    return vec2(z.x * z.x + z.y * z.y * sq_imag, 2. * z.x * z.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.) * vec2(1., iResolution.y / iResolution.x);\n    \n    vec2 c = uv * 2. + vec2(0.5, 0.);\n    \n    float t = sin(iTime);\n\n#define SAMPLES 64.\n    \n    vec2 z = c;\n    float i = 0.;\n    for(; i < SAMPLES; i += 1.)\n    {\n        z = sq(z, t) - c;\n        if(length(z) > 2.)\n            break;\n    }\n    \n    fragColor = vec4(i / SAMPLES);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 100], [102, 102, 159, 209, 595]]}
{"id": "ttlBRN", "name": "PewDiePie Pattern", "author": "mharitsnf", "description": "PewDiePie pattern for training purposes", "tags": ["wavy", "pattern"], "likes": 1, "viewed": 87, "published": "Public", "date": "1596255612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float tiling = 12.;\nconst float PI = 3.14159265359;\nconst float direction = .3;\nconst float warpScale = .03;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    uv.y += sin(uv.y * PI * 2.) * (warpScale - .02);\n    uv.y -= cos(uv.y * PI * 5.) * warpScale;\n    uv.y -= sin(uv.x * PI * 10.) * (warpScale + .03);\n\n    uv.y += (fract(uv.x + uv.y)) * .85;\n    uv.y -= iTime * .02;\n\tuv.y *= tiling;\n\n    float fractVal = floor(fract(uv.y) + .5);\n    \n    vec3 col1 = vec3(228./255., 5./255., 50./255.);\n    vec3 col2 = vec3(10./255., 0./255., 1./255.);\n    vec3 finalCol = mix(col1, col2, fractVal);\n    \n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 174, 741]]}
{"id": "ttlBW2", "name": "SinusoidalRecursion", "author": "AdamLuhring", "description": "Goes into sinusoids some. TIMES! Maybe. Less. more. TIME!", "tags": ["blah"], "likes": 1, "viewed": 42, "published": "Public", "date": "1597798549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int bailout = int(mod(iTime*3.,20.));\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 uvt = vec3(uv.x,uv.y,iTime*4.);\n    vec3 uvt2 = uvt;\n    for(int a = 0; a < bailout; a++){\n        uvt2.x = cos(uvt.x*1.1+uvt.y*1.9+uvt.z*1.1);\n        uvt2.y = cos(uvt.x*1.2+uvt.y*1.2+uvt.z*1.101);\n        uvt2.z = cos(uvt.x*8.1+uvt.y*1.1+uvt.z*1.102);\n        uvt = uvt2;\n    }\n    vec3 col = uvt/2.+.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 487]]}
{"id": "ttlBWf", "name": "Box occlusion optimized", "author": "clem494949", "description": "Analytic box occlusion with half the number of acos calls. It's based on the cube's perimeter instead of the individual faces' perimeter.\nFork of : https://www.shadertoy.com/view/4djXDy", "tags": ["box", "occlusion", "analytic"], "likes": 5, "viewed": 91, "published": "Public", "date": "1597964701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of: https://www.shadertoy.com/view/4djXDy\n\n//=====================================================\n\n// Box occlusion (if fully visible)\nfloat boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n\tvec3 p = (txx*vec4(pos,1.0)).xyz;\n\tvec3 n = (txx*vec4(nor,0.0)).xyz;\n    \n    // Orient the hexagon based on p\n    vec3 f = rad * sign(p);\n    \n    // Make sure the hexagon is always convex\n    vec3 s = sign(rad - abs(p));\n    \n    // 6 verts\n    vec3 v0 = normalize( vec3( 1.0, 1.0,-1.0)*f - p);\n    vec3 v1 = normalize( vec3( 1.0, s.x, s.x)*f - p);\n    vec3 v2 = normalize( vec3( 1.0,-1.0, 1.0)*f - p);\n    vec3 v3 = normalize( vec3( s.z, s.z, 1.0)*f - p);\n    vec3 v4 = normalize( vec3(-1.0, 1.0, 1.0)*f - p);\n    vec3 v5 = normalize( vec3( s.y, 1.0, s.y)*f - p);\n    \n    // 6 edges\n    return abs( dot( n, normalize( cross(v0,v1)) ) * acos( dot(v0,v1) ) +\n    \t    \tdot( n, normalize( cross(v1,v2)) ) * acos( dot(v1,v2) ) +\n    \t    \tdot( n, normalize( cross(v2,v3)) ) * acos( dot(v2,v3) ) +\n    \t    \tdot( n, normalize( cross(v3,v4)) ) * acos( dot(v3,v4) ) +\n    \t    \tdot( n, normalize( cross(v4,v5)) ) * acos( dot(v4,v5) ) +\n    \t    \tdot( n, normalize( cross(v5,v0)) ) * acos( dot(v5,v0) ))\n            \t/ 6.2831;\n}\n\n// returns t and normal\nvec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n//-----------------------------------------------------------------------------------------\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p.x, p.y-0.3,-3.5) );\n\t\n    // box animation\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\tvec3 box = vec3(0.2,0.5,0.6) ;\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = boxOcclusion( pos, nor, txx, txi, box );\n\n        col = vec3(1.1);\n        col *= 1.0 - occ;\n    }\n\n    vec4 res = boxIntersect( ro, rd, txx, txi, box );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = res.yzw;\n\t\tcol = vec3(0.8);\n\n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n//\t\tcol *= abs(onor.x)*texture( iChannel1, 0.5+0.5*opos.yz ).xyz + \n  //             abs(onor.y)*texture( iChannel1, 0.5+0.5*opos.zx ).xyz + \n    //           abs(onor.z)*texture( iChannel1, 0.5+0.5*opos.xy ).xyz;\n        col *= 1.7;\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 144, 232, 232, 1258], [1260, 1284, 1369, 1406, 1924], [1926, 2019, 2066, 2066, 2470], [2472, 2472, 2517, 2517, 2633], [2636, 2636, 2659, 2659, 2729], [2731, 2824, 2864, 2864, 2897], [2899, 2899, 2956, 2956, 4284]]}
{"id": "ttlfD8", "name": "circle test for nedoprogrammer", "author": "lapinozz", "description": "sfml", "tags": ["sfml"], "likes": 0, "viewed": 40, "published": "Public", "date": "1596638408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float space = 1.15;\n    float count = 5.;\n    float speed = 20.;\n    \n    float col = 5.;\n    float r = iResolution.x / ((count + space) * 2.);\n         \n    fragCoord.x = mod(fragCoord.x - iTime * speed, r * (2. + space - 1.));\n    fragCoord.y = mod(fragCoord.y + iTime * speed, r * (2. + space - 1.));\n    \n    fragColor = vec4(1. - pow(distance(vec2(r, r), fragCoord) / r, 2.)) * vec4(1., 1., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 513]]}
{"id": "ttlfRs", "name": "Spinner by Darko [WiP]", "author": "omegasbk", "description": "Just a simple spinner", "tags": ["loadspinner"], "likes": 1, "viewed": 48, "published": "Public", "date": "1597522296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat radius = 0.11;\n\nvec2 spinner1pos = vec2(-0.5, 0.1);\nvec2 spinner2pos = vec2(-0.2, 0.1);\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, vec2 position, float modifier) \n{    \n    return (1. - step(radius, distance(st, position)))\n            * (1. - step(0.005, abs(cos(-iTime * modifier) * (st.y - spinner1pos.y) - \n                                    sin(-iTime * modifier) * (st.x - spinner1pos.x))));\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt(dot(d, d));\n    d = normalize(d);\n    if(abs(d.y) > opening)\n\t    return SMOOTH(r-width/2.0, radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n\n    /*float thickness = 0.03;\n    float position = (sin(iTime * 4. + uv.x * 4.) + 1.) / 2.;\n    vec3 col = vec3(smoothstep(position-thickness, position, uv.y) - \n                    smoothstep(position, position+thickness, uv.y));*/\n   \n    vec3 col = vec3(plot(uv, spinner1pos, 0.5));\n    col += vec3(plot(uv, spinner1pos, 1.));\n    col += vec3(plot(uv, spinner1pos, 1.5));\n    col += vec3(plot(uv, spinner1pos, 2.));\n    col += vec3(plot(uv, spinner1pos, 2.5));\n    col += vec3(plot(uv, spinner1pos, 3.));\n    col += vec3(plot(uv, spinner1pos, 3.5));\n    col += vec3((step(radius, distance(uv, spinner1pos)) -\n                 step(radius + abs(cos(iTime) / 55.) + 0.01, distance(uv, spinner1pos))));\n    \n    \n    \n    float angle = dot(vec2(0., 1.), normalize(uv - spinner2pos));\n    \n    vec3 circle2;\n   \tcircle2 += vec3(\n        (step(0.2, sin(iTime) * angle)) * \n        ((step(radius, distance(uv, spinner2pos)) -\n                 step(radius + 0.01, distance(uv, spinner2pos)))));\n    \n    \n    col += circle2;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 201, 254, 254, 490], [492, 492, 570, 570, 775], [777, 777, 834, 884, 2059]]}
{"id": "ttlfWr", "name": "SlimeBox", "author": "lechuga", "description": "Im still learning, please let me know your feedback!", "tags": ["random", "box", "generator", "cuanticmslime"], "likes": 0, "viewed": 69, "published": "Public", "date": "1596518353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MD 200.\n#define MOD 20.\n\n#define speed time * 0.45\n\nfloat time;\nvec3 lpos;\nvec3 l;\nbool isFOV;\nfloat blue,purple;\n\nfloat slm;\n\nvec3 rep(in vec3 p, in float s, in float r){\n \treturn fract((p/s-r))*s-r;\n}\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat esf(in vec3 p, in float r){\n    return length(p)*0.4-r;\n}\n\nfloat cil(in vec3 p, in float r){\n \treturn length(p.xz)-r;\n}\n\nfloat box(in vec3 p, in float s){\n \treturn length(max(abs(p)-s, 0.));\n}\n\nfloat map(in vec3 p){\n    float t = time;\n    float r3 = 1.5+(sin(t+p.x)*cos(t*cos(t*.5)+p.y)*cos(t+p.z))*.6;\n\n    float scene = esf(p, r3);\n  \n    vec3 p1 = p;\n    p1.xz *= rot(cos(p1.y*0.02+time)*1.);\n    p1.zy *= rot(sin(p1.x*0.02+time)*1.);\n    \n    vec3 p2 = rep(p1-vec3(speed,0,speed), 2., 1.);\n    p2.xz *= rot(p2.y*0.02+time*0.2);\n    //p2.zy *= rot(p2.x*0.02+time);\n\tvec3 p3 = abs(p2);\n    p3.xz *= rot(p3.z*.2+cross(p3, p2).z)+speed*0.15+2.;\n    \n    \n    float\n        e1 = box(p1, 2.6),\n        e2 = cil(p3, 0.00001)*0.2,\n        e3 = esf(p1, r3)*2.;\n    purple += .2/(.05+e1);\n    blue += .1/(.05+e2);\n    \n    scene = max(-scene, e2);\n    scene = min(scene, e1);\n    scene = min(scene, e3);\n    \n    l+= smoothstep(0., 1.,p1+speed*.5)*0.4;\n    lpos -= cos(speed+p1)*0.5;\n    \n    slm = e3;\n    \n    return scene;\n}\n\nvec3 normals(in vec3 p){\n    vec2 e = vec2(.01, 0.);\n    vec3 n = p - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    return normalize(n);\n}\n\nvec3 cam(vec3 ro, vec2 uv){\n    float FOV = .2;\n    vec3 lt = vec3(0.);\n    \n    vec3 f = normalize(lt-ro);\n    vec3 r = cross(vec3(0.,1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro+f*FOV;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    return i-ro; // rd\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = (mod(iTime, MOD));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= iResolution.xy/iResolution.x;\n    \n    vec3 ro = vec3(1., 1., -7.);\n    \n    vec3 rd = cam(ro, uv);\n    \n    vec3 rv;\n    float d;\n    for(float i = 0.; i < MD; i++){\n        vec3 p = ro+rd*d;\n        d += map(p);\n        if((slm <= .08)){\n            vec3 n = normals(p);\n            rd = refract(p,n, .5)*0.03;\n    \t}\n        else if(d < 0.00001) break;\n    }\n\n    vec3 p = ro+rd*d;\n    l = normalize(lpos-p);\n    vec3 n = normals(p);\n    \n    float dif = (clamp((dot(n,l)*cos(speed*0.3)*.5), 0.4, 1.));\n    \n    vec3 col = vec3(dif*1.1);\n    col += rv;\n    col += blue * 0.01 * vec3(.02, 0.213, 0.3985);\n    col += purple * 0.05 * vec3(0.2, 0.1, 0.35);\n\n    col -= 1.-length(uv)*.2;\n    col += exp(col-.55);\n    col = pow(col, vec3(.5));\n    \n    fragColor = vec4(col, .1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 179, 179, 210], [212, 212, 230, 230, 282], [284, 284, 317, 317, 347], [349, 349, 382, 382, 409], [411, 411, 444, 444, 482], [484, 484, 505, 505, 1312], [1314, 1314, 1338, 1338, 1464], [1466, 1466, 1493, 1493, 1732], [1734, 1734, 1791, 1791, 2664]]}
{"id": "ttlfzs", "name": "Schwarz P surface", "author": "illus0r", "description": "Schwarz P surface", "tags": ["raymarching"], "likes": 3, "viewed": 157, "published": "Public API", "date": "1597525566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    \n    float scale = 5.5;\n    float surf = cos(p.x * scale) + cos(p.y * scale) + cos(p.z * scale) + 2. * sin(iTime);\n    surf = abs(surf) - 0.01;\n    surf *= 0.1;\n   \t\n    return max(box, surf);\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlfzs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 339, 358, 358, 420], [422, 422, 444, 444, 538], [540, 540, 569, 569, 650], [652, 652, 675, 675, 909], [916, 916, 950, 950, 1161], [1163, 1163, 1187, 1187, 1377], [1379, 1379, 1429, 1429, 1620], [1624, 1624, 1681, 1681, 2253]]}
{"id": "ttSBDh", "name": "Minimalism #07", "author": "Flopine", "description": "Seventh piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "triangle", "animation", "motion", "minimalist"], "likes": 4, "viewed": 144, "published": "Public", "date": "1598794111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define BPM (120./60.)\n#define dt(speed) fract(iTime*speed)\n#define AnimOutExpo(speed) easeOutExpo(dt(speed))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat easeOutExpo (float x)\n{ \treturn x == 1. ? 1. : 1. - pow(2., -10. * x); }\n\nfloat equitri (vec2 p, float r)\n{\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/sqrt(3.);\n    if (p.x+sqrt(3.)*p.y>0.) p=vec2(p.x-sqrt(3.)*p.y,-sqrt(3.)*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2.*r, 0. );\n    return -length(p)*sign(p.y);\n}\n\nfloat frame (vec2 uv)\n{\n    uv.y += 0.25;\n    float thin = 0.02;\n    float size = 1.;\n    float mask = 1.;\n    float offsettime = 0.05; \n    for (int i=0; i<6; i++)\n    {\n        uv *= rot(AnimOutExpo(BPM/4.-offsettime-PI)*TAU/3.);\n        mask *= AAstep(thin,abs(equitri(uv,size)));\n        offsettime += 0.05;\n        thin += 0.008;\n        size -= 0.2;\n    } \n    return mask;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= 1.4;\n    vec2 ruv = uv*(1.-AnimOutExpo(BPM/4.+0.05)*0.3);\n    vec2 guv = uv*(1.-AnimOutExpo(BPM/4.+0.1)*0.05);\n    vec2 buv = uv*(1.-AnimOutExpo(BPM/4.+0.15)*0.2);\n    vec3 col = vec3(1.-frame(ruv), 1.-frame(guv),frame(buv)); \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSBDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 607, 636, 636, 685], [687, 687, 720, 720, 919], [921, 921, 944, 944, 1302], [1304, 1304, 1360, 1360, 1698]]}
{"id": "ttsBR7", "name": "Homogeneous Shadow Volumes", "author": "skye_adaire", "description": "Click and drag to move the light.\nThe projection plane is shown in red, along with the projection of each vertex in blue.\nThe grey line passing through the light is the half plane boundary. \nVertices should not pass behind the light.", "tags": ["volume", "shadow", "implicit", "homogeneous", "projective"], "likes": 7, "viewed": 137, "published": "Public", "date": "1596480796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by Skye Adaire\nApache License 2.0\n\nThis algorithm produces shadow volumes by treating the projection\nof a set of triangles as a homogenized implicit surface.\n\nAn implicit function takes a \"position\" and outputs a scalar.\n\tf(x, y, ...) = level\n\twhen level < 0 the position is inside the surface\n\twhen level = 0 the position is on the surface\n\twhen level > 0 the position is outside the surface\n\nA function can be homogenized by:\n\tf(x, y) -> w^(degree(f)) * f(x / w, y / w) = h(x, y, w)\n\nThis easily generalizes to 3D.\nIn 2D our \"face\" is a line segment, and our simplex is a triangle.\nIn 3D our face is a triangle, and our simplex is a tetrahedron.\n\nThe algorithm:\n1. Project an object's triangles onto a light's projection plane\n\t(shown in red). I refer to the projected object as the \"umbra mesh.\"\n2. For each face of the object, determine whether that face is\n\ttowards the light.\n3. For faces towards the light (even if occluded) form a \"light simplex\"\n\t(faces included are shown in green)\n4. For faces away from the light form a \"shadow volume\"\n\t(faces included are shown in pink)\n5. For a point in the world, translate and rotate relative to the light\n\t(or use a generalized projective plane)\n6. Evaluate the point against each light simplex and shadow volume.\n7. If a point is included in more shadow volumes than light simplex,\n\tit is shadowed.\n\nNotes:\nFor points not shadowed, the minimum level curve across all shadow\nvolumes could be used as a distance estimate to the nearest shadow.\nThis could be used to make a penumbra region for soft shadows.\n\nFor homogenization, multiplying by w is not required, but doing so\nmakes the shadow level curves appear more regularly spaced.\n\nFor a scene with multiple objects and lights, an umbra mesh\ncould be computed and stored for each pair of object and light.\n*/\n\n#define SHOW_LEVEL_CURVES false\n\nvec2 rotateCW(vec2 n)\n{\n    return vec2(n.y, -n.x);\n}\n\nmat3 makeLightTransform(vec2 origin, vec2 normal)\n{\n    return mat3(rotateCW(normal), 0, normal, 0, origin, 1);\n}\n\nmat3 makeProjection(vec3 v, vec3 p)\n{\n \treturn mat3(v * p[0], v * p[1], v * p[2]) - mat3(dot(v, p));\n}\n\nvec2 hmul1(in mat3 m, in vec2 v)\n{\n \tvec3 hv = m * vec3(v, 1);\n    return hv.xy / hv.z;\n}\n\n//this is to make the generalization more apparent\n#define vec1 float\n\nvec1 projectWorldPositionToLight(in mat3 projectToPlane, in mat3 worldToLight, vec2 p)\n{\n    vec2 pRelLight = hmul1(worldToLight, p);\n    vec2 pProjected = hmul1(projectToPlane, pRelLight);\n    return pProjected.x;\n}\n\nfloat A_intersection(float a, float b)\n{\n \treturn max(a, b);\n}\n\nfloat A_union(float a, float b)\n{\n \treturn min(a, b);\n}\n\n//implicit half plane given two points on it's surface\nfloat A_halfPlane(vec2 a, vec2 b, vec2 p)\n{\n    b = a + normalize(b - a);//make it euclidean\n    return (b.y - a.y) * p.x - (b.x - a.x) * p.y + b.x * a.y - b.y * a.x;\n}\n\n//implicit triangle with non-euclidean level curves, winding order is important\nfloat A_triangle(vec2 v0, vec2 v1, vec2 v2, vec2 p)\n{\n    return\n        A_intersection(A_halfPlane(v0, v1, p),\n   \t\tA_intersection(A_halfPlane(v1, v2, p),\n   \t\tA_halfPlane(v2, v0, p)));\n}\n\n//implicit 1D disk / interval / segment\nfloat A_disk(vec1 a, vec1 b, vec1 p)\n{\n    //return (p - a) * (p - b);//algebraic, but not euclidean\n\treturn max(a - p, p - b);//euclidean\n}\n\nfloat umbraHomogeneous(vec1 v0, vec1 v1, vec2 p)\n{\n \treturn /*p.y * */ A_disk(v0, v1, p.x / p.y);\n}\n\nbool isCounterClockwise(vec2 a, vec2 b, vec2 c)\n{\n    return cross(vec3(b - a, 0), vec3(c - a, 0)).z < 0.0;\n}\n\nvoid orderTriangleCW(inout vec2 v0, inout vec2 v1, inout vec2 v2)\n{\n    if(isCounterClockwise(v0, v1, v2))\n    {\n        vec2 t = v1;\n        v1 = v2;\n        v2 = t;\n    }\n}\n\nvoid orderVolumes(inout vec1 v0, inout vec1 v1)\n{\n \tif(v1 < v0)\n    {\n     \tfloat t = v0;\n        v0 = v1;\n        v1 = t;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n\n    float modelScale = 11.0;\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseUnit = mouseUV - 0.5;\n    vec2 mouseRatio = mouseUnit * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 mouseWorld = modelScale * mouseRatio;\n\n    //the light is the point at infinity\n    float timeScale = iTime * 0.2;\n    vec2 defaultLightPosition = vec2(cos(timeScale), sin(timeScale)) * 5.0;\n    vec2 lightPosition = iMouse.z <= 0.0 ? defaultLightPosition : mouseWorld;\n    vec2 lightNormal = -normalize(lightPosition);\n    mat3 lightToWorld = makeLightTransform(lightPosition, lightNormal);\n    mat3 worldToLight = inverse(lightToWorld);\n\n    //these are fixed relative to the light, which is why we transform rel light\n    vec3 projectionPosition = vec3(0, 0, 1);\n    vec3 projectionPlane = vec3(0, 1, -1.0);\n    mat3 projectToPlane = makeProjection(projectionPosition, projectionPlane);\n\n    vec2 uvPosition = fragCoord/iResolution.xy;\n    vec2 unitPosition = uvPosition - 0.5;\n    vec2 ratioPosition = unitPosition * vec2(iResolution.x / float(iResolution.y), 1.0);\n    vec2 modelPosition = modelScale * ratioPosition;\n    vec2 positionRelLight = hmul1(worldToLight, modelPosition);\n\n    #define vertexCount 9\n    vec2 objectPositions[vertexCount];\n    objectPositions[0] = vec2(-1.0, -1.3);\n    objectPositions[1] = vec2(3.5, 1.3);\n    objectPositions[2] = vec2(0.2, 0.2);\n    objectPositions[3] = vec2(-0.1, 3.0);\n    objectPositions[4] = vec2(-1.5, 1.0);\n    objectPositions[5] = vec2(-4.0, 0.5);\n    objectPositions[6] = vec2(3.0, -1.0);\n    objectPositions[7] = vec2(2.5, -1.5);\n    objectPositions[8] = vec2(3.5, -1.5);\n\n    #define triangleCount 4\n    ivec3 triangles[triangleCount];\n    triangles[0] = ivec3(0, 1, 2);\n    triangles[1] = ivec3(2, 3, 0);\n    triangles[2] = ivec3(0, 4, 5);\n    triangles[3] = ivec3(6, 7, 8);\n\n    vec1 umbraMesh[vertexCount];//the projected object\n\n    for(int i = 0; i < vertexCount; i++)\n    {\n     \tumbraMesh[i] = projectWorldPositionToLight(projectToPlane, worldToLight, objectPositions[i]);\n    }\n\n    //identify the faces pointing towards and away from the light\n    int lightSimplexCount = 0;\n    ivec2 lightSimplexes[10];\n    int shadowVolumeCount = 0;\n    ivec2 shadowVolumes[10];\n\n    for(int i = 0; i < triangleCount; i++)\n    {\n        int v0 = triangles[i].x;\n        int v1 = triangles[i].y;\n        int v2 = triangles[i].z;\n\n        vec2 i0 = lightPosition - objectPositions[v0];\n        vec2 i1 = lightPosition - objectPositions[v1];\n        vec2 i2 = lightPosition - objectPositions[v2];\n\n        vec2 n0 = rotateCW(objectPositions[v1] - objectPositions[v0]);\n        vec2 n1 = rotateCW(objectPositions[v2] - objectPositions[v1]);\n        vec2 n2 = rotateCW(objectPositions[v0] - objectPositions[v2]);\n\n       \tif(dot(n0, i0) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v0, v1);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v0, v1);\n            shadowVolumeCount++;\n        }\n\n        if(dot(n1, i1) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v1, v2);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v1, v2);\n            shadowVolumeCount++;\n        }\n\n        if(dot(n2, i2) >= 0.0)\n        {\n            lightSimplexes[lightSimplexCount] = ivec2(v2, v0);\n            lightSimplexCount++;\n        }\n        else\n        {\n            shadowVolumes[shadowVolumeCount] = ivec2(v2, v0);\n            shadowVolumeCount++;\n        }\n    }\n\n    int simplexShadowParity = 0;\n\n    //form a simplex with each face and the point at infinity\n    for(int i = 0; i < lightSimplexCount; i++)\n    {\n\t\tvec2 p0 = objectPositions[lightSimplexes[i].x];\n        vec2 p1 = objectPositions[lightSimplexes[i].y];\n        vec2 p2 = lightPosition;\n       \torderTriangleCW(p0, p1, p2);\n        \n        float level = A_triangle(p0, p1, p2, modelPosition);\n\n        if(level < 0.0)\n        {\n            simplexShadowParity += 1;\n        }\n    }\n\n    float shadowLevel = 1e10;\n\n    if(positionRelLight.y > 0.0)//exclude the volume behind the light\n    {\n        for(int i = 0; i < shadowVolumeCount; i++)\n        {\n\t\t\tvec1 v0 = umbraMesh[shadowVolumes[i].y];\n            vec1 v1 = umbraMesh[shadowVolumes[i].x];\n            orderVolumes(v0, v1);\n\n            float level = umbraHomogeneous(v0, v1, positionRelLight);\n\n            shadowLevel = A_union(level, shadowLevel);\n\n            if(level < 0.0)\n            {\n                simplexShadowParity -= 1;\n            }\n        }\n    }\n\n    if(simplexShadowParity < 0)//the position is in shadow\n    {\n     \tcolor += vec3(0.2);\n\n        if(SHOW_LEVEL_CURVES)\n        {\n            color -= pow(cos(5.0 * shadowLevel * 3.14159), 40.0) * 0.1;\n        }\n    }\n    else //the position is in light\n    {\n     \tcolor += vec3(0.6);\n\n        if(SHOW_LEVEL_CURVES)\n        {\n            color += pow(cos(5.0 * shadowLevel * 3.14159), 40.0) * 0.1;\n        }\n    }\n\n    //shade the border of the positive half plane through the light\n    if(abs(positionRelLight.y) < 0.05)\n    {\n     \tcolor = vec3(0.5);\n    }\n\n    vec3 lightEdgeColor = vec3(0.5, 0.9, 0.5);\n    vec3 shadowEdgeColor = vec3(0.86, 0.39, 0.73);\n    float edgeWidth = 0.1;\n\n    //draw triangles\n    for(int i = 0; i < triangleCount; i++)\n    {\n        int v0 = triangles[i].x;\n        int v1 = triangles[i].y;\n        int v2 = triangles[i].z;\n\n        if(A_triangle(objectPositions[v0], objectPositions[v1], objectPositions[v2], modelPosition) < 0.0)\n        {\n            color = vec3(1);\n\n            //shade edges based on parity\n\n            for(int j = 0; j < lightSimplexCount; j++)\n            {\n             \tivec2 s = lightSimplexes[j];\n\n                if(abs(A_halfPlane(objectPositions[v0], objectPositions[v1], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v0, v1) || s == ivec2(v1, v0))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v1], objectPositions[v2], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v1, v2) || s == ivec2(v2, v1))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v2], objectPositions[v0], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v2, v0) || s == ivec2(v0, v2))\n                    {\n                        color = lightEdgeColor;\n                    }\n                }\n            }\n\n            for(int j = 0; j < shadowVolumeCount; j++)\n            {\n             \tivec2 s = shadowVolumes[j];\n\n                if(abs(A_halfPlane(objectPositions[v0], objectPositions[v1], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v0, v1) || s == ivec2(v1, v0))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v1], objectPositions[v2], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v1, v2) || s == ivec2(v2, v1))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n                else if(abs(A_halfPlane(objectPositions[v2], objectPositions[v0], modelPosition)) < edgeWidth)\n                {\n                    if(s == ivec2(v2, v0) || s == ivec2(v0, v2))\n                    {\n                        color = shadowEdgeColor;\n                    }\n                }\n            }\n        }\n    }\n\n    //draw real line\n    if(abs(positionRelLight.y - 1.0) < 0.05)\n    {\n     \tcolor = vec3(1.0, 0.2, 0.1);\n    }\n\n    vec3 vertexColor = vec3(0.2, 1, 1);\n\n    //draw vertices\n    for(int i = 0; i < vertexCount; i++)\n    {\n        //R2\n        if(length(modelPosition - objectPositions[i]) < 0.1)\n        {\n            color = vertexColor;\n        }\n\n        //projection in R1\n        if(abs(positionRelLight.y - 1.0) < 0.05 && abs(positionRelLight.x - umbraMesh[i]) < 0.1)\n        {\n            color = vertexColor;\n        }\n    }\n\n    //draw dot for light\n    if(length(positionRelLight) < 0.2)\n    {\n        color = vec3(1);\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBR7.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[0, 1858, 1881, 1881, 1911], [1913, 1913, 1964, 1964, 2026], [2028, 2028, 2065, 2065, 2130], [2132, 2132, 2166, 2166, 2221], [2223, 2294, 2382, 2382, 2510], [2512, 2512, 2552, 2552, 2574], [2576, 2576, 2609, 2609, 2631], [2633, 2688, 2731, 2731, 2856], [2858, 2938, 2991, 2991, 3126], [3128, 3168, 3206, 3268, 3308], [3310, 3310, 3360, 3360, 3409], [3411, 3411, 3460, 3460, 3520], [3522, 3522, 3589, 3589, 3696], [3698, 3698, 3747, 3747, 3828], [3830, 3830, 3887, 3887, 12349]]}
{"id": "ttsBRs", "name": "Depth of Field Raymarching", "author": "athibaul", "description": "A modified raymarching loop that allows to approximate a depth of field effect.", "tags": ["3d", "raymarching", "dof", "depthoffield"], "likes": 9, "viewed": 163, "published": "Public", "date": "1597521151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Depth of Field effect in Raymarching\n// by athibaul\n//\n// Uses a modified raymarching loop to evaluate\n// partial obstruction by nearby objects.\n//\n// Effectively combines views of the \n// inflated and shrunk objects in a smart way.\n\n// UPDATE 17/12/2020 - Added texture filtering based on comment by Xor\n\n#define MAX_STEPS 2048\n\nvec3 sun = normalize(vec3(-1., -1., 2.));\n\nfloat sclamp(float x, float k){\n    float h = max(k-abs(abs(x)-1.), 0.);\n    return clamp(x, -1., 1.) - sign(x)*h*h/(4.*k);\n}\n\n\nfloat sphereSDF(vec3 pos)\n{\n    // Repeating pattern of spheres\n    \n    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);\n    turned = 6.0*round(turned/6.0);\n    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;\n    pos.x -= turned.x;\n    if(pos.y>-7.5)\n    \tpos.y -= turned.y;\n    return length(pos-vec3(0.,0.,1.))-1.;\n}\n\nfloat planeSDF(vec3 pos)\n{\n    // Bottom plane\n    return pos.z+0.4;\n}\n\nfloat blocksSDF(vec3 pos)\n{\n    // Just a few blocks\n    // Rounded box distance function by iq\n    // https://www.youtube.com/watch?v=62-pRVZuS5c\n    pos.xy -= 3.*round(pos.xy/3.);\n    vec3 c = vec3(0., 0., 0.0);\n    float rounded = 0.1;\n    vec3 r = vec3(0.3, 0.3, 0.8)-rounded;\n    vec3 q = abs(pos - c) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n}\n\nint surfaceHit = -1; // 0 for plane, 1 for spheres, 2 for blocks\nfloat sceneSDF(vec3 pos)\n{\n    pos.xz += 1.-cos(pos.y/30.) - sin(pos.x/20.);\n    pos.y += sin(pos.y/40.)+1.-cos(pos.x/25.);\n    float d = planeSDF(pos);\n    surfaceHit = 0;\n    float d1 = sphereSDF(pos);\n    if(d1<d) { surfaceHit = 1; d = d1; }\n    d1 = blocksSDF(pos);\n    if(d1<d) { surfaceHit = 2; d = d1; }\n    return d;\n}\n\n\nvec3 calculateNormal(vec3 pos)\n{\n    // Tetrahedral normal calculation method by iq\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * sceneSDF(pos+e.xxx)\n            + e.xyy * sceneSDF(pos+e.xyy)\n            + e.yxy * sceneSDF(pos+e.yxy)\n            + e.yyx * sceneSDF(pos+e.yyx));\n}\n\nvec3 rayDir(vec3 camFwd, float fov, vec2 uv)\n{\n    // In what direction to shoot?\n    vec3 camUp = vec3(0.,0.,1.);\n    camUp = normalize(camUp - camFwd*dot(camFwd, camUp)); // Orthonormalize\n    vec3 camRight = cross(camFwd, camUp);\n    return normalize(camFwd + (uv.x * camRight + uv.y * camUp)*fov);\n}\n\nvec3 texColor(vec3 p, float lodBias)\n{\n    //vec3 d = vec3(sceneSDF(p), planeSDF(p), sphereSDF(p));\n    if(surfaceHit==0) // Plane hit\n    { \n        return (texture(iChannel1, p.xy*0.03, lodBias)\n                + texture(iChannel1, p.xy*0.2, lodBias)).rgb/1.4;\n    }\n    if(surfaceHit==1) // Spheres hit\n    {\n        p *= 0.2*1.618;\n        return (texture(iChannel0, p.xy, lodBias)\n                +texture(iChannel0, p.yz, lodBias)\n                +texture(iChannel0, p.zx, lodBias)).rgb/2.;\n    }\n    // Blocks hit\n    p *= 0.3*1.618;\n    return (texture(iChannel2, p.xy, lodBias)\n            +texture(iChannel2, p.yz, lodBias)\n            +texture(iChannel2, p.zx, lodBias)).rgb/2.;\n}\n\nvec3 computeColor(in vec3 p, float lodBias){\n    vec3 normal = calculateNormal(p);\n    float diffuse = max(dot(normal, sun), 0.);\n    return diffuse*texColor(p, lodBias);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // uv.y goes between +-1, and uv.x a bit more depending on the display format.\n\n    // Camera ray\n    //vec3 ro = vec3(2.*cos(iTime*0.5), -8., 2.+sin(iTime));\n    float motion = sclamp(1.3*cos(0.5*iTime), 0.15);\n    float mot2 = cos(3.*iTime);\n    float mot3 = cos(1.618*2.*iTime+5.);\n    vec3 unsteady = (mot2+mot3)*vec3(0.01,0.0,0.)\n        +(mot2-mot3)*vec3(0.,0.,0.01);\n    vec3 ro = vec3(2.8,-8.,2.+1.1*motion) + unsteady.xyz;\n    vec3 target = vec3(0.,0.,1.) + unsteady.zyx;\n    vec3 ri = rayDir(normalize(target-ro), 0.5, uv);\n    float w0 = 0.1; // Camera aperture size\n    //float fp = length(ro)-1.; // Camera focus distance\n    float fp = exp(1.4*motion)*8.;\n\n    // Modified raymarching\n    // \n    float d, t=0.;\n    float stepsize;\n    float w;\n    float ocl=0., ocl_c;\n    vec3 col=vec3(0.), col_c; // Current collected luminance\n    float pxSpread = length(fwidth(ri)); // \n    for(int j=0; j<MAX_STEPS; j++)\n    {\n        d = sceneSDF(ro + t*ri);\n        // Local spread of light rays:\n        // Starting with a spread of w0, they converge at a distance of fp,\n        // with a minimal spread of 5mm, then diverge again.\n        w = w0 * abs(1. - t/fp)+0.005;\n        // Partial occlusion occurs when an object is at a distance\n        // less than w from the ray.\n        // We approximate this by testing if d is between +-w.\n        ocl_c = clamp(0.5*(1.-d/w), 0.,1.);\n        //ocl_c *= ocl_c;\n        // In case of partial occlusion, compute local luminance\n        if(ocl_c > min(ocl+0.01, 0.99))\n        { \n            // filter textures based on ray width - thank you Xor!\n            float lodBias = log2(w*200.);\n        \tcol_c = computeColor(ro+t*ri, lodBias);\n            col += (ocl_c - ocl)*col_c;\n            ocl = ocl_c;\n        }\n        // We must march down to a depth of at least d=-w\n        //stepsize = max(0.7*d,0.)+0.5*w;\n        //stepsize = 0.7*(d + w);\n        stepsize = max(0.7*(d-w),0.)+pxSpread*t; // No artifacts, but many steps\n        if(ocl >= 0.99){break;}\n        t += stepsize;\n        if(t>1000.){t=1000.; break; }\n    }\n    vec3 pos = ro + t*ri;\n    vec3 sky = 1.3*vec3(0.5,0.7,0.9);\n    col += (1.-ocl) * sky;\n    // Tone mapping\n    //col = 1.-exp(-2.*col);\n    \n    // Output to screen\n    fragColor.rgb = vec3(col);\n    \n    \n    //fragColor.rgb = vec3(ocl);\n    \n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 376, 407, 407, 501], [504, 504, 531, 567, 829], [831, 831, 857, 877, 901], [903, 903, 930, 1049, 1292], [1315, 1359, 1385, 1385, 1685], [1688, 1688, 1720, 1771, 1983], [1985, 1985, 2031, 2066, 2288], [2290, 2290, 2328, 2389, 2981], [2983, 2983, 3027, 3027, 3155], [3157, 3157, 3214, 3214, 5648]]}
{"id": "ttsBWl", "name": " Procgen Planet mod", "author": "evgenys", "description": "\"Procgen Planet\" shader mod with the reference 3D Perlin noise function to avoid noise artifacts.", "tags": ["procedural", "noise", "fbm", "planet", "domainwarping", "procgen"], "likes": 7, "viewed": 429, "published": "Public API", "date": "1598100358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is a fork of Procgen Planet from https://www.shadertoy.com/view/tltXWM .\n// The problem of Procgen Planet is that there are visible noise artifacts\n// (white dots randomly appearing).\n//\n// This fork uses the reference Perlin 3D function from https://mrl.nyu.edu/~perlin/noise/\n// which fixes the white flashes.\n//\n\nint[] perm = int[](\n    151,160,137,91,90,15,\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n    151\n);\nint perm1plus(int i, int k) { return int(mod(float(perm[i]) + float(k), 256.)); }\n\nfloat Fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfloat Grad(int hash, float x, float y, float z) {\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nfloat Noise3D(vec3 val) {\n    vec3 v1 = floor(val);\n    vec3 v2 = fract(val);\n    int X = int(mod(v1.x, 256.));\n    int Y = int(mod(v1.y, 256.));\n    int Z = int(mod(v1.z, 256.));\n    float x = v2.x;\n    float y = v2.y;\n    float z = v2.z;\n    float u = Fade(x);\n    float v = Fade(y);\n    float w = Fade(z);\n    int A  = perm1plus(X, Y);\n    int B  = perm1plus(X+1, Y);\n    int AA = perm1plus(A, Z);\n    int BA = perm1plus(B, Z);\n    int AB = perm1plus(A+1, Z);\n    int BB = perm1plus(B+1, Z);\n\n    return mix(mix(mix(Grad(perm[AA  ], x, y   , z  ),  Grad(perm[BA  ], x-1., y   , z  ), u),\n                   mix(Grad(perm[AB  ], x, y-1., z  ),  Grad(perm[BB  ], x-1., y-1., z  ), u),\n                   v),\n               mix(mix(Grad(perm[AA+1], x, y   , z-1.), Grad(perm[BA+1], x-1., y   , z-1.), u),\n                   mix(Grad(perm[AB+1], x, y-1., z-1.), Grad(perm[BB+1], x-1., y-1., z-1.), u),\n                   v),\n               w);\n}\n\n// Noise functions and most of the implementation based on\n// https://www.shadertoy.com/view/4dS3Wd by Morgan McGuire @morgan3d!\n\n// see also\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n// https://thebookofshaders.com/13/\n// for informations on fbm, noise, ...\n\n// please check out stuff like: https://www.shadertoy.com/view/lsGGDd\n// for more advanced planet lighting/clouds/...\n\n// Looking for a blue planet? Colors:\n// vec3 col_top = vec3(0.0, 0.5, 0.0);\n// vec3 col_bot = vec3(0.0, 1.0, 1.0);\n// vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n// vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n// vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n// size of the planet\n#define PLANET_SIZE\t\t0.75\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\t//v += a * noise(x);\n        v += a * (Noise3D(x) * .5 + .5);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nvec3 getColorForCoord(vec2 fragCoord) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n\tfloat v = 0.0;\n    vec3 color = vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 25.0 * pi / 180.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n    \n    // calculate color for sphere/background\n    if (t < inf) {\n        // calculate point of intersection on the sphere\n        vec3 X = P + w*t;\n\n        // apply rotation matrix\n        X = rot*X;\n\n        // calculate fbm noise (3 steps)\n        q = vec3(fbm(X + 0.025*iTime), fbm(X), fbm(X));\n        r = vec3(fbm(X + 1.0*q + 0.01*iTime), fbm(X + q), fbm(X + q));\n        v = fbm(X + 5.0*r + iTime*0.005);\n    } else {\n        // ray missed the sphere\n\t\treturn vec3(0.0);\n    }\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n    vec3 col_top = vec3(1.0, 1.0, 1.0);\n    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 1.0)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    //color *= (P + w*t).z * 2.0;\n    color *= (P + w*t).z * 1.0;\n#endif    \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n#ifdef SHARPEN \n    // use a simple sharpen filter (you could improve that immensely!\n    fragColor.rgb =\n        getColorForCoord(fragCoord) * 3. -\n        getColorForCoord(fragCoord + vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord + vec2(0.0, 1.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(1.0, 0.0)) * 0.5 -\n        getColorForCoord(fragCoord - vec2(0.0, 1.0)) * 0.5;\n#else\n    // just use a single pass\n    fragColor.rgb = getColorForCoord(fragCoord);\n#endif\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1349, 1378, 1378, 1430], [1432, 1432, 1453, 1453, 1502], [1504, 1504, 1553, 1553, 1725], [1727, 1727, 1752, 1752, 2671], [3731, 3805, 3826, 3826, 3893], [3895, 3895, 3916, 3916, 4499], [4501, 4501, 4520, 4520, 4739], [4741, 5011, 5034, 5034, 5050], [5051, 5051, 5081, 5081, 5112], [5114, 5189, 5245, 5245, 5519], [5521, 5553, 5574, 5574, 5612], [5614, 5614, 5653, 5690, 8262], [8264, 8264, 8320, 8320, 8884]]}
{"id": "ttsBzM", "name": "Aerial corridor", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 22, "viewed": 272, "published": "Public", "date": "1596377428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Scale;\n\nfloat map(vec3 p){\n    p=mod(p,2.)-1.;\n    p=abs(p)-1.;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x<p.y)p.xy=p.yx;\n    float s=1.;\n    for(int i=0;i<10;i++)\n    {\n      float r2=2./clamp(dot(p,p),.1,1.);\n      p=abs(p)*r2-vec3(.6,.6,3.5);\n      s*=r2;\n    }\n    Scale=log2(s);\n    return length(p)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(.5+.2*sin(iTime*.03),.05*cos(iTime*.03),-.1*iTime),\n  \t\tw=normalize(vec3(.2,sin(iTime*.1),-1)),\n  \t\tu=normalize(cross(w,vec3(0,1,0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n  \tfloat h=.4,d,i;\n \tfor(i=1.;i<100.;i++)\n    {\n    \tp=ro+rd*h;\n    \td=map(p);\n    \tif(d<.001||h>10.)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=mix(vec3(1),vec3(cos(Scale*2.5+p*1.8)*.5+.5),0.5)*10./i;\n    if(i<5.)fragColor.xyz=vec3(.5,.2,.1)*(5.-i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 32, 32, 335], [337, 337, 394, 394, 900]]}
{"id": "ttsfD8", "name": "[TWITCH] Lowlands juggernauts", "author": "evvvvil", "description": "Lowlands juggernauts - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "beam", "glow", "organic", "monster", "dark", "core", "tank", "creature", "juggernaut", "monumental"], "likes": 24, "viewed": 990, "published": "Public API", "date": "1596643243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lowlands juggernauts - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n// Thankx to Flopine for the octan mirror method suggestion, and thanks to Mercury for writing it.\n\n// \"Fortnite is cool, but don't forget who the real fascists are.\" - Woody Guthrie\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,gg,tnoi;vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nvec2 mo(vec2 p, vec2 d) {p=abs(p)-d;if(p.y>p.x) p=p.yx;return p;} //FLOPINE MULTI OCTAN MIRROR THINGY WRITEN BY MERCURY IN THEIR SDF LIB  https://www.shadertoy.com/view/ttffWH\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p )\n{ \n  np=p; p.z=mod(p.z+tt*5.,40.)-20.;  \n  op=p; //Originally thought I would do a sort of bounce animation but i found this slow forward crawl more menacing:\n  p.y+=sin(op.z*.2+tt)*3.-5.; //Flopine pointed out a really good bounce ease function like this: p.y -= bouncy(fract(tt))*10.; using this function: float bouncy (float T){return sqrt(abs(sin(T*PI)));} \n  pp=p; //Thankx again Flopine\n  pp.xz=mo(pp.xz, vec2(1.)); \n  pp.yz*=r2(1.2+sin(p.y*.5+tt)*.3);\n  pp.yz=mo(pp.yz,vec2(0.5,1.));\n  pp.xy=mo(pp.xy,vec2(2.5));  \n  tnoi=texNoise((np.xz+vec2(20,tt*2.))*.018).r;    \n  vec2 h,t=vec2(length(p)-5.,5); //SHELL BLUE\n  t.x=max(abs(t.x)-.4,abs(pp.z)-.5);    \n  t.x=min(t.x,0.5*(op.y+tnoi*8.+4.)); //TERRAIN BLUE\n  bp=pp; bp.xy*=r2(-.9);\n  t.x=smin(t.x,0.6*max(length(bp.xz)-max(1.4-tnoi*4.,0.45),p.y-6.),1.); //TENTACLES BLUE    \n  float frill=sin(pp.y*15.)*0.03;    \n  h=vec2(length(p)-5.5,6); //SHELL WHITE\n  h.x=max(h.x,abs(pp.z)-.2);\n  h.x=max(h.x,-(length(p)-4.+frill));\n  bp=pp; bp.xy*=r2(.4585);\n  h.x=min(0.8*length(bp.yz+vec2(2,0.))-.1+abs(bp.x)*.02,h.x);\n  t=t.x<h.x?t:h;  \n  h=vec2(length(p)-5.4,3); //SHELL BLACK\n  h.x=abs(h.x)-.2;\n  h.x=max(h.x,abs(pp.z)-.3);  \n  h.x=max(h.x,abs(abs(abs(pp.x)-1.)-.5)-.25);  \n  t=t.x<h.x?t:h;    \n  h=vec2(length(p)-3.+frill,5); //CORE \n  pp.xy*=r2(-.6); h.x=smin(h.x,.8*length(pp.xz-vec2(.2,1.+tnoi*3.))-.4+frill,3.);  \n  t=t.x<h.x?t:h;   \n  h.x=min(h.x,0.2*length(cos(op*.2)-1.5)); //TERRAIN SOFT ORBS\n  g+=0.1/(0.1+h.x*h.x*40.);  \n  h=vec2(length(p)-3.+frill,5); //RED CORE   \n  pp.xy*=r2(-.1);\n  h.x=smin(h.x,length(pp.xz-vec2(.2,1.1+tnoi*3.))-.2+frill,3.);\n  h.x=smin(h.x,.6*length(abs(bp+vec3(2,2.+tnoi*5.,0.))-2.)-.7,1.);    \n  gg+=0.1/(0.1+h.x*h.x*(80.-79.9*sin(op.y*.2+tt+1.)));\n  t=t.x<h.x?t:h; t.x*=0.7;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(0);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y;    \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=mix(vec3(0,-4,-15.),vec3(10,2,-15.),ceil(sin(tt))),\n  cw=normalize(vec3(0,0,0)-ro),\n  cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.15,.1,.14)-length(uv)*.2;\n  ld=normalize(vec3(.3,.1,-.3));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=vec3(.1,.2,.4);\n    if(z.y<5.)al=vec3(0);\n    if(z.y>5.)al=vec3(1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.05)*a(.1)+.2)*(dif*vec3(.1,.2,.4)*3.+s(.5)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.00005*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 456, 480, 480, 522], [523, 523, 540, 540, 583], [584, 584, 626, 626, 691], [692, 692, 717, 717, 757], [758, 868, 891, 891, 1164], [1165, 1165, 1184, 1184, 2960], [2961, 2961, 2989, 2989, 3158], [3248, 3248, 3305, 3305, 4196]]}
{"id": "ttsfDf", "name": "descompuesto apollonian-v4", "author": "jorge2017a1", "description": "descompuesto apollonian-v4", "tags": ["descompuestoapollonianv4"], "likes": 3, "viewed": 90, "published": "Public", "date": "1597978017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modificado por jorge2017a1\n\n// Created by inigo quilez - iq/2013---\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level. Make it 2 or 3 if you have a fast machine\n#define AA 1\n\nvec4 orb; \n\nfloat tau = atan(1.0) * 8.0;  \n\n///==== Distance field operators/functions by iq. ====\nfloat opU( float d1, float d2 )\n{ return min(d1,d2);  }\n\nfloat opS( float d1, float d2 )\n{  return max(-d1, d2);}\n\nfloat opI( float d1, float d2 )\n{ return max(d1,d2);  }\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n///==== Distance field operators/functions by iq. ====\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n    vec3 pp=p;\n\torb = vec4(1000.0); \n    \n    float dps=0.5;\n\t\n    \n    \n\tfor( int i=0; i<8;i++ )\n\t{\n\t\t\n        float sdc1= sdSphere( p-vec3(0.0,0.8,0.0), 3.0 );\n        p = -1.0 + 2.0*fract(0.5*p+0.5+float(i));\n        \n        float r2 = dot(p,p);\n\t\tr2= opI( r2, sdc1 );\n        \n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n        float k = 1.7/(r2);\n\t\tp     *= k;\n\t\tscale *= k;\n        \n\t}\n\t\n    return 0.23*abs(p.y)/scale;\n   \n}\n\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.4,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(1.0,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.01,0.02), clamp(6.0*tra.y,0.0,1.0) );\n      \n        rgb = mix( rgb, vec3(0.0,1.0,0.5), pow(clamp(1.0-2.0*tra.x,0.0,1.0),8.0) );\n        \n\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 1.0 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.82,1.2,-0.3), fragRayDir, anim );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[411, 466, 499, 499, 521], [523, 523, 556, 556, 579], [581, 581, 614, 614, 636], [638, 666, 707, 707, 800], [801, 857, 893, 893, 996], [999, 999, 1034, 1034, 1058], [1062, 1062, 1092, 1092, 1549], [1552, 1552, 1600, 1600, 1853], [1855, 1855, 1911, 1911, 2162], [2164, 2164, 2218, 2232, 3232], [3234, 3234, 3291, 3291, 4294], [4296, 4296, 4390, 4390, 4617]]}
{"id": "ttSfRh", "name": "sine-wave (正弦波浪)", "author": "ifaswind", "description": "a simple sine wave.\n一个简单的正弦曲线波浪。", "tags": ["wave", "sine"], "likes": 2, "viewed": 594, "published": "Public", "date": "1598553789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 将像素坐标归一化（区间 [0.0, 1.0]）\n    vec2 uv = fragCoord / iResolution.xy;\n\t\n    // 振幅（控制波浪顶端和底端的高度）\n    float amplitude = 0.05;\n    \n    // 角速度（控制波浪的周期）\n    float angularVelocity = 10.0;\n    \n    // 频率（控制波浪移动的速度）\n    float frequency = 10.0;\n    \n    // 偏距（设为 0.5 使得波浪垂直居中于屏幕）\n    float offset = 0.5;\n    \n    // 代入正弦曲线公式计算 y 值\n    // y = Asin(ωx ± φ) + k\n    float y = amplitude * sin((angularVelocity * uv.x) + (frequency * iTime)) + offset;\n    \n    // 区分上下部分\n    vec4 color = uv.y > y ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(0.0, 0.7, 0.9, 1.0);\n\t\n    // 输出到屏幕\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 826]]}
{"id": "ttsfRS", "name": "9. Simple Camera Model", "author": "altera0", "description": "Source : https://www.youtube.com/watch?v=PBxuVlp7nuM\n\nMy Connection Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["simplecameramodel"], "likes": 0, "viewed": 164, "published": "Public API", "date": "1597081570", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Get Distance To The Ray Rd\nfloat DistanceLine( vec3 ro , vec3 rd , vec3 p ) {\n    float h = length( cross( ( p - ro ) , rd ) ) / length(rd);\n    return h;\n}\n\n// Draw Circle\nfloat DrawCircle(vec3 ro , vec3 rd , vec3 p, float radius ) {\n    float h = DistanceLine( ro , rd , p );\n    h = smoothstep ( radius , radius - 0.001f , h );\n    return h;\n}\n\n// Cube \nfloat CircleCube( vec2 uv , vec3 camPos , float zoom, vec3 objectCenter, float len ) {\n    \n    vec3 lookAt = objectCenter - camPos;\n    \n    vec3 F = normalize( lookAt );\n\n    vec3 R = normalize( cross( vec3(0.0f,1.0f,0.0f), F  ) );\n    vec3 U = normalize( cross( F , R ) );\n\t\n    vec3 nearPlanCenter = camPos + F * zoom;\t// ( - ) \n    vec3 intersectionPoint = nearPlanCenter + uv.x * R + uv.y * U;\n    \n    vec3 rd = intersectionPoint - camPos;\n    \n    float h = 0.0f;\n    float hDiv2 = len/2.0f;\n    \n    // left bottom\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , -hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , -hDiv2 , +hDiv2 ) , 0.1f );\n    \n    // left top\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , +hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( -hDiv2 , +hDiv2 , +hDiv2 ) , 0.1f );\n    \n\t// right bottom\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , -hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , -hDiv2 , +hDiv2 ) , 0.1f );\n    \n    // right top\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , +hDiv2 , -hDiv2 ) , 0.1f );\n    h += DrawCircle( camPos , rd , objectCenter + vec3( +hDiv2 , +hDiv2 , +hDiv2 ) , 0.1f );\n    \n    return h;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n     \n    \n    // variables\n\tfloat zoom = 2.0f;\n    \n    vec3 camPos = vec3( cos(iTime) * 4.0f - sin (iTime) * 4.0f , 4.0f , cos(iTime) * 4.0f + sin(iTime) * 4.0f );\t\t// ro\n    vec3 objectCenter = vec3 (0.0f, 0.0f , 10.0f ); \t// center of Object\n    \n    float cubeLength = 2.0f;\n    \n    \n    \n    float h = CircleCube( uv, camPos , zoom , objectCenter, cubeLength );\n    \n    vec3 col = vec3(h);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 80, 80, 159], [161, 176, 237, 237, 349], [351, 360, 446, 446, 1713], [1715, 1723, 1780, 1780, 2315]]}
{"id": "ttsfRX", "name": "screen blending", "author": "nshelton", "description": "a way to blend projection screens ", "tags": ["distancefield"], "likes": 1, "viewed": 77, "published": "Public", "date": "1597355565", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n// distance to a box\nfloat sdBox( in vec2 p, in vec2 b) \n{\n    vec2 q = abs(p)-b ;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) ;\n}\n\n\nmat2 rotationMatrix(float theta) \n{\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    \n\tvec2 size = vec2(0.9,0.6);\n \n    // translate right screen\n    vec2 p0 = p + vec2(sin(iTime)* 0.2 - 0.5, 0.0);\n\tfloat d0 = sdBox(p0, size);\n    \n    //rotate left screen\n    vec2 p1 = p * rotationMatrix(0.2 + sin(iTime * 0.39));\n    float d1 = sdBox( p1 + 0.5, size  );\n\n       \n    vec3 color = vec3(0.0);\n       \n\n    if ( d0 < 0.0 && d1 > 0.0)\n    {\n        // right screen \n        color = vec3(1.,0.,0.);\n        \n    } \n    else if ( d0 > 0.0 && d1 < 0.0)\n    {\n        // left screen\n        color = vec3(0.,0.,1.);\n    }\n    if (d0 < 0.0 && d1 < 0.0)\n    {\n        // both screens\n\n        // Version 1 (bad weighting)\n        //color = vec3(-d0 , 0.0, -d1 ) / (-d0 + -d1);\n\n        //Version 2 \n        float weight0 = -d0 * (-1.0/d1);\n        float weight1 = -d1 * (-1.0/d0);\n        \n        \n        color = vec3(weight0, 0.0, weight1) / (weight1 + weight0);\n    }\n\n    // Show left screen\n\t//fragColor = vec4(color.bbb ,1.0);\n    \n    // Show right screen\n\t//fragColor = vec4(color.rrr ,1.0);\n    \n    // Show Both\n\tfragColor = vec4(color ,1.0);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 23, 60, 60, 142], [145, 145, 180, 180, 248], [250, 250, 307, 307, 1440]]}
{"id": "ttsfW4", "name": "大龙猫 - Quicky#039", "author": "totetmatt", "description": "Quicky", "tags": ["quicky"], "likes": 4, "viewed": 156, "published": "Public API", "date": "1596907734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r(float f){\n    float c=cos(f),s=sin(f);\n    return mat2(c,s,-s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5 * iResolution.xy) / iResolution.y;\n    vec2 uuv = uv;\n    uv*=r(iTime*.2+length(uv));\n    uv.x *=sign(sin(uv.y*100.));\n    uv.y *= sign(cos(uv.x*100.));\n    if(length(uuv)>.525) {\n         uv*=r(iTime*.2+length(uv));\n    uv.x *=-sign(cos(uv.y*100.));\n    uv.y *= -sign(sin(uv.x*100.));\n    }\n    float d = sin(-iTime+cos(iTime)*atan(uv.y,uv.x)+(3.*atan(uv.x,uv.y))+length(uv*10.));\n    vec3 col = smoothstep(0.1,0.01,vec3(d));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 74], [75, 75, 130, 130, 621]]}
{"id": "ttsfzH", "name": "Warp Texture with Noise", "author": "manu210404", "description": "Perlin noise texture warped with Perlin noise", "tags": ["noise", "warping", "perlin", "warp"], "likes": 6, "viewed": 104, "published": "Public", "date": "1596413163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INTENSITY 8.0\n#define WARP_DETAIL 4\n\n#define S(a) smoothstep(0.0, 1.0, a)\n#define SQRT2 1.41421356237309504\n\nvec2 transform() {\n    // return (-iMouse.xy) / iResolution.xy; // follow mouse cursor\n    return vec2(-iTime * 0.19, iTime * 0.19);\n}\n\nfloat noise(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\nfloat perlin(vec2 pos) {\n    float p00 = noise(vec2(floor(pos.x), floor(pos.y)));\n    float p01 = noise(vec2(floor(pos.x), floor(pos.y) + 1.0));\n    float p10 = noise(vec2(floor(pos.x) + 1.0, floor(pos.y)));\n    float p11 = noise(vec2(floor(pos.x) + 1.0, floor(pos.y) + 1.0));\n\t\n    float offY = S(fract(pos.y));\n    float offX = S(fract(pos.x));\n\n    \n    return mix(mix(p00, p01, offY), mix(p10, p11, offY), offX);\n    \n}\n\nfloat fractalNoise(vec2 co, int iter) {\n    float r = 0.0;\n    float factor = 1.0;\n    for (int n; n < iter; n++) {\n        r += (perlin(co * factor) - 0.5)/factor;\n        factor *= 2.0;\n    }\n    return (r + 1.0) * 0.5;\n}\n\nvec2 warp(vec2 co, float intensity, int detail) {\n    // this is a bit botched, idealy you should use a 2d to 2d perlin noise istead of a 2d to 1d perlin noise\n    return co + vec2((fractalNoise(co + transform(), detail) - .5) * intensity, (fractalNoise(co + transform() + vec2(12342.145, -2340.769), detail) - .5) * intensity);\n}\n\nfloat checkerboard(vec2 co, float scale) {\n    return float(floor(mod(co.x * scale, 2.0)) == floor(mod(co.y * scale, 2.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 nuv = (fragCoord/iResolution.xy - 0.5) * 2.0;// normalized uv coordinates\n\n    float intensity = pow(clamp(1.0 - (pow(abs(nuv.x), 3.) + pow(abs(nuv.y), 3.)), 0.0, 1.0), 2.0)*INTENSITY; // makes it so, that the edges and corners are fixed and the rest isn't\n    \n    float val = pow(fractalNoise(warp(uv, intensity, WARP_DETAIL) + 20.0, 5), 2.2);\n    \n    \n    \n   \t//nuv.y = 0.0;\n    //val = clamp(1.0 - (pow(abs(nuv.x), 3.) + pow(abs(nuv.y), 3.)), 0.0, 1.0); // the intensity function\n    //val = smoothstep(val, val - 0.000001, uv.y);\n    \n    vec3 col = vec3(val);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 135, 203, 251], [253, 253, 275, 275, 337], [339, 339, 363, 363, 762], [764, 764, 803, 803, 987], [989, 989, 1038, 1148, 1319], [1321, 1321, 1363, 1363, 1447], [1449, 1449, 1506, 1506, 2160]]}
{"id": "ttsfzj", "name": "Sea Boze", "author": "kaiware007", "description": "Sea Boze\noriginal sea octave function by TDM: https://www.shadertoy.com/view/Ms2SD1", "tags": ["raymarching", "wave", "sea"], "likes": 3, "viewed": 76, "published": "Public", "date": "1597228577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 10.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.9, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdCucumber(vec3 p)\n{\n\tconst float w = 0.05;\n    const float angle = -radians(20.);\n    const float ds = 300.;\n    surface result = SURF_NOHIT(0.);\n\n    // body\n    vec3 b = p;\n    b.y -= 0.2;\n    \n    b = rotate(b, RAD90, vec3(1,0,0));\n    b = rotate(b, -RAD90, vec3(0,1,0));\n    b = rotate(b, -angle, vec3(0,0,1));\n    \n    float body = sdJoint3DSphere(b, 0.5, angle, w) + sin(ds * p.x) * sin(ds * p.y) * sin(ds * p.z) * 0.0025;\n    result = surface(body, vec4(0.01,0.1,0,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true);\n    \n    // leg\n    for(int i = 0; i < 4; i++) {\n        vec3 l = p;\n        float fx = i % 2 == 0 ? 1. : -1.;\n        float fz = float(i / 2);\n        float fz2 = (i / 2 == 0) ? 1. : -1.;\n        l.x += 0.025 * fx * fz2;\n        l.z += 0.1 * (fz > 0. ? 4. : 1.);\n        l.y -= 0.05;\n        l = rotate(l, radians(20.) * fz2, normalize(vec3(1,0,0.5 * fx)));\n\n    \tfloat leg = sdBox(l, vec3(0.01,0.15,0.01));\n    \tresult = opU(result, surface(leg, vec4(0.8,0.7,0.5,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true));\n    }\n    \n    return result;\n}\n\nsurface sdEggplant(vec3 p)\n{\n\tconst float w = 0.04;\n    const float angle = -radians(20.);\n    //const float ds = 300.;\n    surface result = SURF_NOHIT(0.);\n\n    // body\n    vec3 b = p;\n    b.y -= 0.1;\n    b.z += 0.15;\n    \n    b = rotate(b, RAD90, vec3(1,0,0));\n    b = rotate(b, -RAD90, vec3(0,1,0));\n    b = rotate(b, -angle, vec3(0,0,1));\n    \n    float body = sdJoint3DSphere(b, 0.25, angle, w, w+0.03) ;\n    result = surface(body, vec4(0.025,0,0.05,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true);\n    \n    // leg\n    for(int i = 0; i < 4; i++) {\n        vec3 l = p;\n        float fx = i % 2 == 0 ? 1. : -1.;\n        float fz = float(i / 2);\n        float fz2 = (i / 2 == 0) ? 1. : -1.;\n        l.x += 0.025 * fx * fz2;\n        l.z += 0.15 * (fz > 0. ? 2. : 1.);\n        l.y -= 0.0125;\n        l = rotate(l, radians(20.) * fz2, normalize(vec3(1,0,0.5 * fx)));\n\n    \tfloat leg = sdBox(l, vec3(0.01,0.125,0.01));\n    \tresult = opU(result, surface(leg, vec4(0.8,0.7,0.5,1), vec3(0), 0.2, 0.0, 0, false, 2.2, true));\n    }\n    \n    return result;\n}\n\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    \n    // Sea Cube\n    //vec3 c = p;\n    //c.x += 0.5;\n    //c.y -= 0.1;\n    //c.z -= 0.25;\n    \n    //result = opU(result, SURF_SEA(abs(sdBox(c, vec3(0.1)))));\n    \n    // Eggplant\n    //vec3 e = p;\n    //e.x += 1.0;\n    //e.z -= 0.25;\n    \n    //result = opU(result, sdEggplant(e));\n    \n    // background\n    //vec2 bg1 = vec2(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)), MAT_BG1);\n    //result = opU(result, SURF_SEA(abs(sdPlane(p + vec3(0., 0.1, 0.), vec4(0,1,0,0)))));\n    \n    // sea\n    //float h = noise(p.xz * 2. + vec2(iTime * 0.5, 0.)) * 0.1;\n    float freq = 0.16;\n    float amp = 0.6;\n    float choppy = 4.0;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    #define SEA_TIME (1.0 + iTime * 0.8)\n    const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n    float d, h, bd, bh = 0.0;    \n    for(int i = 0; i < 5; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        bd = sea_octave((vec2(0)+SEA_TIME)*freq,choppy);\n        h += d * amp;\n        bh += bd * amp;\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    //result = opU(result, SURF_SEA(abs(p.y - h + 0.1) * 0.5));\n    result = SURF_SEA(abs(p.y - h + 0.1) * 0.5);\n    \n    // boze\n    vec3 b = p;\n    b.y += 0. - bh;\n    //b = rotate(b, M_PI, vec3(0,5,0));\n    b = rotate(b, RAD90, vec3(1,0,0));\n    \n    result = opU(result, sdBoze(b, vec3(5), 1.));\n    \n    //result = opU(result, bg1);\n    \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0.005,0.01);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\n#define fog_density(x) (1.0 - saturate(exp2(20.0 - (x) * 1.5)))\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\nvoid fireworkLight(out vec3 lightPos, out vec3 lightColor)\n{\n    float t = iTime * 0.5;\n    float index = floor(t);\n    float n = hash11(index);\n\tfloat d = 1. - fract(t);\n    lightPos = vec3(0.50, 0.3, -0.5) + hash31(index)*0.25 * d;\n\n    vec3 c = sinebow(n) * d;\n    lightColor = vec3(0.3, 0.6, 0.9) * 2.0 + c * 3.;\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 2.) * 0.25 + 0.5;\n    float y = 2.5;\n    //float r = 2.0 + sin(t * 0.5);\n    float r = 10.0;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    //float phi   = (mouseUV.y) * RAD90;\n    float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0.2, 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1232, 1727, 1764, 1829, 2047], [2048, 2048, 2090, 2090, 2231], [2896, 2896, 2919, 2919, 2992], [3493, 3569, 3591, 3591, 3922], [3925, 4113, 4136, 4136, 4221], [4223, 4242, 4264, 4264, 4381], [4383, 4402, 4425, 4425, 4528], [4530, 4550, 4571, 4571, 4705], [4707, 4726, 4748, 4748, 4881], [4883, 4903, 4925, 4925, 5050], [5052, 5052, 5073, 5073, 5143], [5145, 5145, 5168, 5168, 5247], [5250, 5250, 5272, 5272, 5689], [5800, 5800, 5821, 5821, 5962], [5964, 5964, 5994, 5994, 6124], [6126, 6126, 6187, 6187, 6325], [6327, 6327, 6353, 6353, 6662], [6664, 6724, 6750, 6750, 7616], [7618, 7698, 7739, 7739, 7910], [7912, 8012, 8048, 8048, 8076], [8078, 8078, 8124, 8124, 8180], [8182, 8182, 8213, 8213, 8304], [8306, 8306, 8356, 8356, 8474], [8476, 8476, 8537, 8537, 8668], [8670, 8670, 8707, 8707, 8796], [8798, 8798, 8868, 8868, 9002], [9004, 9004, 9068, 9068, 9185], [9187, 9187, 9220, 9246, 9277], [9279, 9279, 9304, 9304, 9323], [9324, 9324, 9349, 9349, 9368], [9369, 9369, 9405, 9405, 9433], [9435, 9435, 9494, 9494, 9807], [9809, 9809, 9842, 9842, 9907], [9909, 9933, 9985, 9985, 10104], [10106, 10216, 10248, 10248, 10342], [10344, 10344, 10378, 10378, 10529], [10531, 10531, 10565, 10565, 10713], [10715, 10715, 10749, 10749, 10884], [10886, 10886, 10914, 10914, 10999], [11000, 11058, 11129, 11129, 11457], [11459, 11459, 11541, 11541, 11909], [11911, 11996, 12040, 12040, 12264], [12266, 12323, 12360, 12401, 12484], [12486, 12486, 12525, 12697, 12806], [12808, 12808, 12857, 12857, 13416], [13418, 13418, 13457, 13503, 13588], [13590, 13590, 13631, 13741, 13855], [13870, 13921, 13958, 13958, 13980], [13982, 13982, 14025, 14025, 14047], [14049, 14049, 14093, 14093, 14114], [14116, 14116, 14168, 14168, 14267], [14270, 14270, 14315, 14315, 14744], [14746, 14746, 14767, 14767, 14831], [14833, 14833, 14873, 14873, 14998], [15001, 15001, 15036, 15036, 15184], [15186, 15186, 15220, 15220, 15396], [15398, 15398, 15433, 15433, 15468], [15470, 15470, 15507, 15507, 15542], [15544, 15715, 15800, 15800, 15877], [15879, 15922, 15997, 15997, 16416], [16418, 16996, 17080, 17080, 17423], [17425, 17431, 17483, 17483, 17639], [17641, 17641, 17701, 17701, 17742], [17744, 17959, 17990, 17990, 18039], [18041, 18041, 18068, 18068, 18106], [18108, 18108, 18137, 18137, 18175], [18177, 18177, 18204, 18204, 18253], [18256, 18485, 18506, 18506, 18645], [18671, 18671, 18703, 18703, 18816], [18818, 18818, 18850, 18850, 18990], [18992, 18992, 19025, 19025, 19257], [19259, 19259, 19282, 19282, 19861], [19863, 19863, 19888, 19888, 20049], [20051, 20051, 20094, 20094, 21116], [21118, 21118, 21184, 21184, 21306], [21308, 21308, 21353, 21353, 21524], [21526, 21526, 21594, 21594, 21812], [21814, 22032, 22060, 22060, 23100], [23102, 23102, 23130, 23130, 24148], [24150, 24150, 24171, 24171, 25675], [26195, 26195, 26244, 26244, 26542], [26809, 26877, 26905, 26905, 27032], [27034, 27124, 27187, 27187, 27393], [27395, 27461, 27525, 27695, 28326], [28328, 28328, 28365, 28365, 28455], [28457, 28457, 28483, 28483, 30401], [30406, 30577, 30598, 30598, 30646], [30648, 30648, 30709, 30794, 30993], [30995, 30995, 31068, 31160, 31360], [31362, 31362, 31404, 31484, 31538], [31540, 31540, 31589, 31589, 31637], [31639, 31639, 31712, 31769, 31984], [31986, 31986, 32006, 32006, 32031], [32034, 32218, 32268, 32352, 32710], [32712, 32712, 32767, 32824, 33084], [33086, 33086, 33182, 33182, 34577], [34579, 34781, 34814, 34870, 35056], [35058, 35058, 35097, 35097, 35140], [35142, 35158, 35231, 35231, 35315], [35317, 35443, 35513, 35513, 35796], [35798, 35798, 35898, 35898, 36691], [36693, 36693, 36718, 36718, 37187], [37254, 37254, 37280, 37280, 37644], [37646, 37646, 37695, 37695, 39160], [39162, 39162, 39222, 39222, 39480], [39482, 39482, 39561, 39561, 41976], [41978, 41978, 42018, 42018, 44213], [44215, 44215, 44254, 44296, 44792], [44794, 44794, 44836, 44836, 45014], [45017, 45017, 45074, 45074, 46865]]}
{"id": "ttsfzS", "name": "noimorphism", "author": "ShaderLyf", "description": "f(f)", "tags": ["noimorphism"], "likes": 8, "viewed": 203, "published": "Public", "date": "1597088705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n#define TWO_PI 6.2831853\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\nvec3 map1( vec2 p )\n{   \n    p *= 0.7;\n\n    float f = dot( fbm2( 1.0*(0.05*iTime + p + fbm2(-0.05*iTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n    float bl = smoothstep( -0.8, 0.8, f );\n\n    float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n    return mix( mix( vec3(0.50,0.00,0.00), \n                     vec3(1.00,0.75,0.35), ti ), \n                     vec3(0.00,0.00,0.02), bl );\n}\n\nfloat SmooSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat sRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nfloat sphere(vec2 p,float size)\n{\n    return length(p)-size;\n}\n\nfloat smooU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat Cylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat Link( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.y, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat Prism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 pR45(vec3 p) \n{\n\t vec3 pos = vec3(p + vec3(p.y, -p.x,0))*sqrt(0.5);\n    return pos;\n}\n\nvec3 pR( vec3 p, float a) {\n\tvec3 pos = vec3(cos(a)*p + sin(a)*vec3(p.y, -p.x,0.0));\n    return pos;\n}\n\nfloat sminCu( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec2 map (vec3 pos)\n{\n    \n    vec2 d1 = vec2(Cylinder(pos + vec3(0.69,0.01,1.6), 0.21,0.012,0.125),0.7); \n    \n    vec2 d2 = vec2(Cylinder(pos + vec3(0.69,0.01,-1.6), 0.21,0.012,0.125),0.7); \n    \n    //vec2 link1 = vec2(Link(pos + vec3(0.0,0.5,0.0), 0.7, 0.3,0.21),1.0);  \n    \n    float to = torus(pos+ vec3(-0.7,0.15,0.0), vec2(0.4,0.2));\n    vec2 link1 = vec2( to ,1.0);  \n    \n    float sp = sphere(pos.xz,0.5);\n    \n    float rbo = rBox(pos+ vec3(-0.9,0.25,-1.68), vec3(0.116,0.2,0.3),0.11);\n    \n    float rbo2 = rBox(pos+ vec3(-0.9,0.25,1.68), vec3(0.116,0.2,0.3),0.11);\n    \n   // float f = dot( fbm2( 1.0*(0.05*iTime + pos.xy + fbm2(-0.05*iTime+2.0*(pos.zx + fbm2(4.0*pos.zx)))) ), vec2(1.0,-1.0) );\n    \n    vec2 colc = fbm2( 0.05*iTime+pos.xy+ fbm2(-0.05*iTime-2.0*(pos.zx)) ) *0.15;\n    \n    vec2 cola = 1.0*(0.05*iTime + pos.xy + fbm2(-0.05*iTime+2.0*(pos.zx + fbm2(4.0*pos.zx)))) ;\n    \n   //  d1.x = pMod1(pos.y,1.01);\n\n    //float d2 = pos.y;\n    \n     //float d0 = smooU(pos.y+colc.x, pos.y,0.01);\n    float d0 = sminCu(pos.y+colc.x, pos.y,0.05+0.05*abs(sin(iTime*0.5)));\n    //float d3 = smooU(colc.y*0.01,pos.y,0.3);\n    float d3 = smooU(d1.x,d0,0.3);\n    \n    \n    \n    float d4 = smooU(d2.x,d0,0.3);\n    \n    float dist = smin(d4,d3,0.009);\n    \n    //float l1 = smooU(link1.x,dist,0.06);\n    \n    float l1 = smooU(rbo,d0,0.1+0.04*abs(cos(iTime)));\n   // float l2 = smooU(rbo2,l1,0.06);\n    \n   // float pri = Prism(pR(pos.xzy+vec3(-1,0,0.2),12.05)+vec3(0.,0.0,0.), vec2(0.05,0.01));\n    \n    float pri = torus(pos+vec3(0.,0.05,0.0),vec2(0.628,0.01));\n    \n    float l2 = smooU(pri,l1,0.1+0.04*abs(sin(iTime)));\n    float l3 = smooU(rbo2,l2,0.1+0.04*abs(cos(iTime)));\n    \n   // float l4 = smooU(l3,l2,0.0);\n    \n    float d = smin(l3,dist,0.009);\n    \n   \n    \n   // return (d3<d1.x) ? vec2(d3,1.0) : d1;\n   // return colc;\n   // return colc;\n    return vec2(d,1.0);//+(colc*0.01);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0); \n    return normalize(vec3(map(pos+e.xyy).x-map(pos-e.xyy).x,\n                         map(pos+e.yxy).x-map(pos-e.yxy).x,\n                         map(pos+e.yyx).x-map(pos-e.yyx).x\n                         ));\n}\n\nfloat castShadow(vec3 ro,vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i <100; i++)\n    {\n        vec3 pos = ro+t*rd;\n        float h = map(pos).x;\n        res = min(res, 16.0*h/t);\n        if(h<0.0001)break;\n        t += h;\n        if (t>20.0)break;\n        \n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 marchRay (vec3 ro, vec3 rd)\n{\n    float m = -1.0;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n       vec3 pos = ro+t*rd;\n        \n       vec2 h = map(pos);\n        m = h.y;\n       if (h.x<0.001)\n           break;\n        t+=h.x;\n        if (t>20.0) break;    \n    }\n    \n    if (t>20.0) m=-1.0;\n    return vec2(t,m);\n}\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //float f = smoothstep(0.25,0.26,length(p));\n\tfloat an = 5.0*iMouse.y/iResolution.y;\n    vec3 ta = vec3(0.0,1.0,0.0);\n\n   // vec3 ro = ta+vec3(1.5*sin(an),1.5*cos(an),0.); // Ray origin - 2 back in z direction\n    vec3 ro = ta+vec3(0.02,2.0,0.0); // Ray origin - 2 back in z direction\n    \n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(vec3(p.x*uu + p.y*vv +1.9*ww)); // ray detect, becomes length of camera \n    vec3 col = vec3(0.1,0.1,1.0) - 0.7*rd.y;\n    col = mix(col, vec3(0.1,0.75,0.1),exp(-10.0*rd.y));\n    \n\n  \tvec2 tm = marchRay(ro,rd);\n    \n    \n    if (tm.y>0.0)\n    {\n        float t = tm.x;\n        vec3 pos = ro  + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 matte = vec3(0.18);\n        \n        if (tm.y<1.5)\n        {\n            matte = vec3(0.09,0.09,0.09);\n           // float f = -2.0+2.0*smoothstep(-0.2,0.2,sin(2.0*pos.x)+sin(2.0*pos.y)+sin(2.0*pos.z));\n            \n            float f = -1.0+2.0*smoothstep(-0.05,0.04,-pos.x);\n            \n           // matte+=0.3*f*vec3(0.12,0.12,0.12);\n            \n            matte+=0.3*vec3(0.1,0.12,0.12);\n            \n        }\n\n        \n        else if (tm.y<2.5)\n        {\n           // matte = vec3(0.2,0.1,0.2);\n        }\n        \n        \n        else //if (tm.y<3.5)\n        {\n          //  matte = vec3(0.4,0.4,0.4);\n        }\n        \n        \n    \n        col = vec3(0.03,0.03,0.03);\n       // float f = sin(18.0*pos.x)*sin(18.0*pos.z);\n      // \tcol+=f;\n        vec3 sun_dir = normalize(vec3(0.02,0.022,0.01));\n        //vec3 sun_dir = normalize(vec3(0.5*sin(iTime*0.2)+0.1,0.1+0.1*abs(sin(iTime*0.2)),abs(sin(iTime*0.02))));\n        float sun_dif = clamp (dot(nor,sun_dir),0.0,1.0);\n        float sun_sha = castShadow(pos+nor*0.001,sun_dir);\n        float sky_dif = sqrt(clamp(0.5+0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0));\n        float bou_dif = clamp(0.5+0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);\n        \n        \n        col = matte*sun_dif*vec3(0.2,0.2,0.2); \n        col += matte*sky_dif*vec3(0.5,0.8,0.9);\n        //col += matte*vec3(0.7,0.3,0.2)*bou_dif;\n        \n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(7.0,4.5,5.0); // key light\n        lin += sky_dif*vec3(0.5,0.8,0.9);\n        \n        lin += matte*vec3(0.7,0.3,0.2)*bou_dif;\n        col = col*lin;\n    }\n    \n    col = pow(col,vec3(0.4545));\n    \n    vec2 uv3 = fragCoord.xy;\n\tfloat radius = 0.25 * iResolution.y;\n    vec2 center = iResolution.xy * 0.5;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    // the sound texture is 512x2\n    //uv2+=0.5;\n    uv2 *=0.5;\n\n    vec2 p1 = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    p1*=2.;\n\n    float e = 0.0045;\n\n    vec3 colc = map1( p1               ); float gc = dot(colc,vec3(0.233));\n    vec3 cola = map1( p1 + vec2(e,0.0) ); float ga = dot(cola,vec3(0.233));\n    vec3 colb = map1( p1 + vec2(0.0,e) ); float gb = dot(colb,vec3(0.233));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col1 = colc;\n    col1 += vec3(0.0,0.7,0.6)*1.0*abs(2.0*gc-ga-gb);\n    col1 *= 1.0+0.2*nor.y*nor.y;\n    col1 += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    col1 *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    vec4 fragCo = vec4( col1, 1.0 );\n    \n    \n    vec3 red = vec3(fragCo.rgb);\n    vec4 cc = circle(uv3,center,radius*0.7,red);\n    // Output to screen\n    fragColor = mix(vec4(col,1.0), cc, mix(0.0,1.0*abs(sin(iTime*0.2)),0.5*sin(iTime*0.2)));;\n   // fragColor = mix(vec4(col,1.0), cc, mix(cc.a,0.0,0.));\n    \n     //fragColor = mix(vec4(col,1.0), cc, 0.4);\n    \n    //fragColor = vec4(col,1.0);\n   // fragColor = mix(vec4(col,1.0), cc, mix(cc.a,0.5,1.*abs(sin(iTime*0.2))));;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 226, 248, 248, 338], [340, 340, 366, 366, 660], [662, 662, 683, 683, 879], [881, 881, 905, 905, 948], [950, 950, 971, 971, 1337], [1339, 1339, 1385, 1385, 1485], [1487, 1487, 1526, 1526, 1598], [1600, 1600, 1641, 1641, 1726], [1728, 1728, 1768, 1768, 1889], [1892, 1892, 1925, 1925, 1954], [1956, 1956, 2000, 2000, 2099], [2101, 2101, 2156, 2156, 2273], [2276, 2276, 2328, 2328, 2430], [2432, 2432, 2463, 2463, 2528], [2530, 2530, 2569, 2569, 2660], [2662, 2662, 2693, 2693, 2776], [2778, 2778, 2798, 2798, 2868], [2870, 2870, 2897, 2897, 2972], [2974, 2974, 3017, 3017, 3103], [3105, 3105, 3126, 3126, 5012], [5014, 5014, 5041, 5041, 5284], [5286, 5286, 5321, 5321, 5611], [5613, 5613, 5647, 5647, 5951], [5954, 5954, 6009, 6009, 6107], [6109, 6109, 6166, 6166, 10063]]}
{"id": "ttXBDn", "name": "FieldFX 25/07 MS semifinals", "author": "MonsieurSoleil", "description": "semifinals", "tags": ["raymarching"], "likes": 2, "viewed": 94, "published": "Public", "date": "1596445348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 4.0, 8.0))\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n};\n\nfloat sphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  \n  return max(p.x, max(p.y, p.z));\n}\n\nfloat lineCircle(vec3 p, float s)\n{\n  float mat01;\n  \n  mat01 = sphere(p, s);\n  \n  mat01 = max(mat01, -box(p + vec3(0.0, 0.0, 0.595*s), vec3(2.0 * s, 2.0* s, 0.595*s)));\n  mat01 = max(mat01, -box(p - vec3(0.0, 0.0, 0.595*s), vec3(2.0 * s, 2.0* s, 0.595*s)));\n  mat01 = max(mat01, -sphere(p, 0.999*s));\n  \n  return mat01;\n}\n\nfloat opRepLim(float p, float c, float l )\n{\n  float q = p-c*clamp(round(p/c), 0.0, l);\n  \n  return q;\n}\n\nfloat glowP(float p, float val, float maxmul)\n{\n  float x = abs(val - p);\n  return (abs(2.5 - x) > 5.5) ? 0.0 : clamp((2.5 - x), 0.0, maxmul);\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  float mat01, mat02;\n  \n  vec3 p01 = p, p02= p;\n  \n  \n  \n  p01.z = opRepLim(p01.z, 0.25 + abs(sin(time* 0.15)) * 0.25 , 55.0);\n  \n  p01.x += sin(p.z * 4.0 + time * 2.0 ) * 0.2;\n  p01.y += sin(p.z * 6.0 + mod02 * 4.0) * 0.3;\n  \n  mat01 = lineCircle(p01, 0.1 + mod01 * 0.1 + mod02 * 0.05);\n  \n   mat01 = min(mat01, lineCircle(p01+ vec3(1.0, 1.0, 0.0), 0.05 + mod01 * 0.05 + mod02 * 0.05));\n   mat01 = min(mat01, lineCircle(p01- vec3(1.0, 1.0, 0.0), 0.1 + mod01 * 0.025 + mod02 * 0.05));\n  \n  mat01 = min(mat01, lineCircle(p01- vec3(2.0, 2.0, 0.0), 0.1 + mod01 * 0.2 + mod02 * 0.05));\n  \n  mat01 = min(mat01, lineCircle(p01- vec3(2.0, 2.0, 0.0), 0.1 + mod01 * 0.1 + mod02 * 0.1));\n  \n  float gg01 = glowP(p.z, abs(sin(time)) * 10.0, 4.0);\n  \n  gg += 0.15/(0.05+abs(mat01)) * gg01;\n  \n  mat02 = -box(p, vec3(5.5, 5.5, 15000.0));\n  \n  if(mat02 < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  mat.m = min(mat01, mat02);\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n  map(m02, p - uv.xyy);\n  map(m03, p - uv.yxy);\n  map(m04, p - uv.yyx);\n  return normalize(m01.m- vec3(m02.m, m03.m, m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 0.0, 15.), t = vec3(0.0);\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = dir * 0.5 + o;\n  \n  vec3 col = vec3(0.0);\n  \n  matter mat;\n  float dd = 0.0;\n  \n  for(int i = 0; i < 100; i ++)\n  {\n    p.xy *= rot(abs(sin(mod02)) * 0.035);\n    \n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      if(mat.type == 1 && ! mat.reflected)\n      {\n        vec3 n = normals(p);\n        dir = reflect(dir, -n);\n        mat.reflected = true;\n        \n        mat.m = 0.05;\n      }\n    }\n    \n    col += pow(gg * 0.000375, 1.0 + sin(time * 0.5) * 0.25 ) * mix(vec3(1.0, 0.5, 0.0), vec3(0.0, 0.5, 1.0), abs(sin(mod01)) * 1.0);\n    \n    p += dir * mat.m;\n    dd += mat.m;\n  }\n  float fog = clamp(1.0 - (dd/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(0.6, 0.5, 0.3), vec3(0.8, 0.4, 0.1), uv.y); // shiyt aggain !\n  \n  col += sky * fog;\n  \n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 273, 292, 292, 371], [451, 451, 482, 482, 508], [510, 510, 537, 537, 594], [596, 596, 631, 631, 918], [920, 920, 964, 964, 1024], [1026, 1026, 1073, 1073, 1170], [1172, 1172, 1208, 1208, 2116], [2118, 2118, 2140, 2140, 2347], [2349, 2349, 2406, 2406, 3521]]}
{"id": "ttXBWS", "name": "Overhill flyer z", "author": "illus0r", "description": "Overhill flyer z", "tags": ["raymarching"], "likes": 8, "viewed": 276, "published": "Public API", "date": "1597576656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n#define T iTime * 0.2\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n\n\nvec3 colorInterpolation(vec3 col1, vec3 col2, vec3 col3, vec3 col4, float x) {\n\tvec3 color;\n    float N = 3.;\n    if (x < 1./N) {\n    \tcolor = mix(col1, col2, x * N);\n    }\n    else {\n        if (x < 2./N) {\n            color = mix(col2, col3, (x - 1./N) * N);\n        }\n        else {\n            color = mix(col3, col4, (x - 2./N) * N);\n        }\n    }\n    color = max(vec3(0), color);\n    return color;\n    \n}\n\n\n\nfloat GetDist(vec3 p) {\n    p.x += T * 10.;\n    p.z *= 0.6;\n    p.x *= 1.;\n    p.y *= .5;\n    float plane = dot(p, normalize(vec3(0.,1.,0.)));\n    float n = noise(p);\n    float n2 = noise(p * 2.)  * 0.5;\n    float n3 = noise(p * 8.)  * 0.05;\n    float n4 = noise(p * 16.)  * 0.005;\n    //float n5 = noise(p * 8.) * 0.0375;\n    n += n2 + n3 + n4;// + n5;\n    \n    return (plane + n) * 0.6;\n}\n\n\n\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST*(1.0+dO)) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv += 0.05 * noise(vec3(uv * 5., T));\n    \n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 hills;\n    \n    vec3 ro = vec3(0., 2., 0.);\n    //ro.yx *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + vec3(1., -0.2, 0.), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif; \n        //col = n;\n        //col = vec3(S(10., 0., d)); // dist\n        \n        vec3 col1 = vec3(39. /256.,35. /256.,48. /256.);\n\t    vec3 col2 = vec3(155./256.,101./256.,118./256.);\n\t\tvec3 col3 = vec3(215./256.,126./256.,118./256.);\n\t\tvec3 col4 = vec3(230./256.,176./256.,77./256.);\n\t    hills = colorInterpolation(col1, col2, col3, col4, clamp(0., 1., pow(d, 0.5) / 3. - 0.5));\n    }\n    \n    vec3 col1 = vec3(230./256.,176./256.,77./256.);\n    vec3 col2 = vec3(230./256.,176./256.,77./256.) * 1.0;\n    vec3 col3 = vec3(234./256.,235./256.,198./256.);\n    vec3 col4 = vec3(75./256.,177./256.,210./256.);\n    vec2 uvSky = uv;\n    uvSky += 0.1 * noise(vec3(uvSky, T));\n    vec3 sky = colorInterpolation(col1, col2, col3, col4, uvSky.y * 2.5);\n    vec2 uvCl = uv;\n    uvCl *=  vec2(3., 30.);\n    uvCl.x += iTime * 2.;\n    float clouds = 1. * (0.5 + 0.5 * noise(vec3(uvCl, T)));\n    //uvCl *= vec2(2.66, 2.7);\n    //clouds *= (1.5 + 3.5 * noise(vec3(uvCl, iTime * 2.)));\n    //clouds = min(1., clouds);\n    clouds = pow(clouds, 2.);\n    clouds *= smoothstep(0.1, 0.25, uv.y) - smoothstep(0.25, 0.5, uv.y);\n    sky = mix(sky, vec3(1), clouds);\n    vec3 col = mix(hills, sky, smoothstep(10., 20., d));\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 361, 380, 380, 442], [444, 444, 466, 466, 560], [562, 562, 591, 591, 672], [674, 674, 743, 743, 912], [914, 914, 940, 952, 2118], [2122, 2122, 2200, 2200, 2534], [2538, 2538, 2561, 2561, 2928], [2938, 2938, 2972, 2972, 3192], [3194, 3194, 3218, 3218, 3408], [3410, 3410, 3460, 3460, 3651], [3655, 3655, 3712, 3712, 5543]]}
{"id": "ttXfDB", "name": "Interface 00", "author": "gunthern", "description": "Book of shaders chapter 08 exercise ", "tags": ["ui", "hud", "interface"], "likes": 7, "viewed": 246, "published": "Public", "date": "1597613963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d (float _angle){\n\treturn mat2 (cos(_angle),sin(_angle),-sin(_angle),cos(_angle));   \n}\n\nmat2 scale2d (vec2 _scale){\n\treturn mat2 (_scale.x, 0.0, 0.0, _scale.y);  \n}\n\nfloat box (in vec2 _size, in vec2 _uv){\n    _size = vec2(0.5) - _size*.5;\n    vec2 st = smoothstep (_size, _size+vec2(0.04), _uv);\n    st *= smoothstep (_size, _size+vec2(0.04),vec2(1.0)-_uv);\n    float box = st.x * st.y;\n\treturn box;\n}\n\nfloat plot(in vec2 _uv, in float _pct) {    \n    return smoothstep(_pct-.01, _pct, _uv.y) - smoothstep(_pct, _pct+.01, _uv.y);\n}\n\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //grids\n    float grid0x = cos((uv.x - 1.1) * 170.);\n    grid0x = step(0.99,grid0x);\n    float grid0y = cos((uv.y - 1.5) * 100.);\n    grid0y = step(0.99,grid0y);\n    \n    float grid2 = sin(uv.x * 170.) * sin(uv.y * 100.);\n    grid2 = step(.9,grid2);\n    \n    \n    //Box 0 (top right)\n    float box0 = box(vec2(.45,.65), uv - vec2(0.265, 0.15));\n    float box0inv = 1.0 - step(0.2,box0);\n    box0 = step(0.1,box0) - step(0.2,box0);\n    \n    //box 1 (bottom right)\n    float box1 = box(vec2(.45,.275), uv - vec2(0.265, -0.333));\n    float box1inv = 1.0 - step(0.2,box1);\n    box1 = step(0.1,box1) - step(0.2,box1);\n    \n    //box 2 (left)\n    float box2 = box(vec2(.525,.95), uv - vec2(-0.225, 0.));\n    float box2inv = 1.0 - step(0.2,box2);\n    box2 = step(0.1,box2) - step(0.2,box2);\n    \n    //box 0 contents\n    float plot0 = plot(uv, (sin((uv.x*sin(cos(iTime/2.5))+cos(iTime/2.))*50.)*.25) + .65) + .5;\n    \n    //box 1 contents\n    float loadingbar0 = box(vec2(clamp(abs(sin(iTime*2.4) * sin(iTime/3.6) * cos(iTime/10.5)),abs(sin(iTime)),1.0),0.5), uv - vec2(0.0, -0.333));\n    vec2 uvrot = rotate2d(.25) * uv;\n    float loadingbar0stripes = step(sin((uvrot.x-iTime*.1) * 100.),0.01);\n    loadingbar0 = step(1.,loadingbar0);\n    \n    //box2 contents\n    vec2 uvremap = uv *2.-1.;\n    uvremap = scale2d( vec2(sin(iTime/60.75)*sin(iTime/40.)) ) * uvremap;\n    uvremap *= rotate2d(PI*cos(iTime/10.233)*sin(iTime/40.87));\n    uvremap.y /= 1.75;\n    uvremap += vec2(sin(iTime/30.)*2. + 3.);\n    float dist = length( abs(uvremap)-(sin(iTime/20.3) * cos(iTime/22.33)));\n    vec2 pos = vec2(uvremap*0.5);\n    dist *= noise(pos * vec2(sin(iTime/32.3)));\n    dist = smoothstep(.3,.0,fract(dist*25.0));\n                            \n    //box outline color\n    vec3 lightblue = vec3(.2,.7,1.0);\n                    \n    vec3 col = vec3(0.0);\n    col += vec3(box0) * lightblue;\n    col += vec3(0.0,plot0,0.0) * (1. - vec3(box0inv));\n    col += ((vec3(grid0x) * lightblue * .2) + (vec3(grid0y) * lightblue * .3)) * (1. - vec3(box0inv));\n    col += vec3(box1) * lightblue;\n    col += vec3(loadingbar0*.55,loadingbar0*.25,loadingbar0*.65) * vec3(loadingbar0stripes*0.5+.5) * (1. - vec3(box1inv));\n    col += vec3(.55,0.1,0.5)  * (1. - vec3(box1inv));\n    col += vec3(box2) * lightblue;\n    col += vec3(0.3,0.2,0.45)  * (1. - vec3(box2inv));\n    col += vec3(dist*.2, dist*.9, dist*.9) *.6 * (1. - vec3(box2inv));\n    col += (vec3(grid2) * lightblue * .2) * (1. - vec3(box2inv));\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 55, 55, 125], [127, 127, 154, 154, 203], [205, 205, 244, 244, 441], [443, 443, 483, 483, 571], [573, 573, 601, 601, 677], [679, 766, 793, 793, 1312], [1314, 1314, 1371, 1421, 4004]]}
{"id": "ttXfDM", "name": "The Hole", "author": "BackwardsCap", "description": "It feels a little off but its pretty close to what I was going for.\n\nInspired by this tweet: https://twitter.com/PelletierAuger/status/1291072500521148419", "tags": ["hole"], "likes": 3, "viewed": 207, "published": "Public API", "date": "1597112552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define px 3./R.y\n#define tau 6.2831853\n\nfloat line(vec2 s, vec2 d, vec2 p)\n{\n    vec2 p1 = p-s,\n    \t p2 = p-d;\n    \n    float u = dot(p1,p2);\n    float v = dot(p2,p2);\n    float z = u/v;\n    float h = clamp(z,0.,1.);\n                    \n    return smoothstep(0.,px,length(p1-p2*h));\n}\n\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 p = (2.*f-R.xy)/R.y;\n    float iter = 50., t = iTime/4.0;\n    vec2 rot = vec2(sin(t),cos(t)), lp;\n    p+=dot(p*rot,rot.yx)/10.;\n    vec3 col = vec3(1);\n    \n    for(float i=0.;i<iter;i++)\n    {\n        float k = i/iter;\n        \n    \tlp = vec2(sin(k*tau), cos(k*tau))/2.;\n        \n    \tcol *= line(lp, (lp+rot)*100., p);\n    }\n    \n    float cv = length(p)-.5;\n    col+=smoothstep(0.0,px,cv);\n    if(cv<0.) col*=smoothstep(0.,1.,(length(p+rot)-.4));\n    col=clamp(col,0.,1.);\n    c.rgb = col*smoothstep(0.,px,max(cv, -cv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 102, 102, 312], [315, 315, 356, 356, 891]]}
{"id": "ttXfWB", "name": "#001 - Some rings doing the same", "author": "Deadtotem", "description": "This code is original based on \"RayMarching starting point\" by Martijn Steinrucken aka BigWings/CountFrolic, and modified by me for study purposes only. ", "tags": ["raymarching", "torus", "rings"], "likes": 7, "viewed": 93, "published": "Public", "date": "1597595768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This code is original based on \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// modified by me, for study only.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define S smoothstep\n\nvec3 Bg(vec3 rd){\n    float k = rd.x*.5+.5;\n    vec3 col =  mix(vec3(.2, .1, .1), vec3(.2, .5, 1) * sin(iTime*.12), k);\n    return col;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox2d(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 1.7;\n    float r2=.3;\n    vec2 cp = vec2(length(p.xz)-r1, p.y);\n    float a = atan(p.x, p.z);\n    cp *=Rot(a * 5.5 + iTime);\n    cp.y = abs(cp.y)-.6;\n    cp.y = abs(cp.y)-.13;\n    float d = length(cp)-r2;\n    d = sdBox2d(cp, vec2(.4, .2 *(sin(3.*a)*.5+.5))) -.1;\n    d += sdSphere( vec3(cp, .1), -.02);\n    return d * .208;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.; \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));  \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;  \n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    col += Bg(rd);\n    float d = RayMarch(ro, rd);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n); //reflection rayDir to Normal\n        float spec = pow(max(0., r.y), 20.); //Specular adding\n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 colChan0 = texture(iChannel0, vec2(n.x, n.y)).rgb;\n        col = mix(Bg(r), vec3(dif) * pow(colChan0.rbb,vec3(.65)), .55) + spec ;\n\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 247, 264, 264, 384], [386, 386, 405, 405, 467], [469, 469, 491, 491, 585], [587, 587, 618, 618, 689], [691, 691, 726, 726, 750], [752, 752, 775, 775, 1116], [1118, 1118, 1152, 1152, 1359], [1361, 1361, 1385, 1385, 1539], [1541, 1541, 1591, 1591, 1782], [1785, 1785, 1842, 1842, 2657]]}
{"id": "ttXfWH", "name": "raymarching1_", "author": "pohy", "description": "raymarching1", "tags": ["raymarching1"], "likes": 3, "viewed": 120, "published": "Public API", "date": "1596572278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Progressing with learning ray marching techniques.\n * I recommend to listen to Confidence of Equals by Isaac Chambers\n * https://jumpsuitrecords.bandcamp.com/track/confidence-of-equals\n * Some pretty smooth jams in that EP\n */\n\n#define MAX_ITER 100\n#define MAX_DIST 20.\n#define EPSILON 0.001\n\n#define PI 3.14159\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\nfloat posCos(float x) {\n    return cos(x) * .5 + .5;\n}\n\nfloat sMin(float d1, float d2, float k) {\n    float h = clamp(.5 + .5 * (d2 -d1) / k, 0., 1.);\n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 mapMat(vec3 p) {\n    float t = PI * 3. + iTime * .1;\n    // Plane\n    float d = p.y - (-.25) * sin(p.x - p.z * p.y) * .3;\n    \n    float mat = -1.;\n    \n    // Spheres\n    for (float i = 0.; i < 40.; i++) {\n        float a = i + t;\n        a += 1. + i + t * .2 * i;\n        float r = .25 + i * posSin(i + t * 8.) * .005;\n        float h = 1. + i * .1;\n        float off = .3 + posSin(t * 4.);\n        vec3 c = vec3(cos(a) * off, h, sin(a) * off);\n        float d1 = sdSphere(p - c, r);//length(p - c) - .25;\n        if (d1 < d) {\n            mat = mod(i, 2.);\n        }\n        d = sMin(d1, d, .2 * posSin(t));\n    }\n    \n    return vec2(d, mat);\n}\n\nfloat map(vec3 p) {\n    return mapMat(p).x;\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0., EPSILON);\n    vec3 normal = normalize(vec3(\n        map(pos + eps.yxx) - map(pos - eps.yxx),\n        map(pos + eps.xyx) - map(pos - eps.xyx),\n        map(pos + eps.xxy) - map(pos - eps.xxy)\n    ));\n    return normal;\n}\n\nvec2 castRayMat(vec3 ro, vec3 rd) {\n    float td = 0.;\n    float mat;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 pos = ro + td * rd;\n        vec2 h = mapMat(pos);\n        mat = h.y;\n        if (h.x < EPSILON) break;\n        td += h.x;\n        if (td > MAX_DIST) break;\n    }\n    if (td > MAX_DIST ) td = -1.;\n    return vec2(td, mat);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    return castRayMat(ro, rd).x;\n}\n\nvec3 scenePixelColor(vec3 ro, vec3 rd) {\n    vec3 col = vec3(.3, .75, 1.) - .7 * rd.y;\n    col = mix(col, vec3(.7, .75, .8), exp(-10. * rd.y));\n    \n    vec2 ray = castRayMat(ro, rd);\n    float td = ray.x;\n    \n    float t = PI + iTime * .1;\n    \n    if (td > EPSILON) {\n\t\tvec3 pos = ro + td * rd;\n        vec3 n = normal(pos);\n        \n        vec3 mate;\n        if (ray.y < -.5) {\n            mate = vec3(.2);\n        } else if (ray.y < .5) {\n            mate = vec3(.1, .3, .9);\n        \t//mate = vec3(.4, .1, mod(ray.y, 4.));\n        } else if (ray.y < 1.5) {\n        \tmate = vec3(.9, .3, .1);\n        }\n        \n        vec3 sunPos = normalize(vec3(.8 * sin(t) * 2., .4 - posSin(t) * .25, .2 + cos(t)));\n        \n        float sunDiff = clamp(dot(n, sunPos), .0, 1.);\n        float sunSha = step(castRay(pos + n * EPSILON, sunPos), .0);\n        float skyDiff = clamp(.5 + .5 * dot(n, vec3(0, 1, 0)), 0., 1.);\n        float bouDiff = clamp(.5 + .5 * dot(n, vec3(0, -1, 0)), 0., 1.);\n        \n        col = mate * vec3(7, 4.5, 3) * sunDiff * sunSha;\n        col += mate * vec3(.5, .8, .9) * skyDiff;\n        col += mate * vec3(.7, .3, .2) * bouDiff;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    //col += ray.y;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float t = PI * 1.25 + iTime * .29;\n    //t = PI * .25;\n    \n    float a = t;//mouse.x * 10.;\n    float r = 8.;//4. + posSin(t) * 2.;//2. + mouse.y * 10.;\n    float h = 2.;//.5 + posSin(t) * 2.;\n    \n    vec3 ro0 = vec3(0., .1, .001);\n    //ro0 = vec3(r * sin(a), h, .001 + r * cos(a));\n    vec3 ro1 = vec3(0, 2.5, 10.);\n    vec3 ro = mix(ro0, ro1, posSin(t));\n    \n    // Camera\n    vec3 la0 = vec3(0., 8., 0.);\n    vec3 la1 = vec3(0, 2.25, 0);\n    vec3 la = mix(la0, la1, posSin(t));\n    vec3 cf = normalize(la - ro);\n    vec3 cr = normalize(cross(cf, vec3(0, 1, 0)));\n    vec3 cu = normalize(cross(cr, cf));\n    \n    vec3 rd = normalize(uv.x * cr + uv.y * cu + 1.5 * cf);\n\n    vec3 col = scenePixelColor(ro, rd);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 319, 342, 342, 373], [374, 374, 397, 397, 428], [430, 430, 471, 471, 572], [574, 574, 614, 614, 642], [644, 644, 677, 677, 705], [707, 707, 728, 728, 1360], [1362, 1362, 1381, 1381, 1407], [1409, 1409, 1432, 1432, 1675], [1677, 1677, 1712, 1712, 2024], [2026, 2026, 2059, 2059, 2094], [2096, 2096, 2136, 2136, 3336], [3338, 3338, 3395, 3395, 4259]]}
{"id": "ttXfWs", "name": "[TWITCH] Mirrors", "author": "Flopine", "description": "Made during a Twitch live session. You can watch all of them here: https://www.twitch.tv/flopine", "tags": ["raymarching", "reflection", "animation", "iridescence"], "likes": 4, "viewed": 79, "published": "Public", "date": "1598039634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define ITER 120.\n#define time iTime\n#define PI acos(-1.)\n\nstruct obj\n{\n    float d;\n    int mat;\n    vec3 col;\n};\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b),0.5*(a+u+abs(mod(u-a+st,2.*st)-st)));\n}\n\nobj minobj (obj a, obj b)\n{\n    if(a.d<b.d) return a;\n    else return b;\n}\n\nobj stminobj (obj a, obj b, float k ,float st)\n{\n    float dist = stmin(a.d,b.d,k,st);\n    if (a.d <= b.d) return obj(dist,a.mat,a.col);\n    else return obj(dist,b.mat,b.col);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(min(p.x,min(p.y,p.z))-d,od(p,0.5));\n}\n\nobj cage (vec3 p)\n{\n    p.xz *= rot(-PI/2.);\n    mo(p.yz, vec2(0.8));\n    p.xz *= rot(PI/4.);\n    mo(p.xy, vec2(1.));\n    p.xz *= rot(PI/2.);\n    float cd = box(p,vec3(0.5,0.7,0.05))-0.01;\n    return obj(cd, 1, vec3(0.6,0.1,0.5));\n}\n\nobj subcage (vec3 p)\n{\n    p.z += 0.5;\n    mo(p.xy, vec2(1.));\n    p.x -= 0.8;\n    p.yz *= rot(-PI/4.);\n    mo(p.xz, vec2(0.5));\n    p.xz *= rot(PI/4.);\n    float scd = box(p,vec3(0.8,0.2,0.1))-0.01;\n    return obj(scd, 2, vec3(0.1,0.8,0.));\n}\n\nobj structure (vec3 p)\n{\n    p.x = abs(p.x)-1.;\n    return stminobj(cage(p),subcage(p),0.15,5.);\n}\n\nobj gem (vec3 p)\n{\n    float octa = od(p,0.4);\n    mo(p.xz, vec2(3.));\n    p.xz *= rot(time*0.3);\n    mo(p.xy, vec2(1.5));\n    float gd = sc(p, 0.1)-0.05;\n    return obj(gd, 3, vec3(0.05));\n}\n\n\nobj SDF (vec3 p)\n{\n    obj scene = minobj(structure(p), gem(p));\n    return scene;\n}\n\n\nvec3 norm (vec3 p)\n{\n    vec2 eps = vec2(0.0005,0.);\n    return normalize(SDF(p).d - vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvec3 palette (float t, vec3 c, vec3 d)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+d));}\n\nvec3 iri(vec3 c, vec3 n, vec3 rd, vec3 pal)\n{\n    float fresnel = max(1.-dot(n,rd),0.);\n    c += palette(fresnel,vec3(2.),pal);\n    return c;\n}\n\nvec3 raymarch(inout vec3 p, vec3 rd, vec3 l)\n{\n    vec3 col = vec3(0.85,0.79,0.85);\n    vec3 newrd = rd;\n    bool hit = false;\n    int refi = 0;\n    obj O;\n    for (float i=0.; i<ITER; i++)\n    {\n        O = SDF(p);\n        if (O.d < 0.001)\n        {\n            hit = true;\n            if (O.mat == 3)\n            {\n                if (refi >= 1) break;\n                vec3 n = norm(p);\n                newrd = reflect(newrd,n);\n                p += 0.1*newrd;\n                col = O.col;\n                col += pow(max(dot(n,normalize(l-rd)),0.), 18.)*0.25;\n                refi ++;\n            }\n            else break;\n        }\n        p += O.d*newrd;\n    } \n\n    if (hit)\n    { \n        vec3 n = norm(p);\n        if (O.mat == 1) col = iri(O.col, n, rd, vec3(0.3,0.,0.8));\n        if (O.mat == 2) col = iri(O.col, n, rd, vec3(0.5,0.,0.2));\n    }\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.,0.,-4.35),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(1.,2.,-1.));\n\n    vec3 color = raymarch(p,rd,l); \n\n    // vignetting (from iq)\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcolor *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.15);\n    \n    color *= 1./max(texture(iChannel0,uv*8.).r*1.9,0.01);\n    \n    fragColor = vec4(pow(color,vec3(0.4545)),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 434, 484, 484, 587], [589, 589, 616, 616, 663], [665, 665, 713, 713, 842], [844, 844, 864, 864, 907], [909, 909, 941, 941, 988], [990, 990, 1018, 1018, 1051], [1053, 1053, 1081, 1081, 1117], [1119, 1119, 1147, 1147, 1239], [1241, 1241, 1260, 1260, 1473], [1475, 1475, 1497, 1497, 1718], [1720, 1720, 1744, 1744, 1818], [1820, 1820, 1838, 1838, 2011], [2014, 2014, 2032, 2032, 2098], [2101, 2101, 2121, 2121, 2246], [2248, 2248, 2288, 2288, 2335], [2337, 2337, 2382, 2382, 2480], [2482, 2482, 2528, 2528, 3352], [3354, 3354, 3410, 3410, 3905]]}
{"id": "ttXfWX", "name": "CAO", "author": "JacobC", "description": "Trying to generate fake AO with one pass of the ray marcher. I added the occlusion to show it, you can slide the bar with the cursor by clicking the canvas.", "tags": ["3d", "raymarching", "test", "ao", "bleeding"], "likes": 33, "viewed": 496, "published": "Public", "date": "1597871963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"CAO\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n// Set it to 1. if runs slow\n#define AA 2.\n// Set it to 1 to add color bleeding\n#define CB 0\n\n#define Pi 3.141592\n#define T iTime\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 bleed;\n    float ao;\n};\n    \nfloat torus(in vec3 p, in vec2 r)\n{\n   return length(vec2(length(p.xz) - r.x, p.y)) - r.y; \n}\n\nfloat cylinder( vec3 p, float r, float h, float s)\n{\n  return length(vec2(max(length(p.xz) - r + s, 0.), \n                     max(abs(p.y) - h, 0.))) - s;\n}\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    // mapping distance\n    // like a point light caster from:\n    // http://wiki.ogre3d.org/tiki-index.php?page=-Point+Light+Attenuation\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat Uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 1.4, 7.2);\n    s = map(s, 1., .7, 1.8);\n    \n    return mat(\n        min(a.depth, b.depth),\n        a.depth < b.depth ? a.col : b.col,\n        a.bleed * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s), // Compute color bleeding\n        a.ao * ao // Computing AO\n    );\n}\n\n#define op0 vec3(0., -.3, -4.7)\n#define op1 vec3(-4.5, 1., -1.)\n#define op2 vec3(0., -101., 0.)\n#define op3 vec3(.0, 1., 0.)\n#define op4 vec3(0., .5, 4.3)\n\n#define oc0 vec3(3., 0., 1.5) / Pi\n#define oc1 vec3(1.5, 3., 0.) / Pi\n#define oc2 vec3(3.) / Pi\n#define oc3 vec3(3., 1.5, 0.) / Pi\n#define oc4 vec3(0., 1.5, 3.) / Pi\n\nmat scene(in vec3 p)\n{\n    vec3 q = p;\n    vec3 bl = vec3(1.);\n    q -= op0;\n    q.xz *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    q.xy *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o0 = mat(torus(q, vec2(2., .8)), oc0, bl, 1.);\n    q = p;\n    q -= op1;\n    q.xz *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o1 = mat(cube(q, vec3(2.), .5), oc1, bl, 1.);\n    mat o2 = mat(cube(p - op2, vec3(100.), .0), oc2, bl, 1.);\n    mat o3 = mat(torus(p - op3, vec2(0., 2.)), oc3, bl, 1.);\n    q = p;\n    q -= op4;\n    q.xy *= mat2(cos(T), sin(T), -sin(T), cos(T));\n    mat o4 = mat(cylinder(q, 2., 2., max(sin(T) * 2., .2)), oc4, bl, 1.);\n    \n    \n    float k = 10.;\n    float l = 100.;\n    mat o = Uop(o0, o1);\n    o = Uop(o, o2);\n    o = Uop(o, o4);\n    o = Uop(o, o3);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define NUM_STEPS 255\n#define MIN_DIST .01\n#define MAX_DIST 64.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n        \treturn mat(t, s.col, s.bleed, s.ao);\n        if (t > MAX_DIST)\n            break;\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return u * p.x + v * p.y - w;\n}\n\n#define gd vec3(3.)\n#define sk vec3(1.5, 2.1, 3.)\n\n#define l0 vec3(0., 6., 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\t\n            vec2 uv = (st - n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            float xx = (iMouse.z > 0.) ? ms.x : sin(T) * .6;\n            \n            float sn = sin(ms.x);\n            \n            vec3 o = vec3(sin(Pi * T * .1) * 2., 1., cos(Pi * T * .1) * 2.) * 6.;\n            vec3 t = vec3(0., 0., 0.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            \n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                \n                back = mix(gd, sk, n.y * .5 + .5) / Pi;\n                if (uv.x > xx) \n                {\n                    col += back;\n                \tcol *= m.col * m.ao * .5;\n                    #if CB\n                    col *= m.bleed;\n                    #endif\n                }\n                else\n                    col += m.ao;\n            }\n            else\n                col = back / Pi;\n            \n            float sz = 3. / iResolution.y;\n            col *= smoothstep(sz * .5, sz, abs(uv.x - xx));\n            \n            f_col += col;            \n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[214, 384, 419, 419, 477], [479, 479, 531, 531, 636], [638, 638, 681, 681, 744], [746, 746, 793, 931, 979], [981, 981, 1010, 1010, 1348], [1673, 1673, 1695, 1695, 2464], [2466, 2466, 2490, 2490, 2670], [2737, 2737, 2772, 2772, 3069], [3071, 3071, 3117, 3117, 3262], [3344, 3344, 3401, 3401, 4955]]}
{"id": "ttXfzl", "name": "Ray Marching + Shadows", "author": "Burnout6010", "description": "Two ray marched scenes with real-time shadows", "tags": ["raymarch", "mandelbulb", "shadow"], "likes": 0, "viewed": 113, "published": "Public", "date": "1597433663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hold & drag on window to move view\n#define PI 3.1415f\n#define mandelbulb 1 //1 is Mandelbulb scene, 0 is spheres scene\n\n//The shortest distance function of a plane\nfloat GetPlaneSDF(vec3 point, vec3 normal, float height)\n{\n    return dot(point, normal) - height;\n}\n\n//The shortest distance function of a sphere\nfloat GetSphereSDF(vec3 point, vec3 spherePos, float radius)\n{\n    return (length(point - spherePos) - radius);\n}\n\n//The shortest distance function of Mandelbulb\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat GetMandelbulbSDF(vec3 pos)\n{\n    float power = 6.f + sin(iTime) * 0.1f;\n    //float power = iMouse.x / (iResolution.y*0.1f) + sin(iTime) * 0.1f;\n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 128; i++)\n    {\n\t\tr = length(z);\n\t\tif (r > 2.f) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y, z.x);\n\t\tdr =  pow( r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5f * log(r) * r/dr;\n}\n\n//Following describes the scene\nfloat GetSceneSDF(vec3 point)\n{\n    #if mandelbulb\n    \n    //Mandelbulb scene\n    return GetMandelbulbSDF(point);\n    \n    #else\n    \n    //Other scene\n    float sphereRadius = (sin(iTime) + 2.f) * 3.f;\n    \n    //Spheres\n    float s1 = GetSphereSDF(point, vec3(0.f,0.f,20.f), sphereRadius * 0.75f);\n    float s2 = GetSphereSDF(point, vec3(10.f,0.f,25.f), sphereRadius);\n    float s3 = GetSphereSDF(point, vec3(-10.f,0.f,25), sphereRadius);\n    float spheres = max(min(s2,s3), -s1);\n    \n    //Planes\n    float p1 = GetPlaneSDF(point, vec3(0.f, 1.f, 0.f), -10.f);\n    float planes = p1;\n    \n    //Total\n    return min(spheres, planes);\n    #endif\n}\n\n//Estimate the normal of a given point using the scene\nvec3 GetNormal(vec3 point)\n{\n    //Get distance\n\tfloat dist = GetSceneSDF(point);\n    vec2 e = vec2(.01, 0); //faster to type out\n    \n    //Obtain normal\n    return normalize(dist + vec3(\n        GetSceneSDF(point + e.xyy),\n        GetSceneSDF(point + e.yxy),\n        GetSceneSDF(point + e.yyx)));\n}\n\n//Perform the raymarching itself\nfloat DoMarch(vec3 dir, vec3 origin)\n{\n    //Settings\n \tconst int maxStep = 512;\n    const float maxDistance = 512.f;\n    const float minStep = 1.f / 8192.f;\n    \n    //Start\n    float total = 0.f;\n    float step = GetSceneSDF(origin);\n    \n    //March into the scene for a maximum amount of steps\n    for(int i=0; i < maxStep; ++i)\n    {\n        vec3 point = origin + dir * total;\n        step = GetSceneSDF(point);\n        total += step;\n        \n        //If step was quite small, end\n        if(step < minStep)\n        {\n            return total;\n        }\n    }\n    \n    //If too far, we didn't hit anything\n    if(total > maxDistance)\n    {\n        return 0.f;\n    }\n    \n    return total;\n}\n\n//Perform some lighting calculations\nvec3 DoLight(vec3 pos, vec3 viewDir)\n{\n    //Different lights for different scenes\n    #if mandelbulb\n    vec3 lightDir = normalize(vec3(0.3f, -0.57f, -0.95f)); //light\n    #else\n    vec3 lightDir = normalize(vec3(sin(iTime), -0.57f, cos(iTime))); //light\n    #endif\n    \n    vec3 normal = GetNormal(pos);\n    float value = clamp(dot(-lightDir, normal), 0.f, 1.f);\n\t\n\tif(DoMarch(-lightDir, pos + normal * 0.01f) != 0.f) //No hit == sees light\n    {\n        value *= 0.2f;\n    }\n    \n\tvec3 col = vec3(value * 0.85f, value * 0.85f, value * 0.75f); //sun\n    col += vec3(0.05f, 0.05f, 0.075f); //ambient\n    \n    //Phong\n    vec3 refle = normalize( (normal * 2.f * (dot(normal, lightDir))) - lightDir);\n    float spec = pow(max(dot(viewDir, refle), 0.f), 2.f);\n    col.xyz += spec * 0.2f;\n    \n    //Return result\n    return clamp(col, 0.f, 1.f);\n}\n\n//Creates the look at matrix for given cam pos and a target to look towards\nmat4 LookAt(vec3 camPos, vec3 target)\n{\n    vec3 forward = normalize(target - camPos);\n    vec3 right = normalize(cross(vec3(0.f, 1.f, 0.f), forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    return mat4(\n        vec4(right, 0.f),\n        vec4(up, 0.f),\n        vec4(forward, 0.f),\n        vec4(camPos, 1.f));\n}\n\n//The main program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Readjust fragcoords to have 0,0 in the middle\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //Mouse remapped to -1, 1\n    vec2 mouse = ((iMouse.xy-0.5f*iResolution.xy)/iResolution.xy) * 2.f;\n\n    //Setup ray\n    const float camDist = -2.5f;\n    vec3 camPos = vec3(0.f, 0.f, 0.f)\n        + vec3(sin(-mouse.x * PI), -mouse.y, cos(-mouse.x * PI)) * camDist;\n    vec3 camTarget = vec3(0.f, 0.f, 0.f);\n    \n    //Direction of the ray for this fragment, rotated by the LookAt matrix\n    vec3 dir = (LookAt(camPos, camTarget) * normalize(vec4(uv, 1.f, 0.f))).xyz;\n    \n    //March and obtain colour if there is a hit\n    vec3 col = vec3(0.f, 0.f, 0.f);\n    float dist = DoMarch(dir, camPos);\n    if(dist != 0.f)\n    {\n        vec3 pos = camPos + dir * dist;\n        vec3 viewDir = normalize(pos - camPos);\n        col = DoLight(pos , viewDir);\n    }\n    \n    //Display result\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 166, 224, 224, 266], [268, 313, 375, 375, 426], [428, 600, 634, 634, 1294], [1296, 1328, 1359, 1359, 1978], [1980, 2035, 2063, 2082, 2335], [2337, 2370, 2408, 2423, 3067], [3069, 3106, 3144, 3188, 3951], [3953, 4029, 4068, 4068, 4357], [4359, 4378, 4434, 4486, 5366]]}
{"id": "ttXfzS", "name": "Chaos Abuser", "author": "t420babe", "description": "Inspiration from chapters 9 and 10 of The Book of Shaders \nhttps://thebookofshaders.com/09\nhttps://thebookofshaders.com/10", "tags": ["colors", "patterns", "truchet"], "likes": 1, "viewed": 170, "published": "Public API", "date": "1597004260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n// From https://thebookofshaders.com/edit.php#10/ikeda-00.frag\nfloat random(vec2 pos) {\n  return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// https://thebookofshaders.com/09/\nvec2 truchet_pattern(in vec2 _pos, in float _index) {\n  _index = fract(((_index - 0.5) * 2.0));\n  if (_index > 0.75) {\n    _pos = vec2(4.0) - _pos;\n  } else if (_index > 0.5) {\n    _pos = vec2(4.0 - _pos.x, _pos.x);\n  } else if (_index > 0.25) {\n    _pos = 4.0 - vec2(1.0 - _pos.y, _pos.y);\n  }\n  return _pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(0.0);\n  float keep_time = sin(2.0 * PI * iTime);\n\n  float A = 10.0;\n  float w = 0.5;\n  float phi = 0.0;\n  float wrap_time = abs(A * sin(w * iTime + phi));\n    \n  // [-1, 1]\n  vec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n  pos *= 2.0;\n  vec2 ipos = floor(pos);             // get the integer coords\n  vec2 fpos = fract(pos);             // get the fractional coords\n\n  vec2 tile = truchet_pattern(fpos, random(ipos)) * vec2(wrap_time);\n  tile.x = cos(tile.y) * sin(tile.x);\n  tile.y = log(tile.y) * log(tile.x);\n\n  float maze_color = 0.0;\n  maze_color =\n    smoothstep(tile.x - 0.3, tile.x, tile.y) -\n    smoothstep(tile.x, tile.x + 0.3, tile.y);\n\n\n\n  if (wrap_time < 0.25 * A) {\n    color = vec3(maze_color - 0.5, maze_color / 0.2, maze_color * 0.7);\n  } else if (wrap_time < 0.5 * A) {\n    color = vec3(maze_color + 0.5, maze_color / 0.2, maze_color * 0.7);\n  } else if (wrap_time < 1.0 * A) {\n    color = vec3(maze_color / 0.5, maze_color - 0.2, maze_color / 0.7);\n  }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 148, 172, 172, 247], [249, 285, 338, 338, 596], [599, 599, 656, 656, 1701]]}
{"id": "wdsBWB", "name": "exclamation-colored!", "author": "ichi_raven", "description": "exclamation", "tags": ["art"], "likes": 0, "viewed": 166, "published": "Public API", "date": "1597108815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool box(vec2 st, vec2 ul, vec2 dr)\n{\n    return\n    st.x > ul.x\n    && st.x < dr.x\n    && st.y > ul.y\n    && st.y < dr.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)\n        \t\t/ min(iResolution.x, iResolution.y);\n\n\n    if(box(uv, vec2(-0.15, -0.2), vec2(0.15, 0.8))\n        || box(uv, vec2(-0.15, -0.7), vec2(0.15, -0.4)))\n        fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1.0);\n    else\n        fragColor = vec4(1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 124], [126, 126, 183, 233, 549]]}
{"id": "Wl2BRm", "name": "Minimalism #04", "author": "Flopine", "description": "Fourth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "animation", "scanline", "minimalist"], "likes": 8, "viewed": 131, "published": "Public", "date": "1598555722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define TAU 6.2831853\n#define time(speed) fract(iTime*speed) \n#define square(puv,s) (max(abs(puv.x),abs(puv.y))-s)\n#define xor(a,b) ((1.-b)*a+(1.-a)*b)\n\nfloat frame (vec2 uv)\n{\n    float stripesy = floor(uv.y*15.)-.5;\n    float stripesx = floor(uv.x*15.)-.5;\n    \n    float squvx = uv.x + sin(time(stripesy*0.1)*TAU);\n    float squvy = uv.y + sin(time(stripesx*0.15)*TAU)*0.6;\n    \n \tfloat mask = smoothstep(0.01,0.02,square(vec2(squvx,uv.y),0.5));\n    mask = xor(mask,smoothstep(0.01,0.02,square(vec2(uv.x,squvy),0.5)));\n    \n    return mask;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = mix(vec3(0.01,0.06,0.),vec3(0.55,0.7,0.3),frame(uv*1.2)); \n        \n    // scanline\n    vec3 weight_G = vec3(1., 0.7, 1.);\n    vec3 weight_RB = vec3(0.7, 1., 0.7);\n    vec3 weight = mix(weight_G, weight_RB, mod(floor(fragCoord.y), 3.));\n    \n    fragColor = vec4(sqrt(col*weight),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2BRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 471, 494, 494, 866], [868, 868, 925, 925, 1288]]}
{"id": "Wl2fzm", "name": "simple faster clouds", "author": "danhel95", "description": " simple Clouds based on @42yeah,  with no textures LoD and personalized marching and stripped down perlins needed to 2 ! and faster :)", "tags": ["ray", "tutorial", "cloud", "marching", "sky", "short"], "likes": 4, "viewed": 169, "published": "Public", "date": "1598564014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Learning tutorial 4! \n// first attempt to make simple Clouds based on https://www.shadertoy.com/view/wsjfRD\n// by @42yeah,  with no textures LoD and personalized marching and \n// stripped down perlin needed to 2 ! and faster :)\n\n\n#define ITR 30.\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nconst vec3 a1 = vec3(0. );\nconst vec3 b1 = vec3(1.0, 0.0, 0.0);\nconst vec3 c1 = vec3(0.0, 1.0, 0.0);\nconst vec3 d1 = vec3(1.0, 1.0, 0.0);\nconst vec3 e1 = vec3(0.0, 0.0, 1.0);\nconst vec3 f1 = vec3(1.0, 0.0, 1.0);\nconst vec3 g1 = vec3(0.0, 1.0, 1.0);\nconst vec3 h1 = vec3(1.0, 1.0, 1.0);\n\n\nmat3 RX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), - sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 RY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        - sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 RZ(float a) {\n    return mat3(\n        cos(a), - sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n\n};\n\n\nray raydir(vec2 uv, vec2 m) {\n\n    float ang = sin(TWO_PI*m.x) * 1.;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    vec3 ro = vec3(15.0, 5.0, 15.0) + camR;\n    ro.z -= iTime * .01;\n\n    ro *= RX(-m.x*TWO_PI + iTime*.001 );\n    ro *= RY(- m.y *TWO_PI + iTime*.001);\n    ro *= RZ(- iTime *.01 );\n    vec3 lookat = vec3(0.);\n    float zoom = 1.;\n\n    vec3 forward = normalize(lookat - ro);\n    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = normalize(cross(forward, temp));\n    vec3 right = cross(up, forward);\n    vec3 screen_center = ro + forward * zoom;\n    vec3 i = screen_center + uv.x * right + uv.y * up;\n    vec3 rd = i-ro;\n\n    ray r ;\n    r.o = ro;\n    r.d = rd;\n    return r;\n\n}\n\nfloat rand(vec3 p) {\n    vec3 q = vec3(12.345, 67.89, 412.12);\n    return fract(sin(dot(p, q )) * 42123.45) *2.0 - 1.;\n}\n\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n\n    float a = rand(u + a1);\n    float b = rand(u + b1);\n    float c = rand(u + c1);\n    float d = rand(u + d1);\n    float e = rand(u + e1);\n    float f = rand(u + f1);\n    float g = rand(u + g1);\n    float h = rand(u + h1);\n\n    float r = mix(mix(mix(a, b, s.x),\n    mix(c, d, s.x), s.y),\n    mix(mix(e, f, s.x),\n    mix(g, h, s.x), s.y), s.z);\n    return smoothstep(.0,1.,pow(r,.5));\n}\n\n\n\nfloat fbm(vec3 p) {\n    vec3 off = vec3(10., 50., .1);\n    off.z *= iTime;\n    vec3 q = p - off;\n    float f = .0;\n    f += 0.5 * perlin(q); q *= 2.0;\n    f += 0.25 * perlin(q); q *= 2.0;\n     return  smoothstep(0., .8, f );\n}\n\nfloat scene( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.,1.0)*iTime*.4;\n    float f = fbm(q);\n    return f;\n}\n\n\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float denseD = 10.;\n    float denseE = 1.;\n    vec4 col = vec4(0.0);\n    for (float i = 0.; i < 1.; i+=1./ITR) {\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        vec4 color = vec4(d);\n        color *= pow(d/(denseD + d),denseE);\n        col += color * (1. - col.a);\n        t += i*.5;\n    }\n    col.rgb = clamp(col.rgb, 0., 1.) ;\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    ray r = raydir(uv,m);\n    vec3 sky = 2.*mix(vec3(.1, .5, .9), vec3(.1, .1, .9), uv.y);\n    vec4 col = march(r.o, r.d);\n    float fog = .5 - .5*col.a , a = 1.2, b=-.01;\n    vec3 colr = col.rgb;\n    colr = mix(vec3(col.rgb) * a * exp(b*col.a*col.a),sky, fog);\n    fragColor = vec4(colr, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 593, 611, 611, 719], [721, 721, 739, 739, 847], [849, 849, 867, 867, 975], [1020, 1020, 1049, 1049, 1738], [1740, 1740, 1760, 1760, 1860], [1862, 1862, 1884, 1884, 2356], [2360, 2360, 2379, 2379, 2586], [2588, 2588, 2614, 2614, 2693], [2696, 2696, 2726, 2726, 3114], [3117, 3117, 3172, 3172, 3578]]}
{"id": "wl2fzR", "name": "AWAKE", "author": "EDragon", "description": "A recreation of an animation from the game MapleStory\nI really liked the effect and wanted to try and see if I can recreate it", "tags": ["glitch", "neon", "maplestory"], "likes": 10, "viewed": 198, "published": "Public", "date": "1598468613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution.xy\n#define s smoothstep\n#define t iTime\n#define pi 3.1415\n\nmat2 rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat A(vec2 st){\n    float curve = .35;\n    float a = step(st.x+st.y*curve,.0)*step(.0,st.x-st.y*curve)*step(.15,-st.y)*step(-st.y,.75);\n    a *= 1.-step(.15,st.x-st.y*curve)*step(.15,-st.x-st.y*curve)*step(.7,-st.y);\n    a *= 1.-step(.15,st.x-st.y*curve)*step(.15,-st.x-st.y*curve)*step(-.6,st.y);\n    return a;\n}\n\nfloat W(vec2 st){\n    float curve = .35;\n    float w = step(.0,st.x+st.y*curve)*step(st.x-st.y*curve,1.)*step(.15,-st.y)*step(-st.y,.75);\n    w *= 1.-step(.15,st.x+st.y*curve)*step(st.x-st.y*curve,.5);\n    w *= 1.-step(.15+.35,st.x+(st.y)*curve)*step(st.x-st.y*curve,.5+.35);\n    w *= 1.-step(.15+.5,st.x-(st.y)*curve)*step(st.x+st.y*curve,.5-.15);\n    return w;\n}\n\nfloat K(vec2 st){\n    float curve = .75;\n    float k = step(.75,st.x)*step(st.x,1.5)*step(.15,-st.y)*step(-st.y,.75);\n    k *= 1.-step(st.x-st.y*curve,1.15)*step(.875,st.x);\n    k *= 1.-step(-.475,-st.x-st.y*curve)*step(.875,st.x);\n    k *= 1.-step(-st.x+st.y*curve,-1.29)*step(-st.x-st.y*curve,-.615);\n    return k;\n}\n\nfloat E(vec2 st){\n    float e = step(.35,st.x)*step(st.x,.8)*step(.15,-st.y)*step(-st.y,.75);\n    e *= 1.-step(.5,st.x)*step(-st.y,.625)*step(.51,-st.y);\n    e *= 1.-step(.5,st.x)*step(-st.y,.39)*step(.275,-st.y);\n    e *= 1.-step(.75,st.x)*step(-st.y,.6)*step(.3,-st.y);\n    return e;\n}\n//these functions made me feel so samrt yet I probably forgot how they work by now\n\nfloat rand21(vec2 st){\n\tst = fract(st*vec2(231.327,142.753));\n    st += dot(st, st+41.63);\n    return fract(st.x*st.y);\n}\n\nfloat lazer(vec2 st, float r){\n    st.y += 1.;\n    st *= rot(r);\n    st.y -= 1.;\n    float h = 1.-s(st.x,.0,.01)*s(-st.x,.0,.01);\n    return h;\n}\n//sometimes you just gotta h some lazers man\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*res.x)/iResolution.y;\n    vec2 uv3 = uv; //don't want to be affected by sir modified uv later on chief\n    vec2 uv4 = uv;\n    vec2 uv5 = uv;\n    vec3 col = vec3(0.0);\n    uv *= 1.8; //zoom\n    uv.x -= .075; //screen's doing a wack, don't mind it\n    vec2 uv6 = uv;\n    \n    \n    \n    float cap = 643326.1235; //zmart\n    float move = 224.124; //zmarterst\n    \n    float d = 0.; //d\n    \n    uv5 *= uv5.y-2.; //a classic of mine\n    uv5 *= 10.;\n\tuv5 -= vec2(.0,mod(t,500.)*.1); //stars get yeeha-ed overtime so this will keep'em in line\n    vec2 gv = fract(uv5)-vec2(.5,.9);\n    vec2 id = floor(uv5);\n    float n = 1.;\n    \n    for (float y=-n;y<=n;y++){\n        for (float x=-n;x<=n;x++){\n            vec2 off = vec2(x,y);\n            float r1 = rand21(id+off);\n            float r2 = rand21(id+off)*10.-.475;\n            float f = fract(r1*31.912);\n            \n    \t\tgv = fract(uv5)-vec2(.5,-1.);\n\t\t\tuv5 -= vec2(.0,mod(t,500.)*-.5);\n    \t\tid = floor(uv5);\n            \n            d = s(.1,1.,.02/distance(1.*gv-off,.75*vec2(r1*12.421,r2)-vec2(1.,.0)))*mix(1.,.5,r2);\n            col += d;\n        }\n    }\n    \n    float T = mod(t,10.);\n    \n    if (uv.y >= .25*sin(T*cap)-.75){\n    \tuv.x -= .01*sin(T*move+5323453.351);\n    }else if (uv.y <= .25*sin(T*cap)-.75){\n        uv.x += .01*sin(T*move+5321343.351);\n    }\n    \n    \n    vec2 uv2 = uv;\n\n    vec2 ap = vec2(.55+.75,.25);\n    vec2 wp = vec2(.4+.75,.25);\n    vec2 ap2 = vec2(.0,.25);\n    vec2 kp = vec2(.4,.25); //why did I keep it like that...\n    vec2 ep = vec2(-.55,.25);\n    float space = .02; //text space\n    float space2 = .005; //grid lines space\n    \n    uv3 = fract(uv3*3.+space2-vec2(.0,-t));\n    uv4 = fract(uv4*3.-space2-vec2(.0,-t));\n    \n    vec3 grid = vec3(1.-step(uv3.x-.99,2./res.x)*step(uv3.y-.99,1.25/res.y))*.2*vec3(1.,.0,.5);\n    vec3 grid2 = vec3(1.-step(uv4.x-.99,2./res.x)*step(uv4.y-.99,1.25/res.y))*.1*vec3(.0,1.,3.);\n    \n    \n    \n    vec3 bg = vec3(.0,.0,uv.y*.2+.2)*1.25;\n    bg += vec3(-uv.y*.1,.0,-uv.y*.2);\n    \n    col += max(bg,grid+grid2);\n    col += A(uv+vec2(-space+ap.x,ap.y))*vec3(1.,0.,0.5);\n   \tcol += A(uv+vec2(space+ap.x,ap.y))*vec3(0.,1.,1.);\n    \n    \n    col += W(uv+vec2(-space+wp.x,wp.y))*vec3(1.,0.,0.5);\n    col += W(uv+vec2(space+wp.x,wp.y))*vec3(0.,1.,1.);\n    \n    col += A(uv+vec2(-space+ap2.x,ap2.y))*vec3(1.,0.,0.5);\n    col += A(uv+vec2(space+ap2.x,ap2.y))*vec3(0.,1.,1.);\n    \n    col += K(uv+vec2(-space+kp.x,kp.y))*vec3(1.,0.,0.5);\n    col += K(uv2+vec2(space+kp.x,kp.y))*vec3(0.,1.,1.);\n    \n    col += E(uv+vec2(-space+ep.x,ep.y))*vec3(1.,0.,0.5);\n    col += E(uv+vec2(space+ep.x,ep.y))*vec3(0.,1.,1.);\n    \n    float range = .2; //lazer rotation range\n    float del = .5; //movement delay\n    \n    col += vec3(0.,1.,1.)*lazer(uv6-vec2(.3,-1.3),range*sin(t+del*0.)+.6);\n    col += vec3(1.,0.,.25)*lazer(uv6-vec2(.25,-1.3),range*sin(t+del*1.)+.45);\n    col += vec3(0.,1.,.5)*lazer(uv6-vec2(.2,-1.3),range*sin(t+del*2.)+.3);\n    \n    col += vec3(0.,1.,.5)*lazer(uv6-vec2(-.35,-1.3),range*sin(t+del*2.+pi)-.3);\n    col += vec3(1.,0.,.25)*lazer(uv6-vec2(-.4,-1.3),range*sin(t+del*1.+pi)-.45);\n    col += vec3(0.,1.,1.)*lazer(uv6-vec2(-.45,-1.3),range*sin(t+del*0.+pi)-.6);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2fzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 101, 101, 160], [162, 162, 179, 179, 477], [479, 479, 496, 496, 843], [845, 845, 862, 862, 1163], [1165, 1165, 1182, 1182, 1452], [1453, 1537, 1559, 1559, 1658], [1660, 1660, 1690, 1690, 1805], [1806, 1853, 1910, 1910, 5163]]}
{"id": "Wl2fzw", "name": "grass ball", "author": "osadchy", "description": "Attempt to create grass material", "tags": ["fast", "grass", "material"], "likes": 6, "viewed": 152, "published": "Public", "date": "1598551030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float GAMMA = 2.2;\n\nconst float LIGHT_BRIGHTNESS = 2.0;\nconst vec3 \tLIGHT_COLOR = vec3(1, 0.9, 0.7) * LIGHT_BRIGHTNESS;\n\nconst float AMBIENT_BRIGHTNESS = 0.1;\nconst vec3 AMBIENT_COLOR = vec3(0.5, 0.55, 0.8) * AMBIENT_BRIGHTNESS;\n\nvec3 get_normal(vec2 uv) {\n    return vec3(uv, sqrt(1.0 - dot(pow(uv, vec2(2)), vec2(1))));\n}\n\nvec3 get_noisy_normal(vec3 normal, vec2 uv) {\n\treturn normalize(normal + (texture(iChannel0, uv).xyz - 0.5));\n}\n\nfloat get_occlusion_factor(vec3 normal, vec3 sight_dir) {\n    return abs(dot(sight_dir, normal));\n}\n\nfloat get_specular_factor(vec2 uv) {\n\treturn texture(iChannel1, uv * 0.9 + vec2(0.5)).x;\n}\n\nvec3 get_diffuse_color(vec2 uv, vec3 normal, vec3 sight_dir) {\n    vec3 base = vec3(0.0, 0.0, 0.0);\n    vec3 middle = vec3(0.01, 0.02, 0.0);\n    vec3 top = vec3(0.4, 0.6, 0.05);\n    \n    float occlusion_factor = get_occlusion_factor(sight_dir, normal);\n    \n    float base_factor = (1.0 - texture(iChannel1, uv).x) * 2.0;\n    base_factor = clamp(base_factor - occlusion_factor, 0.0, 1.0);\n    base_factor = pow(base_factor, 0.5);\n    \n    float top_factor = texture(iChannel1, uv).x * 1.5;\n    top_factor = clamp(top_factor - occlusion_factor, 0.0, 1.0);\n    top_factor = pow(top_factor, 1.5);\n    \n    vec3 color = mix(base, middle, base_factor);\n    color = mix(color, top, top_factor);\n    return color;\n}\n\nfloat light_ambient(vec2 uv, vec3 normal, vec3 sight_dir) {\n    float ao_original = texture(iChannel1, uv).x;\n    float ao_decay = pow(get_occlusion_factor(normal, sight_dir), 2.0);\n    return mix(1.0, ao_original, ao_decay);\n}\n\nfloat light_diffuse(vec3 normal, vec3 light_dir, float scattering) {\n    float result = clamp(dot(light_dir, normal) * (1.0 - scattering) + scattering, 0.0, 1.0);\n    return result;\n}\n\nfloat light_specular(vec3 normal, vec3 light_dir, vec3 sight_dir, float shininess, float scattering) {\n    vec3 reflected = reflect(- light_dir, normal);\n    float result = max(dot(sight_dir, reflected), 0.0);\n    result *= max(sign(dot(normal, light_dir)), 0.0);\n    result = max(result * (1.0 - scattering) + scattering, 0.0);\n    result = pow(result, shininess);\n    return result;\n}\n\nvec3 render_grass(vec3 normal, vec2 uv, vec3 sight_dir, vec3 light_dir, vec3 light_color, vec3 ambient_color) {\n    vec3 noisy_normal = get_noisy_normal(normal, uv);\n    vec3 color = get_diffuse_color(uv, normal, sight_dir);\n    \n    float ambient = light_ambient(uv, noisy_normal, sight_dir);\n    \n    float diffuse = light_diffuse(noisy_normal, light_dir, 0.2) * 1.0;\n\n    float specular = light_specular(noisy_normal, light_dir, sight_dir, 1.0, -0.5) * 0.2;\n    specular *= get_specular_factor(uv);\n    \n    color *= (ambient * ambient_color + (diffuse + specular) * light_color);\n    return color;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    float light_rotation_speed = 1.0;\n    float phase = 0.6 + iTime * light_rotation_speed;\n    vec3 light_pos = vec3(2.0 * sin(phase), 1.0, 2.0 * cos(phase));\n    vec2 uv = frag_coord / iResolution.y * 2.2 - 1.1;\n    \n    // Background\n    frag_color = vec4(AMBIENT_COLOR, 1.0);\n    \n    if (length(uv) < 1.0) {\n    \tvec3 normal = get_normal(uv);\n        vec3 pos = normal;\n        vec3 sight_dir = vec3(0, 0, 1);\n        vec3 light_dir = light_pos;\n        vec3 grass = render_grass(normal, uv, sight_dir, light_dir, LIGHT_COLOR, AMBIENT_COLOR);\n        frag_color = vec4(grass, 1.0);\n    }\n    \n    // Light sphere\n    if ((distance(light_pos.xy, uv) < 0.1)) {\n        if ((light_pos.z > 0.0) || (length(uv) >= 1.0)) {\n        \tfrag_color = vec4(LIGHT_COLOR / LIGHT_BRIGHTNESS, 1.0);\n        }\n    }\n    \n    // Gamma-correction\n    frag_color = pow(frag_color, vec4(1.0 / GAMMA));\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2fzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 262, 262, 329], [331, 331, 376, 376, 442], [444, 444, 501, 501, 543], [545, 545, 581, 581, 635], [637, 637, 699, 699, 1345], [1347, 1347, 1406, 1406, 1574], [1576, 1576, 1644, 1644, 1759], [1761, 1761, 1863, 1863, 2147], [2149, 2149, 2260, 2260, 2752], [2754, 2754, 2811, 2811, 3698]]}
{"id": "WlBBD1", "name": "cartoon water", "author": "FabriceNeyret2", "description": "cascade of normalized flownoise ", "tags": ["perlinnoise", "distortion", "flownoise"], "likes": 11, "viewed": 331, "published": "Public API", "date": "1598772711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/WtBBD1\n\n  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n         U = F*F*(3.-2.*F);                   // based Perlin noise\n     //  U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nfloat Uperlin(vec2 p) { \n    float v = Perlin(p); \n    return smoothstep(-1.,1.,v/fwidth(v));    // normalized field\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.* ( 2.*u - R ) /R.y;\n    O -= O;\n    float s=1.;\n    vec4 C = vec4(.8,.85,1,0);\n    for (int i=0; i<5; i++, s*=2., C*=C) \n        O += C * Uperlin(s *(U+9.) ) / s;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBBD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 726, 748, 787, 1112], [1114, 1114, 1137, 1137, 1232], [1234, 1234, 1272, 1272, 1482]]}
{"id": "wlBBRm", "name": "Lit Cell", "author": "dr2", "description": "Seeking illumination", "tags": ["shadow", "light"], "likes": 15, "viewed": 267, "published": "Public API", "date": "1598528184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Lit Cell\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noiseff (float p);\nfloat Hashfv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar, wRad, bFac;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (21., 23.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p.yxz;\n  q.yz = Rot2D (q.yz, 0.1 * tCur);\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 d2;\n  float dMin, d, wThk;\n  dMin = dstFar;\n  wThk = 0.15;\n  d2 = SphGrid (p);\n  d = SmoothMin (d2.x, d2.y, 0.02);\n  d = SmoothMax (abs (PrSphDf (p, wRad)) - wThk, d, 0.02);\n  DMIN (1);\n  d = PrSphDf (p, 0.15 * wRad);\n  DMIN (2);\n  q = p;\n  q.xz = abs (q.xz) - 15.;\n  q.y -= -9.;\n  d = PrSphDf (q, 1.);\n  DMIN (3);\n  d = abs (PrBoxDf (p, vec3 (16., 10., 16.) + 0.1)) - 0.1;\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SphGridShad (vec3 p)\n{\n  vec2 d2;\n  d2 = SphGrid (p);\n  return SmoothMin (d2.x, d2.y, 0.01);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.3 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  if (abs (vn.x) > 0.99) {\n    rg = ShStagGrid (p.zy);\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg = ShStagGrid (p.zx);\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg = ShStagGrid (p.xy);\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec4 BallHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4, db4;\n  vec3 col, vn, roo, ltDir;\n  float dstObj, nDotL, cFac;\n  roo = ro;\n  wRad = 2.;\n  bFac = 0.96 + 0.04 * Noiseff (32. * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    ltDir = - normalize (ro);\n    if (idObj == 1) col4 = vec4 (0.8, 0.7, 0.6, 0.2);\n    else if (idObj == 2) col4 = vec4 (vec3 (1., 1., 0.7) * bFac, -1.);\n    else if (idObj == 3) col4 = vec4 (vec3 (0.8, 0.8, 0.8) * bFac, 0.1);\n    else if (idObj == 4) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n      rg4 = ShStagGrid3d (0.5 * ro, vn);\n      vn = rg4.xyz;\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n      if (rg4.w == 1. && min (abs (ro.x), abs (ro.z)) > 15.9) col4.rgb *= 0.7;\n      vn = VaryNf (8. * ro, vn, 1.);\n    }\n    if (idObj == 3 || idObj == 4) col4 *= 0.8 + 0.2 * step (0.001, SphGridShad (ltDir));\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = bFac * (col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * nDotL * nDotL) +\n         col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    } else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  }\n  cFac = (idObj == 1 || idObj == 2) ? 0.02 : 0.06;\n  for (float r = float (VAR_ZERO); r <= 14.; r ++) {\n    db4 = BallHit (roo, rd, wRad + 0.2 * (14. - r + Hashfv3 (rd + 2. * tCur)));\n    vn = db4.yzw;\n    vn = VaryNf (64. * vn, vn, 0.3);\n    if (db4.x < dstFar) col = mix (col, bFac * vec3 (1., 1., 0.8),\n       cFac * step (0.001, SphGridShad (vn)));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n    el -= 0.08 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -9.);\n  zmFac = 2.;\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 591, 614, 614, 1081], [1083, 1083, 1105, 1105, 1525], [1527, 1527, 1560, 1560, 1744], [1746, 1746, 1767, 1767, 2022], [2024, 2024, 2052, 2052, 2124], [2126, 2126, 2152, 2152, 2479], [2481, 2481, 2518, 2518, 3079], [3081, 3081, 3125, 3125, 3326], [3328, 3328, 3363, 3363, 4900], [4944, 4944, 5000, 5000, 6133], [6135, 6135, 6167, 6167, 6267], [6269, 6269, 6302, 6302, 6329], [6331, 6331, 6376, 6376, 6479], [6481, 6481, 6526, 6526, 6564], [6566, 6566, 6602, 6602, 6808], [6810, 6810, 6840, 6840, 6953], [6987, 6987, 7011, 7011, 7076], [7078, 7078, 7102, 7102, 7155], [7157, 7157, 7181, 7181, 7293], [7295, 7295, 7320, 7320, 7466], [7468, 7468, 7493, 7493, 7679], [7681, 7681, 7710, 7710, 7922], [7924, 7924, 7963, 7963, 8143]]}
{"id": "wlBBz1", "name": "Motion blur experiment", "author": "scanlime", "description": "Just seeing what happens if we add a brute force motion blur to iq's sphere tracing engine", "tags": ["motionblur"], "likes": 3, "viewed": 98, "published": "Public", "date": "1598299003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sphere tracing engine from https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n#define TAA 32   // temporal antialiasing\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat timeSample = 0.;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n      res = opU( res, vec2( sdSphere( pos-vec3(2.*sin(timeSample*11.),0.25,2.*cos(timeSample)), 0.25 ), 26.9 ) );\n    }\n    \n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int q=ZERO; q<TAA; q++ )\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        timeSample = iTime + float(q)*(iTimeDelta * 0.8 / float(TAA));\n\n        vec2 mo = iMouse.xy/iResolution.xy;\n\t\tfloat time = 32.0 + timeSample*1.5;\n\n    \t// camera\t\n\t    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n\t    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n\t\t// camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA*TAA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBBz1.jpg", "access": "shaders20k", "license": "mit", "functions": [[1290, 1359, 1384, 1384, 1403], [1404, 1404, 1429, 1429, 1448], [1449, 1449, 1485, 1485, 1513], [1539, 1539, 1564, 1564, 1579], [1581, 1581, 1616, 1616, 1642], [1644, 1644, 1675, 1675, 1766], [1768, 1768, 1816, 1816, 2104], [2105, 2105, 2164, 2164, 2253], [2255, 2255, 2288, 2288, 2343], [2345, 2345, 2415, 2415, 2555], [2557, 2557, 2593, 2593, 2904], [2906, 2906, 2962, 2962, 3464], [3466, 3466, 3518, 3518, 3632], [3634, 3634, 3698, 3698, 3976], [3978, 3978, 4041, 4105, 4692], [4694, 4694, 4730, 4730, 5080], [5082, 5094, 5130, 5130, 5233], [5235, 5260, 5311, 5311, 5666], [5668, 5680, 5727, 5727, 6072], [6074, 6074, 6145, 6145, 6483], [6485, 6485, 6549, 6549, 7109], [7111, 7157, 7205, 7205, 7374], [7376, 7376, 7413, 7413, 8007], [8009, 8009, 8051, 8051, 8651], [8653, 8693, 8757, 8757, 9015], [9017, 9087, 9117, 9117, 9150], [9252, 9322, 9347, 9347, 9536], [9538, 9606, 9657, 9657, 9862], [9864, 9864, 9904, 9904, 10714], [10716, 10778, 10856, 10879, 11267], [11269, 11333, 11365, 11365, 11935], [11937, 11937, 11979, 11979, 12288], [12290, 12366, 12430, 12451, 12684], [12686, 12686, 12751, 12770, 15193], [15195, 15195, 15247, 15247, 15424], [15426, 15426, 15483, 15483, 16925]]}
{"id": "WlBfRR", "name": "The 3D Party Cube", "author": "Hexdigest", "description": "Bouncing Party Cube, my second ever raymarching & shadertoy project.", "tags": ["3d", "raymarch", "cube", "party", "hexdigest"], "likes": 1, "viewed": 145, "published": "Public", "date": "1598132371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n//#define SURF_DIST 44.\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n\n    float d = sdBox(p, vec3(1));\n    \n    if(iTime>22.95){\n        d = sdBox(p, vec3(iTime / 10.,iTime / 10.,iTime / 10.));\n    }\n    \n    if(iTime>35.8){\n        d = sdBox(p, vec3(1.+sin(iTime),2. + sin(iTime),3.+sin(iTime)));\n    } \n    if(iTime>78.06){\n\n\t\td = sdBox(p, vec3(1.+sin(iTime),1. + sin(iTime),1.+sin(iTime)));\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float fft) {\n\tfloat dO=-333.;\n    float SURF_DIST = fft * 13.;\n    if(iTime>9.8){\n        SURF_DIST = 0.;\n    }\n    if(iTime>22.95){\n        SURF_DIST = fft;\n    }\n\n    if(iTime>70.06){\n        SURF_DIST = sin(iTime)*10.;\n    }\n    \n    if(iTime>78.06){\n        SURF_DIST = fft;\n    }\n    if(iTime>104.){\n        SURF_DIST = 2.0 + sin(iTime * 0.5);\n    }\n    if(iTime>218.){\n        SURF_DIST = 100.;\n    }\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec4 t = texture(iChannel0, uv);\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 col = vec3(-.2);\n    vec3 ro = vec3(0, 2, -1);\n    ro.x += 1.*sin(iTime / 1.2);\n    ro.y += 1.* cos(iTime / 1.2);\n    ro.z += sin(iTime) * cos(iTime);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    if(iTime>9.8){\n        ro.x += 10.*sin(iTime / 1.88);\n        ro.y += 11.* cos(iTime / .44);\n        ro.z += sin(iTime) * cos(iTime);\n\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    if(iTime>22.95){\n        ro.x = 10.*cos(iTime);\n        ro.y = 10.*sin(iTime);\n        ro.z = 5.;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*3.14);\n    }\n    \n    if(iTime>48.85){\n        ro.x += 10.*sin(iTime / 1.88);\n        ro.y += 11.* cos(iTime / .44);\n        ro.z += sin(iTime) * cos(iTime);\n\n        ro.yz *= Rot(-m.y*4.);\n        ro.xz *= Rot(-m.x*8.);\n    }\n    \n    if(iTime>61.75){\n        ro.x += 3.;\n        ro.y += 3.;\n        ro.z += 3.;\n    }\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.4);\n    //ro.xy *= sin(iTime / 2.);\n    \n    float fft = texture(iChannel0, vec2(0., 0.)).x;\n    \n    float d = RayMarch(ro, rd, fft);\n   \n    d += 2.;\n    if(iTime>48.85){\n\t\td += -255.;\n    }\n    \n    if(iTime>61.75){   \n\t\td += 215.;\n    }\n    \n    if(iTime>78.06){\n        ro.x = 0.;\n        ro.y = 0.;\n        ro.z = 0.;\n        ro.yz *= Rot(-m.y*2.);\n        ro.xz *= Rot(-m.x*2.);\n    }\n\n    ro.y += iTime * cos(ro.y / 23.);\n    if(iTime>218.){\n        ro.x = 1.;\n        ro.y = 1.;\n        ro.z = 1.;\n        ro.y = 1.;\n    }\n    //uv *= mat2(cos(t), -sin(t), sin(t), cos(t));\n    \n    vec3 lookat = mix(vec3(0), vec3(-1, 0, -1), sin(iTime*1.56)*.5+.5);\n    float zoom = mix(.5, .1, sin(iTime)*.5+.5);\n    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u;\n    \n    float radius = mix(.3, 1.5, sin(iTime*.4)*.5+.5);\n    \n    float dS, dO;\n    vec3 p;\n    \n    for(int i=0; i<23; i++) {\n    \tp = ro + rd * dO;\n        dS = -(length(vec2(length(p.xz)-4., p.y)) - radius);\n        if(dS<.2) break;\n        dO += dS;\n    }\n\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;\n        col.r = d;\n        col.b = d * d;\n\n        float x = atan(p.x, p.z)+iTime*.5;\t\t\t// -pi to pi\n        float y = atan(length(p.xz)-1., p.y);\n        \n        float bands = sin(y*122.+x*30.);\n        float ripples = sin((x*130.-y*30.)*3.)*.5+.5;\n        float waves = sin(x*2.-y*6.+iTime*20.);\n        \n        float b1 = smoothstep(-.4, .2, bands);\n        float b2 = smoothstep(-.4, .2, bands-.5);\n        \n        float m = b1*(1.-b2);\n        m = max(m, ripples*b2*max(0., waves));\n        m += max(0., waves*.1*b2);\n        \n        col.r = sin(iTime / 5.);\n        col.g = cos(iTime / 5.);\n        col.b = tan(iTime / 3.);\n        col += mix(m, 1.-m, smoothstep(-.3, .3, sin(x+iTime)));\n\n   \t\tvec2 f_uv = fract(uv * .0) -.3 * col.r / 2.0;\n        d = length(f_uv);\n    }\n\n    col = pow(col, vec3(sin(iTime)));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 107, 126, 126, 188], [190, 190, 212, 212, 306], [308, 308, 337, 337, 418], [420, 420, 443, 443, 790], [792, 792, 837, 837, 1418], [1420, 1420, 1444, 1444, 1623], [1625, 1625, 1675, 1675, 1866], [1868, 1868, 1925, 1925, 5223]]}
{"id": "wlBfzW", "name": "two bubble rings", "author": "cyperus", "description": "Parametric procedural 3d-object, allowing smooth transitions between spheres, tori, torusknots, based on julia fractal.\nhttps://www.youtube.com/user/cyperquantus\nhttps://www.shadertoy.com/view/3stSR8 Stephane Cuillerdier - Aiekick/2019 (twitter:@aiekick)", "tags": ["julia", "torus", "sphere", "knot"], "likes": 9, "viewed": 429, "published": "Public API", "date": "1598396806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Patrik Colling - cyperus/2020 (https://www.youtube.com/user/cyperquantus)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Parametric procedural 3d-object allowing smooth transitions between \n// spheres, tori, torusknots.\n//\n\n#define AA\n\n#define PI 3.14159265359\n// Time modulation\n#define PIiTime PI * iTime\n#define sinTime02 sin(0.2*iTime)\n#define sinTime03 sin(0.3*iTime)\n#define sinTime05 sin(0.5*iTime)\n#define sinTime07 sin(0.7*iTime)\n\n// complex number transformations\nvec2 cmul(vec2 za,vec2 zb){return za*mat2(zb.x,-zb.y,zb.yx);}\t// z_out = za*zb\nvec2 cpowq(vec2 z, float q){float r = pow(length(z), q);\t\t// z_out = z^q\n\tfloat a=q* atan(z.y,z.x); return vec2(r*cos(a),r*sin(a));}\nvec2 ctfr(vec2 z,float x0, float p, float a){ \t\t\t\t\t// z_out = (z*e^ia)^p-x0\n\treturn cpowq( cmul(z, vec2(cos(-a),sin(-a))),p) - vec2(x0, 0.);}\n\n// came\nmat3 camerabase(vec3 co, vec3 ct, vec3 cup){\n    // co\t: camera origin point in worldspace\n    // cup\t: camera up direction vector in worldspace\n    // ct\t: camera target point in worldspace\n\tvec3 cw = normalize(ct - co);\t\t// camera ponting direction\n\tvec3 cu = normalize(cross(cup, cw));// camera left right\n\tvec3 cv = normalize(cross(cw, cu));\t// camera down up\n    return mat3(cu,cv,cw); // return camera orhtogonal basis as matrix\n}\n\nvec3 cameraraydirection(vec2 uv, mat3 cam, float f){\n    // uv : Viewport coordinates\n    // cam : camera orhtogonal basis\n    // f : focal length zoom-in: abs(f) ==> 0., zoom-out: abs(f) ==> +inf.\n    return normalize(cam * vec3(f*uv,1.)); \n}\n\nvec4 df(vec3 p)\n{\t///// MetaTorus-transformation\n    \n    // component swizzling: openGL => math coordinatesystem notation.\n    p = p.zxy; //(z, x, y) => (x, y, z)\n    \n    //// (torus,sphere,2spheres)-transformation TODO: (e0)\n    // cylindrical coordinate system\n    float au = atan(p.y, p.x); // [-PI, +PI]\n    float rxy = length(p.xy); // [0., +inf]\n    // 3D => 2D-space: radial half plane in cylindrical coordinate system == half complex plane\n    vec2 z = vec2(rxy, p.z);\n    // julia, half complex plane => complex plane\n\tfloat shift0 = 1.4+(1.0+sinTime05); // [-inf, +inf]\n    z = cmul(z,z)- vec2(shift0, 0.); // realaxis-translation, fraction == 2 \n    \n    //// juliafractal-transformation\n\t/// julia fractal iteration 0\n    const float fracu1 = 3.0; // int in [1,2,3,..]\n    const float fracv1 = 2.0; // int in [1,2,3,..]\n    const float twist1 = 0.0; // int in [...,-1,0,+1,...]\n    // shiftX modulation with FourierSerie F(fracu1 * au)\n    float shift1\t= 2.0 * sinTime02 \t\t\t\t\t\t\t\t\t\t\t\t// 0. order \n        \t\t\t+ 0.5 * cos(1. * (fracu1 * au) + (0.5 * PIiTime) );\t\t\t\t// 1. order\n            \t\t//+ 0.25 * cos(2. * (fracu1 * au) + (0.5 +0.01 * PIiTime) ); \t// 2. order\n    // torsionX must meet knot condition.\n    float torsion1 = au * twist1 / fracv1 - 0.25 * PIiTime;\n    z = ctfr(z, shift1, fracv1,  torsion1); // realaxis-translation,fraction,rotation\n\t/// julia fractal iteration 1\n    const float fracu2 = 7.0;\n    const float fracv2 = 3.0;\n    const float twist2 = 5.0;    \n    float shift2 = 0.5 +1.4 * sinTime03 + 0.5 * cos(fracu2 * au +0.0- 0.02 * PIiTime);\n    float torsion2 = au * twist2 / fracv2 + 0.05 * PIiTime;\n    z = ctfr(z, shift2, fracv2, torsion2);\n    \n\t/// estimated ray-step-length\n\tfloat d = log(length(z)); // :( but it works! TODO: (1)\n\treturn vec4(d , z, au * fracu1 * fracu2);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0.0 );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    // antialeasing\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .92), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n    //// Pixel2Viewport-space\n    vec2 o = rook[n];\n    vec2 uv = (2.*(fragCoord+o)-iResolution.xy)/min(iResolution.x,iResolution.y);\n#else //AA\n\tvec2 uv = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n#endif //AA\n      \n    // mouse\n    vec2 m = vec2(2.*iMouse.x/iResolution.x-1.,(-2.*iMouse.y/iResolution.y+1.)); // [-1.,+1.]\n    \n    //// camera, Viewport2World-space\n    float aa = PI*m.x; // [-PI,+PI]\n    float ab = 0.49*PI*m.y; // ]-PI/2,+PI/2[\n    vec3 co = 4.*vec3( cos(ab)*sin(aa),sin(ab),cos(ab)*cos(aa)); // camera origin \n\n\tconst vec3 cup = vec3(0,1,0);\t// camera up direction in Worldspace\n\tconst vec3 ct = vec3(0,0,0);\t// camera target point in Worldspace\n\tmat3 cam = camerabase(co,ct,cup);   //cameradirection = cam[0];\n \n    const float f = 0.6;\n    vec3 rd =  cameraraydirection(uv,cam, f);\n    \n\t// ray marching\n    const float rayDistMax = 14.;\t// maximal ray distance length\n    const float rayiMax = 300.;\t\t// maximal ray marching iterations\n    const float rayF = 0.02;\t\t// ray step multiplier\n    const float rayEpsi = 0.0001;\n\tfloat rayStep = 1.; // ray step length\n    float rayDist = 0.; // ray distance length\n\tfor (float i=0.; i<rayiMax; i++){\n\t\tvec3 p = co + rd *rayDist; // point in 3D worldspace\t        \n\t\tif (abs(rayStep)<rayEpsi || rayDist>rayDistMax) break;\n\t\trayStep = df(p).x;\n\t\trayDist += rayStep * rayF;\t\n\t}\n    \n\t//// World2Color-space\n    const vec3 ld = vec3(0.,1.,.5); // ligth direction\n    const vec3 lc = vec3(0.4); // ligth color\n    vec3 col;\n    vec3 sky = GetSky(rd, ld, lc);\n\t\n\tif (rayDist<rayDistMax)  // intersection with object\n\t{\n        vec3 p = co + rd * rayDist;\t     \n\t\tvec3 n = nor(p, 0.001);\t// compute normale\n\t\tvec4 mat = df(p);\n        // uv-coords\n        vec2 mat_uv;\n        mat_uv.x = atan(mat[2],mat[1])/PI;\n        mat_uv.y = mat[3]/PI;\n        // texture color\n        const float smoothness = 0.001; // TODO: (2) Calculation inside df()?\n\t\tcol.rgb = vec3(smoothstep(-smoothness,smoothness,cos(PI*mat_uv.x)*cos(PI*mat_uv.y)));                             \n\t\t// lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.16).x);\n        float spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n        float sss = df(p - n*0.001).x/0.01;\n        // shading\t\n        dif *= softshadow( p, ld, 0.1, 1. );\n        vec3 brdf = vec3(0.0);\n        brdf += 0.5*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.5*spe*vec3(0.8,0.60,0.20)*dif;\n        brdf += 0.3*amb*vec3(0.40,0.60,0.40)*occ;\n        brdf += 0.4;\n        col.rgb *= brdf;\n        //\n        col.rgb = mix( col.rgb, sky, 1.0-exp( -0.02*rayDist*rayDist ) ); \n\t}\n\telse\n\t{// no intersection => background\n\t\tcol.rgb = sky;\n\t}\n    \n    tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    // gamma correction\n\tfragColor = vec4( sqrt(0.4*tot), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBfzW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[500, 534, 561, 561, 595], [596, 613, 641, 641, 745], [746, 746, 791, 821, 887], [889, 897, 941, 1087, 1333], [1335, 1335, 1387, 1532, 1578], [1580, 1580, 1597, 1703, 3396], [3398, 3398, 3430, 3430, 3609], [3611, 3627, 3701, 3701, 3940], [3942, 3958, 4000, 4000, 4318], [4398, 4516, 4573, 4573, 4861], [4863, 4863, 4920, 4920, 8043]]}
{"id": "WlBfzz", "name": "Double pendulum zeroes", "author": "neurofuzzy", "description": "The classic double pendulum system is examined. Bluish areas are areas where the double pendulum is nearly periodic in time t=iTime/3.0. That is, where it nearly winds up at the same initial conditions.", "tags": ["physics"], "likes": 0, "viewed": 95, "published": "Public", "date": "1598176457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThe classic double pendulum system is examined. Bluish areas are areas where \nthe double pendulum is nearly periodic in time t=iTime/3.0. That is, where it \nnearly winds up at the same initial conditions. The starting configuration is \nalways the same, and the canonical momenta p1 and p2 depend on the uv coordinates\nof each pixel.\n\nAs you would expect, things get chaotic for large t.\n*/\n\n\n\nfloat metric(float a1,float b1,float c1,float d1,float a2,float b2,float c2,float d2){\n    return 4.0-2.0*cos(a1-a2)-2.0*cos(b1-b2)+(c1-c2)*(c1-c2)+(d1-d2)*(d1-d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float colorCutoff=0.0; //Set this to 0 to not have the colors be so washed out. Set it to 1 to make it clear where things are almost periodic\n    float totaltime=iTime/3.0;\n    int ntimesteps=800;\n    float dt=totaltime/float(ntimesteps);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p=uv*20.5;\n    \n    float theta10=1.0;\n    float theta20=0.0;\n    float p10=(uv.x-1.0)*7.0;\n    float p20=(uv.y-0.9)*7.0;\n    \n    float theta1=theta10;\n    float theta2=theta20;\n    float p1=p10;\n    float p2=p20;\n    \n    \n    /* Leapfrog method for the double pendulum. Code used to generate this is at the end of the file. */\n    for(int i=0;i<ntimesteps;i++){\n       \tfloat theta1tmp = theta1 + (2.*dt*(-1.*p1 + p2*cos(theta1 - 1.*theta2)))/(-3. + cos(2.*(theta1 - 1.*theta2)));\n        float theta2tmp = theta2 + (2.*dt*(-2.*p2 + p1*cos(theta1 - 1.*theta2)))/(-3. + cos(2.*(theta1 - 1.*theta2)));\n        theta1 = theta1tmp;\n        theta2 = theta2tmp;\n        float p1tmp = p1 + dt*(-2.*sin(theta1) - (2.*(-2.*(((p1)*(p1)) + 2.*((p2)*(p2)))*cos(theta1 - 1.*theta2) + p1*p2*(5. + cos(2.*(theta1 - 1.*theta2))))*sin(theta1 - 1.*theta2))/((-3. + cos(2.*(theta1 - 1.*theta2)))*(-3. + cos(2.*(theta1 - 1.*theta2)))));\n        float p2tmp = p2 + dt*((2.*(-2.*(((p1)*(p1)) + 2.*((p2)*(p2)))*cos(theta1 - 1.*theta2) + p1*p2*(5. + cos(2.*(theta1 - 1.*theta2))))*sin(theta1 - 1.*theta2))/((-3. + cos(2.*(theta1 - 1.*theta2)))*(-3. + cos(2.*(theta1 - 1.*theta2)))) - 1.*sin(theta2));\n        p1=p1tmp;\n        p2=p2tmp;\n    }\n    \n    float dist=min(metric(theta10,theta20,p10,p20,theta1,theta2,p1,p2),1.0);\n    \n    \n    \n    fragColor = vec4(max(colorCutoff,0.5*(1.0+cos(theta1)))*dist,max(colorCutoff,0.5*(1.0+sin(theta1)))*dist,1.0-dist,1.0);\n    //fragColor = vec4(max(colorCutoff,0.5*(1.0+cos(theta1)))*dist,max(colorCutoff,0.5*(1.0+sin(theta1)))*dist,dist*max(colorCutoff,0.5*(1.0+sin(theta2))),1.0);\n    //fragColor = vec4(dist,dist,dist,1.0);\n    \n}\n\n\n/* Code used to generate the C Form of the code.\n\ndirection[theta_]={Sin[theta],-Cos[theta]};\npos1=direction[theta1];\npos2=pos1+direction[theta2];\nlagrangian=FullSimplify[1/2 Dt[pos1].Dt[pos1]+1/2 Dt[pos2].Dt[pos2]-pos1[[2]]-pos2[[2]]];\nhamiltonian=FullSimplify[Dt[theta1] p1+Dt[theta2]p2-lagrangian /.First[Solve[{D[lagrangian,Dt[theta1]]==p1,D[lagrangian,Dt[theta2]]==p2},{Dt[theta1],Dt[theta2]}]]];\neoms[t_]=(({Dt[p1]==-D[hamiltonian,theta1],Dt[p2]==-D[hamiltonian,theta2],Dt[theta1]==D[hamiltonian,p1],Dt[theta2]==D[hamiltonian,p2]}//FullSimplify )/. {p1->p1[t],p2->p2[t],theta1->theta1[t],theta2->theta2[t]})/.{Dt[t]->1};\nics[t_]={theta1[0]==1,theta2[0]==0,p1[0]==0,p2[0]==1};\nStringReplace[StringReplace[StringRiffle[{\"float theta1tmp = theta1 + \"<>ToString[CForm[N@FullSimplify@D[hamiltonian,p1]dt]]<>\";\",\n\"float theta2tmp = theta2 + \"<>ToString[CForm[N@FullSimplify@D[hamiltonian,p2]dt]]<>\";\",\n\"theta1 = theta1tmp;\",\n\"theta2 = theta2tmp;\",\n\"float p1tmp = p1 + \"<>ToString[CForm[N@FullSimplify@D[-hamiltonian,theta1]dt]]<>\";\",\n\"float p2tmp = p2 + \"<>ToString[CForm[N@FullSimplify@D[-hamiltonian,theta2]dt]]<>\";\",\n\"p1=p1tmp;\",\n\"p2=p2tmp;\"\n},\"\\n\"] ,{Shortest[\"Power(\"~~x__~~\",2)\"]->\"((\"<>x<>\")*(\"<>x<>\"))\"}],{\"Cos\"->\"cos\",\"Sin\"->\"sin\"}]\n*/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 397, 483, 483, 563], [565, 565, 622, 622, 2573]]}
{"id": "wlfBRj", "name": "CloudsAttempt#3000", "author": "sunnyfree", "description": "yep", "tags": ["clouds"], "likes": 4, "viewed": 41, "published": "Public", "date": "1597188304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 RanNum(vec2 uv)\n{\n    float num = 0.;\n\n    vec3 a = fract(uv.xyx*vec3(520.152,123.432,593.21));\n    \n    a += dot(a, a+52.54); \n    \n    return fract(vec2((a.x*a.y),(a.y*a.z)));\n}\n\nvec2 RanPos(vec2 id, vec2 offset)\n{\n    vec2 pos = vec2(0.);\n    \n    float t = iTime;\n    pos = RanNum(id+offset)*iTime*0.1;\n    \n    return offset + sin(pos)*.4;\n}\n\nfloat LineMask(vec2 p, vec2 a, vec2 b)\n{\n    float mask = 0.; \n    vec2 pa = p - a; \n    vec2 ba = b - a;\n    float t = clamp(dot(pa,ba) / dot(ba,ba),0.,1.);    \n    mask = length(pa-ba*t);\n    return mask;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b )\n{\n    float d = LineMask(p, a ,b);\n    float m = smoothstep(.03,.01,d);\n    return m;\n}\n\nfloat CloudMask(vec2 uv, float multiplications)\n{\n    uv *= multiplications;\n    \n    \n    \n    //returning only the fractional component of uv.\n   \tvec2 guv = fract(uv)-0.5;\n    \n    //returning the id of the grid cell.\n    vec2 cellID = floor(uv);\n    \n    float mask = 0.;\n    \n    vec2 neighbors[9];\n    int index = 0;\n    \n    for (float y = -1.; y <= 1.; y++)\n    {\n        for (float x = -1.; x <= 1.; x++)\n        {\n            //make a line to each neighboring cell\n            vec2 offset = vec2(x,y);\n            neighbors[index++] = RanPos(cellID,offset);\n        }\n    }\n    float d = 100.;\n    \n    for (int i = 0; i < 9; i++)\n    {\n        //get distance from each pixel to each neighbor\n        //if the distance is lower than the last one, replace it\n        float temp = distance(guv,neighbors[i]);\n        if (temp < d)\n        \td = temp;\n    }\n    return mask = 1.-d;\n    \n}\n\nfloat Layer(vec2 uv)\n{\n\tfloat t = iTime;\n    \n    uv += t*0.5;\n    \n    vec3 col = vec3(0.);\n    float ca = CloudMask(uv, 3.5);\n    float cb = CloudMask(uv, 25.213);\n    float c = mix(ca,cb,0.05);\n \t\n    ca = CloudMask(uv, 1.5);\n    c = mix(c,ca,0.7);\n    ca = CloudMask(uv, 10.);\n    c = mix(c, ca, 0.1);\n    \n    float mask = 0.;\n    mask += c;\n    col += vec3(mask)*vec3(0.5,0.5,0.5);\n    col = max(col - 0.2, 0.);\n    col = min(col * (col + 20.), 1.);\n    vec3 mask2 = vec3(c);\n    vec3 l = mix(col, mask2, 0.8); \n    l = max(l - 0.2, 0.);\n    float n = max(l.x-0.3,0.);\n    \n    return n;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    col += Layer(uv);\n    \n    float m = 0.;\n    float t = (iTime)*0.1;\n    float s = sin(t*0.5);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    for (float i = 0.; i <= 1.; i += 1./4.)\n    {\n        float z = fract(i+t);\n        float size = mix(10.,.5,z);\n        float fade = smoothstep(0.,.5,z) * smoothstep(1.,.8,z);;\n        m += Layer(uv*size+i*25.)*fade;\n    }\n    \n    col = vec3(0.5,0.6,0.7);\n    col += vec3(m);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 184], [186, 186, 221, 221, 351], [353, 353, 393, 393, 561], [563, 563, 600, 600, 686], [688, 688, 737, 737, 1582], [1584, 1584, 1606, 1606, 2181], [2183, 2183, 2240, 2290, 2873]]}
{"id": "WlfBRl", "name": "Lasers546984", "author": "Toctave", "description": "-", "tags": ["lasers"], "likes": 5, "viewed": 621, "published": "Public", "date": "1597391338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n#define M_PI 3.1415926535897932384626433832795\n\nvec2 rot2(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return vec2(c * v.x + s * v.y, -s * v.x + c * v.y);\n}\n\nvec2 polar(vec2 v) {\n    v = 2. * v - 1.;\n    float theta = atan(v.y, v.x);\n    float r = sqrt(dot(v, v));\n    return vec2(r, theta / (2. * M_PI) + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0, 0, 0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    //uv *= 2.;\n    //uv = fract(uv);\n\n    //uv = rot2(uv, iTime * .1);\n    uv = polar(uv);\n    uv *= vec2(10, 800);\n    \n    \n    uv.x = -10. * (random(vec2(floor(uv.y), 1)) + .8) * iTime + ((random(vec2(floor(uv.y), 2)) * 2. - 1.) * .5 + 1.) * uv.x;\n   \tvec2 id = floor(uv);\n    uv = fract(uv);\n    \n    col.r = random(id) < .1 ? uv.x : 0.0;\n    \n    \n    //col.xy = uv;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 126, 147, 147, 278], [280, 346, 368, 368, 426], [427, 427, 449, 449, 507], [508, 508, 530, 530, 588], [590, 748, 780, 780, 1200], [1202, 1251, 1276, 1276, 1327], [1328, 1328, 1353, 1353, 1404], [1405, 1405, 1430, 1430, 1481], [1482, 1482, 1507, 1507, 1558], [1608, 1608, 1640, 1640, 1755], [1757, 1757, 1777, 1777, 1911], [1913, 1913, 1970, 1970, 2524]]}
{"id": "WlfBRs", "name": "shifty plasma effect", "author": "thefox231", "description": "looks neat, i enjoy\nhttps://www.bidouille.org/prog/plasma", "tags": ["plasma"], "likes": 2, "viewed": 169, "published": "Public API", "date": "1597410146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n \n#define change (sin(iTime) * .5 + .5)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float v = 0.0;\n    vec2 u_k = vec2(8.0);\n    float time = iTime;\n    \n    vec2 c = (fragCoord.xy / iResolution.xy) * u_k - u_k/2.0;\n    \n    float off = mix(1.0, -1.0, change);\n    \n    v += sin((c.x * off + time));\n    v += sin((c.y * off + time)/2.0);\n    v += sin((c.x * -off + c.y * off + time)/2.0);\n    c += u_k / 2.0 * vec2(sin(time/3.0), cos(time/2.0));\n    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0) + time);\n    v = v / 2.0;\n    \n    float a = sin(v * mix(2.0, 2.4, change) * PI) * .5 + .5;\n    float b = cos(v * mix(2.0, 2.4, change) * PI) * .5 + .5;\n    \n    vec3 col1 = vec3(a - b - .2, a, a - b - .3);\n    vec3 col2 = vec3(b - a - .2, b - a - .3, b);\n    \n    fragColor = vec4(mix(col1, col2, change), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 141, 141, 867]]}
{"id": "wlfBWB", "name": "Dream-3", "author": "KayKay", "description": "❤️ YEP THIS IS EXACTLY WHAT MY DREAM-WAVE LOOKS LIKE.  ", "tags": ["color"], "likes": 1, "viewed": 49, "published": "Public", "date": "1597654055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2020-08-18 / NANJING / 3RD TIME TRIAL - MY IDEAL DREAM-WAVE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    if(uv.y<0.5*(1.0+0.5*sin(1.2*iTime+4.0*sin(uv.x))))\n    fragColor = vec4(col,1.0);\n    else fragColor=vec4(1.0,1.0,1.0,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 64, 121, 171, 456]]}
{"id": "WlfBWf", "name": "infinite eggs", "author": "Deadtotem", "description": "Practice code", "tags": ["infinite", "eggs"], "likes": 1, "viewed": 59, "published": "Public", "date": "1598172608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fogInt 0.009  //Fog / Distance Int\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat eggs(vec3 p) {\n\tfloat e = cos(p.y) * .825;\n    float o = (sin(p.x) - sin(p.y)) * sin(p.z) - e * .5 + .5 * (abs(sin(iTime*.75)*.75));\n\treturn o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv  = ( fragCoord.xy / iResolution.xy );\n\tuv.y *= iResolution.x / iResolution.y ;\n\tvec3 norm = normalize(vec3(uv, .750));\n    float a = atan(norm.y, norm.y);\n    norm.xy *=Rot(a * 5.5 + iTime * .05);\n\tvec3 pos = vec3(2., 2., iTime * 1.75);\n\tfloat o = 0.0;\n\n    for(int i = 0 ; i < 250; i++) {\n\t\tfloat outEggs = (eggs(pos + norm * o) * .5 + .5);\n\t\tif(outEggs < .1) break;\n\t\to += outEggs ;\n\t}\n\n\tfragColor = vec4(vec3(max(0.,eggs(pos+norm*o))+o*fogInt)+norm* (sin(iTime*.55)*.35), .05);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 63, 63, 125], [128, 128, 148, 148, 279], [281, 281, 338, 338, 831]]}
{"id": "wlfBWS", "name": "Abstract Fractal", "author": "propagant", "description": "Made an abstract Apollonian fractal with simple raymarching techniques.", "tags": ["raymarching", "fractal", "apollonian"], "likes": 3, "viewed": 223, "published": "Public API", "date": "1597584890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----Simple apollonian fractal formula by Matej Vanco\n\nstruct ray\n{\n\tvec3 o,d;\n\tfloat l;\n};\n\n//---Fractal initialization - known Apollonian formula\nvec4 fractal(vec3 p, vec2 par, vec3 color)\n{\n\tfloat s = par.x;\n\tfloat g = 45.;\n    //---Additional rotation in deg\n\tp.xy*=mat2(sin(g), -cos(g), cos(g), sin(g));\n\tfloat c = 1.5;\n\n\tfloat scale = 1.;\n\tvec3 cStorage = color;\n    \n\tfor (int i = 0; i < 13; i++)\n\t{\n\t\tp = -1. + 2.0 * fract(0.5 * p + 0.5);\n\n\t\tfloat r2 = dot(p, p);\n\n        //---Color addition\n\t\tcolor += mix(0.8 - color, vec3(0.09,0.0,0.8) * pow(r2, 0.8), 0.8);\n\n\t\tfloat k = s / r2;\n\t\tp *= k;\n\t\tp.x *= par.y;\n\t\tscale *= k;\n\t}\n \t//---Returns final color & fractal value\n\treturn vec4(color * cStorage, 0.25 * abs(p.y) / scale);\n}\n\t\n//---Essential Geometry Function\nvec4 geo(vec3 p)\n{\n    //-Pos-AdditionalParams-Color\n\treturn fractal(p-vec3(0.22+sin(iTime * 0.2)*0.1,0.9,0.2),vec2(1.24,0.75),vec3(0.3,0.29,0.095));\t\n}\n\t\n//---Main Raymarch\nvec4 march(ray r)\n{\n\tvec3 c = vec3(0.);\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tc = g.rgb;\n\t\tr.l += g.w;\n\t\tif(r.l>8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(c, r.l);\n}\n\n//---Final Render output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy -0.5 * iResolution.xy ) / iResolution.y; //---UV recalculation (to the center)\n\n    vec3 c = vec3(0.);\n\t\n\tray r = ray(vec3(0.), vec3(uv,1.), 0.);  //---Ray initialization\n\tvec4 mm = march(r);\n\tvec3 p = r.o + r.d * mm.w; //---March step\n\tc = mm.rgb * mm.w;\n\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 149, 193, 193, 736], [739, 772, 790, 824, 924], [927, 946, 965, 965, 1141], [1143, 1168, 1225, 1225, 1539]]}
{"id": "WlfBzB", "name": "Gerdes Tchokwe Lusona Pattern", "author": "Shane", "description": "A weaved reimagining of Fabrice's Gerdes Tchokwe sand drawing example, rendered in a faux 3D isometric hand drawn style.", "tags": ["truchet", "draw", "pattern", "tile", "sand", "faux", "gerdes", "lusona", "tchokwe"], "likes": 28, "viewed": 397, "published": "Public API", "date": "1597153871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Gerdes Tchokwe Sand Pattern\n    ---------------------------\n\n\tThis is a very basic African influenced Lusona pattern rendered in a \n\tpseudo 3D isometric fashion in the style of oldschool scrollers.\n\tFabrice Neyret often posts interesting snippets of code with visually\n\tsatisfying results. In fact, some are a little too interesting, because \n    one minute I'll be working on something I'm supposed to be doing, then\n\tthe next minute I'm coding up a basic Angolan Tchokwe Lusona pattern. :D\n\n\tThis particular pattern represents a very small subsection of a larger \n    body of work by mathematician and author Paulus Gerdes. In case it needs \n    to be said, African inspired mathematics as it pertains to Sona sand \n    drawings is not my area of expertise. :)\n\n    Algorithmically, the base pattern here is pretty simple to make: Create \n    a square or diamond grid, then randomly render crosses or opposite sided \n    arcs on each shared edge or vertex. From my perspective, the basic design \n    is just a standard two tiled Truchet pattern with some edge constraints. \n    In particular, you force any arc tile to have either a horizontal or \n    vertical orientation on an alternate checkered basis. Use the SHOW_GRID\n    define to show the individual tiles that make up the pattern.\n\n    Since Fabrice has already covered the algorithmic side of things, I \n\tdecided to focus on the rendering. I've mentioned before that I sometimes \n    enjoy producing pseudo 3D effects more than real ones, since faux 3D \n\teffects often requires finesse and inventiveness. This is just simple \n\tlayering effects that most Photoshop artists take for granted -- Drop \n    shadows, bevels, highlights, etc. For the cross tiles (a line on top of \n    another line), I went to the trouble to render Bezier curves to put a \n    little kink at the cross-over points to enhance the illusion. It's a \n    subtle difference that added a chunk of code, but I think it makes all \n    the difference.\n\n    As mentioned, this is the most basic of patterns. There are a wide range \n    of others out there. Fabrice has created a few extentions that are worth \n    looking at. In addition, a proper 3D version of this would be relatively \n    simple, as too would a Wang tile variation. I'm not positive, but I'm \n    pretty sure it'd be possible to create a multiscale version as well. With \n    restrictions on the line lengths, animation flow might be possible, but \n    I'll save variations for another time. :)\n\n\n    Links:\n\n    // Based on the imagery from the following.\n    P.Gerdes & Tchokwe sand drawing - FabriceNeyret2\n    https://www.shadertoy.com/view/wtsfWM\n\n    // A nice variation.\n    P.Gerdes & Tchokwe sand drawing5 - FabriceNeyret2\n    https://www.shadertoy.com/view/3llfRS\n\n\n\tInspiration from Angolan traditional designs - Paulus Gerdes\n\thttps://plus.maths.org/content/new-designs-africa\n\n    Lusona - Wikipedia\n    https://en.wikipedia.org/wiki/Lusona\n\n*/\n\n// Display the individual cell tiles. Note that in this particular case,\n// the entire coordinate system has been rotated by 45 degrees to look\n// like a diamond grid, but this still a square grid.\n//#define SHOW_GRID\n\n// Makes for a neater pattern, but looks less convincing.\n//#define STRAIGHT_LINES\n\n// This takes out the edge constrainst, which results in a standard\n// two-tiled random Truchet pattern.\n//#define RANDOM_TRUCHET\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(57.609, 27.483)))*43758.5453); }\n\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.*B + C;\n    vec2 c = a * 2.;\n    vec2 d = A - pos;\n\n    // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b, b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.*dot(a, a) + dot(d, b))/3.;\n    float kz = kk * dot(d, a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.*kx*kx - 3.*ky) + kz;\n    float h = q*q + 4.*p3;\n\n    if(h >= 0.) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q)/2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        float t = uv.x + uv.y - kx;\n        t = clamp(t, 0., 1.);\n\n        // 1 root.\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.))/3.;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m)*z - kx;\n        t = clamp(t, 0., 1.);\n\n        // 3 roots.\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos, qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos, qos);\n        res = min(res, dis);\n\n        res = sqrt(res);\n    }\n    \n    return res;\n}\n\n\n// This is a standard distance field setup for one, two or more\n// Truchet tiles with some minor additions. The tiles used are\n// overlapping crossed lines and the common double arc tile.\n//\n// There are two distance field value holders for line one or\n// line two in order to render one over the other, and two for\n// each arc, even though one would suffice, since there's no \n// overlap. The only other difference is that we're constructing\n// Bezier lines for the wavy line kinks instead of standard \n// straight ones.\n//\n// There is also a place holder for the central dots that you can\n// see and a final position to identify whether we've returned\n// a cross tile or a double arced one.\n//\nvec4 distField(vec2 p){\n\n    \n    // Offset field position for the central dots. See below.\n    vec2 q = p - .5;\n    \n   \n    // Standard square grid ID and local position.\n    vec2 ip = floor(p) + .5;\n    p -= ip;\n    \n    // Vertice and edge postions... Probably overkill for such a simple example,\n    // but it's a good habit to get into when dealing with more complex setups.\n    const vec2[4] v = vec2[4](vec2(-.5, .5), vec2(.5),  vec2(.5, -.5),  vec2(-.5));\n    const vec2[4] e = vec2[4](vec2(0, .5), vec2(.5, 0),  vec2(0, -.5),  vec2(-.5, 0));\n    \n    \n    \n    // Distance field place holder.\n    vec4 d = vec4(1e5);\n  \n    // Edge width.\n    float ew = .13;\n    \n   \n    // Using the cell ID for some unique random numbers.\n    float rnd = hash21(ip);\n    float rnd2 = hash21(ip + .37);\n    #ifdef RANDOM_TRUCHET\n    float rnd3 = hash21(ip + .73);\n    #endif\n    \n    // Checkered arrangement: The black and white chessboard arrangement comes up\n    // in so many different situations that it's worth committing to memory. In this\n    // case we are aligning all double arc tiles either horizontally or vertically,\n    // depending upon which checker we're on.\n    float check = mod(ip.x + ip.y, 2.);\n    \n    \n    // Render overlapping lined crosses on half the tiles. You could change the\n    // percentage, if you wanted.\n    if(rnd<.5){\n        \n        // X and Y nudge factors to produce the Bezier kinks.\n        #ifdef STRAIGHT_LINES\n        // No kind for the straight lines.\n        const vec2 ndgX = vec2(0);\n        vec2 ndgY = vec2(0);\n        #else\n        // Kink the horizontal lines up and the vertical lines\n        // to the left. If the tiles get rotated, they will switch\n        // to down and right, which makes sense.\n        const vec2 ndgX = vec2(-.075, 0);\n        vec2 ndgY = vec2(0, .075);\n        #endif\n        \n        // Randomly rotate some of the tiles: This has the effect of putting\n        // the top line on the bottom. The nudge factor has to be reversed\n        // to keep the line kinks pointing in the right direction.\n        if(rnd2<.5) {\n            p = rot2(3.14159/2.)*p;\n            ndgY *= -1.;\n        }  \n        \n         \n        // Rendering the Bezier lines, which aren't much different to normal lines, except there's\n        // an additional anchor point to give it a curved appearance. IQ wrote the Bezier algorithm\n        // itself, which wouldn't have been easy.\n        //\n        // Bottome line.... All of these join together at their end points.\n        d.x = min(d.x, sdBezier(p, e[2]*1., e[2] + vec2(0, .1), e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., e[0] - vec2(0, .1), e[0]*1.) - ew);\n        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., ndgY, e[2] + vec2(0, .25) + ndgX/3.) - ew);\n        \n        // Top line.\n        d.y = min(d.y, sdBezier(p, e[3]*1., e[3] + vec2(.1, 0), e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., e[1] - vec2(.1, 0), e[1]*1.) - ew);\n        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., ndgY, e[3] + vec2(.25, 0) + ndgY/3.) - ew);\n        \n        // Tile ID: Zero for a cross.\n        d.w = 0.;\n    }\n    else {\n        \n        // The line here is the only difference between Paulus Gerdes's Tchokew inspired sand pattern\n        // arrangement and a regular double tiled Truchet pattern... If you look at the comments on\n        // Fabrice Neyret's original Shadertoy pattern you'll see that I'm kind of convinced of that,\n        // but I'm not positive... Either way, it's a pretty pattern, so whatever. :D\n        //\n        // As you can see, I've provided an option to randomly rotate tiles as well, which will \n        // produce the common double tiled pattern that you've probably seen all over the place.\n        //\n        #ifdef RANDOM_TRUCHET\n        if(rnd3<.5) p = rot2(3.14159/2.)*p; // Random rotation.\n        #else\n        if(check<.5) p = rot2(3.14159/2.)*p; // Checker pattern constained rotation.\n        #endif \n        \n        // The two quarter arcs: You could put an arc in each of \"d.x\" and \"d.y,\" however,\n        // we're joining both together in the top layer, just in case there's overlap.\n        //d.x = abs(length(p - v[0]) - .5) - ew;\n        //d.y = abs(length(p - v[2]) - .5) - ew;\n        \n        d.y = abs(length(p - v[0]) - .5) - ew;\n        d.y = min(d.y, abs(length(p - v[2]) - .5) - ew);\n        \n        // Tile ID: One for regular double arcs.\n        d.w = 1.; \n        \n    }\n    \n\n    // The distance field for the central black dots.\n    vec2 ip2 = floor(q) + .5;\n    q -= ip2;\n    if(mod(ip2.x + ip2.y, 2.)<.5){\n        d.z = min(d.z, length(q));\n        d.z -= ew*.8;\n\t}\n\n    \n    // Return the tile one and two, the central dots and ID.\n    return d;\n}\n\n\n// The grid cell borders.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p) + .5;\n    p = abs(p - ip);\n\n    return abs(max(p.x, p.y) - .5) - .015;\n   \n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n  \n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // The pattern is resolution based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd; \n\n    return hatch;\n    \n}\n\n// Translating the camera about the XY plane.\nvec2 getCamTrans(float t){ return vec2(sin(t/8.)/16., t/1.); }\n\n// Rotating the camera about the XY plane.\nmat2 getCamRot(float t){\n    \n    //return rot2(0.);\n    return rot2(cos(t/4.)/16.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    \n    // Scaling, rotation and translation.\n    float gSc = 7.5;\n\t// Rotating and moving the canvas. A 2D \"to\" and \"from\" setup would be better, but this\n    // will do for the purpose of the demonstration.\n    vec2 cam = getCamTrans(iTime); // Translation.\n    mat2 camRot = getCamRot(iTime); // Rotation.\n    // Extra 45 degred rotation to give a diamond grid appearance.\n    vec2 p = rot2(3.14159/4.)*(uv*gSc)*camRot + rot2(3.14159/4.)*cam;    \n    \n    \n    // Transformed coordinate copy.\n    vec2 oP = p;\n\n     \n    // Four samples for various things. In this case, it's shadows, highlights,\n    // a pattern field, and the base distance field.\n    vec4 dSh = distField(p - vec2(-2, -1)*.07);\n    vec4 dHi = distField(p + vec2(-2, -1)*.04);\n    vec4 dp = distField(p*6.);\n    vec4 d = distField(p);\n    \n    \n    \n    float sf = 1./iRes*gSc;\n    \n    vec3 col = vec3(1, .9, .95);//vec3(.8, .6, .4);//vec3(1, .9, .95);//\n\n    vec3 lCol = vec3(1, .05, .1);//vec3(1, .05, .1);//vec3(1, .8, .6)/8.;//\n    \n    \n    \n    float pat = smoothstep(0., sf*6., min(dp.x, dp.y))*.5 + .5;\n\n    \n    #ifdef SHOW_GRID\n    // Display the individual cell tiles.\n    float grid = gridField(p);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(grid, -(d.z - .25)))));\n    col = mix(col, col*1.5, (1. - smoothstep(0., sf*2., grid - .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n    \n    vec2 iq = floor(p) + .5;\n    vec2 q = p - iq;\n\n    vec2 sh = max(.5 - d.xy/.15, 0.);\n    vec2 shHi = max(.5 - dHi.xy/.15, 0.);\n    \n    \n    // Thickening the base distance (the extruded walls).\n    d -= .03;\n  \n    // If it's a cross (overlapping line) tile, darken the shadow on the\n    // bottom and add high a highlight to the top line at the crossover point.\n    // It's a subtle effect, but it helps create the illusion.\n    if(d.w < .001){\n        sh.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        shHi.y *= max(1.5 - dot(q, q)*1.5, 1.);\n        \n        sh.x *= min(.5 + dot(q, q)*4., 1.5);\n        shHi.x *= min(.5 + dot(q, q)*4., 1.5);\n    }\n      \n    \n    // Subtle effect to give the ground some shadowy perturbation.\n    col = mix(col, vec3(.3, .1, .2), (1. - smoothstep(0., sf*15., min(dSh.x, dSh.y) - .03))*.25);\n    \n    // Applying the bottom layer of the cell tile. In order is a shadow, fake AO, dark\n    // edge, extruded base layer, top dark edge, and upper hilighted layer. There's a few\n    // layers here, but it's still extremely cheap compared to raymarching.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(dSh.x, dSh.y) - .03*iRes/450.))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., min(d.x, d.y) - .03))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x - .03)));\n    col = mix(col, lCol*sh.x, (1. - smoothstep(0., sf, d.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.x - .015))*.95);\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, dHi.x + .015)));\n\n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.x + .12)));\n  \n    // Applying the intividual top layers of the cell tile.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(max(d.x, d.y - .15), dSh.y)))*.55);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(d.x - .03, d.y - .03*iRes/450.)))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.y - .03)));\n    col = mix(col, lCol*sh.y, (1. - smoothstep(0., sf, d.y)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dHi.y - .015))*.95);\n    col = mix(col, lCol*shHi.y*5.*pat, (1. - smoothstep(0., sf, dHi.y + .015)));\n    \n    // A cheap environmental glaze.\n    col = mix(col, col.xzy*pat*1.5, (1. - smoothstep(0., sf*3., dHi.y + .12)));\n    \n    \n    // Putting some hacky patches on the center of the cell edges to account\n    // for some rendering overlay issues. It's one of the downsides to rendering\n    // layers on a grid. :)\n    q = oP;\n    iq = floor(q) + .5;\n    q -= iq;\n    q = abs(q) - .5;\n    float sq = max(abs(q.x + .5), abs(q.y));\n    sq = min(sq, max(abs(q.x), abs(q.y + .5))) - .25;\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) - .015)));\n    col = mix(col, lCol*shHi.x*5.*pat, (1. - smoothstep(0., sf, max(sq, min(dHi.x, dHi.x)) + .015)));\n   \n \n    // The dark central circles.\n    col = mix(col, col*1.4, (1. - smoothstep(0., sf*8., dHi.z - .03)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.z)));\n    \n         \n    // Post processing.\n    //col = mix(col, col.xzy, dot(col, vec3(.299, .587, .114))/8.);\n    col *= vec3(.8, .75, .6);\n \n\n    \n    // Cheap hatch overlay to give it a very cheap hand drawn look.\n    float hatch = doHatch(rot2(-3.14159/4.)*oP/gSc, iResolution.y);\n    col *= hatch*.4 + .75;\n     \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3401, 3434, 3456, 3456, 3514], [3517, 3545, 3566, 3566, 3629], [3633, 3817, 3866, 4062, 5526], [5529, 6225, 6248, 6316, 11083], [11086, 11112, 11136, 11136, 11241], [11243, 11320, 11353, 11405, 11820], [11822, 11868, 11894, 11894, 11930], [11932, 11975, 11999, 12027, 12061], [12063, 12063, 12117, 12160, 17137]]}
{"id": "WlfBzj", "name": "I'm a little field of color", "author": "darknoon", "description": "Just a gaussian * sine moving around ", "tags": ["particles", "gaussian"], "likes": 6, "viewed": 197, "published": "Public API", "date": "1597115608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define N 6\n#define duration 13.0\n\nfloat sit(float x, float q) {\n    return cos(3.14159*q*x)*exp2(-0.5*x*x);\n}\n\nfloat sinc(float x, float q) {\n    return cos(3.14159*x)/(3.14159*x);\n}\n\n\nvec4 hash4( vec3 p )\n{\n    vec4 q = vec4( dot(p,vec3(127.1,311.7,256.8)), \n\t\t\t\t   dot(p,vec3(269.5,183.3,012.5)), \n\t\t\t\t   dot(p,vec3(419.2,371.9,167.1)),\n                   dot(p,vec3(269.5,183.3,918.1))\n                 );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nvec4 noise24(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    vec4 h0 = hash4(p.xyy);\n    vec4 h1 = hash4(p.xyy + vec3(1.,0.,0.));\n    \n    return mix(h0, h1, smoothstep(0., 1., f.x));\n}\n\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// isquilez color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * 3.141 * (c * t + d)));\n}\n\n\nvoid mainImage(out vec4 color, in vec2 fc)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fc/R.xy;\n    uv -= 0.5;\n    uv.x *= R.x / R.y;\n\n    // Time varying pixel color\n    vec3 col = 0.05 * (colorMap(0.1*iTime) - 0.5);\n    \n    float str = 3. / float(N);\n    \n    for (int i=0; i<N; i++) {\n        float phase = float(i) * 356.4878;\n        vec4 n = noise24(vec2(iTime / duration + phase, float(i)));\n        vec2 p = n.xy - 0.5;\n        float k = sin(8.*n.z);\n        float r = 4.*length(uv - p);\n        vec3 pcolor = colorMap(n.w + 0.8*r);\n    \tcol += k * str * sit(r, 1.5)*pcolor;\n    }\n    \n\n    // Output to screen\n    col = smoothstep(-1.0, 1.0, col);\n    \n    // Blue noise dither\n    vec2 offset = fract(sin(iTime * vec2(1231.25, 53823.0))*43758.5453);\n    vec2 tc = fc / iChannelResolution[0].xy + offset;\n    col += 6. / 256. * (texture(iChannel0, tc).rgb - 0.5);\n\n    color.rgb = col;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 86, 86, 132], [134, 134, 164, 164, 205], [208, 208, 230, 230, 467], [470, 470, 492, 492, 672], [798, 823, 847, 847, 898], [901, 901, 945, 995, 1820]]}
{"id": "wlfBzS", "name": "kikyoumon with ripples", "author": "surffer3d", "description": "Playong with SDF", "tags": ["test"], "likes": 0, "viewed": 46, "published": "Public", "date": "1597424895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 uv, vec2 sz) {\n    vec2 a = abs(uv) - sz;\n    return max(a.x, a.y);\n}\n\n\nfloat circle(vec2 uv, float r) {\n    return length(uv) - r;\n}\n\n\nfloat polygon(vec2 uv, float r, float sides) {\n    float sect = 2.0*3.14159 / sides;\n    float angle = sides * (atan(uv.y, uv.x) / 6.2831 + 0.5);\n    float fangle = fract(angle);\n    float d = length(uv);\n    float L = r * (1.0 - 2.0 * cos(sect*0.5));\n    float D = L / tan(sect*0.5);\n    float H = D * tan(abs(fangle-0.5)*sect);\n    float d2 = sqrt(H*H+D*D);\n    return d - d2;\n}\n\nfloat flower(vec2 uv, float r, float sides) {\n    float sect = 2.0*3.14159 / sides;\n    float angle = sides * (atan(uv.y, uv.x) / 6.2831 + 0.5);\n    float fangle = fract(angle);\n    float d = length(uv);\n    float L = r * (1.0 - 2.0 * cos(sect*0.5));\n    float D = L / tan(sect*0.5);\n    float H = D * tan(abs(fangle-0.5)*sect);\n    float d2 = sqrt(H*H+D*D);\n    \n    float u = 1.0-abs(fangle-0.5)*2.0;\n    u = max(u-0.5, 0.0)/0.5;\n    float m = pow(u,2.5)*0.15;\n    \n    return d - d2 + m;\n}\n\n\nfloat plot(float uv, float v) {\n    float w = 0.005 + fwidth(uv);\n    return smoothstep(v-w, v, uv) - smoothstep(v, v+w, uv);\n}\n\nfloat merge(float A, float B) {\n    return min(A, B);\n}\n\nfloat intersect(float A, float B) {\n    return max(A, B);\n}\n\nfloat substract(float A, float B) {\n    return intersect(A,-B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 5.0;\n    vec2 fuv = fract(uv);\n\n    // Time varying pixel color    \n    uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float c = cos(iTime*0.2);\n    float s = sin(iTime*0.2);\n    c = cos(-3.14159/2.0);\n    s = sin(-3.14159/2.0);\n    uv = mat2(c,-s,s,c) * uv;\n    \n    \n    \n    // Modify uv to make ripple effect\n    vec2 vpos[] = vec2[]( vec2(0.65,0.7), vec2(-0.65, 0.5), vec2(-0.75, -0.4));\n    float vstrength[] = float[]( 0.958, 0.675, 0.875 );\n    float waveMod = 1.0 + (0.5*sin(iTime*0.437)+0.5)*2.0;\n    for (int i=0; i<3; i++) {\n        const int N = 8;\n        for (int j=0; j<N; j++) {\n            vec2 dir = uv - vpos[i];\n            float rd = length(dir);\n            float duration = vstrength[i]*2.0;\n            float rr = mod((iTime+duration)*0.25, duration);\n            float ff = duration - rr;\n            float fd = vstrength[i] * 0.5;\n            float wave = waveMod*0.025 + float(j)*0.001;\n            float waved = 0.075+0.0025*float(j);\n            uv = uv - smoothstep(wave, 0.0, abs(rd-max(rr-waved*float(N-j),0.0))) * normalize(dir)*fd*ff/float(1+N);\n        }\n    }\n    \n    \n    float d = 0.0;\n    d = circle(uv, 0.6);\n    d = substract(d, circle(uv, 0.55));\n    d = merge(d, flower(uv, 0.5, 5.0));\n    d = substract(d, circle(uv, 0.075));\n    for (int i=0; i<5; i++) {\n        vec2 st = uv;\n        c = cos(float(i)*3.15159*2.0/5.);\n        s = sin(float(i)*3.15159*2.0/5.);\n        st = mat2(c,-s,s,c) * st;\n        st -= vec2(0.25, 0.0);\n        d = substract(d, box(st,vec2(0.2,0.02)));\n        \n        st = uv;\n        c = cos((float(i)+0.5)*3.15159*2.0/5.);\n        s = sin((float(i)+0.5)*3.15159*2.0/5.);\n        st = mat2(c,-s,s,c) * st;\n        st -= vec2(0.05, 0.0);\n        d = substract(d, box(st,vec2(0.1,0.01)));\n    }\n    \n    d = merge(d, circle(uv, 0.05));\n    \n    \n    //vec3 col = vec3(1.0) * plot(d, 0.0);\n    vec3 col = vec3(1.0) * (1.0-smoothstep(0.0, 0.0+fwidth(d), d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 84], [87, 87, 119, 119, 148], [151, 151, 197, 197, 531], [533, 533, 578, 578, 1025], [1028, 1028, 1059, 1059, 1155], [1157, 1157, 1188, 1188, 1212], [1214, 1214, 1249, 1249, 1273], [1275, 1275, 1310, 1310, 1340], [1342, 1342, 1399, 1449, 3587]]}
{"id": "wlffDM", "name": "Fractal forest", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 13, "viewed": 155, "published": "Public", "date": "1596870075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat Scale;\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nfloat map(vec3 p){\n    vec3 q=p;\n\tfloat s = 2.5;\n\tfor(int i = 0; i < 10; i++) {\n        p=mod(p-1.,2.)-1.;\n\t\tfloat r2=1.1/pow(lpNorm(abs(p),2.+q.y*10.),1.75);\n    \tp*=r2;\n    \ts*=r2;\n        p.xy*=rot(.001);\n    }\n    Scale=log2(s*.0003);\n    return q.y>1.3?length(p)/s:abs(p.y)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(.7-iTime*.3,.5,-iTime*.3),\n  \t\tw=normalize(vec3(.2,0.3,-1)),\n  \t\tu=normalize(cross(w,vec3(0,1,0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n  \tfloat h=0.,d,i;\n \tfor(i=1.;i<100.;i++){\n    \tp=ro+rd*h;\n      \td=map(p);\n    \tif(d<0.001)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=23.*vec3(cos(Scale*.3+cos(p*.6))*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 93, 93, 155], [157, 157, 175, 175, 440], [442, 442, 499, 499, 898]]}
{"id": "WlffDn", "name": "Tubularity", "author": "Mipmap", "description": "Tweak #2 of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 12, "viewed": 412, "published": "Public API", "date": "1596420186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweak #2 of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. \n//\n// Function fcos() is a band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w); // filtered-approx\n }\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n        \n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    vec2 q = p;\n    p.x += iTime*0.2;\n    \n    \n    // base color pattern\n    vec3 col = getColor( 0.4*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.07*length(q);\n \n   fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffDn.jpg", "access": "shaders20k", "license": "mit", "functions": [[1173, 1944, 1965, 1965, 2059], [2061, 2061, 2090, 2090, 2598], [2600, 2600, 2656, 2675, 3018]]}
{"id": "WlffDS", "name": "Watermelon Boze", "author": "kaiware007", "description": "Watermelon Boze", "tags": ["raymarching", "summer"], "likes": 3, "viewed": 57, "published": "Public", "date": "1597566557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 10.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n\n#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n*/\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += gl * 0.00075;\n    //h += hash12(p.xz*10.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    surface boze = sdWatermelonBoze(b, vec3(1), 2.);\n    boze.dist = max(boze.dist, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    \n    result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdWatermelonBoze(b, vec3(1), 2.);\n    boze.dist = max(boze.dist, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    \n    result = opU(result, boze);\n    \n    return result;\n}\n\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapNormal(position+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 5.) * 0.1 + 0.5;\n    float y = 0.25;\n    float r = 1.5 + sin(t * 2.5);\n    //float r = 1.;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n    //float theta = 0.;\n    //float theta = M_PI - RAD90*0.25;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    //float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    //float phi   = (mouseUV.y) * RAD90;\n    //float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0., 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[945, 1194, 1217, 1217, 1290], [1334, 1830, 1872, 1872, 2013], [2684, 2684, 2741, 2741, 3135], [3739, 3815, 3837, 3837, 4168], [4171, 4359, 4382, 4382, 4467], [4469, 4488, 4510, 4510, 4627], [4629, 4648, 4671, 4671, 4774], [4776, 4796, 4817, 4817, 4951], [4953, 4972, 4994, 4994, 5127], [5129, 5149, 5171, 5171, 5296], [5298, 5298, 5335, 5400, 5841], [5843, 5843, 5864, 5864, 5934], [5936, 5936, 5959, 5959, 6038], [6041, 6041, 6063, 6063, 6480], [6591, 6591, 6612, 6612, 6753], [6755, 6755, 6785, 6785, 6915], [6917, 6917, 6978, 6978, 7116], [7118, 7118, 7144, 7144, 7453], [7455, 7515, 7541, 7541, 8407], [8409, 8489, 8530, 8530, 8701], [8703, 8803, 8839, 8839, 8867], [8869, 8869, 8915, 8915, 8971], [8973, 8973, 9004, 9004, 9095], [9097, 9097, 9147, 9147, 9265], [9267, 9267, 9328, 9328, 9459], [9461, 9461, 9498, 9498, 9587], [9589, 9589, 9659, 9659, 9793], [9795, 9795, 9859, 9859, 9976], [9978, 9978, 10030, 10030, 10137], [10139, 10139, 10172, 10198, 10229], [10231, 10231, 10256, 10256, 10275], [10276, 10276, 10301, 10301, 10320], [10321, 10321, 10357, 10357, 10385], [10387, 10387, 10446, 10446, 10759], [10761, 10761, 10794, 10794, 10859], [10861, 10885, 10937, 10937, 11056], [11058, 11168, 11200, 11200, 11294], [11296, 11296, 11330, 11330, 11481], [11483, 11483, 11517, 11517, 11665], [11667, 11667, 11701, 11701, 11836], [11838, 11838, 11866, 11866, 11951], [11952, 12010, 12081, 12081, 12409], [12411, 12411, 12493, 12493, 12861], [12863, 12948, 12992, 12992, 13216], [13218, 13275, 13312, 13353, 13436], [13438, 13438, 13477, 13649, 13758], [13760, 13760, 13809, 13809, 14368], [14370, 14370, 14409, 14455, 14540], [14542, 14542, 14583, 14693, 14807], [14822, 14873, 14910, 14910, 14932], [14934, 14934, 14977, 14977, 14999], [15001, 15001, 15045, 15045, 15066], [15068, 15068, 15111, 15111, 15210], [15213, 15213, 15258, 15258, 15687], [15689, 15689, 15710, 15710, 15774], [15776, 15776, 15816, 15816, 15941], [15944, 15944, 15979, 15979, 16127], [16129, 16129, 16163, 16163, 16339], [16341, 16341, 16376, 16376, 16411], [16413, 16413, 16450, 16450, 16485], [16487, 16658, 16743, 16743, 16820], [16822, 16865, 16940, 16940, 17359], [17361, 17939, 18023, 18023, 18366], [18368, 18374, 18426, 18426, 18582], [18584, 18584, 18644, 18644, 18685], [18687, 18902, 18933, 18933, 18982], [18984, 18984, 19011, 19011, 19049], [19051, 19051, 19080, 19080, 19118], [19120, 19120, 19147, 19147, 19196], [19199, 19428, 19449, 19449, 19588], [19614, 19614, 19646, 19646, 19759], [19761, 19761, 19793, 19793, 19933], [19935, 19935, 19968, 19968, 20200], [20202, 20202, 20225, 20225, 20804], [20806, 20806, 20831, 20831, 20992], [20994, 20994, 21037, 21037, 22050], [22958, 27273, 27326, 27373, 29299], [29300, 29518, 29539, 29539, 30709], [30711, 30711, 30736, 30736, 32086], [33480, 33480, 33529, 33529, 33827], [33830, 35746, 35772, 35772, 37828], [37833, 38004, 38025, 38025, 38073], [38075, 38075, 38136, 38221, 38420], [38422, 38422, 38495, 38587, 38787], [38789, 38789, 38831, 38911, 38965], [38967, 38967, 39016, 39016, 39064], [39066, 39066, 39139, 39196, 39411], [39413, 39413, 39433, 39433, 39458], [39461, 39645, 39695, 39779, 40137], [40139, 40139, 40194, 40251, 40511], [40513, 40513, 40609, 40609, 42004], [42006, 42208, 42241, 42297, 42483], [42485, 42485, 42524, 42524, 42567], [42569, 45061, 45140, 45140, 47555], [47557, 47557, 47597, 47597, 49791], [49792, 50376, 50418, 50418, 50596], [50599, 50599, 50656, 50656, 52507]]}
{"id": "wlffRM", "name": "v3Eyes.glsl", "author": "jorge2017a1", "description": " keijiro /ShaderSketches \nhttps://github.com/keijiro/ShaderSketches/blob/master/Fragment/Discs2.glsl", "tags": ["v3eyesglsl"], "likes": 3, "viewed": 53, "published": "Public", "date": "1596314772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float eyes(vec2 coord)\n{\n    float div = 8.0 - cos(iTime * 0.3) * 7.0;\n    float sc = iResolution.y / div;\n    vec2 p = (coord - iResolution.xy / 2.0) / sc;\n\n    // circles\n    float l = length(fract(p - 0.5) - 0.5);\n    float rep = sin(dot(floor(p - 0.5), vec2(9.1, 7.9)) + iTime) * 5.0+ 8.0;\n    float c = (abs(0.5 - fract(l * rep + 0.5)) - 0.25) * sc / rep;\n\n    // grid lines\n    vec2 gr = (abs(0.5 - fract(p)) - 0.05) * sc;\n\n    return min(min(c, gr.x), gr.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(eyes(fragCoord.xy));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 467], [469, 469, 526, 526, 570]]}
{"id": "wlffW2", "name": "Animated Circle Robin", "author": "9robin3", "description": "Animated Circle Robin", "tags": ["animatedcricle"], "likes": 1, "viewed": 100, "published": "Public", "date": "1597746368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    float radius = 0.3;\n\n    //For something that goes from low to high, use multiply on UVs to set start size:\n    float radialGradient = length(uv) * 5.;\n\n    //For something that goes from high to low, use division on UVs to set start size: \n    //float radialGradient = length(uv) / 5.;\n\n    //Set the time of the animation / transition\n    //float animTime = iTime * 2.;\n\n    //Use this to make the circle stop growing, and repeat, loop after it reached\n    //its max threshold value (fract is the one that handles the stop and loop):\n    float animTime = pow(fract(iTime * .7), 1.);\n    \n    //Smoothstep to change whats visible of the circle over input (parameter 3), \n    //In this case input is radialGradient\n\n    //This code makes the circle go from small to big, min = max and vice versa!\n    float myCircle = smoothstep(0.5 + animTime, 0.02 + animTime, radialGradient);\n\n    //This code makes the circle go from big to small, min = min and vice versa!\n    //float myCircle = smoothstep(0.5 - animTime, 0.02 - animTime, radialGradient);\n\n     \n    vec3 col = vec3(0.0,1.0,0.0);\n    vec3 circleCol =  myCircle * col;\n   \n    // Output to screen\n    fragColor = vec4(circleCol,myCircle);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1407]]}
{"id": "WlffWB", "name": "Balls of various materials", "author": "kaneta", "description": "Lighting test\nMouse: Control camera", "tags": ["3d", "pbr"], "likes": 17, "viewed": 497, "published": "Public API", "date": "1597566984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAT_FLOOR 0.0\n#define MAT_SPHERE 1.0\n\nconst float pi = acos(-1.);\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 plane = vec2(p.y + 1.0, MAT_FLOOR);\n    p -=  vec3(0.0, -0.5, 0.0);\n    vec3 l = vec3(5.0, 0.0, 5.0);\n    vec3 q = p-clamp(round(p),-l,l);\n    vec2 d = vec2(length(q) - 0.49, MAT_SPHERE);\n    return opU(d, plane);\n}\n\nvec3 normal( vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*(map( pos + e.xyy ).x) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k)\n{\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickWithRoughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 skyColor(vec3 rd, float roughness)\n{\n    vec3 baseColor = mix(vec3(0.3,0.5,0.8)*0.8, vec3(0.3,0.5,0.8) * 0.5, rd.y);\n    baseColor = mix( baseColor, vec3(0.2,0.5,0.85)*0.5, 1.0 - pow(1.0-max(-rd.y,0.0), 1.5));\n    vec3 skyColor = baseColor;\n    skyColor = mix( skyColor, vec3(0.9,1.1,1.2) * 1.5, pow( 1.0-max(rd.y,0.0), 8.0 ) );\n    skyColor = mix( skyColor, vec3(0.2,0.5,0.85)*0.2, 1.0 - pow(1.0-max(-rd.y,0.0), 6.0));\n    \n    return mix(skyColor, baseColor, pow(roughness, 0.1)) * 10.0;\n}\n\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.01;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 128; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 ambientLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float aoRange)\n{\n    vec3 diffuseIrradiance = skyColor(N, 1.0);\n    vec3 diffuseAmbient = diffuseIrradiance * albedo * (1.0 - metalness);\n\n    vec3 R = reflect(-V, N);\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlickWithRoughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 specularIrradiance = skyColor(R, roughness);\n    vec3 specularAmbient = specularIrradiance * F;\n\n    float ambientOcclusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tambientOcclusion = min(exp2( -.8 * pow(ambientOcclusion, 2.0) ), 1.0) * min(1.0, 1.0+0.5*N.y);\n    diffuseAmbient *= ambientOcclusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), ambientOcclusion, roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nvec3 directLighting(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 lightColor)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n    float HdotL = max(0.0, dot(H, L));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick(F0, HdotL);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n    vec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\t\n\tfloat shadow = shadow(pos + N * 0.01, L);\n    vec3 irradiance = lightColor * NdotL * shadow;\n\n\treturn (diffuseBRDF + specularBRDF) * irradiance;\n}\n\n\nvec3 sunDir = normalize(vec3(.3, .45, .5));\n\n#define repid(p, r) (floor((p + r*.5) / r))\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 sky = skyColor(ray, 0.0);\n    vec3 albedo = vec3(1.0, 0.5, 0.1), emissive = vec3(0.0);\n    \n    vec2 id = repid(p.xz, vec2(1.0, 1.0)) / 10.0 + 0.5;\n    float metalness = 1.0 - max(id.y, 0.0);\n    float roughness = max(1.0 - id.x, 0.05);\n    albedo *= mix(0.4, 1.0, metalness);\n    \n    if (depth > 200.0) {\n        return sky;\n    } else if (mat.y == MAT_FLOOR) {\n        float checker = mod(floor(p.x) + floor(p.z), 2.0);\n        albedo = vec3(0.4) * checker + 0.05;\n        roughness = (0.2 + (1.0 - checker) * 0.45);\n        metalness = 0.0;\n    }\n    vec3 n = normal(p, 0.005);\n    \n    col += directLighting(p, albedo, metalness, roughness, n, -ray, normalize(sunDir), vec3(1.0, 0.98, 0.95) * 100.);\n    col += ambientLighting(p, albedo, metalness, roughness, n, -ray, depth / 30.0);\n    col += emissive;\n    \n    float fo = exp(-0.006*depth);\n    col = mix( sky, col, fo );\n\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.1;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 128; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x < 0.001) {\n        \tbreak;\n        }\n        t += abs(mat.x);\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    float time2 = iTime * 3.0;\n    vec3 ro = vec3(cos(time2*0.1) * 15.0, 15.75 * iMouse.y / iResolution.y, sin(time2*0.1) * 15.0);\n    vec3 ta = vec3(0.0, -1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.0 + 8.5 * iMouse.x / iResolution.x));\n    return trace(ro, ray);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 3; y++) {\n        for(int x = 0; x < 3; x++) {\n            vec2 off = vec2(float(x),float(y))/3.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \t//col += reinhard(render(xy), .12, 100.0)/9.;\n            col += acesFilm(render(xy) * .065)/9.;\n        }\n    }\n    \n    //col = render(p) * 0.1;\n    \n    //col = reinhard(col, .3, 100.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    vec2 p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 30.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 103, 103, 136], [138, 138, 156, 156, 381], [383, 383, 419, 419, 629], [631, 631, 675, 675, 846], [848, 848, 892, 892, 941], [943, 943, 1006, 1006, 1117], [1119, 1119, 1165, 1165, 1222], [1224, 1224, 1300, 1300, 1384], [1386, 1386, 1427, 1427, 1882], [1884, 1884, 1932, 1932, 2019], [2021, 2021, 2057, 2057, 2390], [2392, 2392, 2502, 2502, 3233], [3235, 3235, 3354, 3354, 4019], [4112, 4112, 4171, 4171, 5105], [5107, 5107, 5137, 5137, 5401], [5403, 5403, 5445, 5445, 5623], [5625, 5625, 5652, 5652, 5711], [5713, 5713, 5742, 5742, 5946], [5948, 5948, 6002, 6002, 6144], [6146, 6146, 6167, 6167, 6473], [6475, 6475, 6532, 6622, 7310]]}
{"id": "wlffWn", "name": "FieldFX 25/07 MS", "author": "MonsieurSoleil", "description": "Finals.", "tags": ["raymarchingreflection"], "likes": 10, "viewed": 191, "published": "Public", "date": "1596445226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n\n#define time iTime/60.0*140.0\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 0.5, 8.0))\n#define mod03 floor(mod(time * 0.5, 4.0))\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n};\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) -s;\n  return max(p.x, max(p.y,p.z));\n}\n\n\n\nfloat opSmooth(float a, float b, float k)\n{\n  float h = clamp(0.5 - 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) + k*h*(1.0-h);\n}\n\nvec3 opRepLim(vec3 p, vec3 c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c), -l, l);\n  return q;\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  float mat01, mat02, mat03;\n  \n  vec3 p01 = p, p02 = p, p03 = p;\n  \n  \n  p03 = opRepLim(p03, vec3(1.55), vec3(55.0));\n  \n  p01.xy *= rot(sin(time * 0.1))* 0.5; \n  p01.zy *= rot(sin(time * 0.1))* 1.3; \n  \n  mat01 = -box(p01, vec3(5.0, 5.0, 5.0));\n  \n  p03.xy *= rot(sin(time * 2.0)) * 0.5;\n   p03.zy *= rot(sin(time * 2.0)) * 0.5;\n  mat01 = max(mat01, -box(p03, vec3(0.05 + abs(sin(mod01)) * 0.05 )));\n  \n  if(mat01 < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  if(mat.reflected)\n  {\n    p02.xy *= rot(sin(mod01));\n    \n    mat02 = box(p02, vec3(0.5));\n    mat02 = min(mat02, box(p02 + vec3(cos(time) * 1.0, sin(time) * 2.0, 0.0), vec3(0.4)));\n    mat02 = min(mat02, box(p02 + vec3(cos(time * .5) * 0.4, sin(time) * 2.0, 0.0), vec3(0.6)));\n\n  mat02 = min(mat02, box(p02 + vec3(cos(mod02) * 0.8, sin(mod02) * 5.0, 0.0), vec3(1.2 * mod03)));\n    \n    gg += 0.15/(0.05+abs(mat02));\n  }\n  \n  \n  mat.m = mat01;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n  map(m02, p - uv.xyy);\n  map(m03, p - uv.yxy);\n  map(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 o = vec3(0.0, 2.0 * fract(time * 0.2), 4.0 * sin(time * 0.2)), t = vec3(1.0, 2.0, 0.0);\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  \n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = dir * 0.5 + o;\n  \n  vec3 col = vec3(0.0);\n  matter mat;\n  float dd = 0.0;\n  \n  for(int i = 0; i < 150 ;++i)\n  {\n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      if(mat.type == 1)\n      {\n        vec3 n = normals(p);\n        dir = reflect(dir, -n);\n        \n        mat.m = 0.5;\n        mat.reflected = true;\n      }\n      \n      mat.m = 0.5;\n    }\n    \n    col += gg * 0.00125 * mix(vec3(0.0,0.8, 1.0), vec3(1.0, 0.2, 0.0), sin(mod03));\n    \n    p += mat.m * dir * 0.85;\n    dd += mat.m * 0.85;\n  }\n  \n  float fog = clamp(dd/100.0, 0.0, 1.0);\n  vec3 sky = mix(vec3(0.3), vec3(0.1), uv.y);\n  col -= fog * sky;\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 344, 363, 363, 442], [505, 505, 532, 532, 584], [588, 588, 631, 631, 718], [720, 720, 759, 759, 814], [816, 816, 852, 852, 1753], [1755, 1755, 1777, 1777, 1988], [1990, 1990, 2047, 2047, 3086]]}
{"id": "WlffWX", "name": "Orange Chaos", "author": "MysteryPancake", "description": "Modification of code made by https://github.com/cxleb", "tags": ["fractal", "chaos"], "likes": 0, "viewed": 182, "published": "Public API", "date": "1597836988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float firstp = 0.1;\nint iterations = 10;\n\nfloat f(float x, float y, float t, float p) {\n\treturn cos( x * (x + t) / (y + p) + t );\n}\n\nfloat iterate(float x, float y, float t) {\n\tfloat p = firstp;\n\tfor (int i = 0; i < iterations; i++) {\n\t\tp = f(x, y, t, p);\n\t}\n\treturn p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat height = sin(iTime) * 0.5 + 1.5;\n\tvec2 uv = (fragCoord/iResolution.xy)*height;\n\tfloat p = iterate(uv.x-height, uv.y-height, cos(iTime));\n\tfragColor = vec4(1.0-p,0.0-p,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 87, 87, 131], [133, 133, 175, 175, 271], [273, 273, 328, 328, 514]]}
{"id": "WlffzB", "name": "P.Gerdes & Tchokwe sand drawing3", "author": "FabriceNeyret2", "description": "decorated strip variant of [url]https://shadertoy.com/view/wtsfWM[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 11, "viewed": 196, "published": "Public API", "date": "1596991390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// decorated strip variant of https://shadertoy.com/view/wtsfWM\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) cos(6.28*v/.09)                         // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f;        // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99.,                    // edge id (float)\n          r = fract(4e4*sin(i));                     // rand(id)\n    O -= r < .5\n        ? f = abs( abs(F) - .353 ),\n          F = S( f -.1 ) * s(f),                     //  X at edge\n          F.x + F.y \n          - ( F.yx * S(f-.1) ) [int(4.*r)]           //   random crossing order\n        :(                           \n          r = abs( length(F) - .353 ),               // )( at edge\n          S( r -.1 ) * s(r) );\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlffzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 201, 239, 239, 1197]]}
{"id": "wlffzM", "name": "Wobbletunnel", "author": "tyron", "description": "Played around a bit with iqs shader", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 9, "viewed": 129, "published": "Public", "date": "1596299630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Forked from https://www.shadertoy.com/view/wtXfRH\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(6.28,0.0,w);\n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.09*fcos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.08*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.07*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.06*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.06*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.09*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n   \t\n    float w = 1.0 + 3.0*abs(2.0 - length(fragCoord.xy / iResolution.xy));\n    p.x += (cos(iTime * 0.91) + cos(iTime * 0.24)) / 10.0 * w;\n    p.y += (sin(iTime * 0.751) + sin(iTime * 0.42)) / 10.0 * w;\n    \n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    vec2 q = p;\n\n    float b = (length(fragCoord.xy) - 0.5) * iTime/ 1.0;\n\n    // deform 2\n    p += 0.1*cos( (1.5*p.yx + 0.03*1.0*iTime + vec2(0.1,1.1))  );\n\tp += 0.05*cos( (2.4*p.yx + 0.03*1.6*iTime + vec2(4.5,2.6))  );\n\tp += 0.04*cos( (3.3*p.yx + 0.03*1.2*iTime + vec2(3.2,3.4))  );\n\tp += 0.03*cos( (4.2*p.yx + 0.03*1.7*iTime + vec2(1.8,5.2))  );\n\tp += 0.06*cos( (9.1*p.yx + 0.03*1.1*iTime + vec2(6.3,3.9)) );\n\n    // base color pattern\n    vec3 col = getColor( 0.5*length(p) + iTime*0.6 );\n    \n    // lighting\n    col *= 1.4 - 0.07*length(q);\n\n \n   fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[1132, 1919, 1940, 1940, 2010], [2012, 2012, 2041, 2041, 2606], [2608, 2608, 2664, 2683, 3592]]}
{"id": "wlffzs", "name": "Raymarched Sierpenski Pyramid", "author": "IAmLegend", "description": "A raymarched sierpenski pyramid with diffuse + specular lighting and hard shadows. No ambient occlusion >w<", "tags": ["sierpenskipyramidraymarched"], "likes": 1, "viewed": 80, "published": "Public", "date": "1597632657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.14;\nfloat EPSILON = 0.001;\n\n// Map values to unsquish resolution\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// rotation matrix around origin\nvec3 rotate(vec3 p, vec3 r){\n    // d --> r\n    r.x *= PI/180.0;\n    r.y *= PI/180.0;\n    r.z *= PI/180.0;\n    mat3 xRot = mat3 (1,0,0,\n                      0,cos(r.x),-sin(r.x),\n                      0,sin(r.x), cos(r.x));\n    mat3 yRot = mat3 (cos(r.y),0,sin(r.y),\n                      0,1,0,\n                      -sin(r.y),0,cos(r.y));\n    mat3 zRot = mat3 (cos(r.z),-sin(r.z),0,\n                      sin(r.z),cos(r.z),0,\n                      0,0,1);\n    return xRot * yRot * zRot * p;\n}\n// DE from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat pyramidDE(vec3 p){\n    float scale = 1.75;\n    float offset = 2.5;\n    for (int n = 0; n < 16; ++n) {\n        if(p.x + p.y < 0.0){ \n            p.xy = - p.yx;\n        } \n        if(p.x + p.z < 0.0){ \n            p.xz = - p.zx;\n        } \n        if(p.y + p.z < 0.0){ \n            p.zy = - p.yz;\n        } \n        p = p * scale - offset*(scale - 1.0);\n    }\n\n    return length(p) * pow(scale, - 16.0);\n}\n// Derivative of the fractal\nvec3 approxNormal(vec3 p)\n{\n    return normalize(vec3(\n        pyramidDE(p + vec3(EPSILON, 0, 0)) - pyramidDE(p - vec3(EPSILON, 0, 0)),\n        pyramidDE(p + vec3(0, EPSILON, 0)) - pyramidDE(p - vec3(0, EPSILON, 0)),\n        pyramidDE(p + vec3(0, 0, EPSILON)) - pyramidDE(p - vec3(0, 0, EPSILON))));\n}\n// shadows raymarch towards the light from the intersection and see if theres collision cool :o\nfloat hardshadow (vec3 origin, vec3 direction, float smoothness, float time){\n    float distance = EPSILON;\n    for (float iters = 0.0; iters < 200.0; ++iters){\n        vec3 pos = origin + distance * direction;\n        vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));\n        float nextDistance = pyramidDE(rPos);\n        distance += nextDistance;\n        if (abs(nextDistance) < EPSILON){\n            return distance * .5;\n        }\n    }\n    return 1.0;\n}\nvec3 raymarch(vec3 origin, vec3 direction, vec3 light, float time){\n    float distance = 0.0;\n    for (float iters = 0.0; iters < 200.0; ++iters){\n        vec3 pos = origin + distance * direction;\n        vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));\n        float nextDistance = pyramidDE(rPos);\n        distance += nextDistance;\n        if (abs(nextDistance) < EPSILON){ \n            vec3 normal = approxNormal(pos);\n            // Take dot product of normal and light vectors for diffuse\n            // Don't forget to clamp the min at 0\n            float diffuse = max(0.0, dot(normal, light)); \n            vec3 reflected = reflect(direction, normal);\n            // Phong exponent 16 for a nice look\n            float specular = pow(max(dot(reflected, light), 0.0), 16.0); \n            float shade = diffuse * 0.7 + specular * 0.3; \n            vec3 ambient = vec3(1.0, 1.0, 1.0);\n            return shade * ambient * hardshadow(pos, light, .2, time);\n        }\n        if (distance > 100.0){\n            break;\n        }\n    }\n    // Background blue\n    return vec3(0.0, 0.0, 0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // window relative -> clip space\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x = map(uv.x, -1.0, 1.0, -512.0/288.0, 512.0/288.0);\n    \n    vec3 center = vec3(0.3, -0.3, 0.0);\n    float time = iTime;\n    // directional light\n    vec3 light = normalize(vec3(-1.0, 0.8, -1.0)); \n    fragColor = vec4(raymarch(vec3(0.0, 0.0, -6.0), normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0)), light, time), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 78, 150, 150, 218], [219, 252, 280, 295, 747], [748, 855, 879, 879, 1264], [1265, 1294, 1321, 1321, 1595], [1596, 1692, 1769, 1769, 2174], [2175, 2175, 2242, 2242, 3293], [3294, 3294, 3350, 3387, 3773]]}
{"id": "WljBDh", "name": "3D Randomness", "author": "milesWaugh", "description": "I will use this in the future to create perlin noise. ", "tags": ["3d", "random"], "likes": 2, "viewed": 100, "published": "Public", "date": "1598832106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec3 pos){\n    return fract(sin(dot(pos, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(random(vec3(uv.x,uv.y,iTime)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljBDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 116], [118, 118, 175, 175, 302]]}
{"id": "wljBz1", "name": "the white temple", "author": "danhel95", "description": "following iq tutorial , using minimal stuffs of everything to learn :) ", "tags": ["simple", "sdf", "tutorial", "temple"], "likes": 8, "viewed": 108, "published": "Public", "date": "1598357907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// learning tutorial 2\n// thanx iq & bigWigns and others!\n// minimal temple and lightings\n\n#define ITR 50\n#define EPSILON 0.001\n#define MAX_DIST 50.0\n#define SURF_DIST 0.01\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//-----------------------------------------------------------------------------\nvec3 sun, sun_col;\n\nvec3 normal;\n\n//------------------------------------------------------\n\nvec2 opRepLim(in vec2 p, in float s, in vec2 lima, in vec2 limb)\n{\n    return p - s*clamp(round(p / s), lima, limb);\n}\n\n\nmat3 RX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), - sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 RY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        - sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 RZ(float a) {\n    return mat3(\n        cos(a), - sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n\n\nfloat smax(float a , float b, float k) {\n\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    float s = mix(a, b, h) + h*(1.0 - h) * k*0.5 ;\n    return s;\n\n}\n\n//-----------------------------------------------------------------------------\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat cyl(vec3 p, float r) {\n    vec3 q = p;\n\n    r -= 0.05 * q.y;\n    r -= 0.05 * pow((0.5 + 0.5 * sin(12.0 * atan(q.x, q.z))), 2.0);\n    r -= 0.1 * pow((0.5 + 0.5 * sin(2.5 * sin(3.5 * q.y))), 0.15) - 0.1;\n\n    float d = length(q.xz) - r ;\n    d = max(d, abs(q.y - .1) - 4. );\n    //d = max(d, -q.y );\n    d *= 0.7;\n    return d;\n\n}\n\n//---------------------------------------------------------------------------------\nfloat scene(vec3 p) {\n    vec3 q = p - vec3(-10.0, 1.0, -4.);\n    vec3 s = vec3(q);\n    //q.xz = mod(q.xz + 1.0 , 2.0) - 1.0;\n\n    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));\n    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);\n    float d = plane(p, vec3(0.0, 1.0, 0.0), 0.1);\n    d = min(d, cyl(q, 0.4));\n    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));\n    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));\n\n    vec3 f = s - vec3(0.0, - 0.1, 0.0);\n    f.y = abs(f.y- 2.)-2.2;\n    vec3 sz = vec3(0.95, 0.01, 0.95);\n    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));\n    d = min(d, box(f, sz - 0.1) - 0.2);\n\n    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);\n    vec3 gsz = vec3(1.5, 0.2, 1.5);\n    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));\n    d = min(d, box(g, gsz - 0.2) - 0.2);\n\n    return d ;\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 raydir(vec2 uv, vec3 ro, vec3 lookat, float zoom) {\n    vec3 forward = normalize(lookat - ro);\n    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = normalize(cross(forward, temp));\n    vec3 right = cross(up, forward);\n    vec3 screen_center = ro + forward * zoom;\n    vec3 i = screen_center + uv.x * right + uv.y * up;\n    vec3 rd = i-ro;\n    return rd;\n\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < ITR && t < MAX_DIST; ++i)\n    {\n        float dS = scene(ro + t*rd);\n        if (abs(dS) < SURF_DIST )break;\n        t += dS;\n    }\n        return  t ;\n    }\n\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p + e.xyy), scene(p + e.yxy), scene(p + e.yyx)) - scene(p)) / e.x;\n}\n\n//------------------------------------------------\n\n\n\n\nvoid luminance(inout vec3 col, float lum)\n{\n\tlum /= \tdot(col.rgb,vec3(0.2126 , 0.7152  ,0.0722) );\n\tcol *= lum;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd, vec3 l_pos)\n{\n    float res = 1.;\n    float d = march(ro+100.*normal*SURF_DIST, rd);\n    vec3 p = ro + d*rd;\n    float dl = length(l_pos - p );\n    if (d < dl)\n        res = 0.;\n    float r = 10.;\n \tres = clamp((res*d*(d - dl)/(d + dl) + r) / (2. * r), 0., 1.);\n\tres = smoothstep(0., .8, res);\n\n    return res;\n}\n\n\nvec3 light(vec3 p, vec3 l_pos, vec3 color, bool nrf) {\n    vec3 ptol = l_pos - p;\n    vec3 ptol_n = normalize(ptol);\n    float d = length(ptol);\n    float difuse = max(dot(ptol_n, normal), 0.1);\n    vec3 difuse_col = pow(difuse/(d*d) , .5) * color;\n    float shadow = shadow(p, ptol_n, l_pos);\n    vec3 col = difuse_col  ;\n    if (nrf) col *= shadow;\n\n\n    return   col;\n\n\n\n}\n\n\nvec3 reflection(vec3 p, vec3 rd ) {\n\n    vec3 reflectDir = normalize(reflect(rd, normal));\n    vec3 o = p + reflectDir * SURF_DIST *10.;\n    float t = march( o , reflectDir);\n    vec3 pt = o + t*reflectDir;\n    vec3 reflected = light(pt,sun, vec3(1.,.0,.0),false ) ;\n\n    return reflected;\n\n}\n\n\n\nvec3 render(vec3 ro , vec3 rd) {\n\n    float t = march( ro , rd);\n    vec3 p = ro + t*rd;\n    normal = normalize(grad(p));\n    luminance(sun_col,3.);\n    vec3 specul = light(p, sun, sun_col,true);\n    specul += light(p, sun-vec3(1.,3.,-2.), sun_col*.5,true);\n    vec3 reflected = reflection(p,rd);\n\n    vec3 col = vec3(.0);\n    float spec = pow( max( normal.y, normal.z ), 2.);\n    col = mix((reflected), vec3(specul), .6 ) + spec*.3 ;\n    col += mix(col ,reflected, .8 );\n\n    return col ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n\n   sun = vec3(5., 8. + m.y + sin(iTime * 0.3 * TWO_PI ) * 3.0, 5.0);\n   sun_col = vec3(1.0, .6, 0.2) * 10.0;\n\n    vec3 col = vec3(0);\n    float t = iTime;\n    float ang = sin(0.2 * t*PI + TWO_PI*m.x) * .5;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    vec3 ro = vec3(-10.0, 10.0, 15.0) + camR;\n    ro *= RX(-m.x*PI/4. + 0.4);\n    ro *= RY(- m.y * 6.2831);\n    vec3 lookat = vec3(0.0);\n    float zoom = 1.;\n    vec3 rd = raydir(uv, ro, lookat, zoom);\n\n    col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545)); // gamma correction\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 400, 466, 466, 518], [521, 521, 539, 539, 647], [649, 649, 667, 667, 775], [777, 777, 795, 795, 903], [907, 907, 947, 947, 1066], [1068, 1149, 1187, 1187, 1215], [1217, 1217, 1244, 1244, 1339], [1342, 1342, 1370, 1370, 1676], [1678, 1762, 1783, 1783, 2609], [2611, 2692, 2748, 2748, 3067], [3069, 3069, 3100, 3100, 3300], [3303, 3303, 3322, 3322, 3447], [3449, 3504, 3547, 3547, 3617], [3620, 3620, 3664, 3664, 3963], [3966, 3966, 4020, 4020, 4341], [4344, 4344, 4379, 4379, 4636], [4640, 4640, 4672, 4672, 5131], [5133, 5133, 5188, 5188, 5881]]}
{"id": "wljfRw", "name": "Ray-marching Tutorial", "author": "tomon9086", "description": "atomic reaction??", "tags": ["practice"], "likes": 1, "viewed": 56, "published": "Public", "date": "1598569093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.0001\n\nvec3 camera(vec2 pos, vec3 cameraPos) {\n  vec3 sensor = vec3(pos, cameraPos.z - 1.);\n  return normalize(sensor - cameraPos);\n}\n\nfloat sphere(vec3 rayPos, vec3 spherePos, float r) {\n  return length(rayPos - spherePos) - r;\n}\n\nvec3 getSphereNorm(vec3 rayPos, vec3 spherePos) {\n  return normalize(rayPos - spherePos);\n}\n\nfloat sdf(vec3 rayPos) {\n  return min(\n    sphere(rayPos, vec3(cos(iTime), sin(iTime), tan(iTime)), 2.),\n    min(\n      sphere(rayPos, vec3(sin(iTime) + 2.*sin(iTime), sin(iTime), tan(iTime - 1.)), 2.),\n      min(\n        sphere(rayPos, vec3(2.*cos(iTime), sin(iTime), tan(iTime + 1.)), 2.),\n        sphere(rayPos, vec3(cos(iTime), 3.*cos(iTime), .5 * sin(sin(iTime) * 20.)), 2.)\n      )\n    )\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 cameraPos = vec3(0, 0, 10);\n  vec3 ray = camera(pos, cameraPos);\n  vec3 cur = cameraPos;\n\n  for(int i = 0; i < 16; i++) {\n    float d = sdf(cur);\n    if(d < EPS) {\n      fragColor = vec4(getSphereNorm(ray, cur), 1.) + vec4(.5, .5, .5, 0);\n      break;\n    }\n    cur += ray * d;\n    fragColor = vec4(0, 0, 0, 0);\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 59, 59, 146], [148, 148, 200, 200, 243], [245, 245, 294, 294, 336], [338, 338, 362, 362, 738], [740, 740, 795, 795, 1208]]}
{"id": "wljfzz", "name": "Space fungus 2", "author": "FabriceNeyret2", "description": "transparent variant of [url]https://shadertoy.com/view/lsSBWh[/url]", "tags": ["raymarching", "notgyroid"], "likes": 24, "viewed": 344, "published": "Public API", "date": "1598254526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// transparent variant of https://shadertoy.com/view/lsSBWh\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = .1*iTime, a,b, n=0.,s,N=0.;\n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );\n    vec3  q = iResolution,\n          D = normalize(vec3( U+U-q.xy, -q.y) +.1 ),\n          p = 15./q; \n\n    for ( O+=.5-O; n<2e2 ; n++ )\n        q = p,\n        q.xz *= R,\n        q.yz *= R,\n        t = max( length(q) - 9.,                         // Sphere\n                 abs(a=cos(b=3.*dot(sin(q),D/D)))/9. ),  // EggCarton\n        t < .01 ? s = 4.*max( 0., 1.-.2*N-.005*n ),\n                  O.r -= s* b/30., O.g -= s* a, \n                  t=.3, N++ : t, \n        p += t/3.*D;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 97, 97, 672]]}
{"id": "wllBDM", "name": "Old Monitor Scanlines", "author": "devrique", "description": "Simple screen scanlines, like some kind of retro monitor. I got the inspiration to do it playing Stay. WIP.\n\nI'm planning to add more to this effect, I'm new to shaders and already learning. Suggestions and constructive criticism is welcome! :)", "tags": ["scanlines", "tv", "scanline"], "likes": 1, "viewed": 168, "published": "Public", "date": "1596927069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: devrique.\n// Name: Old Monitor Scanlines.\n// Description: Screen scanlines, like some kind of retro monitor.\n//              I got the inspiration to do it playing Stay. :)\n\n// Set to 0.0 to stop animation.\n// Only integer numbers with float format, or else the animation cuts!\nfloat scanSpeedAdd = 6.0;\n\n// Change this value to change scanline size (> = smaller lines).\nfloat lineCut = 0.1;\n\n// Reduce 'anaglyphIntensity' value to reduce eye stress.\n// Adding this two values should result in 1.0.\nfloat whiteIntensity = 0.8;\nfloat anaglyphIntensity = 0.5;\n\n// Anaglyph colors.\nvec3 col_r = vec3(0.0, 1.0, 1.0);\nvec3 col_l = vec3(1.0, 0.0, 0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_right = vec2(uv.x + 0.01, uv.y + 0.01);\n    vec2 uv_left = vec2(uv.x - 0.01, uv.y - 0.01);\n\n    // Black screen.\n    vec3 col = vec3(0.0);\n    \n    // Measure speed.\n    float scanSpeed = (fract(iTime) * 2.5 / 40.0) * scanSpeedAdd;\n    \n    // Generate scanlines.\n    vec3 scanlines = vec3(1.0) * abs(cos((uv.y + scanSpeed) * 100.0)) - lineCut;\n    \n    // Generate anaglyph scanlines.\n    vec3 scanlines_right = col_r * abs(cos((uv_right.y + scanSpeed) * 100.0)) - lineCut;\n    vec3 scanlines_left = col_l * abs(cos((uv_left.y + scanSpeed) * 100.0)) - lineCut;\n    \n    // First try; a strange mess.\n    //vec3 scanlines = cos(cos(sqrt(uv.y)*tan(iTime / 10000.0) * 100.0 * 10.0) * vec3(1.0) * 100.0);\n    \n    col = smoothstep(0.1, 0.7, scanlines * whiteIntensity)\n        + smoothstep(0.1, 0.7, scanlines_right * anaglyphIntensity)\n        + smoothstep(0.1, 0.7, scanlines_left * anaglyphIntensity);\n    \n    // Deform test (WIP, thanks to 'ddoodm' for its Simple Fisheye Distortion!).\n    vec2 eyefishuv = (uv - 0.5) * 2.5;\n    float deform = (1.0 - eyefishuv.y*eyefishuv.y) * 0.02 * eyefishuv.x;\n    //deform = 0.0;\n    \n    // Add texture to visualize better the effect.\n    vec4 texture1 = texture(iChannel0, vec2(uv.x - deform*0.95, uv.y));\n    \n    // Add vignette effect.\n    float bottomRight = pow(uv.x, uv.y * 100.0);\n    float bottomLeft = pow(1.0 - uv.x, uv.y * 100.0);\n    float topRight = pow(uv.x, (1.0 - uv.y) * 100.0);\n    float topLeft = pow(uv.y, uv.x * 100.0);\n    \n    float screenForm = bottomRight\n        + bottomLeft\n        + topRight\n        + topLeft;\n\n    // Invert screenForm color.\n    vec3 col2 = 1.0-vec3(screenForm);\n    \n    // Output to screen.\n    // Invert last 0.1 and 1.0 positions for image processing.\n    fragColor = texture1 + vec4((smoothstep(0.1, 0.9, col) * 0.1), 1.0);\n    fragColor = vec4(fragColor.rgb * col2, fragColor.a);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[570, 660, 717, 768, 2698]]}
{"id": "WllBR8", "name": "darksea", "author": "hematthe", "description": "nightmare  nightmare nightmare", "tags": ["sea"], "likes": 4, "viewed": 99, "published": "Public", "date": "1597065656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nfloat valueNoiseSimple(vec2 vl) {\n   const vec2 helper = vec2(0., 1.);\n    vec2 interp = smoothstep(vec2(0.), vec2(1.), fract(vl));\n    vec2 grid = floor(vl);\n\n    float rez = mix(mix(rand(grid + helper.xx),\n                        rand(grid + helper.yx),\n                        interp.x),\n                    mix(rand(grid + helper.xy),\n                        rand(grid + helper.yy),\n                        interp.x),\n                    interp.y);\n    return rez;\n\n}\n\nconst mat2 unique_transform = mat2( 0.85, -0.65, 0.65, 0.85 );\n\n\nfloat fractalNoise(vec2 vl) {\n    \n    const float persistance = 3.0;\n    float frequency = 2.3;\n    const float freq_mul = 2.3;\n    float amplitude = .7;\n    \n    float rez = 0.0;\n    vec2 p = vl;\n   \n    float mainOfset = (iTime + 40.)/ 2.;\n    \n    vec2 waveDir = vec2(p.x+ mainOfset, p.y + mainOfset);\n    float firstFront = amplitude + \n\t\t\t        (valueNoiseSimple(p) * 2. - 1.);\n    \n    float mainwave =(.7 + (valueNoiseSimple(p) * 2. - 1.)) * valueNoiseSimple(p + (iTime + 40.)/ 2.);\n    \n    rez += mainwave;\n    amplitude /= persistance;\n    p *= unique_transform;\n    p *= frequency;\n    \n\n    float timeOffset = iTime / 4.;\n\n    \n    for (int i = 1; i < 8; i++) {\n        waveDir = p;\n        waveDir.x += timeOffset;\n        rez += amplitude * sin(valueNoiseSimple(waveDir * frequency) * .5 );\n        amplitude /= persistance;\n        p *= unique_transform;\n        frequency *= freq_mul;\n        timeOffset *= 1.025;\n        timeOffset *= -1.;\n    }\n\n    return rez;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = (O.y + 0.2 + sin(fractalNoise(vec2(O.x - 5., O.z )) / 6.5)) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -2.0)); //fov\n\n    float hill;\n\n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < 64; ++i) {\n        d = (O + D*L).y + 0.2 + sin(fractalNoise(vec2((O + D*L).x - 5., (O + D*L).z )) / 6.5);\n        \n        L += d;\n        \n        if (d < .0001*L)\n            break;\n    }\n    \n    hill = d;\n    \n    float path = L;\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n   \n    vec3 lightPos = vec3(20., 90. -h, -95. - timeOffset);\n    \n    \n    vec2 e = vec2(.0001, 0.);\n   float w = coord.y + 0.2 + sin(fractalNoise(vec2(coord.x - 5., coord.z )) / 6.5); \n   \n   vec3 normal =normalize(vec3(\n        (coord+e.xyy).y + 0.2 + sin(fractalNoise(vec2((coord+e.xyy).x - 5., (coord+e.xyy).z )) / 6.5)- w,\n       e.x,\n       ((coord+e.yyx).y + 0.2 + sin(fractalNoise(vec2((coord+e.yyx).x - 5., (coord+e.yyx).z )) / 6.5)) - w));\n    \n \n     \n     vec3 dir = lightPos - coord;\n    vec3 eyeDir = O - coord;\n    float dist = length(eyeDir);\n    float atten = pow(0.93, dist * 7. );\n    \n    \n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .28;\n\n   \trez+= max(0., (coord + dst * normal).y + 0.2 + sin(fractalNoise(vec2((coord + dst * normal).x - 5., (coord + dst * normal).z )) / 6.5));\n    \n    rez+= max(0., (coord + dst * rotXccw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotXccw).x - 5., (coord + dst * rotXccw).z )) / 6.5));\n             \n    rez+=  max(0., (coord + dst * rotXcw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotXcw).x - 5., (coord + dst * rotXcw).z )) / 6.5));\n            \n    rez+= max(0., (coord + dst * rotYccw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotYccw).x - 5., (coord + dst * rotYccw).z )) / 6.5));\n                    \n    rez+=  max(0., (coord + dst * rotYcw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotYcw).x - 5., (coord + dst * rotYcw).z )) / 6.5));\n               \n    rez+= max(0., (coord + dst * rotZccw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotZccw).x - 5., (coord + dst * rotZccw).z )) / 6.5));\n                                    \n    rez+=  max(0., (coord + dst * rotZcw).y + 0.2 + sin(fractalNoise(vec2((coord + dst * rotZcw).x - 5., (coord + dst * rotZcw).z )) / 6.5));\n               \n       \n\n    \n    \n        \n    resColor = vec3(((pow(min(rez, 1.), 4.5) - 0.13725) * 1.7) * atten);\n\n    fragColor = vec4(resColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 92], [96, 96, 129, 129, 567], [634, 634, 663, 663, 1618], [1623, 1623, 1680, 1680, 4695]]}
{"id": "wllBRX", "name": "Bezier Explicit vs. de Casteljau", "author": "fizzer", "description": "Comparing the numerical precision of explicit Bezier curve evaluation versus De Casteljau method. Bottom-left is the usual implementation with calculating of factorials resulting in precision loss. Others use either DeCasteljau or cached binomials.", "tags": ["bezier", "precision", "decasteljau", "factorial"], "likes": 10, "viewed": 273, "published": "Public", "date": "1597351059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Comparing the numerical precision of explicit Bezier curve evaluation versus de Casteljau method.\n//\n// Top-Left = Using cached binomial coefficients (explained below)\n// Top-Right = Cached binomial coefficients + efficient pow() evaluation\n// Bottom-Left = Calculating factorials and running out of precision\n// Bottom-Right = Paul de Casteljau's method: https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n\n// Wikipedia states that the de Casteljau method is \"a numerically stable method for evaluating the curves\".\n// This implies that the original formulation is not numerically stable. I think this is probably because\n// the calculated factorials for curves of degree > 12 start to grow larger than what a 32-bit integer\n// can hold, and larger than what is representable in a 32-bit float (24 bits of precision).\n//\n// However, these factorials are only calculated as part of the binomial coefficients which generally end up\n// being easily representable in 24 bits. The set of binomial coefficients for a Bezier curve of a given\n// degree is constant, so it can be pre-computed offline with a high precision and range.\n//\n// The result is that the original formulation of the Bezier curve evaluation is just as stable as\n// de Casteljau's method at the scales that I've tried. On top of that, de Casteljau's method\n// is very slow at high degrees O(n²) compared to the original formulation's O(n).\n//\n\n\n\n// Undefine this to use a more efficient way to compute the binomial coefficient.\n// This is yet another way that the supposed precision loss in the original Bezier formulation\n// can be avoided.\n#define USE_FACTORIAL\n\n// Degree of the Bezier curve\nconst int n = 13;\n\n// Pre-computed binomial coefficients\nconst int bin13[14] = int[14](1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1);\n\n// Control points\nvec2 control_points[n + 1];\n\n\nint factorial(int x)\n{\n\t// For values of n greater than around 12, the int datatype can't contain the result.\n    int y = 1;\n    while(x > 0)\n    {\n        y *= x;\n        x -= 1;\n    }\n    return y;\n}\n\nfloat binomialCoefficient(int n, int k)\n{\n#ifdef USE_FACTORIAL\n    // Naïve implementation using factorial.\n    return float(factorial(n)) / float(factorial(k) * factorial(n - k));\n#else\n    // Using the multiplicative formula\n    // https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula\n    float c = 1.;\n    for(int i = 1; i <= k; ++i)\n        c *= float(n + 1 - i) / float(i);\n    return c;\n#endif\n}\n\nfloat binomialCached(int n, int k)\n{\n    // Use pre-computed tables to avoid overflow during calculation\n    if(n == 13)\n    \treturn float(bin13[k]);\n    \n    return binomialCoefficient(n, k);\n}\n\n// The method which can be found on Wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zier_curve\nvec2 explicitBezier(float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= n; ++i)\n    {\n        sum += float(binomialCoefficient(n, i)) *\n            \tpow(1. - t, float(n - i)) * pow(t, float(i)) * control_points[i];\n    }\n    return sum;\n}\n\n// Method using cached binomial coefficients to avoid overflow / precision loss.\nvec2 explicitBezierCached(float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= n; ++i)\n    {\n        sum += float(binomialCached(n, i)) *\n            \tpow(1. - t, float(n - i)) * pow(t, float(i)) * control_points[i];\n    }\n    return sum;\n}\n\n// Cached binomial coefficients, plus a reduced method of evaluating the polynomials.\nvec2 explicitBezierCachedWithoutPow(float t)\n{\n    vec2 sum = vec2(0);\n    float s = 1.0;\n    for(int i = 0; i <= n; ++i)\n    {\n        sum *= t;\n        sum += s*binomialCached(n,i)*control_points[n-i];\n        s *= 1.0-t;\n    }\n    return sum;\n}\n\nvec2 deCasteljau(float t)\n{\n    vec2 mid_points[n];\n    for(int i = 0; i < n; ++i)\n    {\n        mid_points[i] = mix(control_points[i], control_points[i + 1], t);\n    }\n    int k = n;\n    while(k > 2)\n    {\n        k -= 1;\n        for(int i = 0; i < k; ++i)\n        {\n            mid_points[i] = mix(mid_points[i], mid_points[i + 1], t);\n        }\n    }\n    return mix(mid_points[0], mid_points[1], t);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// Distance to line segment\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.xy * 2.;\n\tvec2 uv2 = (fract(uv) - .5) * 3.5;\n    uv2.x *= iResolution.x / iResolution.y;\n\n    // Generate control points\n    for(int i = 0; i <= n; ++i)\n    {\n        control_points[i] = vec2(float(i) / float(n) * 2. - 1. + sin(float(i) * 2.3 - iTime / 2.) * .8,\n                                 (hash(vec2(i, 8)) * 2. - 1.) * .4) * 1.5;\n        control_points[i].y += sin(iTime / 3. + float(i) / 1.5);\n    }\n    \n    vec4 col = vec4(0);\n\n    col = vec4(.1 - .02 * smoothstep(0.02, 0.04, abs(fract(uv.x * iResolution.x / iResolution.y * 8.) - .5)) -\n               \t\t.02 * smoothstep(0.02, 0.04, abs(fract(uv.y * 8.) - .5)));\n    \n    col *= smoothstep(0.005, .01, min(abs(uv.y), abs(uv.x) * iResolution.x / iResolution.y));\n    \n    const int m = 64;\n    \n    float dist = 1e4;\n    \n    // Draw the Bezier curve\n    \n    vec2 prevp;\n    for(int i = 0; i <= m; ++i)\n    {\n\t\tfloat t = float(i) / float(m);\n        vec2 p;\n        \n        if(uv.x < 0.)\n        {\n            if(uv.y < 0.)\n            {\n                p = explicitBezier(t);\n            }\n            else\n            {\n                p = explicitBezierCached(t);\n            }\n        }\n        else\n        {\n            if(uv.y < 0.)\n            {\n                p = deCasteljau(t);\n            }\n            else\n            {\n                p = explicitBezierCachedWithoutPow(t);\n            }\n        }\n        \n        if(i > 0)\n            dist = min(dist, segment(uv2, prevp, p));\n\n        prevp = p;\n    }\n    \n\tcol = mix(vec4(1, .2, .2, .2), col, smoothstep(.03, .04, dist));\n    \n    // Draw control points\n    for(int i = 0; i <= n; ++i)\n       col = mix(vec4(1), col, smoothstep(.02, .03, distance(uv2, control_points[i])));\n    \n    if(uv.x < 0.)\n        col = col.argb;\n    if(uv.y < 0.)\n        col = col.barg;\n    \n    fragColor = vec4(sqrt(col.rgb), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1825, 1873, 1895, 1982, 2074], [2076, 2076, 2117, 2117, 2499], [2501, 2501, 2537, 2605, 2695], [2697, 2792, 2822, 2822, 3037], [3039, 3120, 3156, 3156, 3366], [3368, 3454, 3500, 3500, 3701], [3703, 3703, 3730, 3730, 4107], [4109, 4109, 4131, 4131, 4211], [4213, 4241, 4280, 4280, 4371], [4373, 4373, 4430, 4430, 6338]]}
{"id": "wllBW4", "name": "theyaremanycolors 4 - green", "author": "thefox231", "description": "i like this one a lot", "tags": ["theyaremanycolors"], "likes": 2, "viewed": 89, "published": "Public API", "date": "1596788055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define angle 0.9\n#define scale 8.0\n#define scaleFg 1.5\n\n#define alpha 1.0 - fract(iTime * 7.0)\n\nconst vec3 colFg = vec3(0.0, 0.843, 0.0);\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 lines(vec2 uv) {\n    bool mirror = false;\n    \n    uv = rotateVec(uv, angle);\n    uv += iTime * 0.3; // Offset lines\n    \n    if (fract(uv.x * scale/2.0) > 0.5) {\n    \tuv.x += uv.y;   // Make it diagonal\n    } else {\n        mirror = true;\n        uv.x -= uv.y;   // Make it diagonal\n    }\n    uv *= scale;     // Upscale\n    uv = fract(uv); // Fraction\n    \n    vec3 col = vec3(0.0, 0.0, 0.0); // Background color\n        \n    if (mirror) {\n        col = mix(colFg, col, step(uv.x, 0.5)); // Line color\n    } else {\n    \tcol = mix(col, colFg, step(uv.x, 0.5)); // Line color\n    }\n    \n    return col * alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    float angleOffset = hash(floor(iTime * 0.7)) * 3.14;\n    \n    fragColor = vec4(lines(rotateVec(uv, angleOffset)) + lines(rotateVec(uv * scaleFg + 0.2, angle * 2.0 + angleOffset)) * 0.2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 172, 172, 272], [274, 274, 295, 295, 380], [382, 382, 403, 403, 999], [1001, 1001, 1058, 1058, 1303]]}
{"id": "wllBWf", "name": "Soft Shadow", "author": "hummingbird", "description": "This scene showcases soft shadow casting using SDF raymarching. I am trying to use three sphere to construct a bear head lol", "tags": ["sdf", "softshadow"], "likes": 0, "viewed": 85, "published": "Public", "date": "1597964971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Camera{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float focal_length;\n    float aspect_ratio;\n};\n    \n    \n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smoothUnionSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){\n\treturn length(p- center) - radius;\n}\n\nfloat torusSDF(  vec3 p,  vec3 center, float innerRadius, float ringWidth )\n{\n  vec3 pos = p - center;\n  vec2 q = vec2(length(pos.xy)-innerRadius,pos.z);\n  return length(q)-ringWidth;\n}\n\n\n\nfloat planeSDF(vec3 p, vec3 normal, float height){\n\treturn dot(p, normal)-height;\n\n}\n\n\nfloat sceneSDF(vec3 p){\n   float plane = planeSDF(p, vec3(0.0, 1.0, 0.0),-1.0);\n   float sphere = sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.0);\n   float leftEar = sphereSDF(p, vec3(0.8, 0.5, 0.0), .6);\n   float rightEar = sphereSDF(p, vec3(-0.8, 0.5, 0.0), .6);\n   float torusArch = torusSDF(p, vec3(0.0,2,0.0), 4.0, 0.2);\n   \n   float final = smoothUnionSDF(sphere, leftEar,.1);\n   final =smoothUnionSDF(final, rightEar,.1);\n   final = smoothUnionSDF(final, torusArch, .2);\n   final = smoothUnionSDF(final, plane,.1);\n   \n   \n\n   return final;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd,  float k )\n{\n    float res = 1.0;\n    float h = 0.0;\n    float t = 0.1;\n   for(int i = 0; i<50; i++)\n    {\n        \n        h = sceneSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        if(t>=200.0){\n        \treturn res;\n        }\n        t+=h;\n        \n    }\n    return res;\n}\n\n\n\n\nvec3 getSceneNormal(vec3 p){\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nmat4 getViewMatrix(Camera cam){\n\tvec3 f = normalize(cam.target - cam.origin);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n    \tvec4(r,0.0),\n        vec4(u,0.0),\n        vec4(f,0.0),\n        vec4(cam.origin.x,cam.origin.y,cam.origin.z,1.0)\n    );\n\n}\n\nvec3 getCameraRay(vec2 uv, Camera cam){\n    float half_height = tan(radians(cam.vfov/2.0));\n    float half_width = half_height*cam.aspect_ratio; \n    vec3 lower_left = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 view_plane_point = vec4(lower_left + vec3(2.0*half_width,0.0,0.0)*uv.x+vec3(0.0,2.0*half_height,0.0)*uv.y,1.0);\n    view_plane_point = getViewMatrix(cam)*view_plane_point;\n    return normalize(view_plane_point.xyz-cam.origin);\n    \n}\n\n// map from 0 -  255 to 0 - 1\nvec3 normalizedRGB(vec3 rgb){\n\treturn vec3(rgb/255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor = vec4(uv.x, uv.y, 0.0,1.0);\n   \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 horizontal = vec3(2.0 * aspect_ratio,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 lower_left = vec3(-horizontal.x/2.0,-vertical.y/2.0,1.0);\n    \n    // setup camera\n    Camera cam;\n    cam.origin = vec3(cos(iTime)*10.0,2.0,sin(iTime)*10.0);\n   //\tcam.origin = vec3(0,5.0,-10);\n    cam.target = vec3(0.0,0.0,0.0);\n    cam.up = vec3(0.0,1.0,0.0);\n    cam.vfov = 30.0;\n    cam.focal_length = 1.0;\n    cam.aspect_ratio = aspect_ratio;\n    \n    // render sky\n    fragColor.xyz = vec3(0.0);\n   \n    // render scene\n    vec3 rayDir = getCameraRay(uv, cam);\n    vec3 p = cam.origin;\n    vec3 lightPos = vec3(0.0, 3.0, 5.0);\n    \n    \n    for(int i=0;i<250;i++){\n        float d = sceneSDF(p);\n        p = p+rayDir*d;\n        if(d<.001){\n            vec4 finalColor = vec4(0.0,0.0,0.0,1.0);\n            vec3 albedo = vec3(.18,.18,.18);\n            vec3 specular = vec3(1.0,1.0,1.0);\n            vec3 ambient = vec3(0.1,0.1,0.3);\n            vec3 N = getSceneNormal(p);\n           \tvec3 L = normalize(lightPos- p);\n            vec3 E = normalize(cam.origin-p);\n            vec3 H = normalize(L+E);\n            \n            float NdotH = max(dot(N,H), 0.0);\n            float NdotL = max(dot(N, L),0.0);\n            \n            float specularIntensity = pow(NdotH, 300.0);\n            \n            float shadowAtan = softshadow(p, normalize(lightPos), 16.0);\n            finalColor.xyz = (albedo * NdotL  + specular*specularIntensity)*shadowAtan+ ambient;\n            finalColor.xyz = pow(finalColor.xyz, vec3(1.0/ 2.2));\n           \n       \n        \tfragColor = finalColor;\n            return;\n        }\n    \n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 179, 179, 211], [213, 213, 266, 266, 365], [367, 367, 414, 414, 447], [449, 449, 500, 500, 538], [540, 540, 617, 617, 725], [729, 729, 779, 779, 813], [816, 816, 839, 839, 1356], [1359, 1359, 1413, 1413, 1728], [1733, 1733, 1761, 1761, 2114], [2116, 2116, 2147, 2147, 2421], [2423, 2423, 2462, 2462, 2884], [2886, 2916, 2945, 2945, 2972], [2974, 2974, 3031, 3054, 4833]]}
{"id": "wllBWM", "name": "floating_noise", "author": "slackmage", "description": "floating noise", "tags": ["noise"], "likes": 3, "viewed": 254, "published": "Public API", "date": "1596912767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// APOLLONIAN NET FRACTAL\n//\n// shader inspiration and help\n// https://www.shadertoy.com/view/llG3Dt @Gijs\n// https://www.shadertoy.com/view/Xtlyzl @GregRostami / @Fabrice\n\n#define MAX_DIST \t15.0\n#define MIN_DIST \t.001\n#define MAX_STEPS \t158\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define kf(a,b) a*(1.2/b)\n#define pfract(a) -1.+2.*fract(.5*a+.5)\n\n// Antialiasing \"module\" by FabriceNeyret2 \n// https://www.shadertoy.com/view/WlfyW8\n// set at bottom AA = 1 is off\n\nvec3 get_mouse( vec3 ro ) {\n    float x = iMouse.xy==vec2(0) ? -1. :\n    \t(iMouse.y / iResolution.y * 1. - .5) * PI;\n    float y = iMouse.xy==vec2(0) ? .5 :\n    \t-(iMouse.x / iResolution.x * 1. - .5) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n\n\nvec4 orb = vec4(0.0); \n\nvec2 apollo (vec3 p) {\n\tfloat scale = 1.;\n\torb = vec4(0.0);\n\tfor( int i=0; i<4;i++ ) {\n\t\tp = pfract(p);\n\t\tfloat r2 = dot(p,p);  \n        orb = min( orb, vec4(abs(p),r2) );\n\t\tp = kf(p,r2);\n        scale = kf(scale,r2);\n\t}\n    \n    float tubes = length(mod(p.xz+.5,1.)-.5)-.025;\n    tubes =   min(length(mod(p.xy+.5,1.)-.5)-.025,tubes);\n    tubes =   min(length(mod(p.zy+.5,1.)-.5)-.025,tubes);\n    float d = (tubes)/scale;\n    \n\treturn vec2(d*.65,scale);\n}\n\nvec2 map (in vec3 p) {\n    p.x += .5 - iTime *.02;\n    p.y+=1.25;\n    vec2 d = apollo(p);\n\treturn d;\n}\n\n//@iq calNormal using distance - fixes issues\nvec3 get_normal(in vec3 pos, in float t ){\n    float precis = 0.0001 * t * 0.57;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd ) {\n    float depth = 0.0;\n    float m = -1.;\n    for (int i = 0; i<MAX_STEPS;i++)\n    {\n        vec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        m = dist.y;\n        if(abs(dist.x)<MIN_DIST*depth) break;\n        depth += dist.x*.7;\n        if(depth>MAX_DIST) break;\n    } \n    return vec2(depth,m);\n}\n\nfloat get_diff(vec3 p, vec3 lpos, float t) {\n    vec3 l = normalize(lpos-p);\n    vec3 n = get_normal(p, t);\n    float dif = clamp(dot(n,l),0. , 1.);\n    \n    vec2 shadow = ray_march(p + n * MIN_DIST * 2., l);\n    if(shadow.x < length(p -  lpos)) {\n        dif *= .1;\n    }\n    return dif;\n}\n\n//@iq/@shane\nfloat get_ao(vec3 p, vec3 n){\n    float r = 0., w = 1., d;\n    for (float i=1.; i<5.+1.1; i++){\n        d = i/5.;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(6.0), rgb, c.y);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 color = vec3(0.);\n    vec3 fadeColor = vec3(0.5);\n    vec2 ray = ray_march(ro, rd);\n    \n    if(ray.x<MAX_DIST) {\n        vec3 p = ro + ray.x * rd;\n        vec3 n = get_normal(p, ray.x);\n        \n        vec3 lpos1 = vec3(-1.05, -.03, 1.1);\n        vec3 lpos2 = vec3(.05, .01, -.5);\n\n        vec3 tint = hsv2rgb(vec3(ray.y*.006,1.,.5));\n        \n        vec3 diff = vec3(.7)*get_diff(p, lpos1, ray.x);\n             diff+= vec3(.7)*get_diff(p, lpos2, ray.x);\n  \t\tfloat ao = get_ao(p,n);\n\n        color += tint * diff * ao;\n\n    } else {\n    \tcolor = fadeColor;   \n    }\n    \n    color = mix( color, fadeColor, 1.-exp(-1.0015*ray.x*ray.x*ray.x));\n    return color;\n}\n\nvec3 ray( in vec3 ro, in vec3 lp, in vec2 uv ) {\n    vec3 cf = normalize(lp-ro);\n    vec3 cp = vec3(4.,1.,0.);\n    vec3 cr = normalize(cross(cp, cf));\n    vec3 cu = normalize(cross(cf, cr));\n    vec3 c = ro + cf * 6.85;\n    \n    vec3 i = c + uv.x * cr + uv.y * cu;\n    return i-ro; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 ro = vec3(0.,0.1,1.02);\n    vec3 lp = vec3(0.,0.,0.);\n    ro = get_mouse(ro);\n\tvec3 rd = ray(ro, lp, uv);\n\n    vec3 col = render(ro, rd, uv);\n    col= pow(col, vec3(0.4545));\n    fragColor = vec4(col,45.0);\n}\n   \nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n  \tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n    vec3 color = render(fragRayOri, fragRayDir, uv);\n\tcolor = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 532, 559, 559, 794], [821, 821, 843, 843, 1276], [1278, 1278, 1300, 1300, 1380], [1382, 1428, 1470, 1470, 1724], [1726, 1726, 1768, 1768, 2082], [2084, 2084, 2128, 2128, 2374], [2376, 2389, 2418, 2418, 2594], [2596, 2596, 2623, 2623, 2749], [2751, 2751, 2801, 2801, 3475], [3477, 3477, 3525, 3525, 3761], [3763, 3763, 3820, 3820, 4130], [4135, 4135, 4229, 4229, 4443]]}
{"id": "WllBWS", "name": "hole_in_the_box", "author": "TRASHTRASH", "description": "day 3\nI don't hate it\n\"The world gone mad, can't ignore this noise\" - Lecrae\n", "tags": ["raymarching", "beginner", "scene", "vj"], "likes": 3, "viewed": 85, "published": "Public", "date": "1597624075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//TRASHTRASH is Josh deLorimier\n//thanks BigWIngs, evvvvil for your tutorials\n#define MAX_STEPS 128\n#define MAX_DIST 8.\n#define SURF_DIST 0.001\n\n//simplex noise from Patricio Gonzalez Vivo\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0);} \n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n//mercury------------------- \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat box(vec3 p, vec3 b) {\n    return vmax(abs(p)-b);\n}\n//--------------------------\n\nfloat map(vec3 p) {\n    \n    //float n1 = snoise(p.yy+(iTime/2.));\n    float n2 = snoise((p.xy*3.+(iTime*.9)))*2.;\n   // float n3 = abs(snoise(p.yy+iTime/3.));\n  \tvec3 bp1 = vec3(0.,n2,3.);\n    vec3 bp2 = vec3(0.,0.,1.);\n    float b2 = box(p-bp2, vec3(.6,.3,2.));\n    float b = box(p-(bp1), vec3(2.,1.,1.));\n \n    return max(-b2,b )/25.;\n}\n\nfloat RM(vec3 ro, vec3 rd) {\n \tfloat t = 0.;\n    for(int i = 0;i<MAX_STEPS;i++) {\n        vec3 p = ro+rd*t;\n        float s = map(p);\n        \n        if(t > MAX_DIST || abs(s) < (SURF_DIST)) break;\n        t+=s;\n        \n      }\n   return t;\n}\n\n\nvec3 norm(vec3 p) {\n \tfloat d = map(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx));\n    return normalize(n);\n}\n\nfloat shade(vec3 p, vec3 rd) {\n \tvec3 lp = vec3(4,3.,-15.);\n    vec3 l = normalize(lp -p);\n    vec3 n = norm(p);\n    float dif = clamp(dot(n,l),0.,.6);\n  \tfloat fr = pow(1.0+dot(n, rd),4.0);\n   \tfloat ao = (1.0 - fr);\n   \treturn max(fr,0.4)+dif*ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord -0.5 * iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 col = vec3(0.);\n    vec3 c1 = vec3(.5,0.2,0.)*2.;\n    float d = RM(ro, rd);\n    if(d<MAX_DIST) {\n    vec3 p = ro + rd *d;\n    \n    float n4 = snoise(uv.xy+iTime); \n    float dif = shade(p, rd);\n   \tcol = vec3(dif)*(c1*n4+0.4);\n    col*=col*col;\n    }\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 189, 211, 211, 249], [252, 252, 274, 274, 1094], [1095, 1125, 1145, 1145, 1180], [1182, 1182, 1209, 1209, 1238], [1239, 1269, 1288, 1335, 1608], [1610, 1610, 1638, 1638, 1854], [1857, 1857, 1876, 1876, 2018], [2020, 2020, 2050, 2050, 2270], [2273, 2273, 2330, 2330, 2798]]}
{"id": "wllBzf", "name": "Fractal stadium", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 9, "viewed": 93, "published": "Public", "date": "1597377581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.0)\n#define pmod(p,n)length(p)*sin(vec2(0.,PI*.5)+mod(atan(p.y,p.x),PI*2./n)-PI/n)\n#define fold45(p)(p.y>p.x)?p.yx:p\n#define rot(p,a)p*cos(a)+vec2(-p.y,p.x)*sin(a)\n\nfloat orbit;\nfloat map(vec3 p)\n{\n    float scale=3.;\n    vec3 off=vec3(10,1.,.2);\n\tfloat s=2.,de;\n    orbit=0.;\n\tfor(int i=0;++i<9;)\n\t{\n\t    p.xz=pmod(p.xz,5.);\n        p.z-=.7;\n        p.xz=abs(p.xz);\n\t\tp.xz=fold45(p.xz);\n\t\tp.z=1.-abs(p.z-1.);\n\t\t//p.z=abs(p.z-1.)-1;\n\t\tp.xy=fold45(p.xy);\n\t\tp-=off;\n\t\tp*=scale;\n\t\tp+=off;\n\t\ts*=scale;\n        de=length(p)/s-.002;\n        if(de<0.001)break;\n        orbit++;\n\t}\n\treturn de;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p;\n  \tvec3 ro=vec3(0,5,-1.+12.*fract(iTime*.1));\n  \tvec3 w=normalize(vec3(0,.1,-1));\n  \tvec3 u=normalize(cross(w,vec3(0,1,0)));\n  \tvec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\tfloat h=0.,d,i;\n\tfor(i=1.;i<100.;i++)\n    {\n    \tp=ro+rd*h;\n        p.xz=rot(p.xz,iTime*.2);\n\t\td=map(p);\n    \tif(d<.0001||h>50.)break;\n    \th+=d;\n\t}\n    fragColor.xyz=25.*vec3(cos(vec3(.2,.8,.7)*orbit)+(cos(p.xyy)*.5+.5))/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 215, 215, 605], [606, 606, 663, 663, 1134]]}
{"id": "wllBzl", "name": "Following Hexagon tutorial", "author": "mightee_cactus", "description": "https://www.youtube.com/watch?v=VmrIDyYiJBA", "tags": ["hexagon"], "likes": 3, "viewed": 57, "published": "Public", "date": "1597503417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Learning hexagonal tiling by following tutorial\n// https://www.youtube.com/watch?v=VmrIDyYiJBA\n//\n\n\nfloat HexDist(vec2 p)\n{\n    p = abs(p);\n    // ratio for the slope of the hex size\n    float c = dot(p, normalize(vec2(1, 1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\n// Returns (?, dist to hex edge, hex_id.x, hex_id.y)\nvec4 HexCoord(vec2 p)\n{\n    // ratio for the slope of the hex size\n    vec2 ratio = vec2(1, 1.73);\n    vec2 h  = ratio * .5; \n\tvec2 a = mod(p, ratio) - h;\n    vec2 b = mod(p - h, ratio) - h;\n    \n    vec2 gv = dot(a,a) < dot(b,b) ? a : b;\n    \n    vec2 id = p - gv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5 - HexDist(gv);\n    \n    return vec4(x, y, id.x, id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //vec2 guv = fract(uv * 10.);\n    // inverting step, so it is (x, edge) instead of (edge, x)\n    //col += step(HexDist(uv), 0.1);\n    //col += step(HexDist(guv - 0.5)*0.3, 0.1);\n    //col.rg = HexCoord(uv * 5.).xy;\n    uv  *= 10.;\n    vec4 hc = HexCoord(uv);\n    \n    //col += smoothstep(0.03, 0.1, hc.y * sin(hc.z*hc.w + iTime));\n    // some experiments\n    //col += hc.w*0.1+.5; // moving waves illusion\n    col += smoothstep(0.03, 0.1, hc.y * sin(uv.y*uv.x*.5 + iTime*1.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 106, 129, 129, 278], [280, 333, 356, 399, 709], [711, 711, 768, 768, 1378]]}
{"id": "wllfD4", "name": "theyaremanycolors 6 - blue", "author": "thefox231", "description": "this was fun", "tags": ["theyaremanycolors"], "likes": 2, "viewed": 95, "published": "Public API", "date": "1596798994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 layer1Color = vec3(0.0, 0.0, 254.0/255.0);\nconst vec3 layer2Color = vec3(57.0/255.0, 73.0/255.0, 251.0/255.0);\nconst vec3 layer3Color = vec3(0.0, 0.0, 4.0/255.0);\n\n#define scale 30.0\n#define offset 10.0\n\n#define fisheye_amount -0.1\n\nfloat hash(vec3 p3)\n{\n    p3.xy *= 400.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = layer1Color;\n    \n    float hash1 = round(hash(vec3(round(uv * scale) / scale, round(iTime * 15.0))));\n    uv += offset / iResolution.xy;\n    float hash2 = round(hash(vec3(round(uv * scale) / scale, round(iTime * 15.0 + 90.0))));\n    \n    col = mix(col, layer2Color, hash1);\n    col = mix(col, layer3Color, hash2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 265, 265, 388], [390, 390, 447, 447, 1166]]}
{"id": "WllfD8", "name": "Mondrian Animation", "author": "JackKalish", "description": "Exercise from Book of Shader by  Patricio Gonzalez Vivo\nChapter 7: https://thebookofshaders.com/07/\n\n\"show off your skills by making a composition of rectangles and colors that resembles a Piet Mondrian painting.\"", "tags": ["color", "painting", "animation", "rectangle", "box", "mondrian"], "likes": 1, "viewed": 81, "published": "Public", "date": "1596774502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 white = vec3(1.,1.,.95);\nvec3 red = vec3(1., 0.3, 0.1);\nvec3 blue = vec3(0.3, 0.3, .8);\nvec3 yellow = vec3(1., 0.9, .0);\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n\nfloat rect(vec2 st, vec4 r){\n    //vec2 bl = floor(st+vec2(1.)-r.xy);\n    vec2 bl = step(r.xy,st);\n    float pct = bl.x * bl.y;\n\n    // top-right\n    // vec2 tr = step(r.zw,1.0-st);\n    vec2 tr = floor(st-r.zw);\n     pct *= tr.x * tr.y;\n    \n    return pct;\n}\n\nfloat rectOutline(vec2 st, vec4 r, float w){\n    return rect(st,r)-rect(st,vec4(r.x+w, r.y+w, r.z-w, r.w-w));\n}\n\nvec3 coloredBox(vec2 st, vec3 color, vec4 r){\n        \n    float avgColor = (color.r+color.g+color.b)/3.;\n\tfloat w = (sin(iTime*avgColor*1.)+1.1)*.1;\n    color *= 1.-w*5.;\n    return vec3(rect(st, vec4(r.x+w, r.y+w, r.z-w, r.w-w)))*color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0); \n    \n    color += coloredBox(st, red, vec4(.0,.0,.4,.5));\n    color += coloredBox(st, white, vec4(.4,.0,.6,.5));\n    color += coloredBox(st, blue, vec4(.6,.0,1.4,.2));\n    color += coloredBox(st, yellow, vec4(.6, .2, 1.1, .8));\n    color += coloredBox(st, red,    vec4(1.1, .2, 1.4, .8));\n    color += coloredBox(st, white, vec4(.0,.5,.6,.8));\n    color += coloredBox(st, blue, vec4(.0,.8,.9,1.));\n    color += coloredBox(st, white, vec4(.9,.8,1.4,1.));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 274, 315, 505], [507, 507, 551, 551, 618], [620, 620, 665, 665, 860], [862, 862, 916, 916, 1524]]}
{"id": "WllfDN", "name": "theyaremanycolors 2 - red", "author": "thefox231", "description": "yeah", "tags": ["theyaremanycolors"], "likes": 1, "viewed": 95, "published": "Public API", "date": "1596784519", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define alpha 0.0\n#define beta 10.0\n\n#define squareScale 6.0\n\nvec2 rotateVec(vec2 v, float a){\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * (v - .5) + .5;\n}\n\nvec4 spiral4(vec2 coord)\n{\t\n\tfloat alpha_t = alpha - iTime * 300.0;\n\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\n\tfloat r = sqrt(dot(coord, coord));\n\n\tfloat phi = atan(y, x);\n\n\tfloat phi_r = (r - alpha_t) / beta;\n\n\tfloat r_phi = alpha_t + (beta * phi);\n\n\tfloat remainder = abs(cos(phi) - cos(phi_r));\n\n\treturn vec4(vec3(remainder), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uvOrig = uv;\n    \n    uv = rotateVec(uv, iTime * 0.8);\n    \n    vec3 col = vec3(0.2, 0.0, 0.0);\n    col = spiral4(rotateVec(fragCoord.xy / iResolution.xy * (0.9 + uv * 0.1), iTime * 0.8) * iResolution.xy - (iResolution.xy * 0.5)).rgb * vec3(1.0, 0.0, 0.0);\n    \n    col.r += round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + iTime * 13.5)).x - round(fract(rotateVec(uvOrig, iTime * 0.05) * squareScale + squareScale/2.0 + iTime * 13.5)).y;\n    \n    col.r -= round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + iTime * 13.5)).y - round(fract(rotateVec(uvOrig, iTime * 0.2 + 25.0) * squareScale + squareScale/2.0 + iTime * 13.5)).x;\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 94, 94, 194], [196, 196, 222, 222, 532], [534, 534, 591, 591, 1389]]}
{"id": "wllfDX", "name": "Gyroids test _DB", "author": "db009", "description": "Followed a tutorial by the amazing BigWings on here. (link in bottom) just learning everything I can about shaders and raymarching form his videos so I can use it inside of unity\n\nhttps://www.youtube.com/watch?v=-adHIyjIYgk", "tags": ["raymarching", "gyroid", "gyroids"], "likes": 5, "viewed": 182, "published": "Public", "date": "1597961021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 4.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias)\n{\n\t//scale position\n    p*=scale;\n    \n   \t//return dot(sin(p),cos(p.zxy))/scale;//gyroid function - divide by scale factor\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;// thickness gyroid function - divide by scale factor\n    // return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;//same as above but has modifiers to p. scale. must multiply scale by largest of the 2 modifiers of p to fix hiccups\n}\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.15);//rotate the whole gyroid\n    p.z += -iTime*.1;//fly through world\n    p.y-=.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    \n    p = Transform(p);\n    \n    float d = sdBox(p, vec3(1));\n    \n\tfloat gyroid1 = sdGyroid(p,5.23,.03,1.4);\n    float gyroid2 = sdGyroid(p,10.76,.03,.3);\n    float gyroid3 = sdGyroid(p,20.76,.03,.3);\n    float gyroid4 = sdGyroid(p,35.76,.03,.3);\n    float gyroid5 = sdGyroid(p,60.76,.03,.3);\n    float gyroid6 = sdGyroid(p,110.76,.03,.3);\n    //float g = min(gyroid1,gyroid2);//union\n    //float g = max(gyroid1,-gyroid2);//subtraction\n    \n    gyroid1 -= gyroid2*.4;\n    gyroid1 -= gyroid3*.3;\n    gyroid1 += gyroid4*.2;\n    gyroid1 += gyroid5*.2;\n    gyroid1 += gyroid6*.3;\n    float g = gyroid1;\n    \n    //contain gyroid to box only (boiolean intersection)\n    //float dist = max(d, g*.8);\n    \n     float dist = gyroid1*.8;\n    return dist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //vec2 e = vec2(.001, 0);//.001 is accuracy of rayMarch increase it for smoother edges nortt so sharp\n    vec2 e = vec2(.02, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Background(vec3 rd)\n{\n \tvec3 col = vec3(0);\n    float y = rd.y*.5+.5;\n    col += (1.-y)*vec3(1,.4,.1)*2.;\n    \n    float angle = atan(rd.x,rd.z);\n    float flames = sin(angle*10.+iTime)*sin(angle*7.-iTime)*sin(angle*6.);\n    flames*= smoothstep(.8,.5,y);//remove flames from reach top\n     col += flames;//add flmaes to col\n    col = max(col, 0.);//get rid of negatives(adds white to where color division would have been)\n    col += smoothstep(.5,.0,y);//remove flame from  going all the way too bottom\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //uv += sin(uv*20.);//weird cubeish kaleidoscope effect\n    uv += sin(uv*20.+iTime)*.01;//heat distortion\n    vec3 ro = vec3(0, 0, -.3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 lookAt = vec3(0,0,0);\n    vec3 rd = GetRayDir(uv, ro,lookAt , .8);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        float height = p.y;//get height of where looking\n        p = Transform(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        float dif = n.y*.5+.5;//light from above the normal\n        col+= dif*dif;//diffuse lighting . multiply by itself for contrast\n    \t//col += n*.5+.5;//use normals to give it colors off spectrum the *.5+.5 is to remove the deep blacks\n        \n        float gyroid2 = sdGyroid(p,10.76,.03,.3);\n        col *= smoothstep(-.1,.1,gyroid2);//cheap ambient oclussion using gyroid2's position\n        \n        float crackWidth = -0.01+smoothstep(0.,-.5,n.y)*.04;\n        float cracks = smoothstep(crackWidth,-.03,gyroid2);\n        \n        float gyroid3 = sdGyroid(p+(iTime*.1),5.76,.03,.0);\n        float gyroid4 = sdGyroid(p+(iTime*.05),4.76,.03,.0);\n        cracks *= gyroid3*gyroid4*20.+.2*smoothstep(.2,.0,n.y);\n        \n        col+=cracks*vec3(1,.4,.1)*3.;//multiply by color. then multiply for intensity\n        \n        float gyroid5 = sdGyroid(p-vec3(0.,iTime,0.),3.76,.03,.0);//weird flame wind/flicker looking thing        \n        col += gyroid5*vec3(1.,.4,.1);//apply flicker\n        \n        col += smoothstep(0.,-2.,height)*vec3(1.,.4,.1);//glowy floor\n    }\n    \n    col = mix(col,Background(rd),smoothstep(0.,7.,d));//fog gradient\n \t//col = Background(rd);\n \n    col *= 1.-dot(uv,uv);//vingette\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfDX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 337, 356, 356, 418], [420, 420, 442, 442, 536], [538, 538, 567, 567, 648], [650, 650, 716, 734, 1147], [1149, 1149, 1173, 1173, 1294], [1296, 1296, 1319, 1319, 2072], [2074, 2074, 2108, 2108, 2319], [2321, 2321, 2345, 2345, 2635], [2637, 2637, 2687, 2687, 2878], [2880, 2880, 2906, 2906, 3409], [3411, 3411, 3468, 3468, 5391]]}
{"id": "wllfRj", "name": "P.Gerdes & Tchokwe sand drawing7", "author": "FabriceNeyret2", "description": "pseudo3D variant of [url]https://shadertoy.com/view/WlffzB[/url]\n\nReference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n", "tags": ["tiles", "short", "truchets"], "likes": 7, "viewed": 232, "published": "Public API", "date": "1597213034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// pseudo3D variant of https://shadertoy.com/view/WlffzB\n\n#define S(v) smoothstep( 9./R.y , 0. , v )           // AA draw\n#define s(v) ( .5 + .5* cos(3.14*v/.1) )             // strip pattern \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(.5,0,0,0);\n    mat2 M = mat2(1,-1,1,1);                         // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                         // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414, f, S;     // quad center to edge domain\n    \n  //O -= S( length(F) - .1 );                        // dots\n\n    float i = I.y + 10.*I.x +99.,                    // edge id (float)\n          r = fract(4e4*sin(i));                     // rand(id)\n    O = r < .5\n        ? f = abs( abs(F) - .353 ),\n          S = S(f-.1), F = S * s(f),                 //  X at edge\n          mix( O,   F.x + F.y \n                  - ( F.yx*(.5+.5*cos(6.28*f/.71))) [int(4.*r)]  // random crossing order\n                 + O.yyxw ,\n               max(S.x,S.y) )\n        :(                           \n          r = abs( length(F) - .353 ),               // )( at edge\n          mix( O, s(r) + O.yyxy, S(r-.1) ) );\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );   // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 194, 232, 232, 1289]]}
{"id": "wllfRs", "name": "My First Mandelbrot :P", "author": "dub", "description": "Quick mandelbrot", "tags": ["mandelbrot"], "likes": 3, "viewed": 75, "published": "Public", "date": "1597522550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reference:\n// https://en.wikipedia.org/wiki/Mandelbrot_set\n\n#define PI 3.1415926538\n#define PI2 PI/2.0\n\n#define MAX_ITER 100.\n\n// from: http://www.chilliant.com/rgb2hsv.html\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return clamp(vec3(R,G,B), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 2.0; // transform to [-1, 1] y domain\n    uv -= vec2(aspect, 1.0); // center on screen\n    // uv /= exp2(iTime);\n    uv /= exp2(sin(iTime*PI2/18.0-PI2)*9.0+9.0); // this is as far as our precision goes\n    \n    // interesting point\n    // https://commons.wikimedia.org/wiki/File:Fractal-zoom-1-03-Mandelbrot_Buzzsaw.ogv\n   \tuv += vec2(0.001643721971153, -0.822467633298876);\n    \n    // z = 0\n    vec2 xy = vec2(0.);\n    \n    float i = 0.;\n\tvec2 sq_xy = vec2(0.);\n    for (;i < MAX_ITER; i++)\n    {\n        // |z| <= 2\n        if(sq_xy.x + sq_xy.y > 2.0*2.0)\n            break;\n\n        // z^2 + c = x^2 + 2ixy -y^2 + cx + icy\n        xy = vec2(sq_xy.x - sq_xy.y, 2.0*xy.x*xy.y) + uv;\n    \tsq_xy = xy*xy;\n    }\n    /*\n    for (;dot(xy, xy) <= 2.0*2.0 && i < MAX_ITER; i++)\n        // z^2 + c = x^2 + 2ixy -y^2 + cx + icy\n        xy = vec2(xy.x*xy.x - xy.y*xy.y, 2.0*xy.x*xy.y) + uv;\n\t*/\n    \n    //nsmooth := n + 1 - Math.log(Math.log(zn.abs()))/Math.log(2)\n        \n    //vec3 col = (i < MAX_ITER) ? HUEtoRGB(i/MAX_ITER) : vec3(0.);\n    vec3 col = (i < MAX_ITER) ? HUEtoRGB((i + 1. - log2(log(i)))/MAX_ITER) : vec3(0.);\n    \n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 177, 204, 204, 367], [369, 369, 426, 426, 1678]]}
{"id": "WllfWr", "name": "Gbuffer and resolve sample", "author": "Shcherbakov", "description": "Результат написания кода во время первого стрима про gbuffer и resolve с освещением по Фонгу.\nStream: https://www.youtube.com/watch?v=NXemod5o-I8", "tags": ["phong", "gbuffer"], "likes": 1, "viewed": 186, "published": "Public", "date": "1596481824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.1, 0.1, 0.2);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, 0, 4);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.2, 0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.35;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(sin(iTime), -3, cos(iTime)));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    for (int x = 0; x < SAMPLES_COUNT; ++x) {\n        for (int y = 0; y < SAMPLES_COUNT; ++y) {\n            vec2 uv = (fragCoord + vec2(x, y) / float(SAMPLES_COUNT) - iResolution.xy * 0.5)/iResolution.x;\n            vec3 viewVec = normalize(vec3(uv, 1.0));\n            fragColor = vec4(0.0);\n\n            float intersectionDist = FAR_INF;\n            vec3 intersectionColor;\n            vec3 intersectionPos;\n            vec3 intersectionNormal;\n            float intersectionSpecular;\n            for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n                float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n                if (hitDist < intersectionDist) {\n                    intersectionDist = hitDist;\n                    intersectionColor = SPHERES[i].color;\n                    intersectionPos = cameraPos + viewVec * intersectionDist;\n                    intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n                    intersectionSpecular = SPHERES[i].specular;\n                }\n            }\n\n            for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n                float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n                if (hitDist < intersectionDist) {\n                    intersectionDist = hitDist;\n                    intersectionColor = TRIANGLES[i].color;\n                    intersectionPos = cameraPos + viewVec * intersectionDist;\n                    intersectionNormal = TRIANGLES[i].normal;\n                    intersectionSpecular = TRIANGLES[i].specular;\n                }\n            }\n\n            vec3 lighting = intersectionColor * SKY_COLOR;\n\n            bool shadow = false;\n            vec3 shadowCastPos = intersectionPos - SUN_DIR * 0.001;\n            for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n                float hitDist = ray_sphere_intersection(SPHERES[i], shadowCastPos, -SUN_DIR);\n                shadow = shadow || hitDist < FAR_INF;\n            }\n\n            for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n                float hitDist = ray_triangle_intersection(TRIANGLES[i], shadowCastPos, -SUN_DIR);\n                shadow = shadow || hitDist < FAR_INF;\n            }\n\n            if (!shadow) {\n                lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor;\n                if (intersectionSpecular != 0.0)\n                    lighting += pow(max(0.0, dot(reflect(-SUN_DIR, intersectionNormal), viewVec)), intersectionSpecular);\n            }\n            fullLighting += lighting;\n        }\n    }\n    \n    fragColor.xyz = pow(fullLighting / float(SAMPLES_COUNT) / float(SAMPLES_COUNT), vec3(1.0 / 2.2));\n    \n    // Output to screen\n    //fragColor = vec4(vec3(intersectionDist) / 50.0, 1.0);\n    //fragColor = vec4(intersectionColor, 1.0);\n    //fragColor = vec4(intersectionNormal * 0.5 + 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 483, 805, 1241], [1243, 1243, 1311, 1502, 2331], [2333, 2333, 2390, 2390, 6327]]}
{"id": "wllfz2", "name": "Blender Line shader", "author": "jbakker", "description": "Test for blender image editor", "tags": ["lineaa"], "likes": 1, "viewed": 58, "published": "Public", "date": "1597243172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat calc_coverage(vec2 uv, vec2 line_center, float angle) {\n    vec2 line_dir = vec2(sin(angle), cos(angle));\n    \n    vec2 ofs = uv - line_center;\n    float lambda = dot(line_dir, ofs);\n    vec2 projection = line_center + lambda * line_dir;\n    float d = distance(uv, projection);\n    float result = smoothstep(0.002, 0.001,abs(d));\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float coverage = max(max(\n      calc_coverage(uv, vec2(0.5), iTime),\n      calc_coverage(uv, vec2(0.2, 0.3), iTime* 0.2+ 0.1)),\n      calc_coverage(uv, vec2(0.8, 0.2), iTime*-0.3)\n    );\n\n    fragColor = vec4(vec3(coverage),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllfz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 62, 62, 357], [359, 359, 416, 466, 743]]}
{"id": "WllfzB", "name": "Concrete++", "author": "dean_the_coder", "description": "I wanted a procedural 3D texture for future projects, written in a way which can be easily shared.\nThanks to @Shane, there's no need for any texture channels to be used.\nSee getConcreteMaterial() for the texture code.  The corridor, etc is just a demo.\n\n", "tags": ["raymarching", "sdf", "texture", "material", "concrete"], "likes": 8, "viewed": 385, "published": "Public API", "date": "1598207431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Concrete++'\n//\n// I wanted a procedural 3D concrete texture for future projects, written in a way which\n// can be easily shared.\n// See getConcreteMaterial() for the texture code.\n//\n// Thanks to @Shane, there's no need for any texture channels to be used.\n//\n// The corridor, etc is just a demo so I can see how it all looks in a 3D scene.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n\n#define AA  // Comment out this line for a speed boost.\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat opRep(inout float p, float size, float c1, float c2) {\n    float w2 = size * 0.5;\n    float pp = p - w2;\n    float idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return fract(idx * 12532.56);\n}\n\nfloat opRep(inout vec2 p, vec2 size, vec2 c1, vec2 c2) {\n    vec2 w2 = size * 0.5;\n    vec2 pp = p - w2;\n    vec2 idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return dot(fract(idx * 12532.56), vec2(421.0, 965.0));\n}\n\nvec4 min4(vec4 a, vec4 b) { return a.x < b.x ? a : b; }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Call to create a concrete-like 3D texture.\n//\n// p:   [in]  point in 3D space.\n// mat: [out] material rgb\n// id:  [in]  arbitary ID used as a rnd seed.\n// dist:[in]  distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns: surface noise value to apply to a SDF function.\nfloat getConcreteMaterial(vec3 p, out vec3 mat, float id, float dist) {\n    // Set rnd seed from id.\n    vec3 tp = p + vec3(0.32, 0.40, 1.2) * mod(id, 10.0);\n    \n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(tp));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    dist = 1.0 - smoothstep(0.0, 1.0, dist / 14.0);\n    float rough = noise(tp * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(tp * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    // Fade surface roughness(/deflection) out with distance to prevent screen noise.\n    return rough * dist;\n}\n\n// A rectangular concrete 'wall panel', with a small hole in each corner.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdConcretePanel(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each panel a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.03);\n    p.xz *= tilt;\n    p.yz *= tilt;\n    \n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Mounting holes.\n    vec3 pp = p;\n    pp.xy = abs(p.xy) - r.xy * 0.8;\n    float hole = sdCappedCylinder(pp + vec3(0.0, 0.0, r.z * 1.5), r.x * 0.03, r.z * 1.0);\n    d = max(d, -hole);\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Concrete paving slab.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdSlab(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each slab a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.05);\n    p.xz *= tilt;\n    p.yz *= tilt;\n\n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Map the scene using SDF functions.\nvec4 map(vec3 p, vec3 ro) {\n    vec3 r = vec3(1.0, 2.0, 0.05);\n    \n    vec4 d = vec4(1e10);\n    \n    float dist = distance(p, ro);\n    \n    // Left wall.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    float id = opRep(pp.xy, r.xy * 2.0, vec2(-15.0, -2.0), vec2(10.0, 1.0));\n    d = min4(d, sdConcretePanel(pp, r, id, dist));\n    \n    // Far wall.\n    pp = p;\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -2.0), vec2(5.0, 1.0));\n    d = min4(d, sdConcretePanel(pp - vec3(0.0, 0.0, 33.0), r, id, dist));\n    \n    // Columns.\n    pp = p - vec3(8.0, 0.0, 0.0);\n    id = opRep(pp.z, 5.0, -4.0, 3.0);\n    d = min4(d, sdSlab(pp, vec3(2.0, 8.0, 1.0), 1.0, dist));\n    \n    // Floor.\n    pp = p;\n    pp.yz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    r = vec3(3.0, 3.0, 0.1);\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -5.0), vec2(6.0, 6.0));\n    d = min4(d, sdSlab(pp, r, id, dist));\n    \n    // Ceiling.\n    d = min4(d, sdSlab(p - vec3(1.0, 10.0, 0.0), vec3(10.0, 3.0, 50.0), 1.0, dist));\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy, ro).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, ro).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, ro).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, ro).x);\n}\n\nfloat calcShadow(vec3 p, vec3 ro, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float res = 1.0;\n    float t = 0.05;\n    for(float i = 0.0; i < 45.0; i++)\n    {\n        float h = map(p + rd * t, ro).x;\n        if (h < MIN_DIST * t)\n            return 0.0; // Hit an object - Full shadow.\n        \n        res = min(res, 48.0 * h / t);\n        t += h;\n        \n        if (t > 20.0)\n            break; // Marched far enough - Stop.\n    }\n    \n    return res;\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 ro, vec3 n, float h) {\n    return map(p + h * n, ro).x / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, vec3 ro, vec3 mat) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(100.0, 50.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p, ro);\n    float amb = dot(vec3(ao(p, ro, n, 0.2), ao(p, ro, n, 0.5), ao(p, ro, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light (Sun).\n    float sha = calcShadow(p, ro, sunPos) + 0.25;\n    vec3 lig = diff * sunCol * sha;\n\n    // Specular.\n    lig += pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), 15.0);\n\n    // Seconary light (Bounce light);\n    lig += max(0.0, dot(-sunDir, n)) * sunCol * 0.1 * amb;\n    \n    return mat * lig;\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01, prevd = 1.0;\n    vec4 details;\n    for (float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        details = map(p, ro);\n        \n        if (abs(details.x) < MIN_DIST)\n            break; // We've hit a surface - Stop.\n        if (d > 35.0) return vec4(1e7, 0.0, 0.0, 0.0);\n        \n        d += details.x; // No hit, so keep marching.\n    }\n    \n    return details;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n  \tvec4 details = march(ro, rd, p);\n        \n    // Materials and lighting.\n    return applyLighting(p, rd, ro, details.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 9.5));\n    float phase = mod(floor(iTime / 9.5), 3.0);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 9.5)), 100.0);\n    \n    vec3 ro;\n    vec3 lookAt;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(22.0, 9.0, ft), 0.0, 8.0);\n        lookAt = vec3(6.0, 0.0, mix(5.0, 13.0, ft));\n    } else if (phase == 1.0) {\n        ro = vec3(0.0, 0.0, mix(-9.0, 4.5, ft));\n        lookAt = vec3(0.0, mix(-10.0, 0.0, ft), mix(0.0, 8.0, ft));\n    } else if (phase == 2.0) {\n        ro = vec3(-1.0, 0.0, mix(-4.0, 0.0, ft));\n        lookAt = vec3(-5.0, mix(-1.0, 1.0, ft), ro.z + mix(0.0, 5.0, ft));\n    }\n\n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 rd = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rd);\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    col *= dim;\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfzB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[631, 687, 708, 708, 984], [986, 986, 1005, 1005, 1081], [1083, 1083, 1111, 1111, 1155], [1157, 1157, 1217, 1217, 1382], [1384, 1384, 1440, 1440, 1627], [1629, 1629, 1656, 1656, 1684], [1686, 1686, 1715, 1715, 1810], [1812, 1812, 1862, 1862, 1974], [1976, 1976, 2023, 2023, 2228], [2230, 2555, 2626, 2655, 3228], [3230, 3538, 3598, 3637, 4095], [4097, 4356, 4407, 4445, 4705], [4707, 4745, 4772, 4772, 5769], [5771, 5771, 5805, 5805, 6014], [6016, 6016, 6066, 6066, 6494], [6496, 6524, 6568, 6568, 6607], [6609, 6695, 6736, 6736, 6877], [6879, 6879, 6935, 6935, 7606], [7608, 7608, 7650, 7650, 8057], [8059, 8059, 8097, 8114, 8254], [8256, 8256, 8311, 8326, 9558]]}
{"id": "WllfzS", "name": "Sweet road", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 21, "viewed": 246, "published": "Public", "date": "1597043911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Scale;\nfloat map(vec3 p)\n{\n   float s=2.;\n    for(int i = 0; i < 4; i++) {\n        p=mod(p-1.,2.)-1.;\n\t\tfloat r2=1.2/dot(p,p);\n    \tp*=r2;\n    \ts*=r2;\n    }\n    Scale=log2(s);\n    p = abs(p)-0.8;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return length(cross(p,normalize(vec3(0,.5,1))))/s-Scale*.0015;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(1.,1.,iTime),\n  \t\tw=normalize(vec3(.1*sin(iTime*.5),.3,1)),\n  \t\tu=normalize(cross(w,vec3(cos(-iTime*.16),sin(-iTime*.16),0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\tfloat h=0.,d,i;\n\tfor(i=1.;i<100.;i++)\n    {\n    \tp=ro+rd*h;\n\t\td=map(p);\n    \tif(d<.0001)break;\n    \th+=d;\n\t}\n    fragColor.xyz=35.*vec3(vec3(.7,.9,.7)*cos(Scale*.3)+(cos(p.xyy)*.5+.5))/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllfzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 32, 32, 366], [368, 368, 425, 425, 869]]}
{"id": "wlSBDz", "name": "Pulsing rods", "author": "nicoleslaw", "description": "Another learning experience.", "tags": ["rods", "hyperbolicparaboloid"], "likes": 6, "viewed": 77, "published": "Public", "date": "1598883105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n//----------------------- FUNCTIONS -----------------------//\n\n/*\n * Get the 4x4 rotation matrix for rotating about <axis> by angle <theta> in radians.\n */\nmat4 rotation_about_axis(vec3 axis, float theta) {\n    \n    axis = normalize(axis);\n    float x = axis.x; float y = axis.y; float z = axis.z;\n    mat4 R = mat4(x*x+(1.0-x*x)*cos(theta),\n                  x*y*(1.0-cos(theta))-z*sin(theta),\n                  x*z*(1.0-cos(theta))+y*sin(theta), 0.0,\n                  y*x*(1.0-cos(theta))+z*sin(theta),\n                  y*y+(1.0-y*y)*cos(theta),\n                  y*z*(1.0-cos(theta))-x*sin(theta), 0.0,\n                  z*x*(1.0-cos(theta))-y*sin(theta),\n                  z*y*(1.0-cos(theta))+x*sin(theta),\n                  z*z+(1.0-z*z)*cos(theta), 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n    return R;\n}\n\n\nfloat bump(float d) {\n    return 1.0/(1.0 + sqrt(d));\n}\n\nfloat dist_from_line(vec2 p, vec2 A, vec2 B) {\n    float x0 = p.x; float y0 = p.y;\n    float x1 = A.x; float y1 = A.y;\n    float x2 = B.x; float y2 = B.y;\n    return abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)/sqrt((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1));\n}\n\n//----------------------- SCENE -----------------------//\n\n/*\n * Signed distance function for a sphere centered at the <origin> with radius <radius>.\n */\nfloat sphereSDF(vec3 sample_point, vec3 origin, float radius) {\n    return length(sample_point - origin) - radius;\n}\n\n/*\n * Signed distance function for a capsule with origin <a>, endpoint <b>, and radius <r>.\n * https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n */\nfloat capsule_SDF( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n/*\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 sample_point) {\n    /*\n    float dist = 1e5; int N = 10; float L = 2.0;\n    for (int i=0; i < N; i++) {\n        vec3 src = vec3(cos(2.0*PI*float(i)/float(N)), sin(2.0*PI*float(i)/float(N)), 0.0);\n        vec3 dst = L*vec3(cos(2.0*PI*float(i+1)/float(N)), sin(2.0*PI*float(i+1)/float(N)), 0.0);\n        vec3 diff = dst - src;\n        src -= diff*0.5; dst -= diff*0.5;\n        dist = min(dist, capsule_SDF(sample_point, src, dst, 0.1));\n    }\n    return dist;\n\t*/\n    \n    float dist=1e5; float l = 0.5;\n    int N = 5; float r = 0.1;\n    for (int i=-N; i < N; i++) {\n        for (int j=-N; j < N; j++) {\n            float x = float(i);\n            float y = float(j);\n            float z = float(i*j);\n            //dist = min(dist, sphereSDF(sample_point, vec3(x,y,z), r));\n            float t = iTime*0.7;\n            vec3 src;\n            vec3 dst;\n            if (-sin(t) > 0.0) {\n                src = vec3(x-(l*sin(t)),y-(l*sin(t)),(x-(l*sin(t)))*(y-(l*sin(t))));\n            \tdst = vec3(x+(l*sin(t)),y+(l*sin(t)),(x+(l*sin(t)))*(y+(l*sin(t))));\n            }\n            else {\n                src = vec3(x-(l*sin(t)),y+(l*sin(t)),(x-(l*sin(t)))*(y+(l*sin(t))));\n                dst = vec3(x+(l*sin(t)),y-(l*sin(t)),(x+(l*sin(t)))*(y-(l*sin(t))));\n            }\n            dist = min(dist, capsule_SDF(sample_point, src, dst, 0.05));\n        }\n    }\n    return dist;\n}\n\n\n/*\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/*\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//----------------------- Lighting functions -----------------------//\n\n\n/*\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n/*\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p); // vector from point on surface to the light\n    vec3 V = normalize(eye - p); // vector from camera to point on surface\n    vec3 R = normalize(reflect(L, N));\n    \n    float dotLN = max(0.0, dot(N, L));\n    float dotRV = max(0.0, dot(R, V));\n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n/*\n * Lighting (using Phong illumination in this example.)\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n */\nvec3 lighting(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);  \n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0, 2.0, 4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0,2.0,2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    \n    return color;\n}\n\n//----------------------- MAIN -----------------------//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Determine the direction to ray march along.\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    // Location of the camera (eye).  \n    vec3 eye = vec3(0.0, 0.0, 20.0); \n    // Rotate the camera and view direction.\n    mat4 R = rotation_about_axis(vec3(1,-1,0), 2.0*PI*iTime*0.0);\n    eye = (R*vec4(eye,1.0)).xyz;\n    dir = (R*vec4(dir,1.0)).xyz;\n    \n    // Do ray-marching.\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); // background\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    // Compute lighting at that point.\n    vec3 k_a = vec3(1.0, 0.7, 0.2); // ambient \n    vec3 k_d = vec3(0.9, 0.2, 0.7); // diffuse\n    vec3 k_s = vec3(1.0, 1.0, 1.0); // specular\n    float shininess = 5.0;\n    vec3 color = lighting(k_a, k_d, k_s, shininess, p, eye);\n    \n    // Add \"flashes of white light\"\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime/0.7; float travel = 7.0*sin(0.5*t-PI/2.0);\n    vec2 A = vec2(1.0+travel, travel); vec2 B = vec2(travel, 1.0+travel);\n    float pulse = dist_from_line(uv, A, B); pulse = 1.0/(1.0+pow(pulse,10.0));\n    color += vec3(pulse, pulse, pulse);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 303, 353, 353, 964], [967, 967, 988, 988, 1022], [1024, 1024, 1070, 1070, 1277], [1338, 1433, 1496, 1496, 1549], [1551, 1718, 1772, 1772, 1899], [1902, 2141, 2176, 2622, 3535], [3538, 3958, 4049, 4049, 4355], [4370, 4623, 4688, 4688, 4820], [4895, 4983, 5012, 5012, 5327], [5330, 5749, 5889, 5889, 6278], [6281, 6598, 6674, 6674, 7300], [7302, 7361, 7418, 7469, 8798]]}
{"id": "wlsBRl", "name": "Square Wheels", "author": "athibaul", "description": "Who said square wheels don't work?", "tags": ["2d", "geometry", "gear", "tangent", "humor"], "likes": 8, "viewed": 98, "published": "Public", "date": "1597498682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A funny little car with square wheels.\n//\n// https://mathcurve.com/courbes2d.gb/engrenage/engrenage2.shtml\n// http://aesculier.fr/fichiersMaple/rouesdroles/rouesdroles.html\n// https://en.wikipedia.org/wiki/Square_wheel\n\nvec2 uv;\nfloat T = 2.*asinh(1.);\n\nfloat ZeroSet(float f, float linewidth)\n{\n    vec2 grad = vec2(dFdx(f), dFdy(f));\n    float pxSize = max(length(grad), fwidth(uv.y));\n    return clamp(linewidth-abs(f)/pxSize, 0., 1.);\n}\nfloat Fill(float f) {\n    vec2 grad = vec2(dFdx(f), dFdy(f));\n    float pxSize = max(length(grad), fwidth(uv.y));\n    return clamp(max(-f, 0.)/pxSize, 0., 1.);\n}\nfloat ZeroSet(float f) { return ZeroSet(f, 2.); }\nfloat Point(vec2 x) { return ZeroSet(length(x), 5.); }\n\nfloat Segment(vec2 a, vec2 b, vec2 p)\n{\n    float h = clamp(dot(p-a,b-a) / dot(b-a,b-a), 0., 1.);\n    float d = length(p-a - h*(b-a));\n    return ZeroSet(d);\n}\n\nfloat wheel(float x0)\n{\n    float x0p = x0 - T*round(x0/T);\n    vec2 q1 = vec2(x0, 0.);\n    vec2 rot = normalize(vec2(1., -sinh(x0p)));\n    vec2 uvp = mat2(rot.x, rot.y, rot.y, -rot.x) * (uv-q1);\n    vec2 tmp = abs(uvp)-1.;\n    float box = length(max(tmp,0.)) + min(max(tmp.x,tmp.y),0.);\n    return box;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set coordinates to [-1.,1.] vertically, and a little bit more\n    // horizontally.\n    uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // Scale and pan to taste\n    uv *= 3.;\n    uv.y += 1.;\n    float xcar = 2.*(iTime - 2.1*cos(iTime/2.));\n    uv.x += xcar;\n    \n    // Periodize the road\n    float xp = uv.x - T*round(uv.x/T);\n    // The road is piecewise given by the cosh function\n    float fx = -cosh(xp);\n    \n    // Draw the wheels\n    float x0 = xcar - T*1.25;\n    float x1 = xcar + T*1.25;\n    float wh0 = wheel(x0);\n    float wh1 = wheel(x1);\n    \n    // Draw the car\n    vec2 carc = vec2(xcar, 1.);\n    vec2 carr = vec2(3.5, 1.7);\n    float car = length((uv-carc)/carr) - 1.;\n    \n    vec3 col = vec3(0.95,0.94,0.9);\n    //col = mix(col, vec3(0.8), ZeroSet(uv.y));\n    col = mix(col, vec3(0.6, 0.8, 0.9), Fill(10.*car));\n    col = mix(col, vec3(0.1, 0.5, 0.6), ZeroSet(10.*car));\n    col = mix(col, vec3(0.5,0.9,0.7), Fill(wh0));\n    col = mix(col, vec3(0.,0.7,0.4), ZeroSet(wh0));\n    col = mix(col, vec3(0.5,0.9,0.7), Fill(wh1));\n    col = mix(col, vec3(0.,0.7,0.4), ZeroSet(wh1));\n    col = mix(col, vec3(0.), Point(vec2(x0,0.)-uv));\n    col = mix(col, vec3(0.), Point(vec2(x1,0.)-uv));\n    col = mix(col, vec3(1.,0.,0.), 0.2*ZeroSet(uv.y));\n    col = mix(col, vec3(0.), 0.5*Fill(uv.y - fx));\n    col = mix(col, vec3(0.), ZeroSet(fx - uv.y));\n    \n    // Output to screen\n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 257, 298, 298, 443], [444, 444, 465, 465, 605], [606, 606, 630, 630, 655], [656, 656, 677, 677, 710], [712, 712, 751, 751, 871], [873, 873, 896, 896, 1178], [1180, 1180, 1237, 1327, 2703]]}
{"id": "wlSBRW", "name": "Ray Marching with Simplex Noise", "author": "gunthern", "description": "from Art of Code \"Ray Marching for Dummies\" video and Simplex Noise function found in Book of Shaders ch. 11.", "tags": ["3d", "raymarching", "noise", "simple"], "likes": 3, "viewed": 48, "published": "Public", "date": "1598388117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n//snoise from book of shaders ch.11\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//following functions from art of code \"ray marching for dummmies\" video\nfloat getDist (vec3 p){\n\tvec4 s = vec4(0.,1.,5.,1.);\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat rayMarch (vec3 ro, vec3 rd) {\n\tfloat d0 = 0.;\n    for (int i = 0; i < MAX_STEPS; i++){\n    \tvec3 p = ro + rd * d0;\n        float ds = getDist(p);\n        d0 += ds;\n        if (d0>MAX_DIST || ds<SURF_DIST) break;\n    }\n    return d0;\n}\n\nvec3 getNormal (vec3 p){\n    float d = getDist(p);\n    vec2 e = vec2(.01,0.);\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight (vec3 p, vec2 uv){\n\tvec3 lightPos = vec3(0.,5.,6.);\n    lightPos.xz += vec2(sin(iTime),cos(iTime)) * 6.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diff = dot(n, l);\n    diff = clamp(diff, 0., 1.);\n    \n    float d = rayMarch(p+n*(SURF_DIST+.0001),l);\n    if(d<length(lightPos-p)) diff *= .1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n   \n    ////CAMERA////\n    //ray origin\n    vec3 ro = vec3(0.,1.,0.);\n    //ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float diff = getLight(p, uv);\n    \n    col = vec3(diff / snoise(p.xz * (tan(iTime*.025) - cos(iTime*.04))), diff / snoise(p.xz * (sin(iTime*.01) * cos(iTime*.03)))*.1,diff);\n        \n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 104, 125, 125, 172], [173, 173, 194, 194, 241], [242, 242, 264, 264, 299], [301, 301, 323, 323, 1371], [1373, 1446, 1469, 1469, 1637], [1639, 1639, 1674, 1674, 1879], [1881, 1881, 1905, 1905, 2092], [2094, 2094, 2127, 2127, 2467], [2469, 2469, 2526, 2577, 3099]]}
{"id": "wlsBRX", "name": "Raymarching Pebbles", "author": "athibaul", "description": "Just raymarching a scene with pebbles, for fun and for learning about microfacet-based BRDFs.", "tags": ["raymarching", "texture", "heightmap", "stone"], "likes": 17, "viewed": 209, "published": "Public", "date": "1597355377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Just a little raymarching exercise\n// Main idea stolen from Shane\n// https://www.shadertoy.com/view/ldtGWj\n\n\nfloat height(vec3 point)\n{\n    return texture(iChannel0, point.xy).r;\n}\n\nfloat height2(vec3 point)\n{\n    return texture(iChannel0, point.xy).r + 0.08*texture(iChannel1, point.xy).r;\n}\n\nfloat map(vec3 point)\n{\n    // Approx distance from the modified plane\n    return 1. - point.z - 0.1*height2(point);\n}\n\nfloat curvature(vec3 pos, float dist)\n{\n    // Approximate curvature of the heightmap, for AO\n    vec2 e = vec2(dist, -dist);\n    return (\n        height(pos + e.xyy)\n        + height(pos + e.yyx)\n        + height(pos + e.yxy)\n        + height(pos + e.xxx)\n        - 4.*height(pos)\n        );\n}\n\nfloat calculateAO(vec3 pos)\n{\n    return clamp(1. //- pow(1.-height(pos), 3.)\n        - curvature(pos, 0.003)*8.\n        - curvature(pos, 0.02)*.7\n        - curvature(pos, 0.1)*.3,\n                 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat phongSpecular(in vec3 l, in vec3 normal, in vec3 v, float ap, float f0)\n{\n    // Phong specular BRDF\n    // Formulae from \n    // https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n    \n    vec3 h = normalize(l+v); // Half-vector\n    float dp = (ap+2.)/(2.*3.1416)*pow(dot(normal, h), ap); // microfacet distribution function\n    float gct = 1./dot(l,h); // Approximate Cook-Torrance geometry function\n\t// Schlick approximation of Fresnel reflectance\n    float fresnel = f0 + (1.-f0)*pow(1.-dot(l,h),5.);\n    \n    return dp*gct*fresnel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in y, wider in x)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n  \tuv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float theta = cos(iTime*0.2);\n    // Ray direction\n    vec3 ray = normalize(vec3(uv.x, uv.y, 3.0));\n    ray.xy = mat2(cos(theta), sin(theta), -sin(theta), cos(theta)) * ray.xy;\n    \n    // Camera position\n    vec3 cam = vec3(iTime*0.1, 0.2*cos(iTime*0.5), 0.);\n    //vec3 cam = vec3(0.);\n    \n    // Raymarch to the surface of the heightMap\n    float d, t=0.;\n    for(int j=0; j<32; j++){\n        d = map(cam + t*ray);\n        if(d < 0.001) break; // Can't go any further\n        t += d*0.3;\n    }\n    vec3 sp = cam + t*ray;\n    vec3 normal = getNormal(sp);\n    vec3 diffuse = texture(iChannel1, sp.xy).rgb;\n    float ao = calculateAO(sp);\n    \n    // The light is near the camera\n    vec3 light = cam + 0.3*vec3(cos(iTime*3.), sin(iTime), -1.);\n    vec3 li = normalize(light - sp);\n    float ldist = length(light - sp);\n    diffuse *= dot(li, normal)/(ldist*ldist) * 2.5;\n    float specular = phongSpecular(-ray, normal, li, 60., 0.2);\n    \n    \n    \n    // Output to screen\n    //fragColor.rgb = (vec3(1)+normal)*.5;\n    //fragColor.rgb = diffuse;\n    //fragColor.rgb = vec3(ao) * diffuse;\n    //fragColor.rgb = vec3(specular);\n    \n    fragColor.rgb = vec3(ao) * (diffuse + 0.2*vec3(specular));\n    float lum = length(fragColor.rgb);\n    //fragColor.rgb = fragColor.rgb * (1.-exp(-lum))/lum * 1.4; // Custom tone mapping\n\t\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 112, 138, 138, 183], [185, 185, 212, 212, 295], [297, 297, 320, 367, 415], [417, 417, 456, 510, 711], [713, 713, 742, 742, 921], [923, 962, 993, 993, 1194], [1196, 1196, 1275, 1434, 1792], [1794, 1794, 1851, 1919, 3363]]}
{"id": "WlsBWH", "name": "Sphere ray march 1.1", "author": "Andrew3086", "description": "Simple example of ray marching", "tags": ["raymarching"], "likes": 3, "viewed": 109, "published": "Public", "date": "1597768943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MIN_DIST 0.01\n#define MAX_DIST 200.0\n\nfloat smin(float a, float b, float k) {\n \tfloat h = max(min(0.5 + 0.5 * (b - a) / k, 1.0), 0.0);\n    return a * h + b * (1.0 - h) - k * h * (1.0 - h);\n}\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat getDist(vec3 p) {\n    //p.xyz = asin(sin(p.xyz));\n    vec4 sphere = vec4(sin(iTime), cos(iTime), -1.0 * sin(iTime), 0.5);\n\tfloat sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = p.z + 1.0;\n    //return sphereDist;\n    float tmp = smin(sphereDist, planeDist, 0.5);\n    tmp = smin(box(p - vec3(0.0, 0.0, -1.0), vec3(2.0, 2.0, 0.1)), tmp, 0.5);\n    return tmp;\n    //return min(sphereDist, planeDist);\n    //return sphereDist;\n}\n\n\nfloat rayMarch(vec3 r0, vec3 rd) {\n\tfloat d0 = .0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = r0 + d0 * rd;\n        float ds = getDist(p);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < MIN_DIST) break;\n    }\n\treturn d0;\n}\n\nvec3 getNormal(vec3 p) {\n \tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    return normalize(n);  \n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(5, 5, 20);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float dif = dot(n, l);\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;    //текущий пиксель в координатах [x,y], где y=(-0,5;0.5), а \"x\" - от минус половины отношения разрешения по ширине к разрешению по высоте до плюс половины того же отношения\n\n    float zoom = 1.0;                                              //множитель увеличения изображения\n    \n    vec3 r0 = vec3(5.0 * cos(0.5 * iTime), 5.0 * sin(0.5 * iTime), 2);    //координаты камеры\n    vec3 lookat = vec3(0, 0, 0);                                   //точка, на которую \"смотрит\" камера\n    vec3 f = normalize(lookat - r0);                               //нормализованный вектор, направленный от заданной точки на камеру\n    vec3 r = cross(f, vec3(0.0, 0.0, 1.0));                        //векторное произведение нормали к камере - определяет перпендикулярный к нормали камеры вектор\n \tvec3 u = cross(r, f);                                          //определяет третий перпендикуляр. Тем самым, получаем тройку взаимно перпендикулярных векторов\n    vec3 c = r0 + f * zoom;                                        //вектор, нормальный к камере, пущенный из точки, в  которой камера находилась (и масштабируемый на величину \"зума\")\n\tvec3 i = c + uv.x * r + uv.y * u;                              //вектор (радиус-вектор), который указываает на очередную точку экрана перед камерой для трассеровки луча в этом направлении.\n    \n    vec3 rd = i - r0;                                              //а это уже сам вектор, направленный из камеры на очередной пиксел экрана (причем, каким-то волшебным образом, уже нормализованный)\n    float dist = rayMarch(r0, rd);                                 //вычисление дистанции до ближайшего объекта \n    \n    vec3 p = r0 + rd * dist;                                       //а это точка, в которую уперается очередной луч\n    float dif = getLight(p);                                       //модель освещения, куда же без нее\n    vec3 col = vec3(dif);\n    //vec3 matOne = texture(iChannel0, p.xy).xyz;\n    //matOne *= 1.6 * matOne;\n    //col *= matOne;\n   \n\t\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 107, 107, 220], [221, 221, 248, 248, 289], [291, 291, 314, 346, 743], [746, 746, 780, 780, 986], [988, 988, 1012, 1012, 1199], [1201, 1201, 1225, 1225, 1376], [1378, 1378, 1435, 1435, 4335]]}
{"id": "WlsBWr", "name": "nice sin", "author": "curiouspers", "description": "nice sin?", "tags": ["sin"], "likes": 18, "viewed": 474, "published": "Public API", "date": "1596542501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Raymarching part from \"Sphere Gears - Step 1\" by iq. https://shadertoy.com/view/ws3GD2\n// 2020-08-03 19:04:37\n\n// Created by curiouspers 04/08/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// set AA 2 if you have beafy pc\n#define AA 2\n#define OPTIMIZE 1\n\n// not worth it, too different look\n#define SIMPLERAO 0\n#define ORTHOANIM 0\n\n// #define SDBOX( p, r ) (  length(max(abs(p)-r,0.)))\n\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdBox( in vec3 p, in vec3 r )\n{\n    vec3 d = abs(p)-r;\n    return length(max(d,0.));\n}\nfloat displacement(in vec3 p, in float force){\n\treturn (sin(force*p.z*1.0)/2.) / force;\n}\n\nvec4 map( in vec3 p, float time )\n{\n    vec3 boxSize = vec3(0.03, 0.2, 0.4);\n    vec3 start = vec3(0.32,-0.1,0.0);\n    vec3 dif = vec3(0.08,0.0,-0.015);\n    float d = 0.1;\n    \n    p -= start;\n    \n    #if OPTIMIZE\n    // bounding box\n    float bbox = sdBox( p+vec3(0.495,-0.09,0.), vec3(0.54, 0.2, 0.65) );\n    if (bbox < 0.05){\n    #endif\n        \n    float t = iTime*1.75;\n    float an1 = smoothstep(0.0,1.0,(sin(t+10.26)*.5+.6));\n    an1 *= an1;\n    float an2 = smoothstep(0.0,1.0,(sin(t+0.6)*.5+.6));\n    an2 *= an2;\n    float an3 = smoothstep(0.0,1.0,(sin(t+42.745)*0.5+0.6));\n    an3 *= an3;\n    float an4 = smoothstep(0.0,1.0,(sin(t+0.345)*0.5+0.6));\n    an4 *= an4;\n    float an5 = smoothstep(0.0,1.0,(sin(t+142.745)*0.6+0.6));\n    an5 *= an5;\n    float an6 = smoothstep(0.0,1.0,(sin(t+2.135)*0.6+0.6));\n    an6 *= an6;\n    float an7 = smoothstep(0.0,1.0,(sin(t+3.956)*0.7+0.6));\n    an7 *= an7;\n    float an8 = smoothstep(0.0,1.0,(sin(t+1.3)*0.7+0.6));\n    an8 *= an8;\n    \n\t#if 0\n    p.z = p.z*(0.8*smoothstep(0.0,1.0,(sin(t/4.)*2.6+.0)));\n\t#else\n\tp.z = p.z*0.8;\n\t#endif\n    vec3 q = p;\n    \n\n    for(float i=0.01; i<13.; i+=1.){\n        q=p+dif*i;\n        \n        #if OPTIMIZE\n        float bbox = sdBox( q +vec3(0.,-0.1,0.), vec3(boxSize.x, boxSize.y*1.0, boxSize.z) );\n        //d = min(d, bbox);\n        if (bbox >= 0.064){\n            continue;\n        }\n        #endif\n        \n        float h = hash(i*i/3.);\n        float h2 = hash(h*i/3.);\n        float c2 = mod(i-0.01, 2.);\n        float c3 = mod(i-0.01, 3.);\n        float c4 = mod(i-0.01, 4.);\n        float c5 = mod(i-0.01, 5.);\n        float c6 = mod(i-0.01, 6.);\n        vec3 qd = q+vec3(0.,0.,0.1)*h;\n        \n        if (i<1.){\n            q.y += displacement(q, 40.)*0.8;\n            float dis = displacement(qd+vec3(0.,0.,1.), 30.)*1.0 ;\n            q.y += dis+dis*an1;\n            q.y += \t\tdisplacement(qd+vec3(0.,0.,0.2), 60.)*1.0 * an3;\n\t\t} else {\n            q.y += (displacement(qd+vec3(0.,0.,1.2*h2), 20.)*0.9) ;\n            q.y += (displacement(qd+vec3(0.,0.,1.1*h),  20.)*an4*1.0) * c2 ;\n            q.y += (displacement(qd+vec3(0.,0.,1.9*h2), 20.)*an5*0.5) * c3;\n            q.y += (displacement(qd+vec3(0.,0.,1.5*h),  30.)*an6*0.7) * c4;\n            q.y += (displacement(qd+vec3(0.,0.,6.2*h),  30.)*an7*0.4) * c5;\n            q.y += (displacement(qd+vec3(0.,0.,2.2*h),  40.)*an8*0.3) * c6;\n    \t}\n        q.y += smoothstep(0.9,1.1,abs(q.z+dif.z)/boxSize.z)/10.; // edges\n        float d2 = sdBox( q, boxSize);\n        d = min(d, d2);\n        \n        // if hit box in front - skip all next boxes\n        #if OPTIMIZE\n        if (d2<0.0135)\n            break;\n        #endif\n    }\n\t\n    #if OPTIMIZE\n    }\n    #endif\n\n    //d = min(bbox,d);\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    #if SIMPLERAO\n    int   a = 3;\n    float b = 1.;\n    #else\n    int   a = 5;\n    float b = 4.;\n    #endif\n    \n    for( int i=ZERO; i<a; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/b;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 1.9;\n    float tmax = 3.1;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time)/2.;\t\t\t//hack\n        if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\n\t    // camera\t\n        float an = 1.0;// 6.2831*time/40.0;\n        vec3 ta = vec3( 0.0, 0.1, 0.0 )*1.9;\n    \tvec3 ro = vec3(1., 1.2, 2.);// ray origin (camera pos)\n    \t//ro = vec3(0., 1.2, 2.);// ray origin (camera pos)\n        //vec3 ro = ta + vec3( 0.5*cos(an), 0.2, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0. );\n        \n        // ray direction\n        float fl = 4.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n    #if !ORTHOANIM\n    float f = 0.56;\n\t#else\n\tfloat f = iMouse.x/iResolution.x;\n    #endif\n        \n    vec3 rd_orth = setCamera(ro, ta, 0.)*normalize(vec3(0., 0., 1.0));// ray direction via orthographic projection\n    rd = mix(rd, rd_orth, f);\n\n    #if ORTHOANIM\n    float orthRectSize = .0 + 3.0*iMouse.y/iResolution.y;\n    vec3 ro_orth = ro + vec3(p * orthRectSize, 0.);// ray origin \n    ro = mix(ro, ro_orth, f);\n    #endif\n        \n\n        // background\n        vec3 bcol = vec3(0.01, 0.7, 1.0);\n        vec3 tcol = vec3(0.71, 0.35, 0.87)-0.25;\n        vec3 col = mix(bcol, tcol, p.y*.5+0.5 /*1.0+rd.y*/);//vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        \n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n            vec3 l = vec3(2.0,1.0,-1.);\n            float ndl = dot(nor,l)*.4+.6;\n            vec3 amb = col*.5;\n            float rim = (dot(rd,nor)*.5+.5);\n            rim = clamp(0.0,1.0,(pow(rim,1.)));\n            float invRim = 1.0-rim;\n            invRim*=invRim*invRim*invRim;\n                        \n            float y = tuvw.y;\n            y = y*y*8.5;\n            y += 2.0;\n            y /= 3.0;\n            tcol = vec3(0.823, 0.686, 0.992)*0.8;\n\t\t\tcol = mix(bcol, tcol, y);\n            \n            col = col*ndl+amb;\n            col *= col + sin(tuvw.yyy*3000.)*col*0.9*invRim * nor.y + rim;\n            \n    #if SIMPLERAO\n            float ao = calcAO( tuvw.yzw, nor, time )*1.5;\n            ao += 3.0*ao*(1.-nor.y); // top\n            float side = nor.x*(1.-ao)*.8;  // side\n            ao += side;\n            ao *= ao;\n            col = mix(col,col*ao/.9,0.6);\n    #else\n            float ao = calcAO( tuvw.yzw, nor, time )*1.2;\n            ao += 2.0*ao*(1.-nor.y); // top\n            ao += nor.x*(1.-ao)*.2;  // side\n            col = mix(col,col*ao/.9,0.6);\n    #endif\n            \n            // color correction\n            col *= 0.5;\n            col *= col + nor.y*0.4;\n            //col = vec3(ao);\n        }\n            \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma        \n    tot = pow(tot,vec3(0.45) );\n    \n    // cheap dithering to remove banding\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    // show banding\n    #if 0\n    tot = floor(tot*255.)/255.;\n    tot = (abs(dFdy(tot))+abs(dFdx(tot)))*200.0;\n    #endif\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsBWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[383, 438, 464, 464, 503], [505, 505, 542, 542, 597], [598, 598, 644, 644, 687], [908, 3477, 3524, 3524, 3733], [3735, 3735, 3792, 3792, 4169], [4171, 4171, 4228, 4228, 4497], [4499, 4499, 4551, 4551, 4728]]}
{"id": "WlSBzR", "name": "大龙猫 - Quicky#043", "author": "totetmatt", "description": "-T'a du jungle la? \n  - Ouai ya tarzan et jane qui viennent d'atterrir par la 1er liane du matin", "tags": ["quicky"], "likes": 2, "viewed": 315, "published": "Public API", "date": "1598134287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nFunction from IQ website and http://mercury.sexy/\nBased on Flopine last stream\n*/\n#define ITER 64.\n#define PI 3.141592\n#define beat iTime\n#define acc 2.\n#define ttime (floor(beat)+pow(fract(beat),.5))\n#define pal(x) palette( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\nstruct obj{\n    float d;\n    int mat;\n    vec3 col;\n};\nvec3 palette(float t,vec3 a,vec3 b,vec3 c,vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 iri(vec3 c, vec3 n, vec3 rd, vec3 col){\n    float fresnel = max(1.-dot(n,rd),0.);\n    c += pal(fresnel+length(col));\n     \n    return c;\n}\nvoid mo(inout vec2 p,vec2 d){\n  p = abs(p)-d;\n  if(p.y>p.x) p = p.yx;\n}\nfloat box(vec3 p, vec3 c,float sm){\n    return length(max(abs(p)-c, 0.))-(sm);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nobj liane(vec3 p){\n\n  p.yz*=r(PI/2.+sin(iTime+(p.z*.3)*.5)*.1);\n\n     p.xz *=r(+p.y*.1+cos(p.y*.1+iTime*.15));\npModPolar(p.xz,10.);\n  p.x-=sin(ttime+p.y*.4+atan(p.x,p.y)*2.)*.5+.5;\n  p-=vec3(1.51,.0,.0);\n   p.xz *=r(sin(p.y*2.+iTime));\n   \n   pModPolar(p.xz,3.);\n\n    float cd = box(p,vec3(.2,20.2,.2),.0);\n    if(sin(p.z*10.+p.y*.9+iTime*3.)>=.9){\n     return obj(cd,1,vec3(.5,0.5,-0.0));\n    }else\n    return obj(cd,2,vec3(0.1,0.9,0.3));\n}\nobj fig(vec3 p){\n     p.z-=7.;\n     p.xy *=r(iTime);\n     pModPolar(p.xy,3.);\n     p.yz *=r(-iTime);\n     mo(p.xy,vec2(4.9));\n     mo(p.yz,vec2(0.5));\n    float cd = box(p,vec3(.5,.7,.1),.1);\n    cd = abs(cd)-.1;\n    return obj(cd,1,vec3(-0.50,.9,-.1)*.2);\n}\nobj mino(obj a, obj b){\n    if(a.d < b.d) return a;\n    return b;\n}\n\nobj SDF(vec3 p) {return mino(liane(p),fig(p));}\n\n\nvec3 norm(vec3 p){\n    vec2 eps = vec2(.0001,0.);\n    return normalize(SDF(p).d - vec3(   SDF(p-eps.xyy).d,\n                                        SDF(p-eps.yxy).d,\n                                        SDF(p-eps.yyx).d) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro =vec3(0.,0.,-7.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n   \n     \n    obj O ;\n    bool hit = false;\n    float shad;\n    float t=0.;\n    for(float i=0.;i < ITER; i++) {\n        p = ro + t*rd;\n        O = SDF(p);\n        if(O.d< 0.01) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        t+=O.d;\n    }\n    \n    if(hit) {\n        vec3 n = norm(p);\n        if(O.mat == 1) col = iri(O.col,n, rd, vec3(.0,.34,.60)); \n   \n        if(O.mat == 2) col =  O.col*(1.-shad);\n    \n    }\n\n    fragColor = vec4(clamp((col),0.,1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 362, 414, 414, 457], [460, 460, 476, 476, 534], [536, 536, 580, 580, 679], [680, 680, 709, 709, 751], [752, 752, 787, 787, 832], [834, 834, 884, 884, 1146], [1148, 1148, 1166, 1166, 1589], [1590, 1590, 1606, 1606, 1848], [1849, 1849, 1872, 1872, 1916], [1918, 1918, 1935, 1935, 1965], [1968, 1968, 1986, 1986, 2196], [2198, 2198, 2253, 2253, 2923]]}
{"id": "wlSBzW", "name": "Border Ripple effect", "author": "Darkimage", "description": "Simple ripple effect that stops at borders, not optimized.", "tags": ["2d", "distancefield", "rippleeffect"], "likes": 2, "viewed": 210, "published": "Public API", "date": "1598393078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created by Luca Faggion \n\nconst float maxsize = 1.1;\nconst float offset = 0.05;\nconst float speed = 1.5;\nconst vec2 uvoffset = vec2(0.2,0.2);\nconst bool useDisplacement = true;\nconst bool useMouse = true;\n\n\n//All df function taken from the df master iq\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat displacement(float d1, vec3 p, sampler2D channel, float strength, float tile)\n{\n    float d2 = texture(iChannel0, p.xy*tile).x * strength;\n    return d1+d2;\n}\n\nfloat scene(vec2 uv) {\n    vec3 uvs = vec3(uv,0.);\n    vec3 sphereuvs = vec3(uv - uvoffset,0.);\n    if(useMouse){\n    \tvec2 mouseuv = iMouse.xy/iResolution.yy - vec2((iResolution.x/iResolution.y)/2.,0.5);\n        sphereuvs = vec3(uv - mouseuv,0.);\n    }\n\tfloat scene = 0.;\n    float sphere = sdSphere(sphereuvs, maxsize*(sin(iTime*speed)/2.+0.5));\n    float sphere2 = sdSphere(sphereuvs, maxsize*(sin(iTime*speed)/2.+0.5) + offset);\n    float box = sdRoundBox(uvs, vec3(0.79,0.41,1.0), 0.05);\n    if(useDisplacement){\n    \tsphere2 = displacement(sphere2, uvs, iChannel0, 0.1, 0.7);\n    \tsphere = displacement(sphere, uvs, iChannel0, 0.1, 0.7);\n        box = displacement(box, uvs, iChannel0, 0.04, 01.2);\n    }\n    scene = sphere;\n    scene = opIntersection(scene,box);\n    scene = opSubtraction(scene,sphere2);\n\treturn scene;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) with 1-1 ration (square)\n    vec2 uv = (fragCoord/iResolution.yy) - vec2((iResolution.x/iResolution.y)/2.,0.5);\n    \n    //Render the dfs\n    float render = scene(uv);\n    \n    //Hard Edge Visualization https://www.ronja-tutorials.com/2018/11/10/2d-sdf-basics.html#visualisation\n    float distanceChange = fwidth(render) * 5.; //change the multiply to soften the edges\n    float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, render);\n    \n    //Final output\n    float scenecolor = antialiasedCutoff;\n    fragColor = vec4(scenecolor,scenecolor,scenecolor,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 329, 364, 364, 388], [390, 390, 435, 435, 526], [528, 528, 565, 565, 587], [589, 589, 632, 632, 654], [656, 656, 700, 700, 721], [723, 723, 808, 808, 887], [889, 889, 911, 911, 1717], [1720, 1720, 1777, 1852, 2407]]}
{"id": "wlsfD7", "name": "bg time", "author": "shader_tester", "description": "ewfwe", "tags": ["fsdf"], "likes": 3, "viewed": 73, "published": "Public", "date": "1596945150", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Fractal Brownian Motion\n *\n * Reference: https://thebookofshaders.com/13/\n * \n * See also: http://www.iquilezles.org/www/articles/morenoise/morenoise.htm\n */\n\n#define NUM_OCTAVES 5\n\nconst vec3 color = vec3(0.7, 0.0, 0.0);\n\n\n// Get random value\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Get noise\nfloat noise(in vec2 st)\n{\n    // Splited integer and float values.\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    // -2.0f^3 + 3.0f^2\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// fractional brown motion\n//\n// Reduce amplitude multiplied by 0.5, and frequency multiplied by 2.\nfloat fbm(in vec2 st)\n{\n\tfloat v = 0.0;\n    float a = 0.5;\n    \n    for (int i = 0; i < NUM_OCTAVES; i++)\n    {\n    \tv += a * noise(st);\n        st = st * 2.0;\n        a *= 0.5;\n    }\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate normalized UV values.\n    vec2 st = fragCoord / iResolution.xy;\n        \n    vec2 q = vec2(0.0);\n    q.x = fbm(st + vec2(0.0));\n    q.y = fbm(st + vec2(1.0));\n    \n    // These numbers(such as 1.7, 9.2, etc.) are not special meaning.\n    vec2 r = vec2(0.0);\n    r.x = fbm(st + (1.0 * q) + vec2(1.7, 9.2) + (0.15 * iTime));\n    r.y = fbm(st + (1.0 * q) + vec2(8.3, 2.8) + (0.12 * iTime));\n    \n    // Calculate 'r' is that getting domain warping.\n    float f = fbm(st + r);\n    \n    // f^3 + 0.6f^2 + 0.5f\n    float coef = (f * f * f + (0.6 * f * f) + (0.5 * f));\n    vec3 bg = vec3(23 / 255, 31 / 255, 43 / 255);\n    vec3 bgz = vec3(0, 0, 0);\n    fragColor = vec4(bg + coef * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 251, 277, 277, 353], [355, 368, 393, 434, 808], [810, 910, 933, 933, 1114], [1117, 1117, 1174, 1213, 1882]]}
{"id": "WlsfDl", "name": "the book of shaders voronoi ", "author": "soggymongoose", "description": "voronoi", "tags": ["voronoi"], "likes": 3, "viewed": 118, "published": "Public", "date": "1598138744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 5. \n\nfloat random21 (vec2 uv) {\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43858.5453123);\n}\n\nvec2 random22(vec2 uv) {\n    return fract(sin(vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //divide screen into tiles\n    uv *= scale;\n    vec2 tUV = fract(uv);\n    vec2 tID = floor(uv); \n    \n    float minDist = 1.; //declared early to save during for loop\n    \n    //get closest dist with neighbor checking\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            //calc neighbor \n            vec2 neighbor = vec2(x,y);\n            \n            //calc neighbor point\n            vec2 point = random22(tID + neighbor);\n            \n            //animate point location\n           \tpoint = 0.5 + 0.5*sin(iTime + 3.2831*point); \n            \n            //calc dist between neighbor point and current\n            vec2 diff = (neighbor + point) - tUV; //length(neighbor offset + pos in neighbor - home tile UV)\n            float dist = length(diff); \n            \n            //save smallest dist\n            minDist = min(minDist, dist);\n                \n        }\n    }\n    \n    \n    vec3 col = vec3(minDist);\n\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsfDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 45, 45, 114], [116, 116, 140, 140, 235], [237, 237, 294, 344, 1465]]}
{"id": "wlSfRD", "name": "Neon Boba", "author": "scanlime", "description": "Just a summed particle thing", "tags": ["2d", "simple", "particles", "pink", "green"], "likes": 3, "viewed": 69, "published": "Public", "date": "1598402530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float field(vec2 uv)\n{\n\tfloat o = 1.;\n    for (float dot = 0.; dot < 40.; dot+=1.) {\n        vec2 center = vec2(.1+sin(iTime*.01+3e2+dot), sin(iTime*.02+2e2+dot*1.2))*.5+.5;\n        float r = .02;\n        o *= smoothstep(0.,.1, length(uv-center)-r);\n    }\n    return o;\n}\n\nvec2 gradient(vec2 uv, float f)\n{\n    vec2 ep = vec2(.001, 0.);\n    return vec2(field(uv + ep.xy) - f, field(uv + ep.yx) - f) / ep.x;\n}\n\nvoid mainImage( out vec4 O, in vec2 c )\n{\n    vec2 uv = c/iResolution.xy;\n\tuv.y *= iResolution.y / iResolution.x;\n\n   \tfloat f = field(uv);\n    vec2 grad = gradient(uv, f);\n\tfloat angle = atan(grad.x, grad.y);\n   \n\tf -= dot(grad, grad)*pow(2.-sin(angle*16.-iTime*9.),3.)*4e-5;\n    \n    O = vec4(vec3(f), 1.);\t\n    O.g = sin(O.g*10.);\n    O.r = smoothstep(0.1, 0.6, O.r);\n    O.g = smoothstep(0.2, 0.7, O.g);\n    O.b = smoothstep(0.3, 0.8, O.b);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSfRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 271], [273, 273, 306, 306, 408], [410, 410, 451, 451, 856]]}
{"id": "wlsfRj", "name": "Noise Island", "author": "greenstonedt", "description": "Got inspried by this post https://www.reddit.com/r/proceduralgeneration/comments/i756qa/how_to_procedurally_generate_maps_using_layered/, I translated the code into Shadertoy for further reference.", "tags": ["procedural", "noise"], "likes": 4, "viewed": 94, "published": "Public", "date": "1597315222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright © 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n#define HASHSCALE 0.1031\nfloat hash1D(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash1D(pi), pf), grad(hash1D(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//////////////////////////////////////////////\nfloat map( float value, float low, float high, float destLow, float destHigh ) {\n    return destLow + (value - low) * (destHigh - destLow) / (high - low);\n}\n//////////////////////////////////////////////\n// TODO:\n// Add biodome\n\n\n#define ZOOM_VALUE_1 0.05\n#define SEED 10313.8125\n#define NOISE_MAP_COUNT 5\n#define OFFSET vec2(35.0, 32.0)\n\nfloat FREQUENCIES [NOISE_MAP_COUNT] \t= float [NOISE_MAP_COUNT](0.14,\t\t0.72,\t\t2.15,\t\t6.0,\t\t0.1);\nfloat AMPLITUDE [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](1.1,\t\t-0.35,\t\t0.18,\t\t0.05,\t\t-0.67);\nfloat OFFSETX [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](0.0,\t\t1054.0,\t\t-2525.0,\t5656.0,\t\t-852.0);\nfloat OFFSETY [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](0.0,\t\t655.0,\t\t-781.0,\t\t4324.0,\t\t989.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy * ZOOM_VALUE_1 + iMouse.xy + SEED + OFFSET;\n    \n    float h = 0.0;\n    for (int i =0; i < NOISE_MAP_COUNT; i++) {\n        h += noise( vec2(pos.x * FREQUENCIES[i] + OFFSETX[i], pos.y * FREQUENCIES[i] + OFFSETY[i])) * AMPLITUDE[i];\n    }\n    float checkingH = h;\n    vec2 offsetCoord = pos + fragCoord.xy + vec2(1.3, 0.8) * iTime + SEED + iMouse.xy;\n    if (checkingH < 0.244) {\n        float hMap1 = simplex3d(vec3(offsetCoord * 0.001 * 4.0, iTime * 0.1)) * -0.7;\n        float hMap2 = simplex3d(vec3(offsetCoord * 0.04 * 4.0, iTime / 1000.0 * 0.0));\n        h = (hMap1 + hMap2) * 0.41;\n    } else if (checkingH < 0.339) {\n        float hMap = simplex3d(vec3(offsetCoord * 0.002 * 2.0, iTime * 0.3)) * 0.1;\n        h = checkingH + hMap;\n    }\n    if (h < 0.41 && h > 0.339 && checkingH >= 0.224) {\n        float hMap = simplex3d(vec3(offsetCoord * 0.00001 * 2.0, iTime * 0.19)) * 0.02;\n        h = checkingH + hMap * 0.71;\n    }\n    \n    vec4 color = vec4(1.0);\n    if (h < 0.244) color = vec4(0.24, 0.27, 0.49, 1.0);\n    else if (h < 0.339) color = vec4(0.31, 0.46, 0.72, 1.0);\n    else if (h < 0.41) color = vec4(0.56, 0.87, 0.98, 1.0);\n    else if (h < 0.45) color = vec4(0.98, 0.87, 0.72, 1.0);\n    else if (h < 0.474) color = vec4(0.83, 0.67, 0.58, 1.0);\n    else if (h < 0.81) color = vec4(0.37, 0.50, 0.41, 1.0);\n    else if (h < 0.885) color = vec4(0.82, 0.82, 0.82, 1.0);\n        \n    vec2 cloudOffsetCoord = pos + fragCoord.xy + vec2(5.0, -3.14) * iTime + SEED + iMouse.xy;\n    float cloudMap1 = simplex3d(vec3(cloudOffsetCoord * 0.01 * 0.5, iTime * 0.02)) * 1.0;\n    float cloudMap2 = simplex3d(vec3(cloudOffsetCoord * -0.1 * 0.5, iTime * 0.1)) * -0.1;\n    float cloudMap = clamp(cloudMap1 + cloudMap2, 0.0, 1.0);\n        \n   \tvec4 cloudColor = vec4(0.3, 0.3, 0.3, 0.43);\n    if (cloudMap < 0.31) cloudColor = vec4(1.0, 1.0, 1.0, 0.0);\n    else if (cloudMap < 0.48) cloudColor = vec4(1.00, 1.00, 1.00, 0.12);\n    else if (cloudMap < 0.75) cloudColor = vec4(0.57, 0.57, 0.57, 0.25);\n        \n    vec3 finalColor = cloudColor.xyz * cloudColor.w + color.xyz * (1.0 - cloudColor.w);\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfRj.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1343, 1364, 1389, 1511], [1513, 1513, 1539, 1539, 1903], [1930, 1930, 1953, 1953, 2070], [2072, 2072, 2093, 2093, 2128], [2130, 2130, 2163, 2163, 2223], [2225, 2225, 2255, 2255, 2387], [2389, 2462, 2484, 2484, 2657], [2764, 2787, 2812, 3065, 3982], [3984, 4031, 4111, 4111, 4187], [4188, 4767, 4824, 4824, 6992]]}
{"id": "WlsfWS", "name": "circle in circle", "author": "solquemal", "description": "Apollonian casket", "tags": ["fractals2dapollo"], "likes": 3, "viewed": 65, "published": "Public", "date": "1597614381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 space, vec2 center, float amount){\n    return vec2(cos(amount) * (space.x - center.x) + sin(amount) * (space.y - center.y),\n        cos(amount) * (space.y - center.y) - sin(amount) * (space.x - center.x));\n}\n\nfloat reflection(inout vec2 pos, float angle){\n    vec2 normal = vec2(cos(angle),sin(angle));\n    float d = dot(pos, normal);\n    pos -= normal*min(0.,d)*2.;\n    return smoothstep(0.1,0.,abs(d));\n}\nvec3 cosPalette(  float t,  vec3 a,  vec3 b,  vec3 c, vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat apollonian(vec2 z){\n    float s =1.;\n    float PI =3.14;\n    \n    for(int i=0;i<10;i++){\n        float f = 2. / dot(z,z);     \n        z *= f; s *= f;\n        \n        reflection(z,-PI/2.);\n        z= rotate(z,vec2(0.),PI/2.);\n        z.y = 2.*fract(z.y*0.5) - 1.;\n        \n    }\n\n    return (length(z)-.3)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 -1.0) \n        \t\t* vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 pos = uv *1.5;\n    vec4 color;\n    \n    vec3 a = vec3(0.2);  \n    vec3 b = vec3(0.5);  \n    vec3 c = vec3(3.,1.5,2.);     \n     vec3 d = vec3(.1,0.17,0.23); \n    \n    float cir = 1.5-length(pos);\n    float t = min(cir, apollonian(pos));\n    color.rgb = cosPalette(t +iTime*0.041,a,b,c,d);\n\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 224], [226, 226, 272, 272, 423], [424, 424, 487, 487, 530], [532, 532, 557, 557, 849], [851, 851, 908, 908, 1348]]}
{"id": "WlsfzB", "name": "My Black Hole 2 (Modified)", "author": "PierceV32", "description": "Black Hole", "tags": ["singularity"], "likes": 6, "viewed": 125, "published": "Public", "date": "1597067817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//THIS CODE HAS BEEN MODIFIED FROM ITS ORIGINAL SOURCE (THE ORIGINAL IS NOT BY ME)\n\n\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed 2.0  //disk rotation speed\n\n#define _Steps  12. //disk texture layers\n#define _Size 0.3 //size of BH\n\n\n\n//float hash(float x){ return fract(sin(x)*152754.742);}\n//float hash(vec2 x){\treturn hash(x.x + hash(x.y));}\n\nfloat hash(float x){ return fract(sin(x)*15.0); }\nfloat hash(vec2 x){\treturn hash(x.x + hash(x.y)); }\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;\t\n    float b = mix(bl, br, fr.x);\t\n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\nfloat sdSphere(vec3 ray, float r, vec3 pos)\n{\n    return length(ray-pos) - r;\n}\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*3., 100.); //(poor quality) \"stars\" created from value noise\n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    //vec4 nebulae = texture(iChannel0, (uv*1.5 ));\n    //nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    //nebulae.xyz *= 0.25;\n    \n    /*nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n \n\tnebulae.xyz += stars;*/\n\treturn vec4(stars, 1.0);\n}\n\n/*vec4 raymarchSphere(vec3 ray, vec3 zeroPos)\n{   \n    vec3 position = zeroPos;\n    position += dist*_Steps*ray*0.5; \n    \n    vec4 o = vec4(0.);\n    \n    int sphereSteps = 10000;\n    float stepSize = 0.01;\n\n    for(float i = 0. ; i < sphereSteps; i+=1.)\n    {                      \n        position += dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n\t\tfloat angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n        \n        float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    return o ;\n    \n \treturn vec4(0.0);   \n}*/\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.); //no disk\n    \n\tvec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.4 *(1./_Steps) /( abs(ray.y) );\n\n    position += dist*_Steps*ray*0.5;     \n\n    vec2 deltaPos;\n    deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;\n    deltaPos.y = zeroPos.x*0.01 + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= sqrt(lengthPos);\n    parallel *= 0.6;\n    float redShift = parallel +0.4;\n    redShift *= redShift;\n\n    redShift = clamp(redShift, 0., 1.);\n    \n    float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);\n    vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);\n    \n    insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);\n\tinsideCol *= 1.4;\n    redShift += 0.14;\n    redShift *= redShift;\n\n    vec4 o = vec4(0.);\n\n    for(float i = 0. ; i < _Steps; i++)\n    {                      \n        position -= dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1./_Steps) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n\t\tfloat angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n        \n        float extraWidth =  noise * 1. * (1. -  clamp(i * (1./_Steps)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1./_Steps) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    return o ;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 pos = vec3(0.0,0.0,-12.0);  //-12.0\n        vec2 angle = vec2(0.03*iTime,0.12);      \n        float dist = length(pos);\n        Rotate(pos,angle);\n        Rotate(ray,angle);\n\n        vec4 col = vec4(0.); \n        vec4 glow = vec4(0.); \n        vec4 outCol =vec4(100.);\n\n        for(int disks = 0; disks< 32; disks++) //steps\n        {\n\n            for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)\n            {\n                float dotpos = dot(pos,pos);\n                float invDist = inversesqrt(dotpos); //1/distance to BH\n                float centDist = dotpos * invDist; \t//distance to BH\n                float stepDist = 0.92 * abs(pos.y /(ray.y));  //conservative distance to disk (y==0)   \n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n                float invDistSqr = invDist * invDist;\n                float forceK = 0.725; //0.625;\n                float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n                ray =  normalize(ray - (bendForce * invDist )*pos);  //bend ray towards BH\n                pos += stepDist * ray; \n                \n                glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            }\n\n            float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.1) //ray sucked in to BH\n            {\n                outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {                   \n                vec4 bg = background (ray);\n                outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);\n                break;\n            }\n            \n            else if (abs(pos.y) <= _Size * 0.002 ) //ray hit accretion disk\n            {           \n                vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n                pos.y = 0.;\n                pos += abs(_Size * 0.001 /ray.y) * ray;  \n                col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }\n        }\n        \n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 368, 388, 388, 417], [418, 418, 437, 437, 469], [471, 471, 515, 515, 865], [867, 867, 912, 912, 946], [948, 948, 975, 975, 1761], [1763, 3614, 3657, 3699, 6220], [6223, 6223, 6269, 6269, 6423], [6425, 6425, 6479, 6479, 9629]]}
{"id": "wlSfzh", "name": "Murky", "author": "Vectornaut", "description": "One of my ray-marching practice projects from the CODAME shaders workshops, April–May 2020. Playing with lighting and camera movement techniques from the May 16 workshop, \"Explorations in Raymarching.\"", "tags": ["raymarching", "aerialperspective", "atmosphericscattering", "codame"], "likes": 2, "viewed": 62, "published": "Public", "date": "1598291552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// playing with lighting and camera movement techniques from the may 16\n// \"explorations in raymarching\" workshop. i threw in two physics goodies. the\n// halo around the sun comes from a model for scattering off atmospheric haze.\n// the camera orientation is determined from the camera's path by pretending the\n// camera is on an airplane making perfectly banked turns\n\nfloat sphere(vec3 p) {\n    return length(mod(p, vec3(2.)) - vec3(1., 1., 1.)) - 0.2;\n}\n\nconst float PI = 3.141592653589793;\n\nfloat ground(vec3 p) {\n    return p.y - 0.1*(cos(PI*p.x) + cos(PI*p.z)) + 1.1;\n}\n\nfloat scene(vec3 p) {\n    return min(sphere(p), ground(p));\n}\n\nconst float eps = 0.001;\n\nvec3 scene_grad(vec3 p) {\n    vec2 step = vec2(0.02, 0.);\n    return vec3(\n        scene(p + step.stt) - scene(p - step.stt),\n        scene(p + step.tst) - scene(p - step.tst),\n        scene(p + step.tts) - scene(p - step.tts)\n    );\n}\n\nconst int steps = 1024;\nconst float horizon = 60.;\nconst float dust_horizon = 30.;\n\nconst float SQRT2 = sqrt(2.);\nconst float SQRT3 = sqrt(3.);\n\n// sky parameters\nconst float g = 0.6; // scattering anisotropy. runs from 0 to 1\nconst float h = (1.-g)/(1.+g); // the cube root of the scattering phase opposite the sun\nconst float scat_frac = 0.4;\nvec3 sun_color = vec3(1.);\nvec3 sky_base = vec3(0.0, 0.2, 0.3);\n\nfloat dotplus(vec3 a, vec3 b) { return max(dot(a, b), 0.); }\n\n// if we're looking straight at the sun, we see the color of the sun. otherwise,\n// we see a mixture of Mie-scattered sunlight and other skylight.\n//\n// the angular size of the sun, as seen from Earth, is around acos(0.99999). the\n// sun looks small in the scene because we're using a very wide field of view.\n//\n// Mie scattering is scattering off large particles, like atmospheric haze. a\n// scattering process is described by its the phase function, which gives the\n// intensity of scattered light at each scattering angle. i'm using\n// Scratchapixel's approximate phase function for Mie scattering.\n//\n//   https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//\n// i don't know where Scratchapixel got it from, but it's the product of the\n// Rayleigh scattering phase function and the Henyey-Greenstein phase function,\n// an approximate phase function for scattering off interstellar dust.\n//\n//   https://www.oceanopticsbook.info/index.php/view/scattering/the-henyey-greenstein-phase-function\n//\n//   L. G. Henyey and J. L. Greenstein. \"Diffuse radiation in the galaxy\"\n//   https://ui.adsabs.harvard.edu/abs/1941ApJ....93...70H/abstract\n//\nvec3 skylight(vec3 dir, vec3 sun_dir) {\n    float sun_cos = dotplus(dir, -sun_dir);\n    if (sun_cos > 0.99999) {\n        return sun_color;\n    } else {\n        float rayleigh_phase = (1.+sun_cos*sun_cos)/2.;\n        float hg_phase = pow((1.-g)*(1.-g) / (1. - 2.*g*sun_cos + g*g), 1.5);\n        return mix(sky_base, sun_color, scat_frac * rayleigh_phase * hg_phase);\n    }\n}\n\nvec3 radiance(vec3 color, vec3 sky_color, vec3 normal, vec3 view_dir, vec3 sun_dir) {\n    vec3 ambient = color * sky_color;\n    vec3 diffuse = color * sun_color * dotplus(-normal, sun_dir);\n    \n    // `spec_dir` is the viewing direction with the strongest specular highlight\n    vec3 spec_dir = -reflect(sun_dir, normal);\n    vec3 specular = sun_color * pow(dotplus(view_dir, spec_dir), 32.);\n    \n    return ambient + diffuse + specular;\n}\n\nvec3 ray_color(vec3 eye, vec3 dir) {\n    // time-varying sky parameters\n    vec3 sky_color = mix(sky_base, sun_color, scat_frac*h*h*h);\n    vec3 sun_dir = normalize(vec3(cos(iTime/SQRT2), -0.5, sin(iTime/SQRT2)));\n    \n    float r = 0.;\n    for (int cnt = 0; cnt < steps; cnt++) {\n        // find ray position\n        vec3 p = eye + r*dir;\n        \n        // find scene distance\n        float dist = scene(p);\n        \n        // march\n        if (dist < eps) {\n            vec3 normal = normalize(scene_grad(p));\n            vec3 rad = radiance(vec3(1.0, 0.4, 0.5), sky_color, normal, dir, sun_dir);\n            \n            // this is a kludgy way to deal with the fact that the spheres cover\n            // the whole sky. the idea is that faraway spheres act like dust\n            // that contributes to atmospheric perspective, rather than distinct\n            // objects that block out the sky. the implementation probably isn't\n            // very physical; i just picked something that looked all right\n            vec3 atm_color;\n            if (r < dust_horizon) {\n                atm_color = sky_color;\n            } else {\n                atm_color = mix(skylight(dir, sun_dir), sky_color, exp(-0.05*(r-dust_horizon)));\n            }\n            return mix(atm_color, rad, exp(-0.2*r));\n        } else if (r > horizon) {\n            return skylight(dir, sun_dir);\n        } else {\n            r += dist;\n        }\n    }\n    \n    // if you see lime green, we ran out of steps\n    return vec3(0., 1., 0.);\n}\n\nvec3 cam_pos(float t) {\n    return vec3(SQRT3*sin(t), (1.+sin(2.*t)), 6.*t);\n}\n\nvec3 cam_vel(float t) {\n    return vec3(SQRT3*cos(t), 2.*cos(2.*t), 6.);\n}\n\nvec3 cam_accel(float t) {\n    return vec3(-SQRT3*sin(t), -4.*sin(2.*t), 0.);\n}\n\nvec3 ray_dir(vec2 screen_pt, float t) {\n    // let's pretend the camera's on an airplane. point the yaw axis along the\n    // lift vector for a perfect banked turn\n    const vec3 gravity = vec3(0., -120., 0.);\n    vec3 roll_ax = normalize(cam_vel(t));\n    vec3 thrust_lift = cam_accel(t) - gravity;\n    vec3 lift = thrust_lift - dot(roll_ax, thrust_lift)*roll_ax;\n    vec3 yaw_ax = normalize(lift);\n    vec3 pitch_ax = cross(roll_ax, yaw_ax);\n    \n    vec3 screen_dir = normalize(vec3(screen_pt, -1.));\n    return mat3(pitch_ax, yaw_ax, -roll_ax) * screen_dir;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime/6.;\n    vec3 pos = cam_pos(t);\n    float small_dim = min(iResolution.x, iResolution.y);\n    vec2 jiggle = vec2(0.25);\n    vec3 color_sum = vec3(0.);\n    for (int sgn_x = 0; sgn_x < 2; sgn_x++) {\n        for (int sgn_y = 0; sgn_y < 2; sgn_y++) {\n            vec2 screen_pt = 2.*(fragCoord + jiggle - 0.5*iResolution.xy)/small_dim;\n            vec3 dir = ray_dir(screen_pt, t);\n            color_sum += ray_color(pos, dir);\n            jiggle.y = -jiggle.y;\n        }\n        jiggle.x = -jiggle.x;\n    }\n    fragColor = vec4(color_sum/4., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSfzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 370, 392, 392, 456], [495, 495, 517, 517, 575], [577, 577, 598, 598, 638], [666, 666, 691, 691, 901], [1048, 1313, 1344, 1344, 1373], [1375, 2559, 2598, 2598, 2932], [2934, 2934, 3019, 3019, 3375], [3377, 3377, 3413, 3448, 4894], [4896, 4896, 4919, 4919, 4974], [4976, 4976, 4999, 4999, 5050], [5052, 5052, 5077, 5077, 5130], [5132, 5132, 5171, 5295, 5694], [5696, 5696, 5751, 5751, 6315]]}
{"id": "Wlsfzs", "name": "Apollonian wires", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 30, "viewed": 323, "published": "Public", "date": "1597495770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat map(vec3 p)\n{\n\tp.xz*=rot(iTime*.5);\n\tp.xy*=rot(iTime*.5);\n\tfloat s=2.,r2;\n\tp=abs(p);\n    for(int i=0; i<12;i++){\n\t\tp=1.-abs(p-1.);\n        if(fract(iTime*.5)<.7){\n            r2=1.2/dot(p,p);\n        }else{\n            r2=(i%3==1)?1.3:1.3/dot(p,p);\n        }\n    \tp*=r2;\n    \ts*=r2;\n\t}\n\treturn length(cross(p,normalize(vec3(1))))/s-0.003;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n  \tvec3 ro=vec3(\n        mix(8.,3.,sin(iTime*.2+.3*sin(iTime*.5))*.5+.5),\n        mix(-.5,.5,cos(iTime*.1+.5*cos(iTime*.7))*.5+.5),\n        0);\n  \tvec3 w=normalize(-ro);\n  \tvec3 u=normalize(cross(w,vec3(0,1,0)));\n  \tvec3 rd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n    vec3 p;\n    float h=0.,d,i;\n\tfor(i=1.;i<120.;i++)\n    {\n    \tp=ro+rd*h;    \n\t\td=map(p);\n    \tif(d<.0001)break;\n    \th+=d;\n\t}\n    fragColor.xyz=30.*vec3(cos(p*.8)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlsfzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 69, 69, 396], [398, 398, 455, 455, 955]]}
{"id": "WlV3zK", "name": "Raymarching 00", "author": "Toctave", "description": "raymarching tests", "tags": ["raymarching", "test"], "likes": 3, "viewed": 55, "published": "Public", "date": "1597312069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 200\n#define EPSILON 1e-4\n#define END 1e10\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat SphereSDF(vec3 center, float radius, vec3 p) {\n    return length(p - center) - radius;\n}\n\nfloat softAbs(float x, float r) {\n    if (r == 0.) return abs(x);\n    return sqrt(r + pow(x, 2.)) - r;\n}\n\nfloat softMax(float a, float b, float r) {\n    return .5 * (a + b + softAbs(a - b, r));\n}\n\nfloat softMin(float a, float b, float r) {\n    return .5 * (a + b - softAbs(a - b, r));\n}\n\nfloat unionSDF(float d1, float d2, float r) {\n    return softMin(d1, d2, r);\n}\n\nfloat intersectSDF(float d1, float d2, float r) {\n    return softMax(d1, d2, r);\n}\n\nfloat differenceSDF(float d1, float d2, float r) {\n    return softMax(d1, -d2, r);\n}\n\nvec3 camRay(vec3 eye, vec3 lookAt, vec2 uv, float zoom) {\n    vec3 front = normalize(lookAt - eye);\n    vec3 up = vec3(0, 0, 1);\n    vec3 right = normalize(cross(front, up));\n    vec3 top = cross(right, front);\n    \n    return front * zoom + uv.x * right + uv.y * top ;\n}\n\nfloat sceneSDF(vec3 p) {\n    float s1 = SphereSDF(vec3(3., 0., 0.), 2. + sin(iTime + 3.14), p);\n    float s2 = SphereSDF(vec3(0., 0., 0.),  (1.5 + sin(iTime)), p);\n    \n    float d = END;\n    \n    \n    return unionSDF(s2, s1, .5);\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(p + EPSILON * vec3(1, 0, 0)) - sceneSDF(p - EPSILON * vec3(1, 0, 0)),\n        sceneSDF(p + EPSILON * vec3(0, 1, 0)) - sceneSDF(p - EPSILON * vec3(0, 1, 0)),\n        sceneSDF(p + EPSILON * vec3(0, 0, 1)) - sceneSDF(p - EPSILON * vec3(0, 0, 1))\n    ));\n}\n\nfloat march(vec3 eye, vec3 ray, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < STEPS; i++) {\n        float d = sceneSDF(eye + depth * ray);\n        \n        if (d < EPSILON) {\n            return depth;\n        }\n        \n        depth += d;\n        \n        if (depth >= end) {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    float fov = 3.14 * .3;\n    \n    vec3 col = vec3(0);\n    \n    vec3 eye = 20. * vec3(sin(iTime), cos(iTime), 0.);\n    vec3 ray = camRay(eye, vec3(0, 0, 0), uv, 1.);\n    //ray = vec3(uv, 1.);\n    \n    float d = march(eye, ray, 1e-4, END); \n    \n    if (d < END) {\n        col = vec3(normal(eye + d * ray) * .5 + .5);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlV3zK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 78, 78, 209], [211, 211, 263, 263, 305], [307, 307, 340, 340, 411], [413, 413, 455, 455, 502], [504, 504, 546, 546, 593], [595, 595, 640, 640, 673], [675, 675, 724, 724, 757], [759, 759, 809, 809, 843], [845, 845, 902, 902, 1116], [1118, 1118, 1142, 1142, 1350], [1352, 1352, 1373, 1373, 1670], [1672, 1672, 1729, 1729, 2040], [2042, 2042, 2099, 2099, 2525]]}
{"id": "wlXBD4", "name": "Glitchy Merri", "author": "Flopine", "description": "I made this shader during a live set with Lucija/Merristasis for A Bit of Chiptune last concert!\nListen to her work here > https://soundcloud.com/e_z_ra", "tags": ["raymarching", "glitch", "rainbow", "isometric", "live"], "likes": 5, "viewed": 151, "published": "Public", "date": "1596716938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n\n#define BPM (170./60.)\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) sqrt(abs(sin(time(speed)*PI))) \n#define swit(speed) floor(sin(time(speed)*2.*PI)+1.)\n\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(13.1,45.5)))*1284.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat od (vec3 p, float d)\n{return dot (p,normalize(sign(p)))-d;}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat prim1 (vec3 p)\n{\n    return min(\n        max(-sphe(p, 0.95),od(p, 0.8)),\n        max(-(sc(p, 0.9)-0.1),box(p,vec3(1.+bouncy(1.)*0.4))-0.05)\n    );\n}\n\nfloat g1 = 0.;\nfloat prim2 (vec3 p)\n{\n    float d= 1e10;\n    for (int i =0; i<3; i++)\n    {\n        float ratio = (float(i)/4.);\n        mo(p.xz, vec2(0.5));\n        p.x -= 2.;\n        p.yz *= rot(time(0.2)*2.*PI);\n        d = min(d,od(p, 0.5));    \n    }\n    g1 += 0.01/(0.01+d*d);\n    return d;\n}\n\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 pp  = p;\n    \n    moda(p.yz,3.);\n    p.x -= 5.3;\n    float per = 10.;\n    float size = 5.;\n    p = p-per*clamp(round(p/per),-size,size);\n\n    return min(prim2(p),prim1(p));\n}\n\nfloat mask (vec2 uv)\n{return sign(fract(uv.x+0.5*uv.y)-fract(uv.y));}\n\nvec3 pal (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.34,0.66)));}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec2 detail = vec2(2.5, 40.);\n    uv += hash21(floor((uv+time(BPM/4.)*0.)*detail)/detail);\n\n    if (swit(BPM/2.)<= 0.) uv += mask(uv*5.);\n\n    vec3 ro = vec3(uv*15.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,2.,-1.)),\n        col = vec3(0.,0.,0.1);\n\n    bool hit = false; float d = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.1)\n        {\n            hit = true;\n            break;\n        }\n        d = max(abs(d)-0.1,0.5);\n        p += d*rd;\n    } \n\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l), 0.);\n        col = mix(vec3(0.,0.1,0.2),pal(length(p),vec3(.05)),light);\n    }\n    col += g1*0.1;\n\n    fragColor = vec4(sqrt(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 511, 534, 534, 584], [586, 586, 606, 606, 649], [651, 651, 683, 683, 729], [731, 731, 768, 768, 884], [886, 886, 914, 914, 999], [1001, 1001, 1029, 1029, 1066], [1068, 1068, 1098, 1098, 1118], [1120, 1120, 1148, 1148, 1225], [1227, 1227, 1249, 1249, 1381], [1398, 1398, 1420, 1420, 1681], [1684, 1684, 1704, 1704, 1949], [1951, 1951, 1973, 1973, 2020], [2022, 2022, 2050, 2050, 2114], [2116, 2116, 2139, 2139, 2252], [2254, 2254, 2311, 2311, 3209]]}
{"id": "WlXBRj", "name": "Circle Beat Bounce", "author": "JackKalish", "description": "Exercise from Book of Shaders by Patricio Gonzalez Vivo & Jen Lowe\nhttps://thebookofshaders.com/07/\n\nModify the above code in order to contain the entire circular gradient inside the canvas.", "tags": ["circle", "bookofshaders"], "likes": 1, "viewed": 45, "published": "Public", "date": "1597108962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 st, float radius, float s){\n    float pct = distance(st,vec2(0.5)) * 2.;\n    pct = 1.-smoothstep(radius-s,radius+s, pct);\n    return pct;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    float pct = 0.0;\n    \n    st.x *= iResolution.x/iResolution.y;\n    st.x -= .38;\n    \n    float speed = 6.;\n    float radius = (sin(iTime*speed)+1.)*.5; //normalized\n    float doubleTime = (sin(iTime*speed*2.)+1.)*.5;\n    radius += doubleTime*.5;\n    radius += sin(iTime*speed*10.)*sin(iTime*speed)*.5; //vibrate\n    //radius *= radius;\n    \n    //min/max\n    radius += 2.;\n    radius *= .2;\n    \n    float offset = sin(iTime*speed*.5)*.4;\n    \n    st.x += offset;\n    float c1 = circle(st, radius*.8, (1.-radius)*.1);\n\n    //red circle\n    vec3 color = vec3(c1)*vec3(1.,0.1,0.2);\n    \n    //green circle\n    st.x -= offset;\n    float c2 = circle(st, radius, (1.-radius)*.2);\n    color += vec3(c2)*vec3(0.,0.1,0.);\n    \n    //blue circle\n    st.x -= offset;\n    float c3 = circle(st, radius*.8, (1.-radius)*.2);\n    color += vec3(c3)*vec3(0.,0.,1.);\n\n\n\tfragColor = vec4( color, 1.0 );\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 157], [159, 159, 213, 213, 1143]]}
{"id": "wlXBRl", "name": "13. Drive Home 4 - Tail Light", "author": "altera0", "description": "\nSource Link : https://www.youtube.com/watch?v=gKeT6T_bPEE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect", "tags": ["drivehome"], "likes": 5, "viewed": 198, "published": "Public API", "date": "1597426124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE \n/*\nfloat Boke( float d , float lightDiameter , float blur ) {\n    \n      \n\tfloat c = S( lightDiameter , lightDiameter * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( lightDiameter * 0.8f , lightDiameter , d ) );\n    return c;\n} */\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 8389.) * 3862. ) ;\n    return n;\n}\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 2.0f;\n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.1f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// Tail Light\nvec3 TailLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 0.1f;\n    \n    float c = 0.0f;\n    //float t = time * 0.1f;\n    float t = time;\n    \n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\t\t\t// 0 ~ 1\n\t\tif ( n > 0.5f ) continue;\t\t// 0 ~ 0.5\n        \n        \n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n        \n        float lane = step( 0.25f , n );\t// 0 , 1\n        float laneShift = S(0.99f, 0.96f , ti );\n        float carPos = 1.5f - lane * laneShift;\n            \n        float blink = step( 0.0 , sin( t * 10000.0)) * 7.0f * lane * step( 0.9f , ti );\n        \n        c += Boke( ray , vec3( carPos -headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( carPos -headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade * (1.0f + blink);\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( carPos -headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( carPos +headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    \n    vec3 col = vec3( 1.0f , 0.1f , 0.01f) * c;\n    \n    return col;\n}\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0.5f , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0.5f , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= TailLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 129, 196, 196, 666], [669, 673, 723, 868, 949], [952, 956, 1003, 1003, 1088], [1340, 1348, 1425, 1480, 1805], [1810, 1819, 1841, 1841, 1906], [1908, 1924, 2004, 2004, 2537], [2540, 2554, 2633, 2633, 4188], [4191, 4205, 4284, 4284, 6128], [6130, 6138, 6195, 6195, 6962]]}
{"id": "wlXBW8", "name": "RayMarching Lighting Experiments", "author": "Giraugh", "description": "Testing some different lighting effects.\n\n- Phong Specular Highlights\n- Ambient Occlusion\n- Glow", "tags": ["raymarch"], "likes": 0, "viewed": 27, "published": "Public", "date": "1596557295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Simplest Possible Raymarcher */\n/* By Giraugh */\n\n#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 0.01\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    float ss = min(20., iTime)/5.;\n    p *= scale * ss;\n\tfloat g = abs(bias + dot(sin(p), cos(p.zxy))) / (scale * ss);\n    return (g - thickness) / 1.3;\n}\n\n// Return the distance to the nearest point in the scene\n// from (point)\nfloat GetDist(vec3 point) {\n    // Plane SDF at y=0\n    float planeD = point.y;\n    \n    // Sphere SDF at (0, 1, 4) w/ rad 1\n    //float sphereD = length(point - vec3(0, 0, 0)) - 1.;\n    //float sphereD_ = length(point - vec3(-1, 0, 0)) - 1.;\n    \n    //float container = sphereD;\n    //float gyroid = sdGyroid(point, 4., .05, 1.);\n    //return max(gyroid, container);\n    \n    float sphereD = length(point.xz) - 0.3;\n    sphereD += .05 * pow(cos(20. * point.y + iTime), 3.);\n    //sphereD += .15 * abs(point.y);\n    return sphereD / 1.1;\n}\n\n// March a ray forwards into the scene determined by (GetDist)\n// Returns the distance the ray travelled before getting\n// below (SURF_DIST) distance from a surface or too far away\nint ray_march_iters;\nfloat smallest_dist;\nbool did_hit;\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    ray_march_iters = 0;\n    smallest_dist = MAX_DIST;\n    did_hit = false;\n    float d = 0.;\n    for (ray_march_iters = 0; ray_march_iters < MAX_STEPS; ray_march_iters++) {\n        vec3 p = rayOrigin + rayDirection * d;\n        float d_delta = GetDist(p);\n        d += d_delta;\n        if (abs(d_delta) < smallest_dist) smallest_dist = abs(d_delta);\n        if (abs(d_delta) < SURF_DIST) did_hit=true;\n        if (d > MAX_DIST || abs(d_delta) < SURF_DIST) break;\n    }\n    return d;\n}\n\n// Calculate the surface normal at (point)\n// can reduce (off) to improve accuracy\nvec3 GetNormal(vec3 point) {\n    float d = GetDist(point);\n    float off = .01;\n    vec3 n = vec3(\n    \td - GetDist(point - vec3(off,0,0)),\n        d - GetDist(point - vec3(0,off,0)),\n        d - GetDist(point - vec3(0,0,off))\n    );\n    return normalize(n);\n}\n\n// Determine degree of lighting (0 to 1) at (pos) by (lightPos)\nfloat GetLighting(vec3 point, vec3 lightPos) {\n    vec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    float diff = clamp(dot(l, n), 0., 1.);\n    return diff;\n}\n\nfloat GetLightingPhong(vec3 point, vec3 view, vec3 lightPos, float shininess) {\n\tvec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    vec3 r = 2. * n * dot(n, l) - l;\n    \n    if (dot(n, l) < 0.0) {\n        return 0.;\n    } else {\n    \treturn .3 * pow(max(0., dot(r, normalize(-view))), shininess);\n    }\n}\n\nvec3 MouseCameraOrigin(vec3 rayOrigin) {\n\tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n\treturn rayOrigin;\n}\n\nvec3 MouseCameraDirection(vec3 rayDirection) {\n \tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n\treturn rayDirection;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (square) (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    // Declare camera position in terms of ray origin and direction\n    vec3 rayOrigin = MouseCameraOrigin(vec3(0, 0, -3));\n    vec3 rayDirection = MouseCameraDirection(vec3(uv.x, uv.y, 1));\n    \n    // RayMarch to find point\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    // Determine lighting\n    vec3 lightPos = vec3(0, 4, -7);\n    float lighting = GetLighting(hitPoint, lightPos);\n    float highlight = GetLightingPhong(hitPoint, rayDirection, lightPos, 30.);\n\tvec3 col = vec3(lighting + highlight);\n    \n    // Hacky AA\n    col -= 5. * vec3(pow(smoothstep(0., float(MAX_STEPS), float(ray_march_iters)), 1.2));\n    col.r += .4 * sin(hitPoint.y);\n    col.g += .2 * cos(hitPoint.y);\n    \n    // Glow\n    if (!did_hit)\n    col += .1 * vec3(50, 3, 63) * smoothstep(100. * SURF_DIST, SURF_DIST, pow(smallest_dist, 0.15));\n    \n    // Ouput colour at full transparency\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 122, 141, 141, 219], [221, 221, 287, 287, 442], [444, 517, 544, 568, 1057], [1059, 1296, 1347, 1347, 1833], [1835, 1918, 1946, 1946, 2178], [2180, 2244, 2290, 2290, 2425], [2427, 2427, 2506, 2506, 2753], [2755, 2755, 2795, 2795, 3013], [3015, 3015, 3061, 3061, 3333], [3336, 3336, 3393, 3452, 4480]]}
{"id": "wlXBWM", "name": "Line Segment Depth-of-Field", "author": "fizzer", "description": "Modelling the usual volume of jittered rays for sampled depth-of-field as a cone, the sampling integral can be approximated by intersection tests of line segments against this cone. Maybe other DoF-like effects can be done this way too?", "tags": ["wireframe", "landscape", "depthoffield", "analytic"], "likes": 44, "viewed": 491, "published": "Public", "date": "1596913459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159265358979323;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Originally from https://www.shadertoy.com/view/llcfRf\n// Modified to remove the caps and return the whole intersection interval.\nvec2 iCappedCone2( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m3 = dot(rd,ba);\n\n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec2(-1.0);\n\n    return ((vec2(-1, +1) * sqrt(h)) - k1) / k2;\n}\n\n// Originally from https://www.shadertoy.com/view/4lcSRn\n// Modified to remove the caps and return the whole intersection interval.\nvec2 iCylinder2( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    \n    return ((vec2(-1, +1) * sqrt(h)) - b) / a;\n}\n\nfloat dofLine(vec3 c0, vec3 c1, float ra, vec3 p0, vec3 p1)\n{\n    float dlen = length(p1 - p0);\n    vec3 dir = (p1 - p0) / dlen;\n    \n    // Test for intersection of the line segment with the cone of defocused rays.\n    \n    vec2 res = iCappedCone2(p0, dir, c0, c1, ra, 0.);\n    \n    if(res.y < 0. || res.x > dlen)\n    {\n        // To avoid rendering subpixel-sized lines which would end up being heavily under-sampled,\n        // the center of the defocus cone is modelled as a thick cylinder.\n        \n        vec2 res2 = iCylinder2(p0, dir, c0, c1, 2e-3);\n\n        if(res2.y > res2.x && res2.y > 0. && res2.x < dlen)\n        {\n            res.x = min(res.x, res2.x);\n            res.y = max(res.y, res2.y);\n        }\n        \n        if(res.y < 0. || res.x > dlen)\n            return 0.;\n    }\n    \n    vec3 q0 = p0 + dir * res.x;\n    vec3 q1 = p0 + dir * res.y;\n\n    // Contribution is modelled somewhat on the usual monte carlo raytracing.\n    // This amounts to integrating coverage of a varying disc by a small point.\n    // Function to integrate is: 1 / (pi * ((a * x + b) ^ 2))\n    // Integral is: -1 / (pi * a * a * x + pi * a * b)\n    \n    vec3 cd = c1 - c0;\n    float cl2 = ra / dot(cd, cd);\n\n    float z0 = dot(q0 - c1, cd);\n    float z1 = dot(q1 - c1, cd);\n\n    float a = cl2 * (z1 - z0);\n    float b = cl2 * z0;\n\n    float i0 = pi * a * b;\n    float i1 = pi * a * (a + b);\n    \n    i0 = 1e-4 / max(1e-10, abs(i0)) * sign(i0);\n\ti1 = 1e-4 / max(1e-10, abs(i1)) * sign(i1);\n    \n    return min(1., abs(i1 - i0));\n}\n\n\nfloat heightmap(vec2 uv)\n{\n    return (texture(iChannel0, uv.yx / 256.).r - .1) * 2.;\n}\n    \nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(-0.2, 1., 0.);\n    vec3 focus = ro + vec3(uv.xy, -3.5);\n\n    float ra = .08;\n    float t = iTime / 2.;\n    \n    mat3 m = rotX(.23);\n\n    vec3 col = vec3(0.0);\n\n    // Landscape.\n    \n    for(int y = -14; y < -1; ++y)\n    {\n        vec3 ps[4];\n\t\tfor(int x = -6; x < 6; ++x)\n        {            \n            ps[1] = ps[0];\n            ps[3] = ps[2];\n            ps[0] = vec3(float(x + 0), 0, float(y + 0)) / 2.;\n            ps[2] = vec3(float(x + 0), 0, float(y + 1)) / 2.;\n            \n            ps[0].y = heightmap(ps[0].xz + vec2(0., -floor(t))) + cos(iTime / 3.) * .1;\n            ps[0].z += fract(t);\n            ps[0] = m * ps[0];\n\n            ps[2].y = heightmap(ps[2].xz + vec2(0., -floor(t))) + cos(iTime / 3.) * .1;\n            ps[2].z += fract(t);\n            ps[2] = m * ps[2];\n\n            if(x > -6)\n            {\n                if(abs(x) > -y / 2)\n                \tcontinue;\n  \n                float f = 1. - smoothstep(2.8, 3.2,\n                          abs(max(abs(ps[0].z + 3.), max(abs(ps[1].z + 3.),\n                          max(abs(ps[2].z + 3.), abs(ps[3].z + 3.))))));\n                \n                if(f > 0.01)\n                {\n                    col += dofLine(ro, focus, ra, ps[0], ps[1]) * f * .5;\n                    col += dofLine(ro, focus, ra, ps[1], ps[3]) * f * .5;\n                }\n            }\n        }\n    }\n    \n    // Dust particles.\n    \n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 dotp = cos(vec3(19, 129, 99) * (float(i))) * vec3(2., 0.4, 5.) + vec3(0, 0.4, 0.);\n        dotp.z += t;\n        dotp.z = mod(dotp.z, 5.) - 6.;\n        dotp = m * dotp;\n        float f = 1. - smoothstep(1.5, 2., abs(dotp.z + 3.));\n        if(f > 0.01)\n        \tcol += dofLine(ro, focus, ra, dotp, dotp + 1e-4) * f * vec3(1,.8,.2);\n    }\n    \n\n    col = pow(col + (1. - smoothstep(0., 3.8, length(uv))) * .1, vec3(1.8, 1.4, 1));\n\n    fragColor.rgb = col * 2.;\n\n    // Gamma correction\n\n    fragColor.rgb = pow(min(fragColor.rgb, 1.), vec3(1. / 2.2)) +\n        \ttexelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).r / 100.;\n    fragColor.a = 1.;\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 64, 64, 83], [85, 217, 354, 354, 920], [922, 1054, 1179, 1222, 1642], [1644, 1644, 1705, 1705, 3170], [3173, 3173, 3199, 3199, 3260], [3266, 3266, 3286, 3286, 3358], [3360, 3360, 3380, 3380, 3452], [3454, 3454, 3474, 3474, 3546], [3548, 3548, 3605, 3605, 5827]]}
{"id": "WlXBWs", "name": "Another Mosaic", "author": "jayprich", "description": "http://conal.net/Pan/Gallery/intro/medres/neal.jpg", "tags": ["geometric"], "likes": 5, "viewed": 56, "published": "Public", "date": "1598011983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 172\nvoid mainImage(out vec4 c,in vec2 p){\nvec2 q=p/iResolution.y*mat2(4,4,iTime,-4);\nc+=mod(floor(.5+8.*mix(q.y,q.x,step(.25,abs(fract(.5+abs(q.x-5.25)+abs(q.y-1.5))-.5)))),2.);\n}\n\n/* FabriceNeyret2 169 - (Update Feb 2021 : JP unfortunately the golf'ed \"#define mainImage(c,p)\" trick is now broken)\n#define M(x) mod(floor(x),2.)\n#define mainImage(c,p)                             \\\n    vec2 q = p/iResolution.y * mat2(5,5,5,-5);     \\\n    c += mix( M( .5+ (.02*sin(iTime)+4.) * q.y ),  \\\n              M( .5+ 4.*q.x ),                     \\\n              M( abs(q.x-6.75) + abs(q.y-1.75) ) )\n*/\n\n/* Original       242\nvoid mainImage(out vec4 c,in vec2 p)\n{\n    vec2 q = p.xy/iResolution.y;\n    float z = mod(floor(5.*abs(q.x+q.y-1.35)+5.*abs(q.x-q.y-.35)),2.);\n    float w = z*mod(floor(.5+20.*(q.x+q.y)),2.)+(1.-z)*mod(floor(.5+(.1*sin(iTime)+20.)*(q.x-q.y)),2.);\n    c=vec4(w,w,w,1.);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 44, 44, 182]]}
{"id": "wlXfW7", "name": "polkaTunnel0", "author": "pohy", "description": "polkaTunnel0", "tags": ["polkatunnel0"], "likes": 0, "viewed": 131, "published": "Public API", "date": "1596872172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nfloat getFreq(float freq) {\n    int tx = int(freq / 22000. * 512.);\n    return texelFetch(iChannel0, ivec2(tx, 0), 0).r;\n}\n\nfloat getBand(float freq, float width) {\n    float avg = 0.;\n    float it = width / freq;\n    for (float i = 0.; i < it; i++) {\n        avg += getFreq(freq * i);\n    }\n    return avg;\n}\n\nvec2 toLogPolar(vec2 uv) {\n    return vec2(log(length(uv)), atan(uv.y, uv.x));\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float t = iTime * .1;\n    vec3 col = vec3(0);\n    \n    float snare = getFreq(5000.);\n    \n    uv *= 6. + (sin(t) * 3.);\n    uv = fract(abs(uv));\n    uv = toLogPolar(uv);\n    uv.x -= t + snare * .1;\n    uv *= 6. / PI;\n    uv = fract(uv) - .5;\n    \n    float r = .25 + getFreq(80.) * .2;\n    float dist = length(uv);\n    float delta = fwidth(dist);\n    float c = smoothstep(r * 1.01, r - delta, dist);\n    vec3 color = mix(vec3(.8, .8, .5), vec3(.2, .2, .8), snare);\n    col += c;//vec3(.8 + (snare * .2), .8 - (snare * .2), .5 - (snare * .2));\n    //col.rg = id;\n    //col += getFreq(60.);\n    //col.rg += uv;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 142], [144, 144, 184, 184, 329], [331, 331, 357, 357, 411], [413, 413, 432, 432, 508], [510, 510, 567, 567, 1324]]}
{"id": "WlXfWj", "name": "6D Leopard", "author": "snolot", "description": "Test to apply triplanar mapping on sdf", "tags": ["sdf", "triplanar", "hair"], "likes": 6, "viewed": 125, "published": "Public", "date": "1597692608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/************************************************************************************************\n*\n* SDF code: \n* from blackle - That's Six-Dimensional Gravy - (https://www.shadertoy.com/view/3lKGRm)\n*\n* HAIR code: \n* from pronce - 2D Fur and hair textures - (https://www.shadertoy.com/view/ttjyRc)\n*\n* TRIPLANAR code from:\n* Improved Triplanar Mapping from tux (https://www.shadertoy.com/view/lsj3z3)\n* Stochastic Triplanar Sampling from miloyip (https://www.shadertoy.com/view/3lS3Rm)\n* noise-preserving triplanar from  FabriceNeyret2  (https://www.shadertoy.com/view/3l2SDd)\n* taken from Industrial Complex  from  Shane  (https://www.shadertoy.com/view/MtdSWS)\n* N-Planar Texturing from pastasfuture (https://www.shadertoy.com/view/4sccRl)\n*\n************************************************************************************************/\n\n#define ROTATE\n#define SLICE\n#define PI 3.14159265\n\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// global parameters\nfloat HAIR_LENGTH = 60.0;\nfloat TOUSLE = 0.5;\nfloat BORDER = 1.5;\n\nfloat noise (vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = R(i);\n    float b = R((i + vec2(1.0, 0.0)));\n    float c = R((i + vec2(0.0, 1.0)));\n    float d = R((i + vec2(1.0, 1.0)));\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return (mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y) * 2.0 - 1.0;\n}\n\nfloat fbm(vec2 x){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// generate a hair patch, which is essentially just some fbm noise \n// stretched along one axis based on the rotation value a.\n// to mimic tousling of the hair a random offset is added to the \n// rotation. the hair length is derived from the actual stretch\nfloat hairpatch(vec2 u, vec2 o, float a){\n\n    a += sin(R(o) * 5.0) * TOUSLE;\n    vec2 d = vec2(1.0 / HAIR_LENGTH, .5);\n    float s = sin(a); float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    u=m*u;\n  \n    float h = (fbm((u + o) * d * 70.0) + 1.0) / 2.0;\n     \n    h = smoothstep(0.0, 2.2, h);\n\n    return max(0.0, 1.0 - min(1.0, 1.0 - h));\n}\n\n\n// as the hair is organized in patches, each patch has some\n// smooth falloff since patches are blended together dynamically\nfloat hair(vec2 u, vec2 d, float w, float a){\n    float hr = 0.0;\n    u *= w * 4.0;\n    u += d;\n    vec2 hp = fract(u) - vec2(0.5);\n    float h = hairpatch(hp, floor(u), a);\n    return pow(h * max(1.-length(hp) * BORDER, 0.0),1.0 / 3.0);\n}\n\n// mix 9 hair patches together in order to simulate an overlapping effect\nfloat hairtexture(vec2 uv, float scale, float angle){\n    vec2 offsets[9] = vec2[9](vec2(0.), vec2(.5), vec2(-.5),\n                              vec2(.5,0.), vec2(-.5,0.),\n                              vec2(0.,.5), vec2(0.,-.5),\n                              vec2(.5,-.5), vec2(-.5,.5));\n\n    float f = 0.0;\n\n    for(int i = 0; i < 9; i++){\n        f = max(f, hair(uv, offsets[i], scale, angle));\n    } \n    \n    return smoothstep(0.0, 1.0, f);\n}\n\nvec3 hyena(vec2 uv){\n    HAIR_LENGTH = 20.0;\n    TOUSLE = 0.15;\n    BORDER = 1.5;\n    \n    float angle = (fbm(uv) + 2.0) * PI;\n    float f = hairtexture(uv, 1.0f, angle);\n    \n    // apply color look and use fbm to create darker patches\n    vec3 col = mix(vec3(0.4, 0.3, 0.25) * f * mix(2.0, 4.0, fbm(uv * 8.0)), vec3(1.0), pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 leopard(vec2 uv){\n    HAIR_LENGTH = 15.0;\n    TOUSLE = 0.15;\n    BORDER = 1.5;\n    \n    float angle = (fbm(uv)-2.0) * PI * 0.25;\n    float f = hairtexture(uv, 1.0, angle);\n    \n    //generate a map that mixes between the black and yellow patches\n    float patches = min(1.0, sin(fbm(uv * 2.0) * 3.0 * PI));\n    \n    // apply both colors to the patches\n    vec3 col = mix(max(vec3(0.0), vec3(0.55, 0.37, 0.05) * f * mix(1.0, 4.0, patches)), \n                   vec3(1.0), \n                   pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 woman(vec2 uv){\n    HAIR_LENGTH = 2000.0;\n    TOUSLE = 0.1;\n    BORDER = 1.25;\n    \n    float angle = (fbm(uv * 0.25)) * PI;\n    float f = hairtexture(uv * 0.5, 1.0, angle);\n    \n    // just mix in some blond strains\n    vec3 col = mix(vec3(0.8, 0.5, 0.0) * f * mix(2.0, 1.0, fbm(uv)), vec3(1.05, 0.92, 0.9), pow(f, 4.0) * 2.0);\n    \n    return col;\n}\n\n#define HAIR_FUNK(U) leopard(U)\n//#define HAIR_FUNK(U) hyena(U)\n//#define HAIR_FUNK(U) woman(U)\n\n// Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n// Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\nfloat hash(vec2 p) {\n   return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n}\n\nfloat hash3D(vec3 p) {\n   return hash(vec2(hash(p.xy), p.z));\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n\n    vec3 p1 = p;\n    #ifdef SLICE\n        vec3 p2 = vec3(asin(sin(iTime )),0,0);\n    #else\n        vec3 p2 = vec3(1,0,0);\n    #endif\n\n    #ifdef ROTATE\n    \tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n    \tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n    \tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n    \tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n    #else    \n        mat3 r11 = mat3(1);\n        mat3 r12 = mat3(0);\n        mat3 r21 = mat3(0);\n        mat3 r22 = mat3(1);\n    #endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 tex3D( in vec3 pos, in vec3 normal ){\n    return  HAIR_FUNK( pos.yz )*abs(normal.x)+ \n            HAIR_FUNK( pos.xz )*abs(normal.y)+ \n            HAIR_FUNK( pos.xy )*abs(normal.z);\n}\n\nvec3 norm2(vec3 p){\n    vec3 P = vec3(-.05, .05, 0) * 0.005;\n\n    vec3 N = normalize(scene(p+P.xyy)*P.xyy+scene(p+P.yxy)*P.yxy+\n                  scene(p+P.yyx)*P.yyx+scene(p+P.xxx)*P.xxx);\n    \n    vec3 B = vec3(tex3D(p+P.xzz,N).r,tex3D(p+P.zxz,N).r,\n                  tex3D(p+P.zzx,N).r)-tex3D(p,N).r;\n    B = (B-N*dot(B,N));\n\n    return normalize(N+B*5.0);\n}\n\nvec3 triplanar(vec3 P, vec3 N){   \n    \n    vec3 Nb = max(abs(N)- vec3(0.0, 0.1, 0.0), 0.0);\n\n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\n    \n    vec3 c0 = HAIR_FUNK(P.xy).rgb * Nb.z;\n    vec3 c1 = HAIR_FUNK(P.yz).rgb * Nb.x;\n    vec3 c2 = HAIR_FUNK(P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 triplanarB(vec3 P, vec3 N){\n    vec3 signs = sign(N);\n        \n    vec3 weights = max(abs(N) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n    \n    float anglep = 3.14159265/4.0;\n\n    float cosp = cos(anglep);\n    float sinp = sin(anglep);\n    \n    // Set up the 3 planar projections that we will be using\n    // first plane is rotated around z compensating for the sign of the normal\n    vec3 p1t = vec3(0.0, 0.0, 1.0);\n    vec3 p1b = vec3(-signs.x * cosp, sinp, 0.0);\n\n    // second plane is just the xz plane\n    vec3 p2t = vec3(0.0, 0.0, 1.0);\n    vec3 p2b = vec3(1.0, 0.0, 0.0);\n    \n    /// third plane is rotated around x also compensating for the sign of the normal\n    vec3 p3t = vec3(1.0, 0.0, 0.0);\n    vec3 p3b = vec3(0.0, sinp, -signs.z * cosp);\n    \n    // Perform the uv projection on to each plane\n    vec2 uvp1 = vec2(dot(P, p1t), dot(P, p1b));\n    vec2 uvp2 = vec2(dot(P, p2t), dot(P, p2b));\n    vec2 uvp3 = vec2(dot(P, p3t), dot(P, p3b));\n\n    vec3 texCol = HAIR_FUNK(uvp1) * weights.x +\n          HAIR_FUNK(uvp2) * weights.y +\n          HAIR_FUNK(uvp3) * weights.z;\n\n    return texCol;\n}\n\nvec3 triplanarC(vec2 P, vec3 N){\n    vec3 NN = vec3(P, sqrt(1.0 - dot(P, P)));\n\n    vec3 a = max(vec3(0.0), abs(NN) - sqrt(3.0)/3.0);\n    vec3 w = a / (a.x + a.y + a.z);\n    \n\n    vec2 g; // maximum projection\n    if (w.x > w.y && w.x > w.z)\n        g = NN.yz;\n    else if (w.y > w.z)\n        g = NN.xz;\n    else\n        g = NN.xy;\n\n    float pixDeriv = length(vec2(length(dFdx(NN)), length(dFdy(NN))));\n    float pixScale = 1.0 / pixDeriv;\n\n    float h = hash3D(floor(NN * pixScale));\n    \n    vec2 t;\n    if (w.z > h)\n        t = NN.xy;\n    else if (w.z + w.y > h)\n        t = NN.xz;\n    else\n        t = NN.yz;\n\n    //\n    return \n        HAIR_FUNK(t) * w.z + \n        HAIR_FUNK(t) * w.y + \n        HAIR_FUNK(t) * w.x;\n    //return textureGrad(iChannel0, t, dFdx(g), dFdy(g));\n}\n\nvec3 triplanarD(vec3 P, vec3 N){\n    vec3 c = max(abs(N)- vec3(0.0, 0.4, 0.0), 0.0);\n\n    \n    vec3 O = c.z*HAIR_FUNK(P.xy) +  c.x*HAIR_FUNK(P.yz) +  c.y*HAIR_FUNK(P.xz);\n    O +=  c.z*HAIR_FUNK(P.xy)+ c.x*HAIR_FUNK(P.yz)+ c.y*HAIR_FUNK(P.xz)  / (c.x+c.y+c.z);\n    O += .5+ ( c.z*(HAIR_FUNK(P.xy)-.5) + c.x*(HAIR_FUNK(P.yz)-.5) + c.y*(HAIR_FUNK(P.xz)-.5) ) / length(c);\n\n    return O.rgb;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 triplanarE(vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec3 tx = HAIR_FUNK(p.zy).xyz;\n    vec3 ty = HAIR_FUNK(p.xz).xyz;\n    vec3 tz = HAIR_FUNK(p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/6.;\n    mouse.y += iTime/10.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-11,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    \n    vec3 n = norm(p);\n    \n    /////////\n    // Use this one for bump mapping but too\n    // vec3 n = norm(p);\n    ////////\n\n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n\n    // TEST 1:\n   \t//vec3 col = ao*mix(ss,diff,.5)* triplanar(p * .15, n) +pow(spec,30.)*fres*5.*ro;\n    \n    // TEST 2:\n    //vec3 col = ao*mix(ss,diff,.5)* triplanarD(p * .15, n) * .5 +pow(spec,30.)*fres*5.*ro;\n    \n    // TEST 3:\n    vec3 col = ao*mix(ss,diff,.5)* triplanarE(p * .25, n) +pow(spec,20.)*fres*2.*ro;\n    //col = sqrt(clamp(col, 0., .4));\n    \n    float bg = length(sin(cam*2.5)*0.6+0.4)/sqrt(3.) ;\n  \tfragColor = hit ? vec4(sqrt(col), 1.) : vec4(vec3(pow(bg,7.))* vec3(.15, .07, .02), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[965, 1053, 1075, 1075, 1416], [1418, 1418, 1436, 1436, 1701], [1703, 1960, 2001, 2001, 2306], [2309, 2434, 2479, 2479, 2673], [2675, 2749, 2802, 2802, 3195], [3197, 3197, 3217, 3217, 3557], [3559, 3559, 3581, 3581, 4091], [4093, 4093, 4113, 4113, 4449], [4548, 4709, 4729, 4729, 4822], [4824, 4824, 4846, 4846, 4887], [4889, 4889, 4910, 4910, 4939], [4941, 4941, 4977, 4977, 5042], [5044, 5044, 5063, 5063, 5891], [5893, 5893, 5914, 6020, 6077], [6079, 6079, 6098, 6098, 6213], [6215, 6215, 6257, 6257, 6402], [6404, 6404, 6423, 6423, 6765], [6767, 6767, 6798, 6798, 7078], [7080, 7080, 7112, 7112, 8382], [8384, 8384, 8416, 8416, 9165], [9167, 9167, 9199, 9199, 9557], [9559, 9713, 9745, 9745, 10251], [10254, 10254, 10311, 10311, 12193]]}
{"id": "wlXfWS", "name": "#845 - Daily Experiments", "author": "sixclones", "description": "One more day.", "tags": ["3d", "raymarching", "experiments", "daily"], "likes": 6, "viewed": 464, "published": "Public API", "date": "1597586319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// =========\n// CONSTANTS\n// =========\n\n#define QP 0.785398163397448\n#define TRP 1.047197551196598\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define EPS 0.001\n#define STEPS 64.0\n#define DIST 0.01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// ========\n// UTILS FN\n// ========\n\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\n  to be used with cos/sin\n  e.g.: `map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n// classical 2d rotation\nvec2 rotate2d(vec2 uv, float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n}\n\n// =====\n// SCENE\n// =====\n\n/* SDF of a torus from Inigo Quilez\n  https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n*/\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n/* scene definition\n  mainly defining a torus and deform radius and thickness of it */\nfloat sceneSDF(vec3 p) {\n  vec3 _p = p; // save value of `p` before rotating it\n  \n  // some rotations\n  p.xy = rotate2d(p.xy, t);\n  float angle = P * S(0.25, 0.75, abs(2.0 * fract(t / P) - 1.0));\n  p.yz = rotate2d(p.yz, angle - QP);\n  \n  // combine cos/sin and `p` to deform the radius\n  float r = map01(sin(t\n    + 2.0 * (_p.x + _p.z)\n    + HP * cos(-t + p.y)\n    ), 1.25, 1.5); // radius\n  \n  // switch between `p.x` and `p.y` to deform thickness\n  float mixer = S(0.125, 0.875, abs(2.0 * fract(t / TP) - 1.0));\n  // combine cos/sin and `p` to deform the thickness\n  float t = map01(cos(-t\n    + 2.5 * mix(_p.x, _p.y, mixer)\n    + P * sin(-t\n      + 2.0 * _p.z\n      + TP * sin(t + 0.25 * (_p.x + _p.y + _p.z))\n    )), 0.55, 0.65); // thickness\n  \n  float torus = torusSDF(p, vec2(r, t));\n  \n  return torus;\n}\n\n// ======\n// RENDER\n// ======\n\n/* compute normales by an estimation of them, offseting the scene computation\n  more details reading here:\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting */\nvec3 computeNormal(vec3 p) {\n  float center = sceneSDF(p);\n  vec3 offset = vec3(0.0, EPS, 0.0);\n\n  return normalize(vec3(\n    center - sceneSDF(p + offset.yxx),\n    center - sceneSDF(p + offset.xyx),\n    center - sceneSDF(p + offset.xxy)\n  ));\n}\n\n// =====\n// MAIN\n// =====\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\n  vec3 color = vec3(0.07, 0.05, 0.08);\n\n  vec3 rd = normalize((vec3(uv, 1.0)));\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n\n  // raymarching loop\n  float f = 10.0 / STEPS;\n  for (float i = 0.0; i < STEPS; i++) {\n    vec3 pos = ro + f * rd;\n    float scene = sceneSDF(pos);\n    if (scene < DIST) {\n      // use normales as color and switch the channels, instead of classical `.rgb` use `.brg` for a fresher render\n      color = 0.5 * computeNormal(pos).brg + 0.5;\n      break;\n    }\n    f += scene;\n  }\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 460, 534, 534, 606], [608, 748, 797, 797, 853], [855, 880, 913, 913, 968], [998, 1107, 1139, 1139, 1204], [1206, 1293, 1317, 1317, 2105], [2138, 2352, 2380, 2380, 2597], [2599, 2626, 2681, 2681, 3278]]}
{"id": "WlXfzs", "name": "Noise landscape", "author": "illus0r", "description": "Foggy landscape", "tags": ["raymarchingnoiselandscape"], "likes": 6, "viewed": 235, "published": "Public API", "date": "1597418372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat GetDist(vec3 p) {\n    float plane = dot(p, normalize(vec3(0.,1.,0.)));\n    float n = noise(p);\n    float n2 = noise(p * 2.)  * 0.5;\n    float n3 = noise(p * 4.)  * 0.25;\n    float n4 = noise(p * 8.)  * 0.075;\n    float n5 = noise(p * 8.) * 0.0375;\n    n += n2 + n3 + n4 + n5;\n    \n    return (plane + n) * 0.1;\n}\n\n\n\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0. + iTime, 0.6, -3);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + vec3(1., 0., 0.), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif; \n        //col = n * d;\n        col = vec3(S(10., 0., d));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXfzs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 339, 358, 358, 420], [422, 422, 444, 444, 538], [540, 540, 569, 569, 650], [652, 652, 721, 721, 890], [892, 892, 918, 930, 2096], [2098, 2098, 2121, 2121, 2416], [2426, 2426, 2460, 2460, 2671], [2673, 2673, 2697, 2697, 2887], [2889, 2889, 2939, 2939, 3130], [3134, 3134, 3191, 3191, 3853]]}
{"id": "WlXyW8", "name": "DG Water marching", "author": "DG622", "description": "This is my first attempt at a procedural ocean using raymarching and some colour blending (well blue and green), at times it looks good at others not so good. ", "tags": ["raymarching", "water", "ocean", "undulating"], "likes": 6, "viewed": 144, "published": "Public", "date": "1596729551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//This code is dervived from the you tube tutorials of the Art of Code aka BigWings\n//and some helpful articles by Inigo Quilez\n//appologies for my comments\n\nfloat N21a (vec2 p){//simple noise 1 dimensional, x and y need to have different multipliers\n    return  fract(sin(p.x*10.0 + p.y * 64.0) *57.0);\n}\n\nfloat smoothNoise (vec2 uv){// this is essentiually a mixing function\n   uv.xy -= iTime*.57;\n    uv*=1.5;\n    //we are going to get the value of the blue at each corner and then interpolate between that\n    \t\t// and a uv point in the cell to get the pattern, lv meaning 'local uv'\n    vec2 lv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 id = floor(uv);\n   \n   lv = lv * lv *(3. - 2. *lv);//interpolation for dummies video but this is essentially a smoothstep\n    \t\t\t\t\t\t\t//lv = smoothstep ( 0.0, 1.0, fract(uv * 10.0));\n    \n    float bl = N21a(id);//bottom left\n    float br = N21a(id + vec2(1, 0));//bottom right\n    float b = mix( bl, br, lv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float tl = N21a(id + vec2(0, 1));//top left etc\n    float tr = N21a(id + vec2(1, 1));\n    float t = mix( tl, tr, lv.x);\n       \n    return mix(b, t, lv.y);    \n}\n\nfloat smoothNoise2 (vec2 uv){\n    if(true){//original Perlin set\n    float c;\n      c = smoothNoise(uv*4.);  // So (uv * frequency ) * Amplitude\n    c+= smoothNoise(uv* 8. ) * .5;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .25;\n    c+= smoothNoise(uv* 32. ) * .125;\n    c+= smoothNoise(uv* 65. ) * .0625;\n    return c/2.0;\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n    }\n    if(false){//tweaked set\n     float c;\n      c = smoothNoise(uv*4.) * 0.25;  // So (uv * frequency ) * Amplitude\n    c+= smoothNoise(uv* 8. ) * .125;//add another layer/octave, each time double the frequency \n    \t\t\t\t\t\t\t\t//and halve the amplitude\n    c+= smoothNoise(uv* 16. ) * .0625;\n    c+= smoothNoise(uv* 64. ) * .01225;\n    c+= smoothNoise(uv* 125. ) * .01225;\n    return c/2.0;\t\t\t//need to divide by a factor to make sure c does not breach 1.0\n    }\n}\n\nfloat GetDist (vec3 p){ \n    \tfloat v_time = iTime*0.5;   \t\t\t\n    \tfloat wave;  \n  \t\tp.xz*=0.03;\n    \t//p.x -= v_time* 0.1751;\n    //\tp.z -= v_time* 0.357;\n     \t\t\t\t\t\n    \twave = sin((p.x+p.z)*0.7751)*1.7351 ;//x direction separate out from z (freq)*amplitude\n \t\twave+=sin(p.x*0.937)*1.773;\n  \t\twave += smoothNoise2(vec2(sin(p.x), sin(p.z)));\n   \t\twave+=smoothNoise2(vec2(sin(p.x+0.13), sin(p.z+0.57)));    \n    \tfloat dPlane = dot(vec3(p.x,p.y-2.5-wave,p.z), normalize(vec3 (0.0,1.0,0.0))); \n    \treturn min(dPlane, p.y);\n      \t\t\t\t\t\t\t               \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n            float dO = 0.0;\n            \n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                float dS = GetDist(p);                      \t\t\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }   \n          \treturn  dO;                     \n       }\nvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p);          \t          \n            vec3 n = d - vec3(GetDist(p-e.xyy),GetDist(p-e.yxy), GetDist(p-e.yyx));           \n            n = normalize(n);\n            return n;           \n       }\n        vec2 GetLight(vec3 p){\n         \tvec3 lightPos = vec3( -15.0, 15.0, 15.0);\n            lightPos.xz += vec2(sin(iTime), cos(iTime));\n            vec3 light = normalize(lightPos - p);\n            vec3 n = GetNormal(p);           \n            vec2 dif = vec2(clamp(dot(n,light), 0.0, 1.0),n);// so no negative numbers, last one just to carry the normal back\n            //for the shadow\n            float d  = RayMarch(p+ n   , light);//this adding the n  is a work around            \n            if (d < length (lightPos - p )) dif *= 0.1;                                                    \n          //  dif.y = n;\n            return dif;\n        }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;     \n\tvec3 col = vec3(0.0);\n    vec3 RGBblue = vec3(0.05, 0.13, 0.19);\n    vec3 RGBgreen = vec3(0.05, 0.17, 0.25);\n    vec3 RGB = vec3(0.0);\n   // vec3 LightCol = vec3(0.15, 0.1, 0.1);\n    vec3 ro = vec3(15.0 , 15.0 ,-15.0  );\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    float d = RayMarch(ro,rd);\t\t//water\t            \n    vec3 p= ro+rd*d;\n    vec2 diff = GetLight(p);\n   \tRGB = mix(RGBblue, RGBgreen, smoothstep(0.05, 0.6, diff.y));//mix green and blu via the normal\n    \n    col = vec3(diff.x+RGB );    \n    \n   // float c = max(smoothstep(0.5, -.100,uv.y),\tsmoothNoise2(uv)); \n  \tif (d > 100.0) col =vec3(max(smoothstep(0.5, -.100,uv.y),smoothNoise2(uv)) );//cloud\n   \n    col = pow(col, vec3(0.4545));   //gamma correction        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 158, 178, 250, 305], [307, 307, 335, 376, 1256], [1258, 1258, 1287, 1287, 2200], [2202, 2202, 2225, 2225, 2755], [2757, 2757, 2790, 2790, 3168], [3169, 3169, 3193, 3193, 3453], [3462, 3462, 3484, 3484, 4110], [4114, 4114, 4171, 4171, 4996]]}
{"id": "wsGXDz", "name": "selfmade raymarching template", "author": "Jarazz", "description": "Basics for raymarching scene, not made with a direct guide though, so probably not A+ quality\n\nRaymarching tutorial by \"The Art of Code\" has the proper setup", "tags": ["raymarching"], "likes": 0, "viewed": 58, "published": "Public", "date": "1597933913", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n//fancy struct from https://www.shadertoy.com/view/4t2cR1 (who probably has it from somewhere else)\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n\n     \n //preset variables\n   \tvec3 camPos = vec3(0,1,-4);\n   \tvec3 viewDir = vec3(0,-.2,1);\n    vec3 camUp = vec3(0,1,0);\n    vec3 camRight = vec3(1,0,0);\t//for more complex up and right vectors use: normalize(cross(camUp,viewDir));\n    float camSize = 1.;\n    float zoom = 2.;\n    \n \n  \n\n//helper functions:\n \n    \n    \n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nvec3 smin( vec3 a, vec3 b)\n{  \n    return vec3(smin(a.x,b.x,0.1),smin(a.y,b.y,0.1),smin(a.z,b.z,0.1));\n}\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\n\n\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 1.-(--f)*f*f*f*-f;\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphereSDF(vec3 x, float sphereSize, vec3 spherePos)\n{\n    return length(x-spherePos)-sphereSize;\n    }\n\nfloat boxSDF( vec3 p, vec3 b ) //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sceneSDF(vec3 pos)\n{ \n    float torus =  sdTorus(pos+vec3(0.,sin(iTime)*2.-2.,0), vec2(2.,.25));\n     \n    \n    \n    \n    vec3 boxPos = vec3(sin(iTime)+1.5,sin(iTime)+2.,0);\n    \n     float box = boxSDF(boxPos+pos,vec3(1.5,.5,.1) );\n    float sphere =sphereSDF(pos,  1.5 , vec3(1,-3,1) );\n    \n    float tmp = smin( sphere , box,1.4); \n     tmp = min(tmp, torus);\n\treturn tmp;\n}\n\n\n\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 estimateNormal(vec3 p) {\n    float EPSILON =5.0001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat calcLighting(vec3 p, vec3 lightPos, float brightness) {\n   vec3 n = estimateNormal(p);\n    vec3 l = normalize(lightPos-p)*brightness;\n    return max(0.,dot(n,l)); //standard cheap n.l lighting\n}\n\nfloat calcLighting(vec3 p) {\n    vec3 lightPos = vec3(10,10,2);\n    float brightness = 1.;\n    return calcLighting(p, lightPos, brightness);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 uvOffset = uv.x*camSize * camRight + uv.y*camSize*camUp; //the position of the pixel relative to the camera \n    vec3 pixelPos = camPos + uvOffset;\n    vec3 pixelForward = normalize( viewDir+uvOffset*zoom) ; // changes the cam from orthographic to perspective\n    \n    \n    \n    //Raymarch loop:\n    int maxIterations = 200;\n\tfloat maxStepDist = 11.;\n\tfloat hitDist = .03;\n    float dist;\n    float closestCall=9999999.;\n    int i = 0; \n    for(;i < maxIterations; i++){\n     \n        dist = sceneSDF(pixelPos);\n        closestCall = min(closestCall,dist);\n    \tif(dist<hitDist) break;\n        pixelPos+=  pixelForward*min(maxStepDist,dist);\n    \n    }\n   \n    \n    \n    \n    \n    vec3 col;//vec3(0.5 + 0.5*pixelPos/50., 0., 0.);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    \n    \n    //if we hit something:\n   // if(dist<hitDist){  }\n    \n    \n        float light = calcLighting(pixelPos) + calcLighting(pixelPos, vec3(-22.*sin(iTime),-22.*cos(3.1415*iTime),100.+222.*cos(0.521415*iTime)),1.);\n        //float light = calcLighting(pixelPos, vec3(0,0,0),1.);\n                         \n        float red = (-float(i)/float(maxIterations-1) )+(float(maxIterations)/float(maxIterations-1));\n        float blue =clamp( 1./(10.*(closestCall-hitDist)),0.,1.);   //clamp( - 4.*((closestCall/maxStepDist)-0.5)*((closestCall-hitDist)-0.5) +1.,0.,1.);\n        col = vec3( red*light, blue, 1.);\n    \n    \n    \n    \n    //col = vec3(pixelPos.z );\n    \n    \n    \n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 531, 572, 572, 656], [657, 657, 685, 685, 761], [763, 763, 785, 785, 865], [871, 883, 909, 909, 1531], [1533, 1533, 1635, 1635, 1700], [1702, 1702, 1761, 1761, 1810], [1812, 1812, 1913, 1913, 2063], [2065, 2065, 2091, 2091, 2449], [2453, 2528, 2557, 2557, 2894], [2896, 2896, 2957, 2957, 3096], [3098, 3098, 3126, 3126, 3240], [3243, 3243, 3300, 3300, 4917]]}
{"id": "wt2BRh", "name": "cloods", "author": "EmmaChase", "description": "clouds", "tags": ["cloud"], "likes": 2, "viewed": 49, "published": "Public", "date": "1598375739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_STEPS 10\n#define NUM_SCATTER 2\n#define C_SCALE 0.15\n#define ENERGY_C 2.3\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid rayBoxDist(vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir, out float dstToBox, out float dstInsideBox) {\n    vec3 t0 = (boundsMin - rayOrigin) / rayDir;\n    vec3 t1 = (boundsMax - rayOrigin) / rayDir;\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float dstA = max(max(tmin.x, tmin.y), tmin.z);\n    float dstB = min(tmax.x, min(tmax.y, tmax.z));\n    \n    dstToBox = max(0., dstA);\n    dstInsideBox = max(0., dstB - dstToBox);\n}\n\nvec3 sample_cloud(vec3 pos) {\n    vec3 nsamp = vec3(snoise(1. *pos+0.1*iTime))*0.5;\n    nsamp     += vec3(snoise(2. *pos))*0.25;\n    nsamp     += vec3(snoise(4. *pos))*0.125;\n    nsamp     += vec3(snoise(8. *pos))*0.02125;\n    nsamp     += vec3(snoise(16.*pos))*0.02125;\n    \n    return nsamp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 sunPos = vec3(0., 15., 8.);\n\n    \n    vec3 cameraPosition = vec3(4.+2.*sin(iTime), 3.5, -6.);\n    vec3 cameraLook = normalize(vec3(0, -0.5, 1.));\n    \n    vec3 rayDir = normalize(vec3(-0.7, -1.5, 1.) + 1.25*vec3(2.*uv - 1., 0.));//normalize(cameraLook + vec3(0.5*uv, 0.));\n    //nsamp /= 5.;\n    \n    vec3 boxMin = vec3(-1000, -10, -10);\n    vec3 boxMax = vec3(1000,3,200);\n    \n    float dtb = 0.;\n    float dib = 0.;\n    rayBoxDist(boxMin, boxMax, cameraPosition, rayDir, dtb, dib);\n    \n    float transmittance = 1.;\n    vec3 energy = vec3(0.);\n    \n    float lightAbsorptionThroughCloud = 0.25;\n    float lightAbsorptionTowardSun = 0.15;\n    \n    //float avg_density = 0.;\n    if (dib > 0.) {\n        vec3 step_pt = cameraPosition + rayDir*dtb;\n        float step_size = dib / (float(NUM_STEPS) - 1.);\n        for (int i = 0; i < NUM_STEPS; i++) {\n            float pt_density = max(0., sample_cloud(C_SCALE*step_pt).r);\n            \n            \n            if (pt_density > 0.) {\n                vec3 scatter_pt = step_pt;\n            \tvec3 scatter_dir = normalize(sunPos - scatter_pt);\n            \tfloat dts = 0.;\n            \tfloat dic = 0.;\n            \trayBoxDist(boxMin, boxMax, scatter_pt, scatter_dir, dts, dic);\n            \n                float subDensity = 0.;\n                \n\t            float scat_size = dic / float(NUM_SCATTER);\n    \t        for (int j = 0; j < NUM_SCATTER; j++) {\n        \t        scatter_pt += scatter_dir*scat_size;\n                \n            \t    subDensity += max(0., sample_cloud(C_SCALE*scatter_pt).r);\n            \t}\n                \n                float subTransmittance = exp(-subDensity * lightAbsorptionTowardSun);\n            \n                float phaseVal = acos(dot(rayDir, scatter_dir) / length(rayDir)*length(scatter_dir)) / (2.*3.1415);\n                \n                energy += ENERGY_C * pt_density * step_size * transmittance * subTransmittance * phaseVal;\n                transmittance *= exp(-pt_density * step_size * lightAbsorptionThroughCloud);\n            \t//avg_density += pt_density;\n                \n                // Too small anyways\n                if (transmittance < 0.01) {\n                    break;\n                }\n            }\n            \n            \n            step_pt += rayDir*step_size;\n        }\n        \n        //avg_density /= float(NUM_STEPS);\n        \n        //col *= vec3(1.) * (1. - avg_density);\n    }\n    \n    //float transmittance = exp(-2.*avg_density);\n    vec3 lightColor = vec3(1., 1., 1.);\n    vec3 cloudColor = energy*lightColor;\n    col *= transmittance;\n    col += cloudColor;\n    \n    // Output to screen\n    fragColor = vec4(col*transmittance, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2BRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 140, 161, 161, 198], [199, 199, 226, 226, 274], [276, 276, 297, 297, 2133], [2135, 2135, 2257, 2257, 2600], [2602, 2602, 2631, 2631, 2897], [2899, 2899, 2956, 3006, 5819]]}
{"id": "Wt2BRw", "name": "lava lamp experiment", "author": "rubenalexander", "description": "experimenting with the lava lamp effect.", "tags": ["lavalamp"], "likes": 1, "viewed": 89, "published": "Public", "date": "1598631799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\nfloat random (in vec2 st) {\n    float x = fract(sin(dot(st.xy,vec2(12.9898,78.233)))* 43758.5453123);\n    float y = fract(cos(dot(st.xy,vec2(35745.54,65468545.546)))* 546.4563);\n    return mod(x+y,1.)+mod(x-y,1.);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = (6.*f*f*f*f*f)-15.*(f*f*f*f)+10.*(f*f*f);\n\n    // Mix 4 corners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvec3 rm (vec2 uv, vec3 col) {\n    float val = .2;\n    float cbuff=val;\n    \n    if (col.r+col.g+col.b > .1) { \n        for (float m=0.; m<1.;m+=.1){\n            for (float n=0.; n<1.;n+=.1){\n                col.r *= cbuff;\n                col.g *= cbuff;\n                col.b *= cbuff;\n                cbuff *= sin(n);\n                uv.x += .2;\n            }\n            uv.y +=.2;\n            cbuff=val;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    float inv = fract(uv.x/uv.y);\n    vec3 col = vec3(0.);\n\t\n    // shifts the screen to a more interesting section\n    uv.x += .75;\n    uv.y *= .5;\n    \n    // I have used anywhere between 2 and 5 for proper scaling\n    uv *= 5.;\n    \n    \n    // save the original uv coordinates\n    vec2 suv = uv;\n \tfloat r,g,b=0.;\n    \n    // loop that generates the animation\n    \n    for(float n=0.05;n<5.;n+=.1) { \n        uv.x +=1.5;\n        uv.y=uv.y*suv.y;\n        \n        uv.x -=n;\n        uv.y += +.55*sin(iTime/(7.-n)*n)+.1;\n\t\tuv.x -=n;\t\n        uv.y += +.25*sin(iTime/(8.-n)*n)+.1;\n        \n        uv.y += -.55*sin(iTime/(9.-n)*n)+.2;\n        uv.x -=n;\n        \n        // fade between three colors\n        \n        b += smoothstep(.29,.20,length(uv))*.4;\n        r += smoothstep(.33,.27,length(uv))*.3;\n        g += smoothstep(.35,.30,length(uv))*.55;\n        \n        uv.y += -.55*sin(iTime/(7.-n)*n)+.2;\n        uv.x -=n;\n        b += smoothstep(.29,.20,length(uv))*.4;\n        g += smoothstep(.33,.27,length(uv))*.3;\n        r += smoothstep(.35,.30,length(uv))*.55;\n        \n        uv.y += -.55*sin(iTime/(6.-n)*n)+.2;\n        uv.x -=n;\n        r += smoothstep(.29,.20,length(uv))*.4;\n        g += smoothstep(.33,.27,length(uv))*.3;\n        b += smoothstep(.35,.30,length(uv))*.55;\n        \n        float s = abs(sin(iTime));\n        float c = abs(cos(iTime));\n        float t = abs(tan(iTime));\n        \n        // fade color change\n        col = vec3(mix(r,g,.5*s),mix(g,b,.5*c),mix(b,r,.5*1.-s)); \n        col *=1.5;\n        \n        // speeds up the movement + increases density\n        // uv = suv;\n    }\n    \n   \n    // runs around 120 to 140 fps with the original code   \n    fragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2BRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 93, 93, 281], [283, 283, 309, 309, 739], [742, 742, 771, 771, 1188], [1190, 1190, 1247, 1298, 3089]]}
{"id": "Wt2fRw", "name": "Fading spiral", "author": "Aurocosh", "description": "A spiral that gradually inverts its color as it gets farther from center horizontally", "tags": ["spiral"], "likes": 3, "viewed": 55, "published": "Public", "date": "1598582783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spiral function is taken from https://www.shadertoy.com/view/ldBGDc\nfloat spiral(vec2 m) {\n\tfloat r = length(m);\n\tfloat a = atan(m.y, m.x);\n\tfloat v = sin(50.*(sqrt(r) - 0.02 * a - .2 * iTime));\n\treturn clamp(v,0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    float sp = spiral(uv);\n    float sig = sign(uv.x);\n    uv.x -= sig * sp;\n\n    float d = length(uv);\n    float res = 1.0 - d;\n    \n    vec3 color = vec3(res);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2fRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 93, 93, 223], [225, 225, 281, 331, 626]]}
{"id": "wt2fzz", "name": "Nautilus Interior", "author": "dr2", "description": "Where Captain Nemo commands and watches dolphins (mouseable)", "tags": ["ocean", "dolphin", "submarine", "verne", "fiction"], "likes": 18, "viewed": 264, "published": "Public API", "date": "1598256558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Nautilus Interior\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // = 1 for optional antialiasing\n\n#define FISH  1  // optional fish (dolphins)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir, ltDir, qHit, bSize;\nfloat tCur, dstFar, winRad, tunRad, whlAng, wvBase;\n#if FISH\nvec3 fishPos;\nfloat fishAngI;\n#endif\nint idObj, idObjEx;\nconst int idWal = 1, idWalB = 2, idTun = 3, idLad = 4, idWin = 5, idGlas = 6, idWEnd = 7, idNut = 8,\n   idPipe = 9, idPer = 10, idScrn = 11, idWhl = 12, idWhlB = 13, idWhlS = 14, idWhlD = 15, idComp = 16,\n   idLev = 17, idDial = 18, idBras = 19, idBox = 20, idFlot = 21, idLit = 22;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = (id);  qHit = q; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (12., 15.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p;\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp, qq;\n  vec2 d2;\n  float dMin, d, wThk, zOff, s, dw, r;\n  dMin = dstFar;\n  wThk = 0.07;\n  zOff = -2.;\n  pp = p;\n  pp.x = abs (pp.x) - bSize.x;\n  q = pp;\n  d2 = SphGrid (q);\n  d2.x = max (d2.x, 0.3 * winRad - length (q.yz)); \n  d = SmoothMin (d2.x, d2.y, 0.02);\n  d = max (SmoothMax (abs (PrSphDf (q, winRad)) - wThk, d, 0.02), -0.01 - q.x);\n  DMINQ (idWin);\n  d = max (abs (PrSphDf (q, winRad + 0.5 * wThk)) - 0.25 * wThk, -0.01 - pp.x);\n  DMINQ (idGlas);\n  q = pp;\n  q.x -= -0.05;\n  d = PrCylAnDf (q.yzx, winRad - wThk + 0.2, 0.2, 0.05);\n  q.yz = Rot2D (q.yz, 2. * pi * floor (12. * atan (q.z, - q.y) / (2. * pi) + 0.5) / 12.);\n  q.xy -= vec2 (-0.1, - winRad - 0.1);\n  d = max (d, - PrCylDf (q.yzx, 0.13, 0.1));\n  DMINQ (idWEnd);\n  d = max (abs (q.z) - 0.5 * min (abs (q.z) - sqrt3 * abs (q.y), 0.) - 0.1, abs (q.x - 0.05) - 0.05);\n  DMINQ (idNut);\n  q = p;\n  dw = winRad - length (q.yz);\n  q.z -= zOff;\n  s = length (q.zx - vec2 (clamp (q.z, - bSize.z, bSize.z), 0.)) - bSize.x - 0.1;\n  d = abs (max (s, abs (q.y) - bSize.y)) - 0.02;\n  qq.y = q.y + bSize.y;\n  qq.z = abs (q.z) - bSize.z - bSize.x + tunRad + 0.05;\n  r = length (vec2 (q.x, qq.z));\n  d = max (dw, max (d, min (tunRad + 0.05 - r, 0.2 - abs (qq.y + 0.1))));\n  DMINQ (idWal);\n  q.y = qq.y + 0.9;\n  q.z = qq.z;\n  d = min (max (abs (r - tunRad) - 0.05, abs (q.y) - 1.), q.y + 0.9);\n  DMINQ (idTun);\n  d = abs (s + 0.08) - 0.04;\n  q = p;\n  q.y = mod (q.y + 1., 2.) - 1.;\n  q.z -= zOff;\n  if (d < bSize.z - abs (q.z)) {\n    q.z = mod (q.z + 1., 2.) - 1.;\n  } else {\n    q.z = abs (q.z) - bSize.z;\n    q.zx = Rot2D (q.zx, pi / 12.);\n    q.z = 0.85 * dot (q.zx, sin (2. * pi * (floor (12. * atan (q.x, - q.z) / (2. * pi)) +\n       0.5) / 12. + vec2 (0., 0.5 * pi)));\n  }\n  d = max (dw + 0.34, SmoothMax (d, 0.05 - length (max (abs (q.yz) - 0.85, 0.)), 0.03));\n  DMINQ (idWalB);\n  q = p;\n  q.z -= zOff;\n  q.xz = abs (q.xz) - vec2 (bSize.x - 0.25, bSize.z + 0.8);\n  d = PrCylDf (q.xzy, 0.1 + 0.03 * smoothstep (0.87, 0.9, abs (mod (q.y + 1., 2.) - 1.)), bSize.y);\n  DMINQ (idPipe);\n  q.xy -= vec2 (-0.15, -2.);\n  d = PrCylDf (q.yzx, 0.3, 0.05);\n  DMINQ (idPipe);\n  q = p;\n  q.z = abs (q.z - zOff) - bSize.z - bSize.x + 0.4;\n  d = max (abs (q.y) - bSize.y - 2., PrCylDf (vec3 (q.x, mod (q.y + 0.5, 1.) - 0.5, q.z).yzx,\n     0.09, 0.7));\n  d = min (d, PrCylDf (vec3 (abs (q.x) - 0.7, q.yz).xzy, 0.11, bSize.y + 2.));\n  DMINQ (idLad);\n  q = p;\n  q.yz -= vec2 (bSize.y - 1.6, 3.);\n  d = PrCylDf (q.xzy, 0.15, 1.6);\n  DMINQ (idPer);\n  q.y -= -2.2;\n  d = min (PrCapsDf (vec3 (q.x, abs (q.y) - 0.6, q.z).yzx, 0.05, 1.2),\n     PrCapsDf (vec3 (abs (q.x) - 1.2, q.yz).xzy, 0.05, 0.6));\n  DMINQ (idPer);\n  d = PrBoxDf (q, vec3 (1.2, 0.6, 0.03));\n  DMINQ ((q.z < 0.) ? idScrn : idPer);\n  q = p;\n  q.yz -= vec2 (-1.2, 1.5);\n  d = PrCylDf (q, 0.1, 0.2);\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, whlAng);\n  d = min (PrCylAnDf (q, 1.1, 0.1, 0.1), PrCylDf (q + vec3 (0., 0., -0.3), 0.2, 0.5));\n  DMINQ (idWhl);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (12. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 12.);\n  q.x += 0.8;\n  d = PrCapsDf (q.yzx, 0.05, 0.8);\n  DMINQ (idWhlS);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 2.3, 2.55);\n  d = PrRoundBoxDf (q, vec3 (0.3, 2.3, 0.3), 0.05);\n  q.y -= 2.2;\n  d = min (d, PrRoundBoxDf (q, vec3 (1.2, 0.1, 0.3), 0.05));\n  DMINQ (idWhlB);\n  q.x = abs (q.x) - 1.1;\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.12, 0.1);\n  DMINQ (idBras);\n  q = p;\n  q.yz -= vec2 (- bSize.y + 1.4, 2.55);\n  d = PrCylDf (q.yzx, 0.1, 0.65);\n  q.x = abs (q.x) - 0.5;\n  d = min (d, PrCylDf (q.yzx, 0.7, 0.1));\n  DMINQ (idWhlD);\n  q = p;\n  q.x = abs (q.x) - 2.;\n  q.y -= - bSize.y + 0.5;\n  q.z = (q.z > 0.) ? q.z - 6. : abs (q.z + 8.) - 2.;\n  d = PrRoundBoxDf (q, vec3 (0.5, 0.5, 1.), 0.05);\n  DMINQ (idBox);\n  q.xy -= vec2 (bSize.x - 2.1, bSize.y - 2.);\n  q.z = abs (q.z) - 0.15;\n  d = PrCylDf (q.xzy, 0.05, 4.);\n  DMINQ (idPipe);\n  q.y = abs (q.y - 3.5) - 0.5;\n  d = PrRoundBoxDf (q, vec3 (0.1, 0.25, 0.5), 0.05);\n  DMINQ (idBox);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2., - bSize.y + 0.7, 0.1);\n  q.x = abs (q.x);\n  d = max (- min (min (max (q.x - 0.07, abs (q.z) - 0.6), 0.), 0.18 - q.x),\n     length (vec2 (q.y - min (q.y, 0.5), q.z)) - 0.7);\n  d = min (min (d, PrCylDf (q.yzx, 0.1, 0.25)), PrCapsDf (q.xzy, 0.06, 2.));\n  DMINQ (idLev);\n  q = p;\n  q.yz -= vec2 (-0.35, 2.65);\n  r = length (q.xz);\n  d = max (abs (r - 0.55) - 0.05, abs (q.y) - 0.1);\n  DMINQ (idBras);\n  d = max (r - 0.5, abs (q.y + 0.02) - 0.08);\n  DMINQ (idComp);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (bSize.x - 0.05, -1., 4.);\n  d = PrCylDf (q.yzx, 0.35, 0.05);\n  DMINQ (idDial);\n  q.y -= -2.;\n  d = PrCylDf (q.xzy, 0.05, 2.);\n  DMINQ (idPipe);\n  q = p;\n  q = abs (vec3 (q.x, q.y + 4., q.z - zOff))- vec3 (bSize.x - 0.25, 0.5,  bSize.z - 1.7);\n  q.z = abs (q.z) - 1.2;\n  d = PrCapsDf (q, 0.4, 0.5);\n  DMINQ (idFlot);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - zOff));\n  q -= vec3 (bSize.x, bSize.y - 1., 4.);\n  q.z = abs (q.z) - 2.;\n  d = PrCapsDf (q, 0.2, 0.5);\n  DMINQ (idLit);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.01 + float (j) / 20.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 2. * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 ro)\n{\n  vec4 col4;\n  vec3 w;\n  float a, s;\n  if (idObj <= idLad) {\n    if (idObj == idWal) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.1);\n      if (ro.y < - bSize.y + 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.x, 1.));\n        w.xz = max (abs (ro.xz) - vec2 (1.6, 2.6), 0.);\n        if (length (w.xz) < 0.5) col4 = vec4 (0.5, 0.2, 0., 0.1) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (8. * ro.z, 1.)));\n      } else if (ro.y > bSize.y - 0.1) {\n        col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (4. * ro.z, 1.));\n        col4 = mix (vec4 (0.8, 0.3, 0.3, 0.1), col4, step (0.2, length (vec2 (abs (ro.x) - 2.,\n           mod (ro.z + 1., 2.) - 1.))));\n        col4 = mix (vec4 (1., 1., 0.8, -1.), col4, smoothstep (0.03, 0.05, abs (abs (ro.x) - 3.)));\n        col4 = mix (vec4 (0., 0.5, 0., -1.), col4, step (0.07, abs (length (vec2 (abs (ro.z + 2.) - bSize.z -\n           bSize.x + tunRad + 0.05, ro.x)) - tunRad)));\n      } else col4 = mix (vec4 (0.3, 1., 0.3, 0.), col4, smoothstep (0.05, 0.1, \n         max (abs (abs (ro.x) - 2.3), abs (ro.y) - 0.7)));\n    } else if (idObj == idWalB) {\n      col4 = vec4 (0.6, 0.7, 0.6, 0.1) * (0.8 + 0.2 * smoothstep (0.05, 0.1,\n         length (abs (qHit.yz) - 1.)));\n    } else if (idObj == idTun) {\n      col4 = mix (vec4 (0.3, 0.7, 0.3, -1.), vec4 (0., 0.4, 0., 0.), \n         step (0., max (length (qHit.xz) - tunRad, 0.5 - qHit.y)));\n    } else if (idObj == idLad) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n    }\n  } else if (idObj <= idPipe) {\n    if (idObj == idWin) {\n      col4 = vec4 (0.7, 0.8, 0.7, 0.2) * (0.5 + 0.5 * step (0.02, abs (length (qHit) - winRad)));\n    } else if (idObj == idWEnd) {\n      col4 = vec4 (0.5, 0.55, 0.1, 0.2) * (0.5 + 0.5 * step (abs (ro.x), bSize.x - 0.1));\n    } else if (idObj == idNut) {\n      col4 = vec4 (0.4, 0.4, 0.5, 0.2);\n    } else if (idObj == idPipe) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n    }\n  } else if (idObj <= idWhlS) {\n    if (idObj == idPer) {\n      col4 = vec4 (0.4, 0.4, 0.42, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (length (qHit.xy) - 1.1) - 0.02,\n         length (qHit.xy) - 0.11)));\n      col4 = mix (vec4 (0.4, 0.4, 0.8, 0.3), col4, step (0.05, length (vec2 (qHit.x, qHit.y - 1.1))));\n    } else if (idObj == idWhlB) {\n      col4 = mix (vec4 (0.8, 0.8, 0.8, -1.), vec4 (0.7, 0.5, 0.2, 0.05),\n         smoothstep (0.01, 0.02, abs (abs (qHit.z) - 0.15)));\n    } else if (idObj == idWhlS) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0.05, abs (qHit.x + 0.7)));\n    }\n  } else if (idObj <= idDial) {\n    if (idObj == idWhlD) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.5 + 0.5 * step (0., min (abs (qHit.x) - 0.04,\n         length (qHit.yz) - 0.105)));\n    } else if (idObj == idComp) {\n      if (qHit.y > 0.) {\n        col4 = vec4 (1., 1., 1., 0.1);\n        qHit.xz = Rot2D (qHit.xz, -0.5 * whlAng);\n        col4 = mix (vec4 (0.8, 0.2, 0.2, 0.1), col4, step (0.05, length (vec2 (qHit.x, qHit.z - 0.4))));\n        s = min (abs (qHit.x), abs (qHit.z));\n        qHit.xz = Rot2D (qHit.xz, 2. * pi * floor (36. * atan (qHit.z, - qHit.x) /\n           (2. * pi) + 0.5) / 36.);\n        if (abs (qHit.x + 0.45) < 0.02) s = min (s, abs (qHit.z));\n        col4 *= (0.1 + 0.9 * smoothstep (0.003, 0.008, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    } else if (idObj == idLev) {\n      col4 = (length (qHit.xz) > 0.07) ? vec4 (0.7, 0.5, 0.2, 0.05) : vec4 (0.3, 0.4, 0.1, 0.05);\n      col4 *= 0.5 + 0.5 * step (0., min (1.7 - qHit.y, length (qHit.yz) - 0.11));\n    } else if (idObj == idDial) {\n      if (length (qHit.yz) < 0.27) {\n        if (ro.z < 0.) {\n          s = 1.;\n          a = atan (qHit.z, - qHit.y) / (2. * pi);\n          if (abs (a) > 0.12) {\n            s = abs (qHit.z);\n            qHit.yz = Rot2D (qHit.yz, 2. * pi * floor (16. * a + 0.5) / 16.);\n            if (abs (qHit.y + 0.25) < 0.02) s = min (s, abs (qHit.z));\n          }\n        } else {\n          s = abs (dot (sign (Rot2D (qHit.yz, - pi * tCur)), vec2 (0.5)));\n        }\n        col4 = vec4 (1., 1., 1., 0.1) * (0.1 + 0.9 * smoothstep (0.01, 0.02, s));\n      } else col4 = vec4 (0.7, 0.7, 0., 0.2);\n    }\n  } else if (idObj <= idLit) {\n    if (idObj == idBras) {\n      col4 = vec4 (0.7, 0.7, 0., 0.2);\n      qHit.xz = abs (qHit.xz);\n      if (abs (length (qHit.xz) - 0.55) < 0.04) col4 *= 0.5 +\n         0.5 * smoothstep (0.005, 0.01, min (qHit.x, qHit.z));\n    } else if (idObj == idBox) {\n      if (abs (ro.x) < 3.) col4 = vec4 (0.3, 0.5, 0.4, 0.) * (0.5 + \n         0.5 * smoothstep (0.02, 0.03, abs (abs (qHit.x) - 0.1) - 0.01));\n      else col4 = vec4 (0.5, 0.7, 0.6, 0.1) * (0.5 + 0.5 * smoothstep (0.02, 0.03, abs (qHit.y)));\n    } else if (idObj == idFlot) {\n      col4 = vec4 (0.7, 0.3, 0.1, 0.) * (0.5 + 0.5 * smoothstep (0.02, 0.03,\n         abs (abs (qHit.z) - 0.3) - 0.05));\n    } else if (idObj == idLit) {\n      col4 = vec4 (vec3 (1., 1., 0.8) * (0.93 + 0.07 * cos (32. * pi * qHit.y)), -1.);\n    }\n  }\n  return col4;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.05 * tCur);\n  wAmp = 1.;\n  h = wvBase;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    t4 = abs (sin (t4));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz) / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\n#if FISH\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrSphDf (q, 0.1);\n  idObjEx = 1;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (SmoothMin (dMin, dFinT, 0.1), dMouth, 0.15);\n  dMin = SmoothMin (SmoothMin (dMin, dFinD, 0.02), dFinP, 0.02);\n  if (dEye < dMin) {\n    idObjEx = 2;\n    dMin = dEye;\n  }\n  return 0.9 * dMin;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  p.x = abs (abs (p.x) - 18.) - 4.;\n  return FishDf (p - fishPos);\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n#endif\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd;\n  a = atan (rd.z, rd.x) + 0.001 * tCur * sign (rd.x);\n  if (rd.y < 0.01 * Fbm1 (64. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.35, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.3 * gd);\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, rdd, rdo, colUw, ltDirF;\n  float dstObj, dstWat, eta, atFac; \n  bool unWat, hitWat;\n  eta = 1.33;\n  atFac = 3.;\n  rdo = rd;\n  unWat = (ro.y < WaveHt (ro.xz));\n  dstWat = WaveRay (ro, rd, (! unWat ? 1. : -1.));\n#if FISH\n  if (idObj == idGlas) {\n    fishAngI = 0.1 * sin (pi * tCur);\n    dstObj = ExObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) col4 = vec4 (vec3 (0.7, 0.7, 0.8) * (1. -\n         0.2 * smoothstep (-0.5, -0.3, vn.y)), 0.1);\n      else if (idObjEx == 2) col4 = vec4 (0.3, 1., 0.3, -1.);\n      if (col4.a >= 0.) {\n        ltDirF = normalize (vec3 (0., 1., 0.5));\n        col = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDirF), 0.) +\n           col4.a * pow (max (dot (reflect (rd, vn), ltDirF), 0.), 32.));\n      } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd));\n    }\n  } else dstObj = dstFar;\n#else\n  dstObj = dstFar;\n#endif\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n  }\n  if (dstObj >= dstFar) col = (hitWat == unWat) ? SkyGrndCol (ro, rd) : SeaFloorCol (rd);\n  if (! unWat) {\n    if (hitWat) col = mix (col, 0.8 * SkyGrndCol (ro, reflect (rdo, vnw)),\n       pow (1. - abs (dot (rdo, vnw)), 5.));\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) col = mix (colUw, col, min (1., exp (- atFac * dstObj / dstFar)));\n    else if (dstWat < dstFar) col = (rd.y > 0.) ? mix (colUw, col,\n       exp (- atFac * dstWat / dstFar)) : colUw;\n    else col = colUw;\n  }\n\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDirL[5];\n  vec2 vf;\n  float dstObj, nDotL, dSum, sSum, ao, wd;\n  bool isMet, exVu;\n  bSize = vec3 (4.5, 5.1, 10.);\n  winRad = 2.5;\n  tunRad = 1.55;\n  dstObj = ObjRay (ro, rd);\n  exVu = (dstObj < dstFar && (idObj == idScrn || idObj == idGlas));\n  if (dstObj < dstFar && ! exVu) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro);\n    vf = vec2 (0.);\n    if (idObj == idWal || idObj == idWalB || idObj == idWin || idObj == idWEnd || idObj == idTun ||\n       idObj == idBox) {\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idNut || idObj == idPipe) {\n      vf = vec2 (128., 0.2);\n    } else if (idObj == idWhl || idObj == idWhlS || idObj == idWhlD) {\n      vf = vec2 (128., 0.1);\n    } else if (idObj == idWhlB || idObj == idLev) {\n      vf = vec2 (64., 0.2);\n    }\n    wd = smoothstep (-0.7, 0.7, wvBase);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      ltDirL[0] = normalize (bSize * vec3 (1., 0.7, 1.));\n      ltDirL[1] = normalize (bSize * vec3 (-1., 0.7, 1.));\n      ltDirL[2] = normalize (bSize * vec3 (1., 0.7, -1.));\n      ltDirL[3] = normalize (bSize * vec3 (-1., 0.7, -1.));\n      ltDirL[4] = ltDir;\n      dSum = 0.;\n      sSum = 0.;\n      isMet = (idObj == idWal || idObj == idWalB || idObj == idComp || idObj == idDial);\n      for (int k = 0; k < 5; k ++) {\n        nDotL = max (dot (vn, ltDirL[k]), 0.);\n        if (isMet) nDotL *= nDotL;\n        dSum += ((k < 5) ? 0.7 : 1.) * nDotL;\n        sSum += ((k < 5) ? 0.7 : 1.) * pow (max (dot (normalize (ltDirL[k] - rd), vn), 0.), 64.);\n      }\n      ao = ObjAO (ro, vn);\n      col = ao * col4.rgb * (0.2 + 0.4 * dSum) + step (0.95, ao) * col4.a * sSum;\n      col *= mix (vec3 (1.), vec3 (0.6, 0.8, 1.), wd);\n    } else col = col4.rgb * (0.7 - 0.3 * dot (vn, rd)) * (1. - 0.5 * wd);\n  }\n  if (exVu) {\n    if (idObj == idGlas) {\n      ro += dstObj * rd;\n    } else {\n      ro = vec3 (0., 3., 3.);\n      rd = normalize (vec3 (qHit.xy, 2.));\n    }\n    col = ExShowScene (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2.5 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.03 * tCur, 2.);\n    az += 0.5 * pi * SmoothBump (0.25, 0.75, 0.15, mod (t, 1.)) * sign (t - 1.);\n    el += 0.1 * abs (az);\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -4.5);\n  ro.z *= 1. + abs (cos (az));\n  vuPos = ro;\n  zmFac = 3. + 1.5 * abs (sin (az));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n  sunDir = normalize (vec3 (1., 1., -1.));\n  whlAng = 0.2 * pi * sin (0.05 * pi * tCur);\n  wvBase = 2. + 7. * sin (0.03 * pi * tCur);\n#if FISH\n  fishPos = vec3 (0., wvBase - 8., mod (45. + 2. * tCur, 90.) - 45.);\n#endif\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a +\n       0.5) * pi)) / zmFac;\n    uvv.x = 2. * tan (0.5 * atan (uvv.x / asp)) * asp;\n    rd = vuMat * normalize (vec3 (uvv, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2fzz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1456, 1479, 1479, 1907], [1909, 1909, 1931, 1931, 6947], [6949, 6949, 6982, 6982, 7166], [7168, 7168, 7189, 7189, 7446], [7448, 7448, 7480, 7480, 7685], [7687, 7687, 7710, 7710, 12765], [12767, 12767, 12790, 12790, 13401], [13403, 13403, 13446, 13446, 13983], [13985, 13985, 14016, 14016, 14179], [16056, 16056, 16092, 16092, 17058], [17060, 17060, 17088, 17088, 17207], [17209, 17209, 17232, 17232, 17585], [17587, 17587, 17624, 17624, 19390], [19392, 19392, 19427, 19427, 21489], [21491, 21491, 21547, 21547, 23106], [23108, 23108, 23140, 23140, 23240], [23242, 23242, 23275, 23275, 23364], [23366, 23366, 23412, 23412, 23459], [23461, 23461, 23494, 23494, 23521], [23523, 23523, 23565, 23565, 23616], [23618, 23618, 23671, 23671, 23732], [23734, 23734, 23777, 23777, 23841], [23843, 23843, 23878, 23878, 23940], [23942, 23942, 23987, 23987, 24090], [24092, 24092, 24137, 24137, 24175], [24177, 24177, 24234, 24234, 24317], [24319, 24319, 24355, 24355, 24561], [24563, 24563, 24593, 24593, 24706], [24740, 24740, 24764, 24764, 24817], [24819, 24819, 24843, 24843, 24955], [24957, 24957, 24982, 24982, 25128], [25130, 25130, 25155, 25155, 25341], [25343, 25343, 25365, 25365, 25519], [25521, 25521, 25542, 25542, 25697], [25699, 25699, 25728, 25728, 25940], [25942, 25942, 25981, 25981, 26161]]}
{"id": "wt2yWd", "name": "Hue To RGB Visualizer", "author": "LilBensson", "description": "Visualizing hue to RGB.\n\n", "tags": ["rgb", "visualizer", "hue"], "likes": 5, "viewed": 74, "published": "Public", "date": "1597044480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I was watching Acegikmo's stream when she was making a painting app in Unity and I was \n// interested in how she converted hue to RGB. I wanted to visualize the conversion, \n// since an animation of it could be pretty cool and to explain the \n// correlation between the channels across the hue spectrum.\n\n// Acegikmo's twitch: https://www.twitch.tv/acegikmo\n\n// The upper moving black bars shows the current color.\n// The 3 horizontal bars right below shows the amount of red, green and \n// blue across the spectrum.\n// The 3 vertical bars in the middle shows the amount of red, green and \n// blue for the current color.\n\n// When a vertical bar is under the white horizontal line, then the channel\n// has a value below 0. If the top of a bar is bright, then the value is above 1.\n\n// The animation shows that all colors across the hue spectrum is only using\n// 2 channels, where the sum of the channels is 2. The exception to this is\n// when a color is strictly only red, green or blue. In that case, the single\n// channel's value is 2. The unused channels would simply be clamped to 0.\n\nvec3 HueToRGB(float hue)\n{\n    // Fractional part of each component with an added offset\n    vec3 fr = fract(vec3(hue) + vec3(0.0, -1.0/3.0, 1.0/3.0));\n    \n    // Change min/max from 0 and 1, to -1 and 2\n    vec3 s = 3.0*abs(1.0 - 2.0*fr) - 1.0;\n    \n\treturn s;\n}\n\n// Check if the current coordinate is within the bounds of a rectangle\nfloat Rectangle(vec2 uv, vec4 bounds)\n{\n\treturn (uv.x >= bounds.x && uv.x < bounds.x+bounds.z && \n           \tuv.y >= bounds.y && uv.y < bounds.y+bounds.w) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 screenCol = vec3(0.0);\n    \n    // Upper color spectrum rectangle\n    vec3 hueHere = HueToRGB(uv.x);\n    screenCol += hueHere * Rectangle(uv, vec4(0.0, 0.9, 1.0, 0.1)); \n    \n    screenCol += vec3(hueHere.r, 0.0, 0.0) * Rectangle(uv, vec4(0.0, 0.87, \t\t\t1.0, 0.03)); \n    screenCol += vec3(0.0, hueHere.g, 0.0) * Rectangle(uv, vec4(0.0, 0.87-0.03, \t1.0, 0.03)); \n    screenCol += vec3(0.0, 0.0, hueHere.b) * Rectangle(uv, vec4(0.0, 0.87-0.03*2.0, 1.0, 0.03)); \n    \n    // Moving current colored box\n    float xPos = fract(iTime*0.1);\n    vec3 currentCol = HueToRGB(xPos);\n    vec3 movingBoxColor = currentCol * Rectangle(uv, vec4(xPos-0.005, 0.9, 0.02, 0.1));\n    \n    screenCol = mix(screenCol, vec3(0.0), Rectangle(uv, vec4(xPos-0.01, 0.9, 0.01+0.01+0.01, 0.1)));\n    screenCol += movingBoxColor;\n    \n    // Visualizers\n    screenCol += vec3(1.0, 0.0, 0.0) * Rectangle(uv, vec4(0.5-0.2-0.2, \t0.3 + min(currentCol.r*0.2, 0.0), 0.2, abs(currentCol.r*0.2)));\n    screenCol += vec3(0.0, 1.0, 0.0) * Rectangle(uv, vec4(0.5-0.1, \t\t0.3 + min(currentCol.g*0.2, 0.0), 0.2, abs(currentCol.g*0.2)));\n    screenCol += vec3(0.0, 0.0, 1.0) * Rectangle(uv, vec4(0.5+0.2, \t\t0.3 + min(currentCol.b*0.2, 0.0), 0.2, abs(currentCol.b*0.2)));\n    \n    // Value is negative\n    screenCol -= vec3(0.6) * Rectangle(uv, vec4(0.0, 0.0, 1.0, 0.3-0.002));\n    \n    // Value is more than one\n    vec3 colLastTime = clamp(floor(vec3(1.0) - screenCol), 0.0, 1.0); \n    screenCol += vec3(0.6) * Rectangle(uv, vec4(0.0, 0.3 + 0.2, 1.0, 0.2)) * (1.0 - colLastTime.r * colLastTime.g * colLastTime.b);\n    \n    \n    // White line in the middle\n    screenCol += Rectangle(uv, vec4(0.0, 0.3-0.002, 1.0, 0.002*2.0));\n    \n    // Gamma correction\n    screenCol = clamp(screenCol, 0.0, 1.0);\n    screenCol = pow(screenCol, vec3(0.454545));\n    \n    // Output to screen\n    fragColor = vec4(screenCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[784, 1091, 1117, 1179, 1355], [1357, 1428, 1467, 1467, 1598], [1600, 1600, 1657, 1657, 3578]]}
{"id": "WtBBD1", "name": "can of worms", "author": "FabriceNeyret2", "description": "use divergence-free flownoise to distort a base function ( here, radial gradient )", "tags": ["perlinnoise", "displacement", "distortion", "flownoise", "filament", "divergencefree"], "likes": 7, "viewed": 259, "published": "Public API", "date": "1598770748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  #define hash(p)    fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n//#define hash2(p) ( 2.* fract( sin( (p) * mat2(127.1,311.7, 269.5,183.3) ) *43758.5453123 ) - 1. )\n  #define hash2(p)   cos( 6.28*hash(p) + vec2(0,11) + V(p)*iTime ) // variant of random gradient + rotating (= lownoise)\n  #define l(i,j)     dot( hash2(I+vec2(i,j)) , F-vec2(i,j) )       // random wavelet at grid vertex I+vec2(i,j) \n  #define L(j,x)     mix( l(0,j), l(1,j), x )\n\n  #define V(p) 2.                                // flownoise rotation speed \n//#define V(p) 2.*( 2.*mod((p).x+(p).y,2.)- 1. ) // checkered rotation direction \n//#define V(p) length(p)\n//#define V(p) ( 8. - length(p) )\n\nfloat Perlin(vec2 p) {                        // Perlin noise\n    vec2 I = floor(p), \n         F = fract(p), \n     //  U = F;\n     //  U = F*F*(3.-2.*F);                   // based Perlin noise\n         U = F*F*F*( F* ( F*6.-15.) + 10. );  // improved Perlin noise ( better derivatives )\n    return mix( L(0,U.x) , L(1,U.x) , U.y );  // smooth interpolation of corners random wavelets\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         S = 8. / R.yy,\n         U = ( 2.*u - R ) * S,\n         D;\n    float v = Perlin( U );                    \n // O = vec4( .5 + .5 * v ); return;          // see Perlin noise\n    \n                                              // --- divergence-free displacement noise\n // D = vec2( v - Perlin( U+vec2(0,S.y) ), Perlin( U+vec2(S.x,0) ) - v ) *2./ S;\n    D = vec2( -dFdy(v), dFdx(v) ) / S;        // using hardware derivatives\n // O = vec4( .5 + .5 * D, 0, 0); return;     // see noise vector\n // O = vec4(.5+.5*atan(D.y,D.x)/3.14); return;// see noise direction\n // D += .5*U; O = vec4(.5+.5*atan(D.y,D.x)/3.14); return;// see noise direction\n    \n    v = length( U + 1.*D );                   // distorted distance\n // O = vec4( v / 10. );                      // see\n // O = vec4( v / max(2.,1.5*length(U)) );    // renormalize by distance\n    O = vec4( v / max(1.5,.5*dot(U,U)) );     // renormalize by distance then div by dist\n // O = vec4( .5 + .5 * sin(v) );             // distorted concentric circles\n // O = vec4( .01* v / fwidth(v) );\n    O *= vec4(1.3,.8,.5,0);                   // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 677, 699, 738, 1063], [1065, 1065, 1103, 1103, 2242]]}
{"id": "wtBBRD", "name": "Raymarch Melt", "author": "AngryKnees", "description": "Raymarched deformed sphere heavily inspired by:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm", "tags": ["raymarching"], "likes": 4, "viewed": 65, "published": "Public", "date": "1598402890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// boilerplate from jlfwong @ https://www.shadertoy.com/view/Xtd3z7\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float time = iTime * 0.5;\n    float y = samplePoint.y;\n    \n    float angle;\n    angle += sin(y + time);\n    angle += sin(y * 1.5 + time * 0.5) * 1.25;\n    angle += sin(y * 2.3 + time * 1.7) * 1.563;\n    angle += sin(y * 3.1 + time * 3.2) * 1.953;\n    angle += sin(y * 0.1 + time * 0.2) * 2.441;\n    angle += sin(y * 1.1 + time * 1.2) * 3.052;\n    \n    angle = angle * 3.14159 + 3.14159;\n    \n    vec3 offset = vec3(sin(angle), 0.0, cos(angle)) * 0.05;\n    return sphereSDF(samplePoint + offset);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N), 0.0, 1.0);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 color = k_a;\n    \n    float s = sin(iTime);\n    float c = cos(iTime);\n    \n    vec3 light1Pos = vec3(4.0 * s,\n                          2.0,\n                          4.0 * c);\n    vec3 light1Intensity = vec3(0.4) + s * 0.1;\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.1) + c * 0.1;\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transformation matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 2.0, 5.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.211, 0.223, 0.247, 1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.211, 0.223, 0.247);\n    vec3 K_d = vec3(0.921, 0.690, 0.192);\n    vec3 K_s = vec3(0.921, 0.690, 0.192);\n    float shininess = 500.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBBRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 282, 317, 317, 357], [359, 599, 633, 633, 1136], [1138, 1559, 1650, 1650, 1956], [1971, 2225, 2290, 2290, 2422], [2424, 2513, 2542, 2542, 2852], [2854, 3346, 3486, 3486, 4093], [4095, 4465, 4550, 4550, 5317], [5319, 5633, 5682, 5682, 5869], [5872, 5872, 5929, 5929, 6797]]}
{"id": "WtBBWD", "name": "Gem rejuvenator", "author": "sukupaper", "description": "\"Gem Rejuvenator\" from Steven Universe", "tags": ["raymarching", "gem", "asset", "stevenuniverse"], "likes": 12, "viewed": 153, "published": "Public", "date": "1598901965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: paperu\n// Title: Gem Rejuvenator\n\nfloat t, closed, intensity, closedShifted;\n#define P 6.283185307\n\nfloat bezier(in float p1, in float p2, in float p3, in float p4, in float t){\n    float a = mix(p2,p3,t);\n    return mix(mix(mix(p1,p2,t),a,t),mix(a,mix(p3,p4,t),t),t);\n}\n\nfloat anim1(in float x, in float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - .5);\n}\nfloat anim2(in float x, in float sm){\n  float xmd = mod(x,2.) - .5;\n  return smoothstep(-sm,sm,xmd + .05) - smoothstep(-sm,sm,xmd - .52);\n}\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec2 fold(in vec2 p, in float a){ vec2 n = vec2(cos(-a),sin(-a)); return p - 2.*min(0.,dot(p,n))*n; }\n\nfloat box(in vec3 p, in vec3 s, in float r) { return length(max(abs(p) - s,0.)) - r; }\nfloat cyl(in vec3 p, in float h, in float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat ci(in vec2 p, in float s) { return length(p) - s; }\nfloat scytheBlade2dsdf(in vec2 p, in float intensity) {\n    p.x += cos(p.y*1500. + t*20.)*.008*intensity;\n\tp.x -= .069;\n    float d = max(max(-ci(p + vec2(.08,.43),.6),ci(p + vec2(.138,.31),.625)),-max(-ci(p + vec2(-.025,.305),.6),ci(p + vec2(.31,.365),.6)));\n    float d2 = min(ci(p + vec2(.172,-0.16),.078),min(ci(p - vec2(.028,0.15),.067),min(ci(p + vec2(.21,-.382),.15),ci(p - vec2(.105,.35),.15))));\n    d2 -= cos(t*40.)*mix(.002,.0001,intensity);\n    d = max(d,-max(max(d - 1.,-d2),(abs(-p.x - .07) - .12)));\n    d = max(max(d,-p.y - .2),-p.x - .5);\n    d -= cos(t*100.)*.001*intensity;\n    return d;\n}\nfloat scytheBlade3dsdf(in vec3 p, in float h, in float intensity) {\n    float c = closedShifted;\n    float d = scytheBlade2dsdf(p.xy, intensity);\n    d = max(d,ci(p.xy - vec2(0.,.2),.75 - c*2. - .05*cos(atan(p.x,p.y + .2)*20.)));\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat crystal(in vec3 p) {\n    float c = closed;\n    float s = 2.25 + 4.*c;\n    p.y -= 0.21 - .8*c;\n    p *= s;\n    float d = box(p,vec3(.5,.5,.025),.001);\n    d = max(d,dot(abs(p) - .03,normalize(vec3(2.,0.,1.8))));\n    d = max(d,dot(vec3(abs(p.x) - .015,-p.y,abs(p.z) - .01),normalize(vec3(.7,.8,1.8))));\n    d = max(d,dot(vec3(abs(p.x) - 0.098,p.y,abs(p.z) - .01),normalize(vec3(.5,.3,1.))));\n    return d/s;\n}\nfloat crystalSupport(in vec3 p) {\n    float c = closed;\n    p.y -= .19 - .8*closed;\n    return cyl(p,.009,.01);\n}\nfloat handleHead(in vec3 p) {\n    float c = closed;\n    p.y -= .12 - .8*c;\n    float h = p.y - .05;\n    return cyl(p,.018 - h*mix(-.07,.5,step(0.,h)) - .005*c,.06);\n}\nfloat handleBody(in vec3 p) {\n    float c = closed;\n    p.y += .3 + c*.35;\n    return cyl(p,.009,.42 - c*.42);\n}\nfloat handle(in vec3 p) {\n    p.y += .65;\n    float h = abs(p.y) - 0.075;\n    return cyl(p,.015 - h*mix(0.,.75,step(0.,h)),.1);\n}\nfloat handleButton(in vec3 p) {\n    p.xy += vec2(-.009,.61);\n    return box(p,vec3(.01,.0075,.0025),.001);\n}\n\nfloat bladeRotAnim(in float x) {\n    x = mod(x,4.);\n    float b = x < 1. ? bezier(0.0,.1,1.5,.0,x)\n        : x < 2. ? bezier(0.0,-2.,-2.,0.0,x - 1.)\n        : x < 3. ? bezier(0.0,1.0,0.1,0.0,x - 2.)\n        : x < 4. ? bezier(0.0,-0.1,-0.1,0.0,x - 3.)\n        : 0.;\n    return b;\n}\nfloat bladeRotAnim2(in float x) {\n    float t = mod(x,4.);\n    float b = \n          t < 1. ? bezier(0.0,0.0,0.0,0.1,t)\n        : t < 2. ? bezier(0.1,0.2,1.0,2.0,t - 1.)\n        : t < 3. ? bezier(2.0,3.0,3.0,3.0,t - 2.)\n        : 0.;\n    return b + floor(x/3.)*3.;\n}\n\nfloat distFromBlade;\nstruct Dm { float dist; int mat; };\nDm df(in vec3 p) {\n    p.y = abs(p.y + .6) - .7 + cos(t*2.5)*.1;\n\tp.xz *= rot(cos(t*.5)*.5);\n    float animA = bladeRotAnim(t);\n    float intensity = (bladeRotAnim(t + .01) - animA)/.01;\n\tp.xy *= rot(animA*P*.2*(1. - closed));\n    p.y -= .15;\n\tp.xz *= rot(-bladeRotAnim(t - 3.)*1.85);\n    p.y -= .45*closed;\n    \n    float scytheBlade = scytheBlade3dsdf(p,.001,intensity);\n    float crystal = crystal(p);\n    float crystalSupport = crystalSupport(p);\n    float handleHead = handleHead(p);\n    float handleBody = handleBody(p);\n    float handle = handle(p);\n    float handleButton = handleButton(p);\n    \n    float d = min(min(min(min(min(min(scytheBlade,crystal),crystalSupport),handleBody),handleHead),handle),handleButton);\n    \n    Dm m;\n    m.dist = d;\n    m.mat = d == scytheBlade ? 1\n    \t: d == crystal ? 2\n        : d == crystalSupport || d == handleButton ? 3\n        : d == handleBody ? 4\n        : d == handleHead ? 5\n        : 6;\n    distFromBlade = scytheBlade;\n    return m;\n}\n\nvec3 normal(in vec3 p) { float d = df(p).dist; vec2 u = vec2(0.,.001); return normalize(vec3(df(p + u.yxx).dist,df(p + u.xyx).dist,df(p + u.xxy).dist) - d); }\n\n#define MAX_D 5.\n#define MIN_D 0.1\n#define LIM .001\n#define MAX_IT 90\nstruct RmRes { vec3 pos; int it; bool hit; int mat; };\nRmRes rm(in vec3 c, in vec3 r) {\n    RmRes res;\n    res.pos = c + r*MIN_D;\n    res.hit = false;\n    Dm m;\n    for(int i = 0; i < MAX_IT; i++) {\n        m = df(res.pos);\n        if(m.dist < LIM) { res.it = i; res.hit = true; break; }\n        if(distance(c,res.pos) > MAX_D) { res.it = i; break; }\n        res.pos += m.dist*r*.95;\n    }\n    res.mat = m.mat;\n    return res;\n}\n\nvec3 colorMain(in vec2 st) {\n    vec3 c = vec3(0.,0.,-3.);\n    vec3 r = normalize(vec3(st,2.));\n\n    RmRes res = rm(c,r);\n    \n    vec3 color = vec3(.04,0.,.04) - length(st)*.03;\n    vec3 ambientColor = vec3(1.);\n    \n    if(res.hit) {\n        vec3 n = normal(res.pos);\n        \n        vec3 matColor = res.mat == 1 ? vec3(1.)\n            : res.mat == 2 ? vec3(.874,.129,.447)\n            : res.mat == 3 ? vec3(.819,.360,.6)\n            : res.mat == 4 ? vec3(.427,.090,.266)\n            : vec3(.603,.035,.305);\n        \n        if(res.mat == 2) color = mix(ambientColor,matColor,clamp(pow(dot(n,r),2.)*1.25,0.,1.));\n        else if(res.mat == 1) color = matColor;\n        else {\n            color = matColor*(1.8 - dot(n,-r))*clamp(1. - distFromBlade*2.,.2,1.);\n            if(res.mat == 5) {\n                RmRes resReflect = rm(res.pos - r*.1,reflect(r,n));\n            \tif(resReflect.hit && resReflect.mat == 1) color += 1.;\n            }\n        }\n    }\n    color *= mix(1.1,.25,closed);\n    color += pow(float(res.it)/30.,2.)*vec3(1.,.415,.738);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    t = iTime + 2.8;\n    closed = anim1(t*.2,.05);\n    closedShifted = anim2(t*.2,.075);\n    \n    vec3 color = colorMain(st);\n    \n    fragColor = vec4(color*2. - length(st*mix(.02,.35,closed)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 111, 188, 188, 281], [283, 283, 320, 320, 415], [416, 416, 453, 453, 555], [557, 557, 580, 580, 644], [645, 645, 667, 667, 712], [713, 713, 746, 746, 814], [816, 816, 861, 861, 902], [903, 903, 949, 949, 1054], [1056, 1056, 1089, 1089, 1113], [1114, 1114, 1169, 1169, 1722], [1723, 1723, 1790, 1790, 2043], [2045, 2045, 2071, 2071, 2458], [2459, 2459, 2492, 2492, 2572], [2573, 2573, 2602, 2602, 2739], [2740, 2740, 2769, 2769, 2852], [2853, 2853, 2878, 2878, 2982], [2983, 2983, 3014, 3014, 3091], [3093, 3093, 3125, 3125, 3373], [3374, 3374, 3407, 3407, 3639], [3698, 3698, 3716, 3716, 4688], [4690, 4690, 4714, 4714, 4848], [4975, 4975, 5007, 5007, 5348], [5350, 5350, 5378, 5378, 6421], [6423, 6423, 6478, 6478, 6769]]}
{"id": "WtBBzh", "name": "sun and sea", "author": "crazyshark12", "description": "code is awful, and i dont understand why it works, but works ! ", "tags": ["sun"], "likes": 1, "viewed": 51, "published": "Public", "date": "1598299976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x - 0.5;\n    uv.y=uv.y- 0.5;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    vec2 Pos = vec2 (0.7,-0.1*1.5*sin(iTime));// position of the sun \n    float d = length ( uv - Pos);\n    float radius = 0.05;\n    float col = smoothstep(radius, radius-0.01, d);\n\n\nvec3 color = vec3(1.,sin(iTime+3.14)*(1.8-col),1.*(1.1-col));\n    vec3 blue = vec3 (0.5,0.5,1.);\n    if (uv.y > -0.2)\n    {\n        blue = blue + vec3(uv.y,uv.y,0.);\n    }\n    else\n        blue = blue - vec3(0.9+uv.y*2.,0.9+uv.y*2., 0.);\n    vec3 last = mix(color,blue,1.-col);\n    \n    \nvec3 colorA = vec3(0.5,0.0,0.0);\nvec3 grad = (1.1-d)*1.3* colorA;    \nvec3 lastLast= mix(last,grad, 0.8*(2.-col)*(-Pos.y+0.2));\n    fragColor = vec4(lastLast,1.0);     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 141], [142, 142, 199, 199, 979]]}
{"id": "wtBfRm", "name": "Polar Weave Pattern - simple", "author": "FabriceNeyret2", "description": "reproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\nchange s = 2Pi / N by any N you like\n\n( golfed here: [url]https://www.shadertoy.com/view/3l2fzw [/url] )", "tags": ["2d", "repetition", "pattern", "polar", "short", "weave"], "likes": 14, "viewed": 244, "published": "Public API", "date": "1598545718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D U = l *cos(a + vec2(0,11)) ;                                         \\\n          d = abs( length(U-vec2(r,0)) - r*sin(s/2.)); /* dist in ribbon    */ \\\n          m = clamp(1.- R.y/4.* (d-.1),0.,1.);         /* antialiased mask  */ \\\n          O += T * m * min( 1.+.5*cos(2e2*d), 1.);     /* pattern in ribbon */ \\\n       /*        *( .7 + .3* cos(atan(U.y,U.x-r)) );    */                     \\\n          T *=   1.-m                                  /* for blending      */\n              \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    O -= O;\n    vec2  R = iResolution.xy,\n          U = 2.*u - R;\n    float s = 6.28/8., r=.5, d, m, T = 1.,\n          a = mod( atan(U.y,U.x) + iTime/2. , s ), // wrap all to main 1/8 pie slice\n          l = length(U) / R.y,                     // \n          L = l * cos(a-s/2.) / cos(s/2.);         // line between 2 disks center\n                \n    a -= L > r ? s : 0.;               // at crossing, decide which pie win (i.e. is on top)\n    D;                                 // draw ribbon \n\n    a += L > r ? s : -s;               // same for background slice\n    D;\n // O.b += float(L<r);  O.r -= M;      // for debug\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBfRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 585, 624, 624, 1251]]}
{"id": "WtBfzR", "name": "Generative tiles z", "author": "illus0r", "description": "Generative tiles z", "tags": ["raymarchingfractalarchitecture"], "likes": 7, "viewed": 218, "published": "Public API", "date": "1598146337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n#define IVORY 1.\n#define BLUE 2.\n#define BLACK 3.\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\nfloat sdTorus(vec3 p, float smallRadius, float largeRadius) {\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\nvec2 getDist(vec3 p) {\n    p.y -= 0.5;\n    vec2 plane = vec2(p.y+0.5, IVORY);\n    float step = 1.5;\n    p.x += iTime;\n    p.z -= iTime;\n    \n    vec3 pFrame = p;\n    pFrame.xz -= step / 2.;\n    pFrame.xz = mod(pFrame.xz, step) - step / 2.;\n    pFrame.xz *= Rot(PI / 4.);\n    pFrame.xz = abs(pFrame.xz);\n    pFrame.xz *= Rot(PI / 4.);\n    pFrame.xy *= Rot(PI / 4.);\n    float frame = sdBox(pFrame, vec2(0.074, step / 2.).xxy);\n    \n    vec2 id = floor(p.xz / step);\n    p.xz = mod(p.xz, step) - step / 2.;\n    //p.xz *= Rot(iTime / 4.);\n    vec3 pBox = p;\n    // pBox.xz /= 100.;// * (.5 + .5 * sin(iTime));\n    //vec3 pTiles = p;\n    float t = iTime;\n    t = floor(t) + smoothstep(0.4, 0.6, fract(t));\n\tp.y += sin(id.x + id.y * 2. + t / 10.);\n    float box = sdBox(pBox, vec2(0.05, step / 2.).yxy);\n    //p.yz *= Rot(PI / 2.);\n    float scale = 0.7;\n    vec2 torus = vec2(sdTorus(p, .4, 1.5), BLUE);\n    for (int i = 0; i < 7; i++) {\n\t\tp.xz = abs(p.xz);\n        p.xz -= 1.;\n        p /= scale;\n        p.yz *= Rot(PI / 2.);\n\t    p.xy *= Rot(PI / 4.);\n        vec2 newTorus = vec2(sdTorus(p, .4, 1.5) * pow(scale, float(i+1)), BLUE);\n        torus = torus.x < newTorus.x? torus : newTorus;\n    }\n    torus = box < torus.x ? torus : vec2(box, 0);\n    vec2 fractalAndPlane = torus.x < plane.x? torus : plane;\n    //torus.x -=  - 0.03;\n    return fractalAndPlane.x < frame ? fractalAndPlane : vec2(frame, BLACK);\n}\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float minAngleToObstacle = 1e10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec3(d, info, minAngleToObstacle);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\n\n\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= Rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(-3, 5, 3);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = getRayDir(uv, ro, vec3(0), 0.75);\n    \n    vec3 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 colorBg = vec3(0.233,0.715,0.920);\n    vec3 color = vec3(0);\n    vec3 light = vec3(50);\n    //light.xz *= Rot(iTime);\n    vec3 p = ro + rd * d;\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(p);\n        //n.zy *= Rot(iTime);\n    \t//color = vec3( n + 1.0 );\n        //color *= info;\n        // vec3 tex = boxmap(u_tex_bg, ro + rd * d, n, 32.0 ).xyz;//\n        // self shadeing\n        color_bw = 0.5 + .5 * dot(n, normalize(light - p));\n        // drop shadeos\n        // trying to raymarch to the light for MAX_DIST\n        // and if we hit something, it's shadow\n        vec3 dirToLight = normalize(light - p);\n        vec3 rayMarchLight = rayMarch(p + dirToLight * .5, dirToLight);\n        float distToObstable = rayMarchLight.x;\n        float distToLight = length(light - p);\n        // if (distToObstable < distToLight) {\n        //     color_bw =  0.;\n        // }\n\n        // smooth shadows\n        float shadow = smoothstep(0.0, .1, rayMarchLight.z / PI);\n        color_bw *= .7 + .3 * shadow;\n        \n\n        // tex *= color_bw;\n        // color = tex;\n    }\n    color += 0.6 + vec3( color_bw );\n    // coloring\n    if (info == IVORY) {\n        color *= vec3(0.433,0.457,0.545);\n    }\n    else if (info == BLUE) {\n        color *= vec3(0.655,0.129,0.054);\n    }\n    else if (info == BLACK) {\n        color *= vec3(0.130,0.130,0.130);\n    }\n    color = mix(color, colorBg, smoothstep(20., 28., d));\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 160, 160, 223], [225, 225, 263, 263, 292], [293, 293, 324, 324, 407], [410, 410, 471, 471, 545], [549, 628, 650, 650, 2038], [2039, 2123, 2156, 2156, 2625], [2627, 2627, 2651, 2651, 2869], [2874, 2874, 2928, 2928, 3155], [3157, 3157, 3207, 3207, 3398], [3401, 3401, 3457, 3457, 5250]]}
{"id": "WtfBD2", "name": "Reflect shader Testing", "author": "ptemoche", "description": "I am learning.\nIt's not the best way but I am trying.", "tags": ["raymarching", "reflection", "antialiasing"], "likes": 6, "viewed": 117, "published": "Public", "date": "1597779581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_DIST 0.01\n#define AA 8\n#define rn 4\n#define normal_desv 0.0\n#define eAA 0.001\n#define wAA 9.0\n\nmat3 RotY(float angle){\n \n    return mat3(cos(angle), 0.0,sin(angle),\n                0.0,       1.0,0.0       ,\n                -sin(angle),0.0,cos(angle));\n    \n}\n\nfloat hash21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nvec3 hash33(vec3 p){\n \n    return vec3(hash21(p.xy),hash21(p.yz),hash21(p.xz));\n}\n\nvec4 min_v4(vec4 a, vec4 b){\n \treturn(a.w<b.w)?a:b;   \n}\n\nvec4 sd_sphere(vec3 p, vec4 s, vec3 mat){\n    return vec4(mat,length(p-s.xyz)-s.w);\n}\nvec4 sd_cel(vec3 p, vec4 s, vec3 mat){\n    vec3 pos = sin(p*10.0+iTime)*0.5;\n    \n    float l = (length(p-s.xyz)-s.w+(pos.x*pos.y*pos.z))*0.5;\n    return vec4(mat,l);\n}\nvec4 sd_plane(vec3 pos, vec3 N, float d, vec3 mat){\n \n    vec3 p = pos*N;\n        \n    return vec4(mat,(d+p.x+p.y+p.z)*0.5);\n    \n}\n\n\n\nvec4 map(vec3 pos){\n \n    vec4 d = sd_sphere(pos, vec4(0.75,sin(iTime*2.0)*0.5,4.0+cos(iTime*2.0),0.45),vec3(0.7,0.1,0.1));\n    d = min_v4(d,sd_cel(pos, vec4(-1,0,4,0.45),vec3(0.1,0.9,0.9)));\n    d = min_v4(d,sd_sphere(pos, vec4(-1,-1,4.5,0.5),sin(pos*10.0)*0.5+0.5 ));\n    d = min_v4(d,sd_sphere(pos, vec4(-0.1,-1.1,4.6,0.4),sin(pos+iTime*5.0)*0.5+0.5));\n    d = min_v4(d,sd_sphere(pos, vec4(-0.5,-1.3,3.5,0.2),vec3(0.05,0.05,0.05)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,1.0,0.0),1.5,vec3(0.95,0.95,0.95)));\n    d = min_v4(d,sd_plane(pos,vec3(1.0,0.0,0.0),1.5,vec3(0.5,0.25,0.5)));\n    d = min_v4(d,sd_plane(pos,vec3(-1.0,0.0,0.0),1.5,vec3(0.1,0.1,0.95)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,-1.0,0.0),1.5,vec3(0.95,0.95,0.1)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,0.0,-1.0),5.0,vec3(0.1,0.95,0.1)));\n    d = min_v4(d,sd_plane(pos,vec3(0.0,0.0,1.0),1.0,vec3(0.1,0.95,0.1)));\n   \n   \n    \n    return d;\n}\n\nvec4 raymarching(vec3 o, vec3 dir){\n    \n    float d = 0.0;\n    vec4 t = vec4(0);\n    \n    for(int i = 0; i<MAX_STEPS;++i){\n     \tvec3 pos = o+dir*d;\n        t = map(pos);\n        d+=t.w;\n        \n        if(abs(t.w)<MIN_DIST || d>MAX_DIST)\n            break;\n    }\n    \n    t.w = d;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos){\n \n    vec2 e = vec2(0.01,0.0);\n    \n    return normalize(map(pos).w-vec3(\n    \t\t\t\t\t\tmap(pos-e.xyy).w,\n        \t\t\t\t\tmap(pos-e.yxy).w,\n        \t\t\t\t\tmap(pos-e.yyx).w\n    \t\t\t\t\t\t)+sin(hash33(pos))*normal_desv);\n    \n}\n\nfloat getLigth(vec3 pos){\n \n    vec3 ligth  = vec3(1,1,3);\n    vec3 l = normalize(pos-ligth);\n    vec3 N = getNormal(pos);\n    float dif = clamp(dot(N,-l),0.0,1.0);\n    float spec = pow(clamp(dot(-l,reflect(normalize(pos),N)),0.0,1.0),200.0);\n    float amb = clamp(dot(N,normalize(vec3(0.0,-1.0,-1.0))),0.0,1.0);\n    float fresnel = 1.0-clamp(dot(N,normalize(-pos)),0.0,1.0);\n    float l_d = dif*0.4+spec*0.9+amb*0.1+fresnel*0.75;\n    \n    float d = raymarching(pos+N*0.1,-l).w;\n    \n    if(length(ligth-pos)>d)\n        l_d*=0.95;\n    \n\treturn l_d;    \n}\n\nvec3 getColor(vec3 origin, vec3 dir,int bounce){\n \n    vec3 col = vec3(0.0);\n    \n    \n    \n    for(int i = 0; i < bounce;++i){\n     \n        vec4 r_pos = raymarching(origin,dir);\n    \n        vec3 p = origin+dir*r_pos.w;\n\t\t\n        col += r_pos.xyz*getLigth(p)*(pow(2.0,float(bounce-1-i))/(pow(2.0,float(bounce))-1.0));\n        \n        \n        dir = reflect(normalize(p-origin),getNormal(p));\n        origin = p+dir*0.05;\n          \n    }\n    \n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec2 rot = (iMouse.xy*6.2831)/iResolution.xy;\n    vec3 origin = vec3(sin(rot),0.0);\n    vec3 dir = normalize(vec3(uv,1.0+origin.z)-origin);\n    \n    \n\tcol = (getColor(origin, dir, rn)*wAA)/(float(AA)+wAA);\n    \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir = normalize(dir+sampling[i]);\n\n        col += getColor(origin,dir,1)/(float(AA)+wAA);\n        \n    }\n    //col = pow(col, vec3(0.4545));\n    // Output to screen\n    if(0.2126*col.r+0.7152*col.g+0.0722*col.b<0.6)\n        col*=1.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 175, 175, 316], [318, 318, 340, 340, 419], [421, 421, 441, 441, 502], [504, 504, 532, 532, 560], [562, 562, 603, 603, 647], [648, 648, 686, 686, 816], [817, 817, 868, 868, 948], [952, 952, 971, 971, 1866], [1868, 1868, 1903, 1903, 2172], [2174, 2174, 2199, 2199, 2412], [2414, 2414, 2439, 2439, 2968], [2970, 2970, 3018, 3018, 3444], [3446, 3446, 3503, 3553, 4501]]}
{"id": "wtfBDf", "name": "Warped Extruded Skewed Grid", "author": "Shane", "description": "A warped extruded skewed dual tile grid, rendered in an early 2000s demoscene style. :)", "tags": ["grid", "demo", "square", "quad", "extruded", "dystopian", "skewed"], "likes": 276, "viewed": 13801, "published": "Public API", "date": "1597929249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Warped Extruded Skewed Grid\n    ---------------------------\n\n    This is a warped extruded skewed grid, rendered in an early 2000s demoscene \n    style. In particular, the grid cell centers have been skewed into position, \n    then two different sized nonskewed squares have been constructed around them\n    to form a pinwheel arrangement.\n\n\tI've been putting up a bunch of tech-like examples lately, so to break the\n\tmonotony for myself, I decided to code something artsy and more reminiscent \n    of a cliche 2000s demo scene. A lot of 2000s demos were rendered in a grungey \n    dystopian graphic art style, so I kind of went with that. On the technical \n    side, it's a demonstration of grid construction consisting of two different \n    kinds of tiles rendered in a staggered fashion. There's nothing in here \n    that's particularly difficult to implement.\n\n\tOne of the many things I've always admired about demo coders in general is \n    their ability to identify the most visually enticing effects that can be\n    produced with the least amount of effort on whatever machine they're running \n    on.\n\n\tI've attempted to emulate that philosophy by employing a few simple \n    techniques that demoscoders take for granted. These include things like\n    rendering minor details outside the main loop and concentrating on the cheap \n    aspects that have the largest visual impact, like color palettes and camera \n    motion.\n\n    Decent color palettes and textures usually account for a large part of the \n    the final image, and they cost virtually nothing. Camera movements can add \n    interest to a scene, and in the grand scheme of things are very cheap to \n    implement. Warping space can be a little fiddly, especially when positioning \n    lights and so forth, but it's also cheap and interesting, so I've made use\n    of that too.\n\n    The only thing here that I'd consider new is the grid arrangement. I like it \n    because it's a completely ordered grid that looks randomized in height map \n    form, which makes it visually interesting and relatively cheap to produce. \n    Having said that, there are still 8 taps and some skewing involved, so it's \n    probably not the kind of scene that a slow system would be happy with.\n\n    The frame rate in window form was surprisingly better than I'd expected. \n    Having said that, I'm on a pretty quick machine, and it doesn't like running \n    in fullscreen, so it's all relative. There are at least two things that could\n    improve performance (like face and height storage), but that would be at the \n    expense of readability, so I'm going to leave it alone.\n\n    By the way, for anyone interested in just the grid code, I'll put up a much\n\tsimpler example later.\n\n\n\n    More interesting tilings:\n\n    // Tiling on steroids. Very cool.\n    Wythoffian Tiling Generator - mla\n    https://www.shadertoy.com/view/wlGSWc\n    //\n    Based on:\n    // \n\tWythoff Uniform Tilings + Duals - fizzer\n\thttps://www.shadertoy.com/view/3tyXWw\n    //\n    Tilings - knighty\n    https://www.shadertoy.com/view/4sf3zX\n\n\n*/\n\n\n#define SKEW_GRID\n\n// Snap the pylons to discreet height units. It looks neater, but I wanted \n// haphazored heights, so it's off by default.\n//#define QUANTIZE_HEIGHTS\n\n// Flattening the grid in order to discern the 2D face pattern more clearly.\n//#define FLAT_GRID\n\n// Grid positioning independant of the camera path.\n//#define PTH_INDPNT_GRD\n\n// Grayscale, for that artsy look. Technically, a touch of color has been \n// left in, but the palette has a gray feel.\n//#define GRAYSCALE\n\n// Reverse the color palette.\n//#define REVERSE_PALETTE\n\n// Max ray distance: If deliberately set this up close for artistic effect (and to\n// save a few cycles), but you'd normally set this higher to put the horizon further away.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the floor object from the pylons.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// vec3 to float.\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\n\n// The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\n\n// 2D texture function.\n//\nvec3 getTex(in vec2 p){\n    \n    // Stretching things out so that the image fills up the window.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p/8.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n    \n    // Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;    \n}\n\n/*\n// IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*/\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n\n// A dual face extruded block grid with additional skewing. This particular one\n// is rendered in a pinwheel arrangement.\n//\n// The idea is very simple: Produce a skewed grid full of packed objects.\n// That is, use the center pixel of each object within the cell to obtain a height \n// value (read in from a height map), then render a pylon at that height.\n \n// Global local coordinates. It's lazy putting them here, but I'll tidy this up later.\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale... Kind of redundant here, but sometimes there's a distinction\n    // between scale and dimension.\n\tconst vec2 scale = vec2(1./5.);\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; // Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; // Pylon height.\n\n\n    // Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        // The larger grid cell face.\n        //\n        vec2 idi1 = idi; // Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)/20.; // Discreet height units.\n        #endif\n        h1 *= hs; // Scale the height.\n        \n        // Larger face and height extrusion.\n        float face1 = sBoxS(p, 2./5.*dim - .02*scale.x, .015);\n        //float face1 = length(p) - 2./5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        // The second, smaller face.\n        //\n        //vec2 offs = vec2(3./5., -1./5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  // Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)/20.; // Discreet height units.\n        #endif\n        h2 *= hs; // Scale the height.\n     \n        // Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1./5.*dim - .02*scale.x, .015);\n        //float face2 = length(p - offs) - 1./5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        // Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        //face1Ext += face1*.25;\n        //face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            // Setting the local coordinates: This is hacky, but I needed a \n            // copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// Speaking of lazy, here's some global glow variables. :D\n// Glow: XYZ is for color (unused), and W is for individual \n// blocks.\nvec4 gGlow = vec4(0);\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Wrap the scene around the path. This mutates the geometry,\n    // but it's easier to implement. By the way, it's possible to\n    // snap the geometry around the path, and I've done that in\n    // other examples.\n    p.xy -= path(p.z);\n    \n    // Twist the geometry along Z. It's cheap and visually effective.\n    // Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    // Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    // There are gaps between the pylons, so a floor needs to go in\n    // to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    // Keep the blocks independent of the camera movement, but still \n    // twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    // Only alowing certain blocks to glow. We're including some \n    // animation in there as well.\n    float rnd = hash21(gID.xy);\n    //\n    // Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);\n    //gGlow.w = rnd>.05? 0. : 1.; // Static version.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\n\n  \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    // Zero out the glow.\n    gGlow = vec4(0);\n    \n    // Random dithering -- This is on the hacky side, but we're trying to cheap out \n    // on the glow by calculating it inside the raymarching loop instead of it's \n    // own one. If the the jump off point was too close to the closest object in the\n    // scene, you wouldn't do this.\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); // Distance function.\n        \n        // Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)/(1. + t);\n        }\n \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.4 : d*.7; \n        //t += d*.5; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 6.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n*/ \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*1.5); // Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .25); // \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); // Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 3.); // Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); // Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    float a = getTwist(ro.z);\n    // Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)/(ro.z - lk.z)/4.;\n\tvec3 fw = normalize(lk - ro);\n\t//vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t//vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw/FOV);\t\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        // Texel color. \n\t    vec3 texCol;   \n        \n        // Transforming the texture coordinates according to the camera path\n        // and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(-.5, 1., tx)*vec3(1, .8, 1.8);\n            \n            \n            // Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            // dark lines, and some light adjacent ones. As you can see, it gives the\n            // impression of horizontally segmented grooves on the pylons.\n            const float lvls = 8.;\n            \n            // Vertical lines... A bit too much for this example, but useful for a fake\n            // voxel setup.\n            //float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            // Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .5/lvls, 1./lvls) - .5/lvls);\n            float hLn2 = abs(mod(yDist + .5/lvls - .008, 1./lvls) - .5/lvls);\n            \n            // Omitting the top and bottom planes... I was in a hurry, and it seems to\n            // work, but there'd be better ways to do this. \n            if(yDist - 2.5<.25/lvls) hLn = 1e5;\n            if(yDist - 2.5<.25/lvls) hLn2 = 1e5;\n            \n            // Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .003, hLn2 - .0035));\n       \t\ttexCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., .003, hLn - .0035));\n       \t\t \n            \n            // Render a dot on the face center of each extruded block for whatever reason...\n            // They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0086;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .005, fDot - .0035));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, fDot));\n  \n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 3./(1. + lDist*lDist*.5);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.35; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n       \n        // Fake environmental lighting: Interesting, but I couldn't justify it, both\n        // from a visual and logical standpoint.\n        //vec3 cTex = envMap(reflect(rd, sn)); // Be sure to uncomment the function above.\n        //col += col*cTex.zyx*4.;\n\n    \n        // Shading.\n        col *= ao*sh*atten;\n\t\n\t}\n\n    \n    // Applying the glow -- You perform this outside the hit logic block. The reason\n    // I mention this is that I make this mistake all the time and spend ages trying\n    // to figure out why it's not working. :) As for how you apply it, that's up to\n    // you. I made the following up, and I'd imagine there'd be nicer ways to apply \n    // it, but it'll do.\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    // Some colorful fog: Like the above, it's been tweaked to produce something\n    // colorful that, hopefully, helps the scene. The cool thing about fog is that\n    // it's about as cheap an operation as you could hope for, but has virtually\n    // no impact on the frame rate. With that in mind, it's definitely worth taking\n    // the time to get it looking the way you'd like it to look.\n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .35, uv.y - .35));\n    col = mix(col, fog/1.5, smoothstep(0., .99, t*t/FAR/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; // A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n    /*\n    // Uncomment this block if you'd like to see the 2D pattern on its own.\n    uv = fragCoord/iResolution.y;\n    vec4 d = blocks(vec3(uv*2. + iTime/4., 0.));\n    //vec2 offs = inCentRad(gV[0], gV[1], gV[2]).xy;\n    vec3 oCol = smoothstep(-.05, .5, getTex(d.yz));\n    float quadD = sBoxS(gP, 3./5.*vec2(1./5.) - .04, .015);\n    #ifdef SKEW_GRID\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(-.5, .5);//;\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    gP -= unskewXY(vec2(1./2.), sk)/5.;\n    quadD = min(quadD, sBoxS(gP, 3./10.*vec2(1./5.) - .04/2., .015));\n    float sf = 1./iResolution.y;\n    col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, quadD));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, quadD + .006));\n    */      \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3902, 3935, 3957, 3957, 4015], [4018, 4046, 4067, 4067, 4130], [4132, 4150, 4171, 4171, 4245], [4248, 4351, 4373, 4401, 4452], [4455, 4482, 4505, 4627, 4777], [4779, 4843, 4863, 4863, 4912], [4915, 4942, 5012, 5069, 5186], [5325, 5353, 5400, 5400, 5485], [5487, 5550, 5578, 5578, 5622], [5624, 5689, 5719, 5719, 5768], [6130, 6228, 6248, 6366, 9836], [9838, 9838, 9862, 9862, 9878], [10112, 10135, 10153, 10377, 11541], [11546, 11567, 11603, 11652, 12798], [12801, 12901, 12927, 12927, 13593], [13597, 13788, 13840, 13957, 15238], [15241, 15393, 15429, 15429, 15673], [15675, 16853, 16909, 16942, 25455]]}
{"id": "WtfBWn", "name": "japs", "author": "Lf4", "description": "frw", "tags": ["nedi"], "likes": 1, "viewed": 75, "published": "Public", "date": "1596405585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p){\n    p=mod(p,2.)-1.;\n    p = abs(p)-1.;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    float s=1.;\n    for(int i=0;i++<50;)\n    {\n      float r2=2./clamp(dot(p,p),.1,1.05);\n      p=abs(p)*r2-vec3(0.050,0.75,1.5555);\n      s*=r2;\n    }\n    return length(p)/s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(.4+.32*sin(iTime*.055),.2+.05*cos(iTime*.05),-.5*iTime),\n  \t\tw=normalize(vec3(.2,sin(iTime*.05),-1)),\n  \t\tu=normalize(cross(w,vec3(5,5,5))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n  \tfloat h=0.1,d,i,zoom = 2.;\n \tro*=zoom;\n\tfor(i=5.;i<150.;i++){\n    \tp=ro+rd*h;\n    \tp/=zoom;\n\t  \td=map(p);\n    \tif(d<0.005||h>55.)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=55.*vec3(cos(p*.5)*.5+.5)/i;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 331], [334, 334, 391, 391, 857]]}
{"id": "wtfBWS", "name": "3D cubic Koch snowflake", "author": "CyanMARgh", "description": "To be honest, I'm not very sure that it is called that way. Does anyone know its real name?", "tags": ["raymarching", "fractal", "koch"], "likes": 5, "viewed": 101, "published": "Public", "date": "1597583452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cameraPos = vec3(0., 10., -13.5);\nfloat softShadow = 10.;\nfloat depthmax = 80.; \nconst float eps = 0.0001;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\n\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\nvec4 cdif(vec4 d1, vec4 d2){\n    d2.w*=-1.;\n    return d1.w>d2.w?d1:d2;\n}\nvec4 cmix(vec4 d1, vec4 d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat box(vec3 b, vec3 p){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nbool closer(vec3 p, vec3 a, vec3 b){\n    return length(p-a)<length(p-b);\n}\nvec4 koch(vec3 p){    \n    float d = box(vec3(3.),p);\n    float x,y,z,s=1.;\n\tconst vec3 Y=vec3(0.,4.,0.),X=vec3(4.,0.,0.),Z=vec3(0.,0.,4.),XY=vec3(2.,2.,0.),XZ=vec3(2.,0.,2.),YZ=vec3(0.,2.,2.),XYZ=vec3(2.,2.,2.);\n\n    float I=4.+2.1*sin(iTime),i_=0.;\n    vec3 p_;\n    for(float i=1.;i<=I;i++){\n        p = abs(p);x=p.x,y=p.y,z=p.z;\n        \n        if(closer(p,XYZ,X)&&closer(p,XYZ,Y)&&closer(p,XYZ,Z)&&closer(p,XYZ,XY)&&closer(p,XYZ,XZ)&&closer(p,XYZ,YZ)){\n            p_=XYZ;\n        }else if(y>max(x,z)+2.){\n            p_=Y;i_++;\n        }else if(x>max(y,z)+2.){\n            p_=X;i_++;\n        }else if(z>max(x,y)+2.){\n            p_=Z;i_++;\n        }else{\n            float m = min(x,min(y,z));\n            if(m==x){\n                p_=YZ;\n            }else if(m==y){\n                p_=XZ;\n            }else{\n                p_=XY;\n            }\n        }        \n        p = 3.*(p-p_);\n        s*=3.3;\n    \td = min(box(vec3(3.),p)/s,d);\n    }    \n    return vec4(mix(vec3(2.,2.,3.0),vec3(1.7),i_/I),d);\n}\n\n\n\n//color functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(1.,1.,1.,-box(vec3(20.,20.,20.),p-vec3(0.,20.,0.)));\n    d0.xyz*=cb3(p)?1.:.8;\n    \n    vec4 d = koch(p-vec3(0.,6.,0.));\n    d0 = cun(d0,d);\n        \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += h;//clamp(h,0.,3.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 2; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n\n    if (length(pos) < depthmax){\n        col = vec3(.25);\n\t\tcol += getLight(pos, vec3(11., 13., 8.), n, vec3(1.,.9,.9), 60.,false);\n        col += getLight(pos, vec3(-8.,13., 11.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(-11.,13.,-8.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(8., 13.,-11.), n, vec3(1.,.9,.9), 60.,false);\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.zy*=ro(-.25);\n    dir.xz*=ro(angle);\n    return dir;\n}\n\n//color and length of ray\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist, distM;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;\n\n        depth += dist;\n        sdepth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n*5.;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n\tif(map(pos).w<0.)col+=vec3(1e20);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //direction calculation\n    float angle = 6.9;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle);\n    vec3 dir = getDir(fragCoord,angle);\n\n    //raymarching\n    vec3 col = rayCast(eye, dir);\n    \n    fragColor = vec4(1.5*log(1.+ col), 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 181, 181, 241], [242, 242, 269, 269, 299], [300, 300, 328, 328, 373], [374, 374, 412, 412, 515], [516, 516, 542, 542, 633], [634, 634, 670, 670, 708], [709, 709, 727, 727, 1720], [1724, 1742, 1759, 1759, 1823], [1824, 1836, 1853, 1853, 2039], [2040, 2050, 2068, 2068, 2245], [2246, 2277, 2346, 2346, 2755], [2756, 2786, 2817, 2817, 3214], [3215, 3215, 3251, 3251, 3715], [3716, 3750, 3791, 3791, 4044], [4046, 4072, 4105, 4105, 4772], [4773, 4787, 4841, 4869, 5090]]}
{"id": "wtfBzS", "name": "NoiseMaker", "author": "BlockMaster", "description": "Simple tool for creating noise textures (in need of some optimization I guess :)).", "tags": ["noise", "perlin", "worley", "value", "spaghetti"], "likes": 4, "viewed": 111, "published": "Public", "date": "1597002991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/// Simple tool for creating noise textures (in need of some optimization I guess :)).\n/// You can modify the noise in the section below.\n\n//CUSTOMIZE THE NOISE//\n//Main Options\nint noiseType = 2;\t//0 - value noise; 1 - perlin noise; 2 - spaghetti noise; 3 - worley (voronoi) noise\nint dimension = 1;\t//0 - 2D noise; 1 - 3D noise (a bit slower than 2D)\nfloat frequency = 10.;\nbool combineNoises = true;\t//specific noise values && their contribution to the main noise can be modified in the mainImage\n\n//Properties\nint octaves = 1;\nfloat lacunarity = 2.;\nfloat persistence = 0.5;\nint vectorSet = 2;\t//0 - normalized vector; 1 - horizontal-vertical vector; 2 - diagonal vector; 3 - 8-directional vector; 2D noises only\nint nNearest = 1;\t//worley noise only\n\n//Motion\nfloat time;\nfloat noiseSpeed = 0.05;\t//3D noise only\nbool motion = false;\t//worley noise only\n\n//Mapping\nfloat mapMin = - 0.4;\nfloat mapMax = 0.85;\nbool mapChange = false;\n\n//Colour\n/*vec3 colourMin = vec3(0.);\t//value\nvec3 colourMax = vec3(1.);*/\n/*vec3 colourMin = vec3(0.63, 0.22, 0.13);\t//spaghetti\nvec3 colourMax = vec3(0.91, 0.77, 0.39);*/\nvec3 colourMin = vec3(0.41, 0.84, 0.94) - 0.5;\t//blue\nvec3 colourMax = vec3(1.);\n\n\n//USEFUL FUNCTIONS//\n//Map\nfloat map(float value, float currentMin, float currentMax, float targetMin, float targetMax)\n{\n    return targetMin + (targetMax - targetMin) * ((value - currentMin) / (currentMax - currentMin));\n}\n\n//Smootherstep\nfloat smootherstep(float value)\n{\n    return 6.0 * pow(value, 5.) - 15. * pow(value, 4.) + 10. * pow(value, 3.);\n}\n\n//RNG Returning a Float (0. to 1.)\nfloat randomValue(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//RNG Returning a Vec2 (0. to 1.)\nvec2 randomVector(vec2 uv)\n{\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n//RNG Returning a Direction Limited Vec2 (- 1. to 1.)\nvec2 randomLimitedVector(vec2 uv, int type)\n{\n    vec2 randomVector = randomVector(uv);\n    \n    switch (type)\n    {\n        //Normalized Vector (Any Direction with Length 1)\n        case 0:\n        {\n            return normalize(randomVector + 0.0001) * 2. - 1.;\n        }\n        break;\n        \n        //Horizontal-Vertical Vector (Right, Down, Left, Up)\n        case 1:\n        {\n            \n            return vec2(float(randomVector.x > 0.333) - 2. * float(randomVector.x > 0.666),\n                        sign(randomVector.y * 2. - 1.) * float(randomVector.x < 0.333));\n        }\n        break;\n        \n        //Diagonal Vector (Right Down, Left Down, Left Up, Right Up)\n        case 2:\n        {\n            return vec2(float(randomVector.x > 0.5) * 2. - 1.,\n                        float(randomVector.y > 0.5) * 2. - 1.);\n        }\n        break;\n        \n        //8-Directional Vector (Rigth, Right Down, Down, Left Down, Left, Left Up, Up, Right Up)\n        case 3:\n        {\n            return vec2(float(randomVector.x > 0.333) - 2. * float(randomVector.x > 0.666),\n                        sign(randomVector.y * 2. - 1.) * float(randomVector.y < 0.666 || randomVector.x < 0.333));\n        }\n        break;\n    }\n}\n\n//Vector Lookup Table for 3D Noises\nvec3 vectorTable3D[] = vec3[] (vec3(1., 1., 0.), vec3(- 1., 1., 0.), vec3(1., - 1., 0.), vec3(- 1., - 1., 0.), \n                               vec3(1., 0., 1.), vec3(- 1., 0., 1.), vec3(1., 0., - 1.), vec3(- 1., 0., - 1.),\n                               vec3(0., 1., 1.), vec3(0., - 1., 1.), vec3(0., 1., - 1.), vec3(0., - 1., - 1.));\n\n\n//NOISES//\n//Value Noise\nfloat valueNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the Value of the 4 Nearest Grid Points\n        float point1 = randomValue(cellPosition) * 2. - 1.0;\n        float point2 = randomValue(vec2(cellPosition.x + 1., cellPosition.y)) * 2. - 1.0;\n        float point3 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.)) * 2. - 1.0;\n        float point4 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.)) * 2. - 1.0;\n\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(point1, point2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(point3, point4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation3 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Value Noise\nfloat valueNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\n        //Get the Value of the 8 Nearest Grid Points\n        float point1 = randomValue(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point2 = randomValue(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point3 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point4 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 2. - 1.0;\n        float point5 = randomValue(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point6 = randomValue(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point7 = randomValue(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        float point8 = randomValue(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 2. - 1.0;\n        \n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(point1, point2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(point3, point4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(point5, point6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(point7, point8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation7 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Perlin Noise\nfloat perlinNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 4 Nearest Grid Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition, vectorSet);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y), vectorSet);\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.), vectorSet);\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.), vectorSet);\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation3 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Perlin Noise\nfloat perlinNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 8 Nearest Grid Points\n        vec3 gradientVector1 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector2 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector3 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector4 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector5 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector6 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector7 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector8 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec3 distanceVector1 = vec3(pixelPosition.x, - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector2 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector3 = vec3(pixelPosition.x, 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector4 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector5 = vec3(pixelPosition.x, - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector6 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector7 = vec3(pixelPosition.x, 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector8 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n        float dotProduct5 = dot(gradientVector5, distanceVector5);\n        float dotProduct6 = dot(gradientVector6, distanceVector6);\n        float dotProduct7 = dot(gradientVector7, distanceVector7);\n        float dotProduct8 = dot(gradientVector8, distanceVector8);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(dotProduct5, dotProduct6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(dotProduct7, dotProduct8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += ((interpolation7 + 1.) / 2.) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Spaghetti Noise\nfloat spaghettiNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the Gradient Vector of the 4 Nearest Grid Points\n        vec2 gradientVector1 = randomLimitedVector(cellPosition, vectorSet);\n        vec2 gradientVector2 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y), vectorSet);\n        vec2 gradientVector3 = randomLimitedVector(vec2(cellPosition.x, cellPosition.y + 1.), vectorSet);\n        vec2 gradientVector4 = randomLimitedVector(vec2(cellPosition.x + 1., cellPosition.y + 1.), vectorSet);\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec2 distanceVector1 = vec2(pixelPosition.x, - pixelPosition.y);\n        vec2 distanceVector2 = vec2(- (1. - pixelPosition.x), - pixelPosition.y);\n        vec2 distanceVector3 = vec2(pixelPosition.x, 1. - pixelPosition.y);\n        vec2 distanceVector4 = vec2(- (1. - pixelPosition.x), 1. - pixelPosition.y);\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec2 pixelPositionSmoothed = vec2(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y));\n\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += abs(interpolation3) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//3D Spaghetti Noise\nfloat spaghettiNoise3D(vec3 uv, float frequency, int octaves, float lacunarity, float persistence)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec3 pixelPosition = fract(uv * frequency);\n        vec3 cellPosition = floor(uv * frequency);\n\t\t\n        //Get the Gradient Vector of the 8 Nearest Grid Points\n        vec3 gradientVector1 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector2 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector3 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector4 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z))) * 11.))];\n        vec3 gradientVector5 = vectorTable3D[int(ceil(randomVector(cellPosition.xy * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector6 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector7 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x, cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        vec3 gradientVector8 = vectorTable3D[int(ceil(randomVector(vec2(cellPosition.x + 1., cellPosition.y + 1.) * randomValue(vec2(cellPosition.z + 1.))) * 11.))];\n        \n        //Calculate the Distance Vector from the Pixel to the Grid Points\n        vec3 distanceVector1 = vec3(pixelPosition.x, - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector2 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector3 = vec3(pixelPosition.x, 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector4 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, pixelPosition.z);\n        vec3 distanceVector5 = vec3(pixelPosition.x, - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector6 = vec3(- (1. - pixelPosition.x), - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector7 = vec3(pixelPosition.x, 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        vec3 distanceVector8 = vec3(- (1. - pixelPosition.x), 1. - pixelPosition.y, - (1. - pixelPosition.z));\n        \n        //Calculate the Dot Products of the Gradient && Distance Vectors\n        float dotProduct1 = dot(gradientVector1, distanceVector1);\n        float dotProduct2 = dot(gradientVector2, distanceVector2);\n        float dotProduct3 = dot(gradientVector3, distanceVector3);\n        float dotProduct4 = dot(gradientVector4, distanceVector4);\n        float dotProduct5 = dot(gradientVector5, distanceVector5);\n        float dotProduct6 = dot(gradientVector6, distanceVector6);\n        float dotProduct7 = dot(gradientVector7, distanceVector7);\n        float dotProduct8 = dot(gradientVector8, distanceVector8);\n\t\t\n        //Smooth the Pixel's Coordinates for the Interpolation Using the Smootherstep Function\n        vec3 pixelPositionSmoothed = vec3(smootherstep(pixelPosition.x), smootherstep(pixelPosition.y), smootherstep(pixelPosition.z));\n\t\t\n        //Interpolate Between the Grid Point Values\n        float interpolation1 = mix(dotProduct1, dotProduct2, pixelPositionSmoothed.x);\n        float interpolation2 = mix(dotProduct3, dotProduct4, pixelPositionSmoothed.x);\n        float interpolation3 = mix(dotProduct5, dotProduct6, pixelPositionSmoothed.x);\n        float interpolation4 = mix(dotProduct7, dotProduct8, pixelPositionSmoothed.x);\n        \n        float interpolation5 = mix(interpolation1, interpolation2, pixelPositionSmoothed.y);\n        float interpolation6 = mix(interpolation3, interpolation4, pixelPositionSmoothed.y);\n        \n        float interpolation7 = mix(interpolation5, interpolation6, pixelPositionSmoothed.z);\n        \n        //Add the Current Octave's Value to the Final Value\n        pixelValue += abs(interpolation7) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\n//Worley Noise\nfloat worleyNoise(vec2 uv, float frequency, int octaves, float lacunarity, float persistence, int nNearest)\n{\n    float pixelValue = 0.;\n    float maxValue = 0.;\t//used to normalize the final value\n    float amplitude = 1.;\n    for (int octave = 0; octave < octaves; octave ++)\n    {\n        //Get the Pixel's Position Within Its Grid Cell && the Cell's Position \n        vec2 pixelPosition = fract(uv * frequency);\n        vec2 cellPosition = floor(uv * frequency);\n\n        //Get the n-Nearest Cell Point Position\n    \tfloat distances[9] = float[] (5., 5., 5., 5., 5., 5., 5., 5., 5.);\n        for (int i = - 1; i < 2; i ++)\n        {\n        \tfor (int j = - 1; j < 2; j ++)\n        \t{\n                //Get the Point Position Within Its Grid Cell\n        \t\tvec2 pointPosition = randomVector(vec2(cellPosition.x + float(j), cellPosition.y + float(i)));\n                pointPosition *= (sin(iTime * noiseSpeed * 5. + pointPosition.x * 20.) + 1.) * 0.5 * float(motion) + float(!motion);\t//noise motion\n                pointPosition += vec2(j, i);\n            \t\n                //Compare the Distance Between the Pixel && the Point with the Previous Distances\n                float distanceToCompare = distance(pixelPosition, pointPosition);\n                for (int k = 0; k < distances.length(); k ++)\n                {\n                    if (distanceToCompare < distances[k])\n                    {\n                    \tfloat tempDistance = distances[k];\n                        distances[k] = distanceToCompare;\n                        distanceToCompare = tempDistance;\n                    }\n                }\n        \t}\n        }\n        pixelValue += distances[nNearest - 1] * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }\n    return pixelValue / maxValue;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Remap the Fragcoord\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.x /= aspectRatio;\n    \n    //Set the Time for Changing the z Noise Component\n    time = mod(iTime, 200.) + 1.;\t//the RNGs aren't functioning well on higher numbers ¯\\_(ツ)_/¯\n    \n    //Get the Noise Value && Set the Fragcolor\n    float noiseValue;\n    switch (noiseType)\n    {\n        case 0:\n        {\n            if (dimension == 0) noiseValue = valueNoise(uv, frequency, octaves, lacunarity, persistence);\n            if (dimension == 1) noiseValue = valueNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 1:\n        {\n            if (dimension == 0) noiseValue = perlinNoise(uv, frequency, octaves, lacunarity, persistence);\n\t\t\tif (dimension == 1) noiseValue = perlinNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 2:\n        {\n            if (dimension == 0) noiseValue = spaghettiNoise(uv, frequency, octaves, lacunarity, persistence);\n\t\t\tif (dimension == 1) noiseValue = spaghettiNoise3D(vec3(uv, noiseSpeed * time), frequency, octaves, lacunarity, persistence);\n        }\n        break;\n        \n        case 3:\n        {\n            noiseValue = worleyNoise(uv, frequency, octaves, lacunarity, persistence, nNearest);\n        }\n        break;\n    }\n\t\n    if (combineNoises)\n    {\n        noiseValue *= perlinNoise3D(vec3(uv, noiseSpeed * time), 20., 6, lacunarity, persistence) * 1.;\t//combine multiple noises\n        noiseValue += worleyNoise(uv, 5., 1, lacunarity, persistence, 1) * 1.;\n    }\n    \n    noiseValue = map(noiseValue, 0., 1., mapMin, mapMax) * float(!mapChange) +\t//normal\n        \t\t map(noiseValue, 0., 1., (sin(iTime) + 1.) * 0.5, 1. - (sin(iTime) + 1.) * 0.5) * float(mapChange);\t//changing\n    \n    fragColor = vec4(mix(colourMin, colourMax, clamp(noiseValue, - 0.5, 1.)), 2.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1194, 1221, 1315, 1315, 1418], [1420, 1435, 1468, 1468, 1549], [1551, 1586, 1614, 1614, 1687], [1689, 1723, 1751, 1751, 1886], [1888, 1942, 1987, 1987, 3173], [3548, 3573, 3667, 3667, 5188], [5190, 5207, 5303, 5303, 7871], [7873, 7888, 7983, 7983, 10353], [10355, 10373, 10470, 10470, 14831], [14833, 14851, 14949, 14949, 17304], [17306, 17327, 17427, 17427, 21779], [21781, 21796, 21905, 21905, 23629], [23631, 23631, 23686, 23712, 25690]]}
{"id": "wtfBzX", "name": "Film Burn", "author": "Hopepdm", "description": "炫光转场切换纹理：https://blog.csdn.net/panda1234lee/article/details/105969304", "tags": ["burn"], "likes": 2, "viewed": 128, "published": "Public", "date": "1597288160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed = 2.31;\n \n#define PI 3.141592653589\n#define PI_HALF (PI/2.)\n#define clamps(x) clamp(x, 0., 1.)\n \n//#iChannel0 \"file://./images/私の初めて、キミにあげます/1 (6).jpeg\"\n//#iChannel1 \"file://./images/私の初めて、キミにあげます/timg (4).jpg\"\n \nfloat progress = 0.f;\n \nvec4 getFromColor(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n \nvec4 getToColor(vec2 uv)\n{\n    return texture(iChannel1, uv);\n}\n \nfloat sigmoid(float x, float a)\n{\n    float b = pow(x * 2., a) / 2.;\n    if (x > .5)\n    {\n        b = 1. - pow(2. - (x * 2.), a) / 2.;\n    }\n    return b;\n}\n \nfloat apow(float a, float b)\n{\n    return pow(abs(a), b) * sign(b);\n}\n \n/// @brief 三通道的 apow\nvec3 pow3(vec3 a, vec3 b)\n{\n    return vec3(apow(a.r, b.r), apow(a.g, b.g), apow(a.b, b.b));\n}\n \n/// @brief 平滑混合\nfloat smoothMix(float a, float b, float c)\n{\n    return mix(a, b, sigmoid(c, 2.));\n}\n \n/// ---------------------------------------------------------\n/// 随机函数部分\nfloat rand(float co)\n{\n    return fract(sin((co * 24.9898) + seed) * 43758.5453);\n}\n \nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n \nfloat rand(vec2 co, float shft)\n{\n    co += 10.;\n    return smoothMix(fract(sin(dot(co.xy, vec2(12.9898 + (floor(shft) * .5), 78.233 + seed))) * 43758.5453),\n                     fract(sin(dot(co.xy, vec2(12.9898 + (floor(shft + 1.) * .5), 78.233 + seed))) * 43758.5453),\n                     fract(shft));\n}\n \nfloat smoothRandom(vec2 co, float shft)\n{\n    return smoothMix(smoothMix(rand(floor(co), shft),\n                               rand(floor(co + vec2(1., 0.)), shft), fract(co.x)),\n                     smoothMix(rand(floor(co + vec2(0., 1.)), shft),\n                               rand(floor(co + vec2(1., 1.)), shft), fract(co.x)),\n                     fract(co.y));\n}\n/// ---------------------------------------------------------\n \n/// @brief 纹理平滑混合\nvec4 textureSmoothMix(vec2 p)\n{\n    return mix(getFromColor(p), getToColor(p), sigmoid(progress, 10.));\n}\n \nvec3 color = vec3(1., 0.7, 0.6);\nfloat repeats = 50.0; \n \nvec4 transition(vec2 p)\n{\n    /// @note 粒子效果\n    vec3 f = vec3(0.);\n    /// 粒子的个数\n    for (float i = 0.; i < 20.; i++)\n    {\n        /// @note 大 Blob\n        /// 增加一点随机性，改变每个 blob 的形状\n        f += .1 +\n             sin(((p.x * rand(i) * 6.0) + ///< 影响 blob 的大小\n                  (progress * 8.0)) +     ///< 影响 blob 的速度\n                 rand(i + 1.43)) *\n             cos(((p.y * rand(i + 4.4) * 6.0) + ///< 影响 blob 的大小\n                  (progress * 6.0)) +           ///< 影响 blob 的速度\n                 rand(i + 2.4));\n        // -------------------------------------------------------------------------\n \n        /// @note 小粒子\n        f += 1. - clamps(length(p -\n                                vec2(smoothRandom(vec2(progress * 1.3), i + 1.0),       ///< 控制粒子的运动位置和轨迹\n                                     smoothRandom(vec2(progress * 0.5), i + 6.25))) *\n                         mix(20., 70., rand(i)));                                       ///< 影响粒子的大小，值越大粒子越小\n \n    }\n    f += 4.;\n    f /= 11.;  ///< 变暗\n \n    /// @note 颜色随着 progress 而变化\n    f = pow3(f * color,                  ///< 着色\n             vec3(1., 2. - sin(progress * PI), 1.3)); ///< 1., [2., 1.], 1.3\n    f *= sin(progress * PI);\n \n \n    /// @note 图像周期性缩放\n    p -= .5;    ///< 以屏幕中心为原点\n    /// 随机对纹理坐标进行缩放\n    p *= 1. + (smoothRandom(vec2(progress * 5.), 6.3) * sin(progress * PI) * .05);\n    p += .5;    ///< 平移原点回左下角\n \n \n    vec4 blurred_image = vec4(0.);\n \n    /// @note 带噪点的转场效果\n    float bluramount = sin(progress * PI) * .03;\n \n    /// @note repeats 越大，毛玻璃效果越弱\n    for (float i = 0.; i < repeats; i++)\n    {\n        /// 角度转弧度\n        float rad = radians((i / repeats) * 360.);\n        vec2 q = vec2(cos(rad), sin(rad)) *\n                 (rand(vec2(i, p.x + p.y)) + bluramount); ///< 生成噪点\n \n        vec2 uv2 = p + (q * bluramount); ///< 随机噪点偏移纹理坐标，毛玻璃效果\n        blurred_image += textureSmoothMix(uv2); ///< 叠加随机偏移的纹理（同时随着 progress 变化）\n \n    }\n    blurred_image /= repeats; ///< 平均，模糊\n \n \n    return blurred_image + vec4(f, 0.); ///< 毛玻璃+粒子\n \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // uv.x *= iResolution.x/iResolution.y;\n \n    progress = fract(.5 * iTime); ///< 线性速度\n \n    fragColor = transition(uv);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 300, 328, 328, 365], [368, 368, 394, 394, 431], [434, 434, 467, 467, 591], [594, 594, 624, 624, 663], [666, 695, 722, 722, 789], [792, 816, 860, 860, 900], [903, 988, 1010, 1010, 1071], [1074, 1074, 1095, 1095, 1168], [1171, 1171, 1204, 1204, 1479], [1482, 1482, 1523, 1523, 1849], [1914, 1944, 1975, 1975, 2049], [2110, 2110, 2135, 2162, 4506], [4509, 4509, 4566, 4566, 4745]]}
{"id": "WtffDH", "name": "Jolly jumping", "author": "NachoRosa95", "description": "A silly edit of one of my favorite shaders by iq:\n\nhttps://www.shadertoy.com/view/3lsSzf\n\nWait for the beat to drop for a little surprise", "tags": ["raymarching"], "likes": 3, "viewed": 159, "published": "Public", "date": "1596552593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//\n// An animation test - a happy and blobby creature jumping and\n// looking around. It gets off-model very often, but it looks\n// good enough I think.\n//\n// Making-of and related math/shader/art explanations (6 hours\n// long): https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n//\n// Video capture: https://www.youtube.com/watch?v=s_UOFo2IULQ\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 3.0*t1*(1.0-t1);\n    float pp = 2.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.3*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.2,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );\n\n    if( res.x-1.0 < pos.y ) // bounding volume\n    {\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n    // head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n    float d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n    float d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n    d = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n\n    // belly wrinkles\n    {\n        float yy = r.y-0.02-2.5*r.x*r.x;\n        res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n\n    // arms\n    {\n        vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n        res.xz = smin( res.xz, arms, 0.02+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n\n    // ears\n    {\n        float t3 = fract(atime+0.9);\n        float p3 = 4.0*t3*(1.0-t3);\n        vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n        res.xz = smin( res.xz, ear, 0.06 );\n    }\n\n    // mouth\n    {\n        d = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n        res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n        res.x = smax( res.x, -d, 0.03 );\n    }\n\n    // legs\n    {\n        float t6 = cos(6.2831*(atime*0.5+0.25));\n        float ccc = cos(1.57*t6*sign(r.x));\n        float sss = sin(1.57*t6*sign(r.x));\n        vec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n        vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n        res.xz = smin( res.xz, legs, 0.03 );\n    }\n\n    // eye\n    {\n        float blink = pow(0.5+0.5*sin(1.1*atime),20.0);\n        float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n        res.x = smin( res.x, eyeball, 0.03 );\n\n        vec3 cq = hq-vec3(0.1,0.34,0.08);\n        cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n        d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n        res.x = smin( res.x, d, 0.03 );\n\n        float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n        res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n        res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\n    // hat\n    float hatHeight = 0.60;\n    vec3 hatPivot = h - vec3(0.0,hatHeight,0.0);\n    float mul = abs(q.y - h.y);\n    vec3 hatCoords = hatPivot + vec3(0,0,0.3*mul);\n    float hat  = sdCone( hatCoords, vec2(sin(.6),cos(.6)), .25);\n    d = smin( res.x, hat, 0.0003 );\n    if(d < res.x) res = vec4(d, 1.25, 0, 1.0);\n        \n        \n    }\n    \n    \n    // ground\n    float mul = pow(texture(iChannel0, vec2(0.7, .25)).r, 3.0f) * 0.5f;\n    float fh = -0.1 - mul*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5f = fract(atime+0.05);\n    float t5i = floor(atime+0.05); \n    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;\n    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*12.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // candy\n    {\n    float ds = 0.45;\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    d = sdSphere( vp, ds*ra )/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.5-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.7, 0.8, 1) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y*2.0;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n    \n\n    // scene geometry\n    vec4 res = castRay(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        float f2 = 1.0;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.58,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n            \n            // snow\n            vec3 snowDir = vec3(0,.9,0);\n            vec3 snowColor = vec3(1,1,1);\n            float mul = dot(nor, snowDir);\n            mul = max(mul, 0.0);\n            col = min(col + snowColor * mul, vec3(1));\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.6,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.1)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n        else if( res.y > 1.1) // hat = 1.25\n        {\n            col = vec3(0.0,0.1,0.00);\n        }\n\t\telse // terrain\n        {\n            // base color            \n            col = vec3(0.3,0.02,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            //col = f*vec3(0.01,0.3,0.02);\n            col = mix(col, vec3(0.0,0.2,0.0), clamp(f,0.0,1.0)*5.0);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.8,0.3,0), mark );\n            ks *= 1.0-0.5*mark;\n        \n            // snow\n            vec3 snowDir = vec3(0,2,0);\n            vec3 snowColor = vec3(.2,.2,.2);\n            float mul = dot(nor, snowDir);\n            mul = max(mul, 0.0);\n            mul*=0.8+f*0.2;\n            mul = clamp(mul, 0.0, 1.0);\n            col = mix(col, snowColor, mul);\n            \n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(5.10,6.00,6.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 1.3333333;\n        //time = 0.7;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 10.0*iMouse.x/iResolution.x + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(0.79,0.89,0.89);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "MtSGWy", "previewfilepath": "https://soundcloud.com/tylerwalker/deck-the-halls", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tylerwalker/deck-the-halls", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[644, 696, 737, 737, 809], [811, 863, 901, 901, 998], [1000, 1052, 1093, 1093, 1165], [1167, 1241, 1276, 1276, 1302], [1304, 1378, 1437, 1437, 1526], [1528, 1528, 1602, 1602, 1755], [1757, 1757, 1809, 1809, 1930], [1933, 2007, 2054, 2188, 2523], [2525, 2577, 2607, 2607, 2640], [2742, 2837, 2875, 2875, 8371], [8373, 8373, 8425, 8425, 8927], [8929, 8991, 9051, 9051, 9489], [9491, 9555, 9599, 9599, 10162], [10164, 10164, 10225, 10225, 10518], [10520, 10520, 10571, 10588, 14994], [14996, 14996, 15048, 15048, 15225], [15227, 15227, 15284, 15284, 17297]]}
{"id": "wtffDl", "name": "Shadow dancing", "author": "bwestlin", "description": "Playing around with light and shadow rendering turned out to look like some form of dancing shadows.", "tags": ["raymarching", "sound", "lightning"], "likes": 5, "viewed": 122, "published": "Public", "date": "1598037488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHOW_LIGHTS 1\n#define LIGHT_SIZE  0.2\n\n#define M_NONE\t\t0.0\n#define M_FLOOR\t\t1.0\n#define M_SPHERE\t2.0\n#define M_SPHERE2\t3.0\n#define M_L1\t\t4.0\n#define M_L2\t\t5.0\n\nfloat m(float i) {\n    return texture(iChannel0, vec2(i, 0.0)).x * 2.0;    \n}\n\nvec3 camera(vec2 uv, vec3 origin, vec3 target) {\n    vec3 forward = normalize((target - origin) * vec3(1.0, 1.0, 2.5));\n\tvec3 side = cross(forward, vec3(0.0, 1.0, 0.0));\n\tvec3 up = cross(side, forward);\n\tvec3 rayDir = forward + uv.x * side + uv.y * up;\n\treturn normalize(rayDir);\n}\n\nfloat sdSphere( vec3 p, float s ) {\n\treturn length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\n// Smooth minimum : http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smin08( float a, float b) {\n    return smin(a, b, 0.8);\n}\n\nvec3 l1pos() {\n    return vec3((-3.0 + m(0.1)) * cos(iTime), m(0.6), -5.0);\n}\n\nvec3 l2pos() {\n    return vec3((3.0 + m(0.2)) * cos(iTime), m(0.5), -5.0);\n}\n\nvec2 map(vec3 p, bool lights) {\n    float sphere = sdSphere(p - vec3(0.0, sin(iTime) * 0.2 * m(0.2) * 5.0, -3.0), 1.0);\n    float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n    \n    float sphere2 = smin08(\n        sdSphere(p - vec3( 1.5, -1.0 + sin(iTime * 4.0) * 0.2, -2.5), 1.0),\n        sdSphere(p - vec3(-1.5,-1.0 + sin(iTime * 4.0 + 3.14) * 0.2, -2.5), 1.0)\n    );\n           \n    #if (SHOW_LIGHTS == 0)\n    lights = false;\n    #endif\n    float l1 = lights ? sdSphere(p - l1pos(), LIGHT_SIZE) : 100000.0;\n    float l2 = lights ? sdSphere(p - l2pos(), LIGHT_SIZE) : 100000.0;\n    \n    float d = min(min(smin08(sphere2, smin08(sphere, plane)), l1), l2);\n    \n    if (d == sphere) return vec2(d, M_SPHERE);\n    if (d == sphere2)return vec2(d, M_SPHERE2);\n    if (d == plane)  return vec2(d, M_FLOOR);\n    if (d == l1)  return vec2(d, M_L1);\n    if (d == l2)  return vec2(d, M_L2);\n    \n    return vec2(d, M_NONE);\n}\n\nvec3 normal(vec3 p) {\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    float x = map(p, true).x;\n    return normalize(vec3(\n        map(p + eps.xzz, true).x - x,\n        map(p + eps.zxz, true).x - x,\n        map(p + eps.zzx, true).x - x\n    ));\n}\n\nvec2 intersect(vec3 origin, vec3 rayDir) {\n    float eps = 0.01;\n    float maxDistance = 100.0;\n    float t = 0.0;\n    \n    vec2 dm = vec2(0.1, M_NONE);\n    \n    for (int i = 0; i < 200; i++) {\n        t += dm.x;\n        dm = map(t * rayDir + origin, true);\n        \n        if (abs(dm.x) <= eps) {\n            break;\n        }\n        if (t > maxDistance) {\n            return vec2(0.0, M_NONE);\n        }\n    }\n    return vec2(t, dm.y);\n}\n\n// Soft shadows: https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {  \n    float res = 1.0;\n    for (float t = mint; t < maxt;) {\n        float h = map(ro + rd * t, false).x;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;    \n}\n\nfloat is_shadow(vec3 hit, vec3 lightpos) {\n    vec3 rayDir = normalize(lightpos - hit);\n    float maxDistance = abs(length(lightpos - hit));\n    return shadow(hit, rayDir, 0.1, maxDistance, 32.0);\n}\n\nvec3 diffuseLightning(vec3 n, vec3 lightDir, vec3 lightColor) {\n    float diffuse = dot(n, lightDir);        \n    return lightColor * max(0.0, diffuse);\n}\n\nvec3 specularLightning(vec3 n, vec3 rayDir, vec3 lightDir, vec3 lightColor, float shininess) {\n    float ratio = dot(rayDir, -reflect(lightDir, n));\n\treturn lightColor * pow(max(0., ratio), shininess);\n}\n\nvec3 light(vec3 lightPos, vec3 lightColor, vec3 color, vec3 hit, vec3 n, vec3 rayDir) {\n    vec3 lightDir = normalize(hit - lightPos);\n    vec3 refLight = reflect(lightDir, n);\n    \n    float dist = length(hit - lightPos);\n    float attenuation = (1.0 / (dist * dist)) * (sin(iTime) * 150.0 + 175.0);    \n    lightColor *= attenuation;\n    color += diffuseLightning(n, refLight, lightColor) / 5.0;\n    color *= diffuseLightning(n, refLight, lightColor);\n    color += specularLightning(n, rayDir, lightDir, lightColor, 50.);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(-(sin(iTime * 0.2) * 3.0 + 2.0), sin(iTime * 0.33) * 3.0 + 2.0, 3.0) * (sin(iTime * 0.66) * 0.25 + 0.75);\n    vec3 cameraTarget = vec3(0.0, -3.0, 0.0);\n\n\tvec2 mPos = vec2(0.0);\n    if (iMouse.x > 0.0 && iMouse.y > 0.0) {\n        mPos = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    }\n           \n    cameraTarget.xy -= mPos * 8.;\n    \n    vec3 rayDir = camera(uv, cameraOrigin, cameraTarget);\n\n    vec3 color = vec3(0.0);\n    \n    vec2 dm = intersect(cameraOrigin, rayDir);\n    float t = dm.x;\n    float material = dm.y;\n    \n    if (t > 0.0) {\n        vec3 hit = cameraOrigin + t * rayDir;\n        \n        vec3 n = normal(hit);\n        vec3 origColor = vec3(1.0, 0.5, 0.7);\n        \n        vec3 l1color = vec3(sin(iTime * 2.1111) * 0.5 + 0.5, 0.5, sin(iTime * 5.1111) * 0.5 + 0.5);\n        vec3 l1 = light(l1pos(),\n                        l1color,\n                        origColor,\n                        hit,\n                        n,\n                        rayDir) * is_shadow(hit, l1pos());\n\n        vec3 l2color = vec3(sin(iTime * 8.1111) * 0.5 + 0.5, 0.5, sin(iTime * 1.333) * 0.5 + 0.5);\n        vec3 l2 = light(l2pos(),\n                        l2color,\n                        origColor,\n                        hit,\n                        n,\n                        rayDir) * is_shadow(hit, l2pos());\n        \n        color = l1 + l2;\n        \n        #if (SHOW_LIGHTS == 1)\n        if (material == M_L1) color = l1color * 5.0;\n        if (material == M_L2) color = l2color * 5.0;\n        #endif\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 186, 186, 245], [247, 247, 295, 295, 528], [530, 530, 565, 565, 590], [592, 592, 623, 623, 654], [656, 725, 764, 764, 867], [869, 869, 902, 902, 932], [934, 934, 948, 948, 1011], [1013, 1013, 1027, 1027, 1089], [1091, 1091, 1122, 1122, 2011], [2013, 2013, 2034, 2034, 2251], [2253, 2253, 2295, 2295, 2693], [2695, 2772, 2843, 2843, 3075], [3077, 3077, 3119, 3119, 3275], [3277, 3277, 3340, 3340, 3431], [3433, 3433, 3527, 3527, 3636], [3638, 3638, 3725, 3725, 4181], [4183, 4183, 4238, 4238, 5926]]}
{"id": "wtffDM", "name": "Triange Fade", "author": "cold_code", "description": "Remix of Triange Trip. Changed colors, more structured.\nhttps://www.shadertoy.com/view/MtdBz2", "tags": ["procedural", "triangle", "varonoi"], "likes": 7, "viewed": 203, "published": "Public API", "date": "1596858044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define scale 10.\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 randPt(vec2 co) {\n  float f1 = rand(co);\n  float f2 = rand(co * f1);\n  return vec2(f1 * .8 + .1, f2 * .8 + .1);\n}\n\nvec2 sqPoint(vec2 sq) {\n  //float time = 2. * iTime + 1.;\n  //time = 2.;\n  //vec2 curPt = randPt(floor(sq) * floor(time));\n  //vec2 nextPt = randPt(floor(sq) * floor(time + 1.));\n  //return fract(time) * (nextPt - curPt) + curPt;\n    if(mod(floor(sq.y),2.) == 0.){\n  \t\treturn vec2(.5, .1 + .8*abs((floor(sq.x)-cos(iTime))/scale));\n    }\n    else{\n        return vec2(.5,.1 + .4*(1.+cos(2.*3.14*fract(iTime/5.)))*abs(floor(sq.y))/scale);\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat distToShade(float d) {\n  float time = (1. + .3 * cos(3. * iTime));\n  //time = 1.;\n  return smoothstep(0.01, 1., 1. / (100. * time * d));\n}\n\nfloat cross2d(vec2 u, vec2 v) { return u.x * v.y - u.y * v.x; }\n\nfloat triArea(vec2 a, vec2 b, vec2 c) { return cross2d(b - a, c - a) / 2.; }\n\nconst vec3[4] palette = vec3[4](vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\nconst float _2PI = 6.28318;\n\nvec3 pal(in float t, in vec3[4] pal) {\n    t *= 2.4;\n    t += iTime/10.;\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.x;\n\n  //float scale = 10.;//= 1.25 *(pow(sin( iTime/8.) + 4., 1.5));\n  //scale = 2.;\n  vec2 sq = uv * scale;\n  vec2 uvSq = fract(sq);\n  vec2 sqPt = sqPoint(sq);\n  float c = 0.;\n  vec3 col = vec3(0.);\n  vec2[] offsets = vec2[](vec2(-1, -1), vec2(-1, 0), vec2(0, 1), vec2(1, 1),\n                          vec2(1, 0), vec2(0, -1)\n                          // vec2(-1, 1),\n                          // vec2(0, 0),\n                          // vec2(1, -1),\n  );\n\n  vec2 sqPtLast = sqPoint(sq + offsets[5]) + offsets[5];\n  for (int i = 0; i < 6; ++i) {\n    vec2 off = offsets[i];\n    vec2 sq2 = sq + off;\n    vec2 sqPt2 = sqPoint(sq2) + off;\n\n    //vec2 triCenter = (sqPt2 + sqPtLast + sqPt) / 3.;\n\n    float a = triArea(sqPt, sqPt2, sqPtLast);\n    //col.g += smoothstep(.1, 0., length(triCenter - uvSq));\n    float r1 = cross2d(uvSq - sqPt, sqPtLast - sqPt);\n    float r2 = cross2d(sqPt2 - sqPt, uvSq - sqPt);\n    \n      r1 = smoothstep(0., .001, r1);\n    r2 = smoothstep(0., .001, r2);\n    col += r1 * r2 * pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt, sqPt2);\n    c += distToShade(d);\n\n    sqPtLast = sqPt2;\n  }\n\n  vec2[] diagOffsets = vec2[](vec2(-1, 0), vec2(0, 1),\n                              // vec2(-1, 0), vec2(0, -1),\n                              // vec2(1, 0), vec2(0, 1),\n                              vec2(1, 0), vec2(0, -1));\n  for (int i = 0; i < 4; i += 2) {\n    vec2 off1 = diagOffsets[ i];\n    vec2 sq1 = sq + off1;\n    vec2 sqPt1 = sqPoint(sq1) + off1;\n    vec2 vPt1 = sqPt1 - uvSq;\n\n    vec2 off2 = diagOffsets[ i + 1];\n    vec2 sq2 = sq + off2;\n    vec2 sqPt2 = sqPoint(sq2) + off2;\n\n    vec2 off3 = vec2(off1.x, off2.y);\n    vec2 sq3 = sq + off3;\n    vec2 sqPt3 = sqPoint(sq3) + off3;\n\n    float a = triArea(sqPt1,sqPt2, sqPt3);\n    \n    float r1 = cross2d(uvSq - sqPt2, sqPt1 - sqPt2);\n    float r2 = smoothstep(.01, 0., r1);\n    r1 = smoothstep(0., .001, r1);\n    col *= r2;\n    col += r1*pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt1, sqPt2);\n    c += distToShade(d);\n  }\n\n  col -= vec3(c);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffDM.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1135, 1156, 1156, 1227], [1229, 1229, 1251, 1251, 1347], [1349, 1349, 1372, 1578, 1793], [1795, 1795, 1842, 1842, 1961], [1963, 1963, 1991, 1991, 2107], [2109, 2109, 2140, 2140, 2172], [2174, 2174, 2213, 2213, 2250], [2390, 2390, 2428, 2428, 2526], [2528, 2528, 2583, 2631, 4747]]}
{"id": "WtffRl", "name": "Dancing Boze", "author": "kaiware007", "description": "Dancing Everyday", "tags": ["raymarching"], "likes": 3, "viewed": 66, "published": "Public", "date": "1597408673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 10.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    float bg = sdCappedCylinder(q, 0.5, 100.);\n    \n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    result = SURF_BG1(bg, p);\n    \n    // boze    \n    result = opU(result, sdBozeFullBody(p));\n        \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    \n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    float t = iTime * M_PI2 * -0.05;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    float y = sin(t * 5.) * 0.5 + 0.75;\n    //float y = 0.5;\n    //float r = 2.0 + sin(t * 0.5);\n    float r = 5.;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    //float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n    //float theta = 0.;\n\t//float theta = t + RAD90;\n    //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n    //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n    //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float phi   = 0.;\n    //float phi   = RAD90*0.5;\n    float phi   = (mouseUV.y) * RAD90;\n    //float phi   = (mouseUV.y) * RAD90;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., 0.5, 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[943, 1192, 1215, 1215, 1288], [1332, 1828, 1870, 1870, 2011], [3181, 3257, 3279, 3279, 3610], [3613, 3801, 3824, 3824, 3909], [3911, 3930, 3952, 3952, 4069], [4071, 4090, 4113, 4113, 4216], [4218, 4238, 4259, 4259, 4393], [4395, 4414, 4436, 4436, 4569], [4571, 4591, 4613, 4613, 4738], [4740, 4740, 4777, 4842, 5283], [5285, 5285, 5306, 5306, 5376], [5378, 5378, 5401, 5401, 5480], [5483, 5483, 5505, 5505, 5922], [6033, 6033, 6054, 6054, 6195], [6197, 6197, 6227, 6227, 6357], [6359, 6359, 6420, 6420, 6558], [6560, 6560, 6586, 6586, 6895], [6897, 6957, 6983, 6983, 7849], [7851, 7931, 7972, 7972, 8143], [8145, 8245, 8281, 8281, 8309], [8311, 8311, 8357, 8357, 8413], [8415, 8415, 8446, 8446, 8537], [8539, 8539, 8589, 8589, 8707], [8709, 8709, 8770, 8770, 8901], [8903, 8903, 8940, 8940, 9029], [9031, 9031, 9101, 9101, 9235], [9237, 9237, 9301, 9301, 9418], [9420, 9420, 9472, 9472, 9579], [9581, 9581, 9614, 9640, 9671], [9673, 9673, 9698, 9698, 9717], [9718, 9718, 9743, 9743, 9762], [9763, 9763, 9799, 9799, 9827], [9829, 9829, 9888, 9888, 10201], [10203, 10203, 10236, 10236, 10301], [10303, 10327, 10379, 10379, 10498], [10500, 10610, 10642, 10642, 10736], [10738, 10738, 10772, 10772, 10923], [10925, 10925, 10959, 10959, 11107], [11109, 11109, 11143, 11143, 11278], [11280, 11280, 11308, 11308, 11393], [11394, 11452, 11523, 11523, 11851], [11853, 11853, 11935, 11935, 12303], [12305, 12390, 12434, 12434, 12658], [12660, 12717, 12754, 12795, 12878], [12880, 12880, 12919, 13091, 13200], [13202, 13202, 13251, 13251, 13810], [13812, 13812, 13851, 13897, 13982], [13984, 13984, 14025, 14135, 14249], [14264, 14315, 14352, 14352, 14374], [14376, 14376, 14419, 14419, 14441], [14443, 14443, 14487, 14487, 14508], [14510, 14510, 14553, 14553, 14652], [14655, 14655, 14700, 14700, 15129], [15131, 15131, 15152, 15152, 15216], [15218, 15218, 15258, 15258, 15383], [15386, 15386, 15421, 15421, 15569], [15571, 15571, 15605, 15605, 15781], [15783, 15783, 15818, 15818, 15853], [15855, 15855, 15892, 15892, 15927], [15929, 16100, 16185, 16185, 16262], [16264, 16307, 16382, 16382, 16801], [16803, 17381, 17465, 17465, 17808], [17810, 17816, 17868, 17868, 18024], [18026, 18026, 18086, 18086, 18127], [18129, 18344, 18375, 18375, 18424], [18426, 18426, 18453, 18453, 18491], [18493, 18493, 18522, 18522, 18560], [18562, 18562, 18589, 18589, 18638], [18641, 18870, 18891, 18891, 19030], [19056, 19056, 19088, 19088, 19201], [19203, 19203, 19235, 19235, 19375], [19377, 19377, 19410, 19410, 19642], [19644, 19644, 19667, 19667, 20246], [20248, 20248, 20273, 20273, 20434], [20436, 20436, 20479, 20479, 21492], [21493, 22401, 22486, 22561, 23010], [23012, 23012, 23044, 23044, 26709], [26711, 26928, 26949, 26949, 27447], [28816, 28816, 28865, 28865, 29163], [29166, 31082, 31108, 31108, 33078], [33083, 33254, 33275, 33275, 33323], [33325, 33325, 33386, 33471, 33670], [33672, 33672, 33745, 33837, 34037], [34039, 34039, 34081, 34161, 34215], [34217, 34217, 34266, 34266, 34314], [34316, 34316, 34389, 34446, 34661], [34663, 34663, 34683, 34683, 34708], [34711, 34895, 34945, 35029, 35387], [35389, 35389, 35444, 35501, 35761], [35763, 35763, 35859, 35859, 37254], [37256, 37458, 37491, 37547, 37733], [37735, 37735, 37774, 37774, 37817], [37819, 40311, 40390, 40390, 42805], [42807, 42807, 42847, 42847, 45041], [45042, 45626, 45668, 45668, 45846], [45849, 45849, 45906, 45906, 47719]]}
{"id": "wtffRM", "name": "v3Circles2.glsl", "author": "jorge2017a1", "description": " keijiro /ShaderSketches \nhttps://github.com/keijiro/ShaderSketches/blob/master/Fragment/Discs2.glsl", "tags": ["v3circles2glsl"], "likes": 2, "viewed": 42, "published": "Public", "date": "1596314773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 coord, vec2 seed)\n{\n    float reso = 16.0;\n    float cw = iResolution.x / reso;\n\n    vec2 p = mod(coord, cw);\n    float d = distance(p, vec2(cw / 2.0));\n\n    float rnd = dot(floor(coord / cw), seed);\n    float t = iTime * 2.0 + fract(sin(rnd)) * 6.2;\n\n    float l = cw * (sin(t) * 0.25 + 0.25);\n    return clamp(l - d, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    vec2 dp = vec2(7.9438, 0.3335) * iTime;\n    float c1 = circle(p - dp, vec2(323.443, 412.312));\n    float c2 = circle(p + dp, vec2(878.465, 499.173));\n    float c = max(0.0, c1 - c2);\n    fragColor = vec4(c, c, c, 1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 349], [351, 351, 408, 408, 658]]}
{"id": "wtffWN", "name": "UVs of basic fractal", "author": "CoolerZ", "description": "Based on https://www.shadertoy.com/view/tltSWs \"Basic Fractal Zero\" by @paulofalcao", "tags": ["fractal", "domain", "uvs", "manipulation", "mirroring"], "likes": 3, "viewed": 65, "published": "Public", "date": "1596724932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/tltSWs \"Basic Fractal Zero\" by @paulofalcao\n// Too see the uvs that we get after mirroring and shifting uncomment below line.\n//#define UVS\n// To see the original fractal, comment UVS and uncomment below line.\n//#define ORIGINAL\n\nconst int maxIterations = 5;\nconst float radius = .5;\n\n//generic rotation formula\nmat2 rot(float a)\n{\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    // Taken from https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    // Taken from https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat scene_d(vec2 p)\n{\n    // Try out different shapes.\n    #ifdef ORIGINAL\n    return length(p)-radius;\n    #else\n    //return sdEquilateralTriangle(p);\n    return sdHexagon(p, 1.);\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n\t//global zoom\n\t//uv*=sin(iTime)*0.5+1.5;\n    \n\tfor(int i = 0; i < maxIterations; i++)\n    {\n        uv = abs(uv); // Mirror the uvs so that all quadrants become the 1st quadrant\n        uv = 2.*uv-1.; // Shift all the numbers back to -1 to 1 range so we are back where we started.\n        uv = rot(iTime)*uv; // Rotate by some amount, these rotations add up as you go to deeper levels.\n        // Recursion, do all above steps again and again to get the fractal structure.\n\t}\n\n    #ifdef UVS\n    vec3 col = vec3(uv, 0.);\n    #else\n\t//draw a circle\n    float d = scene_d(uv);\n    #ifdef ORIGINAL\n    float mask = 1.-smoothstep(0., .01, d);\n    vec3 col = vec3(mask);\n    #else\n    float mask = 1.-smoothstep(0., 10., d);\n    vec3 col = vec3(uv*mask+uv.yx,0.);\n    #endif\n    #endif\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtffWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 355, 374, 374, 438], [440, 440, 482, 576, 787], [789, 789, 831, 925, 1115], [1117, 1117, 1140, 1173, 1313], [1315, 1315, 1370, 1370, 2246]]}
{"id": "WtffWS", "name": "Aquatic colors", "author": "Lay", "description": "Hi there!\n\nThis is the first shader I share\nAnd it is very simple :)\nHope, all designations are correct\n\nHave a nice day!", "tags": ["procedural", "2d", "perlin"], "likes": 2, "viewed": 69, "published": "Public", "date": "1597536869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat2 m = mat2( 0.60,  0.80, -0.80,  0.60 ); // everybody use this matrix\n\nfloat noise(vec2 p)\n{\n    float a = fract(100.*sin(220.*p.x+34.24)*sin(520.*p.y+2.68));\n    \n    return a;\n}\n\nvec2 random_direction(vec2 p)\n{\n    float f = noise(p);\n    return vec2(cos(6.283185307*f), sin(6.283185307*f));\n}\n\nfloat smoothing(float a, float b, float t)\n{\n    t = t * t * t * (t * (t * 6. - 15.) + 10.);\n    return a + (b-a)*t;\n}\n\nfloat perlin(vec2 p, float N)\n{\n    p *= N;\n    vec2 r = floor(p);\n    vec2 q = fract(p);\n    \n    float n00 = dot(q-vec2(0.,0.),random_direction(r+vec2(0.,0.)));\n    float n10 = dot(q-vec2(1.,0.),random_direction(r+vec2(1.,0.)));\n    float n01 = dot(q-vec2(0.,1.),random_direction(r+vec2(0.,1.)));\n    float n11 = dot(q-vec2(1.,1.),random_direction(r+vec2(1.,1.)));\n    \n    return .5*(1.+smoothing(smoothing(n00, n10, q.x),smoothing(n01, n11, q.x), q.y));\n}\n\nfloat perlin_octaves(vec2 p)\n{\n    float N = 7.;// + .5*sin(0.0003*iTime);\n    int oct = 4;\n    \n    float ns = perlin(p, N);\n    float A = 1.;\n    float MAX = 1.;\n    for (int i = 0; i < oct; ++i) {\n        N *= 2.;\n        A *= .5;\n        ns += A*perlin(p + N*vec2(1., 2.), N);\n        MAX += A;\n    }\n    return ns / MAX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x + vec2(0.02,0.05)*iTime + vec2(-0.05*sin(0.4*iTime), -0.03*sin(0.3*iTime));\n\n    vec2 p = uv;\n    float per0 = perlin_octaves(p);\n    float per1 = perlin_octaves(m*p + vec2(1., 3.));\n    float per2 = perlin_octaves(m*m*p + vec2(2., 2.));\n    float per3 = perlin_octaves(m*m*m*p + vec2(1., 1.));\n    \n    float super_perlin0 = perlin_octaves(m*(vec2(per0, per1) + 0.5*(per1*sin(.07*iTime)+per3*cos(.07*iTime))));\n    float super_perlin1 = perlin_octaves(m*m*vec2(per2, per3));// + 0.7*sin(0.2*iTime)*(per2+per3));\n    \n    float mega_perin = perlin_octaves(m*m*m*vec2(super_perlin0, super_perlin1));\n    \n    vec3 col = vec3(mega_perin, mega_perin, mega_perin);\n    \n    col *= per1*vec3(.4, .8, .3) + per3*vec3(.5, .25, .8) + per2*vec3(.0, .02, .0);\n    col *= 1.7;\n    \n    // to calibrate noise\n    float ns = .5+.5*noise(uv);\n    //col = vec3(ns, ns, ns);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 80, 101, 101, 188], [190, 190, 221, 221, 304], [306, 306, 350, 350, 424], [426, 426, 457, 457, 885], [887, 887, 917, 917, 1214], [1216, 1216, 1273, 1273, 2208]]}
{"id": "WtffWX", "name": "Caleb's Chaos", "author": "MysteryPancake", "description": "Shader port of code made by https://github.com/cxleb", "tags": ["fractal", "chaos"], "likes": 0, "viewed": 173, "published": "Public API", "date": "1597836776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float w = 16.0;\nfloat h = 9.0;\nfloat firstp = 0.0001;\nint iterations = 100;\nfloat tstart = 0.0;\nfloat tend = 20.0;\nfloat tstep = 0.5;\n//float t = 0.0;\n\nfloat f(float x, float y, float t, float p) {\n\treturn (sin(x * (x + t) / (y + p) + t) + 1.0) / 2.0;\n}\n\nfloat iterate(float x, float y, float t) {\n\tfloat p = firstp;\n\tfor (int i = 0; i < iterations; i++) {\n\t\tp = f(x, -y, t, p);\n\t}\n\treturn p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2((fragCoord.x / iResolution.x) * w, (fragCoord.y / iResolution.y) * h);\n\t//t += tstep;\n\tfloat t = mod(iTime * tstep, tend);\n\tfloat p = iterate(uv.x - (w / 2.0), uv.y - (h / 2.0), t);\n\tfragColor = vec4(p, p, p, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 152, 197, 197, 253], [255, 255, 297, 297, 394], [396, 396, 451, 451, 684]]}
{"id": "WtffzB", "name": "Library by MareeBree", "author": "mareebree", "description": "My first shader on shadertoy", "tags": ["library"], "likes": 7, "viewed": 194, "published": "Public API", "date": "1597004965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define eNISTA 0\n#define eFIOKA 1\n#define eKNJIGE 2\n\n#define BROWN vec3(0.647,0.325,0.094)\n#define GOLD vec3(1.0,0.843,0.0)\n\n#define LOCAL_UV_SIZE \tvec2(4.0,6.0)\n#define LOCAL_UV_OFFSET vec2(0.05*iTime,0.5*iTime)\n\n#define ASPECT_RATIO iResolution.x/iResolution.y\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nbool inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y;\n}\n\nfloat aspectDist(vec2 x,vec2 y)\n{\n    return length((x-y)*vec2(ASPECT_RATIO,1.0));\n}\n\nvec2 localUVSpace(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    uv *= LOCAL_UV_SIZE;\n    uv = fract(uv);\n    return uv;\n}\n\nvec2 localUVIndex(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    vec2 uvRatio = 1.0/LOCAL_UV_SIZE;\n    return floor(uv/uvRatio);\n}\n\nint getItem(vec2 index)\n{\n    float r = rand(index/1000.0);\n    if(r > 0.7) \t\t\treturn eFIOKA;\n    else if(r > 0.1) \t\treturn eKNJIGE;\n    else \t\t\t\t\treturn eNISTA;\n}\n\nvec3 drawFioka(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.2;\n    float fd = 0.15;\n    \n    vec3 col = BROWN;\n    vec2 edge_col = smoothstep(0.85,0.98,uv);\n    col -= max(edge_col.x,edge_col.y);\n    edge_col = smoothstep(0.80,0.98,vec2(1.0)-uv);\n    edge_col += smoothstep(0.85,0.98,vec2(1.0)-uv);\n    col -= max(edge_col.x,edge_col.y);\n    col = max(col,0.4*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.6*BROWN);\n    \n    float handleSize = 0.1;\n    vec3 handleColor = 0.6*BROWN;\n    float handleDist = aspectDist(uv,vec2(0.5));\n    handleColor *= smoothstep(0.15,0.11,handleDist);\n    col -= handleColor;\n\n    vec2 reflectionOffset = uvIndex*vec2(0.01,0.02);\n    reflectionOffset.x = clamp(-0.03,0.03,reflectionOffset.x);\n    reflectionOffset.y = clamp(-0.03,0.03,reflectionOffset.y);\n\n    vec2 reflectionPos = vec2(0.5) + reflectionOffset;\n    float reflectionDist = aspectDist(uv,reflectionPos);\n    col += smoothstep(0.04,0.001,reflectionDist);    \n\t\n    return col;\n}\n\nvec3 drawKnjige(vec2 uv,vec2 uvIndex)\n{\n    int numBooks = 6;\n    \n    vec2 bookUV = uv;\n\tbookUV.x = fract(uv.x*float(numBooks));\n    int bookIndex = int(uv/(1.0/float(numBooks)));\n    \n    float r = rand(vec2(bookIndex,uvIndex.x + uvIndex.y/2.0));\n    vec3 bookColorHSV = vec3(r,0.8,0.6);\n    vec3 bookColor = hsv2rgb(bookColorHSV);\n    \n    float bookMask = sin(3.14*bookUV.x);\n    \n    float trakaPos = bookUV.y+0.05*bookMask-0.05*r;\n   \t\n    float t = smoothstep(0.13,0.14,trakaPos);\n    float traka = min(t,smoothstep(0.20,0.19,trakaPos));\n    \n    traka *= bookMask*0.4;\n    vec3 trakaColor = GOLD*0.4;\n    \n    vec3 col = bookColor*bookMask + traka*trakaColor;\n    col += smoothstep(0.2,0.1,bookMask)*0.6*BROWN;\n    col += vec3(traka)*bookMask;\n    \n    col = clamp(col,0.0,1.0);\n    return col;\n}\n\nvec3 drawPolica(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.15; // Frame size\n    float fd = 0.10; // Frame depth\n    \n    vec3 col = vec3(0.0);\n\tcol = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.5*BROWN);\n    \n    bool shouldDrawBooks = inRect(uv,vec2(fs),vec2(1.0-fs));\n    vec2 booksUV = uv;\n    booksUV -= vec2(fs);\n    booksUV /= 1.0-2.0*fs;\n    col = mix(col,drawKnjige(booksUV,uvIndex),float(shouldDrawBooks));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= (1.3 + 0.3*sin(iTime))*iResolution.x/800.0;\n    uv.x += 0.03*uv.y*(-uv.x);\n    \n    vec2 localUV = localUVSpace(uv);\n    vec2 localIndex = localUVIndex(uv);\n    vec3 col = vec3(0);\n    \n    int item = getItem(localIndex);\n    if(item == eFIOKA)\n    {\n\t   col = drawFioka(localUV,localIndex);\n    }\n    else if(item == eKNJIGE)\n    {\n        col = drawPolica(localUV,localIndex);\n    }\n\telse\n    {\n       col = BROWN;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 402, 424, 424, 593], [595, 674, 694, 694, 766], [768, 822, 859, 859, 922], [924, 924, 957, 957, 1008], [1010, 1010, 1038, 1038, 1127], [1129, 1129, 1157, 1157, 1254], [1256, 1256, 1281, 1281, 1419], [1421, 1421, 1460, 1460, 2599], [2601, 2601, 2640, 2640, 3405], [3407, 3407, 3447, 3447, 4035], [4037, 4037, 4094, 4094, 4658]]}
{"id": "WtffzS", "name": "Necker Cube 2", "author": "dr2", "description": "Another dynamic generalization of the Necker Cube (mouse restores sanity)", "tags": ["illusion", "paradox"], "likes": 5, "viewed": 190, "published": "Public API", "date": "1596968188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Necker Cube 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec4 sLen;\nvec3 ltDir, vuDir;\nfloat tCur, dstFar, eWid;\nbool isBg, doFg;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  if (isBg) {\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.wyz).yzx, eWid, sLen.x));\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.xwz).xzy, eWid, sLen.y));\n    dMin = min (dMin, PrCapsDf ((abs (p) - sLen.xyw), eWid, sLen.z));\n  } else {\n    dMin = min (dMin, PrCylDf ((p - (sLen.xwz - 10. * vuDir)).xzy, eWid, sLen.y - eWid));\n    dMin = min (dMin, PrCylDf ((p - (sLen.xyw * vec3 (1., -1., 1.) - 10. * vuDir)), eWid, sLen.z - eWid));\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, vn;\n  vec2 s;\n  float dstObj, dstObjF, nDotL;\n  sLen = vec4 (vec3 (3., 2., 4.), 0.);\n  eWid = 0.3;\n  isBg = true;\n  roo = ro;\n  col = vec3 (0.61, 0.6, 0.6);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = (Minv3 (max (abs (ro) - sLen.xyz + eWid, 0.)) > 0.) ?\n       vec4 (0.9, 0.9, 1., 0.3) : vec4 (0., 0.9, 0.6, 0.2);\n    if (doFg) {\n      isBg = false;\n      ro = roo;\n      dstObjF = ObjRay (ro, rd);\n      if (dstObjF < dstObj) {\n        ro += dstObjF * rd;\n        vn = ObjNf (ro);\n        col4 = vec4 (0., 0.9, 0.6, 0.2);\n      }\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.3 + 0.7 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, col, vx, vy;\n  vec2 canvas, uv, uvv, mSize, fgLim;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  az = 0.3 * pi - 0.05 * pi * sin (0.1 * pi * tCur);\n  el = -0.07 * pi - 0.02 * pi * cos (0.1 * pi * tCur);\n  ro = vec3 (0., 0., -12.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  vuDir = normalize (- ro);\n  mSize = vec2 (0.7, 0.5);\n  fgLim = abs (uv) - mSize;\n  doFg = (max (fgLim.x, fgLim.y) < 0.);\n  if (mPtr.z > 0.) doFg = false;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  zmFac = 0.22;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (-1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, vuDir);\n  }\n  uv *= vec2 (canvas.y / canvas.x, 1.);\n  uv *= uv;\n  uv *= uv;\n  col *= 1. - 0.3 * smoothstep (0.5, 1., dot (uv, uv));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtffzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 361, 383, 383, 875], [877, 877, 910, 910, 1087], [1089, 1089, 1110, 1110, 1360], [1362, 1362, 1397, 1397, 2226], [2270, 2270, 2326, 2326, 3640], [3642, 3642, 3684, 3684, 3735], [3737, 3737, 3780, 3780, 3844], [3846, 3846, 3868, 3868, 3906], [3908, 3908, 3938, 3938, 4051]]}
{"id": "WtjBRR", "name": "Soft shadows - athibaul", "author": "athibaul", "description": "An alternative algorithm for computing soft shadows.\n", "tags": ["raymarching"], "likes": 1, "viewed": 47, "published": "Public", "date": "1598388989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// An alternative to iq's algorithm for soft shadows\n// with results somewhat closer to physical based lighting.\n\n// Inigo Quilez's tutorial on soft shadows:\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n// The algorithm by iq makes shadows are a bit too large:\n// it widens the penumbra,\n// but it does not shrink the area of the umbra.\n// This is because we still consider that the light \n// is fully blocked whenever the center of the light source is occluded.\n\n// My alternative is to do a modified raymarching loop,\n// where the distance marched is the scene SDF + the \"width\" of the light bundle.\n// Occlusion is computed using the signed distance:\n// d <= -w   ==> Full occlusion\n// d = 0     ==> Half occlusion\n// d > w     ==> No occlusion\n// This results in (much!) stronger artifacts,\n// but they can be reduced using a randomized first step.\n\n\n// 0: Hard shadows\n// 1: Soft shadows by iq\n// 2: Soft shadows by iq, reduced artifacts\n// 3: Soft shadows by athibaul\n#define SHADOW_TYPE 3\n\n// Just a golden color\n#define C_GOLD vec3(1., 0.86, 0.57);\n\n// How many steps until full shadow\n#define LIGHT_STEPS 100\n// Use blue noise in various places to reduce banding/aliasing artifacts\n#define USE_BLUE_NOISE true\n// Sun half-angle size in radians\n#define SUN_SIZE 0.1\n\n\n\nvec4 bluenoise(in vec2 fragCoord)\n{\n    if(!USE_BLUE_NOISE) return vec4(0.);\n    ivec2 c = ivec2(fragCoord);\n    c.x %= 1024;\n    c.y %= 1024;\n    return texelFetch(iChannel0, c, 0) - 0.5;\n}\n\nfloat boxDist(in vec3 p, in vec3 r)\n{\n    vec3 q = abs(p) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sphereDist(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat map( in vec3 p )\n{\n    float d = boxDist(p, vec3(1.))-0.1;\n    d = min(d, p.z+1.);\n    d = min(d, sphereDist(p - vec3(0.,2.,0.), 1.));\n    return d;\n}\n\nvec3 normal( in vec3 p )\n{\n    vec2 eps = vec2(0.0001, 0.);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)));\n}\n\n\nvec3 camRay( in vec3 fwd, in vec2 fragCoord, in float fov )\n{\n    vec3 up = vec3(0.,0.,1.); // Z is up\n    // Orthonormalize\n    up = normalize(up - fwd * dot(fwd, up));\n    vec3 right = cross(fwd, up);\n    // Relative coordinates : from 0 to 1, then from -1 to 1 vertically\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    return normalize(fwd + fov * (uv.x * right + uv.y * up));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime*0.2;\n    vec3 ro = vec3(5.*cos(theta),5.*sin(theta),2.5);\n    vec3 target = vec3(0.);\n    vec2 coo = fragCoord;\n    //vec2 coo = fragCoord + bluenoise(fragCoord).xy;\n    vec3 ri = camRay(normalize(target-ro), coo, 0.7);\n    \n    // Raymarching loop\n    vec3 pos, norm;\n    float tray;\n    {\n        float d, t=0.;\n        int i;\n        for(i=0; i<300; i++)\n        {\n            d = map(ro + t*ri);\n            if(d < 0.0001) break;\n            t += d;\n            if(t > 100.) break;\n        }\n        pos = ro + t*ri;\n        norm = normal(pos);\n        tray = t;\n    }\n    \n    // Lighting loop\n    float shadow = 1.; // 1 for full light, 0 for full shadow\n\tvec3 li = normalize(vec3(2.,1.,2.2)); // Directional light\n    vec3 lo = pos + 0.001*norm; // Get away from the surface\n    float th = -iTime*0.5 + 3.14159; // Sun revolves around the scene\n    li.xy = mat2(cos(th), sin(th), -sin(th), cos(th)) * li.xy;\n    {\n        float d, t = map(lo) * (bluenoise(fragCoord).w+0.5);\n        int i;\n        float r1=1000., r2; // Previous and current \"step size\"\n        for(i=0;i<LIGHT_STEPS;i++)\n        {\n            d = map(lo + t*li);\n            // Hard shadows       \n            #if SHADOW_TYPE==0\n\t\t\tif(d < 0.0001) { shadow = 0.; break; }\n            t += d;\n\t\t\t#endif\n            \n            // Soft shadows - iq's simple version\n            // https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n            // This exhibits some artifacts at sharp corners,\n            // which can be reduced using blue noise.\n            #if SHADOW_TYPE==1\n            float w = SUN_SIZE*t;\n            shadow = min(shadow, smoothstep(0., w, d));\n            t += d;\n            #endif\n            \n            // Soft shadows - iq's version 2, with reduced artifacts\n            #if SHADOW_TYPE==2\n            float w = SUN_SIZE*t;\n            r2 = d;\n            float y = r2*r2/(2.0*r1)*0.999;\n            float true_d = sqrt(r2*r2-y*y);\n            float true_w = SUN_SIZE*max(0.,t-y);\n            shadow = min(shadow, smoothstep(0., true_w, true_d));\n            t += r2;\n            r1 = r2;\n            #endif\n            \n            // Soft shadows - athibault version\n            #if SHADOW_TYPE==3\n            float w = SUN_SIZE*t;\n            shadow = min(shadow, smoothstep(-w, w, d));\n            t += d+w;\n            #endif\n            \n            if(t > 100.) break;\n        }\n        if(i==LIGHT_STEPS) { // Didn't find the light\n            shadow = 0.;\n        }\n    }\n    \n    // Output to screen\n    //vec3 col = vec3(t/10.);\n    vec3 diffuse = abs(norm.yzx) * clamp(dot(norm, li),0.,1.) * 2.;\n    vec3 col = mix(diffuse * shadow, vec3(0.2,0.6,0.2), smoothstep(3., 50., tray));\n    //vec3 col = vec3(shadow);\n    //vec3 col = diffuse;\n    \n    col /= length(vec2(length(col), 1.0));\n    fragColor = vec4(col,1.0);\n    // Add some noise to avoid banding\n    fragColor.rgb += 0.02 * bluenoise(fragCoord).xyz;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjBRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1242, 1300, 1335, 1335, 1490], [1492, 1492, 1529, 1529, 1622], [1624, 1624, 1665, 1665, 1693], [1695, 1695, 1719, 1719, 1851], [1853, 1853, 1879, 1879, 2105], [2108, 2108, 2169, 2169, 2544], [2546, 2546, 2603, 2603, 5567]]}
{"id": "wtjBRW", "name": "Minimalism #03", "author": "Flopine", "description": "Third piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.", "tags": ["2d", "animation", "minimalist"], "likes": 10, "viewed": 127, "published": "Public", "date": "1598449480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define time(speed) fract(iTime*speed)\n#define bouncy(speed) (abs(sqrt(sin(time(speed)*PI))))\n#define AnimOutExpo(speed) easeOutExpo(time(speed))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define circle(puv,s) (length(puv)-s)\n#define square(puv,s) (max(abs(puv.x),abs(puv.y))-s)\n#define line(puv,s) (abs(puv)-s)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(puv,s) puv=abs(puv)-s; if(puv.y>puv.x) puv=puv.yx\n#define xor(a,b) ((1.-b)*a+(1.-a)*b)\n\nfloat easeOutExpo (float x) \n{\n\treturn x == 1. ? 1. : 1. - pow(2., -10. * x);\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 uu = uv;\n    float per = 4.;\n    \n    // crossing lines\n    float mask = AAstep(0.01,line(uu.x,0.01));\n    mask *= AAstep(0.01,line(uu.y,0.01));\n    \n    // repetition, mirror\n    mo(uv,vec2(0.));\n\n    //animation\n    float sp = 0.2;\n    float swit = sign(sin(time(sp)*TAU));\n    float anim = (time(sp)*2.-1.)*sign(sin(time(sp*0.5)*TAU));\n    uv = (swit <= 0.) ? uv-vec2(bouncy(sp*2.)*1.2,0.) : uv*rot(AnimOutExpo(sp)*PI*1.03);\n  \n    uu = uv;\n    \n    // star\n    mo(uv,vec2(0.2));\n \tmask *= AAstep(0.01,line(uv.x+uv.y*1.8,0.05));\n    //circles\n    uv -= 0.2;\n    mask *= AAstep(0.02, abs(circle(uv,0.1)));\n    \n    // outside square\n    mask *= AAstep(0.015,abs(square(uu,0.65)));\n    \n    // inside squares\n    mask *= AAstep(0.015,abs(square(uu,0.2)));\n    uu *= rot(PI/4.);\n    mask *= AAstep(0.015,abs(square(uu,0.13)));\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(frame(uv*2.));\n    col = xor(col,vec3(0.,0.,0.15));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 866, 896, 896, 945], [947, 947, 970, 970, 1830], [1832, 1832, 1889, 1889, 2060]]}
{"id": "WtjcWR", "name": "Distributed noise", "author": "erikthalen", "description": "normal distributed noise", "tags": ["noise"], "likes": 0, "viewed": 49, "published": "Public", "date": "1596660692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265359;\nfloat e = 2.7182818284590452353602;\n\n// https://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm\nfloat normal(float x) {\n\treturn (pow(e, (pow(-x, 2.)/2.))) / sqrt(2.*pi);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat random11 (float x) {\n    return fract(sin(x*78.233)* 43758.5453123);\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.1;\n    vec2 uv = (fragCoord / .5 -iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy / .5 -iResolution.xy)/iResolution.y;\n    \n    float normalRandom = normal(vec2(random(uv)).y) * normal(vec2(random(uv)).x) * 1.5;\n    \n    float hue = normalRandom;\n    \n    float fromMouse = length(vec2(mouse) - vec2(uv));\n    \n    hue += uv.x * .0001;\n    \n    hue += time;\n    \n    float lightness = fromMouse;\n\n    fragColor = vec4(hsl2rgb( vec3(hue, .9, .5)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 132, 155, 155, 207], [209, 209, 235, 235, 375], [377, 377, 401, 401, 474], [476, 476, 502, 502, 552], [562, 562, 619, 619, 1112]]}
{"id": "wtjfRh", "name": "animated worley noise", "author": "soggymongoose", "description": "animated worley noise, let me know if you have questions and have comments about how badly this is implemented ", "tags": ["voronoi", "noise", "tutorial", "worley"], "likes": 3, "viewed": 94, "published": "Public", "date": "1598338218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//number of points to be randomly placed to create the distance field (keep a float)\n#define pNum 50. \n\nvec2 random12(float uv) { //what other random number generator should I be using\n    return vec2(fract(sin(uv*523.72342)*2323.51231),fract(cos(uv*383.23563)*6248.35731));\n}\n\nfloat random21(vec2 uv) {\n    return fract(sin(dot(uv,vec2(12.541,73.652)))*45231.62423);\n}\n\nvec2 random22(vec2 uv) {\n    return vec2(fract(sin(dot(uv,vec2(14.541,68.674)))*73451.54923),\n                fract(cos(dot(uv,vec2(20.784,84.356)))*62234.85234)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\n\t//create points for comparison\n    vec2[int(pNum)] points; \n    for (float i = 0.; i < pNum; i++) {\n    \tpoints[int(i)] = vec2(random12(i) - .5);\n        //move dots to fix my bad random number method\n        points[int(i)].x *= 1.3;\n        points[int(i)].y *= .6;\n        \n        //animate points\n    \tif (random21(points[int(i)]) > .5) {\n      \t\tpoints[int(i)] += 0.1*sin(iTime + 3.2831*points[int(i)]);\n    \t} else {\n        \tpoints[int(i)] += 0.1*cos(iTime + 4.2831*points[int(i)]);\n    \t}\n    }\n    \n\t//calculate smallest distance from every point\n    float minDist = 2.;\n    \n    for (float i = 0.; i < pNum; i++) {\n    \tfloat tempDist = distance(points[int(i)],uv);\n        \n        if (tempDist < minDist) {\n           minDist = tempDist;\n        }\n    }\n    \n    //add blue background and invert color\n    vec3 col = vec3(max(smoothstep(.5,.0,minDist),.5));\n    \n    col -= vec3(1.-126./255.,1.-249./255.,0.)+.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 104, 129, 184, 276], [278, 278, 303, 303, 369], [371, 371, 395, 395, 537], [539, 539, 596, 646, 1730]]}
{"id": "WtjfRw", "name": "Trippy 2 By MareeBree", "author": "mareebree", "description": "trippy", "tags": ["trippy"], "likes": 6, "viewed": 539, "published": "Public API", "date": "1598547167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define PI (3.1415)\n\n// UTIL FUNCTIONS //////////////////////////////////////\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 inverseColor(vec3 col)\n{\n    return vec3(1.0-col.r,1.0-col.g,1.0-col.b);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float c){\n    vec2 co = vec2(c,c);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat xor(float a,float b)\n{\n    return a*(1.0-b)+b*(1.0-a);\n}\n\nvec3 xor(vec3 a,vec3 b)\n{\n    return vec3(xor(a.x,b.x),xor(a.y,b.y),xor(a.z,b.z));\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nfloat inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y ? 1.0 : 0.0;\n}\n\n////////////////////////////////////////\n\n// Wraps uv around tunnel\n// https://www.shadertoy.com/view/4djBRm\nvec2 tunnel(vec2 uv, float size, float time)\n{\n    vec2 p  = -1.0 + (2.0 * uv);\n    float a = atan(p.y, p.x);\n    float r = sqrt(dot(p, p));\n    return vec2(a / PI, time + (size / r));\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    uv -= 0.5;\n    mat2 mat = mat2(vec2(cos(angle), sin(angle)),vec2(-sin(angle), cos(angle)));\n    return mat*uv + 0.5;\n}\n\nfloat diamondMask(vec2 uv,float ds,float lb)\n{\n    vec2 iuv = vec2(1.0-uv.x,1.0-uv.y); // inverse uv\n    \n    float db1 = S(0.5+ds,0.5+ds-lb,(iuv.x+uv.y)/2.0);\n    float db2 = S(0.5+ds,0.5+ds-lb,(uv.x+iuv.y)/2.0);\n    float db3 = S(0.5+ds,0.5+ds-lb,(uv.x+uv.y)/2.0);\n    float db4 = S(0.5+ds,0.5+ds-lb,(iuv.x+iuv.y)/2.0);\n    return min(min(min(db1,db2),db3),db4);\n}\n\nfloat shapeMask(vec2 uv,float layer,float t)\n{\n    // Rotation\n    float rotAngle = 3.0*sin(t*0.5 + 2.0*PI*rand(layer));\n    rotAngle = min(PI/2.0,rotAngle);\n    rotAngle = max(0.0,rotAngle);\n    \n    uv = rotate(uv,rotAngle);\n    \n    // Some variables\n   \tfloat lt = 0.1; // line thickness\n    float lt2 = lt/2.0;\n    float lb = 0.01; // line blur\n    \n    // Vertical line\n    float vl = S(0.5-lt2-lb,0.5-lt2,uv.x);\n    vl = min(vl,S(0.5+lt2,0.5+lt2-lb,uv.x));\n    \n    // Horizontal line\n    float lta = lt2; // line thickness with AR\n    float lba = lb;\n    float hl = S(0.5-lta-lba,0.5-lta,uv.y);\n    hl = min(hl,S(0.5+lta,0.5+lta-lba,uv.y));\n    \n    float c = max(hl,vl); // Cross\n    \n    // Center shape\n    float bds = 0.2; // big diamond size\n    float sds = bds-lt; // small diamond size\n    float bd = diamondMask(uv,bds,lb); // Big diamond\n    float sd = diamondMask(uv,sds,lb); // Small diamoind\n    float cs = clamp(bd-sd,0.0,1.0); // center shape\n    \n    float rs = 0.25;//center size\n    vec4 cr = vec4(rs,rs,1.0-rs,1.0-rs);  // center rect (a,b)\n    float inCenter = inRect(uv,cr.xy,cr.zw);\n    \n    float m = mix(c+cs,cs,inCenter);\n    \n    m = clamp(m,0.0,1.0);\n    \n    return m;\n}\n\nvec3 shapeColor(vec2 uv,float t,float layer)\n{\n    vec3 hsv = vec3(rand(layer)+ 0.3*sin(0.1*t),0.7/(layer/2.0),0.8+0.3*sin(t));\n    return hsv2rgb(hsv);\n}\n\nvec3 drawLayer(vec2 uv,vec2 suv,float layer, float opacity,float t)\n{\n    float mask = shapeMask(uv,layer,t);\n    vec3 color = shapeColor(suv*layer,t,layer);\n    return color*mask*opacity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sound data\n    int tx = int(0.8*512.0);\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    vec2 suv = fragCoord/iResolution.xy; // screen uv\n\n    \n    vec2 guv = suv;\n    float t = 0.3*iTime;\n   \tguv = rotate(guv,0.5*atan(sin(.5*t),suv.x+suv.y));\n    guv.x += 0.05*sin(0.3*iTime);\n    guv.y += 0.05*cos(0.3*iTime);\n    \n    float dc = sqrt(length(guv-vec2(0.5,0.5))); // distance to center\n    \n    guv = tunnel(guv,0.1*(1.0+sin(t)),0.2*t-0.5*(1.0+sin(t)));\n    \n    vec2 uv = 5.0*guv;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n    \n    \n    for(float i=1.0;i<=4.0;i++)\n    {\n        vec2 layerUV = fract(uv + rand(i));\n        layerUV = fract(layerUV+0.1*iTime*rand(i));\n        //col = xor(col,inverseColor(col)*drawLayer(layerUV,suv,i,2.0/i,iTime));\n        col += inverseColor(col)*drawLayer(layerUV,suv,i,2.0/i,iTime);\n    }\n\t\n    vec3 icol = inverseColor(col);\n    float bgMask = S(0.8,0.85,max(max(icol.r,icol.g),icol.b));\n   \tvec3 bgColor = hsv2rgb(vec3(0.7+0.2*sin(t*0.1 + 0.1*wave),0.9,0.8));\n    \n    \n    float fadeEffect = (1.0+sin(0.2*t))/2.0;\n    fadeEffect = min(3.0*fadeEffect,1.0);\n    \n    float distanceShadow = clamp(2.0*dc,0.0,1.0);\n    col = mix(bgMask*bgColor,bgMask*bgColor+col,fadeEffect)*distanceShadow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XtSGWK", "previewfilepath": "https://soundcloud.com/rainbowtripmusic/psychedelicmushroomstripexperience", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/rainbowtripmusic/psychedelicmushroomstripexperience", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 252, 274, 274, 443], [445, 445, 474, 474, 524], [526, 526, 546, 546, 618], [620, 620, 640, 640, 737], [739, 739, 767, 767, 801], [803, 803, 828, 828, 887], [889, 943, 981, 981, 1056], [1100, 1167, 1213, 1213, 1353], [1355, 1355, 1390, 1390, 1513], [1515, 1515, 1561, 1561, 1881], [1883, 1883, 1929, 1945, 3088], [3090, 3090, 3136, 3136, 3244], [3246, 3246, 3315, 3315, 3436], [3438, 3438, 3495, 3513, 4880]]}
{"id": "WtjfWR", "name": "attemping clouds part 2", "author": "danhel95", "description": "my 2nd attempt to make  clouds !", "tags": ["noise", "ray", "cloud", "marching"], "likes": 1, "viewed": 144, "published": "Public", "date": "1598659689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Learning tutorial 5! \n// clouds part 2\n// based on https://www.shadertoy.com/view/wsjfRD by @42yeah,\n// and https://www.shadertoy.com/view/tt2cWh by @shikz86\n\n#define ITR 30.\n#define EPSILON 0.001\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nvec3 sun, sun_col;\nvec3 normal;\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n};\n\nfloat N21( vec3 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat N11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat N31(in vec3 n)\n{\n\tvec3 i = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = i.x+i.y*57.+i.z*113.;\n    float r =\n    mix(\n        mix(\n            mix(N11(q+0.),N11(q+1.),f.x),\n            mix(N11(q+57.),N11(q+58.),f.x),\n            f.y),\n        mix(\n            mix(N11(q+113.),N11(q+114.),f.x),\n            mix(N11(q+170.),N11(q+171.),f.x),\n            f.y),\n        f.z);\n\n    return r;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f = 0.5*N31(p);\n    return f;\n}\n\n\nfloat sphere( vec3 q,float r){\n\n    vec3 p = q *.5;\n    p *= 1. - .3*vec3(.1,0.2,.1);\n    p.z *= .6;\n    p.y -= pow(abs(p.x)/15.,-p.y*.1+1.5)*1.2;\n    p.x *= .8;\n    float d = length(p) - r;\n    return d;\n}\n\n\nfloat scene(in vec3 q)\n{\n    vec3 p = q - vec3(0.0,0.,2.0)*sin(iTime*.5);\n    float f = fbm(p);\n    vec2 r = vec2(6.,2.);\n    float d =1.;\n    d -= sphere(p,1.7);\n    d += 1.2*f;\n    return clamp(d,0.,.6);\n}\n\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nray raydir(vec2 uv) {\n\n    vec2 m = iMouse.xy / iResolution.xy;\n    float zoom = 1., roll=0.;\n    float camY = 4.+ .25*sin(iTime*.33) ;\n    float camX = 15. +.25*cos(iTime*.33);\n    float camZ = zoom - 8. ;\n    vec3 camPos = vec3(camX,camY,camZ);\n\n    //camPos += vec3(2., .0 ,2. );\n    vec3 lookat = vec3(0.);\n    ray r ;\n    r.o = camPos;\n    r.t = lookat;\n\n    mat3 viewCam = camera(r, roll);\n    vec3 o = vec3(uv,zoom);\n    vec3 rd =  viewCam * normalize(o);\n    r.d = normalize(rd);\n    return r;\n\n}\n\n\nvoid luminance(inout vec3 col, float lum)\n{\n\tlum /= \tdot(col.rgb,vec3(0.2126 , 0.7152  ,0.0722) );\n\tcol *= lum;\n}\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\nvec3 draw_light(vec3 p, vec3 l, vec3 color, float range, float radius,float shad)\n{\n\tfloat ld = length(p - l);\n\tvec3 rd = normalize(l - p);\n\tif (ld > range) return vec3(0.);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(sphere(p - l, radius));\n\treturn (shad* fall + source) * color;\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    // float denseD1 = .5;\n    // float denseE1 = .01;\n    float denseD2 = .01;\n    float denseE2 = .2 ;\n    float dd = 0.;\n    vec4 col = vec4(0.0);\n    for (float i = 0.; i < 1.; i+=1./ITR) {\n        float res = 0.;\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        vec4 color = vec4(d);\n        luminance(sun_col,1.5);\n        float dl = length(sun - p );\n        if (d < dl)\n            res = .5;\n        vec3 s = draw_light(p,sun,sun_col,100.,8.,.4);\n        color.rgb *= mix(s,color.rgb,.4);\n        //color *= pow(d/(denseD1 + d),denseE1);\n        color *= 1.2*exp(-(d -denseD2)*(d -denseD2)/denseE2);\n        col += color * (1. - col.a);\n        t += i;\n    }\n\n\n\n    col.rgb = clamp(col.rgb, 0., 1.) ;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = st*2.;\n\n    ray r = raydir(uv);\n    vec3 sky = mix(vec3(.1, .6, .9), vec3(.2, .2, .6), (.25-st.y));\n    sun = vec3(5.+.5*sin(iTime*.33)*10. , 15.  , 5.0 +.5*cos(iTime*.33)*10.  );\n    sun_col = vec3(.9, .3, 0.2) ;\n\n    vec4 col = march(r.o, r.d);\n    float fog = 1.1 - .8*col.a , a = 1.5, b = -.001;\n    vec3 colr = col.rgb;\n    colr = mix(vec3(col.rgb) * a * exp(b*col.a*col.a),sky, fog);\n    //gamma correction\n    colr = pow(colr,vec3(1./2.2));\n\n\n\n    fragColor = vec4(colr, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjfWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 344, 365, 365, 433], [435, 435, 455, 455, 491], [493, 493, 515, 515, 911], [913, 913, 932, 932, 978], [981, 981, 1011, 1011, 1187], [1190, 1190, 1214, 1214, 1397], [1401, 1401, 1434, 1434, 1607], [1609, 1609, 1630, 1630, 2113], [2116, 2116, 2159, 2159, 2229], [2232, 2232, 2260, 2260, 2294], [2295, 2295, 2378, 2378, 2607], [2611, 2611, 2641, 2641, 3404], [3406, 3406, 3461, 3461, 4024]]}
{"id": "wtlBD8", "name": "gradient_area", "author": "Sakurai_ken", "description": "gradient_area", "tags": ["2d"], "likes": 1, "viewed": 42, "published": "Public", "date": "1596634299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 5\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdPolygon(in vec2[N]v,in vec2 p)\n{\n  float d=dot(p-v[0],p-v[0]);\n  float s=1.;\n  for(int i=0,j=N-1;i<N;j=i,i++)\n  {\n    vec2 e=v[j]-v[i];\n    vec2 w=p-v[i];\n    // 距离矢量，由端点到点的矢量减去端点到投影点的矢量\n    vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);\n    d=min(d,dot(b,b));\n    // 还是even_odd着色, y在端点间，且叉积为正\n    bvec3 c=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if(all(c)||all(not(c)))s*=-1.;\n  }\n  return s*sqrt(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p=(2.*fragCoord-iResolution.xy)/iResolution.y;\n  \n  vec2 v0=.8*cos(.40*iTime+vec2(0.,2.)+0.);\n  vec2 v1=.8*cos(.45*iTime+vec2(0.,1.50)+1.);\n  vec2 v2=.8*cos(.50*iTime+vec2(0.,3.)+2.);\n  vec2 v3=.8*cos(.55*iTime+vec2(0.,2.)+4.);\n  vec2 v4=.8*cos(.60*iTime+vec2(0.,1.)+5.);\n  \n  vec2[]poly=vec2[](v0,v1,v2,v3,v4);\n  float d=-sdPolygon(poly,p) + 0.01;\n  float i = step(abs(d), 0.01);\n  // 截取的着色函数\n  float alpha=pow(1.-clamp(d * 5.,0.,1.)-step(d,0.),2.);\n  vec3 color=  i * vec3(0.1, 0.1, 1.) + (1.-i) * vec3(0., 0., alpha);\n  \n  fragColor=vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 38, 38, 57], [58, 58, 98, 98, 551], [554, 554, 611, 611, 1187]]}
{"id": "wtlBDB", "name": "A Worm trailing", "author": "mightee_cactus", "description": "Just a worm :)", "tags": ["worm", "trail", "tail"], "likes": 2, "viewed": 96, "published": "Public", "date": "1597680758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Started from here:\n// https://www.shadertoy.com/view/WlX3Wr\n//\n// Then gone too experimental :D\n//\n\n\n#define RADIUS  0.1\n#define TAIL_LENGTH 0.8\n#define H_SIZE 0.3\n#define V_SIZE 0.3\n#define H_OSC 15.\n#define V_OSC 5.\n\n#define BG_COLOR    vec3(0.165, 0.125, 0.224)\n#define SNAKE_COLOR vec3(0.906, 0.275, 0.6)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = fragCoord/iResolution.xy;\n    vec2 uvUni = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 pivot = vec2(0.);\n    \n    vec2 pos;\n    float step = H_SIZE * 0.001;\n    for(float t = TAIL_LENGTH; t > 0.; t -= step)\n    {\n        pos = pivot;\n        pos.x += sin(iTime + t*H_OSC) * H_SIZE;\n        pos.y += cos(iTime + t*V_OSC) * V_SIZE;\n        \n\t\tif(length(pos - uvUni) <= RADIUS)\n        {   \n            fragColor = vec4(SNAKE_COLOR * (t / TAIL_LENGTH), 1.0);\n            return;\n        }\n    }\n    \n    fragColor = vec4(BG_COLOR, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 317, 374, 374, 940]]}
{"id": "WtlBDS", "name": "Menger z", "author": "illus0r", "description": "Menger z", "tags": ["raymarching"], "likes": 2, "viewed": 200, "published": "Public API", "date": "1597615745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 200\n#define MAX_DIST 5.\n#define SURF_DIST .0001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\n\n\n\nfloat GetDist(vec3 p) {\n    \n    p.xz *= Rot(sin(iTime));\n\n    p.x = abs(p.x);\n    p.x += 0.1 * sin(iTime / 1.7);\n    //p.x -= 0.1 * sin(iTime);\n    \n\n    p.z = abs(p.z);\n    p.z += 0.1 * sin(iTime / 1.4);\n    //p.z -= 0.1 * sin(iTime);\n\n    float box = sdBox(p, vec3(iTime));\n    //p.y += iTime / 10.;\n    p.y += iTime * 1.;\n    \n    \n    float hole = 0.;\n\n    float holiness = 3.;//2. + 2. * (0.5 + 0.5 * sin(p.y + iTime));\n    float iterations = 3.;\n    for (float axes = 0.; axes <= 2.; axes++) {\n        p = p.zxy;\n\t    vec3 pm = p;\n   \t\tfor (float i = 1.; i <= iterations; i++) {\n        \tpm.xy = fract((pm.xy * 1. * i + 0.5)) - 0.5;\n\t\t    hole = min(hole, sdBox(pm, vec3(1./holiness/i, 1./holiness/i, iTime * 2.)));\n\t    }\n    }\n    \n    //hole /= 2. * iterations;\n    hole *= 3.9;\n    \n    return max(0., -hole);\n}\n\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0., 0.);\n    vec3 camDir = vec3(0.001, 1., 0);\n    \n    camDir.yz *= Rot(-m.y*3.14+1.);\n    camDir.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro + camDir, 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \t//float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \t//col += dif;\n        //col = n / 2. + 0.5;\n        //col *= n.x;\n        col = vec3(1.-smoothstep(0., 4., d));\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 338, 357, 357, 419], [421, 421, 443, 443, 537], [539, 539, 568, 568, 649], [656, 656, 679, 679, 1478], [1485, 1485, 1519, 1519, 1730], [1732, 1732, 1756, 1756, 1946], [1948, 1948, 1998, 1998, 2189], [2193, 2193, 2250, 2250, 2985]]}
{"id": "wtlBRl", "name": "#002 - Mandelbrot Xperiment", "author": "Deadtotem", "description": "Messing around with the Mandelbrot fractal", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 48, "published": "Public", "date": "1597495114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318\n#define PI 3.141592\n\nmat2 Rot(float a){\n    float s = sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\tvec4 area = vec4(1.5,-1.5,10.,10.);\n    float t = iTime*.0032;\n    vec2 c = ((fragCoord.yx/iResolution.xy))*area.zw*.5+.5;\n    c.xy *= Rot(t);\n    vec2 gv = c *.5396;\n    gv /= iTime*3.213;\n    \n\n\n    vec2 z;\n    float iter;\n    for(iter=0.; iter < 255.; iter++){\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y) + gv *.35+.35;\n       \n        if (length(z)>7.) break;\n    }\n    \n   \tfloat m= sqrt(iter/255.); \n    \n    vec3 col= sin(vec3(.34,.046,.075)*m*20.)*.5+.5;\n       \n\tcol *=mix(texture(iChannel0, vec2(c.y-iTime*.912,z+iTime*.021)/iter).rgb, col, .5)*fract(2345.2)*TAU;\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 59, 59, 120], [123, 123, 180, 180, 802]]}
{"id": "WtlBW2", "name": "Inflated Parametric Curve", "author": "arifr123", "description": "The function 'c(t) ' defines a curve in 3D space which is then drawn using several gradient descent optimisations (over t).\n", "tags": ["gradientdescent"], "likes": 5, "viewed": 73, "published": "Public", "date": "1598020980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define sq(x) dot(x, x)\n\n// Hue from: https://www.shadertoy.com/view/ll2cDc\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )\n//#define hue(v)  ( .5 +      cos( 6.3*(v)  + vec3(0,23,21)  ) )\n\nvec3 c(float t)\n{\n    // ###################################\n    // This is the parametric curve drawn.\n    // Try changing it!\n    // ###################################\n    \n    float time = 0.5*iTime;\n    return vec3(sin(5.*t + 0.6*sin(time)), sin(2.*t + 0.6*sin(time + 2.*PI/3.)), sin(3.*t + 0.6*sin(time + 4.*PI/3.)));\n}\n\nconst float h = 0.01;  // 0.0001\n\nvec3 dC_dt(float t, vec3 C)\n{\n    return (c(t + h) - C) / h;\n    //return vec3(-sin(t), cos(t), 0);\n    //return vec3(cos(2.*t), cos(3.*t), cos(5.*t));\n}\n\n\nstruct Ray\n{\n  vec3 ro;\n  vec3 rd;\n};\n\n/*\nfloat sqDistanceToRay(float t, Ray ray)\n{\n    vec3 c_o = c(t) - ray.ro;\n    return sq(c_o) - sq(dot(c_o, ray.rd));\n}\n*/\n\nfloat dSqDistanceToRay_dt(float t, Ray ray)\n{\n    vec3 c_o = c(t);\n    vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n    c_o -= ray.ro;\n    \n    return 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n    //return 2. * (dot(c_o, dc_dt - ray.rd * dot(dc_dt, ray.rd)));\n}\n\n/*\nfloat minimizeDistanceToRay(float startT, Ray ray)\n{\n    float t = startT;\n    \n    for(int i = 0; i < 100; i++)\n    {\n        float deltaT = 0.01 * dSqDistanceToRay_dt(t, ray);\n        \n        t -= deltaT;\n        \n        if(abs(deltaT) < 0.001)\n        \tbreak;\n    }\n    \n    return t;\n}\n\nfloat multipleSectionMinimization(float minT, float maxT, int sectionNum, Ray ray)\n{\n    float sectionSize = (maxT - minT) / float(sectionNum);\n    \n    float bestT = 0.;\n    float minSqDist = 0.;\n    \n    for(int i = 0; i < sectionNum; i++)\n    {\n        float sectionStart = float(i)*sectionSize;\n        float t = minimizeDistanceToRay(sectionStart + sectionSize / 2., ray);\n        \n        float sqDist = sqDistanceToRay(t, ray);\n        \n        if(i == 0 || sqDist < minSqDist)\n        {\n            minSqDist = sqDist;\n            bestT = t;\n        }\n    }\n    \n    return bestT;\n}\n\nfloat momentumGradientDescent(float startT, Ray ray, float learningRate, float exponentialFactor)\n{\n    float t = startT;\n    float deltaT = 0.;\n    \n    for(int i = 0; i < 300; i++)\n    {\n        deltaT = exponentialFactor * deltaT - learningRate * dSqDistanceToRay_dt(t, ray);\n        \n        t += deltaT;\n    }\n    \n    return t;\n}\n\nconst float epsilon = 0.00000001;\nconst float beta1 = 0.9;  // 0.9\nconst float beta2 = 0.999;  // 0.999\nconst float alpha = 0.1;  // 0.001\nfloat adam(float startT, Ray ray)\n{\n    float t = startT;\n    float m = 0.;\n    float v = 0.;\n    \n    float beta1pow = beta1;\n    float beta2pow = beta2;\n    \n    for(int i = 0; i < 300; i++)\n    {\n        float grad = dSqDistanceToRay_dt(t, ray);\n        \n        m = beta1*m + (1.-beta1)*grad;\n        v = beta2*v + (1.-beta2)*sq(grad);\n        \n        float m_hat = m / (1. - beta1pow);\n        float v_hat = v / (1. - beta2pow);\n        \n        t -= alpha * m_hat/(sqrt(v_hat)+epsilon);\n        \n        beta1pow *= beta1;\n        beta2pow *= beta2;\n    }\n    \n    return t;\n}\n*/\n\nfloat dSqDistance_dt(float t, vec3 p)\n{\n    vec3 C = c(t);\n    return dot(C - p, dC_dt(t, C));\n}\n\nvec2 reverseRaymarching(float t, float cProjection, float r, Ray ray)\n{\n    vec3 p = ray.ro + cProjection * ray.rd;\n\n    for(int i = 0; i < 50; i++)\n    {\n        // Try changing to 0.1 :)\n        float deltaT = 0.005 * dSqDistance_dt(t, p);  // 0.01\n\n        t -= deltaT;\n\t\t\n        //if(abs(deltaT) < 0.01)\n        {\n            float deltaP = (sqrt(sq(c(t) - p)) - r);\n\n            p += deltaP * ray.rd;\n            cProjection += deltaP;\n            // p == ray.ro + cProjection * ray.rd\n\n            if(abs(deltaP) < 0.0001)\n            {\n                break;\n            }\n        }\n    }\n    \n    return vec2(t, cProjection);\n}\n\n\n\n// Try changing to 0.01 :)\nconst float minDelta = 0.001;  // 0.001\n/*\nvec3 closectIntersection(Ray ray, float minT, float maxT, float r)\n{\n    float bestT = 0.;\n    float minProjection = -1.;\n    \n    float t = minT + minDelta;\n    float learning_rate = 0.01 * sign(dSqDistanceToRay_dt(t, ray));\n    \n    float intersection = 0.;\n    \n    for(int i = 0; i < 1000 && t >= minT && t < maxT; i++)//while(t >= minT && t < maxT)\n    {   \n        vec3 c_o = c(t);\n        vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n        c_o -= ray.ro;\n        \n        float deltaT = learning_rate * 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n\n        if(abs(deltaT) < minDelta)\n        {\n            // Extreme\n            \n            if(learning_rate < 0.)\n            {\n                // Min\n                \n                float cProjection = dot(c_o, ray.rd);\n                \n                if(sq(c_o) - sq(cProjection) <= sq(r))\n                {\n                    // Intersection\n                    \n                    vec2 res = reverseRaymarching(t, cProjection, r, ray);\n                    cProjection = res[1];\n                    \n                    if(minProjection < 0. || (cProjection > 0. && cProjection < minProjection))\n                    {\n                        intersection = (1. - 1. / (1. + sq(mod(abs(bestT - res[0]), 2. * PI-0.1)))) / (1. + pow(10.*(minProjection - cProjection), 6.));\n                        \n                        minProjection = cProjection;\n                        bestT = res[0];\n                    }\n                }\n            }\n            \n            //while(sign(learning_rate) * sign(dSqDistanceToRay_dt(t, ray)) > 0.)\n            //{\n            //\tt += minDelta;\n            //}\n            \n            t += 30. * minDelta;  // 30\n\n            learning_rate *= -1.;\n        }\n        \n        t += deltaT;\n    }\n    \n    return vec3(bestT, minProjection, intersection);\n}\n*/\n\nvec2 cis(float a)\n{\n    return vec2(cos(a), sin(a));\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y - 0.5*iResolution.xy/iResolution.y;\n    \n    \n   \tvec2 angles = PI * (vec2(2., 1.) * iMouse.xy / iResolution.xy - vec2(1., 0.5));  // vec2([-PI, PI], [-PI/2, PI/2])\n    \n    if(abs(iMouse.x) < 1.)\n    {\n        angles = vec2(0., 0.);\n    }\n    \n    \n    vec2 cisXY = cis(angles.x);\n    vec2 cisRZ = cis(angles.y);\n    \n    vec3 ro = vec3(cisRZ.x * cisXY, cisRZ.y);\n    \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    vec3 forward = -ro;\n    \n    ro *= 6.;\n    \n    \n    float zoom = 2.;\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + zoom * forward);\n    \n    Ray ray = Ray(ro, rd);\n    \n    \n    float r = 0.2;\n    \n    float minT = 0., maxT = 2.*PI;\n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 pureCol = vec3(0);\n    \n    \n    float bestT = 0.;\n    float minProjection = -1.;\n    \n    float t = minT + minDelta;\n    float learning_rate = 0.01 * sign(dSqDistanceToRay_dt(t, ray));  // 0.01\n    \n    float intersection = 0.;\n    \n    for(int i = 0; i < 1000 && t >= minT && t < maxT; i++)//while(t >= minT && t < maxT)\n    {   \n        vec3 c_o = c(t);\n        vec3 dc_dt = (c(t + h) - c_o) / h;//dC_dt(t, c_o);\n        c_o -= ray.ro;\n        \n        float deltaT = learning_rate * 2. * (dot(c_o, dc_dt) - dot(c_o, ray.rd) * dot(dc_dt, ray.rd));\n\n        if(abs(deltaT) < minDelta)\n        {\n            // Extreme\n            \n            if(learning_rate < 0.)\n            {\n                // Min\n                \n                float cProjection = dot(c_o, ray.rd);\n                \n                if(sq(c_o) - sq(cProjection) <= sq(r))\n                {\n                    // Intersection\n                    \n                    vec2 res = reverseRaymarching(t, cProjection, r, ray);\n                    cProjection = res[1];\n                    \n                    if(minProjection < 0. || (cProjection > 0. && cProjection < minProjection))\n                    {\n                        float closeAngle = 1. - 1. / (1. + sq(mod(abs(bestT - res[0]), 2. * PI - 0.1))); // 1. for far away and 0. for close.\n                        \n                        intersection = closeAngle / (1. + pow(10.*(minProjection - cProjection), 6.));\n                        \n                        \n                        minProjection = cProjection;\n                        bestT = res[0];\n                        \n                        \n                        float t = bestT;\n                        vec3 p = ray.ro + minProjection * ray.rd;\n\n\n                        vec3 normal = normalize(p - c(t));\n\n                        \n                        vec3 newPureCol = hue(t / (2.* PI)) * ((dot(normal, vec3(1, 0, 1)) + 1.)/2. + pow((dot(normal, normalize(vec3(1, 0, 1))) + 1.)/2., 30.));\n                        \n                        \n                        float alpha = closeAngle * 0.8 + (1. - closeAngle) * 1.;\n                        \n                    \tcol = alpha * newPureCol + (1. - alpha) * pureCol;\n                        \n                        pureCol = newPureCol;\n                    }\n                }\n            }\n            \n            //while(sign(learning_rate) * sign(dSqDistanceToRay_dt(t, ray)) > 0.)\n            //{\n            //\tt += minDelta;\n            //}\n            \n            t += 120. * minDelta;  // 30\n\n            learning_rate *= -1.;\n        }\n        \n        t += deltaT;\n    }\n    \n    \n    col = vec3(1, 1, 1) * intersection + (1. - intersection) * col;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 230, 247, 400, 555], [580, 591, 620, 620, 744], [786, 910, 955, 955, 1199], [1201, 3153, 3192, 3192, 3249], [3251, 3251, 3322, 3322, 3887], [3891, 5851, 5870, 5870, 5905], [5907, 5907, 5926, 5926, 5956], [5958, 5958, 6015, 6015, 9600]]}
{"id": "wtlBW8", "name": "asteroid v.1", "author": "okelly4408", "description": "variant of crater noise shader with different params used", "tags": ["craters"], "likes": 6, "viewed": 132, "published": "Public", "date": "1596621239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\nconst vec3 BOX = vec3(0.5);\nconst float eps = 0.0001;\nfloat hash(\n\tin float n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nfloat noise(\n\tin vec3 x\n){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm (in vec3 p)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float n = noise(p * freq) / freq;\n        f += n;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n\n\nvec4 gpuGetCell3D(const in int x, const in int y, const in int z)\n{\n\tfloat u = float(x + y * 31) / 256.0;\n\tfloat v = float(z - x * 3) / 256.0;\n\treturn(texture(iChannel1, vec2(u, v)));\n}\n\nvec2 gpuCellNoise3D(const in vec3 xyz)\n{\n\tint xi = int(floor(xyz.x));\n\tint yi = int(floor(xyz.y));\n\tint zi = int(floor(xyz.z));\n\n\tfloat xf = xyz.x - float(xi);\n\tfloat yf = xyz.y - float(yi);\n\tfloat zf = xyz.z - float(zi);\n\n\tfloat dist1 = 9999999.0;\n\tfloat dist2 = 9999999.0;\n\tvec3 cell;\n\n\tfor (int z = -1; z <= 1; z++)\n\t{\n\t\tfor (int y = -1; y <= 1; y++)\n\t\t{\n\t\t\tfor (int x = -1; x <= 1; x++)\n\t\t\t{\n\t\t\t\tcell = gpuGetCell3D(xi + x, yi + y, zi + z).xyz;\n\t\t\t\tcell.x += (float(x) - xf);\n\t\t\t\tcell.y += (float(y) - yf);\n\t\t\t\tcell.z += (float(z) - zf);\n\t\t\t\tfloat dist = dot(cell, cell);\n\t\t\t\tif (dist < dist1)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist1;\n\t\t\t\t\tdist1 = dist;\n\t\t\t\t}\n\t\t\t\telse if (dist < dist2)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec2(sqrt(dist1), sqrt(dist2));\n}\n\nfloat f2mf1(vec3 p){\nvec2 c = gpuCellNoise3D(p);\n\nreturn c.y - c.x;\n}\n\n\nfloat craterNoise3D(in vec3 p){\n\t\n    \n    float radius = 0.30;\n    float slope = .32;\n    float frequency = 1.0;\n    float depth = -0.22;\n    float rimWidth = 0.2;\n    \n\tfloat fractal = fbm(p * frequency * 2.0) * 0.17;\n\tfloat cell = gpuCellNoise3D((p * frequency) + fractal ).x;\n\tfloat r = radius + fractal;\n\tfloat crater = smoothstep(slope, r, cell);\n\t  \t  crater = mix(depth, crater, crater);\n\tfloat rim = 1.0 - smoothstep(r, r + rimWidth, cell);\n\t      crater = rim - (1.0 - crater);\nreturn crater * 0.175;\n}\n\n  \nfloat sdSphere(vec3 p, vec3 c, float r) {\n    \n    return length(p - c) - (r + fbm(p * 0.5) + (craterNoise3D(p / 2.0)));\n}\n\nfloat map(in vec3 p){\n    return sdSphere(p, vec3(0.0), 4.0);\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.0; \n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd;\n        float h = map(p);\n        if(abs(h)<MIN_DIST) break;\n        t+=h*0.75;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return t;\n}\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 li = normalize(vec3(0.5, .8, 3.0));\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0; // target distance\n    vec3 ro = vec3( 8.0 * sin(a + float(iTime * 0.25)), 7.0, 8.0* cos(a + float(iTime * 0.25))); // camera origin\n    vec3 ta = vec3(0,0,0); // target\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    float t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 normal = sNormal(pos);\n        col =mix(vec3(0.6, 0.4, 0.3), vec3(0.2), smoothstep(4.5, 5.5, length(pos))) + 0.25*pow(max(dot(li, normal)*1.2, 0.05), .75);\n    }\n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 145, 145, 182], [184, 184, 210, 210, 570], [571, 571, 594, 594, 774], [778, 778, 845, 845, 963], [965, 965, 1005, 1005, 1725], [1727, 1727, 1747, 1747, 1796], [1799, 1799, 1830, 1830, 2311], [2316, 2316, 2357, 2357, 2438], [2440, 2440, 2461, 2461, 2503], [2504, 2504, 2528, 2528, 2727], [2728, 2728, 2760, 2760, 3004], [3005, 3005, 3060, 3060, 3395], [3396, 3396, 3453, 3503, 4305]]}
{"id": "wtlBWB", "name": "Colorless Field", "author": "JacobC", "description": "Playing around with ray marching", "tags": ["3d", "raymarching", "sdf", "smoothdistance"], "likes": 7, "viewed": 123, "published": "Public", "date": "1597674643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T iTime * .5\n#define Pi 3.14159\n\n#define R 4.5\n\n#define sp0 vec3(0., sin(T), 0.) * R\n#define sp1 vec3(sin(T), cos(T), 0.) * R\n#define sp2 vec3(-sin(T), cos(T), 0.) * R\n\n#define sp3 vec3(0., -sin(T), 0.) * R\n#define sp4 vec3(0., sin(T), cos(T)) * R\n#define sp5 vec3(0., sin(T), -cos(T)) * R\n\n#define sp6 vec3(-sin(T), 0., 0.) * R\n#define sp7 vec3(cos(T), sin(T), cos(T)) * R\n#define sp8 vec3(-cos(T), sin(T), -cos(T)) * R\n\n#define sp9 vec3(sin(T), 0., 0.) * R\n#define sp10 vec3(sin(T), sin(T), sin(T)) * R\n#define sp11 vec3(-sin(T), sin(T), -sin(T)) * R\n\n#define gr vec4(0., -101., 0., 100.)\n\n#define sc2 vec3(1., .5, 0.)\n#define sc1 vec3(.5, 0., 1.)\n#define sc0 vec3(0., 1., .5)\n\n#define sc3 vec3(.5, 1., 0.)\n#define sc4 vec3(1., 0., .5)\n#define sc5 vec3(0., .5, 1.)\n\n#define sc6 vec3(1., 1., 0.)\n#define sc7 vec3(1., 0., 1.)\n#define sc8 vec3(0., 1., 1.)\n\n#define sc9 vec3(1., 0., 0.)\n#define sc10 vec3(0., 0., 1.)\n#define sc11 vec3(0., 1., 0.)\n\n#define grc vec3(1., 1., 1.)\n\n\n#define sky vec3(.5, .7, 1.)\n#define ground vec3(0.)\n\nstruct mat\n{\n    float depth;\n    vec3 color;\n    float ref;\n};\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat torus(in vec3 p, in vec2 r)\n{\n    vec3 c = vec3(0.);\n    c.xz = p.xz / length(p.xz) * r.x;\n    return length(p - c) - r.y;\n}\n\nmat softUop(mat a, mat b, float k, float l)\n{\n    float f = min(a.depth, b.depth);\n    float g = max(.5 - abs((a.depth - b.depth))* .5, 0.) * k;\n    float h = clamp((a.depth - b.depth) * .5 + .5, .0, 1.) * (1. - l);\n    return mat(\n        mix(f, f - g, g), \n        mix(a.color, b.color, h),\n        mix(a.ref, b.ref, h)\n    );\n}\n\nmat scene(in vec3 p)\n{\n    p = mod(p, 14.) - 7.;\n    float rs = 1.;\n    \n    mat s0 = mat(sphere(p - sp0, rs), sc0, 1.);\n    mat s1 = mat(sphere(p - sp1, rs), sc1, 1.);\n    mat s2 = mat(sphere(p - sp2, rs), sc2, 1.);\n    \n    mat s3 = mat(sphere(p - sp3, rs), sc3, 1.);\n    mat s4 = mat(sphere(p - sp4, rs), sc4, 1.);\n    mat s5 = mat(sphere(p - sp5, rs), sc5, 1.);\n    \n    mat s6 = mat(sphere(p - sp6, rs), sc6, 1.);\n    mat s7 = mat(sphere(p - sp7, rs), sc7, 1.);\n    mat s8 = mat(sphere(p - sp8, rs), sc8, 1.);\n    \n    mat s9 = mat(sphere(p - sp9, rs), sc9, 1.);\n    mat s10 = mat(sphere(p - sp10, rs), sc10, 1.);\n    mat s11 = mat(sphere(p - sp11, rs), sc11, 1.);\n    \n    float rt = max(sin(T)*2.5, 0.);\n    mat t0 = mat(torus(p, vec2(rt, .5)), vec3(1.), 0.);\n    mat t1 = mat(torus(p.xzy, vec2(rt, .5)), vec3(1.), 0.);\n    mat t2 = mat(torus(p.zxy, vec2(rt, .5)), vec3(1.), 0.);\n    \n    mat s = softUop(s0, softUop(s1, s2, 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s3, softUop(s4, s5, 1., 0.), 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s6, softUop(s7, s8, 1., 0.), 1., 0.), 1., 0.);\n    s = softUop(s, softUop(s9, softUop(s10, s11, 1., 0.), 1., 0.), 1., 0.);\n    \n    mat t = softUop(t0, softUop(t1, t2, 1., 0.), 1., .0);\n    s = softUop(s, t, 1., .0);    \n    \n    return s;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < 99; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth * .45;\n        if (s.depth < .025)\n            return mat(t, s.color, s.ref);\n        if (t > 30.)\n            return mat(t, vec3(-1.), -1.);\n    }\n    return mat(t, vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2. // Improve Detail(drawback: gets slow)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 f_col = vec3(0.);\n    vec2 st = fragCoord;\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = ((st + n) - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            float sn = sin(ms.x * Pi);\n\n            vec3 o = vec3(sn, ms.y * 6., T * 3.);\n            vec3 t = vec3(0., 0., 1. + T * 3.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(ground, sky, d.y * .5 + .5);\n            vec3 col = back;\n\n            mat m = marcher(o, d);\n            if(m.ref > -1.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p) * .5 + .5;\n                vec3 ambient = mix(ground, sky, n.y * .5 + .5);\n                col = mix(m.color * ambient, back, clamp(m.depth / 30., 0., 1.));\n            }\n            f_col += col;\n        }\n    }\n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1104, 1104, 1138, 1138, 1166], [1168, 1168, 1203, 1203, 1298], [1300, 1300, 1345, 1345, 1630], [1632, 1632, 1654, 1654, 2924], [2926, 2926, 2950, 2950, 3130], [3132, 3132, 3167, 3167, 3464], [3466, 3466, 3512, 3512, 3657], [3713, 3713, 3770, 3770, 4811]]}
{"id": "wtlBWM", "name": "vessel", "author": "slackmage", "description": "vessel", "tags": ["vessel"], "likes": 1, "viewed": 214, "published": "Public API", "date": "1596912597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nfloat hash1( vec2 p )\n{\n    return fract(sin(p.x+131.1*p.y)*1751.5453);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// ripped from Kali's Lonely Tree shader\nmat3 rotationMat(vec3 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n                (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n                (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z);\n}\n\nvec3 axis = normalize( vec3(-0.3,-1.,-0.4) );\n\nvec2 map( vec3 p )\n{\n    // animation\n    float atime = iTime+2.0;\n    vec2 o = floor( 0.5 + p.xz/50.0  );\n    float o1 = hash( o.x*57.0 + 12.1234*o.y );\n    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );\n    p.y -= 2.0*(atime + f*f);\n    p = mod( (p+25.0)/50.0, 1.0 )*40.0-25.0;\n    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;\n    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );\n    // modeling\n\tfor( int i=0; i<18; i++ )\n\t{\n        p = roma*abs(p);\n        p.y-=7.0;\n    }\n\tfloat d = length(p*vec3(1.0,0.1,1.0))-0.75;\n    float h = 0.5 + p.z;\n    return vec2( d, h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 40.0;\n    float precis = 0.001;\n    float t = 0.0;\n    float d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec2 res = map( ro+rd*t );\n        if( res.x<precis||t>maxd ) break;\n        t += 0.6*min( res.x, 5.0 );\n        d = res.y;\n    }\n    if( t>maxd ) m=-5.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.2,0.0,0.0);\n    return normalize( vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float totao = 0.0;\n    for( int aoi=0; aoi<6; aoi++ )\n    {\n        vec3 aopos = -0.0+2.0*hash3(float(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + aopos*5.5;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n    totao /= 16.0;\n    return clamp( totao*totao*1.5, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(-0.5,0.7,-1.0));\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fc )\n{\n    // render\n    vec3 bgc = 0.6*vec3(0.8,0.9,0.0)*(-0.5 + 0.3*rd.y);\n    vec3 col = bgc;\n    // raymarch\n    vec3 tmat = intersect(ro,rd);\n    float dis = tmat.x;\n    if( tmat.z>-0.9 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        // material\n        vec3 mate = -0.5 + 0.5*mix( sin( vec3(0.2,1.5,1.0)*tmat.y*.9 ),\n                                  sin( vec3(10.1,1.1,5.0)*tmat.y*6.0 ),\n                                  30.0-abs(2.0*nor.y) );\n        // lighting\n        float occ = calcAO( pos, nor );\n        float amb = -3.1 + 0.2*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n        float sha = 1.0; if( dif>0.001 ) sha=softshadow( pos+0.001*nor, lig, 0.1, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 0.0 ), 0.0 );\n        // lights\n        vec3 brdf = vec3(5.7);\n        brdf += 1.0*dif*vec3(1.00,0.90,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        brdf += 1.0*amb*vec3(0.05,0.05,0.05)*occ;\n        brdf += 1.0*bac*vec3(0.03,0.03,0.03)*occ;\n        brdf += 1.0*fre*vec3(1.00,0.70,0.40)*occ*(0.2+0.8*sha);\n        brdf += 1.0*occ*vec3(1.00,0.70,0.30)*occ*max(dot(-nor,lig),0.0)*pow(clamp(dot(rd,lig),0.0,1.0),64.0)*tmat.y*2.0;\n        // surface-light interacion\n        col = mate * brdf;\n        // fogt\n        col = mix( col, bgc, clamp(1.0-1.2*exp(-0.0002*tmat.x*tmat.x ),0.0,1.0) );\n    }\n    else\n    {\n        // sun\n        vec3 sun = vec3(0.0,0.8,0.5)*pow( clamp(dot(rd,lig),0.0,1.0), 1.0 );\n        col += sun;\n        dis = 100.0;\n    }\n    \n    // god rays\n    #if 0\n    float gr = 0.0;\n    float t = 0.1 * hash1(fc);\n    for( int i=0; i<12; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float dt = clamp(0.3*t2.0,20.0);\n        gr += dt*softshadow( pos, lig, 0.01, 128.0 );\n        t  += dt;\n        if( t>dis ) break;\n    }\n    col += vec3(0.0,0.9,0.7)*pow(gr*0.004,2.0) - 0.02;\n    #endif\n    \n    // sun scatter\n    col += 10.6*vec3(0.2,0.14,0.1)*pow( clamp(dot(rd,lig),0.0,1.0), 5.0 );\n    // postprocessing\n    // gamma\n    col = pow( col, vec3(1.45) );\n    // contrast/brightness\n    col = .6*col-0.1;\n    // tint\n    col *= vec3( 0.40, .04, .0);\n\n     return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    // camera\n    float an = 4.5 + 0.8*iTime - 6.2*m.x;\n    float cr = 0.3*cos(0.2*iTime);\n    vec3 ro = vec3(15.0*sin(an),12.0-24.0*m.y,15.0*cos(an));\n    vec3 ta = vec3( 0.0, 2.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(27.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.9*ww );\n    vec3 col = render( ro, rd, fragCoord );\n    // vigneting\n    col *= pow( .1*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4( col, .1 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, fragCoord );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBWM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 125, 148, 148, 186], [188, 188, 211, 211, 261], [263, 263, 286, 286, 380], [382, 423, 462, 462, 844], [893, 893, 913, 930, 1500], [1502, 1502, 1544, 1544, 1886], [1888, 1888, 1920, 1920, 2135], [2137, 2137, 2202, 2202, 2456], [2458, 2458, 2500, 2500, 2847], [2893, 2893, 2944, 2958, 5200], [5202, 5202, 5259, 5259, 6066], [6068, 6068, 6162, 6162, 6318]]}
{"id": "WtlBWN", "name": "Voronoi displacement sphere", "author": "ptemoche", "description": "displacement distance created with a voronoi.", "tags": ["raymarching", "voronoi", "displacement"], "likes": 5, "viewed": 94, "published": "Public", "date": "1596757268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//RayMarching practice \n//from https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define PI 3.14159265\n#define VSD 10.0\n\nfloat random21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nvec2 random22(vec2 st){\n \treturn vec2(random21(st),fract(random21(st.yx*1793.45786)*9848.588456));   \n}\n\n\n\nvec4 voronoi(vec2 st, float n){\n \n    float c = 0.0;\n    st*=n;\n    vec2 id = floor(st);\n    vec2 uv = fract(st);\n    vec2 color = vec2(0,0);\n    c = 1.0;\n    for(float i = -1.0; i<=1.0; i+=1.0){\n        for(float j = -1.0; j<=1.0; j+=1.0){\n         \tvec2 offset = vec2(i,j);\n            vec2 idNew = ((id+offset)+n);\n            idNew = mod(idNew,n);\n            vec2 pos = (sin(random22(idNew)*iTime)*0.5+0.5)+offset;\n            if(length(pos-uv)<c){\n                c=length(pos-uv);\n                color = random22(idNew);\n            }\n            \n        }\n    }\n    color=color*0.5+0.5;\n   \n    //return smoothstep(0.02,0.01,length(((random22(id))-uv)));\n    return vec4(color.x,color.y,random21(color)*0.5+0.5,clamp((1.0-c),0.0,sin(iTime*0.5)*0.5+0.5)*0.1);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 GetDist(vec3 p) {\n    \n    p+=vec3(0,0,-6);\n   \tp.xz*=Rot(iTime*0.1);\n\tvec4 sphere = vec4(0, 0, 0, 2);\n    \n    float sphereDist =  length(p-sphere.xyz)-sphere.w;\n    vec3 s_dir = p-sphere.xyz;\n    float cosT = acos(dot(normalize(vec3(s_dir.x,0.0,s_dir.z)),vec3(1,0,0)));\n    if(s_dir.z>0.0)\n        cosT=2.0*PI-cosT;\n    \n    float s = cosT/(2.0*PI);\n    float t = acos(dot(normalize(vec3(0.0,s_dir.y,1.0)),vec3(0,-1,0)))/PI;\n    //float planeDist = p.y-voronoi(p.xz*0.3,2.0);\n    vec4 voronoiVec = voronoi(vec2(s,t),VSD);\n    //voronoiVec.w = 0.0;/////////////////////////////////////////////////////////////////////////\n    voronoiVec.w = sphereDist-voronoiVec.w;\n    //voronoiVec.xyz = vec3(t);\n    //float d = min(sphereDist, planeDist);\n    return voronoiVec;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec4 distVec = vec4(0);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        distVec= GetDist(p);\n        float dS = distVec.w;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    distVec.w = dO;\n    return distVec;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).w;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 1);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float occ = (n.y+0.5+0.5)*0.75;\n    float dif = 0.1;//clamp(dot(n, vec3(0,-1,0)), 0., 1.)*0.15;\n    \n    dif += (clamp(dot(n, l), 0., 1.))*0.5;\n    \n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    if(d<length(lightPos-p)) dif *= 0.75;\n    //dif = 0.5;//////////////////////////////////////////////\n    return dif*occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec4 marching = RayMarch(ro, rd);\n    float d = marching.w;\n    \n    vec3 p = ro + rd * d;\n    float back = smoothstep(0.0,1.0,uv.y+0.5)*0.2;\n    col=vec3(back);\n    if(d<500.0){\n        float dif = GetLight(p);\n        col = marching.xyz*dif;\n    }\n    //float dif = (d>500.0)? back:GetLight(p);\n    //dif=1.0;\n    //marching.xyz=vec3(1);//////////////////////////////////////////\n    \n    \n    col = pow(col, vec3(.4545));\t\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 184, 208, 208, 287], [289, 289, 312, 312, 392], [396, 396, 427, 427, 1166], [1169, 1169, 1188, 1188, 1264], [1266, 1266, 1288, 1288, 2038], [2040, 2040, 2073, 2073, 2350], [2352, 2352, 2376, 2376, 2573], [2575, 2575, 2599, 2599, 3076], [3078, 3078, 3135, 3185, 3815]]}
{"id": "wtlBz7", "name": "v4-51154.9", "author": "jorge2017a1", "description": "v4-51154.9 ---Autor desconocido\nUsar el Mouse", "tags": ["v4511549"], "likes": 4, "viewed": 43, "published": "Public", "date": "1596395584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia\n//51154.9 ---Autor desconocido\n\n#define PI \t\t3.1415926535897932384626\n#define ZERO \t\tvec3(0.0)\n#define X\t\tvec3(1.0,0.0,0.0)\n#define Y\t\tvec3(0.0,1.0,0.0)\n#define Z\t\tvec3(0.0,0.0,1.0)\n#define R\t\t2.0\n#define T\t\t4\n\n#define EPSILON\t\t0.001\n#define MAX_DIST\t80.0\n#define MAX_ITER\t100\n\n#define MAX_LIGHT\t2\n#define BALL_ROW\t1.0\n#define BALL_COL\t2.0\n#define RADIUS\t\t2.0\n\n#define ALBEDO  \tvec3(0.75)\n#define METALLIC \t0.99\n#define ROUGHNESS \t1.0\n#define F0\t\tmix(vec3(0.04),albedo,metallic)\n#define AO\t\t1.0\n\n\n\n\n\n//-----------------------------\n\nfloat rand(vec3 seed){\n\treturn fract(sin(dot(seed, vec3(12.9898,78.233,233.33))) * 43758.5453);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(vec3(seed,0.0));\n}\n\nfloat rand(float seed)\n{\n\treturn rand(vec3(seed,0.0,0.0));\n}\n\nfloat noise3(vec3 pos)\n{\n\tfloat t = -iTime*0.0;\n\tvec3 base = floor(pos*R+t);\n\tvec3 pot = fract(pos*R+t);\n\tvec3 f = smoothstep(0.0,1.0,pot);\n\tfloat w1 = mix(rand(base),    rand(base+X),    f.x);\n\tfloat w2 = mix(rand(base+Z),  rand(base+X+Z),  f.x);\n\tfloat w3 = mix(rand(base+Y),  rand(base+X+Y),  f.x);\n\tfloat w4 = mix(rand(base+Y+Z),rand(base+X+Y+Z),f.x);\n\treturn mix(\n\t\tmix(w1,w3,f.y),\n\t\tmix(w2,w4,f.y),\n\t\tf.z\n\t);\n}\n\n\nfloat fbm3(vec3 pos)\n{\n\tfloat total = 0.0, amp = 1.0;\n\tfor (int i = 0; i < T; i++){\n\t\ttotal += noise3(pos) * amp; \n\t\tpos *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn 1.0-exp(-total*total);\n}\n//\nvec3 fresnelSchlick(vec3 albedo,float cosTheta,float metallic)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n//\nfloat plane(vec3 pos,vec3 normal,float h)\n{\n\treturn dot(pos,normalize(normal))-h;\n}\n\nfloat box(vec3 pos,vec3 center,vec3 size)\n{\n  \tvec3 d = abs(pos-center) - size;\n \treturn length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec3 t){\n  vec2 q = vec2(length(p.xz)-t.x, p.y+t.z);\n  return length(q)-t.y;\n}\n\nfloat cylinder( vec3 p, vec2 h)\n{\n   \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat solidSphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = distance(pos,center)-radius;\n\treturn d;\n}\n\nfloat sphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = solidSphere(pos,center,radius);\n\treturn d;\n}\n\nvec2 dmin(vec2 a,vec2 b)\n{\n\tif(a.x == min(a.x,b.x))\n\t\treturn a;\n\telse \n\t\treturn b;\n}\n\n\n//---------------------------------------------------------\n\n// return (distance, id)\n\nvec2 dist(vec3 pos)\n{\n\tfloat id = 0.0;\n\tfloat d = MAX_DIST;\n    \n\tfloat obj = id;\n\t\n    for(float i = -BALL_ROW+1.0; i <= BALL_ROW-1.0; i+=2.0){\n\t\tfor(float j = -BALL_COL+1.0; j <= BALL_COL-1.0; j+=2.0){\t\n\t\t\tfloat _d = sphere(pos,1.25*(j*X-i*Z-Z)*RADIUS,RADIUS);\n\t\t\td = min(d,_d);\n\t\t\tif(d == _d){\n\t\t\t\tobj = id;\n\t\t\t}\n\t\t\tid++;\n\t\t}\n\t}\n\n\tfloat s_id = BALL_ROW*BALL_COL;\n\tvec2 dp = vec2(plane(pos,Y,-RADIUS),-1.);\n\tvec2 db = vec2(box(pos-7.0*Z-5.0*X,ZERO,vec3(RADIUS)),s_id);\n\tvec2 dc = vec2(cylinder(pos+5.*X-5.*Z,vec2(1.0,5.0)),s_id+1.0);\n\tvec2 dt = vec2(torus(pos+5.*X-5.*Z,vec3(2.0,0.5,1.5)),s_id+2.0);\n\tvec2 p = vec2(d,obj);\n\tp = dmin(p,dp);\n\tp = dmin(p,db);\n\tp = dmin(p,dc);\n\tp = dmin(p,dt);\n\n\treturn p;\n}\n\nvec3 setCamera(vec2 uv,vec3 pos,vec3 lookat,vec3 up)\n{\n\tvec3 camDir = normalize(lookat-pos);\n\tvec3 camUp = normalize(up);\n\tvec3 camRight = cross(camDir,camUp);\n\treturn normalize(uv.x*camRight+uv.y*camUp+5.0*camDir);\n}\n\nvec3 rayMarching(vec3 ro,vec3 rd,float mint)\n{\n\tvec2 d = vec2(mint);\n\tfloat h = d.x;\n\tfor(int i = 0; i<MAX_ITER; i++){\n\t\td = dist(ro+rd*h);\n\t\tif(d.x < EPSILON){ \n\t\t\tbreak;\n\t\t}\n\t\tif(h > MAX_DIST){\n\t\t\treturn vec3(MAX_DIST);\n\t\t}\n\t\th += d.x;\n\t}\n\treturn vec3(h,d);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t return normalize(vec3(\n        \tdist(pos+X*EPSILON).x - dist(pos - X*EPSILON).x,\n        \tdist(pos+Y*EPSILON).x - dist(pos - Y*EPSILON).x,\n        \tdist(pos+Z*EPSILON).x - dist(pos - Z*EPSILON).x\n    \t));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float k)\n{\n    float res = 1.0;\n    float h = mint;\n    for(int t = 0; t < MAX_ITER; t++){\n        float d = dist(ro+rd*h).x;\n        if( d < EPSILON)\n            return 0.0;\n\tif(h > MAX_DIST)\n\t\tbreak;\n        res = min(res, k*d/h);\n        h += d;\n    }\n    return res;\n}\n\nfloat calcShadow(vec3 pos,vec3 dir)\n{\n\tfloat esp = 100.0*EPSILON;\n\tfloat d = rayMarching(pos,dir,esp).y;\n\treturn step(esp,d);\n}\n\n\n\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\t\n   \n    float t=mod(iTime, 300.0);\n    vec3 ro=vec3(0.0+10.0*cos(t),10.0,-30.0+10.0*sin(t));\n    \n    ro= getMouse(ro);\n    \n   \n\tvec3 rd = setCamera(uv,ro,ZERO,Y);\n\tvec3 h = rayMarching(ro,rd,EPSILON);\n\tvec3 color = ZERO;\n\t\n    \n    if(h.x < MAX_DIST)\n    {\n\t\tfor(int i = 0; i< MAX_LIGHT;i++){\n\t\tvec3 Lo = ZERO;\n\t\tfloat t = 0.2 * iTime;\n\t\tvec3 light = 18.0*vec3(sin(t*float(i)),0.3,cos(float(i)*t));\n\t\tvec3 pos = ro+rd*h.x;\n\t\t\n\t\tfloat row = floor(h.y / BALL_COL);\n\t\tfloat col = h.y - row * BALL_COL;\n\t\tfloat k = smoothstep(0.4,0.7,fbm3(pos));\n\t\tfloat id = step(0.0,h.z);\n\t\tvec3 albedo = mix(vec3(1.0),mix(ALBEDO,vec3(0.69,0.05,0.0),1.0-k),id);\n\t\tfloat roughness = ROUGHNESS*(1.0-k)*id+0.2;\n\t\tfloat metallic = METALLIC*(k)*id+0.2;\n\t\t\n\t\tvec3 N = calcNormal(pos);\n\t\tvec3 L = normalize(light-pos);\n\t\tvec3 V = normalize(ro-pos);\n\t\tvec3 H = normalize(V+L);\n\t\t\n\t\tvec3 F  = fresnelSchlick(albedo,max(dot(H, V), 0.0),metallic);\n\t\tfloat NDF = DistributionGGX(N, H, roughness);       \n\t\tfloat G   = GeometrySmith(N, V, L, roughness);\n\t\t\n\t\tfloat dis = 1.0;//length(light-pos);\n        \tfloat attenuation = 1.0 / (dis * dis);\n        \tvec3 radiance     = vec3(1.0,1.0,1.0) * attenuation;\n\n\t\tvec3 nominator  = NDF * G * F;\n\t\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n\t\tvec3 specular     = nominator / denominator;\n\t\tvec3 kS = F;\n\t\tvec3 kD = vec3(1.0) - kS;\n\t\tkD *= 1.0 - metallic; \n\t\tfloat NdotL = max(dot(N, L), 0.0);        \n   \t\tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\t\tvec3 ambient = vec3(0.03) * albedo * AO ;\n\t\tcolor += ambient + Lo * softShadow(pos,L,0.1,16.0);  \n\t\t}\n\t\tcolor = color / (color + vec3(1.0));\n\t\tcolor = pow(color, vec3(1.0/2.19)); \n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 546, 568, 568, 643], [645, 645, 668, 668, 700], [702, 702, 726, 726, 762], [764, 764, 788, 788, 1180], [1183, 1183, 1205, 1205, 1361], [1362, 1365, 1429, 1429, 1486], [1488, 1488, 1544, 1544, 1807], [1809, 1809, 1865, 1865, 2017], [2019, 2019, 2081, 2081, 2297], [2298, 2301, 2344, 2344, 2384], [2386, 2386, 2429, 2429, 2496], [2498, 2498, 2527, 2527, 2597], [2599, 2599, 2632, 2632, 2734], [2736, 2736, 2792, 2792, 2845], [2847, 2847, 2898, 2898, 2954], [2956, 2956, 2982, 2982, 3040], [3104, 3130, 3151, 3151, 3836], [3838, 3838, 3892, 3892, 4055], [4057, 4057, 4103, 4103, 4318], [4320, 4320, 4347, 4347, 4556], [4558, 4558, 4615, 4615, 4877], [4879, 4879, 4916, 4916, 5006], [5012, 5083, 5119, 5119, 5325], [5328, 5399, 5423, 5423, 5683], [5689, 5689, 5746, 5746, 7547]]}
{"id": "WtlfRl", "name": "Raymarched Sphere", "author": "IAmLegend", "description": "Raymarched Sphere with phong shading", "tags": ["sphereraymarch"], "likes": 1, "viewed": 145, "published": "Public", "date": "1597465907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Map values to unsquish resolution\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// Simple sphere stuff\nvec3 sphereNormal (vec3 pos, vec3 center){\n    return normalize(pos - center); \n}\nfloat sphereDE (vec3 pos, vec3 center, float radius){ \n    return length(pos - center) - radius; \n}\n\nvec3 raymarch(vec3 origin, vec3 direction, vec3 center, vec3 light){\n    float distance = 0.0;\n    for (float iters = 0.0; iters < 200.0; ++iters){\n        vec3 pos = origin + distance * direction;\n        float nextDistance = sphereDE(pos, center, 0.3);\n        distance += nextDistance;\n        if (nextDistance < 0.001){ \n            // Calculate shading phong model\n            vec3 normal = sphereNormal(pos, center);\n            // Diffuse lighting\n            float diffuse = max(0.0, dot(normal, light)); \n            // Specular lighting\n            vec3 reflected = reflect(direction, normal);\n            float specular = pow(max(dot(reflected, light), 0.0), 32.0); \n            // Multiply by ambient (maybe time varying interpolated color :o)\n            float shade = diffuse * 0.7 + specular * 0.3; \n            vec3 ambient = vec3(1.0, 1.0, 1.0);\n            return shade * ambient;\n        }\n    }\n    // Background blue\n    return vec3(0.0, 0.0, 0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Clip space coords\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x = map(uv.x,  - 288.0/512.0, 288.0/512.0, -1.0, 1.0);\n\tvec3 center = vec3(0.0);\n    float time = iTime;\n    // Light going in this direction\n\tvec3 light = normalize(vec3(2.0* sin(time), cos(time), cos(time))); \n    // Output to screen\n    fragColor = vec4(raymarch(vec3(0.0, 0.0, -1.0), normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0)), center, light), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 109, 109, 177], [178, 201, 243, 243, 282], [283, 283, 336, 336, 382], [384, 384, 452, 452, 1355], [1356, 1356, 1413, 1438, 1863]]}
{"id": "wtsBD7", "name": "jagged uv step", "author": "3SvBop3F", "description": "none", "tags": ["jagged", "stair"], "likes": 1, "viewed": 152, "published": "Public API", "date": "1596940151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // regular uv\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    // square, centered uv\n    float max_res_dim = max(iResolution.x, iResolution.y);\n    vec2 uvsq_offset = (1.-(iResolution.xy/max_res_dim))/2.;\n\n    vec2 uvsq = (        // special case screen-is-uv-but-square-uv-space\n        gl_FragCoord.xy  // width/height\n        / max_res_dim    // of max width/height\n    ) + uvsq_offset;     // plus half the w/h margin\n\t\t\t\t\t     // is centered\n    \n    //uv = uvsq;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = mix(\n        vec4(col, 1.),\n        vec4(vec3(1.) - (col*0.5), 1.),\n               \n        float(\n            (uv.y)*10.>(round((-uv.x+1.-0.06)*10.) + 0.5)\n       )\n               \n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 79, 861]]}
{"id": "wtsBDr", "name": "Hue Expansion", "author": "JackKalish", "description": "Exercise from Book of Shaders by Patricio Gonzalez Vivo\nChapter 6 - Colors: https://thebookofshaders.com/06/\n\n\"Use a shaping function together with the conversion function from HSB to RGB to expand a particular hue value and shrink the rest.\"", "tags": ["color", "rgb", "wheel", "hue", "hsb"], "likes": 0, "viewed": 88, "published": "Public", "date": "1596775379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SPEED -.1\n\nvec3 rgb2hsb( in vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c, in float hueOffset){\n    vec3 rgb = clamp(abs(mod((c.x+hueOffset)*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//  Function from Iñigo Quiles\n//  www.iquilezles.org/www/articles/functions/functions.htm\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st.x -= .4;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x)-iTime*SPEED*TWO_PI;\n     //   float angle = atan(toCenter.y*(sin(iTime+PI)+2.),toCenter.x*(sin(iTime)+2.));\n   // angle = smoothstep(-PI,PI,angle);\n    \n    float radius = length(toCenter)*2.0;\n    \n    //angle = cubicPulse(1.,0.984,angle);\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    float hue = fract((angle/TWO_PI)+0.5);\n        \n    //apply shaping function to hue\n    hue = mix(smoothstep(0.,1.,hue),hue, .2);\n    \n    color = hsb2rgb(vec3(hue,radius,1.0), iTime*SPEED);\n\n    fragColor = vec4(color,1.0);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 99, 99, 529], [531, 605, 650, 650, 894], [896, 988, 1034, 1034, 1128], [1130, 1130, 1185, 1185, 2018]]}
{"id": "wtsBDX", "name": "Cube experiments z", "author": "illus0r", "description": "Cube experiments z", "tags": ["raymarching"], "likes": 3, "viewed": 169, "published": "Public API", "date": "1597956527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n    \n    //p.x += -0.8;\n    p.xz *= Rot(iTime * 2.);\n    float scale = 0.4 + 0.1 * sin(iTime);\n\tvec2 box = vec2(1e10, 1.);\n    \n    for (float i = 0.; i < 5.; i++) {\n        vec2 box2 = vec2( sdBox(p, vec3(1)) * pow(scale, i), 0.5 + i / 5. );\n        box = box.x < box2.x ? box : box2;\n        p = abs(p);\n        p -= 1.;\n\t    p.xz *= Rot(iTime);\n        p /= scale;\n    }\n    \n    return box;\n}\n\n\n\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float distToClosestLight = 9999999.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec2(d, info);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // ray origin\n    vec3 ro = vec3(0, 0., -5.5);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = normalize(vec3(uv, zoom));\n    \n    vec2 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 color = vec3(0.);\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(ro + rd * d);\n        n.zy *= Rot(iTime);\n    \tcolor = vec3( n + 1.0 );\n        color *= info;\n        //color_bw += 0.5 + dot(n, normalize(vec3(1,1,0))) / 2.;\n    }\n    //color = vec3( color_bw );\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 173], [175, 175, 213, 213, 242], [243, 243, 274, 274, 357], [362, 362, 408, 408, 515], [518, 598, 620, 644, 1017], [1022, 1106, 1139, 1139, 1512], [1514, 1514, 1538, 1538, 1756], [1758, 1758, 1815, 1815, 2483]]}
{"id": "WtsBRS", "name": "Distortion Boze", "author": "kaiware007", "description": "Distortion camera position", "tags": ["raymarching", "noise"], "likes": 1, "viewed": 52, "published": "Public", "date": "1597030885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 20.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-4;\nconst float EPS_N = 1e-5;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.1, 0.3, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result;\n    \n    vec3 b = p;\n    b = rotate(b, M_PI, vec3(0,5,0));\n    //float scb = saturate(sin(b.z *200. + iTime*50.)) * 0.025;\n    \n    b = opRep(b, vec3(1));\n    \n    result = sdBoze(b - vec3(0, 0.0, 0), vec3(1, 1, 1), 1.);\n    \n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    return vec3(0,0,0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 50.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    \n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n    \n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\t*/\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        \n    }\n    */\n    if(d <= EPS){\n        \n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    if (!mat.isHit && mat.albedo.a < EPS) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n    \n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n    \n    //float t = iTime * M_PI2 * -0.1;\n    //float t = iTime * -1.0;\n    //float t = 0.;\n\t//float y = sin(t * 2.5) * 0.125-0.0;\n    //float y = sin(t * 2.) * 0.25 + 0.5;\n    float y = 0.06;\n    //float r = 2.0 + sin(t * 0.5);\n    float r = 0.65;\n    //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n    float distortionPower = sin(iTime * 0.05 * M_PI2);\n    //float theta = t + RAD90 + RAD90*0.25;\n    //float theta = RAD90 + RAD90*0.25;\n\t//float theta = t + RAD90;\n    float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float theta = RAD90;\n    float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    //float phi   = 0.;\n    //vec3 ro = vec3( 0., 0.05, -0.75 );\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n    vec3 ta = vec3(0., y, 0);\n    //vec3 ta = vec3(0. + t, -0.5, 0.);\n    \n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, ray, fragCoord.xy);\n    \n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(col,1.0);\n}\n\n// test\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float y = 0.06;\n    float r = 0.65;\n    float distortionPower = sin(iTime * 0.05 * M_PI2);\n    float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r) + fragRayOri;\n    //vec3 ta = vec3(0., y, 0) + fragRayOri;\n    \n    //mat3 c = camera(ro, ta, 0.0);\n    //vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = render(ro, fragRayDir, fragCoord.xy);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1136, 1631, 1668, 1733, 1951], [2427, 2427, 2450, 2450, 2523], [3024, 3100, 3122, 3122, 3453], [3456, 3644, 3666, 3666, 3783], [3785, 3804, 3827, 3827, 3930], [3932, 3952, 3973, 3973, 4107], [4109, 4128, 4150, 4150, 4283], [4285, 4305, 4327, 4327, 4452], [4454, 4454, 4475, 4475, 4545], [4547, 4547, 4570, 4570, 4649], [4652, 4652, 4674, 4674, 5091], [5202, 5202, 5223, 5223, 5364], [5366, 5366, 5396, 5396, 5526], [5528, 5528, 5589, 5589, 5727], [5729, 5729, 5755, 5755, 6064], [6066, 6126, 6152, 6152, 7018], [7020, 7120, 7156, 7156, 7184], [7186, 7186, 7232, 7232, 7288], [7290, 7290, 7321, 7321, 7412], [7414, 7414, 7464, 7464, 7582], [7584, 7584, 7645, 7645, 7776], [7778, 7778, 7815, 7815, 7904], [7906, 7906, 7976, 7976, 8110], [8112, 8112, 8176, 8176, 8293], [8295, 8295, 8328, 8354, 8385], [8387, 8387, 8412, 8412, 8431], [8432, 8432, 8457, 8457, 8476], [8477, 8477, 8513, 8513, 8541], [8543, 8543, 8602, 8602, 8915], [8917, 8917, 8950, 8950, 9015], [9017, 9041, 9093, 9093, 9212], [9214, 9324, 9356, 9356, 9450], [9452, 9452, 9486, 9486, 9637], [9639, 9639, 9673, 9673, 9821], [9823, 9823, 9857, 9857, 9992], [9994, 9994, 10022, 10022, 10107], [10108, 10166, 10237, 10237, 10565], [10567, 10652, 10696, 10696, 10920], [10922, 10979, 11016, 11057, 11140], [11142, 11142, 11181, 11353, 11462], [11464, 11464, 11513, 11513, 12072], [12074, 12074, 12113, 12159, 12244], [12246, 12246, 12287, 12397, 12511], [12526, 12577, 12614, 12614, 12636], [12638, 12638, 12681, 12681, 12703], [12705, 12705, 12749, 12749, 12770], [12772, 12772, 12824, 12824, 12923], [12926, 12926, 12971, 12971, 13400], [13402, 13402, 13423, 13423, 13487], [13489, 13489, 13529, 13529, 13654], [13657, 13657, 13692, 13692, 13840], [13842, 13842, 13876, 13876, 14052], [14054, 14054, 14089, 14089, 14124], [14126, 14126, 14163, 14163, 14198], [14200, 14371, 14456, 14456, 14533], [14535, 14578, 14653, 14653, 15072], [15074, 15652, 15736, 15736, 16079], [16081, 16087, 16139, 16139, 16295], [16297, 16297, 16357, 16357, 16398], [16400, 16615, 16646, 16646, 16695], [16697, 16697, 16724, 16724, 16762], [16764, 16764, 16793, 16793, 16831], [16833, 16833, 16860, 16860, 16909], [16912, 17141, 17162, 17162, 17301], [17327, 17327, 17359, 17359, 17472], [17474, 17474, 17506, 17506, 17646], [17648, 17648, 17681, 17681, 17913], [17915, 17915, 17938, 17938, 18517], [18519, 18519, 18544, 18544, 18705], [18707, 18707, 18750, 18750, 19772], [19774, 19774, 19840, 19840, 19962], [19964, 19964, 20009, 20009, 20180], [20182, 20182, 20250, 20250, 20468], [20470, 20688, 20709, 20709, 20973], [21493, 21493, 21542, 21542, 21840], [22107, 22175, 22203, 22203, 22330], [22332, 22422, 22485, 22485, 22691], [22693, 22759, 22823, 22993, 23624], [23626, 23626, 23663, 23663, 23753], [23755, 23755, 23781, 23781, 25612], [25617, 25788, 25809, 25809, 25857], [25859, 25859, 25920, 26005, 26204], [26206, 26206, 26279, 26371, 26571], [26573, 26573, 26615, 26695, 26749], [26751, 26751, 26800, 26800, 26848], [26850, 26850, 26923, 26980, 27195], [27197, 27197, 27217, 27217, 27242], [27245, 27429, 27479, 27563, 27921], [27923, 27923, 27978, 28035, 28295], [28297, 28297, 28393, 28393, 29788], [29790, 29992, 30025, 30081, 30267], [30269, 30269, 30308, 30308, 30351], [30353, 30369, 30442, 30442, 30526], [30528, 30654, 30724, 30724, 31007], [31009, 31009, 31109, 31109, 31902], [31904, 31904, 31929, 31929, 32398], [32465, 32465, 32491, 32491, 32855], [32857, 32857, 32906, 32906, 34371], [34373, 34373, 34452, 34452, 36774], [36776, 36776, 36816, 36816, 38950], [38952, 38952, 38991, 39033, 39529], [39531, 39531, 39573, 39573, 39751], [39754, 39754, 39811, 39811, 41326], [41328, 41336, 41430, 41430, 42103]]}
{"id": "wtSBWh", "name": "Smooth kaleidoscope", "author": "mrange", "description": "License CC0: Smooth kaleidoscope\nKaleidoscope with smoothing\nI thought this might be useful to someone else so I shared this ugly barebones shared\n", "tags": ["kaleidoscope", "sabs"], "likes": 2, "viewed": 233, "published": "Public API", "date": "1598782361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Smooth kaleidoscope\n// Kaleidoscope effects are cool but while the mirror effect ensure the curves are\n//  continuous the derivates are not. \n//  SABS has been a great tool whenever I needed an abs function that gave the illusion\n//   continuous derivates.\n//  I patched SABS into a kaleidoscope effect to get a smooth kaleidoscopic effect.\n\n// I thought this might be useful to someone else so I shared this ugly barebones shared\n\n#define TIME       iTime\n#define RESOLUTION iResolution\n\n#define PI         3.141592654\n#define TAU        (2.0*PI)\n\n// SABS by ollj, this has turned out extremely useful on many occassions\n//  https://www.shadertoy.com/view/Ws2SDK\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n// http://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat df(vec2 p) {\n  const float rep = 6.0;\n\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  \n  // mod the angular component to get an kaleidoscope effect\n  // modMirror ensure curves are continuous\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  // Apply smoothing on right side of screen to make derivate of curves continuous\n  //   Left side non-smoothed for comparison\n  if (p.x > 0.0) {\n    float sa = PI/rep - SABS(PI/rep - abs(hpp.y), 0.25);\n    hpp.y = sign(hpp.y)*sa;\n  }\n\n  hp = toRect(hpp);\n  hp.x -= 0.5;\n  \n  rot(hp, TIME);\n  float d1 = box(hp, 0.25*vec2(0.5, 0.75));\n\n  float d = d1;\n\n  d = abs(d) - 0.01;\n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  float d = df(p);\n  \n  vec3 col = vec3(0.0);\n  float aa = 1.0/RESOLUTION.y;\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  col += vec3(0.0, 0.5, 0.5)*(0.5 + 0.5*sin(200.0*d));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBWh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[789, 820, 865, 865, 1019], [1021, 1021, 1054, 1054, 1139], [1141, 1141, 1163, 1163, 1207], [1209, 1209, 1230, 1230, 1271], [1273, 1352, 1379, 1379, 1455], [1457, 1457, 1475, 1475, 2085], [2087, 2087, 2139, 2139, 2457]]}
{"id": "wtsBz7", "name": "Raytracing experiment", "author": "dub", "description": "Raytracer", "tags": ["raytracer", "phong", "oddlysatisfying"], "likes": 4, "viewed": 122, "published": "Public", "date": "1596395646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reference:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n#define MOVING\n\nconst float MAXFLOAT = 3.402823e+38;\nconst float EPSILON = 0.001;\nconst int MAX_BOUNCE = 6;\n\nvec3 camera = vec3(0.0, 0.0, 0.0);\n\nvec3 center = vec3(0.0, 0.0, 2.0);\n\nvec3 light = vec3(-10.0, 10.0, -10.0);\n\nfloat radius = 1.0;\nfloat radius2 = 1.0; // squared\n\nvec3 color_white = vec3(1.0, 1.0, 1.0);\nvec3 color_black = vec3(0.0, 0.0, 0.0);\nconst vec3 sphere_color = vec3(1.0, 0.0, 0.0);\n\nvec4[5] scene = vec4[](\n    vec4(0.0, 0.0, 4.0, 0.9),\n    vec4(-2.0, 0.6, 4.0, 0.9),\n    vec4(2.0, 0.6, 4.0, 0.9),\n    vec4(-0.5, -0.5, 2.0, 0.3),\n    vec4(0.5, -0.5, 2.0, 0.3)\n);\n\nvec3 sky(vec3 a)\n{\n    #if 0\n    return mix(\n        color_white,\n        vec3(0.0, 0.423, 0.784),\n        dot(normalize(a), vec3(0.0, 1.0, 0.0))*0.5+0.5);\n    #else\n    // happy accident\n    return mix(\n        color_white,\n        color_black,\n        dot(normalize(a), vec3(0.0, 1.0, 0.0)));\n    #endif\n}\n\nbool sphere_intersect(in vec4 sphere, in vec3 origin, in vec3 dir, out float x0, out float x1)\n{\n    vec3 center = sphere.xyz;\n    float radius2 = sphere.w*sphere.w;\n    \n\tvec3 L = origin - center;\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, L);\n    float c = dot(L, L) - radius2;\n    \n    float discr = b * b - 4.0 * a * c;\n    \n    if (discr < 0.0)\n        return false;\n    \n    if (discr == 0.0)\n    {\n        x0 = x1 = -0.5 * b / a;\n        \n        return true;\n    }\n    \n    float q = (b > 0.0) ?\n        -0.5 * (b + sqrt(discr)) :\n    \t-0.5 * (b - sqrt(discr));\n    x0 = q / a;\n    x1 = c / q;\n    \n    if (x0 > x1)\n    {\n        float t = x0;\n        x0 = x1;\n        x1 = t;\n    }\n    \n    if (x0 < 0.0)\n    {\n        x0 = x1;\n        if (x0 < EPSILON) // avoid self colisions roughly\n            return false;\n    }\n    \n    return true;\n}\n\n// Blinn-Phong (light, view, normal)\nvec3 phong(in vec3 l, in vec3 v, in vec3 n)\n{\n\tvec3 h = normalize(l + v);\n\n    vec3 diffuse = sphere_color * max(dot(n, l), EPSILON);\n\n    vec3 specular = color_white * max(pow(dot(n, h), 200.0), EPSILON);\n    \n    return (specular * 0.3) + (diffuse * 0.5) + color_white * 0.2;\n}\n\nbool nearest_intersection(in vec3 origin, in vec3 dir, out vec3 center, out float t)\n{\n    t = MAXFLOAT;\n    float t0, t1;\n    bool hit = false;\n    \n    #ifdef MOVING\n    vec4 sphere;\n    \n    for (int i = 0; i < 3; i++)\n    {\n        if(sphere_intersect(scene[i], origin, dir, t0, t1))\n    \t{\n            if(t0 < t)\n            {\n                t = t0;\n                center = scene[i].xyz;\n            }\n            \n            hit = true;\n        }\n    }\n    \n    // let's add some stuff not on the scene\n    for (int i = 0; i < 8; i++)\n    {\n    \t//sphere = scene[0];\n        float ts = iTime + float(i) * 3.14/4.0;\n        \n        sphere = vec4(cos(ts)*1.5, -0.6, sin(ts)*1.5+4.0, 0.5);\n        \n        if(sphere_intersect(sphere, origin, dir, t0, t1))\n        {\n            if(t0 < t)\n            {\n                t = t0;\n                center = sphere.xyz;\n            }\n\n            hit = true;\n        }\n    }\n    \n    #else\n    for (int i = 0; i < 5; i++)\n    {\n        if(sphere_intersect(scene[i], origin, dir, t0, t1))\n    \t{\n            if(t0 < t)\n            {\n                t = t0;\n                center = scene[i].xyz;\n            }\n            \n            hit = true;\n        }\n    }\n    #endif\n    \n    return hit;\n}\n\nvoid reflect_n(in vec3 origin, in vec3 dir, out vec3 color)\n{\n    vec3 center;\n    float t = MAXFLOAT;\n    bool hit = true;\n    // color = color_white;\n    color = sky(dir);\n    \n    for (int n = 0; n < MAX_BOUNCE; n++)\n    {\n        if(!nearest_intersection(origin, dir, center, t))\n        \tbreak;\n        \n        vec3 intersection = origin + dir * t;\n        vec3 normal = normalize(intersection - center);\n\n        vec3 pcolor = phong(\n            normalize(light - intersection), // light\n            normalize(origin - intersection), // view\n            normal); // normal\n\n        color = mix(color, pcolor, 0.6);\n\n        origin = intersection;\n        dir = reflect(dir, normal);\n    }\n    color = mix(color, sky(dir), 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    \n    // primary rays\n    vec3 dir = normalize(vec3(uv.x - aspect / 2.0, uv.y-0.5, 1.0));\n\n   \tvec3 rcolor;\n    reflect_n(camera, dir, rcolor);\n    fragColor = vec4(rcolor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[404, 725, 743, 743, 1032], [1034, 1034, 1130, 1130, 1899], [1901, 1938, 1983, 1983, 2217], [2219, 2219, 2305, 2305, 3466], [3468, 3468, 3529, 3529, 4204], [4206, 4206, 4263, 4263, 4575]]}
{"id": "WtsBzf", "name": "Aeriel Flux", "author": "iRyanBell", "description": "Based on Aeriel Machina https://fractalforums.org/share-a-fractal/22/df-mandelbox-variation/3547\n\nView on Cineshader @ https://www.cineshader.com/view/WtsBzf", "tags": ["cineshader"], "likes": 5, "viewed": 9239, "published": "Public API", "date": "1597338350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 z0)\n{\n    float T = cos(iTime*0.002)+0.33;\n    float T2 = cos(iTime*0.015)+0.25;\n    vec4 z = vec4(z0,0.05);\n    \n    for (int n = 0; n < 8; n++) {\n        z.xyz=clamp(z.xyz, -T*T2, T*T2)*2.0-z.xyz;\n        z*=(T-0.25)/max(dot(z.xyz, z.xyz), 0.02*(T+T2));\n    }\n    return length(max(abs(z.xyz)-vec3(0.0,1.0,0.0),0.0))/z.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = sin(iTime*0.05)-1.0;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0)*(1.0-T)*1024.0, 0.0);\n\tvec3 rayDir = vec3(0.0, 0.0, 0.001);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 10; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    float c = 1.0-pow(depth*0.0005, 0.75);\n    fragColor = vec4(c*2.0,c*0.125,c*0.125,1.0-depth*0.00001);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Aeriel Flux\",\n\t\"description\": \"Intersection plane into a mandelbox-like structure\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 340], [343, 343, 400, 400, 896]]}
{"id": "wtsBzM", "name": "Sanctum", "author": "dean_the_coder", "description": "Another scene featuring 'god rays'.\nImproving their quality hurts my GPU too much - I might have to spend some time thinking of a more efficient technique.", "tags": ["3d", "raymarching", "light", "godrays", "ruins"], "likes": 30, "viewed": 638, "published": "Public API", "date": "1596993137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Sanctum'\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n\n#define MIN_DIST .0015\n\n#define MISS_ID   .5\n#define FLOOR_ID  1.5\n#define WALL_ID   2.5\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 lr, vec2 rr) {\n    return p - c * clamp(round(p / c), -rr, rr);\n}\n\nmat2 rot(float a) {\n    float c = cos(a),\n          s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y), 0.);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdFlower(vec2 xy, float r, float a, float peaks) {\n    return length(xy) - r + a * sin(atan(xy.y * 2.34 / xy.x) * peaks);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdArch(vec3 p, const float plinthDepth) {\n    // Main wall.\n    vec3 s = vec3(2, 3, .4);\n    const float gapWidth = .5;\n    float holeOffset = (s.x + gapWidth) / 2.;\n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y -= s.y;\n    float d = sdBox(pp, s);\n\n    // Arch holes.\n    d = max(d, -length(pp.xy - vec2(0, 1.5)) + gapWidth);\n    d = max(d, -length(pp.xy - vec2(holeOffset, 1)) + gapWidth);\n\n    // Arch gaps.\n    pp.y += s.y;\n    d = max(d, -sdBox(pp.xy, vec2(gapWidth, s.y + 1.5)));\n    d = max(d, -sdBox(pp.xy - vec2(holeOffset, 0), vec2(gapWidth, s.y + 1.)));\n\n    // Support decoration.\n    d = min(d, sdBox(pp - vec3(s.x / 3. - .035, s.y + .75, 0.), vec3(.15, .05, s.z + .05)) - .05);\n\n    // Short wall.\n    pp.z = abs(pp.z) + .7;\n    pp.y -= .6;\n    d = min(d, sdCylinder(pp.yxz, 1., s.x - gapWidth / 2.));\n\n    // Plinth.\n    d = min(d, sdBox(p - vec3(0, .2, 0), vec3(s.x - gapWidth / 2., .1, s.z + plinthDepth)) - .1);\n\n    // Backing wall.\n    pp = p;\n    s *= vec3(1.18, 1, .25);\n    pp -= vec3(0, s.y, 3);\n    d = min(d, sdBox(pp, s));\n\n    // Backing roof.\n    float hole = .6,\n          bar = .03;\n    pp.y -= 1.;\n    pp.xy = cappedMod(pp.xy, hole + bar * 2., vec2(2), vec2(1));\n    d = max(d, -sdBox(pp, vec3(hole / 2., hole / 2., .5)));\n\n    return d;\n}\n\nvec2 map(vec3 p) {\n    float surface = texture(iChannel0, (p.xy + p.yz + p.xz) * .1).r * .01,\n\n    // 'Collapse'.\n          collapse = sdFlower(p.xy - vec2(1, 11), 5., .2, 8.);\n    collapse = max(collapse, 10. - p.z);\n    collapse = min(collapse, sdFlower(p.xy - vec2(.9, 10), 3., .2, 4.));\n\n    // 'Fold space' to duplicate the arches.\n    for (int i = 0; i < 9; i++) {\n        p.xz *= rot(-.1);\n        p.x -= 1.04;\n        p.x = abs(p.x);\n    }\n\n    // Top arches.\n    float d = sdArch(p - vec3(0, 5.7, 10), 0.);\n    d = max(d, -collapse);\n\n    // Bottom arches.\n    d = min(d, sdArch(p - vec3(0, 0, 10), 1.));\n    d -= surface;\n\n    return min2(vec2(abs(p.y), FLOOR_ID), vec2(d, WALL_ID));\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1., -1.) * .5773 * .0001;\n    return normalize(e.xyy * map(p + e.xyy).x +\n\t\t\t\t\t e.yyx * map(p + e.yyx).x +\n\t\t\t\t\t e.yxy * map(p + e.yxy).x +\n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d).x / d, 0., 1.);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n\n    float res = 1.,\n          t = .1;\n    for(float i = 0.; i < 30.; i++)\n    {\n        float h = map(p + rd * t).x;\n        if (h < .03)\n            return 0.; // Hit an object - Full shadow.\n\n        res = min(res, 8. * h / t);\n        t += h;\n\n        if (t > 20.)\n            break; // Marched far enough - Stop.\n    }\n\n    return res;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n    return col;\n}\n\nvec3 sunPos = vec3(10, 8, 20),\n     sunCol = vec3(2, 1.9, 1.5);\n\nvec3 getMaterial(vec3 p, vec3 rd, float id) {\n    if (id == MISS_ID)\n        return vec3(0);\n\n    vec3 sunDir = normalize(sunPos - p),\n         n = calcNormal(p);\n\n    vec3 mat;\n    if (id == FLOOR_ID) {\n        mat = vec3(texture(iChannel0, p.xz * .01).r);\n    } else if (id == WALL_ID) {\n        mat = texture(iChannel0, (n.xy + n.yz) * .05).rgb;\n    }\n\n    // Diffuse color.\n    float diff = max(0., dot(sunDir, n)),\n\n    // Fake ambient occlusion.\n          occ = min(1., .2 + calcAO(p, n, 1.) * calcAO(p, n, .4));\n\n    // Shadows.\n    float sha = calcShadow(p, sunPos);\n\n    // Primary light (Sun).\n    vec3 lig = diff * sha * sunCol;\n\n    // Seconary light (Sky);\n    lig += max(0., .5 + .5 * n.y) * vec3(.7, .8, 1) * .2 * occ;\n\n    // Third light - Ambient.\n    lig += max(0., dot(sunDir * vec3(-1., 0., -1.), n)) * sunCol * .02 * occ;\n\n    return mat * lig;\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = .01;\n    for (float steps = 0.; steps < 96.; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n\n        if (abs(h.x) < MIN_DIST) return; // We've hit a surface - Stop.\n        d += h.x * .9; // No hit, so keep marching.\n    }\n\n    h.y = MISS_ID;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    // Camera.\n    float ft = fract(iTime / 8.),\n          phase = mod(floor(iTime / 8.), 3.);\n\n    vec3 ro,\n         lookAt = vec3(0, 6, 12);\n\n    if (phase == 0.) {\n        ro = vec3(5. - ft, 1.5, -5.);\n        lookAt.x -= ft;\n        sunPos.x *= mix(.82, 1.62, ft);\n        sunPos.y *= mix(2.375, .90, ft);\n    } else if (phase == 1.) {\n        ro = vec3(-5. + ft, 1.5, 2.);\n        lookAt = vec3(0, 3, 12);\n        sunPos.x *= mix(.02, 1.99, ft);\n        sunPos.y *= mix(.375, .90, ft);\n    } else if (phase == 2.) {\n        ro = vec3(mix(-5., -.0625, ft), 4.7, 5.);\n        sunPos.y *= 1.625;\n    }\n\n    vec3 rd = getRayDir(ro, lookAt, uv);\n\n    // Raymarch.\n    vec2 h = vec2(1e7, MISS_ID);\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n    vec3 col = getMaterial(p, rd, h.y);\n\n    // Volumetric lighting ('God rays')\n    const float maxSteps = 35.;\n    float dp = distance(ro, p);\n    vec3 beamStep = rd * dp / maxSteps;\n    float illum = 0.;\n    float jit = hash(uv) * .6;\n    for (float i = 0.; i < maxSteps; i++) {\n        vec3 sp = ro + beamStep * (i + jit); // Jitter so smooth sampling point. (Thanks BigWings!)\n        illum += smoothstep(0., 1., calcShadow(sp, sunPos));\n    }\n\n    illum /= maxSteps;\n    col = mix(col, sunCol, pow(illum, .7));\n\n    // Fog.\n    col = mix(vec3(1), col, vec3(exp(-pow(dp / 50., 3.) * 5.)));\n\n    // Output to screen.\n    col = vignette(pow(col, vec3(.4545)), fragCoord);\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 212, 232, 232, 296], [298, 298, 349, 349, 400], [402, 402, 421, 421, 497], [499, 499, 528, 528, 621], [623, 623, 652, 652, 735], [737, 737, 781, 781, 890], [892, 892, 948, 948, 1021], [1023, 1023, 1070, 1070, 1269], [1271, 1271, 1298, 1298, 1330], [1332, 1332, 1379, 1397, 2610], [2612, 2612, 2630, 2630, 3307], [3309, 3309, 3334, 3334, 3527], [3529, 3529, 3568, 3568, 3618], [3620, 3620, 3661, 3661, 4043], [4045, 4131, 4172, 4172, 4307], [4374, 4374, 4419, 4419, 5241], [5243, 5243, 5297, 5297, 5565], [5567, 5567, 5619, 5619, 7155]]}
{"id": "wtsBzS", "name": "Double Ended Truchet Experiment", "author": "mrange", "description": "License CC0: Double Ended Truchet Experiment\nBeen looking at some double ended truchets by BigWings and Shane. After some experiments I got something I felt was interesting enough to share.", "tags": ["truchet"], "likes": 14, "viewed": 246, "published": "Public API", "date": "1597084518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Double Ended Truchet Experiment\n// Been looking at some double ended truchets by BigWings and Shane. \n// After some experiments I got something I felt was interesting enough to share.\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nconst vec2 coords[8] = vec2[8](\n  0.5*vec2(-1.0, -0.5),\n  0.5*vec2(-1.0, +0.5),\n  0.5*vec2(-0.5, +1.0),\n  0.5*vec2(+0.5, +1.0),\n  0.5*vec2(+1.0, +0.5),\n  0.5*vec2(+1.0, -0.5),\n  0.5*vec2(+0.5, -1.0),\n  0.5*vec2(-0.5, -1.0)\n  );\n\nconst vec2 dcoords[8] = vec2[8](\n  vec2(+1.0, +0.0),\n  vec2(+1.0, +0.0),\n  vec2(+0.0, -1.0),\n  vec2(+0.0, -1.0),\n  vec2(-1.0, +0.0),\n  vec2(-1.0, +0.0),\n  vec2(+0.0, +1.0),\n  vec2(+0.0, +1.0)\n  );\n\nconst int noCorners = 105;\n// Using symmetries and reflections should be possible to reduce this \n//  array alot, but that is hard ;)\nconst int corners[105*8] = int[105*8](\n  0, 1, 2, 3, 4, 5, 6, 7, \n  0, 1, 2, 3, 4, 6, 5, 7, \n  0, 1, 2, 3, 4, 7, 5, 6, \n  0, 1, 2, 4, 3, 5, 6, 7, \n  0, 1, 2, 4, 3, 6, 5, 7, \n  0, 1, 2, 4, 3, 7, 5, 6, \n  0, 1, 2, 5, 3, 4, 6, 7, \n  0, 1, 2, 5, 3, 6, 4, 7, \n  0, 1, 2, 5, 3, 7, 4, 6, \n  0, 1, 2, 6, 3, 4, 5, 7, \n  0, 1, 2, 6, 3, 5, 4, 7, \n  0, 1, 2, 6, 3, 7, 4, 5, \n  0, 1, 2, 7, 3, 4, 5, 6, \n  0, 1, 2, 7, 3, 5, 4, 6, \n  0, 1, 2, 7, 3, 6, 4, 5, \n  0, 2, 1, 3, 4, 5, 6, 7, \n  0, 2, 1, 3, 4, 6, 5, 7, \n  0, 2, 1, 3, 4, 7, 5, 6, \n  0, 2, 1, 4, 3, 5, 6, 7, \n  0, 2, 1, 4, 3, 6, 5, 7, \n  0, 2, 1, 4, 3, 7, 5, 6, \n  0, 2, 1, 5, 3, 4, 6, 7, \n  0, 2, 1, 5, 3, 6, 4, 7, \n  0, 2, 1, 5, 3, 7, 4, 6, \n  0, 2, 1, 6, 3, 4, 5, 7, \n  0, 2, 1, 6, 3, 5, 4, 7, \n  0, 2, 1, 6, 3, 7, 4, 5, \n  0, 2, 1, 7, 3, 4, 5, 6, \n  0, 2, 1, 7, 3, 5, 4, 6, \n  0, 2, 1, 7, 3, 6, 4, 5, \n  0, 3, 1, 2, 4, 5, 6, 7, \n  0, 3, 1, 2, 4, 6, 5, 7, \n  0, 3, 1, 2, 4, 7, 5, 6, \n  0, 3, 1, 4, 2, 5, 6, 7, \n  0, 3, 1, 4, 2, 6, 5, 7, \n  0, 3, 1, 4, 2, 7, 5, 6, \n  0, 3, 1, 5, 2, 4, 6, 7, \n  0, 3, 1, 5, 2, 6, 4, 7, \n  0, 3, 1, 5, 2, 7, 4, 6, \n  0, 3, 1, 6, 2, 4, 5, 7, \n  0, 3, 1, 6, 2, 5, 4, 7, \n  0, 3, 1, 6, 2, 7, 4, 5, \n  0, 3, 1, 7, 2, 4, 5, 6, \n  0, 3, 1, 7, 2, 5, 4, 6, \n  0, 3, 1, 7, 2, 6, 4, 5, \n  0, 4, 1, 2, 3, 5, 6, 7, \n  0, 4, 1, 2, 3, 6, 5, 7, \n  0, 4, 1, 2, 3, 7, 5, 6, \n  0, 4, 1, 3, 2, 5, 6, 7, \n  0, 4, 1, 3, 2, 6, 5, 7, \n  0, 4, 1, 3, 2, 7, 5, 6, \n  0, 4, 1, 5, 2, 3, 6, 7, \n  0, 4, 1, 5, 2, 6, 3, 7, \n  0, 4, 1, 5, 2, 7, 3, 6, \n  0, 4, 1, 6, 2, 3, 5, 7, \n  0, 4, 1, 6, 2, 5, 3, 7, \n  0, 4, 1, 6, 2, 7, 3, 5, \n  0, 4, 1, 7, 2, 3, 5, 6, \n  0, 4, 1, 7, 2, 5, 3, 6, \n  0, 4, 1, 7, 2, 6, 3, 5, \n  0, 5, 1, 2, 3, 4, 6, 7, \n  0, 5, 1, 2, 3, 6, 4, 7, \n  0, 5, 1, 2, 3, 7, 4, 6, \n  0, 5, 1, 3, 2, 4, 6, 7, \n  0, 5, 1, 3, 2, 6, 4, 7, \n  0, 5, 1, 3, 2, 7, 4, 6, \n  0, 5, 1, 4, 2, 3, 6, 7, \n  0, 5, 1, 4, 2, 6, 3, 7, \n  0, 5, 1, 4, 2, 7, 3, 6, \n  0, 5, 1, 6, 2, 3, 4, 7, \n  0, 5, 1, 6, 2, 4, 3, 7, \n  0, 5, 1, 6, 2, 7, 3, 4, \n  0, 5, 1, 7, 2, 3, 4, 6, \n  0, 5, 1, 7, 2, 4, 3, 6, \n  0, 5, 1, 7, 2, 6, 3, 4, \n  0, 6, 1, 2, 3, 4, 5, 7, \n  0, 6, 1, 2, 3, 5, 4, 7, \n  0, 6, 1, 2, 3, 7, 4, 5, \n  0, 6, 1, 3, 2, 4, 5, 7, \n  0, 6, 1, 3, 2, 5, 4, 7, \n  0, 6, 1, 3, 2, 7, 4, 5, \n  0, 6, 1, 4, 2, 3, 5, 7, \n  0, 6, 1, 4, 2, 5, 3, 7, \n  0, 6, 1, 4, 2, 7, 3, 5, \n  0, 6, 1, 5, 2, 3, 4, 7, \n  0, 6, 1, 5, 2, 4, 3, 7, \n  0, 6, 1, 5, 2, 7, 3, 4, \n  0, 6, 1, 7, 2, 3, 4, 5, \n  0, 6, 1, 7, 2, 4, 3, 5, \n  0, 6, 1, 7, 2, 5, 3, 4, \n  0, 7, 1, 2, 3, 4, 5, 6, \n  0, 7, 1, 2, 3, 5, 4, 6, \n  0, 7, 1, 2, 3, 6, 4, 5, \n  0, 7, 1, 3, 2, 4, 5, 6, \n  0, 7, 1, 3, 2, 5, 4, 6, \n  0, 7, 1, 3, 2, 6, 4, 5, \n  0, 7, 1, 4, 2, 3, 5, 6, \n  0, 7, 1, 4, 2, 5, 3, 6, \n  0, 7, 1, 4, 2, 6, 3, 5, \n  0, 7, 1, 5, 2, 3, 4, 6, \n  0, 7, 1, 5, 2, 4, 3, 6, \n  0, 7, 1, 5, 2, 6, 3, 4, \n  0, 7, 1, 6, 2, 3, 4, 5, \n  0, 7, 1, 6, 2, 4, 3, 5, \n  0, 7, 1, 6, 2, 5, 3, 4\n  );\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 off, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5+off;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  p /= s;\n  vec2 cp = p;\n  vec2 cn = mod2_1(cp);\n  float rr = hash(cn);\n  int sel = int(float(noCorners)*rr);\n  int off = sel*8;\n  \n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n  \n  for (int i = 0; i < 4; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];    \n    int odd = min(c0, c1) & 1;\n    \n    float r = fract(rr*13.0*float(i+1));\n    \n    int l = abs(c0 - c1) + odd*8;\n    float f = 0.71;\n    vec2 off = vec2(0.0, 0.0);\n\n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n    \n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n\n    vec2 dp = mix(dp0, dp1, r);\n\n    switch(l) {\n    // Mid shape\n    case 1:\n    case 15:\n      f = mix(0.75, 2.5, r);\n      break;\n    // L - shape\n    case 2:\n    case 6:\n    case 10:\n    case 14:\n      f = r > 0.5 ? 0.35 : 1.25;\n      break;\n    // Big corner shape\n    case 3:\n    case 13:\n      f = mix(0.5, 1.0, r);\n      break;\n    // Cross line\n    case 4:\n    case 12:\n      f = r>0.5 ? 0.5 : 1.5;\n      break;\n    // Straight line\n    case 5:\n    case 11:\n      f = 1.5;\n      off = (r > 0.5 ? 1.0 : -1.0)*0.15*vec2(dp0.y, -dp0.x);\n      break;\n    // Small corner shape\n    case 7:\n    case 9:\n      f = r>0.5 ? 0.75 : 2.75;\n      break;\n    default:\n      f = 0.5;\n      break;\n    }\n    \n    float dd = (bezier2(cp, f, off, p0, dp0, p1, dp1)-0.025)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  p += vec2(0.5, sqrt(0.5))*TIME*0.1;\n \n  float aa = 2.0/RESOLUTION.y;\n  float s = 0.25;\n\n  vec3 col = vec3(0.1);\n  col = color(p, s, aa, col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBzS.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[791, 3776, 3803, 3803, 3872], [3874, 3874, 3895, 3895, 3965], [3967, 3967, 3988, 3988, 4017], [4019, 4019, 4039, 4039, 4058], [4064, 4064, 4104, 4104, 4212], [4214, 4266, 4314, 4314, 5346], [5348, 5348, 5428, 5428, 5704], [5706, 5706, 5755, 5755, 7331], [7333, 7333, 7385, 7385, 7663]]}
{"id": "wtSBzz", "name": "Torus Inside", "author": "Kali", "description": "Inside of a torus based on an image I found on facebook", "tags": ["torus"], "likes": 19, "viewed": 280, "published": "Public", "date": "1598203828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat de(vec3 p) {\n    float t=-sdTorus(p,vec2(2.3,2.));\n    p.y+=1.;\n    float d=100.,s=2.;\n    p*=.5;\n    for (int i=0; i<6; i++) {\n        p.xz*=rot(iTime);\n        p.xz=abs(p.xz);\n        float inv=1./clamp(dot(p,p),0.,1.);\n        p=p*inv-1.;\n        s*=inv;\n        d=min(d,length(p.xz)+fract(p.y*.05+iTime*.2)-.1);\n    }\n    return min(d/s,t);\n}\n\nfloat march(vec3 from, vec3 dir) {\n    float td=0., g=0.;\n    vec3 p;\n    for (int i=0; i<100; i++) {\n    \tp=from+dir*td;\n        float d=de(p);\n        if (d<.002) break;\n        g++;\n        td+=d;\n    }\n    return smoothstep(.3,0.,abs(.5-fract(p.y*15.)))*exp(-.07*td*td)*sin(p.y*10.+iTime*10.)+g*g*.00008;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float t=iTime*.5;\n\tvec3 from=vec3(cos(t),0.,-3.3);\n    vec3 dir=normalize(vec3(uv,.7));\n\tdir.xy*=rot(.5*sin(t));    \n    float col=march(from,dir);\n    fragColor=vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSBzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 74], [76, 76, 109, 109, 174], [176, 176, 194, 194, 528], [530, 530, 564, 564, 840], [842, 842, 899, 899, 1158]]}
{"id": "wtSfD1", "name": "blipping lines", "author": "rhaglennuddestron", "description": "lines that be cool", "tags": ["simple", "lines", "flashing"], "likes": 2, "viewed": 45, "published": "Public", "date": "1598819034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.y += iTime*0.25;uv.x += sin(iTime)*0.3;\n    vec3 col = vec3(4.*sin(8.*uv.y),\n                    4.*cos(8.*uv.y),\n                    4.*(1.-sin(8.*-uv.y + 0.1*uv.x)));\n    float off = cos(uv.y*18. *iTime*0.05 + iTimeDelta*8.);\n    col *= sin((uv.x-off*1e-2)*50.);\n\tcol *= (uv.x -off*10.> 0. && uv.x -off*10. < 1. ? mat3(1,0,0,0,1,0,0,0,1):mat3(1,0,1,0,1,1,1,1,0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 500]]}
{"id": "wtsfD4", "name": "theyaremanycolors 7 - blue deep", "author": "thefox231", "description": "oooo..... pseudo bloom.........", "tags": ["theyaremanycolors"], "likes": 2, "viewed": 119, "published": "Public API", "date": "1596798946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 layer1Color = vec3(0.0, 0.0, 0.0);\nconst vec3 layer2Color = vec3(1.0, 1.0, 1.0);\nconst vec3 layer3Color = vec3(0.0, 12.0/255.0, 242.0/255.0);\n\n#define scale 40.0\n#define offset 10.0\n\n#define passes 20.0\n#define bloomSize 0.2\n\n#define fisheye_amount -0.4\n\nfloat hash(vec3 p3)\n{\n    p3.xy *= 400.0;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smoothHash(vec3 p3) {\n   \treturn mix(round(hash(vec3(p3.xy, floor(p3.z)))), round(hash(vec3(p3.xy, ceil(p3.z)))), fract(p3.z));\n}\n\nvec4 render(vec2 uv) {\n    // fisheye\n\n    uv -= 0.5;\n    uv *= 1.0 - fisheye_amount / 2.0;\n\n    float r = sqrt(dot(uv,uv));\n    uv *= 1.0 + r * fisheye_amount;\n    uv += 0.5;\n\n    vec2 res = iResolution.xy;\n    uv = clamp( uv, 1.0 / res, (res - 1.0) / res );\n\n    // fisheye end\n    \n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = layer1Color;\n    \n    vec2 uvPix = round(uv * scale) / scale;\n    float hash1 = (smoothHash(vec3(uvPix, iTime * 3.3 + uv.x * 2.63)));\n    \n    uv += offset / iResolution.xy;\n    uvPix = round(uv * scale) / scale;\n    float hash2 = (smoothHash(vec3(uvPix, iTime * 5.3 + 90.0 + uvPix.y * 25.3 + uvPix.x * 24.53)));\n    \n    col = mix(col, layer2Color, hash1);\n    col = mix(col, layer3Color, hash2);\n    \n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.0);\n    \n    for (int i = 0; float(i) < passes; i++) {\n        float progress = float(i) / passes;\n        vec2 scaledUv = (uv - 0.5) * (1.0 + progress * bloomSize) + 0.5;\n        vec4 rendered = render(scaledUv);\n        \n        float lumi = (rendered.r + rendered.g + rendered.b) / 3.0;\n        \n        col += rendered * pow(1.0 - progress, 3.0) * pow(lumi, 2.0);\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 287, 287, 410], [412, 412, 439, 439, 547], [549, 549, 571, 586, 1323], [1325, 1325, 1382, 1382, 1851]]}
{"id": "wtSfDR", "name": "Polar Weave Pattern - simple 3", "author": "FabriceNeyret2", "description": "asymmetrical variant\ngolfed variant of [url]https://shadertoy.com/view/wtBfRm[/url]\nreproducing another way the base pattern of [url]https://www.shadertoy.com/view/3ljfR1[/url]\n\n- s: change s = 2Pi / N by any N you like\n- D: without final .5 is nice too", "tags": ["2d", "repetition", "pattern", "polar", "short", "weave"], "likes": 6, "viewed": 207, "published": "Public API", "date": "1598642211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Variant of https://shadertoy.com/view/3l2fzw\n// Golfed variant of https://shadertoy.com/view/wtBfRm\n// Reproducing another way the base pattern of https://www.shadertoy.com/view/3ljfR1\n\n#define D(S) ( v = l * cos(a-s/2.) / cos(s/2.) -1.,             \\\n               m = r*abs(  sin(s/2.)                            \\\n                          - sqrt( l*l + 1. - 2.*l* cos( S v > 0. ? a-s : a ) ) \\\n                          - (.25*sin(iTime)-.05)*sign(v) ) -.07,\\\n               m = clamp(1.- R.y/4.* m, 0.,1.),                 \\\n               m * ( .2+fract(S A/s) ) )                       //\n            /* m * fract(S.5*A/s) )      */                    //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float s = 6.28 / 7., r = .5, m, T, v,\n          A = atan(U.y,U.x) + iTime/2.,\n          a = mod(A,s),\n          l = length(U) / R.y / r;\n    O += D( );  T = 1.-m;\n    O += D(-) * T;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[663, 666, 702, 702, 943]]}
{"id": "WtsfRf", "name": "art 4 art 2 cos", "author": "zeichlicht", "description": ".... this shader has been modified ...  the original shader can be found here :::\n\nCreation by Silexars :::  https://www.shadertoy.com/view/XsXXDn \n", "tags": ["zeichlicht"], "likes": 3, "viewed": 229, "published": "Public API", "date": "1597336433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n//.... this shader has been modified ...  the original shader can be found here :::\n// Creation by Silexars :::  https://www.shadertoy.com/view/XsXXDn \n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.05;\n\t\tl=length(p);\n       // l*=l;\n\t\tuv+=p/l*cos(cos(z)+1.)*abs(cos(l*9.-z*2.));\n         l=pow(l,.001);\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 321, 377, 377, 664]]}
{"id": "wtsfRj", "name": "Two tadpoles", "author": "akanarika", "description": "2 swimming tadpoles", "tags": ["2d"], "likes": 1, "viewed": 45, "published": "Public", "date": "1597213440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float calc(vec2 uv, float ratio) {\n    float col = 1.0;\n    float tail = smoothstep(-.1, .8, abs(.9 * sin(uv.x - .1)));\n    if (uv.x < -.15 && uv.x > -ratio && abs(uv.y * 1.1) < .32) {\n        col = smoothstep(0., .05 * (1. - tail) * (1. - sin(uv.x)), 2. * abs(uv.y + .2 * sin(iTime * 10.) * sin(uv.x) * sin(uv.x) * sin(uv.x)) * tail);\n    } else {\n        col = smoothstep(0.7, .8, 3.5 * length(vec2((uv.x - 0.11) * .8, uv.y)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    float ratio = iResolution.x / iResolution.y;\n    \n    vec2 p = vec2(uv.x + step(uv.y, 0.) - .5, abs(uv.y) - .4 + (step(uv.y, 0.) - .2) * sin(iTime + step(uv.y, 0.)) * .2);\n\n    float col = calc(p, ratio);\n    \n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 453], [455, 455, 512, 512, 833]]}
{"id": "wtSfRm", "name": "para-mi-estudio-v1", "author": "jorge2017a1", "description": "//autor desconocido", "tags": ["paramiestudiov1"], "likes": 8, "viewed": 96, "published": "Public", "date": "1598535201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//autor desconocido\n\n\n//#define grid_size 85.0 \n#define grid_size 60.0 \n#define glow_size 2.0\n#define glow_br   0.2\n#define time_step 10.0\n\nfloat random(vec2 seed)\n{\n\tfloat value \t= fract(sin(dot(seed ,vec2(12.9898,78.233))) * 43758.5453);\n\treturn value;\n}\nfloat rand(in vec2 p)\n{\n\treturn abs( fract( sin(p.x * 95325.328 + p.y * -48674.077) + cos(p.x * -46738.322 + p.y * 76485.077) + iTime/3. ) -.5)+.5;\n}\n\nvec4 dot_grid(vec2 pos)\n{\n\t\n\tfloat c_time\t= iTime / time_step;\n\t\n\tvec2 p = pos / grid_size;\t\n\tvec2 step_pos\t= floor(p) * grid_size;\n\tvec2 norm_pos\t= step_pos.xy / iResolution.xy;\n\t\n\t//norm_pos\t= vec2(norm_pos.x + random(norm_pos), norm_pos.y + random(norm_pos ));\n    norm_pos\t= vec2(norm_pos.x  , norm_pos.y );\n\t\n\tfloat r = fract(sin(norm_pos.x ));\n\tfloat g = fract(sin(norm_pos.y + abs(c_time) ));\n\tfloat b = abs(r-g);\n\n\tvec3 color = vec3(rand(step_pos), rand(step_pos / grid_size), rand(floor(p * .5)));\n\tfloat scale = 1.-pow( pow( (mod( p.x, 1.)-.5) , 2.) + pow( (mod( p.y, 1.)-.5), 2.), .7 );\n\t\n\treturn vec4(mix(color * scale, vec3(r, g, b), 0.5), 1.0);\n}\n\n\n\nfloat lines(vec2 pos)\n{\n\tfloat value = floor(mod(pos.x,grid_size)) * floor(mod(pos.y,grid_size));\t\t\n\treturn clamp(value, 0.0, 1.0);\n}\n\nvec4 glow(vec2 pos)\n{\n\tvec4 color \t=  clamp(dot_grid(pos) * lines(pos) * glow_br, 0.0, 1.0);\n\tcolor\t\t+= clamp(dot_grid(vec2(pos.x - glow_size,pos.y)) * glow_br, 0.0, 1.0);\n\tcolor\t\t+= clamp(dot_grid(vec2(pos.x + glow_size,pos.y)) * glow_br, 0.0, 1.0);\n\tcolor\t\t+= clamp(dot_grid(vec2(pos.x,pos.y - glow_size)) * glow_br, 0.0, 1.0);\n\tcolor\t\t+= clamp(dot_grid(vec2(pos.x,pos.y + glow_size)) * glow_br, 0.0, 1.0);\n\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy;\n\tfragColor = glow(position);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 140, 165, 165, 256], [257, 257, 280, 280, 406], [408, 408, 433, 433, 1068], [1072, 1072, 1095, 1095, 1205], [1207, 1207, 1228, 1228, 1634], [1636, 1636, 1693, 1693, 1755]]}
{"id": "WtSfW1", "name": "2d bend deformer", "author": "greje656", "description": "A simple 2d bend deformer", "tags": ["deformer"], "likes": 5, "viewed": 287, "published": "Public", "date": "1598761980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 GetCheckboard(vec2 p)\n{\n    vec3 PALETTE[5];\n    PALETTE[0] = vec3( 38, 70, 83)/255.0;\n    PALETTE[1] = vec3( 42,157,143)/255.0;\n    PALETTE[2] = vec3(233,196,105)/255.0;\n    PALETTE[3] = vec3(244,162, 97)/255.0;\n    PALETTE[4] = vec3(231,111, 81)/255.0;\n    \n    float offsetX = p.x < 0.0 ? 1.0 : 0.0;\n    float offsetY = p.y < 0.0 ? 1.0 : 0.0;\n    \n    float ttt = (sin(iTime * 0.5) + 1.0) * 0.5;\n    float sss = mix(20.0, 50.0, ttt);\n    float checkBoardX = abs(round(abs(p.x) * sss) + offsetX);\n    float checkBoardY = abs(ceil(abs(p.y) * sss) + offsetY + checkBoardX);\n    int c1 = int(mod(checkBoardX + checkBoardY, 5.0));\n    \n    return\n        c1==0 ? PALETTE[0]:\n        c1==1 ? PALETTE[1]:\n        c1==2 ? PALETTE[2]:\n        c1==3 ? PALETTE[3]:\n                PALETTE[4];\n}\n\nfloat GetArcLength(vec2 circleCenter, vec2 p)\n{\n    vec2  dir = p - circleCenter;\n    float radius = length(dir);\n    float d = dot(normalize(dir), vec2(0, 1));\n\n    d = clamp(d, -0.9999999, 0.9999999);\n    return acos(d) * radius;\n}\n\nvec2 MapArcOnCircle(vec2 circleCenter, float radius, float arc)\n{\n    float halfCirconference = PI * radius;\n    float v = arc / halfCirconference;\n    float a = v * PI;\n    vec2  dir = vec2(sin(a), cos(a));\n    return circleCenter + dir * radius;\n}\n\nvec2 UnbendPoint(vec2 p, vec2 bendCircleCenter, float bendCircleRadius, float t, float ox)\n{\n    float derrivedRadius = distance(p, bendCircleCenter);\n    float d = derrivedRadius - bendCircleRadius;\n    float s  = GetArcLength(bendCircleCenter, p);\n    float safety = clamp((t - 0.01) / 0.01, 0.0, 1.0);\n    s = mix(abs(p.x - ox), s, safety);\n\n    float bendCircleRadiusT0 = 1.0 / PI + d;\n    float bendCircleHalfCirconference = PI * bendCircleRadiusT0;\n    float dynamicArcLength = mix(1.0, bendCircleHalfCirconference, t);\n\n    vec2  mp = MapArcOnCircle(bendCircleCenter, derrivedRadius, dynamicArcLength);\n    float sp = GetArcLength(bendCircleCenter, mp);\n    return vec2(s / sp, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv    = fragCoord/iResolution.xy;\n    vec2  mouse = (iMouse.xy/iResolution.xy);\n    float vignette = clamp((length(uv - 0.5) - 0.35) * 1.5, 0.0, 1.0);\n    float screenRatio = iResolution.y/iResolution.x;\n    uv.y    *= screenRatio;\n    mouse.y *= screenRatio;\n\n    vec2  m = (mouse - 0.5) * 2.0 * vec2(1,1);\n    vec2  p = (uv    - 0.5) * 2.0 * vec2(1,1);\n    float bendAmount = (sin(iTime) + 1.0) * 0.5;\n\n    if(iMouse.z == 0.0)\n        m = vec2(0,-0.48);\n\n    float bendCircleRadius = 1.0 / max(0.01, (PI * bendAmount));\n    vec2  bendCircleCenter = vec2(m.x, -bendCircleRadius + m.y + 1.0/PI);\n    vec2  up = UnbendPoint(p, bendCircleCenter, bendCircleRadius, bendAmount, m.x);\n    vec3  pattern = GetCheckboard(up);\n\n    float sl = abs(up.y) * 150.0;\n    sl = 1.0 - clamp(sl, 0.0, 1.0);\n    sl = clamp(sl * 2.0, 0.0, 1.0);\n    \n    vec3 col = pattern;\n    col = mix(col, col * 0.5, up.y < 0.0 ? 1.0 : 0.0);\n    col = mix(col, vec3(0.1, 0.1, 0.1), sl);\n    col = mix(col, col * 0.0, vignette);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 817], [819, 819, 866, 866, 1052], [1054, 1054, 1119, 1119, 1303], [1305, 1305, 1397, 1397, 1995], [1997, 1997, 2054, 2054, 3094]]}
{"id": "wtsfWM", "name": "P.Gerdes & Tchokwe sand drawing", "author": "FabriceNeyret2", "description": "reference:\n[url]https://www.google.com/search?q=tchokwe+sand+drawing&tbm=isch[/url]\n[img]https://images.fr.shopping.rakuten.com/photo/244198430.jpg[/img]\n\nSee also variants: [url]https://www.shadertoy.com/results?query=Tchokwe[/url]\n", "tags": ["tiles", "short", "reproduction", "truchets", "ethnomathematics"], "likes": 10, "viewed": 251, "published": "Public API", "date": "1596917115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// see also variants: https://www.shadertoy.com/results?query=Tchokwe\n\n#define S(v) smoothstep( 9./R.y , 0. , v )          // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = vec4(1);\n    mat2 M = mat2(1,-1,1,1);                        // for 45° rotations\n    vec2 R = iResolution.xy,\n         U = 3. * ( 2.*u - R ) / R.y + iTime,\n         I = floor( U * M ),                        // edge id (vec)\n         F = ( fract(U) - .5 ) *M / 1.414;          // quad center to edge domain\n    \n    O -= S( length(F) - .1 );                       // dots\n\n    float i = I.y + 10.*I.x +99.,                   // edge id (float)\n          r = fract(4e4*sin(i));                    // rand(id)\n    O -= r < .5\n        ? F = S( abs( abs(F) - .35 ) -.01 ),        //  X at edge\n          F.x + F.y \n        : S(  abs( length(F) - .35 ) -.01 );        // )( at edge\n\n // O -= .4*( .5+.5*cos(6.3*r + vec4(0,2,-2,0)) );  // coloring ( debug )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 173, 173, 937]]}
{"id": "wtsfWN", "name": "Feeding material for shells", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 13, "viewed": 127, "published": "Public", "date": "1596804915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n\tfloat s=3.;\n\tfor(float i=0.;i++<4.;)\n    {\n        p=mod(p-1.,2.)-1.;\n        p=abs(p);\n\t\tfloat r2=1.4/dot(p,p);\n\t\tp*=r2;\n\t\ts*=r2;\n\t}\n\treturn dot(p,normalize(vec3(-1,5,2.+1.5*sin(iTime+.5*sin(.3*iTime)))))/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(1.5,1.5,iTime*1.2),\n  \t\tw=normalize(vec3(.3*sin(iTime*.5),.5,1)),\n  \t\tu=normalize(cross(w,vec3(cos(-iTime*.16),sin(-iTime*.16),0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\tfloat h=0.8,d,i;\n\tfor(i=1.;i<150.;i++)\n    {\n    \tp=ro+rd*h;\n\t\td=map(p);\n    \tif(d<.001)break;\n    \th+=d;\n\t}\n    vec3 col=30.*vec3(cos(p.yxx*1.2)*.5+.5)/i;\n    if(i<3.)col*=.1; \n    else if(i<7.)col=vec3(1,.25,0); \n\tfragColor.xyz=pow(col,vec3(1.5,.8,1.3));\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 231], [233, 233, 290, 290, 814]]}
{"id": "WtsfWr", "name": "I'm trapped", "author": "Flopine", "description": "An improve version of a doodle I made under 25 minutes during the FieldFX Shader Showdown qualifications", "tags": ["raymarching", "animation", "rainbow", "isometric", "showdown"], "likes": 34, "viewed": 356, "published": "Public", "date": "1596482096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define time iTime\n#define BPM (135./60.)\n#define dt(speed) fract(time*speed)\n\n#define bouncy(speed) sqrt(abs(sin(dt(speed)*PI)))\n#define switchanim(speed) floor(sin(dt(speed)*2.*PI)+1.)\n\nstruct obj \n{\n    float d;\n    float m;\n    vec3 c;\n}\n;\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvec3 pal (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.37,0.63)));}\n\nobj strucmin (obj a, obj b)\n{\n    if (a.d<b.d) return a;\n \telse return b;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}  \n\nobj cages (vec3 p)\n{\n    mo(p.xz, vec2(0.5));\n    p.x -= 0.8;\n\n    mo(p.yz, vec2(1.));\n    p.y -= 1.+bouncy(BPM/4.);\n\n    mo(p.xz, vec2(2.));\n    p.x -= 1.5;\n\n\tfloat anim = (PI/2.)*(floor(time*(BPM/2.))+pow(dt(BPM/2.),5.));\n    p.xz += vec2(cos(anim),sin(anim));\n\n    return obj(max(-sc(p,0.9-bouncy(BPM)*0.1),box(p,vec3(1.)))-0.02,0.,pal(length(p),vec3(1.)));\n}\n\nobj gem (vec3 p)\n{\n    p.xz *= rot(dt(BPM/5.)*PI);\n    return obj (dot(p,normalize(sign(p)))-1., 1., vec3(1.));\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.0);\n    return strucmin(gem(p),cages(p));\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat mask(vec2 uv)\n{\n    return smoothstep(0.1,0.4, sin(fract(length(uv))-time*(BPM/4.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec2 uu = floor(uv*30.)/30.;\n    uv *= 0.95+mask(uu);\n    \n    vec3 ro = vec3(uv*8.,-50.),\n        rd = vec3(0.,0.,1.),\n        l = normalize(vec3(1.,2.,-2.)),\n        p = ro,\n        col = vec3(0.);\n\n    bool hit = false; obj O;\n\n    for (float i=0.; i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {\n            hit = true; break;\n        }\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float lighting = max(dot(n,l),0.);\n        if (O.m == 0.) col = O.c*lighting;\n        if (O.m == 1.) col = mix(vec3(0.1,0.2,0.8),vec3(1.,0.8,0.8), lighting);\n\n    }\n    \n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 584, 604, 604, 647], [649, 649, 681, 681, 728], [730, 730, 758, 758, 822], [824, 824, 853, 853, 899], [901, 901, 929, 929, 1015], [1017, 1017, 1045, 1045, 1121], [1125, 1125, 1145, 1145, 1487], [1489, 1489, 1507, 1507, 1602], [1604, 1604, 1622, 1622, 1724], [1726, 1726, 1748, 1748, 1870], [1872, 1872, 1893, 1893, 1965], [1968, 1968, 2025, 2025, 2828]]}
{"id": "wtSfWz", "name": "Astral Train", "author": "sukupaper", "description": "A trippy train ~\n\n(sorry about the not readable code)", "tags": ["raymarching", "rainbow", "starfield", "train", "rayway", "catenary"], "likes": 36, "viewed": 353, "published": "Public", "date": "1598703760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: sukupaperu\n// Title: Astral Train\n// Music: \"Gazela\" by Teetow - https://soundcloud.com/teetow/gazela\n// Big thanks to Teetow for this special edit : https://soundcloud.com/teetow/gazela-astral-train-edit\n\n#define P 6.283185307\n\n// global variables\nint wagonId = -1, railsId = -1;\nvec3 mapTravel, mapGlobal;\nfloat t, isMagicalWorld;\n\n// other functions\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nfloat cord(in float x, in float h, in float d) { x = abs(x) - d*.5; return (x*x)*h - (d*d*.25)*h; }\nfloat anim1(float x, float sm){ float xmd = mod(x,2.) - .5; return smoothstep(-sm,sm,xmd) - smoothstep(-sm,sm,xmd - 1.); }\n\n// color functions\nvec3 SpectrumPoly(in float x) {\n    // https://www.shadertoy.com/view/wlSBzD\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)+(vec3(-2.965000e1, 6.806567e1,-3.606269e1)+(vec3( 5.451365e2,-7.921759e2, 6.966892e2)+(vec3(-4.121053e3, 4.432167e3,-4.463157e3)+(vec3( 1.501655e4,-1.264621e4, 1.375260e4)+(vec3(-2.904744e4, 1.969591e4,-2.330431e4)+(vec3( 3.068214e4,-1.698411e4, 2.229810e4)+(vec3(-1.675434e4, 7.594470e3,-1.131826e4)+ vec3( 3.707437e3,-1.366175e3, 2.372779e3)*x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\nvec3 hsv2rgb(in vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0); return c.z*mix(vec3(1.0),rgb,c.y); }\n\n// coordinate transformation functions\nvec2 fold(vec2 p, float a){ vec2 n = vec2(cos(-a),sin(-a)); return p - 2.*min(0.,dot(p,n))*n; }\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// 3d sdf functions\nfloat box(in vec3 p, in vec3 s, in float r) { return length(max(abs(p) - s,0.)) - r; }\nfloat rcyl(in vec3 p, in float ra, in float rb, in float h) { vec2 d = vec2(length(p.xz) - 2.*ra+rb, abs(p.y) - h); return min(max(d.x,d.y),0.) + length(max(d,0.)) - rb; }\nfloat cyl(in vec3 p, in float h, in float r) { vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r); return max(length(max(abs(p.y) - h,0.)) - .01, length(p.xz) - r) - .01;}\n\nfloat wagon(in vec3 p, in float hadPanto) {\n    vec3 cabineS = vec3(2.5,.66,.5);\n    vec3 cabineP = p+ vec3(0.,cos(t*40.)*.002,0.);// + vec3(0.,cos(t*40.)*.00,0.)\n    float cabine = max(box(cabineP, cabineS, .07), -cabineP.y - .32);\n    float cabineInner = -max(box(cabineP, cabineS*0.95, .07),-p.y - .3);\n    \n    float window = -min(\n        box(vec3(mod(cabineP.x,.628) - .314,cabineP.yz) - vec3(0.,.275,0.), vec3(.2,.15,1.), .03),\n        box(cabineP.zyx - vec3(0.,.275,0.), vec3(.2,.15,3.), .03)\n    );\n    cabine = max(cabine, window);\n    \n    float cabinePart2 = max(rcyl(cabineP.yxz,.45,.07,2.5), -cabineP.y + .69);\n    cabinePart2 = min(cabinePart2, max(box(cabineP, cabineS, .085), abs(cabineP.y) - .02));\n    \n    vec3 wheelsP = vec3(p.y + .525,abs(p.z) - .35,abs(abs(p.x) - 2.) - .25);\n    float wheels = max(cyl(wheelsP, 0.05, .15),-cyl(wheelsP - vec3(0.,0.1,0.), 0.06, .13));\n    wheels = min(wheels,box(wheelsP - vec3(.1,.1,.0),vec3(.08,.04,.25),.001));\n    wheels = min(wheels,cyl(wheelsP + vec3(0.,.05,0.), -0.002, .175));\n    vec3 attachesP = wheelsP.yzx - vec3(0.,0.,0.1);\n    float attaches = min(cyl(attachesP,.5,.04),cyl(attachesP - vec3(0.,.5,0.),.001,.08));\n    attaches = min(attaches,box(p + vec3(0.,.4,0.), vec3(1.35,0.075,0.45), 0.05));\n    wheels = min(wheels,attaches);\n    \n    vec3 pantoP = p + vec3(0.,-.92,0.);\n    float panto = box(pantoP,vec3(.2,.05,.2),.01);\n    vec3 pantoArmP = vec3(abs(pantoP.x) - .15,abs(pantoP.y - .22) - .1,abs(pantoP.z) - .1);\n    vec3 pantoArm2P = vec3(abs(pantoP.x) - .05,pantoP.y - .4125,pantoP.z);\n    pantoArmP.xy *= rot(-P*.1);\n    panto = min(panto,box(pantoArmP,vec3(.17,.001,.001),.01));\n    panto = min(panto,max(max(max(box(pantoArm2P,vec3(.5,.01,.2),.02),abs(pantoArm2P.x) -.03),-box(pantoArm2P + vec3(0.,0.01,0.),vec3(.5,.01,.2),.02)),-pantoArm2P.y + .008));\n    \n    wheels = min(wheels,mix(panto,10e9,hadPanto));\n    \n    float d = min(min(cabine,wheels),cabinePart2);\n    d = max(d, cabineInner);\n    \n    wagonId = d == window ? 2\n        : d == cabineInner ? 4\n        : d == cabine ? 1\n        : d == wheels ? 2\n        : 3\n    ;\n    return d;\n}\n\nfloat rails(in vec3 p) {\n    vec3 railsP = vec3(0.,p.y,abs(p.z) - .37) + vec3(0.,0.745,0.);\n    float rails = min(box(railsP,vec3(.1,.04,.02),.01),box(vec3(railsP.x,abs(railsP.y) - .04,railsP.z),vec3(.1,.01,.04),.005));\n    float traverses = box(vec3(mod(p.x,.5) - .25,p.y + .846,p.z),vec3(.08,.04,.5),.001);\n    \n    float sol = (p.y + mix(.86,10e2,isMagicalWorld));\n    \n    float piloneEcart = 15.;\n    vec3 pilonesP = vec3(mod(p.x,piloneEcart) - piloneEcart*.5,p.yz) - vec3(0.,0.5,.8);\n    float pilones = box(vec3(abs(pilonesP.x) - .05,pilonesP.y,abs(pilonesP.z) - .05),vec3(.0015,1.5,.0015),.01);\n    vec3 pilonesMeshP = vec3(pilonesP.x,abs(mod(pilonesP.y,.25) - .125) - .06,pilonesP.z);\n    vec3 pilonesMeshP2 = pilonesMeshP.zyx;\n        pilonesMeshP.x = pilonesMeshP.x*sign(pilonesMeshP.z); pilonesMeshP2.x = pilonesMeshP2.x*sign(pilonesMeshP2.z);\n        pilonesMeshP.xy *= rot(P*.15); pilonesMeshP2.xy *= rot(P*.15);\n        pilonesMeshP.z = abs(pilonesMeshP.z) - .05; pilonesMeshP2.z = abs(pilonesMeshP2.z) - .05;\n    pilones = min(pilones,max(\n        min(box(pilonesMeshP,vec3(.15,.002,.002),.001),box(pilonesMeshP2,vec3(.15,.002,.002),.001)),\n        abs(-pilonesP.y) - 1.5)\n    );\n    vec3 catP = pilonesP + vec3(0.,-1.2,.8);\n    vec3 cat2P = catP + vec3(0.,0.3,-.28);\n    catP.yz = fold(catP.yz,-.25); catP.z -= .25;\n    pilones = min(pilones,box(catP,vec3(.001,.001,.6),.005));\n    pilones = min(pilones,cyl(vec3(catP.y,abs(catP.z - .45) - .02,catP.x),-.01,.02));\n    pilones = min(pilones,box(cat2P,vec3(.001,.001,.26),.005));\n    pilones = min(pilones,box(cat2P + vec3(0.,0.025,0.25),vec3(piloneEcart,0.001,0.001),.005));\n    float cableCurve = cord(pilonesP.x, 0.002, piloneEcart);\n    pilones = min(pilones,box(cat2P + vec3(0.,-.25 - cableCurve,0.25),vec3(piloneEcart,0.001,0.001),.001));\n    float vertPos = .125 + cableCurve*.4;\n    pilones = min(pilones,box(vec3(mod(cat2P.x,1.) - .5,cat2P.y - vertPos*.5 - .02,cat2P.z + .25),vec3(.0,vertPos,.0),.005));\n    rails = min(rails,pilones);\n    \n    float d = min(min(rails,traverses),sol);\n    railsId = d == rails ? 1 : d == traverses ? 2 : 3;\n    return d;\n}\n\n// function for hills heightmap\nfloat deniv(in vec2 p) {\n    vec2 pp;\n    p *= rot(P*.125);\n    return cos(p.x*.1)*1.2 + sin(pp.x*.81)*.05 + cos(p.y*0.2);\n}\n\n// main sdf function\nfloat df(in vec3 p) {\n    p.yz *= rot(P*-0.030);\n    p.xz *= rot(P*0.418);\n    p = p.zyx;\n    p.x -= t*10.;\n    mapGlobal = p;\n    p.yz *= rot((P*.125 + P*cos(p.x*.025))*isMagicalWorld);\n    \n    float aaaa= p.y;\n    float dBtwWagons = 5.56, dBtwWagonsH = dBtwWagons*.5;\n    float tSpeed = t*15. + cos(t*.55)*10.;\n    \n    float pxWagon = p.x + tSpeed;\n    float wagonNo = floor(pxWagon/dBtwWagons);\n    float pxDeniv = wagonNo*dBtwWagons + dBtwWagonsH - tSpeed;\n    vec3 wagonP = vec3(mod(pxWagon,dBtwWagons) - dBtwWagonsH,p.y + deniv(vec2(pxDeniv,p.z)),p.z);\n    \n    float pyWshifted = deniv(vec2(pxDeniv - dBtwWagonsH,p.z)) - deniv(vec2(pxDeniv + dBtwWagonsH,p.z));\n    wagonP.xy *= rot(atan(pyWshifted/dBtwWagons));\n    \n    p.y += deniv(p.xz);\n    \n    float wagon = wagon(wagonP,mod(wagonNo,3.));\n    float rails = rails(p);\n    \n    float d = min(rails,wagon);\n    \n    if(d == wagon) railsId = 0;\n    mapTravel = vec3(pxWagon,wagonP.yz);\n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,mix(.001,.1,isMagicalWorld)); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\n// raymarching loop\n#define MAX_D 150.\n#define LIM .001\n#define MAX_IT 80\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    vec3 p = c;\n    int it;\n    bool hit = false;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(p);\n        if(d < LIM) { hit = true; break; }\n        if(distance(c,p) > MAX_D) break;\n        p += d*r;\n        it = i;\n    }\n    rmRes res; res.pos = p; res.it = it; res.hit = hit;\n    return res;\n}\n\n\n// 2d (cheap) starfield functions\nfloat sq(in vec2 st, in vec2 s) { return length(max(abs(st) - s, 0.)) - .001; }\nfloat star1(in vec2 st) { return max(abs(st.x)*abs(st.y) - .001,length(abs(st)) - .5); }\nfloat star2(in vec2 st) { return length(max(abs(st.y) + .02,0.)*max(abs(st.x) + .02,0.)) - .01; }\nfloat star3(in vec2 st) { return abs(length(st) - .4) - .03; }\nfloat star4(in vec2 st) { return min(sq(st,vec2(.5,.05)),sq(st,vec2(.05,.5))); }\nfloat star5(in vec2 st) { return abs(st.x) + abs(st.y) - .125; }\nfloat starSel(in vec2 st, in float sel) { st.x -= sel; return max(min(star1(st),min(star2(st + vec2(1.,0.)),min(star3(st + vec2(2.,0.)),min(star4(st + vec2(3.,0.)),star5(st + vec2(4.,0.)))))),(length(vec2(st.x + sel,st.y)) - .5)); }\nvec3 starField(in vec2 st) {\n    st *= 80.;\n    float d = starSel((fract(st) - .5)*1.5,floor(rand(floor(st))*100.));\n    return mix(vec3(1.),vec3(0.122,0.056,0.305),step(0.02,d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy - .5;\n    t = mod(iTime,240.)*-1.;\n    \n    isMagicalWorld = anim1(t*.025 + (st.x + .5)*.015,.1);\n    \n    vec3 c = vec3(2.,1.,-5.);\n    vec3 r = normalize(vec3(st,.65));\n    r.xz *= rot(.5*(m.x));\n    r.yz *= rot(.5*(m.y));\n    rmRes res = rm(c,r);\n    \n    vec3 skyColor = mix(vec3(.529,.807,.98),vec3(6.),isMagicalWorld);\n    vec2 bgMapPos = vec2(atan(r.x,r.z),r.y);\n    vec3 color = mix(skyColor,starField(bgMapPos + .015*t),isMagicalWorld);\n    color = mix(vec3(0.980,0.724,0.969)*1.2,color,clamp(bgMapPos.y*2.2 + 1.5,0.,1.));\n    \n    if(res.hit) {\n        vec3 n = normal(res.pos);\n        vec3 l = normalize(vec3(-0.387,0.666,0.087));\n        \n        float wagonColSel = mod(floor(mapTravel.x/5.56),5.)/5.;\n        color = wagonId == 1 ? hsv2rgb(vec3(.3 + wagonColSel,.8,1.))\n            : wagonId == 2 ? vec3(.2)\n            : wagonId == 4 ? vec3(0.109,0.271,0.500)\n            : wagonId == 3 ? vec3(.95)\n            : color;\n        color = railsId == 1 ? vec3(.5)\n            : railsId == 2 ? vec3(0.635,0.324,0.169)\n            : railsId == 3 ? vec3(0.498,.9,0.1)\n            : color;\n        \n        rmRes resShadow = rm(res.pos - r*.004,l);\n        if(resShadow.hit) color = mix(color*clamp(step(.4,-skyColor),0.4,1.),color,isMagicalWorld);\n        \n        color = mix(color,SpectrumPoly(clamp(.5+.5*cos(dot(n,-r)*8. + t),0.,1.)),isMagicalWorld);\n    \tskyColor = SpectrumPoly(fract(mapGlobal.x*.015))*mix(3.,30.,isMagicalWorld);\n        color += distance(res.pos,c)*.025;\n    }\n    color += pow(float(res.it)/float(MAX_IT),2.)*skyColor;\n\n    fragColor = vec4(color - pow(length(st)*.75,2.),1.0);\n}", "image_inputs": [{"id": "4lBGDK", "previewfilepath": "https://soundcloud.com/teetow/gazela-astral-train-edit", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/teetow/gazela-astral-train-edit", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSfWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 364, 387, 387, 451], [452, 452, 500, 500, 551], [552, 552, 583, 583, 674], [676, 695, 726, 771, 1198], [1199, 1199, 1224, 1224, 1342], [1344, 1383, 1410, 1410, 1478], [1479, 1479, 1501, 1501, 1546], [1548, 1568, 1613, 1613, 1654], [1655, 1655, 1716, 1716, 1826], [1827, 1827, 1873, 1873, 1996], [1998, 1998, 2041, 2041, 4124], [4126, 4126, 4150, 4150, 6256], [6258, 6290, 6314, 6314, 6414], [6416, 6437, 6458, 6458, 7399], [7401, 7401, 7425, 7425, 7562], [7564, 7684, 7716, 7716, 8027], [8030, 8064, 8097, 8097, 8143], [8144, 8144, 8169, 8169, 8232], [8233, 8233, 8258, 8258, 8330], [8331, 8331, 8356, 8356, 8393], [8394, 8394, 8419, 8419, 8474], [8475, 8475, 8500, 8500, 8539], [8540, 8540, 8581, 8581, 8772], [8773, 8773, 8801, 8801, 8954], [8956, 8956, 9011, 9011, 10753]]}
{"id": "WtSfzh", "name": "Spaceless", "author": "JacobC", "description": "Faking IL/GI with ray marching.\nYou can move the camera by clicking the canvas and drag with the mouse", "tags": ["raymarching", "ao", "il"], "likes": 10, "viewed": 109, "published": "Public", "date": "1598651789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Spaceless\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 icol;\n    float ao;\n};\n\nfloat torus(in vec3 p, in vec2 r)\n{\n    vec3 c = vec3(0.);\n    c.xz = p.xz / length(p.xz) * r.x;\n    return length(p - c) - r.y;\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat line(in vec3 p, in vec2 r)\n{\n    vec3 x = vec3(1., 0., 0.);\n    float t = clamp(dot(p, x) / dot(x, x), -r.x*.5, r.x*.5);\n    return length(p-x*t) - r.y;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 3.5, 9.);\n    s = map(s, 1., .7, 1.8);\n    return mat\n        (\n            min(a.depth, b.depth),\n            a.depth < b.depth ? a.col : b.col,\n            a.icol * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s),\n            a.ao * ao\n        );\n}\n\n#define op0 vec3(0, 1.5, 0)\n#define op1 vec3(sin(iTime) + 2., 0., 0.)\n#define op2 vec3(0, -1.5, 0)\n#define op3 vec3(-sin(iTime) - 2., 0., 0.)\n\n\nmat scene(in vec3 p)\n{    \n    mat o0 = mat(line(p - op0, vec2(2, .5)), vec3(1, .0, .5), vec3(1), 1.);\n    mat o1 = mat(sphere(p - op1, 1.), vec3(1), vec3(1), 1.);\n    mat o2 = mat(torus(p - op2, vec2(1.5, .5)), vec3(0, .5, 1), vec3(1), 1.);\n    mat o3 = mat(cube(p - op3, vec3(1.), .5), vec3(.5, 1, 0), vec3(1), 1.);\n    \n    mat o = uop(o1, o3);\n    o = uop(o, o2);\n    o = uop(o, o0);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define NUM_STEPS 99\n#define MIN_DIST .01\n#define MAX_DIST 64.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n            return mat(t, s.col, s.icol, s.ao);\n        if (t > MAX_DIST)\n            return mat(t, vec3(-1.), vec3(-1.), -1.);\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2.\n#define sk vec3(.5, .7, 1)\n#define gd vec3(1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\tvec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            float sn = ms.x * 6.283184;\n            \n            vec3 o = vec3(3, 3, 6);\n            if (iMouse.z > 0.)\n            \to = vec3(sin(sn), ms.y, cos(sn)) * 8.;\n            vec3 t = vec3(0.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                back = mix(gd, sk, n.y);\n                col += m.col * m.icol * m.ao * back;\n            }\n            else\n                col += back;\n                        \n            f_col += col;\n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSfzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 254, 289, 289, 384], [386, 386, 420, 420, 448], [450, 450, 493, 493, 556], [558, 558, 592, 592, 718], [720, 720, 767, 767, 815], [817, 817, 846, 846, 1164], [1310, 1310, 1332, 1332, 1718], [1720, 1720, 1744, 1744, 1924], [1990, 1990, 2025, 2025, 2359], [2361, 2361, 2407, 2407, 2552], [2615, 2615, 2672, 2672, 3792]]}
{"id": "wtSGRw", "name": "simple ray marcher pew", "author": "Teppich", "description": "sdfs <3", "tags": ["rayssdf"], "likes": 2, "viewed": 67, "published": "Public", "date": "1597260242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n    vec3 t = abs(p) - b;\n\treturn max(max(t.x, t.y), t.z);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1.0, 1.0)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\nfloat mapX(vec3 p) {\n    float d = distance(p-vec3(0.0, sin(iTime)/3., 0.0), vec3(-1, 0, -5)) - min(abs(sin(iTime)), 0.1);     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p-vec3(0.0, sin(p.x), 0.0), vec3(2, 0, -3)) - 1.);    // second sphere\n    d = min(d, distance(p-vec3(sin(iTime)/2.,0.,0.), vec3(-2, 0, -2)) - 1.);   // and another\n    d = min(d, fBoxCheap(sin(p)-vec3(abs(sin(iTime)), 0.0, 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fBoxCheap(cos(p)+vec3(abs(sin(iTime)), -5., 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fCylinder(p, 0.1, 0.1));\n    float pew;\n    if(int(iTime) % 16 < 8)\n        pew = clamp(sin(iTime),0.,1.)/10.0;\n    else\n        pew = clamp(sin(iTime),-1.,0.)/10.0;\n    d = min(d, 300.0 * fBlob(p+ vec3(-pew, min(sin(iTime), PI/2.0), pew+3.)));\n    //d = min(d, p.y + 1000. * sin(iTime));                            // horizontal plane at y = -1\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = distance(p-vec3(0.0, sin(iTime)/3., 0.0), vec3(-1, 0, -5)) - min(abs(sin(iTime)), 0.1);     // sphere at (-1,0,5) with radius 1\n    d = min(d, distance(p-vec3(0.0, sin(p.x), 0.0), vec3(2, 0, -3)) - 1.);    // second sphere\n    d = min(d, distance(p-vec3(sin(iTime)/2.,0.,0.), vec3(-2, 0, -2)) - 1.);   // and another\n    d = min(d, fBoxCheap(sin(p)-vec3(abs(sin(iTime)), 0.0, 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fBoxCheap(cos(p)+vec3(abs(sin(iTime)), -5., 0.0), min(vec3(0.3, 0.3 + cos(iTime)/4.0,1), 0.8)));\n    d = min(d, fCylinder(p, 0.1, 0.1));\n    float pew;\n    if(int(iTime) % 16 < 8)\n        pew = clamp(sin(iTime),0.,1.)/10.0;\n    else\n        pew = clamp(sin(iTime),-1.,0.)/10.0;\n    d = min(d, 300.0 * fBlob(p+ vec3(cos(iTime), min(sin(iTime), PI/2.0), pew+3.)));\n    //d = min(d, p.y + sin(iTime));                            // horizontal plane at y = -1\n    return d;\n}\n\n// Calculate the normal by taking the central differences on the distance field.\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 0, 1) + vec3(sin(iTime)/32.,cos(iTime)/16.,0);    // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n\n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    for (int i = 0; i < 256; i++) {\n        \n        if(int(iTime) % 32 < 16)\n            h = mapX(ro + rd * t +vec3(sin(iTime),sin(iTime)/cos(iTime),sin(iTime)));\n        else\n            h = map(ro + rd * t +vec3(sin(iTime),sin(iTime)/cos(iTime),sin(iTime)));\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - p, light - p);\n        \n        //fragColor = vec4(vec3(pow(dif, 0.4545)), 1.);\n\tif(int(iTime) % 8 < 4)\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1.);\n    else\n        fragColor = vec4(vec3(pow(dif, 0.4545), (pow(dif, abs(sin(0.4545*(iTime))))), pow(dif, 0.4545)), 1);     // Gamma correction\n\n        \n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 108, 141, 153, 213], [215, 215, 263, 263, 337], [339, 443, 464, 464, 841], [843, 843, 863, 863, 1795], [1797, 1797, 1816, 1816, 2746], [2748, 2829, 2857, 2857, 3052], [3054, 3054, 3109, 3109, 4585]]}
{"id": "wtsyzj", "name": "Circles Lines", "author": "MonsieurSoleil", "description": "Some aesthetics researchs.", "tags": ["raymarching"], "likes": 7, "viewed": 125, "published": "Public", "date": "1596445054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\nfloat gg = 0.0;\n\nmat2 rot(float a)\n{\n \tfloat ca = cos(a);\n    float sa = sin(a);\n    \n    return mat2(ca, -sa, sa, ca);\n}\n\nstruct matter\n{\n \tfloat m;\n    int type;\n};\n    \nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tp = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat lineCircle(vec3 p, float s)\n{\n    float mat01;\n\n    mat01 = sphere(p, s);\n\n    mat01 = max(mat01, -box(p + vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n    mat01 = max(mat01, -box(p - vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n\n    mat01 = max(mat01, -sphere(p, s*0.996));\n    \n    return mat01;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\n\nvec3 opRepLim( vec3 p, in vec3 c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c), -l, l);\n    return q;\n}\n\nfloat opRepLim( float p, in float c, in float l)\n{\n    float q = p-c*clamp(round(p/c), 0.0, l);\n    return q;\n}\n\nfloat repeat(float p, float repeat)\n{\n    return (fract(p/repeat-0.5) - 0.5) * repeat;\n}\n\nmatter map(vec3 p)\n{\n \tmatter mat;\n    vec3 p01 = p;\n    vec3 p02 = p;\n    \n    \n    p01.z -= cos(iTime);\n    p01.z = opRepLim( p.z , 0.04 + 0.02 * abs(sin(iTime * 0.01)), 30.0);\n   \n    p01.y += sin(p.z * 4.0) * 0.05;\n    p01.x += sin(p.z * 5.0 + iTime) * 0.08;\n\n\tp02.z = opRepLim( p.z , 0.03 + 0.03 * abs(cos(iTime * 0.01)), 30.0);\n    p02.y += sin(p.z * 7.0 * sin(iTime * 0.03)) * 0.25;\n    p02.x += sin(p.z * 22.0 * cos(iTime * 0.03)) * 0.28;\n\n    mat.m = lineCircle(p01, 1.0 + clamp((p.z * 0.06), 0.0, 2.0));\n    mat.m = min(mat.m, lineCircle(p02 + vec3(0.1, 0.0, 0.0), 1.0 + clamp((p.z * 0.10), 0.0, 2.0)));\n    mat.m = min(mat.m, lineCircle(p02 - vec3(0.1, 0.0, 0.0), 1.0 + clamp((p.z * 0.10), 0.0, 2.0)));\n    \n   \tmat.m = min(mat.m, lineCircle(p02 - vec3(0.2, 0.0, 0.0), 1.0 + clamp((p.z * 0.50), 0.0, 2.0)));\n    mat.m = min(mat.m, lineCircle(p02 - vec3(0.2, 0.0, 0.0), 1.0 + clamp((p.z * 0.50), 0.0, 2.0)));\n    \n    gg += 0.155/(0.15+abs(mat.m));\n    \n    return mat;\n}\n\nvec3 normals(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n    return normalize(map(p).m - vec3(map(p - uv.xyy).m, map(p - uv.yxy).m, map(p - uv.yyx).m));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 l = normalize(vec3(3.0, 5.0, 0.0));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n        \n    vec3 o = vec3(cos(1.5) * 4.0, 0.2, sin(1.5) * 4.0), t = vec3(0.0);\n    vec3 fr = normalize(t - o);\n    vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n    vec3 up = normalize(cross(fr, ri));\n    vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n    vec3 p = o +dir * 0.2;\n    \n    matter mat;\n    float shad = 0.0, d = 0.0;\n    \n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 200; ++i)\n    {\n\n     \tmat = map(p);\n        mat.m = abs(mat.m);\n\n        if(mat.m < 0.00002)\n        {\n            \n            mat.m = 0.1;\n\n\n            break;\n            \n        }\n        \n        col += pow(gg * 0.0065, 8.0) * vec3(0.5);\n        \n        p += dir * mat.m * 0.5;\n        d += mat.m * 0.5;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 186, 205, 205, 290], [341, 341, 372, 372, 400], [402, 402, 429, 429, 484], [486, 486, 521, 521, 819], [821, 821, 860, 860, 939], [941, 941, 977, 977, 1055], [1058, 1058, 1104, 1104, 1163], [1165, 1165, 1215, 1215, 1276], [1278, 1278, 1315, 1315, 1366], [1368, 1368, 1388, 1388, 2349], [2351, 2351, 2373, 2373, 2502], [2504, 2504, 2561, 2561, 3542]]}
{"id": "WtXBRj", "name": "My Shader - In Progress", "author": "PierceV32", "description": "My Shader", "tags": ["shader"], "likes": 3, "viewed": 67, "published": "Public", "date": "1597202268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//THIS CODE HAS BEEN MODIFIED FROM ITS ORIGINAL SOURCE (THE ORIGINAL IS NOT BY ME)\n\n\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed 0.0  //disk rotation speed\n\n#define _Steps  0. //disk texture layers\n#define _Size 1.1 //size of BH\n\n#define _MaxDistance 15.0\n\n//#define _BHSize = 10.0\n\nfloat hash(float x){ return fract(sin(x)*152754.742);}\n//float hash(vec2 x){\treturn hash(x.x + hash(x.y));}\n\n//float hash(float x){ return fract(sin(x)*15.0); }\nfloat hash(vec2 x){\treturn hash(x.x + hash(x.y)); }\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;\t\n    float b = mix(bl, br, fr.x);\t\n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\n/*bool isInBox(vec3 pos, vec3 boxPos, vec3 box)\n{\n    bool isInBox = true;\n    \n\tif (pos.x )\n        \n    return isInBox;\n}*/\n\nfloat sdSphere(vec3 pos, float radius, vec3 spherePos)\n{\n    //if (abs(pos.x - spherePos.x))\n    return length(pos-spherePos) - radius;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos, in vec3 spherePos)\n{\n    float M_PI = 3.1416;\n\tvec3 p = pos-spherePos;\n\tfloat phi = atan(p.z, p.x);\n\tfloat theta = asin(p.y);\n\tfloat u = 1.0 - (phi + M_PI) / (2.0 * M_PI);\n\tfloat v = (theta + M_PI / 2.0) / M_PI;\n\treturn vec2(u,v);\n}\n\n\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*3., 100.); //(poor quality) \"stars\" created from value noise\n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    //vec4 nebulae = texture(iChannel0, (uv*1.5 ));\n    //nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    //nebulae.xyz *= 0.25;\n    \n    /*nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n    nebulae*= nebulae;\n \n\tnebulae.xyz += stars;*/\n\t//return vec4(stars, 1.0);\n    if (brightness < 0.00) { brightness = 0.00; }\n    return vec4(brightness, brightness, brightness, 1.0);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 raymarch(vec3 ray, vec3 camPos)\n{   \n    \n    vec3 BHPos = vec3(-2.0,0.0,0.0);\n    vec3 spherePos = vec3(2.0,0.0,0.0);\n    vec3 spherePos2 = vec3(0.0,0.0,2.0);\n    vec3 spherePos3 = vec3(0.0,0.0,-2.0);\n    \n    int steps = 7000;\n    float stepSize = 0.05;\n    float BHRadius = 0.14;\n    float sphereRadius = 0.25;\n    float sphereRadius2 = 0.1;\n    float sphereRadius3 = 0.25;\n    \n    vec3 position = camPos;\n    //position -= float(sphereSteps)*ray*0.5; \n    \n    vec4 color = vec4(0.0);\n    \n    for(int i = 0; i < steps; i++)\n    {              \n        \n        float dotpos = dot(position,BHPos);\n        float dist = length(BHPos-position);\n        float invDist = 1.0/dist; //1/distance to BH\n        //float centDist = dotpos * invDist; \t//distance to BH\n        float centDist = dist;\n        float stepDist = 1.0; //0.92  //conservative distance to disk (y==0)   \n        float farLimit = centDist * 1.5; //limit step size far from to BH\n        float closeLimit = centDist*BHRadius + BHRadius/2.0*centDist*centDist*(1./_Size); //limit step size closse to BH\n        stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n        float invDistSqr = invDist * invDist;\n        float forceK = 0.007; //0.625;\n        float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n        ray = normalize(ray - (bendForce * invDist )*position);  //bend ray towards BH\n\n        position += stepSize * ray;\n        \n        dist = length(BHPos-position);\n        \n        float sphDist = sdSphere(position, sphereRadius, spherePos);\n        float sphDist2 = sdSphere(position, sphereRadius2, spherePos2);\n        float sphDist3 = sdSphere(position, sphereRadius3, spherePos3);\n        \n        if(dist < _Size*BHRadius) //ray sucked in to BH\n        {\n            color = vec4(0.0, 0.0, 0.0, 1.0);\n        \treturn color;\n        }\n\n        if(dist >= _MaxDistance || i == steps-1) //ray escaped BH\n        {     \n            color = background(ray);\n            //color = vec4(0.0);\n            return color;\n        }\n        \n        if (dist >= _Size*BHRadius && dist < _Size*0.5 && abs(position.y-BHPos.y) < _Size*0.005) //ray hit accretion disk\n        {         \n            color = vec4(1.0,1.0,0.0,1.0);\n            return color;\n            //vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n            //pos.y = 0.;\n            //pos += abs(_Size * 0.001 /ray.y) * ray;  \n            //col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n        }\n            \n        if (sphDist < sphereRadius)\n        {       \n            /*while (sphDist < sphereRadius) {\n        \t\tspherePos -= ray * sphereRadius*0.1; \n                sphDist = sdSphere(position, sphereRadius, spherePos);\n        \t}*/\n            vec3 lightDir = normalize(spherePos-spherePos2);\n            float lightDot = dot(spherePos-position,lightDir)+0.2;\n            color = vec4(0.0, lightDot, lightDot, 1.0);  \n        \treturn color;   \n        }\n        \n        if (sphDist2 < sphereRadius2) \n        {           \n            color = vec4(1.0, 1.0, 1.0, 1.0);\n            \n            //vec2 uv = getSphereUV(position, spherePos2);\n            //float random = rand(uv);\n            //color = vec4(random, random, random, 1.0);\n            //color = vec4(random, 0.0, 0.5, 1.0);\n            \n            /*float h = max(0.0, 1.4 - y - pow(abs(x - 0.5), 3.0));\n\t\t\tcolor.r = pow(h, 3.0);\n\t\t\tcolor.g = pow(h, 7.0);\n\t\t\tcolor.b = 0.2 + pow(max(0.0, h - 0.1), 10.0);*/\n        \treturn color;   \n        }\n        \n        else if (sphDist3 < sphereRadius3) \n        {           \n            vec3 lightDir = normalize(spherePos3-spherePos2);\n            float lightDot = dot(spherePos3-position,lightDir)+0.2;\n            color = vec4(lightDot, 0.0, 0.0, 1.0);  \n            \n            /*vec2 uv = getSphereUV(position, spherePos3);\n            //color = vec4(uv.x, 0.0, uv.y, 1.0);\n            color = texture(iChannel0, vec2(uv.x, uv.y));\n            color = vec4(color.r*lightDot, color.g*lightDot, color.b*lightDot, 1.0);\n        \t*/\n\t\t\treturn color;   \n        }\n        \n    } \n \n    //o.rgb = clamp(o.rgb - 0.005, 0., 1.);\n    //return o ;\n    \n \treturn color;   \n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 rayDir = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 camPos = vec3(0.0,0.0,-10.0);  //-12.0\n        //vec3 rayDir = normalize(vec3(0.0, 0.0, 1.0));\n        vec2 angle = vec2(0.07*iTime,0.14); //*iTime     \n        //float dist = length(camPos);\n        Rotate(camPos,angle);\n        Rotate(rayDir,angle);\n\n        vec4 col = vec4(1.0, 0.0, 1.0, 1.0); \n        vec4 glow = vec4(0.); \n        vec4 outCol = vec4(100.);\n        \n        //vec4 sphereColor = raymarchSphere(rayDir, camPos, spherePos);\n        //outCol = sphereColor;\n        //return;\n        \n        vec4 sphereColor = raymarch(rayDir, camPos);\n        colOut = sphereColor;\n        \n        return;\n\n        //for (int h = 0; h < 32; h++) //reduces tests for exit conditions (to minimise branching)\n            //{\n                /*float dotpos = dot(BHPos,camPos);\n                float dist = length(BHPos-camPos);\n                float invDist = 1.0/dist; //1/distance to BH\n                float centDist = dotpos * invDist; \t//distance to BH\n                float stepDist = 0.92 * abs(pos.y /(pos.y));  //conservative distance to disk (y==0)   \n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n\t\t\t\t\n                float invDistSqr = invDist * invDist;\n                float forceK = 0.025; //0.625;\n                float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n                rayDir =  normalize(rayDir - (bendForce * invDist )*pos);  //bend ray towards BH\n                pos += stepDist * rayDir; */\n                \n                //glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            //}\n\n            /*float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.1) //ray sucked in to BH\n            {\n                //outCol =  vec4( col.rgb * col.a + glow.rgb *(1.-col.a ) ,1.) ;\n                outCol = vec4(1.0);\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {     \n                outCol = vec4(1.0, 0.0, 0.0, 0.5);\n                //vec4 bg = background(ray);\n                //outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);\n                break;\n            }\n            \n            else  //ray hit accretion disk\n            {           \n                vec4 sphereColor = raymarchSphere(rayDir, camPos, spherePos);\n                outCol = sphereColor;\n                //col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }*/\n        \n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 307, 327, 327, 361], [416, 468, 487, 487, 519], [521, 521, 565, 565, 915], [917, 1044, 1100, 1136, 1181], [1183, 1183, 1219, 1240, 1463], [1465, 1465, 1515, 1515, 1727], [1731, 1731, 1758, 1758, 2654], [2656, 2656, 2677, 2677, 2749], [2751, 2751, 2789, 2789, 6955], [6958, 6958, 7004, 7004, 7158], [7160, 7160, 7214, 7214, 10707]]}
{"id": "WtXBRl", "name": "Aperiodic Penrose Tiling", "author": "dr2", "description": "Penrose tiling with two rhombs, where tile color depends on rhomb shape and  orientation; click in upper/lower half to see corresponding atoms or  big/small coloring.\n", "tags": ["quasicrystal", "symmetry", "pentagon"], "likes": 13, "viewed": 480, "published": "Public API", "date": "1597388246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Aperiodic Penrose Tiling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Based on an old program that used OpenGL to draw quads; that was much more \n efficient than the present pixel-based version and allowed much larger grids.\n Using de Bruijn's projection method [Math. Proc. A 84 (1981) 39,53]\n\n Projection method also used by knighty (https://www.shadertoy.com/view/XdtBzH) to\n produce a symmetric pattern, but not a full aperiodic tiling.\n An alternative (and faster) substitution method was used by tomkh\n (https://www.shadertoy.com/view/4t2XWG).\n There are other examples (search: penrose) that consider the related kite-and-dart tiles.\n*/\n\n#define BIG  0  // set =1 for larger grid - more work!!!\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 VToRMat (vec3 v, float a);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nfloat tCur;\nint nFrame;\nbool showPoly, rhomCol;\nconst float pi = 3.1415927;\n\nbool InTri (vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n  vec3 s;\n  vec2 v10, v20, p0;\n  float d;\n  v10 = v1 - v0;\n  v20 = v2 - v0;\n  d = v20.y * v10.x - v20.x * v10.y;\n  p0 = p - v0;\n  s.xy = vec2 (v20.y * p0.x - v20.x * p0.y, - v10.y * p0.x + v10.x * p0.y);\n  s = abs (vec3 (s.xy, d - s.x - s.y) - 0.5 * d);\n  return (Maxv3 (s) < 0.5 * abs (d));\n}\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col, vn, ltDir;\n  vec2 vp[5], csn[5], g, gg, mp, offset, up, vm, v[3];\n  float gam[5], gamSum, kCur[5], d, dm, di, rr, pScale, r1, r2, ic, f;\n  bool fatRom, done;\n#if BIG\n  const float kLimit = 7.;\n  pScale = 0.09;\n#else\n  const float kLimit = 4.;\n  pScale = 0.15;\n#endif\n  offset = Rot2D (vec2 (1.7, 0.), 0.05 * pi * tCur);\n  uv /= pScale;\n  uv -= offset;\n  r1 = 0.5 * sin (pi / 5.);\n  r2 = 0.5 * sin (2. * pi / 5.);\n  for (int k = 0; k < 5; k ++) csn[k] = sin (2. * pi * float (k) / 5. + vec2 (0.5 * pi, 0.));\n  gamSum = 0.;\n  for (int k = 0; k < 4; k ++) {\n    gam[k] = 0.1 * float (k + 1);\n    gamSum += gam[k];\n  }\n  gam[4] = - gamSum;\n  done = false;\n  ic = -1.;\n  for (int k1 = VAR_ZERO; k1 <= 3; k1 ++) {\n    for (int k2 = VAR_ZERO + 1; k2 <= 4; k2 ++) {\n      if (k2 >= k1 + 1) {\n        fatRom = (k2 - k1 == 1 || k2 - k1 == 4);\n        rr = fatRom ? r2 * r2 : r1 * r1;\n        ++ ic;\n        gg = - gam[k1] * csn[k2] + gam[k2] * csn[k1];\n        di = 1. / (csn[k1].x * csn[k2].y - csn[k2].x * csn[k1].y);\n        for (float kV1 = - kLimit + float (VAR_ZERO); kV1 <= kLimit; kV1 ++) {\n          kCur[k1] = kV1;\n          for (float kV2 = - kLimit + float (VAR_ZERO); kV2 <= kLimit; kV2 ++) {\n            kCur[k2] = kV2;\n            g = (gg + kV1 * csn[k2] - kV2 * csn[k1]).yx * vec2 (1., -1.);\n            for (int k = 0; k < 5; k ++) {\n              if (k != k1 && k != k2) {\n                d = dot (csn[k], g) * di + gam[k];\n                d += step (0., d);\n                kCur[k] = floor (abs (d)) * sign (d);\n              }\n            }\n            vp[0] = vec2 (0.);\n            for (int k = 0; k < 5; k ++) vp[0] += kCur[k] * csn[k];\n            vp[1] = vp[0] + csn[k1];\n            vp[2] = vp[0] + csn[k1] + csn[k2];\n            vp[3] = vp[0] + csn[k2];\n            mp = 0.25 * (vp[0] + vp[1] + vp[2] + vp[3]) - uv;\n            if (showPoly) done = (InTri (uv, vp[0], vp[1], vp[2]) ||\n               InTri (uv, vp[0], vp[3], vp[2]));\n            else done = (dot (mp, mp) < rr);\n            if (done) break;\n          }\n          if (done) break;\n        }\n      }\n      if (done) break;\n    }\n    if (done) break;\n  }\n  if (done) {\n    if (showPoly) {\n      dm = 99.;\n      vp[4] = vp[0];\n      for (int k = 0; k < 4; k ++) {\n        up = uv - vp[k];\n        v[0] = normalize (vp[k + 1] - vp[k]);\n        if (k == 0) v[1] = v[0];\n        else if (k == 1) v[2] = v[0];\n        f = dot (v[0], up);\n        d = dot (up, up) - f * f;\n        if (d < dm) {\n          dm = d;\n          vm = v[0];\n        }\n      }\n      dm = sqrt (dm);\n      if (rhomCol) col = HsvToRgb (vec3 (0.1 * ic, (fatRom ? 1. : 0.5), 1.));         \n      else col = fatRom ? vec3 (0., 1., 0.) : vec3 (1., 0., 0.);\n      col *= 0.4 + 0.6 * smoothstep (0.01, 0.03, dm);\n      vn = VToRMat (vec3 (vm, 0.), 0.12 * pi * sign (v[1].x * v[2].y - v[2].x * v[1].y) *\n         (1. - smoothstep (0., 0.15, dm))) * vec3 (0., 0., -1.);\n    } else {\n      col = vec3 (1., 1., (fatRom ? 0. : 0.5)) * (1. - smoothstep (0.9, 0.99, dot (mp, mp) / rr));\n      vn = - normalize (vec3 (mp, 0.7));\n    }\n    ltDir = normalize (vec3 (0.4, 0.6, -1.));\n    f = max (dot (vn, ltDir), 0.);\n    col = col * (0.2 + 0.8 * f * f + 0.5 * pow (max (0., dot (ltDir,\n       reflect (vec3 (0., 0., 1.), vn))), 32.));\n    col *= 0.1 + 0.9 * smoothstep (0.1, 0.9, Maxv3 (col));\n  } else col = vec3 (0.1, 0.1, 0.1);\n  return col;\n}\n\n#define AA   0 \n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  rhomCol = true;\n  showPoly = true;\n  if (mPtr.z > 0.) {\n    if (mPtr.y > 0.) showPoly = false;\n    else rhomCol = false;\n  }\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[132, 989, 1037, 1037, 1331], [1333, 1333, 1359, 1359, 4751], [4770, 4770, 4826, 4826, 5708], [5710, 5710, 5742, 5742, 6118], [6120, 6120, 6142, 6142, 6180], [6182, 6182, 6212, 6212, 6325], [6327, 6327, 6351, 6351, 6468]]}
{"id": "WtXBWf", "name": "[TWITCH] Venus Bebop", "author": "evvvvil", "description": "Venus Bebop - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "glow", "organic", "city", "island", "world", "dark", "mountain", "other", "network", "cowboy", "bebop"], "likes": 19, "viewed": 552, "published": "Public API", "date": "1597849542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Venus Bebop - Result of an improvised live coding session on Twitch\n// Vaguely inspired by the floating islands on Venus in Cowboy Bebop\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,b,bb,g,gg,tnoi; vec3 np,bp,op,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){ p = abs(p) - r; return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin( float d1, float d2, float k ){  float h = max(k-abs(d1-d2),0.0);return min(d1,d2)-h*h*0.25/k; }\nfloat smax( float d1, float d2, float k ){  float h = max(k-abs(-d1-d2),0.0);return max(-d1,d2)+h*h*0.25/k; }\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25; //MERCURTY SDF LIBRARY IS HERE OFF COURSE: http://mercury.sexy/hg_sdf/\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nfloat cy(vec3 p,vec3 r){ return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z);}\nvec2 tower( vec3 p,float flying)\n{\n    vec2 h,t=vec2(cy(p,vec3(.8,.2,1.2)),5);//BLUE CYL CUT\n    t.x=max(t.x,-(abs(abs(abs(p.y)-.4)-.2)-.1));\n    t.x=max(t.x,-(abs(p.z)-.2)); \n    h=vec2(cy(p,vec3(.5,.1,1.4)),6); //WHITE OUTTER\n    h.x=max(h.x,-(abs(p.z)-.4));\n    h.x=smin(h.x,length(abs(p)-vec3(0,1.5,1))-.4,.5);\n    h.x=smin(h.x,.6*length(abs(p.xz)-vec2(0,1))-.1+abs(p.y)*.02,.5);  \n    h.x=min(h.x,bo(p+vec3(.7,1,-2.2),vec3(2,4,1))); //FLOOR WHITE\n    t=t.x<h.x?t:h;    \n    if(flying>0.) {\n        h=vec2(bo(abs(p+vec3(.7,1,-2.))-vec3(1.6,1.-sin(tt)*2.,0),vec3(p.z*.1,p.z*.1,10)),6); //BLACK CUBES FLYING  \n        gg+=0.1/(0.1+h.x*h.x*40.);\n        t=t.x<h.x?t:h;\n    }  \n    h=vec2(cy(p,vec3(.8,.1,1.4)),3);//BLACK CYL  \n    h.x=min(h.x,bo(abs(p+vec3(.7,1,-2.))-vec3(2.,2,0),vec3(.1,2,1))); //BLACK EDGES FLOOR \n    h.x=max(h.x,-(abs(p.z)-.3));\n    t=t.x<h.x?t:h;\n    p.xy*=r2(-sin(p.y*.2)*.5);  \n    t=t.x<h.x?t:h;  \n    return t;\n}\nvec4 c=vec4(0,5,5,.2);\nvec2 mp( vec3 p)\n{\n    op=p;\n    p.x+=sin(op.z*.1+tt*.2)*2.;\n    p.z=mod(p.z+tt*2.,20.)-10.;\n    vec3 tp=p;\n    float disp=sin(p.x*.4)+cos(p.z*.2)*.5;\n    vec2 _uv=vec2(op.x,dot(op.yz+vec2(0,tt*2.),vec2(.5)));\n    tnoi=texNoise(_uv*.05).r;  \n    vec3 towp=2.1*(p-vec3(0,1.1,-1.));\n    for(int i=0;i<3;i++){\n        towp.xz=abs(towp.xz)-vec2(1.5,1);\n        towp.xz*=r2(.55);\n    }   \n    towp.xz-=1.;\n    vec2 h,t=tower(towp,0.);t.x/=2.5;  //FIRST ROUND OF TOWER KIFS\n    bp=towp; bp.xy*=r2(-.3-sin(p.y*.2+tt+op.z*.1)*.4);\n    h=vec2(.7*(length(bp.xz+vec2(-0,2.))-.1+p.y*.05)*.5,6);//LAZER\n    h.x=max(h.x,-p.y);\n    g+=0.1/(0.1+h.x*h.x*40.);   \n    t=t.x<h.x?t:h;   \n    towp.yz*=r2(.785*2.); \n    towp.xy-=vec2(1.,0.1);\n    h=tower(towp,1.);h.x/=2.5;  //SECOND ROUND OF TOWER KIFS\n    t=t.x<h.x?t:h;\n    h=vec2(length(tp)-7.+sin(p.z*.3)*1.5+tnoi*2.5,7);//TERRAIN  STARTS WITH SPHERE\n    h.x=smax(-p.y-.2+tnoi*2.,h.x,1.5);  //SMOOTH CUT SPHERE WITH PLANE\n    h.x=smax(length(tp-vec3(0,0,-1))-1.5+tnoi,h.x,1.5);   //SMOOTH SUBSTRACT SPHERE IN MIDDLE OF ISLAND\n    h.x=smin(h.x,p.y+7.+sin(op.x*.15+1.5)+sin(op.z*.3+tt*.6+3.14)*1.5+tnoi*3.,5.); //SMOOTH MIN ADD TERRAIN AT BOTTOM\n    h.x=smin(length(abs(tp.xz-vec2(2.-tnoi,-1))-4.+disp)-2.+tnoi+(abs(p.y)+5.+tnoi*2.)*0.2,h.x,1.5);//SMOOTH MIN ADD 4 SPIKEY MOUTAINS ON SIDE OF ISLAND\n    h.x=smin(length(abs(op.xy+vec2(0,1.5))-vec2(2.5+sin(op.z*.2+tt*.4)*1.,0.))-1.3+tnoi*2.+sin(op.z*10.+tt*20.)*.03+sin(op.z*.5+tt*2.)*.4,h.x,1.5);  //SMOOTH MIN ADD 2 INFINITE Z CYLINDERS\n    h.x*=0.6; pp=tp;\n    t=t.x<h.x?t:h;   \n    h=vec2(length(cos(p*.5+towp*.4+vec3(0,0,tt*2.))),6); //PARTICLES\n    h.x=max(h.x,length(p.xz)-7.);\n    g+=0.1/(0.1+h.x*h.x*200.);\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n    vec2 h,t=vec2(0.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x);\n        if(h.x<.0001||t.x>100.) break;\n        t.x+=h.x;t.y=h.y;\n    }  \n    if(t.x>100.) t.y=0.;\n    return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(16.+iTime,62.82);\n    vec3 ro=mix(vec3(1),vec3(.3,1.5,1),ceil(sin(tt*.2)))*vec3(cos(tt*.4)*9.,3.-cos(tt*.4)*1.5,-15.),\n    cw=normalize(vec3(0,-6.+sin(tt*.4)*5.,0)-ro),\n    cu=normalize(cross(cw,vec3(0,1,0))),\n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,.6)),co,fo;\n    v=vec2(abs(atan(rd.x,rd.z)),rd.y-tt*.02);\n    co=fo=vec3(.13,.1,.1)-length(uv)*.15-rd.y*.15+texNoise(v*.4).r*.3,\n    ld=normalize(vec3(-.2,.3,-.4));\n    z=tr(ro,rd);t=z.x;\n    if(z.y>0.){   \n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n        al=mix(vec3(.1,.2,0.7),vec3(.1,.6,0.8),.5+.5*sin(pp.y*2.+1.));\n        float sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n        if(z.y<5.) al=vec3(0);\n        if(z.y>5.) al=vec3(1);\n        if(z.y>6.) sp=0.,al=mix(vec3(1),vec3(.2,.4,.5),.5+.5*sin(min(-pp.y*.7+.7,2.)+.2+pp.x*.1))-tnoi*1.8;\n        float dif=max(0.,dot(no,ld)),\n        fr=pow(1.+dot(no,rd),4.);    \n        co=mix(sp+al*(a(.05)*a(.1)+.2)*(dif+s(3.)),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00002*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*vec3(.1,.2,.7)+gg*.2*vec3(.7,.2,.1),vec3(.55)),1);\n} ", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 339, 363, 363, 410], [411, 411, 428, 428, 471], [472, 472, 514, 514, 579], [580, 580, 622, 622, 689], [690, 690, 713, 713, 1004], [1005, 1005, 1029, 1029, 1082], [1083, 1083, 1117, 1117, 2023], [2047, 2047, 2065, 2065, 3778], [3779, 3779, 3807, 3807, 3998], [4088, 4088, 4145, 4145, 5433]]}
{"id": "wtXBWs", "name": "Stars to sphere morphing z", "author": "illus0r", "description": "Stars to sphere morphing", "tags": ["raymarching"], "likes": 3, "viewed": 185, "published": "Public API", "date": "1598038288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.0001\n#define PI 3.14159265\n\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float radius) { return length(p) - radius; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\n\n\n\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRay (vec3 p) {\n  p.y -= 0.6;\n  p.x = -abs(p.x);\n  p.x -= 1.;\n  p.xy *= Rot(PI / 16.);\n  p.xz *= Rot(PI / 4.);\n  return sdBox(p, vec3(.81, .8, .8));\n}\n\n\nfloat sdStar(vec3 p) {\n  float r1, r2, r3, r4;\n  r1 = r2 = r3 = r4 = 1e10;\n  r1 = sdRay(p);\n  //p.x = abs(p.x);\n  //p.xy *= Rot(PI / 3.);\n  //p.xy *= Rot(PI / 3.);\n  //p.x = abs(p.x);\n  vec3 p2 = p;\n  p2.xy *= Rot(1.9106329);\n  r2 = sdRay(p2);\n  //p.xz *= Rot(1.9106329);\n  vec3 p3 = p;\n  p3.xz *= Rot(2. * PI / 3.);\n  p3.xy *= Rot(1.9106329);\n  r3 = sdRay(p3);\n  vec3 p4 = p;\n  p4.xz *= Rot(- 2. * PI / 3.);\n  p4.xy *= Rot(1.9106329);\n  r4 = sdRay(p4);\n  return min(min(r1, r2),min(r3, r4));\n}\n\n\n\n// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\nvec2 getDist(vec3 p) {\n  p.y += 0.2;\n  p.xz *= Rot(iTime);\n  float sphere = (length(p) - 1.5) * .5;\n  float fractal = sdStar(p);\n  float scale = 0.7;\n  vec3 shift = vec3(0, -1.5, 0);\n\n  for (int i = 0; i < 1; i ++) {\n    //p.xy *= Rot(PI / 3.);\n    //p.x = abs(p.x);\n    //p.xy *= Rot(PI / 3.);\n    //p.x = abs(p.x);\n    //p /= scale;\n    //p.xy *= Rot(PI / 3.);\n    //p.xz *= Rot(PI / (4. + 2. * sin(iTime))); // normally PI / 2.\n    //p += shift;\n    //fractal = min(fractal, sdStar(p) * pow(scale, (float(i + 1))));\n\n      float r0, r1, r2, r3, r4;\n      r0 = sdStar(p);\n      r1 = r2 = r3 = r4 = 1e10;\n\n      vec3 p1 = p;\n      p1 += shift;\n      p1 /= scale;\n      p1.xz *= Rot(PI / 3.);\n      r1 = sdStar(p1);\n      //p.x = abs(p.x);\n      //p.xy *= Rot(PI / 3.);\n      //p.xy *= Rot(PI / 3.);\n      //p.x = abs(p.x);\n      vec3 p2 = p;\n      p2.xy *= Rot(1.9106329);\n      p2 += shift;\n      p2 /= scale;\n      r2 = sdStar(p2);\n      //p.xz *= Rot(1.9106329);\n      vec3 p3 = p;\n      p3.xz *= Rot(2. * PI / 3.);\n      p3.xy *= Rot(1.9106329);\n      p3 += shift;\n      p3 /= scale;\n      r3 = sdStar(p3);\n      vec3 p4 = p;\n      p4.xz *= Rot(- 2. * PI / 3.);\n      p4.xy *= Rot(1.9106329);\n      p4 += shift;\n      p4 /= scale;\n      r4 = sdStar(p4);\n      fractal = min(min(min(r0, r1 * scale), r2 * scale),min(r3 * scale, r4 * scale));\n  }\n  return vec2(mix(fractal, sphere, 0.5 + 0.5 * sin(iTime * 1.)), 0.6);\n  //return vec2(sdStar(p), 0.6);\n}\n\n\n\n\n// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n\n\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    float info = 0.;\n    //float glow = 0.;\n    float distToClosestLight = 9999999.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec2 distToClosest = getDist(ro + rd * d);\n        d += distToClosest.x;\n        info = distToClosest.y;\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n        \tbreak;\n        }\n    }\n    return vec2(d, info);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                               getDist(p - e.yxy).x,\n                               getDist(p - e.yyx).x);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // ray origin\n    vec3 ro = vec3(0, 0., -5.5);\n    float zoom = 1.100;\n    \n    // ray direction\n    vec3 rd = normalize(vec3(uv, zoom));\n    \n    vec2 rm = rayMarch(ro, rd);\n    float d = rm[0];\n    float info = rm[1];\n    \n    float color_bw = 0.;\n    vec3 color = vec3(0.);\n    if (d < MAX_DIST) {\n        vec3 n = getNormal(ro + rd * d);\n        n.zy *= Rot(iTime);\n    \tcolor = vec3( n + 1.0 );\n        color *= info;\n        //color_bw += 0.5 + dot(n, normalize(vec3(1,1,0))) / 2.;\n    }\n    //color = vec3( color_bw );\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 110, 110, 173], [175, 175, 213, 213, 242], [243, 243, 274, 274, 357], [362, 362, 408, 408, 515], [517, 517, 539, 539, 674], [677, 677, 699, 699, 1171], [1175, 1255, 1277, 1277, 2710], [2715, 2799, 2832, 2832, 3205], [3207, 3207, 3231, 3231, 3449], [3451, 3451, 3508, 3508, 4176]]}
{"id": "wtXBz2", "name": "Double ended truchet hex tiling", "author": "mrange", "description": "License CC0: Double ended truchet hextiling\nDecided to experiment a bit with double ended truchet with triangle tiles stacked inside hex tiles.\nInspired by work done by BigWings and Shane", "tags": ["2d", "truchet", "hex", "double"], "likes": 6, "viewed": 216, "published": "Public API", "date": "1597169080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Double ended truchet hextiling\n//  Decided to experiment a bit with double ended truchet with triangle tiles stacked inside hext iles.\n//  Inspired by work done by BigWings and Shane\n    \n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ORT(p)          vec2((p).y, -(p).x)\n\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst float is3     = 1.0/sqrt(3.0);\nconst vec2 cdir     = normalize(vec2(1.0, is3));\nconst vec2 flipy    = vec2(1.0, -1.0);\n\nconst vec2 coords[6] = vec2[6](\n  is3*cdir*1.0/3.0,\n  is3*cdir*2.0/3.0,\n  vec2(0.5, is3/6.0),\n  vec2(0.5, -is3/6.0),\n  is3*cdir*2.0/3.0*flipy,\n  is3*cdir*1.0/3.0*flipy\n  );\n\nconst vec2 dcoords[6] = vec2[6](\n  ORT(cdir),\n  ORT(cdir),\n  vec2(-1.0, 0.0),\n  vec2(-1.0, 0.0),\n  ORT(-cdir*flipy),\n  ORT(-cdir*flipy)\n  );\n\nconst int noCorners = 15;\nconst int corners[15*6] = int[15*6](\n  0, 1, 2, 3, 4, 5, \n  0, 1, 2, 4, 3, 5, \n  0, 1, 2, 5, 3, 4, \n  0, 2, 1, 3, 4, 5, \n  0, 2, 1, 4, 3, 5, \n  0, 2, 1, 5, 3, 4, \n  0, 3, 1, 2, 4, 5, \n  0, 3, 1, 4, 2, 5, \n  0, 3, 1, 5, 2, 4, \n  0, 4, 1, 2, 3, 5, \n  0, 4, 1, 3, 2, 5, \n  0, 4, 1, 5, 2, 3, \n  0, 5, 1, 2, 3, 4, \n  0, 5, 1, 3, 2, 4, \n  0, 5, 1, 4, 2, 3\n  );\n\nfloat hash(vec3 r)  { \n  return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); \n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 color(vec2 p, float s, float aa, vec3 col) {\n  vec2 hp = p/s;\n  vec2 hn = hextile(hp);\n  \n  vec2 pp = toPolar(hp);\n  float pn = mod1(pp.y, TAU/6.0);\n  vec2 tp = toRect(pp);\n\n  pn = mod(pn+3.0, 6.0);\n  vec3 nn = vec3(hn, pn);\n\n  float r = hash(nn);\n  int sel = int(float(noCorners)*r);\n  int off = sel*6;\n\n  const vec3 scol = vec3(0.25);\n  const vec3 bcol = vec3(1.0);\n  const float sw = 0.05;\n\n  for (int i = 0; i < 3; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];\n    \n    int c = max(c0, c1) - min(c0, c1);\n    \n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n\n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n    \n    float mi = 0.5;    \n    float mx = 0.5;    \n    \n    float rr = fract(r*27.0*float(i+1));\n    switch(c) {\n      case 1:\n        mx = 1.75;\n        break;\n      case 2:\n        mx = .95;\n        break;\n      case 3:\n        mx = 1.5;\n        break;\n      case 4:\n        mx = 0.75;\n        break;\n      case 5:\n        mx = 1.95;\n        break;\n      default:\n        break;\n    }\n    \n    float f = mix(mi, mx, rr);\n    \n    float dd = (bezier2(tp, f, p0, dp0, p1, dp1)-0.01)*s;\n    \n    vec4 sc = vec4(scol, smoothstep(-sw, sw, -dd));\n    vec4 bc = vec4(bcol, smoothstep(-aa, aa, -dd));\n\n    col = alphaBlend(col, sc);\n    col = alphaBlend(col, bc);\n  }\n  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float s = 0.45;\n  float aa = 2.0/RESOLUTION.y;\n  vec3 n;\n  vec3 col = vec3(0.0);\n  p += TIME*0.1;\n  col = color(p, s, aa, col);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBz2.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 1282, 1303, 1303, 1391], [1393, 1393, 1421, 1520, 1760], [1762, 1762, 1784, 1784, 1828], [1830, 1830, 1851, 1851, 1892], [1894, 1926, 1965, 1965, 2090], [2092, 2092, 2132, 2132, 2240], [2242, 2242, 2262, 2262, 2281], [2287, 2339, 2387, 2387, 3419], [3421, 3421, 3491, 3491, 3763], [3765, 3765, 3814, 3814, 5110], [5112, 5112, 5141, 5141, 5288], [5290, 5290, 5342, 5342, 5504]]}
{"id": "WtXBzf", "name": "Pattern In Motion", "author": "rikmazz", "description": "Simple pattern looping animation for practicing glsl basics. ", "tags": ["beginner", "glsl", "motion", "pattern"], "likes": 2, "viewed": 281, "published": "Public API", "date": "1597264903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nfloat circle_outline(in vec2 _st, in float _radius, in float _thk, in float _blur){\n    vec2 dist = _st-vec2(0.5);\n    float pct = smoothstep(_radius-_thk/2.-(_blur),\n                         _radius-_thk/2.,\n                         dot(dist,dist)*5.128) - \n        \t\tsmoothstep(_radius+_thk/2.,\n                         _radius+_thk/2.+(_blur),\n                         dot(dist,dist)*5.128);\n\treturn pct;\n}\n\nfloat sc_f = 6.;\nfloat radius = 0.476;\nfloat thk = 0.006;\nfloat blur = 0.058;\n\nfloat speed = 0.448;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= sc_f;\n    \n    float time = speed * iTime;\n    st.x += step(1., mod(st.y, 2.))*2.*smoothstep(0.,1.,(fract(time)*step(0.,sin(time*PI))));\n    st.x += (1.-step(1., mod(st.y, 2.)))*-2.*smoothstep(0.,1.,(fract(time)*step(0.,sin(time*PI))));\n    st.y += step(1., mod(st.x, 2.))*2.*smoothstep(0., 1.,(fract(time)*step(0.,sin(time*PI-PI))));\n    st.y += (1.-step(1., mod(st.x, 2.)))*-2.*smoothstep(0., 1.,(fract(time)*step(0.,sin(time*PI-PI))));\n    st = fract(st);\n    \n    float pct = circle_outline(st, radius, thk, blur);\n\n    vec3 color = vec3(0.684,0.700,0.168);\n    vec3 bg_color = vec3(0.062,0.065,0.051);\n\n    fragColor = vec4(color,1.0) * pct + vec4(bg_color,1.0) * (1.-pct);\n    // gl_FragColor = vec4(st.x, st.y, 0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 155, 155, 481], [584, 584, 641, 641, 1464]]}
{"id": "WtXBzl", "name": "Dreams", "author": "KayKay", "description": "THIS IS THE 1ST SHADER PREPARED FOR ME WHICH I GET NO IDEA OF WHAT THE CODE REALLY MEANS.\nBUT STILL TRY TO EDIT SOMETHING.", "tags": ["color"], "likes": 1, "viewed": 44, "published": "Public", "date": "1597397191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2020-08-14 / Nanjing / About 30min left to start my weekend.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 50 to 100)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.6 + 0.3*cos(iTime+uv.xyx+vec3(0,0,1));\n    if(uv.y<0.9*(1.0+sin(iTime)));\n    \n    // Output to screen\n    fragColor = vec4(col,0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXBzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 122, 175, 401]]}
{"id": "WtXfR2", "name": "Nautilus Submerging", "author": "dr2", "description": "One more page for the Nautilus Book (mouseable)", "tags": ["wave", "ocean", "reflect", "refract", "submarine", "verne"], "likes": 17, "viewed": 271, "published": "Public API", "date": "1597130268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Nautilus Submerging\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 vuPos, sunDir;\nfloat dstFar, tCur, sbLen, sbDepth, prpRot;\nint idObj;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = 0.05 * p + vec2 (0., 0.025 * tCur);\n  wAmp = 1.;\n  h = 0.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = q.xyxy + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    t4 = abs (sin (t4));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return 0.4 * h * (1. - smoothstep (0.5, 1.2, length (p - vuPos.xz)/ dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd, float u)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  ro.y *= u;\n  rd.y *= u;\n  s = 0.;\n  sLo = 0.;\n  for (int j = 0; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - u * WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 1.3 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > u * WaveHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),\n     WaveHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qe;\n  float dMin, d, rad, s, dph, suLen;\n  dMin = dstFar;\n  p.y -= sbDepth;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjCol (vec3 p, vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  p.y -= sbDepth;\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (p.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * p))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (p.y, - p.x) / pi, 2. * p.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (p.z + 1.)), smoothstep (0.01, 0.012, abs (p.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 =  (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    t = smoothstep (0.05, 0.07, length (mod (vec2 (((abs (p.x) > 0.5) ?\n       2. * p.z : 2. * p.x + 0.5), 2. * p.y + 0.5) + 0.5, 1.) - 0.5));\n    t = min (t, smoothstep (0.01, 0.012, abs (abs (length (vec2 (p.x, abs (p.z + 1.) - 0.5)) -\n       0.18) - 0.12)));\n    t = min (t, 1. - step (length (vec2 (p.y - 1.1, abs (abs (p.z + 0.5) - 0.5) - 0.25)), 0.15) *\n       smoothstep (0.18, 0.2, abs (mod (24. * p.y + 0.5, 1.) - 0.5)));\n    t = min (t, 1. - step (length (vec2 (p.x, p.z - 1.3)), 0.3) *\n       smoothstep (0.25, 0.3, abs (mod (12. * p.x + 0.5, 1.) - 0.5)));\n    col4 = cc * (0.7 + 0.3 * t);\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.01, 0.01, 0.003, p.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (p.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * p.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.8, 0.2, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      p = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n      p.xy = Rot2D (p.xy, -0.05 * pi);\n      p.xz = Rot2D (p.xz, -0.05 * pi);\n      t = length (p.yz) - 0.17;\n    } else {\n      t = length (p.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (p.y + p.z), abs (p.y - p.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (0.4, 0.3, 0.2, -1.);\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  int idObjP;\n  idObjP = idObj;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  idObj = idObjP;\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyGrndCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd;\n  a = atan (rd.z, rd.x) + 0.005 * tCur;\n  if (rd.y < 0.01 * Fbm1 (64. * a) - 0.005) {\n    col = mix (vec3 (0.2, 0.35, 0.2), vec3 (0.3, 0.35, 0.35), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvec3 SeaFloorCol (vec3 rd)\n{\n  return mix (vec3 (0.05, 0.17, 0.12), vec3 (0., 0.15, 0.2), \n     smoothstep (0.4, 0.7, Fbm2 (2. * rd.xz / rd.y)));\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 UnwCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 2.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return vec3 (0.1, 0.3, 0.4) * (0.2 + 0.4 * (rd.y + 1.)) * (1. + 0.1 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roc, row, vnw, rdo, rdd, colUw;\n  float dstObj, dstWat, dstDom, sh, foamFac, eta, atFac, s, h;\n  bool hitWat, unWat;\n  eta = 1.33;\n  atFac = 5.;\n  prpRot = 0.5 * 2. * pi * tCur;\n  sbLen = 6.;\n  dstDom = 5.;\n  roc = ro + dstDom * rd;\n  rdo = rd;\n  dstObj = ObjRay (ro, rd);\n  unWat = (roc.y < WaveHt (roc.xz));\n  dstWat = dstDom + WaveRay (roc, rd, (! unWat ? 1. : -1.));\n  hitWat = (dstWat < min (dstObj, dstFar));\n  if (hitWat) {\n    ro += dstWat * rd;\n    row = ro;\n    vnw = WaveNf (ro, dstWat);\n    if (! unWat) {\n      rd = refract (rd, vnw, 1. / eta);\n    } else {\n      vnw *= -1.;\n      rdd = refract (rd, vnw, eta);\n      rd = (length (rdd) > 0.) ? rdd : reflect (rd, vnw);\n    }\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, vn);\n    sh = ObjSShadow (ro, sunDir);\n    h = WaveHt (ro.xz) - ro.y;\n    if (col4.a >= 0.) {\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n         0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) + \n         col4.a * step (0.95, sh) * vec3 (1., 0.9, 0.5) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n      if (unWat) col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vn), 0.2 * tCur) *\n         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vn.y);\n      else col *= 0.6 + 0.4 * (1. - smoothstep (1., 4., h));\n    } else col = col4.rgb;\n    col *= mix (vec3 (1.), vec3 (0.7, 0.9, 1.), (unWat ? 1. : smoothstep (0., 0.1, h)));\n  } else {\n    col = (hitWat == unWat) ? SkyGrndCol (ro, rd) : SeaFloorCol (rd);\n  }\n  if (! unWat) {\n    if (hitWat) {\n      col = mix (col, 0.8 * SkyGrndCol (row, reflect (rdo, vnw)), pow (1. - abs (dot (rdo, vnw)), 5.));\n      s = Fbm3 (128. * row);\n      foamFac = pow (smoothstep (0., 1., WaveHt (row.xz) - 0.6) + 0.008 * s, 8.);\n      col = mix (col, vec3 (1.), foamFac);\n    }\n  } else {\n    colUw = UnwCol (rd);\n    if (dstObj < dstFar) {\n      col = mix (colUw, col, min (1., exp (1. - atFac * dstObj / dstFar)));\n    } else if (dstWat < dstFar) {\n      col = (rd.y > 0.) ? mix (colUw, col, exp (- atFac * dstWat / dstFar)) : colUw;\n    } else col = colUw;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, svn;\n  vec2 canvas, uv;\n  float el, az, zmFac, pr, cr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pr = 0.95;\n  cr = length (uv);\n  if (cr < pr) {\n    az = 0.5 * pi;\n    el = 0.05 * pi;\n    if (mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += pi * mPtr.y;\n    }\n    az += 0.01 * tCur;\n    el += 0.2 * pi * (SmoothBump (0.25, 0.75, 0.2, mod (0.012 * tCur, 1.)) - 0.5);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 3.2;\n    vuMat = StdVuMat (el, az);\n    ro = vuMat * vec3 (0., 0., -40.);\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n    sbDepth = -4. + 4. * sin (0.05 * pi * tCur);\n    ro.y += sbDepth;\n    vuPos = ro;\n    sunDir = normalize (vec3 (-0.5, 1., 0.2));\n    dstFar = 300.;\n    col = ShowScene (ro, rd);\n  } else {\n    cr -= pr + 0.1;\n    svn = normalize (vec3 (0.6 * normalize (uv) * SmoothBump (0., 0.04, 0.01,\n       abs (abs (cr) - 0.1)) * sign (cr), -1.));\n    svn = VaryNf (256. * vec3 (uv, 1.), svn, 0.5);\n    col = vec3 (0.6, 0.5, 0.1) * (0.2 + 0.8 * max (dot (svn, normalize (vec3 (1., 1., -1.))), 0.));\n    col = mix (col * (0.1 + 0.9 * smoothstep (0., 0.005, abs (length (Rot2D (uv, 2. * pi *\n       (floor (12. * atan (uv.y, - uv.x) / (2. * pi) + 0.5) / 12.)) + vec2 (pr + 0.1, 0.)) - 0.03))),\n       vec3 (0.2, 0.2, 0.) * Fbm2 (256. * uv), step (0.1, cr));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 971, 994, 994, 1601], [1603, 1603, 1646, 1646, 2169], [2171, 2171, 2202, 2202, 2365], [2367, 2367, 2389, 2389, 5288], [5290, 5290, 5323, 5323, 5499], [5501, 5501, 5522, 5522, 5770], [5772, 5772, 5803, 5803, 8287], [8289, 8289, 8326, 8326, 8597], [8599, 8599, 8635, 8635, 9587], [9589, 9589, 9617, 9617, 9736], [9738, 9738, 9778, 9778, 10238], [10240, 10240, 10263, 10263, 10616], [10618, 10618, 10653, 10653, 12948], [12950, 12950, 13003, 13003, 14510], [14512, 14512, 14545, 14545, 14634], [14636, 14636, 14682, 14682, 14729], [14731, 14731, 14764, 14764, 14791], [14793, 14793, 14835, 14835, 14886], [14888, 14888, 14947, 14947, 15078], [15080, 15080, 15133, 15133, 15194], [15196, 15196, 15226, 15226, 15339], [15341, 15341, 15377, 15377, 15583], [15585, 15585, 15642, 15642, 15725], [15759, 15759, 15783, 15783, 15836], [15838, 15838, 15862, 15862, 15974], [15976, 15976, 16000, 16000, 16119], [16121, 16121, 16146, 16146, 16292], [16294, 16294, 16319, 16319, 16505], [16507, 16507, 16532, 16532, 16757], [16759, 16759, 16781, 16781, 16935], [16937, 16937, 16958, 16958, 17113], [17115, 17115, 17136, 17136, 17291], [17293, 17293, 17322, 17322, 17534], [17536, 17536, 17575, 17575, 17755]]}
{"id": "wtXfRM", "name": "v3Discs2.glsl", "author": "jorge2017a1", "description": " keijiro /ShaderSketches \nhttps://github.com/keijiro/ShaderSketches/blob/master/Fragment/Discs2.glsl", "tags": ["v3discs2glsl"], "likes": 6, "viewed": 231, "published": "Public", "date": "1596314649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = iResolution.y / 10.0;\n    vec2 p = fragCoord.xy / scale;\n    vec2 p1 = fract(p) - 0.5;\n    vec2 p2 = fract(p - 0.5) - 0.5;\n\n    float z1 = rand(0.12 * floor(p));\n    float z2 = rand(0.23 * floor(p - 0.5));\n\n    float r1 = 0.2 + 0.2 * sin(iTime * 1.9 + z1 * 30.0);\n    float r2 = 0.2 + 0.2 * sin(iTime * 1.9 + z2 * 30.0);\n\n    float c1 = saturate((r1 - length(p1)) * scale);\n    float c2 = saturate((r2 - length(p2)) * scale);\n\n    float a1 = saturate((r1 + 0.08 - length(p1)) * scale);\n    float a2 = saturate((r2 + 0.08 - length(p2)) * scale);\n\n    float c = mix(\n        mix(mix(0.0, c1, a1), c2, a2),\n        mix(mix(0.0, c2, a2), c1, a1),\n        step(z1, z2)\n    );\n\n    fragColor = vec4(c, c, c, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 55], [57, 57, 78, 78, 148], [150, 150, 207, 207, 935]]}
{"id": "wtXfRS", "name": "Twisted Medallion", "author": "t420babe", "description": "Originated from playing with functions from chapter 6 of The Book of Shaders (https://thebookofshaders.com/06/)", "tags": ["pulse", "colors", "polarshapes", "medallion"], "likes": 0, "viewed": 169, "published": "Public API", "date": "1596996104", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// Inspiration from http://thebookofshaders.com/edit.php?log=200809173941\nvec3 twisted_hsb2rgb(in vec3 color) {\n  float change_rate = 2.0;\n  float color_multiplier = abs(sin(iTime * change_rate)) + 1.0;\n  vec3 c = vec3(9.0, 5.0, 2.0) * color_multiplier;\n  vec3 rgb_abs = abs(mod(color.x * 5.0 + c, 5.0) - 5.0) - 1.0;\n  vec3 rgb = clamp(rgb_abs, 0.0, 1.0);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  return color.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  // [-1, 1]\n  vec2 position = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n  vec3 color = vec3(0.0);\n\n  float center = 0.0;\n  float scale = 1.0;    \n\n  // Polar coordinates\n  float r = length(position) * scale;\n  float theta = atan(position.y, position.x);\n\n  float w0 = 500.0;\n  float w1 = 10.0;\n  float m = -200.0;\n  float vary_radius = 0.5;\n\n  float f = smoothstep(-0.5, 1.0, cos(theta * w0)) * m + vary_radius;\n\n  float thickness = 0.3;\n  color = twisted_hsb2rgb(vec3(1.0 - smoothstep(f, f + thickness, r)));\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 100, 137, 137, 467], [469, 469, 526, 540, 1105]]}
{"id": "wtXfWH", "name": "Low Escape Julia", "author": "md1", "description": "Simple Julia set visualization, but with a low escape radius.\n\n", "tags": ["fractal", "julia", "juliaset"], "likes": 2, "viewed": 67, "published": "Public", "date": "1596572385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define max_iterations 250\n#define eR 1.0\n#define zoom 3.0\n\n\n\nfloat calc(vec2 z, vec2 c)\n{\n    for(int i = 0; i < max_iterations; i++)\n    {\n     \tfloat real = z.x * z.x - z.y * z.y + c.x;\n        float imag = 2.0 * z.x * z.y + c.y;\n        \n        z.x = real;\n        z.y = imag;\n        \n        if(dot(z, z) > eR)\n        {\n            return (float(i) - log2(log2(dot(z, z))) + 5.0) / float(max_iterations);\n        }\n    }\n    return 0.0;\n}\n\n\nfloat juliaCalc(vec2 coord, vec2 cCoord)\n{\n    return calc(coord, cCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord  = 1.5 * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 cCoord = vec2(cos(iTime*0.3 - 3.1415), 0.8*sin(iTime*0.3 - 3.1415));\n  \n    float juliaValue = juliaCalc(coord, cCoord);\n    vec3 color = vec3(cos((juliaValue) * 40.0 + 3.0), cos((juliaValue) * 30.0 + 2.8), cos((juliaValue) * 35.0 + 4.0));\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 90, 90, 446], [449, 449, 491, 491, 525], [527, 527, 584, 584, 954]]}
{"id": "WtXfWr", "name": "Planets with Valleys", "author": "jarble", "description": "This is another variation of my \"Cratered Planets\" shader, with valleys instead of craters.", "tags": ["procedural", "3d", "raymarching", "terrain", "planets"], "likes": 2, "viewed": 207, "published": "Public API", "date": "1596427733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0005;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p,float i) {\n    p += sin(p.yzx*i/100.0)*50.0/i;\n    //p += sin(p.yzx*20.0)/80.0;\n    return  (3.0 -sin(length(p/i))*i -.9/(i)+ sin(p.x)+cos(p.y)+cos(p.z))*2.9;\n}\n\nfloat sceneSDF2(vec3 p,int iterations){\n    float k = 1.0;\n    float to_return = sceneSDF1(p,k);\n    for(int i = 0; i < iterations; i++){\n        k *= 6.0;\n\n        to_return = min(to_return, to_return*1.5/k+sceneSDF1(p*k,k/5.0));\n    }\n    return to_return;\n}\n\nfloat sceneSDF2(vec3 p){\n\treturn sceneSDF2(p,2);\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 100.0;\n    return sceneSDF2(p,1)-sceneSDF2((p.yzx)*(10.0+sceneSDF2(p*(20.0))*.01))*.01;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= 100.0;\n    vec3 c1 = vec3(sceneSDF2(p+p.yzx/2.0),sceneSDF2(p+p.zxy/2.0),sceneSDF2(p+p/2.0));\n    return (sin(c1))*vec3(.5)/(10.0)+vec3(.5, .4,.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    //viewDir.xz *= sin(iTime)/2.0+1.0;\n    \n    vec3 eye = vec3(5.0, 5.0, 5.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 492, 525, 525, 675], [677, 677, 716, 716, 937], [939, 939, 963, 963, 989], [991, 991, 1014, 1014, 1113], [1115, 1115, 1143, 1143, 1301], [1303, 1724, 1815, 1815, 2127], [2142, 2396, 2461, 2461, 2593], [2595, 2684, 2713, 2713, 3023], [3025, 3517, 3657, 3657, 4247], [4249, 4619, 4704, 4704, 5062], [5064, 5391, 5440, 5475, 5606], [5608, 5608, 5665, 5665, 6788]]}
{"id": "wtXfWX", "name": "20200819_1", "author": "gweltou", "description": "earth texture proto 1", "tags": ["random", "scrolling"], "likes": 3, "viewed": 37, "published": "Public", "date": "1597873842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random2d(vec2 coord)\n{\n    // D'après https://www.youtube.com/watch?v=nM320eVlLvQ\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n\nvec3 colNoise(vec2 st, vec3 c, float amp) {\n  float x = Random2d(st) * amp;\n  float y = Random2d(st) * (amp-x);\n  float z = Random2d(st) * (amp-x-y);\n  x -= amp/2.;\n  y-=amp/2.;\n  z-=amp/2.;\n  float tmp;\n  // Shuffle\n  for (int i=0; i<3; i++) {\n    switch (int(floor(Random2d(st) * 3.))) {\n      case 0: tmp=x; x=y; y=tmp;\n              break;\n      case 1: tmp=x; x=z; z=tmp;\n              break;\n      case 2: tmp=y; y=z; z=tmp;\n              break;\n      default: break;\n    }\n  }\n  //return vec3(red(c)+x, green(c)+y, blue(c)+z);\n    return c + vec3(x,y,z);\n}\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st *= 4. + 4. * (1. + sin(iTime/10.));\n    st.x *= iResolution.x/iResolution.y;\n    st.x += iTime/10.;\n    \n    vec3 color = vec3(0.9);\n    float rnd = .0;\n    \n    int i = 0;\n\t\n    while (rnd < .9 && i < 4) {\n        st *= 2.;\n        //st *= 2.1;\n        vec2 zoneCoord = floor(st.xy);\n        rnd = Random2d(zoneCoord);\n        color = colNoise(zoneCoord, color, .4);\n    \ti++;\n    }\n    //color = vec3(rnd);\n\t\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 88, 167], [170, 170, 213, 213, 733], [739, 739, 796, 796, 1293]]}
{"id": "wtXyWH", "name": "Simple Slime", "author": "imanishi", "description": "test", "tags": ["sphere"], "likes": 1, "viewed": 94, "published": "Public", "date": "1598341803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_MARCH_STEP = 50;\nconst vec3 BG_COLOR = vec3(0.78, 0.8, 0.9);\n\n\n// 球の距離関数\nfloat dSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid setCamera(out vec3 camPos, out vec3 camTarget, in float time, in vec2 mouse)\n{\n    float radius = 3.0;\n    float theta = 0.1 + 5.0 * mouse.x - iTime * 0.2;\n    float phi = 3.14159 * 0.4; //5.0*mouse.y;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTarget = vec3(0.0,0.0,0.0);\n}\n\n// スムース(距離関数をスムーズに合成) \nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// -----------\n// Noise\n// -----------\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// -----------\n// Modelling\n// -----------\n\nvec2 map(vec3 pos) {\n    float sphere = dSphere(pos, 2.0) + noise(pos * 1.0 + (iTime * 0.5));\n    float t1 = sphere;\n\n    // 距離関数の合成\n    t1 = smin(t1, dSphere(pos + vec3(1.8, 0.0, 0.0), 0.2), 2.0);\n    t1 = smin(t1, dSphere(pos + vec3(-1.8, 0.0, -1.0), 0.2), 2.0);\n    \n    return vec2(t1, 1.0);\n}\n\n/*\nfloat distFunc(vec3 pos)\n{\n    float sphere = dSphere(pos, 2.0) + noise(pos * 1.0 + (iTime * 0.1));\n    float t1 = sphere;\n\n    // 距離関数の合成\n    t1 = smin(t1, dSphere(pos + vec3(1.8, 0.0, 0.0), 0.2), 2.0);\n    t1 = smin(t1, dSphere(pos + vec3(-1.8, 0.0, -1.0), 0.2), 2.0);\n\n    return t1;\n}\n*/\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xxy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n    return normalize(nor);\n}\n\nvoid renderColor(vec3 rayOrigin, vec3 rayDirection, inout vec3 color, vec3 currentPos) {\n    vec3 lightDirection = normalize(vec3(1.0, 4.0, 1.0));\n\n    vec3 normal = calcNormal(currentPos);\n    vec3 normalDistorted = calcNormal(currentPos + noise(currentPos * 1.5 + vec3(0.0, 0.0, sin(iTime*0.75))));\n\n    // リムライティング\n    float l = abs(dot(-rayDirection, normal));\n    float lDistorted = abs(dot(-rayDirection, normalDistorted));\n    float rim = pow(1.0 - l, 6.0);\n    float rimDistorted = pow(1.0 - lDistorted, 6.0);\n    \n    color = mix(color, normal * 0.3 + vec3(1.0), rimDistorted + 0.1);\n    color += rim;\n\n}\n\n// -----------\n// Ray March\n// -----------\n\nvec3 rayPlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec4 plane) {\n\tfloat t = -(dot(rayOrigin, plane.xyz) + plane.w) / dot(rayDirection, plane.xyz);\n\treturn rayOrigin + t * rayDirection;\n}\nbool renderRayMarch(vec3 rayOrigin, vec3 rayDirection, inout vec3 color) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < NUM_MARCH_STEP; i++) {\n        vec3 currentPos = rayOrigin + rayDirection * t;\n        d = map(currentPos).x;\n        if (d < INTERSECTION_PRECISION) {\n            break;\n        }\n        t += d;\n    }\n\n    if (d < INTERSECTION_PRECISION) {\n        vec3 currentPos = rayOrigin + rayDirection * t;\n        renderColor(rayOrigin, rayDirection, color, currentPos);\n        return true;\n    }\n\n    vec3 planePoint = rayPlaneIntersection(rayOrigin, rayDirection, vec4(0.0, 1.0, 0.0, 1.0));\n\n    return false;\n}\n\n// -----------\n// Output\n// -----------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 rayOrigin, camTarget;\n    setCamera(rayOrigin, camTarget, iTime, m);\n\n    // Ray生成\n    mat3 camMat = calcLookAtMatrix(rayOrigin, camTarget, 0.0);\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, 2.0));\n\n    // RayMarching\n\n    vec3 color = BG_COLOR;\n    renderRayMarch(rayOrigin, rayDirection, color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 208, 246, 246, 279], [281, 281, 343, 343, 516], [518, 518, 601, 601, 948], [950, 1005, 1046, 1046, 1117], [1119, 1228, 1250, 1250, 1295], [1296, 1296, 1316, 1316, 1361], [1362, 1362, 1380, 1380, 1419], [1421, 1421, 1441, 1441, 1932], [1934, 1978, 1998, 1998, 2289], [2291, 2601, 2631, 2631, 2879], [2881, 2881, 2969, 2969, 3510], [3512, 3556, 3630, 3630, 3752], [3753, 3753, 3827, 3827, 4396], [4398, 4439, 4494, 4494, 4959]]}
{"id": "XdKcWK", "name": "CIS 566 Final Project Test2", "author": "ChloeSnyder", "description": "test", "tags": ["project"], "likes": 4, "viewed": 95, "published": "Public", "date": "1597848017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\n#define Iterations 64\n#define Thickness 0.15\n#define Thickness2 0.15\n#define Thickness3 0.2\n#define SuperQuadPower 2.5 // controls roundness of spindle\n#define Fisheye 1.5\n\nfloat truchetarc(vec3 pos)\n{\n    // Is there a way to make this arc be chained circles?\n    \n\tfloat r=length(pos.xy);\n//\treturn max(abs(r-0.5),abs(pos.z-0.5))-Thickness;\n//\treturn length(vec2(r-0.5,pos.z-0.5))-Thickness;\n    if(rand(pos) > .5)\n    {\n        return pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness2;\n    }\n\treturn pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness;\n}\n\nfloat truchetcell(vec3 pos)\n{\n\treturn min(min(\n\ttruchetarc(pos),\n\ttruchetarc(vec3(pos.z,1.0-pos.x,pos.y))),\n\ttruchetarc(vec3(1.0-pos.y,1.0-pos.z,pos.x)));\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 cellpos=fract(pos);\n\tvec3 gridpos=floor(pos);\n\n\tfloat rnd=rand(gridpos);\n\n\tif(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,cellpos.z));\n\telse if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,cellpos.z));\n\telse if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,cellpos.z));\n\telse  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,cellpos.z));\n}\n\nvec3 gradient(vec3 pos)\n{\n\tconst float eps=0.0001;\n\tfloat mid=distfunc(pos);\n\treturn vec3(\n\tdistfunc(pos+vec3(eps,0.0,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,eps,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,0.0,eps))-mid);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ray_dir=fragRayDir;\n\tvec3 ray_pos=fragRayOri;\n\n\tfloat i=float(Iterations);\n\tfor(int j=0;j<Iterations;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tvec3 normal=normalize(gradient(ray_pos));\n\n\tfloat ao=1.0-i/float(Iterations);\n\tfloat what=pow(max(0.0,dot(normal,-ray_dir)),2.0);\n\tfloat light=ao*what*1.4;\n\n\tfloat z=ray_pos.z/2.0;\n//\tvec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;\n\tvec3 col=(cos(ray_pos/2.0)+2.0)/3.0;\n\n\tvec3 reflected=reflect(ray_dir,normal);\n\tvec3 env= vec3(1,0,1);//texture(iChannel0,reflected*reflected*reflected).xyz;\n\n\tfragColor=vec4(col*light+0.1*env,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float pi=3.141592;\n\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/length(iResolution.xy);\n\n\tfloat a=iTime/3.0;\n\tmat3 m=mat3(\n\t0.0,1.0,0.0,\n\t-sin(a),0.0,cos(a),\n\tcos(a),0.0,sin(a));\n\tm*=m;\n\tm*=m;\n\n\tvec3 ray_dir=m*normalize(vec3(1.4*coords,-1.0+Fisheye*(coords.x*coords.x+coords.y*coords.y)));\n\n\tfloat t=iTime/3.0;\n\tvec3 ray_pos=vec3(\n    2.0*(sin(t+sin(2.0*t)/2.0)/2.0+0.5),\n    2.0*(sin(t-sin(2.0*t)/2.0-pi/2.0)/2.0+0.5),\n    2.0*((-2.0*(t-sin(4.0*t)/4.0)/pi)+0.5+0.5));\n\n    mainVR(fragColor,fragCoord,ray_pos,ray_dir);\n\n   \tfloat vignette=pow(1.0-length(coords),0.3);\n\tfragColor.xyz*=vec3(vignette);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 104], [279, 279, 307, 366, 762], [764, 764, 793, 793, 920], [922, 922, 948, 948, 1674], [1676, 1676, 1701, 1701, 1883], [1885, 1885, 1979, 1979, 2646], [2648, 2648, 2705, 2705, 3317]]}
{"id": "XtBfWd", "name": "2/1 CIS 566 Radar Demo", "author": "ChloeSnyder", "description": "demo", "tags": ["demo"], "likes": 3, "viewed": 55, "published": "Public", "date": "1597847995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrPt = uv * 2.0 - 1.0;// map -1 to 1\n    scrPt.x *= iResolution.x / iResolution.y; // make a circle by multiplying by aspect ratio\n    \n    // animate\n    mat2 rot;\n    float theta = -iTime * 6.28318530718; // scale time for 1 revolution per second\n    float cosTheta, sinTheta;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    vec2 scrPtRot = rot * scrPt;\n    \n    \n    // -pi to pi, remapped 0 to 1 for better colors by dividing by 2pi and adding .5\n    float angle = 1.0 - (atan(scrPtRot.y, scrPtRot.x) / 6.28318530718 + .5); \n    \n    //scale mask (values closer to black where closer to 1)\n    float falloff = 1.0 - length(scrPt); // the radius\n    // make falloff more intense by raising angle to a power, still keeps it in 0 to 1 range\n    angle = pow(angle, 2.0);\n    \n    \n    vec3 col = vec3(0);\n    \n    // Create circles, increase color for each circle\n    float ringSpacing = .23;\n    float radius = .01;\n    float numRings = 5.0;\n    if(mod(length(scrPtRot), ringSpacing) < radius && length(scrPtRot) / ringSpacing < numRings)\n    {\n        col += vec3(0, 0.5, 0);\n    }\n    \n    // blinking circle\n    // 2.0 * max(0, fract(iTime * .5) - .5)\n    if(length(scrPt - vec2(0.5, 0.5)) < .1)\n    {\n        col.r = 2.0 * max(0.0, fract(-iTime * .5) - .5);\n    }\n    \n    //step function give 0 or 1 answer, 1 if a < b, 0 otherwise (good instead of if statement)\n    col += vec3(0.0, 0.0, 0.8) * step(mod(length(scrPtRot),ringSpacing), 0.01) * step(length(scrPtRot),1.0);\n\n\n    // Output to screen\n    fragColor = vec4(vec3(angle * falloff) * vec3(0,1,0) + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 110, 1855]]}
