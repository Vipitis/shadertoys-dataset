{"id": "4d2cDh", "name": "Sketch_Eyes2", "author": "cexlearning", "description": "Eyes2， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 16, "viewed": 615, "date": "1492327374", "time_retrieved": "2024-06-20T18:52:46.892275", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 hue2rgb(float h)\n{\n    h = fract(h) * 6.0 - 2.0;\n    return clamp(vec3(abs(h - 1.0) - 1.0, 2.0 - abs(h), 2.0- abs(h - 2.0)), 0.0, 1.0);\n}\n\nvec3 eyes(vec2 coord)\n{\n    const float pi = 3.141592;\n    float t = 0.4 * iTime; \n    float div = 5.0 - cos(t * 0.33 * pi) * 4.0;\n    float sc = iResolution.y / div;\n\n    vec2 p = (coord - iResolution.xy / 2.0) / sc - 0.5;\n\n    // center offset\n    float dir = floor(rand(floor(p) + floor(t) * 0.11) * 4.0) * pi / 2.0;\n    vec2 offs = vec2(sin(dir), cos(dir)) * 0.6;\n    offs *= smoothstep(0.0, 0.1,     fract(t));\n    offs *= smoothstep(0.4, 0.5, 1.0 - fract(t));\n\n    // circles\n    float l = length(fract(p) + offs - 0.5);\n    float rep = sin((rand(floor(p)) * 2.0 + 2.0) * t) * 4.0 + 5.0;\n    float c = (abs(0.5 - fract(l * rep + 0.5)) - 0.25) * sc / rep;\n\n    // grid lines\n    vec2 gr = (abs(0.5 - fract(p + 0.5)) - 0.05) * sc;\n    c = clamp(min(min(c, gr.x), gr.y), 0.0, 1.0);\n\n    return hue2rgb(rand(floor(p) * 0.3231)) * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t fragColor = vec4(eyes(fragCoord.xy), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2cDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 91], [93, 93, 116, 116, 235], [237, 237, 260, 260, 1073], [1075, 1075, 1132, 1132, 1177]]}
{"id": "4d2czc", "name": "NND", "author": "drakes", "description": "Description here", "tags": ["dubstep"], "likes": 1, "viewed": 123, "date": "1493141553", "time_retrieved": "2024-06-20T18:52:46.892275", "image_code": "// Prototype for Jonas\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: Connect to the lamps\n    \n\tvec2 uv = vec2(-0.5) + fragCoord.xy / iResolution.xy;\n    \n\t// Zoom in and out\n    float zoom = 1.5 + cos(50.0*iTime);\n    float radius = 0.1;\n    //vec2 r = uv - vec2(0.1*cos(5.0*sin(iTime)*iTime), 0.1*sin(iTime));\n    vec2 c = 0.8*vec2(0.1*cos(5.0*sin(iTime)*iTime), 0.1*sin(iTime));\n    vec2 r = uv - c;\n    vec2 p;\n    p.x = cos(4.0*iTime)*r[0] - sin(4.0*iTime)*r[1];\n    p.y = sin(4.0*iTime)*r[0] + cos(4.0*iTime)*r[1];\n    p.x *= 0.5;\n    if (length(p) <= radius * zoom)\n\t\t// All colors change\n\t\tfragColor = vec4(0.5+0.5*sin(10.0*iTime),0.0,0.0,1.0);\n    else\n        fragColor = vec4(vec3(0.0), 1.0);        \n}\n", "image_inputs": [{"id": "4sXSRr", "previewfilepath": "https://soundcloud.com/dubstep/eliminate-holly-telekinetic-wild-boyz-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dubstep/eliminate-holly-telekinetic-wild-boyz-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2czc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 23, 80, 114, 738]]}
{"id": "4d2yRm", "name": "3D reflective raymarching tunnel", "author": "croxxx", "description": "This shader was created as part of a small first demoscene project for a university course.\nThe viewer flies through an endless reflective tunnel.\n\nYou can watch the demo this was taken from here: https://www.youtube.com/watch?v=eUk_yZvCj5s", "tags": ["3d", "raymarching", "reflection", "tunnel", "lighting"], "likes": 5, "viewed": 617, "date": "1491390804", "time_retrieved": "2024-06-20T18:52:48.195202", "image_code": "// ##############################\n// BEGIN\tIQ methods\n// ##############################\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot(p,n.xyz) + n.w;\n}\nfloat sdTorus88( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length8(p.xy)-t.x,p.z);\n\treturn length8(q)-t.y;\n}\n\n// Union\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n// Substraction\nfloat opS( float d1, float d2 )\n{\n\treturn max(-d1,d2);\n}\n// Repetition\nvec3 opRep( vec3 p, vec3 c )\n{\n\treturn mod(p,c)-0.5*c;\n}\n// ##############################\n// END\t\tIQ methods\n// ##############################\n\n// ##############################\n// BEGIN\tCamera helpers\n// ##############################\nfloat iCamPosX = 0.0;\nfloat iCamPosY = 0.0;\nfloat iCamPosZ = 0.0;\nfloat iCamRotX = 0.0;\nfloat iCamRotY = 0.0;\nfloat iCamRotZ = 0.0;\n\nvec3 calcCameraPos()\n{\n\treturn vec3(iCamPosX, iCamPosY, iCamPosZ);\n}\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// ##############################\n// END\t\tCamera helpers\n// ##############################\n\nconst vec3 repSpacing = vec3( 50.0, 50.0, 1.5 );\n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec3 point )\n{\n\tvec3 point2 = opRep( point, repSpacing );\n\trotateAxis( point2.xy, (iTime+floor(point.z/repSpacing.z))/4.0 );\n\treturn sdTorus88( point2-vec3( 0, 0, 0 ), vec2( 2.0, 0.5 ) );\n}\n\n\nvec3 getNormal( in vec3 pos )\n{\n\t// IQ\n\tvec2 e = vec2( 1.0,-1.0 ) * 0.001;\n\treturn normalize( e.xyy*distFunc( pos + e.xyy ) +\n\t\t\t\t\t  e.yyx*distFunc( pos + e.yyx ) +\n\t\t\t\t\t  e.yxy*distFunc( pos + e.yxy ) +\n\t\t\t\t\t  e.xxx*distFunc( pos + e.xxx ) );\n}\n\nbool isEdge(const vec3 point)\n{\n\tfloat d = 0.05;\n\t//get points a little bit to each side of the point\n\tvec3 right = point + vec3(d, 0.0, 0.0);\n\tvec3 left = point + vec3(-d, 0.0, 0.0);\n\tvec3 up = point + vec3(0.0, d, 0.0);\n\tvec3 down = point + vec3(0.0, -d, 0.0);\n\tvec3 behind = point + vec3(0.0, 0.0, d);\n\tvec3 before = point + vec3(0.0, 0.0, -d);\n\n\tvec3 normRight = getNormal(right);\n\tvec3 normLeft = getNormal(left);\n\tvec3 normUp = getNormal(up);\n\tvec3 normDown = getNormal(down);\n\tvec3 normBehind = getNormal(behind);\n\tvec3 normBefore = getNormal(before);\n\n\tvec3 normal = getNormal(point);\n\n\tconst float limit = 0.99;\n\n\t// float gradient1 = abs(dot(normal, normRight - normLeft));\n\t// float gradient2 = abs(dot(normal, normUp - normDown));\n\t// float gradient3 = abs(dot(normal, normBehind - normBefore));\n\n\tif(abs(dot(normal, normRight)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normLeft)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normUp)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normDown)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normBehind)) < limit) {\n\t\treturn true;\n\t}\n\tif(abs(dot(normal, normBefore)) < limit) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n//vec3 lightColor = clamp(vec3( afFrequencies[0]+afFrequencies[1], afFrequencies[2]+afFrequencies[3], afFrequencies[4]+afFrequencies[5] ), 0.0, 1.0);\n\n\nconst float lightAttenuation = 0.02;\nvec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )\n{\n\t//\tlight relative to camera position\n\tvec3 lightPosition = vec3(sin(iTime), 1.0, cos(iTime));\n\tlightPosition += cameraPosition;\n\n\t//\tSpecular highlight factor\n\tfloat materialShininess = 16.0;\n\tvec3 materialSpecularColor = vec3( 1.0 );\n\n\t//\tOutput color\n\tvec3 outputColor = vec3( 0.0 );\n\n\t//\tCalculate eye vector and its reflection\n\t//vec3 ev = normalize( hitPosition - cameraPosition );\n\t//vec3 ref_ev = reflect( ev, normal );\n\tvec3 surfaceToLight = normalize(lightPosition - hitPosition);\n\tvec3 surfaceToCamera = normalize(cameraPosition - hitPosition);\n\n\t//\tsurface color\n\tvec3 surfaceColor = vec3( 1.0 );\n\n\t//\tedge detection\n\t// if(isEdge(hitPosition))\n\t// {\n\t// \tsurfaceColor = vec3( 0.3 );\n\t// }\n\n\t//\tambient component\n    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*0.5;\n\tvec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor\n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n\tvec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 0.0;\n\tif(diffuseCoefficient > 0.0) {\n\t\tspecularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n\t}\n\tvec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - hitPosition);\n\tfloat attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.));\n\n\toutputColor = ambientColor + attenuation*(diffuseColor + specularColor);\n\n\t//\tgamma correction\n\t//vec3 gamma = vec3(1.0/2.2);\n\t//outputColor = vec3(pow(outputColor, gamma));\n\n\t//\treturn shading result\n\treturn outputColor;\n}\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 256;\nconst float maxT = 110.0;\nfloat trace(vec3 ro, vec3 rd, out vec3 point, out bool objectHit)\n{\n\tfloat t = 0.0;\n\tpoint = ro;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n\t{\n\t\t//check how far the point is from the nearest surface\n\t\tfloat dist = distFunc(point);\n\t\t//if we are very close\n\t\tif(epsilon > dist)\n\t\t{\n\t\t\tobjectHit = true;\n\t\t\tbreak;\n\t\t}\n\t\t//not so close -> we can step at least dist without hitting anything\n\t\tt += dist;\n\t\t// return immediately if maximum t is reached\n\t\tif(t > maxT)\n\t\t{\n\t\t\tobjectHit = false;\n\t\t\treturn maxT;\n\t\t}\n\t\t//calculate new point\n\t\tpoint = ro + t * rd;\n\t}\n\n\treturn t;\n}\n\nconst int reflectionBounces = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//\tSet up Camera\n\tvec3 camP = calcCameraPos(); // Camera position\n\tcamP += vec3( repSpacing.x/2.0+sin( iTime ), repSpacing.y/2.0+cos( iTime ), 6.0*iTime );\n\tvec3 camDir = calcCameraRayDir( 80.0, fragCoord.xy, iResolution.xy ); // Camera view direction\n\n\t//\tSet up ray\n\tvec3 point;\t\t// Set in trace()\n\tbool objectHit;\t// Set in trace()\n\n\t//\tInitialize color\n\tvec3 color = vec3(0.0);\n\n\tfloat t = trace(camP, camDir, point, objectHit);\n\tif(objectHit)\n\t{\n\t\t//\tLighting calculations\n\t\tvec3 normal = getNormal(point);\n\t\tcolor = getShadedColor( point, normal, camP );\n\n\t\t//\tReflections\n\t\tfor(int i = 0; i < reflectionBounces; i++)\n\t\t{\n\t\t\tvec3 pointRef;\t// Set in trace()\n\t\t\tcamDir = reflect(camDir, normal);\n\t\t\ttrace(point + camDir*0.001, camDir, pointRef, objectHit);\n\t\t\tif(objectHit)\n\t\t\t{\n\t\t\t\t// Get color of reflection\n\t\t\t\tcolor += 0.3 * getShadedColor( pointRef, getNormal(pointRef), point );\n\t\t\t}\n\t\t\tpoint = pointRef;\n\t\t}\n\t}\n\n\t//\tfog\n\tvec3 fogColor = vec3( 0.1, 0.1+0.4*(1.0-sin(iTime)), 0.1+0.5*(1.0-sin(iTime)) );\n\tfloat FogDensity = 0.05;\n\tfloat fogFactor = 1.0 /exp(t * FogDensity);\n\tfogFactor = clamp( fogFactor, 0.0, 1.0 );\n\tcolor = mix(fogColor, color, fogFactor);\n\n\tfragColor = vec4(color, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2yRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 88, 113, 113, 178], [179, 179, 212, 237, 267], [268, 268, 303, 303, 368], [370, 379, 412, 412, 434], [435, 451, 484, 484, 507], [508, 522, 552, 552, 578], [667, 892, 914, 914, 960], [961, 961, 1001, 1001, 1043], [1044, 1044, 1111, 1111, 1397], [1540, 1595, 1625, 1625, 1800], [1803, 1803, 1834, 1841, 2048], [2050, 2050, 2081, 2081, 3239], [3242, 3431, 3506, 3544, 5267], [5351, 5351, 5418, 5418, 5928], [5963, 5963, 6020, 6038, 7225]]}
{"id": "4d2yRy", "name": "loading icon with blend texture", "author": "michaelxqy", "description": "loading icon with blend texture", "tags": ["blendtexture"], "likes": 0, "viewed": 173, "date": "1492595531", "time_retrieved": "2024-06-20T18:52:48.201868", "image_code": "//refer loading icon\n//https://www.shadertoy.com/view/XdBXzd\n#define SMOOTH(r) (mix(1.0, 0.0, smoothstep(0.9,1.0, r)))\n#define M_PI 3.1415926535897932384626433832795\n\nfloat movingRing(vec2 uv, vec2 center, float r1, float r2)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = -atan(d.y,d.x);\n    theta  = mod(-iTime+0.5*(1.0+theta/M_PI), 1.0);\n    //anti aliasing for the ring's head (thanks to TDM !)\n    theta -= max(theta - 1.0 + 1e-2, 0.0) * 1e2;\n    return theta*(SMOOTH(r/r2)-SMOOTH(r/r1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy; // Condensing this into one line\n    vec4 texColor = texture(iChannel0, xy); // Get the pixel at xy from iChannel0\n    //vec4 tex2Color = texture(iChannel1, xy);\n    vec2 uv = fragCoord.xy;\n    float ring = movingRing(uv, vec2(iResolution.x/2.0,iResolution.y/2.0), 20.0, 30.0);\n    vec4 tex2Color = vec4( 0.1 + 0.9*ring );\n    \n    vec3 color = mix(texColor.rgb, tex2Color.rgb, tex2Color.a);//texColor; // Set the screen pixel to that color\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2yRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 167, 227, 227, 551], [553, 553, 610, 610, 1132]]}
{"id": "4d2yW1", "name": "Sketch_Hex5", "author": "cexlearning", "description": "Hex5， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 10, "viewed": 127, "date": "1492327697", "time_retrieved": "2024-06-20T18:52:48.201868", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tconst float pi = 3.1415926535;\n    vec2 p = fragCoord.xy - iResolution.xy / 2.0;\n    float phi = atan(p.y, p.x + 1e-6);\n\n    float fin = mod(floor(phi * 3.0 / pi + 0.5), 6.0);\n    float phi_fin = fin * pi / 3.0;\n\n    vec2 dir = vec2(cos(phi_fin), sin(phi_fin));\n    float l = dot(dir, p) - iTime * iResolution.y / 5.0;\n\n    float ivr = 20.0;\n    float seg = l / ivr;\n\n    float w = sin(floor(seg) * 0.2 - iTime) * 0.4 + 0.5;\n    float c = (w / 2.0 - abs(fract(seg) - 0.5)) * ivr;\n\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2yW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 576]]}
{"id": "4d2yWh", "name": "Sketch_Boxes", "author": "cexlearning", "description": "Boxes copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 3, "viewed": 88, "date": "1491970480", "time_retrieved": "2024-06-20T18:52:48.201868", "image_code": "float circle(vec2 coord, vec2 offs)\n{\n    float reso = 16.0;\n    float cw = iResolution.x / reso;\n\n    vec2 p = mod(coord, cw) - cw * 0.5 + offs * cw;\n\n    vec2 p2 = floor(coord / cw) - offs;\n    vec2 gr = vec2(0.193, 0.272);\n    float tr = iTime * 2.0;\n    float ts = tr + dot(p2, gr);\n\n    float sn = sin(tr), cs = cos(tr);\n    p = mat2(cs, -sn, sn, cs) * p;\n\n    float s = cw * (0.3 + 0.3 * sin(ts));\n    float d = 0;//max(abs(p.x), abs(p.y));\n\n    return max(0.0, 1.0 - abs(s - d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = 0.0;\n\n    for (int i = 0; i < 9; i++)\n    {\n        float dx = mod(float(i), 3.0) - 1.0;\n        float dy = float(i / 3) - 1.0;\n        c += circle(fragCoord.xy, vec2(dx, dy));\n    }\n    \n    fragColor = vec4(vec3(min(1.0, c)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2yWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 37, 488], [491, 491, 548, 548, 796]]}
{"id": "4d2yWm", "name": "hyperghost shrine", "author": "netgrind", "description": "mouse y to come closer\nmouse x to unfold\nhacked from https://www.shadertoy.com/view/XdlcWf by macbooktall - connor bell", "tags": ["ray", "blackandwhite", "hyperghost", "hedron"], "likes": 0, "viewed": 362, "date": "1492374001", "time_retrieved": "2024-06-20T18:52:49.358939", "image_code": "//  by cale bradbury @netgrind.net\n//  hacked from https://www.shadertoy.com/view/XdlcWf by macbooktall - connor bell\n\n//  hg_sdf by MERCURY http://mercury.sexy\n// \tReleased as Creative Commons Attribution-NonCommercial (CC BY-NC)\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat mx = 0.;\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d1);\n}\nfloat opURound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat roomWidth = .5;\nfloat count = 5.;\nvec2 map( in vec3 pos ){\n  \tfloat rep = 4.;\n\tvec3 p = pos;\n    pModPolar(pos.xz, rep);\n    pos.x -= .6;\n    pos.y = abs(pos.y);\n    pos.y-= .4;\n    pos.y = abs(pos.y);\n    vec4 dx = vec4(p.y, length(p)*2., pos.y*2., length(pos)*2.*2.);\n\tvec4 idx = vec4(1.);\n    float mul = .015;\n    for(float i = 1.; i<count; i++){\n        vec4 f = floor((abs(dx +mul*.5*i)) / ((i)*mul))*pow(1.-i/count, 9.);\n       idx-=f*mx;\n    }\n    \n    float clock = iTime*3.1415;\n\n    float anim = sin((idx.y+idx.x) + clock)*mx;\n    float anim2 = cos((idx.z+idx.w) + clock)*mx ;\n\n   // float i = ;\n    pos.y -= anim2*0.05;\n\n    float dist = fOctahedron(pos,roomWidth*.5);\n\tpR45(p.xz);\n    dist = opURound(dist, fOctahedron(p, roomWidth*1.25 + anim*0.03), .2);\n                           \n    vec2 res = vec2(dist, 0.);\n\n    return res;\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    float d = 1000.;\n    for( int i=0; i<16; i++ )\n    {\n   \t\tvec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n    \tm = res.y;\n        d = min(res.x, d);\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m , d);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<10; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0., 0.1 );\n        if(t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<8; i++ )\n    {\n        float hr = 0.01 + .15*float(i)/8.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(1.);\n    vec3 res = castRay(ro,rd);\n    const vec3 a = vec3(1., 1., 1.);\n    const vec3 b = vec3(1., .0, .3);\n    const vec3 c = vec3(0.2, 0., 0.5);\n    const vec3 d = vec3(.8,.2,.2);\n        \n    //if (res.x > 6.) return ;\n    \n    vec3 pos = ro + res.x*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n   \tfloat occ = calcAO( pos, normalize(nor+vec3(0., 0.,0.)) );\n   \tfloat occ2 = calcAO( pos, normalize(nor+vec3(0., 0.,0.)) );\n    float dom = smoothstep( -0.6, 20.6, ref.y );\n\n    dom *= softshadow( pos, ref, .1, 10. );\n\n    col = vec3(mix(occ, res.x*.001, 0.5));//palette(3.+res.x*.1,a,b,c,d)*occ*length(ref)*(1.+dom);\n   // col = mix( col, vec3(.0), max(1.0-exp( -0.05*res.x ),clamp(res.x*0.1,0.,1.)) );\n\t//col = col*(1.+dom);\n    return vec3( clamp(col *vec3(pow(max(0.,1.-res.z*4.), 5.)),0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tmx = iMouse.x/iResolution.x;\n    float dist = mix(.8, 3., .9-iMouse.y/iResolution.y*.7);\n    float ang = iTime*.075;\n    float y = iMouse.y/iResolution.y;\n\tvec3 ro = vec3(sin(ang)*dist,y , cos(ang)*dist);\n  \tvec3 ta = vec3(0.,y,.0);\n    mat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize(vec3(p.xy,2.));\n    vec3 col = render( ro, rd );\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0 OR cc-by-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2yWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[695, 912, 948, 948, 1044], [1045, 1045, 1070, 1070, 1110], [1113, 1226, 1276, 1276, 1696], [1698, 1858, 1891, 1891, 1917], [1919, 1919, 1952, 1952, 1977], [1978, 1978, 2021, 2021, 2106], [2148, 2148, 2172, 2172, 2960], [2962, 2962, 3002, 3002, 3335], [3338, 3338, 3412, 3412, 3663], [3665, 3665, 3697, 3697, 3911], [3913, 3913, 3955, 3955, 4252], [4254, 4254, 4326, 4326, 4369], [4371, 4371, 4410, 4410, 5266], [5268, 5268, 5320, 5320, 5497], [5498, 5498, 5556, 5556, 6041]]}
{"id": "4dBcD1", "name": "tonemap test", "author": "Jodie", "description": "based on https://www.shadertoy.com/view/lslGzl\nrobo tonemap from https://www.shadertoy.com/user/robobo1221", "tags": ["test", "tonemap", "robin", "robobo", "jodie"], "likes": 3, "viewed": 530, "date": "1491855075", "time_retrieved": "2024-06-20T18:52:50.231729", "image_code": "\n// curve matched using turingbot\nvec3 linearToSrgb(const vec3 x){\n    return 1.14374*(-0.126893*x+sqrt(x));\n}\n\n \nvec3 getBaseColor(int i)\n{\n    if (i == 0) return vec3(1.0, 0.4, 0.2);\n    if (i == 1) return vec3(0.4, 1.0, 0.2);\n    if (i == 2) return vec3(0.2, 1.0, 0.4);\n    if (i == 3) return vec3(0.2, 0.4, 1.0);\n    if (i == 4) return vec3(0.4, 0.2, 1.0);\n    if (i == 5) return vec3(1.0, 0.2, 0.4);\n \n    return vec3(1.);\n}\n \nvec3 getBaseColor()\n{\n    float colorPerSecond = 0.5;\n    int i = int(mod(colorPerSecond * iTime, 7.));\n    int j = int(mod(float(i) + 1., 7.));\n \n    return mix(getBaseColor(i), getBaseColor(j), fract(colorPerSecond * iTime));\n}\n\nvec3 reinhardRobo(vec3 x,float y){\n    return x/pow(1.+pow(x,vec3(y) ),vec3(1./y) );\n}\nfloat reinhardRobo(float x,float y){\n    return x/pow(1.+pow(x,y ),1./y );\n}\nvec3 roboTonemap(vec3 c){\n    return c/sqrt(1.+c*c);\n}\n\nvec3 jodieRoboTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc=c/sqrt(c*c+1.);\n    return mix(c/sqrt(l*l+1.),tc,tc);\n}\nvec3 reinhardTonemap(vec3 c){\n    return c/(c+1.);\n}\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc=c/(c+1.);\n    return mix(c/(l+1.),tc,tc);\n}\nvec3 jodieReinhard2ElectricBoogaloo(const vec3 color){\n    float luma = dot(color, vec3(.2126, .7152, .0722));\n\n    // tonemap curve goes on this line\n    // (I used reinhard here)\n    vec4 rgbl = vec4(color, luma) / (luma + 1.);\n    \n    vec3 mappedColor = rgbl.rgb;\n    float mappedLuma = rgbl.a;\n    \n    float channelMax = max(max(max(\n    \tmappedColor.r,\n    \tmappedColor.g),\n    \tmappedColor.b),\n    \t1.);\n    \n    // this is just the simplified/optimised math\n    // of the more human readable version below\n    return (\n        (mappedLuma*mappedColor-mappedColor)-\n        (channelMax*mappedLuma-mappedLuma)\n    )/(mappedLuma-channelMax);\n    \n    const vec3 white = vec3(1);\n    \n    // prevent clipping\n    vec3 clampedColor = mappedColor/channelMax;\n    \n    // x is how much white needs to be mixed with\n    // clampedColor so that its luma equals the\n    // mapped luma\n    //\n    // mix(mappedLuma/channelMax,1.,x) = mappedLuma;\n    // \n    // mix is defined as\n    // x*(1-a)+y*a\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\n    // \n    // (mappedLuma/channelMax)*(1.-x)+1.*x = mappedLuma\n\n    float x = (mappedLuma - mappedLuma*channelMax)\n        /(mappedLuma - channelMax);\n    return mix(clampedColor, white, x);\n}\nvec3 jodieRobo2ElectricBoogaloo(const vec3 color){\n    float luma = dot(color, vec3(.2126, .7152, .0722));\n\n    // tonemap curve goes on this line\n    // (I used robo here)\n    vec4 rgbl = vec4(color, luma) * inversesqrt(luma*luma + 1.);\n    \n    vec3 mappedColor = rgbl.rgb;\n    float mappedLuma = rgbl.a;\n    \n    float channelMax = max(max(max(\n    \tmappedColor.r,\n    \tmappedColor.g),\n    \tmappedColor.b),\n    \t1.);\n    \n    // this is just the simplified/optimised math\n    // of the more human readable version below\n    return (\n        (mappedLuma*mappedColor-mappedColor)-\n        (channelMax*mappedLuma-mappedLuma)\n    )/(mappedLuma-channelMax);\n    \n    const vec3 white = vec3(1);\n    \n    // prevent clipping\n    vec3 clampedColor = mappedColor/channelMax;\n    \n    // x is how much white needs to be mixed with\n    // clampedColor so that its luma equals the\n    // mapped luma\n    //\n    // mix(mappedLuma/channelMax,1.,x) = mappedLuma;\n    // \n    // mix is defined as\n    // x*(1-a)+y*a\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml\n    // \n    // (mappedLuma/channelMax)*(1.-x)+1.*x = mappedLuma\n\n    float x = (mappedLuma - mappedLuma*channelMax)\n        /(mappedLuma - channelMax);\n    return mix(clampedColor, white, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = getBaseColor();\n    //vec3 color = vec3(.1,1,.2);\n \n    float n = 6.;\n    if (uv.x > 0.2)\n    {\n        color *= (uv.x-0.2)*10.;\n\n        int i = int(n * (1. - uv.y));\n        if (i == 0) color = roboTonemap(color);\n        if (i == 1) color = jodieRoboTonemap(color);\n        if (i == 2) color = jodieRobo2ElectricBoogaloo(color);\n        if (i == 3) color = reinhardTonemap(color);\n        if (i == 4) color = jodieReinhardTonemap(color);\n        if (i == 5) color = jodieReinhard2ElectricBoogaloo(color);\n        \n    }\n    \n \n    if (abs(fract(n * uv.y + 0.5) - 0.5) < 0.02)\n        color = vec3(0.);\n    \n    color = linearToSrgb(color);\n    \n \n    fragColor = vec4(color, 1.);\n    //fragColor = vec4((color-1.)*1000., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBcD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 34, 66, 66, 110], [114, 114, 140, 140, 429], [432, 432, 453, 453, 661], [663, 663, 697, 697, 749], [750, 750, 786, 786, 826], [827, 827, 852, 852, 881], [883, 883, 913, 913, 1033], [1034, 1034, 1063, 1063, 1086], [1087, 1087, 1121, 1121, 1229], [1230, 1230, 1284, 1284, 2494], [2495, 2495, 2545, 2545, 3767], [3769, 3769, 3826, 3826, 4619]]}
{"id": "4dBcDm", "name": "learning ray marching / sdfs", "author": "rytone", "description": "probably bad", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 158, "date": "1492559787", "time_retrieved": "2024-06-20T18:52:50.922753", "image_code": "#define MAX_MARCH_STEPS 512\n#define PI 3.14159265359\n#define DEG_TO_RAD PI / 180.0\n#define EPSILON 0.0001\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n// polynomial smooth min from http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// gets distance from the ray position (pos) to some surface defined by this function\n// if the returned value is negative, then the ray has intersected with the surface.\nfloat sd(vec3 pos) {\n    float dist1 = length(pos - vec3(sin(iTime) - 0.5, 0.6 + sin(iTime * 2.0) / 2.0, sin(iTime * 1.1))) - 0.5;\n    float dist2 = length(pos - vec3(sin(iTime * 1.8) + 0.5, 0.6 - sin(iTime * 3.0) / 2.0, cos(iTime * 2.7))) - 0.5;\n    \n    float sDist = smin(dist1, dist2, 1.4);\n    \n    float surface = length(max(abs(pos - vec3(0.0, -3.0, 0.0))-2.0,0.0));\n    \n    float dist = smin(sDist, surface, 2.0);\n    \n    return dist;\n}\n\n// marching function\nfloat march(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = origin + dir * depth;\n        float dist = sd(p);\n        if (dist < EPSILON) {\n            // intersection\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            // too far!\n            return end;\n        }\n    }\n    return end;\n}\n\n// get ray direction\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// copy pasted math\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float far = 50.0;\n    \n    vec3 eye = vec3(cos(iTime) * 8.0, 3.0, sin(iTime) * 8.0);\n    vec3 look =  ray_dir(40.0, iResolution.xy, fragCoord.xy);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    look = viewToWorld * look;\n    \n    float depth = march(eye, look, 0.0, far);\n    \n    if (depth == far) {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    } else {\n        vec3 lightPos = vec3(3.0, 5.0, 3.0);\n        vec3 hitPos = eye + look.xyz * depth;\n        vec3 lightDir = normalize(hitPos - lightPos);\n        \n        float shadowVal = 0.0;\n        for (int i = 0; i <= 16; i++) {\n            float lightDepth = march(lightPos, lightDir + (vec3(random(vec3(iTime, fragCoord)), random(vec3(iTime + float(i), fragCoord)), random(vec3(iTime - float(i), fragCoord))) - 0.5) * 0.0001, 0.0, far);\n        \tvec3 lightHitPos = lightPos + lightDir * lightDepth;\n            if (length(hitPos - lightHitPos) > 0.001) {\n            \tshadowVal += 0.5;\n        \t}\n        }\n        shadowVal /= 16.0;\n        shadowVal = 1.0 - shadowVal;\n        \n        // object color\n        vec3 col = vec3(0.9, 0.9, 0.9);\n        \n        fragColor = vec4(col * shadowVal, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBcDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[107, 178, 199, 199, 330], [334, 400, 422, 422, 480], [481, 481, 503, 503, 561], [562, 562, 584, 584, 642], [646, 804, 836, 836, 1256], [1260, 1309, 1334, 1334, 1385], [1387, 1466, 1507, 1507, 1600], [1602, 1773, 1793, 1793, 2219], [2221, 2242, 2302, 2302, 2669], [2671, 2692, 2738, 2738, 2910], [2912, 2932, 2981, 3016, 3147], [3149, 3149, 3204, 3204, 4419]]}
{"id": "4dBcRD", "name": "Water waves drag", "author": "afl_ext", "description": "This shader demonstrates how each water octave can bend sufrace UVs to emulate very appealing effect! Also its darn fast", "tags": ["procedural", "waves", "water", "drag"], "likes": 76, "viewed": 12672, "date": "1491041647", "time_retrieved": "2024-06-20T18:52:51.662280", "image_code": "//afl_ext 2018\n\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n#define WATER_DEPTH 2.1\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\n// returns vec2 with wave height in X and its derivative in Y\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, Time);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(Resolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 getatm(vec3 ray, float roughness){\n    vec3 sharp = mix(vec3( 0.0293, 0.0698, 0.1717) * 10.0, vec3(3.0), pow(1.0 - ray.y, 8.0));\n    vec3 rough = vec3(vec3( 0.0293, 0.0698, 0.1717) + vec3(1.0));\n    return mix(sharp, rough, roughness);\n}\n\nfloat sun(vec3 ray){\n    return pow(max(0.0, dot(ray, normalize(vec3(1.0, 1.0, 0.0)))), 668.0) * 110.0;\n}\n\nvec3 getColor(vec2 uv){\n\tvec3 ray = getRay(uv);\n    \n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray, 0.0) * 1.0 + sun(ray) * 2.0;\n     \treturn C; \n    }\n    \n\tvec3 wfloor = vec3(0.0, -WATER_DEPTH, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, WATER_DEPTH);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.01, WATER_DEPTH);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    vec3 R = reflect(ray, N);\n    float roughness = 1.0 - 1.0 / (dist * 0.01 + 1.0);\n    N = normalize(mix(N, vec3(0.0, 1.0, 0.0), roughness));\n    R = normalize(mix(R, N, roughness));\n    R.y = abs(R.y);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * (getatm(R, roughness) + sun(R)) * 2.0;\n    \n\treturn C;\n}\n\nvec3 gammacorrect(vec3 c){\n    return pow(c, vec3(1.0 / 2.4));\n}\n\nvec3 render(vec2 uv){\n \tvec3 ray = getRay(uv);\n    vec3 C = getColor(uv) * 0.3;\n    return gammacorrect(C);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBcRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[226, 288, 379, 379, 547], [549, 549, 595, 595, 1112], [1114, 1114, 1182, 1182, 1581], [1598, 1598, 1642, 1642, 2026], [2027, 2027, 2064, 2064, 2478], [2480, 2480, 2501, 2501, 2869], [2871, 2871, 2947, 2947, 3040], [3042, 3042, 3081, 3081, 3284], [3286, 3286, 3306, 3306, 3391], [3393, 3393, 3416, 3416, 4435], [4437, 4437, 4463, 4463, 4501], [4503, 4503, 4524, 4524, 4614], [4616, 4616, 4673, 4673, 4753]]}
{"id": "4dBczw", "name": "STAD 0001", "author": "tpen", "description": "Shadertoy-a-day, entry #1!\n\nShadertoy version of http://i.imgur.com/pGTAjg1.gifv", "tags": ["procedural", "2d", "stad", "copyagif", "shadereveryday"], "likes": 13, "viewed": 288, "date": "1491297337", "time_retrieved": "2024-06-20T18:52:52.044147", "image_code": "float pointCircle(vec2 p, vec2 center, float radius)\n{\n    float d = distance(p, center);\n    float aaf = fwidth(d);\n\treturn 1.0 - smoothstep(radius - aaf, radius, d);\n}\n\nfloat dotPattern(vec2 p)\n{\n    const float radius = 0.038;\n    const float pi = 3.14159265359;\n    const float numLayers = 9.0;\n    \n    float pr = length(p);\n    \n    if (pr > 0.95 || pr < 0.05)\n    {\n    \treturn 0.0;\n    }\n\n    float q = clamp(pr - 0.05, 0.0, 0.8);\n    float layer = 8.0 - floor(q * 10.0);\n\n    float d = 0.0;\n    float numCircles = 36.0 - layer * 4.0;\n    float r = 0.9 * (numLayers - layer) / numLayers;\n    float dist = r * pi * 2.0;\n    float speed = 4.0 / dist;\t\n    for (float index = 0.0; index < 36.0; index += 1.0)\n    {\n        if (index >= numCircles) break;\n        float a = 2.0 * pi * index / numCircles + pi * 0.25 + iTime * 0.6;\n        a -= iTime * speed;\n        vec2 pos = vec2(cos(a), sin(a)) * r;\n        d = max(d, pointCircle(p, pos, radius * (1.0 - layer * 0.04)));\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 2.0;\n    uv -= vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfloat d = dotPattern(uv);\n    float shadow_offset = 0.01;\n    float ds = dotPattern(uv + vec2(-shadow_offset, shadow_offset));                          \n         \n    vec3 bkg = vec3(56.0/255.0,\t137.0/255.0,\t157.0/255.0);\t\n    vec3 dots = vec3(253.0/255.0,\t248.0/255.0,\t255.0\t/255.0);\n    vec3 shadow = vec3(44.0/255.0,\t118.0/255.0,\t130.0/255.0);\n                  \n    vec3 c = mix(bkg, shadow, ds);\n    c = mix(c, dots, d);\n    \n\tfragColor = vec4(c, 1.0);\n}\n\n// version history:\n// 1.0 - base version [tpen]\n// 1.1 - size/movement fixes [void room]\n// 1.2 - some performance improvements [tpen]\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dBczw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 54, 54, 169], [171, 171, 197, 197, 1002], [1004, 1004, 1061, 1061, 1648]]}
{"id": "4dByzK", "name": "Point to Tesseract", "author": "balkhan", "description": "point\t\t-->\tsegment\nsegment\t-->\tsquare\nsquare\t-->\tcube\ncube\t\t-->\ttesseract\nDidn't saw one already.", "tags": ["raymarching", "translation", "tesseract"], "likes": 15, "viewed": 412, "date": "1492991523", "time_retrieved": "2024-06-20T18:52:52.050073", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t100\n#define E\t\t0.001\n\n#define L1\tvec3(0., 0., 4.)\n#define L2\tvec3(st*3.,0.,4.+ct*3.)\n\nvec3\tP00;\nvec3\tP01;\nvec3\tP02;\nvec3\tP03;\nvec3\tP04;\nvec3\tP05;\nvec3\tP06;\nvec3\tP07;\nvec3\tP08;\nvec3\tP09;\nvec3\tP10;\nvec3\tP11;\nvec3\tP12;\nvec3\tP13;\nvec3\tP14;\nvec3\tP15;\n\nvoid\trotate(inout vec2 v, float angle);\nfloat\tsdCapsule( vec3 p, vec3 a, vec3 b, float r );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\nvoid\tolala();\n\n// --globals-- //\nvec3\th;\nfloat\tg; //coloring id\nfloat\tt; // time\nfloat\tmine;\nfloat\tst;\nfloat\tct;\nvec3\te;\nvec3\ts;\n// --globals-- //\n\nconst vec3\tlightCol1 = vec3(.1,.3,.7);\nconst vec3\tlightCol2 = vec3(.5,.3,.2);\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(L1-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n        \tlightCol2 * 1.0/(distanceToL*distanceToL)\n           +lightCol1 * 1.0/(distanceToL2*distanceToL2)\n        \t)*.5;\n}\n\n// ------------volumetric light----------- //\n\t\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    t = iTime;\n\tP00 = vec3( -1., -1., -1. );\n    e = vec3(exp(-t+2.19), exp(-t+4.57), exp(-t+8.00));\n    s = vec3(step(2.19,t), step(4.57,t), step(8.00,t));\n    olala();\n    mine = 1e5;\n    st = sin(t);\n    ct = cos(t);\n\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h = vec3(0.);\n    \n    vec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 15.0);\n    vec2\tinter = (march(pos, dir));\n\n    o.xyz = blackbody(((h.x+h.y+h.z) )*100.);\n    o.xyz += vec3(abs(sin(t+1.04+g)), abs(sin(t+2.09+g)), abs(sin(t+3.14+g)))*(1.-inter.y*.0515);\n    o.xyz *= (1.-length(uv)*1.); // vignette\n    o.xyz += h*1.;\n}\n\nfloat\ttesseract(vec3 p)\n{\n\tfloat\tr = 1e5;\n\n    p.z+=-4.;\n\n    rotate(p.yx, (t)*.25);\n    rotate(p.zx, (t)*.25);\n\n    r = min(r, sdCapsule(p, P00, P01, .1) );\n    r = min(r, sdCapsule(p, P00, P02, .1) );\n    r = min(r, sdCapsule(p, P01, P03, .1) );\n    r = min(r, sdCapsule(p, P02, P03, .1) );\n\n    r = min(r, sdCapsule(p, P04, P05, .1) );\n    r = min(r, sdCapsule(p, P04, P06, .1) );\n    r = min(r, sdCapsule(p, P05, P07, .1) );\n    r = min(r, sdCapsule(p, P06, P07, .1) );\n\n    r = min(r, sdCapsule(p, P00, P04, .1) );\n    r = min(r, sdCapsule(p, P01, P05, .1) );\n    r = min(r, sdCapsule(p, P02, P06, .1) );\n    r = min(r, -1e5*s.y+s.x*1e5+sdCapsule(p, P03, P07, .1) );\n\n    //\n\n    r = min(r, sdCapsule(p, P08, P09, .1) );\n    r = min(r, sdCapsule(p, P08, P10, .1) );\n    r = min(r, sdCapsule(p, P09, P11, .1) );\n    r = min(r, sdCapsule(p, P10, P11, .1) );\n\n    r = min(r, sdCapsule(p, P12, P13, .1) );\n    r = min(r, sdCapsule(p, P12, P14, .1) );\n    r = min(r, sdCapsule(p, P13, P15, .1) );\n    r = min(r, sdCapsule(p, P14, P15, .1) );\n\n    r = min(r, sdCapsule(p, P08, P12, .1) );\n    r = min(r, sdCapsule(p, P09, P13, .1) );\n    r = min(r, sdCapsule(p, P10, P14, .1) );\n    r = min(r, sdCapsule(p, P11, P15, .1) );\n\n    //\n\n    r = min(r, sdCapsule(p, P00, P08, .1) );\n    r = min(r, sdCapsule(p, P01, P09, .1) );\n    r = min(r, sdCapsule(p, P02, P10, .1) );\n    r = min(r, 1e5*s.y+s.x*1e5-s.z*1e5*2.+sdCapsule(p, P03, P11, .1) );\n\tr = min(r, 1e5*s.y+s.x*1e5-s.z*1e5*2.+sdCapsule(p, P04, P12, .1) );\n    r = min(r, 1e5*s.y+s.x*1e5-s.z*1e5*2.+sdCapsule(p, P05, P13, .1) );\n    r = min(r, 1e5*s.y+s.x*1e5-s.z*1e5*2.+sdCapsule(p, P06, P14, .1) );\n    r = min(r, 1e5*s.y+s.x*1e5-s.z*1e5*2.+sdCapsule(p, P07, P15, .1) );\n    \n    return (r);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind;\n    mind = 1e5;\n\n\tmine = p.z+1.;\n    mine = min(mine, +(p.x)+6.);\n    mine = min(mine, -(p.x)+6.);\n    mine = min(mine, +(p.y)+5.5);\n    mine = min(mine, -(p.y)+5.5);\n    mine = min(mine, length(p-L1)-.1);\n\n    mind = tesseract(p);\n\n    p-= L2;\n\n    mind = min(mind, length(p)-.1);\n    mind = min(mine, mind);\n\n    return mind;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n    \n    for (int i = 1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.251125;\n        if (dist.x < E || dist.y > 20.)\n        {\n            if(dist.x != mine)\n                p=vec3(0.);\n\t        g +=  (step(sin(20.*abs(p.y) ), .5) \n                  + step(sin(20.*abs(p.x) ), .5)\n                  + step(sin(20.*abs(p.z) ), .5)\n                 );\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nvoid\tolala()\n{\n\tP01 = P00+vec3(2.-2.*exp(-t), 0., 0. );\n    P02 = P00+s.x*vec3(0., 2.-2.*e.x, 0. );\n    P03 = P00+s.x*vec3(2., 2.-2.*e.x, 0. );\n    P04 = P00+s.y*vec3(0., 0., 2.-2.*e.y );\n    P05 = P00+s.y*vec3(2., 0., 2.-2.*e.y );\n    P06 = P00+s.y*vec3(0., 2., 2.-2.*e.y );\n    P07 = P00+s.y*vec3(2., 2., 2.-2.*e.y );\n    P08 = P00+s.z*vec3(-2.+2.*e.z, -2.+2.*e.z, -2.+2.*e.z );\n    P09 = P00+s.z*vec3(4.-2.*e.z, -2.+2.*e.z, -2.+2.*e.z );\n    P10 = P00+s.z*vec3(-2.+2.*e.z, 4.-2.*e.z, -2.+2.*e.z );\n    P11 = P00+s.z*vec3(4.-2.*e.z, 4.-2.*e.z, -2.+2.*e.z );\n    P12 = P00+s.z*vec3(-2.+2.*e.z, -2.+2.*e.z, 4.-2.*e.z );\n    P13 = P00+s.z*vec3(4.-2.*e.z, -2.+2.*e.z, 4.-2.*e.z );\n    P14 = P00+s.z*vec3(-2.+2.*e.z, 4.-2.*e.z, 4.-2.*e.z );\n    P15 = P00+s.z*vec3(4.-2.*e.z, 4.-2.*e.z, 4.-2.*e.z );\n}\n\n\n// Utilities\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dByzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[910, 1132, 1160, 1160, 1485], [1602, 1649, 1682, 1682, 1900], [1902, 1950, 1990, 1990, 2608], [2610, 2610, 2635, 2635, 4356], [4358, 4358, 4379, 4379, 4725], [4727, 4727, 4759, 4759, 5360], [5362, 5362, 5376, 5376, 6159], [6162, 6176, 6228, 6228, 6342], [6345, 6345, 6367, 6367, 6574], [6576, 6576, 6616, 6616, 6691]]}
{"id": "4djcD1", "name": "Sketch_Text3", "author": "cexlearning", "description": "Text3，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketech"], "likes": 7, "viewed": 116, "date": "1492604550", "time_retrieved": "2024-06-20T18:52:52.056295", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat glyph(vec2 coord)\n{\n    float chars = 25.0;\n    float size = iResolution.x / chars;\n\n    // time\n    float gt = iTime * 3.5; // global\n    float ct = floor(gt); // coarse\n    float rt = fract(gt); // repeated\n\n    // position\n    vec2 gp = floor(coord / size * 7.0); // global\n    vec2 cp = floor(coord / size); // coarse\n    vec2 rp = floor(fract(coord / size) * 7.0); // repeated\n    vec2 odd = fract(rp * 0.5) * 2.0; // odd/even\n\n    // scrolling\n    vec2 gp2 = gp - vec2(0, ct * 7.0); // global (scrolled)\n    vec2 cp2 = cp - vec2(0, ct); // coarse (scrolled)\n\n    float c = max(odd.x, odd.y); // 2x2 grid\n    c *= step(0.5, rand(gp2)); // random removal\n    c += min(odd.x, odd.y); // border and center points\n\n    c *= rp.x * (6.0 - rp.x); // cropping\n    c *= rp.y * (6.0 - rp.y);\n\n    c *= max(step(1.0, cp.y), step(cp.x, chars * rt)); // 1st line anim\n    c *= step(0.15, rand(cp2 * 10.0)); // space\n    c *= step(cp.x, rand(cp2.yy * 10.0) * 10.0 + 10.0); // line end\n\n    float flicker = sin(iTime * 100.0 + coord.y * 3.1416 * 0.3) * 20.0 + 0.5;\n    c = clamp(clamp(c, 0.0, 1.0) * flicker, 0.0, 1.0);\n\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, glyph(fragCoord.xy), 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djcD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 91], [93, 93, 118, 118, 1226], [1229, 1229, 1286, 1286, 1340]]}
{"id": "4djcDh", "name": "Sketch_Dots1", "author": "cexlearning", "description": "Dots1， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 5, "viewed": 124, "date": "1492175707", "time_retrieved": "2024-06-20T18:52:52.056295", "image_code": "float swirl(vec2 coord)\n{\n    float l = length(coord) / iResolution.x;\n    float phi = atan(coord.y, coord.x + 1e-6);\n    return sin(l * 10.0 + phi - iTime * 4.0) * 0.5 + 0.5;\n}\n\nfloat halftone(vec2 coord)\n{\n    coord -= iResolution.xy * 0.5;\n    float size = iResolution.x / (60.0 + sin(iTime * 0.5) * 50.0);\n    vec2 uv = coord / size; \n    vec2 ip = floor(uv); // column, row\n    vec2 odd = vec2(0.5 * mod(ip.y, 2.0), 0); // odd line offset\n    vec2 cp = floor(uv - odd) + odd; // dot center\n    float d = length(uv - cp - 0.5) * size; // distance\n    float r = swirl(cp * size) * (size - 2.0) * 0.5; // dot radius\n    return clamp(d - r, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t fragColor = vec4(vec3(1, 1, 0) * halftone(fragCoord.xy), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djcDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 25, 25, 177], [179, 179, 207, 207, 654], [657, 657, 714, 714, 779]]}
{"id": "4djcWh", "name": "Sketch_Circles2", "author": "cexlearning", "description": "Circles2， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 5, "viewed": 70, "date": "1491970539", "time_retrieved": "2024-06-20T18:52:52.056295", "image_code": "float circle(vec2 coord, vec2 seed)\n{\n    float reso = 16.0;\n    float cw = iResolution.x / reso;\n\n    vec2 p = mod(coord, cw);\n    float d = distance(p, vec2(cw / 2.0));\n\n    float rnd = dot(floor(coord / cw), seed);\n    float t = iTime * 2.0 + fract(sin(rnd)) * 6.2;\n\n    float l = cw * (sin(t) * 0.25 + 0.25);\n    return clamp(l - d, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    vec2 dp = vec2(7.9438, 0.3335) * iTime;\n    float c1 = circle(p - dp, vec2(323.443, 412.312));\n    float c2 = circle(p + dp, vec2(878.465, 499.173));\n    float c = max(0.0, c1 - c2);\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djcWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 37, 349], [351, 351, 408, 408, 658]]}
{"id": "4djcWm", "name": "CrownFractal", "author": "Fading", "description": "Played around with elliptic curves, plugged in some complex numbers and played around some more. Calling it Crown Fractal because of the 3 to 6 jags on each of the four fractal components.", "tags": ["fractal", "animation"], "likes": 0, "viewed": 77, "date": "1492376995", "time_retrieved": "2024-06-20T18:52:52.056295", "image_code": "/**\n * Copyright (c) 2017 Niklas Rosenstein\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nvec2 cmpxmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 cmpxpow(in vec2 c, int p) {\n\tfor (int i = 0; i < p; ++i) {\n\t\tc = cmpxmul(c, c);\n\t}\n    return c;\n}\n\nint crown(in vec2 z, in vec2 c, int max) {\n    int num = 0;\n    while (length(z) < 2.0 && num < max) {\n     \tz = cmpxpow(z, 3) + z - cmpxpow(c, 2);\n        num++;\n    }\n    return num;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime / 16.0;\n    vec2 mp = vec2(cos(t), sin(t)) * 0.8;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    int max = 12;\n    int num = crown(mp, uv, max);\n    float x = float(num) / float(max);\n\tfragColor = vec4(x, x, x, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4djcWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 1124, 1160, 1160, 1222], [1224, 1224, 1256, 1256, 1327], [1329, 1329, 1371, 1371, 1515], [1517, 1517, 1572, 1572, 1822]]}
{"id": "4djczm", "name": "Parametric curve dot plotter", "author": "apazat", "description": "/A basic parametric curve plotter using dots.\nThis is one of my firsts shaders, there are lots of imperfections.", "tags": ["curve", "dots", "parametric"], "likes": 5, "viewed": 531, "date": "1491405539", "time_retrieved": "2024-06-20T18:52:52.395539", "image_code": "// Author : Antoine Pazat\n// 04/05/2017\n\n// Basic parametric curve plotter using dots.\n// Note : This is one of my firsts shaders, there are lots of imperfections.\n// A parametric curve is described by two functions of one parameter t\n// (one for the x axis one for the y axis)\n\n#define PI 3.14\n\n// Basic circle function : \n// Draws a white circle on a black background\n// [in] vec2 uv :\t\tnormalized coordinates of the window\n// [in] vec2 pos :\t\tcoordinates of the center of the circle\n// [in]\tfloat radius :\tradius of the circe\n// [out]float : \t\tfloat value describing the circle\nfloat circle(vec2 uv, vec2 pos, float radius){\n    return smoothstep(0.0,0.002,radius-length(uv + pos));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizing the coordinates between -1 and 1\n    vec2 uv = -1. + 2.*fragCoord.xy / iResolution.xy;\n    // Ratio correction\n    uv.x *= iResolution.x/iResolution.y;\n    // Initializing color to black\n    vec3 color = vec3(0.);\n    // Vector describing the parametric function.\n    vec2 pos;\n    \n    // Iteration on the parameter value.\n    // x and y axes values are between -1. and 1., so t should be varying between -2. and 2.\n    // (not sure the t value is mathematically correct)\n    for(float t=-2.; t<2.02; t+=.02){       \n        \n        // LISSAJOUS CURVE EQUATIONS\n        pos.x = sin(4.*t+(iTime));\n        pos.y = cos(6.*t);\n        \n        // Draws a white circle for each t position computed\n        color += circle(uv, pos,.05);        \n        \n    }//for\n    \n    fragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djczm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[296, 581, 627, 627, 687], [690, 690, 747, 799, 1573]]}
{"id": "4djczw", "name": "Books and Stairs", "author": "dr2", "description": "Another library, now with stairs to make it easier to move between floors  (use mouse to look around).", "tags": ["raymarch", "library"], "likes": 5, "viewed": 511, "date": "1491385560", "time_retrieved": "2024-06-20T18:52:52.423333", "image_code": "// \"Books and Stairs\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 HexCellId (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nvec3 inCell;\nvec2 szGr, bsa[4];\nfloat dstFar, tCur, rdRm, htRm, wlThk, rdHol, spShf, htShf, hRot;\nint idObj;\nbool isHole;\nconst int idRm = 1, idCol = 2, idRal = 3, idChr = 4, idBks = 5, idShlf = 6,\n   idStp = 7, idLt = 8;\n\n#define sss  max (0.5, szGr.y) // this is for screwed-up glsl on windows\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, a, da, dy, ah6, a6h, wdDor, wdShf, db, rm, stDir, fns;\n  const int ns = 16;\n  dMin = dstFar;\n  wdDor = 0.15 * szGr.x;\n  wdShf = 0.06 * rdRm;\n  q = p;\n  inCell.xy = HexCellId (q.xz / szGr.x);\n  inCell.z = floor (q.y / (2. * szGr.y) + 0.5);\n  isHole = (all (equal (mod (inCell.xy, 2.), vec2 (0.))));\n  q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  ah6 = 2. * pi * floor (6. * a + 0.5) / 6.;\n  a6h = 2. * pi * (floor (6. * a) + 0.5) / 6.;\n  rm = 1.5 - abs (r - 0.5 * (rdHol + rdRm - wlThk));\n  if (isHole) {\n    qq = q;\n    fns = float (ns);\n    stDir = 1. - 2. * step (1., mod (floor (6. * a), 2.));\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (3. * a) - stDir * 0.5 + 0.5) / 3. +\n       stDir * (0.5 * fns / (fns + 1.) + 0.8/12.) / 12.));\n    qq.y = mod (qq.y + sss, 2. * sss) - sss;\n    qq.y -= - htRm + 0.2;\n    da = stDir * 2. * pi / (2. * 6. * fns);\n    dy = (2. * sss - 0.5) / fns;\n    d = dMin;\n    for (int j = 0; j < ns; j ++) {\n      d = min (d, - min (min (rm, 0.3 - abs (qq.y)), 0.15 - abs (qq.z)));\n      qq.xz = Rot2D (qq.xz, da);\n      qq.y -= dy;\n    }\n    if (d < dMin) { dMin = d;  idObj = idStp; }\n  }\n  q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ah6);\n  d = min (max (abs (r - rdRm) - wlThk, wdDor - abs (qq.z)),\n     htRm - abs (qq.y));\n  if (isHole) {\n    d = max (d, rdHol - (0.05 + r));\n    qq.z = abs (qq.z);\n    db = min (rm, dot (qq.xz, bsa[2]));\n    d = min (max (db, d), max (db, - min (min (rm + 0.2, 0.1 -\n       abs (qq.y + htRm - 0.1)), dot (qq.xz, bsa[3]))));\n  }\n  if (d < dMin) {dMin = d;  idObj = idRm; }\n  if (isHole) {\n    d = length (max (abs (vec2 (r - rdHol, abs (abs (q.y + 0.625 * htRm) -\n       0.15 * htRm) - 0.075 * htRm)) - vec2 (0.06, 0.04), 0.)) - 0.005;\n    qq = q;  qq.y -= - htRm + 0.3 * htRm;\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (18. * a) + 0.5) / 18.));\n    qq.x += rdHol;\n    d = min (d, PrCylDf (qq.xzy, 0.05, 0.3 * htRm));\n    if (d < dMin) { dMin = d;  idObj = idRal; }\n  } else { \n    qq = q;  qq.y -= 0.7 - htRm;\n    d = PrRCylDf (qq.xzy, 2.5, 0.1, 0.7);\n    if (d < dMin) { dMin = d;  idObj = idChr; }\n    qq = q;\n    qq.xz = Rot2D (qq.xz, a6h);\n    qq.z = abs (qq.z);\n    d = max (abs (r - rdRm + wlThk + 1. * wdShf) - 0.5 * wdShf, dot (qq.xz, bsa[1]));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idBks; }\n    d = max (abs (r - rdRm + wlThk + wdShf) - wdShf, dot (qq.xz, bsa[0]));\n    d = max (d, min (abs (mod (qq.y + 0.5 * spShf, spShf) - 0.5 * spShf) - htShf,\n       - dot (qq.xz, bsa[1])));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idShlf; }\n    qq.x -= - 0.85 * rdRm;\n    qq.z -= 0.29 * rdRm;\n    d = PrCylDf (qq.xzy, 0.25, htRm);\n    if (d < dMin) {dMin = d;  idObj = idCol; }\n  }\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ((! isHole) ? a6h : ah6));\n  qq.xy -= vec2 (- 0.5 * (rdHol + rdRm - wlThk), htRm - 0.04);\n  if (! isHole) qq.z = abs (qq.z) - 1.7;\n  d = PrCylDf (qq.xzy, 0.3, 0.03);\n  if (d < dMin) {dMin = d;  idObj = idLt; }\n  if (! isHole) {\n    qq = q;\n    qq.y -= htRm + 1.7;\n    d = max (PrSphDf (qq, 2.), q.y - htRm);\n    if (d < dMin) {dMin = d;  idObj = idLt; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.8 * mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return 0.5 * sqrt3 * ((1. - p.x)  + 0.5 * min (p.x - sqrt3 * p.y, 0.));\n}\n\nvec3 HexGrdCol (vec2 p)\n{\n  p.y *= 2./sqrt3;\n  p.x += 0.5 * mod (floor (p.y), 2.);\n  p = abs (fract (p) - 0.5);\n  return mix (vec3 (0.3, 0.3, 0.25), vec3 (0.4, 0.5, 0.2),\n     smoothstep (0.05, 0.15, abs (p.x + max (p.x, 1.5 * p.y) - 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, ltVec, col, vn, q, ld, bgCol;\n  vec2 gbRm, gbBk, g, bt;\n  float dstObj, r, a, bh, s, cRm, fr, spec, ao, sh, atten;\n  bool isLit;\n  wlThk = 0.04 * szGr.x;\n  rdRm = szGr.x - 0.7 * wlThk;\n  rdHol = 0.5 * rdRm;\n  htRm = 0.93 * szGr.y;\n  spShf = htRm / 3.;\n  htShf = 0.05 * spShf;\n  float cbc[4];\n  cbc[0] = 1.1;  cbc[1] = 1.06;  cbc[2] = 1.;  cbc[3] = 0.92;\n  for (int k = 0; k < 4; k ++) \n     bsa[k] = vec2 (sin (cbc[k] * 2. * pi / 24.), cos (cbc[k] * 2. * pi / 24.));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  bgCol = (abs (rd.y) < 0.5) ? 0.5 * vec3 (0.7, 0.5, 0.) : ((rd.y > 0.) ?\n     vec3 (0.5, 0.5, 0.55) : vec3 (0., 0., 0.2));\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n    q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    gbRm = inCell.xy + inCell.z;\n    cRm = Noisefv2 (gbRm * vec2 (17., 11.));\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idRm) {\n      col = vec3 (0.8, 0.6, 0.5);\n      if (vn.y < -0.99) {\n        isLit = false;\n        if (r < 0.99 * rdRm) {\n          if (isHole) col = vec3 (0.8, 0.8, 0.6) * (1. - 0.3 * smoothstep (0.4, 3.,\n             length (vec2 (15. * (0.5 - mod (6. * a + 0.5, 1.)),\n             r - 0.5 * (rdHol + rdRm - wlThk)))));\n          else col = mix (vec3 (0.2, 0.2, 0.5), vec3 (0.4, 0.4, 0.7),\n             smoothstep (0.1, 0.8, r / rdRm)) *\n             (1. - 0.05 * SmoothBump (0.3, 0.6, 0.1, mod (10. * r / rdRm, 1.)));\n        } else col = vec3 (0.4, 0.4, 0.7);\n      } else if (abs (vn.y) < 0.01) {\n        if (r > rdRm - 0.9 * wlThk) {\n          col = vec3 (0.4, 0.4, 0.8) * (0.6 + 0.3 * q.y / htRm);\n          isLit = false;\n        } else if (isHole) {\n          if (q.y > - htRm + 0.001 && r > rdRm - wlThk - 0.01) {\n            q.xy = vec2 (10. * (mod (6. * a, 1.) - 0.5), 0.5 * q.y);\n            col = HexGrdCol (6. * q.xy);\n            if (abs (q.x) < 0.5 && abs (q.y) < 0.15) {\n              if (ShowInt (vec2 (q.x - 0.5, q.y + 0.12),\n                 vec2 (1., 0.25), 4., mod (4242. + inCell.z, 10000.)) != 0.) {\n                col = vec3 (0.7, 0.7, 0.);\n                isLit = false;\n              }\n            }\n          } else if (q.y < - htRm && r > rdHol + 0.01) {\n            col = vec3 (0.2, 0.2, 1.);\n            isLit = false;\n          } else if (r < rdHol + 0.01) {\n            col = vec3 (0.5, 0.7, 0.3) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.01,\n               mod (120. * a, 1.)));\n          }\n        } else col = 1.1 * WoodCol (vec3 (120. * a, ro.y, r), vn);\n      } else if (vn.y > 0.99 && q.y < - htRm + 0.001 &&\n         (! isHole || r > rdHol + 0.05)) {\n        col = FloorCol (vec2 (32. * a, r));\n        if (! isHole) col *= (1. + smoothstep (0.5, 0.9, r / rdRm) *\n           0.5 * smoothstep (0.1, 0.3, abs (0.5 - mod (6. * a - 0.5, 1.))));\n        col = mix (vec3 (1., 0.7, 0.), col, step (0.01, HexEdgeDist (q.xz / szGr.x)));\n      }\n    } else if (idObj == idRal) {\n      col = vec3 (0.7, 0.7, 0.5);\n      spec = 0.1;\n    } else if (idObj == idChr) {\n      if (r < 0.8) {\n        col = vec3 (0.4, 0.4, 0.7);\n        q.xz = Rot2D (q.xz, tCur);\n        q.xz = 1.2 * (q.xz - vec2 (0.4, -0.1));\n        if (ShowInt (q.xz,\n           vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + inCell.xy, 100.),\n           vec2 (100., 1.))) != 0.) {\n          col = vec3 (1., 1., 0.);\n          isLit = false;\n        }\n      } else col = vec3 (0.7, 0.5, 0.) * (0.5 +\n         0.5 * SmoothBump (0.3, 0.7, 0.02, mod (6. * a, 1.)));\n    } else if (idObj == idBks) {\n      bt = vec2 (5000. * a, 200. * q.y);\n      a = 80. * mod (6. * a + 0.5, 1.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.2 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           0.7 * SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n        if (abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n           Noisefv2 ((gbRm + gbBk) * vec2 (19., 31.) + floor (bt)) > 0.7) {\n          col *= 4.;\n        } else {\n          spec = 0.3;\n          vn.xz = Rot2D (vn.xz, q.x);\n        }\n      } else {\n        col = vec3 (0.02);\n        isLit = false;\n      }\n    } else if (idObj == idShlf) {\n      col = WoodCol (vec3 (5. * (mod (6. * a, 1.) - 0.5), ro.y, r), vn);\n    } else if (idObj == idCol) {\n      col = vec3 (0.8, 0.7, 0.6) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.02,\n         mod (4. * q.y, 1.)));\n    } else if (idObj == idStp) {\n      if (abs (r - 0.5 * (rdHol + rdRm - wlThk)) < 1.1) {\n        if (vn.y > 0.99) col = FloorCol (vec2 (64. * a, r));\n        else col = vec3 (0.7, 0.4, 0.2);\n      } else col = vec3 (0.6, 0.6, 0.9);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.7) * (0.5 - 0.5 * vn.y);\n      if (! isHole && r < 1.5) col *= 0.95 + 0.05 * sin (12. * 2. * pi * a);\n      isLit = false;\n    }\n    ltVec = roo + vec3 (0., 2., 0.) - ro;\n    atten = 1. / (1. + 0.0001 * dot (ltVec, ltVec));\n    if (isLit) {\n      ltVec = normalize (ltVec);\n      ao = ObjAO (ro, vn);\n      sh = ObjSShadow (ro, ltVec);\n      col = col * ao * (0.2 + 0.8 * atten * sh * max (0., max (dot (vn, ltVec), 0.)) +\n         atten * spec * sh * pow (max (0., dot (ltVec, reflect (rd, vn))), 16.));\n    } else col *= atten;\n  } else col = bgCol;\n  col = mix (col, bgCol, smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tp[7], td[6];\n  float dir, tm, tc;\n  tm = mod (t, 15.);\n  tc = floor (t / 15.);\n  p.y = 0.1 + 2. * tc;\n  td[0] = vec2 (1., 0.);\n  tp[0] = vec2 (-0.5 + 2. * tc, -0.5 * sqrt3);\n  dir = 1. - 2. * step (15., mod (t, 30.));\n  if (tm < 14.) {\n    hRot = 0.;\n    if (tm < 12.) {\n      dir *= -1. + 2. * step (6., tm);\n      tm = mod (tm, 6.);\n      td[1] = vec2 (0.5, 0.5 * sqrt3 * dir);\n      td[2] = vec2 (-0.5, 0.5 * sqrt3 * dir);\n      td[3] = - td[0];\n      td[4] = - td[1];\n      td[5] = - td[2];\n      for (int k = 0; k < 6; k ++) tp[k + 1] = tp[k] + td[k];\n      if (tm < 1.)      p.xz = tp[0] + td[0] * tm;\n      else if (tm < 2.) p.xz = tp[1] + td[1] * (tm - 1.); \n      else if (tm < 3.) p.xz = tp[2] + td[2] * (tm - 2.); \n      else if (tm < 4.) p.xz = tp[3] + td[3] * (tm - 3.); \n      else if (tm < 5.) p.xz = tp[4] + td[4] * (tm - 4.); \n      else if (tm < 6.) p.xz = tp[5] + td[5] * (tm - 5.); \n    } else {\n      p.xz = tp[0] + td[0] * (tm - 12.);\n    }\n  } else {\n    p.xz = tp[0] + 2. * td[0];\n    p.y += 2. * (tm - 14.);\n    hRot = 2. * pi * dir * (tm - 14.);\n  }\n  p.xz *= 4. * szGr.x;\n  p.y *= szGr.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 uv, ori, ca, sa;\n  float el, az, spd;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = clamp (el + 0.8 * pi * mPtr.y, -0.3 * pi, 0.3 * pi);\n  }\n  szGr = vec2 (15., 3.3);\n  spd = 0.12;\n  fpF = TrackPath (spd * tCur + 0.1);\n  az += hRot;\n  fpB = TrackPath (spd * tCur - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  dstFar = 500.;\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 HexCellId (vec2 p)\n{\n  vec3 c, r, dr;\n  p.y *= (1./sqrt3);\n  c.xz = vec2 (0.5 * (p.x - p.y), p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (2., step (dr.yzx, dr) + step (dr.zxy, dr)) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4djczw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 947, 969, 969, 4285], [4287, 4287, 4320, 4320, 4496], [4498, 4498, 4519, 4519, 4728], [4730, 4730, 4762, 4762, 4960], [4962, 4962, 4999, 4999, 5223], [5225, 5225, 5256, 5256, 5473], [5475, 5475, 5499, 5499, 5673], [5675, 5675, 5703, 5703, 5794], [5796, 5796, 5821, 5821, 6038], [6040, 6040, 6075, 6075, 11733], [11735, 11735, 11761, 11761, 12909], [12911, 12911, 12964, 12964, 13896], [13898, 13898, 13931, 13931, 13958], [13960, 13960, 14002, 14002, 14053], [14055, 14055, 14108, 14108, 14169], [14171, 14171, 14224, 14224, 14403], [14405, 14405, 14451, 14451, 14508], [14510, 14510, 14535, 14535, 14772], [14774, 14774, 14831, 14831, 14914], [14916, 14916, 14946, 14946, 15004], [15127, 15127, 15151, 15151, 15198], [15200, 15200, 15225, 15225, 15424], [15426, 15426, 15447, 15447, 15602], [15604, 15604, 15628, 15628, 15764], [15766, 15766, 15789, 15789, 15848], [15921, 15921, 15953, 15953, 16495], [16497, 16497, 16557, 16557, 17132]]}
{"id": "4dScRG", "name": "Distance field test", "author": "nuclear", "description": "Just bored and thought I'd try a funky distance function.", "tags": ["foo"], "likes": 6, "viewed": 454, "date": "1492481702", "time_retrieved": "2024-06-20T18:52:52.424330", "image_code": "#define THRES\t\t1e-3\n#define MAX_ITER\t250\n#define MAX_STEP\t0.1\n#define M_PI\t\t3.14159265\n\nfloat calc_dist(in vec3 p);\n\nvec3 ray_march(in vec3 p, in vec3 dir);\nvec3 colorize(in vec3 p, in vec3 dir, in float dist);\nvec3 backdrop(in vec3 dir);\nvec3 get_ray_dir(in vec2 p);\n\nfloat tsec;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    tsec = iTime;\n    \n    vec3 origin = vec3(0.0, 0.0, -13.0);\n    vec3 dir = normalize(get_ray_dir(uv));\n    \n    fragColor.rgb = ray_march(origin, dir);\n    fragColor.a = 1.0;\n}\n\nfloat calc_dist(in vec3 p)\n{\n    const vec3 sph_pos = vec3(0.0, 0.0, 0.0);\n    vec3 sph_dir = p - sph_pos;\n    float sph_dist = length(sph_dir * vec3(1.0, 1.0, 1.0));\n    sph_dir = normalize(sph_dir);\n    float theta = atan(sph_dir.z, sph_dir.x) + M_PI + cos(sph_dist + tsec * 2.0) * 0.1;\n    theta = mod(theta - tsec * 0.2, 2.0 * M_PI);\n    float phi = acos(sph_dir.y) + cos(sph_dist + tsec * 1.2) * 0.1;\n    \n    float rad = 5.0 + (1.0 - sin(theta * 8.0)) * 1.0 *\n        (1.0 - cos(phi * 10.0)) * 1.0;\n    sph_dist -= rad;\n    \n    return sph_dist;\n}\n\nvec3 ray_march(in vec3 p, in vec3 dir)\n{\n    float d, total_d = 0.0;\n    \n    for(int i=0; i<MAX_ITER; i++) {\n        if((d = calc_dist(p)) <= THRES) {\n            return colorize(p, dir, total_d);\n        }\n        \n        d = min(d, MAX_STEP);\n        \n        p = p + dir * d;\n        total_d += d;\n    }\n    \n    return backdrop(dir);\n}\n\nvec3 calc_normal(in vec3 p)\n{\n    const float delta = 1e-2;\n    float gx = calc_dist(p + vec3(delta, 0.0, 0.0)) - calc_dist(p - vec3(delta, 0.0, 0.0));\n    float gy = calc_dist(p + vec3(0.0, delta, 0.0)) - calc_dist(p - vec3(0.0, delta, 0.0));\n    float gz = calc_dist(p + vec3(0.0, 0.0, delta)) - calc_dist(p - vec3(0.0, 0.0, delta));\n    return normalize(vec3(gx, gy, gz));\n}\n\nvec3 colorize(in vec3 p, in vec3 dir, in float dist)\n{\n    const vec3 kd = vec3(1.0, 0.3, 0.1);\n    const vec3 ks = vec3(0.7, 0.7, 0.7);\n    const vec3 ldir = normalize(vec3(-1.0, 1.0, -1.5));\n    const vec3 vdir = vec3(0.0, 0.0, -1.0);\n\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    \n    vec3 n = calc_normal(p);\n    vec3 hdir = normalize(ldir + vdir);\n\n    float ndotl = max(dot(n, ldir), 0.0);\n    float ndoth = max(dot(n, hdir), 0.0);\n    \n    diffuse += kd * ndotl;\n    specular += ks * pow(ndoth, 50.0);\n    \n    float fog = clamp(300.0 / (dist * dist), 0.0, 1.0);\n\n    return mix(backdrop(dir), diffuse + specular, fog);\n}\n\nvec3 backdrop(in vec3 dir)\n{\n    return vec3(0.5, 0.5, 0.7);\n}\n\nvec3 get_ray_dir(in vec2 p)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return vec3(aspect * (p.x * 2.0 - 1.0), p.y * 2.0 - 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dScRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[282, 282, 339, 339, 567], [569, 569, 597, 597, 1122], [1124, 1124, 1164, 1164, 1465], [1467, 1467, 1496, 1496, 1844], [1846, 1846, 1900, 1900, 2514], [2516, 2516, 2544, 2544, 2578], [2580, 2580, 2609, 2609, 2728]]}
{"id": "4dScWG", "name": "Bad Dream", "author": "slerpy", "description": "I wrote a working raytracer, tortured it to death and gave it some music.\n\nThe music might still be loading while the shader has already started, so I recommend resetting the whole demo as soon as you hear the music kick into action.", "tags": ["3d", "raytracer", "music"], "likes": 2, "viewed": 165, "date": "1493472530", "time_retrieved": "2024-06-20T18:52:52.424330", "image_code": "// map function is based of this shader:\n// https://www.shadertoy.com/view/ldyGWm\n\nfloat map(vec3 q){\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    p =  abs(fract(q*2.)*.5 - .25);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n}\n\nfloat tracer(in vec3 ro, in vec3 rd)\n{\n    float t = .0;\n    for(int i=0; i<8; i++) {\n        float m = map(ro+rd*t);\n        if(m < 0. || t > 1.)break;\n        t += m;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p, float k)\n{\n    vec2 e = k * vec2(1,0); \n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float ang = atan(uv.x,uv.y)+iTime/16.;\n    uv = vec2(sin(ang),cos(ang))*length(uv);\n    \n    vec3 ro = vec3(vec2(0.),iTime/8.);\n    vec3 rd = vec3(iTime/24.,uv);\n    \n    float t = tracer(ro, rd);\n    \n    vec3 sp = ro + rd * t;\n    vec3 sn = normal(sp, .001);\n    \n    vec3 ld = normalize(rd+vec3(.5));\n    float angle = (1.+dot(sn,ld))/2.;\n    \n    fragColor = vec4(angle - pow(t/10.,.5));\n    fragColor = fract( 2. * fragColor * cos(200.*iTime*0.01308996938995747182692768076366) );\n    fragColor.r = max(.3-fragColor.r,fragColor.r);\n    fragColor.rgb -= sn.rbb;\n    fragColor *= min(.1 * iTime, 1.);\n}\n", "image_inputs": [{"id": "4slSzn", "previewfilepath": "https://soundcloud.com/virgill/virgill-wannabe-a-64", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/virgill/virgill-wannabe-a-64", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dScWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 83, 101, 101, 343], [345, 345, 383, 383, 535], [537, 537, 567, 567, 755], [757, 757, 814, 814, 1488]]}
{"id": "4dSyDm", "name": "The Raven That Refused To Sing", "author": "s23b", "description": "yet another shader inspired by an album cover, this time it's [url=http://bit.ly/2owVY2y]The Raven That Refused to Sing (And Other Stories)[/url] by Steven Wilson\n\nmusic: [url=https://youtu.be/n8sLcvWG1M4]the last song of the album[/url]", "tags": ["2d", "stars", "moon", "albumcover", "stevenwilson", "theraventhatrefusedtosing"], "likes": 10, "viewed": 682, "date": "1492768243", "time_retrieved": "2024-06-20T18:52:53.165219", "image_code": "#define saturate(x) clamp(x, 0., 1.)\n\n// width of the blur when rendering SDFs\nfloat _blur = .01;\n\n// distortion matrix for FBM function\nconst mat2 mat = mat2(.8, -.6, .6, .8);\n\n// simple 2D hash\nfloat hash(vec2 uv) {\n    return fract(sin(dot(uv, vec2(.009123898, .00231233))) * 1e5);\n}\n\n// 2D noise (lerp between grid point noise values\nfloat noise(vec2 uv) {\n    vec2 fuv = floor(uv);\n    vec4 cell = vec4(\n        hash(fuv + vec2(0, 0)),\n        hash(fuv + vec2(0, 1)),\n        hash(fuv + vec2(1, 0)),\n        hash(fuv + vec2(1, 1))\n    );\n    vec2 axis = mix(cell.xz, cell.yw, fract(uv.y));\n    return mix(axis.x, axis.y, fract(uv.x));\n}\n\n// 2D fractional Brownian motion\nfloat fbm(vec2 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        uv *= mat;\n        f += noise((uv += 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// function that tries going up and down with a tangent of 1,\n// but the gaps and the bumps grow exponentially\nfloat logSaw(float x) {\n    return (abs(fract(log(x + 1.) * 4.) - .5) - .25) * (x + 1.) / 4.;\n}\n\n// rectangle distance function (used for the nose\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// render an array of shaking distorted concentric circles\nfloat shakyCircles(vec2 uv, float offset, float time) {\n    float l = length(uv);\n    uv += (vec2(fbm(vec2(uv.x * .5, time)), fbm(vec2(uv.y * .5, time + 10.))) - .5) * 1. * (.05 + l);\n    l = length(uv);\n    float d = abs(logSaw(l + offset * l));\n    d += (l - .75) * .15;\n    \n    return smoothstep(_blur, -_blur, d);\n}\n\n// layer shaky circles on top of each other\nfloat hole(vec2 uv, float time) {\n    float f = 0.;\n    for (float i = .0; i <= .5; i += .25) {\n    \tf += shakyCircles(uv, i, time * 2. + i * 55.) / 3.;\n    }\n    return saturate(1.- f);\n}\n\n// same as above, only this time we use rounded rectangles, and only render the bottom half\nfloat shakyHalfCircles(vec2 uv, float offset, float time) {\n    float l = sdRect(uv, vec2(.05, .3));\n    uv += (vec2(fbm(vec2(uv.x * .5, time)), fbm(vec2(uv.y * .5, time + 10.))) - .5) * 1. * (.05 + l);\n    l = sdRect(uv, vec2(.05, .3));\n    float d = abs(logSaw(l + offset * l));\n    d += ((abs(l - .3) - .3) + smoothstep(-.6, 2., uv.y)) * .15;\n    \n    return smoothstep(_blur, -_blur, d);\n}\n\n// render a nose, just like a hole, but layering t\nfloat nose(vec2 uv, float time) {\n    float f = 0.;\n    for (float i = .0; i <= .5; i += .25) {\n    \tf += shakyHalfCircles(uv, i, time * 2. + i * 55.) / 3.;\n    }\n    return saturate(1.- f);\n}\n\n// render a circle with radius r\nfloat circle(vec2 uv, float r) {\n    float d = length(uv) - r;\n    return smoothstep(_blur, -_blur, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.3;\n    \n    // get some frequencies from the fft\n    float speed = texture(iChannel0, vec2(.1, .25)).x * .1;\n    float bgspeed = texture(iChannel0, vec2(.3, .25)).x;\n    float mouthSize = texture(iChannel0, vec2(.7, .25)).x;\n \t\n    // add a distortion (blur + zoom)\n    // that comes in waves and reacts to high frequencies\n    float s = sin(uv.y * .8 + uv.x * .4 + iTime * 2.);\n    s = texture(iChannel0, vec2(.8, .25)).x * saturate(4. - length(uv)) * s * s * s * s;\n    _blur = .01 + .1 * s;\n    uv /= 1. + s * .1;\n    \n    vec3 color = vec3(0);\n    float f = 1.;\n    \n    float time = iTime;\n    \n    // uv for head shape/stars/pupils\n    vec2 puv = uv + (vec2(fbm(vec2(uv.x * 2., time)), fbm(vec2(uv.y * 2., time + 10.))) - .5) * .1;\n    \n    // shade on head\n    f += hole(uv / 3. + vec2(0, .1), time * .1 + bgspeed) * .6;\n    f -= hole(uv * 1.5 + vec2(0, .3), time * .1 + bgspeed) * .4;\n    // head\n    f *= circle(puv, 2.);\n    // shade behind\n    f  = max(f,.25- hole(uv / 4. + vec2(0, .1), time * .01) * .25);\n    // mouth\n    vec2 muv = (uv + vec2(0, 1.2)) * vec2(1.2 - mouthSize * .2, 1.2 - mouthSize * .8);\n    f *= hole(muv, time * (1. + speed * 2.));\n    // nose\n    f *= nose(uv + vec2(0, -.1), iTime * (1. + speed * 2.));\n    // eyes\n    f *= hole(uv - vec2(-.9, .2), iTime * (1. + speed * 5.)) * hole(uv - vec2(.9, .2), iTime * (1. + speed * 5.) + 3.);\n    // pupils\n    f += circle(puv - vec2(-.9, .2), .18) + circle(uv - vec2(.9, .2), .15);\n    \n    // render some stars with hard coded dimensions\n    f += circle(puv - vec2(-3., 1.4), .1) + circle(puv - vec2(3, 1), .13)\n       + circle(puv - vec2(2.5, -1), .05) + circle(puv - vec2(-3.6, -1.5), .05)\n       + circle(puv - vec2(3.6, -1.7), .06) + circle(puv - vec2(-2.2, .2), .05)\n       + circle(puv - vec2(3.4, 1.7), .07) + circle(puv - vec2(-2.2, -1.6), .1);\n    \n    // add some noise\n    f = saturate(f * .8 + (fbm(uv * 4.) - .5) * .2);\n    color = mix(vec3(.08, .1, .06), vec3(.95, .85, .75), f);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "ldBGDd", "previewfilepath": "https://soundcloud.com/kscopemusic/steven-wilson-the-raven-that", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kscopemusic/steven-wilson-the-raven-that", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSyDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[178, 196, 217, 217, 286], [288, 338, 360, 360, 641], [643, 676, 696, 696, 872], [874, 985, 1008, 1008, 1080], [1082, 1132, 1162, 1162, 1237], [1239, 1298, 1353, 1353, 1618], [1620, 1664, 1697, 1697, 1852], [1854, 1946, 2005, 2005, 2339], [2341, 2392, 2425, 2425, 2584], [2586, 2619, 2651, 2651, 2724], [2726, 2726, 2783, 2783, 4900]]}
{"id": "4dyXD1", "name": "Red Strobe", "author": "30000fps", "description": "I'd really like to learn more.. if anyone can recommend tutorials or a good place to start", "tags": ["test", "strobe"], "likes": 1, "viewed": 102, "date": "1492897059", "time_retrieved": "2024-06-20T18:52:53.171391", "image_code": "// i have no idea what i'm doing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    // gradient\n    // fragColor = vec4(uv.x,uv.y,0.5+0.5*sin(iTime*1.5),1.0);\n    \n    // red speed1\n    fragColor = vec4(0.5+0.5*sin(iTime*1.),.0,.1,1.0);\n       \n    // red speed10\n    // fragColor = vec4(0.5+0.5*sin(iTime*10.),.0,.1,1.0);\n    \n    // red speed20\n    // fragColor = vec4(0.5+0.5*sin(iTime*20.),.0,.1,1.0);\n    \n    // red speed50\n    // fragColor = vec4(0.5+0.5*sin(iTime*50.),.0,.1,1.0);\n    \n    // red blue speed100\n    // fragColor = vec4(0.5+0.5*sin(iTime*100.),.0,.5,1.0);\n    \n}", "image_inputs": [{"id": "4djGDt", "previewfilepath": "https://soundcloud.com/logic-moon/im-in-your-veins", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/logic-moon/im-in-your-veins", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyXD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 34, 91, 91, 641]]}
{"id": "4s2cRt", "name": "diamonds or circles", "author": "public_int_i", "description": "diamonds or circles.", "tags": ["circles", "diamonds", "or"], "likes": 2, "viewed": 572, "date": "1493340478", "time_retrieved": "2024-06-20T18:52:53.171391", "image_code": "//Ethan Alexander Shulman 2017\n\n\n#define circleSize 0.1\n\n#define draw(dc) c = mix(dc,c,clamp(d/pixelSize, 0., 1.))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelSize = length(1.0/iResolution.xy);\n\tvec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.x;\n    \n    \n    vec3 c = vec3(1.);//start with white background\n    \n    //deform\n    uv *= 1.+length(uv)*(5.+cos(iTime*0.25)*4.);\n    \n    //scrolling repeating black circles\n\tvec2 ruv = mod(abs(uv+vec2(0.,iTime*0.2)),circleSize*2.)-circleSize;    \n    float d = (length(ruv)-circleSize);\n    draw(vec3(0.));\n    \n    //output color\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2cRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 117, 174, 174, 645]]}
{"id": "4s2cWR", "name": "Per-Pixel Randomness", "author": "imallett", "description": "Demonstration of simple per-pixel white noise. The distribution is not particularly great, but it's simple and fast.", "tags": ["procedural", "2d", "random"], "likes": 5, "viewed": 270, "date": "1491606022", "time_retrieved": "2024-06-20T18:52:53.395636", "image_code": "//RNG state\nuvec2 rvec;\nuint _george_marsaglia() {\n\trvec.x = 36969u * (rvec.x & 65535u) + (rvec.x >> 16u);\n\trvec.y = 18000u * (rvec.y & 65535u) + (rvec.y >> 16u);\n\treturn (rvec.x << 16u) + rvec.y;\n}\n\n//Random Functions\nfloat rand_float() {\n\treturn float(_george_marsaglia()) / float(0xFFFFFFFFu);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\t//Initialize RNG offset parameter.  This should be as random as possible,\n\t//\ttaking into account time and possibly screen position.  You can use a\n\t//\tuniform or SSBO to save its state across frames.  Something like:\n\t//\t\tstatic Vec2 offset = Vec2(0,0); //or maybe a random value\n\t//\t\t//Then, each frame, do these lines:\n\t//\t\toffset.x = 71.000*fract(offset.x+1.2);\n\t//\t\toffset.y = 12.444*fract(offset.y+4.9);\n\t//\tFor now, just make it use the time:\n\tvec2 offset = vec2(iTime,0.0);\n\n\t//Initialize RNG\n\trvec = uvec2(397.6432*(coord.xy+offset));\n\trvec ^= uvec2(32.9875*(coord.yx+offset));\n\n\t//Return a random color\n\tcolor = vec4(vec3(\n\t\trand_float(),\n\t\trand_float(),\n\t\trand_float()\n\t),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2cWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 24, 50, 50, 198], [200, 219, 239, 239, 298], [300, 300, 347, 798, 1039]]}
{"id": "4s2cWw", "name": "Deform ray noise it", "author": "Loeizd", "description": "poor noise on top of https://www.shadertoy.com/view/MsByDm", "tags": ["ray"], "likes": 0, "viewed": 107, "date": "1492355315", "time_retrieved": "2024-06-20T18:52:53.971490", "image_code": "#define PI 3.141592653589\nvec3 NoiseIt(vec3 img)\n{\n\treturn vec3(sin(img.x*9897.), sin(img.y*7654.8),sin(img.z*97.));    \n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    //vec3 offset = vec3(0.,0.,0.);\n    //c = c+offset;\n    vec3 q = mod(p,c)-0.5*c;\n    //return sdTorus( q , vec2(0.1, 0.05));\n    \n    float s = 0.1;\n    //s=  (1.-fract(iDate.w*2.))*0.01 + 0.09;\n    return sdBox( q , vec3(s));//vec3(0.1, 0.1, 0.1));\n}\n\n// Raymarching\nconst float rayEpsilon = 0.001;\nconst float rayMin = 0.1;\nconst float rayMax = 1000.0;\nconst int rayCount = 64;\n\n// Camera\n\nvec3 right = vec3(1, 0, 0);\nvec3 up = vec3(0, 1, 0);\n\n// Colors\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\nvec3 skyColor = vec3(0, 0, 0.1);\nvec3 shadowColor = vec3(0, 0, 0);\n\nfloat sphere( vec3 p, float s ) { return length(p)-s; }\nfloat reflectance(vec3 a, vec3 b) { return dot(normalize(a), normalize(b)) * 0.5 + 0.5; }\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\nvec3 rotateY(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost); }\nvec3 rotateX(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost); }\nvec3 rotateZ(vec3 p, float angle) { \n\tfloat c = cos(angle); float s = sin(angle);\n  \treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z); }\n\n\nvec2 rotation(vec2 p, float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0, 0, -1.5);\n\tvec3 front = vec3(0.,0.,1.);//vec3(0, 0, 1.);//iTime+2.);   \n    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    // Color\n    vec3 color = skyColor;\n    \n    // Animation\n    float translationTime = iTime * 0.5;\n    \n    // Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        //vec3 dist = float(r)*0.1*vec3(sin(iDate.w)*0.01,0., 0.);\n        // Ray Position\n        vec3 p = eye + ray * t;\n        p.xy = rotation(p.xy, t*0.8*sin(iTime));\n        p.yz = rotation(p.yz, t*0.08*sin(iTime*2.));\n        p.z = p.z + iDate.w*5.5;\n        p.y = p.y + sin(iDate.w*.2)*6.;\n        \n        // Distance to Sphere\n        float d = sphere(p, 0.5);\n        d = opRep(p,vec3(0.5,0.5,0.5));\n        \n        // Distance min or max reached\n        if (d < rayEpsilon || t > rayMax)\n        {\n            // Shadow from ray count\n            color = mix(lightColor, shadowColor, float(r) / float(rayCount));\n            \n            // Sky color from distance\n            color = mix(color, skyColor, smoothstep(rayMin, rayMax, t));\n            break;\n        }\n        \n        // Distance field step\n        t += d;\n    }\n    \n    float select = clamp(floor(sin(iDate.w*64.)+1.), 0.,1.);\n    \n    // Hop\n\tfragColor = select-vec4(NoiseIt(color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2cWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 50, 50, 122], [124, 124, 155, 155, 242], [243, 243, 276, 276, 341], [343, 343, 374, 430, 630], [825, 942, 975, 975, 997], [998, 998, 1033, 1033, 1087], [1088, 1088, 1114, 1114, 1159], [1160, 1160, 1191, 1191, 1309], [1310, 1310, 1341, 1341, 1458], [1459, 1459, 1494, 1494, 1590], [1593, 1593, 1629, 1629, 1701], [1705, 1705, 1762, 1762, 3205]]}
{"id": "4s2czc", "name": "rotation explotion", "author": "abje", "description": "rotation/mirroring a cross 20 times", "tags": ["fractal", "square", "rotation"], "likes": 11, "viewed": 459, "date": "1493142181", "time_retrieved": "2024-06-20T18:52:53.971490", "image_code": "\n/**/\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define loops 20\nvec2 mirrorrep(vec2 uv) {\n    return abs(mod(uv,2.0)-1.0)-0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 4.0*(fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    mat2 rotmat = rot(iTime*0.1);\n    int i = 0;\n    for(i = 0; i < loops; i++) {\n        uv = (abs(uv+1.0)-1.0)*rotmat;\n        if (min(uv.x,uv.y)>0.5)break;\n    }\n    \n\tfragColor = vec4(float(i)/float(loops));\n}\n/**/\n\n//179  by coyote using iTime:\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u = 4.*(u+u - (o.xy=iResolution.xy)) / o.y;\n    for(o-=o;\n        u=(abs(++u)-1.)*mat2(cos(1.57*vec4(0,1,3,0)-iTime*.1)),\n        max(o.x, min(u.x,u.y)*2.)<1.;\n        o+=.05);\n}\n/**/\n\n//178 chars by FabricaNeyret2:\n/**\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u = 4.*(u+u - (o.xy=iResolution.xy)) / o.y;\n    for (o-=o; o.x<1.; o+=.05)\n    {\n        u = (abs(++u)-1.) * mat2(cos(.8*vec4(0,2,6,0) - iDate.w*.1));\n        if (min(u.x,u.y)>.5) break;\n    }\n}\n/**/\n\n//154 chars by GregRostami:\n/**\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u = u/.1/iResolution.x-4.;\n    for(o-=o;\n        u=(abs(++u)-1.)*mat2(cos(.8*vec4(0,2,6,0)-iTime*.1)),\n        max(o.x, min(u.x,u.y)*2.)<1.;\n        o+=.05);\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2czc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 88, 113, 113, 152], [154, 154, 211, 211, 495]]}
{"id": "4s2yR3", "name": "Loading icon for VR", "author": "michaelxqy", "description": "Loading icon for VR", "tags": ["shaderloadingicon"], "likes": 1, "viewed": 128, "date": "1493116254", "time_retrieved": "2024-06-20T18:52:53.971490", "image_code": "\n#define SMOOTH(r) (mix(1.0, 0.0, smoothstep(0.9,1.0, r)))\n#define M_PI 3.1415926535897932384626433832795\n\nfloat movingRing(vec2 uv, vec2 center, float r1, float r2)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = -atan(d.y,d.x);\n    theta  = mod(-iTime+0.5*(1.0+theta/M_PI), 1.0);\n    //anti aliasing for the ring's head (thanks to TDM !)\n    theta -= max(theta - 1.0 + 1e-2, 0.0) * 1e2;\n    return theta*(SMOOTH(r/r2)-SMOOTH(r/r1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    if(fragCoord.x < iResolution.x/2.0)\n    {\n    \tfloat ring = movingRing(uv, vec2(iResolution.x/4.0,iResolution.y/2.0), 20.0, 30.0);\n    \tfragColor = vec4( 0.1 + 0.9*ring );\n    }\n    else\n    {\n        float ring = movingRing(uv, vec2(iResolution.x * 0.75,iResolution.y/2.0), 20.0, 30.0);\n        fragColor = vec4( 0.1 + 0.9*ring );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[107, 107, 167, 167, 491], [493, 493, 550, 550, 919]]}
{"id": "4s2yRc", "name": "Firstshader_2", "author": "Gwynbleidd", "description": "Fragmentshader liczący kształt wykorzystując funkcje SDF. ", "tags": ["sdf"], "likes": 0, "viewed": 76, "date": "1493136256", "time_retrieved": "2024-06-20T18:52:53.977570", "image_code": "#define rot_v 1.0\n#define dark 1.0\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat cube (vec3 p)\n{\n    p = abs(p);\n    return max(p.x, max(p.y, p.z)) - 0.8;\n}\nfloat sdf(vec3 p)\n{\n //gdy 1   r\n  //  return sphere(p, 1.0);\n    // gdy 2 sfery\nreturn max(max (cube(p),sphere(p - vec3(-0.0, 0.0, 0.0), 1.0)),  -sphere(p, 0.95)); //min - suma, max - czesc wspolna\n// return max (cube(p),sphere(p - vec3(-0.0, 0.0, 0.0), 1.0)); //min - suma, max - czesc wspolna\n\n    //cube\n  //  return cube(p);\n} \nvec2 rot(vec2 p, float a)\n{\n  return cos(a) * p - vec2(p.y, -p.x) * sin(a);  \n}\nfloat sdf_rot(vec3 p)\n{\n    /*\n   p.y = p.y/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n   p.x = p.x/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n   p.z = p.z/(2.0*abs(cos(1.0*iTime+0.5))+1.0);\n\n   //*/ \n    \n   p.xz = rot(p.xz, iTime*0.5 * rot_v);\n   p.xy = rot(p.xy, iTime*0.5 * rot_v);\n   p.zy = rot(p.zy, iTime*0.7 * rot_v);\n\n    return sdf(p); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (fragCoord.xy - iResolution.xy * 0.5)/iResolution.x * 0.5;  //zrobienie kwadratu bo na tym polu pozniej pracujemy\n   \n    //definujemy kolory pikseli\n  \tvec3 cam = vec3(-50.0, 4.0*cos(1.0*iTime), 4.0*sin(1.0*iTime)); \n  //vec3 cam = vec3(   - 50.0, 0.0, -6.0*abs(cos(1.0*iTime))+3.0);   \n\t//vec3 cam = vec3(-25.0, 0.0, 0.0); \n    vec3 ray = vec3(1.0, uv.x, uv.y); // do robienia odleglosci\n    \n    float d = 0.0;\n    vec3 p;\n\tfor (int i = 0; i < 100; ++i) //sprawdzamy jak daleko jestesmy\n    {\n       p = 0.5*(cam + ray * d);\n        float nearest = sdf_rot(p);\n        d += nearest; \n        if (d > 1000.0 || nearest < 0.002) break;\n    }\n    \n    if (d > 1000.0)\n    {\n       // fragColor = vec4(0.85  ,0.45   ,0.62 , 0.55  );\n        fragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n        return;\n    }\n\t// gradient daje normalna\n   \n   // p = cam + ray * d\n    \n    vec3 ldir = normalize(vec3(-60.0, 5.0 + 10.0*cos(1.0*iTime), 5.0 + 1.0*cos(1.0*iTime)));\n    //vec3 ldir = normalize(vec3(-20.0, 30.0, 20.0 ));\n    \n//Liczenie gradientu\n    vec2 delta = vec2(0.02, 0.0);\n    vec3 normal;\n    normal.x = sdf_rot(p + delta.xyy) - sdf_rot(p); //xyy - wektor 3d z wektora 2d\n    normal.y = sdf_rot(p + delta.yxy) - sdf_rot(p); //xyy - wektor 3d\n    normal.z = sdf_rot(p + delta.yyx) - sdf_rot(p); //xyy - wektor 3d\n    normalize (normal);   //zamiast pochodnej w gradiencie - normalizacja\n   \n    /*\n     dotproduct - dlugosc rzutu wektora na drugi (od 0 do 1 - 90  stopni)\n\t normalize wektor w kierunku o dlugosci 1\n   \t float en1 = clamp(dot(ldir, normal) , 0.0, 1.0);                         \n     float en1 = 20.0 * dot(ldir, normal);\n*/\n  float  en1 = 50.0 * clamp(dot(ldir,normal),0.0,0.02);\t\n//    float en1 = 1.0;\n        en1 *= dark ;\n        fragColor = vec4(0.85 * en1 ,0.15 * en1  ,0.62 * en1 , 0.55 * en1 ) ; // drugi 0.35 - rozowy\t\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[36, 36, 67, 67, 95], [96, 96, 117, 117, 177], [178, 178, 197, 258, 509], [511, 511, 538, 538, 590], [591, 591, 614, 774, 923], [925, 925, 982, 982, 2876]]}
{"id": "4s2yRW", "name": "Schottky Orange", "author": "soma_arc", "description": "Volume rendered kissing Schottky orbit of spheres.\nLooks delicious!", "tags": ["3d", "volume", "schottky"], "likes": 5, "viewed": 99, "date": "1491145758", "time_retrieved": "2024-06-20T18:52:55.007946", "image_code": "/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nconst vec3 SPHERE_POS1 = vec3(100, 100, 0);\nconst vec3 SPHERE_POS2 = vec3(100, -100, 0);\nconst vec3 SPHERE_POS3 = vec3(-100, 100, 0);\nconst vec3 SPHERE_POS4 = vec3(-100, -100, 0);\nconst vec3 SPHERE_POS5 = vec3(0, 0, 141.42);\nconst vec3 SPHERE_POS6 = vec3(0, 0, -141.42);\nconst float SPHERE_R = 100.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nvec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nconst float MAX_KLEIN_ITARATION = 30.;\nfloat IIS(vec3 pos){\n  float loopNum = 0.;\n  float dr = 1.;\n  bool loopEnd = true;\n  for(float i = 0. ; i < MAX_KLEIN_ITARATION ; i++){\n    loopEnd = true;\n    if(distance(pos, SPHERE_POS1) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS2) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS3) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS4) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS5) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS6) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }\n    if(loopEnd == true) break;\n  }\n  \n  return loopNum;\n}\n\n\nvec4 sampleVolume(vec3 p) {\n    float itCount, minDist, maxDist;\n    float loopNum = IIS(p);\n    if(loopNum == 0.) return vec4(0);\n\treturn vec4(hsv2rgb(vec3(2.5 * loopNum / MAX_KLEIN_ITARATION , 1., 1.)), \n                pow(loopNum / MAX_KLEIN_ITARATION, 1.4));\n}\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec4 l = vec4(0);\n\n\tfloat t0, t1;\n   \tbool hit = intersectBox(eye, ray, \n                    \t\tvec3(-250), vec3(250),\n                    \t\tt0, t1);\n    \n    if(!hit) return l.rgb;\n    \n    const float MAX_SAMPLES = 150.;\n    float t = t0;\n    float tStep = (t1 - t0) / MAX_SAMPLES;\n    \n    vec3 p0 = eye + t0 * ray;\n    vec3 p1 = eye + t1 * ray;\n    vec3 distP = p0 - p1;\n    float dist = abs(dot(vec3(1, 0, 0), distP));\n    dist = max(dist, abs(dot(vec3(0, 1, 0), distP)));\n    dist = max(dist, abs(dot(vec3(0, 0, 1), distP)));\n    float sliceWidth = .05;\n    float samples = floor(dist / sliceWidth) + 1.;\n    //tStep = (t1 - t0) / samples;\n    samples = MAX_SAMPLES;\n    for (float i = 0.; i < MAX_SAMPLES; i++){\n    \tif((min(min(l.x, l.y), l.z)) > 1.0 ||\n           l.w > 0.999 ||\n           t >= t1 ||\n          samples < i) break;\n        \n        vec3 p = eye + t * ray;\n        \n        vec4 volCol = sampleVolume(p);\n        volCol.a *= 1.;\n        volCol.rgb *= volCol.a;\n        l = (1. - l.a) * volCol + l;\n        \n        t += tStep; \n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float r = 400.;\n    vec3 eye = vec3(r * sin(iTime) , r/1.5 * sin(iTime), \n                    r * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 541], [639, 639, 791, 791, 1151], [1202, 1202, 1229, 1229, 1343], [1345, 1345, 1466, 1466, 2232], [2580, 2580, 2639, 2639, 2758], [2799, 2799, 2819, 2819, 3894], [3897, 3897, 3924, 3924, 4162], [4164, 4164, 4211, 4211, 5295], [5341, 5341, 5370, 5370, 5547], [5671, 5671, 5727, 5727, 6288]]}
{"id": "4s2yRy", "name": "Britney Warp", "author": "defcon8", "description": "My first fragment shader..", "tags": ["britneywarp"], "likes": 1, "viewed": 75, "date": "1492600633", "time_retrieved": "2024-06-20T18:52:55.244267", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord.xy / iResolution.xy ) - vec2(0.5,0.5);\t\n    vec2 normalpos = ( fragCoord.xy / iResolution.xy );\n    float horizon = cos(iTime)*0.1; \n    float fov = 0.7; \n\tfloat scaling = abs((sin(iTime)+0.5)) * 0.02 + 0.05;\n\tfloat t = sin(iTime) * 0.1;\n\t\n\tmat2 rot = mat2(cos(t),sin(t),sin(t),cos(t));\n\t\n\tpos  *=rot;\n\t\n\tvec3 p = vec3(pos.x, fov, pos.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n\t\n\ts.xy *=rot;\n\t\n\tfloat dupa = 5.0;\n\tfloat color =1.0;\n    if(pos.y < 1.1)\n    \tcolor = sign((mod(s.x, 0.1) - 0.05) * (mod(s.y + dupa * mod(-iTime * 0.05, 1.0), 0.1) - 0.05));\n\t\t \n\tcolor *= p.z*p.z*14.0;\n\t\n\tfragColor = vec4( 0.9-p.y,0.9,0.9, 1.0 );\n    \n    normalpos *=rot;\n    \n    fragColor = texture(iChannel0, vec2(normalpos.x, normalpos.y+0.2));\n    \n    float mean = (fragColor.r + fragColor.g + fragColor.b) / 3.0;\n    if(fragColor.g - 0.15 > mean) {\n     \tfragColor.a = 0.0; \n        fragColor.r = 0.0;\n        fragColor.g = 0.0;\n        fragColor.b = 0.0;\n    }\n\t\n\tfragColor += vec4( vec3(sin(iTime)*color,cos(iTime)*color,color), 0.5 );\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1130]]}
{"id": "4s2yW1", "name": "Bokeh Paralax", "author": "knarkowicz", "description": "Feeling artsy", "tags": ["procedural", "2d", "circles", "bokeh"], "likes": 137, "viewed": 8394, "date": "1492029808", "time_retrieved": "2024-06-20T18:52:55.244267", "image_code": "const float MATH_PI\t= float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a ) \n{\n\tp = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\n\treturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )   \n{\n    float wrap = 450.0;    \n    if ( mod( floor( p.y / wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p / wrap + 0.5 );\n    float cellR = Rand( cell );\n        \n    c *= fract( cellR * 3.33 + 3.33 );    \n    float radius = mix( 30.0, 70.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n    \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow\t = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.x * 1000.0;\n    \n    // background\n\tvec3 color = mix( vec3( 0.3, 0.1, 0.3 ), vec3( 0.1, 0.4, 0.5 ), dot( uv, vec2( 0.2, 0.7 ) ) );\n\n    float time = iTime - 15.0;\n    \n    Rotate( p, 0.2 + time * 0.03 );\n    BokehLayer( color, p + vec2( -50.0 * time +  0.0, 0.0  ), 3.0 * vec3( 0.4, 0.1, 0.2 ) );\n\tRotate( p, 0.3 - time * 0.05 );\n    BokehLayer( color, p + vec2( -70.0 * time + 33.0, -33.0 ), 3.5 * vec3( 0.6, 0.4, 0.2 ) );\n\tRotate( p, 0.5 + time * 0.07 );\n    BokehLayer( color, p + vec2( -60.0 * time + 55.0, 55.0 ), 3.0 * vec3( 0.4, 0.3, 0.2 ) );\n    Rotate( p, 0.9 - time * 0.03 );\n    BokehLayer( color, p + vec2( -25.0 * time + 77.0, 77.0 ), 3.0 * vec3( 0.4, 0.2, 0.1 ) );    \n    Rotate( p, 0.0 + time * 0.05 );\n    BokehLayer( color, p + vec2( -15.0 * time + 99.0, 99.0 ), 3.0 * vec3( 0.2, 0.0, 0.4 ) );     \n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[47, 47, 86, 86, 138], [140, 140, 173, 173, 217], [219, 219, 241, 241, 318], [320, 320, 347, 347, 379], [381, 381, 437, 437, 1146], [1148, 1148, 1205, 1205, 2165]]}
{"id": "4s2yWz", "name": "[ #09 ] - Random particle system", "author": "Yrai", "description": "Particle system with as many random variables as possible:\n- random particle position\n- random particle ellipsoid path with a,b = random\n- random particle speed and size (size depending on speed) \n- random color\n\nSystem is re-scaled within a rectangle ", "tags": ["2d", "text", "texture", "random", "hash", "particle", "system", "atlas"], "likes": 10, "viewed": 702, "date": "1491675723", "time_retrieved": "2024-06-20T18:52:55.244267", "image_code": "#define res_            iResolution\n#define t               iTime\n\n// System attributes\n#define particle_r_            .01\n#define particle_system_size_  50\n#define particle_speed_factor_ 11.\n\n// Colors\n#define white vec3(1.)\n#define black vec3(0.)\n\nstruct particle {\n\tfloat r;\n    float d;\n    vec2 pos;\n    vec2 path;\n    vec3 col;\n};\n\n    \n\nfloat pchar(vec2 p, int C);\nfloat pfnum(vec2 p, float x);\nfloat pinum(vec2 p, float x);\nfloat ppoint(vec2 p, vec2 n);\n\nvec2  domain(vec2 uv, float s);\nfloat hash(vec2 p);\nfloat hashm(vec2 p);\n\nparticle[particle_system_size_] calc_system(vec2 p, vec2 span);\n\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 4.5);\n\t\n\tvec2 span = vec2(4. + sin(t) , 2. - cos(t)*2.);\n    float axis = 4. * smoothstep(.02, .01, min(abs(p.y), abs(p.x)));\n    float box  = smoothstep(\n        .02, .01, abs(max(abs(p.x) - span.x, abs(p.y) - span.y))\n    );\n    \n    particle particle_system[particle_system_size_] = calc_system(p, span);\n\n        \n    vec3 c = vec3(0.);\n    c = mix(c, vec3(1.), axis);\n    c = mix(c, vec3(1.), box);\n    for(int i = 0; i < particle_system_size_; i++) {\n        c = mix(c, white, particle_system[i].col * particle_system[i].d);        \n    }\n    \n    c = mix(c, white, ppoint(4.*(p+vec2(span.x, -span.y)), span));\n    o = vec4(c, 1.);\n}\n\n\nparticle[particle_system_size_] calc_system(vec2 p, vec2 span) {\n    float x_span = span.x;\n    float y_span = span.y;\n    \n    particle particle_system[particle_system_size_];\n    for(int i = 0; i < particle_system_size_; i++) {\n    \tfloat fi = float(i);\n        float sx = sign(hashm( vec2(0., fi) ));\n        float sy = sign(hashm( vec2(fi + 1., fi + 1.) ));\n        float dx = x_span * hash( vec2(fi, .2) );\n        float dy = y_span * hash( vec2(fi - 1., fi - 1.) );\n        float randrx = sx * hash( vec2(fi - 1., fi) );\n        float randry = sy * hash( vec2(fi, fi) );\n        \n        float part_speed = t*(particle_speed_factor_ * hash( vec2(fi, fi) ));\n        vec2  part_pos   = p + vec2(sx*dx, sy*dy);\n        vec2  part_path = vec2(\n            randrx * cos(part_speed) + hash( vec2(0., fi) ),\n            randry * sin(part_speed)\n        );\n        float part_r = particle_r_;\n        float part_d = smoothstep(.02 + abs(.2*sin(t*part_speed)), .01,\n        \tlength(part_pos - part_path) - part_r\n        );\n        \n        vec3 part_col = 2.*vec3(\n        \thash( vec2(0.-fi, 0.*fi)  ),\n            hash( vec2(0.+2.*fi, fi)  ),\n            hash( vec2(fi, 1./(fi+.1)) )\n        );\n        \n        particle_system[i] = particle(\n            part_r,\n            part_d,\n        \tpart_pos,\n            part_path,\n            part_col\n        );\n    }\n    \n    return particle_system;\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\nfloat hashm(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\nfloat pinum(vec2 p, float x) {\n    bool neg = false;\n    if(x < 0.) {\n    \tneg = true;\n        x *= -1.;\n    }\n    \n    int x_ = int(floor(x));\n    float nm = 0.;\n    if(neg)\n        nm = pchar(p+vec2(.3,0.), 45);\n    \n    for(int i = 0; i < 10; i++) {\n    \tint n = int(floor(mod(float(x_), 10.)));\n        nm = max(nm, pchar(p + float(i)*vec2(.4, 0.), 48+n));\n        x_ /= 10;\n        if(x_ == 0)\n            break;\n    }\n    \n    return nm;\n}\n\nfloat pfnum(vec2 p, float x) {\n   \t// +/-dn...d1d0d,d_0d_1...d_n\n    float xo = x;\n    bool neg = false;\n    if(x < 0.) { neg = true; x *= -1.; }\n    \n\tint d = int(abs(floor(x)));\n    int d0 = 0;\n    \n    int d_0 = int( floor(abs(fract(x)) * 10.) );\n\tint d_1 = int( floor(abs(fract(x)) * 100.) );\n    d_1 = int( d_1 - d_0*10);\n    \n    float nm = pinum(p, xo);\n    nm = max(nm, pchar(p - vec2(.3, 0.), 46));\n    nm = max(nm, pchar(p - vec2(.6, 0.), 48 + d_0));\n    nm = max(nm, pchar(p - vec2(1., 0.), 48 + d_1));\n\t\n    return nm;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\nfloat pchar(vec2 p, int C) {\n  if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n   \n  return textureGrad(\n      iChannel0, p/16. + fract(vec2(C, 15-C/16) / 16.), \n      dFdx(p/16.),dFdy(p/16.)\n  ).r;\n}\n\nfloat ppoint(vec2 p, vec2 n) {\n\tfloat pn = max(pchar(p + vec2(.5, 0.), 40), pfnum(p, n.x));\n    pn = max(pn, pchar(p - vec2(1.3, 0.), 44));\n    pn = max(pn, pfnum(p - vec2(1.9, 0.), n.y));\n    pn = max(pn, pchar(p - vec2(3.3, 0.), 41));\n    return pn;\n}\n\n\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4s2yWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[193, 603, 639, 639, 1299], [2701, 2701, 2721, 2721, 2784], [2786, 2786, 2807, 2807, 2899], [2901, 2901, 2931, 2931, 3346], [3348, 3348, 3378, 3412, 3880], [3882, 3882, 3913, 3913, 3963], [3965, 3965, 3993, 3993, 4168], [4170, 4170, 4200, 4200, 4423]]}
{"id": "4sBcDz", "name": "Pinwheelbrot", "author": "akohdr", "description": "Started as visualization of space distortion / attractors of Mandelbrot set.\n", "tags": ["fractal", "mandelbrot"], "likes": 4, "viewed": 85, "date": "1491538652", "time_retrieved": "2024-06-20T18:52:55.244267", "image_code": "// Created by Andrew Wild - akohdr/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define ATTRACTOR_PINWHEEL\n#define iT iTime\n#define CS(a) vec2(cos(a),sin(a))\n\n// m => vec4(center.xy, zoom, max its.);\n//   <= vec4(z, dz)\nvec4 mandel(in vec2 p, in vec4 m )\n{\n    vec2 c = (p + m.xy)/m.z,  z = c,  dz = CS(iT);\n    for(float j=0.; j<m.w; j++) {\n   \t\tmat2 Mz = mat2( z.x, z.y, \n                       -z.y, z.x );\n        \t dz = Mz * dz;\n         \t  z = Mz * z + c;\n        if (length(z)>2.) break;\n    }\n    return vec4(z,dz);\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    vec2 iR = iResolution.xy,\n    \t  c = vec2(-.25,0);\n\tp -= .5*iR; p /= iR.y;\n\tk = mandel(p, vec4(c, .5, iT/3.));\n    \n#ifdef ATTRACTOR_PINWHEEL    \n\tk = k.xyxy/k.zwwz;\t\t\t\t\t// shows space distortion & attractors \n    k = (length(k)<.1) ? vec4(1) : normalize(k);\n#else\n    k = k*dot(k.yx,k.zw);\t\t\t\t// visually more interesting. around 3/4 its.\n    k = (length(k)<.1) ? vec4(.5-length(p+c)) : normalize(k);\n#endif\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBcDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[209, 270, 306, 306, 575], [577, 577, 618, 618, 1034]]}
{"id": "4sBcRm", "name": "CellTex Domain Distortion", "author": "TinyTexel", "description": "potentially useful for generating mountains\nright: distorted cell tex\nbottom left: undistorted cell tex\ntop left: distortion vector\n", "tags": ["voronoi", "noise", "distortion", "worley", "cellular", "cell"], "likes": 5, "viewed": 181, "date": "1491312719", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "/*\npotentially useful for generating mountains\nright: distorted cell tex\nbottom left: undistorted cell tex\ntop left: distortion vector\n*/\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n    \n    \n\tfloat dd = 64.0;\n    \n    const float n = 1.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd = min(dd, d);\n\t}\n\t\n\treturn dd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    //uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    \n    vec2 pos = uv * 0.02 + Time * 0.2;\n    \n    vec2 off = vec2(CellTex(pos, 0.1, cells), \n                    CellTex(pos, 0.2, cells)) - vec2(0.25);\n    \n    float os = tex.x > 0.25 ? 0.3 : 0.0;\n    \n    float r = CellTex(pos + off * os, 0.0, cells);\n    \n    vec3 col = tex.y > 0.5 && tex.x < 0.25 ? vec3(off.xy * 1.0, 0.0*length(off)) : vec3(r);\n    \n    fragColor = vec4(clamp(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBcRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[159, 358, 384, 384, 421], [423, 423, 446, 446, 460], [461, 461, 484, 484, 502], [503, 503, 526, 526, 544], [545, 545, 568, 568, 586], [588, 588, 614, 614, 667], [669, 669, 694, 694, 736], [739, 739, 786, 786, 1741], [1743, 1743, 1800, 1800, 2345]]}
{"id": "4sBczc", "name": "DonKarlssonSan's second shader", "author": "DonKarlssonSan", "description": "asdf", "tags": ["experiment"], "likes": 1, "viewed": 89, "date": "1493059455", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = float(int((fragCoord.x * fragCoord.y)/20000.9*iTime));\n   \n    bool c = mod(f, 2.0) == 0.0;\n    \n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sBczc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 206]]}
{"id": "4sByDG", "name": "heart2", "author": "popescualexandrucristian", "description": "heart", "tags": ["heart"], "likes": 1, "viewed": 98, "date": "1493479861", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 org_uv = uv;\n    \n    uv -= 0.5;\n    uv.x *= (iResolution.x / iResolution.y);\n    uv.y += 0.1;\n    \n    uv.y = ((uv.y - (pow(abs(uv.x * (0.88 - uv.y)) + 0.4,1.5)) + 0.2));\n    uv.xy /= 0.5;\n    \n    float time = mod(iTime, 42.0) * 2000.0;\n    \n    float a = abs(sin((time * uv.y) - 4.0 * org_uv.y)) / 2.0 + 0.4;\n    float b = pow((sin(iTime*6.0) * org_uv.y * 1.4) * 0.4, 2.0);\n    \n    float heart_mask = smoothstep(b + a, b + a + 0.05,length(uv * 2.0));\n    \n\tfragColor = vec4(vec3(a + b, 0.2 * b, 0.0) - heart_mask, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sByDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 634]]}
{"id": "4sByRy", "name": "Mom, I made a raytracer!", "author": "slerpy", "description": "My first ever raytracer!", "tags": ["3d", "tunnel"], "likes": 3, "viewed": 107, "date": "1492509552", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "#define TAU 6.28318530718\n\n#define FAR 25.\n#define ITER 250\n#define QUA .001\n\nfloat map(vec3 ray)\n{   \n    vec3 cen = round(ray*3.)/3.;\n    float rad = length(cen.xy-vec2(0.))/(7.+4.*sin(iTime/16.));\n    return length(ray-cen) - rad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float ang = atan(uv.x,uv.y)+sin(iTime/3.)/3.;\n    uv = vec2(sin(ang),cos(ang))*length(uv);\n    \n    float d = 0.;\n    for(int i=0; i<ITER; i++) {\n        vec3 ray = vec3(uv,1.)*d;\n        vec3 acid = pow(d,3.)/80.*vec3(cos(iTime/8.),sin(iTime/8.),0.);\n        vec3 shift = vec3(vec2(0.),iTime);\n        float m = map(ray+acid+shift);\n        if(m < QUA*d || abs(d) > 24.)break;\n        d += .5 * m;\n    }\n    \n\tfragColor = vec4(1.-d/FAR);\n    if(abs(mod(d+iTime,2.))>1.) {\n        fragColor *= round(mod(16.*(d+1.2*iTime),2.))\n            *vec4(sin(iTime), sin(iTime+TAU/3.), sin(iTime+2.*TAU/3.), 0.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sByRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[78, 78, 99, 99, 235], [237, 237, 294, 294, 973]]}
{"id": "4sByzG", "name": "Starting Raytracing", "author": "Torumu106", "description": "Starting raytracing.\nI'll improve this shader.\nBe carefull! Maybe you get sick.", "tags": ["3d"], "likes": 2, "viewed": 206, "date": "1492502903", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "struct HitInfo\n{\n\tvec4 color;\n    float dist;\n};\nHitInfo map(vec3 p){\n    vec4 defo = vec4(0.0, 0.0, 0.0, 0.005);\n    vec3 q = fract(p) * 2.0 - 1.0;\n    HitInfo hit;\n    hit.dist = 10000.0;\n    hit.color = defo;\n    float sphere = length(q) - 0.25;\n    /*if(sphere <= 0.01)\n    {\n\t\thit.dist = sphere;\n        hit.color = vec4(1.0, 1.0, 1.0, 1.0);\n    }*/\n    float xaxis = length(vec3(0.0, q.y, q.z)) - 0.15;\n    if(xaxis <= 0.01)\n    {\n\t\t//hit.dist = xaxis;\n        hit.color += vec4(1.0, 0.0, 0.0, 0.05);\n    }\n    float yaxis = length(vec3(q.x, 0.0, q.z)) - 0.15;\n    if(yaxis <= 0.01)\n    {\n\t\t//hit.dist = yaxis;\n        hit.color += vec4(0.0, 1.0, 0.0, 0.05);\n    }\n    float zaxis = length(vec3(q.x, q.y, 0.0)) - 0.15;\n    if(zaxis <= 0.01)\n    {\n\t\t//hit.dist = zaxis;\n        hit.color += vec4(0.0, 0.0, 1.0, 0.05);\n    }\n    hit.dist = min(min(hit.dist, xaxis - 0.01), min(yaxis - 0.01, zaxis - 0.01));\n    return hit;\n}\nvec3 trace(vec3 o, vec3 r)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 p = o + r * 6.4;\n    HitInfo mapp = map(p);\n\tfor(float i = 6.4; i > 0.0; i -= max(0.0125, mapp.dist-1.0)){\n    \tvec3 p = o + r * i;\n        HitInfo d = map(p);\n        mapp = d;\n        float dist = length(p-o);\n        if(d.dist <= 0.01){\n            color = d.color.xyz * 1.0 / (1.0 + dist * dist * 0.1) * d.color.w + color * (1.0 - d.color.w);\n        }\n    }\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    r += vec3(0.0, r.x * 0.5 * sin(iTime * 2.0) + r.x * 0.1 * sin(iTime * 2.0), 0.0);\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0, iTime + 0.5, iTime);\n    \n\tfragColor = vec4(trace(o, r),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sByzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[49, 49, 69, 69, 928], [929, 929, 957, 957, 1387], [1388, 1388, 1445, 1445, 1866]]}
{"id": "4sByzy", "name": "GRAPPROG FINALS - LIM", "author": "marcoolim", "description": "Miguel Enrico G. Lim\ngrapprog finals", "tags": ["noise"], "likes": 0, "viewed": 62, "date": "1492625211", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SWITCH 8\n\n/* \n1- checkered static\n2- lava\n3- clouds\n4- cork board\n5- tartan\n6- twinkling stars\n7- lava lamp with rotating light\n8-\n*/\n\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 yellow = vec3(.900, .300, 0.0);\nvec3 blue = vec3(0.0, 0.0, 1.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\t\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 orange = vec3(1.0,0.7,0.0);\nvec3 brown = vec3(0.930,0.493,0.502);\nvec3 cyan = vec3(0.0,1.0,1.0);\nvec3 sky = vec3(0.541, 0.729, 0.827);\nvec3 cloud = vec3(0.941, 0.945, 0.941);\nvec3 lava = vec3(0.929, 0.203, 0.572);\n\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n// Value noise\nfloat noise2(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 circle(vec2 uv, vec2 center, float r){\n    float color = distance(center+(noise(uv*6.5+(iTime/1.2))*0.06), uv);\n    return vec3(smoothstep(color, r, 1.0));\n}\n\nfloat circlePoly(vec2 circle, vec2 uv, float r) { \n    float diameter = distance(circle,uv)* 2.0;\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n   \tangle += iTime * 2.;\n    r = sin(13.*angle);\n    float color = 1.0 - step(r,diameter);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    \n    #if (SWITCH == 1)\n    uv *= 0.7;\n    vec3 value = white;\n    //vec3 clouds = vec3(fbm((uv)*15.0))*0.15;\n    vec3 clouds = vec3(fbm((uv * 60. + iTime / 2.)*11.0))*.20;\n    \n    value = mix(value, black,(smoothstep(0.02,0.1,clouds) - smoothstep(0.1, 0.3,clouds)));\n    fragColor = vec4(value, 1.0);\n    #endif\n    \n    #if (SWITCH == 2)\n  \tfloat lava = (fbm(uv  * 30.5 + iTime /2.) * .13);\n    vec3 value = yellow * abs(sin(uv.x + lava *50. + iTime) +.3 );\n    float off = noise(uv * 5. + iTime) * .3;\n    value = mix(value, yellow , off) + mix(value, red , off) * mix(value, red , off) ;\n\tvalue -= red * 0.05;\n    fragColor = vec4(vec3(value),1.0);\n    #endif\n    \n    #if (SWITCH == 3)\n    uv *= 0.7;\n    vec3 value = sky;\n    vec3 clouds = vec3(fbm((uv * 14. + iTime / 2.)*1.0))*.15;\n    value = mix(value, cloud,(smoothstep(0.02,0.1,clouds) - smoothstep(0.1, 0.3,clouds)));\n    fragColor = vec4(value, 1.0);\n    #endif\n    \n    #if (SWITCH == 4)\n    float value = fract(sin(uv.x * uv.y*10000.0) * 10000.0);\n    uv *= 1.0;\n    vec2 idx= floor(uv) + (iTime / 10000.0);\n    value = rand(uv);    \n\tfragColor = vec4(vec3(value) * brown + orange/2.0,1.0);\n    #endif\n    \n    #if (SWITCH == 5)\n    uv *= 2.0 ;\n    uv = fract(uv);\n    vec3 value = red;\n    float blackBox = 0.0;\n    blackBox += step(0.15, uv.x) - step(0.35, uv.x);\n    blackBox += step(0.65, uv.x) - step(0.85, uv.x);\n    blackBox += step(0.15, uv.y) - step(0.35, uv.y);\n    blackBox += step(0.68, uv.y) - step(0.85, uv.y);\n    value = mix(value, black, vec3(blackBox * noise(uv* 100000.)));\n    value = mix(value, green, .7*vec3(fbm(uv.yy*40.)));    \n    value += (noise(uv.x*vec2(5000.0, 20.0) - noise(uv.x*vec2(2000., 60.))) * 0.06);\n    value -= vec3((snoise(uv.x*vec2(600.0, 7.0)) - gnoise(uv.y*vec2(300.0, 1.0))) * 0.1);    \n\tfragColor =vec4(value,1.0);\n    #endif\n    \n    #if (SWITCH == 6)\n    float stars = step(.99, rand(uv)) * ((abs(sin(iTime))) * 1.0)/ 0.5;\n    stars  += step(.999, rand(uv));\n    fragColor = vec4(vec3(stars), 1.0);\n    #endif\n    \n    #if (SWITCH == 7)\n    float lava = (fbm(uv  * 999.5 + iTime /2.) * .13);\n    vec3 value = white * abs(sin(uv.x + lava *30. + iTime) +.3 );\n    float off = noise(uv * 5. + iTime) * .3;\n    value = mix(value, red , off) * mix(value, red , off) / mix(value, blue , off) ;\n\tvalue -= red * 0.5;\n    fragColor = vec4(vec3(value),1.0);\n    #endif\n    \n    #if (SWITCH == 8)\n    vec2 pos = vec2(0.350 * ratio,0.0);\n    uv -= pos;\n    vec3 value = red;\n    value = mix(value, green , .7*vec3(fbm(uv.yy*40.)));\n    value += vec3((snoise(uv.x*vec2(1000.0, 1.0)) - gnoise(uv.y*vec2(300.0, 1.0))) * 1.0) * green; \n    value += circlePoly(vec2(0.3, 0.5), uv, 5.0);\n    \n    fragColor = vec4(vec3(value),1.0);    \n    #endif\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sByzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[73, 622, 646, 646, 720], [722, 722, 748, 748, 1120], [1140, 1140, 1164, 1186, 1437], [1439, 1454, 1480, 1480, 1991], [1993, 2011, 2069, 2069, 2207], [2209, 2209, 2236, 2236, 2634], [2636, 2653, 2674, 2674, 2721], [2722, 2722, 2743, 2743, 2790], [2791, 2791, 2813, 2813, 2848], [2850, 2850, 2872, 2872, 3920], [3922, 3922, 3965, 3965, 4084], [4086, 4086, 4135, 4135, 4348], [4350, 4350, 4407, 4407, 7300]]}
{"id": "4sjcD1", "name": "Sketch_Tri", "author": "cexlearning", "description": "Tri，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 2, "viewed": 81, "date": "1492604569", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "const float PI = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 coord = fragCoord.xy - iResolution.xy * 0.5;\n\n    float phi = atan(coord.y, coord.x + 1e-6);\n    float seg = fract(phi / (2.0 * PI) + 0.5 - 0.5 / 6.0) * 3.0;\n\n    float theta = (floor(seg) * 2.0 / 3.0 + 0.5) * PI;\n    vec2 dir = vec2(-cos(theta), -sin(theta));\n\n    float y = dot(dir, coord);\n    float w = iResolution.x * 0.08;\n\n    float phase = iTime * 1.1;\n    float pr = y / w - iTime * 1.4;\n    float id = floor(pr) - floor(phase);\n\n    float th1 = fract( id        / 2.0) * 2.0;\n    float th2 = fract((id + 1.0) / 2.0) * 2.0;\n    float thp = min(1.0, fract(phase) + fract(seg) * 0.2);\n    float th = mix(th1, th2, smoothstep(0.8, 1.0, thp));\n\n    float d = fract(pr);\n    float c = clamp((abs(0.5 - d) - (1.0 - th) / 2.0) * w / 2.0, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjcD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[28, 28, 85, 85, 886]]}
{"id": "4sjcRd", "name": "\"precision\" compiler bug", "author": "FabriceNeyret2", "description": "Not only \"precision\" is no longer allowed, but not even in comments ;-)", "tags": ["glsl", "bug"], "likes": 1, "viewed": 440, "date": "1493382991", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;     // hello precision lowp hello\n\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0); /* hello precision lowp hello */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjcRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 215]]}
{"id": "4sjcW1", "name": "Sketch_Lattice3", "author": "cexlearning", "description": "Lattice3，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 8, "viewed": 83, "date": "1492432216", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float pi = 3.1415926;\n    float t = iTime * 0.7;\n\n    float scale = 10.0 / iResolution.y;\n    vec2 p = fragCoord.xy * scale + 0.5; // pos normalized /w grid\n    p += vec2(2, 0.5) * iTime;\n\n    float rnd = fract(sin(dot(floor(p), vec2(21.98, 19.37))) * 4231.73);\n    float flip = fract(rnd * 13.8273) > 0.5 ? 1.0 : -1.0;\n    rnd = floor(rnd * 2.0) / 2.0 + floor(t) * flip / 2.0;\n\n    float anim = smoothstep(0.0, 0.66, fract(t));\n    float phi = pi * (rnd + anim * flip / 2.0);\n    vec2 a1 = vec2(cos(phi), sin(phi));\n    vec2 a2 = vec2(-a1.y, a1.x);\n    vec2 a3 = vec2(cos(phi + pi / 4.0), sin(phi + pi / 4.0));\n\n    vec2 pf = fract(p) - 0.5;\n    float d1 = abs(min(min(dot( pf, a1), dot( pf, a2)), dot( pf, a3) - 0.2));\n    float d2 = abs(min(min(dot(-pf, a1), dot(-pf, a2)), dot(-pf, a3) - 0.2));\n\n    float w = 0.1 + sin(t) * 0.08; // line width\n    float c = 1.0 - clamp((w - min(d1, d2)) / scale, 0.0, 1.0);\n    fragColor = vec4(c, 0.5 * c, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjcW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1022]]}
{"id": "4sjcWh", "name": "Sketch_Circles4", "author": "cexlearning", "description": "Circles4， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 14, "viewed": 147, "date": "1491970589", "time_retrieved": "2024-06-20T18:52:55.880686", "image_code": "#define MONOCHROME 1\n\nvec3 circle(vec2 coord, float bias)\n{\n    float repeat = sin(iTime * 0.4) * 10.0 + 30.0;\n\n    float interval = iResolution.x / repeat;\n    vec2 center = iResolution.xy * 0.5;\n\n    float dist1 = distance(coord, center);\n    float num = max(floor(dist1 / interval + 0.5) + bias, 1.0);\n    float radius = num * interval;\n\n    float phase1 = iTime * 3.0 + radius * 0.04;\n    float phase2 = phase1 * 1.3426;\n    vec2 offs = vec2(sin(phase1), cos(phase2)) * interval * 0.5;\n    float dist2 = distance(coord, center + offs);\n\n    float width = interval * 0.33;\n    float c = clamp(width * 0.5 - abs(radius - dist2), 0.0, 1.0);\n\n#if MONOCHROME\n    return vec3(1, 1, 1) * c;\n#else\n    float c_r = 0.7 + 0.2 * sin(phase1 * 0.12);\n    float c_g = 0.5 + 0.2 * sin(phase1 * 0.34);\n    float c_b = 0.3 + 0.2 * sin(phase1 * 0.176);\n    return vec3(c_r, c_g, c_b) * c;\n#endif\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    vec3 c1 = circle(p, -1.0);\n   \n    fragColor = vec4(c1, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjcWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[22, 22, 59, 59, 883], [887, 887, 944, 944, 1037]]}
{"id": "4sjcWm", "name": "Cube : Extrusion", "author": "JCDjcd", "description": "This is a very simple extruded cube displayed by ray-tracing method.\nThe intersections ray/cube are found by solving 3x3-matrix linear equations.", "tags": ["cube"], "likes": 2, "viewed": 99, "date": "1493421867", "time_retrieved": "2024-06-20T18:52:56.959548", "image_code": "//--------------------------------------------------------------------------\n// Intersect between line (point P, direction n)\n// and parallelogram (AB and AC are adjacent vertexes).\n// The return value is the value t such that the intersection point is P+t.n\nfloat intersect(in vec3 A,in vec3 B,in vec3 C,in vec3 P,in vec3 n)\n{\n    // ==========\n    //  STEP #1\n    // ==========\n    // First step is the computation of the intersection between the plan and the line.\n    // The line is parametrized with one parameter t      : P + t.n\n    // The plan is parametrized with two parameters (p,q) : A + p.AB + q.AC\n    vec3 u = B-A;\n    vec3 v = C-A;\n    vec3 w = -n;\n    vec3 s = P-A; // 's' stands for second member of the equation (see below)\n    \n    //\n    // Solve the equation p.u + q.v + t.w = s\n    // The intersect is within the plan (AB,AC) and on the line P+t.n\n    // That equation is linear :\n    //\n    //                   ( p )\n    //                   ( q )  <-- unkown\n    //                   ( t )\n    //\n    // ( u.x  v.x  w.x ) (s.x)\n    // ( u.y  v.y  w.y ) (s.y)\n    // ( u.z  v.z  w.z ) (s.z)\n    // \n    // To solve the 3x3 matrix, we use determinant and co-matrix.\n    //\n    float det \t= u.x*v.y*w.z\n        \t\t+ v.x*w.y*u.z\n        \t\t+ w.x*u.y*v.z\n              \t- w.x*v.y*u.z\n        \t\t- v.x*u.y*w.z\n        \t\t- u.x*w.y*v.z;\n    if(abs(det) < 1e-6) // line and plan are parallel\n        return -1000.0;\n    float cm_ux = v.y*w.z-v.z*w.y;\n    float cm_vx = u.z*w.y-u.y*w.z;\n    float cm_wx = u.y*v.z-u.z*v.y;\n    float cm_uy = v.z*w.x-v.x*w.z;\n    float cm_vy = u.x*w.z-u.z*w.x;\n    float cm_wy = u.z*v.x-u.x*v.z;\n    float cm_uz = v.x*w.y-v.y*w.x;\n    float cm_vz = u.y*w.x-u.x*w.y;\n    float cm_wz = u.x*v.y-u.y*v.x;\n    \n    // Now it is easy to solve because the inverse of the matrice\n    // is the transpose of the co-matrix divided by the determinant.\n    float p = (cm_ux*s.x+cm_uy*s.y+cm_uz*s.z)/det;\n    float q = (cm_vx*s.x+cm_vy*s.y+cm_vz*s.z)/det;\n    float t = (cm_wx*s.x+cm_wy*s.y+cm_wz*s.z)/det;\n\n    // ==========\n    //  STEP #2\n    // ==========\n    // The second step consists on checking if the intersection point\n    // is within the cube side (parallelogram ABDC, see below).\n    if(p >= 0.0 && p <= 1.0 && q >= 0.0 && q <= 1.0) // belongs to the cube's side\n    {\n        // Let's have a funny cube where we extruded a cross.\n        // The cross is defined by two ellipsis.\n        float e \t= 20.0; // ellipsis parameter\n        float r2 \t= 0.15; // square radius of the ellipsis\n        // Compute coordinated from the middle of the square :\n        float x = p-0.5;\n        float y = q-0.5;\n        // Rotate by 45° the coordinate in order to have the ellipsis\n        // axis along the diagonal of the square :\n        float rx = (x+y)*0.70710678;\n        float ry = (x-y)*0.70710678;\n        if(rx*rx+e*ry*ry<r2)\n            return -1000.0; // no intersection of the extruded part\n        else if(e*rx*rx+ry*ry<r2)\n            return -1000.0; // no intersection of the extruded part\n        else\n    \t\treturn t; // intersection!!\n    }\n    else // does not belong to the cube's side\n    {\n        return -1000.0;\n    }\n} // intersect()\n\n//--------------------------------------------------------------------------\nstruct CubeSide\n{\n    // Cube side :\n    //    A ___ B\n    //    |     |\n    //    |     |\n    //    C ___ D\n    // \n    // The point D is not used. The points of the cube's side are :\n    // x.AB + y.AC for all 0 <= x <= 1 and 0 <= y <= 1\n    // \n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n}; // struct CubeSide\n    \n//--------------------------------------------------------------------------\nvec4 compute(in vec3 P, in vec3 n)\n{\n    // Definition of the cube :\n    CubeSide sides[6];\n    \n\t// top and bottom sides\n    sides[0].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[0].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[0].C \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[0].color \t= vec4( 0.0, 0.0, 1.0 ,1.0); \t// blue\n    sides[1].A \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[1].B \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[1].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[1].color \t= vec4( 1.0, 1.0, 0.0, 1.0); \t// yellow\n\t// front and rear sides\n    sides[2].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[2].B \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[2].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[2].color \t= vec4( 1.0, 0.0, 0.0, 1.0); \t// red\n    sides[3].A \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[3].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[3].C \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[3].color \t= vec4( 0.0, 1.0, 1.0, 1.0); \t// cyan\n\t// left and right sides\n    sides[4].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[4].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[4].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[4].color \t= vec4( 0.0, 1.0, 0.0, 1.0); \t// green\n    sides[5].A \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[5].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[5].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[5].color \t= vec4( 1.0, 0.0, 1.0, 1.0); \t// magenta\n\t\n    // We need to compute the color of the neareast points\n    // (intersections between ray (parametrized by t) and cube sides).\n    float t_min \t= 1000.0; // put starting current minimum t far away...\n    vec4  color \t= vec4(0.0,0.0,0.0,1.0); // black for the background\n    int   i;\n    for(i=0;i<6;i++) // loop on each cube sides\n    {\n        // Compute the intersection with that side.\n        // If behing the observer direction, don't take it into account.\n    \tfloat t = intersect(sides[i].A,sides[i].B,sides[i].C,P,n);\n        if(t > 0.0 && t < t_min)\n        {\n            t_min = t;\n            color = sides[i].color;\n        }\n    } // for()\n\n    return color;\n} // compute()\n\n//--------------------------------------------------------------------------\n// Rotation along z-axis.\nvec3 Rz(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float x = c*u.x-s*u.y;\n    float y = s*u.x+c*u.y;\n    float z = u.z;\n    return vec3(x,y,z);\n} // Rz()\n\n//--------------------------------------------------------------------------\n// Rotation along y-axis.\nvec3 Ry(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float z = s*u.z+c*u.x;\n    float x = c*u.z-s*u.x;\n    float y = u.y;\n    return vec3(x,y,z);\n} // Ry()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    // Get min/max of the resolution (in most case the width).\n    float m \t\t= min(iResolution.x,iResolution.y);\n    // Center the viewport (cube's center is (0,0,0)).\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*4.5;\n    // Before doing the rotation, the ray pass through that pixel defined by (x,y,0)\n    // and ray'direction is in the z-direction (0,0,0).\n    // The point is put back of -5 unit in the z-direction to observe the cube from outside.\n    vec3 P \t\t\t= vec3(uv.x,uv.y,-5.0);\n    vec3 n      \t= vec3(0.0,0.0,1.0);\n    // Now perform the rotation of the observer.\n    // Two angles for respectively the rotations along y- and the z-direction.\n    // Periods are 10 seconds and 3 seconds.\n    float alpha1\t= iTime*3.1415926535*2.0/10.0;\n    float alpha2\t= iTime*3.1415926535*2.0/3.0;\n    P \t\t\t\t= Ry(P,alpha1);\n    P \t\t\t\t= Rz(P,alpha2);\n    n\t \t\t\t= Ry(n,alpha1);\n    n \t\t\t\t= Rz(n,alpha2);\n    // Compute the color of the intersection (if exists) between the ray and the cube.\n\tfragColor \t\t= compute(P,n);\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjcWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 259, 327, 611, 3176], [3597, 3674, 3710, 3742, 5615], [5630, 5733, 5765, 5765, 5916], [5926, 6029, 6061, 6061, 6212], [6222, 6299, 6350, 6413, 7371]]}
{"id": "4sjyDh", "name": "Sketch_Discs2", "author": "cexlearning", "description": "Dics2， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 5, "viewed": 123, "date": "1492175595", "time_retrieved": "2024-06-20T18:52:56.959548", "image_code": "float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scale = iResolution.y / 10.0;\n    vec2 p = fragCoord.xy / scale;\n    vec2 p1 = fract(p) - 0.5;\n    vec2 p2 = fract(p - 0.5) - 0.5;\n\n    float z1 = rand(0.12 * floor(p));\n    float z2 = rand(0.23 * floor(p - 0.5));\n\n    float r1 = 0.2 + 0.2 * sin(iTime * 1.9 + z1 * 30.0);\n    float r2 = 0.2 + 0.2 * sin(iTime * 1.9 + z2 * 30.0);\n\n    float c1 = saturate((r1 - length(p1)) * scale);\n    float c2 = saturate((r2 - length(p2)) * scale);\n\n    float a1 = saturate((r1 + 0.08 - length(p1)) * scale);\n    float a2 = saturate((r2 + 0.08 - length(p2)) * scale);\n\n    float c = mix(\n        mix(mix(0.0, c1, a1), c2, a2),\n        mix(mix(0.0, c2, a2), c1, a1),\n        step(z1, z2)\n    );\n\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjyDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 25, 25, 54], [56, 56, 77, 77, 147], [149, 149, 206, 206, 929]]}
{"id": "4sjyDW", "name": "get in the robot shinji", "author": "pickledchickenfoot", "description": "hello im a ghost nice to meet you ", "tags": ["shit"], "likes": 0, "viewed": 402, "date": "1492144540", "time_retrieved": "2024-06-20T18:52:56.959548", "image_code": "#define PI 3.1415926535\nfloat dist(vec2 p0, vec2 pf){return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));}\n\nvec3 difference (vec3 target, vec3 blend){\n    return abs (target - blend);\n    \n}\n\nvec3 radialGradient(vec2 location, float size, vec3 inner, vec3 outer, vec2 fragCoord)\n{\n    float d = dist(iResolution.xy*location,fragCoord.xy);\n    return mix(inner, outer, d/size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float sinSeed = sin(iTime);\n    float cosSeed = cos(iTime);\n    float time = iTime;\n    \n    vec3 color = vec3(0.0);\n\n    float mul = 1.;\n    for(float j = 0.; j < mul; j += 1.) {\n        float amt = 2.95;\n        for(float i = 0.1; i < amt; i += 0.1) {\n            vec2 loc1 = vec2(0.5 + sin(time+i+j)*0.2, 0.5 + cos(time+i+j)*0.2);\n            vec3 c1 = radialGradient(loc1, 10., vec3(0.0), vec3(1.0), fragCoord);\n            color = difference(color, c1);\n            vec2 loc2 = vec2(0.5 + sin(time+i+j+PI)*0.2, 0.5 + cos(time+i+j+PI)*0.2);\n            vec3 c2 = radialGradient(loc2, 10., vec3(0.0), vec3(0.2), fragCoord);\n            color = difference(color, c2);\n        }\n    }\n    \n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjyDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 24, 53, 53, 115], [117, 117, 159, 159, 199], [201, 201, 289, 289, 387], [389, 389, 446, 446, 1226]]}
{"id": "4sjyW1", "name": "Sketch_Hex3", "author": "cexlearning", "description": "Hex3， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 6, "viewed": 86, "date": "1492327600", "time_retrieved": "2024-06-20T18:52:56.959548", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float pi = 3.1415926535;\n    vec2 p = fragCoord.xy - iResolution.xy / 2.0;\n    float phi = atan(p.y, p.x + 1e-5);\n\n    float fin = mod(floor(phi * 3.0 / pi + 0.5), 6.0);\n    float phi_fin = fin * pi / 3.0;\n\n    vec2 dir = vec2(cos(phi_fin), sin(phi_fin));\n    float l = dot(dir, p) - iTime * iResolution.y / 8.0;\n    float seg = floor(l * 70.0 / iResolution.y);\n\n    float th = sin(iTime) * 0.4 + 0.5;\n    float t = sin(seg * 92.198763) * iTime;\n    fragColor = vec4(step(th, fract(phi / pi / 2.0 + t)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjyW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 577]]}
{"id": "4sjyzy", "name": "volumetric reflecting laser", "author": "ollj", "description": " more simplified (barely less general) version of \nhttps://www.shadertoy.com/view/XsjyRy\n\nmouse.y= something something brightness something\nmouse to right=AO [q] || mouse to left = WRONG color [c]\nthis is not what i want it to be, but pretty close to it.", "tags": ["reflection", "lines", "light", "volumetric", "ao", "laser", "neon"], "likes": 21, "viewed": 1156, "date": "1492614943", "time_retrieved": "2024-06-20T18:52:57.547633", "image_code": "//inversion and simplifying substiturion of\n//https://www.shadertoy.com/view/XsjyRy\n\n//i wanted to have colored ao, but all i got was a mix of 2 mutually exclusive things:\n\n#define t iTime\n#define phi (2.*sqrt(5.)*.5+.5)\n#define co(a) (cos(a)*.3+.6)\n\n//#define ScaleBright co(t*phi)\n#define ScaleBright (.5+iMouse.y*9./iResolution.y)\n\n#define bidpScale co(t)*ScaleBright;\n//#define bidpScale .5;\n\n//sharpness\n#define  falloffDist (1.0*ScaleBright)\n\n#define pows pow(e,.1/ScaleBright)\n\n//is lineAO2() of https://www.shadertoy.com/view/XsjyRy\nfloat lineAO(vec2 p,vec2 a,vec2 b){\n vec2 d=normalize(a-b);\n vec2 r=vec2(-d.y,d.x);\n vec2 c=normalize(a-p);\n float f=dot(normalize(a-p ),normalize(b-p));\n float e=clamp(abs(dot(r,a-p))/falloffDist,0.,1.);\n return 1.+(1.-pows)*(f-1.)*bidpScale;\n}\n\n//coloring lineAO()\nfloat lineAOv(vec2 p,vec2 a,vec2 b){\n   vec3 c=vec3(1);\n  return lineAO(p,a,b);}\n //return lineAO(p,a,b)+(-c+vec3(1.));}\n               \n\n\n//coloring lineAO()\nvec3 lineAOc(vec2 p,vec2 a,vec2 b,vec3 c){\n //c=vec3(1);//overwrite color with monochrome\n return lineAO(p,a,b)+(-c+vec3(1.));}\n            \n\nvec2 frame(vec2 p){\n p-=iResolution.xy*.5;\n p/=iResolution.xy; \n p.x*=iResolution.x/iResolution.y;\n return p;}\n\n//coloring lineAO()\nvec3 lineAOf(vec2 p,vec2 a,vec2 b,vec3 c){\n return vec3(\n  lineAO(p,a,b)*c.x\n ,lineAO(p,a,b)*c.y\n ,lineAO(p,a,b)*c.z);}\n\nvoid  qc(in vec2 u,inout vec3 f,inout vec3 c,inout vec3 q,vec2 a,vec2 b,vec3 d){\n  q*=      lineAOv(u,a,b  ) ;\n  f*=      lineAOf(u,a,b,f) ;\n  c =min(c,lineAOc(u,a,b,d));}\n\n//#define max3(a) max(max(a.x,a.y),a.z)\n//#define min3(a) min(min(a.x,a.y),a.z)\n\nvoid mainImage( out vec4 fragColor, in vec2 In ){\n    vec2 u=frame(In);\n\tvec3 q=vec3(1.);\n\tvec3 c=vec3(1.);\n\tvec3 f=vec3(1.);\n    //dodo, a loop with reflect()\n    qc(u,f,c,q,vec2(0      ),vec2( .1, .2),vec3(0,1,1) );\n        \n    qc(u,f,c,q,vec2( .2, .2),vec2( .1, .2),vec3(1,1,0) );\n    \n\tqc(u,f,c,q,vec2( .2, .2),vec2( .4, .0),vec3(1,0,0) );\n\t\n    qc(u,f,c,q,vec2( .1,-.4),vec2( .4, .0),vec3(0,1,1) );\n\tqc(u,f,c,q,vec2( .1,-.4),vec2(-.2,-.4),vec3(0,0,1) );\n\tqc(u,f,c,q,vec2(-.4,-.3),vec2(-.2,-.4),vec3(1,1,1) );\n    qc(u,f,c,q,vec2(-.4,-.3),vec2(-.1)    ,vec3(0,1,0) );\n    qc(u,f,c,q,vec2(-.4, .0),vec2(-.1)    ,vec3(1,0,1) );\n\tqc(u,f,c,q,vec2(-.4, .0),vec2(-.4, .3),vec3(1,0,0) );\n    qc(u,f,c,q,vec2(-.1, .3),vec2(-.4, .3),vec3(0,0,1) );\n\tqc(u,f,c,q,vec2(-.1, .3),vec2(0      ),vec3(1,1,1) );\n/**/\n    \n    //c additively       calculates color without AO\n    //q multiplicatively calculates AO    without color\n    //a mix() of the 2 was the best union i could do.\n    //i suchk at AO!\n    \n    //i kept trying to mix them internally with [f] but that fails.\n    \n    q=clamp(q,0.,1.);//uneccessary\n    c=clamp(c,0.,1.);//uneccessary\n    vec3 o=1.-q;//closest to https://www.shadertoy.com/view/XsjyRy\n    //but i anted to colorize it, which is not too simple:\n    //q=1.-c;\n    q=max(1.-c,o*iMouse.x/iResolution.x);\n    //q=min(1.-c,1.-q);\n    \n    //occlusion has no color :\n    //q=mix(q,o,.7);//not corrct, but a decent enough illusion?\n    \n    //q=1.-q;//inversion to make \"AO\"\n\tfragColor = vec4(q,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sjyzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[485, 541, 576, 576, 786], [788, 808, 844, 844, 888], [947, 967, 1009, 1056, 1094], [1109, 1109, 1128, 1128, 1219], [1221, 1241, 1283, 1283, 1360], [1362, 1362, 1442, 1442, 1533], [1535, 1616, 1665, 1665, 3131]]}
{"id": "4sScDD", "name": "Awesome Smiley", "author": "xx3000", "description": "Who needs raymarching anyway", "tags": ["trippy", "smiley", "awesome"], "likes": 10, "viewed": 200, "date": "1492046134", "time_retrieved": "2024-06-20T18:52:57.547633", "image_code": "#define PI 3.1415926\n\n#define AA 0\n\nfloat faceDist(vec2 uv1, vec2 uv2,vec2 uv3, float scl1, float scl2)\n{\n\treturn (1.0+sin(1.0*atan(uv1.y*scl1,uv1.x*scl2)+uv3.y*0.2+4.5)) - sqrt(dot(uv2,uv2));\n}\n\nfloat insideSuperEllipse(vec2 uv, float a, float b, float n)\n{\nreturn pow(abs(uv.x/a),n)+pow(abs(uv.y/b),n) - 1.0;\n\n}\n\n// cosine based palette, by iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec4 render(vec2 uv)\n{\nvec2 centered = uv;\n    float angle = (atan(centered.y,centered.x)+PI)/(PI*2.0);\n    float a =angle +iTime*0.05;\n    centered*=0.3;\n    \n   // centered.x=centered.x+sin(iTime)*0.1;\n    float r = length(centered);\n    vec4 bg1=vec4(0.0,0.4,0.95,1.0);\n    vec4 bg2=vec4(0.27,0.59,1.0,1.0);\n    vec4 bg3=vec4(0.15,0.5,0.9,1.0);\n    \n    bg2= vec4(palette((1.0-(r)+iTime*0.5),vec3(0.5,0.5,0),vec3(0.5),vec3(1.0),vec3(0.00, 0.33, 0.67)),1.0);\n    \n    bg1= vec4(palette((1.0-(r)+iTime*0.25),vec3(0.5,0.0,0.5),vec3(0.0,0.0,0.5),vec3(1.0),vec3(0.00, 0.33, 0.67)),1.0);\n    \n    //Background\n    vec4 col = bg1*(1.0-(r));\n    float cones =mod(a*30.0 , 2.0);\n    //if(int(cones) != 0)\n    //    col = bg3*(1.0-(r));\n    \n    \n    float a2 = angle+iTime*0.07;\n    //float a2 = angle;\n    \n    a2+= sin((length(uv)*5.0)-1.0*iTime*5.0)*-0.005;\n    \n    float cones2 =mod(a2*40.0 , 2.0);\n    \n    col = mix(col,bg2*(1.0-(r)),(smoothstep(0.0, 0.08, cones2) * (smoothstep(1.0, 0.92, cones2))));\n    \n    //smiley\n    \n    col = mix(col,vec4(0),smoothstep(0.0015,-0.0015,r-0.2));\n    \n    {\n\t\tcol = mix(col,vec4(1.0,0.85,0.31,1.0),smoothstep(0.001,-0.001,r-0.183));\n        // mouth\n        {    \n            vec2 basecoord= uv;\n            basecoord.y-=0.03;\n            basecoord.x-=0.25;\n            basecoord*=1.25;\n            vec2 angleCoord = basecoord*0.3;\n\t\t\tfloat fd1 = faceDist(angleCoord,basecoord*2.0,uv,2.0,1.5);\n            if(  uv.y < -0.03 )\n            {\n                vec2 ac2=angleCoord-0.1;\n                vec2 bc2=basecoord*2.0-0.1;\n               \tfloat fd2 = faceDist(ac2,bc2,uv,1.2,1.5);\n                {\n                    col= mix(col,vec4(0),smoothstep(-0.01,0.01,min(fd2,fd1)));\n                   \n                    basecoord*=2.13;\n                    basecoord.x*=1.05;\n                    basecoord.x+=0.07;\n                    angleCoord = basecoord*0.3;\n                    ac2=angleCoord-0.1;\n                    bc2=basecoord-0.1;\n                    fd1=faceDist(angleCoord,basecoord,uv,2.0,1.5);\n                    fd2=faceDist(ac2,bc2,uv,1.2,1.5);\n                    if(uv.y < -0.07)\n                    {\n                        col=mix(col,vec4(0.5,0.075,0.25,1.0),smoothstep(-0.005,0.005,min(fd1,fd2)));\n                        vec2 tuv = uv;\n                        tuv.x-=0.1;\n                        tuv.y+= 0.53;\n                        float r3 = length(tuv);\n\t\t\t\t\t\t\n                        col=mix(col,vec4(1.0,0.73,0.86,1.0),smoothstep(-0.005,0.005,min(min(fd1,fd2),-(r3 - 0.23))));\n\n                    }\n                }\n            }     \n            if(uv.x > -0.54 && uv.x < 0.300 && uv.y > -0.07 && uv.y < -0.03)\n                col = vec4(0);\n        }\n        \n        //eyes\n        {\n            \n            vec2 leftuv= uv;\n            leftuv.x+=0.31;\n            leftuv.y-=0.2;\n            vec2 el = vec2(0.19,0.22);\n        \tif(uv.y > 0.08)\n            {\n                float sy1=insideSuperEllipse(leftuv,el.x,el.y,2.0);\n                \n            \tcol=mix(col,vec4(0),smoothstep(0.03,-0.03,sy1));\n                el*=0.79;\n                \n                col=mix(col,vec4(1),smoothstep(0.03,-0.03,insideSuperEllipse(leftuv,el.x,el.y,2.0)));\n\t\t\t\t\n                if(leftuv.y < -0.08 && sy1 < 0.0)\n                    col=vec4(0);\n                \n                \n                leftuv-=vec2(0.0,0.05);\n                leftuv+=vec2(-sin(iTime*5.0)*0.08,cos(iTime*5.0)*0.08);\n                float r4 = length(leftuv);\n\t\t\t\t\n                col=mix(col,vec4(0),smoothstep(0.005,-0.005,r4-0.08));\n            }\n            \n            vec2 rightuv= uv;\n            rightuv.x-=0.23;\n            rightuv.y-=0.2;\n            el = vec2(0.205,0.22);\n        \tif( uv.y > 0.08)\n            {\n                float sy1=insideSuperEllipse(rightuv,el.x,el.y,2.0);\n            \tcol=mix(col,vec4(0),smoothstep(0.03,-0.03,sy1));\n                el*=0.79;\n                \n                col=mix(col,vec4(1),smoothstep(0.03,-0.03,insideSuperEllipse(rightuv,el.x,el.y,2.0)));\n                \n                if(rightuv.y < -0.08 && sy1 < 0.0)\n                    col=vec4(0);\n                \n                rightuv-=vec2(0.0,0.05);\n                rightuv+=vec2(-sin(iTime*5.0)*0.08,cos(iTime*5.0)*0.08);\n                float r4 = length(rightuv);\n\n                col=mix(col,vec4(0),smoothstep(0.005,-0.005,r4-0.08));\n            }\n                \n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv;\n    \n       \n    vec4 col = vec4(0);\n    \n//2x2 RGSS AA\n   if(AA == 1)\n   {\n        uv = (-iResolution.xy + 2.0*fragCoord+vec2(0.125,0.375)) / iResolution.y;\n        col+=render(uv);\n        uv = (-iResolution.xy + 2.0*fragCoord+vec2(-0.375,0.125)) / iResolution.y;\n        col+=render(uv);\n        uv = (-iResolution.xy + 2.0*fragCoord+vec2(0.375,-0.125)) / iResolution.y;\n        col+=render(uv);\n        uv = (-iResolution.xy + 2.0*fragCoord+vec2(-0.125,-0.375)) / iResolution.y;\n        col+=render(uv);\n       \n       col*=0.25;\n    }\n    else\n    {\n    \tuv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n        col+=render(uv);\n    }\n    \n\tfragColor =col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sScDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[36, 36, 105, 105, 194], [196, 196, 258, 258, 313], [315, 346, 418, 418, 461], [463, 463, 485, 485, 4922], [4924, 4924, 4981, 4981, 5709]]}
{"id": "4sScRV", "name": "Quick Cornell Box", "author": "tempaccnt", "description": "Quick creation of depth and color in cornell box", "tags": ["procedural", "2d", "3d", "color", "depth"], "likes": 0, "viewed": 463, "date": "1492818599", "time_retrieved": "2024-06-20T18:52:57.547633", "image_code": "// camera at .5, 1.0, -.5\n// fov @ 90\n\n// 1/3 of vision is the back wall\nfloat twoThirds = 2.0/3.0;\nfloat oneThird = 1.0/3.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n    \n    //fragColor = vec4(uv.x, uv.y, 1.0, 1.0);\n    // fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    float z = 0.0;\n    bool isLight = false;\n    vec4 diffuse;\n    vec4 worldPos = vec4(0.0, 0.0, 0.0, 0.0);\n    if(x > oneThird && x < twoThirds && y > oneThird && y <twoThirds){\n        // back wall\n        z = -1.0;\n        diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n        worldPos.x = (x - oneThird) * 3.0;\n        worldPos.y = (y - oneThird) * 3.0;\n        worldPos.z = z;\n    }else if( y < x && y > -x + 1.0 && x > twoThirds){\n        // right wall\n        z = -(1.0-x)/oneThird;\n        diffuse = vec4(0.0, 1.0, 0.0, 1.0);\n        worldPos.x = 1.0;\n        worldPos.y = (y-(-z * oneThird)) * ((6.0 * (1.0 - x)) + 1.0);\n        worldPos.y = (y               )*((6.0 * (1.0 - x)) + 1.0) - (1.0 - x) / oneThird;\n        worldPos.z = z;\n    }else if( y > x && y < -x + 1.0 && x < oneThird){\n        // left wall\n        z = - x / oneThird;\n        diffuse = vec4(1.0, 0.0, 0.0, 1.0);\n        worldPos.x = 0.0;\n        worldPos.y = (y-(-z*oneThird))*((6.0 * (x)) + 1.0);\n        worldPos.y = (y- x            )*((6.0 * (x)) + 1.0);\n        worldPos.y = (y               )*((6.0 * (x)) + 1.0) - x / oneThird;\n        worldPos.z = z;\n    }else if( y < x && y < -x + 1.0 && y < oneThird){\n        // floor\n        z = -y/oneThird;\n        diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n        worldPos.x = (x-(-z*oneThird)) * ((6.0 * (y)) + 1.0);\n        worldPos.x = (x - y) * ((6.0 * (y)) + 1.0);\n        worldPos.x = (x               )*((6.0 * (y)) + 1.0) - y / oneThird;\n        worldPos.y = 0.0;\n        worldPos.z = z;\n    }else if( y > x && y > -x + 1.0 && y > oneThird){\n        // ceiling\n        z = -(1.0-y)/oneThird;\n        diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n        worldPos.x = (x-(-z*oneThird))*((6.0 * (1.0 - y)) + 1.0);\n        worldPos.x = (x - (1.0 - y)) * ((6.0 * (1.0 - y)) + 1.0);\n        worldPos.x = (x               )*((6.0 * (1.0 - y)) + 1.0) - (1.0 - y) / oneThird;\n        worldPos.y = 1.0;\n        worldPos.z = z;\n        if( y > 3.0 * x - 1.0 && y > -3.0 * x +2.0 && -z > oneThird && -z < twoThirds){\n            // light window\n            diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n            //isLight = true;\n        }\n    }else{\n        // nothing should get here\n        diffuse = vec4(x, y, x, 1.0);\n    }\n    \n    vec4 lightPos = vec4(0.5, sin(iTime) * 0.5 + 0.5, -0.5, 1.0);\n    vec4 diff = worldPos - lightPos;\n    float lightInt = 1.0 - 4.0/5.0 * sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n    if(isLight){\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }else{\n        fragColor =  diffuse * lightInt;\n    }\n    /*\n    if(x >= 0.499 && x <= 0.501){\n        fragColor = vec4(0.5, 0.0, 0.0, 0.0);\n    }else if(y >= 0.498 && y <= 0.502){\n        fragColor = vec4(0.5, 0.0, 0.0, 0.0);\n    }else{\n        fragColor = vec4(worldPos.x, 0.0, 0.0, 0.0);\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sScRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[39, 127, 184, 184, 3172]]}
{"id": "4sSyDW", "name": "zooming grid layers", "author": "public_int_i", "description": "zooming grid layers, buffers didnt work this morning so i went for something 2D", "tags": ["grid", "layers", "zooming"], "likes": 1, "viewed": 472, "date": "1491998976", "time_retrieved": "2024-06-20T18:52:57.802085", "image_code": "\n#define gridsize 0.5\n\n\n#define draw(dc) c = mix(dc,c,clamp(d/pixelSize, 0., 1.))\n\n\n//2d box signed distance\nfloat sdBox(vec2 p, vec2 b)\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixelSize = length(1.0/iResolution.xy);\n\tvec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.x;\n    \n    //infinite zoom, repeating offset and scaling\n    float zoomRepeat = fract(iTime)*(1.0+1e-4),\n        scale = zoomRepeat;\n    uv += zoomRepeat*0.5;\n    uv *= 1.0-scale*0.5;\n    \n    \n    vec3 c = vec3(1.);//start with white background\n    \n    //layers of grids, first smallest is fading in\n    for (int i = 1; i < 3; i++) {\n        float sz = gridsize/pow(2.,float(3-i)),\n              sz2 = sz/2.0;\n      \tfloat d = abs(sdBox(mod(abs(uv),sz)-sz2, vec2(sz2)))-0.004*(1.0-scale*0.75);\n    \t\n        vec3 rc = vec3(0.);\n        if (i == 1) rc = vec3(1.-zoomRepeat);\n        draw(rc);\n    }\n    \n    //output color\n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sSyDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[84, 109, 138, 138, 216], [220, 220, 277, 277, 1038]]}
{"id": "ld2yDR", "name": "LH", "author": "gilesruscoe", "description": "LH", "tags": ["giles"], "likes": 1, "viewed": 72, "date": "1491700412", "time_retrieved": "2024-06-20T18:52:58.286931", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Aspect ratio of screen\n    float aspect = iResolution.y / iResolution.x;\n    //Uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //Centered\n    uv = uv * 2.f - 1.f;\n    //Aspect ratio fix\n    uv.y *= aspect;\n    \n    //Circle mask\n    float circle = smoothstep(length(uv), length(uv)+0.005f, 0.5f);\n    \n    //Colors\n    const vec3 red = vec3(0.89, 0.27, 0.18);\n    const vec3 green = vec3(0.5f, 0.72f, 0.2f);\n    const vec3 blue = vec3(0.26f, 0.64f, 0.85f);\n    const vec3 mint = vec3(0.22f, 0.82f, 0.4f);\n    const vec3 orange = vec3(0.96f, 0.7f, 0.18f);\n    vec3 white = mix(blue, vec3(1.f, 1.f, 1.f), length(vec2(5.0f, -5.0f) - uv * 2.f) * 0.135f);\n    const vec4 bgCol = vec4(0.13,0.2,0.282,1);\n    \n    //Because sin is a bastard\n    const float PI = 3.14159265f;\n\t\n    //Base height of waves\n    const float waveBaseline = -0.25f;\n    \n    //Phase of the sine wave, to allow tiling phase modulation\n    float heightPhase = sin(mod(iTime * 0.35f, 0.5*PI)) * PI;\n    //increased phase mod for wave speed\n    float phase = heightPhase * 16.f;\n    \n    //Height of the waves controlled by phase modulation\n\tfloat waveHeight = 0.2f * (1.f-(sin(2.0*PI + heightPhase) * 0.5f + 0.5f));\n\t\n    //The red wave\n    vec4 redWave;\n    float redWaveform = sin(2.0*PI*uv.x * 0.7f + phase - 1.1f);//sin(5.3f + iTime * 0.75f + uv.x * 4.f);\n    redWave.rgb = red;\n    redWave.a = smoothstep(uv.y + redWaveform * waveHeight, uv.y + redWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //The blue wave\n    vec4 blueWave;\n    float blueWaveform = sin(2.0*PI*uv.x * 1.15f + phase - 0.6f);\n    blueWave.rgb = blue;\n    blueWave.a = smoothstep(uv.y + blueWaveform * waveHeight, uv.y + blueWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //The green wave\n    vec4 greenWave;\n    float greenWaveform = sin(2.0*PI*uv.x * 2.0f + phase);\n    greenWave.rgb = green; \n    greenWave.a = smoothstep(uv.y + greenWaveform * waveHeight, uv.y + greenWaveform * waveHeight + 0.005f, waveBaseline);\n    \n    //Combine waves\n    vec4 waveComp = mix(bgCol, redWave, redWave.a);\n    waveComp = mix(waveComp, blueWave, blueWave.a);\n    waveComp = mix(waveComp, greenWave, greenWave.a);\n    \n    //Overlap between green and blue\n    float mintSection = smoothstep( 1.99f, 2.0f, greenWave.a + blueWave.a);\n    waveComp = mix(waveComp, vec4(mint, 1.0f), mintSection);\n    \n    //Overlap between red and green\n    float orangeSection = smoothstep(1.99f, 2.0f, greenWave.a + redWave.a - blueWave.a);\n    waveComp = mix(waveComp, vec4(orange.rgb, 1.0f), orangeSection);\n   \n    //Overlap between all\n    float whiteSection = smoothstep(2.2f, 3.0f, greenWave.a + redWave.a + blueWave.a);\n    waveComp = mix(waveComp, vec4(white, 1.0f), whiteSection);\n    \n    //Lighthouse\n    vec2 LHPos = vec2(0.086f, -0.1f);\n    LHPos.y = mix(-0.05f, -0.1f, sin(iTime) * 0.5 + 0.5);\n    float leftTopPlane = smoothstep((LHPos.x + uv.x) * -4.f + (LHPos.y + uv.y) * 5.f, 0.02f +(LHPos.x + uv.x) * -4.f + (LHPos.y + uv.y) * 5.f, 1.f);\n\tfloat rightTopPlane = smoothstep((LHPos.x + uv.x) * 4.f + (LHPos.y + uv.y) * 5.f, 0.02f + (LHPos.x + uv.x) * 4.f + (LHPos.y + uv.y) * 5.f, 1.7f);\n    float middleSplit = step(uv.x, 0.0f);\n    float leftSidePlane = smoothstep((LHPos.x + uv.x) * -30.f + (LHPos.y + uv.y) * 5.f, 0.15f + (LHPos.x + uv.x) * -30.f + (LHPos.y + uv.y) * 5.f, 0.4f);\n    float rightSidePlane = smoothstep((LHPos.x + uv.x) * 30.f + (LHPos.y + uv.y) * 5.f, 0.15f + (LHPos.x + uv.x) * 30.f + (LHPos.y + uv.y) * 5.f, 5.65f);\n    float LHMask = leftSidePlane * leftTopPlane * rightTopPlane * rightSidePlane;\n    LHMask *= clamp(uv.y * 2.5 + 0.5, 0.f, 1.f);\n    float grad1 = uv.y * 0.75 + 0.3;\n    float grad2 = 1.3 * (uv.y * 0.75 + 0.4);\n    float LH = mix(grad1, grad2, middleSplit) * LHMask;\n    //Final comp\n    vec4 comp = mix(vec4(1,1,1,1), waveComp, circle);\n\tfragColor = comp + LH;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 91, 3924]]}
{"id": "ld2yzK", "name": "Spinning Blue Circles", "author": "space928", "description": "I'm learning Shadertoy, this is my first shader (in Shadertoy)", "tags": ["2d", "simple", "rotation"], "likes": 0, "viewed": 66, "date": "1492937101", "time_retrieved": "2024-06-20T18:52:58.286931", "image_code": "//sampler2D iChannel0;\nint boxes = 100;\nfloat spinSpd = 1.0;\nfloat boxSize = 10.0;\nfloat noiseStr = 0.04;\nfloat space = 0.1;\nvec3 col1 = vec3(0.2,0.4,1.0);//fade from\nvec3 col2 = vec3(0.00,0.025,0.25);//fade to\nvec3 col3 = vec3(0.1,1.0,0.8);\nvec3 col4 = vec3(0.001,0.05,0.05);\n\nvec3 box(vec2 pos, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xx - pos;\n    uv *= mat2(cos(-iTime*spinSpd), -sin(-iTime*spinSpd),\n               sin(-iTime*spinSpd), cos(-iTime*spinSpd));\n    uv *= boxSize;\n    \n    vec3 col = vec3(0.0);\n    col += mix(col1, col2, uv.x)/vec3(2.0);\n    col += mix(col3, col4, uv.y)/vec3(2.0);\n    \n    if(length(uv) > 1.0) {\n        uv = vec2(0.0);\n        col = vec3(0.0);\n    }\n    \n    return col;//vec3(uv, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(1.0, iResolution.y/iResolution.x);\n    \n    vec2 n = texture(iChannel0, fragCoord.xy / iResolution.xx*64.0).xy*2.0-1.0;\n    n*= vec2(noiseStr);\n    \n    vec2 pos = vec2(0.5);\n\tvec3 outCol = vec3(0.0);\n    \n    for(int i = 0; i < boxes; i++) {\n    \toutCol += box (pos*res + n, fragCoord);\n        pos += vec2(cos(iTime)*space, sin(iTime)*space);\n    }\n\tfragColor = vec4(outCol,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[155, 278, 314, 314, 745], [747, 747, 804, 804, 1208]]}
{"id": "ld2yzt", "name": "Smileys demo", "author": "ocdy1001", "description": "ok", "tags": ["test"], "likes": 0, "viewed": 82, "date": "1493405969", "time_retrieved": "2024-06-20T18:52:58.286931", "image_code": "#define PI 3.1415f\n//shapes---------------------------------------------------------------------------\nfloat circle(vec2 uv, vec2 pos, float r, float blur){\n    float d = length(uv - pos);\n    return smoothstep(r, r-blur, d);\n}\n\nfloat band(float t, float start, float end, float blur){\n    float s0 = smoothstep(start-blur, start+blur, t);\n    float s1 = smoothstep(end+blur, end-blur, t);\n    return s0*s1;\n}\n\nfloat rect(vec2 uv, float l, float r, float t, float b, float blur){\n\tfloat s0 = band(uv.x, l, r, blur);\n    float s1 = band(uv.y, t, b, blur);\n    return s0*s1;\n}\n//other----------------------------------------------------------------------------\nfloat smiley(vec2 uv, vec2 pos, float r){\n    uv -= pos;\n    uv /= r * 2.5f;\n    \n    float mask = circle(uv, vec2(0.0f, 0.0f), 0.4f, 0.05f);\n    mask -= circle(uv, vec2(-0.13f, 0.16f), 0.05f, 0.01f);\n    mask -= circle(uv, vec2(+0.13f, 0.16f), 0.05f, 0.01f);\n    \n    float mouth = circle(uv, vec2(0.0f, 0.0f), 0.3f, 0.02f);\n    mouth -= circle(uv, vec2(0.0f, 0.3f), 0.5f, 0.02f);\n    mouth = max(mouth, 0.0f);\n    \n    mask -= mouth;\n    mask -= rect(uv, -0.03f, +0.03f, -0.1f, +0.05f, 0.01f);\n        \n    return mask;\n}\n//main----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rawuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n    uv -= 0.5f;//set origen to the middle of the screen.\n    uv.x *= iResolution.x / iResolution.y;//aspect ratio\n    \n\tfloat mask = 0.0f;\n    \n    mask += smiley(uv, vec2(0.0f, 0.0f), 0.3f);\n    for(int i = 0; i < 10; i++){\n        float rot = (float(i) * (2.0f*PI/10.0f)) + (iTime * 0.3f);\n    \tmask += smiley(uv, vec2(sin(rot)*0.4f, cos(rot)*0.4f), 0.05f);\n    }\n    \n    vec3 backg = vec3(rawuv,0.5+0.5*sin(iTime));\n    vec3 col = backg * mask;\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld2yzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[19, 103, 156, 156, 227], [229, 229, 285, 285, 409], [411, 411, 479, 479, 574], [575, 659, 700, 700, 1182], [1183, 1266, 1321, 1321, 1893]]}
{"id": "ldBcDm", "name": "Revision logo", "author": "Daedelus", "description": "Approximated from the goodybag... hung over at the party.", "tags": ["revisionlogo"], "likes": 3, "viewed": 124, "date": "1492344264", "time_retrieved": "2024-06-20T18:52:58.293095", "image_code": "#define ANIMATE\n\n#define TAU 6.28318530718\n#define PI 3.14159265359\n\nbool isPixelInLogo(vec2 uv)\n{\n    float d = length(uv);\n    int id = int(floor(d * 10.0));\n    \n    float angle = atan(uv.x, uv.y);\n    #ifdef ANIMATE\n    angle = fract((angle / TAU + 0.5) + float(id) * iTime * 0.02) * TAU - PI;\n    #endif\n\n    // this should be a switch\n    //if(id == 0)\n    //{\n    //   return false;\n    //}\n    if(id == 1)\n    {\n        return true;\n    }\n    else if(id == 2)\n    {\n        if(angle < -0.32 && angle > -1.45)\n        {\n            return true;\n        }\n    }\n    else if(id == 3)\n    {\n        if(angle < 0.35 && angle > 0.1)\n        {\n            return true;\n        }\n        if(angle < 2.3 && angle > 1.7)\n        {\n            return true;\n        }\n        if(angle < -1.9 && angle > -2.6)\n        {\n            return true;\n        }\n    }\n    else if(id == 4)\n    {\n        if(angle < 0.8 && angle > -0.2)\n        {\n            return true;\n        }\n        if(angle < 2.75 && angle > 1.0)\n        {\n            return true;\n        }\n        if(angle < -1.65 || angle > 2.95)\n        {\n            return true;\n        }\n    }\n    else if(id == 5)\n    {\n       \treturn true;\n    }\n    //else if(id == 6)\n    //{\n    //   \treturn false;\n    //}\n    else if(id == 7)\n    {\n        if(angle < -2.6 && angle > -2.77)\n        {\n            return true;\n        }\n        else if(angle > 2.75)\n        {\n            return true;\n        }\n        else if(angle > -1.55 && angle < -1.25)\n        {\n            return true;\n        }\n        else if(angle > -0.95 && angle < -0.75)\n        {\n            return true;\n        }\n        else if(angle > -0.23 && angle < 0.23)\n        {\n            return true;\n        }\n        else if(angle > 0.7 && angle < 1.7)\n        {\n            return true;\n        }\n    }\n    else if(id == 8)\n    {\n       \treturn true;\n    }\n    else if(id == 9)\n    {\n        if(angle > -2.55 && angle < -1.6)\n        {\n            return true;\n        }\n        else if(angle > 0.7 && angle < 0.85)\n        {\n            return true;\n        }\n    }\n    \n\treturn false;\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    int id = int(floor(hsv.x * 6.0));\n    float local = fract(hsv.x * 6.0);\n    vec3 c = vec3(1.0, local, 0.0);\n    if(id == 1)\n    {\n        c = vec3(1.0 - local, 1.0, 0.0);\n    }\n    else if(id == 2)\n    {\n        c = vec3(0.0, 1.0, local);\n    }\n    else if(id == 3)\n    {\n        c = vec3(0.0, 1.0 - local, 1.0);\n    }\n    else if(id == 4)\n    {\n        c = vec3(local, 0.0, 1.0);\n    }\n    else if(id == 5 )\n    {\n        c = vec3(1.0, 0.0, 1.0 - local);\n    }\n\treturn mix(c * hsv.z, hsv.zzz, 1.0 - hsv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy* 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    vec3 foreground = hsv2rgb(vec3(fract(d + iTime * 0.2 + atan(uv.x, uv.y) / PI), 0.4, 0.8));\n    vec3 background = vec3(0.0);\n    \n    fragColor = vec4(isPixelInLogo(uv) ? foreground : background, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[69, 69, 98, 98, 2110], [2112, 2112, 2136, 2136, 2650], [2652, 2652, 2709, 2709, 3012]]}
{"id": "ldBcDw", "name": "cube has evolev", "author": "floopfloop", "description": "o no", "tags": ["cube", "edgerendering"], "likes": 1, "viewed": 77, "date": "1492327059", "time_retrieved": "2024-06-20T18:52:58.511188", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_position = (iResolution.xy - 2.0*fragCoord.xy) / iResolution.y;\n    \n    float xmod = 0.0;//sin(iTime * 1.25) * 0.75;\n    float ymod = 0.0;//cos(iTime * 2.5) * 0.25;\n    float zmod = cos(iTime * 1.75);\n    \n    vec3 velocity = vec3(xmod, ymod, zmod);\n    \n    vec3 position = (vec3(0.5, 0.5, 1.0) * vec3(uv_position, 1.0)) + velocity;\n    vec3 bounds = vec3(0.1, 0.1, 0.1) * position.z;\n\n    float cubic_field = length(max(abs(vec2(position))-vec2(bounds),0.0));\n    \n\t// sharpness is hard to control in general, its relationship\n    // with field should be defined better somehow\n    \n    // It's really interesting to have a slight breathing-esque animation to\n    // the fields though. Makes things feel more alive and less clinical.\n    float sharpness = (sin(iTime*1.25)*0.25 + 1.) * 1000.;\n    \n    // And somehow I've made edge rendering. Cool.\n    float technique = 1./(1.0-cubic_field * sharpness);\n    \n    fragColor = vec4(\n        1.0 + technique, \n        0.75 + technique, \n        0.6 + technique, \n        technique\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 56, 56, 1109]]}
{"id": "ldBcRD", "name": "Volume Mandelbulb", "author": "soma_arc", "description": "Volume Rendered Mandelbulb.\nReference: http://graphicsrunner.blogspot.jp/2009/01/volume-rendering-101.html", "tags": ["3d", "fractal", "volume"], "likes": 21, "viewed": 509, "date": "1491112065", "time_retrieved": "2024-06-20T18:52:59.444680", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nconst float MAX_MANDEL_ITERATION = 4.;\nbool mandelbulb(vec3 pos, \n                out float iterationCount,\n               out float minDist, out float maxDist) {\n    vec3 z = pos;\n    float r = 0.;\n    iterationCount = 0.;\n    float power = 8.;\n    minDist = 99999.;\n    maxDist = -1.;\n    for (float i = 0.; i < MAX_MANDEL_ITERATION; i++) {\n\t\titerationCount = i;\n        r = length(z);\n        minDist = min(minDist, r);\n        maxDist = max(maxDist, r);\n        if( r > 2. ) return false;\n        \n        float zr = pow( r,power);\n        float theta = acos(z.y / r);\n\t\tfloat phi = atan(z.z, z.x);\n        theta *= power;\n        phi *= power;\n        z = zr*vec3(sin(theta)*cos(phi),\n                    cos(theta),\n                    sin(phi)*sin(theta));\n        z += pos;\n    }\n    \n    return true;\n}\n\nvec4 sampleVolume(vec3 p) {\n    float itCount, minDist, maxDist;\n    bool mandel = mandelbulb(p, itCount, minDist, maxDist);\n\tif (!mandel) return vec4(0);\n\treturn vec4(hsv2rgb(vec3(minDist, 1., 1.)), 0.1);\n}\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec4 l = vec4(0);\n\n\tfloat t0, t1;\n   \tbool hit = intersectBox(eye, ray, \n                    \t\tvec3(-1.5), vec3(1.5),\n                    \t\tt0, t1);\n    \n    if(!hit) return l.rgb;\n    \n    const float MAX_SAMPLES = 150.;\n    float t = t0;\n    float tStep = (t1 - t0) / MAX_SAMPLES;\n    \n    vec3 p0 = eye + t0 * ray;\n    vec3 p1 = eye + t1 * ray;\n    vec3 distP = p0 - p1;\n    float dist = abs(dot(vec3(1, 0, 0), distP));\n    dist = max(dist, abs(dot(vec3(0, 1, 0), distP)));\n    dist = max(dist, abs(dot(vec3(0, 0, 1), distP)));\n    float sliceWidth = .05;\n    float samples = floor(dist / sliceWidth) + 1.;\n    //tStep = (t1 - t0) / samples;\n    samples = MAX_SAMPLES;\n    for (float i = 0.; i < MAX_SAMPLES; i++){\n    \tif((min(min(l.x, l.y), l.z)) > 1.0 ||\n           l.w > 0.999 ||\n           t >= t1 ||\n          samples < i) break;\n        \n        vec3 p = eye + t * ray;\n        \n        vec4 volCol = sampleVolume(p);\n        volCol.a *= 1.;\n        volCol.rgb *= volCol.a;\n        l = (1. - l.a) * volCol + l;\n        \n        t += tStep; \n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 eye = vec3(1.9 * sin(iTime) , 2. * sin(iTime), \n                    1.9 * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 541], [639, 639, 791, 791, 1151], [1202, 1202, 1229, 1229, 1343], [1345, 1345, 1466, 1466, 2232], [2273, 2273, 2396, 2396, 3045], [3047, 3047, 3074, 3074, 3254], [3256, 3256, 3303, 3303, 4387], [4433, 4433, 4462, 4462, 4639], [4763, 4763, 4819, 4819, 5361]]}
{"id": "ldBcRy", "name": "Procedural Checkers", "author": "animatedlew", "description": "This shader produces a procedural checkered texture.", "tags": ["procedural", "texture", "checkers"], "likes": 3, "viewed": 120, "date": "1492543011", "time_retrieved": "2024-06-20T18:52:59.444680", "image_code": "bool inTile(vec2 p, float tileSize) {\n    // draw tiles that are tileSize in size\n    vec2 ptile = step(0.5, fract(0.5 * p / tileSize));\n    return ptile.x == ptile.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = fragCoord.xy;\n    // smooth out the sine motion with a sqrt; tile size of 16\n    float tileSize = sqrt(sin(iTime * 2.) / 2. + 1.) * 16.;\n    // if diagonals match, draw as a black square\n    if (inTile(fragCoord.xy, tileSize)) fragColor = vec4(0.);\n    else fragColor = vec4(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 81, 169], [171, 171, 228, 228, 520]]}
{"id": "ldBcWW", "name": "Slide Operation", "author": "gaz", "description": "idia from sdCapsule", "tags": ["raymarching"], "likes": 4, "viewed": 187, "date": "1492065597", "time_retrieved": "2024-06-20T18:52:59.444680", "image_code": "mat3 rotate(in vec3 axis, in float theta)\n{\n  axis = normalize(axis);\n  float x = axis.x, y = axis.y, z = axis.z, s = sin(theta), c = cos(theta), o = 1.0-c;\n  return mat3(\n    o*x*x+c,o*x*y+z*s,o*z*x-y*s,\n    o*x*y-z*s,o*y*y+c,o*y*z+x*s,\n    o*z*x+y*s,o*y*z-x*s,o*z*z+c);\n}\n\nvec4 opSlide(vec3 p, vec3 a, vec3 b, vec3 up){\n  vec3 ba = b - a;\n  float h = clamp(dot(p-a, ba) / dot(ba, ba), 0., 1.);\n  p -= a + ba * h;\n  vec3 w = normalize(ba), u = normalize(cross(up, w)), v = cross(w, u);\n  return vec4(p * mat3(u, v, w), h);\n}\n\n/*\nvec4 opSlide(in vec3 p, in vec3 a, in vec3 b, in vec3 up)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 hor = normalize(cross(ba, up));\n  vec3 ver = normalize(cross(ba, hor));\n  p = p - (a + ba * h);\n  return vec4(dot(p, hor), dot(p, ver), dot(p, normalize(ba)), h);\n}\n*/\n\nfloat sdSphere(in vec3 p, in float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism(in vec3 p, in vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat deJyabara(in vec3 p, in float t)\n{\n\tfloat de2 = abs(length(p.xz) - 0.5 + 0.02 * sin(t * 30.0));\n    vec2 d = abs(vec2(de2, p.y)) - vec2(0.08, 0.0);\n  \treturn min(max(d.x, d.y), -0.03) + length(max(d, 0.0));  \n}\n\nfloat map(in vec3 p)\n{\n\tvec3 a = rotate(normalize(vec3(1, 2, -3)), iTime*0.5) * vec3(0.8);\n \tvec3 b = rotate(normalize(vec3(2, 1, -1)), iTime*0.3) * vec3(-0.7);\n \tvec3 up = normalize(vec3(1,2,3));   \n\tvec4 op = opSlide(p, a, b, up);\n\tp = op.xyz; \n\tswitch (int(floor(mod(iTime * 0.3, 5.0)))) {\n\tcase 0:\n  \t\treturn length(max(abs(p) - vec3(0.5, 0.2, 0.0), 0.0)) - 0.05;\n  \tcase 1:\n\t\treturn sdTorus(p, vec2(0.5, 0.2));\n  \tcase 2:\n\t\treturn sdHexPrism(p.xzy, vec2(0.3, 0.2));\n  \tcase 3:\n\t\treturn sdSphere(p, 0.35);\n  \tcase 4:\n\t\treturn deJyabara(p.xzy, op.w);\n  \t}\n}\n\nvec3 calcNormal(in vec3 p)\n{\n  vec2 e = vec2(1.0, -1.0) * 0.002;\n  return normalize(\n    e.xyy*map(p+e.xyy)+e.yyx*map(p+e.yyx)+ \n    e.yxy*map(p+e.yxy)+e.xxx*map(p+e.xxx)\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n  vec3 ro = vec3(0, 0, 3);\n  vec3 rd = normalize(vec3(p, -1.5));\n  vec3 col = vec3(0.1, 0.6, 0.7) * p.y * p.y;\n  float maxd = 10.0;\n  float t = 0.0, d;\n  for(int i = 0; i < 128; i++)\n  {\n    t += d = map(ro + rd * t);\n    if(d < 0.001 || t > maxd) break;\n  }\n  if(t < maxd)\n  {\n    vec3 p = ro + rd * t;\n    vec3 normal = calcNormal(p);\n    vec3 light = normalize(vec3(1));\n    col = \n      mix(\n        col,\n        clamp(\n          vec3(1.0, 0.2, 0.2) *\n          clamp((dot(normal, light)+0.5)*0.7, 0.3, 1.0) *\n          max(0.0, 0.7+0.3*normal.y) +\n          pow(\n            clamp(\n              dot(reflect(normalize(p - ro), normal), light),\n              0.0, 1.0\n            ),\n            80.0\n          ) * step(0.5, dot(normal, light)),\n          0.0,1.0\n        ),\n        exp(-pow(length(p - ro),2.0)*0.02)\n      );\n  \tcol = pow(col, vec3(0.7));\n  }\t\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldBcWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 43, 43, 273], [275, 275, 321, 321, 525], [527, 853, 893, 893, 917], [919, 919, 957, 957, 1022], [1024, 1024, 1065, 1065, 1149], [1151, 1151, 1204, 1204, 1244], [1246, 1246, 1286, 1286, 1462], [1464, 1464, 1486, 1486, 2024], [2026, 2026, 2054, 2054, 2203], [2205, 2205, 2262, 2262, 3223]]}
{"id": "ldByDW", "name": "IIS 3D Loxodromic - Parabolic Ex", "author": "soma_arc", "description": "Render the orbit of spheres with Iterated Inversion System.\nLoxodromic <--> Parabolic\n", "tags": ["3d", "fractal", "inversion", "schottky"], "likes": 1, "viewed": 129, "date": "1493038585", "time_retrieved": "2024-06-20T18:53:02.057222", "image_code": "/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nmat4 pivoting(mat4 mat, int k){\n    const int n = 3;\n    int col = k;\n    float maxValue = abs(mat[k][k]);\n    for(int i = k+1; i < n ; i++){\n        if(abs(mat[i][k]) > maxValue){\n            col = i;\n            maxValue = abs(mat[i][k]);\n        }\n    }\n    if(k != col){\n        vec4 tmp = mat[col];\n        mat[col] = mat[k];\n        mat[k] = tmp;\n    }\n    return mat;\n}\n\nvec4 makeSphereFromPoints(const vec3 p1,\n                          const vec3 p2,\n                          const vec3 p3,\n                          const vec3 p4){\n    mat4 p = mat4(vec4(p1, 0), vec4(p2, 0),\n                  vec4(p3, 0), vec4(p4, 0));\n    mat4 coefficient = mat4(vec4(1), vec4(1), vec4(1), vec4(0));\n    \n    for(int i = 0 ; i < 3 ; i++){\n        coefficient[i][0] = 2. * (p[i + 1][0] - p[i][0]);\n\t    coefficient[i][1] = 2. * (p[i + 1][1] - p[i][1]);\n\t    coefficient[i][2] = 2. * (p[i + 1][2] - p[i][2]);\n\t    coefficient[i][3] = -(p[i][0] * p[i][0] + p[i][1] * p[i][1] + p[i][2] * p[i][2])+\n\t        p[i + 1][0] * p[i + 1][0] + p[i + 1][1] * p[i + 1][1] + p[i + 1][2] * p[i + 1][2];\n    }\n\n    // Gaussian elimination\n    // Implementation is based on http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%A5%D4%A5%DC%A5%C3%A5%C8%C1%AA%C2%F2\n    // forward elimination\n    const int n = 3;\n    for(int k = 0; k < n - 1; k++){\n        coefficient = pivoting(coefficient, k);\n\n        float vkk = coefficient[k][k];\n        for(int i = k+1; i < n; i++){\n            float vik = coefficient[i][k];\n            for(int j = k; j < n + 1; ++j){\n                coefficient[i][j] = coefficient[i][j]-vik *(coefficient[k][j]/vkk);\n            }\n        }\n    }\n\n    // back substitution\n    \n    coefficient[n-1][n] = coefficient[n-1][n]/coefficient[n-1][n-1];\n    for(int i = n-2; i >= 0; i--){\n        float acc = 0.0;\n        for(int j = i+1; j < n; j++){\n            acc += coefficient[i][j]*coefficient[j][n];\n        }\n        coefficient[i][n] = (coefficient[i][n] - acc)/coefficient[i][i];\n    }\n    \n    vec3 center = vec3(coefficient[0][3], \n                       coefficient[1][3],\n                       coefficient[2][3]);\n    float r = distance(center, p1);\n    return vec4(center, r);\n}\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nconst float RT_3 = sqrt(3.);\nvec4 sphereInvertOnSphere(vec4 invertSphere, vec4 genSphere){\n    float r = invertSphere.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = sphereInvert(invertSphere.xyz + vec3(coeffR),\n                           genSphere);\n    vec3 p2 = sphereInvert(invertSphere.xyz + vec3(-coeffR), \n                           genSphere);\n    vec3 p3 = sphereInvert(invertSphere.xyz + vec3(coeffR, -coeffR, - coeffR),\n                           genSphere);\n    vec3 p4 = sphereInvert(invertSphere.xyz + vec3(coeffR, coeffR, - coeffR),\n                           genSphere);\n    return makeSphereFromPoints(p1, p2, p3, p4);\n}\n\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(float h, float s, float v){\n  vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n  return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nbool intersectSphere(vec4 sphere,\n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphere.xyz;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphere.xyz);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nconst vec4 baseSphere = vec4(0, 60, 180, 125);\n\nconst float schottkyRad = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRad) + vec4(baseSphere.xyz, 0);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRad)+ vec4(baseSphere.xyz, 0);\n\nvec4 S1 = vec4(0, 695, 555, 500);\nvec4 S2 = vec4(0, 695, 500, 660);\nvec4 S1d; //I_S1(S2)\nint maxIterations = 0;\nconst int MAX_KLEIN_ITARATION = 30;\nfloat distIIS(vec3 pos, out float loopNum){\n    pos -= vec3(0, 0, 0);\n  \tfloat dr = 1.;\n  \tbool loopEnd = true;\n  \tfloat scalingFactor= .08;\n  \tloopNum = 0.;\n  \tfor(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n  \t\tif(i >= maxIterations) break;\n        loopEnd = true;\n    \tif(distance(pos, S1.xyz) < S1.w){\n            vec3 diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n      \t\tpos = sphereInvert(pos, S1);\n\n            diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, S1d.xyz) >= S1d.w){\n            vec3 diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            \n            diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S1);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n      \t\tvec3 diff = (pos - schottky1.xyz);\n      \t\tdr *= schottky1.w * schottky1.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky1);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky2.xyz) < schottky2.w){\n      \t\tvec3 diff = (pos - schottky2.xyz);\n      \t\tdr *= schottky2.w * schottky2.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky2);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky3.xyz) < schottky3.w){\n      \t\tvec3 diff = (pos - schottky3.xyz);\n      \t\tdr *= schottky3.w * schottky3.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky3);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky4.xyz) < schottky4.w){\n      \t\tvec3 diff = (pos - schottky4.xyz);\n      \t\tdr *= schottky4.w * schottky4.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky4);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky5.xyz) < schottky5.w){\n      \t\tvec3 diff = (pos - schottky5.xyz);\n      \t\tdr *= schottky5.w * schottky5.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky5);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky6.xyz) < schottky6.w){\n      \t\tvec3 diff = (pos - schottky6.xyz);\n      \t\tdr *= schottky6.w * schottky6.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky6);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}\n    \tif(loopEnd == true) break;\n    }\n\n    return (distance(pos, baseSphere.xyz) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 getNormal(const vec3 p){\n\tconst vec2 d = vec2(1., 0.);\n    float loopNum;\n\treturn normalize(vec3(distIIS(p + d.xyy, loopNum) - distIIS(p - d.xyy, loopNum),\n                          distIIS(p + d.yxy, loopNum) - distIIS(p - d.yxy, loopNum),\n                          distIIS(p + d.yyx, loopNum) - distIIS(p - d.yyx, loopNum)));\n}\n\n\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\nconst vec3 AMBIENT_FACTOR = vec3(.1);\nfloat transparent = 0.4;\nvoid renderGenerators(vec3 eye, vec3 rayDir, \n                      inout vec4 l, inout float minDist){\n\tvec3 intersection, normal;\n    minDist = 999999.;\n\tfloat S1dDist;\n    bool hitS1d = intersectSphere(S1d, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS1d){\n    \tvec3 mcol = vec3(0., 0, 0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    S1dDist = minDist;\n    \n    minDist = 999999.;\n    bool hitS2 = intersectSphere(S2, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS2){\n    \tvec3 mcol = vec3(0., 0.7, 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = 999999.;\n    bool hitS1 = intersectSphere(S1, eye, rayDir, \n                     \t\t\t minDist, intersection, normal);\n    if(hitS1){\n    \tvec3 mcol = vec3(0.7, 0., 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n  \n\t\n    minDist = 999999.;\n    bool hitS = intersectSphere(schottky1, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky2, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky3, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky4, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = 999999.;\n    hitS = intersectSphere(schottky5, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky6, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }    \n    \n    minDist = S1dDist;\n}\n\nint MAX_MARCH = 800;\nvec3 calcColor(float time, vec3 eye, vec3 rayDir){\n  \tvec4 l = vec4(0);\n\n    vec3 rayPos = eye;\n    float dist;\n    float rayLength = 0.;\n    bool hit = false;\n    float loopNum;\n    \n    \n    float minDist = 99999.;\n    if(transparent > 0.01)\n\t\trenderGenerators(eye, rayDir, l, minDist);\n    \n    float t0, t1;\n    bool inBox;\n    vec3 bboxMin = vec3(-3000, -5000, -1000);\n    vec3 bboxMax = vec3(3000, 1000, 5000);\n    bool hitBBox = intersectBox(eye, rayDir, bboxMin, bboxMax, t0, t1, inBox);\n    if(hitBBox == false) return l.rgb;\n    //if(hitBBox ) return vec3(1);\n\n    if(!inBox){\n    \trayLength = t0;\n        rayPos = eye + rayDir * rayLength;\n    }\n    for(int i = 0 ; i < MAX_MARCH ; i++) {\n        if(rayLength > t1) break;\n    \tdist = distIIS(rayPos, loopNum);\n        \n        //dist = distance(rayPos, S1d.xyz) - S1d.w;\n        rayLength += dist;\n        rayPos = eye + rayDir * rayLength;\n        if(dist < .2){\n          \thit = true;\n            break;\n        }\n    }\n    //if(hit && rayLength < minDist) l = vec4(0);\n    \n    if(hit){\n        vec3 mCol;\n    \tif(loopNum == 0.)\n        \tmCol = hsv2rgb(0.33, 1., .77);\n    \telse\n        \tmCol = hsv2rgb(0.0 + loopNum * 0.12 , 1., 1.);\n        vec3 normal = getNormal(rayPos);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * mCol;\n    \tvec3 ambient = mCol * AMBIENT_FACTOR;\n\n        vec4 col = vec4(diffuse + ambient, 1.);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l;\n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, PI * 12.);\n\n    float start = 1.;\n    float dur = 2.;\n    maxIterations = int(mix(0., 15., (scene(t, start, dur))));\n    \n    start += dur + 1.;\n    dur = 2.; \n    float r = mix(4000., 1000., (scene(t, start, dur)));\n    \n    start += dur + 2.;\n    dur = 1.;    \n\tschottky1.w = mix(0., schottkyRad, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w = mix(0., schottkyRad, circEasingIn(scene(t, start + dur, dur)));\n\tschottky3.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 2. * dur, dur)));\n\tschottky4.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 3. * dur, dur)));\n    schottky5.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 4. * dur, dur)));\n\tschottky6.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 5. * dur, dur)));\n\tdur = dur * 6.;\n    \n    start += dur + 6.;\n    dur = 2.; \n    r += mix(0., 3000., (scene(t, start, dur)));\n    \n    start += dur + 8.;\n    dur = 1.;\n  \tschottky1.w -= mix(0., schottkyRad, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + dur * .5, dur)));\n\tschottky3.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 2. * dur * .5, dur)));\n\tschottky4.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 3. * dur * .5, dur)));\n    schottky5.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 4. * dur * .5, dur)));\n\tschottky6.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 5. * dur * .5, dur)));\n\tdur = dur * 6. * .5;\n    \n\tstart += dur + 1.;\n    dur = 3.;\n    maxIterations -= int(mix(0., 15., (scene(t, start, dur))));\n    \n    vec3 center = vec3(0, 695, 800);\n    vec3 target = center - vec3(0, 500., 0);\n\n    S1.z += 115. * sin(t) * sin(t);\n    S1d = sphereInvertOnSphere(S1, S2);\n    vec3 eye = vec3(r * sin(t), 500., \n                    r * cos(t) ) + center;\n  \tvec3 sum = vec3(0);\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = vec2(.5);//rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldByDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 541], [543, 543, 591, 591, 632], [634, 634, 661, 661, 701], [702, 702, 731, 731, 767], [769, 769, 800, 800, 907], [909, 909, 937, 937, 973], [975, 975, 1006, 1006, 1351], [1353, 1353, 1517, 1517, 3189], [3191, 3191, 3232, 3232, 3352], [3383, 3383, 3444, 3444, 3994], [4093, 4093, 4245, 4245, 4605], [4656, 4656, 4696, 4696, 4808], [4810, 4810, 4947, 4947, 5786], [5788, 5788, 5980, 5980, 6430], [7043, 7113, 7156, 7156, 9739], [9741, 9741, 9770, 9770, 10075], [10190, 10190, 10293, 10293, 13909], [13932, 13932, 13982, 13982, 15424], [15470, 15470, 15499, 15499, 15676], [15766, 15766, 15822, 15822, 18070]]}
{"id": "ldByzK", "name": "Sketch_Template", "author": "cexlearning", "description": "Template,copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 0, "viewed": 70, "date": "1492773894", "time_retrieved": "2024-06-20T18:53:02.063114", "image_code": "vec2 sincos(float x) { return vec2(sin(x), cos(x)); }\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 fade(vec2 x) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 fade(vec3 x) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\n\nvec2 phash(vec2 p)\n{\n    p = fract(mat2(1.2989833, 7.8233198, 6.7598192, 3.4857334) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2.0 - 1.0);\n}\n\nvec3 phash(vec3 p)\n{\n    p = fract(mat3(1.2989833, 7.8233198, 2.3562332,\n                   6.7598192, 3.4857334, 8.2837193,\n                   2.9175399, 2.9884245, 5.4987265) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2.0 - 1.0);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float d00 = dot(phash(ip), fp);\n    float d01 = dot(phash(ip + vec2(0, 1)), fp - vec2(0, 1));\n    float d10 = dot(phash(ip + vec2(1, 0)), fp - vec2(1, 0));\n    float d11 = dot(phash(ip + vec2(1, 1)), fp - vec2(1, 1));\n    fp = fade(fp);\n    return mix(mix(d00, d01, fp.y), mix(d10, d11, fp.y), fp.x);\n}\n\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float d000 = dot(phash(ip), fp);\n    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));\n    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));\n    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));\n    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));\n    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));\n    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));\n    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));\n    fp = fade(fp);\n    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),\n               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy * 10.0 / iResolution.y;\n    float c = noise(vec3(p, iTime)) + 0.5;\n    vec3 rgb = vec3(c);\n    fragColor = vec4(rgb, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldByzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 22, 22, 53], [55, 55, 76, 76, 146], [148, 148, 167, 167, 219], [220, 220, 239, 239, 291], [293, 293, 313, 313, 499], [501, 501, 521, 521, 800], [802, 802, 823, 823, 1178], [1180, 1180, 1201, 1201, 1941], [1944, 1944, 2001, 2001, 2147]]}
{"id": "ldjczD", "name": "bp Mancha", "author": "blackpolygon", "description": "A poor implementation of a fractal :D", "tags": ["fractal", "noise", "glitch"], "likes": 6, "viewed": 136, "date": "1491260958", "time_retrieved": "2024-06-20T18:53:02.063114", "image_code": "// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p) {\n\tfloat strength = 7. + .03 * log(1.240 + fract(sin(iTime) * 4374.158));\n\tfloat accum = 0.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 32; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-0.435,-0.770,-0.728);\n\t\tfloat w = exp(-float(i) / 8.952);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.420));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw / 0.900 - .8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y) + vec2(0.5);\n\tvec3 p = vec3(st,2.240) + vec3(-0.50,-0.50,sin(iTime/5.));      \n    vec3 fc1 = vec3(mix(vec3(0.292,0.099,0.560), vec3(0.589,0.595,0.995), st.y));\n    vec3 c1 = vec3(field(p));\n    \n    bool box = (st.x < 0.1 || st.x > 0.9 || st.y < 0.1 || st.y > 0.9) ? true : false;\n    \n    vec3 finalColor = box ? \n        vec3(mix(vec3(0.351,0.028,0.420), vec3(0.799,0.830,0.607), st.y - 0.2*sin(iTime)))\n        :  mix(c1, fc1, length(c1) > 0.6 ? 1.0 : 0.252);\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjczD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 100, 124, 124, 529], [531, 531, 588, 588, 1175]]}
{"id": "ldjyWw", "name": "voronoi rain splashes b", "author": "ollj", "description": "simpler fork of\nhttps://www.shadertoy.com/view/4ldSRj\n\n(incorrectly) raymarched version in :\nhttps://www.shadertoy.com/view/ldjyWw", "tags": ["voronoi", "ripples", "water", "worley", "raindrops", "vorley"], "likes": 16, "viewed": 1692, "date": "1492447364", "time_retrieved": "2024-06-20T18:53:03.026781", "image_code": "/*this is a fork of https://www.shadertoy.com/view/4ldSRj\n\ncleaned up, \ncore almost identical,\ncommented-out environmental reflection mapping.\n*/\n\n//set camera\n#define camPos    vec3(0,4,-4)\n#define camTarget vec3(0)\n#define upDir     vec3(0,1,0)\n\n\n#define HASHSCALE3 vec3(.1031,.1030,.0973)\n#define HASHSCALE1 .1031\n//hashes from https://www.shadertoy.com/view/4djSRW\n/*\nfloat hash11(float p){vec3 p3=fract(vec3(p)*HASHSCALE1);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z);}\nvec2 hash22(vec2 p){vec3 p3=fract(vec3(p.xyx)*HASHSCALE3);\n p3+=dot(p3,p3.yzx+176.1958);\n return fract((p3.xx+p3.yz)*p3.zy);}\n*/\nvec3 hash33(vec3 p3){p3=fract(p3*HASHSCALE3);\n p3+=dot(p3,p3.yxz+19.19);\n return fract((p3.xxy + p3.yxx)*p3.zyx);}\n#define vorRainSpeed  .8\n#define vorRainScale 1.0\n//worley rain subroutine\nfloat bias(float s,float b){return s/((((1./b)-2.)*(1.-s))+1.);}\n//worley rain\nvec3 vorRain(vec3 p,float r){\n vec3 vw,xy,xz,s1,s2,xx;\n vec3 yz=vec3(0),bz=vec3(0),az=vec3(0),xw=vec3(0);\n p=p.xzy;p/=vorRainScale;\n vec3 uv2=p,p2=p;\n p=vec3(floor(p)); \n float t=iTime*vorRainSpeed;\n //vec2 rand = vw/vec2(iterations);\n vec2 yx=vec2(0);\n for(int j=-1;j<=1;j++)\n for(int k=-1;k<=1;k++){\n  vec3 offset=vec3(float(j),float(k),0.);\n  //hashed for grid\n  s1.xz=hash33(p+offset.xyz+127.43+r).xz;\n  //hashed for timer for switching positions of raindrop\n  s2.xz=floor(s1.xx + t);\n  //add timer to random value so that everytime a ripple fades, a new drop appears\n  xz.xz=hash33(p+offset.xyz+(s2)+r).xz;\n  xx=hash33(p+offset.xyz+(s2-1.));\n  s1=mod(s1+t,1.);\n  //p2=(p2-p2)+vec3(s1.x,0.0,s1.y);\n  p2=mod(p2,1.0);\n  float op=1.-s1.x;//opacity\n  op=bias(op,.21);//optional smooth blending\n  //change the profile of the timer\n  s1.x=bias(s1.x,.62);//optional harder fadeout\n  float size=mix(4.,1.,s1.x);//ripple.expansion over time\n  //move ripple formation from the center as it grows\n  float size2=mix(.005,2.0,s1.x);\n  // make the voronoi 'balls'\n  xy.xz=vec2(length((p.xy+xz.xz)-(uv2.xy-offset.xy))*size);\n  //xy.xz *= (1.0/9.0);\n  xx=vec3(length((p2)+xz)-(uv2-offset)*1.30);\n  //xx=1.-xx;//optional?\n  xy.x=1.-xy.x;//mandatory!\n  xy.x*=size2;//almost optional viscosity\n  #define ripp if(xy.x>.5)xy.x=mix(1.,0.,xy.x);xy.x=mix(0.,2.,xy.x) \n  ripp;ripp;\n  xy.x=smoothstep(.0,1.,xy.x);\n  xy*=op;// fade ripple over time\n  yz =1.-((1.-yz)*(1.-xy));\n  //ops += mix(0.0,xy.x,op.x);\n  //yz = yz.xxx;\n  //yz = max(yz,xy);\n  //yz += p;\n  //xw = max(xx,xw);\n }return vec3(yz*.1);}\n\n//less ripples is really prettier than more ripples.\n#define iterRippleCount 2.\n//only problem is that many drops hit at the very same time, so 2 is reasonable minimum.\n//returns height  of water ripples at [p]\nfloat dfRipples(vec3 p){\n float pl=(p.y+1.);\n vec3 r=vec3(0);\n for(float i=0.;i<iterRippleCount;i++){\n  r+=vorRain(p,i+1.);\n }return pl-r.x;}\n\n//return direction of ray, set by [p]PositionOnScreen and camera data.\n//[o]canPos [t]camTarget [u]upDirection (sets angle)\nvec3 CamCross(vec2 p,vec3 o,vec3 t,vec3 u){vec3\n d=normalize(t-o),r=normalize(cross(u,d)),\n Up=p.y*cross(d,r);r*=p.x*iResolution.x/iResolution.y;\nreturn normalize(((o+d+r+Up)*.86)-(camPos));}\n//shit cam uses too many cross() and normalize()\n\nvoid mainImage( out vec4 Out, in vec2 In){\n vec2 u=In.xy / iResolution.xy;\n u=-1.+2.*u;\n float midPoint = u.x + .5;\n vec2 po;\n float mixer1=mix(-4.,4. ,.5+.5*sin(iTime*.024));\n float mixer2=mix(-4.,4. ,.5+.5*cos(iTime*.024));\n float mixer3=mix(-1.,1.6,.5+.5*cos(iTime*.14));\n float mixer4=mix( 1.,.01,.5+.5*cos(iTime*.4));\n float move=iTime*1.5;\n\n // props to all this vector math from a reddit tutorial: \n // https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n\n vec3 rayDir=CamCross(u,camPos,camTarget,upDir);\n   \n // help from Andy Whittock - a non-ray-marched version;\n vec3 plane1=vec3(0,-.01,0);\n float d=-dot(camPos,plane1)/dot(rayDir,plane1);\n float fog=smoothstep(0.,1.,clamp(d/20.,0.,1.));\n vec3 hitPoint=(camPos+(d*rayDir));  \n hitPoint+=.2;\n //texturing\n\n #define EPSILON .06\n float std=dfRipples(hitPoint);\n vec2 eps=vec2(EPSILON,0.);\n float v1=dfRipples(hitPoint+eps.xyy);\n float v2=dfRipples(hitPoint+eps.yxy);\n float v3=dfRipples(hitPoint+eps.yyx);\n vec3 n=vec3(v1,v2,v3)-std; \n n=normalize(n);\n //n=normalize(der+plane1);//cheesy way to get something like a normal\n \n /* //reflecting to a sphere-map\n //vec3 ref2=reflect(rayDir,normal);\n //vec3 refr=normal;//texture(iChannel0,ref2).xyz;\n //vec3 refl=normal;//texture(iChannel0,-ref2).xyz;\n //vec3 L=normalize(vec3(17.5,12.5,12.5));\n //float LDist=length(L-pos);\n //float atten=min(2.0, 1.0/(LDist/4.50));//atten=1.0;\n //vec3 diffuse=vec3(.50,.5,.5);\n //float light=max(.0,dot(normalize(L), normal2));  \n //vec3 ref=-reflect(rayDir,normal);\n */\n    \n vec3 col=vec3(0);\n /*\n float fresnel=1.+(dot(normal,rayDir))*.5;\n fresnel=bias(fresnel,.35);\n fresnel=pow(fresnel,2.4);\n refl=mix(vec3(0.0),refl,fresnel);\n col=mix(refl,refr,.0);//col = mix(refl,refr,fresnel);\n */\n \n col=n;\n //col=der*.5+.5;\n //vec3 fogColor=vec3(0.3,.6,1.);\n //col=mix(refl,fogColor,fog);\n \n //col.y*=.4;\n //col.y=0.;\n \n col=col.zxy;//swivel for \"blue\" flat water.\n col.xy*=.5;\n    \n /*\n hitPoint=fract(hitPoint);\n hitPoint=vec3(length(hitPoint));\n col=mix(col,hitPoint,.2);\n */ \n    \n //col=mix(col,vec3(log(std)),.1);\n    \n //col=vec3(fract(std*100.));\n //col=sqrt(col);   \n \n Out=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjyWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[317, 619, 640, 640, 733], [784, 809, 837, 837, 873], [874, 888, 917, 917, 2467], [2549, 2680, 2704, 2704, 2821], [2823, 2947, 2990, 2990, 3138], [3139, 3189, 3231, 3231, 5369]]}
{"id": "ldjyz1", "name": "[ #10 ] - Pi road", "author": "Yrai", "description": "Raw experiment with printing and tracking point values (could be useful for debugging / observation).\nPrint functions will be upgraded / refactored later.", "tags": ["2d", "math", "text", "texture", "print", "atlas"], "likes": 13, "viewed": 671, "date": "1491375417", "time_retrieved": "2024-06-20T18:53:03.026781", "image_code": "#define res_            iResolution\n#define t               iTime\n#define pi_             3.14159265\n\n\nfloat pchar(vec2 p, int C);\nfloat pfnum(vec2 p, float x);\nfloat pinum(vec2 p, float x);\nfloat ppoint(vec2 p, vec2 n);\n\nfloat d_line(vec2 p, vec2 a, vec2 b);\nvec2  domain(vec2 uv, float s);\n\nvoid mainImage(out vec4 o, vec2 f) {\n\tvec2 p = domain(f, 2.);\n    vec2 sp = p;\n    \n    vec2 rpath = vec2(cos(t), sin(t));\n    vec2 gpath = vec2(t, sin(t));\n    vec2 prp = p - rpath;\n\tp.x += t;\n    rpath += vec2(t, 0.);\n    \n    vec2 pgp = p - gpath;\n    \n    float cr  = smoothstep(.02, .0001, abs(length(p - vec2(t, 0.)) - 1.));\n    float sn  = smoothstep(.02, .0001, abs(sin(p.x) - p.y));\n    float pr  = smoothstep(.06, .01, length(prp));\n    float po1 = smoothstep(.06, .01, length(pgp));\n    \n    vec3 c = vec3(0.);\n    c = mix(c, vec3(1.), cr);\n    c = mix(c, vec3(1.), sn);\n    \n    c = mix(c, vec3(1., 0., 0.), pr);\n    c = mix(c, vec3(1.), ppoint(prp*6.,  rpath) );\n    c = mix(c, vec3(0., 1., 0.), po1);\n    c = mix(c, vec3(1.), ppoint(pgp*6., gpath));\n\n    float ln  = smoothstep(.01, .001, d_line(p, rpath, gpath));\n    c = mix(c, vec3(1.), ln);\n    \n    float axis = max(smoothstep(.02, .0001, abs(p.x)), smoothstep(.02, .0001, abs(p.y)));\n    float as = max(smoothstep(.01, .001, abs(p.y - 1.02)), smoothstep(.01, .001, abs(p.y + 1.02)));\n    c = mix(c, vec3(.3), axis);\n    c = mix(c, vec3(.1), as);\n    \n    float i = floor(p.x / pi_);\n    \n    c = mix(\n        c, vec3(1., 0., 0.),\n        max(\n            pchar(4.9*(p-vec2(pi_*i+.2, 0.)), 137),\n            pinum(4.9*(p-vec2(pi_*i+.1, 0.)), i)\n        )\n    );\n    \n    \n    o = vec4(c, 1.);\n}\n\nfloat pinum(vec2 p, float x) {\n    bool neg = false;\n    if(x < 0.) {\n    \tneg = true;\n        x *= -1.;\n    }\n    \n    int x_ = int(floor(x));\n    float nm = 0.;\n    if(neg)\n        nm = pchar(p+vec2(.3,0.), 45);\n    \n    for(int i = 0; i < 10; i++) {\n    \tint n = int(floor(mod(float(x_), 10.)));\n        nm = max(nm, pchar(p + float(i)*vec2(.4, 0.), 48+n));\n        x_ /= 10;\n        if(x_ == 0)\n            break;\n    }\n    \n    return nm;\n}\n\nfloat pfnum(vec2 p, float x) {\n   \t// +/-dn...d1d0d,d_0d_1...d_n\n    float xo = x;\n    bool neg = false;\n    if(x < 0.) { neg = true; x *= -1.; }\n    \n\tint d = int(abs(floor(x)));\n    int d0 = 0;\n    \n    int d_0 = int( floor(abs(fract(x)) * 10.) );\n\tint d_1 = int( floor(abs(fract(x)) * 100.) );\n    d_1 = int( d_1 - d_0*10);\n    \n    float nm = pinum(p, xo);\n    nm = max(nm, pchar(p - vec2(.3, 0.), 46));\n    nm = max(nm, pchar(p - vec2(.6, 0.), 48 + d_0));\n    nm = max(nm, pchar(p - vec2(1., 0.), 48 + d_1));\n\t\n    return nm;\n}\n\nvec2 domain(vec2 uv, float s) {\n    return (2. * uv.xy - res_.xy) / res_.y * s;\n}\n\nfloat pchar(vec2 p, int C) {\n  if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return 0.;\n   \n  return textureGrad(\n      iChannel0, p/16. + fract(vec2(C, 15-C/16) / 16.), \n      dFdx(p/16.),dFdy(p/16.)\n  ).r;\n}\n\nfloat ppoint(vec2 p, vec2 n) {\n\tfloat pn = max(pchar(p + vec2(1.2, 0.), 40), pfnum(p, n.x));\n    pn = max(pn, pchar(p - vec2(1.3, 0.), 44));\n    pn = max(pn, pfnum(p - vec2(1.9, 0.), n.y));\n    pn = max(pn, pchar(p - vec2(3.3, 0.), 41));\n    return pn;\n}\n\nfloat d_line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.7;\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjyz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[293, 293, 329, 329, 1656], [1658, 1658, 1688, 1688, 2103], [2105, 2105, 2135, 2169, 2637], [2639, 2639, 2670, 2670, 2720], [2722, 2722, 2750, 2750, 2925], [2927, 2927, 2957, 2957, 3181], [3183, 3183, 3221, 3221, 3347]]}
{"id": "ldjyz3", "name": "Flower in pink", "author": "liamegan", "description": "Learning GLSL, drawing a number of circles rotated around a centrepoint.", "tags": ["2d", "circle", "learning"], "likes": 3, "viewed": 130, "date": "1493147734", "time_retrieved": "2024-06-20T18:53:03.353775", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\n\nvec4 circle(in vec2 position, in vec2 uv, float size, vec3 color) {\n    \n    float dist = distance(position, uv); // The distance between the pixel and the circle position\n    dist = fract(dist * size * 2.0);\n    \n    \n    vec4 circle = vec4(0.0); // Creating a \"full\" color for the circle\n//    circle.r = circle.g = circle.b = smoothstep(size + 0.005, size, dist); // Setting up the inverted circle rgb color\n    circle.r = circle.g = circle.b = dist; // Setting up the inverted circle rgb color\n    \n    circle.rgb += color; // Additive colour because our circle is inverted\n\n    return circle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolutionalMin = min(iResolution.x, iResolution.y);\n    vec2 squaredRez = vec2(resolutionalMin);\n\tvec2 uv = fragCoord.xy / squaredRez;\n    \n    float ratio = iResolution.x / iResolution.y;\n    vec2 centre = vec2(0.5) * ratio;\n    \n    if(iResolution.x > iResolution.y) {\n       centre.y = 0.5;\n    } else {\n       centre.x = 0.5;\n    }\n    \n    float size = (sin(iTime * 1.0) * 0.3) + 2.1;\n   \n    float handDist = 0.2;\n    float instances = 5.0;\n    float increment = instances;\n    float rotationalIncrement = TAU / instances;\n    vec4 composite = vec4(0.0);\n    \n    while( increment > 0.0) {\n        float rotationalPosition = increment * rotationalIncrement + iTime / 15.0;\n        vec2 circlePos = centre + vec2(sin(rotationalPosition), cos(rotationalPosition)) * handDist;\n        vec4 circleColor = circle(circlePos, uv, size, vec3(1.0, 0.5, 0.5));\n        composite += circleColor;\n        increment -= 1.0;\n    }\n    \n    composite /= instances;\n    \n    fragColor = composite;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldjyz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[66, 66, 133, 133, 665], [668, 668, 725, 725, 1726]]}
{"id": "ldScRm", "name": "Basic clockwise square example", "author": "barakooda", "description": "Basic clockwise square example", "tags": ["basicclockwisesquareexample"], "likes": 1, "viewed": 454, "date": "1491332995", "time_retrieved": "2024-06-20T18:53:03.614703", "image_code": "//Barakooda 4/4/2017\n//white rectangle\n\nfloat whiteRectangle(vec2 uv)\n\t{\n        // creating buttom left rectangle point\n        vec2 bl = step(vec2(-.1),uv);\n\n\n        // creating top right rectangle point\n        vec2 tr = step(vec2(-.1),-uv);\n\n        // multiplie step layers\n        return tr.x * tr.y * bl.x * bl.y ;\n\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //noramelize \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //window aspect\n    float aspect = iResolution.y/iResolution.x;\n    \n    //axis change from 0 - 1.0 to -1.0 - 1.0\n\tuv = uv * 2. - 1.;\n    \n   \n    \n    // createing translation data.\n    vec2 translate = vec2(-cos(iTime),sin(iTime));\n   \n    //Strecth y axis\n    uv.y*=aspect;\n    \n    //adding translation to uv\n    uv += translate*0.45;   \n    \n    \n\n\t//creating square    \n    float color = whiteRectangle(uv);\n   \n    \n    //final\n\tfragColor = vec4(vec3(color),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldScRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 40, 72, 120, 325], [328, 328, 385, 408, 931]]}
{"id": "ldScWG", "name": "Kapotje", "author": "Tenderz", "description": "test", "tags": ["stolenshaders"], "likes": 2, "viewed": 101, "date": "1493528928", "time_retrieved": "2024-06-20T18:53:03.620865", "image_code": "//iChannel0\n//iTime\n\nfloat hue_to_rgb(float m1, float m2, float h)\n{\n    if (h < 0.0f) h += 1.0f;\n    if (h > 1.0f) h -= 1.0f;\n    if (h * 6.0 < 1.0) return m1 + (m2 - m1) * h * 6.0f;\n    if (h * 2.0 < 1.0) return m2;\n    if (h * 3.0 < 2.0) return m1 + (m2 - m1) * (2.0f / 3.0f - h) * 6.0f;\n    return m1;\n}\nvec3 hsl_to_rgb(float h, float s, float l)\n{\n    h = h < 0.0f ? 0.0f : h > 1.0f ? 1.0f : h;\n    s = s < 0.0f ? 0.0f : s > 1.0f ? 1.0f : s;\n    l = l < 0.0f ? 0.0f : l > 1.0f ? 1.0f : l;\n\n    float m2 = (l <= 0.5f) ? (l * (s + 1.0f)) : (l + s - l * s);\n    float m1 = l * 2.0f - m2;\n    float r = hue_to_rgb(m1, m2, h + 1.0f / 3.0f);\n    float g = hue_to_rgb(m1, m2, h);\n    float b = hue_to_rgb(m1, m2, h - 1.0f / 3.0f);\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y += cos(uv.x * 30.0 + iTime*5.0) * 0.025;\n    uv.y -= 0.5;\n    uv.y = abs(uv.y);\n    uv.y += 0.5;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    float gs = (color.r + color.g + color.b) / 3.0;\n\n    float m = mod(gs * 1.0 + iTime*0.1, 0.5);\n    m *= m;\n    fragColor = vec4(hsl_to_rgb(m, 0.75, 0.5), 1);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldScWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 21, 68, 68, 307], [308, 308, 352, 352, 756], [758, 758, 815, 815, 1178]]}
{"id": "ldScWw", "name": "Grain - Post Processing", "author": "juniorxsound", "description": "A tiny and basic grain post processing shader", "tags": ["postprocessing", "webcam", "fragment", "grain"], "likes": 6, "viewed": 1131, "date": "1492292320", "time_retrieved": "2024-06-20T18:53:03.620865", "image_code": "\nfloat grain (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(17.0,180.)))* 2500. + iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Coords\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Produce some noise based on the coords\n    vec3 grainPlate = vec3(grain(uv));\n    \n    //Get the webcam\n    vec4 webcam = texture(iChannel0, uv);\n    \n    //Mix the two signals together\n    vec3 mixer = mix(webcam.rgb, grainPlate, .1);\n\t\n    \n    fragColor = vec4(mixer,1.0); \n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldScWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 24, 24, 93], [95, 95, 152, 165, 497]]}
{"id": "ldSyDG", "name": "Literary Tunnel", "author": "dr2", "description": "Underground books", "tags": ["tunnel", "raymarch", "library", "books"], "likes": 12, "viewed": 494, "date": "1493540786", "time_retrieved": "2024-06-20T18:53:03.633486", "image_code": "// \"Literary Tunnel\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 ltDir;\nfloat dstFar, tCur, wdTun, htTun, segTun, spShf;\nint idObj;\nconst int idWal = 1, idCeil = 2, idFlr = 3, idLmp = 4, idBks = 5, idShlf = 6;\nconst float pi = 3.14159;\n\nfloat TrackPath (float t)\n{\n  return wdTun * (0.6 * sin (0.005 * 2. * pi * t) + 0.3 * cos (0.009 * 2. * pi * t));\n}\n\nfloat TrackPathD (float t)\n{\n  return wdTun * 2. * pi * (0.6 * 0.005 * cos (0.005 * 2. * pi * t) -\n     0.3 * 0.009 * sin (0.009 * 2. * pi * t));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db;\n  dMin = dstFar;\n  p.x -= TrackPath (p.z);\n  q = p;\n  q.y -= htTun;\n  d = wdTun - abs (q.x);\n  if (d < dMin) { dMin = d;  idObj = idWal; }\n  d = q.y + htTun;\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  q.y -= htTun;\n  d = max (wdTun - length (q.xy), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idCeil; }\n  q.z = mod (q.z + segTun, 2. * segTun) - segTun;\n  q.y -= 0.5 * wdTun;\n  d = PrCylDf (q.xzy, 0.1 * wdTun, 0.01 * wdTun);\n  q.y -= 0.25 * wdTun;\n  d = min (d, PrCylDf (q.xzy, 0.005 * wdTun, 0.25 * wdTun));\n  q.y -= 0.25 * wdTun;\n  d = min (d, PrCylDf (q.xzy, 0.05 * wdTun, 0.02 * wdTun));\n  q.y -= - wdTun - htTun;\n  if (d < dMin) { dMin = d;  idObj = idLmp; }\n  q.x = abs (q.x) - wdTun + 0.75;\n  d = length (max (abs (q) - vec3 (0.75, htTun, segTun - 1.1), 0.));\n  if (d < dMin) { dMin = d;  idObj = idBks; }\n  q.x += 0.1;\n  db = length (max (abs (q) - vec3 (0.85, htTun, segTun - 1.), 0.));\n  q.y = mod (q.y, spShf) - 0.5 * spShf;\n  q.yz = abs (q.yz) - vec2 (0.5 * spShf - 0.05, segTun - 1.1);\n  d = max (db, - min (max (q.y, q.z), 0.));\n  if (d < dMin) { dMin = d;  idObj = idShlf; }\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 300; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 5.;\n  f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.2)),\n     Fbm2 (p.xz * vec2 (1., 0.2)), Fbm2 (p.xy * vec2 (1., 0.2))), abs (n));\n  return mix (vec3 (0.9, 0.4, 0.2), vec3 (0.5, 0.3, 0.), f);\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (SQRT3/2.) - q.x + 0.5 * min (q.x - SQRT3 * q.y, 0.));\n}\n\nfloat BrickGrid (vec2 p)\n{\n  vec2 q, iq;\n  q = p * vec2 (2./3., 2.);\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) {\n    q.x += 0.5;\n    iq = floor (q);\n  }\n  q = smoothstep (0.03, 0.05, abs (fract (q + 0.5) - 0.5));\n  return 1. - 0.4 * q.x * q.y;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q, qh;\n  vec2 gb, bt, bs;\n  float dstObj, bh, s, spec, att;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.x -= TrackPath (q.z);\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idWal) {\n      col = vec3 (0.3, 0.4, 1.) * BrickGrid (q.zy);\n    } else if (idObj == idCeil) {\n      q.x = wdTun * atan (q.x, q.y - 2. * htTun);\n      qh = HexGrid (1.5 * q.xz);\n      col = mix (vec3 (0.9, 0.9, 1.), vec3 (0.1, 0.1, 1.), (1. - length (qh.xy)) *\n         (0.3 + 0.7 * smoothstep (0.03, 0.06, qh.z)));\n      spec = 0.05;\n    } else if (idObj == idFlr) {\n      qh = HexGrid (q.zx);\n      col = vec3 (0.8, 0.8, 0.85) * (0.3 + 0.7 * smoothstep (0.03, 0.06, qh.z)) *\n         (1. - 0.1 * Noisefv2 (150. * q.xz));\n      q.z = mod (q.z + segTun, 2. * segTun) - segTun;\n      col *= 1. - 0.3 * smoothstep (0.4, 0.85, length (q.xz) / wdTun);\n      spec = 0.1;\n      s = max (length (qh.xy) - 0.5, 0.);\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 5. * s * s));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n      vn = VaryNf (100. * q, vn, 0.2);\n    } else if (idObj == idShlf) {\n      col = WoodCol (ro, vn);\n    } else if (idObj == idBks) {\n      bs = vec2 (sign (q.x), floor (q.z / (2. * segTun) + 0.5));\n      bt = floor (vec2 (q.yz * vec2 (200., 120.)));\n      q.z = mod (q.z, 2. * segTun);\n      q.z = 50. * (q.z - 1.1) / (2. * segTun - 2.2);\n      gb = floor (vec2 (q.y / spShf, q.z));\n      bh = (0.7 + 0.3 * Fbm2 (gb * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        s = mod (q.z, 1.);\n        col = vec3 (HsvToRgb (vec3 (mod (5. * Fbm2 (gb * vec2 (17., 11.) + bs), 1.), 1.,\n           0.05 + 0.8 * SmoothBump (0.05, 0.95, 0.015, abs (s)))));\n        q.y = q.y / bh - 0.5;\n        if (abs (s - 0.5) < 0.1 && abs (q.y) < 0.2 &&\n           Noisefv2 (gb * vec2 (19., 31.) + mod (bs * 73. + bt, 1000.)) > 0.6) {\n          col *= 0.1;\n        } else {\n          spec = 0.1;\n          vn.xz = Rot2D (vn.xz, (1. - 2. * s) * bs.x);\n        }\n      } else {\n        col = vec3 (0.05);\n        spec = -1.;\n      }\n    } else if (idObj == idLmp) {\n      if (q.y < htTun + wdTun) {\n        col = vec3 (1., 1., 0.7) * 0.5 * (1. - vn.y);\n        spec = -1.;\n      } else col = vec3 (0.6, 0.4, 0.1);\n    }\n    if (spec >= 0.) {\n      att = min (600. / pow (dstObj, 1.5), 1.);\n      col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.) +\n         spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)) * att;\n    }\n  } else col = vec3 (0.02, 0.02, 0.1);\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  wdTun = 8.;\n  htTun = 4.;\n  segTun = 5.;\n  spShf = 0.3333 * htTun;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el + pi * mPtr.y, -0.4 * pi, 0.4 * pi);\n    az = az + 2.5 * pi * mPtr.x;\n  }\n  dstFar = 300.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro.z = mod (8. * tCur, 30000.);\n  ro.x = TrackPath (ro.z);\n  ro.y = htTun + 1.5 * spShf;\n  a = atan (TrackPathD (ro.z));\n  rd.zx = Rot2D (rd.zx, 4. * a);\n  ltDir = vuMat * normalize (vec3 (0., 0.2, -1.));\n  ltDir.zx = Rot2D (ltDir.zx, 4. * a);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldSyDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 539, 566, 566, 654], [656, 656, 684, 684, 803], [805, 805, 827, 827, 1977], [1979, 1979, 2012, 2012, 2188], [2190, 2190, 2211, 2211, 2424], [2426, 2426, 2457, 2457, 2665], [2692, 2692, 2716, 2716, 2946], [2948, 2948, 2972, 2972, 3032], [3034, 3034, 3057, 3057, 3189], [3191, 3191, 3217, 3217, 3450], [3452, 3452, 3487, 3487, 6088], [6090, 6090, 6146, 6146, 7149], [7151, 7151, 7193, 7193, 7244], [7246, 7246, 7303, 7303, 7386], [7388, 7388, 7418, 7418, 7476], [7599, 7599, 7623, 7623, 7670], [7672, 7672, 7697, 7697, 7876], [7878, 7878, 7899, 7899, 8054], [8056, 8056, 8085, 8085, 8313], [8315, 8315, 8354, 8354, 8577], [8579, 8579, 8603, 8603, 8739]]}
{"id": "ls2czy", "name": "Red Tunnel", "author": "slerpy", "description": "A tunnel with a terrible raytracer", "tags": ["3d", "tunnel"], "likes": 4, "viewed": 121, "date": "1492682272", "time_retrieved": "2024-06-20T18:53:03.633486", "image_code": "bool col(vec3 ray)\n{\n    bool s0 = max(abs(ray.x),2.*abs(ray.y)) > .2;\n    bool s1 = length(ray.xz-vec2(0.15*sign(ray.x),round(ray.z*5.)/5.)) < .01;\n    bool s2 = fract(ray.z) < 0.2;\n    return s0 || s1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float d;\n    for(d=.1;d<2.;d+=.0001) {\n        vec3 ray = vec3(uv,1.)*d;\n        ray.x -= (d*d)/4.;\n        ray.z += iTime/8.;\n        if(col(ray))break;\n    }\n    \n\tfragColor = vec4(1.-d/2.);\n    if(fract(d+iTime/8.)<.5)\n    \tfragColor.gb -= vec2(1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2czy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 205], [207, 207, 264, 264, 587]]}
{"id": "ls2yRD", "name": "simple SDF", "author": "Incompetent", "description": "Simple SDF Test", "tags": ["sdf"], "likes": 2, "viewed": 87, "date": "1491246861", "time_retrieved": "2024-06-20T18:53:03.634483", "image_code": "float cubeDistance(vec3 rayPosition, vec3 cubePosition, vec3 cubeSize) {\n    vec3 d = abs(rayPosition - cubePosition) - cubeSize;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sphereDistance(vec3 rayPosition, vec3 spherePosition, float sphereRadius)\n{\n    float d = length(rayPosition - spherePosition) - sphereRadius;\n    return d;\n}\n\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat scene(vec3 rayPosition)\n{\n    float blend = 3.*iMouse.y/iResolution.y;\n\tvec3 spherePosition = vec3(4.*sin(iTime), 2., 0.);\n\tfloat sdf = sphereDistance(rayPosition, spherePosition, 2.5);\n\tsdf = smin(sdf,sphereDistance(rayPosition, vec3(0.,0.,0.), 1.5),blend);\n    sdf = smin(sdf,cubeDistance(rayPosition,vec3(0.,-3.*sin(iTime),0.), vec3(1.,1.,1.)),blend);\n    return sdf;\n}\n\nconst float EPS = 0.01;\nvec3 getNormal( in vec3 p )\n{\n\treturn normalize( vec3(\n\t\tscene(p+vec3(EPS,0.,0.))-scene(p-vec3(EPS,0.,0.)),\n\t\tscene(p+vec3(0.,EPS,0.))-scene(p-vec3(0.,EPS,0.)),\n\t\tscene(p+vec3(0.,0.,EPS))-scene(p-vec3(0.,0.,EPS))\n\t) );\n}\n\nvec3 rayCast(vec3 rayPosition, vec3 rayDirection)\n{    \n    vec3 color = rayDirection*0.5+0.5;\n    \n    for(int i = 0; i < 128; ++i)\n    {\n        float d = scene(rayPosition);\n        rayPosition += d * rayDirection;\n        \n        if(d <= 0.01)\n        {\n            color = getNormal(rayPosition)*0.5+0.5;\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv -= .5;\n    uv.x = aspect * uv.x;    \n    \n    vec3 cameraPosition = vec3(0, 3, -10.0);\n    float angle = iMouse.x*0.01;\n    cameraPosition.xz = vec2(cos(angle),sin(angle));\n    cameraPosition.xz *= 10.;\n    vec3 cameraTarget = vec3(0);\n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraUp = vec3(0,1,0);\n    vec3 cameraRight = normalize( cross(cameraForward, cameraUp));\n    \n    vec3 rayPosition = cameraPosition;\n    vec3 rayDirection = normalize(cameraForward + uv.x * cameraRight + uv.y * cameraUp);\n                                \n    vec3 color = rayCast(rayPosition, rayDirection);\n    \n\tfragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2yRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 72, 72, 197], [199, 199, 280, 280, 363], [365, 365, 406, 406, 495], [498, 498, 529, 529, 876], [902, 902, 931, 931, 1122], [1124, 1124, 1175, 1175, 1489], [1491, 1491, 1548, 1548, 2305]]}
{"id": "ls2yzw", "name": "WIP:Spheres and Cones, rotating ", "author": "vsnchips", "description": "Getting some standard raymarching stuff happening.\n\nTheres a lot of unused code, the start of a tree based ray compositor.\n\nAt the moment im figuring out why the shadow umbras are glitching out at the edges. Any help would be greatly appreciated!", "tags": ["raymarching", "normals", "shadows", "compositing"], "likes": 0, "viewed": 594, "date": "1491429169", "time_retrieved": "2024-06-20T18:53:06.681697", "image_code": "\n#define PI 3.1412\n#define MAXRAYNODES 2\n\n#define REFLECTCLIP 0.05\n#define ALPHACLIP 0.05\n#define SHADN 1024\n#define TREEN 16\n#define N 256\n#define MAXD 200\n\nconst int HALFRAYNODES = (MAXRAYNODES+1 /2);\n\nfloat iFade;\nint iFadeMode;\n//uniform float iTime;\n//uniform vec3 iMouse;\n//uniform vec2 iResolution;\n\nvec3 iCamLook;\nvec3 iCamPos;\nvec3 iWorldRotate;\nvec3 iSun;\n\nfloat iSphereRad = 1.;\n\nuniform vec3 hsvin;\n\nuniform float rad;\n\n#define iMarchFactor 0.4;\nfloat iTMFactor=0.2;\nfloat iResultDMult=0.8;\n\nfloat radius = 0.34;\nfloat iCubeScale;\nfloat iSphereScale = 0.2;\n\nuniform float iShapeCF;\nuniform float iShapeFade;\n\nfloat iModX = 1.;\nfloat iModY = 1.;\nfloat iModZ = 1.;\n\nfloat iDotSlide = 1.;\n\nuniform float iAperture;\n\n//////////////////////////\n//STRUCTS\n\n//////////////////////////\n\nstruct traceData{\n    vec3 r;\n    float l;\n    float t;\n    vec3 p;\n    vec3 myNormal;\n    int matId;\n    int surfId;\n    float alpha;\n    float reflectance;\n    vec3 radiance;\n\n} dtraceOut;\n\nstruct ray{\n    vec3 o;\n    vec3 r;\n    float a;\n} baseRay;\n\nstruct rayNode{\n    traceData myData;\n    int leftP;\n    int rightP; \n    float aperture;\n    vec3 result;\n    vec3 diffresult;\n    bool done;\n}rootNode;\n\nstruct light{\n    vec3 tint;\n    vec3 p;    \n} theSun;\n\nstruct material{\n    vec3 radiance;\n    vec3 diffuse;\n    vec3 refMult;\n    vec3 alphaMult;\n    float alpha;\n    float reflectance;\n}somethingness;\n\n\n                                                                    //fragment globals\n\n traceData dSphere;\n traceData dCubish;\n traceData dTexMarch;\n traceData dCone;\n\n vec3 wP;\n\n rayNode[MAXRAYNODES] rayTree;\n\n int rtQCursor;\n int rtCCursor;\n int rtCount;\n\nvec4 texCol0;\nvec2 fragCoord;\nvec2 vUv;\n\nmaterial mats[32];\n\nfloat scope=0.8;\nfloat pulsespeed = 0.2;\n\nvec3 origincam = vec3 (0.1,1.5,2.2);\n\nfloat camrotx = 0.;\nfloat camroty = 0.;\nfloat camrotz = 0.;\n\n//\n////\n// ADAPT\n////\n//\n\nvoid adapt(){\n    \n  //  fragCoord = vUV.st;\n  //  vUv = vUV.st;    \n   // texCol0 = texture2D(sTD2DInputs[0],fragCoord);\n}\n\n\n//\n///\n/////\n\n// VARIOUS MATH\n\n/////\n///\n//\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n//\n////\n////////\n////////////\n\n// COLOR, ANIMATION, UNIFORM INTERPRETATION\n\n////////////\n////////\n////\n//\n\n\n\n\nfloat deg60 = 1./6.;\n\n\nvec3 HSVfromRGB(vec3 incol){\n            \n            \n                float value = max(incol.r,max(incol.g,incol.b));\n                float grey = min(incol.r,min(incol.g,incol.b));\n                float sat = value - grey;           \n                float hue;\n                \n                \n                if (value == incol.r){\n                    if (grey == incol.b){\n                        hue = deg60*(incol.g-grey)/(value-grey);// sector 1     //orange reds\n                    } else {                                                \n                    hue = 1.-deg60*(incol.b-grey)/(value-grey);                 //magentas                                                                                  \n                    }   \n                }                       \n                if (value == incol.g){\n                    if (grey == incol.b){\n                        hue = 2.*deg60 - deg60*(incol.r-grey)/(value-grey);// sector 1      //yellow greens\n                    } else {\n                    hue = 2.*deg60+deg60*(incol.b-grey)/(value-grey);                   //turquoise, cyans\n                    }\n                }   \n                if (value == incol.b){\n                    if (grey == incol.r){\n                        hue = 4.*deg60 - deg60*(incol.g-grey)/(value-grey);// sector 1      //cyan blues\n                    } else {\n                    hue = 4.*deg60+deg60*(incol.r-grey)/(value-grey);                   //violet blues\n                    }\n                }   \n            \n            return vec3(hue,sat,value);\n\n        }\n\n\n            vec3 RGBfromHSV(vec3 hsv){\n            \n                float chroma, greylevel, X;\n                chroma = hsv.y*hsv.z;         // chroma and greylevel, two different relationships between saturation and value.\n                greylevel = hsv.z - hsv.y;  \n                \n                \n                float tH;           \n                \n                tH = hsv.x/deg60;\n                X = (1.-abs(mod(tH,2.)-1.));   // x lerps between greylevel and V\n                \n                vec3 tCol;\n                \n                \n                int sector = int(floor(tH));\n                /*/switch (sector){\n                //case 0: tCol = vec3(1.,X,0.); break;\n                //case 1: tCol = vec3(X,1.,0.); break;\n                case 2: tCol = vec3(0.1.,X); break; \n                case 3: tCol = vec3(0.,X,1.); break;\n                case 4: tCol = vec3(X,0.,1.); break;\n                case 5: tCol = vec3(1.,0.,X); break;*/\n                \n                if (sector == 0){tCol = vec3(1.,X,0.); }\n                else if (sector == 1){tCol = vec3(X,1.,0.); }\n                else if (sector == 2){tCol = vec3(0.,1.,X);}\n                else if (sector == 3){tCol = vec3(0.,X,1.);}\n                else if (sector == 4){tCol = vec3(X,0.,1.); }\n                else if (sector == 5){tCol = vec3(1.,0.,X);; }\n                \n                return chroma*tCol+greylevel;   // final color.\n                \n            }\n\n\n//\n////\n////////\n////////////\n\n//RayMarching Geometry\n\n////////////\n////////\n////\n//\n\n\n///////////////////// MAKE SOME SHAPES /////////////////////////////\n\n        ////    //   //   //  ||////     //////   /////////// \n     //    //  //   //  // || ||   //   //       //        //\n    //        //   //  //  || ||  //   //        //\n   ///////// ///////  /////|| ||///   ////////    ///////// \n   //     // //   //  //    || ||     //           /      //   \n    ////// //   //  //     || ||    //////////     ///////\n\n\n//////////////////////////////\n//      primitives           //\n//////////////////////////////\n\n\n//cubeything\n\ntraceData cubish (vec3 p, float size, float pw)\n{\n\n    traceData tout;\n    vec3 ftbish= vec3(pow(fract(p.x)*2.-1.,pw),pow(fract(p.y)*2.-1.,pw),pow(fract(p.z)*2.-1.,pw));\n    vec3 bish= vec3(pow(p.x,pw),pow(p.y,pw),pow(p.z,pw));\n    \n    tout.p = (ftbish);\n    tout.l = abs(length (tout.p) - size);\n    return tout;\n}\n\n\n\n\n\n                                                //sphere\ntraceData sphere (vec3 p,float rad){\n\ntraceData tout;\n\n//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - iSphereRad;\nfloat lod1 = 0.;\nif (lod1 > 0.1 ){  tout.l = lod1;}\nelse{\ntout.p = fract((2.*(p+.5))-1.)  -.5;\ntout.l = (length(tout.p) - rad)*0.8;\n}\nreturn tout;\n\n}\n\n\n\n                                        //sphere with modulus iteration\n\ntraceData modsphere (vec3 p, float rad){\n\ntraceData tout;\n\ntout.p = vec3(   mod(((2.*(p.x+.5))-1.),iModX)-.5*iModX ,  mod(((2.*(p.z+.5))-1.),iModY)-.5*iModY ,      mod(((2.*(p.y+.5))-1.),iModZ)-.5*iModZ);\ntout.l = length(tout.p) - rad;\nreturn tout;\n\n}\n\n\n// cone\nfloat ConeD(vec3 p, float h, float r){          // cone dist\n    \n//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - 2    ;\nfloat lod1 =0.;      \nif (lod1> 0.1 )  return lod1;\n    \n    mat2 rotation = rotate2d(ceil(p.y)*0.6);\n    //mat2 rotation = rotate2d(0.);\n\n    p=(fract(p));\n\tp-=0.5;\n\n    p.yz *= rotation;\n    \n    float pl = length(p.xy)/r;\n\n    return max((pl+(p.z)-0.5), -p.z);\n    }\n\n\n//////////////////////////////\n//      Geometric Glue      //\n//////////////////////////////\n\nvec3 lerpDotSpace(vec3 p, float t){\n\n    float dotp = dot(p,p);\n\n    p= vec3(mix(p.x,p.x/dotp,t),mix(p.y,p.y/dotp,t),mix(p.z,p.z/dotp,t));\n\n    p=mix(p,p/dotp,t);\n\n    return p;\n\n}\n\n// polynomial smooth \n\nfloat pSmoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//\n///\n/////\n////////////////////////////////                                                // SCENE LAYOUT HAPPENS HERE\n//      map         Scene     ///////////////////////////        \n////////////////////////////////\n/////\n///\n//\n\n\n//traceData map(vec3 point){\n\nfloat map(vec3 point){\n\n\nwP = point + iCamPos;\n    \n        //shape finding functions:\n        dSphere = sphere(point*iSphereScale, 0.3);\n        dCone.l = ConeD(point,0.8,0.4);\n       return min(dSphere.l,dCone.l);\n       //return min(dSphere.l,point.z+20);\n}\n\ntraceData finalmap(vec3 point){\n    \n        //shape finding functions:\n        dSphere = sphere(point*iSphereScale, rad);\n\n        dCone.l = ConeD(point,0.4,0.2);\n\n        //dTexMarch.p = texture2D(sTD2DInputs[0],fract(point.xy*0.1)).rgb;\n        //dTexMarch.l=length(dTexMarch.p);\n\n        traceData fout;\n        //fout.l= pSmoothMin(dCone.l,dSphere.l,0.5);\n        fout.l= dSphere.l;\n        \n\n        float least = min(dCone.l,dSphere.l);\n       // return fout;\n       //return pSmoothMin(dCone.l,dSphere.l,0.1);\n       return fout;\n}\n\n\n////\n////////\n////////////\n\n// Normal finder\n\n////////////\n////////\n////\n\nvec3 getNorm( in vec3 pos )\n{\n    vec3 eps = vec3( 0.00001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n////////////////////////////////\n//      trace functions        //\n////////////////////////////////\n\n\n traceData trace (vec3 o, vec3 r, float rad , int tN){ \n\n    traceData dtraceOut;\n\n    vec3 newpoint;\n    float t = 0.05;\n\n    for (int i = 0; i < tN; ++i) {                  // <-- trace iterator\n\n         newpoint = o + r * t;\n        //o = lerpDotSpace(o,iDotSlide);\n\n        if (t>float(MAXD)) break;\n        dtraceOut.l = map(newpoint);        \n        if (dtraceOut.l < 0.01 ) break;     \n\n        t += dtraceOut.l * iMarchFactor;\n    }\n\n dtraceOut.t = t;\n dtraceOut.surfId=1;\n dtraceOut.matId=dtraceOut.surfId;\n dtraceOut.myNormal = getNorm(newpoint);\ndtraceOut.matId = 0;\ndtraceOut.p = newpoint;\n\nreturn dtraceOut;\n}\n\n\n///////////////////////////////////////\n\n float shadeTrace (vec3 o, vec3 r, int pen, float maxT){ \n\n    float exp = 1.;\n\n    vec3 newpoint;\n    float t = 0.5;\n\n    float d;\n\n    int i;\n    for (t=0.05; t < maxT; i++ ) {                  // <-- trace iterator\n\n        //break;\n         newpoint = o + r * t;\n        //o = lerpDotSpace(o,iDotSlide);\n\n        //if (t>MAXD) break;\n        d = map(newpoint);        \n        if (d < 0.00001 ||  i >= SHADN){exp = 0.; break; }\n        \n        //t += d * 0.2 *iMarchFactor;\n        t += d;\n\n        exp = min(exp,d*(float(pen))/t);\n    }\nreturn exp;\n}\n\n\n///////////////////////////////////////\n\n\n\n\n\n//rootNode = rayTree[0];\n\nint i = 0;\nfloat thisalpha = 1.;\nfloat[MAXRAYNODES] alphaStack;\nint aStackH = 0;\n\n\nvoid shootRay(){\n    //while (!rayTree[0].done){   // mite break it\n    for (int bark = 0; bark < 128; bark ++){                                       // THIS is a RAY TREE\n                                                                // implemented iteratively with an array as a stack.        \n        if (i<HALFRAYNODES){\n\n            bool leftDone = (rayTree[i*2].done || thisalpha*mats[rayTree[i].myData.matId].alpha>ALPHACLIP);             // Do we need to blend?\n            bool rightDone = (rayTree[i*2+1].done || thisalpha*mats[rayTree[i].myData.matId].reflectance>REFLECTCLIP);          // Do we need to reflect?\n\n            if (leftDone && rightDone){                                                             // Ray Color Compositing\n            \n                rayTree[i].diffresult = vec3(0.3);   // TODO: Calculate Diffusion    //lighting calcs go here\n                traceData lightresult = trace(theSun.p,theSun.p-rayTree[i].myData.p,10.,SHADN);\n                rayTree[i].diffresult *= (1.-lightresult.l*80.3);\n\n                rayTree[i].result = (mix(rayTree[i*2].result,rayTree[i].diffresult*mats[rayTree[i].myData.matId].alphaMult,mats[rayTree[i].myData.matId].alpha) +        //Diffusion Blocks the background\n               \n                mats[rayTree[i].myData.matId].radiance +                                                                //Radiance is purely additive\n                rayTree[i*2+1].result*mats[rayTree[i].myData.matId].refMult);                                                            //As is reflectance.\n\n                 //rayTree[i].result = vec3(1,0.5,1);\n\n                rayTree[i].done = true;\n\n                i /=2;\n                //i =0;\n                thisalpha = alphaStack[i];      // Go to Parent // i *think * this'll work.\n            }\n\n        if (!leftDone){\n\n            while (  (i<HALFRAYNODES && thisalpha*rayTree[i].myData.alpha<ALPHACLIP)  ||     // alpha OR relection\n             (i<HALFRAYNODES && thisalpha*rayTree[i].myData.reflectance<REFLECTCLIP)       //  if this node isnt a heap yet\n\n            ){\n                if (i<HALFRAYNODES && !rayTree[i*2].done && thisalpha*rayTree[i].myData.alpha<ALPHACLIP){   // if left isnt a heap yet, \n                \n                    rayTree[i*2].myData = trace(rayTree[i].myData.p+rayTree[i].myData.r*0.0001,rayTree[i].myData.r,1.0,TREEN);    // march that same ray\n\n                    alphaStack[i] = thisalpha;                                              // save the alpha\n                    thisalpha *= mats[rayTree[i].myData.matId].alpha;                                             //multiply it for the next node\n                i = i*2;                                                                    // step over to the new point\n                continue;                                                                   // Check next Alpha\n                      }\n\n                if (i<HALFRAYNODES && !rayTree[i*2+1].done && thisalpha*rayTree[i].myData.reflectance<REFLECTCLIP){ // if left is a heap but right isnt a heap yet, \n                \n                    rayTree[i].myData.myNormal = getNorm(rayTree[i].myData.p);                  //get the Normal j.i.t                  \n                    vec3 reRay = reflect(rayTree[i].myData.r,rayTree[i].myData.myNormal);               // now we get the reflection\n                    rayTree[i*2+1].myData = trace(rayTree[i].myData.p+reRay*0.1,reRay,10.0,TREEN);    // march that reflection ray\n\n                    alphaStack[i] = thisalpha;                                              // save the alpha\n                    thisalpha *= mats[rayTree[i].myData.matId].alpha;                                             //multiply it for the next node\n                i = i*2;                                                                    // step over to the new point\n\n                      }      \n                }\n\n            //  if ()\n        }\n\n\n}\nelse {\nrayTree[i].done = true;\nrayTree[i].diffresult = vec3(0.8,0.3,0.01);\nrayTree[i].result = rayTree[i].diffresult + mats[rayTree[i].myData.matId].radiance; //radiate+expose\n\n}\n\nif (rayTree[0].done) break;\n\n}\n}\n\n\n/*void queueRay(ray newRay){\n    rayTree[rtQCursor] = newRay;\n    rtQCursor = (rtQCursor > 30) ? 0 : rtQCursor +1;\n\n}\n\ntraceData catchRay(ray newRay){\n    traceData notrace;\n    return notrace;\n}\n*/\n\n\n\n\n////\n////////\n////////////\n\n// Lighting\n\n////////////\n////////\n////\n\n\n\n//////// DEFINE MATERIALS ////////////                      //\\    /||\n                                                            // \\  / ||\nvoid defMats(){                                             //  \\/  ||         \n    material clay;\n    somethingness.radiance = vec3(0,0.0,0.5);\n    somethingness.diffuse = vec3(0.8,0.5,0.2);\n    somethingness.refMult = vec3(1,1,1);\n    somethingness.alphaMult = vec3(1,1,1);\n    somethingness.alpha = 0.9;\n    somethingness.reflectance = 0.3;\n    clay.radiance = vec3(0,0.0,0.8);\n    clay.diffuse = vec3(0.8,0.5,0.2);\n    clay.refMult = vec3(1,1,1);\n    clay.alphaMult = vec3(1,1,1);\n    clay.alpha = 1.;\n    clay.reflectance = 0.0;\n\nmats[0] = somethingness;\nmats[1] = clay;\n}\n\n\n\n//\n////\n/////\n// MAIN //\n/////\n////\n//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n    adapt();\n    defMats();      //DEPRECATED\n    \n    \n    // copypaste TouchDesigner uniforms into local variables\n\n\niCamPos  = vec3(iTime*0.1);\n    iCamPos.z = 0.0011;\niWorldRotate = vec3(iTime*.1);\n    //\n\niSun = vec3(iTime*0.1+7.*sin(iTime*0.01));\niSun.z = 0.5;    \n\niCamLook  = iSun;\n    \n    theSun.p = iSun;\ntheSun.tint = vec3 (1.5,1.2,0.5);\n    \n    //update camera, size, transforms\n   origincam = iCamPos;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.2 -1.0;\n   vec3 ray = normalize(vec3( uv,scope)); \n\n    /////////////////////Look At Target   /////////////////////\n   ray.xy *= mat2 (cos (iCamLook.z),-sin (iCamLook.z),sin (iCamLook.z),cos (iCamLook.z));\n   ray.yz *= mat2 (cos (iCamLook.x),-sin (iCamLook.x),sin (iCamLook.x),cos (iCamLook.x));\n   ray.xz *= mat2 (cos (iCamLook.y),-sin (iCamLook.y),sin (iCamLook.y),cos (iCamLook.y));      \n\n   vec3 normpos = normalize(origincam);\n    normpos = vec3(origincam.x,origincam.y,-origincam.z);\n\n   float camYrot = atan(normpos.x,normpos.z); \n   //float camYrot = atan(normpos.z,normpos.x); \n   normpos.xz *= mat2 (cos (camYrot), -sin (camYrot), sin (camYrot), cos (camYrot));  \n   float camXrot = atan(normpos.y,normpos.z);\n   //float camXrot = atan(normpos.z,normpos.y);\n   ray.yz *= mat2 (cos (camXrot), -sin (camXrot),sin (camXrot),cos (camXrot));\n   ray.xz *= mat2 (cos (camYrot), -sin (camYrot),sin (camYrot),cos (camYrot)); \n   ///////////////////////\n\n\n    rayTree[0].myData = trace(origincam,ray,0.,N);\n    rayTree[0].myData.myNormal = getNorm(rayTree[0].myData.p);\n\n\n    //shootRay();\n\n    vec3 sunRay = rayTree[0].myData.p-theSun.p;\n    float sunD = length(sunRay);\n    sunRay = normalize(sunRay);\n    sunRay = sunRay;\n\n    float fres = dot(rayTree[0].myData.myNormal, sunRay);\n   \n    float exposure = shadeTrace(theSun.p,sunRay,100,sunD-0.01);\n\n    vec3 sunvec = (theSun.p - origincam);\n    float looksun = dot(normalize(sunvec) , ray);\n   \n    //float sunpoint = step(length(sunvec),rayTree[0].myData.t)*looksun*looksun*looksun*0.5;  \n    float sunpoint = step(length(sunvec),rayTree[0].myData.t)*max(pow(looksun*300.-298.8,3.),0.);  \n    //float sunpoint = step(length(sunvec),rayTree[0].myData.t)*pow(max(3-sunD,0),3)*0.5;  \n\n    vec4 comp = vec4(1.-0.7*length(rayTree[0].myData.p))*0.+exposure;\n\n    //comp.rgb /= (-fres*1);\n    //comp.rgb -= (0.5/-fres*0.5);\n    \n    comp.rgb -= (1.+fres)*0.5;\n    //comp.rgb=vec3(-fres);\n    comp.rgb += vec3(rayTree[0].myData.myNormal*0.1);\n\n\n    comp.rgb = smoothstep(0.,1.,comp.rgb); //clip negative shadows;\n    //comp.rgb += looksun*0.1;\n    comp.rgb += max(1.5-sunD*3.,0.)*rayTree[0].myData.myNormal;\n\n    comp.rgb += vec3(rayTree[0].myData.myNormal*0.1);\n\n    comp.rgb += vec3(sunpoint);\n    fragColor = comp;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls2yzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1866, 1892, 1905, 2013, 2015], [2049, 2063, 2091, 2091, 2177], [2255, 2312, 2340, 2340, 3893], [3908, 3908, 3934, 3934, 5347], [5966, 5980, 6029, 6029, 6296], [6350, 6359, 6395, 6395, 6622], [6666, 6699, 6739, 6739, 6950], [6953, 6961, 6999, 7080, 7350], [7353, 7447, 7482, 7482, 7627], [7629, 7652, 7699, 7699, 7792], [8030, 8060, 8082, 8082, 8320], [8322, 8322, 8353, 8393, 8861], [8910, 8938, 8967, 8967, 9196], [9198, 9301, 9354, 9354, 9924], [9927, 9969, 10024, 10024, 10524], [10572, 10681, 10697, 10748, 14860], [15137, 15279, 15294, 15358, 15856], [15860, 15901, 15957, 15957, 18695]]}
{"id": "lsByWz", "name": "tetrahedron", "author": "donniet", "description": "platonic solid in spherical projection", "tags": ["2d"], "likes": 4, "viewed": 119, "date": "1491581729", "time_retrieved": "2024-06-20T18:53:06.687752", "image_code": "\nvec3 sphereToCart(vec3 sphere) {\n    float cp = cos(sphere.x);\n    float sp = sin(sphere.x);\n    float ct = cos(sphere.y);\n    float st = sin(sphere.y);\n    float r = sphere.z;\n    return vec3(r * cp * ct, r * st, r * sp * ct);\n}\n\nvec3 cartToSphere(vec3 cart) {\n    float r = length(cart);\n    vec3 n = cart / r;\n    return vec3(atan(n.x, n.z), asin(n.y), r);\n}\n\n\nconst float SQRT_2 = 1.414213562373095;\nconst float ISQRT_2 = 0.70710678118655;\nconst float PI = 3.141592653589793;\n\nconst vec3 coords[8] = vec3[8](\n    vec3(1, 0, ISQRT_2),\n    vec3(-1, 0, ISQRT_2),\n    vec3(0, 1, -ISQRT_2),\n    vec3(0, -1, -ISQRT_2),\n    vec3(1, 0, -ISQRT_2),\n    vec3(-1, 0, -ISQRT_2),\n    vec3(0, 1, ISQRT_2),\n    vec3(0, -1, ISQRT_2)\n);\n\nconst int faces[12] = int[12](\n    0, 1, 2,\n    0, 2, 3,\n    0, 3, 1,\n    1, 2, 3\n);\n\nconst int dual_faces[12] = int[12](\n    4, 5, 6,\n    4, 6, 7,\n    4, 7, 5,\n    5, 6, 7\n);\n\nbool intersects(\n    in vec3 orig, in vec3 dir, in vec3 vertices[3],\n    out vec3 I, out vec2 st)\n{\n    vec3 u, v, n;\n    vec3 w0, w;\n    float r, a, b;\n    \n    u = vertices[1] - vertices[0];\n    v = vertices[2] - vertices[0];\n    n = cross(u, v);\n    \n    w0 = orig - vertices[0];\n    a = -dot(n, w0);\n    b = dot(n, dir);\n    if (abs(b) < 1e-5) return false;\n    \n    r = a / b;\n    if (r < 1e-5) return false;\n    \n    I = orig + r * dir;\n    float uu, uv, vv, wu, wv, D;\n    uu = dot(u, u);\n    uv = dot(u, v);\n    vv = dot(v, v);\n    w = I - vertices[0];\n    wu = dot(w, u);\n    wv = dot(w, v);\n    D = uv * uv - uu * vv;\n    \n    float s, t;\n    s = (uv * wv - vv * wu) / D;\n    if (s < 0. || s > 1.) return false;\n    t = (uv * wu - uu * wv) / D;\n    if (t < 0. || t > 1.) return false;\n    \n    st = vec2(s, t);\n    if (r > 1e-5) return true;\n    \n    return false;\n}\n\n\nbool intersectsShape(\n    in vec3 orig, in vec3 dir, in mat3 rot, \n    out int face, out vec3 I, out vec2 st) \n{\n    bool found = false;\n    vec3 found_I;\n    vec2 found_st;\n    for(int i = 0; i < 4; i++) {\n        if (intersects(orig, dir, vec3[3](\n            \trot * coords[faces[3 * i]],\n            \trot * coords[faces[3 * i + 1]],\n            \trot * coords[faces[3 * i + 2]]\n        \t), found_I, found_st)) {\n            \n            if (!found || length(st) > length(found_st)) {\n                found = true;\n                st = found_st;\n                I = found_I;\n                face = i;\n            }\n        }\n    }\n    \n    return found;\n}\n\n\n\nbool intersectsDual(\n    in vec3 orig, in vec3 dir, in mat3 rot, \n    out int face, out vec3 I, out vec2 st) \n{\n    bool found = false;\n    vec3 found_I;\n    vec2 found_st;\n    for(int i = 0; i < 4; i++) {\n        if (intersects(orig, dir, vec3[3](\n            \trot * coords[dual_faces[3 * i]],\n            \trot * coords[dual_faces[3 * i + 1]],\n            \trot * coords[dual_faces[3 * i + 2]]\n        \t), found_I, found_st)) {\n            \n            if (!found || length(st) > length(found_st)) {\n                found = true;\n                st = found_st;\n                I = found_I;\n                face = i;\n            }\n        }\n    }\n    \n    return found;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 rot = mat3(\n        sin(iTime), cos(iTime), 0.,\n       \tcos(iTime), -sin(iTime), 0.,\n        0., 0., 1.\n    );\n    //mat3 rot = mat3(1., 0., 0., 0., 1., 0., 0., 0., 1.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 cart = sphereToCart(vec3(2. * PI * uv.s, PI * (uv.t - 0.5), 1.));\n    //vec3 cart = vec3(uv, 0.5);\n    \n    int face = 0;\n    vec3 p = vec3(0.);\n    vec2 st = vec2(0.);\n    \n    if (intersectsShape(vec3(0., 0., 0.), cart, rot, face, p, st)) {\n        float x = 1. - min(st.s + st.t, min(1. - st.s, 1. - st.t));\n        \n        vec3 v = vec3(st.s+st.t, 1. - st.s, 1. - st.t);\n        x = 1. - x * x * x * x * x * x;\n        \n        fragColor = vec4(x * (0.5 * normalize(coords[face]) + 0.5), 1.);\n        //fragColor = vec4(x, x, x, 1.);\n    } else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n    \n     if (intersectsDual(vec3(0., 0., 0.), cart, rot, face, p, st)) {\n        float x = 1. - min(st.s + st.t, min(1. - st.s, 1. - st.t));\n        \n        vec3 v = vec3(st.s+st.t, 1. - st.s, 1. - st.t);\n        x = 1. - x * x * x * x;\n        \n        fragColor = x * fragColor;\n        //fragColor = vec4(x, x, x, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsByWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 33, 33, 230], [232, 232, 262, 262, 362], [902, 902, 1001, 1001, 1778], [1781, 1781, 1893, 1893, 2437], [2441, 2441, 2552, 2552, 3111], [3113, 3113, 3170, 3170, 4337]]}
{"id": "lsByzc", "name": "Dot Matrix", "author": "ohjxc", "description": "Generate matrix", "tags": ["matrix"], "likes": 7, "viewed": 156, "date": "1493173338", "time_retrieved": "2024-06-20T18:53:06.687752", "image_code": "float factorSinFunction(float smoothstepA, float smoothstepB, float floatSinX, float SinFactor, float MovingFactor)\n{\n    float sinfactor = sin(floatSinX * SinFactor * 3.0 + MovingFactor * 10.0);\n    float smoothstepfactor = smoothstep(smoothstepA, smoothstepB, sinfactor);\n    return smoothstepfactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec4 color = vec4(0.06, 0.96, 1.0, 0.6 );\n    \n    float A = factorSinFunction(0.7, 1.0, uv.x, uv.x * uv.y, iTime);\n    float B = factorSinFunction(0.7, 1.0, uv.y, uv.x * uv.y, iTime);\n    \n    float C = factorSinFunction(0.7, 1.0, uv.x, uv.x * uv.y + 2.0, iTime * 1.1);\n    float D = factorSinFunction(0.7, 1.0, uv.y, uv.x * uv.y + 2.0, iTime * 1.1);\n    \n    float E = factorSinFunction(0.7, 1.0, uv.x, uv.x * uv.y + 5.0, iTime * 1.3);\n    float F = factorSinFunction(0.7, 1.0, uv.y, uv.x * uv.y + 5.0, iTime * 1.3);\n    \n    float G = factorSinFunction(0.7, 1.0, uv.x, uv.x * uv.y + 8.0, iTime * 1.5);\n    float H = factorSinFunction(0.7, 1.0, uv.y, uv.x * uv.y + 8.0, iTime * 1.5);\n    \n    vec4 layer1 = color * A * B;\n    vec4 layer2 = color * C * D * 0.5;\n    vec4 layer3 = color * E * F * 0.3;\n    vec4 layer4 = color * G * H * 0.1;\n    \n\tfragColor = layer1 + layer2 + layer3 + layer4;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsByzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 117, 117, 304], [306, 306, 363, 363, 1335]]}
{"id": "lsjczy", "name": "HCL Sweep", "author": "ccorcos", "description": "yup", "tags": ["color"], "likes": 0, "viewed": 160, "date": "1492668654", "time_retrieved": "2024-06-20T18:53:06.857583", "image_code": "// HSL colorspace:\n// https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n// GLSL Tutorial for reference:\n// https://www.shadertoy.com/view/Md23DV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Compute swirl:\n    float hue = iTime * 0.3;\n\n    // Compute rgb:\n    vec3 rgb = hsl2rgb(vec3(hue, 1.0, 0.6));\n    fragColor = vec4(rgb, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjczy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 60, 87, 87, 230], [233, 306, 363, 387, 526]]}
{"id": "lsjyRW", "name": "fourier series", "author": "nyamadandan", "description": "fourier series, rectangular wave.", "tags": ["2d"], "likes": 28, "viewed": 451, "date": "1491213035", "time_retrieved": "2024-06-20T18:53:06.857583", "image_code": "const float PI = 3.1415;\nconst float OMEGA = 4.0;\nconst float STEP = 10.0;\nconst float TIME_SCALE = 0.24;\n\nvec3 drawCircle(vec2 uv, vec3 color0, vec3 color, float r, vec2 p, float w)\n{\n\treturn vec3(color * w /  abs(distance(uv, p) - r)) + color0;\n}\n\nvec3 drawPoint(vec2 uv, vec3 color0, vec3 color, float r, vec2 p)\n{\n\treturn vec3(color * r /  distance(uv, p)) + color0;\n}\n\nvec3 drawSegment(vec2 uv, vec3 color0, vec3 color, vec2 p0, vec2 p1, float w)\n{\n\tvec2 a = uv - p0;\n\tvec2 b = p1 - p0;\n\tvec2 c = b * max(min(dot(a, b) / dot(b, b), 1.0), 0.0);\n\tfloat d = distance(a, c);\n\treturn color * (w / d) + color0;\n}\n\nvec3 drawFourier(vec2 uv, vec3 color0, float amp, float t, float omega, vec2 p)\n{\n\tvec2 pp = uv - p;\n\t\n\tvec3 dstColor = color0;\n\n\tfloat y = 0.0;\n\tvec2 p0 = vec2(p.x, 0.0);\n\t\n\tfor(float i = 0.0; i < STEP; i++) {\n\t\tfloat n = 2.0 * i + 1.0;\n\t\tfloat ampn = amp / n;\n\t\tvec2 p1 = vec2(p0.x + ampn * cos(n * t), p0.y + ampn * sin(n * t));\n\t\ty += ampn * sin(n * (omega * pp.x + t));\n\n\t\tdstColor = drawCircle(uv, dstColor, vec3(0.5), ampn, p0, 0.00125);\n\t\tdstColor = drawPoint(uv, dstColor, vec3(0.5), 0.00125, p1);\n\t\tdstColor = drawSegment(uv, dstColor, vec3(1.0, 0.0, 0.0), p0, p1, 0.001);\n\t\tp0 =  p1;\n\t}\n\t\n\tvec2 p1 = vec2(p.x + 2.0 * PI / omega, p0.y);\n\tdstColor = drawPoint(uv, dstColor, vec3(1.0), 0.0125, p1);\n\tdstColor = drawSegment(uv, dstColor, vec3(1.0), p0, p1, 0.0025);\n\t\n\tfloat dist = distance(pp, vec2(pp.x, y));\n\tdstColor += 0.005 / dist;\n\treturn dstColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy / iResolution.xy - 1.0)  * iResolution.xy / min(iResolution.x, iResolution.y);\n\tvec3 color = vec3(0.0);\n\tfloat t = iTime * TIME_SCALE;\n\n\tfloat r = 0.6;\n\tvec2 offset = vec2(-0.5, 0.0);\n\tcolor = drawFourier(p, color, r, t * OMEGA, OMEGA, offset);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjyRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[107, 107, 184, 184, 248], [250, 250, 317, 317, 372], [374, 374, 453, 453, 611], [613, 613, 694, 694, 1477], [1479, 1479, 1536, 1536, 1846]]}
{"id": "lsjyzK", "name": "IIS 3D Compound Parabolic Ex", "author": "soma_arc", "description": "Render the orbit of spheres with Iterated Inversion System.\nCompound Parabolic Generator.\nParallel Translation + Rotation", "tags": ["3d", "sphere", "kleiniangroups"], "likes": 2, "viewed": 140, "date": "1493036085", "time_retrieved": "2024-06-20T18:53:08.651340", "image_code": "/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(float h, float s, float v){\n  vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n  return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nbool intersectPlane(vec3 rayOrigin, vec3 rayDir, int objId,\n                    vec3 center, float size, mat3 rotation,\n                    inout int hitObjId,\n                    inout float minDist, inout vec3 normal, inout vec3 col) {\n    vec3 n = rotation * vec3(0, 0, 1);\n    vec3 xAxis = rotation * vec3(1, 0, 0);\n    vec3 yAxis = rotation * vec3(0, 1, 0);\n    float d = -dot(center, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(0.001 < t && t < minDist){\n        vec3 p = rayOrigin + t * rayDir;\n        float hSize = size * .5;\n        float x = dot(p - center, xAxis);\n        float y = dot(p - center, yAxis);\n        if(-hSize <= x && x <= hSize &&\n           -hSize <= y && y <= hSize ){\n            if((-hSize <= x && x <= hSize &&\n               -hSize/4. <= y && y <= hSize/4.) ||\n              (-hSize/4. <= x && x <= hSize/4. &&\n               -hSize <= y && y <= hSize)){\n            \tcol = vec3(1);\n            }else{\n            \tcol = vec3(0);\n            }\n\t\t\tminDist = t;\n            normal = n;\n            hitObjId = objId;\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec4 baseSphere = vec4(0, 0, 0, 125);\nconst vec4 s1 = vec4(300, 300, 0, 300);\nconst vec4 s2 = vec4(300, -300, 0, 300);\nconst vec4 s3 = vec4(-300, 300, 0, 300);\nconst vec4 s4 = vec4(-300, -300, 0, 300);\nconst vec4 s5 = vec4(0, 0, 424.26, 300);\nconst vec4 s6 = vec4(0, 0, -424.26, 300);\nconst float s1r2 = s1.w * s1.w;\nconst float s2r2 = s2.w * s2.w;\nconst float s3r2 = s3.w * s3.w;\nconst float s4r2 = s4.w * s4.w;\nconst float s5r2 = s5.w * s5.w;\nconst float s6r2 = s6.w * s6.w;\n\n// (zPos, distance, twist, size)\nvec4 planes;\n\nconst int MAX_KLEIN_ITARATION = 8;\nfloat distIIS(vec3 pos, out float loopNum){\n    pos -= vec3(0, 0, 0);\n  \tfloat dr = 1.;\n  \tbool loopEnd = true;\n  \tfloat scalingFactor= 0.2;\n  \tloopNum = 0.;\n  \tfor(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n  \t\tloopEnd = true;\n    \t\n        if(pos.z < -planes.x || planes.x < pos.z){\n        \tpos.z += planes.x;\n            float nn = abs(floor(pos.z/(planes.y)));\n        \tloopNum += nn;\n            pos.z = mod(pos.z, planes.y);\n        \tpos.z -= planes.x;\n            \n            float theta = -(planes.z * nn);\n            float cosTheta = cos(theta);\n            float sinTheta = sin(theta);\n            mat3 m = mat3(cosTheta, -sinTheta, 0,\n                          sinTheta, cosTheta, 0,\n                           0, 0, 1);\n            pos = m * pos;\n        }\n            \n        if(distance(pos, s1.xyz) < s1.w){\n            vec3 diff = (pos - s1.xyz);\n      \t\tdr *= s1r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s1);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s2.xyz) < s2.w){\n            vec3 diff = (pos - s2.xyz);\n      \t\tdr *= s2r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s2);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s3.xyz) < s3.w){\n            vec3 diff = (pos - s3.xyz);\n      \t\tdr *= s3r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s3);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s4.xyz) < s4.w){\n            vec3 diff = (pos - s4.xyz);\n      \t\tdr *= s4r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s4);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s5.xyz) < s5.w){\n            vec3 diff = (pos - s5.xyz);\n      \t\tdr *= s5r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s5);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }else if(distance(pos, s6.xyz) < s6.w){\n            vec3 diff = (pos - s6.xyz);\n      \t\tdr *= s6r2 / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, s6);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n        }\n        \n    \tif(loopEnd == true) break;\n    }\n\n    return (distance(pos, baseSphere.xyz) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 getNormal(const vec3 p){\n\tconst vec2 d = vec2(1., 0.);\n    float loopNum;\n\treturn normalize(vec3(distIIS(p + d.xyy, loopNum) - distIIS(p - d.xyy, loopNum),\n                          distIIS(p + d.yxy, loopNum) - distIIS(p - d.yxy, loopNum),\n                          distIIS(p + d.yyx, loopNum) - distIIS(p - d.yyx, loopNum)));\n}\n\n\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\n\nint MAX_MARCH = 500;\nvec3 calcColor(float time, vec3 eye, vec3 rayDir){\n  \tvec3 l = vec3(0);\n\n    vec3 rayPos = eye;\n    float dist;\n    float rayLength = 0.;\n    bool hit = false;\n    float loopNum;\n    \n    float t0, t1;\n    bool inBox;\n    float bboxSize = 500.;\n    vec3 bboxMin = vec3(-bboxSize, -bboxSize, -90000);\n    vec3 bboxMax = vec3(bboxSize, bboxSize, 90000);\n    \n    bool hitBBox = intersectBox(eye, rayDir, bboxMin, bboxMax, t0, t1, inBox);\n    \n    vec3 normal;\n    mat3 rotation = mat3(1, 0, 0,\n                     0, 1, 0,\n                     0, 0, 1);\n    \n    float cosTheta = cos(planes.z);\n    float sinTheta = sin(planes.z);\n    mat3 twist = mat3(cosTheta, -sinTheta, 0,\n                      sinTheta, cosTheta, 0,\n                      0, 0, 1);\n    float minDist = 99999999.;\n    int objId = -1;\n    vec3 pCol = vec3(0);\n    intersectPlane(eye, rayDir, 1, vec3(0, 0, planes.x), planes.w,\n                   rotation, objId, minDist, normal, pCol);\n    intersectPlane(eye, rayDir, 1, vec3(0, 0, -planes.x), planes.w,\n                   rotation * twist, objId, minDist, normal, pCol);\n    if(hitBBox == false && objId == -1) return vec3(0);\n\n    \n    if(!inBox){\n    \trayLength = t0;\n        rayPos = eye + rayDir * rayLength;\n    }\n    t1 = min(t1, minDist);\n    int marchNum = 0;\n    for(int i = 0 ; i < MAX_MARCH ; i++) {\n        if(rayLength > t1) break;\n        marchNum = i;\n    \tdist = distIIS(rayPos, loopNum);\n        \n        rayLength += dist;\n        rayPos = eye + rayDir * rayLength;\n        if(dist < 0.08){\n            hit = true;\n            break;\n        }\n    }\n    \n    if(hit || objId != -1){\n        vec3 mCol;\n        if(!hit){\n        \tmCol = mix(vec3(0, 0, 7), vec3(1), pCol.x);\n        }else{\n        \tif(loopNum == 0.)\n        \t\tmCol = hsv2rgb(0.33, 1., .77);\n    \t\telse\n        \t\tmCol = hsv2rgb(0.0 + loopNum * 0.1 , 1., 1.);\n        \tnormal = getNormal(rayPos);\n        }\n        const vec3 AMBIENT_FACTOR = vec3(.1);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * mCol;\n    \tvec3 ambient = mCol * AMBIENT_FACTOR;\n        l += ambient + diffuse;\n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float r = 800.;\n    float t = mod(iTime, PI * 12.) * .5;\n    \n    //planes = vec4(posZ, distance, twist, size);\n    planes.x = 350. + 80. * sin(iTime);\n    planes.y = 2. * planes.x;\n    planes.z = (PI/2.) * sin(iTime);\n    planes.w = 800.;\n    vec3 center = vec3(0, 0, 0);\n    vec3 target = vec3(0, 0, 1000. * cos(t ));\n    /*\n    vec3 eye = vec3(500. * sin(iTime) , r * cos(iTime), \n                    300. * cos(iTime) ) + center;\n\n    \teye = vec3(600. * sin(t), 300. * cos(t), \n                   0. * cos(t) ) + center;\n\t*/\n    vec3 eye;\n    float start = PI;\n    float dur = 1.;\n    eye = mix(vec3(1200, 700, 0), vec3(500, 400, 300), \n             (scene(t, start, dur)));\n    planes.w = mix(800., 1., scene(t, start, dur));\n\n    start += dur + PI;\n    dur = 3.;\n\teye = mix(eye, vec3(500, 400, 1200), \n             scene(t, start, dur));\n\n    start += dur + PI;\n  \teye = mix(eye, vec3(1200, 700, 0), \n             scene(t, start, dur));\n    planes.w = mix(planes.w, 800.,\n                  scene(t, start, dur));\n\n    vec3 sum = vec3(0);\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjyzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 541], [544, 544, 585, 585, 705], [803, 803, 955, 955, 1315], [1366, 1366, 1406, 1406, 1518], [1520, 1520, 1657, 1657, 2496], [2498, 2498, 2735, 2735, 3647], [4133, 4215, 4258, 4258, 6381], [6383, 6383, 6412, 6412, 6717], [6791, 6791, 6841, 6841, 8920], [8966, 8966, 8995, 8995, 9172], [9175, 9205, 9253, 9253, 9294], [9297, 9297, 9324, 9324, 9364], [9365, 9365, 9394, 9394, 9430], [9432, 9432, 9463, 9463, 9570], [9658, 9658, 9714, 9714, 11145]]}
{"id": "lsjyzy", "name": "HSL Sweep", "author": "ccorcos", "description": "HSL sweep", "tags": ["color"], "likes": 1, "viewed": 85, "date": "1492665451", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "// HCL colorspace:\n// https://www.shadertoy.com/view/Xt3SDs\nconst float X = 0.950470;\nconst float Y = 1.0;\nconst float Z = 1.088830;\n\nconst float t0 = 4.0 / 29.0;\nconst float t1 = 6.0 / 29.0;\nconst float t2 = 3.0 * t1 * t1;\nconst float t3 = t1 * t1 * t1;\n\nfloat lab_xyz(float t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfloat xyz_rgb(float x) {\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nvec3 lab2rgb(vec3 lab) {\n    float l = lab.x;\n    float a = lab.y;\n    float b = lab.z;\n    float y = (l + 16.0) / 116.0;\n    float x = y + a / 500.0;\n    float z = y - b / 200.0;\n    x = lab_xyz(x) * X;\n    y = lab_xyz(y) * Y;\n    z = lab_xyz(z) * Z;\n    return vec3(\n        xyz_rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z),\n\t\txyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n        xyz_rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n}\n\nvec3 hcl2lab(vec3 hcl) {\n    float h = hcl.x;\n    float c = hcl.y;\n    float l = hcl.z;\n    h = radians(h);\n    return vec3(l, cos(h) * c, sin(h) * c);\n}\n\nvec3 hcl2rgb(vec3 hcl) {\n    return lab2rgb(hcl2lab(hcl));\n}\n\nvec3 hcl(float h, float c, float l)\n{\n\treturn hcl2rgb(vec3(h * 360.0, c * 128.0, l * 100.0));\n}\n\n// GLSL Tutorial for reference:\n// https://www.shadertoy.com/view/Md23DV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    // Compute swirl:\n    float hue = iTime * 0.3;\n\n    // Compute rgb:\n    vec3 rgb = hcl(hue, 0.66, 0.36);\n    fragColor = vec4(rgb, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsjyzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 256, 280, 280, 329], [331, 331, 355, 355, 432], [434, 434, 458, 458, 899], [901, 901, 925, 925, 1054], [1056, 1056, 1080, 1080, 1116], [1118, 1118, 1155, 1155, 1213], [1215, 1288, 1345, 1369, 1500]]}
{"id": "lsScWW", "name": "3 Object.Box,Floor,Sphere", "author": "sw", "description": "Light changes in X direction", "tags": ["tutorial", "learning"], "likes": 1, "viewed": 99, "date": "1492056206", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdFloor(vec3 p){\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdAll(vec3 p)\n{\n    vec3 boxPos=vec3(5,0,10);\n    vec3 spherePos=vec3(0,0,3);\n\n    float d1 = sdBox(p+boxPos,vec3(1,1,1));\n    float d2 = sdFloor(p);\n    float d3 = sdSphere(p+spherePos,1.0);\n    return min(min(d1,d2),d3);\n    //return d3;\n    //return d1;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        sdAll(p + vec3(  d, 0.0, 0.0)) - sdAll(p + vec3( -d, 0.0, 0.0)),\n        sdAll(p + vec3(0.0,   d, 0.0)) - sdAll(p + vec3(0.0,  -d, 0.0)),\n        sdAll(p + vec3(0.0, 0.0,   d)) - sdAll(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // light\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tvec3 lightDir = normalize(vec3(mouse.x, mouse.y, 0.577));\n    \n    // camera\n    vec3 cPos = vec3(0.0, 0.0,  0.0);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0; \n    \n    // ray\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;     \n    vec3  rPos = cPos; \n    for(int i = 0; i < 256; i++){\n        distance = sdAll(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    // hit check\n    if(abs(distance) < 0.001){\n        vec3 SurfaceColor=vec3(0.2,0.4,0.9);\n        \n        float offsetX=sin(iTime);\n\t\tvec3 lightDir = vec3( 0, 0.57, 0.57);\n        lightDir.x=offsetX;\n        lightDir=normalize(lightDir);\n        \n        float lighing=dot( lightDir, getNormal(rPos)); \n        fragColor.xyz = SurfaceColor * lighing;\n    }else{\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsScWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 31, 31, 69], [70, 70, 92, 92, 140], [142, 142, 177, 177, 201], [203, 203, 224, 224, 467], [469, 469, 492, 492, 769], [771, 771, 828, 853, 2004]]}
{"id": "lsSczd", "name": "Test Thing", "author": "jgordon510", "description": "New test", "tags": ["test"], "likes": 0, "viewed": 59, "date": "1493315088", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec4 color = vec4(0,0.0,0.0,1.0);\n    \n\tvec2 xy = fragCoord.xy;\n    color.g = abs(sin(xy.x)*5.0+sin(iTime));//Set its red component to 1.0\n\n    color.r = abs(sin(xy.y/10.0 + cos(xy.x/20.0+tan(iTime))));\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsSczd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 299]]}
{"id": "lttXD8", "name": "metaball - dithered", "author": "vojd", "description": "A dither like metaball", "tags": ["metaball"], "likes": 1, "viewed": 108, "date": "1493483256", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "float metaball(vec2 p, float r)\n{\n    return 1.0/((p.x * p.x) + p.y * p.y) * r;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc_xy = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;  \n    vec2 scaled_xy = ndc_xy * vec2(aspect_ratio, 1.0);\n    \n\tvec2 uv = scaled_xy / 2.0 * sin(fragCoord.y) * cos(fragCoord.x);\n    \n    float d \n        = metaball(vec2(uv.x * sin(iTime), uv.y), 0.1)\n        + metaball(vec2(uv.x, uv.y * sin(iTime)), 0.1);\n    \n    vec3 color = hsv(length(uv) * sin(iTime * 0.01), 0.5, 1.0);\n    if(d > 0.707) color = color - 0.4083;\n    fragColor = vec4(color, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lttXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 33, 33, 81], [83, 83, 120, 120, 252], [254, 254, 311, 311, 837]]}
{"id": "Md2yDR", "name": "Lave noise", "author": "kosmonaut", "description": "just some random perlin noise with smooth fade between random values.", "tags": ["noise", "lava"], "likes": 6, "viewed": 628, "date": "1491692247", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "float random(vec2 uv, float seed)\n{\n    uv = uv * fract(uv + seed );\n    return (fract(sin(dot(uv, vec2(15.8989, 76.132) * 1.0f)) * 46336.23745));\n}\n\nconst float PI = 3.141;\n\nfloat getMip(vec2 uv, vec2 offset, float size, float globalTime)\n{\n    vec2 uvlocal = trunc((uv.xy / size) + offset) * size;\n    \n    uvlocal = uvlocal.xy / iResolution.xy;\n    \n    //next mip\n    \n    float time = globalTime + 4.0*PI;\n    \n    float timetrunc = trunc(time / (2.0 * PI));\n    float timetrunc2 = trunc((time + PI) / (2.0 * PI)) - PI;\n    \n    float rand1 = random(uvlocal, timetrunc);\n    float rand2 = random(uvlocal, timetrunc2);\n    \n    return mix(rand2, rand1, 1.0 - (cos(time)+1.0)/2.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randsmall1 = vec2(random(fragCoord.xy / iResolution.xy, 1.0), random(1.0-(fragCoord.xy / iResolution.xy), 0.5)) * 2.0 - 1.0;\n    vec2 randsmall2 = vec2(random(fragCoord.xy / iResolution.xy, randsmall1.x), random(1.0-(fragCoord.xy / iResolution.xy), randsmall1.y)) * 2.0 - 1.0;\n    \n    vec2 randsmall =  mix(randsmall1, randsmall2, (sin(iTime)+1.0)/2.0 );\n    \n    float size = 8.0;\n    //random\n    //randsmall = vec2(0.0);\n    \n    //float rand0 = getMip(fragCoord.xy, randsmall, 2.0, iTime * 0.5);\n    //float rand1 = getMip(fragCoord.xy, randsmall, 4.0, iTime * 1.0);\n    float rand2 = getMip(fragCoord.xy, randsmall, 8.0, iTime * 2.0);\n    float rand3 = getMip(fragCoord.xy, randsmall, 16.0, iTime * 2.1);\n    float rand4 = getMip(fragCoord.xy, randsmall, 32.0, iTime);\n    \n    float rand = /*rand0 + rand1+*/rand2+rand3+rand4;\n    rand/=3.0;\n    \n    rand = 1.0-rand;\n    rand = pow(rand,1.5);\n    rand = 1.0-rand;\n    \n    fragColor = vec4( mix(vec3(1,0,0),vec3(1,1,0), rand), 1);\n    \n\t//fragColor = vec4(rand, rand, rand, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2yDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 35, 35, 148], [175, 175, 241, 241, 687], [690, 690, 747, 747, 1794]]}
{"id": "Md2yRw", "name": "DF Test 1", "author": "aiekick", "description": "DF Test 1", "tags": ["test", "1", "df"], "likes": 2, "viewed": 371, "date": "1491419623", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\t\n\tfloat evo = sin(iTime*.1);\n\tfloat a = floor(atan(p.x,p.y)/3.14159*20.)*3.*evo;\n\t\n\tfloat d = length(p) - cos(a)*0.288;\n\t\n\td = smoothstep(0.,1.,.8 - d);\n\td = smoothstep(0.,0.01/d,d);\n\tfragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2yRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 329]]}
{"id": "Md2yWm", "name": "Daily 2017-04-17", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 1, "viewed": 273, "date": "1492458596", "time_retrieved": "2024-06-20T18:53:09.033273", "image_code": "const float inf = 1./.0;\n\nmat3 rx(float a){float s=sin(a),c=cos(a);return mat3(1.,0.,0.,0.,c,s,0.,-s,c);}\nmat3 ry(float a){float s=sin(a),c=cos(a);return mat3(c,0.,s,0.,1.,0.,-s,0.,c);}\nmat3 rz(float a){float s=sin(a),c=cos(a);return mat3(c,s,0.,-s,c,0.,0.,0.,1.);}\n\nfloat fq(float t) {return texture(iChannel0,vec2(t,0.25)).r;}\nvec3 hsv(vec3 c){\n    vec4 K=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);\n    return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);\n}\n\nfloat map(vec3 p)\n{\n    p*=rz(p.z*0.1+iTime*0.2);\n    return length(mod(p,2.)-1.)-.2-fq(0.05)*0.2;\n}\n\nfloat df(vec3 o, vec3 d, out vec3 p)\n{\n    int i;\n    float rd=.0;\n    for (i=0;i<30;++i)\n    {\n        p=o+d*rd;\n        float td=map(p);\n        rd+=td;\n        if (td<.01) break;\n    }\n    return 1.-float(i)/30.;\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy -.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 o=vec3(uv,-iTime),d=vec3(uv,-1.),mp;\n\tfloat md=df(o,d,mp);\n    vec3 c=hsv(vec3(mp.x*0.02 + mp.y*.1+iTime*0.1,1.,1.)); \n\tfragColor = vec4(md*c,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md2yWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[26, 26, 43, 43, 105], [106, 106, 123, 123, 185], [186, 186, 203, 203, 265], [267, 267, 286, 286, 328], [329, 329, 346, 346, 481], [483, 483, 502, 502, 583], [585, 585, 623, 623, 802], [813, 813, 870, 870, 1116]]}
{"id": "MdByDw", "name": "GRAPROG - Final Project", "author": "mcad_30", "description": "FINAL PROJECT FOR GRAPROG. FINALLY", "tags": ["noise"], "likes": 1, "viewed": 91, "date": "1492315107", "time_retrieved": "2024-06-20T18:53:09.039372", "image_code": "#define PI 3.141592\n#define TWOPI 6.2831\n#define OCTAVES 6\n\n#define patternNo 1\n\nfloat circleMaker(vec2 uv, vec2 center, float radius);\nfloat createShape(vec2 centerPosition, float side);\nfloat rand(vec2 uv);\nfloat noise(in vec2 st);\nfloat fbm (in vec2 uv);\n\nvec3 colorYellow = vec3(1.0, 1.0, 0.0 );\nvec3 colorBrown = vec3(0.53, 0.45, 0.11);\nvec3 colorGreen = vec3(0.0, 1.0, 0.0 );\nvec3 colorRed = vec3(1.0, 0.0, 0.0);\nvec3 colorBlue = vec3(0.0, 0.0, 1.0);\nvec3 colorBlack = vec3(0.0, 0.0, 0.0 );\nvec3 colorWhite = vec3(1.0, 1.0, 1.0 );\n\n#if patternNo == 1\n\n// Lava lamp\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float n = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position1 = vec2(0.52*ratio , abs(0.5 * sin(0.03*iTime)));\n    position1.y += n;\n    vec3 circle1 = vec3(circleMaker(uv, position1, .09));\n    circle1 *= colorGreen;\n    \n    float n2 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position2 = vec2(0.5*ratio , abs(0.9 * sin(0.03*iTime)));\n    position2.y += n2;\n    vec3 circle2 = vec3(circleMaker(uv, position2, .06));\n    circle2 *= colorGreen;\n    \n    float n3 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position3 = vec2(0.48*ratio , abs(0.9 * sin(0.04*iTime)));\n    position3.y += n3;\n    vec3 circle3 = vec3(circleMaker(uv, position3, .06));\n    circle3 *= colorGreen;\n    \n    float n4 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position4 = vec2(0.5*ratio , abs(0.9 * sin(0.07*iTime)));\n    position4.y += n4;\n    vec3 circle4 = vec3(circleMaker(uv, position4, .06));\n    circle4 *= colorGreen;\n    \n    float n5 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position5 = vec2(0.5*ratio , abs(0.9 * sin(0.05*iTime)));\n    position5.y += n5;\n    vec3 circle5 = vec3(circleMaker(uv, position5, .06));\n    circle5 *= colorGreen;\n    \n    float n6 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position6 = vec2(0.52*ratio , abs(0.9 * sin(0.08*iTime)));\n    position6.y += n6;\n    vec3 circle6 = vec3(circleMaker(uv, position6, .06));\n    circle6 *= colorGreen;\n    \n    float n7 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position7 = vec2(0.48*ratio , abs(0.9 * sin(0.1*iTime)));\n    position7.y += n7;\n    vec3 circle7 = vec3(circleMaker(uv, position7, .06));\n    circle7 *= colorGreen;\n    \n    float n8 = noise(uv  * 10. + iTime) * 0.1; \n    vec2 position8 = vec2(0.5*ratio , 0.001 + n8);\n    vec3 circle8 = vec3(circleMaker(uv, position8, .15));\n    circle8 *= colorGreen;\n    \n    //==============================================================================================\n    vec3 square1 = vec3(1.0);\n    vec2 squarePosition = vec2(0.5*ratio, 0.5);\n    square1 = vec3(step(createShape(uv - squarePosition, 2.0), 0.1));\n    square1 *= colorYellow;\n    \n    fragColor = vec4(vec3(square1 - (circle1 + circle2 + circle3 + circle4 + circle5 + circle6 + circle7 + circle8)), 1.0);\n}\n\n#elif patternNo == 2\n\n// Sand Paper\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float value = 0.0;\n    \n    value = fract(sin(uv.x * uv.y*10000.) * 10000.);\n    uv *= 1.0;\n    vec2 idx= floor(uv);\n    value = rand(uv);\n\tfragColor = vec4(vec3(value) * colorBrown,1.0);\n}\n\n#elif patternNo == 3\n\n// Wood Plank\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 value = vec3(0.35, 0.27, 0.18);\n    \n    float plank = abs(sin(uv.x *20.));\n    value *= plank;\n    \n    float mask = (step(3.0, uv.x) - step(0.35, uv.x));\n\tvec3 yellow = vec3(1.0, 1.0, 0.0);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    \n    value = mix(value, vec3(0.390, 0.265, 0.192), vec3(fbm(uv.xx*25.)));\n    value = mix(value, vec3(0.930, 0.493, 0.502), rand(uv.xx)*.1);\n    value -= (noise(uv*vec2(500.0, 14.0)-noise(uv*vec2(1000.0,64.0)))* 0.1);\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float n = noise(uv  * 500.) * 0.1; \n    vec2 position1 = vec2(0.3*ratio , 0.7);\n    position1.y += n;\n    vec3 circle1 = vec3(circleMaker(uv, position1, 4.0 * n));\n\n    circle1 *= colorYellow;\n    \n\tfragColor = vec4(value + circle1,1.0);\n}\n\n#elif patternNo == 4\n\n// Lava\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv += iTime/100.;\n    vec3 color = mix(vec3(1.0, 1.0, 0.0),vec3(0.8,0.4,0.0),vec3(fbm(uv*10.)*2.0));\n    fragColor = vec4(vec3(color),1.0);\n}\n\n#elif patternNo == 5\n\n// Clouds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y += iTime/100.;\n    vec3 color = mix(vec3(0.93,0.93,0.95),vec3(0.0, 0.0, 0.98),vec3(fbm(uv*12.)*1.7));\n    \n    fragColor = vec4(vec3(color),1.0);\n}\n\n#elif patternNo == 6\n\n// Marble\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = mix(vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),vec3(fbm(uv*10.)*1.5));\n    fragColor = vec4(vec3(color),1.0);\n}\n\n#elif patternNo == 7\n\n// Scottish Tartan x Pollock Painting\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Green x\n    float line1 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine1 = vec3(step (0.05 - line1, uv.x) - step(.1 - line1, uv.x));\n    \n    float line2 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine2 = vec3(step (0.5 - line2, uv.x) - step(.55 - line2, uv.x));\n    \n    float line3 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine3 = vec3(step (0.9 - line3, uv.x) - step(.95 - line3, uv.x));\n    \n    // Red x\n    float line4 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine4 = vec3(step (0.2- line4, uv.x) - step(.25 - line4, uv.x));\n    \n    float line5 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine5 = vec3(step (0.65 - line3, uv.x) - step(0.7 - line3, uv.x));\n    \n    //Blue x\n    float line7 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine7 = vec3(step (0.35 - line4, uv.x) - step(.4 - line4, uv.x));\n    \n    float line8 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine8 = vec3(step (0.8 - line4, uv.x) - step(.85 - line4, uv.x));\n    \n   \n    // Green y\n    \n    float lineY1 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLineY1 = vec3(step (0.05 - lineY1, uv.y) - step(.1 - lineY1, uv.y));\n    \n    float lineY2 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLineY2 = vec3(step (0.5 - lineY2, uv.y) - step(.55 - lineY2, uv.y));\n    \n    float lineY3 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLineY3 = vec3(step (0.94 - lineY3, uv.y) - step(.99 - lineY3, uv.y));\n    \n    // Red y\n    float line6 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLineY6 = vec3(step (0.49 - line4, uv.x) - step(.492 - line4, uv.x));\n    \n     //Blue y\n    float line9 = noise(uv * 10. + iTime) * .05;\n    vec3 noiseLine9 = vec3(step (0.49 - line4, uv.x) - step(.492 - line4, uv.x));\n    \n    vec3 greenLines = (noiseLine1 + noiseLine2 + noiseLine3) * colorGreen;\n    vec3 redLines = (noiseLine4 + noiseLine5) * colorRed;\n    vec3 blueLines = (noiseLine7 + noiseLine8) * colorBlue;\n    \n    vec3 greenYLines = vec3(noiseLineY1 + noiseLineY2  + noiseLineY3) * colorGreen;\n    \n\tfragColor = vec4(vec3(greenLines + redLines + blueLines + greenYLines) ,1.0);    \n    \n}\n\n#elif patternNo == 8\n\n// Night Sea\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    if(uv.y > 0.3){\n        vec3 color = mix(vec3(0.18, 0.17, 0.20),vec3(0.13, 0.13, 0.18),vec3(fbm(uv*10.)*6.5));\n        vec3 moonColor = mix(vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),vec3(fbm(uv*60.)*1.5));\n        \n    \tuv.x *= ratio;\n    \tfloat n = noise(uv) * 0.1; \n    \tvec2 position = vec2(0.5*ratio, 0.5);\n    \tvec3 circle = vec3(circleMaker(uv, position, 0.15));\n    \tcircle *= moonColor;\n        \n    \t\n    \tfragColor = vec4(vec3(color + circle),1.0);\n    }\n    \n    else if(uv.y < 0.3){\n        \n        vec3 color = mix(vec3(0.0, 0.0, 0.0),vec3(0.0, 0.0, 0.06),vec3(fbm(uv*10.)*1.5));\n        vec3 moonReflectionColor = mix(vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),vec3(fbm(uv*60.)*1.5));\n    \tuv.x *= ratio;\n    \tfloat n = noise(uv  * 70. + iTime) * 0.2; \n    \tvec2 position2 = vec2(0.5 * ratio , 0.15 + n);\n    \tvec3 circle2 = vec3(circleMaker(uv, position2, .10));\n    \tcircle2 *= moonReflectionColor;\n        \n    \t\n        \n    \tfragColor = vec4(vec3(color + circle2),1.0);   \n    }\n}\n\n\n#endif\n\n\nfloat circleMaker(vec2 uv, vec2 center, float radius)\n{\n    float circle = step(distance(center,uv), radius);\n    return circle;\n}\n\nfloat createShape(vec2 centerPosition, float side)\n{  \n    float a = atan(centerPosition.y,centerPosition.x);\n    float r = TWOPI/side;\n    return cos(floor(.5+a/r)*r-a)*length(centerPosition.xy);\n}\n\nfloat rand(vec2 uv)\n{\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 uv) {\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdByDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[8524, 8524, 8579, 8579, 8654], [8656, 8656, 8708, 8708, 8854], [8856, 8856, 8877, 8877, 8943], [8945, 8945, 8970, 8970, 9481], [9483, 9483, 9507, 9507, 9728]]}
{"id": "MdByW1", "name": "HexGridPlane", "author": "cexlearning", "description": "draw HexGrid and rings,copy from https://github.com/unity3d-jp/unitychan-crs", "tags": ["2d"], "likes": 23, "viewed": 552, "date": "1491905146", "time_retrieved": "2024-06-20T18:53:09.039372", "image_code": "float Hex( vec2 p, vec2 h )\n{\n\tvec2 q = abs(p);\n    return max(q.x-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\n\nfloat HexGrid(vec2 p)\n{\n    float scale = 1.2;\n    vec2 grid = vec2(0.692, 0.4) * scale;\n    float radius = 0.22 * scale;\n\n    vec2 p1 = mod(p.xy, grid) - grid*0.5;\n    float c1 = Hex(p1, vec2(radius, radius));\n\n    vec2 p2 = mod(p.xy+grid*0.5, grid) - grid*0.5;\n    float c2 = Hex(p2, vec2(radius, radius));\n    return min(c1, c2);\n}\n\n\nfloat Circle(vec2 pos)\n{\n    float o_radius = 5.0;\n    float i_radius = 4.0;\n    float d = length(pos.xy);\n    float c = max(o_radius-(o_radius-mod(d-iTime*1.5, o_radius))-i_radius, 0.0);\n    return c;\n}\n\nfloat  iq_rand( float  p )\n{\n    return fract(sin(p)*43758.5453);\n}\n\nfloat Rings(vec2 pos)\n{\n    float pi = 3.14159;\n    vec2 wpos = pos;\n\n    float stride = 0.2;//_RingSrtide;\n    float strine_half = stride * 0.5;\n    vec4 _Spectra = vec4(0.2143147,0,0,0.8872105);\n    float _RingThicknessMin = 0.1;\n    float _RingThicknessMax = 0.5;\n    float thickness = 1.0 - (_RingThicknessMin + length(_Spectra)*(_RingThicknessMax-_RingThicknessMin));\n    float distance = abs(length(wpos) - iTime*0.1);\n    float fra = mod(distance, stride);\n    float cycle = floor((distance)/stride);\n\n    float c = strine_half - abs(fra-strine_half) - strine_half*thickness;\n    c = max(c * (1.0/(strine_half*thickness)), 0.0);\n\n    float rs = iq_rand(cycle*cycle);\n    float _RingSpeedMin = 0.2;\n    float _RingSpeedMax = 0.5;\n    float r = iq_rand(cycle) + iTime*(_RingSpeedMin+(_RingSpeedMax-_RingSpeedMin)*rs);\n\n    float angle = atan(wpos.y,wpos.x) / pi *0.5 + 0.5; // 0.0-1.0\n    float a = 1.0-mod(angle + r, 1.0);\n    a = max(a-0.7, 0.0) * c;\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 gridColor = vec4(0.2, 0.3, 0.5, 1);\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy/2.0)/80.0;\n    float trails = Rings(uv);\n\tfloat grid_d = HexGrid(uv);\n    float grid = grid_d > 0.0 ? 1.0 : 0.0;\n    float circle = Circle(uv);\n    vec4 _Spectra = vec4(0.2143147,0,0,0.8872105);\n    fragColor = trails * (0.5 + _Spectra * 10.0);\n    fragColor += vec4(grid * circle,grid * circle,grid * circle,1) * gridColor * 8.0;\n    fragColor += 0.2 * (1.0-grid*0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdByW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 29, 29, 110], [112, 112, 135, 135, 446], [449, 449, 473, 473, 652], [654, 654, 682, 682, 721], [723, 723, 746, 746, 1696], [1698, 1698, 1755, 1755, 2219]]}
{"id": "MdByWy", "name": "Cube : Blending", "author": "JCDjcd", "description": "Compute translucidity by blending the nearest 10 points of ray-tracing.", "tags": ["cube", "blending"], "likes": 10, "viewed": 165, "date": "1493570972", "time_retrieved": "2024-06-20T18:53:10.027424", "image_code": "//--------------------------------------------------------------------------\nfloat intersect(in vec3 A,in vec3 B,in vec3 C,in vec3 P,in vec3 n)\n{\n    vec3 u = B-A;\n    vec3 v = C-A;\n    vec3 w = -n;\n    vec3 s = P-A;\n    float det \t= u.x*v.y*w.z\n        \t\t+ v.x*w.y*u.z\n        \t\t+ w.x*u.y*v.z\n              \t- w.x*v.y*u.z\n        \t\t- v.x*u.y*w.z\n        \t\t- u.x*w.y*v.z;\n    if(abs(det) < 1e-6)\n        return -1000.0;\n    float cm_ux = v.y*w.z-v.z*w.y;\n    float cm_vx = u.z*w.y-u.y*w.z;\n    float cm_wx = u.y*v.z-u.z*v.y;\n    float cm_uy = v.z*w.x-v.x*w.z;\n    float cm_vy = u.x*w.z-u.z*w.x;\n    float cm_wy = u.z*v.x-u.x*v.z;\n    float cm_uz = v.x*w.y-v.y*w.x;\n    float cm_vz = u.y*w.x-u.x*w.y;\n    float cm_wz = u.x*v.y-u.y*v.x;\n    \n    float p = (cm_ux*s.x+cm_uy*s.y+cm_uz*s.z)/det;\n    float q = (cm_vx*s.x+cm_vy*s.y+cm_vz*s.z)/det;\n    float t = (cm_wx*s.x+cm_wy*s.y+cm_wz*s.z)/det;\n\n    if(p >= 0.0 && p <= 1.0 && q >= 0.0 && q <= 1.0)\n    {\n    \treturn t;\n    }\n    else\n    {\n        return -1000.0;\n    }\n} // intersect()\n\n//--------------------------------------------------------------------------\nvec3 Rz(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float x = c*u.x-s*u.y;\n    float y = s*u.x+c*u.y;\n    float z = u.z;\n    return vec3(x,y,z);\n} // Rz()\n\n//--------------------------------------------------------------------------\nvec3 Ry(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float z = s*u.z+c*u.x;\n    float x = c*u.z-s*u.x;\n    float y = u.y;\n    return vec3(x,y,z);\n} // Ry()\n\n//--------------------------------------------------------------------------\nstruct CubeSide\n{\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n}; // struct CubeSide\n\n//--------------------------------------------------------------------------\nstruct Transformation\n{\n    float scale;\n    float theta;\n    float phi;\n    vec3  translation;\n}; // struct Transformation\n    \n//--------------------------------------------------------------------------\nvec4 compute(in vec3 P, in vec3 n)\n{        \n    // Definition of the cube :\n    CubeSide sides[6];\n    \n\t// top and bottom sides\n    sides[0].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[0].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[0].C \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[0].color \t= vec4( 0.0, 0.0, 1.0 ,1.0); \t// blue\n    sides[1].A \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[1].B \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[1].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[1].color \t= vec4( 1.0, 1.0, 0.0, 1.0); \t// yellow\n\t// front and rear sides\n    sides[2].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[2].B \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[2].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[2].color \t= vec4( 1.0, 0.0, 0.0, 1.0); \t// red\n    sides[3].A \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[3].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[3].C \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[3].color \t= vec4( 0.0, 1.0, 1.0, 1.0); \t// cyan\n\t// left and right sides\n    sides[4].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[4].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[4].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[4].color \t= vec4( 0.0, 1.0, 0.0, 1.0); \t// green\n    sides[5].A \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[5].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[5].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[5].color \t= vec4( 1.0, 0.0, 1.0, 1.0); \t// magenta\n\n    // Transformation for the three cubes\n    Transformation transformations[3];\n    \n    transformations[0].scale \t\t= 1.0;\n    transformations[0].theta \t\t= 0.0;\n    transformations[0].phi \t\t\t= 0.0;\n    transformations[0].translation \t= vec3(0.0,0.0,0.0);\n    \n    transformations[1].scale \t\t= 0.50;\n    transformations[1].theta \t\t= 3.1415926535*0.25;\n    transformations[1].phi \t\t\t= 3.1415926535*1.25;\n    transformations[1].translation \t= vec3(0.0,0.0,0.0);\n    \n    transformations[2].scale \t\t= 0.25;\n    transformations[2].theta \t\t= 0.0;\n    transformations[2].phi \t\t\t= 0.0;\n    transformations[2].translation \t= vec3(0.0,0.0,0.0);\n    \n\t// In order to perform the blending, we sort the nearest 10 intersections\n    float \tt_min[10];\n    vec4  \tcolor[10];\n    vec3    point[10];\n    int \tk;\n    for(k=0;k<10;k++)\n    {\n\t    t_min[k] = +1000.0;\n        color[k] = vec4(0.0,0.0,0.0,1.0);\n        point[k] = vec3(0.0,0.0,0.0);\n    } // for()\n    \n    int   i,j;\n    for(i=0;i<6;i++) // loop on each cube sides\n    {\n        for(j=0;j<3;j++) // loop on each cube\n        {\n            vec3 A = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].A,transformations[j].theta),transformations[j].phi);\n            vec3 B = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].B,transformations[j].theta),transformations[j].phi);\n            vec3 C = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].C,transformations[j].theta),transformations[j].phi);\n            // Compute the intersection with that side.\n            // If behing the observer direction, don't take it into account.\n            float t = intersect(A,B,C,P,n);\n            if(t > 0.0 && t < t_min[9])\n            {\n                // put that value at the end of the sorted array\n                t_min[9] = t;\n                color[9] = sides[i].color;\n                // then re-sort the array\n                point[9] = P+t*n;\n                for(k=8;k>=0;k--)\n                {\n                    if(t_min[k+1] < t_min[k])\n                    {\n                        // swap k and k+1\n                        float tmp_t_min = t_min[k];\n                        vec4  tmp_color = color[k];\n                        vec3  tmp_point = point[k];\n                        \n                        t_min[k] \t\t= t_min[k+1];\n                        color[k] \t\t= color[k+1];\n                        point[k] \t\t= point[k+1];\n                        \n                        t_min[k+1] \t\t= tmp_t_min;\n                        color[k+1] \t\t= tmp_color;\n                        point[k+1] \t\t= tmp_point;\n                 \t}\n             \t} // for()\n            }\n        } // for()\n    } // for()\n\n    // now compute the render color base on the sorted intersections\n    vec4  c \t\t\t= vec4(0.0,0.0,0.0,1.0);\n    float decay_factor \t= 0.7;\n    float decay \t\t= 1.0;\n    float dr \t\t\t= 0.5;\n    float dt \t\t\t= 3.0;\n    for(k=0;k<10;k++)\n    {\n        decay \t\t\t   *= decay_factor;\n        float r = sqrt(point[k].x*point[k].x+point[k].y*point[k].y+point[k].z*point[k].z);\n        float attenuation \t= 0.5+0.5*cos(2.0*3.1415926535*((r/dr)-(iTime/dt)));\n        attenuation \t\t= pow(attenuation,10.0);\n        attenuation \t\t= 0.2+0.8*attenuation;\n        c \t\t\t\t   += decay*attenuation*color[k];\n    } // for()\n    \n    return vec4(c.xyz,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*4.5;\n    vec3 P \t\t\t= vec3(uv.x,uv.y,-5.0);\n    vec3 n      \t= vec3(0.0,0.0,1.0);\n    float alpha1\t= iTime*3.1415926535*2.0/17.0;\n    float alpha2\t= iTime*3.1415926535*2.0/5.0;\n    P \t\t\t\t= Ry(P,alpha1);\n    P \t\t\t\t= Rz(P,alpha2);\n    n\t \t\t\t= Ry(n,alpha1);\n    n \t\t\t\t= Rz(n,alpha2);\n\tfragColor \t\t= compute(P,n);\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdByWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 77, 145, 145, 1020], [1037, 1114, 1146, 1146, 1297], [1307, 1384, 1416, 1416, 1567], [1953, 2030, 2066, 2106, 6656], [6671, 6748, 6799, 6799, 7208]]}
{"id": "MdjcRy", "name": "Paint Spiral", "author": "halfspiral", "description": "Spinning hypnotic colors", "tags": ["2d", "sound"], "likes": 1, "viewed": 483, "date": "1492740866", "time_retrieved": "2024-06-20T18:53:10.033473", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 center = iResolution.xy / 2.0;\n    vec2 p = center - fragCoord;\n    vec2 polar = vec2(length(p), atan(p.y, p.x));\n    //float rf = rand(vec2(trunc(polar.y * 100.) / 100., 0)) * 0.05;\n    float freq = abs((trunc(polar.y * 100.) / 100.) / radians(180.0));\n    float fft = texture(iChannel0, vec2(freq, 0.25)).x;\n    float wave = texture(iChannel0, vec2(freq, 0.75)).x * 0.3;\n    vec3 hsv = vec3(\n        polar.y / radians(180.0) + wave + iTime + polar.x / 100.,\n        0.75,\n        //sin(polar.x / (10. + sin(iTime) * 5.)) + 1.2);\n        //0, 0, rf);\n        sin(polar.x / (9. + fft + sin(iTime) * 5.)) + 1.2);\n\tfragColor = vec4(hsv2rgb(hsv), 1.0);\n}", "image_inputs": [{"id": "lsBGDd", "previewfilepath": "https://soundcloud.com/futurecityrecords/unitra-parallel-memories", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/futurecityrecords/unitra-parallel-memories", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjcRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 20, 20, 92], [94, 94, 116, 116, 447], [449, 449, 471, 471, 640], [642, 642, 699, 699, 1357]]}
{"id": "MdjczK", "name": "Chromatic Metaballs", "author": "paramcookie", "description": "Simple implementation of metaballs with chromatic aberration with the help of http://thebookofshaders.com/", "tags": ["metaballs"], "likes": 12, "viewed": 366, "date": "1492942646", "time_retrieved": "2024-06-20T18:53:10.033473", "image_code": "#define PI  3.14159265358979323846\n#define TAU 6.28318530717958647692\n\nfloat random(in float val) {\n    return fract(sin(val * 12.9898) * 43758.5453123);\n}\n\nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 random2(in float val){\n    vec2 st = vec2( dot(vec2(val), vec2(127.1, 311.7)), dot(vec2(val), vec2(269.5, 183.3)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec2 random2(in vec2 st){\n    st = vec2( dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = min(iResolution.x, iResolution.y);\n    vec2 st = (fragCoord.xy - (iResolution.xy / 2.0)) / d;\n    vec2 p =  (iMouse.xy - (iResolution.xy / 2.0)) / d;\n    vec3 color = vec3(0.0);\n    float t = iTime;\n    \n    vec3 m_dist = vec3(0.0);\n    const int n = 10;\n    for(int i=0; i<n; i++){\n        vec2 pos = random2(vec2(float(i), 0.2)) * 0.2;\n        float angle  = mix(0.0,  TAU, random(float(i)));\n        float radius = mix(0.01, 0.2, random(float(i)));\n        float freq = 1.0;\n        if(random(float(i)) > 0.5){\n            freq = -1.0;\n        }\n        vec2 offset = radius*vec2(sin(freq*t + angle), cos(freq*t + angle));\n\n        m_dist.r += 1.0 / distance(st + vec2(0.00, 0.00), pos + offset);\n        m_dist.g += 1.0 / distance(st + vec2(0.01, 0.01), pos + offset);\n        m_dist.b += 1.0 / distance(st + vec2(0.05, 0.00), pos + offset);\n    }\n    m_dist.r -= 2.0 / distance(st + vec2(0.00, 0.00), p);\n    m_dist.g -= 2.0 / distance(st + vec2(0.01, 0.01), p);\n    m_dist.b -= 2.0 / distance(st + vec2(0.05, 0.00), p);\n\n    color += smoothstep(0.49, 0.5, m_dist * 0.01);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjczK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[71, 71, 99, 99, 155], [157, 157, 183, 183, 259], [261, 261, 288, 288, 440], [442, 442, 467, 467, 600], [602, 602, 659, 659, 1789]]}
{"id": "MdjyDR", "name": "Crazy Mandelbrot", "author": "R4stafa", "description": "simple but crazy looking mandelbrot implementation", "tags": ["2d", "fractal", "crazy", "mandebrot"], "likes": 3, "viewed": 91, "date": "1491689175", "time_retrieved": "2024-06-20T18:53:10.033473", "image_code": "\nvec2 cMult( in vec2 c1, in vec2 c2 )\n{\n    return vec2(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);\n}\n\n\n\nvoid mandelbrot( out int n, in vec2 C, in int maxIter)\n{\n    vec2 Z = vec2(0, 0);\n    \n    while( length(Z) < 2.0 && n < maxIter )\n    {\n        Z = cMult(Z, Z) + C;\n        n++;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float x = (fragCoord.x - iResolution.x/2.0) / iResolution.y;\n    float y = (fragCoord.y - iResolution.y/2.0) / iResolution.y;\n    \n    vec2 origin = vec2(0.9869, 0.2498);\n    float time = float(int(iTime) % 45) + fract(iTime);\n    float zoom = 4.0 / pow(2.0, time * 0.4);\n    \n    x = x*zoom - origin.x;\n    y = y*zoom - origin.y;\n    \n    int f;\n    float m = 0.01 + time / 45.0 * 4.0;\n    int maxIter = int(100.0 * m);\n    mandelbrot(f, vec2(x, y), maxIter);\n    \n    f = maxIter - f;\n    \n    int modr = 12;\n    int modg = 13;\n    int modb = 9;\n    \n    \n    float r = float((f+0) % modr) / float(modr);\n    float g = float((f+0) % modg) / float(modg);\n    float b = float((f+0) % modb) / float(modb);\n    \n    \n    fragColor = vec4( r, g, b, 1.0 );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1, 1, 39, 39, 112], [116, 116, 172, 172, 302], [305, 305, 362, 362, 1129]]}
{"id": "MdjyR3", "name": "Final Practice Shader", "author": "hamiltonaaronw", "description": "Sphere rotates in ellipse in front of a rippled checkerboard background, revealing a scene within a specific radius inside the sphere", "tags": ["ripples", "checkerboard", "reveal", "rotatingsphere", "kernels"], "likes": 0, "viewed": 94, "date": "1493142338", "time_retrieved": "2024-06-20T18:53:10.984944", "image_code": "// rotating sphere ----------------------------------------------------\n// size and brightness of sphere\nfloat sphereScale = 0.7;\nfloat sphereShine = 0.5;\n\n// sets diffuse, specular and initial specular point position\nvec3 sphereDiff = vec3(0.5, 0.0, .05);\nvec3 sphereSpec = vec3(1.0, 1.0, 1.0);\nvec2 specPoint = vec2(0.2, -0.1);\nvec2 specPoint2 = vec2(0.2, -0.1);\n// end rotating sphere -------------------------------------------------------------\n\n\n// checkerboard ----------------------------------------------------------------\nfloat board(vec2 uv)\n{\n \tuv = floor(uv * 2.0);\n    \n    return mod(uv.x + uv.y, 2.0);\n}\n// end checkerboard ---------------------------------------------------------------\n\n// reveal ------------------------------------------------\n// kernels\nmat3 blur = mat3(\n    0.111, 0.111, 0.111,\n    0.111, 0.111, 0.111,\n    0.111, 0.111, 0.111\n    );\n\nmat3 sharpen = mat3 (\n    0.0, -1.0, 0.0,\n    -1.0, 5.0, -1.0,\n    0.0, -1.0, 0.0\n    );\n\nmat3 edge = mat3 (\n    -1.0, -1.0, -1.0,\n    -1.0, 8.0, -1.0,\n    -1.0, -1.0, -1.0\n    );\n\nmat3 gaussBlur = mat3 ((1.0 / 16.0) * (\n    1.0, 2.0, 1.0,\n    2.0, 4.0, 2.0, \n    1.0, 2.0, 1.0\n    ));\n\nvec3 sample0(const int x, const int y, in vec2 fragCoord)\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;    \n    uv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n    return texture(iChannel0, uv).xyz;\n}\n\nvec3 filter0(in vec2 fragCoord, mat3 kernel)\n{\n    vec3 sum = sample0(-1, -1, fragCoord) * kernel[0][0]\n        + sample0(-1, 0, fragCoord) * kernel[0][1]\n        + sample0(-1, 1, fragCoord) * kernel[0][2]\n        + sample0(0, -1, fragCoord) * kernel[1][0]\n        + sample0(0, 0, fragCoord) * kernel[1][1]\n        + sample0(0, 1, fragCoord) * kernel[1][2]\n        + sample0(1, -1, fragCoord) * kernel[2][0]\n        + sample0(1, 0, fragCoord) * kernel[2][1]\n        + sample0(1, 1, fragCoord) * kernel[2][2];\n    \n    return sum;\n}\n\nuniform vec2 mouse;\nfloat revealRadius = 0.5;\nvec2 center;\n\n// end reveal -------------------------------------------------------------\n\n// ripples -----------------------------------------------------------------\n\nvec2 rippleCenter = vec2(0.5, 0.5);\nfloat rippleSpeed = 0.035;\n\n// end ripples -------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //ripples\n    float invAr = iResolution.y / iResolution.x;\n    vec3 rippleColor = vec4(uv, 0.5 + 0.5*sin(iTime), 1.0).xyz;\n    vec3 texColor;\n    \n    float rippleX = (rippleCenter.x - uv.x);\n    float rippleY = (center.y - uv.y) * invAr;\n    \n    float rippleR = -((rippleX * rippleX) + (rippleY * rippleY));\n    float rippleZ = 1.0 + 0.5 * sin((rippleR + iTime*rippleSpeed) / 0.013);\n    // end ripples\n  \t  \n    vec3 checkerBoard = vec3(board(uv));\n    \n    checkerBoard.x = rippleZ;\n    checkerBoard.y = rippleZ;  \n    \n    // declarting kernel variables\n    vec2 fc = fragCoord.xy;\n    vec3 cfBlur = filter0(fc, blur);\n    vec3 cfSharp = filter0(fc, sharpen);\n    vec3 cfEdge = filter0(fc, edge);\n    vec3 cfGauss = filter0(fc, gaussBlur);\n    \n    // layers\n    vec4 midLayer0 = vec4(cfBlur, 0.7);\n    vec4 midLayer1 = vec4(cfSharp, 0.7);\n    vec4 midLayer2 = vec4(cfEdge, 0.7);\n    vec4 midLayer3 = vec4(cfGauss, 0.7);\n    \n    // shader pixel coordinates\n    vec2 p = uv * 2.3 - 1.0;\n    vec2 p2 = uv * 2.3 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    p2.x *= iResolution.x / iResolution.y;\n    \n    // rotates sphere in an ellipse\n//    p.x += cos(-iTime) * 0.75;\n//    p.y += -sin(-iTime) * 0.35;\n    \n    float a = atan(p.y, p.x);\n    \n    // rotates sphere in a figure-8\n    p.x += cos(a * 0.5) * cos(iTime) * 0.75;\n    p.y -= sin(a * 0.5);\n    p2.x = 2.0 * p.x;\n    p2.y = p.y;\n    //p.x += cos(iTime) * cos(-a * 0.5) * 0.75;\n    //p.y += sin(iTime) * sin(-a * 0.25) * 0.35;\n    \n    // rotates specular point with the sphere\n    //specPoint.x += cos(-iTime) * 0.35;\n    //specPoint.y += sin(-iTime) * 0.35;\n    specPoint.x += cos(iTime) * cos(a * 0.5) * 0.75;\n    specPoint.y += sin(iTime) * sin(a * 0.25) * 0.35;\n    specPoint2.x = 2.0 * specPoint.x;\n    specPoint2.y = specPoint.y;\n    \n    \n    // set radius of sphere to middle of screen\n    float radius = sqrt(dot(p, p));\n    float radius2 = sqrt(dot(p2, p2));\n    \n    // checkerboard\n    vec3 col = checkerBoard;\n    vec3 sphere2;\n    \n    // set initial dark shadow around edge of sphere\n    float f = smoothstep(sphereScale * 0.9, sphereScale, length(p + specPoint));\n    col -= mix(col, vec3(0.0), f) * 0.2;\n    float f2 = smoothstep(sphereScale * 0.9, sphereScale, length(p2 + specPoint2));\n    sphere2 -= mix(sphere2, vec3(0.0), f2) * 0.2;\n    \n    // only carries out logic if radius is less than the scale\n    if (radius < sphereScale) {\n     \tvec3 bg = col;\n     \n       // set diffuse of sphere\n        col = sphereDiff;\n        sphere2 = sphereDiff;\n        \n        // adds smooth dark borders\n        f = smoothstep(sphereScale * 0.7, sphereScale, radius);\n        col = mix(col, sphereDiff * 0.45, f);\n        f2 = smoothstep(sphereScale * 0.7, sphereScale, radius2);\n        sphere2 = mix(sphere2, sphereDiff * 0.45, f2);\n        \n        // adds specular glow\n        f = 1.0 - smoothstep(-0.2, 0.6, length(p - specPoint));\n        col += f * sphereShine * sphereSpec;\n        f2 = 1.0 - smoothstep(-0.2, 0.6, length(p2 - specPoint2));\n        sphere2 += f2 * sphereShine * sphereSpec;\n        \n        // smoothes edge of sphere\n        f = smoothstep(sphereScale - 0.01, sphereScale, radius);\n        col = mix(col, bg, f);\n       \tf2 = smoothstep(sphereScale - 0.1, sphereScale, radius2);\n        sphere2 = mix(sphere2, bg, f2);\n    }\n    \n    vec4 bgLayer = vec4(col + sphere2, 1.0);\n    \n    if (radius > revealRadius)\n        fragColor = bgLayer;\n    else {\n        fragColor = mix(bgLayer, midLayer2, 0.5);\n\n    }\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[452, 533, 555, 555, 620], [706, 1163, 1222, 1222, 1392], [1394, 1394, 1440, 1440, 1925], [2206, 2284, 2341, 2341, 5913]]}
{"id": "MdjyRc", "name": "NotAKnot1", "author": "balkhan", "description": "Again fooling with the DE for knots found by Knightly and DarkBeam on fractal forums.\nThe balls and pole are only here to hide artefacts. Happy to be able to use bitwise operations. ", "tags": ["3d", "raymarchig"], "likes": 7, "viewed": 151, "date": "1493164013", "time_retrieved": "2024-06-20T18:53:10.984944", "image_code": "#define\tI_MAX\t100\n#define\tE\t\t0.0000001\n#define PI\t\t3.14\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tDE(vec3 p);\nvec2\tmarch(vec3 pos, vec3 dir);\nfloat\tsdCappedCylinder( vec3 p, vec2 h );\n\nfloat\tballs;\nfloat\tmind;\nmat2\trot_t;\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    rot_t = mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n    vec2\tf_s = fragCoord.xy - iResolution.xy*.5;\n    f_s = iResolution.x*.1-abs(f_s);\n    f_s *= rot_t;\n\tvec3\tcol = vec3(int(iResolution.y+f_s.x )&int(iResolution.y+f_s.y ) );\n    \n    vec3\tdir = (vec3(fragCoord.xy - iResolution.xy/2.0, -iResolution.y));\n    vec3\tpos = vec3(20.0*cos(2.0+3.*iTime), 20.0*sin(2.0+3.*iTime), 69.0-2.0*cos(iTime));\n    mat4\tlook = lookat(pos, vec3(cos(2.0+iTime), 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    dir = (vec4(dir.xyz, 1.)*look).xyz;\n    dir = normalize(dir);\n   \tvec2 inter = (march(pos, dir));\n    if (mind == balls && inter.y < 100. && inter.x != float(I_MAX) )\n        col.xyz = vec3(0.,0.5,.4)*inter.y*.01;\n    else if (inter.y < 100. && inter.x != float(I_MAX))\n        col.xyz = vec3(1.,0.,.4)*inter.y*.01;\n\tfragColor = vec4(col, 1.0);\n}\n\nfloat DE(vec3 p)\n{\n    p.zx *= rot_t;\n    balls = length(p-vec3(0.,0.,21.98))-4.;\n    balls = min(balls, length(p-vec3(0.,0.,-21.98))-4.);\n    balls = min(balls, sdCappedCylinder(p, vec2(2.,20.41)) ); // the poles and the balls\n\tfloat mobius;\n   \tmobius = (1.0/(9.)) * atan(PI*(p.x), PI*(p.y) );\n\tp.x = length(p.xy) - 6.28;\n    rotate(p.zx, iTime);\n\trotate(p.xz, mobius);\n\tfloat m = (1.0 - ((1.0+9.)))/(6.28);\n\tfloat angle = floor(0.5 + m * (PI/2.0-atan(p.x,p.z)))/m;\n\trotate(p.xz, angle);\n\tp.x -= 18.84;\n    mind = min(length(p.xz)-3.14, balls);\n\treturn mind;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = DE(p);\n        dist.y += dist.x;\n        if (dist.y < E || dist.y >100.)\n           break;\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nmat4\tlookat(vec3 e, vec3 ta, vec3 up)\n{\n    vec3 z = normalize(e - ta);    \n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);     \n\n    mat4 orientation = mat4(\n       \t\t\t\t\t\tx.x, y.x, z.x, 0.0,\n       \t\t\t\t\t\tx.y, y.y, z.y, 0.0,\n       \t\t\t\t\t\tx.z, y.z, z.z, 0.0,\n       \t\t\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\n    mat4 translation = mat4(\n         \t\t\t\t\t1.0, 0.0, 0.0, 0.0,\n         \t\t\t\t\t0.0, 1.0, 0.0, 0.0, \n         \t\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t-e.x,-e.y,-e.z, 1.0);\n\n    return (orientation * translation);\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[379, 601, 629, 629, 954], [956, 1003, 1059, 1059, 1944], [1946, 1946, 1964, 1964, 2508], [2510, 2510, 2542, 2542, 2855], [2857, 2857, 2896, 2896, 3369], [3371, 3371, 3411, 3411, 3486], [3488, 3488, 3530, 3530, 3628]]}
{"id": "MdjyRK", "name": "2D rotating maxnorm ellipse", "author": "assumptionsoup", "description": "Visualization of a maxnorm signed distance field for a rotating ellipse.  Mouse input enabled.\n", "tags": ["2d", "sdf", "ellipse", "maxnorm"], "likes": 4, "viewed": 200, "date": "1492896022", "time_retrieved": "2024-06-20T18:53:12.451723", "image_code": "/*\nPrior work/references:\n\nNon-rotated 3D ellipse:\nhttps://www.shadertoy.com/view/Mt2XWG\n\nGeneral maxnorm distance paper:\nhttp://gamma.cs.unc.edu/RECONS/maxnorm.pdf\n\nSweet SDF visualization technique from:\nhttps://www.shadertoy.com/view/4ddSR7\n\nUpdates: \n4-27-2017 - Solve ellipse_1 + 2 using common sub-expressions.\n            They are very similar solutions.  Usually just b vs -b\n            But unfortunately, the domain mirroring prevents\n\t\t\tsolving them together for large efficiency gains.\n*/\n\nfloat SIGNED_DIST_MAX = 1000.0;\nfloat PI = 3.14159265359;\nfloat scene_dist(vec2 p);\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nfloat shape_circle(vec2 p, vec2 center) {\n  float d = length(p - center) - 0.5;\n  return d;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec2 solve_quadratic(in float a, in float b, in float c) {\n    // ax^2.0 + bx + c = 0, a non-zero\n    float q = b*b - 4.0*a*c;\n    if (q < 0.0) {\n        return vec2(SIGNED_DIST_MAX);\n    }\n    float r0 = -b/(2.0*a);\n    float r1 = sqrt(q)/(2.0*a);\n    return vec2(r0 - r1, r0 + r1);\n}\n\nfloat sum_elem(in vec2 v) { return v.x + v.y; }\n\nfloat min_elem(vec2 v) { return min(v.x, v.y); }\n\nfloat max_elem(vec2 v) { return max(v.x, v.y); }\n\n// Solve ellipse equation for y == x\nfloat ellipse_1(in vec2 p, in vec2 r, in float an) {\n    // mirror input coordinates along y = x\n    if (-p.x > p.y) {\n        float tmp = p.y;\n        p.y = -p.x;\n        p.x = -tmp;\n        an=-an-PI/2.0;\n    }\n\n    // Mathematic code used to create this solution:\n    //\n    // p = {px, py}\n    // r = {rx, ry}\n    // v = {x, y}\n    // rot = RotationMatrix[an]\n    //\n    // (* ellipse equation *)\n    // ellipsem[v_] := Total[(v.rot - p.rot)^2 / r^2] - 1\n    //\n    // (* ellipse gradient and solutions for it *)\n    // derivs = D[ellipsem[{x, y}], {v}]\n    //\n    // (* I don't know mathematica well enough to write this more elegantly *)\n    // derivx = Simplify[Solve[derivs[[1]] == 0, x]][[1]][[1]][[2]]\n    // derivy = Simplify[Solve[derivs[[2]] == 0, y]][[1]][[1]][[2]]\n    // edgex = Simplify[CoefficientList[ellipsem[{x, y}] /. x -> derivx, y]]\n    // edgey = Simplify[CoefficientList[ellipsem[{x, y}] /. y -> derivy, x]]\n    // corners = Simplify[CoefficientList[ellipsem[{x, x}], x]]\n    //\n    // (* Find common sub-expressions.  Then parse the hell out of the answer. *)\n    // optexpr = Experimental`OptimizeExpression[Flatten[{corners, derivy, derivx, edgey, edgex}], OptimizationLevel -> 2]\n\n    float cosa = cos(an);\n    float sina = sin(an);\n    float sin2a = sin(2.0*an);\n    float cos2a = cos(2.0*an);\n\n    vec2 p2 = pow(p, vec2(2.0));\n    vec2 r2 = pow(r, vec2(2.0));\n    vec2 ir2 = vec2(1.0) / r2;\n\n    float c_1 = pow(cosa, 2.0);\n    float c_2 = pow(sina, 2.0);\n    float c_3 = r2.x - r2.y;\n\n    // y = x   - corner\n    float a, b, c;\n    c = -1.0 + dot(p2, ir2) * c_1 - 2.0 * p.x * p.y * ir2.y * cosa * sina + dot(p2, ir2.yx) * c_2 + p.x * p.y * ir2.x * sin2a;\n    b =  -2.0 * ir2.x * ir2.y * ((p.y * r2.x + p.x * r2.y) * c_1 - (p.x + p.y) * c_3 * cosa * sina + ( p.x * r2.x + p.y * r2.y) * c_2);\n    a = sum_elem(ir2) + (ir2.x - ir2.y) * sin2a;\n\n    if (c <= 0.0) {\n        // solving for the absolute value here solves\n        // some discontinuities that would appear due to\n        // mirroring our coordinate system when p.x < p.y\n        return -min_elem(abs(solve_quadratic(a, b, c)));\n    }\n    float corner = min_elem(solve_quadratic(a, b, c));\n\n    float c_4 = dot(r2, vec2(c_1, c_2));\n    float c_5 = dot(r2, vec2(c_2, c_1));\n    float c_6 = sum_elem(r2) + (r2.x - r2.y) * cos2a;\n    float c_7 = sum_elem(r2) + (r2.y - r2.x) * cos2a;\n\n    // df/dy = 0, f(x) = 0  - edge parallel to y\n    c = -(-2.0 * p2.x + c_6) / c_6;\n    b = -2.0 * p.x / c_4;\n    a = 1.0 / c_4;\n    float edge_y = min_elem(solve_quadratic(a, b, c));\n\n    // df/dy = 0\n    float deriv_y =  (p.y * r2.x * c_1 - c_3 * (p.x - edge_y) * cosa * sina + p.y * r2.y * c_2) / c_4;\n\n    // df/dx = 0, f(x) = 0  - edge parallel to x\n    c = -(-2.0 * p2.y + c_7) / c_7;\n    b = -2.0 * p.y / c_5;\n    a = 1.0 / c_5;\n    float edge_x = min_elem(solve_quadratic(a, b, c));\n\n    // df/dx = 0\n    float deriv_x = (p.x * r2.y * c_1 - c_3 * (p.y + -edge_x) * cosa * sina + p.x * r2.x * c_2) / c_5;\n\n    float dist = SIGNED_DIST_MAX;\n    dist = min(SIGNED_DIST_MAX, corner);\n    dist = min(dist, max(deriv_y, edge_y));\n    dist = min(dist, max(deriv_x, edge_x));\n\n    return dist;\n}\n\n// same as ellipse_1, but all equations solved for y == -x\nfloat ellipse_2(in vec2 p, in vec2 r, in float an) {\n\n    // mirror input coordinates along y = -x\n    if (p.x < p.y) {\n        float tmp = p.y;\n        p.y = p.x;\n        p.x = tmp;\n        an=-an+PI/2.0;\n    }\n\n    // Mathematic code used to create this solution:\n    //\n    // p = {px, py}\n    // r = {rx, ry}\n    // v = {x, y}\n    // rot = RotationMatrix[an]\n    //\n    // (* ellipse equation *)\n    // ellipsem[v_] := Total[(v.rot - p.rot)^2 / r^2] - 1\n    //\n    // (* ellipse gradient and solutions for it *)\n    // derivs = D[ellipsem[{x, -y}], {v}]\n    //\n    // (* I don't know mathematica well enough to write this more elegantly *)\n    // derivx = Simplify[Solve[derivs[[1]] == 0, x]][[1]][[1]][[2]]\n    // derivy = Simplify[Solve[derivs[[2]] == 0, y]][[1]][[1]][[2]]\n    // edgex = Simplify[CoefficientList[ellipsem[{x, -y}] /. x -> derivx, y]]\n    // edgey = Simplify[CoefficientList[ellipsem[{x, -y}] /. y -> derivy, x]]\n    // corners = Simplify[CoefficientList[ellipsem[{x, -x}], x]]\n    //\n    // (* Find common sub-expressions.  Then parse the hell out of the answer. *)\n    // optexpr = Experimental`OptimizeExpression[Flatten[{corners, derivy, derivx, edgey, edgex}], OptimizationLevel -> 2]\n\n    float cosa = cos(an);\n    float sina = sin(an);\n    float sin2a = sin(2.0*an);\n    float cos2a = cos(2.0*an);\n\n    vec2 p2 = pow(p, vec2(2.0));\n    vec2 r2 = pow(r, vec2(2.0));\n    vec2 ir2 = vec2(1.0) / r2;\n\n    float c_1 = pow(cosa, 2.0);\n    float c_2 = pow(sina, 2.0);\n    float c_3 = r2.x - r2.y;\n\n    // y = -x   - corner\n    float a, b, c;\n    c = -1.0 + dot(p2, ir2) * c_1 - 2.0 * p.x * p.y * ir2.y * cosa * sina + dot(p2, ir2.yx) * c_2 + p.x * p.y * ir2.x * sin2a;\n    b = 2.0 * ir2.x * ir2.y * ((p.y * r2.x - p.x * r2.y) * c_1 - (p.x - p.y) * c_3 * cosa * sina + (-p.x * r2.x + p.y * r2.y) * c_2);\n    a = sum_elem(ir2) + (ir2.y - ir2.x) * sin2a;\n\n    if (c <= 0.0) {\n        // solving for the absolute value here solves\n        // some discontinuities that would appear due to\n        // mirroring our coordinate system when p.x < p.y\n        return -min_elem(abs(solve_quadratic(a, b, c)));\n    }\n    float corner = min_elem(solve_quadratic(a, b, c));\n\n    float c_4 = dot(r2, vec2(c_1, c_2));\n    float c_5 = dot(r2, vec2(c_2, c_1));\n    float c_6 = sum_elem(r2) + (r2.x - r2.y) * cos2a;\n    float c_7 = sum_elem(r2) + (r2.y - r2.x) * cos2a;\n\n    // df/dy = 0, f(x) = 0  - edge parallel to y\n    c = -(-2.0 * p2.x + c_6) / c_6;\n    b = -2.0 * p.x / c_4;\n    a = 1.0 / c_4;\n    float edge_y = min_elem(solve_quadratic(a, b, c));\n\n    // df/dy = 0\n    float deriv_y = (-p.y * r2.x * c_1 + c_3 * (p.x - edge_y) * cosa * sina - p.y * r2.y * c_2) / c_4;\n\n    // df/dx = 0, f(x) = 0  - edge parallel to x\n    c = -(-2.0 * p2.y + c_7) / c_7;\n    b = 2.0 * p.y / c_5;\n    a = 1.0 / c_5;\n    float edge_x = min_elem(solve_quadratic(a, b, c));\n\n    // df/dx = 0\n    float deriv_x = (p.x * r2.y * c_1 - c_3 * (p.y + edge_x) * cosa * sina + p.x * r2.x * c_2) / c_5;\n\n    float dist = SIGNED_DIST_MAX;\n    dist = min(dist, corner);\n    dist = min(dist, max(deriv_y, edge_y));\n    dist = min(dist, max(deriv_x, edge_x));\n    return dist;\n}\n\nfloat ellipse(in vec2 point, in vec2 radius,in float angle) {\n    float e1 = ellipse_1(point, radius, angle);\n    float e2 = ellipse_2(point, radius, angle);\n    return max(e1, e2);\n}\n\nfloat scene_dist(vec2 test_point, vec2 center_point) {\n    float rotation = mod(2.0*iTime, PI);\n    // offset graph so that the ellipse is centered at (0,0)\n    vec2 point = test_point - center_point;\n    vec2 radius = vec2(0.5, 0.25);\n    return ellipse(point, radius, rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    vec2 center_point = vec2(0, 0);\n    \n    // Hacky test to make sure the mouse has been clicked.\n    // Otherwise, the ellipse shows up in the corner, making\n    // the shader look janky.\n    if (iMouse.xy != vec2(0, 0))\n    \tcenter_point = squareFrame(iResolution.xy, iMouse.xy);\n    \n    fragColor.rgb = draw_distance(scene_dist(uv, center_point));\n    fragColor.a   = 1.0;\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 587, 634, 634, 758], [760, 760, 801, 801, 853], [855, 855, 897, 897, 1005], [1007, 1007, 1032, 1032, 1065], [1067, 1067, 1094, 1094, 1156], [1158, 1158, 1187, 1187, 1620], [1622, 1622, 1680, 1719, 1907], [1909, 1909, 1936, 1936, 1956], [1958, 1958, 1982, 1982, 2006], [2008, 2008, 2032, 2032, 2056], [2058, 2095, 2147, 2191, 5264], [5266, 5325, 5377, 5423, 8482], [8484, 8484, 8545, 8545, 8667], [8669, 8669, 8723, 8723, 8951], [8953, 8953, 9010, 9010, 9446]]}
{"id": "MdjyRm", "name": "Shaderlamp", "author": "lherm", "description": "Playing with a torus", "tags": ["raymarch"], "likes": 49, "viewed": 24448, "date": "1491439335", "time_retrieved": "2024-06-20T18:53:13.106255", "image_code": "#define eps 0.005\n#define far 40.\n#define time iTime*.25\n#define PI 3.1415926\n\n#define PSD pow(abs(textureLod(iChannel0, vec2(.5), 0.).r), 2.)\n\n// Variants\n//#define rings\n//#define polar\n//#define warp\n\n//#define audio\n\nvec2 rotate(vec2 p, float a)\n{\n    float t = atan(p.y, p.x)+a;\n    float l = length(p);\n    return vec2(l*cos(t), l*sin(t));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\nfloat distort(vec3 p)\n{\n    //return sin(p.x + sin(p.y + time * .1) + sin(p.z)*p.z + p.x + p.y + time);\n    return dot(tri(p+time) + sin(tri(p+time)), vec3(.666));\n}\n\nfloat trap;\n\nfloat map(vec3 p)\n{\n    p.z += .2;\n    p += distort(p*distort(p))*.1;\n    #ifdef audio\n    trap = dot(sin(p), 1.-abs(p-PSD))*1.2;\n    #else\n    trap = dot(sin(p), 1.-abs(p))*1.2;\n    #endif\n    float d = -sdTorus(p, vec2(1., .7)) + distort(p)*.05;\n    \n    #ifdef rings\n    p.y -= .2;\n    for(int i = 0; i < 3; i++)\n    {\n        p.y += float(i)*.1;\n        \n    \td = min(d, sdTorus(p, vec2(.75, .01))-distort(p*float(i))*.01);\n    }\n    #endif\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        ));\n}\n\nfloat trace(vec3 r, vec3 d, float start)\n{\n    float m, t=start;\n    for (int i = 0; i < 100; i++)\n    {\n        m = map(r + d * t);\n        t += m;\n        if (m < eps || t > far) break;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 R=iResolution.xy, u = (g+g-R)/R.y;\n    \n    #ifdef audio\n    u *= sin(PSD*5.);\n    #endif\n    \n    #ifdef polar\n    u = rotate(u, 2.*atan(u.y, u.x) + time);\n    #endif\n    \n    #ifdef warp\n    u = abs(u)/dot(u, u) - vec2(step(1., time));\n    #endif\n    \n    vec3 r = vec3(0, 0, 1), d = normalize(vec3(u, -1)), p, n, col;\n    col = vec3(0.);\n    float t = trace(r, d, 0.);\n    p = r + d * t;\n    \n    n = calcNormal(p);\n    \n    if (t < far)\n    {\n        vec3 objcol = vec3(trap/abs(1.-trap), trap*trap, 1.-trap);\n        vec3 lp = vec3(1, 3, 3);\n        vec3 ld = lp - p;\n        float len = length(ld);\n        float atten = max(0., 1./(len*len));\n        ld /= len;\n        float amb = .25;\n        float diff = max(0., dot(ld, n));\n        float spec = pow(max(0., dot(reflect(-ld, n), r)), 8.);\n        float ref = trace(r, reflect(d, n), eps*5.);\n        col = objcol * (((diff*.8+amb*.8)+.1*spec)+atten*.1)*ref;\n    }\n    \n    f = vec4(col, 1);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[204, 221, 251, 251, 347], [349, 349, 382, 382, 447], [449, 449, 469, 469, 496], [497, 520, 543, 623, 685], [700, 700, 719, 719, 1165], [1167, 1167, 1192, 1192, 1364], [1366, 1366, 1408, 1408, 1575], [1577, 1577, 1618, 1618, 2578]]}
{"id": "MdjyRV", "name": "IIS 3D Compound Loxodromic Ex", "author": "soma_arc", "description": "Render the orbit of spheres with Iterated Inversion System.\nCompound Loxodromic Generator.", "tags": ["3d", "sphere", "schottky", "iis"], "likes": 0, "viewed": 98, "date": "1493036068", "time_retrieved": "2024-06-20T18:53:15.985274", "image_code": "/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nmat4 pivoting(mat4 mat, int k){\n    const int n = 3;\n    int col = k;\n    float maxValue = abs(mat[k][k]);\n    for(int i = k+1; i < n ; i++){\n        if(abs(mat[i][k]) > maxValue){\n            col = i;\n            maxValue = abs(mat[i][k]);\n        }\n    }\n    if(k != col){\n        vec4 tmp = mat[col];\n        mat[col] = mat[k];\n        mat[k] = tmp;\n    }\n    return mat;\n}\n\nvec4 makeSphereFromPoints(const vec3 p1,\n                          const vec3 p2,\n                          const vec3 p3,\n                          const vec3 p4){\n    mat4 p = mat4(vec4(p1, 0), vec4(p2, 0),\n                  vec4(p3, 0), vec4(p4, 0));\n    mat4 coefficient = mat4(vec4(1), vec4(1), vec4(1), vec4(0));\n    \n    for(int i = 0 ; i < 3 ; i++){\n        coefficient[i][0] = 2. * (p[i + 1][0] - p[i][0]);\n\t    coefficient[i][1] = 2. * (p[i + 1][1] - p[i][1]);\n\t    coefficient[i][2] = 2. * (p[i + 1][2] - p[i][2]);\n\t    coefficient[i][3] = -(p[i][0] * p[i][0] + p[i][1] * p[i][1] + p[i][2] * p[i][2])+\n\t        p[i + 1][0] * p[i + 1][0] + p[i + 1][1] * p[i + 1][1] + p[i + 1][2] * p[i + 1][2];\n    }\n\n    // Gaussian elimination\n    // Implementation is based on http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%A5%D4%A5%DC%A5%C3%A5%C8%C1%AA%C2%F2\n    // forward elimination\n    const int n = 3;\n    for(int k = 0; k < n - 1; k++){\n        coefficient = pivoting(coefficient, k);\n\n        float vkk = coefficient[k][k];\n        for(int i = k+1; i < n; i++){\n            float vik = coefficient[i][k];\n            for(int j = k; j < n + 1; ++j){\n                coefficient[i][j] = coefficient[i][j]-vik *(coefficient[k][j]/vkk);\n            }\n        }\n    }\n\n    // back substitution\n    \n    coefficient[n-1][n] = coefficient[n-1][n]/coefficient[n-1][n-1];\n    for(int i = n-2; i >= 0; i--){\n        float acc = 0.0;\n        for(int j = i+1; j < n; j++){\n            acc += coefficient[i][j]*coefficient[j][n];\n        }\n        coefficient[i][n] = (coefficient[i][n] - acc)/coefficient[i][i];\n    }\n    \n    vec3 center = vec3(coefficient[0][3], \n                       coefficient[1][3],\n                       coefficient[2][3]);\n    float r = distance(center, p1);\n    return vec4(center, r);\n}\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nconst float RT_3 = sqrt(3.);\nvec4 sphereInvertOnSphere(vec4 invertSphere, vec4 genSphere){\n    float r = invertSphere.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = sphereInvert(invertSphere.xyz + vec3(coeffR),\n                           genSphere);\n    vec3 p2 = sphereInvert(invertSphere.xyz + vec3(-coeffR), \n                           genSphere);\n    vec3 p3 = sphereInvert(invertSphere.xyz + vec3(coeffR, -coeffR, -coeffR),\n                           genSphere);\n    vec3 p4 = sphereInvert(invertSphere.xyz + vec3(-coeffR, coeffR, -coeffR),\n                           genSphere);\n    return makeSphereFromPoints(p1, p2, p3, p4);\n}\n\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(float h, float s, float v){\n  vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n  return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nconst vec4 baseSphere = vec4(0, 0, 0, 100.);\n\nconst float sp = 220.;\nconst float schottkyRadius = sp - baseSphere.w;\nvec4 schottky1 = vec4(sp, 0, 0, 100);\nvec4 schottky2 = vec4(-sp, 0, 0, 100);\nvec4 schottky3 = vec4(0, sp, 0, 100);\nvec4 schottky4 = vec4(0, -sp, 0, 100);\n\nvec4 S1 = vec4(10, 161, 645.82, 566.96);\nvec4 S2 = vec4(100, 211, 666.18, 700);\nvec3 P = vec3(0, 1111, -133); \nvec3 Q1 = vec3(100, -588, -133);\nvec3 Q2 = vec3(800, 111, -143);\nvec4 S3;\nvec4 S4;\nvec4 S1d; //I_S1(S2)\n\nconst int MAX_KLEIN_ITARATION = 25;\nint maxIterations = 1;\nfloat distIIS(vec3 pos, out float loopNum){\n    pos -= vec3(0, 0, 0);\n  \tfloat dr = 1.;\n  \tbool loopEnd = true;\n  \tfloat scalingFactor= 0.08;\n  \tloopNum = 0.;\n  \tfor(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n  \t\tif(i >= maxIterations) break;\n        loopEnd = true;\n        \n        if(distance(pos, S1.xyz) < S1.w){\n\t\t\tvec3 diff0 = (pos - S4.xyz);\n            dr *= S4.w * S4.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S4);\n\n            diff0 = (pos - S3.xyz);\n            dr *= S3.w * S3.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S3);\n\n\n            diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n      \t\tpos = sphereInvert(pos, S1);\n\n            diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            \n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, S1d.xyz) >= S1d.w){\n            vec3 diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            \n            diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S1);\n\n\n            diff0 = (pos - S3.xyz);\n            dr *= S3.w * S3.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S3);\n            \n            diff0 = (pos - S4.xyz);\n            dr *= S4.w * S4.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S4);\n            \n            loopEnd = false;\n            loopNum++;\n        }\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n      \t\tvec3 diff = (pos - schottky1.xyz);\n      \t\tdr *= schottky1.w * schottky1.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky1);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky2.xyz) < schottky2.w){\n      \t\tvec3 diff = (pos - schottky2.xyz);\n      \t\tdr *= schottky2.w * schottky2.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky2);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky3.xyz) < schottky3.w){\n      \t\tvec3 diff = (pos - schottky3.xyz);\n      \t\tdr *= schottky3.w * schottky3.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky3);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky4.xyz) < schottky4.w){\n      \t\tvec3 diff = (pos - schottky4.xyz);\n      \t\tdr *= schottky4.w * schottky4.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky4);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}\n        \n    \tif(loopEnd == true) break;\n    }\n\n    return (distance(pos, baseSphere.xyz) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 getNormal(const vec3 p){\n\tconst vec2 d = vec2(1., 0.);\n    float loopNum;\n\treturn normalize(vec3(distIIS(p + d.xyy, loopNum) - distIIS(p - d.xyy, loopNum),\n                          distIIS(p + d.yxy, loopNum) - distIIS(p - d.yxy, loopNum),\n                          distIIS(p + d.yyx, loopNum) - distIIS(p - d.yyx, loopNum)));\n}\n\nbool intersectSphere(vec4 sphere,\n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphere.xyz;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphere.xyz);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\nconst vec3 AMBIENT_FACTOR = vec3(.4);\nfloat transparent = 0.;\n\nvoid renderGenerators(vec3 eye, vec3 rayDir, \n                      inout vec4 l, inout float minDist){\n\tvec3 intersection, normal;\n    float minSphere;\n    minDist = 999999.;\n    bool hitP = intersectSphere(vec4(P, 50.), eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitP){\n    \tvec3 mcol = vec3(0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, 1);\n\t\tl = col; \n    }\n    \n    hitP = intersectSphere(vec4(Q1, 50.), eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitP){\n    \tvec3 mcol = vec3(0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, 1);\n\t\tl = col; \n    }\n    \n    hitP = intersectSphere(vec4(Q2, 50.), eye, rayDir, \n                     \t\tminDist, intersection, normal);\n    if(hitP){\n    \tvec3 mcol = vec3(0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, 1);\n\t\tl = col; \n    }\n    \n        minDist = 999999.;\n    bool hitS1d = intersectSphere(S1d, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS1d){\n    \tvec3 mcol = vec3(0., 0, 0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minSphere = minDist;\n    \n    minDist = 999999.;\n    bool hitS2 = intersectSphere(S2, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS2){\n    \tvec3 mcol = vec3(0., 0.7, 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minSphere = (minDist < minSphere) ? minDist : minSphere;\n    \n    minDist = 999999.;\n    bool hitS1 = intersectSphere(S1, eye, rayDir, \n                     \t\t\t minDist, intersection, normal);\n    if(hitS1){\n    \tvec3 mcol = vec3(0.7, 0., 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minSphere = (minDist < minSphere) ? minDist : minSphere;\n\n    \n    minDist = 999999.;\n    bool hitS3 = intersectSphere(S3, eye, rayDir, \n                     \t\t\t minDist, intersection, normal);\n    if(hitS3){\n    \tvec3 mcol = vec3(0.78, 0., 0.78);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minSphere = (minDist < minSphere) ? minDist : minSphere;\n\n    \n    minDist = 999999.;\n    bool hitS4 = intersectSphere(S4, eye, rayDir, \n                     \t\t\t minDist, intersection, normal);\n    if(hitS4){\n    \tvec3 mcol = vec3(1, 1, 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minSphere = (minDist < minSphere) ? minDist : minSphere;\n\n    \n    minDist = 999999.;\n    bool hitS = intersectSphere(schottky1, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky2, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky3, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky4, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = minSphere;\n}\n\nint MAX_MARCH = 500;\nvec3 calcColor(float time, vec3 eye, vec3 rayDir){\n  \tvec4 l = vec4(0);\n\n    vec3 rayPos = eye;\n    float dist;\n    float rayLength = 0.;\n    bool hit = false;\n    float loopNum;\n    \n    float t0, t1;\n    bool inBox;\n    vec3 bboxMin = vec3(-3000);\n    vec3 bboxMax = vec3(3000);\n    bool hitBBox = intersectBox(eye, rayDir, bboxMin, bboxMax, t0, t1, inBox);\n    if(hitBBox == false) return l.rgb;\n    \n    float minDist = 99999.;\n    if(transparent > 0.01)\n    \trenderGenerators(eye, rayDir, l, minDist);\n    \n    if(!inBox){\n    \trayLength = t0;\n        rayPos = eye + rayDir * rayLength;\n    }\n    for(int i = 0 ; i < MAX_MARCH ; i++) {\n        if(rayLength > t1) break;\n    \tdist = distIIS(rayPos, loopNum);\n        \n        //dist = distance(rayPos, S1d.xyz) - S1d.w;\n        rayLength += dist;\n        rayPos = eye + rayDir * rayLength;\n        if(dist < .08){\n   //         if(rayLength < minDist)\n            \thit = true;\n            break;\n        }\n    }\n    \n   if(hit && rayLength < minDist) l = vec4(0);\n\n    \n    if(hit){\n        vec3 mCol;\n    \tif(loopNum == 0.)\n        \tmCol = hsv2rgb(0.33, 1., .77);\n    \telse\n        \tmCol = hsv2rgb(0.0 + loopNum * 0.12 , 1., 1.);\n        vec3 normal = getNormal(rayPos);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * mCol;\n    \tvec3 ambient = mCol * AMBIENT_FACTOR;\n        \n        vec4 col = vec4(diffuse + ambient, 1.);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l;\n        //l += vec4(ambient + diffuse, 1);\n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 3.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float r = 4000.;\n    float t = mod(iTime, PI * 10.);\n    vec3 center = vec3(-1300, 0, 200);\n    vec3 target = center;\n    \n  \tvec3 sum = vec3(0);\n    \n    P = vec3( 0.+ 1200. * cos(t) * cos(t), 1111.,\n             -280. * abs(sin(t)));\n    \n    //baseSphere.y += 300. * abs(sin(iTime));\n    vec3 pS1Inv = sphereInvert(P, S1);\n    vec3 pS2Inv = sphereInvert(P, S2);\n    S3 = makeSphereFromPoints(P, pS1Inv, pS2Inv, Q1);\n    S4 = makeSphereFromPoints(P, pS1Inv, pS2Inv, Q2);\n    S1d = sphereInvertOnSphere(S1, S2);\n\n    float start = 1.;\n    float dur = 3.;\n    maxIterations = int(mix(0., 15., (scene(t, start, dur))));\n    \n        start += dur + 1.;\n    dur = 3.;\n    transparent = mix(0.4, 0., expEasingIn(scene(t, start, dur)));\n    r -= mix(0., 2000., expEasingIn(scene(t, start, dur)));\n    \n    start += dur + 1.;\n    dur = 1.;\n\tschottky1.w = mix(0., schottkyRadius, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w = mix(0., schottkyRadius, circEasingIn(scene(t, start + dur, dur)));\n\tschottky3.w = mix(0., schottkyRadius, circEasingIn(scene(t, start + 2. * dur, dur)));\n\tschottky4.w = mix(0., schottkyRadius, circEasingIn(scene(t, start + 3. * dur, dur)));\n\tdur = dur * 4.;\n    \n    start += dur + 10.;\n    dur = 2.;\n    \n    schottky1.w -= mix(0., schottkyRadius, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w -= mix(0., schottkyRadius, circEasingIn(scene(t, start, dur)));\n\tschottky3.w -= mix(0., schottkyRadius, circEasingIn(scene(t, start, dur)));\n\tschottky4.w -= mix(0., schottkyRadius, circEasingIn(scene(t, start, dur)));\n    \n    start += dur + 1.;\n    dur = 2.;\n    maxIterations -= int(mix(0., 15., (scene(t, start, dur))));\n    \n    start += dur + .5;\n    dur = 2.;\n    transparent += mix(0., 0.4, expEasingIn(scene(t, start, dur)));\n    r += mix(0., 2000., expEasingIn(scene(t, start, dur)));\n\n    \n    vec3 eye = vec3(r * sin(t) , r * sin(0.), \n                    r * cos(t) ) + center;\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[130, 219, 260, 260, 541], [543, 543, 591, 591, 632], [634, 634, 661, 661, 701], [702, 702, 731, 731, 767], [769, 769, 800, 800, 907], [909, 909, 937, 937, 973], [975, 975, 1006, 1006, 1351], [1353, 1353, 1517, 1517, 3189], [3191, 3191, 3232, 3232, 3352], [3383, 3383, 3444, 3444, 3993], [4092, 4092, 4244, 4244, 4604], [4655, 4655, 4695, 4695, 4807], [4809, 4809, 4946, 4946, 5785], [6263, 6334, 6377, 6377, 9031], [9033, 9033, 9062, 9062, 9367], [9369, 9369, 9561, 9561, 10011], [10125, 10125, 10228, 10228, 15091], [15114, 15114, 15164, 15164, 16642], [16688, 16688, 16717, 16717, 16894], [16984, 16984, 17040, 17040, 19347]]}
{"id": "MdjyRw", "name": "STAD 0002", "author": "tpen", "description": "Shadertoy-a-day, entry #2!\n\nShadertoy version of http://i.imgur.com/dWiqpjO.gif", "tags": ["procedural", "2d", "circles", "stad", "copyagif", "shadereveryday"], "likes": 15, "viewed": 267, "date": "1491423048", "time_retrieved": "2024-06-20T18:53:15.991335", "image_code": "// https://www.shadertoy.com/view/MdjyRw\n\nconst float TOTAL_RADIUS = 177.0;\nconst float CIRCLE_RADIUS = 13.5;\nconst float MARGIN = 50.0;\nconst float NUMBER_OF_CIRCLES = 24.0 / 2.0;\n\nconst float INTERNAL_RADIUS = (CIRCLE_RADIUS)/(TOTAL_RADIUS+MARGIN);\nconst float EXTERNAL_RADIUS = (TOTAL_RADIUS-CIRCLE_RADIUS)/(TOTAL_RADIUS+MARGIN);\nconst float PI = 3.14159265359;\n\n// http://www.chilliant.com/rgb2hsv.html\nvec3 hueToRGB(float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return clamp(vec3(R,G,B), vec3(0.0), vec3(1.0));\n}\n\nfloat pointCircle(vec2 p, vec2 center, float radius)\n{\n    float d = distance(p, center);\n    float aaf = fwidth(d);\n\treturn 1.0 - smoothstep(radius - aaf, radius, d);\n}\n\nfloat pointCircleStroke(vec2 p, vec2 center, float radius)\n{\n    float d = distance(p, center);\n    float aaf = fwidth(d);\n    \n    return smoothstep(radius-aaf, radius, d) - smoothstep(radius, radius+aaf, d);\n}\n\nvec4 alphaBlend(vec4 src, vec4 dst)\n{\n    vec3 col = mix(dst.xyz, src.xyz, src.w);\n    return vec4(col, 1.0);\n}\n\nvec4 circlePattern(vec2 p)\n{\n    vec4 ret = vec4(vec3(0.0), 1.0);\n    for (float i = 0.0; i < NUMBER_OF_CIRCLES; i++)\n    {\n        float angle0 = i * PI * 2.0 / NUMBER_OF_CIRCLES;\n        float angle1 = (i + 1.5) * PI * 2.0 / NUMBER_OF_CIRCLES;\n        \n        float radius = INTERNAL_RADIUS;\n                \n        vec2 circlePos0 = vec2(cos(angle0), sin(angle0)) * EXTERNAL_RADIUS;        \n        vec2 circlePos1 = vec2(cos(angle1), sin(angle1)) * EXTERNAL_RADIUS;\n        vec2 middlePos = (circlePos0 + circlePos1) / 2.0;\n        vec2 diff = middlePos - circlePos0;\n        float middleRadius = length(diff);\n        \n        float middleAngle = atan(diff.y,diff.x);\n        \n        float ratio = smoothstep(0.0,1.0,mod(iTime*0.5+i*0.25,3.0));\n        middleAngle -= ratio * PI;\n            \n        vec2 realPos0 = middlePos + vec2(cos(middleAngle), sin(middleAngle)) * middleRadius;\n        vec2 realPos1 = middlePos + vec2(cos(PI + middleAngle), sin(PI + middleAngle)) * middleRadius;\n        \n        vec3 color0 = hueToRGB(mod(0.25 + 1.0/24.0 - (i+1.5) / NUMBER_OF_CIRCLES, 1.0));\n        vec3 color1 = hueToRGB(mod(0.25 + 1.0/24.0 - (i-0.0) / NUMBER_OF_CIRCLES, 1.0));\n        \n        float bandRatio = 1.0 - abs(2.0 * ratio - 1.0);\n        \n        vec3 realColor0 = mix(color0, color1, ratio);\n        vec3 realColor1 = mix(color1, color0, ratio);\n               \n        float st = pointCircleStroke(p, middlePos, middleRadius);\n\t\tret = alphaBlend(vec4(color0, st * bandRatio), ret);\n        \n        float c0 = pointCircle(p, realPos0, radius);\n        ret = alphaBlend(vec4(realColor0, c0), ret);\n        \n        float c1 = pointCircle(p, realPos1, radius);\n        ret = alphaBlend(vec4(realColor1, c1), ret);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = circlePattern(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[366, 407, 431, 431, 606], [608, 608, 662, 662, 777], [779, 779, 839, 839, 990], [992, 992, 1029, 1029, 1103], [1105, 1105, 1133, 1133, 2861], [2863, 2863, 2920, 2920, 3062]]}
{"id": "MdjyzD", "name": "raymarching w/o GPU", "author": "hopskotchrainbow", "description": "No GPU sound? No problem.", "tags": ["3d", "raymarching", "4d", "dimensional"], "likes": 1, "viewed": 680, "date": "1491253898", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "#define pi 3.14152865\n\n#define eps 0.001\n#define edge 0.00125\n#define shading 0.00125\n#define ev vec3(shading, 0.0, 0.0)\n\n#define time iTime\n\nstruct bit3d_shape\n{\n\tvec3 diffuse;\n\tvec3 ambient;\n\tvec3 glowcolor;\n\tfloat glow;\n\tfloat surface;\n\tvec3 specular;\n\tfloat specPower;\n\tint portal;\n\tfloat ambientOcclusion;\n\tfloat reflection;\n\tbool stepk;\n};\nstruct bit3d_coordinate\n{\n\tvec3 position;\n\tint portal;\n};\n\nstruct bit3d_Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n\tint maxIterations;\n\tint iters;\n\tfloat dist;\n\tbit3d_coordinate coord;\n\tbit3d_shape target;\n\tbool hit;\n\tvec3 normal;\n\tbool inside;\n};\n\n\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\nfloat direction(vec2 uv) {\n\tfloat a = atan(uv.x,uv.y)/radians(360.0);\n\ta += 0.5;\n\treturn a*360.0;\n}\n\nvoid rotate(inout vec2 uv, float angle) {\n\tfloat rad = radians(angle);\n\tuv = vec2(uv.x*cos(rad)-uv.y*sin(rad),\n\t\tuv.x*sin(rad)+uv.y*cos(rad));\n}\n\nvec2 direction(vec3 v)\n{\n\treturn vec2(\n\t\tdirection(v.xz)+180.0,\n\t\tdirection(vec2(\n\t\t\tlength(v.xz),\n\t\t\tv.y\n\t\t))+90.0\n\t);\n}\n\nvoid rotate(inout vec3 v, vec3 angle) {\n\trotate(v.zy, angle.x);\n\trotate(v.xz, angle.y);\n\trotate(v.xy, angle.z);\n}\n\nvec3 spherical(vec2 angle) {\n    vec2 rad = radians(angle*2.0-vec2(180.0,90.0));\n    return vec3(\n        sin(rad.x)*sin(rad.y),\n        cos(rad.y),\n        cos(rad.x)*sin(rad.y)\n    );\n}\n\n// union\nbit3d_shape op_union(bit3d_shape primary, bit3d_shape secondary) {\n\tbit3d_shape shape3d = primary;\n\tif (secondary.surface < primary.surface) shape3d = secondary;\n\treturn shape3d;\n}\n\n// intersection\nfloat op_intersect(float primary, float secondary) {\n\treturn max(primary, secondary);\n}\n\n// mixing\nfloat op_mix(float primary, float secondary, float factor) {\n\tfloat h = clamp((primary-secondary)/factor+1.0,0.0,1.0);\n\tfloat j = mix(primary, secondary, pow(h,3.0));\n\treturn j;\n}\n\n// subtraction\nfloat op_subtract(float primary, float secondary) {\n\treturn max(primary, -secondary);\n}\n\n// sphere\nfloat sphere(vec3 l, vec3 size) {\n\tvec3 sqf = sqrt(size);\n\tvec3 m = l/(sqf);\n\tif (length(m) > 1.0)\n\t{\n\t\tm = normalize(m);\n\t}\n\tm *= sqf;\n\treturn length(l-m);\n}\n\n// box\nfloat box(vec3 l, vec3 size) {\n\tvec3 m = clamp(l, -size/2.0,size/2.0);\n\treturn distance(l, m);\n}\n\n// cylinder\nfloat cylinder(vec3 l, vec2 scale, float bottom, float top) {\n\tvec2 scf = l.xz/scale;\n\tif (length(scf) >= 1.0) scf = normalize(scf);\n\tfloat coDist = distance(l.xz, scf*scale);\n\tfloat cg = max(l.y-bottom, top-l.y);\n\treturn max(cg, coDist);\n}\n\n\nvec3 path(float k, int id) {\n\tvec2 nv = vec2(cos(k*0.7),sin(k*0.7))*0.6;\n\treturn vec3(nv,k*1.3);\n}\n\nvec3 pathdir(float k, int id) {\n\treturn normalize(path(k+eps, id)-path(k, id));\n}\n\nvoid forward(inout vec3 point, vec3 target) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(dh.yx,0.0));\n}\n\nvoid forward(inout vec3 point, vec3 target, float inverse) {\n\tvec2 dh = direction(target);\n\trotate(point, -vec3(mix(dh.yx,-dh.yx,inverse),0.0));\n}\n\nfloat capsphere(vec3 h, float radius) {\n\tvec2 orig = h.xy;\n\tif (length(orig) >= radius) {\n\t\torig = normalize(orig)*radius;\n\t}\n\treturn length(vec3(h.xy-orig.xy,h.z));\n}\n\nfloat speed(float k, int id) {\n\treturn distance(path(k,id),path(k+eps,id))/eps;\n}\n\nfloat crossh(vec3 p) {\n\tfloat m = max(max(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat n = min(min(abs(p.x),abs(p.y)),abs(p.z));\n\tfloat d = (abs(p.x)+abs(p.y)+abs(p.z))/3.0;\n\treturn min(abs(n-m)+d/length(p),n);\n}\n\nvoid scene(\n\tinout bit3d_shape shape,\n\tbit3d_coordinate coord\n)\n{\n\tvec3 frame = (abs(fract(coord.position/16.0)-0.5)-0.5)*16.;\n\tvec3 utframe = (fract(coord.position/16.0+0.5)-0.5)*16.0;\n\tshape.diffuse = vec3(0.11,0.5,0.89);\n\tshape.ambient = vec3(0.0);\n\tshape.specular = vec3(0.2);\n\tshape.specPower = 5.0;\n\tshape.stepk = false;\n\tshape.reflection = 0.0;\n\tshape.ambientOcclusion = 0.5;\n\tfloat holes = min(length(frame.xy)-0.8,length(frame.zy)-0.8);\n\tholes = min(holes,length(frame.xz)-0.1);\n\tfloat setcube = op_mix(box(frame,vec3(5.0)),holes,0.52);\n\tfloat h = op_subtract(0.2-holes,box(frame,vec3(5.0)));\n\tsetcube = op_mix(setcube,(1.0-crossh(frame)),0.3);\n\tif (coord.portal == 0) {\n\t\tshape.surface = 0.2-setcube;\n\t\tif (holes >= 0.2) {\n\t\t\tshape.reflection = 0.0;\n\t\t\tshape.ambientOcclusion = 0.54;\n\t\t} else if (h < 0.2 && shape.surface <= edge*2.0) {\n\t\t\tshape.portal = 1;\n\t\t}\n\t} else if (coord.portal == 1) {\n\t\tvec3 hu = utframe;\n\t\thu.y-= pow(abs(hu.x),0.75);\n\t\tshape.surface = op_mix(pow(capsphere(hu,5.77),0.25)-1.0,-0.5+sphere(frame,vec3(1.7,1.7,1.)),0.9);\n\t\tif (h > 0.2 && shape.surface <= edge) shape.portal = 0;\n\t shape.diffuse = vec3(0.9,0.5,0.7);\n\t shape.ambientOcclusion = 0.8;\n\t}\n}\n\nfloat scenef(bit3d_coordinate l) {\n\tbit3d_shape shape;\n\tshape.portal = l.portal;\n\tscene(shape, l);\n\treturn shape.surface;\n}\n\nbit3d_coordinate cadd(bit3d_coordinate v, vec3 n) {\n\tbit3d_coordinate a;\n\ta.portal = v.portal;\n\ta.position = v.position+n;\n\treturn a;\n}\n\nvec3 bit3d_normal(bit3d_coordinate l) {\n\treturn normalize(vec3(\n\t\tscenef(cadd(l, ev.xyz))-scenef(cadd(l,0.0-ev.xyz)),\n\t\tscenef(cadd(l, ev.yxz))-scenef(cadd(l,0.0-ev.yxz)),\n\t\tscenef(cadd(l, ev.zyx))-scenef(cadd(l,0.0-ev.zyx))\n\t));\n}\n\nvoid fire(inout bit3d_Ray ray, int firstPortal) {\n\tray.coord.position = ray.origin;\n\tvec3 d = normalize(ray.direction);\n\tbit3d_coordinate coord = ray.coord;\n\tcoord.position = ray.origin;\n\tcoord.portal = firstPortal;\n\tbit3d_shape shape = ray.target;\n\tray.hit = false;\n\tray.iters = 0;\n\tray.dist = 0.0;\n\tray.inside = true;\n\tshape.portal = firstPortal;\n\tray.maxIterations = max(ray.maxIterations, 256);\n\twhile (ray.iters < ray.maxIterations && ray.dist < length(ray.direction)) {\n\t\tray.iters += 1;\n\t\tfloat zh = shape.surface;\n\t\tbool kh = shape.stepk;\n\t\tint pl = shape.portal;\n\t\tscene(shape, coord);\n\t if (ray.dist > edge) ray.inside = false;\n\t \tif (shape.surface <= edge && shape.portal == coord.portal) {\n\t\t \tray.hit = true;\n\t\t \tray.normal = bit3d_normal(coord);\n\t\t \tbreak;\n\t\t }\n\t\tfloat hy = max(shape.surface,0.0);\n\t\tif (kh) {hy = 0.075;}\n\t\tcoord.position += d*hy;\n\t coord.portal = shape.portal;\n\t\tray.dist += hy;\n\t}\n\tray.target = shape;\n\tray.coord = coord;\n}\n\nint unroll(int i) {\n    float maxf = float(i);\n    maxf = min(maxf*(iFrameRate/30.0), 1.0);\n    return int(maxf);\n}\n\nbit3d_Ray rayof(vec3 o, vec3 t, int mi) {\n\tbit3d_Ray r;\n\tr.origin = o;\n\tr.direction = t;\n\tr.maxIterations = unroll(8);\n\treturn r;\n}\n\nvec3 LightPosition(bit3d_Ray r) {\n\treturn path(time+2.0,0)+vec3(0.0,0.2,0.0);\n}\n\nvec4 materialColor(bit3d_Ray ray) {\n\tvec3 lightpos = LightPosition(ray);\n\tvec4 m = vec4(0.0);\n\tif (ray.hit) {\n\t\tbit3d_shape target = ray.target;\n\t\tvec3 vn = normalize(ray.direction);\n\t\tvec3 im = lightpos;\n\t\tvec3 vm = normalize(ray.coord.position-im);\n\t\tvec3 vi = normalize(vm-im);\n\t\tvec3 h = normalize(ray.coord.position-lightpos);\n\t\tbit3d_Ray hray = rayof(ray.coord.position-h*edge*2.,h*(length(ray.direction)-ray.dist),ray.maxIterations-ray.iters);\n\t\tfloat byshade = 1.0;\n\n\t\tfloat diffuse = dot(ray.normal, vi)*byshade;\n\t\tdiffuse = pow(clamp(diffuse+target.ambientOcclusion, target.ambientOcclusion, 1.0),1.0);\n\t\tfloat specm = pow(max(dot(vi, ray.normal),0.0),target.specPower);\n\t\tm.a = clamp(1.0-(pow(float(ray.iters)/float(ray.maxIterations),0.2)*pow(distance(ray.coord.position,ray.origin)/length(ray.direction)*24.0,0.01)),0.0,1.0);\n\t\tm.a *= 1.0-(ray.dist/length(ray.direction));\n\t\tm.rgb = mix(target.ambient+mix(target.diffuse*diffuse,target.diffuse+target.specular,specm),target.glowcolor, target.glow*(1.0-diffuse));\n\t}\n\tm.rgb = clamp(m.rgb, 0.0, 1.0);\n\treturn m;\n}\n\nvoid blend(inout vec4 fragColor, vec4 c) {\n\tfragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n\tfragColor.a = max(fragColor.a, c.a);\n}\n\nvoid blend(\n\tsampler2D sampler,\n    vec2 fragCoord,\n    inout vec4 fragColor,\n\tvec2 origin,\n\tvec2 size,\n\tfloat rotation,\n\tfloat alpha\n) {\n vec2 c = fragCoord.xy-origin;\n c /= size;\n rotate(c, rotation);\n c += 0.5;\n if (c.x>= 0.0 && c.y >= 0.0 && c.x < 1.0 && c.y < 1.0) {\n \tvec4 t = texture(sampler, c);\n \tt.a *= alpha;\n \tblend(fragColor, t);\n }\n}\n\nvoid blend(inout vec4 fragColor, bit3d_Ray ray) {\n\tvec4 color = materialColor(ray);\n\tbit3d_Ray refl = ray;\n\tint iei = ray.iters;\n\twhile (iei > 0) {\n\t\tfloat rh = refl.target.reflection;\n\t\tint iters = refl.iters;\n\t\tif ((!ray.hit) || rh <= 0.0) break;\n\t\tfloat gz = length(refl.direction)-refl.dist;\n\t\trefl.origin = refl.coord.position;\n\t\trefl.direction = reflect(normalize(refl.direction), refl.normal)*gz;\n\t\trefl.maxIterations = ray.maxIterations;\n\t\trefl.origin += normalize(refl.direction)*shading;\n\t\tfire(refl, refl.coord.portal);\n\t\tiei -= iters;\n\t\tvec4 c2 = materialColor(refl);\n\t\tcolor.rgb = mix(color.rgb, c2.rgb, rh);\n\t\tcolor.a = mix(color.a,color.a*c2.a,rh);\n\t}\n\tblend(fragColor, color);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 b = pathdir(time, 0);\n    vec3 o = path(time, 0);\n    vec3 unv = normalize(rd)*64.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 8);\n    fire(ray, 0);\n    vec4 c = vec4(vec3(0.0),1.0);\n    blend(c, ray);\n    vec3 m = mix(vec3(0.0), c.rgb, c.a);\n\tfragColor = vec4(m,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv /= max(iResolution.x,iResolution.y);\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    vec3 b = pathdir(time, 0);\n    vec3 o = path(time, 0);\n    vec3 sph = spherical(uv*90.0);\n    vec3 unv = vec3(sph)*60.0;\n    rotate(unv, vec3(direction(b),0.0));\n    bit3d_Ray ray = rayof(o, unv, 8);\n    fire(ray, 0);\n    vec4 c = vec4(vec3(0.0),1.0);\n    blend(c, ray);\n\tvec3 m = mix(vec3(1.0), c.rgb, c.a);\n\tfragColor = vec4(m,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdjyzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[591, 625, 652, 652, 779], [781, 813, 847, 847, 1024], [1026, 1026, 1052, 1052, 1367], [1369, 1369, 1395, 1395, 1468], [1470, 1470, 1511, 1511, 1614], [1616, 1616, 1640, 1640, 1737], [1739, 1739, 1778, 1778, 1852], [1854, 1854, 1882, 1882, 2041], [2043, 2052, 2118, 2118, 2232], [2234, 2250, 2302, 2302, 2337], [2339, 2349, 2409, 2409, 2528], [2530, 2545, 2596, 2596, 2632], [2634, 2644, 2677, 2677, 2802], [2804, 2811, 2841, 2841, 2907], [2909, 2921, 2982, 2982, 3161], [3164, 3164, 3192, 3192, 3262], [3264, 3264, 3295, 3295, 3345], [3347, 3347, 3392, 3392, 3458], [3460, 3460, 3520, 3520, 3606], [3608, 3608, 3647, 3647, 3775], [3777, 3777, 3807, 3807, 3858], [3860, 3860, 3882, 3882, 4064], [4066, 4066, 4131, 4131, 5253], [5255, 5255, 5289, 5289, 5378], [5380, 5380, 5431, 5431, 5515], [5517, 5517, 5556, 5556, 5748], [5750, 5750, 5799, 5799, 6707], [6709, 6709, 6728, 6728, 6824], [6826, 6826, 6867, 6867, 6957], [6959, 6959, 6992, 6992, 7038], [7040, 7040, 7075, 7075, 8114], [8116, 8116, 8158, 8158, 8247], [8249, 8249, 8386, 8386, 8596], [8598, 8598, 8647, 8647, 9292], [9294, 9294, 9372, 9372, 9685], [9687, 9687, 9744, 9744, 10221]]}
{"id": "Mdjyzt", "name": "Sketch 001", "author": "Rackdoll", "description": "My first raymarch sketch. Lovin' it.\nLearning thru concepts from other shaders here on shadertoy,\nand my engine work @ home.", "tags": ["raymarch"], "likes": 0, "viewed": 88, "date": "1493405153", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "/*\n\tMy First RM Expertiment\n\tLearning as i go thru shadertoy &\n    using concepts from my own engine.\n\tRackdoll@2019\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\n\n//Primitives, thnx mercury!\nfloat SDFSphere( vec3 p, float s )\n{\n\treturn length(p) - s;    \n}\n\nfloat SDFTorus( vec3 p, vec2 s )\n{\n    vec2 q = vec2(length(p.xz)-s.x,p.y);\n    return length(q)-s.y;\n}\n\nfloat SDFBox( vec3 p, float s )\n{\n    return length( max( abs(p) - s, 0.0 ) ); \n}\n\n\n//ROTATIONS\nvec3 rotateX( vec3 p, float a )\n{\n \treturn mat3( 1.0, 0.0, 0.0,\n                     0.0, cos(a), -sin(a),\n                     0.0, sin(a), cos(a) ) * p;\n}\nvec3 rotateY( vec3 p, float a )\n{\n \treturn mat3( cos(a), 0.0, sin(a),\n                    0.0, 1.0,    0.0,\n                -sin(a), 0.0,  cos(a) ) * p;\n}\nvec3 rotateZ( vec3 p, float a )\n{\n \treturn mat3( cos(a), -sin(a), 0.0,\n                 sin(a), cos(a),  0.0,\n                        0.0, 0.0, 1.0 ) * p;\n}\n\n\n\n\n\nvec2 map( vec3 p )\n{\n\n    float id = 0.0;\n    \n\n    vec3 p_rot = rotateX( p, iTime / 3.0 );\n    p_rot      = rotateZ( p_rot, iTime/ 3.0  );\n    \n    float torus  = SDFTorus( p_rot, vec2( 0.20, 0.05 ) );\n    float sphere = SDFSphere( p, 0.4 ); \n    \n    \n    p_rot = rotateX( p, -iTime / 10.0 );\n    p_rot = rotateZ( p_rot, -iTime/ 10.0 );\n    float box    = SDFBox( p_rot, 0.3 );\n\n    //create scene\n    float scene = max( -sphere, box );\n    scene       = min( scene, torus );\n \n    //get id\n    if(scene == box || scene > box) id = 1.0;\n    if(scene == torus) id = 2.0;\n    \n    \n\treturn vec2(scene, id);    \n}\n\n//normals.\nvec3 normal( vec3 p )\n{\n\tvec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);\n}\n\nvec2 RM( vec3 RO, vec3 RD )\n{\n    float depth = 0.0;\n \tfor( int i= 0; i < MAX_MARCHING_STEPS; ++i )\n    {\n    \tvec3 ray    = RO + ( depth * RD);\n        vec2 scene = map( ray ); \n        \n        \n        if( scene.x < EPSILON )\n        {\n            \n         \treturn vec2( depth, scene.y);   \n        }\n            \n        \n        depth += scene.x;\n        if( depth >= MAX_DIST )\n        {\n        \treturn vec2(MAX_DIST,0);    \n        }\n        \n    }\n    return vec2(MAX_DIST,0);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec2 r2d( vec2 p, float a )\n{\n    return p * cos( a ) + sin( a ) * vec2( p.y, -p.x );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2( fragCoord.x / iResolution.x, fragCoord.y / iResolution.y );\n    vec2 middle = vec2( 1.0, 0.5 );\n    \n\t\n    //ray direction / origin\n    vec3 RD = rayDirection(45.0,iResolution.xy,fragCoord );\n    vec3 RO = vec3( 0, 0, 3.0 );\n\n    vec2 value = RM( RO, RD );\n    \n    //nothing hit.\n    if( value.x > MAX_DIST - EPSILON )\n    {\n        \n        vec2 uv2 = uv;\n        uv2.y -= 0.5;\n        \n        uv2 *= vec2( iResolution.x / iResolution.y, 1 );\n        uv2.s +=  iTime * 0.15;\n        uv2.t +=  -0.05 + sin(iTime * 3.0 + uv.x *5.0) * 0.1;\n        \n        \n        \n        float cellSize = 0.15;\n        vec2 c = floor( uv2 / cellSize );\n        vec2 p = mod(  uv2 / cellSize, vec2(1.));\n        p -= vec2(0.5 );\n        \n        \n        \n        if( c.y > 0.5 || c.y < -2.5) \n        {\t\n         \tfragColor = vec4(0, 0, 0 , 1.0 ); \n        \treturn;   \n        }\n\n        float a = min( max( (cos( iTime ) * c.y  * 2.0) * (sin( iTime *c.x) ), -3.12), 3.12 );\n        a = cos( iTime + c.x ) * 3.12 * sin( iTime + c.y ) * 2.0;\n       \n        if( c.y < -1.0  && c.y > -5.0) a = -0.05 + sin(iTime * 3.0 + uv.x *5.0) *2.0;\n        if( c.y > -0.5  && c.y < 5.0) a = -0.05 + sin(-iTime * 3.0 + uv.x *5.0) *2.0;\n        p = r2d( p, a);\n        \n        float l  = length( p );\n        float l2 = length( middle - (uv*vec2( iResolution.x / iResolution.y, 1 )));\n        float l3 = length( middle - p ) ;\n        \n        \n        vec3 col = ( p.x < 0.0) ? vec3( l2, l3-l, l ): vec3(l, l2, l3-l);\n        col *= l2 * l2;\n        if(  l > 0.5 ) col = vec3(0);\n\n\n    \tfragColor = vec4(col * (1.0-length(p)) , 1.0 ); \n        return;\n    }\n    \n    //something hit.\n   \n    // -> lighting\n    vec3 ray   = RO + ( RD * value.x );\n\tvec3 light = RO + vec3(0.0, 1.0, -1.0 );\n    vec3 N     = ray;\n    vec3 L     = normal( vec3( light - ray ) );\n\n    //diffuse\n    float diffuseWeight = max( dot( vec4(N, 1.0), vec4(L, 1.0) ), 0.0 );\n\n    //specular\n    vec3 viewEye = normal( -ray );\n    vec3 halfVec = normal( viewEye + L );\n    float specularWeight = pow( max ( dot( reflect( -L, normal(N)), -RD ), 0.0 ), 5.0 );\n    \n    //attenuation\n    float len = length( light - ray );\n    float lightRadius = 2.0;\n    float lightCutOff = 0.5;\n    float d = max( len - lightRadius, 0.0 );\n    float denom  = d/lightRadius + 1.0;\n    float attenuationWeight = 1.0 / (denom*denom);\n    attenuationWeight       = ( attenuationWeight -lightCutOff) / (1.0-lightCutOff);\n    attenuationWeight       = max( attenuationWeight, 0.0);\n    \n    \n    \n    vec3 ambient  = vec3( 0.0, 0, 0 );\n\tvec3 diffuse  = vec3( 1.0, 0.0, 0.0 ) * diffuseWeight * attenuationWeight;\n    vec3 specular = vec3( 1.0, 1.0, 1.0 ) * specularWeight * attenuationWeight; \n\n    vec3 c     = vec3(0);\n    if( value.y == 1.0 ) c = vec3(0.0, 0.0, 0.5 );\n    if( value.y == 2.0 ) c = vec3(0.0, 0.0, 1.0 );\n    vec3 color = (c + diffuse + specular) * attenuationWeight;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdjyzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[248, 276, 312, 312, 341], [343, 343, 377, 377, 446], [448, 448, 481, 481, 529], [532, 544, 577, 577, 700], [701, 701, 734, 734, 855], [856, 856, 889, 889, 1012], [1018, 1018, 1038, 1038, 1630], [1632, 1643, 1666, 1666, 1829], [1831, 1831, 1860, 1860, 2319], [2322, 2322, 2387, 2387, 2519], [2522, 2522, 2551, 2551, 2609], [2612, 2612, 2669, 2669, 5630]]}
{"id": "MdScRy", "name": "No more bass needed", "author": "Eybor", "description": "The shader I wrote for the shader showdown semifinals at Revision 2017\n\nSorry for the crappy and oversaturated colors", "tags": ["3d", "raymarching", "ribbons", "sphere"], "likes": 4, "viewed": 567, "date": "1492541192", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "vec2 rotation(vec2 p, float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;\n}\n\nfloat r1(vec3 p)\n{\n    p.xy += vec2(sin(p.z+ iTime), cos(p.z + iTime)); \n    return length(p.xy - vec2(-6., 3.)) - .5;\n}\n\nfloat r2(vec3 p)\n{\n    p.xy += vec2(sin(p.z+ iTime), cos(p.z + iTime));\n    return length(p.xy - vec2(6., 3.)) - .5;\n}\n\nfloat r3(vec3 p)\n{\n    p.xy += vec2(sin(p.z+ iTime), cos(p.z + iTime));\n    return length(p.xy - vec2(0., 10.)) - .5;\n}\n\nfloat map(vec3 p, float bass)\n{\n    float d = length(p-vec3(0., 5., 0.)) - 5.;\n    vec3 p2 = p;\n    p2.xz = rotation(p2.xz, +1.+2.*bass+iTime+p2.y*.1-5.);\n    p2 = mod(p2, vec3(1.))-vec3(.5);\n    d = max(d, -(length(p2) - .45*bass));\n    return min(r3(p),min(r2(p),min(r1(p), min(p.y, d))));\n}\n\nvec3 rm(vec3 o, vec3 rd, float bass)\n{\n    vec3 p = o;\n    \n    for(int i = 0; i < 128; ++i)\n    {\n        float d = map(p, bass);\n        p += d*rd;\n    }\n    \n    return p;\n}\n\nvec3 gn(vec3 p, float bass)\n{\n    vec2 e = vec2(0., .001);\n    return normalize(vec3(map(p-e.yxx, bass) - map(p+e.yxx, bass),\n                          map(p-e.xyx, bass) - map(p+e.xyx, bass),\n                          map(p-e.xxy, bass) - map(p+e.xxy, bass)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 rd = normalize(vec3((-1.+2.*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.), -1.));\n\t\n    float bass = 0.;\n    \n    for(float f = 0.; f <=.25; f += 1./100.)\n    {\n        bass += texture(iChannel0, vec2(f, .25)).x;\n    }\n    \n    bass *= .1;\n    \n    vec3 o = vec3(0., 5., 8.);\n    \n    vec3 p = rm(o, rd, bass);\n    \n    vec3 co = (1.-distance(p, o)*.004)*vec3(dot(gn(p, bass), normalize(vec3(1., -2., -6.))));\n    \n    co += vec3(.1, .1, 1.)/pow(.1+r1(p), 2.)*bass*5.;\n    co += vec3(1., 1., .1)/pow(.1+r2(p), 2.)*bass*5.;\n    co += vec3(1., .1, 1.)/pow(.1+r3(p), 2.)*bass*5.;\n        \n    fragColor = vec4(co, 1.0);\n}", "image_inputs": [{"id": "lsS3Wd", "previewfilepath": "https://soundcloud.com/edmtunestv/thefatrat-unity", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/edmtunestv/thefatrat-unity", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdScRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 36, 36, 108], [110, 110, 128, 128, 230], [232, 232, 250, 250, 350], [352, 352, 370, 370, 471], [473, 473, 504, 504, 766], [768, 768, 806, 806, 944], [946, 946, 975, 975, 1209], [1211, 1211, 1268, 1268, 1914]]}
{"id": "MdScWy", "name": "CheckersTrip", "author": "jgordon510", "description": "Little bouncing ball and checkers rainbow background.  Still figuring things out.", "tags": ["checker"], "likes": 1, "viewed": 68, "date": "1493571591", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n    \n    vec4 color = vec4(xy.x/200.0*abs(sin(iTime)),xy.x/200.0*abs(cos(iTime)),xy.y/200.0*abs(tan(iTime)),1.0);\n    \n\t\n    if(xy.x - (10.0 * floor(xy.x/10.0)) < 5.0*abs(sin(iTime)) && xy.y - (10.0 * floor(xy.y/10.0)) > 5.0*abs(cos(iTime)))\n    {\n        color =  vec4(abs(sin(iTime)),abs(tan(iTime)),1.0,1.0);\n    }\n    if(xy.x - (10.0 * floor(xy.x/10.0)) > 5.0*abs(sin(iTime)) && xy.y - (10.0 * floor(xy.y/10.0)) < 5.0*abs(cos(iTime)))\n    {\n        color =  vec4(1.0,abs(sin(iTime)),abs(tan(iTime)),1.0);\n    }\n    \n    if(sqrt( (xy.x-200.0)*(xy.x-200.0) + (xy.y-200.0*abs(sin(iTime)))*(xy.y-200.0*abs(sin(iTime)))) < 30.0)\n    {\n        color =  vec4(1.0*abs(sin(iTime)),1.0*abs(cos(iTime)),0.0,1.0);\n    }\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdScWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 827]]}
{"id": "MdSczy", "name": "3D Metaballs", "author": "Helpfully", "description": "Metaball algorithm implemented with vertex shader only", "tags": ["3d", "metaball"], "likes": 2, "viewed": 257, "date": "1492549665", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "/** VARIABLES **/\n\nconst vec3 light_pos = vec3(-2.0, 4.0, -1.0);\nconst vec3 c_light_pos = vec3(2.0, -4.0, -0.0);\n\nconst int \tTRACE_STEPS \t\t= 248;\nconst float TRACE_EPSILON \t\t= 0.00000000001; // 0.00000001;\nconst float REFLECT_EPSILON \t= 100.0;\nconst float TRACE_DISTANCE\t\t= 50.0;\nconst float NORMAL_EPSILON\t\t= 1.0;\nconst int   REFLECT_DEPTH\t\t= 50;\nconst int \tNUM_BALLS\t\t\t= 10;\n\n\nvec3 balls[NUM_BALLS];\n\n\n\n\n/* FUNCTIONS */\nvoid update_balls_position() {\n    \n\tfloat t = iTime * 0.1;\n\tfor (int i = 0; i < NUM_BALLS; ++i) {\n\t\tballs[i] = 3. * vec3(\n\t\t\tsin(2.3+float(i+2)*t),\n\t\t\tcos(1.7+float(-5+i)*t),\n\t\t\t1.1*sin(3.0+float(i+7)*t));\n\t}\n}\n\n\nfloat metaballs_field(in vec3 at) {\n\tfloat sum = 0.;\n\tfor (int i = 0; i < NUM_BALLS; ++i) {\n\t\tfloat r = length(balls[i] - at);\n\t\t\n\t\tsum += 1.0 / ( r * r * r * (r * (r * 6.0 - 15.0) + 10.0));\n\t    // sum += 1.0 / ( r * r * r * r - r * r + 0.25);\n\t}\n\treturn 1. - sum;\n}\n\n\n\nvec3 normal(in vec3 at) {\n\tvec2 e = vec2(0.0, NORMAL_EPSILON);\n\treturn normalize(vec3(metaballs_field(at+e.yxx)-metaballs_field(at), \n\t\t\t\t\t\t  metaballs_field(at+e.xyx)-metaballs_field(at),\n\t\t\t\t\t\t  metaballs_field(at+e.xxy)-metaballs_field(at)));\n}\n\nvec4 raymarch(in vec3 pos, in vec3 dir, in float maxL) {\n\tfloat l = 0.;\n\tfor (int i = 0; i < TRACE_STEPS; ++i) {\n\t\tfloat d = metaballs_field(pos + dir * l);\n\t\tif (d < TRACE_EPSILON*l)\n\t\t\tbreak;\n\t\tl += d;\n\t\tif (l > maxL) break;\n\t}\n\treturn vec4(pos + dir * l, l);\n}\n\nvec3 lookAtDir(in vec3 dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn normalize(dir.x * r + dir.y * u + dir.z * f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tupdate_balls_position();\n\t\n\tfloat t = iTime * 0.1;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n\t\n\tvec3 pos = vec3(cos(2.+4.*cos(t))*10., 2.+8.*cos(t*.8), 10.*sin(2.+3.*cos(t)));\n\tvec3 dir = lookAtDir(normalize(vec3(uv, 2.)), pos.xyz, vec3(balls[0]));\n\t\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n\t\n\tfor (int reflections = 0; reflections < REFLECT_DEPTH; ++reflections) {\n\t\tvec4 tpos = raymarch(pos, dir, TRACE_DISTANCE);\n\t\tif (tpos.w >= TRACE_DISTANCE) {\n\t\t\tcolor += vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// color \n\t\tvec3 norm = normal(tpos.xyz);\n\t\tvec3 light_norm = normalize(light_pos - tpos.xyz); \n\t\tvec4 diffuse = max(dot(norm, light_norm), 0.0) * vec4(0.5, 0.0, 0.0, 1.0); \n\t\tvec3 r_light = normalize(reflect(light_norm, norm));\n\t\tvec4 specular = vec4(1.0) * pow(max(dot(r_light, -dir), 0.0), 4.0);\n\t\tvec3 c_light_normal = normalize(c_light_pos - tpos.xyz);\n\t\tvec3 c_r_light = normalize(reflect(c_light_normal, norm));\n\t\tvec4 c_specular = vec4(0.0, 0.0, 0.7, 1.0) * pow(max(dot(c_r_light, -dir), 0.0), 4.0);\n\t\t\n\t\t\n\t   \n\t\tcolor = vec4(0.1, 0.0, 0.0, 0.0) + diffuse + specular + c_specular;\n\t\t\n\t\tcolor -= color.w * 0.004;\n\n\t\tdir = normalize(reflect(dir, normal(tpos.xyz)));\n\t\tpos = tpos.xyz + dir * REFLECT_EPSILON;\n\t}\n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSczy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[406, 422, 452, 452, 633], [636, 636, 671, 671, 903], [907, 907, 932, 932, 1154], [1156, 1156, 1212, 1212, 1419], [1421, 1421, 1475, 1475, 1621], [1624, 1624, 1681, 1681, 3007]]}
{"id": "MdSyRt", "name": "loading thingy", "author": "rytone", "description": "test", "tags": ["2d"], "likes": 4, "viewed": 150, "date": "1493342206", "time_retrieved": "2024-06-20T18:53:17.894610", "image_code": "#define SMOOTH(r) (mix(1.0, 0.0, smoothstep(0.9,1.0, r)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float len = length(fragCoord - vec2(iResolution.x - 60.0, 60.0));\n    if (len < 30.0) {\n        float angle = dot(vec2(sin(iTime*10.0), cos(iTime*10.0)), normalize(fragCoord - vec2(iResolution.x - 60.0, 60.0)));\n        if (angle > sin(iTime*3.0)*0.74+0.25) {\n            fragColor = vec4(0.8, 0.8, 0.8, 1.0);\n        } else {\n        \tfragColor = vec4(0.15, 0.15, 0.15, 1.0);\n        }\n    } else {\n        fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    }\n    len = length(fragCoord - vec2(iResolution.x - 60.0, 60.0));\n    if (len < 20.0) {\n        fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    }\n    fragColor *= min(iTime, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSyRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[59, 59, 116, 116, 746]]}
{"id": "Ms2yDw", "name": "Slow Flame", "author": "animatedlew", "description": "This shader is meant to be a slow stylized flame that should be combined with particle sparks.", "tags": ["flame"], "likes": 3, "viewed": 312, "date": "1492451753", "time_retrieved": "2024-06-20T18:53:17.900709", "image_code": "float norm(float a, float b, float t) {\n\treturn (t - a) / (b - a);\n}\n\nfloat map(float a, float b, float c, float d, float t) {\n\treturn norm(a, b, t) * (d-c) + c;\n}\n\nfloat bar(float t, float s, float e, float blur) {\n    //blur = 0.001; // for testing strips\n    return smoothstep(s-blur, s+blur, t) * smoothstep(e+blur, e-blur, t);\n}\n\nvec3 blurredBar(vec2 uv, vec2 p, vec2 blur, vec3 color) {    \n    float b = map(1.0, -1.0, blur.s, blur.t, uv.t);    \n    b = pow(b, 2.0);\n\treturn bar(uv.s, p.s, p.t, b) * color;\n}\n\nvec3 fire(vec2 uv) {\n    \n    const float maxblur = 1.0;\n    const float minblur = 0.001;\n    const float start = -0.1;\n    const float end = 0.1;\n    \n    float y = uv.y;    \n    float m = sin(y * 10.0 + iTime * 6.0) * 0.01;\n    float x = uv.x - m;\n    \n    vec3 mask = blurredBar(vec2(x, y), vec2(start, end), vec2(maxblur, minblur), vec3(1.0, 1.0, 0.0)) +\n        blurredBar(vec2(x, y), vec2(start-0.1, end+0.1), vec2(maxblur+0.2, minblur-0.2), vec3(1.0, 0.0, 0.0));\n    \n    vec3 fade = vec3(0.5) - y;\n    \n    return mask * fade;\n}\n\nvec3 distortion(vec2 uv, vec3 image) {\n\tvec2 d = uv.xy;    \n\td.y += iChannelResolution[0].y * -sin(iTime / 800.0);\n\tvec4 c = texture(iChannel0, d);\n    \n    // pulse a composite mask\n    float blur = map(-1.0, 1.0, 0.30, 0.5, sin(iTime * 4.0));\n    \n    // make the mask wave as function of uv.y\n    uv.x += sin(uv.y * 10.0 + iTime * 6.0) * 0.01;\n    \n    // shift the mask up a bit\n    uv.y -= 0.5;\n    \n    // taper start and end x components as a function of uv.y and taper attennuation\n    float taper = 0.05;    \n    float mask = bar(uv.x, -5.0 * -uv.y * taper, 5.0 * -uv.y * taper, blur / 5.0);\n    \n    //return vec3(mask); // for testing\n\treturn mask * (image - vec3(c) * .2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tfragColor = vec4(distortion(uv, fire(uv)), 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 68], [70, 70, 126, 126, 163], [165, 165, 215, 257, 333], [335, 335, 392, 392, 515], [517, 517, 537, 537, 1053], [1055, 1055, 1093, 1093, 1741], [1743, 1743, 1800, 1800, 1952]]}
{"id": "Ms2yzd", "name": "Refactoring Voxel Marcher", "author": "SudoNhim", "description": "Reworking my voxel marcher to make it smaller + saner + faster", "tags": ["voxels"], "likes": 21, "viewed": 440, "date": "1493546267", "time_retrieved": "2024-06-20T18:53:17.900709", "image_code": "#define PI 3.14159\n\n\n//[Scene]========================================\\\n\n#define VOXEL_ERROR 0\n#define VOXEL_NONE 1\n#define VOXEL_STONE 2\n\n#define EDGE_RADIUS 0.1\n\n// from Shane: Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001); // n = max(n*n, 0.001); // Etc.\n    n /= dot(n, vec3(1));\n    vec3 tx = textureLod(channel, p.zy*0.3, 0.0).xyz;\n    vec3 ty = textureLod(channel, p.xz*0.3+0.3, 0.0).xyz;\n    vec3 tz = textureLod(channel, p.xy*0.3+0.6, 0.0).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you see should correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\nbool isTerrainAt(ivec3 ip)\n{\n    vec3 v = tex3D(iChannel0, normalize(vec3(ip)), normalize(vec3(ip)));\n    return length(vec3(ip)) < 16.0 + 24.0*v.r;\n}\n\nint getTerrainTypeAt(ivec3 ip)\n{    \n    if (isTerrainAt(ip)) return VOXEL_STONE;\n    else return VOXEL_ERROR;\n}\n\nfloat dfVoxel(vec3 p, bvec3 adj)\n{\n    vec3 cube = vec3(0.5, 0.5, 0.5) + vec3(adj);\n    return length(max(abs(p)-(cube - EDGE_RADIUS),0.0)) - EDGE_RADIUS;\n}\n\nvec3 nrmVoxel(vec3 p, bvec3 adj) \n{\n    p += 0.01 * normalize(p);\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, adj);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, adj) - base,\n        dfVoxel(p+dd.yxy, adj) - base,\n        dfVoxel(p+dd.yyx, adj) - base\n    ));\n}\n\nbvec3 voxelAdjAt(ivec3 mapPos, vec3 p)\n{\n    ivec3 sp = ivec3(sign(p));\n    return bvec3(\n    \tisTerrainAt(mapPos + ivec3(sp.x, 0, 0)),\n    \tisTerrainAt(mapPos + ivec3(0, sp.y, 0)),\n        isTerrainAt(mapPos + ivec3(0, 0, sp.z)));\n}\n        \n//[/Scene]========================================/\n        \n        \n//[Voxel Marcher]=================================\\\n        \n#define MAX_HITS 4\n\nivec3 g_mapPos, g_rayStep;\nvec3 g_ro, g_rd, g_deltaDist, g_sideDist;\nivec3 g_hits[MAX_HITS];\nint g_nHits;\n        \nvoid voxelMarchInit(vec3 ro, vec3 rd)\n{\n    g_ro = ro;\n    g_rd = rd;\n\tg_mapPos = ivec3(floor(ro));\n    g_deltaDist = abs(vec3(length(rd)) / rd);\n    g_rayStep = ivec3(sign(rd));\n    g_sideDist = (sign(rd) * (vec3(g_mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * g_deltaDist;\n    g_nHits = 0;\n}\n        \nvoid voxelMarchStep()\n{\n    vec3 mi = step( g_sideDist.xyz, g_sideDist.yzx ); \n    vec3 mm = mi*(1.0-mi.zxy);\n    g_sideDist += mm * vec3(g_rayStep) / g_rd;\n    g_mapPos += ivec3(mm)*g_rayStep;\n    if (isTerrainAt(g_mapPos) && g_nHits < MAX_HITS)\n        g_hits[g_nHits++] = g_mapPos;\n}\n\nstruct VoxelHit\n{\n    int terrainType;\n\tivec3 mapCoord;\n    vec3 hitLocation;\n    vec3 normal;\n    float weight;\n};\n        \nstruct VoxelMarchResult\n{\n    VoxelHit first;\n    VoxelHit second;\n};\n        \nVoxelMarchResult voxelMarchResolve()\n{\n    VoxelMarchResult result;\n    result.first.terrainType = VOXEL_NONE;\n    result.second.terrainType == VOXEL_NONE;\n    \n    if (g_nHits == 0) return result;\n    \n    // for hits before the last hit, do distance field intersection\n\tfor (int i=0; i<MAX_HITS-1; i++)\n    {\n        if (i == g_nHits-1) break;\n        \n        VoxelHit hit;\n        hit.mapCoord = g_hits[i];\n        hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n        \n        // intersect with voxel cube\n        vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n        vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n        float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n        \n        // get adjacency\n        bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n        \n        // distance march\n        float diff; float mindiff = 1.0; float finaldist = 0.0;\n        for (int i=0; i<8; i++) {\n            vec3 p = g_ro + g_rd * dist;\n            diff = dfVoxel(p - hitVoxelCenter, adj);\n            if (diff < mindiff) {\n                mindiff = diff;\n                finaldist = dist;\n            }\n            dist += diff; \n        }\n        \n        float pixSizeApprox = 2.0/iResolution.x * finaldist; // the FOV is actually about 1 radian :)\n        hit.weight = smoothstep(pixSizeApprox, 0.0, mindiff - 0.01); // anti-alias blend\n        hit.hitLocation = g_ro + g_rd * finaldist - hitVoxelCenter;\n        hit.normal = nrmVoxel(hit.hitLocation, adj);\n        \n        if (hit.weight > 0.0)\n            if (result.first.terrainType == VOXEL_NONE)\n                result.first = hit;\n            else {\n                result.second = hit;\n                return result;\n            }\n    }\n    \n    VoxelHit hit;\n    hit.mapCoord = g_hits[g_nHits-1];\n    hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n    \n    // for the last hit, just do cube intersection\n    vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n    vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n    \n    hit.weight = 1.0;\n    hit.hitLocation = g_ro + g_rd * dist - hitVoxelCenter;\n    hit.normal = nrmVoxel(hit.hitLocation, adj);\n    \n    if (result.first.terrainType == VOXEL_NONE)\n        result.first = hit;\n    else\n        result.second = hit;\n    \n    return result;\n}\n        \n//[/Voxel Marcher]================================/\n\n\n//[Render]========================================\\\n\nvec3 g_lightDir;\n\nfloat calcAmbientOcclusion(VoxelHit hit)\n{\n    float ambientOcc = 0.0;\n    \n    // for each of the 28 voxels surrounding the hit voxel\n    for (int i=-1; i<=1; i++) for (int j=-1; j<=1; j++) for (int k=-1; k<=1; k++) {\n        if (i == 0 && j == 0 && k == 0) continue; // skip the hit voxel\n        ivec3 offset = ivec3(i, j, k);\n\n        if (dot(hit.normal, vec3(offset)) <= 0.0) continue; \n        \n        int terrainType=VOXEL_STONE;\n        if (isTerrainAt(hit.mapCoord + offset)) {\n            \n            // use the distance from just above the intersection to estimate occlusion\n            float dist = dfVoxel(hit.hitLocation + hit.normal*0.5 - vec3(offset), bvec3(false));\n            ambientOcc += smoothstep(1.0, 0.0, dist);\n        }\n    }\n    \n    return ambientOcc / 8.0;\n}\n\nvec3 renderVoxelHit(VoxelHit hit)\n{\n    vec3 v = tex3D(iChannel0, normalize(vec3(hit.mapCoord)), normalize(vec3(hit.mapCoord)));\n    v.g = v.r*v.r;\n    v.r = 0.3 + 0.7*v.r;\n    \n    vec3 color = vec3(1.0, 0.0, 0.0);\n    if (hit.terrainType == VOXEL_STONE)\n        color = v;\n    \n    float ambient = 0.4*(1.0-calcAmbientOcclusion(hit));\n    float diffuse = 0.6*max(dot(hit.normal, g_lightDir), 0.0);\n    \n    return (ambient + diffuse) * color;\n}\n\n//[/Render]=======================================/\n\n\n//[Main]==========================================\\\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 ro = vec3(sin(iTime*0.3)*40.0, sin(iTime*0.23)*24.0, cos(iTime*0.3)*40.0);\n    mat3 camMat = lookAt(ro, vec3(0.0), iTime*0.1);\n    vec3 rd = normalize(camMat*vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    \n    voxelMarchInit(ro, rd);\n    \n    for (int i=0; i<96; i++)\n        voxelMarchStep();\n    \n    VoxelMarchResult result = voxelMarchResolve();\n    \n    vec3 color = vec3(0.0);\n    g_lightDir = camMat*normalize(vec3(-1.0, -0.2, -.4));\n    if (result.first.terrainType != VOXEL_NONE)\n    {\n        color = renderVoxelHit(result.first);\n        if (result.second.terrainType != VOXEL_NONE)\n            color = mix(color, renderVoxelHit(result.second), 1.0-result.first.weight);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n\n//[/Main]=========================================/", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[164, 330, 376, 376, 977], [980, 980, 1008, 1008, 1130], [1132, 1132, 1164, 1164, 1244], [1246, 1246, 1280, 1280, 1402], [1404, 1404, 1439, 1439, 1687], [1689, 1689, 1729, 1729, 1922], [2002, 2198, 2237, 2237, 2487], [2497, 2497, 2520, 2520, 2783], [2989, 2989, 3027, 3027, 5503], [5567, 5638, 5680, 5680, 6428], [6430, 6430, 6465, 6465, 6876], [6932, 6985, 7036, 7036, 7227], [7229, 7229, 7286, 7286, 8072]]}
{"id": "Ms2yzy", "name": "Colorful Swirl 5 (HCL)", "author": "ccorcos", "description": "yup", "tags": ["color"], "likes": 2, "viewed": 135, "date": "1492666839", "time_retrieved": "2024-06-20T18:53:18.506788", "image_code": "// HCL colorspace:\n// https://www.shadertoy.com/view/Xt3SDs\nconst float X = 0.950470;\nconst float Y = 1.0;\nconst float Z = 1.088830;\n\nconst float t0 = 4.0 / 29.0;\nconst float t1 = 6.0 / 29.0;\nconst float t2 = 3.0 * t1 * t1;\nconst float t3 = t1 * t1 * t1;\n\nfloat lab_xyz(float t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfloat xyz_rgb(float x) {\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1.0 / 2.4) - 0.055;\n}\n\nvec3 lab2rgb(vec3 lab) {\n    float l = lab.x;\n    float a = lab.y;\n    float b = lab.z;\n    float y = (l + 16.0) / 116.0;\n    float x = y + a / 500.0;\n    float z = y - b / 200.0;\n    x = lab_xyz(x) * X;\n    y = lab_xyz(y) * Y;\n    z = lab_xyz(z) * Z;\n    return vec3(\n        xyz_rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z),\n\t\txyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n        xyz_rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n}\n\nvec3 hcl2lab(vec3 hcl) {\n    float h = hcl.x;\n    float c = hcl.y;\n    float l = hcl.z;\n    h = radians(h);\n    return vec3(l, cos(h) * c, sin(h) * c);\n}\n\nvec3 hcl2rgb(vec3 hcl) {\n    return lab2rgb(hcl2lab(hcl));\n}\n\nvec3 hcl(float h, float c, float l)\n{\n\treturn hcl2rgb(vec3(h * 360.0, c * 128.0, l * 100.0));\n}\n\n\n// GLSL Tutorial for reference:\n// https://www.shadertoy.com/view/Md23DV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Coordinate to width:\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n    // Number of tiles across\n    float tiles = 4.0;\n    \n    // Project point into that tile\n    vec2 tp = p * tiles;\n    \n    // Determine the spin of that tile\n    float sx = floor(mod(tp.x, 2.0)) * 2.0 - 1.0;\n    float sy = floor(mod(tp.y, 2.0)) * 2.0 - 1.0;\n    float spin = sx * sy;\n    \n    // Normalize the tile point\n    vec2 coord = mod(tp, 1.0) * iResolution.xy;\n     \n    // Just an alias for no reason\n    vec3 res = iResolution;\n            \n    // Polar coordinates:\n    // https://www.shadertoy.com/view/ltlXRf\n    vec2 rel = coord.xy - (res.xy / 2.0);\n    vec2 polar;\n    polar.y = sqrt(rel.x * rel.x + rel.y * rel.y);\n    polar.y /= res.x / 2.0;\n    polar.y = 1.0 - polar.y;\n\n    polar.x = atan(rel.y, rel.x);\n    polar.x -= 1.57079632679;\n    if(polar.x < 0.0){\n\t\tpolar.x += 6.28318530718;\n    }\n    polar.x /= 6.28318530718;\n    polar.x = 1.0 - polar.x;\n    \n    // Visualization params:\n    float speed = 0.3;\n    float arms = 1.0;\n    //float tightness = (sin(iTime * 2.0 / 3.0) + 1.0) * 0.5 * arms + 0.5;\n    float tightness = 1.5 * arms;\n    \n    // Compute swirl:\n    float hue = spin * polar.x * arms\n        + mod(arms, 2.0) * sy * 0.25\n        + iTime * speed\n        + spin * rel.x * rel.y / res.x / res.y * tightness;\n\n    // Compute rgb:\n    vec3 rgb = hcl(hue, 0.66, 0.76);\n    fragColor = vec4(rgb, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2yzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 256, 280, 280, 329], [331, 331, 355, 355, 432], [434, 434, 458, 458, 899], [901, 901, 925, 925, 1054], [1056, 1056, 1080, 1080, 1116], [1118, 1118, 1155, 1155, 1213], [1216, 1289, 1346, 1379, 2784]]}
{"id": "MsBcDz", "name": "STAD 0004", "author": "tpen", "description": "Shadertoy-a-day, entry #4!\n\nYou can probably guess by now that I like circles a lot.\n\nShadertoy version of http://imgur.com/gallery/R5Kty3B", "tags": ["procedural", "2d", "circles", "stad", "copyagif", "shadereveryday"], "likes": 5, "viewed": 137, "date": "1491598354", "time_retrieved": "2024-06-20T18:53:18.506788", "image_code": "// https://www.shadertoy.com/view/MsBcDz\n// based on http://imgur.com/gallery/R5Kty3B\n\nconst float NUMBER_OF_CIRCLES = 12.0;\nconst float PI = 3.14159265359;\nconst float MOTION_BLUR = 5.0;\nconst float MAX_T = 4.0;\n\nfloat circle(vec2 p, vec2 center, float exRadius, float inRadius)\n{\n    float d = distance(p, center);\n    float aaf = fwidth(d);\n    \n    return smoothstep(inRadius - aaf, inRadius, d)\n        -smoothstep(exRadius - aaf, exRadius, d);\n}\n\nfloat circleEx(vec2 p, vec2 center, float exRadius, float inRadius, float t, float speed, float minBorder)\n{\n    float regCircle = circle(p, center, exRadius, max(exRadius-minBorder,inRadius));\n\n    vec2 diff = p - center;\n    float angle = atan(diff.y, diff.x);\n    \n    float ret = 0.0;\n\n    float recExRadius = (exRadius-inRadius)*0.5;\n    float recInRadius = min(recExRadius-minBorder, recExRadius * inRadius / exRadius);\n    float xradius = inRadius + recExRadius;\n    \n    for (float i = 0.0; i < NUMBER_OF_CIRCLES; i++)\n    {\n        float a = -t*speed + i / NUMBER_OF_CIRCLES * PI * 2.0;\n       \n        vec2 cpos = center + vec2(cos(a), sin(a)) * xradius;\n        \n        float c = circle(p, cpos, recExRadius, recInRadius);\n        ret = max(ret, c);\n    }\n    \n    return mix(ret,regCircle,pow(smoothstep(3.0,4.0,speed),2.0));\n}\n\nfloat circleExMB(vec2 p, vec2 center, float exRadius, float inRadius, float t, float speed, float minBorder)\n{\n   \tfloat ret = 0.0;\n    for (float i = -MOTION_BLUR; i <= MOTION_BLUR; i += 1.0)\n    {\n        float t2 = t + (i / MOTION_BLUR) * speed * 0.1 * 0.05;\n        ret += circleEx(p, center, exRadius, inRadius, t2, speed, minBorder);\n    }\n    return ret / (MOTION_BLUR * 2.0 + 1.0);\n}\n\nfloat pattern(vec2 p, float t)\n{    \n    float factor = smoothstep(0.0, 1.0, (1.0 - (t / MAX_T)));\n    float radius = 5.0 * factor;\n    float width = 2.0/3.0 * factor;\n    float minBorder = 0.05;\n    radius = max(radius, width);\n    radius = max(radius,1.0/3.0);\n    width = max(width, minBorder);\n    float tx = t;\n    float speed = t;\n\tfloat d = circleExMB(p, vec2(0.0, 1.0/3.0 - radius), radius, radius - width, tx, speed, minBorder);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = mod(iTime * 0.5, MAX_T);\n    \n    float d = pattern(uv, time);\n    \n    fragColor = vec4(vec3(1.0 - d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsBcDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 214, 281, 281, 451], [453, 453, 561, 561, 1293], [1295, 1295, 1405, 1405, 1686], [1688, 1688, 1720, 1720, 2141], [2143, 2143, 2200, 2200, 2437]]}
{"id": "MsByWD", "name": "Colour Physics", "author": "akohdr", "description": "Experimenting with RGB intensity profile effect on visible spectrum.\nAnyone recommend a good treatise on colour models?", "tags": ["spectrum", "color", "colour"], "likes": 2, "viewed": 118, "date": "1492149248", "time_retrieved": "2024-06-20T18:53:18.979580", "image_code": "// Created by Andrew Wild - akohdr/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define BANDS 1.\n#define PI 3.141\n#define iT iTime/12.\n\n#define saw(a) 2.*mod((a)/(2.*PI),1.)-1.\n#define tri(a) 2.*abs(saw(a))-1.\n#define triN2(a) .810569*(dot(vec2(1,-.1111111),sin(a*vec2(1,3))))\n#define triN3(a) .810569*(dot(vec3(1,-.1111111,.04),sin(a*vec3(1,3,5))))\n#define triN4(a) .810569*(dot(vec4(1,-.1111111,.04,-.0204082),sin(a*vec4(1,3,5,7))))\n#define triN5(a) .810569*(sin(a)+dot(vec4(-.1111111,.04,-.0204082,.0123457),sin(a*vec4(3,5,7,9))))\n\nfloat triHarm(float a) {\n    // Harmonic Fourier Series form of triangle wave\n    // https://en.wikipedia.org/wiki/Triangle_wave\n    return .810569*(sin(a)\n      - .1111111*sin(3.*a)\n      + .04     *sin(5.*a)\n      - .0204082*sin(7.*a)\n      + .0123457*sin(9.*a) );\n}\n\nfloat f(float a) { \n// uncomment ONE for fixed shape\n//\treturn sin(a);\t\t\n//\treturn tri(a);\n//\treturn triN2(a);\n//\treturn triN3(a);\n//\treturn triN4(a);\n//\treturn triN5(a);\n//\treturn  saw(a);\n    float t = mod(iT,7.);\n    return t<1. ? sin(a) : \n           t<2. ? tri(a) : \n           t<3. ? triN2(a) : \n           t<4. ? triN3(a) : \n           t<5. ? triN4(a) : \n           t<6. ? triN5(a) : \n\t\t\t\t  saw(a) ; \n}\n\nfloat g(float a) { return 2.*PI*\n\tsin(a);\n//\ttri(a);\n//\tsaw(a);\n}\n\n//#define SAT(a) sin(a*iT)\t// temporal saturation\n#define SAT(a) 1.\t\t\t// fixed saturation\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n\tvec2 uv = 2.*PI * p.xy / iResolution.xy;\n//\tuv.x += 1./uv.y;\t\t// space distortion\n    float t = iT;\n    uv.x *= BANDS;\n    \n    k = vec4(\n        f(uv.x - g(t*3.))*SAT(1.),\n        f(uv.x - g(t*2.))*SAT(2.),\n        f(uv.x - g(t   ))*SAT(3.),\n        0);\n    \n//\tk = k/2.+.5;\t\t\t// comment for half cycle (black bars)\n//\tk = abs(k);  \t\t\t// rectify\n//\tk = 1.-log(k+2.);\n    \n\tk += step(abs(uv.y-k-vec4(1,3,5,0)),vec4(.02));\n\n//\tk = normalize(k);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsByWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 583, 607, 711, 851], [853, 853, 871, 1042, 1262], [1264, 1264, 1282, 1282, 1329], [1331, 1422, 1463, 1463, 1910]]}
{"id": "MsByzV", "name": "RGB Rainbow", "author": "defcon8", "description": "RGB, Rainbow, Fragment, Shader", "tags": ["rgbrainbow"], "likes": 8, "viewed": 295, "date": "1492801985", "time_retrieved": "2024-06-20T18:53:18.979580", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float frequency = 3.0;\n    \n    float index = uv.x + iTime + uv.y;\n    \n    float red = sin(frequency * index + 0.0) * 0.5 + 0.5;\n    float green = sin(frequency * index + 2.0) * 0.5 + 0.5;\n    float blue = sin(frequency * index + 4.0) * 0.5 + 0.5;\n    \n    fragColor = vec4(red,green,blue,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsByzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 403]]}
{"id": "MsjcRt", "name": "Organic", "author": "guil", "description": "Testing a new fractal formula.", "tags": ["2d", "fractal"], "likes": 8, "viewed": 246, "date": "1493398654", "time_retrieved": "2024-06-20T18:53:18.985605", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 rnn3(vec2 last) \n{\n\n        \n    float a = -1.4;\n    float b = -1.6;\n    float c = 1.0;\n    float d = -1.08+.2*sin(iTime);\n    float e = -0.17;\n    float f = -0.27;\n    \n\tvec2 next = vec2(0);\n\t\n    next.x = tanh(a * last.x + b * last.y) + tanh(last.x*last.x+e);\n    next.y = tanh(c * last.x + d * last.y) + tanh(last.y*last.y+f);\n    \n    return next;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 1.15*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\n\tvec2 z = p;\n\tfloat f = 4.;\n\tfloat g = 4.;\n    \n    \t\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tfloat w = .1*iTime+float(i)*.12457;\n\t\tvec2 z1 = vec2(2.*cos(w),2.*sin(w));\t\t   \n        z= rnn3(z)-p;\n\t\tf = min( f, abs(dot(z-p,z-p) ));\n\t\tg = min( g, dot(z-z1,z-z1));\n\t}\n\t\n\tf = 1.0+log(f)/15.0;\n\tg = 1.0+log(g)/8.0;\n\n\n\tfragColor = 1.-abs(vec4(g,f*f,f*f*f,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjcRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 88, 111, 111, 446], [451, 451, 508, 508, 926]]}
{"id": "MsjczK", "name": "Strobe Sphere", "author": "30000fps", "description": "2nd test – modified simple sphere shader with light, found on shadertoy", "tags": ["test", "sphere", "strobe"], "likes": 1, "viewed": 92, "date": "1492946694", "time_retrieved": "2024-06-20T18:53:18.985605", "image_code": "// i have no idea what i'm doing\n\n// light\nvec3 light = vec3(-1, -1, 1.6);\nvec3 light_color = vec3(.8, 1, 1);\n// sphere\nvec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\nvec3 sphere_color = vec3(1, 1, 1);\n// strobe speed\nfloat strobe_speed = 1.1;\n\n// draw sphere\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n\tfloat dt = dot(rdir, sp - rpos);\n\tif (dt < 0.0) {\n\t\treturn -1.0;\n\t}\n\tvec3 tmp = rpos - sp;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius) {\n\t\treturn -1.0;\n\t}\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\n// light, texture and color strobe \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tlight.xy = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n\tlight.y = -light.y;\n\tvec3 point; \n\tvec3 normal;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\n    // background color   \n\tfragColor = vec4(.0,.0,.0,.0);\n\t\n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n\t\n\tif (dist > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 5.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t\t\n        // textured sphere\n        // fragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture(iChannel0, vec2(u, v)).xyz;\n\t\t\n        //colored sphere\n        fragColor.xyz = vec3(dot(tmp, normal)) * light_color * vec3(0.2+0.5*cos(iTime*strobe_speed),0.5+0.5*sin(iTime*strobe_speed),0.6+0.5*sin(iTime*strobe_speed));\n\n    }\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4d2GDt", "previewfilepath": "https://soundcloud.com/logic-moon/im-in-your-veins", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/logic-moon/im-in-your-veins", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjczK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[252, 267, 366, 366, 682], [684, 720, 777, 777, 1706]]}
{"id": "Msjczt", "name": "Circular band Spin", "author": "RogB", "description": "based on the circular spins in the Amiga Demo 'State Of The Art'\nhttps://www.youtube.com/watch?v=89wq5EoXy-0\n\nsadly, no dancing polygon girls.\n\n(im not really a coder, just an enthusiastic artist, be gentle ;-) )", "tags": ["2d", "amiga", "demo"], "likes": 2, "viewed": 121, "date": "1493414080", "time_retrieved": "2024-06-20T18:53:18.985605", "image_code": "vec3 circbands(vec2 uv, vec2 middle2)\n{\n    float dist2 = distance(uv, middle2)*30.0;\n    vec3 col2 = vec3(dist2);\n    col2 = fract(col2);\n    col2 = step(0.5,col2);\n    col2 = 1.0-col2;\n    return col2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 middle1 = vec2(0.5+(sin(iTime)*0.51),0.5 +(cos(iTime)*0.5));\n    vec2 middle2 = vec2(0.5+(cos(iTime)*0.13),0.5 +(sin(iTime)*0.5));\n        \n    vec3 col = vec3(circbands(uv, middle1));\n    vec3 col2 = vec3(circbands(uv, middle2));\n   \n    \n    col -= col2;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msjczt.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 39, 39, 205], [208, 208, 265, 265, 612]]}
{"id": "Msjczw", "name": "Rotating Kernels", "author": "balkhan", "description": "toying with volumetric light from sebH. ", "tags": ["3d", "raymarching", "volumetric"], "likes": 22, "viewed": 303, "date": "1492201645", "time_retrieved": "2024-06-20T18:53:18.998560", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t100\n#define E\t\t0.001\n\n#define LPOS\tvec3(0., 0., 0.)\n#define L2\t\t1.0*vec3(st*4.,0.,ct*4.)\n\n//#define CAM_SHAKE\n\nvoid\trotate(inout vec2 v, float angle);\nfloat\tsdTorus( vec3 p, vec2 t );\nfloat\tsdCappedCylinder( vec3 p, vec2 h );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\n// --globals-- //\nvec3\th;\nfloat\tg; //coloring id\nfloat\tt; // time\nfloat\ta; // angle\nvec3\tss;// tmp var recording old ray position\nvec3\tsss;\nfloat\tmind;\nfloat\tmine;\nfloat\tminf;\nvec3\tsuper_uv;\nfloat\tst;\nfloat\tct;\n// --globals-- //\n\nconst vec3\tlightCol = vec3(1.,.7,.51);\nmat2\t\trot_t;\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(LPOS-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n        \tlightCol * 1.0/(distanceToL*distanceToL)\n           +lightCol * 1.0/(distanceToL2*distanceToL2)\n        \t)*.5;\n}\n\n// ------------volumetric light----------- //\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    mine = 1e5;\n    t = iTime*.5;\n    st = sin(t);\n    ct = cos(t);\n    rot_t = mat2(ct, st, -st, ct );\n\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h = vec3(0.);\n    \n    vec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 7.50);\n    #ifdef CAM_SHAKE\n    rotate(dir.xz, sin(t*40.)*.06125);\n    #endif\n    vec2\tinter = (march(pos, dir));\n\n    o.xyz = blackbody(((h.x+h.y+h.z) )*100.);\n    o.xyz += vec3(abs(sin(t+1.04+g)), abs(sin(t+2.09+g)), abs(sin(t+3.14+g)))*(1.-inter.y*.067515);\n    o.xyz += h*.125;\n    o.xyz *= (1.25-length(uv)*1.); // vignette\n}\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tde_0(vec3 p) // Spaghettis\n{\n\tfloat\tming = 1e5;\n\tfloat\ta = ( (t+p.z *.5)  ) * 4.;\n\tvec3\tpr = p;\n\n    pr.z *= 2.;\n\trotate(pr.xy, a);\n    ming = max(length( abs(pr.xy)-.51*(p.z+2.1)) -.5, .0051 );\n    ming = min(ming, max(length( abs(pr.xy)+.51*(p.z-2.1) ) -.5, .00051 ) );\n    ming = max(ming, sdCappedCylinder(p-vec3(0.,0.,0.), vec2(1.5, 2.4) ) );\n\treturn (ming);\n}\n\nfloat\tscene(vec3 p)\n{\n    mind = 1e5;\n\n\tmine = p.z+8.;\n    mine = min(mine, -(p.z)+8.);\n    mine = min(mine, (p.x)+8.);\n    mine = min(mine, -(p.x)+8.);\n    mine = min(mine, (p.y)+4.);\n    mine = min(mine, -(p.y)+4.);\n    mine = min(mine, length(p)-.1);\n\tvec3\tpole = vec3(p.x,p.z,p.y);\n    pole.xy *= mix(1., .8, abs(sin(t*8.)) );\n\tmine = min(mine, de_0(pole) );\n\n    minf = sdTorus(vec3(p.z,p.y,p.x), vec2(.58,.55) )\n        \t\t\t-sdCy(vec3(p.x,p.y,p.z), vec2(1.6,.85) \n                  );\n    mind = max(minf,-sdCy(vec3(p.z,p.y,p.x)*.65, vec2(.75,1.5) ) );\n    sss = p;\n    p-= L2;\n    vec3 tata = p;\n    rotate(tata.xy, +t*6.28+6.28 );\n    rotate(p.xy, +t*6.28 );\n    vec3 tracker;\n    tracker.x =\tmax(sdTorus(vec3(tata.z,tata.y,tata.x), vec2(.521,.521) ), -sdCy(vec3(tata.z,tata.y,tata.x), vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5)*abs(tata.x*.5)\n        \t\t\t;\n    if (tracker.x <= E)\n\t    ss = tata;\n    tata = p;\n    rotate(tata.zx, +t*6.28+4.16 );\n    rotate(p.zx, +t*6.28 );\n    tracker.y =\tmax(sdTorus(vec3(tata.x,tata.y,tata.z)*.75, vec2(.521,.521) ), -sdCy(vec3(tata.x,tata.y,tata.z)*.75, vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5*.75)*abs(tata.x*.5*.75)\n        \t\t\t;\n\tif (tracker.y <= E)\n\t    ss = tata;\n    tata = p;\n    rotate(tata.yz, +t*6.28+2.09 );\n    rotate(p.yz, +t*6.28 );\n    tracker.z =\tmax(sdTorus(vec3(tata.z,tata.x,tata.y)*.5, vec2(.521,.521) ), -sdCy(vec3(tata.z,tata.x,tata.y)*.5, vec2(.61,1.5) ))\n    \t\t\t\t+ abs(tata.y*1.5*.5)*abs(tata.x*.5*.5)\n        \t\t\t;\n    mind = min(mind, tracker.x);\n    mind = min(mind, tracker.y);\n    mind = min(mind, tracker.z);\n    mind = min(mind, length(p)-.1);\n    if (tracker.z <= E)\n\t    ss = p;\n    mind = min(mine, mind);\n\n    return mind;\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\n    for (int i = 1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        p.xy *= rot_t;\n        p.zx *= rot_t;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.251125;\n        if (dist.x < E || dist.y > 20.)\n        {\n            if(dist.x == minf)\n\t            p=super_uv=sss;\n            if(dist.x != minf && dist.x != mine)\n                p=ss;\n\t        g +=  (step(sin(20.*abs(p.y) ), .5) \n                  + step(sin(20.*abs(p.x) ), .5)\n                  + step(sin(20.*abs(p.z) ), .5)\n                 );\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msjczw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[854, 1076, 1104, 1104, 1429], [1546, 1593, 1626, 1626, 1844], [1846, 1893, 1933, 1933, 2512], [2514, 2514, 2544, 2544, 2643], [2645, 2645, 2679, 2679, 3016], [3018, 3018, 3039, 3039, 4722], [4724, 4724, 4756, 4756, 5471], [5473, 5487, 5520, 5520, 5587], [5589, 5589, 5631, 5631, 5729], [5732, 5732, 5754, 5754, 5961], [5963, 5963, 6003, 6003, 6078]]}
{"id": "MsjyRK", "name": "DNA Worms", "author": "wolf", "description": "Semi-accurate B-DNA model with the worms shader created by iq: https://www.shadertoy.com/view/XsjXR1", "tags": ["3d", "raymarching", "worms", "dna"], "likes": 7, "viewed": 671, "date": "1492900124", "time_retrieved": "2024-06-20T18:53:21.076759", "image_code": "// DNA Worms\n// combination of a couple things\n// DNA model - me, used wikipedia and a few other sources to get the numbers right.\n// (DNA-B)\n\n// worms:\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nvec2  sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3  opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n \n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n }\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n// Smooth Min\n// http://www.iquilezles.org/www/articles/smin/smin.htm\n\n// Min Polynomial\n// ========================================\nfloat sMinP( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// Min Exponential\n// ========================================\nfloat sMinE( float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// Min Power\n// ========================================\nfloat sMin( float a, float b, float k ) {\n    a = pow( a, k );\n    b = pow( b, k );\n    return pow( (a*b) / (a+b), 1.0/k );\n}\n\nmat4 Rot4X(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( 1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Y matrix\n// angle in radians\n// ========================================\nmat4 Rot4Y(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( c, 0, s, 0,\n                0, 1, 0, 0,\n                -s, 0, c, 0,\n                0, 0, 0, 1 );\n}\n\n// Return 4x4 rotation Z matrix\n// angle in radians\n// ========================================\nmat4 Rot4Z(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\n// if no support for GLSL 1.2+\n//     #version 120\n// ========================================\nmat4 transposeM4(in mat4 m ) {\n    vec4 r0 = m[0];\n    vec4 r1 = m[1];\n    vec4 r2 = m[2];\n    vec4 r3 = m[3];\n\n    mat4 t = mat4(\n        vec4( r0.x, r1.x, r2.x, r3.x ),\n        vec4( r0.y, r1.y, r2.y, r3.y ),\n        vec4( r0.z, r1.z, r2.z, r3.z ),\n        vec4( r0.w, r1.w, r2.w, r3.w )\n    );\n    return t;\n}\n\n\n// Note: m must already be inverted!\n// TODO: invert(m) transpose(m)\n// Op Rotation / Translation\n// ========================================\nvec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n    return (transposeM4(m)*vec4(p,1.0)).xyz;\n}\n\n// angstroms to world units\n#define ANG_TO_WORLD 0.1\n// angstroms\n#define DNA_RADIUS 10.72 * ANG_TO_WORLD\n\n#define RISE 3.32 * ANG_TO_WORLD\n\n#define OFFSET 21.44 * ANG_TO_WORLD\n// angstroms\n\n//#define ROTATION_PER_BP -0.5986479 / 3.32 / ANG_TO_WORLD\n#define ROTATION_PER_BP -0.180315633 / ANG_TO_WORLD\n\n#define BP_APOTHEM 3.84170 * ANG_TO_WORLD\n\n#define BP_WIDTH 20.01596 * ANG_TO_WORLD / 2.0\n\nvec3 opDNATwist(vec3 p) // 20 angs wide\n{\n    float c = cos(ROTATION_PER_BP * p.y); // angs / 10\n    float s = sin(ROTATION_PER_BP * p.y);\n    mat2 m = mat2(c, -s, s, c); // rotation matrix\n \treturn vec3(m * p.xz, p.y);\n}\n\nfloat mapDNA(vec3 pos) {\n    // dna base pair\n    float dnaBasePairs = sdBox(\n        opRep(\n            opDNATwist(pos - vec3(0, - RISE / 2.0, 0)) + vec3(BP_APOTHEM, 0, iTime * 1.0),\n            vec3(0, 0, RISE)\n        ),\n        vec3(.07, BP_WIDTH, .1)\n    );\n    \n    vec2 strands = opU(\n        vec2(sdBox(opDNATwist(pos) - vec3(0, DNA_RADIUS, 0), vec3(.225, .125, 100)), 200.),\n        vec2(sdBox(opDNATwist(pos + vec3(0, OFFSET, 0)) - vec3(0, DNA_RADIUS, 0.0), vec3(.225, .125, 100)), 100.0)\n    );\n    \n    \n    vec2 res = opU(\n        strands,\n        vec2(dnaBasePairs, 40.0)\n    );\n    \n    return res[0];\n}\n\nvec3 map( vec3 p )\n{\n    vec2  id = floor( (p.xz+1.0)/5.0 );\n    float ph = hash(id+113.1);\n    float ve = hash(id);\n\n    p.xz = mod( p.xz+1.0, 5.0 ) - 2.50;\n    p.xz += 0.5*cos( 2.0*ve*iTime + (p.y+ph)*vec2(0.53,0.32) - vec2(1.57,0.0) );\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(p.y-ve*iTime*ve+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(p.y-ve*iTime*ve+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(p.y-ve*iTime*ve+4.0);\n    \n    vec2 h1 = sdSegment( p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment( p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment( p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n\n    return opU( opU( vec3(h1.x-0.15*(0.8+0.2*sin(200.0*h1.y)), ve + 0.000, h1.y), \n                     vec3(h2.x-0.15*(0.8+0.2*sin(200.0*h2.y)), ve + 0.015, h2.y) ), \n                     vec3(mapDNA(p), ve + 0.030, h3.y) );\n\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float px, const float maxdist )\n{\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    vec3 h = map(ro + t*rd);\n        res = vec3( t, h.yz );\n        if( h.x<(px*t) || t>maxdist ) break;\n        t += min( h.x, 0.5 )*0.7;\n    }\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.003;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.1;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.0*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += h-d;\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float px )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    vec3 res = intersect( ro, rd, px, maxdist );\n    if( res.x < maxdist )\n    {\n        vec3  pos = ro + res.x*rd;\n        vec3  nor = calcNormal( pos );\n        float occ = calcOcc( pos, nor );\n\n        col = 0.5 + 0.5*cos( res.y*30.0 + vec3(0.0,4.4,4.0) );\n        col *= 0.5 + 1.5*nor.y;\n        col += clamp(1.0+dot(rd,nor),0.0,1.0);\n        float u = 800.0*res.z - sin(res.y)*iTime;\n        col *= 0.95 + 0.05*cos( u + 3.1416*cos(1.5*u + 3.1416*cos(3.0*u)) + vec3(0.0,1.0,2.0) );\n        col *= vec3(1.5,1.0,0.7);\n        col *= occ;\n\n        float fl = mod( (0.5+cos(2.0+res.y*47.0))*iTime + res.y*7.0, 4.0 )/4.0;\n        col *= 2.5 - 1.5*smoothstep(0.02,0.04,abs(res.z-fl));\n        \n        col *= exp( -0.1*res.x );\n        col *= 1.0 - smoothstep( 20.0, 30.0, res.x );\n    }\n    \n    return pow( col, vec3(0.5,1.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec2 q = fragCoord.xy/iResolution.xy;\n    \n\tvec3  ro = vec3(0.6,1.4,1.2);\n\tvec3  ta = vec3(-2.0,1.0,0.0);\n    float fl = 3.0;\n    vec3  ww = normalize( ta - ro);\n    vec3  uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3  vv = normalize( cross(ww,uu) );\n    vec3  rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\n    vec3 col = render( ro, rd, 1.0/(iResolution.y*fl) );\n    \n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 rd = fragRayDir;\n    vec3 col = render( ro, rd, 0.001 );\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjyRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[143, 260, 282, 282, 343], [344, 344, 369, 369, 402], [403, 403, 433, 433, 464], [466, 466, 517, 517, 645], [647, 647, 672, 672, 687], [689, 689, 724, 724, 750], [752, 752, 783, 783, 874], [876, 876, 919, 919, 979], [981, 981, 1026, 1026, 1068], [1070, 1070, 1103, 1103, 1158], [1160, 1160, 1196, 1196, 1438], [1440, 1440, 1492, 1492, 1606], [1608, 1608, 1644, 1644, 1892], [1894, 1894, 1930, 1930, 2029], [2031, 2031, 2069, 2069, 2238], [2240, 2240, 2312, 2312, 2527], [2529, 2529, 2596, 2635, 3007], [3009, 3009, 3034, 3034, 3071], [3073, 3073, 3098, 3098, 3156], [3158, 3158, 3183, 3183, 3248], [3250, 3250, 3285, 3285, 3356], [3358, 3358, 3393, 3393, 3464], [3466, 3466, 3503, 3503, 3556], [3558, 3628, 3661, 3661, 3687], [3689, 3689, 3719, 3719, 3752], [3754, 3754, 3784, 3784, 3813], [3815, 3815, 3839, 3839, 3971], [4044, 4106, 4148, 4148, 4241], [4243, 4306, 4347, 4347, 4418], [4420, 4477, 4518, 4518, 4602], [4604, 4604, 4626, 4626, 4791], [4793, 4889, 4911, 4911, 5077], [5079, 5175, 5197, 5197, 5350], [5352, 5447, 5477, 5477, 5759], [5762, 5904, 5933, 5968, 6015], [6208, 6411, 6452, 6452, 6632], [6634, 6634, 6658, 6679, 7252], [7254, 7254, 7274, 7274, 8133], [8135, 8135, 8211, 8211, 8455], [8457, 8457, 8489, 8489, 8695], [8697, 8697, 8740, 8740, 9067], [9069, 9069, 9121, 9121, 10019], [10021, 10021, 10078, 10078, 10618], [10620, 10620, 10714, 10714, 10868]]}
{"id": "MsjyzG", "name": "Super Basic Mandelbrot", "author": "Karambit", "description": "Watching an old Numberphile video i decided to give it a go.", "tags": ["fractal", "mandelbrot", "b"], "likes": 5, "viewed": 1214, "date": "1492626663", "time_retrieved": "2024-06-20T18:53:21.482915", "image_code": "/********************************\n\nVery basic Mandelbrot fractal rendering.\n\nIt uses the smooth iteration count as described here: \nhttp://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n\n********************************/\n\n#define MAX_ITERATIONS 128\n#define B 4.0\n#define ZOOM 1.15\n#define POSITION vec2(-0.5, 0.0)\n\n//Function to square complex numbers\nvec2 ipow2(vec2 i)\n{\n    return vec2(i.x*i.x - i.y*i.y, 2.0*i.x*i.y);\n}\n\nvec2 ipow3 (vec2 i)\n{\n    return vec2 ( pow(i.x, 3.0) - 3.0 * i.x * pow(i.y, 2.0), \n                 3.0 *pow(i.x, 2.0) * i.y - pow(i.y, 3.0));\n}\n\nvec2 ipow4 (vec2 i)\n{\n    return vec2(pow(i.x, 4.0) - 6.0 * pow(i.x, 2.0) * pow(i.y, 2.0) + pow(i.y, 4.0),\n               4.0 * pow(i.x, 3.0) * i.y - 4.0 * i.x * pow(i.y, 3.0));\n}\n\n//Fractal calculation loop\nfloat mandelbrot(in vec2 c, inout vec2 z){\n    //Don't use floating point numbers in a for loop, it's evil.\n    float t;\n    for(int i=0;i<MAX_ITERATIONS;++i){\n        z = ipow2(z) + c;\n        //Does it go off bounds?\n        if( dot(z,z)>B*B ) {\n            break;\n        }\n        t+=1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / iResolution.xy\n        \t\t* 2.0 - 1.0)\n        \t\t* vec2(iResolution.x/iResolution.y, 1.0);\n    \n    float time = iTime;\n    \n    //Center the uv coordinates\n    vec2 c = uv * ZOOM + POSITION;\n    vec3 col = vec3(0.0);\n    vec2 z = vec2(0.0);\n    \n\tfloat f = mandelbrot(c, z);\n    \n    //Smooth iteration count by Iñigo Quilez\n    f = f - log2(log2(dot(z,z))) + 4.0;\n    \n    //color gradient\n    col = vec3(cos(f*0.3+time), sin(f*0.2+time), cos(f*0.5+time));\n    \n\tfragColor = vec4(normalize(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsjyzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[329, 366, 386, 386, 437], [439, 439, 460, 460, 584], [586, 586, 607, 607, 765], [767, 794, 836, 901, 1113], [1115, 1115, 1171, 1171, 1705]]}
{"id": "Msjyzy", "name": "LAB Colorspace", "author": "ccorcos", "description": "yup", "tags": ["color"], "likes": 2, "viewed": 98, "date": "1492663644", "time_retrieved": "2024-06-20T18:53:21.919158", "image_code": "// LAB colorspace\n// https://gist.github.com/mattatz/44f081cac87e2f7c8980\nvec3 rgb2xyz( in vec3 c )\n{\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    const mat3 mat = mat3(\n\t\t0.4124, 0.3576, 0.1805,\n        0.2126, 0.7152, 0.0722,\n        0.0193, 0.1192, 0.9505 \n\t);\n    return 100.0 * (mat * tmp);\n}\n\nvec3 xyz2lab( in vec3 c )\n{\n    vec3 n = c / vec3(95.047, 100, 108.883);\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab( in vec3 c )\n{\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 lab2xyz( in vec3 c )\n{\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb( in vec3 c )\n{\n\tconst mat3 mat = mat3(\n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n\t);\n    vec3 v = mat * (c / 100.0);\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb( in vec3 c ) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n\n// GLSL Tutorial for reference:\n// https://www.shadertoy.com/view/Md23DV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Coordinate to width:\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n    float l = (sin(iTime) + 1.0) / 2.0;\n    float a = p.x;\n    float b = p.y;\n        \n    // Compute rgb:\n    vec3 rgb = lab2rgb(vec3(l, a, b));\n    fragColor = vec4(rgb, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msjyzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 74, 101, 101, 519], [521, 521, 548, 548, 967], [969, 969, 996, 996, 1133], [1135, 1135, 1162, 1162, 1550], [1552, 1552, 1579, 1579, 2048], [2050, 2050, 2077, 2077, 2185], [2188, 2261, 2318, 2351, 2591]]}
{"id": "MsScDz", "name": " Books and Stairs patched?", "author": "ollj", "description": "left mouse button == mouselook , just pause time.\n\nhttps://www.shadertoy.com/view/4djczw \nis closer to its source that worked on linux.\nwhile this one solves for windows?", "tags": ["raymarch", "library", "babel"], "likes": 6, "viewed": 551, "date": "1491585828", "time_retrieved": "2024-06-20T18:53:24.992249", "image_code": "//this is pretty much a duplicate backup of \n//https://www.shadertoy.com/view/4djczw\n//that i made out of pride for fixing one incompatibility with non-linux systems\n//most likely caused by mod(a,b) for b<=0;\n//you can undo my fix by replacing all \"max(0.5,szGr.y)\" with \"szGr.y\"\n//and you will get some strange overstepping, but not on linux.\n//this patch is lousy and may be insufficient or inefficient.\n//such is patching someone elses code.\n\n\n//https://www.shadertoy.com/view/4djczw \n//worked well on linux, but not well on windows.\n//https://www.shadertoy.com/view/MsScDz ==.this\n//seems to work well for windows, but not on linux.\n\n//this dichoonomy makes debugging hard.\n\n//to be a true \"library of babel\"\n//\n//this needs klickable books filled with content that equals any book's position, \n//if you encode position and content to binary in a unique non-hash address.\n//\n//a single 16 bit float is insufficient to place a camera in it \n//(and to address all books in it)\n//so this needs a buffer that stores an xyz camera position, bitwise, ina rgba array\n//of at least 1024x1024 pixels.\n//i did calculations for all that, but never finished a 3d model for it as it exists here.\n\n//this needs a freely movable camera\n//\n//this needs more \"pony\" \n//to match the story to the youtube fanfiction video \n//\"library of discord\"\n\n//increased how far you can look down\n//and found more error cases when increasing how far i could look up:\n//\n//all that lookUp sets is how far i can rotate the camera up:\n//and setting this value >.3 causes the same damn overstepping errors again!\nconst float lookUp=.3;\n//all while lookDown is just fine being >.4, allowing you to look down into the abyss:\nconst float lookDown=.4;\n//\n//danit i am onto something new in regards to a bug in this code.\n\n\n// \"Books and Stairs\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 HexCellId (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\nconst float sqrt3 = 1.73205;\n\nvec3 inCell;\nvec2 szGr, bsa[4];\nfloat dstFar, tCur, rdRm, htRm, wlThk, rdHol, spShf, htShf, hRot;\nint idObj;\nbool isHole;\nconst int idRm = 1, idCol = 2, idRal = 3, idChr = 4, idBks = 5, idShlf = 6,\n   idStp = 7, idLt = 8;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dMin, r, a, da, dy, ah6, a6h, wdDor, wdShf, db, rm, stDir, fns;\n  const int ns = 16;\n  dMin = dstFar;\n  wdDor = 0.15 * szGr.x;\n  wdShf = 0.06 * rdRm;\n  q = p;\n  inCell.xy = HexCellId (q.xz / szGr.x);\n  inCell.z = floor (q.y / (2. * szGr.y) + 0.5);\n  isHole = (all (equal (mod (inCell.xy, 2.), vec2 (0.))));\n  q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  ah6 = 2. * pi * floor (6. * a + 0.5) / 6.;\n  a6h = 2. * pi * (floor (6. * a) + 0.5) / 6.;\n  rm = 1.5 - abs (r - 0.5 * (rdHol + rdRm - wlThk));\n    \n  if (isHole) {\n    qq = q;\n    fns = float (ns);\n    stDir = 1. - 2. * step (1., mod (floor (6. * a), 2.));\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (3. * a) - stDir * 0.5 + 0.5) / 3. +\n       stDir * (0.5 * fns / (fns + 1.) + 0.8/12.) / 12.));\n    qq.y = mod (qq.y + max(0.5,szGr.y), 2. *max(0.5,szGr.y)) - max(0.5,szGr.y);\n    qq.y -= - htRm + 0.2;\n    da = stDir * 2. * pi / (2. * 6. * fns);\n    dy = (2. * max(0.5,szGr.y) - 0.5) / fns;\n    d = dMin;\n    for (int j = 0; j < ns; j ++) {\n      d = min (d, - min (min (rm, 0.3 - abs (qq.y)), 0.15 - abs (qq.z)));\n      qq.xz = Rot2D (qq.xz, da);\n      qq.y -= dy;\n    }\n    if (d < dMin) { dMin = d;  idObj = idStp; }\n  }\n  q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ah6);\n  d = min (max (abs (r - rdRm) - wlThk, wdDor - abs (qq.z)),\n     htRm - abs (qq.y));\n  if (isHole) {\n    d = max (d, rdHol - (0.05 + r));\n    qq.z = abs (qq.z);\n    db = min (rm, dot (qq.xz, bsa[2]));\n    d = min (max (db, d), max (db, - min (min (rm + 0.2, 0.1 -\n       abs (qq.y + htRm - 0.1)), dot (qq.xz, bsa[3]))));\n  }\n  if (d < dMin) {dMin = d;  idObj = idRm; }\n  if (isHole) {\n    d = length (max (abs (vec2 (r - rdHol, abs (abs (q.y + 0.625 * htRm) -\n       0.15 * htRm) - 0.075 * htRm)) - vec2 (0.06, 0.04), 0.)) - 0.005;\n    qq = q;  qq.y -= - htRm + 0.3 * htRm;\n    qq.xz = Rot2D (qq.xz, 2. * pi * ((floor (18. * a) + 0.5) / 18.));\n    qq.x += rdHol;\n    d = min (d, PrCylDf (qq.xzy, 0.05, 0.3 * htRm));\n    if (d < dMin) { dMin = d;  idObj = idRal; }\n  } else { \n    qq = q;  qq.y -= 0.7 - htRm;\n    d = PrRCylDf (qq.xzy, 2.5, 0.1, 0.7);\n    if (d < dMin) { dMin = d;  idObj = idChr; }\n    qq = q;\n    qq.xz = Rot2D (qq.xz, a6h);\n    qq.z = abs (qq.z);\n    d = max (abs (r - rdRm + wlThk + 1. * wdShf) - 0.5 * wdShf, dot (qq.xz, bsa[1]));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idBks; }\n    d = max (abs (r - rdRm + wlThk + wdShf) - wdShf, dot (qq.xz, bsa[0]));\n    d = max (d, min (abs (mod (qq.y + 0.5 * spShf, spShf) - 0.5 * spShf) - htShf,\n       - dot (qq.xz, bsa[1])));\n    d = max (d, abs (qq.y) - htRm + spShf);\n    if (d < dMin) {dMin = d;  idObj = idShlf; }\n    qq.x -= - 0.85 * rdRm;\n    qq.z -= 0.29 * rdRm;\n    d = PrCylDf (qq.xzy, 0.25, htRm);\n    if (d < dMin) {dMin = d;  idObj = idCol; }\n  }\n  qq = q;\n  qq.xz = Rot2D (qq.xz, ((! isHole) ? a6h : ah6));\n  qq.xy -= vec2 (- 0.5 * (rdHol + rdRm - wlThk), htRm - 0.04);\n  if (! isHole) qq.z = abs (qq.z) - 1.7;\n  d = PrCylDf (qq.xzy, 0.3, 0.03);\n  if (d < dMin) {dMin = d;  idObj = idLt; }\n  if (! isHole) {\n    qq = q;\n    qq.y -= htRm + 1.7;\n    d = max (PrSphDf (qq, 2.), q.y - htRm);\n    if (d < dMin) {dMin = d;  idObj = idLt; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.8 * mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return 0.5 * sqrt3 * ((1. - p.x)  + 0.5 * min (p.x - sqrt3 * p.y, 0.));\n}\n\nvec3 HexGrdCol (vec2 p)\n{\n  p.y *= 2./sqrt3;\n  p.x += 0.5 * mod (floor (p.y), 2.);\n  p = abs (fract (p) - 0.5);\n  return mix (vec3 (0.3, 0.3, 0.25), vec3 (0.4, 0.5, 0.2),\n     smoothstep (0.05, 0.15, abs (p.x + max (p.x, 1.5 * p.y) - 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, ltVec, col, vn, q, ld, bgCol;\n  vec2 gbRm, gbBk, g, bt;\n  float dstObj, r, a, bh, s, cRm, fr, spec, ao, sh, atten;\n  bool isLit;\n  wlThk = 0.04 * szGr.x;\n  rdRm = szGr.x - 0.7 * wlThk;\n  rdHol = 0.5 * rdRm;\n  htRm = 0.93 * szGr.y;\n  spShf = htRm / 3.;\n  htShf = 0.05 * spShf;\n  float cbc[4];\n  cbc[0] = 1.1;  cbc[1] = 1.06;  cbc[2] = 1.;  cbc[3] = 0.92;\n  for (int k = 0; k < 4; k ++) \n     bsa[k] = vec2 (sin (cbc[k] * 2. * pi / 24.), cos (cbc[k] * 2. * pi / 24.));\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  isLit = true;\n  bgCol = (abs (rd.y) < 0.5) ? 0.5 * vec3 (0.7, 0.5, 0.) : ((rd.y > 0.) ?\n     vec3 (0.5, 0.5, 0.55) : vec3 (0., 0., 0.2));\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.xz -= vec2 (2. * inCell.x + inCell.y, sqrt3 * inCell.y) * szGr.x;\n    q.y = mod (q.y + szGr.y, 2. * szGr.y) - szGr.y;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    gbRm = inCell.xy + inCell.z;\n    cRm = Noisefv2 (gbRm * vec2 (17., 11.));\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idRm) {\n      col = vec3 (0.8, 0.6, 0.5);\n      if (vn.y < -0.99) {\n        isLit = false;\n        if (r < 0.99 * rdRm) {\n          if (isHole) col = vec3 (0.8, 0.8, 0.6) * (1. - 0.3 * smoothstep (0.4, 3.,\n             length (vec2 (15. * (0.5 - mod (6. * a + 0.5, 1.)),\n             r - 0.5 * (rdHol + rdRm - wlThk)))));\n          else col = mix (vec3 (0.2, 0.2, 0.5), vec3 (0.4, 0.4, 0.7),\n             smoothstep (0.1, 0.8, r / rdRm)) *\n             (1. - 0.05 * SmoothBump (0.3, 0.6, 0.1, mod (10. * r / rdRm, 1.)));\n        } else col = vec3 (0.4, 0.4, 0.7);\n      } else if (abs (vn.y) < 0.01) {\n        if (r > rdRm - 0.9 * wlThk) {\n          col = vec3 (0.4, 0.4, 0.8) * (0.6 + 0.3 * q.y / htRm);\n          isLit = false;\n        } else if (isHole) {\n          if (q.y > - htRm + 0.001 && r > rdRm - wlThk - 0.01) {\n            q.xy = vec2 (10. * (mod (6. * a, 1.) - 0.5), 0.5 * q.y);\n            col = HexGrdCol (6. * q.xy);\n            if (abs (q.x) < 0.5 && abs (q.y) < 0.15) {\n              if (ShowInt (vec2 (q.x - 0.5, q.y + 0.12),\n                 vec2 (1., 0.25), 4., mod (4242. + inCell.z, 10000.)) != 0.) {\n                col = vec3 (0.7, 0.7, 0.);\n                isLit = false;\n              }\n            }\n          } else if (q.y < - htRm && r > rdHol + 0.01) {\n            col = vec3 (0.2, 0.2, 1.);\n            isLit = false;\n          } else if (r < rdHol + 0.01) {\n            col = vec3 (0.5, 0.7, 0.3) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.01,\n               mod (120. * a, 1.)));\n          }\n        } else col = 1.1 * WoodCol (vec3 (120. * a, ro.y, r), vn);\n      } else if (vn.y > 0.99 && q.y < - htRm + 0.001 &&\n         (! isHole || r > rdHol + 0.05)) {\n        col = FloorCol (vec2 (32. * a, r));\n        if (! isHole) col *= (1. + smoothstep (0.5, 0.9, r / rdRm) *\n           0.5 * smoothstep (0.1, 0.3, abs (0.5 - mod (6. * a - 0.5, 1.))));\n        col = mix (vec3 (1., 0.7, 0.), col, step (0.01, HexEdgeDist (q.xz / szGr.x)));\n      }\n    } else if (idObj == idRal) {\n      col = vec3 (0.7, 0.7, 0.5);\n      spec = 0.1;\n    } else if (idObj == idChr) {\n      if (r < 0.8) {\n        col = vec3 (0.4, 0.4, 0.7);\n        q.xz = Rot2D (q.xz, tCur);\n        q.xz = 1.2 * (q.xz - vec2 (0.4, -0.1));\n        if (ShowInt (q.xz,\n           vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + inCell.xy, 100.),\n           vec2 (100., 1.))) != 0.) {\n          col = vec3 (1., 1., 0.);\n          isLit = false;\n        }\n      } else col = vec3 (0.7, 0.5, 0.) * (0.5 +\n         0.5 * SmoothBump (0.3, 0.7, 0.02, mod (6. * a, 1.)));\n    } else if (idObj == idBks) {\n      bt = vec2 (5000. * a, 200. * q.y);\n      a = 80. * mod (6. * a + 0.5, 1.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) {\n        q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.2 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           0.7 * SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n        if (abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n           Noisefv2 ((gbRm + gbBk) * vec2 (19., 31.) + floor (bt)) > 0.7) {\n          col *= 4.;\n        } else {\n          spec = 0.3;\n          vn.xz = Rot2D (vn.xz, q.x);\n        }\n      } else {\n        col = vec3 (0.02);\n        isLit = false;\n      }\n    } else if (idObj == idShlf) {\n      col = WoodCol (vec3 (5. * (mod (6. * a, 1.) - 0.5), ro.y, r), vn);\n    } else if (idObj == idCol) {\n      col = vec3 (0.8, 0.7, 0.6) * (1. - 0.1 * SmoothBump (0.45, 0.55, 0.02,\n         mod (4. * q.y, 1.)));\n    } else if (idObj == idStp) {\n      if (abs (r - 0.5 * (rdHol + rdRm - wlThk)) < 1.1) {\n        if (vn.y > 0.99) col = FloorCol (vec2 (64. * a, r));\n        else col = vec3 (0.7, 0.4, 0.2);\n      } else col = vec3 (0.6, 0.6, 0.9);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.7) * (0.5 - 0.5 * vn.y);\n      if (! isHole && r < 1.5) col *= 0.95 + 0.05 * sin (12. * 2. * pi * a);\n      isLit = false;\n    }\n    ltVec = roo + vec3 (0., 2., 0.) - ro;\n    atten = 1. / (1. + 0.0001 * dot (ltVec, ltVec));\n    if (isLit) {\n      ltVec = normalize (ltVec);\n      ao = ObjAO (ro, vn);\n      sh = ObjSShadow (ro, ltVec);\n      col = col * ao * (0.2 + 0.8 * atten * sh * max (0., max (dot (vn, ltVec), 0.)) +\n         atten * spec * sh * pow (max (0., dot (ltVec, reflect (rd, vn))), 16.));\n    } else col *= atten;\n  } else col = bgCol;\n  col = mix (col, bgCol, smoothstep (0.6, 1., min (dstObj / dstFar, 1.)));\n  col = clamp (col, 0., 1.);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 tp[7], td[6];\n  float dir, tm, tc;\n  tm = mod (t, 15.);\n  tc = floor (t / 15.);\n  p.y = 0.1 + 2. * tc;\n  td[0] = vec2 (1., 0.);\n  tp[0] = vec2 (-0.5 + 2. * tc, -0.5 * sqrt3);\n  dir = 1. - 2. * step (15., mod (t, 30.));\n  if (tm < 14.) {\n    hRot = 0.;\n    if (tm < 12.) {\n      dir *= -1. + 2. * step (6., tm);\n      tm = mod (tm, 6.);\n      td[1] = vec2 (0.5, 0.5 * sqrt3 * dir);\n      td[2] = vec2 (-0.5, 0.5 * sqrt3 * dir);\n      td[3] = - td[0];\n      td[4] = - td[1];\n      td[5] = - td[2];\n      for (int k = 0; k < 6; k ++) tp[k + 1] = tp[k] + td[k];\n      if (tm < 1.)      p.xz = tp[0] + td[0] * tm;\n      else if (tm < 2.) p.xz = tp[1] + td[1] * (tm - 1.); \n      else if (tm < 3.) p.xz = tp[2] + td[2] * (tm - 2.); \n      else if (tm < 4.) p.xz = tp[3] + td[3] * (tm - 3.); \n      else if (tm < 5.) p.xz = tp[4] + td[4] * (tm - 4.); \n      else if (tm < 6.) p.xz = tp[5] + td[5] * (tm - 5.); \n    } else {\n      p.xz = tp[0] + td[0] * (tm - 12.);\n    }\n  } else {\n    p.xz = tp[0] + 2. * td[0];\n    p.y += 2. * (tm - 14.);\n    hRot = 2. * pi * dir * (tm - 14.);\n  }\n  p.xz *= 4. * szGr.x;\n  p.y *= szGr.y;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 uv, ori, ca, sa;\n  float el, az, spd;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = clamp (el + 0.8 * pi * mPtr.y, -lookDown * pi, lookUp * pi);\n  }\n  szGr = vec2 (15., 3.3);\n  spd = 0.12;\n  fpF = TrackPath (spd * tCur + 0.1);\n  az += hRot;\n  fpB = TrackPath (spd * tCur - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  dstFar = 500.;\n  fragColor = vec4 (ShowScene (ro, rd), 2.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 HexCellId (vec2 p)\n{\n  vec3 c, r, dr;\n  p.y *= (1./sqrt3);\n  c.xz = vec2 (0.5 * (p.x - p.y), p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (2., step (dr.yzx, dr) + step (dr.zxy, dr)) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsScDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1788, 2661, 2683, 2683, 6051], [6053, 6053, 6086, 6086, 6262], [6264, 6264, 6285, 6285, 6494], [6496, 6496, 6528, 6528, 6726], [6728, 6728, 6765, 6765, 6989], [6991, 6991, 7022, 7022, 7239], [7241, 7241, 7265, 7265, 7439], [7441, 7441, 7469, 7469, 7560], [7562, 7562, 7587, 7587, 7804], [7806, 7806, 7841, 7841, 13499], [13501, 13501, 13527, 13527, 14675], [14677, 14677, 14730, 14730, 15670], [15672, 15672, 15705, 15705, 15732], [15734, 15734, 15776, 15776, 15827], [15829, 15829, 15882, 15882, 15943], [15945, 15945, 15998, 15998, 16177], [16179, 16179, 16225, 16225, 16282], [16284, 16284, 16309, 16309, 16546], [16548, 16548, 16605, 16605, 16688], [16690, 16690, 16720, 16720, 16778], [16901, 16901, 16925, 16925, 16972], [16974, 16974, 16999, 16999, 17198], [17200, 17200, 17221, 17221, 17376], [17378, 17378, 17402, 17402, 17538], [17540, 17540, 17563, 17563, 17622], [17695, 17695, 17727, 17727, 18269], [18271, 18271, 18331, 18331, 18906]]}
{"id": "MsScRD", "name": "Abstract Water Tunnel", "author": "Shane", "description": "An abstract representation of some shallow water flowing through a subterranean tunnel.", "tags": ["raymarching", "reflection", "tunnel", "refraction", "water", "abstract"], "likes": 48, "viewed": 2907, "date": "1491223640", "time_retrieved": "2024-06-20T18:53:29.574385", "image_code": "/*\n\n\tAbstract Water Tunnel\n\t---------------------\n\n\tThis is merely an abstract representation of some water flowing through a \n\ttunnel, so isn't in any way supposed to be a treatise on water physics...\n    or even a loose reference. :)\n\n\tI've been meaning to do a basic reflection\\refraction example for a while. \n\tI made the setting abstract to avoid having to deal with the physics - \n\tand ultimately, GPU effort - that tend to accompany realistic scenes. \n\tHaving said that, the edges required to give a pseudo polygonal effect \n\tkind of complicated things a little.\n\n\tThe scene geometry is reasonably cheap. When including extra passes, it kind \n\tof has to be. I chose a watery setting, because I could get away with just \n\tone refractive bounce. In fact, if I'd chosen deep water, I probably could \n\thave got away with just the reflection, but I thought clear shallow water\n\twould look more interesting.\n\n\tI coded this on my fast machine, which can run it in fullscreen without a \n\tproblem, but I targeted it toward the 800x450 canvas. I was too afraid to \n\ttest it on my slow machine, just in case the FPS was much lower than I \n    expected. :) Regardless, I've done my best to keep operations, iterations, \n\tetc, down to a reasonable level. Hopefully, it'll run well enough on the \n\taverage machine.\n\n\tBy the way, I rushed in the comments, but I'll tidy them up in due course.\n\tIf you spot any errors, feel free to let me know - especially if I've done\n\tsomething stupid, like invert the refracted ray, etc. I make dumb mistakes \n    like that all... the... time. :D\n    \n\n    // Other examples:\n\n    // A more physically realistic example... that I proabably should have \n    // referred to. :)\n    Where the River Goes (+ PostFX) - P_Malin\n    https://www.shadertoy.com/view/XdG3zd\n\n    // Really nice.\n    Tunnel with lamps - TambakoJaguar\n\thttps://www.shadertoy.com/view/MsVXzK\n \n\n*/\n\n#define FAR 40. // Maximum ray distance. Analogous to the far plane.\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic picture focus adjusting thing with your eyes.\n//#define THREE_D \n\n//#define NO_RERACTION // Displays just the reflected water. Cheaper.\n\n\n// Scene object ID. Either water (0) or the tunnel walls (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's consice, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7., 157., 113.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \nconst vec2 e = vec2(0, 1);\n\n\n\n/*\n// The standard vec3 to vec3 hash, commonly attributed to IQ. On a GPU, the \"sin\" function\n// tends to break down with large time values.\nvec3 hash(in vec3 p){\n    \n\n\tp = vec3( dot(p,vec3(127.1, 311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5, 183.3, 246.1)),\n\t\t\t  dot(p,vec3(113.5, 271.9, 124.6))); \n\t\n\tp = fract(sin(p)*43758.5453123)*2. - 1.;\n    \n    mat2  m = r2(iTime*2.);//in general use 3d rotation\n\tp.xy = m * p.xy;//rotate gradient vector\n    //p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n}\n*/\n\n// Dave's hash function. More reliable with large values, but will still eventually break down.\n//\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// vec3 to vec3.\nvec3 hash(vec3 p){\n\n\tp = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz + 19.19);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n    \n    /*\n    // Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = r2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;//rotate gradient vector\n    p.yz = m * p.yz;//rotate gradient vector\n    //p.zx = m * p.zx;//rotate gradient vector\n\treturn p;\n    */\n\n}\n\n/*\n// Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n// it over large values.\nvec3 hash(vec3 p){ \n   \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    //mat2  m = r2(iTime);//in general use 3d rotation\n\t//p.xy = m * p.xy;//rotate gradient vector\n    ////p.yz = m * p.yz;//rotate gradient vector\n    ////p.zx = m * p.zx;//rotate gradient vector\n\t//return p;\n    \n    //float n = sin(dot(p, vec3(7, 157, 113)));    \n    //return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n\n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    p = fract(vec3(2097152, 262144, 32768)*n); \n    return sin(p*6.2831853 + iTime); \n}\n*/\n\n// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into cubes, \n// attach random 3D vectors to each of the cube's eight verticies, then smoothly \n// interpolate the space between them.\nfloat gradN3D(in vec3 f){\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec3 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    //vec3 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec3 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec3 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec3 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec3 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between\n    // cubes, the result is blending of random values throughout the 3D space. By the way, the \"dot\" operation\n    // makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(mix(dot(hash(p + e.xxx), f - e.xxx), dot(hash(p + e.yxx), f - e.yxx), w.x),\n                      mix(dot(hash(p + e.xyx), f - e.xyx), dot(hash(p + e.yyx), f - e.yyx), w.x), w.y),\n                  mix(mix(dot(hash(p + e.xxy), f - e.xxy), dot(hash(p + e.yxy), f - e.yxy), w.x),\n                      mix(dot(hash(p + e.xyy), f - e.xyy), dot(hash(p + e.yyy), f - e.yyy), w.x), w.y), w.z);\n    \n    // Taking the final result, and putting it into the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n\n/* \nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    \n    p = fract(p) - .5;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.5));\n    \n    \n    //p = fract(p) - .5;    \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz))*1.5;\n    \n    //p = abs(fract(p)-.5);\n    //return max(max(p.x, p.y), p.z);\n    \n    //p = cos(p*3.14159)*0.5; \n    //p = abs(cos(p*3.14159)*0.5);\n    //p = abs(fract(p)-.5);\n    //return max(max(p.x - p.y, p.y - p.z), p.z - p.x);\n    //return min(min(p.x - p.y, p.y - p.z), p.z - p.x);\n    \n}\n\n\nfloat cellTile(in vec3 p){\n    \n     \n    vec3 d = vec3(.75); // Set the maximum.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    d.z = drawObject(p - vec3(.81, .62, .53));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.z = drawObject(p - vec3(.39, .2, .11));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    \n    \n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n     \n   \n    d.z = drawObject(p - vec3(.62, .24, .06));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071; \n    d.z = drawObject(p - vec3(.2, .82, .64));\n    d.y = max(d.x, min(d.y, d.z)); d.x = min(d.x, d.z);\n\n    //d = sqrt(d);\n    \n    //return 1. - (d.x*2.66);\n    return ((d.y - d.x)*2.66);\n    //return (1.-sqrt(d.x)*1.33);\n    \n} \n*/\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0);\n    //float s = sin(z/24.)*cos(z/12.);\n    //return vec2(s*12., 0.);\n    \n    return vec2(sin(z*.15)*2.4, cos(z*.25)*1.7); \n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x - floor(x) - .5);} // Triangle function.\n// PF - phase variance. Varies between zero and 1. Zero is redundant, as it returns the triangle function.\nvec3 trap(in vec3 x, float pf){ return (tri(x - pf*.125) + tri(x + pf*.125))*.5; } // Trapezoid function.\n\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    // Far more interesting formations, and fast, but not fast enough for this example.\n    //return cellTile(p/5.)*.75 + cellTile(p/2.5)*.25; \n    \n\t//return dot(tri(p*.384 + tri(p.yzx*.192)), vec3(.666));\n    return dot(trap(p*.384 + trap(p.yzx*.192, .75), .75), vec3(.666));\n}\n\n// Perturbing the water. Just a very basic sinusoidal combination. Definitely not water physics. :)\nfloat surfFunc2(in vec3 p){\n    \n    p += vec3(0, 0, -iTime*4.); // Flow it in the Z-direction - down the tunnel.\n    \n\treturn dot(sin(p + sin(p.yzx*2. + iTime*1.)), vec3(.1666)) + .5;\n\n}\n \n\n// Standard tunnel distance function with some perturbation thrown into the mix. A water plane has been \n// worked in also. A tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. \n// The walls of the tube are perturbed by a pretty cheap 3D surface function.\nfloat map(vec3 p){\n    \n    float sf = surfFunc(p); // Some triangular based noise to perturb the walls. Gives a low-poly effect.\n\n    p.xy -= path(p.z); // Wrap the tunnel around the path.\n    \n \n    // Round tunnel: Euclidean distance: length(tun.xy)\n    float n = 1. - length(p.xy*vec2(0.5, 0.7071)) + (0.5 - sf);\n    \n    // Square tunnel: Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1.- max(tun.x, tun.y) + (0.5 - sf);\n    \n    // Rounded square tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1. - pow(dot(pow(tun, vec2(4)), vec2(1)), 1./4.) + (0.5 - sf);\n    \n    // Hexagonal tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.75);\n    //float n = 1. - max(tun.x*.866025 + tun.y*.5, tun.y) + (0.5 - sf); //1.133975\n    \n    \n    sf = surfFunc2(p); // Some watery perturbation. Very minimal.\n    p.y += (.5-sf)*.5 + .85; // Add it to the water surface plane.\n    \n    // Object ID.\n    objID = step(n, p.y);\n\n    return min(n, p.y); // Return the object isovalue (distance).\n    \n \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat mapRef(vec3 p){\n    \n    float sf = surfFunc(p); // Some triangular based noise to perturb the walls.\n\n    p.xy -= path(p.z); // Wrap the tunnel around the path.\n   \n    // Round tunnel: Euclidean distance: length(tun.xy)\n    float n = 1. - length(p.xy*vec2(0.5, 0.7071)) + (0.5 - sf);\n    \n    // Square tunnel: Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1.- max(tun.x, tun.y) + (0.5 - sf);\n    \n    // Rounded square tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.7071);\n    //float n = 1. - pow(dot(pow(tun, vec2(4)), vec2(1)), 1./4.) + (0.5 - sf);\n    \n    // Hexagonal tunnel.\n    //vec2 tun = abs(p.xy)*vec2(0.5, 0.75);\n    //float n = 1. - max(tun.x*.866025 + tun.y*.5, tun.y) + (0.5 - sf); //1.133975\n    \n    // Object ID.\n    objID = 1.;\n\n    return n; // Return to object isovalue (distance).\n\n \n}\n\n\n// The bump function.\nfloat bumpFunc(vec3 p){\n\n    // Just one layer of moving gradient noise to give the impression that the surface is rippled.\n    // By the way, the cheaper cubic interpolation (see the function) shows grid lines when bump \n    // mapped. There's a quintic option, but the ripples are so small, that no one will notice.\n    return gradN3D(p*8. + vec3(0, iTime, 0.));\n}\n\n// Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy), bumpFunc(p - e.yxy), bumpFunc(p - e.yyx)) - ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;//.001*(t*.125 + 1.)\n        \n        t += d*.86; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<32; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<0.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Another pass, which is the first, and only, refracted bounce. \n// Virtually the same as above, but uses a slimmed down distance function - due\n// to the fact that the water plane doesn't need to be included.\nfloat traceRefr(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<32; i++){\n\n        d = mapRef(ro + rd*t);\n        \n        if((d<0. && abs(d)<0.002*(t*.25 + 1.)) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .2); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0025, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormalRefr(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(6./iResolution.y, 0);\n\n\tfloat d1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\tfloat d3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\tfloat d5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n\tfloat d = mapRef(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\td3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\td5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.003, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = mapRef(p + e.xyy), d2 = mapRef(p - e.xyy);\n\td3 = mapRef(p + e.yxy), d4 = mapRef(p - e.yxy);\n\td5 = mapRef(p + e.yyx), d6 = mapRef(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color, with some contract thrown in.\n    vec3 tx = tex3D(iChannel0, p/3., n );\n    tx = smoothstep(.1, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.5) {\n        \n        tx *= vec3(1, .55, .35); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.1, .6, surfFunc(p))*.6 + .4;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else tx *= vec3(.6, .8,  1); // Tinting the water blue, to give bluish reflections.\n\n    \n    return tx; // pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 1.5/(1. + lDist*0.125 + lDist*lDist*0.025);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = (objCol*(diff + 0.7 + vec3(1, .6, .2)*spec*2.));\n        \n        // Edges and curvature.\n        //sceneCol *= clamp(crv, 0., 1.);\n        //sceneCol += edge*.15;\n        sceneCol *= 1. - edge*.9;\n        \n\n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*3.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, .25, 3.);\n    \n\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    #ifdef THREE_D\n    ro.x -= sg*.15; lk.x -= sg*.15; lp.x -= sg*.15;\n    #endif\n    \n    /*\n    // Attempting to influence the camera with the wave motion. Needs a faster camera speed.\n\t// Anyway, it didn't make the cut, but it's a work in progress. :)\n    float sfRo = surfFunc2(ro);\n    float sfLk = surfFunc2(lk);\n    ro.y += sfRo*.16;\n    lk.y += sfLk*.12;\n    */\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n\n    // Edge and curvature variables. Passed to the normal functions... The refraction\n    // pass has seperate normal function.\n    float edge = 0., crv = 1.;\n\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    svObjID = objID;\n    float oSvObjID = svObjID;\n\n    \n\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    vec3 sn = getNormal(sp, edge, crv);\n    \n\n    // Bump the water surface with some basic gradient noise.\n    if(oSvObjID<0.5) sn = bumpMap(sp, sn, .02);\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes, but here it'll be used \n    // as a transmission ratio for the reflection and refraction.\n    float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(sp, rd, sn, lp, edge, crv, t);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.0011, lp, 16., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n    // Fog - based off of distance from the camera. This will be applied at the end.\n    float fog = smoothstep(0., .95, t/FAR);\n    \n    \n    \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n\n\n    // The ray is edged off the surface, as required, but note that it has to be enough\n    // to avoid conflict with the break condition in the \"reflected\" trace algorithm. To\n    // make things difficult, I've chosen a relaxed break condition to speed up the first\n    // pass... but reflections (and shadows) require surface accuracy, so it's a choice \n    // between lag and accuracy, or speed and artifacts. I can't win. :) Having said that,\n    // this example seems to be pretty free of artifacts.\n    t = traceRef(sp + sn*0.0015, refl);\n    svObjID = objID;\n    \n    // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n    refSp = sp + refl*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(refSp, edge, crv);//*rDir;\n \n    \n    vec3 reflColor = doColor(refSp, refl, sn, lp, edge, crv, t);\n    \n    #ifdef NO_RERACTION\n    // Fake deeper water version. Just reflected water with no refraction. Obviously cheaper.\n    if(oSvObjID<0.5) sceneColor = sceneColor*.1 +  reflColor*(fr*fr); \n    else sceneColor += reflColor*.5; // Add a portion of the reflection to the tunnel walls.\n    #else    \n    // REFRACTED PASS\n    \n    // If we hit the water surface, refract, retrieve the refracted color, then combine\n    // it with the reflected color retrieved above.\n    if(oSvObjID<0.5){  \n\n        // Standard reflracted ray, which is just a refraction of the unit\n        // direction ray from the intersected surface. You use the normal\n        // at the surface point to do this also.\n\n        t = traceRefr(sp - sn*.0025, refr);\n        svObjID = objID;\n\n        // Advancing the ray from the new origin, \"sp,\" to the new refracted hit point.\n        refSp = sp + refr*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormalRefr(refSp, edge, crv);\n\n        vec3 refrColor = doColor(refSp, refr, sn, lp, edge, crv, t);\n        \n        // Add a small portion of the diffuse water color to the reflected and refracted colors.\n        // The Fresnel value is used to provide a rough reflection to refraction ratio. It's based\n        // on very rough science, but it gives a nice enough effect.\n        sceneColor = sceneColor*.2 + mix(refrColor, reflColor, pow(fr, 5.)*.8 + .2)*vec3(.6, .8, 1);\n        \n    }\n    else { // If the tunnel walls were hit, just add the reflected color from above.\n        \n        sceneColor += reflColor*.5; // Add a portion of the reflection to the tunnel walls.\n        //sceneColor = mix(sceneColor, reflColor, fr*fr*fr*.75 + .25); // Another way.\n        //sceneColor = sceneColor*.5 + mix(sceneColor, reflColor, .75); // etc.\n    }\n    #endif\n   \n   \n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = vec3(.7, .75, 1)*(rd.y*.25 + .75)*1.5;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    //sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    sceneColor = pow(max(sceneColor, 0.), vec3(1.33))*1.66; // Adding a bit of contrast.\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n\n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsScRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2398, 2441, 2459, 2459, 2527], [2529, 2595, 2643, 2643, 3146], [3148, 3216, 3234, 3234, 3587], [4253, 4495, 4513, 4513, 4939], [5678, 5974, 5999, 6091, 7752], [9384, 9484, 9506, 9599, 9656], [9658, 9856, 9876, 9876, 9907], [9908, 10037, 10068, 10068, 10119], [10145, 10599, 10625, 10837, 10910], [10912, 11012, 11039, 11039, 11199], [11203, 11490, 11508, 11508, 12567], [12569, 12701, 12722, 12722, 13585], [13588, 13610, 13633, 13927, 13976], [13978, 14028, 14081, 14081, 14406], [14409, 14442, 14472, 14472, 14761], [14763, 15173, 15206, 15206, 15430], [15432, 15643, 15677, 15677, 15905], [15908, 16209, 16262, 16379, 17673], [18488, 18554, 18613, 18680, 19635], [19638, 19704, 19767, 19834, 20845], [20847, 20917, 20953, 21017, 21694], [21696, 21834, 21927, 21983, 23533], [23535, 23687, 23732, 23732, 23991], [23995, 23995, 24051, 24079, 31897]]}
{"id": "MsScWz", "name": "Recursive Voronoi", "author": "unconed", "description": "quick experiment", "tags": ["voronoi"], "likes": 25, "viewed": 759, "date": "1491573170", "time_retrieved": "2024-06-20T18:53:30.065491", "image_code": "// based on https://www.shadertoy.com/view/llG3zy\n\n#define LEVELS 4\n#define ANIMATE\n#define ANIMATE_D .5\n#define EPSILON .00001\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr, mp;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mp = n + g;\n        }\n    }\n\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mp );\n}\n\nvec3 plot( vec2 p, float ss )\n{\n    float d = 8.0;\n    vec2 xy = p;\n    \n    vec3 albedo = vec3(0.0);\n    float r = 1.0;\n\n    for (int i = 0; i < LEVELS; ++i) {\n\t    vec3 c = voronoi(xy);\n        xy = xy * 2.0 + c.yz;\n        d = min(d, c.x * r);\n\n       \tfloat h = dot(c.yz, c.zy + 1.0) * r;\n        r *= .75;\n        vec3 cc = sin(vec3(h, h*2.0, h*3.0)) * .5 + .5;\n        albedo = mix(albedo, cc, .25);\n\t}\n    \n    float edge = clamp(1.1 - d * 32.0, 0.0, 1.0);\n    return vec3(albedo + edge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsScWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 129, 149, 149, 609], [611, 611, 638, 638, 1356], [1358, 1358, 1389, 1389, 1855], [1857, 1857, 1914, 1914, 2148]]}
{"id": "MsSyzK", "name": "Rotational shader beginner", "author": "Etilawin", "description": "Feel free to tell me how to improve my code ;)", "tags": ["beginner", "smoothstep", "rotation"], "likes": 2, "viewed": 398, "date": "1492763511", "time_retrieved": "2024-06-20T18:53:30.065491", "image_code": "#define PI 3.141592653589793\n\nvoid grid(vec2 r, vec3 color, inout vec3 pixel)\n{\n    // Grid\n \tpixel  = mix(pixel, color, smoothstep(0.008, 0.004, mod(r.x, 0.1)));\n    pixel  = mix(pixel, color, smoothstep(0.008, 0.004, mod(r.y, 0.1)));\n    // Axis\n    pixel  = mix(pixel, color, smoothstep(0.02,0.01,abs(r.x)));\n    pixel  = mix(pixel, color, smoothstep(0.02,0.01,abs(r.y)));\n}\n\nvec2 rotate(vec2 r, float a)\n{\n\treturn r*mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\nvec2 scale(vec2 r, float scalingFactor)\n{\n    return r * (1./scalingFactor);\n}\n\nfloat rect(vec2 r, vec2 topLeft, vec2 bottomRight)\n{\n    float d = 0.005;\n    float ret  = smoothstep(topLeft.x - d,topLeft.x + d , r.x);\n    \t  ret *= smoothstep(topLeft.y - d,topLeft.y + d, r.y);\n    \t  ret *= 1. - smoothstep(bottomRight.x - d, bottomRight.y + d, r.x);\n          ret *= 1. - smoothstep(bottomRight.y -d, bottomRight.y + d, r.y);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 r  = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 r2 = rotate(r, PI * iTime / 4.);\n    \t r2 = scale(r2, .5);\n    \n    vec3 pixel = vec3(0.);\n    vec3 col1 = vec3(.6,.6,.6);\n    vec3 col2 = vec3(.4,.4,.4);\n    vec3 col3 = vec3(.1,.5,.7);\n    \n    grid(r, col1, pixel);\n    grid(r2, col2, pixel);\n    \n    pixel = mix(pixel, col3, rect(r, vec2(0., 0.), vec2(0.2, 0.2)));\n    pixel = mix(pixel, col3, rect(r2, vec2(0., 0.), vec2(0.2, 0.2)));\n    \n    fragColor = vec4(pixel, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSyzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[30, 30, 79, 91, 377], [379, 379, 409, 409, 463], [465, 465, 506, 506, 543], [545, 545, 597, 597, 910], [912, 912, 969, 969, 1514]]}
{"id": "MsSyzW", "name": "2D Worley and Cell Noise", "author": "TinyTexel", "description": "left: 1 - worley\nmiddle: f2^2 - f1^2\nright: proper distances to the cell edges \n(http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nnote: iq used f2 - f1 for the simple solution which messed up the distance estimate more then necessary)\n", "tags": ["voronoi", "noise", "worley"], "likes": 12, "viewed": 348, "date": "1491071937", "time_retrieved": "2024-06-20T18:53:31.471644", "image_code": "/*\nleft: f1^2 (1 - worley)\nmiddle: f2^2 - f1^2\nright: proper distance to closest cell edge\n(http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\nnote: iq used f2 - f1 for the simple solution which messed up the distance estimate more then necessary)\n*/\n#define Time iTime\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n\n#ifndef OUT\n/* \ndummy token for separating IN and OUT parameters\nexample: foo(in0, in1, in2, OUT ou0, ou1)\n*/\n#define OUT \n#endif\n\nconst float Pi = 3.141592653589793238462643383279502884197169399375105820974944592;\n\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\n\n/*\nIN:\n\tp\t\t: sample position\n\tseed\t: seed that feeds into the hash generation\n\tcells   : cell count per tile; no tiling if all elements are 0\n\nOUT:\n\tout_d\t: distance to closest feature point\n\tout_p\t: position of closest feature point\n\tout_h\t: hash of closest feature point\n\nEXAMPLE:\t\n\tfloat d; vec2 p; float h;\n\tF1_N3(pos, 0.1, vec2(0.0), OUT d, p, h);\n*/\nvoid F1_N3\n(\n\tin  vec2  p,\n\tin  float seed,\n\tin  vec2  cells,\n\t\n\tout float out_d,\n\tout vec2  out_p,\n\tout float out_h\n){\n\tvec2 p_i = floor(p);\n\t\n\tout_d = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t// o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t           // CheapHash(cid * 1.70117 + 0.67484 + seed));\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < out_d)\n\t\t{\n\t\t\tout_d = d;\n\t\t\tout_p = fp;\n\t\t\tout_h = h;\n\t\t}\n\t}\n}\n\n/*\nIN:\n\tp\t\t: sample position\n\tseed\t: seed that feeds into the hash generation\n\tcells   : cell count per tile; no tiling if all elements are 0\n\nOUT:\n\tout_d1\t: distance to closest feature point\n\tout_p1\t: position of closest feature point\n\tout_h1\t: hash of closest feature point\n\t\n\tout_d2\t: distance to second closest feature point\n\tout_p2\t: position of second closest feature point\n\tout_h2\t: hash of second closest feature point\n\nEXAMPLE:\t\n\tfloat d1; vec2 p1; float h1;\n\tfloat d2; vec2 p2; float h2;\n\tF1F2_N3(pos, 0.1, vec2(0.0), OUT d1, p1, h1, d2, p2, h2);\n*/\nvoid F1F2_N3\n(\n\tin  vec2  p,\n\tin  float seed,\n\tin  vec2  cells,\n\t\n\tout float out_d1,\n\tout vec2  out_p1,\n\tout float out_h1,\n\t\n\tout float out_d2,\n\tout vec2  out_p2,\n\tout float out_h2\n){\n\tvec2 p_i = floor(p);\n\t\n\tout_d1 = out_d2 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\t\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t// o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t           // CheapHash(cid * 1.70117 + 0.67484 + seed));\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < out_d1)\n\t\t{\n\t\t\tout_d2 = out_d1;\n\t\t\tout_p2 = out_p1;\n\t\t\tout_h2 = out_h1;\n\t\t\t\n\t\t\tout_d1 = d;\n\t\t\tout_p1 = fp;\n\t\t\tout_h1 = h;\n\t\t}\n\t\telse\n\t\tif(d < out_d2)\n\t\t{\n\t\t\tout_d2 = d;\n\t\t\tout_p2 = fp;\n\t\t\tout_h2 = h;\n\t\t}\n\t}\n}\n\n\nfloat CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n        #if 1\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n        #else\n\t\tvec2 o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t              CheapHash(cid * 1.70117 + 0.67484 + seed)) * 0.99;\n\t\t#endif\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n\tfloat dd = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n        #if 1\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n        #else\n\t\tvec2 o = vec2(CheapHash(cid * 1.36541 + 0.82477 + seed), \n\t\t              CheapHash(cid * 1.70117 + 0.67484 + seed)) * 0.99;\n\t\t#endif\n        \n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t    // d = dot(p - (p1 + fp) * 0.5, (p1 - fp)) * 2.0 / 1.48 * 0.55;// same as middle texture\n\n\t\tdd = min(dd, d);\n\t}\n\t\n\treturn dd * 1.48;// empirically normalized\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    uv.x = mod(uv.x, iResolution.x / 3.0);\n    \n    vec2 cells = vec2(0.0);\n    //cells = vec2(5.0);// 5 cells per tile\n    \n    vec2 pos = uv * 0.04 + Time * 1.0;\n    \n    // left:\n    float r0;\n    {\n    \tfloat d; vec2 p; float h;\n\t\tF1_N3(pos, 0.0, cells, OUT d, p, h);\n        \n        r0 = d;\n    }\n    \n    // middle:\n    float r1;\n    {\n        float d1; vec2 p1; float h1;\n        float d2; vec2 p2; float h2;\n        F1F2_N3(pos, 0.0, cells, OUT d1, p1, h1, d2, p2, h2);\n        \n        r1 = (d2 - d1) * 0.55;// empirically normalized\n    }\n    \n    // right:\n    float r2 = CellTex(pos, 0.0, cells);\n    //fragColor = vec4(pow(r2,1.0/2.2)); return;\n\n    fragColor = vec4(vec3(pow(tex.x < 1.0/3.0 ? r0 : \n                             (tex.x < 2.0/3.0 ? r1 : r2), 1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsSyzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": []}
{"id": "MtcSR8", "name": "Raytrace Reflections", "author": "dmemes", "description": "messing around", "tags": ["raytrace"], "likes": 4, "viewed": 159, "date": "1493327497", "time_retrieved": "2024-06-20T18:53:32.574647", "image_code": "#define PI 3.14159265359\n#define MAXDIST 1e5\n\nstruct Material{\n\tfloat Reflect;\n\tfloat SpecularIntensity;\n\tfloat SpecularPower;\n  \tvec3 Color;\n};\n\nvec3 LightDirection = normalize(vec3(-.1, -.2, -.3));\n\nvoid Sphere(in vec3 ro, in vec3 rd, in vec3 pos, in float radius, out float dist, out vec3 normal){\n    dist = 100000.0;\n    normal = vec3(0.0);\n    \n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, ro - pos);\n    float c = dot(pos, pos) + dot(ro, ro) - 2.0 * dot(pos, ro) - radius*radius;\n    \n    float x = b*b - 4.0*a*c;\n    if (x >= 0.01){\n        x = sqrt(x);\n        float d1 = (-b - x) / (2.0 * a);\n        float d2 = (-b + x) / (2.0 * a);\n        if (d1 > 0.0 && d2 > 0.0){\n            dist = d1;\n            normal = normalize(ro+rd*dist - pos);\n        }\n    }\n}\nvoid Plane(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 norm, out float dist, out vec3 normal){\n    dist = 100000.0;\n    normal = vec3(0.0);\n    \n    float denom = dot(norm, rd);\n    if (abs(denom) > 0.001){\n        float t = dot(pos - ro, norm) / denom;\n        if (t >= 0.001){\n            dist = t;\n            normal = norm;\n        }\n    }\n}\nvoid Box(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 size, out float dist, out vec3 normal) {\n    vec3 lb = pos - size;\n    vec3 rt = pos + size;\n    // r.dir is unit direction vector of ray\n    vec3 dirfrac = 1.0 / rd;\n    // lb is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    // r.org is origin of ray\n    float t1 = (lb.x - ro.x)*dirfrac.x;\n    float t2 = (rt.x - ro.x)*dirfrac.x;\n    float t3 = (lb.y - ro.y)*dirfrac.y;\n    float t4 = (rt.y - ro.y)*dirfrac.y;\n    float t5 = (lb.z - ro.z)*dirfrac.z;\n    float t6 = (rt.z - ro.z)*dirfrac.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n    if (tmax < 0.0 || tmin < 0.0)\n    {\n        dist = MAXDIST;\n        normal = vec3(0.0);\n        return;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax)\n    {\n        dist = MAXDIST;\n        normal = vec3(0.0);\n        return;\n    }\n\n    dist = tmin;\n    \n    float m = length(size);\n    float d;\n    vec3 point = ro + rd * dist - pos;\n\n    d = abs(size.x - abs(point.x));\n    if (d < m){\n        m = d;\n        normal = sign(point.x) * vec3(1.0, 0.0, 0.0);\n    }\n    d = abs(size.y - abs(point.y));\n    if (d < m){\n        m = d;\n        normal = sign(point.y) * vec3(0.0, 1.0, 0.0);\n    }\n    d = abs(size.z - abs(point.z));\n    if (d < m){\n        m = d;\n        normal = sign(point.z) * vec3(0.0, 0.0, 1.0);\n    }\n} \n\nvoid trace(in vec3 ro, in vec3 rd, out Material mat, out float dist, out vec3 normal){\n    dist = MAXDIST;\n    normal = vec3(0.0);\n    \n    float s;\n    vec3 n;\n    \n    Plane(ro, rd, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), s, n);\n    if (s < dist){\n    \tdist = s;\n        normal = n;\n        vec3 pos = ro + rd * s;\n        float f = mod(floor(pos.z) + floor(pos.x), 2.0);\n        mat.Color = vec3(0.5 + 0.1*f);\n        mat.SpecularIntensity = 0.0;\n        mat.Reflect = 0.0;\n    }else{\n    \t\n    }\n    \n    for (float x = -5.0; x < 5.0; x++){\n    \tfor (float z = -5.0; z < 5.0; z++){\n            float t = x+z;//.5 * (x+z)*(x+z+1.0)+z;\n            float s = sin(t+iTime)*.5 + .5;\n            float c = cos(t+iTime)*.5 + .5;\n            \n            Sphere(ro, rd, vec3(2.3*x, 1.0 + 2.0 * s, 2.3*z), 1.0, s, n);\n            if (s < dist){\n                dist = s;\n                normal = n;\n                mat.Color = vec3(c*.65, .15, s*.1);\n                mat.SpecularIntensity = 1.0;\n                mat.SpecularPower = 100.0;\n                mat.Reflect = .9;\n            }\n        }\n    }\n}\n\nvec3 renderReflection(in vec3 ro, in vec3 rd){\n    // ray direction\n    Material mat;\n    mat.Color = vec3(.5, .5, .8) * clamp((abs(rd.y)+.8),0.0,1.0) + pow(dot(rd, -LightDirection), 100.0);\n    \n    vec3 norm;\n    float dist;\n    trace(ro, rd, mat, dist, norm);\n    \n    vec3 color = mat.Color;\n    \n    if (dist < MAXDIST){\n    \tcolor *= dot(LightDirection, -norm);\n        \n        // shadow\n        Material m;\n        vec3 n;\n        float d;\n        trace(ro + rd * dist, -LightDirection, m, d, n);\n        if (d < MAXDIST){\n            color *= .5;\n        }else{\n            // specular\n            if (mat.SpecularIntensity > 0.0){\n                float spec = dot(-rd, reflect(LightDirection, norm));\n                if (spec > 0.0)\n                    color += mat.SpecularIntensity * pow(spec, mat.SpecularPower);\n            }\n        }\n    }\n    return color;\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    // ray direction\n    Material mat;\n    mat.Color = vec3(.5, .5, .8) * clamp((abs(rd.y)+.8),0.0,1.0) + pow(dot(rd, -LightDirection), 100.0);\n    \n    vec3 norm;\n    float dist;\n    trace(ro, rd, mat, dist, norm);\n    \n    vec3 color = mat.Color;\n    \n    if (dist < MAXDIST){\n    \tcolor *= dot(LightDirection, -norm);\n        \n        if (mat.Reflect > 0.0){\n            // reflection\n            vec3 r = reflect(rd, norm);\n            vec3 c = renderReflection(ro + rd * dist, r);\n            color = mix(color, c, mat.Reflect);\n        }\n    }\n    return color;\n}\n\nmat3 xrot(float t){\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\nmat3 yrot(float t){\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\nmat3 zrot(float t){\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 c = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\tc.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) * -2.0 + 1.0;\n\t\n    mat3 rot = xrot(m.y * PI * .5) * yrot(m.x * PI * 2.0) * zrot(0.0);\n    \n    vec3 rd = normalize(vec3(c, 1.0)) * rot;\n    vec3 ro = (vec3(0.0,0.0,-5.0) * rot);\n    ro.y += 3.0;\n    if (ro.y < 0.1)\n        ro.y = 0.1;\n    \n\tfragColor = vec4(render(ro, rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtcSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[201, 201, 300, 300, 779], [780, 780, 875, 875, 1126], [1127, 1127, 1221, 1221, 2678], [2681, 2681, 2767, 2767, 3782], [3784, 3784, 3830, 3851, 4659], [4661, 4661, 4697, 4718, 5267], [5269, 5269, 5288, 5288, 5394], [5395, 5395, 5414, 5414, 5520], [5521, 5521, 5540, 5540, 5649], [5650, 5650, 5706, 5706, 6124]]}
{"id": "Xd2cD1", "name": "Sketch_Zebra", "author": "cexlearning", "description": "Zebra，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 10, "viewed": 144, "date": "1492604607", "time_retrieved": "2024-06-20T18:53:32.574647", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    const float pi = 3.14159265359;\n    float size = iResolution.y / 10.0; // cell size in pixel\n\n    vec2 p1 = fragCoord.xy / size; // normalized pos\n    vec2 p2 = fract(p1) - 0.5; // relative pos from cell center\n\n    // random number\n    float rnd = dot(floor(p1), vec2(12.9898, 78.233));\n    rnd = fract(sin(rnd) * 43758.5453);\n\n    // rotation matrix\n    float phi = rnd * pi * 2.0 + iTime * 0.4;\n    mat2 rot = mat2(cos(phi), -sin(phi), sin(phi), cos(phi));\n\n    vec2 p3 = rot * p2; // apply rotation\n    p3.y += sin(p3.x * 5.0 + iTime * 2.0) * 0.12; // wave\n\n    float rep = fract(rnd * 13.285) * 8.0 + 2.0; // line repetition\n    float gr = fract(p3.y * rep + iTime * 0.8); // repeating gradient\n\n    // make antialiased line by saturating the gradient\n    float c = clamp((0.25 - abs(0.5 - gr)) * size * 0.75 / rep, 0.0, 1.0);\n    c *= max(0.0, 1.0 - length(p2) * 0.6); // darken corners\n\n    vec2 bd = (0.5 - abs(p2)) * size - 2.0; // border lines\n    c *= clamp(min(bd.x, bd.y), 0.0, 1.0);\n\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2cD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 1174]]}
{"id": "Xd2cW1", "name": "Sketch_Lines", "author": "cexlearning", "description": "Lines，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 11, "viewed": 199, "date": "1492432225", "time_retrieved": "2024-06-20T18:53:32.574647", "image_code": "float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat potential(vec2 coord)\n{\n    float t = iTime * 2.0;\n    return saturate(dot(sin(coord * 0.015 + t) + 1.0, vec2(0.4)));\n}\n\nfloat line(vec2 coord)\n{\n    float reso = 24.0;\n    float cw = iResolution.x / reso;\n\n    vec2 pc = floor(coord / cw) * cw;\n    vec2 pd = fract(coord / cw) * cw;\n    \n    float pt = potential(pc);\n    float lw = pt + 0.5;\n    float grad = 1.0 - pt * 2.0;\n\n    return saturate(lw - abs(grad * pd.y - pd.x + cw * pt));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat c = line(fragCoord.xy);\n    fragColor = vec4(vec3(c, c, c), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2cW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 25, 25, 54], [56, 56, 85, 85, 181], [183, 183, 207, 207, 501], [503, 503, 560, 560, 633]]}
{"id": "Xd2cWh", "name": "Sketch_Circles5", "author": "cexlearning", "description": "Circles5， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 0, "viewed": 92, "date": "1491970613", "time_retrieved": "2024-06-20T18:53:32.580443", "image_code": "float circles(vec2 coord)\n{\n    float reso = 5.0;\n    float width = iResolution.x / reso;\n\n    vec2 center = floor(coord / width + 0.5) * width;\n    float dist = distance(coord, center);\n\n    float time = iTime * 0.9;\n    float phase = dot(center, vec2(1.647346, 7.323874));\n    float radius = width * (0.3 + sin(time + phase) * 0.16);\n\n    return dist - radius;\n}\n\nfloat line(vec2 coord, float seed)\n{\n    vec2 dir = vec2(-1.0, 1.0);\n    float bound = dot(iResolution.xy, abs(dir));\n\n    float speed = fract(seed * 4785.9433) * 0.3 + 0.3;\n    float time = fract(iTime * speed);\n\n    float phase = iTime * (fract(seed * 438.454) * 3.3 + 3.3);\n    float width = bound * 0.02 * (sin(phase) + 1.0);\n\n    float dist = dot(coord, dir) + (time - 0.5) * bound;\n    return abs(dist) - width;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy;\n    \n    float c = 1e+6;\n    for (int i = 0; i < 4; i++)\n        c = min(c, line(p, 94.3 * float(i)));\n\n    c = max(c, circles(p));\n    c = clamp(1.0 - abs(1.0 - c), 0.0, 1.0);\n    \n    fragColor = vec4(vec3(c, c, c), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2cWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 27, 27, 364], [366, 366, 402, 402, 785], [787, 787, 844, 844, 1092]]}
{"id": "Xd2yDR", "name": "Update1 Basic clockwise square ", "author": "barakooda", "description": "Improved Basic clockwise square \n//Improved white rectangle of https://www.shadertoy.com/view/ldScRm\n//Credit to ollj.", "tags": ["improvedbasicclockwisesquare"], "likes": 0, "viewed": 473, "date": "1491614077", "time_retrieved": "2024-06-20T18:53:32.847369", "image_code": "//Barakooda 8/4/2017\n//Improved white rectangle https://www.shadertoy.com/view/ldScRm\n//Credit to ollj.\n\nbool whiteRectangle(vec2 uv)\n\t{\n          // creating buttom left rectangle point\n        \n\t\tbvec2 bl = lessThan(vec2 (-.1),uv);\n\n        // creating top right rectangle point\n        bvec2 tr = lessThan(vec2(-.1),-uv);\n\n        // multiplie step layers\n        return ( (bl.x && tr.x) && (bl.y && tr.y) ) ;\n\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //noramelize \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //window aspect\n    float aspect = iResolution.y/iResolution.x;\n    \n    //axis change from 0 - 1.0 to -1.0 - 1.0\n\tuv = uv * 2. - 1.;\n    \n   \n    \n    // createing translation data.\n    vec2 translate = vec2(-cos(iTime),sin(iTime));\n   \n    //Strecth y axis\n    uv.y*=aspect;\n    \n    //adding translation to uv\n    uv += translate*0.45;   \n    \n    \n\n\t//creating square    \n    bool color = whiteRectangle(uv);\n   \n    \n    //final\n\tfragColor = vec4(vec3(color),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2yDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 105, 136, 186, 415], [418, 418, 475, 498, 1020]]}
{"id": "Xd2yW1", "name": "Sketch_Hex4", "author": "cexlearning", "description": "Hex4， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 6, "viewed": 99, "date": "1492327651", "time_retrieved": "2024-06-20T18:53:32.853428", "image_code": "vec3 hue2rgb(float h)\n{\n    h = fract(h) * 6.0 - 2.0;\n    return clamp(vec3(abs(h - 1.0) - 1.0, 2.0 - abs(h), 2.0 - abs(h - 2.0)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float pi = 3.1415926535;\n    vec2 p = gl_FragCoord.xy - iResolution.xy / 2.0;\n    float phi = atan(p.y, p.x + 1e-5);\n\n    float fin = mod(floor(phi * 3.0 / pi + 0.5), 6.0);\n    float phi_fin = fin * pi / 3.0;\n\n    vec2 dir = vec2(cos(phi_fin), sin(phi_fin));\n    float l = dot(dir, p) - iTime * iResolution.y / 8.0;\n    float seg = floor(l * 40.0 / iResolution.y);\n\n    float th = sin(iTime) * 0.4 + 0.5;\n    float t = sin(seg * 92.198763) * iTime;\n\n    vec3 c  = hue2rgb(sin(seg * 99.374662) * 237.28364);\n    c *= step(th, fract(phi / pi / 2.0 + t));\n\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2yW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 143], [145, 145, 202, 202, 793]]}
{"id": "Xd2yWh", "name": "Sketch_Cherry", "author": "cexlearning", "description": "Cherry， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 1, "viewed": 114, "date": "1491970499", "time_retrieved": "2024-06-20T18:53:33.083864", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    const float pi = 3.1415926;\n    float scale = iResolution.y / 5.0;\n\n    vec2 p = fragCoord.xy / scale;\n    float t = iTime * 0.6 + rand(floor(p)) * 200.0;\n    \n    float s2 = 1.6 + 0.6 * sin(t);\n    p = (fract(p) - 0.5) * s2; // repeat and scale\n    scale /= s2;\n\n    float d1 = 1e6; // distance field (petal)\n    float d2 = 0.0;   // distance field (cut)\n\n    for (int i = 0; i < 5; i++)\n    {\n        float phi = pi * (2.0 * float(i) / 5.0 + 0.1) + t;\n\n        vec2 v1 = vec2(cos(phi), sin(phi)); // outward vector\n        vec2 v2 = vec2(-v1.y, v1.x);        // vertical vector\n        vec2 v3 = vec2(cos(phi - 1.0), sin(phi - 1.0)); // cut line 1\n        vec2 v4 = vec2(cos(phi + 1.0), sin(phi + 1.0)); // cut line 2\n\n        d1 = min(d1, max(distance(p, v1 * 0.27 - v2 * 0.15),\n                         distance(p, v1 * 0.27 + v2 * 0.15)));\n\n        d2 = max(d2, min(dot(v3, p) - dot(v3, v1 * 0.4),\n                         dot(v4, p) - dot(v4, v1 * 0.4)));\n    }\n\n    vec2 c12 = vec2(1) - vec2(d1 - 0.29, d2) * scale;\n    vec3 c = max(vec3(1, 0.7, 0.7) + p.y, 0.0) * min(c12.x, c12.y);\n\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2yWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 21, 21, 91], [95, 95, 152, 152, 1371]]}
{"id": "XdByD1", "name": "marble colour test 2", "author": "hclarke", "description": "based off guil's marble: https://www.shadertoy.com/view/MtX3Ws", "tags": ["marble"], "likes": 9, "viewed": 352, "date": "1491845194", "time_retrieved": "2024-06-20T18:53:33.089996", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nfloat zoom=1.;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p, vec2 sctime) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n    c.xy = c.xy * sctime.x + vec2(c.y, c.x) * sctime.y;\n\tfor (int i = 0; i < 10; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n        \n\t}\n\treturn res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax , vec2 sctime)\n{\n    //tminmax += vec2(1.,1.) * sin( iTime * 1.3)*3.0;\n   \tvec3 one3 = vec3(1.,1.,1.);\n    vec3 t = one3 * tminmax.x;\n    \n    vec3 dt = vec3(.07, 0.02, 0.05);\n    vec3 col= vec3(0.);\n    vec3 c = one3 * 0.;\n    for( int i=0; i<64; i++ )\n\t{\n     \tvec3 s = vec3(2.0, 3.0, 4.0);   \n        t+=dt*exp(-s*c);\n        vec3 a = step(t,one3*tminmax.y);\n        vec3 pos = ro+t*rd;\n        \n        c.x = map(ro+t.x*rd, sctime);\n        c.y = map(ro+t.y*rd, sctime);\n        c.z = map(ro+t.z*rd, sctime);               \n        \n        col = mix(col, .99*col+ .08*c*c*c, a);\n    }\n    \n    vec3 c0 = vec3(0.4,0.3,0.99);\n    vec3 c1 = vec3(0.9,0.7,0.0);\n    vec3 c2 = vec3(0.9,0.1,0.2);\n    return c0 * col.x + c1 * col.y + c2 * col.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm, vec2(sin(iTime), cos(iTime)));\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdByD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 136, 166, 166, 221], [222, 222, 244, 244, 293], [296, 296, 315, 315, 362], [364, 364, 426, 426, 612], [614, 614, 649, 649, 924], [928, 928, 993, 1047, 1722], [1725, 1725, 1782, 1782, 2581]]}
{"id": "XdByRK", "name": "Learning Raymarching a", "author": "otiose", "description": "learning stuff", "tags": ["raymarching"], "likes": 4, "viewed": 103, "date": "1492687935", "time_retrieved": "2024-06-20T18:53:33.089996", "image_code": "float map(vec3 p){\n    //vec3 q = fract(p) * 2.0 - 1.0;\n    float r = 4.0 * (sin(iTime) + 1.4);\n    vec3 q = mod(p,r)-0.5*r;\n    vec3 c = vec3(0.0, 0.0, 0.05);\n    \n\treturn min(min(min(length(q) - (1.1 + sin(iTime + length(p * 0.4) * 2.0)) * 0.25, length(q.xz-c.xy)-c.z), length(q.xy-c.xy)-c.z), length(q.yz-c.xy)-c.z);\n}\n\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 30; ++i){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.8;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float fov = 30.0 * (sin(iTime*0.5)+1.02);\n    \n    uv = uv * fov - fov / 2.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,  1.0));\n    \n    float the =  0.2 * iTime;\n    //r.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0, 0.0, (1.0 + sin(iTime)) * 3.0); //Camera\n    \n    float t = trace(o, r);\n    \n    float fog = (3.0 * sin(iTime * 2.0) + 4.0) * 1.0 / (1.0 + t * t * 0.1);\n    \n    if(fog < 0.3)fog *= 2.0 * (1.5 + sin(iTime * 0.2));\n    \n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fog * uv.x, fog, fog * uv.y, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdByRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 18, 55, 321], [323, 323, 351, 351, 498], [500, 500, 557, 557, 1267]]}
{"id": "XdByRw", "name": "Wave table", "author": "52GW", "description": "Just playing around learning volumetric rendering. This is a work in progress, but I figured it is at least slightly interesting.\n\nThe mouse controls the light location.", "tags": ["reflection", "waves", "volumetric", "shadows"], "likes": 11, "viewed": 253, "date": "1491444348", "time_retrieved": "2024-06-20T18:53:34.132510", "image_code": "// A first exercise for myself. Mybe I'll make it juggle a couple balls next next!\n\n// for higher frame rate, turn fisheye off and reduce reflections to 1\nconst bool fisheye = true;\nconst int reflections = 2;\n\nconst float PI = 3.1415926536;\nconst float max_depth = 15.0;\n\nconst float time_f = 0.4;\nconst float FOV = radians(65.0);\nconst float tilt = -20.0 * PI/180.0;\nconst float rotate = -30.0 * PI/180.0;\nconst vec3 eye_pos = vec3(-0.5, 0.0, -6.7)\n    * mat3(1.0,0.0,0.0,0.0,cos(tilt),sin(tilt),0.0,-sin(tilt),cos(tilt))\n    * mat3(cos(rotate),0.0,sin(rotate),0.0,1.0,0.0,-sin(rotate),0.0,cos(rotate));\n\n// Shiny, bouncy ball\nconst float r_ball = 0.8;\nconst float ball_y = 0.3;\nconst float disp_y = 0.1;\n\nvec3 o_ball;\n\nfloat BallDistance(vec3 pos, float r) {\n    return distance(pos, o_ball) - r;\n}\n\n// The box holding the waves\nconst float box_size = 3.0;\t\t\t\t// half the box width and height (inside)\nconst float box_thickness = 0.1;\t\t// thickness of box walls\nconst float box_top = 0.3;\nconst float box_bottom = -0.8;\n\nfloat BoxDistance(vec3 pos) {\n    float outside = max(abs(pos.x) - (box_size + box_thickness),\n                        \t  abs(pos.z) - (box_size + box_thickness));\n    float inside = min(box_size - abs(pos.x),\n                       \t\t box_size - abs(pos.z));\n    return max(max(outside, inside), max(box_bottom - pos.y, pos.y - box_top));\n}\n\n// Wavy pool\nconst float reflect_f = 0.8;\t\t\t// waves reflect off the sides (only once), this is how much gets reflected\nconst vec2 o_wave1 = vec2(-1.7,-0.9);\t// wave origins\nconst vec2 o_wave2 = vec2(1.7,0.3);\nconst float m_wave1 = 0.1;\t\t\t\t// wave magnitudes\nconst float m_wave2 = 0.14;\nconst float f_wave1 = 10.0;\t\t\t\t// wave frequencies\nconst float f_wave2 = 9.0;\nconst int num_points = 2;\t\t\t\t// change to 1 to remove second wave\n\nconst vec2 o[10] = vec2[10](o_wave1, vec2(-6.0-o_wave1.x, o_wave1.y), vec2(6.0-o_wave1.x, o_wave1.y),\n                                     vec2(o_wave1.x, -6.0-o_wave1.y), vec2(o_wave1.x, 6.0-o_wave1.y),\n                            o_wave2, vec2(-6.0-o_wave2.x, o_wave2.y), vec2(6.0-o_wave2.x, o_wave2.y),\n                                     vec2(o_wave2.x, -6.0-o_wave2.y), vec2(o_wave2.x, 6.0-o_wave2.y));\nconst float m[10] = float[10](m_wave1, m_wave1*reflect_f, m_wave1*reflect_f, m_wave1*reflect_f, m_wave1*reflect_f,\n                              m_wave2, m_wave2*reflect_f, m_wave2*reflect_f, m_wave2*reflect_f, m_wave2*reflect_f);\nconst float f[10] = float[10](f_wave1, f_wave1, f_wave1, f_wave1, f_wave1,\n                              f_wave2, f_wave2, f_wave2, f_wave2, f_wave2);\n\nvec3 o_disp;\n\nfloat PoolDistance(vec3 pos) {\n    float dist = pos.y;\n    for(int i=0; i<num_points*5; ++i) {\n        float d = distance(pos.xz,o[i]);\n        d = mix(0.3,d,smoothstep(0.0,0.09,d*d));\n      \tdist -= pow(sin((d-iTime*time_f)*f[i])*0.5+0.5,2.0)/(d+0.3)*m[i];\n    }\n    float disp_dist = 4.0*pow(distance(vec3(pos.x,-1.0,pos.z), o_disp) + 1.0, -3.0);\n    return max(max(abs(pos.x) - box_size, abs(pos.z) - box_size),\n               max(box_bottom - pos.y, dist + disp_dist));\n}\n\n// Ray marching to the objects\nfloat pool_dist;\nfloat ball_dist;\nfloat box_dist;\n\nfloat RayMarch(vec3 start_pos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 255 && depth < max_depth; i++) {\n        vec3 pos = start_pos + dir * depth;\n        pool_dist = PoolDistance(pos);\n        ball_dist = BallDistance(pos, r_ball);\n        box_dist = BoxDistance(pos);\n        float dist = min(min(pool_dist, ball_dist), box_dist);\n        if (abs(dist) < 0.001) {\n        \treturn depth;\n        }\n        depth += 0.9 * dist;\n    }\n    return max_depth;\n}\n\n// Normals to our objects\nconst float DX = 0.01;\nconst vec3 dx = vec3(DX, 0.0, 0.0);\nconst vec3 dy = vec3(0.0, DX, 0.0);\nconst vec3 dz = vec3(0.0, 0.0, DX);\n\nvec3 PoolNormal(vec3 pos) {\n    return normalize(vec3(\n        PoolDistance(pos + dx) - PoolDistance(pos - dx),\n        PoolDistance(pos + dy) - PoolDistance(pos - dy),\n        PoolDistance(pos + dz) - PoolDistance(pos - dz)\n    ));\n}\nvec3 BallNormal(vec3 pos) {\n    return normalize(pos - o_ball);\n}\nvec3 BoxNormal(vec3 pos) {\n    return normalize(vec3(\n        BoxDistance(pos + dx) - BoxDistance(pos - dx),\n        BoxDistance(pos + dy) - BoxDistance(pos - dy),\n        BoxDistance(pos + dz) - BoxDistance(pos - dz)\n    ));\n}\n\n// Needs rework, but sample the point we hit\nvec3 sample_normal;\nfloat sample_reflect;\n\nvec3 sampler(vec3 pos, vec3 light_dir) {\n    vec3 color;\n    \n    if (pool_dist < 0.001) {\n        sample_normal = PoolNormal(pos);\n        color = vec3(0.0,1.0,0.4);\n        sample_reflect = 0.2;\n    }\n    else if (ball_dist < 0.001) {\n        sample_normal = BallNormal(pos);\n        color = vec3(0.1,0.2,0.3);\n        sample_reflect = 0.8;\n    }\n    else if (box_dist < 0.001) {\n        sample_normal = BoxNormal(pos);\n        color = vec3(0.3,0.0,0.1);\n        sample_reflect = 0.5;\n    }\n    float shadow_dist = RayMarch(pos + 0.02*light_dir, light_dir);\n    float diffuse = clamp(dot(light_dir, sample_normal), 0.0, step(max_depth-0.1, shadow_dist)) +\n        0.2*clamp(dot(vec3(0.0,1.0,0.0), sample_normal), 0.0, 1.0);\n    return color * diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // vectors from eye and light\n    vec2 xy = fragCoord - vec2(0.5,0.5)*iResolution.xy;\n    vec3 ray_dir;\n    if (fisheye) {\n\t    ray_dir = normalize(vec3(xy, cos(2.0*FOV/iResolution.x*length(xy)) * iResolution.x));\n    } else {\n\t    ray_dir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    }\n    ray_dir.yz *= mat2(cos(tilt),sin(tilt),-sin(tilt),cos(tilt));\n    ray_dir.xz *= mat2(cos(rotate),sin(rotate),-sin(rotate),cos(rotate));\n    vec2 mouse_pos = (iMouse.xy == vec2(0.0) ? vec2(0.7,0.25) : iMouse.xy / iResolution.xy) * vec2(6.2832,2.0);\n    vec3 light_dir = normalize(vec3(-sin(mouse_pos.x), mouse_pos.y, cos(mouse_pos.x)));\n\n    // animate the wave displacement and ball\n    float anim_d = fract((-iTime * time_f + 0.19) * f[0] * (0.25/PI));\n    o_ball.xz = mix(o_wave1, o_wave2, 0.5 - 0.45*cos(anim_d * 2.0*PI));\n    anim_d = fract((-iTime * time_f + 0.14) * f[0] * (0.5/PI)) - 0.5;\n    anim_d *= anim_d;\n    o_ball.y = ball_y + (1.0 - 8.0*anim_d) / (1.0 + 256.0*pow(anim_d, 4.0));\n    \n    anim_d = fract((-iTime * time_f + 0.05) * f[0] * (0.25/PI));\n    o_disp.xz = mix(o_wave1, o_wave2, 0.5 - 0.45*cos(anim_d * 2.0*PI));\n    anim_d = fract(2.0*anim_d) - 0.5;\n    anim_d *= anim_d;\n    o_disp.y = disp_y + (1.0 - 12.0*anim_d) / (1.0 + 48.0*anim_d*anim_d);\n\n    float depth = RayMarch(eye_pos, ray_dir);\n    if (depth >= max_depth) {\n        // the background is the background, does not get reflected or anything\n        fragColor = vec4(0.1,0.2,0.4,1.0);\n    } else {\n        // sample the fragment\n        vec3 pos = eye_pos + ray_dir * depth;\n\t\tfragColor = vec4(sampler(pos, light_dir),1.0);\n\n        // and then add any reflections\n        float r_factor = sample_reflect;\n\t    for (int i = 0; i < reflections; ++i ) {\n            ray_dir = reflect(ray_dir, sample_normal);\n            pos += 0.02*ray_dir;\n\n            depth = RayMarch(pos, ray_dir);\n            if (depth >= max_depth) break;\n\n            pos += ray_dir * depth;\n            fragColor.rgb += r_factor * sampler(pos, light_dir);\n            r_factor *= sample_reflect;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdByRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[606, 721, 760, 760, 800], [802, 1023, 1052, 1052, 1364], [1760, 2604, 2634, 2634, 3079], [3081, 3163, 3205, 3205, 3637], [3639, 3797, 3824, 3824, 4031], [4032, 4032, 4059, 4059, 4097], [4098, 4098, 4124, 4124, 4325], [4327, 4415, 4455, 4455, 5170], [5172, 5172, 5227, 5261, 7322]]}
{"id": "XdByzc", "name": "compiler fails on matrix", "author": "ollj", "description": "//within 2 loops, were n and k are ALWAYS only\nint k=0;int n=0;\n//and\n    mat3 T=mat3(0);\n           T[n][k] = 0.;//refuses to compile\n           T[0][0] = 0.;//compiles just fine\n           T[1][1] = 0.;//compiles just fine\n\non win7 Firefox", "tags": ["error", "compatibility", "compiler"], "likes": 0, "viewed": 493, "date": "1493050836", "time_retrieved": "2024-06-20T18:53:34.532353", "image_code": "//pinnied down a compilation error that i got on\n//https://www.shadertoy.com/view/lsjcRK\n\n\n//uncomment the line below to have it compile by explicit const types.\n//#define DoConst\n\n\n//cartToBary refuses to compile. \"parameters require 1-value arguments\nvec4 cartToBary(){//from cartesian to barycentric coordinates\n    mat3 T=mat3(0);\n   // for(int n = 0; n < 1; n++){\n   //      for(int k = 0; k < 1; k++){\n   \n   //worse, even without a loop this fails:\n    \n   #ifndef DoConst\n   int n=0;\n   int k=0;\n   #else\n   const int n=0;//compiles just fine\n   const int k=0;//compiles just fine\n   #endif\n    \n   //type const int                  compiles fine\n   //type       int                  fails to commpile\n   //type    for(int i=0;i<1.;i++){} fails to commpile\n  \n           T[n][k] = 2.;//refuses to compile       <- BAAAAAD\n         //T[k][n] = 2.;//refuses to compile       <- BAAAAAD\n           T[0][k] = 2.;//compiles just fine    <- but but, this is fine?\n           T[0][n] = 2.;//compiles just fine    <- but but, this is fine?\n           T[k][0] = 2.;//compiles just fine    <- but but, this is fine?\n           T[n][0] = 2.;//compiles just fine    <- but but, this is fine?\n           //just to make REALLY sure:\n           T[n].x  = 2.;//compiles just fine\n           T[k].x  = 2.;//compiles just fine\n           T[0][0] = 2.;//compiles just fine\n           T[1][1] = 2.;//compiles just fine\n \n  //      }\n  //  }\n    return vec4(0);\n}\n\n\n//tiny default main:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    vec4 a=vec4(0);    \n    a= cartToBary();//this refuses to compile\n        \n    \n        \n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdByzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[182, 253, 271, 314, 1450], [1453, 1474, 1531, 1531, 1729]]}
{"id": "XdByzy", "name": "Dancing stick figures", "author": "Eybor", "description": "The shader I wrote for the shader showdown qualifications at Revision 2017", "tags": ["2d", "dance", "stickfigures"], "likes": 14, "viewed": 23995, "date": "1492536789", "time_retrieved": "2024-06-20T18:53:34.926385", "image_code": "#define PI 3.141592\n\nfloat head(vec2 pos, vec2 uv)\n{\n    vec2 v = pos-uv;\n    float d = dot(v, v) *10.-1.;\n    return smoothstep(0., 0.03, d*d);\n}\n\nfloat body(vec2 pos, vec2 uv)\n{\n    vec2 v = pos - uv;\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    return clamp(smoothstep(0., .1, dx*100.)+smoothstep(.5, .6, d), 0., 1.);\n}\n\nvec2 rotation(vec2 p, float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle))*p;\n}\n\nfloat leg(vec2 pos, vec2 uv, float angle)\n{\n    vec2 v = rotation(pos - uv, angle) - vec2(0., .5);\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    return clamp(smoothstep(0., .1, dx*100.)+smoothstep(.2, .3, d), 0., 1.);\n}\n\nfloat arm(vec2 pos, vec2 uv, float angle1, float angle2)\n{\n    vec2 v = rotation(pos - uv, angle1) - vec2(0., .35);\n    float dx = v.x*v.x;\n    float d = dot(v, v);\n    vec2 v2 = rotation(v - vec2(0., .35), angle2) - vec2(0., .35);\n    float dx2 = v2.x*v2.x;\n    float d2 = dot(v2, v2);\n    return clamp(smoothstep(0., .1, dx*100.)+smoothstep(.1, .15, d), 0., 1.)*\n        clamp(smoothstep(0., .1, dx2*100.)+smoothstep(.1, .15, d2), 0., 1.);\n}\n\nfloat stickman(vec2 pos, vec2 uv, float bass, float angle1, float angle2)\n{\n    vec2 v = uv-pos;\n    float d = head(vec2(0., .8), v*1.5);\n    d *= body(vec2(0., -.1), v*2.);\n    d *= leg(vec2(0., -.8), v*2., angle1);\n    d *= leg(vec2(0., -.8), v*2., -angle1);\n    d *= arm(vec2(0., .65), v*2., angle2+bass, iTime+bass*2.);\n    d *= arm(vec2(0., .65), v*2., -(angle2+bass), -iTime+bass*2.);\n   \treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.+2.*fragCoord.xy/iResolution.xy)*vec2(iResolution.x/iResolution.y, 1.);\n    \n    float bass = 0.;\n    \n    for(float f = 0.; f <= .25; f += 1./100.)\n    {\n        bass += texture(iChannel0, vec2(f, .25)).x;\n    }\n    \n    bass = -1.+2.*bass;\n    \n    vec3 co = vec3(1.);\n    \n    co *= stickman(vec2(0., 0.), uv, bass, PI/8., PI/4.);\n    co *= stickman(vec2(-1., 0.), uv, bass, PI/8., PI);\n    co *= stickman(vec2(1., 0.), uv, bass, PI/3., PI/3.);\n    \n    co *= vec3(sin(uv.x), cos(uv.x), sin(uv.x*uv.y));\n    \n    fragColor = vec4(co, 1.0);\n}", "image_inputs": [{"id": "ldBGWd", "previewfilepath": "https://soundcloud.com/xmatthewryanx/fs-reid-speed-bass-monster", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/xmatthewryanx/fs-reid-speed-bass-monster", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdByzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[21, 21, 52, 52, 146], [148, 148, 179, 179, 330], [332, 332, 368, 368, 438], [440, 440, 483, 483, 666], [668, 668, 726, 726, 1111], [1113, 1113, 1188, 1188, 1519], [1521, 1521, 1578, 1578, 2138]]}
{"id": "XdjcWh", "name": "Sketch_Circles", "author": "cexlearning", "description": "Circkes， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 10, "viewed": 150, "date": "1491970520", "time_retrieved": "2024-06-20T18:53:34.926385", "image_code": "float circle(vec2 coord, vec2 offs)\n{\n    float reso = 16.0;\n    float cw = iResolution.x / reso;\n\n    vec2 p = mod(coord, cw) + offs * cw;\n    float d = distance(p, vec2(cw / 2.0));\n\n    vec2 p2 = floor(coord / cw) - offs;\n    vec2 gr = vec2(0.443, 0.312);\n    float t = iTime * 2.0 + dot(p2, gr);\n\n    float l = cw * (sin(t) + 1.2) * 0.4;\n    float lw = 1.5;\n    return max(0.0, 1.0 - abs(l - d) / lw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = 0.0;\n    for (int i = 0; i < 9; i++)\n    {\n        float dx = mod(float(i), 3.0) - 1.0;\n        float dy = float(i / 3) - 1.0;\n        c += circle(fragCoord.xy, vec2(dx, dy));\n    }\n    fragColor = vec4(vec3(min(1.0, c)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjcWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 37, 37, 406], [408, 408, 465, 465, 707]]}
{"id": "XdjcWz", "name": "Simple pattern music visualizer", "author": "Ruzzyr", "description": "Some simple experimentation with patterns and music. Feedback is always welcome :)", "tags": ["simple", "music", "sine", "pattern"], "likes": 11, "viewed": 256, "date": "1491645326", "time_retrieved": "2024-06-20T18:53:34.926385", "image_code": "vec3 color1 = vec3(20,30,48)/255.;\nvec3 color2 = vec3(36,59,85)/255.;\n\nvec3 color11 = vec3(255,95,109)/255.;\nvec3 color12 = vec3(255,195,113)/255.;\n\nmat2 rotateAroundZ(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 tUv = fragCoord.xy / iResolution.xy*aspect;\n    vec2 uv;\n\tuv.y = (fragCoord.y / iResolution.y)*4. - 2.;\n    uv.y = 1.0 - pow(abs(uv.y), 1.0);\n    //uv.y = 1.0 - pow(abs(sin(3.14*uv.y)), 1.5);\n\n    uv.x = fragCoord.x / iResolution.x * aspect.x*4. - 3.5;\n        uv.x = 1.0 - pow(abs(uv.x), 1.0);\n\n    fragColor = vec4(mix(color1, color2, sin(tUv.y)), 0.);\n    float audio = texture(iChannel0, vec2(0.25,tUv.y)).x;\n    for( int i = 0; i < 20; i++)\n    {\n        float pos = float(i+1);\n        vec2 locUv = uv*rotateAroundZ(.314*pos);\n\t\tlocUv.y += iTime/4.;\n        locUv.x += abs(sin(iTime/4.))*0.1;\n\n        float offset = audio;\n        //float offset = cos(locUv.y*iTime/160.)*audio;\n        float mainTrunk = sin(locUv.y*3.)*abs(cos(locUv.y*2.))*0.5;\n        float func = \n            smoothstep(mainTrunk, mainTrunk +0.03, locUv.x - offset + 0.4*(1.- tUv.y)) - \n            smoothstep(mainTrunk, mainTrunk +0.03, locUv.x - offset);\n        fragColor.a += func*0.2;\n        \n    }\n    vec4 color = vec4(mix(color1, color2, tUv.y), 1.0);\n    vec4 color1 = vec4(mix(color12, color11, length(uv*3.)), 1.0);\n    fragColor = mix(color,color1,fragColor.a);\n\n}", "image_inputs": [{"id": "XdSGWt", "previewfilepath": "https://soundcloud.com/playstation/transistor-we-all-become", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/playstation/transistor-we-all-become", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjcWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[149, 149, 182, 182, 266], [269, 269, 326, 326, 1547]]}
{"id": "XdjyDm", "name": "functions graph", "author": "viknewbie", "description": "a basic plotting functions visualizer with anti-aliasing", "tags": ["beginner", "graph", "function", "plot", "cartesian", "short"], "likes": 5, "viewed": 150, "date": "1492399273", "time_retrieved": "2024-06-20T18:53:34.926385", "image_code": "#define PI 3.141592653589793\n\nvoid plot(\n    float formula, float y,\n    float size, \n    inout vec3 pixel, vec3 color\n){\n    pixel = mix(color,pixel,smoothstep(size-size*.5,size, abs(formula-y)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 p = vec3(1.);\n    // cf FabriceNeyret2's comment\n    /*\n    vec2 s = fragCoord.xy/iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    float w = .008;\n    //*/\n\tvec2  s = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    float w = 2./iResolution.y;\n    float t = iTime;\n    // some ugly colors ;)\n    // TODO hsl -> rgb\n    vec3 axe = vec3(.0,1.,1.),\n     \t c1  = vec3(.3),\n         c2  = vec3(1.,1.,.0),\n         c3  = vec3(1.,.0,1.),\n         c4  = vec3(.485,.879,.716);\n    \n    // cf FabriceNeyret2's comment\n    /*\n\ts = s*2.-1.;\n    s.r *= r;\n\t//*/    \n\n    p  = vec3(step(mod(s.x,.1),w));\n    p += vec3(step(mod(s.y,.1),w));\n    p  = mix(c1,vec3(1.),p);\n    \n    if( abs(s.y) < w ) p = axe;\n    if( abs(s.x) < w ) p = axe;\n    \n    plot(-s.x*s.x, \t\t\t\t\t   s.y, w, \t   p, c2);\n    plot(s.x*s.x*s.x, \t\t\t\t   s.y, w*2.,  p, c4);\n    plot(sin(s.x*PI*2.+t*1.5)*.25+.25, s.y, w*1.5, p, c3);\n    plot(exp(-4.*s.x*s.x)*.9,\t\t   s.y, w,\t   p, vec3(1.,.0,.0));\n    \n    fragColor = vec4(p,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjyDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[30, 30, 121, 121, 199], [201, 201, 255, 255, 1261]]}
{"id": "XdjyRm", "name": "3D spectrum circle", "author": "croxxx", "description": "This shader was created as part of a small first demoscene project for a university course.\nIt displays cubes reacting to music in a circular pattern.\n\nYou can watch the demo this was taken from here: https://www.youtube.com/watch?v=eUk_yZvCj5s", "tags": ["3d", "raymarching", "sound", "lighting", "shadows", "visualizer"], "likes": 25, "viewed": 3036, "date": "1491389183", "time_retrieved": "2024-06-20T18:53:36.623465", "image_code": "// ##############################\n// BEGIN\tIQ methods\n// ##############################\n\n// Calculate matrix for camera looking at a specific target\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n// ##############################\n// END\t\tIQ methods\n// ##############################\n\n\n#define PI 3.14159265\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// ##############################\n// BEGIN\tCamera helpers\n// ##############################\nuniform float iCamPosX;\nuniform float iCamPosY;\nuniform float iCamPosZ;\nuniform float iCamRotX;\nuniform float iCamRotY;\nuniform float iCamRotZ;\n\nvec3 calcCameraPos()\n{\n\treturn vec3(iCamPosX, iCamPosY, iCamPosZ);\n}\nvoid rotateAxis(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)\n{\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / resolution.x;\n\tvec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n\trotateAxis(rayDir.yz, iCamRotX);\n\trotateAxis(rayDir.xz, iCamRotY);\n\trotateAxis(rayDir.xy, iCamRotZ);\n\treturn rayDir;\n}\n// ##############################\n// END\t\tCamera helpers\n// ##############################\n\n// Change this to change repetition interval\nfloat afFrequencies[8];\n\nfloat cubeCircle(vec3 point, float radius, int count, vec3 cubeSize)\n{\n\tfloat c = pModPolar(point.xz, float(count));\n\tfloat index = floor(c + float(count)/2. -1.);\n\n\treturn fBox( point-vec3(radius,0,0), cubeSize + vec3(0, 0.3 + 0.7*afFrequencies[int(mod(index,float(afFrequencies.length())))] , 0));\n}\n\n//\tCalculates distance to nearest object given a point\nfloat distFunc( vec3 point )\n{\n\t//\tparameters\n\tint circleTiles = 64;\n\tfloat radius = 4.;\n\tvec3 cubeSize = vec3(0.1);\n\n\t//\tdistance to floor plane\n\tfloat planeDist = sdPlane(point);\n\n\t//\tdistances to the cube circles\n\tfloat cubesCircleBigDist = cubeCircle(point, radius, circleTiles, cubeSize);\n\tfloat cubesCircleSmallDist = cubeCircle(point, radius/2., circleTiles/2, cubeSize);\n\n\t//\tblack cube in the center\n\tpoint.y -= 1.0;\n\trotateAxis(point.yz, radians(45.0));\n\trotateAxis(point.xy, PI/4.);\n\tfloat boxDist = fBox( point, 5.*cubeSize*afFrequencies[1] );\n\n\t//\treturn closest object\n\treturn min(min(min(cubesCircleBigDist, boxDist), cubesCircleSmallDist), planeDist);\n}\n\nvec3 getNormal( in vec3 pos )\n{\n\t// IQ\n\tvec2 e = vec2( 1.0,-1.0 ) * 0.001;\n\treturn normalize( e.xyy*distFunc( pos + e.xyy ) +\n\te.yyx*distFunc( pos + e.yyx ) +\n\te.yxy*distFunc( pos + e.yxy ) +\n\te.xxx*distFunc( pos + e.xxx ) );\n}\n\nvec3 getMaterialColor(vec3 point)\n{\n\t//\tfloor color\n\tif(point.y < 0.0001)\n\t{\n\t\treturn vec3( 0.5 );\n\t}\n\n\t//\tcolor for center area\n\tif(length(point.xz) < 1.0)\n\t{\n\t\treturn vec3( 0.0, 0.0, 0.0 );\n\t}\n\n\t//\totherwise determine color based on angle\n\tfloat count = 64.;\n\n\t//\tCalculate ID for each segment of the circular rotation\n\tfloat c = pModPolar(point.xz, count);\n\n\treturn vec3(0.45*sin(((c+iTime)/count)*2.*PI)+0.55);\n}\n\nfloat softshadow(const vec3 origin, in vec3 dir, in float mint, in float tmax, float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = distFunc( origin + dir*t );\n\t\tres = min( res, k*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nfloat ambientOcclusion(vec3 point, float delta, int samples)\n{\n\tvec3 normal = getNormal(point);\n\tfloat occ = 0.;\n\tfor(float i = 1.; i < float(samples); ++i)\n\t{\n\t\tocc += (2.0/i) * (i * delta - distFunc(point + i * delta * normal));\n\t}\n\t// occ = clamp(occ, 0, 1);\n\treturn 1. - occ;\n}\n\n\n//\tLighting settings\n#define ENABLE_SHADOWS\n//#define ENABLE_OCCLUSION\n\nconst float lightAttenuation = 0.00;\n\nvec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )\n{\n\t//\tlight relative to camera position\n\tvec3 lightPosition = vec3(sin(iTime), 3.0, cos(iTime));\n\n\t//\tSpecular highlight factor\n\tfloat materialShininess = 64.0;\n\tvec3 materialSpecularColor = vec3( 1.0 );\n\n\t//\tOutput color\n\tvec3 outputColor = vec3( 0.0 );\n\n\t//\tCalculate eye vector and its reflection\n\tvec3 surfaceToLight = normalize(lightPosition - hitPosition);\n\tvec3 surfaceToCamera = normalize(cameraPosition - hitPosition);\n\n\t//\tsurface color\n\tvec3 surfaceColor = getMaterialColor(hitPosition);\n\n\t//\tambient component\n    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*smoothstep(-0.3, 1.0, afFrequencies[0]);\n\tvec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor\n\n\t//\tdiffuse component\n\tfloat diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));\n\tvec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;\n\n\t//\tspecular component\n\tfloat specularCoefficient = 0.0;\n\tif(diffuseCoefficient > 0.0) {\n\t\t//specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);\n\t}\n\tvec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;\n\n\t//\tlight attenuation (falloff based on distance, fog)\n\tfloat distanceToLight = length(lightPosition - hitPosition);\n\tfloat attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.0));\n\n\t//\tsoft shadows (optional)\n\tfloat shadow = 1.0;\n\t#ifdef ENABLE_SHADOWS\n\tshadow = max(0.2, softshadow(hitPosition, surfaceToLight, 0.01, 5.0, 8.0));\n\t#endif\n\n\t//\tambient occlusion (optional)\n\tfloat occlusionCoefficient = 1.0;\n\t#ifdef ENABLE_OCCLUSION\n\tocclusionCoefficient = ambientOcclusion(hitPosition, 0.01, 10);\n\t#endif\n\n\t//\tcalculate final color\n\toutputColor = ambientColor + occlusionCoefficient * shadow * attenuation*(diffuseColor + specularColor);\n\n\t//\tgamma correction\n\t//vec3 gamma = vec3(1.0/2.2);\n\t//outputColor = vec3(pow(outputColor, gamma));\n\n\t//\treturn shading result\n\treturn outputColor;\n}\n\nconst float epsilon = 0.0001;\nconst int maxSteps = 256;\nconst float maxT = 20.0;\nfloat trace(vec3 ro, vec3 rd, out vec3 point, out bool objectHit)\n{\n\tfloat t = 0.0;\n\tpoint = ro;\n\n\tfor(int steps = 0; steps < maxSteps; ++steps)\n\t{\n\t\t//check how far the point is from the nearest surface\n\t\tfloat dist = distFunc(point);\n\t\t//if we are very close\n\t\tif(epsilon > dist)\n\t\t{\n\t\t\tobjectHit = true;\n\t\t\tbreak;\n\t\t}\n\t\t//not so close -> we can step at least dist without hitting anything\n\t\tt += dist;\n\t\t// return immediately if maximum t is reached\n\t\tif(t > maxT)\n\t\t{\n\t\t\tobjectHit = false;\n\t\t\treturn maxT;\n\t\t}\n\t\t//calculate new point\n\t\tpoint = ro + t * rd;\n\t}\n\n\treturn t;\n}\n\nvoid populateSoundArray()\n{\n    // Get FFT values from texture\n    for (int i = 0; i < afFrequencies.length(); i++)\n    {\n        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.25) ).x;\n    }\n}\n\nconst int reflectionBounces = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fill arrays for sound things\n    populateSoundArray();\n    \n\t//\tSet up Camera\n\tvec3 camP = calcCameraPos(); // Camera position\n\n\t//\tMove camera in a circle\n\tcamP += vec3(5.0*cos(iTime*0.25), 1.5*cos(iTime*0.2)+2.5,  5.0*sin(iTime*0.25));\n\n\t//\tAlways look at center\n\tvec3 target = vec3(0.0);\n\tmat3 cameraMatrix = setCamera( camP, target, 0.0 );\n\tvec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n\tvec3 camDir = cameraMatrix * normalize( vec3(p.xy, 2.0) );\n\n\t//\tSet up ray\n\tvec3 point;\t\t// Set in trace()\n\tbool objectHit;\t// Set in trace()\n\n\t//\tInitialize color\n\tvec3 color = vec3(0.0);\n\n\tfloat t = trace(camP, camDir, point, objectHit);\n\tif(objectHit)\n\t{\n\t\t//\tLighting calculations\n\t\tvec3 normal = getNormal(point);\n\t\tcolor = getShadedColor( point, normal, camP );\n\n\t\t//\tReflections\n\t\tfor(int i = 0; i < reflectionBounces; i++)\n\t\t{\n\t\t\tvec3 pointRef;\t// Set in trace()\n\t\t\tcamDir = reflect(camDir, normal);\n\t\t\ttrace(point + camDir*0.001, camDir, pointRef, objectHit);\n\t\t\tif(objectHit)\n\t\t\t{\n\t\t\t\t// Get color of reflection\n\t\t\t\tcolor += 0.1 * getShadedColor( pointRef, getNormal(pointRef), point );\n\t\t\t}\n\t\t\tpoint = pointRef;\n\t\t}\n\t}\n\n\t//\tfog\n\tvec3 fogColor = vec3( 0.1, 0.3, 0.8);\n\tfloat FogDensity = 0.005;\n\tfloat fogFactor = 1.0 /exp(t * FogDensity);\n\tfogFactor = clamp( fogFactor, 0.0, 1.0 );\n\tcolor = mix(fogColor, color, fogFactor);\n\n\tfragColor = vec4(color, clamp((t-6.0)/15.0, 0.0, 1.0));\n}", "image_inputs": [{"id": "Ms23D3", "previewfilepath": "https://soundcloud.com/namatjira/namatjira-stvn-drizzly-summer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/namatjira/namatjira-stvn-drizzly-summer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjyRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[89, 149, 201, 201, 375], [376, 487, 507, 507, 542], [543, 543, 571, 571, 652], [653, 653, 678, 678, 693], [695, 808, 858, 858, 1248], [1251, 1488, 1510, 1510, 1556], [1557, 1557, 1597, 1597, 1639], [1640, 1640, 1707, 1707, 1993], [2086, 2156, 2226, 2226, 2457], [2459, 2514, 2544, 2559, 3183], [3185, 3185, 3216, 3223, 3412], [3414, 3414, 3449, 3465, 3830], [3832, 3832, 3921, 3921, 4154], [4156, 4156, 4218, 4218, 4437], [4484, 4550, 4625, 4663, 6603], [6686, 6686, 6753, 6753, 7263], [7265, 7265, 7292, 7327, 7497], [7532, 7532, 7589, 7625, 9001]]}
{"id": "XdjyW1", "name": "Sketch_Hex2", "author": "cexlearning", "description": "Hex2， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 3, "viewed": 78, "date": "1492327536", "time_retrieved": "2024-06-20T18:53:36.623465", "image_code": "const float PI = 3.141592;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy - iResolution.xy * 0.5;\n\n    float phi = atan(coord.y, coord.x + 1e-6);\n    phi = phi / PI * 0.5 + 0.5;\n    float seg = floor(phi * 6.0);\n\n    float theta = (seg + 0.5) / 6.0 * PI * 2.0;\n    vec2 dir1 = vec2(cos(theta), sin(theta));\n    vec2 dir2 = vec2(-dir1.y, dir1.x);\n\n    float l = dot(dir1, coord);\n    float w = sin(seg * 31.374) * 18.0 + 20.0;\n    float prog = l / w + iTime * 2.0;\n    float idx = floor(prog);\n\n    float phase = iTime * 0.8;\n    float th1 = fract(273.84937 * sin(idx * 54.67458 + floor(phase      )));\n    float th2 = fract(273.84937 * sin(idx * 54.67458 + floor(phase + 1.0)));\n    float thresh = mix(th1, th2, smoothstep(0.75, 1.0, fract(phase)));\n\n    float l2 = dot(dir2, coord);\n    float slide = fract(idx * 32.74853) * 200.0 * iTime;\n    float w2 = fract(idx * 39.721784) * 500.0;\n    float prog2 = (l2 + slide) / w2;\n\n    float c = clamp((fract(prog) - thresh) * w * 0.3, 0.0, 1.0);\n    c *= clamp((fract(prog2) - 1.0 + thresh) * w2 * 0.3, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdjyW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[28, 28, 85, 85, 1134]]}
{"id": "XdlcWf", "name": "position offsetting", "author": "macbooktall", "description": "discontinuous floored displacements of an sdf. low coefficients can create a nice effect, but naturally creates artifacts.\nbase raymarching code from iq.\npModPolar and fOctahedron from Mercury's hg_sdf library.", "tags": ["raymarching"], "likes": 59, "viewed": 4417, "date": "1491869536", "time_retrieved": "2024-06-20T18:53:37.684036", "image_code": "//  hg_sdf by MERCURY http://mercury.sexy\n// \tReleased as Creative Commons Attribution-NonCommercial (CC BY-NC)\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d1);\n}\n\nfloat roomWidth = .5;\n\nvec2 map( in vec3 pos ){\n  \tfloat rep = 4.;\n\tvec3 p = pos;\n\n    vec2 idx = floor((abs(pos.xz)) / 0.2)*0.5;\n\n    float clock = iTime*4.;\n    float phase = (idx.y+idx.x);\n\n    float anim = sin(phase + clock);\n\n    float i = pModPolar(pos.xz, rep);\n    pos.x -= .75 + anim*0.1;\n\n    float dist = fOctahedron(pos,roomWidth*.6);\n\n    dist = opU(dist, fOctahedron(p, roomWidth*1.25 + anim*0.05));\n                           \n    vec2 res = vec2(dist, 0.);\n\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 60.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n   \t\tvec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n    \tm = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0., 0.1 );\n        if(t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + .15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(1.);\n    vec2 res = castRay(ro,rd);\n    const vec3 a = vec3(1., 1., 1.);\n    const vec3 b = vec3(1., .0, .3);\n    const vec3 c = vec3(0.2, 0., 0.5);\n    const vec3 d = vec3(.8,.2,.2);\n        \n    if (res.x > 6.) return palette(.3,a,b,c,d);\n    \n    vec3 pos = ro + res.x*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n   \tfloat occ = calcAO( pos, nor );\n    float dom = smoothstep( -0.6, 20.6, ref.y );\n\n    dom *= softshadow( pos, ref, .9, .15 );\n\n    col = palette(3.+res.x*.1,a,b,c,d)*occ*length(ref)*(1.+dom);\n    col = mix( col, vec3(.0), max(1.0-exp( -0.05*res.x ),clamp(res.x*0.1,0.,1.)) );\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(-3., roomWidth*3., 1.5 + cos(iTime*2.)*0.3 );\n  \tvec3 ta = vec3(0.,.0,.0);\n    mat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize(vec3(p.xy,2.));\n    vec3 col = render( ro, rd );\n\tcol = pow(col, vec3(1.5));\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-4.0 OR cc-by-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlcWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[576, 778, 814, 814, 910], [913, 1026, 1076, 1076, 1496], [1498, 1658, 1691, 1691, 1717], [1719, 1719, 1752, 1752, 1777], [1802, 1802, 1826, 1826, 2270], [2272, 2272, 2312, 2312, 2594], [2597, 2597, 2671, 2671, 2922], [2924, 2924, 2956, 2956, 3170], [3172, 3172, 3214, 3214, 3511], [3513, 3513, 3585, 3585, 3628], [3630, 3630, 3669, 3669, 4357], [4359, 4359, 4411, 4411, 4588], [4590, 4590, 4648, 4648, 5019]]}
{"id": "XdSczc", "name": "Unknown Dimension", "author": "ZehMatt", "description": "Testing stuff", "tags": ["fft"], "likes": 2, "viewed": 210, "date": "1493056198", "time_retrieved": "2024-06-20T18:53:39.150665", "image_code": "vec3 orientation;\n\nfloat dt = 0.0;\nfloat totaldt = 0.0;\nfloat accumulator = 0.0;\nfloat fft = 0.0;\n\nconst float ln2 = log(2.0);\nconst float meanFreq = 4.0;\nconst float mean = meanFreq * .69314718;\nconst float stdDev = 2.0;\nconst float pi = 4.0 * atan(1.0);\nconst float pi2 = 2.0 * pi;\n\nfloat smoothWave(int n, float x){\n    float l = ln2 * float(n) + log(x);\n    l -= mean;\n    return exp(-l * l / stdDev) / 2.0;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat terrainFunction(vec3 pos, vec4 t1, vec4 t2)\n{\n    float d = sin(iTime / 20.0) * 0.5 + 0.75;\n    vec3 c = vec3(d);\n    pos = mod(pos, c) - 0.5 * c;\n        \n    float time = iTime * 1.0;\n    float p1 = 1.0 + (cos(dt + t1[0] * t2[0]) * 1.5);\n    //p1 *= 5.2;\n\n  \tfloat d2 = p1 + p1 + totaldt;\n    pos *= sqrt((d2 * d2) + (d2 * d2));\n\n    vec3 nPos1 = vec3(pos.x, pos.y - 1.0, pos.z);\n    vec3 nPos2 = vec3(pos.x, pos.y + 1.0, pos.z);\n    vec3 nPos3 = vec3(pos.x, pos.y, pos.z + 1.0);\n    vec3 nPos4 = vec3(pos.x, pos.y, pos.z - 1.0);\n    vec3 nPos5 = vec3(pos.x + 1.0, pos.y, pos.z);\n    vec3 nPos6 = vec3(pos.x - 1.0, pos.y, pos.z);\n    \n    return -\n        opS(sdSphere(nPos6, 0.33321),\n        opS(sdSphere(nPos5, 0.5),\n        opS(sdSphere(nPos4, 0.3),\n        opS(sdSphere(nPos3, 0.5),\n        opS(sdSphere(nPos2, 0.7),\n        opS(sdSphere(nPos1, 0.2),\n        sdSphere(pos, 1.0)))))));\n}\n\nvec3 normalAt(vec3 pos, vec4 t1, vec4 t2)\n{\n    float epsilon = 0.01;\n    \n    float b = 0.0;\n    float s = terrainFunction(pos, t1, t2);\n    float dx = s - terrainFunction(vec3(pos.x + epsilon, pos.y, pos.z), t1, t2);\n    float dy = s - terrainFunction(vec3(pos.x, pos.y + epsilon, pos.z), t1, t2);\n    float dz = s - terrainFunction(vec3(pos.x, pos.y, pos.z + b + epsilon), t1, t2);\n                                   \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat march(vec3 offset, vec3 dir, vec4 t1, vec4 t2)\n{\n    const float minDist = 1.0;\n    const float maxDist = 200.0;\n    const float delta = 1.0;\n    float inp = (t1[0] * t1[1]) + (t2[0] * t2[1]) * 0.5;\n\tfloat amp = inp * 1.05;\n    \n    float lastTer = 0.0;\n    float closest = 0.0;\n    \n    float d = minDist;\n    float m = t1[0] * t2[0];\n    m *= 256.0;\n    \n    for (float t = 0.0; t < m; t++)\n    {\n        if (d > maxDist)\n            break;\n        vec3 pos = offset + dir * d;\n        \n        float ter = terrainFunction(pos, t1, t2);\n        \n        if (ter >= amp)\n            return d + delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        float ter2 = terrainFunction(pos * -1.0, t1 * -0.1, t2 * -1.5);\n        if(ter2 >= amp)\n            return d * delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        lastTer = ter;\n        \n        if (ter > closest)\n            closest = ter;\n        \n        d += delta;\n    }\n    \n    return closest - amp;\n}\n\nvec3 rotX(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cy = c * vec.y;\n    float sy = s * vec.y;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(vec.x, cy - sz, sy + cz));\n}\n\nvec3 rotY(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cx = c * vec.x;\n    float sx = s * vec.x;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(cx - sz, vec.y, sx + cz));\n}\n\nvec3 palette[7]; \n\nvec3 getcolor(float c) \n{\n\tc=mod(c,7.); \n\tint p=0;\n\tvec3 color=vec3(0.);\n\tfor(int i=0;i<7;i++) {\n\t\tif (float(i)-c<=.0) { \n\t\t\tcolor=palette[i]; \n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 getsmcolor(float c, float s) \n{\n    s*=.5;\n    c=mod(c-.5,7.);\n    vec3 color1=vec3(0.0),color2=vec3(0.0);\n    for(int i=0;i<7;i++) {\n        if (float(i)-c<=.0) {\n            color1 = palette[i];\n            color2 = palette[(i+1>6)?0:i+1];\n        }\n    }\n    return mix(color1,color2,smoothstep(.5-s,.5+s,fract(c)));\n}\n\nvec3 shade(vec3 position, vec3 rayDir, vec2 uv2, vec4 t1, vec4 t2)\n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 color=vec3(0.);\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    float mul = 1.0;\n       \n    if (uv.x>.9) { \n        color=getsmcolor(uv.y*7.0+iTime*.5,.25+.75*abs(sin(iTime))); \n    } else if (uv.x>.1) {\n        color=getcolor(uv.y*7.7-iTime*.5); \n    } \n\n    vec2 p=(uv2-.5);\n    p.x*=iResolution.x/iResolution.y;\n\n    // fractal\n    float a=iTime*.075;\t\n    float b=iTime*60.;\t\n    float ot=1000.;\n    mat2 rot=mat2(cos(a),sin(a),-sin(a),cos(a));\n    p += sin(iTime);\n\n    float l=length(p);\n    for(int i=0;i<128;i++) \n    {\n        p*=rot;\n        p=abs(p)*1.2-1.;\n        ot=min(ot,abs(dot(p,p)-sin(b+l*20.)*.015-.15)); \n    }\n    ot=max(0.,.1-ot)/.1; //orbit trap \n\n    color=getsmcolor(ot*4.+l*10.-iTime*7.,1.)*(1.-.4*step(.5,1.-dot(p,p))); //get color gradient for orbit trap value\t\n    color=mix(vec3(length(color))*.5,color,.6); // saturation adjustment\n    \n    const float numWaves = 3.0;\n    for (float i = 1.0; i < numWaves; i++)\n    {\n    \tvec3 normal = normalAt(position, t1, t2);\n        col = col * (1.0 - mul) + mul * clamp(dot(normal, orientation), 0.4, 1.0) * col * 1.4;\n        \n        vec3 dir = vec3(1.0, 0.0, 0.0);\n        col += vec3(sin(totaldt / 6.0 + t1[0] + t2[0] - uv.x), sin(iTime / 3.0 + uv.y + t1[0]), sin(iTime / 4.0 + t2[0])) * clamp(dot(normal, dir), 0.0, 1.0) * 0.5;\n        \n        col *= sin(totaldt / 4.0) / 4.0 + 1.0;\n        \n        //col *= getcolor(t1[0] * 7.0);\n        //col *= getsmcolor(1.0 + atan(uv.y*7.0+iTime*.5) * 6.0, t1[0]); \n\t\tcol += (color * 0.01);\n        col += (getsmcolor(t1[0] * 7.0, pow(.3, t1[0])) * 0.01);\n        col=mix(vec3(length(col))*.8,col,.9);\n        \n        col.x *= 0.5 + sin(uv.x + t1[0]+ totaldt / 7.0);\n        col.y *= 1.0 + cos(uv.y + t1[0] * 2.0 + totaldt / 3.0);\n        col.z *= 1.0 + sin(uv.x + uv.y + t2[0] * 2.0 + totaldt / 6.0);\n        \n        rayDir = reflect(rayDir, normal);\n        \n        float dist = march(position, rayDir, t1, t2);\n        if (dist >= 0.0)\n            position = (position + rayDir * dist);\n        \n        mul *= 0.8;\n        \n        float scale = exp2(-fract(iTime / 5.0));\n        float theta = pi * float(i) / float(numWaves);\n        vec2 waveVec = vec2(cos(theta), sin(theta));\n        float phase = dot(position.xy * (rayDir.xy * 100.0), waveVec);\n        for(int k = 0; k < int(5); k++){\n            mul += cos(phase * scale * exp2(float(t1.xy))) * smoothWave(k, 1.0 + (sin(accumulator) * 0.5));\n        }\n    }\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    palette[6]=vec3(0,000,000)/255.;\n\tpalette[5]=vec3(0,127,000)/255.;\n\tpalette[4]=vec3(0,255,000)/255.;\n\tpalette[3]=vec3(0,050,050)/255.;\n\tpalette[2]=vec3(000,050,50)/255.;\n\tpalette[1]=vec3(0,000,130)/255.;\n\tpalette[0]=vec3(0,000,255)/255.;\n    \n    orientation = normalize(vec3(0.0, sin(iTime), cos(iTime)));\n    \n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    //uv=abs(2.0*(uv-0.5));\n    \n    float theta = atan(fft)*(1.0/(3.14159/2.0))*atan(uv.x);\n    float r = length(uv);\n\tfloat a= -1.0 * log(r);\n    uv = vec2(theta, -r);\n    \n    vec3 cameraPos = vec3(sin(iTime / 7.0), \n                          sin(iTime * accumulator / 5.0) * 3.0, \n                          sin((iTime + accumulator) * 0.002) * 30.0);\n    \n    float focalLength = sin(fft / 2.0) * 4.0 + 5.0;\n    float x = fragCoord.x / iResolution.x - 0.5;\n    float y = (fragCoord.y / iResolution.y - 0.5) * (iResolution.y / iResolution.x);\n    \n    int tx = int(uv.x*512.0);\n    \n    float fft2  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    fft += ( (fft2 + fft2) * (fft2 + fft2) );\n    fft = clamp(0.0, 100.0, fft - (5.0 * iTimeDelta));\n    \n    accumulator += (fft2 * 0.5);\n    \n    float lookX = sin((iTime + accumulator) / 1000.0) * 150.0;\n    float lookY = cos((iTime + accumulator) / 100.0) * 50.0;\n    \n    vec3 rayDir = normalize(vec3(x * focalLength, -1, y * focalLength));\n    rayDir = rotX(rayDir, lookX + sin(accumulator * 0.01));\n    rayDir = rotY(rayDir, lookY);\n    \n    float p1 = fragCoord.x / iResolution.x;\n    float p2 = fragCoord.y / iResolution.y;\n        \n    vec4 t1 = texture(iChannel0, vec2(tx, 0) );\n    vec4 t2 = texture(iChannel0, vec2(tx, 1) );\n    \n    float dist = march(cameraPos, rayDir, t1, t2);\n\n    vec3 pos = (cameraPos + rayDir * dist);\n    vec2 xy = pi2 * 1.0 * ((2.0 * fragCoord - iResolution.xy) / iResolution.y - exp2(iTime + fft) * atan(accumulator * fft));\n            \n    float n = (t1[0] + t2[0] + fft) * 0.5;\n    totaldt += n;\n    \n    dt += n * 0.5;\n    dt = abs(dt - (1.0 * iTimeDelta));\n    \n\tvec3 color = shade(pos, rayDir, fragCoord, t1, t2);\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "ltjGRW", "previewfilepath": "https://soundcloud.com/au4-band/everyone-is-everyone", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/au4-band/everyone-is-everyone", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSczc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[285, 285, 318, 318, 413], [415, 415, 448, 448, 473], [475, 475, 508, 508, 534], [536, 536, 571, 571, 594], [596, 596, 647, 647, 1495], [1497, 1497, 1540, 1540, 1959], [1962, 1962, 2016, 2016, 2957], [2959, 2959, 2989, 2989, 3197], [3199, 3199, 3229, 3229, 3437], [3458, 3458, 3483, 3483, 3625], [3627, 3627, 3663, 3663, 3953], [3955, 3955, 4023, 4023, 6545], [6547, 6547, 6604, 6604, 8708]]}
{"id": "XdSyDR", "name": "STAD 0003", "author": "tpen", "description": "Shadertoy-a-day, entry #3!\n\nShadertoy version of http://i.imgur.com/qX1qqW0.gifv", "tags": ["procedural", "2d", "circle", "stad", "copyagif", "shadereveryday"], "likes": 9, "viewed": 251, "date": "1491503400", "time_retrieved": "2024-06-20T18:53:39.150896", "image_code": "// https://www.shadertoy.com/view/XdSyDR\n// based on http://i.imgur.com/qX1qqW0.gif\n\nconst float RADIUS = 0.6;\nconst float WIDTH = 0.03;\nconst float PI = 3.14159265359;\nconst float WIGGLE_REPEAT = 6.0;\nconst float WIGGLE_STRENGTH = 0.1;\nconst float WIGGLE_OFFSET = PI*0.7;\n\nconst vec3 COLOR_R = vec3(191.0,49.0,107.0)/255.0;\nconst vec3 COLOR_B = vec3(67.0,177.0,50.0)/255.0;\nconst vec3 COLOR_G = vec3(81.0,99.0,145.0)/255.0;\n\nvec3 shape(float d, vec3 radii)\n{\n    vec3 dv = vec3(d);\n    vec3 t1 = vec3(greaterThan(dv, radii - vec3(WIDTH * 0.5)));\n    vec3 t2 = vec3(lessThan(dv, radii + vec3(WIDTH * 0.5)));\n    return t1 * t2;\n}\n\nvec3 pattern(vec2 p)\n{\n    float d = length(p);\n    float a = atan(p.y, p.x) - iTime * 0.4;\n    \n    vec3 offsets = vec3(0.0, 1.0, 2.0) * WIGGLE_OFFSET;\n    vec3 angles = offsets + vec3(a * WIGGLE_REPEAT);   \n    float factor = sin(a + iTime * 1.5) * 0.5 + 0.5;\n    factor = pow(factor, 1.1);\n    vec3 mods = sin(angles) * factor * WIGGLE_STRENGTH + vec3(1.0);\n    vec3 radii = mods * vec3(RADIUS);\n    \n    return shape(d, radii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 2.0;\n    uv -= vec2(1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 c = pattern(uv);\n    vec3 ret = \n        COLOR_R * c.x + \n        COLOR_G * c.y +\n        COLOR_B * c.z;\n    fragColor = vec4(ret, 1.0);\n}\n\n// version history\n// 1.0 - original version [tpen]\n// 1.1 - finetuning [void room]", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdSyDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 426, 459, 459, 629], [631, 631, 653, 653, 1064], [1066, 1066, 1123, 1123, 1397]]}
{"id": "XdXcRl", "name": "area light trace", "author": "public_int_i", "description": "area light trace", "tags": ["light", "area", "trace"], "likes": 12, "viewed": 685, "date": "1490998804", "time_retrieved": "2024-06-20T18:53:39.150896", "image_code": "//Ethan Alexander Shulman 2017\n\n\n//returns light intensity, x = diffuse, y = specular\nvec2 areaLight(vec3 relativePos, vec3 rayDirection, vec3 size, float specularRoughness) {\n    float light = 0.,\n          lightDistance = length(max(abs(relativePos)-size,0.));\n    \n    relativePos += rayDirection*lightDistance;\n    \n    for (int i = 0; i < 3; i++) {\n        if (max(light,specularRoughness) > 1.0-1e-4) break;\n        \n        float dst = length(max(abs(relativePos)-size,0.));\n        light += 1.0/(dst+1.0);\n        \n        relativePos += rayDirection*dst;\n    }\n    \n    light = min(1., light);\n    float diffuseFalloff = 0.1/(lightDistance/dot(size,vec3(1.)));\n    return vec2(pow(light,1.0/128.0)*diffuseFalloff,\n                pow(light,mix(4.0,1.0/128.0,specularRoughness))*mix(1.0,diffuseFalloff,specularRoughness*specularRoughness));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.-iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv,1.)),\n        rp = vec3(0.,0.,-45.);\n    \n    \n    vec3 lightSize = vec3(sin(iTime*0.4),cos(iTime*.6),sin(iTime*0.7))*5.5+5.75;\n    \n    //reflection plane\n    float refl = (rp.y-10.)/rd.y,\n        reflLight = 0.;\n    if (refl > 0.) {\n        vec3 reflDir = reflect(rd, vec3(0,-1,0));\n        vec3 hp = rp+rd*refl;\n    \n    \tvec2 lg = areaLight(hp,reflDir,lightSize,0.5);\n        reflLight = lg.x*0.5+lg.y*0.5;\n    }\n    \n    //direct light\n    fragColor = areaLight(rp,rd,\n                          lightSize,\n                          0.).yyyy+reflLight;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXcRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[33, 86, 175, 175, 850], [855, 855, 912, 912, 1561]]}
{"id": "Xs2cDh", "name": "Sketch_Grid", "author": "cexlearning", "description": "Grid,Thanks to Keijiro Takahashi， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 16, "viewed": 186, "date": "1492327426", "time_retrieved": "2024-06-20T18:53:39.405487", "image_code": "float uvrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 offs = vec2(iResolution.x - iResolution.y, 0.0) / 2.0;\n    vec2 p = (fragCoord.xy - offs) / iResolution.y;\n\n    vec2 ro = vec2(0.5, 0.5); // rect origin\n    vec2 rw = vec2(0.5, 0.5); // rect extent (half width)\n    float t = floor(iTime);\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (uvrand(ro + t) < 0.05 * float(i)) break;\n        rw *= 0.5;\n        ro += rw * (step(ro, p) * 2.0 - 1.0);\n    }\n\n    float rnd = uvrand(ro);\n\n    vec2 sl = rnd < 0.5 ? vec2(1,0) : vec2(0,1); // sliding param\n    sl *= 2.0 * rw * (1.0 - smoothstep(0.0, 0.5, fract(iTime)));\n\n    vec2 cp = (abs(rw - p + ro) - sl) * iResolution.y - 3.0; // rect fill\n    float c = clamp(min(cp.x, cp.y), 0.0, 1.0);\n\n    c *= rnd * (1.0 - abs(floor(p.x))); // outside\n\n    fragColor = vec4(c, 0, 0, 1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2cDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 93], [95, 95, 152, 152, 941]]}
{"id": "Xs2cW1", "name": "Sketch_Waves", "author": "cexlearning", "description": "Waves，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 12, "viewed": 140, "date": "1492604593", "time_retrieved": "2024-06-20T18:53:39.405487", "image_code": "float saturate(float x) { return clamp(x, 0.0, 1.0); }\n\nfloat wave(vec2 coord)\n{\n    float interval = iResolution.x * 0.04;\n    vec2 p = coord / interval;\n\n    float py2t = 0.112 * sin(iTime * 0.378);\n    float phase1 = dot(p, vec2(0.00, 1.00)) + iTime * 1.338;\n    float phase2 = dot(p, vec2(0.09, py2t)) + iTime * 0.566;\n    float phase3 = dot(p, vec2(0.08, 0.11)) + iTime * 0.666;\n\n    float pt = phase1 + sin(phase2) * 3.0;\n    pt = abs(fract(pt) - 0.5) * interval * 0.5;\n\n    float lw = 2.3 + sin(phase3) * 1.9;\n    return saturate(lw - pt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor.rgb = vec3(wave(fragCoord.xy));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2cW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 25, 25, 54], [56, 56, 80, 80, 548], [550, 550, 607, 607, 652]]}
{"id": "Xs2cWh", "name": "Sketch_Coaxial", "author": "cexlearning", "description": "Coaxial， copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 1, "viewed": 104, "date": "1492175529", "time_retrieved": "2024-06-20T18:53:39.405487", "image_code": "float uvrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat arc(vec2 coord)\n{\n    const float pi = 3.1415926;\n    float t = floor(iTime * 1.1) * 7.3962;\n\n    vec2 sc = (coord.xy - iResolution.xy / 2.0) / iResolution.y;\n    float phi = atan(sc.y, sc.x + 1e-6);\n    vec2 pc = vec2(fract(phi / (pi * 2.0) + iTime * 0.07), length(sc));\n\n    vec2 org = vec2(0.5, 0.5);\n    vec2 wid = vec2(0.5, 0.5);\n\n    for (int i = 0; i < 7; i++)\n    {\n        if (uvrand(org + t) < 0.04 * float(i)) break;\n        wid *= 0.5;\n        org += wid * (step(org, pc) * 2.0 - 1.0);\n    }\n\n    return uvrand(org);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 delta = vec4(-1, -1, 1, 1) * 0.5;\n\n    // neightbor four samples\n    float c1 = arc(fragCoord.xy + delta.xy);\n    float c2 = arc(fragCoord.xy + delta.zy);\n    float c3 = arc(fragCoord.xy + delta.xw);\n    float c4 = arc(fragCoord.xy + delta.zw);\n\n    // roberts cross operator\n    float gx = c1 - c4;\n    float gy = c2 - c3;\n    float g = sqrt(gx * gx + gy * gy);\n\n    fragColor = vec4(g * 4.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2cWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 23, 23, 93], [95, 95, 118, 118, 631], [633, 633, 690, 690, 1096]]}
{"id": "Xs2yRG", "name": "quasicrystal", "author": "jes5199", "description": "based on https://mainisusuallyafunction.blogspot.co.uk/2011/10/quasicrystals-as-sums-of-waves-in-plane.html", "tags": ["2d", "quasicrystal", "trippy"], "likes": 29, "viewed": 525, "date": "1492555836", "time_retrieved": "2024-06-20T18:53:39.405487", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.5;\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy / 2.0);\n        \n    float t = iTime * 3.1415;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    float pi = acos(-1.);\n        \n   \n    float m = 1.;\n    float n = 8.;\n    float p = 1.;\n    \n    float r = sqrt(x*x+y*y);\n    float th = atan(y, x);\n   \n    \n    float value = 0.;\n    \n    const int points = 7;\n    \n    for(int i = 0; i < points ; i++){\n      float angle = pi / float(points) * float(i);\n\n      float w = x * sin(angle) + y * cos(angle);\n\n\t  value += sin(w + t);\n    };\n\n        \n    float color = (sin(value * pi / 2.) + 1.) * 1.5;\n    \n    if(color > 0.0) {\n      fragColor = color - vec4(0,1.5,2,0); \n    } else {\n      //fragColor = vec4(med, med, low,1.0);\n      fragColor = -color - vec4(1,1.5,0,0); \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 867]]}
{"id": "Xs2yW1", "name": "Sketch_Lattice", "author": "cexlearning", "description": "Lattice，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 6, "viewed": 91, "date": "1492432171", "time_retrieved": "2024-06-20T18:53:39.405487", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float pi = 3.1415926;\n    float t = iTime * 0.7;\n\n    float scale = 10.0 / iResolution.y;\n    vec2 p = fragCoord.xy * scale + 0.5; // pos normalized /w grid\n    p += vec2(2, 0.5) * iTime;\n\n    float rnd = fract(sin(dot(floor(p), vec2(21.98, 19.37))) * 4231.73);\n    rnd = floor(rnd * 2.0) / 2.0 + floor(t) / 2.0;\n\n    float anim = smoothstep(0.0, 0.7, fract(t));\n    float phi = pi * (rnd + 0.5 * anim + 0.25);\n    vec2 dir = vec2(cos(phi), sin(phi));\n\n    vec2 pf = fract(p);\n    float d1 = abs(dot(pf - vec2(0.5, 0), dir)); // line 1\n    float d2 = abs(dot(pf - vec2(0.5, 1), dir)); // line 2\n\n    fragColor = vec4((0.1 - min(d1, d2)) / scale);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 57, 57, 716]]}
{"id": "Xs2yzW", "name": "Infinite Maze (in VR)", "author": "marciot", "description": "This is a slightly modified version of Flyguy's \"Infinite Maze\" (https://www.shadertoy.com/view/Mdd3R8). I refactored the code to add a \"mainVR\" entry point.", "tags": ["distancefield", "raymarch", "random", "maze"], "likes": 7, "viewed": 644, "date": "1491157935", "time_retrieved": "2024-06-20T18:53:40.775263", "image_code": "/*\n    Infinite Maze\n    --------------\n\n    Slightly modified version of the original, expanded to support VR.\n    \n    Original Author: Flyguy\n    Original URL:    https://www.shadertoy.com/view/Mdd3R8\n\n    Change Log:\n      marciot - Added mainVR\n\n*/\n\n#define PI 3.1415926535898\n\n//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 24.0\n#define MAX_STEPS 96\n#define STEP_MULT 1.0\n#define NORMAL_OFFS 0.01\n\n//Scene settings\n\n//#define SHOW_RAY_COST\n//#define SHOW_TILES\n#define FLY_MODE\n#define SKY_COLOR vec3(0.00, 0.00, 0.00)\n#define HAZE_COLOR vec3(0.50, 0.9, 0.00)\n#define WALL_HEIGHT 0.5\n#define WALL_WIDTH 0.125\n#define MAZE_SCALE 1.5\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define WALLS 2.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nvec2 tile = vec2(0);\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\nfloat noise(vec2 pos) \n{\n\treturn abs(fract(sin(dot(pos ,vec2(19.9*pos.x,28.633*pos.y))) * 1341.9453*pos.x));\n}\n\nvec4 texture3Plane(sampler2D tex,vec3 norm, vec3 pos, float mip)\n{\n    vec4 texel = vec4(0);\n    \n    texel = mix(texel, texture(tex, pos.yz, mip), abs(norm.x));\n    texel = mix(texel, texture(tex, pos.xz, mip), abs(norm.y));\n    texel = mix(texel, texture(tex, pos.xy, mip), abs(norm.z));\n    \n    return texel;\n}\n\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n  return vec2(dot(p,n.xyz) + n.w, id);\n}\n//===================================================\nvec2 sdMaze(vec3 p, float id)\n{\n    vec2 t = floor(p.xy * MAZE_SCALE);\n    \n\tp.xy = fract(p.xy * MAZE_SCALE) - 0.5;    \n\tp.x *= 2.0*floor(fract(noise(t) * 4.3) * 1.8) - 1.0; \n    \n\tfloat d = abs(1.0 - 2.0*abs(dot(p.xy, vec2(1.0)))) / (2.0 * sqrt(2.0));\n    \n    #ifdef SHOW_TILES\n    \ttile = t;\n    #endif\n    \n    return vec2(max((d / MAZE_SCALE) - WALL_WIDTH / 2.0, -p.z - WALL_HEIGHT), id);\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \n    d = opU(d, sdPlane(p, vec4(0, 0,-1, 0), FLOOR));\n    \n    d = opU(d, sdMaze(p, WALLS));\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += abs(object.x) * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n\n    if(hit.id == FLOOR)\n    {\n        float d = sdMaze(hit.position, 0.0).x;\n        float a = smoothstep(0.05, 0.04, d);\n        \n        color = mix(vec3(0.3), vec3(1,0.1,1), a);\n    }\n    if(hit.id == WALLS)\n    {\n        float a = smoothstep(0.05, 0.04, min(-hit.position.z, hit.position.z + WALL_HEIGHT));\n        color = mix(vec3(0.3), vec3(1, 0.1, 1), a);\n    }\n    color *= texture3Plane(iChannel0,hit.normal, hit.position * 4.0, -1.0).r * 0.5 + 0.5;\n    \n    //Lighting\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(hit.normal, direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular, 5.0));\n    color *= (1.0-(hit.steps / float(MAX_STEPS)));\n\t\n    //Fog / haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, hit.dist);\n    float haze = clamp(0.5/(hit.dist/MAX_DIST),0.0,1.0);\n    \n    vec3 skycol = mix(HAZE_COLOR, SKY_COLOR, clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    color = mix(skycol, color, sky * haze);\n    \n    #ifdef SHOW_TILES\n    color = texture(iChannel1, tile/iChannelResolution[1].xy+0.5, -99.0).rgb * (1.0-(hit.steps / float(MAX_STEPS)));\n    #endif\n    \n    return color;\n}\n   \nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{   \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.2 / 8.0);\n        angles.x = iTime * 0.2;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 13.0 * tau / 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = ro + vec3(0, 0,-2) * rotate;\n    \n    #ifdef FLY_MODE\n    orig -= vec3(0, iTime, 0);\n    #else\n    orig -= vec3(0, 0, 0);\n    #endif\n    \n    rd.z *= -1.;\n    vec3 dir = rd * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    float FOV    = PI/3.; // FOV - Field of view.\n    vec3 forward = vec3(0., 0., -1.);\n    vec3 up      = vec3(0., 1., 0.);\n    vec3 right   = vec3(1., 0., 0.);\n    \n    // rd - Ray direction.\n    vec3 rd      = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    vec3 ro      = vec3(0.,0.,0.);\n    \n    mainVR( fragColor, fragCoord, ro, rd );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2yzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[908, 980, 1006, 1006, 1295], [1297, 1297, 1321, 1321, 1407], [1409, 1409, 1475, 1475, 1723], [1725, 1779, 1807, 1807, 1845], [1847, 1847, 1875, 1875, 1925], [1927, 1927, 1969, 1969, 2005], [2007, 2007, 2047, 2073, 2114], [2115, 2169, 2200, 2200, 2564], [2566, 2590, 2610, 2610, 2763], [2765, 2806, 2827, 2827, 3107], [3109, 3149, 3191, 3191, 3906], [3908, 3934, 3992, 3992, 5236], [5241, 5241, 5319, 5344, 6195], [6197, 6197, 6254, 6278, 6692]]}
{"id": "XsBcRm", "name": "CellTex Doodle", "author": "TinyTexel", "description": "related: https://www.shadertoy.com/view/MdByzD", "tags": ["voronoi", "noise", "worley", "cellular", "cell"], "likes": 12, "viewed": 169, "date": "1491310318", "time_retrieved": "2024-06-20T18:53:41.611814", "image_code": "/*\nrelated: https://www.shadertoy.com/view/MdByzD\n*/\n\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define clamp(x) clamp(x, 0.0, 1.0)\n\n\nconst float Pi = 3.14159265359;\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n\nfloat FwdPot_RcpExp(float d, float s)\n{\n\treturn 1.0 / (exp2(d * s) - 1.0);\n}\n\nfloat InvPot_RcpExp(float d, float s)\n{\n\treturn log2(1.0 / d + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn pow(exp2(d * s) - 1.0, -e);\n}\n\nfloat InvPot_RcpPowExp(float d, float e, float s)\n{\n\ts /= e;\n\treturn log2(pow(d, -1.0 / e) + 1.0) / s;\n}\n\n\nfloat FwdPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -e);\n}\n\nfloat InvPot_RcpPow(float d, float e)\n{\n\treturn pow(d, -1.0 / e);\n}\n\n\nvec3 CellTex(vec2 p, float seed, vec2 cells)\n{\n\tfloat d1;\n\tvec2 p1;\n\tvec2 cv1;\n\t\n\tvec2 p_i = floor(p);\n\t\n\td1 = 64.0;\n\t\n\tfor(float i = -1.0; i <= 1.0; ++i)\n\tfor(float j = -1.0; j <= 1.0; ++j)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t\tfloat d = SqrLen(p - fp);\n\n\t\tif(d < d1)\n\t\t{\n\t\t\td1 = d;\n\t\t\tp1 = fp;\n\t\t\tcv1 = cv;\n\t\t}\n\t}\n\t\n    float e1 = 0.2;\n    float s1 = 24.0;\n    \n    float e2 = 8.0;\n    float s2 = 8.0;\n    \n\tfloat dd1 = 64.0;\n\tfloat dd2 = 0.0;\n    float dd3 = 0.0;\n    \n    const float n = 2.0;\n\tfor(float i = -n; i <= n; ++i)\n\tfor(float j = -n; j <= n; ++j)\n\tif(i != cv1.x || j != cv1.y)\n\t{\n\t\tvec2 cv = vec2(i, j);\t\t\n\t\tvec2 cvg = cv + p_i;\n\t\tvec2 cid = mod(cvg, cells);\n\t\t\n\t\tfloat h = CheapHash(cid * 1.36541 + 0.82477 + seed);\n\t\tvec2 o = AngToVec(h * Pi);\n\t\t\n\t\tvec2 fp = cvg + 0.5;\n\t\tfp += o * 0.437;\n\t\t\n\t    float d = dot(p - (p1 + fp) * 0.5, normalize(p1 - fp));\n\t\td *= 1.48;// empirically normalized\n\n\t\tdd1 = min(dd1, d);\n        dd2 += FwdPot_RcpPowExp(d, e1, s1);\n        dd3 += FwdPot_RcpPowExp(d, e2, s2);\n\t}\n\t\n\treturn vec3(dd1, InvPot_RcpPowExp(dd2, e1, s1), InvPot_RcpPowExp(dd3, e2, s2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 tex = uv / iResolution.xy;\n    \n    vec2 cells = vec2(0.0);\n    \n    vec2 pos = uv * 0.02 + Time * 0.2;\n    \n    \n    vec3 r = CellTex(pos, 0.0, cells);\n    \n    float r0 = sqrt(clamp(r.y * 16.0 - 0.005));// left\n    float r1 = clamp(1.0 - (r.x - r.z) * 16.0);// right\n    \n    float r2 = tex.x < 0.5 ? r0 : r1;\n    \n    //r2 = mix(r0, r1, tex.x);\n    //if(tex.x > 1.0/3.0 && tex.x < 2.0/3.0)\n    if(tex.x > 0.25 && tex.x < 0.5)\n    r2 = r0 * r1;// middle\n    \n    vec3 col = vec3(r2); \n    fragColor = vec4(pow(clamp(col), vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[75, 274, 300, 300, 337], [339, 339, 362, 362, 376], [377, 377, 400, 400, 418], [419, 419, 442, 442, 460], [461, 461, 484, 484, 502], [504, 504, 530, 530, 583], [585, 585, 610, 610, 652], [655, 655, 694, 694, 731], [733, 733, 772, 772, 807], [810, 810, 861, 861, 908], [910, 910, 961, 961, 1014], [1017, 1017, 1056, 1056, 1078], [1080, 1080, 1119, 1119, 1147], [1150, 1150, 1196, 1196, 2433], [2435, 2435, 2492, 2492, 3074]]}
{"id": "XsBcW1", "name": "Marble colour 3", "author": "hclarke", "description": "more of this", "tags": ["marble"], "likes": 1, "viewed": 92, "date": "1491836954", "time_retrieved": "2024-06-20T18:53:41.617932", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n\nfloat zoom=0.4;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n        \n\t}\n\treturn res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    ro.z += fract(iTime*0.2);\n   \tvec3 one3 = vec3(1.,1.,1.);\n    vec3 t = one3 * tminmax.x;\n    \n    vec3 dt = vec3(.04, 0.02, 0.09);\n    //float dt = .2 - .195*cos(iTime*.05);//animated\n    vec3 col= vec3(0.);\n    vec3 c = one3 * 0.;\n    for( int i=0; i<32; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        vec3 a = step(t,one3*tminmax.y);\n        vec3 pos = ro+t*rd;\n        \n        c.x = map(ro+t.x*rd);\n        c.y = map(ro+t.y*rd);\n        c.z = map(ro+t.z*rd);  \n        col = mix(col, .99*col+ .08*c, a);\n    }    \n    return col;\n}\n\nvec3 cubehelix(float v, float m, float M, float s) {\n \tconst mat3 YUV_to_RGB = mat3(\n         1.0,1.0,1.0,\n        0.0,-0.39465,2.03211,\n        1.13983,-0.58060,0.0);\n    \n    float a = 3.14159*(v+iTime*0.5)*2.0 * s;\n    vec3 c = vec3(mix(m,M,pow(v,.7)),sin(a),cos(a));\n   \tc.yz *= 0.08;\n    \n    return YUV_to_RGB*c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.2);\n    vec3 ta = vec3( 0.0 , 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm);\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    //col = clamp(col,0.,1.);\n    col = cubehelix(col.r*10.0, col.b, col.g,0.4);\n\t\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 137, 167, 167, 222], [223, 223, 245, 245, 294], [297, 297, 316, 316, 363], [365, 365, 427, 427, 613], [615, 615, 637, 637, 856], [860, 860, 912, 912, 1448], [1450, 1450, 1502, 1502, 1770], [1772, 1772, 1829, 1829, 2641]]}
{"id": "XsByDW", "name": "2d preset tutorial & intro", "author": "ollj", "description": "The default \"New shader\" is pretty useless.\nIt lacks framing (and mouse input) with aspect ratio\nand does not explain the very CORE functions of ALL distance fields.\n\nThat makes the very first steps harder.\nThis at least  comes with a core 2d library.", "tags": ["2d", "tutorial", "start", "introduction", "preset"], "likes": 2, "viewed": 555, "date": "1491999652", "time_retrieved": "2024-06-20T18:53:42.466501", "image_code": "/*\nThis is a very basic tutorial and 2d library \n...that ends up being in almost all shadertoy shaders.\n\nTo learn basics, by changing functional code keeps making sense,\nwhile changing|removing|(un)commenting core parts of it.\n\nThis tutorializs very basic distanceField functions in 2d within df().\nThis stores and modifies 2 distances:\n[d] =distance to point (0.,0.)        in red , and \n[di]=distance to distance field df(p) in grey\nBlue and green display the orthogonal carthesian xy axes.\n\n*/\n\n////A define is identical to an \"alias\" or \"bind\", a useful shorthand.\n#define zoom 5.\n\n////A list of useful constants: acos(-1.)=3.14=pi | acos(0.)=3.14*0.5=pih\n#define pi acos(-1.)\n#define pih acos(0.)\n////phi=golden-Ratio: 1/phi=1-phi\n#define phi (sqrt(5.)*.5-.5)\n////phi is good for hashes and to avoid overlapping.\n\n////Aliases such as \"phi\" may need to be in (or contain) round brackets: \"()\" around them,\n////becase order of operations matters for commutativity.\n\n////A define can have parameters, and these parameters have no types, \n////because their parameters are aliases, too.\n////defines are basic Genetal-Type functions:\n\n////return a sinusoid over time with range.y [-1 .. 1] & wavelength of 1 second.\n#define hz sin(iTime*pi*2.)\n////return a sinusoid over time with range.y [ 0 .. 1] & wavelength of 1 second.\n#define hz1 (hz*.5+.5)\n\n////By discarding the whole part (of a line) with x=fract(x), you get a seesaw with range.y [0 .. 1];\n#define frac(a) a=fract(a)\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n\n////return 2x2matrix that mirrors a point on a line, that is rotated by r*0.5 radians.\n#define r2(r) mat2(sin(r+vec4(pih,0,0,-pih)))\n////r2(r) is equal to the matrix of a SINGLE rotation by [r], but (a*r2(r))*r2(r)=a is a double,refletion back and forth.\n////see \"complex number rotation in 2d\", which also uses \"half-angles\"\n\n//return polar (distamce,angle) coordinates of carthesian (x,y) input.\nvec2 c2p(vec2 p){return vec2(length(p),atan(p.y,p.x));}\n//return carthesian (x,y) coordinates of polar (distamce,angle) input.\nvec2 p2c(vec2 p){return p.x*vec2(cos(p.y),sin(p.y));}\n\n////Below this line, all lines that do not start with a purple word can be commented out by \"//\" to see what they change.\n////And all commented-out lines can be commented back in, so see what that will (un)do.\n////\n////Learn stuff just by removing any \"//\" in the code below.\n////And by trying out many different combinations of disabled and enabled lines.\n////A lot of it is just disabledas suggestion that would be \"too much at once\"\n\n////This frame() function scales and transforms a point to scale and center it \n////to the viewFrame|screen\n////and to \"fix\" aspect ratio stretching.\nvec2 frame(vec2 p){p/=iResolution.xy;\n    p-=vec2(.5);//move xy=vec2(0,0) to the center of range [0 .. 1].xy\n    p*=zoom;//scale by [zoom]\n    p.x*=iResolution.x/iResolution.y;//m.x scales by aspect ratio.\n  //p=p*r2(iTime);//rotation transform, clockwise over time\n  p=p*r2(sin(iTime*phi*2.)*.1);//rotation transform, PENDULUM over time\n  //p.x-=p.y;//skew transform\n\n//polar coordinates:\n  //p=c2p(p);\n////welcome to polar coordinates\n  //p.y+=iTime;//y dimension  rotates\n  //p.x*=2.+hz1*5.;  //x dimensions scales\n  //p=p2c(p);\n////back to carthesian coordiantes\nreturn p;}//with mouse input, frame() is used twice.\n////Matrix transformations affect mouse input!\n////other transformations are left out of this one, but could go in here.\n////see https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations\n\n\n////This function [df(p)] is a distance field\n////It returns the shortest distance of [p] to a shape that is defined by its functions.\n////For a  SIGNED  distance field, a negative distance is \"inside of\" the shape.\n////For a (signed) distance BOUND, the function may return smaller values\n//// ...than the intended distance. This is fine, often much faster.\n////for an OVERSTEPPING distance field, the function may returns a larger value than intended. This is bad.\nfloat df(vec2 p){\n    vec2 mouse=frame(iMouse.xy)-p;\n    float DitanceToMouse =length(mouse);//distance of p to framed-mouse\n    float DitanceToMetaball=DitanceToMouse*length(p);//simple metaball.\n    float d=0.;\n////Uncomment some \"d+=\" lines to see what the others do:\n////Multiple \"d+=\" lines can be accumulated,sometimes useful, sometimes useless.\n////In 2d, sums of distance fields are silly fun. But in 3d, this too easily causes \"oversteppig\"\n////Summing up distance fields is BAD STYLE, but it is good enough to teach basics here.\n\n////A \"-x\" substraction increases the returned distance to the object, \n////because it makes the object \"thinner\" by [x].\n  d-=hz*.1;//oscillate [d] a little bit over time. (larger oscillations distract too much)\n  //d+=DitanceToMouse;\n  \n  d+=max(abs(mouse.x),abs(mouse.y));//distance to square\n  //d+=min(abs(p.x),abs(p.y));//distance to cross\n  //d+=max(abs(p.x),abs(p.y))*(3.-hz1)-min(abs(mouse.x),abs(mouse.y));//distance to (distorting) star.\n  \n  //d+=DitanceToMetaball-2.;\n  //d+=min(length(p),DitanceToMouse)*phi*4.-2.;//union of 2 distances to 2 points via min(a,b)\n  //d+= min(DitanceToMouse*1.5,DitanceToMetaball)-2.;//union of 2 distances \n////mix(a,b,c) does linear interpolation on a line trough a and b, c=0.0 returns a,c=1.0 returns b:\n  //d+= mix(DitanceToMetaball,min(DitanceToMouse*1.5,DitanceToMetaball),hz)-2.;\n////max(a,b) returns the UNION of 2 distance fields [a] and [b]\n  //d+=max(length(p),  DitanceToMouse     )-1.;//distance to union\n////max(a,-b) returns the distance to shpe [a], substracted by distance to shape [b].\n////(but that is for distances to volumes, in 2d we need an offset (here -2.)):\n  //d+=max(length(p)-2.,-(DitanceToMouse-2.));\n  //d+=(DitanceToMouse+length(p))-2.;//(poorly scaled) oval\n  //d+= DitanceToMouse/length(p)+length(p)-2.;//hearty\n    return d;//return distance to mouse\n}////see http://mercury.sexy/hg_sdf/\n\n\nvoid mainImage(out vec4 Out,in vec2 In){vec2 p=frame(In);\n    vec2 p2=p;//we change p soon, and copy a backup of it here.\n    float c=length(p);//length(a.xyzw) returns euclidean distance, pythagrean, squareroot of sum of squares.\n    frac(p);//.xy grid <- seesaw\n    ss2t(p);//.xy grid    seesaw <- triangle\n    p*=p*p; //f(p)=p*p*p; simple way to make p more exponential (for p range[0 .. 1])\n                               \n    frac(c);//distance to point (0,0) <- seesaw\n  //ss2t(c);//distance to point (0,0)    seesaw <- triangle\n  //c*=c;   //f(c)=c*c; simple way to make d more exponential (for p range[0 .. 1])\n  //c=step(c,.5);\n    c*=hz1;//multiply [c] by a sinusoid over time see \"#define hz...\"\n    Out=vec4(c,p,1.);//set the \"out vec4 Out\" value, \n////[Out] is the \"return Out;\" value of this function.\n////above code sets up a coordinate system\n                                        \n////below code adds a 2d distance-field to play around with\n    float di=df(p2);//di stores [distance of [p2] to distance field df()\n  //di+=hz1;//Oscillates [di] a bit over time (outside of distance field == better style)                   \n    frac(di);//display distance fiels just as we display distance to point (0,0)\n  //di=step(di+hz1,1.);//display distance field as \"inside and outside of distance 1.0\"\n  //di=1.-di;//optional inversion, with offset\n    Out.xyz+=di*.5;//show distance field. Additive visualization is lazy and fast (and bad style)\n///end of distance field code\n                                        \n////post processing:\n    Out*=Out;//f(Out)=Out*Out; simple way to increase contrast.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsByDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[1913, 1984, 2001, 2001, 2039], [2040, 2111, 2128, 2128, 2164], [2603, 2753, 2772, 2772, 3330], [3576, 4043, 4060, 4060, 5916], [5916, 5954, 5994, 5994, 7567]]}
{"id": "XsByWW", "name": "Grapprog Finals", "author": "Jops", "description": "ye", "tags": ["noise"], "likes": 6, "viewed": 142, "date": "1492582681", "time_retrieved": "2024-06-20T18:53:42.466501", "image_code": "#define PATTERN 6\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n\nfloat createPoly(int corners, vec2 uv, vec2 pos, float rotate)\n{\n    uv-=pos;\n    //pos.x *= ratio;\n// Number of sides of your shape\n\tint N = corners;\n\n// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI + rotate;\n\tfloat r = TWO_PI/float(N);\n  \n// Shaping function that modulate the distance\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\n\nfloat createRectangle(vec2 uv, vec2 pos, vec2 size)\n{\n   \n    \n    float testH = step(pos.x, uv.x ) - step(pos.x + (size.x), uv.x );\n    float testV = step(pos.y, uv.y ) - step(pos.y + (size.y), uv.y );\n    \n    return testV * testH;\n}\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat createCircle(vec2 uv, vec2 pos, float rad)\n{\n    \n    float testV;\n    \n    testV = 1.-step(rad, distance(pos, uv));  \n    return testV;\n}\n//WOOD \n#if PATTERN == 1 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n\t\n    \n    //uv *- 1.;\n    \n    float brightness = 1.;\n        \n    vec3 value = vec3(0.860, .806, .574);\n    \n    value *= brightness;\n    \n    float planks;\n    planks = abs(sin(uv.x*10.) +.1 );\n    planks = abs(floor(sin(uv.x * 20.) + .5) + .2);\n    value *= planks;\n    \n    vec3 colorA = vec3(.390, .265, .192);\n    vec3 colorB = vec3 (.930, .493, .502);\n    vec3 colorC = vec3(.0, .0, 1.);\n    \n    float mask = step(0.5, uv.x) ;\n    //mask = sin(uv.x*1.0) ;\n    mask = createRectangle(uv, vec2(0.5 * ratio, 0.5), vec2(0.2, 0.2));\n    value = mix(value, colorA, vec3(fbm(uv.xx * 10.)));  \n    \n    //mask = createRectangle(uv, vec2(0.5 * ratio * sin(iTime) + .59, 0.5), vec2(0.2, 0.2));\n    //value *= mix(value, colorB, vec3(fbm(uv.xx * 10.)));\n    \n   \t\n    value -= (noise(uv*vec2(500., 14.) / noise(uv*vec2(1000., 64.) )) * .2);\n    value -= vec3((snoise(uv*vec2(400., 3.)) - snoise(uv*vec2(14., 1.)))) * .04;\n    value -= vec3((snoise(uv*vec2(4000., 3.)) - snoise(uv*vec2(1400., 1.)))) * .01;\n        \n    //value = vec3(snoise(uv*vec2(400., 3.)));\n    \n    //vec3 stains = vec3(fbm((uv*3.)*1.))*.40;\n    //value = mix(value, vec3(0.860, .806, .574) * -.01,  (smoothstep(.08, .11, stains) - smoothstep(.11, .14, stains)) * .4);\n    \n    fragColor = vec4(vec3(value),1.0);\n    \n    \n}\n\n//CLOUD\n#elif PATTERN == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    vec3 colorA = vec3(.0, .0, .36);\n    vec3 colorB = vec3(.3, .0, .0);\n    vec3 colorC = vec3(.755,.755,.755);\n    vec3 value = colorC;\n    float wave = sin(iTime*.8);\n    \n    //vec3 fbm = vec3(fbm(uv));\n    vec3 cloud = vec3(fbm((uv * 4. + iTime / 2.)*1.))*2.;\n    \n   \t//value = fbm + offset;\n    //value *= cloud;\n    //value = mix(value, vec3(0.860, .806, .574) * -.01,  (smoothstep(.08, .11, cloud) - smoothstep(.11, .14, cloud)) * .4);\n   \tvalue = mix(colorA, colorC, smoothstep(.9,.5,cloud) - smoothstep(1.,.2, cloud) *.1 ); \n    value += .1;\n\tfragColor = vec4(vec3(value),1.0);\n}\n\n#elif PATTERN == 3\n//WATER\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    float wave = sin(iTime*.8);\n    \n    vec2 water = vec2(fbm(uv + offset * 1.5 * wave) * .1);\n\n    \n    fragColor = texture(iChannel0, uv + water);\n    \n}\n\n#elif PATTERN == 4\n//Concrete\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 colorA = vec3(.211,.211,.211); // Dark Grey\n    vec3 colorB = vec3(.469,.469,.469); // Light Gray\n    \n    vec3 roughness = (vec3(fbm(((uv * 10.))*2.))*1.);\n    \n\t  \n    float offset = noise(((uv * 1.)) * 5.);\n    float wave = sin(iTime*.8);\n    \n    float concrete = (fbm(uv  * 2.5) * .6);\n    \n    vec3 value = colorA;\n    \n    //value *= abs(floor(sin(uv.x + fbm * 20.) + .2) + .1);\n    value *= abs(sin(uv.x + concrete *10.) +.3 );\n    \n    vec3 color = mix(colorB, colorA, roughness);\n   \t\n  \tvalue += color; \n   \t\n    value -= (noise(uv*vec2(500., 14.) / noise(uv*vec2(1000., 64.) )) * .2);\n    value -= vec3((rand(uv*vec2(10., 3.)) - rand(uv*vec2(14., 1.)))) * .1;\n    \n   \tvalue -= vec3((snoise(uv*vec2(4000., 3.)) - snoise(uv*vec2(1400., 1.)))) * .01;\n        \n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 5\n//Lava\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    float wave = sin(iTime*.8);\n    \n  \tfloat lava = (fbm(uv  * 2.5 + iTime /6.) * .6);\n    float test = abs(sin(uv.x + lava *100. + iTime) +.3 );\n    vec3 value = colorB;\n    value *= abs(sin(uv.x + lava *100. + iTime) +.3 );\n    value = mix(value, colorB , offset) + mix(value, colorA , offset) ;\n    value *= mix(value, colorA , offset);\n\tvalue -= colorA * .5;\n    \n    //fragColor = texture(iChannel0, uv + fbm*10.) +.3 ;\n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 6\n//WAVE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n\n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n  \n    vec3 value = vec3(0.,0.,0.);\n   \n    \n    //float value = step(radius , dist);\n   \t\n    value +=  step(distance(vec2(0.5 * ratio,0.5), uv ), 0.2 * abs(sin(iTime * 5.))) - step(distance(uv , vec2(0.5 * ratio, 0.5) ) , 0.16 * abs(sin(iTime * 5.)));\n    value = mix(value , colorA, value);\n\tvalue +=  step(distance(vec2(0.5 * ratio,0.5), uv ), 0.3 * abs(sin(iTime * 5.))) - step(distance(uv, vec2(0.5 * ratio, 0.5) ) , 0.26 * abs(sin(iTime * 5.)));\n    value = mix(value, colorB, value);\n    value +=  step(distance(vec2(0.5* ratio,0.5), abs(uv + offset) ), 0.2 + abs(fract(iTime *1.6 ))) - step(distance( abs(uv + offset) , vec2(0.5 * ratio, 0.5) ) , 0.16  + abs(fract(iTime * 1.6 )));\n    value = mix(value, colorA, value);\n    //LIGHT\n    value += smoothstep( distance(vec2(0.5 * ratio, 0.5), uv + offset), 0.001, 0.1 + abs(fract(iTime *1.6 ))) - smoothstep( distance(vec2(0.5 * ratio, 0.5), uv + offset), 0.0, 0.2 + abs(fract(iTime *1.6 ))) ;\n    value = mix(value, colorB, value);\n     value += .13;\n    \n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 7\n//SUNSET\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    float offset = noise(uv * 8. + iTime) * .2;\n    vec3 cloud = vec3(fbm((uv * 4. + iTime / 2.)*1.))*2.;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    vec3 colorC = vec3(.228,.128,.828) ;// Indigo\n    vec3 colorD = vec3(.0, .0, .36);\n    \n    vec3 sun; \n    sun =  vec3(smoothstep(distance(vec2(0.5 * ratio,0.5 * sin(iTime)), uv ),  .3, 0.2) * 2. );\n    \n   \t//vec3 value = sun;\n   \n   \n   \tvec3 value = mix(colorA * sin(iTime) , colorB * sin(iTime) , uv.y + .3);\n    value = mix(colorB  * sin(iTime), value, sun);\n    value = mix(value, (colorC ) + offset , uv.y - .3);\n  \n  \t\n    fragColor = vec4(vec3(value),1.0);\n}\t\n#elif PATTERN == 8\n//HUD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    //uv.x *= ratio;\n    float offset = noise(uv * 8. + iTime) * .2;\n\tfloat offset2 = (fbm(uv  * 2.5 + iTime /6.) * .6);\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    vec3 colorC = vec3(.228,.128,.828) ;// Indigo\n    vec3 colorD = vec3(.0, .0, .36);\n    \n   \n    \n   \t  //2d array\n    //uv *= 4.;    \n    //vec2 tileIdx = floor(uv);\n    //uv = fract(uv);\n    \n    \n    \n    uv.x *= ratio;    \n    vec2 origin = vec2(0.5*ratio, 0.5);\n    \n    uv -= origin;     \n   \t//uv *= scale(vec2(sin(iTime / 6.) * 6.35));\n    //uv *= rotate2d((sin(iTime / 6.) * 6.35));\n    uv += origin;   \n \t\n    vec2 pos = origin;\n    \n   float dist = distance(pos, uv )*2.;\n   \n    \n   \tuv -= pos;\n    float angle = atan(uv.y, uv.x);\n    //float test = 1.-abs(smoothstep(cos(8.*angle  + snoise(  vec2(iTime / 2. )) - snoise(  vec2(iTime * 2. )) ) - 1.6   , .3 ,cos(10.*dist)));\n   \t//float test = 1.-abs(smoothstep(cos(8.*angle  ) - 1.6   , .3 ,cos(10.*dist)));\n   \tfloat ring1 = abs( step(dist * floor(sin(12.* angle + snoise(vec2(iTime) ) ) + 2. ),  cos(9.*dist) ) );\n    float ring2 = abs( step(dist * floor(sin(12.* angle - sin(snoise(vec2(iTime) ) ) * 5. ) + 2.  ),  cos(15.*dist) ) );\n    float ring3 = abs( step(dist * floor(sin(16.* angle + sin(snoise(vec2(iTime * 2.) ) ) ) + 2.  ),  cos(7.*dist) ) );\n    //test += 1.-abs(smoothstep(cos(8.*angle  - snoise(  vec2(step(.2, uv) + iTime )) ) - 1.6   , .3 ,cos(2.*dist)));\n    \n    \n   \tvec3 value = colorD;\n    value = mix(value, colorB, uv.y );\n    value = mix(value, colorB , -smoothstep( distance(vec2(0.0), uv ), 0.3 ,0.4) -smoothstep( distance(vec2(0.), uv), 0.1,0.9) );\n \t//value = mix(value, colorA, colorC);\n \tvalue += ring1; \n    value += ring2;\n    value += ring3;\n    \n\tvalue = mix(value, colorA, colorC);\n  \n  \t\n    fragColor = vec4(vec3(value),1.0);\n}\n#endif", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "MdBGDt", "previewfilepath": "https://soundcloud.com/ujico/pixelgalaxy", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ujico/pixelgalaxy", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsByWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[73, 73, 94, 269, 335], [338, 338, 402, 402, 726], [728, 728, 781, 781, 963], [965, 965, 992, 992, 1099], [1101, 1179, 1205, 1205, 1585], [1605, 1605, 1629, 1651, 1902], [1904, 1904, 1925, 1925, 1972], [1973, 1973, 1994, 1994, 2041], [2042, 2042, 2064, 2064, 2099], [2101, 2101, 2123, 2123, 3171], [3173, 3173, 3223, 3223, 3317]]}
{"id": "XsByzm", "name": "2D Lighted Flower Shape", "author": "aiekick", "description": "Based on the code of Shane : [url=https://www.shadertoy.com/view/ll3GRM]Rounded Voronoi Borders[/url]", "tags": ["2d", "simple", "shape", "lighted"], "likes": 7, "viewed": 634, "date": "1491314658", "time_retrieved": "2024-06-20T18:53:42.466501", "image_code": "// use the code and tricks of shane shader\n// Rounded Voronoi Borders https://www.shadertoy.com/view/ll3GRM\n\n#define maxRadius 20.\n#define petalThickness 5.\n#define petalCount 8.\n#define flowerThickness 6.\n\nfloat df(vec2 p)\n{\n\tfloat flower = maxRadius - petalThickness * cos(atan(p.x,p.y) * petalCount) - dot(p,p);\n\treturn flowerThickness - abs(flower);\n}\n\nvec2 hMap(vec2 uv)\n{\n    float h = df(uv*6.);\n    float c = smoothstep(0., fwidth(h)*4., h)*h;\n    return vec2(c, h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n\t\n\tfloat a = iTime;\n\tvec2 ld = vec2(cos(a),sin(a)) * 0.004;\n\t\n    vec2 c = hMap(uv);\n    vec2 c2 = hMap(uv + ld);\n    \n    float b = max(c2.x - c.x, 0.)*12.;\n    \n    vec3 col = vec3(0.13,0.03,0.06)*c.x;\n\n    col += vec3(0.1,0.05,0.4)*(b*b*0.04 + b*b*b*b*0.07);\n\t \n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsByzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 207, 225, 225, 355], [357, 357, 377, 377, 476], [478, 478, 535, 535, 914]]}
{"id": "Xsf3zH", "name": "Julia quaternion fractal", "author": "nuclear", "description": "A julia quaternion hack. Originally a C/OpenGL program ( https://www.youtube.com/watch?v=yZt--S1eS6A ), ported to WebGL ( http://nuclear.mutantstargoat.com/webgl/ ), and now in an act of rampant unbridled procrastination, ported to shadertoy.", "tags": ["fractal", "julia", "juliaquaternion"], "likes": 3, "viewed": 518, "date": "1492688840", "time_retrieved": "2024-06-20T18:53:44.205903", "image_code": "#ifdef GL_ES\nhighp float;\n#endif\n\nfloat aspect;\nconst float vfov = 1.02;\nvec4 seed = vec4(0.4, 0.0, 0.0, -0.8);\nconst float err_thres = 0.0075;\nconst int iter = 10;\nconst float reflectivity = 0.4;\nconst vec3 diffuse_color = vec3(0.38, 0.35, 0.32);\nconst int show_floor = 1;\n\n//uniform mat4 mvmat, normmat;\nmat3 rotmat;\n\n#define quat(s, x, y, z)\tvec4(x, y, z, s)\n#define quat_identity()\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\n#define vec2quat(v)\t\t(v).wxyz\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Julia {\n\tbool inside;\n\tvec4 q;\n\tvec4 qprime;\n};\n\nstruct Material {\n\tvec3 kd, ks;\n\tfloat kr;\n\tfloat spow;\n};\n\nstruct ISect {\n\tbool hit;\n\tfloat t;\n\tvec3 pos;\n\tvec3 normal;\n\tMaterial mat;\n};\n\nISect find_intersection(Ray ray);\nvec3 shade(Ray ray, ISect isect);\nfloat amboc(ISect isect);\nvec3 sky(Ray ray);\nJulia julia(vec4 q, vec4 c);\nfloat julia_dist(vec4 z);\nvec3 julia_grad(vec4 z);\nvec4 quat_mul(vec4 q1, vec4 q2);\nvec4 quat_sq(vec4 q);\nfloat quat_length_sq(vec4 q);\nISect ray_julia(Ray ray);\nISect ray_sphere(Ray ray, float rad);\nISect ray_floor(Ray ray);\nRay get_primary_ray(in vec2 tc);\n\nvec3 steps_color(int steps);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime * 0.075;\n    float phi = 0.25;\n    float sintheta = sin(theta);\n    float costheta = cos(theta);\n    float sinphi = sin(phi);\n    float cosphi = cos(phi);\n    \n    mat3 rotx = mat3(\n        costheta, 0, -sintheta,\n        0, 1, 0,\n        sintheta, 0, costheta);\n    mat3 roty = mat3(\n        1, 0, 0,\n        0, cosphi, sinphi,\n        0, -sinphi, cosphi);\n    rotmat = rotx * roty;\n    \n    seed[0] = cos(iTime * 0.333);\n    seed[3] = sin(iTime * 0.333) * 1.25 - 0.25;\n    \n    \n    vec2 tc = fragCoord.xy / iResolution.xy;\n    aspect = iResolution.x / iResolution.y;\n\tRay ray = get_primary_ray(tc);\n\n\tfloat energy = 1.0;\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfor(int i=0; i<2; i++) {\n\t\tISect res = find_intersection(ray);\n\n\t\tif(res.hit) {\n\t\t\tcolor += shade(ray, res) * energy;\n\t\t\tenergy *= res.mat.kr;\n\n\t\t\tif(energy < 0.001) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tray.origin = res.pos;\n\t\t\tray.dir = reflect(ray.dir, res.normal);\n\t\t} else {\n\t\t\tcolor += sky(ray) * energy;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}\n\n\nISect find_intersection(Ray ray)\n{\n\tISect res;\n\tres.hit = false;\n\t\n\tISect bhit = ray_sphere(ray, 2.0);\n\tif(bhit.hit) {\n\t\tray.origin = bhit.pos;\n\t\tres = ray_julia(ray);\n\t}\n\n\tif(!res.hit && show_floor == 1) {\n\t\tres = ray_floor(ray);\n\t}\n\treturn res;\n}\n\nvec3 shade(Ray ray, ISect isect)\n{\n\tvec3 ldir = normalize(vec3(10.0, 10.0, -10.0) - isect.pos);\n\tvec3 vdir = -ray.dir;\n\tvec3 hdir = normalize(ldir + vdir);\n\n\tfloat ndotl = dot(ldir, isect.normal);\n\tfloat ndoth = dot(hdir, isect.normal);\n\n\tvec3 dcol = isect.mat.kd;// * abs(ndotl);\n\tvec3 scol = isect.mat.ks * pow(abs(ndoth), isect.mat.spow);\n\n\treturn vec3(0.05, 0.05, 0.05) + dcol + scol;\n}\n\n#define AO_STEP\t\t0.04\n#define AO_MAGIC\t8.0\nfloat amboc(ISect isect)\n{\n\tfloat sum = 0.0;\n\n\tfor(float fi=0.0; fi<5.0; fi+=1.0) {\n\t\tfloat sample_dist = fi * AO_STEP;\n\t\tvec3 pt = isect.pos + isect.normal * sample_dist;\n\t\tfloat jdist = julia_dist(quat(pt.x, pt.y, pt.z, 0.0));\n\n\t\tsum += 1.0 / pow(2.0, fi) * (sample_dist - jdist);\n\t}\n\t\n\tfloat res = 1.0 - AO_MAGIC * sum;\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 sky(Ray ray)\n{\n\tvec3 col1 = vec3(0.75, 0.78, 0.8);\n\tvec3 col2 = vec3(0.56, 0.7, 1.0);\n\n\tfloat t = max(ray.dir.y, -0.5);\n\treturn mix(col1, col2, t);\n}\n\nJulia julia(vec4 q, vec4 c)\n{\n\tJulia res;\n\tres.inside = true;\n\n\tres.q = q;\n\tres.qprime = quat_identity();\n\n\t//for(int i=0; i<iter; i++) {\n\tfor(int i=0; i<10; i++) {\n\t\tres.qprime = 2.0 * quat_mul(res.q, res.qprime);\n\t\tres.q = quat_sq(res.q) + c;\n\n\t\tif(dot(res.q, res.q) > 8.0) {\n\t\t\tres.inside = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nfloat julia_dist(vec4 z)\n{\n\tJulia jres = julia(z, seed);\n\n\tfloat lenq = length(jres.q);\n\tfloat lenqprime = length(jres.qprime);\n\n\treturn 0.5 * lenq * log(lenq) / lenqprime;\n}\n\n#define OFFS 1e-4\nvec3 julia_grad(vec4 z)\n{\n\tvec3 grad;\n\tgrad.x = julia_dist(z + quat(OFFS, 0.0, 0.0, 0.0)) - julia_dist(z - quat(OFFS, 0.0, 0.0, 0.0));\n\tgrad.y = julia_dist(z + quat(0.0, OFFS, 0.0, 0.0)) - julia_dist(z - quat(0.0, OFFS, 0.0, 0.0));\n\tgrad.z = julia_dist(z + quat(0.0, 0.0, OFFS, 0.0)) - julia_dist(z - quat(0.0, 0.0, OFFS, 0.0));\n\treturn grad;\n}\n\nvec4 quat_mul(vec4 q1, vec4 q2)\n{\n\tvec4 res;\n\tres.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n\tres.xyz = q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz);\n\treturn res;\n}\n\nvec4 quat_sq(vec4 q)\n{\n\tvec4 res;\n\tres.w = q.w * q.w - dot(q.xyz, q.xyz);\n\tres.xyz = 2.0 * q.w * q.xyz;\n\treturn res;\n}\n\n#define MIN_STEP\t0.001\nISect ray_julia(Ray inray)\n{\n\tfloat dist_acc = 0.0;\n\tRay ray = inray;\n\tISect res;\n\n\tfloat fi = 0.0;\n\tfor(int i=0; i<1000; i++) {\n\t\tvec4 q = quat(ray.origin.x, ray.origin.y, ray.origin.z, 0.0);\n\t\t\n\t\tfloat dist = max(julia_dist(q), MIN_STEP);\n\n\t\tray.origin += ray.dir * dist;\n\t\tdist_acc += dist;\n\n\t\tif(dist < err_thres) {\n\t\t\tres.hit = true;\n\t\t\tres.t = dist_acc;\n\t\t\tres.pos = ray.origin;\n\t\t\tres.normal = normalize(julia_grad(quat(res.pos.x, res.pos.y, res.pos.z, 0.0)));\n\t\t\tres.mat.kr = reflectivity;\n\t\t\tres.mat.kd = diffuse_color * amboc(res);\n\t\t\tres.mat.ks = vec3(0.4, 0.4, 0.4);\n\t\t\tres.mat.spow = 50.0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(dot(ray.origin, ray.origin) > 100.0) {\n\t\t\tres.hit = false;\n\t\t\tbreak;\n\t\t}\n\t\tfi += 0.1;\n\t}\n\n\treturn res;\n}\n\nISect ray_sphere(Ray ray, float rad)\n{\n\tISect res;\n\tres.hit = false;\n\n\tfloat a = dot(ray.dir, ray.dir);\n\tfloat b = 2.0 * dot(ray.dir, ray.origin);\n\tfloat c = dot(ray.origin, ray.origin) - rad * rad;\n\n\tfloat d = b * b - 4.0 * a * c;\n\tif(d < 0.0) return res;\n\n\tfloat sqrt_d = sqrt(d);\n\tfloat t1 = (-b + sqrt_d) / (2.0 * a);\n\tfloat t2 = (-b - sqrt_d) / (2.0 * a);\n\n\tif((t1 >= 0.0 || t2 >= 0.0)) {\n\t\tif(t1 < 0.0) t1 = t2;\n\t\tif(t2 < 0.0) t2 = t1;\n\t\t\n\t\tres.hit = true;\n\t\tres.t = min(t1, t2);\n\t\tres.pos = ray.origin + ray.dir * res.t;\n\t\t//res.mat.kd = vec3(1.0, 0.3, 0.2);\n\t\t//res.normal = res.pos / rad;\n\t}\n\n\treturn res;\n}\n\n#define FLOOR_HEIGHT\t(-2.0)\n\nISect ray_floor(Ray ray)\n{\n\tISect res;\n\tres.hit = false;\n\n\tif(ray.origin.y < FLOOR_HEIGHT || ray.dir.y >= 0.0) {\n\t\treturn res;\n\t}\n\n\tres.normal = vec3(0.0, 1.0, 0.0);\n\tfloat ndotdir = dot(res.normal, ray.dir);\n\n\tfloat t = (FLOOR_HEIGHT - ray.origin.y) / ndotdir;\n\tres.pos = ray.origin + ray.dir * t;\n\n\tif(abs(res.pos.x) > 8.0 || abs(res.pos.z) > 8.0) {\n\t\tres.hit = false;\n\t} else {\n\t\tres.hit = true;\n\t\n\t\tfloat chess = mod(floor(res.pos.x * 0.75) + floor(res.pos.z * 0.75), 2.0);\n\t\tres.mat.kd = mix(vec3(0.498, 0.165, 0.149), vec3(0.776, 0.851, 0.847), chess);\n\t\tres.mat.ks = vec3(0.0, 0.0, 0.0);\n\t\tres.mat.spow = 1.0;\n\t\tres.mat.kr = 0.0;\n\t}\n\treturn res;\n}\n\nRay get_primary_ray(in vec2 tc)\n{\n\tRay ray;\n\t//ray.origin = (mvmat * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    ray.origin = rotmat * vec3(0.0, 0.0, -3.0);\n\n\tfloat ysz = 2.0;\n\tfloat xsz = aspect * ysz;\n\n\tfloat px = tc.x * xsz - xsz / 2.0;\n\tfloat py = tc.y * ysz - 1.0;\n\tfloat pz = 1.0 / tan(0.5 * vfov);\n\n\t//vec4 dir = normmat * vec4(px, py, pz, 1.0);\n    vec3 dir = rotmat * vec3(px, py, pz);\n\tray.dir = normalize(dir.xyz);\n\n\treturn ray;\n}\n\nvec3 steps_color(int steps)\n{\n\tif(steps <= 1) {\n\t\treturn vec3(0.0, 0.5, 0.0);\n\t} else if(steps == 2) {\n\t\treturn vec3(0.0, 1.0, 0.0);\n\t} else if(steps == 3) {\n\t\treturn vec3(0.0, 0.0, 0.5);\n\t} else if(steps == 4) {\n\t\treturn vec3(0.0, 0.0, 1.0);\n\t} else if(steps == 5) {\n\t\treturn vec3(0.0, 0.5, 0.5);\n\t} else if(steps == 6) {\n\t\treturn vec3(0.0, 1.0, 1.0);\n\t} else if(steps == 7) {\n\t\treturn vec3(0.5, 0.0, 0.5);\n\t} else if(steps == 8) {\n\t\treturn vec3(1.0, 0.0, 1.0);\n\t} else if(steps == 9) {\n\t\treturn vec3(0.5, 0.0, 0.0);\n\t}\n\treturn vec3(0.5 + float(steps - 9) / 10.0, 0.0, 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsf3zH.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[275, 1114, 1171, 1171, 2202], [2205, 2205, 2239, 2239, 2453], [2455, 2455, 2489, 2489, 2845], [2890, 2890, 2916, 2916, 3244], [3246, 3246, 3265, 3265, 3400], [3402, 3402, 3431, 3431, 3734], [3736, 3736, 3762, 3762, 3910], [3930, 3930, 3955, 3955, 4274], [4276, 4276, 4309, 4309, 4445], [4447, 4447, 4469, 4469, 4565], [4590, 4590, 4618, 4618, 5317], [5319, 5319, 5357, 5357, 5935], [5966, 5966, 5992, 5992, 6620], [6622, 6622, 6655, 6655, 7054], [7056, 7056, 7085, 7085, 7633]]}
{"id": "XsjcDm", "name": "StrangeCharBug", "author": "tholzer", "description": "There seems to be 'UNKNOWN' characters like '\\' or '@', which produces error message\n  Unknown Error: ERROR: 0: ? : '' : syntax error\nin the 1st source line of my firefox browser(Win7).\n  ... please continue reading at source code header ... \n", "tags": ["bug", "browser", "scanner", "webgl2", "syntax", "graphicscard"], "likes": 3, "viewed": 93, "date": "1492421647", "time_retrieved": "2024-06-20T18:53:44.424099", "image_code": "// StrangeCharBug.glsl\n\n/*\nThere seems to be 'UNKNOWN' characters like '\\' or '@', which produces error message\n  Unknown Error: ERROR: 0: ? : '' : syntax error\nin the 1st source line of my firefox browser(Win7). \n\n- Who produces that error - the browser, WebGL2 implementation, the graphics card ?\n- Why is the error message not appearing in the proper line?\n- Where can I get more info about GLSL compiling?\n\nother bugs: \n matrix      https://www.shadertoy.com/view/XdByzc\n moduli      https://www.shadertoy.com/view/Xlt3W4\n overview    https://www.shadertoy.com/results?query=glsl+bug\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(0);\n    fragColor.r = sin(88.*uv.x) + sin(55.*uv.y) + 0.5+2.*sin(iTime*2.);\n   \n    // uncomment one of the following lines to get the 'unknown' error message\n    //\\\n    //@\n}\n\n// 2017-01-22 note:  In the meantime iq made some changes.\n// Now you have to uncomment both lines to get the error message.\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjcDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[24, 592, 649, 649, 886]]}
{"id": "XsjcRc", "name": "Mount Book", "author": "dr2", "description": "Great place for a library", "tags": ["reflection", "raymarch", "sunset", "landscape", "mountain", "library"], "likes": 9, "viewed": 524, "date": "1493138547", "time_retrieved": "2024-06-20T18:53:44.442375", "image_code": "// \"Mount Book\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec3 HsvToRgb (vec3 c);\n\nconst float pi = 3.14159;\nvec3 vnCylIn, sunDir;\nvec2 bsa[4];\nfloat tCur, dstFar, bCylRad, bCylHt, spShf, dCylIn, dCylOut, yShift, mntHt;\nint idObj;\nconst int idFrm = 1, idBks = 2, idShlf = 3, idSup = 4, idDr = 5, idMnt = 6;\n\nvoid CylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, ai, b, w, ws, srdy;\n  dCylIn = dstFar;\n  dCylOut = dstFar;\n  vnCylIn = vec3 (0.);\n  ro.y -= yShift;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      ai =  1. / a;\n      dCylIn = (- b - ws) * ai;\n      dCylOut = (- b + ws) * ai;\n    }\n    if (a > 0.) s = ro + dCylIn * rd;\n    else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylIn.xz = s.xz / bCylRad;\n    else if (srdy * ro.y < - bCylHt) {\n      dCylIn = - (srdy * ro.y + bCylHt) / abs (rd.y);\n      if (length (ro.xz + dCylIn * rd.xz) < bCylRad) vnCylIn.y = - srdy;\n      else dCylIn = dstFar;\n    } else dCylIn = dstFar;\n    if (dCylIn < dstFar) {\n      if (a > 0.) s = ro + dCylOut * rd;\n      else s.y = bCylHt;\n      if (abs (s.y) > bCylHt && srdy * ro.y < bCylHt)\n         dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n    }\n  }\n}\n\nfloat MountDf (vec3 p)\n{\n  vec3 q;\n  float a, r, hd, s, rMnt;\n  rMnt = 350.;\n  q = p;\n  a = atan (q.z, q.x) / (2. * pi) + 0.5;\n  r = length (q.xz);\n  s = Fbm2 (vec2 (55. * a, 0.3 * r));\n  q.y -= 0.5 * mntHt;\n  a = mod (a + 0.01 * sin (2. * 2. * pi * q.y / mntHt), 1.);\n  hd = 0.02 * (1. +  0.5 * sin (64. * pi * a) + 1. * sin (25. * pi * a)) +\n     0.1 * (s - 0.5);\n  q.y -= 0.51 * rMnt + hd * mntHt;\n  return max (SmoothMin (max (length (q.xz) - rMnt, - PrTorusDf (q.xzy, rMnt, rMnt)),\n     PrCylDf (p.xzy, 0.3 * rMnt, 0.1), 10.), abs (p.y - 0.5 * mntHt) - 0.5 * mntHt);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, r, a, htShf;\n  dMin = dstFar;\n  d = 0.7 * MountDf (p);\n  if (d < dMin) { dMin = d;  idObj = idMnt; }\n  htShf = 0.05 * spShf;\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p.y -= yShift;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (7. * a + 0.5) / 7.);\n  qq = q;\n  q.x += 0.77 * bCylRad;\n  q.xz = abs (q.xz) - vec2 (0.03 * bCylRad, 0.1 * bCylRad);\n  d = PrCylDf (q.xzy, 0.008 * bCylRad, bCylHt + 0.2);\n  if (d < dMin) { dMin = d;  idObj = idSup; }\n  q = qq;\n  d = max (r - 1.2 * bCylRad, abs (abs (p.y) - bCylHt - 0.2) - 0.2);\n  q.z = abs (q.z);\n  if (p.y > 0.) d = max (d,\n     min (- (abs (abs (abs (abs (r / bCylRad - 0.52) - 0.25)) - 0.125) -\n     0.065) * bCylRad, dot (q.xz, bsa[0])));\n  d = min (d, length (vec2 (r - 1.15 * bCylRad,\n     abs (abs (q.y + 0.5 * bCylHt) - 0.2 * bCylHt) - 0.1 * bCylHt)) - 0.1);\n  q.xy += vec2 (1.15 * bCylRad, 1.);\n  d = min (min (d, PrCylDf (q.xzy, 0.3, bCylHt + 1.)),\n     max (abs (r - bCylRad) - 0.1, abs (abs (p.y) - bCylHt + 0.19) - 0.2));\n  if (d < dMin) { dMin = d;  idObj = idFrm; }\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (7. * a) + 0.5) / 7.);\n  q.z = abs (q.z);\n  d = max (max (abs (r - 0.77 * bCylRad) - 0.05 * bCylRad,\n     abs (p.y + 0.1 * bCylHt) - 0.7 * bCylHt), - dot (q.xz, bsa[2]));\n  if (d < dMin) { dMin = d;  idObj = idBks; }\n  d = max (max (max (abs (r - 0.77 * bCylRad) - 0.07 * bCylRad,\n     abs (p.y + 0.1 * bCylHt) - (0.7 * bCylHt + htShf)), - dot (q.xz, bsa[3])),\n     - max (htShf - (abs (mod (p.y + 0.1 * bCylHt + 0.5 * spShf, spShf) -\n     0.5 * spShf)), - dot (q.xz, bsa[2])));\n  if (d < dMin) { dMin = d;  idObj = idShlf; }\n  d = max (max (max (abs (r - bCylRad) - 0.15,\n     abs (p.y + 0.3 * bCylHt) - 0.7 * bCylHt), dot (q.xz, bsa[0])),\n     - max (0.08 - abs (p.y - 0.4 * bCylHt + 0.08), dot (q.xz, bsa[1])));\n  if (d < dMin) { dMin = d;  idObj = idDr; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.9, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nfloat ObjSShadowN (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.5;\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat ObjSShadowF (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 30; j ++) {\n    h = MountDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 12.;\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p;\n  float ds, fd, att, attSum, d, sd;\n  p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n  ds = 0.1 * sqrt (length (p));\n  p += ro;\n  fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz += 0.1 * tCur;\n  att = Fbm2 (p.xz);\n  attSum = att;\n  d = fd;\n  ds *= fd;\n  for (int j = 0; j < 4; j ++) {\n    attSum += Fbm2 (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  attSum *= 0.3;\n  att *= 0.3;\n  sd = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) *\n     max (rd.y - 0.1, 0.)));\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n     return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float sh;\n  if (rd.y >= 0.) col = SkyCol (ro, rd);\n  else {\n    ro -= (ro.y / rd.y) * rd;\n    col = (0.7 + 0.3 * Fbm2 (0.5 * ro.xz)) * vec3 (0.3, 0.15, 0.);\n    vn = VaryNf (0.1 * ro, vec3 (0., 1., 0.), 10.);\n    sh = ObjSShadowF (ro, sunDir);\n    col *= (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.) +\n       0.1 * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));\n    col = mix (col, SkyCol (ro, normalize (vec3 (vn.x, 0.1, vn.z))),\n       0.2 * length (col));\n  }\n  return col;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, q;\n  vec2 gbBk, bt;\n  float a, r, bh, spec, sh;\n  spec = 0.1;\n  vn = ObjNf (ro);\n  q = ro;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  if (idObj == idMnt) {\n    col = (0.7 + 0.3 * Fbm2 (0.5 * q.xz)) *\n       mix (vec3 (0.3, 0.15, 0.), vec3 (0.3, 0.3, 0.35),\n       q.y / mntHt + 0.2 * Fbm2 (0.2 * q.xz) - 0.1);\n    if (r < 1.21 * bCylRad && vn.y > 0.99) col *= 0.6;\n    if (q.y > 0.5 * mntHt && vn.y > 0.99) vn = VaryNf (1.5 * q, vn, 5.);\n    else if (q.y < 0.1 * mntHt) vn = VaryNf (0.1 * q, vn, 10.);\n    else vn = VaryNf (0.5 * q, vn, 10.);\n  } else if (idObj == idBks) {\n    bt = vec2 (5000. * a, 200. * q.y);\n    a *= (dot (vn.xz, q.xz) > 0.) ? 600. : 500.;\n    gbBk = floor (vec2 (q.y / spShf, a));\n    bh = (0.7 + 0.3 * Fbm2 (gbBk * vec2 (19., 31.))) * spShf;\n    q.y = mod (q.y, spShf);\n    if (q.y < bh) {\n      q.xy = vec2 (2. * mod (a, 1.) - 1., q.y / bh - 0.5);\n      col = vec3 (HsvToRgb (vec3 (Fbm2 (gbBk * vec2 (17., 11.)), 1.,\n         0.7 * SmoothBump (0.08, 0.92, 0.01, 0.55 + 0.45 * q.x))));\n      if (abs (q.x) < 0.3 && abs (q.y) < 0.2 &&\n         Noisefv2 (gbBk * vec2 (19., 31.) + floor (bt)) > 0.7) {\n        col *= 4.;\n      } else {\n        spec = 0.3;\n        vn.xz = Rot2D (vn.xz, q.x);\n      }\n    } else {\n      col = vec3 (0.02);\n      spec = -1.;\n    }\n  } else if (idObj == idShlf) {\n     col = WoodCol (vec3 (5. * (mod (7. * a + 0.5, 1.) - 0.5), ro.y, r), vn);\n  } else if (idObj == idSup) {\n    col = vec3 (0.2, 0.1, 0.);\n  } else if (idObj == idFrm) {\n    if (ro.y < bCylHt + mntHt && r < bCylRad && vn.y > 0.99) {\n       if (r > 0.05 * bCylRad) col = FloorCol (vec2 (42. * a, r));\n       else col = vec3 (0.4, 0.3, 0.1);\n    } else {\n      col = vec3 (0.75, 0.7, 0.7);\n      if (ro.y > yShift + bCylHt + 0.39) {\n        vn = vec3 (0., Rot2D (vec2 (1., 0.), -0.1 * pi * sin (pi *\n           (0.5 - mod (16. * (r / bCylRad - 0.52), 1.)))));\n        vn.xz = Rot2D (vn.xz, 2. * pi * a);\n      }\n      vn = VaryNf (20. * ro, vn, 1.);\n    }\n  } else if (idObj == idDr) {\n    col = vec3 (0.4, 0.4, 0.5);\n  }\n  sh = (idObj != idMnt) ? ObjSShadowN (ro, sunDir) : ObjSShadowF (ro, sunDir);\n  if (spec >= 0.) col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.) +\n     spec * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n  col = mix (col, SkyCol (ro, normalize (vec3 (vn.x, 0.1, vn.z))), 0.2 * length (col));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR;\n  float cbc[4], dstObj;\n  cbc[0] = 0.4;  cbc[1] = 0.37;  cbc[2] = 0.9;  cbc[3] = 0.85;\n  for (int k = 0; k < 4; k ++) \n     bsa[k] = vec2 (sin (cbc[k] * 2. * pi / 28.), cos (cbc[k] * 2. * pi / 28.));\n  dstObj = ObjRay (ro, rd);\n  col = (dstObj < dstFar) ? ObjCol (ro + rd * dstObj, rd) : BgCol (ro, rd);\n  CylHit (ro, rd);\n  if (dCylIn < min (dstObj, dstFar)) {\n    col *= 0.9;\n    if (dCylOut < min (dstObj, dstFar)) col *= 0.8;\n    ro += dCylIn * rd;\n    rd = reflect (rd, vnCylIn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    colR = (dstObj < dstFar) ? ObjCol (ro + rd * dstObj, rd) : BgCol (ro, rd);\n    col = mix (col, colR, smoothstep (0.7, 0.95,\n       1. - pow (abs (dot (rd, vnCylIn)), 5.)));\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, u, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mntHt = 100.;\n  bCylRad = 20.;\n  bCylHt = 4.;\n  yShift = bCylHt + 1. + mntHt;\n  spShf = 0.7 * bCylHt / 3.;\n  dstFar = 1000.;\n  az = 0.011 * 2. * pi * tCur;\n  el = 0.5 * pi * (0.4 - 0.3 * sin (0.018 * 2. * pi * tCur));\n  zmFac = 3. + 22. * SmoothBump (0.2, 0.7, 0.1, mod (0.05 * tCur, 1.));\n  if (mPtr.z > 0.) {\n    el = clamp (el - pi * mPtr.y, 0.05, 1.5);\n    az = az - 2.5 * pi * mPtr.x;\n  }\n  ro = 400. * vec3 (cos (el) * cos (az), sin (el), cos (el) * sin (az));\n  vd = normalize (vec3 (0., yShift * pow (zmFac / 25., 0.3), 0.) - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (1., 0.5, -1.));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.7)), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + vec2 (- q.y, q.x) * sin (a);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 4; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjcRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 673, 705, 705, 1663], [1665, 1665, 1689, 1689, 2238], [2240, 2240, 2262, 2262, 4180], [4182, 4182, 4215, 4215, 4391], [4393, 4393, 4414, 4414, 4629], [4631, 4631, 4655, 4655, 4829], [4831, 4831, 4862, 4862, 5073], [5075, 5075, 5113, 5113, 5336], [5338, 5338, 5376, 5376, 5600], [5602, 5602, 5634, 5634, 6483], [6485, 6485, 6516, 6516, 7025], [7027, 7027, 7059, 7059, 9468], [9470, 9470, 9505, 9505, 10256], [10258, 10258, 10314, 10314, 11422], [11424, 11424, 11466, 11466, 11517], [11519, 11519, 11565, 11565, 11622], [11624, 11624, 11669, 11669, 11772], [11774, 11774, 11831, 11831, 11914], [11916, 11916, 11946, 11946, 12000], [12123, 12123, 12147, 12147, 12194], [12196, 12196, 12221, 12221, 12420], [12422, 12422, 12443, 12443, 12598], [12600, 12600, 12629, 12629, 12857], [12859, 12859, 12898, 12898, 13121], [13123, 13123, 13147, 13147, 13283]]}
{"id": "XsjcW1", "name": "Sketch_Lattice2", "author": "cexlearning", "description": "Lattice2，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 10, "viewed": 95, "date": "1492432205", "time_retrieved": "2024-06-20T18:53:44.442375", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float pi = 3.1415926;\n    float t = iTime * 0.7;\n\n    float scale = 10.0 / iResolution.y;\n    vec2 p = fragCoord.xy * scale + 0.5; // pos normalized /w grid\n    p += vec2(2, 0.5) * iTime;\n\n    float rnd = fract(sin(dot(floor(p), vec2(21.98, 19.37))) * 4231.73);\n    float flip = fract(rnd * 13.8273) > 0.5 ? 1.0 : -1.0;\n    rnd = floor(rnd * 2.0) / 2.0 + floor(t) * flip / 2.0;\n\n    float anim = smoothstep(0.0, 0.66, fract(t));\n    float phi = pi * (rnd + anim * flip / 2.0 + 0.25);\n    vec2 offs = vec2(cos(phi), sin(phi)) * sqrt(2.0) / 2.0;\n\n    vec2 pf = fract(p);\n    float d1 = abs(0.5 - distance(pf, vec2(0.5 - offs))); // arc 1\n    float d2 = abs(0.5 - distance(pf, vec2(0.5 + offs))); // arc 2\n\n    float w = 0.1 + 0.08 * sin(t);\n    fragColor = vec4((w - min(d1, d2)) / scale);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjcW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[2, 2, 59, 59, 859]]}
{"id": "XsjyD1", "name": "Sketch_Text", "author": "cexlearning", "description": "Text，copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 7, "viewed": 130, "date": "1492432272", "time_retrieved": "2024-06-20T18:53:44.442375", "image_code": "float letter(vec2 coord)\n{\n    float size = iResolution.x / 25.0;\n\n    vec2 gp = floor(coord / size * 7.0); // global\n    vec2 rp = floor(fract(coord / size) * 7.0); // repeated\n\n    vec2 odd = fract(rp * 0.5) * 2.0;\n    float rnd = fract(sin(dot(gp, vec2(12.9898, 78.233))) * 43758.5453);\n\n    float c = max(odd.x, odd.y) * step(0.5, rnd); // random lines\n    c += min(odd.x, odd.y); // corder and center points\n\n    c *= rp.x * (6.0 - rp.x); // cropping\n    c *= rp.y * (6.0 - rp.y);\n\n    return clamp(c, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy;\n    coord.x += iResolution.x * 0.1 * iTime;\n\n    float c; // MSAA with 2x2 RGSS sampling pattern\n    c  = letter(coord + vec2(-3.0 / 8.0, -1.0 / 8.0));\n    c += letter(coord + vec2( 1.0 / 8.0, -3.0 / 8.0));\n    c += letter(coord + vec2( 3.0 / 8.0,  1.0 / 8.0));\n    c += letter(coord + vec2(-1.0 / 8.0,  3.0 / 8.0));\n    fragColor = vec4(c / 4.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsjyD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[0, 0, 26, 26, 519], [521, 521, 578, 578, 956]]}
{"id": "XsScWy", "name": "Raymarching shadow test", "author": "kosmonaut", "description": "I think this should cover the basic idea of raymarching, but I exectuted it more or less just as it looked in my head, but I'm always happy if someone comes along with reference solutions or links to such.", "tags": ["raymarch"], "likes": 2, "viewed": 516, "date": "1493493221", "time_retrieved": "2024-06-20T18:53:44.442375", "image_code": "\nconst float lightSize = 40.;\nconst float lightSizeSq = lightSize*lightSize;\nconst float lineSize = 10.;\n\nfloat line(vec2 p, vec2 a, vec2 b)  { // line distance field\n\tvec2 pa = p - a, ba = b - a;\n    float u = dot(pa, ba)/dot(ba, ba);\n \treturn length(pa - ba * clamp(u,0.,1.));\n}\n\nvoid mainImage( out vec4 O,  vec2 fragCoord )\n{\n    float t=iTime;\n    vec2 start = .5 * iResolution.xy,\n         end = start + vec2(cos(t),sin(t)) * min(iResolution.x,iResolution.y)/3.;\n    \n    \n    vec2 p = fragCoord;\n    \n    //Light\n    vec2 l = iMouse.z > 0. \n                ? iMouse.xy \n\t\t\t\t:vec2(.1, .5) *iResolution.xy;\n    \n    vec2 dir = normalize(l-p);\n    \n    \n    int i = 0; \n    while(i<40)\n    {\n    \tfloat dist = line(p,start,end)-lineSize;\n        \n        vec2 ftl = l-p;\n        \n    \tif(dot(ftl, ftl) < lightSizeSq && i==0) \n    \t{\n     \t \tO = vec4(1.,1.0,0.,1.);\n        \treturn;  \n    \t}\n       \n\t\tif(dist < 0.01)\n    \t{\n            if(i==0)\n            {\n        \t\tO = vec4(0.,0.5,0.,1.);\n            }\n        \treturn;\n    \t}\n        \n        if(dot(ftl, ftl) < dist*dist) \n        {\n            O = vec4(.9);\n            return;\n        }\n        \n        //step\n        p += dir * dist;\n        \n        i++;\n    }\n    \n    \n    O = vec4(0.125);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsScWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested", "functions": [[106, 106, 143, 166, 280], [282, 282, 329, 329, 1258]]}
