{"id": "3dfcDr", "name": "Rand214", "author": "supah", "description": "rand", "tags": ["random"], "likes": 2, "viewed": 41, "published": "Public", "date": "1631609440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n#define PI 3.14159265\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    uv = vec2(atan(uv.x, uv.y) * PI * .03, length(.1 * iTime + cos(uv * PI * .4)));\n    vec2 pos = uv * 10.;\n    \n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n   \tfloat r = random(i);\n    vec3 col = vec3(r);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [121, 121, 178, 178, 487]], "test": "untested"}
{"id": "3lfBW8", "name": "rep3109847", "author": "lennyjpg", "description": "sdfdssdfsdf", "tags": ["ddfsdfdf"], "likes": 1, "viewed": 127, "published": "Public API", "date": "1633019003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n\nfloat layer(vec2 uv, vec2 offset, float s, float t){\n   uv += offset * t * 100.4;\n   uv = rotate2D(uv, t);\n   float p = mod(uv.x/  s, 1.0);\n  // return smoothstep(p, p * 1.01, 0.5);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 f = fragCoord.xy;\n\n    float t = iTime * 0.01;\n    vec2 u = uv;\n    \n    float a = layer(f, vec2(0.0, 3.0), 500.0, t * -4.4);\n    float b = layer(f, vec2(3.3, 0.5), 100.0, t * 2.432);\n    float c = layer(f, vec2(2.2, -3.3), 50.0, t * -1.32);\n\n    float k = a - b + c;\n    \n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 181], [184, 184, 236, 236, 381], [383, 383, 440, 440, 789]], "test": "untested"}
{"id": "4tjXWt", "name": "Simple Concrete Material", "author": "jt", "description": "A procedural material that is supposed to look like concrete (based on perlin resp. simplex noise), using iq's ray-marcher &  candycats' noise lab.\n", "tags": ["noise", "perlin", "simplex", "material", "concrete"], "likes": 3, "viewed": 53, "published": "Public", "date": "1631303626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4tjXWt\n// Simple Concrete Material, 2021 by jt\n// (using iq's raymarching & candycat' noises)\n\n// https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n    p3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// https://www.shadertoy.com/view/4sc3z2\n// Noise Lab (3D) by candycat\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n\n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return  mix(\n                mix(\n                    mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))),\n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                        w.x),\n                    mix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))),\n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                        w.x),\n                    w.z),\n                mix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))),\n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                        w.x),\n                    mix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))),\n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                        w.x),\n                    w.z),\n                w.y);\n}\n\n// https://www.shadertoy.com/view/4sc3z2\n// Noise Lab (3D) by candycat\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n\nfloat halfspace(vec3 p)\n{\n    return p.z + 1.2;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat box(vec3 p)\n{\n    vec3 d = abs(p) - 1.0;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder( vec3 p )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(1,1);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    return min(min(box(p+vec3(+1.0,0.0,0.0)), cylinder(p+vec3(-1.0,0.0,0.0))), halfspace(p));\n    //return min(min(box(p+vec3(+1.0,0.0,0.0)), sphere(p+vec3(-1.0,0.0,0.0))), halfspace(p));\n    //return box(p);\n}\n\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm tetrahedron normals\nvec3 normal( vec3 p ) \n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    for(float t = 0.0; t < DIST_MAX;)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return DIST_MAX;\n}\n\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nvec3 material(vec3 p)\n{\n    vec3 color = vec3(0.0);\n    vec3 color0 = mix(vec3(0.45), vec3(0.55), simplex_noise(p*vec3(20.0, 20.0, 1.0)));\n    //vec3 color0 = mix(vec3(0.4), vec3(0.6), perlin_noise(p*vec3(20.0, 20.0, 1.0)));\n    vec3 color1 = mix(vec3(0.4), vec3(0.6), simplex_noise(p*vec3(50.0, 50.0, 50.0)));\n    //vec3 color1 = mix(vec3(0.4), vec3(0.6), perlin_noise(p*vec3(50.0, 50.0, 50.0)));\n    color = mix(color0, color1, 0.75);\n    return color;\n}\n\n#define pi 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 6.28 * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x != 0.0) ? mx : 6.28 * fract(iTime * 0.1);\n    my = (iMouse.y != 0.0) ? my : pi / 2.0;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0, -5.0 );//vec3(0.0, -10.0 * my, 0.0);\n    //mat2 S = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0));\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz=S*ro.yz;\n    ro.xy = R * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz=S*rd.yz;\n    rd.xy = R * rd.xy;\n\n    float dist = trace(ro, rd);\n    vec3 dst = ro + rd * dist;\n    vec3 n = normal(dst);\n    \n    vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 ambient = vec3(0.4);\n    float brightness = max(dot(lightdir, n), 0.0);\n    brightness *= shadow(ro+rd*dist,lightdir, 0.01, DIST_MAX ); // XXX artifacts on cylinder XXX\n    //vec3 color = (n * 0.5 + 0.5);\n    vec3 color = mix(vec3(0.1), vec3(material(dst)), step(-1.0, dst.z));\n    color = (ambient * calcAO(dst, n) + brightness) * color;\n\n    fragColor = mix(vec4(color, 1.0), vec4(0.0), step(DIST_MAX, dist));\n    fragColor = sqrt(fragColor); // approximate gamma\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 292, 315, 315, 433], [435, 435, 457, 457, 612], [614, 685, 713, 713, 1673], [1675, 1746, 1775, 1775, 2478], [2526, 2526, 2551, 2551, 2575], [2577, 2577, 2599, 2599, 2629], [2631, 2631, 2650, 2650, 2743], [2745, 2745, 2771, 2771, 2882], [2884, 2884, 2903, 2903, 3114], [3116, 3201, 3225, 3225, 3487], [3489, 3489, 3520, 3520, 3691], [3693, 3756, 3820, 3820, 3981], [3983, 4047, 4089, 4089, 4376], [4378, 4378, 4401, 4401, 4834], [4858, 4858, 4915, 4915, 6375]], "test": "untested"}
{"id": "7d3Sz4", "name": "Damped Spring ODE", "author": "oneshade", "description": "My first second order ODE. Especially fun because afterwards I can make a fun animation with it! :)\nSolving process (updated): https://www.desmos.com/calculator/z8c1limv0t", "tags": ["solution", "spring", "oscillation", "damping", "ode"], "likes": 13, "viewed": 116, "published": "Public", "date": "1632788971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// https://www.shadertoy.com/view/tlcBW2\nfloat udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\n// mx'' + ux' + kx = 0\nfloat springODE(in float t, in float t0, in float x0, in float v0,\n                in float m, in float u, in float k) {\n\n    t -= t0;\n    float alpha = -u / (2.0 * m);\n    float discr = alpha * alpha - k / m;\n    float beta = sqrt(abs(discr));\n\n    if (discr < 0.0) { // Normal oscillation\n        float w = beta * t;\n        return (x0 * cos(w) - (alpha * x0 - v0) / beta * sin(w)) * exp(alpha * t);\n    }\n\n    if (abs(discr) < 1e-3) { // No oscillation - edge case\n        return (x0 - (alpha * x0 - v0) * t) * exp(alpha * t);\n    }\n\n    // No oscillation\n    return (((beta - alpha) * x0 + v0) * exp((alpha + beta) * t) +\n            ((beta + alpha) * x0 - v0) * exp((alpha - beta) * t)) / (2.0 * beta);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0 * cos(iTime), sin(0.5 * iTime)) * 2.0;\n\n    // Constants: mass (m), springiness (k), resistance/friction (u)\n    float m = 1.0;\n    float k = 100.0;\n    float u = 0.8;\n\n    // Initial position (x0) and initial velocity (v0)\n    float x0 = 3.0;\n    float v0 = 0.0;\n\n    // Position vs. time graph\n    float y = springODE(iTime - uv.x, 0.0, x0, v0, m, u, k) - 2.0;\n    float dx = (springODE(iTime - uv.x + 0.001, 0.0, x0, v0, m, u, k) - 2.0 - y) / 0.001;\n    if (uv.x > 0.0 && uv.x < iTime) drawSDF(abs(uv.y - y) / sqrt(1.0 + dx * dx), vec3(1.0, 0.0, 0.0));\n\n    // Spring and weight\n    float x = springODE(iTime, 0.0, x0, v0, m, u, k) - 2.0;\n    if (uv.y < 8.0 && uv.y > x) drawSDF(udTriangleWave(vec2(uv.y - 4.0, uv.x), 12.0 / (4.0 - x), 0.7), vec3(0.0));\n    drawSDF(sdDisk(uv, vec2(0.0, x), 0.5), vec3(0.0, 0.0, 1.0));\n\n    // Vignette\n    color *= 1.0 - 2.0 * pow(length(fragCoord / iResolution.xy - 0.5), 4.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3Sz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 56, 56, 88], [90, 90, 137, 137, 245], [247, 288, 350, 350, 603], [605, 628, 748, 748, 1337], [1419, 1419, 1474, 1474, 2748]], "test": "untested"}
{"id": "7d3XD8", "name": "progressive random gradients ", "author": "FabriceNeyret2", "description": "Progressive variant of https://shadertoy.com/view/fscSWH where you (almost) don't see the white pixels appearing.\nClick to see the difference.", "tags": ["gradient", "hash", "dithering", "bluenoise", "whitenoise"], "likes": 6, "viewed": 186, "published": "Public API", "date": "1633020918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Progressive variant of https://shadertoy.com/view/fscSWH\n// Eulerian variant of https://www.shadertoy.com/view/fdcXWH\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define T(c)     texelFetch(c, ivec2(u) % textureSize(c,0).xy, 0).x \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R;\n    u.x += float(iFrame);\n    U = u / R;\n\n    float h =    P.y > .66 ? hash(U)\n               : P.y > .33 ? T(iChannel0) \n               :             T(iChannel1);\n    O = vec4 ( iMouse.z > 0. ? step(P.x,h)               // raw thresholding\n                             : R.x/64.* ( h - P.x) +.5   // progressive appear\n             );             // 10.\n    if ( int(u.y)*3 % int(R.y) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 264, 302, 302, 782]], "test": "untested"}
{"id": "7d3XDr", "name": "note:02", "author": "shunyadezain", "description": "practice raymarching", "tags": ["raymarching", "fold"], "likes": 8, "viewed": 61, "published": "Public", "date": "1632934112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//reference: https://gam0022.net/blog/2017/03/02/raymarching-fold/\n\n#define PI  3.14159265359\n#define PI2 PI * 2.0\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) \n{\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat de1(vec3 p, float s)\n{\n    \n    float scale = s;\n    vec3 size = vec3(.3, 1., .3);\n        float d = sdBox(p, size);\n\n        for (int i = 0; i < 8; i++){\n           vec3 q = foldX(p);\n           q.xy -= size.y * 2.;\n           q.xy *= rotate(PI * iTime * 0.1);\n\n           d = min(d, sdBox(p, size * scale));\n           p = q;\n        }\n\n        d = min(d, sdBox(p, size));\n        return d;\n}\n    \n\nfloat map(vec3 p)\n{\n    vec3 p1 = p;\n    p1.xy = foldRotate(p.xy, 3.);\n    vec3 p2 = p;\n    p2.zy = foldRotate(p.zy, 5.);\n    vec3 p3 = p;\n    p3.zx = foldRotate(p.zx, 10.);\n\n    return min(de1(p1, 0.8), min(de1(p2, sin(iTime * 0.2) + .4), de1(p3, 1.)));\n} \n\nvec3 doColor(vec3 p)\n{\n    return vec3(0.,.1,.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,0,-50);\n    ro.zx*=rotate(iTime*0.2);\n    ro.zy*=rotate(iTime*0.5);\n    vec3 rd=normalize(vec3(uv,2));\n    vec3 ta=vec3(0);\n    vec3 w=normalize(ta-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=cross(u,w);\n    mat3 lookat=mat3(u,v,w);\n    rd=lookat*rd;\n    float d,i,t=0.0;\n    vec3 p=ro;\n    vec3 col=vec3(0);\n    for(i=1.0;i>0.0;i-=1./50.0)\n    {\n        t+=d=map(p);\n        if(d<0.0001)\n        {\n            col+=doColor(p);\n            col+=pow(i, 1.);\n            break;\n        }\n        p+=rd*d;\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 116, 136, 136, 172], [174, 174, 196, 196, 245], [247, 288, 329, 329, 453], [456, 456, 487, 487, 574], [576, 576, 604, 604, 976], [983, 983, 1002, 1002, 1239], [1242, 1242, 1264, 1264, 1293], [1296, 1296, 1353, 1353, 1986]], "test": "untested"}
{"id": "7d3XzH", "name": "Flowers-1", "author": "1rosehip", "description": "Inspired by this great tutorial: https://www.youtube.com/watch?v=0ifChJ0nJfM\n\nBut I still need to find out how to make the flowers have different colors and how to prevent \"stretching\" of the whole scene.", "tags": ["flower", "rotation"], "likes": 3, "viewed": 44, "published": "Public", "date": "1632605887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 getRotationMatrix(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s,\n                s, c);\n}\n\n\nvec3 flower(\n        vec2 position, \n        vec2 center, \n        float amplitude, \n        float size, \n        float frequency, \n        float blur, \n        float rotation, \n        vec2 skew,\n        float index) {\n    \n    // by default, flower color will be black, and the background white\n    vec3 color = vec3(1.0);\n    vec2 figure = position - center;\n\n    // draw the vertical line\n    float lineSize = 0.005;\n\n    // 0.1 * sin(5.0 * figure.y) makes the line be \"wavy\"\n    // to flip horizontaly -> - 0.1 * sin(5.0 * figure.y)\n    float verticalLine = smoothstep(lineSize, lineSize + lineSize / 2.0, abs(figure.x + 0.1 * sin(5.0 * figure.y)));\n\n    // remove the 'top' part of the vertical line \n    color *= 1.0 - (1.0 - verticalLine) * (smoothstep(0.1, 0.0, figure.y));\n\n    // animation\n    mat2 mat = getRotationMatrix(iTime * index * 2.5);\n    figure = mat * figure;\n\n    // draw the flower\n    figure += skew;\n    float r = size + amplitude * cos(atan(figure.y, figure.x) * frequency + rotation);\n    color *= smoothstep(r, r + blur, length(figure));\n\n    // apply the colors\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord / iResolution.y - vec2(0.5, 0.0);\n    \n    // mirror effect\n    // vec2 uv = abs(fragCoord.xy / iResolution.xy - 0.5); \n    \n    // duplicates effect\n    // uv = mod(uv * 12.0, 1.0); \n    \n    // diagonal symmetry\n    // if (uv.x>uv.y) uv = uv.yx;\n    \n    // nice rotation\n    // uv += .1*sin(5.*uv-iTime);\n    \n    // another cool effect :)\n    // uv /= ( .5-dot(uv,uv) );\n\n    vec3 color = mix(vec3(0.1647, 0.8078, 0.3255), vec3(1.0), uv.y);\n\n    // draw all flowers and black and white\n    color     *= flower(uv, vec2(0.5, 0.5),  0.1,  0.1, 10.0, 0.01, 0.0, vec2(0.0), -0.6);\n    color     *= flower(uv, vec2(0.3, 0.9),  0.1,  0.001, 4.0,  0.01, 0.0, vec2(0.0), 0.2);\n    color     *= flower(uv, vec2(0.51, 0.83),  0.01, 0.09, 60.0, 0.01, 0.0, vec2(0.0), 0.3);\n    color     *= flower(uv, vec2(0.1, 0.2),  0.2,  0.1, 7.0,  0.01, 0.0, vec2(0.0), -0.4);\n    color     *= flower(uv, vec2(0.55, 0.1), 0.05, 0.1, 3.0,  0.01, 0.0, vec2(0.0), 0.5);\n    color     *= flower(uv, vec2(0.8, 0.3),  0.05, 0.1, 10.0, 0.01, 0.0, vec2(0.0), -0.6);\n    color     *= flower(uv, vec2(0.15, 0.7), 0.01, 0.1, 10.0, 0.01, 0.0, vec2(0.0), 0.7);\n    color     *= flower(uv, vec2(0.8, 0.8),  0.03, 0.1, 10.0, 0.01, 0.0, vec2(0.0), 0.8);\n\n    // color them\n    color = mix(vec3(1.0, 0.9961, 0.8392), vec3(0.1725, 0.6471, 0.5216), color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3XzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 138], [141, 141, 360, 437, 1253], [1256, 1256, 1313, 1355, 2738]], "test": "untested"}
{"id": "7dcSDr", "name": "Oscillator a la hydra", "author": "alvarobyrne", "description": "Oscillator like hydra does: [url]https://github.com/ojack/hydra-synth[/url]", "tags": ["hydra"], "likes": 1, "viewed": 101, "published": "Public API", "date": "1632933564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 osc(vec2 _st, float frequency, float sync, float offset) {\n     vec2 st = _st;\n     float r = sin((st.x-offset/frequency+iTime*sync)*frequency)*0.5  + 0.5;\n     float g = sin((st.x+iTime*sync)*frequency)*0.5 + 0.5;\n     float b = sin((st.x+offset/frequency+iTime*sync)*frequency)*0.5  + 0.5;\n     return vec4(r, g, b, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = osc(uv,60.,0.1,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 330], [333, 333, 390, 440, 543]], "test": "untested"}
{"id": "7dcSR4", "name": "Supah Japan flag ", "author": "supah", "description": "Japan flag", "tags": ["displacement", "flag", "japan"], "likes": 0, "viewed": 37, "published": "Public", "date": "1632732234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    vec2 u = (I-.5*R.xy)/R.y+vec2(.55,-.2);\n    float d = texture(iChannel1, .1*u+iTime*.1).r * .024;\n    u += d;\n    float c = sin(iTime+16.*atan(u.x,u.y));\n    c = smoothstep(.1,.1+1.5/R.y, c);\n    O = vec4(mix(vec3(1,0,0),vec3(1),vec3(c-smoothstep(.85,.85 +1.5/R.y, 1.-length(u))))-d*2.,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 368]], "test": "untested"}
{"id": "7dcSRM", "name": "Geometric Wave", "author": "Flopine", "description": "Still exploring repetition trick presenting by Blackle, this time with size variation and translation! It still contains some artefacts, reduced by marching slower", "tags": ["raymarching", "palette", "polar", "repetiion"], "likes": 23, "viewed": 358, "published": "Public", "date": "1632835554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Still exploring repetition trick presenting by Blackle on Perfect Pistons <3 \n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define palette(t,c) (vec3(.8)+vec3(.7)*cos(TAU*(c*t+vec3(0.8,0.1,0.2))))\n\n#define dt(sp) fract(iTime*sp)\n\n// iq's website: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    return (p2.x > p2.y) ? vec2((p.x<0.)?-1.:1., 0.) : vec2(0., (p.y<0.)?-1.:1.);\n}\n\nfloat palt;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 center = floor(p.xz)+.5,\n    neighbour = center + edge(p.xz-center);\n    palt = atan(center.y,center.x);\n    \n    float a = palt-(dt(.5)*TAU), \n    radius = length(center),\n    \n    py = sin(length(center)+dt(.25)*TAU)*.5+.5, \n    size = clamp(sin(a+radius)*.5+.5,0.08,0.4),\n\n    me = length(p-vec3(center.x,py,center.y))-size,\n    // has to be the sum of all possible spheres\n    next = sdVerticalCapsule(p-vec3(neighbour.x,0.,neighbour.y),1.,0.4); \n\n    return min(me,next);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(uv*4.,-30.), rd=vec3(0.,0.04,1.),p=ro,\n    col=vec3(0.), l=normalize(vec3(1.,2.,-2.));\n\n    bool hit=false;\n    for(float i=0.;i<100.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit=true;break;\n        }\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.15),\n        ao = AO(0.1,p,n)+AO(0.25,p,n)+AO(0.8,p,n);\n        \n        col = palette(abs(palt)/PI,1.)*light*ao/3.;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[725, 814, 867, 867, 926], [928, 928, 948, 948, 1054], [1068, 1068, 1088, 1088, 1642], [1644, 1644, 1667, 1667, 1780], [1782, 1782, 1820, 1820, 1858], [1861, 1861, 1918, 1918, 2515]], "test": "untested"}
{"id": "7dcSRn", "name": "Lesson-0123", "author": "xlat", "description": "Lesson-0123", "tags": ["fragmentshader"], "likes": 1, "viewed": 35, "published": "Public", "date": "1632473065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// www.cyberforum.ru\n///----------------------------------------------------------------------------:\n\n///----------------------------------|\n/// Координаты(верхнего левого угла) | \n/// квадрата и его размер.           |\n/// (уже нормированные)              |\n///----------------------------------:\nvec3 Q1 = vec3(0.2, 0.5, 0.3);\nvec3 Q2 = vec3(0.51, 0.5, 0.2);\nvec3 Q3 = vec3(0.72, 0.5, 0.1);\n///----------------------------------.\n\nconst float PI = 3.14;\n\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = PI / (maxx - minn);\n    float c  = 0.8  * sin(a * x)+0.1;\n    return vec4(0.1, c, 0.1, 0.9);\n}\n\nvec4 colorquad(vec2 pos, vec3 q)\n{   float k = iResolution.y / iResolution.x;\n\n    if(     q.x < pos.x && pos.x < (q.x+q.z) &&\n            q.y < pos.y && pos.y < (q.y+q.z*k)  )\n    {   \n        return tonsin(q.x, q.x+q.z, pos.x);\n    }\n    return vec4(0.0);\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = vec2(1.- uv.y+cos(iTime)*0.1, uv.x+sin(iTime)*0.1);\n    \n    fragColor   = colorquad(uv, Q1)\n                + colorquad(uv, Q2)\n                + colorquad(uv, Q3);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcSRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[547, 611, 657, 657, 782], [784, 784, 818, 818, 1043], [1045, 1216, 1273, 1273, 1499]], "test": "untested"}
{"id": "7dcXD8", "name": "linear gradient with curve", "author": "sam_hains", "description": "linear gradient", "tags": ["gradient"], "likes": 1, "viewed": 19, "published": "Public", "date": "1633021558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vUv = uv;\n    float time = iTime;\n    // Time varying pixel color\n    float yOffset = .0;\n \n    float grad =vUv.y + sin(vUv.x*3.0+time) / 10.0-yOffset;\n    grad = smoothstep(0.2,0.4,grad);\n\n    // Output to screen\n    fragColor = vec4(vec3(grad),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcXD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 410]], "test": "untested"}
{"id": "7ddGzX", "name": "Colour Pencils", "author": "bitless", "description": "Colour Pencils", "tags": ["2d"], "likes": 23, "viewed": 113, "published": "Public", "date": "1630484031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: bitless\n// Title: Colour Pencils\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  http://www.iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define s(sm,p,i,j) smoothstep (p+sm,p-sm,abs(i)+j)\n\nvec3 p(vec2 uv, vec2 l, vec2 sh, float sm, out float a)\n{\n        float ys = fract(sin(dot(floor(uv),vec2(12.9898,78.233)))*43758.5453123); //random y-shift and color for cell\n        vec3 c = .6 + .6 * cos(6.3*(ys) + vec3(0.,23.,21.)); //base color HUE\n        ys += (sin(iTime*ys*2.+ys*3.)-1.)*.25; //y-shift moving \n        l.x += sh.x;\n        ys += sh.y;\n        \n        a = (smoothstep(1.,.5,abs(l.x)+(l.y-ys))*.6 + s(sm,.5,l.x,l.y-ys)*.4)*s(sm,.5,l.x,0.); //alpha mask\n        vec3 f = l.y < ys ? c*.6 :vec3(0.); //base color\n        f = mix (f,vec3(.9,.9,.6), s(sm,.5,l.x,abs(l.y-ys))); //yellow nib\n        f = mix (f,c, s(sm,.2,l.x,abs(l.y-ys-.3))); //color nib\n        f *= (1.-abs(l.x)) * (smoothstep(sm,-sm,l.x)+1.5)/2.; //light & shadow \n        return f; \n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,uv = ((g+g-r)/r.y+vec2(0.,-iTime*0.3))*vec2(4, 1)*vec2(.75)\n        ,l = fract(uv); //cell local coords \n    float  sm = 3./r.y //smoothing factor\n            ,a; //alpha\n    \n    l.x -= .5;\n    l.y *= 4.;\n    \n    vec3 f = p(uv+vec2(0.,1.),l,vec2(0.,4.5),sm,a); //top neighbor\n    f = mix (f,p(uv+vec2(9.,0.),l,vec2(-.5,2.),sm,a),a); //left neighbor\n    f = mix(f,p(uv+vec2(8.,0.),l,vec2(.5,2.),sm,a),a); //right neighbor\n    f = mix(f,p(uv,l,vec2(0.,.5),sm,a),a); \n    C = vec4(f,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 378, 435, 435, 1151], [1153, 1153, 1193, 1193, 1719]], "test": "untested"}
{"id": "7df3zn", "name": "MAGIC BOX", "author": "willis", "description": "MAGIC BOX", "tags": ["raymarching"], "likes": 8, "viewed": 77, "published": "Public", "date": "1632823269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define Sat(a) clamp(a, 0., 1.)\n\nvec3 objcol = vec3(0.);\nfloat ffd1 = 1., ffd2 = 1.;\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Octa(vec3 p, float s){\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat GetDist(vec3 p){\n    float t = (iTime*.3) + iMouse.x/iResolution.x;\n\n    p = vec3(p.xy * Rot(t), p.z);\n    p.yz *= Rot(t*0.5);\n    float r =  0.5;\n    \n    float l = S(0.2, 0.8, abs(sin(t))) + ffd1 * 0.2;\n   \n    vec3 op = p;\n    \n    op.zx *= Rot(t);\n    op.xy *= Rot(t*3.5);\n    op.yz *= Rot(t*2.2);\n    \n    p = abs(p) - l - r;\n    \n    \n    \n    float d = length(p) - r;\n    //d = max(d, Octa(p,0.6) );\n    \n    op = abs(op);\n    //d = min(d, min((length(op) - l * 0.3), Octa(op, l * r) ));\n\n    d = min(d,Octa(op, l * r));\n    \n    d = min(d, max(length(p.xz)-.1,p.y));\n    d = min(d, max(length(p.xy)-.1,p.z));\n    d = min(d, max(length(p.yz)-.1,p.x));\n    \n    //l = S(0.4, 0.8, abs(sin(t*0.2)));\n    \n    \n    //.yz *= Rot(t*3.);\n    \n    //op.xz *= Rot(op.y * .5);\n    \n    d = min(d, length(vec2(length(op.xz)-(l*4.*ffd1+2.), op.y)) - (l*0.01+0.1) );\n    d = min(d, Octa(op-r,0.2));\n    d = min(d, length(vec2(length(op.xy)-(l*3.*ffd1+2.), op.z) ) - (l*0.01+0.1));\n    //d = min(d, length(vec2(length(op.yz)-(l*2.+2.), op.x) ) - (l*0.01+0.1));\n    \n    \n    //q.xz *= Rot(0.1 * q.y);\n   \n    vec3 q = op;\n    q.xz *= Rot(q.y * 0.5);\n    q.xy *= Rot(t*0.5);\n    q.yz *= Rot(t*2.3);\n    \n    d = min(d, length(vec2(length(q.xy)-(l-r+0.8), q.z)) - (l*0.05+0.01));\n    d = min(d, length(vec2(length(q.yz)-(l-r+0.8), q.x)) - (l*0.05+0.01));\n    d = min(d, length(vec2(length(q.xz)-(l-r+0.8), q.y)) - (l*0.05+0.01));\n    \n    objcol += abs(op);\n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(0., .001);\n    return vec3(normalize(GetDist(p) - vec3(GetDist(p - e.yxx), GetDist(p - e.xyx),GetDist(p - e.xxy)) ));\n}\n\nfloat Hash21(vec2 p){\n    p = sin(p * vec2(135.11, 257.49));\n    float n = dot(p, p + 1237.56);\n    return fract(n * (p.x * p.y));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float d = 0.;\n    vec3 p = ro ;\n    for(int i=0; i<100; i++){\n        float d1 = GetDist(p);\n        d += d1;\n        p += rd * d1;      \n        if(d > 100. || d1 < 0.01) break;\n    }\n    return d;\n}\n\nfloat refMarch(vec3 ro, vec3 rd){\n    float d = 0.;\n    vec3 p = ro ;\n    for(int i=0; i<32; i++){\n        float d1 = GetDist(p);\n        d += d1;\n        p += rd * d1;      \n        if(d > 100. || d1 < 0.01) return d;\n    }\n    return 999.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    float m = iMouse.x/iResolution.x;\n    vec3 col = vec3(0), bg = vec3(0);\n    vec3 ro = vec3(vec2(1,1) * Rot(iTime+m),-8), rd = normalize(vec3(uv,1));\n    ffd1 = texture(iChannel0, vec2(32. / 512., 0)).x * 0.5;\n    ffd2 = texture(iChannel0, vec2(1. / 512., 0)).x;\n    float d = march(ro, rd); //first pass\n    \n    if(d < 100.){\n        ro += d * rd;\n        col += objcol * 0.015;\n        \n        rd = reflect(rd, GetNormal(ro));\n        ro += rd ;\n        d = refMarch(ro, rd);  //second pass(reflection)\n        \n\n        if(d < 100.){\n            vec3 p = ro + rd * d;\n            vec3 refcol = Sat(dot(GetNormal(p), vec3(0., 0., -1.)) ) * objcol ;\n            col += refcol * 0.01;\n        }\n    }\n    else{ \n        bg = abs(uv.x) * vec3(0.3, 0.4, 0.2);\n        bg += (1.-(fragCoord/iResolution.xy).y) * vec3(0.3, 0.1, 0.4);\n        bg *= ffd2;\n    }\n    col += S(-5., 5., ro.z) * .2 + bg;\n    col = pow(col, vec3(2.2));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7df3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 143, 143, 219], [221, 221, 249, 249, 314], [316, 316, 338, 338, 1786], [1788, 1788, 1811, 1811, 1949], [1951, 1951, 1972, 1972, 2083], [2085, 2085, 2115, 2115, 2320], [2322, 2322, 2355, 2355, 2565], [2567, 2567, 2624, 2624, 3647]], "test": "untested"}
{"id": "7dG3DW", "name": "Animated SDF  with Cook-Torrance", "author": "steps3d", "description": "Example of complex SDF animated shape with Cook-Torrance shader", "tags": ["sdf", "pbr", "cooktorrance"], "likes": 1, "viewed": 49, "published": "Public", "date": "1631548287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0 + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n    \n    //return dSphere ( p, vec3 ( 2, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.7, 0.1, 0.1 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( r0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tfloat diff = max(nl, 0.0);\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( diff * clr + ks * ct, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v );\n\t} \n\n        // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dG3DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 184, 211, 211, 358], [360, 398, 425, 425, 572], [574, 574, 611, 611, 676], [678, 678, 707, 707, 775], [777, 777, 806, 806, 893], [896, 896, 929, 929, 1010], [1012, 1012, 1054, 1054, 1124], [1126, 1126, 1151, 1246, 1290], [1292, 1292, 1328, 1328, 1539], [1541, 1541, 1608, 1608, 1923], [1925, 1925, 1977, 1977, 2346], [2548, 2576, 2623, 2623, 2737], [2739, 2739, 2788, 2788, 2928], [2930, 2930, 2985, 2985, 3141], [3143, 3143, 3193, 3193, 3340], [3342, 3342, 3408, 3408, 3550], [3552, 3552, 3598, 3598, 3634], [3636, 3636, 3694, 3694, 3726], [3728, 3728, 3800, 3800, 3859], [3861, 3861, 3927, 3927, 4428], [4430, 4430, 4487, 4542, 5397]], "test": "untested"}
{"id": "7dG3RW", "name": "slanted squares", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 2, "viewed": 43, "published": "Public", "date": "1631241411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fold(float x) {\n    return 2.0 * abs(0.5 - fract(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 2.);\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 15.;\n    \n    // diagonal grid\n    vec2 slantUV = vec2(uv.x + uv.y, uv.x - uv.y);\n    vec2 slantRnd = floor(slantUV);\n    slantUV = fract(slantUV + 0.5) - 0.5;\n    \n    // spiral\n    float r = length(slantRnd);\n    float angle = atan(slantRnd.y, slantRnd.x) / 2.0 / 3.14159265358979;\n    float spiral = fold(r * 0.15 + angle + time - cos(time * 3.1415927));\n\n    float thres = \n        min(abs(slantUV.x), abs(slantUV.y));\n        float zig = step(1., 1.5 * fract(time * 1. + abs(floor(0.25 + slantRnd.y - slantRnd.x)) / 6.));\n\n    vec3 col = mix(\n        mix(vec3(0.3, 0.1, 0.1), vec3(0.5, 0.2, 0.0), zig),\n        mix(vec3(0.1, 0.5, 0.8), vec3(0.0, 0.8, 1.0), zig),\n        \n        smoothstep(\n            0.7, 0.8,\n            spiral + thres\n        )\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dG3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 61], [63, 63, 120, 120, 1158]], "test": "untested"}
{"id": "7dG3WD", "name": "My balls", "author": "arovesto", "description": "Use sdf to draw simple fractals", "tags": ["sdf", "balls"], "likes": 1, "viewed": 79, "published": "Public", "date": "1631553738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 my_mod( vec3 p, float m) {\n    return p - m * round(p / m);\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( my_mod(p, 4.0) - c ) - 1.0;\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   q += iTime ;\n    \n    return dSphere ( q, vec3 ( 0, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\t//return smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 100.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dG3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 184, 211, 211, 358], [360, 398, 425, 425, 572], [574, 574, 605, 605, 640], [642, 642, 679, 679, 726], [728, 728, 757, 757, 825], [827, 827, 856, 856, 943], [946, 946, 979, 979, 1060], [1062, 1062, 1104, 1104, 1174], [1176, 1176, 1201, 1296, 1340], [1342, 1342, 1378, 1378, 1605], [1607, 1607, 1674, 1674, 1990], [1992, 1992, 2044, 2044, 2413], [2415, 2415, 2472, 2527, 3393]], "test": "untested"}
{"id": "7dG3zy", "name": "The Expanse Ring Gate", "author": "wouterdek", "description": "Reproduction of the ring gate shot as seen in the credits of The Expanse season 4. An experiment in procedural textures and spectral refraction.", "tags": ["space", "wormhole", "theexpanse", "ringgate", "warpgate"], "likes": 11, "viewed": 91, "published": "Public", "date": "1631734213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nconst vec3 BACKGROUND_COLOR_1 = vec3(0., .247, .286);\nconst vec3 BACKGROUND_COLOR_2 = vec3(0., .014, .045);\n\nconst vec3 RING_COLOR_1 = vec3(.000, .051, .094);\nconst vec3 RING_COLOR_2 = vec3(.094, .447, .604);\n\nconst float RING_MIN_SIZE = 0.39;\nconst float RING_MAX_SIZE = .8;\nconst float RING_MIN_EDGE_SIZE = 0.014;\nconst float ZOOM_SPEED = 1./50.;\n\nconst float LENS_HEIGHT_MULTIPLIER = 0.05;\nconst vec3 LENS_IOR = vec3(2.286543164, 2.420857286, 2.435478974);\nconst vec3 LENS_TINT = vec3(1.00, 0.98, 0.94);\n\nconst float RING_HALO_INTENSITY = .005;\nconst vec3 RING_HALO_COLOR = vec3(0., .25, .3);\nconst vec3 RING_HIGHLIGHT_COLOR = vec3(0, .145, .212);\n\nfloat noise2(vec2 uv)\n{\n    float v = dot(uv, vec2(101.9364, 96.45418));\n    return fract(sin(v)*100000.0);\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x)*10000.0);\n}\n\nfloat valueNoise1(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float bl = rand(i + 0.);\n    float br = rand(i + 1.);\n    \n    return mix(bl, br, f);\n}\n\nfloat valueNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    float bl = noise2(i + vec2(0., 0.));\n    float br = noise2(i + vec2(1., 0.));\n    float tl = noise2(i + vec2(0., 1.));\n    float tr = noise2(i + vec2(1., 1.));\n    \n    return mix(bl, br, f.x) + \n            (tl - bl) * f.y * (1. - f.x) + \n            (tr - br) * f.y * f.x;\n}\n\n#define FBM_OCTAVES 3\nfloat fbm(vec2 x)\n{\n    float v = 0.;\n    float a = 0.5;\n\n    float am = 0.5;\n    float fm = 2.0;\n    \n    for(int i = 0; i < FBM_OCTAVES; ++i)\n    {\n        v += a * valueNoise(x);\n        x *= fm;\n        a *= am;\n    }\n    \n    return v;\n}\n\nfloat gradientNoise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float bl = noise2(i + vec2(0, 0));\n    float br = noise2(i + vec2(1, 0));\n    float tl = noise2(i + vec2(0, 1));\n    float tr = noise2(i + vec2(1, 1));\n    \n    return mix(bl, br, f.x) +\n        (tl - bl) * (1. - f.x) * f.y + \n        (tr - br) * f.x * f.y;\n}\n\nfloat voronoi(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float d = 64.;\n    for(int y = -1; y <= 1; ++y)\n    {\n        for(int x = -1; x <= 1; ++x)\n        {\n            vec2 b = vec2(x, y);\n            vec2 c = b+noise2(i+b)-f;\n            d = min(d, dot(c, c));\n        }\n    }\n    return sqrt(d);\n}\n\nfloat smoothVoronoi(vec2 uv, float smoothing)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float d = 0.;\n    for(int y = -1; y <= 1; ++y)\n    {\n        for(int x = -1; x <= 1; ++x)\n        {\n            vec2 b = vec2(x, y);\n            vec2 c = b+noise2(i+b)-f;\n            float l = length(c);\n            d += exp(-smoothing * l);\n        }\n    }\n    return -1./smoothing*log(d);\n}\n\nfloat powerRemap(float x, float head, float tail)\n{\n    return pow(1.0 - pow(x, head), tail);\n}\n\nfloat speckles(vec2 uv, float maxSize, float sizeVariation)\n{\n    float intensity = 16./maxSize + pow(smoothstep(1., 0.,  cos(sqrt(uv.x)*24.0) * sin(sqrt(uv.y)*15.0) * cos(uv.x*uv.y*64.0)), .9)*sizeVariation;\n    return powerRemap(voronoi(uv*50.), 1.5, intensity);\n}\n\nvec3 grid(vec2 uv)\n{\n    uv = 80. * uv;\n    return vec3(sin(uv.x), sin(uv.y), 0);\n}\n\nvec3 calcRefract(vec3 vIn, vec3 n, float iorA, float iorB, out float fresnel)\n{\n    float iorRel = iorA/iorB;\n\n    vIn *= -1.;\n    float cosI = dot(vIn, n);\n    float sinI = sqrt(1. - cosI * cosI);\n    float sinT = sinI * iorRel;\n    float cosT = sqrt(1. - sinT * sinT);\n    \n    float rPar = 0.;\n    {\n        float a = iorB * cosI;\n        float b = iorA * cosT;\n        rPar = (a - b) / (a + b);\n    }\n    float rPer = 0.;\n    {\n        float a = iorA * cosI;\n        float b = iorB * cosT;\n        rPer = (a - b) / (a + b);\n    }\n    fresnel = 0.5 * (rPar * rPar + rPer * rPer);\n    \n    return iorRel * -vIn + (iorRel * cosI - cosT) * n;\n}\n\nfloat lensHeight(vec2 uv)\n{\n    float v = length(uv);\n    float isNotCenter = (v/(v+0.05));\n    float a = LENS_HEIGHT_MULTIPLIER * (1.0 + sin(v*59.0)) * isNotCenter;\n    float b = LENS_HEIGHT_MULTIPLIER * (1.0 + sin(v*59.0*cos(0.075*iTime))) * isNotCenter;\n    return mix(b, a, min(1., v/0.3));\n}\n\n#define RAYMARCH_ITER 500\n#define RAYMARCH_STEP 0.001\n\nvec3 lensSurface(vec2 uv, float scale, out vec3 dIn, out vec3 normal)\n{\n    const float lensZPos = 1.0;\n    \n    vec3 p = vec3(0.0,0.0, 0);\n    vec3 d = normalize(vec3(uv.x, uv.y, 1.0) - p);\n    p += d * .7;\n    float tDepth = 0.;\n    \n    for(int i = 0; i < RAYMARCH_ITER; ++i)\n    {\n        p += d * RAYMARCH_STEP;\n        tDepth = lensZPos - lensHeight(p.xy / scale);\n        if(tDepth < p.z)\n        {\n            break;\n        }\n    }\n    \n    vec3 v1l = p + vec3(-.0001, 0, 0);\n    v1l.z = lensZPos - lensHeight(v1l.xy / scale);\n    vec3 v1r = p + vec3(.0001, 0, 0);\n    v1r.z = lensZPos - lensHeight(v1r.xy / scale);\n    vec3 v2t = p + vec3(0, -.0001, 0);\n    v2t.z = lensZPos - lensHeight(v2t.xy / scale);\n    vec3 v2b = p + vec3(0, .0001, 0);\n    v2b.z = lensZPos - lensHeight(v2b.xy / scale);\n    \n    normal = normalize(cross(v1r - v1l, v2t - v2b));\n    dIn = d;\n    return p;\n}\n\nvec2 lens(vec3 p, vec3 dIn, vec3 n, float ior, out float fresnel)\n{\n    const float bgPlaneZPos = 1.0;\n\n    vec3 refractDir = calcRefract(dIn, n, 1.0, ior, fresnel);\n    vec3 reflectDir = reflect(dIn, n);\n    \n    for(int i = 0; i < RAYMARCH_ITER; ++i)\n    {\n        p += refractDir * RAYMARCH_STEP;\n        if(bgPlaneZPos < p.z)\n        {\n            break;\n        }\n    }\n    return p.xy;\n}\n\nvec3 background(vec2 uv)\n{\n    float mixVal = smoothVoronoi(uv*2., 16.);\n    vec3 col = mix(BACKGROUND_COLOR_1, BACKGROUND_COLOR_2, mixVal);\n    \n    float stringy1 = pow(voronoi(uv*4.)*.6, 3.);\n    float stringy2 = pow(voronoi((uv+vec2(3,3))*5.)*.75, 3.);\n    float stringy = mix(stringy1, stringy2, 0.8 + .5*sin(iTime*0.1));\n    col += BACKGROUND_COLOR_1 * stringy;\n\n    const float scanFreq = 1.8;\n    const float scanIntensity = 0.05;\n    float scanVal = 0.5 * (1.0 + sin(uv.y*iResolution.y*scanFreq));\n    scanVal = scanIntensity*(scanVal-1.0)+1.0;\n    col *= scanVal;\n\n    return col;\n}\n\nfloat remapEdgeWrap(float x)\n{\n    x *= 200.;\n    return x+(valueNoise1(x*0.1)*PI*2.8);\n}\n\nvec3 ringEdge(vec2 uv, vec2 edgeSpaceUV, vec3 inCol, vec3 outCol, float aspect)\n{\n    float edgePLateral = edgeSpaceUV.x;\n    float edgePTransverse = edgeSpaceUV.y;\n\n    float wrap = max(0., sin(remapEdgeWrap(edgePLateral) + edgePTransverse*6.)); \n    wrap = wrap;\n    \n    float q = sin(edgePTransverse*PI*.8);\n    q *= q * q * q * q;\n    q = q * q * q * q;\n    q = q * q;\n    float r = max(0., dot(normalize(vec3(uv, 1.)), normalize(vec3(-10,-30,0.))))*.3*(0.5+wrap*.5);\n    \n    \n    float colMixCoef = fbm(uv*aspect*200.);\n    colMixCoef *= 1. - wrap*.33;\n    float v = gradientNoise(uv*5.);\n    colMixCoef *= 0.5 + 1.5 * v * v;\n    \n    vec3 c = mix(RING_COLOR_1, RING_COLOR_2, colMixCoef);\n    c = mix(mix(inCol, outCol*.8, edgePTransverse), c, sin(edgePTransverse*PI));\n    c = mix(c, RING_HIGHLIGHT_COLOR * 10., q*r);\n    \n    float speckFact = 1.0 + 0.5*sin(iTime*.5 * edgeSpaceUV.x);\n    c += pow(speckles(uv*1.0, 10., 30.), 0.2) * max(-.2, sin(edgeSpaceUV.x*9.0)) * RING_COLOR_2 * sin(edgePTransverse*PI) * speckFact;\n    c += pow(speckles(uv*1.5, .1, 100.), 0.2) * max(-.2, sin(edgeSpaceUV.x*8.0)) * RING_COLOR_2 * sin(edgePTransverse*PI) * speckFact;\n    \n    float k = max(0., dot(normalize(vec3(uv, 1.)), normalize(vec3(10,30,0.)))) * cos(edgePTransverse);\n    k = pow(k, 1.2);\n    c = mix(c, inCol, min(0.8, k));\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x/iResolution.y;\n    vec2 ringUV = uv;\n    ringUV.x *= aspect;\n    vec2 ringCenteredUV = ringUV - vec2(0.5*aspect, 0.5);\n\n    const float ringTimeFac = (PI*0.5) * ZOOM_SPEED;\n    float ringSize = RING_MIN_SIZE + (RING_MAX_SIZE-RING_MIN_SIZE)*(1.0 - 0.5*(1.+cos(iTime*ringTimeFac)));\n    float ringScaleFactor = ringSize / RING_MIN_SIZE;\n    float ringEdgeSize = RING_MIN_EDGE_SIZE * ringScaleFactor;\n    float centerDist = length(ringCenteredUV);\n    \n    vec3 bg = background(ringCenteredUV)*.4;\n\n    vec3 col = vec3(0,0,0);\n    \n    if(centerDist < ringSize)\n    {\n        float fresnel;\n        vec3 normal;\n        vec3 dIn;\n        vec3 p = lensSurface(ringCenteredUV, ringScaleFactor, dIn, normal);\n\n        vec2 fgUvR = lens(p, dIn, normal, LENS_IOR.r, fresnel);\n        vec2 fgUvG = lens(p, dIn, normal, LENS_IOR.g, fresnel);\n        vec2 fgUvB = lens(p, dIn, normal, LENS_IOR.b, fresnel);\n        vec3 fg = vec3(\n            pow(voronoi((fgUvR+vec2(1,1))*180.), 8.)*voronoi((fgUvR+vec2(3,3))*10.),\n            pow(voronoi((fgUvG+vec2(1,1))*180.), 8.)*voronoi((fgUvG+vec2(3,3))*10.),\n            pow(voronoi((fgUvB+vec2(1,1))*180.), 8.)*voronoi((fgUvB+vec2(3,3))*10.)\n        );\n        fg *= LENS_TINT;\n        fg *= (1. + sin(100.*voronoi(fgUvR*10.) + iTime))*.5;\n        fg *= 1. - fresnel;\n        fg += fresnel * bg * pow(centerDist / ringSize, 8.0);\n        col = fg;\n    }\n    else if(centerDist < ringSize + ringEdgeSize)\n    {\n        float edgePLateral = atan(ringCenteredUV.y, ringCenteredUV.x);\n        float edgePTransverse = (centerDist - ringSize) / ringEdgeSize;\n        col = ringEdge(ringCenteredUV / ringScaleFactor, vec2(edgePLateral, edgePTransverse), vec3(0,0,0), bg, aspect);\n    }\n    else\n    {\n        col = bg;\n        col += ((ringSize + ringEdgeSize)/pow(centerDist, 5.0)) * RING_HALO_INTENSITY * RING_HALO_COLOR;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dG3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[675, 675, 698, 698, 784], [786, 786, 807, 807, 843], [845, 845, 873, 873, 1018], [1020, 1020, 1046, 1046, 1378], [1402, 1402, 1421, 1421, 1644], [1646, 1646, 1676, 1676, 1989], [1991, 1991, 2015, 2015, 2317], [2319, 2319, 2366, 2366, 2716], [2718, 2718, 2769, 2769, 2813], [2815, 2815, 2876, 2876, 3081], [3083, 3083, 3103, 3103, 3166], [3168, 3168, 3247, 3247, 3812], [3814, 3814, 3841, 3841, 4110], [4167, 4167, 4238, 4238, 5057], [5059, 5059, 5126, 5126, 5452], [5454, 5454, 5480, 5480, 6046], [6048, 6048, 6078, 6078, 6137], [6139, 6139, 6220, 6220, 7484], [7486, 7486, 7543, 7543, 9514]], "test": "untested"}
{"id": "7dGGzt", "name": "Analytic domain repetition", "author": "NLIBS", "description": "A function for ray tracing cubes repeated In one dimension. (no loops in the code)\nMove around with the mouse", "tags": ["raytracing", "domainrepetition", "shadows", "infinite"], "likes": 3, "viewed": 132, "published": "Public API", "date": "1631936316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define EPS 0.001\n//#define BASIC\n\nfloat plane(vec3 ro, vec3 rd, float h) \n{\n    float t = (h-ro.y)/rd.y;\n    if (t<=0.) t = 1e5;\n    return t;\n}\n\nvec4 ray(vec3 ro, vec3 rd) \n{ \n    float t = plane(ro,rd,1.)*step(1.,ro.y);\n    vec3 n = vec3(0.,1.,0.);\n    \n    if (abs(ro.x)>.5-EPS) {\n        vec3 s = vec3(1.,sign(ro.x),1.);\n        float t2 = plane(ro.yxz*s,rd.yxz*s,.5-EPS)+EPS;\n        if (t2>=t) {\n            t = t2;\n            n = vec3(s.y,0.,0.);\n        }\n    }\n    \n    vec3 p = ro+rd*t;\n    float target = mix(p.z,floor(p.z+step(0.,rd.z)),mod(floor(p.z),2.));\n    float shift = (target-p.z)/rd.z;\n    t += shift;\n    if (abs(shift)>EPS) n = vec3(0.,0.,-sign(rd.z));\n    if (t<=0. || abs(ro.x+rd.x*t)>.5 || abs(ro.y+rd.y*t)>1.+EPS) t = 1e5;\n    \n    float t2 = plane(ro,rd,0.);\n    if (t2<t) {\n        t = t2;\n        n = vec3(0.,1.,0.);\n    }\n    \n    return vec4(t,n);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R   = iResolution.xy,\n         uv  = (2.*u-R)/R.x,\n         muv = -(2.*iMouse.xy-R)/R.x*PI*.5;\n    \n    muv = mix(vec2(.7,.3), muv, step(1.,iMouse.z));\n    //Camera\n    vec3 ro = vec3(muv.x*6.,2.,iTime),\n         rd = normalize(vec3(uv,1));\n         \n    //Add Mouse rotation\n    vec4 cs = vec4(cos(muv),sin(muv));\n    rd.yz = mat2(cs.y,cs.w,-cs.w,cs.y)*rd.yz;\n    rd.xz = mat2(cs.x,cs.z,-cs.z,cs.x)*rd.xz;\n    \n    vec3 col = vec3(0.);\n    \n    vec4 tn = ray(ro,rd);\n    vec3 p = ro+rd*(tn.x-EPS);\n    \n    vec3 ld = vec3(4.*sin(iTime),4.,iTime+6.)-p;\n    float d = length(ld)*0.05;\n    ld /= d;\n    \n    #ifdef BASIC\n    col = vec3(1.) * 0.5*(1.-sqrt(1.-min(0.01/(d*d),1.)));\n    #else\n    col = vec3(1.) * dot(tn.yzw,ld) * 0.5*(1.-sqrt(1.-min(0.01/(d*d),1.)));\n    vec4 tn2 = ray(p,ld);\n    if (tn2.x<1e4 || tn.x>1e4) col *= 0.;\n    #endif\n    \n    col = pow(max(1.-exp(-col),EPS),vec3(1./2.2));\n        \n    O = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 60, 101, 101, 170], [172, 172, 201, 201, 908], [910, 910, 951, 951, 1892]], "test": "untested"}
{"id": "7dK3D3", "name": " Branchless Voxel Raycasting Tex", "author": "jt", "description": "Fork of [url]https://www.shadertoy.com/view/4dX3zl[/url] Branchless Voxel Raycasting by fb39ca4 (with loop optimization by kzy),\nbased on the article [url]http://lodev.org/cgtutor/raycasting.html[/url].\nAdded 3d-texture on the voxels by recovering hitpos.", "tags": ["3d", "raytracing", "raycasting", "voxel", "fork", "dda", "textured"], "likes": 3, "viewed": 177, "published": "Public", "date": "1632346829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// fork of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// tags: 3d, raytracing, raycasting, voxel, dda, textured, fork\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n\treturn d < 0.0;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 cameraDir = vec3(0.0, 0.0, 0.8);\n    vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n    vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    vec3 rayPos = vec3(0.0, 0.0 * sin(iTime * 2.7), -12.0);\n\n    mat2 R = rotate(iTime / 5.0);\n    rayPos.xz = R * rayPos.xz;\n    rayDir.xz = R * rayDir.xz;\n    \n    rayDir = normalize(rayDir);\n\n    ivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n    vec3 color = vec3(1.0);\n    vec3 sideDist;\n    bvec3 mask;\n    // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    vec3 deltaDist;\n    {\n        deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        {\n            if (getVoxel(mapPos)) break; // forked shader used continue here\n\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n\n        color *= mask.x ? vec3(0.5) : mask.y ? vec3(1.0) : mask.z ? vec3(0.75) : vec3(0.0);\n    }\n\n    // jt's 3d-texture addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    //float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir); // rayDir not normalized\n    float d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized\n\n    vec3 dst = rayPos + rayDir * d;    \n    // simple 3d-texture as proof-of-concept\n    //color *= texture(iChannel0, dst).xyz;\n    color *= vec3(0.5 + 0.5 * checker(dst));\n\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n    color *= mix(fogcolor, color, exp(-d * d / 200.0)); // fog for depth impression & to suppress flickering\n    \n    //if(mask.x) color = texture(iChannel1, fract(dst.yz)).xyz; // try with video-texture :)\n    //if(mask.y) color = texture(iChannel2, fract(dst.xz)).xyz; // try with video-texture :)\n    //if(mask.z) color = texture(iChannel3, fract(dst.xy)).xyz; // try with video-texture :)\n\n\tfragColor.rgb = color;\n}\n", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3D3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 375, 398, 471, 615], [617, 617, 639, 639, 703], [705, 705, 738, 738, 767], [770, 770, 801, 801, 892], [894, 894, 918, 918, 1049], [1051, 1222, 1279, 1279, 3907]], "test": "untested"}
{"id": "7dK3DR", "name": "Trippy Morph ", "author": "xXx_T0SHIII_xXx", "description": "I thought this looked really neat. Playing with colors. If you have any suggestions to help make this better or make more sense in the coding then please lemme know! I've been having fun with this! :) \n\n", "tags": ["alien", "trippy", "weird", "coding", "wonky"], "likes": 2, "viewed": 51, "published": "Public", "date": "1631378757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float tiling = 15.;\n    float r = .5;\n    float rm = mix(.078,.5,sin(t*3.)*.5+.5); // mix(min,max,change amount)\n    \n    // Normalized pixel coordinates (from 0 to 1) with 0,0 moved to center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //make grid\n    vec2 gv = fract(uv*tiling)-.5;\n    \n    //make id for each tile on grid(?)\n    vec2 id = floor(uv*tiling);\n    \n    //Make Circles\n    float d = length(uv);\n    float d2 = length(gv);\n    float d3 = length (gv - id)*3.;\n    \n   \n     rm = mix(.078,.5,sin(t*d3/9.)*.5+.5); // mix(min,max,change amount)\n     \n    //Smooth/Animate Circles\n    float c = smoothstep(rm,rm*.9,d);\n    float c2 = smoothstep(rm,rm*.9,d2);\n    \n    \n    \n    //visualize here\n    vec3 col =vec3(c2);\n       col.r *= sin(t+d);\n       col.g *= cos(t+d3);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3DR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 954]], "test": "untested"}
{"id": "7dK3RG", "name": "Cute Flower Sam Lee", "author": "18smlee", "description": "cute flower", "tags": ["flower"], "likes": 0, "viewed": 17, "published": "Public", "date": "1631752958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\nfloat GetBias(float time, float bias)\n{\n  return (time / ((((1.0/bias) - 2.0)*(1.0 - time))+1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    vec2 center_to_uv = uv - center;\n    vec2 x_axis = vec2(1,0);\n    \n    float divs = 5.0;\n    float amp = 0.3;\n    float freq = 7.0;\n    \n    float theta = acos(dot(x_axis, center_to_uv) / length(center_to_uv) * length(x_axis));\n    \n    float bias = GetBias(cos(freq * theta), 0.1);\n       \n    float offset = radius * sin(iTime) * amp * bias;\n    \n    radius += offset;\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 113, 150, 150, 199], [201, 264, 325, 325, 429], [431, 491, 546, 546, 820], [822, 822, 861, 861, 922], [924, 924, 981, 981, 1702]], "test": "untested"}
{"id": "7dK3WD", "name": "Kleinian limit set", "author": "neozhaoliang", "description": "Another Kleinian limit set. A mix of the work https://www.shadertoy.com/view/ttdXDl and  https://www.shadertoy.com/view/Wl3fzM", "tags": ["2d", "fractal", "kleinian", "limitset"], "likes": 24, "viewed": 432, "published": "Public API", "date": "1631608166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L2(x)           dot(x, x)\n#define MAX_ITER        50\n\n\nbool doHalfPlane = true;\n\nconst vec2[] PARAMS = vec2[] (\n    vec2(1.8462756, 0.09627581),\n    vec2(1.958591, 0.011278),\n    vec2(1.857382, 0.076258),\n    vec2(1.64213876, 0.76658841),\n    vec2(1.658312, 0.5),\n    vec2(1.926434053, 0.027381792),\n    vec2(2, 0)\n);\n\nconst int NUM_PARAMS = PARAMS.length();\n\nfloat wrap(in float x, in float a, in float s) {\n    return mod(x - s, a) + s;\n}\n\nvec2 transA(in vec2 z, float a, float b, inout float scale) {\n    float k = 1. / dot(z, z);\n    z *= k;\n    scale *= k;\n    z.x -= b;\n    z.y = a - z.y;\n    return z;\n}\n\nbool separation(in vec2 z, in float a, in float b) {\n    float f = (z.x >= -b/2.0) ? 1.0 : -1.0;\n    float K = sign(b) * (2.0*a - 1.95) / 4.3;\n    float M = 7.2 - (1.95 - a) * 18.0;\n    return z.y >= 0.5*a + K*f*(1.0 - exp(-M*abs(z.x + b * 0.5)));\n}\n\nfloat kleinian(in vec2 z, vec2 pattern, float scale) {\n    float a = pattern.x, b = pattern.y;\n    float f = sign(b);\n    vec2 lz = z + vec2(1), llz = z - vec2(1);\n    for (int i = 0; i < MAX_ITER; i++) {\n        z.x = z.x + f * b / a * z.y;\n        z.x = wrap(z.x, 2.0, -1.0);\n        z.x = z.x - f * b / a * z.y;\n\n        if (separation(z, a, b)) {\n            z = vec2(-b, a) - z;\n        }\n\n        z = transA(z, a, b, scale);\n\t\t\n        // If the iterated points enters a 2-cycle, bail out.\n        if (dot(z-llz, z-llz) < 1e-6) {\n            return abs(z.y)  / scale;\n        }\n    \n       // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n        if (z.y < 0.0)\n            return -z.y/scale;\n        if (z.y > a)\n            return (z.y - a)/scale;\n\n        llz=lz; lz=z;\n    }\n    return 1e3;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    const float zoom = 3.;\n    \n    float time = mod(0.2*iTime, float(NUM_PARAMS));\n    int it = int(floor(time));\n    float ft = fract(time);\n    vec2 pattern = mix(PARAMS[it], PARAMS[(it+1) % NUM_PARAMS], smoothstep(0., 1., ft));\n    float scale = 1.2;\n    vec2 p = uv * 1.1;\n    \n    if (doHalfPlane) {\n        p.y += 1.0;\n        p *= 0.5*pattern.x;\n    }\n    else {\n        p -= vec2(0, -1);\n        float r2 = 2. / dot(p, p);\n        p *= r2;\n        scale *= r2;\n        p += vec2(0, -1);\n    }\n    float aa = 2. / iResolution.y;\n    \n    float d = zoom * kleinian(p, pattern, scale);\n    \n    float b = -0.125;\n    float t = 20.0;\n    const float lh = 1.25;\n    const vec3 lp1 = vec3(.5, .5, lh);\n    const vec3 lp2 = vec3(-0.5, .5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld1 = normalize(lp1 - pp);\n    vec3 ld2 = normalize(lp2 - pp);\n\n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd1 = normalize(lp1 - bp);\n    vec3  srd2 = normalize(lp2 - bp);\n    float bl21 = L2(lp1 - bp);\n    float bl22 = L2(lp2 - bp);\n\n    float st1 = (0.0-b)/srd1.z;\n    float st2 = (0.0-b)/srd2.z;\n    vec3  sp1 = bp + srd1*st1;\n    vec3  sp2 = bp + srd2*st1;\n\n    float bd = zoom * kleinian(bp.xy, pattern, scale);\n    float sd1= zoom * kleinian(sp1.xy, pattern, scale);\n    float sd2= zoom * kleinian(sp2.xy, pattern, scale);\n\n    vec3 col = vec3(0.0);\n    const float ss = 15.0;\n  \n    col       += vec3(1)  * (1.0 - exp(-ss*(max(sd1, 0.0)))) / bl21;\n    col       += vec3(.5) * (1.0 - exp(-ss*(max(sd2, 0.0)))) / bl22;\n    float l   = length(p);\n    float hue = fract(0.75*l-0.3*iTime) + .5;\n    float sat = tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    col       *= (1.0-tanh(0.25*l))*0.5;\n    col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = postprocess(col, fragCoord/iResolution.xy);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dK3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 416, 416, 448], [450, 450, 511, 511, 618], [620, 620, 672, 672, 869], [871, 871, 925, 925, 1689], [1692, 1692, 1714, 1714, 1885], [1887, 1887, 1923, 1923, 2162], [2165, 2165, 2222, 2222, 4337]], "test": "untested"}
{"id": "7dKGDt", "name": "Folded disc pseudo-SDF", "author": "dysangel", "description": "was playing around with the line segment shader and discovered this", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 1, "viewed": 32, "published": "Public", "date": "1632424691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h+sin(h)*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    //float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    float th = 0.5;\n    \n\tfloat d = udSegment( p, v1, v2 ) - th;\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = udSegment(m, v1, v2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGDt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1216, 1377, 1429, 1429, 1559], [1561, 1561, 1618, 1618, 2469]], "test": "untested"}
{"id": "7dKGRy", "name": "566 Lab 1 part 3", "author": "emma20", "description": "added a little center to the flower", "tags": ["circle"], "likes": 0, "viewed": 22, "published": "Public", "date": "1631758576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat easeInExpo(float x){\nif(x <= .001)\n{\nreturn x;\n}\nelse\n{\nreturn pow(2.5, 2.5 * x - 2.5);\n} \n}\nfloat deformAlongSin(in vec2 uv, in vec2 center){\n    vec2 newUV = normalize(uv - center);\n    float amp = 25.0 * cos(iTime);\n   \n    float res =  sin(atan(newUV.x, newUV.y) * 25.0) * amp;\n    return res;\n}\n\nfloat bias(float a, float t)\n{\n    return pow(t, log(a) / log(0.5));\n}\n\n\nfloat deformFlower(in vec2 uv, in vec2 center){\n    //vec2 newUV = rotatePoint2d(newUV, center, sin(iTime) * 5.0);\n    vec2 newUV = normalize(uv - center);\n    float amp = 25.0 * cos(iTime);\n    float res = sin(atan(newUV.x, newUV.y) * 10.0);\n   \n    res = (res + 1.0) / 2.0;\n    res = sqrt(res) * 3.0;\n    res = easeInExpo(res);\n    return res * amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n    // Deform Circle\n    //float deformRadius = deformAlongSin(uv, center);\n    float deformRadius = deformFlower(uv, center);\n    \n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n    vec3 black = rgb(0.0, 0.0, 50.0);\n    vec2 newUV = rotatePoint2d(uv, center, 30.f);\n\tvec4 layer2 = circle(uv, center, radius + deformRadius, red);\n\tvec4 layer3 = circle(uv, center, .05 * iResolution.y, black);\n\t// Blend the two\n\tvec4 testColor = mix(layer1, layer2, layer2.a);\n    fragColor = mix(testColor, layer3, layer3.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 112, 149, 149, 198], [200, 263, 324, 324, 428], [430, 490, 545, 545, 819], [820, 820, 867, 867, 961], [963, 963, 989, 989, 1061], [1062, 1062, 1111, 1111, 1268], [1270, 1270, 1300, 1300, 1340], [1343, 1343, 1390, 1457, 1696], [1698, 1698, 1755, 1755, 2452]], "test": "untested"}
{"id": "7dKGWK", "name": "Tunnely Torus Thingy", "author": "SnoopethDuckDuck", "description": "Super happy with this one, backgrounds a bit empty. code is sloppy and not much color variation but i like it ", "tags": ["raymarching", "template", "artofcode"], "likes": 8, "viewed": 198, "published": "Public API", "date": "1632235625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 350.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(1));\n    float r1 = min(20.,1.5 * iTime + 1.5);////iTime+ 0. + 0.1 * p.z, r2 = 0.3; //1.5\n    float r2 = 0.3;\n    vec2 cp = vec2(length(p.xy) - r1, p.z);\n    float a = atan(p.x,p.y);\n    cp.x = abs(cp.x) - 1.4 -4.* cos(0.8 * min(iTime,(30./4.) * 3.1415));\n    cp.x += cos(2. * a + 8. * iTime +  p.z) - 2.;\n    cp.y = 0.4;//cos(p.z + iTime) + sin(p.z - iTime);\n    cp *= Rot(9. * a + 1.4 *iTime );\n    cp.x = abs(cp.x)- 0.3 * abs(cp.y + min(1.8, 0.02 * p.z));// + 3.5 * cos(1.2 * p.z));\n    float td = length(cp)- r2;\n    td *= 0.5;\n    \n    float sd = sdSphere(p - vec3(2. * sin(1.8 * iTime),2. * cos(2. * iTime),-21. + 2. * iTime), 2.4 + 2. * sin(iTime));\n    //float bd = sdBox(p - vec3(0,0,-21.+2. * iTime), vec3(5.));\n    //d = min(td, p.z + 0.9 * iTime);\n    return min(sd,td);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    \n    float b1 = .5 + .5 * cos(iTime + (2./3.) * 3.1415);\n    float b2 = .5 + .5 * cos(iTime + (4./3.) * 3.1415);\n    float b3 = .5 + .5 * cos(iTime);\n    \n    float k = (b1 * rd.x + b2 * rd.y + b3 * rd.z) + .5;\n    //k = clamp(k,0.,1.);\n    vec3 col = mix(vec3(95,205,228)/255., vec3(0), k * (1.-k));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    float s = 2.;\n    vec3 ro = vec3(s * cos(1.2 * iTime),s * sin(1.2 * iTime), 1. + 2. * iTime);\n    //vec3 ro = vec3(0.,0.,1. + 2. * iTime);\n   //  vec3 ro = vec3(0,0, 1. + iTime + cos(iTime));\n   // ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0.), 1.);\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        float a = atan(r.z, r.y);\n        vec2 r2 = r.xy * Rot( iTime);\n        vec2 r3 = r.xy * Rot((iTime + (2./3.) * 3.1415));\n        vec2 r4 = r.xy * Rot((iTime + (4./3.) * 3.1415));\n        \n        float spec2 = pow(max(0., r2.x ),32.);\n        float spec3 = pow(max(0., r3.x ),32.);\n        float spec4 = pow(max(0., r4.x ),32.);\n        \n        float dif = dot(n, normalize(vec3(0,0,0)))*.5+.5;\n        col = mix(Bg(r), vec3(dif), 0.5);\n        col += spec2 + spec3 + spec4;\n        \n        //col +=0.2 *( 1.- 16. * col * col * (1.-col) * (1.-col));// + spec;\n    }\n    \n   // col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGWK.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1670, 1670, 1703, 1703, 1731], [1733, 1733, 1756, 1756, 2569], [2571, 2571, 2605, 2605, 2816], [2818, 2818, 2842, 2842, 3032], [3034, 3034, 3084, 3084, 3275], [3277, 3277, 3295, 3295, 3618], [3620, 3620, 3677, 3677, 4963]], "test": "untested"}
{"id": "7dKGzG", "name": "Trippy patterns", "author": "SnoopethDuckDuck", "description": "sloppy code", "tags": ["cool"], "likes": 6, "viewed": 181, "published": "Public API", "date": "1631753123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float myLength(vec2 uv, vec2 fragCoord) {\n//return length(mod(4. * (1.-uv) * uv,0.4));\nfloat x = cos(iResolution.x * abs(uv.x) + 0.2 * iTime);\nfloat y = sin(abs(uv.y) + x - 0.5 * iTime);\nfloat b = 0.5 * (1. + cos(0.3 * iTime));\nfloat b2 = 0.5 * (1. + cos(0.15 * iTime));\nreturn mod(x + y, (1.-b) * x * y + b * 0.4 * length(uv)) * ( b2 + (1.-b2)* 0.5 * (0.2 + sin(2. * uv.x * uv.y + iTime)));\n//return mod(x * y, abs(x * x - y * y) + 10.);// * length(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6. * (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    float theta = atan(uv.y, uv.x);\n    float k = 0.5 * (1. + cos(0.25 * t));\n    float s = 0.5 * (1. + cos(t));\n    //s = 1. - 4. * s * (1.-s);\n    s = (1.-k) * s + k * (1.-s);\n\n    float d = myLength(uv, fragCoord);\n    float p = 0.2;//0.5 * 3.14159;\n    float a = 0.2;\n    \n    float r = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float r2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    t -= a;\n    float g = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float g2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    t += 2. * a;\n    float b = 0.4 + 0.1 * (s * cos(3. * theta + t) + (1.-s) * sin(7. * theta + t));    \n    float b2 =  0.43 + 0.1 * (s * cos(3. * theta + t + p) + (1.-s) * sin(7. * theta + t + p));\n    \n    \n    \n    r = 1.- smoothstep(d, r2, r);\n    g = 1.- smoothstep(d, g2, g);\n    b = 1.- smoothstep(d, b2, b);\n    r = 16. * r * r * (1.-r) * (1.-r);\n    g = 16. * g * g * (1.-g) * (1.-g);\n    b = 16. * b * b * (1.-b) * (1.-b);\n    \n    float c1 = 0.5 * (1. + cos(t));\n    float c2 = 0.5 * (1. + cos(t + 3.14159 / 3.));\n    float c3 = 0.5 * (1. + cos(t - 3.14159 / 3.));\n    \n\n    fragColor = vec4(g + c1 * r,r + c2 * b,b + c3 * g,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 86, 456], [459, 459, 516, 516, 1960]], "test": "untested"}
{"id": "7dKGzK", "name": "Animation and Layers NT1", "author": "yogo503", "description": "For Class", "tags": ["idk"], "likes": 0, "viewed": 29, "published": "Public", "date": "1632159360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 number1 (vec2 uv)\n{\n    float FREQUENCY = 5.0;\n    float AMPLITUDE = .3;\n    vec2 circlePos = vec2(0.5,0.25);\n    float radius = 0.15;\n    vec4 FG = vec4(0,0,1,1.0);\n    vec4 BG = vec4(0,1,0,1.0);\n    vec4 returnValue;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio;\n    circlePos.y = circlePos.y * aspectRatio + ((sin(iTime * FREQUENCY)+1.0)/2.0) * AMPLITUDE;\n    float dist = distance(circlePos,uv);\n    float isOutOfCircle = smoothstep(radius-.002,radius+.002,dist);\n    vec4 col = mix(FG,BG,isOutOfCircle);\n    returnValue = vec4(col);\n    return returnValue;\n}\n\nvec4 number2 (vec2 uv)\n{\n    const float FREQUENCY = 2.5;\n    const float AMPLITUDE = .5;\n    vec2 circlePos = vec2(0.5,0.5);\n    float radius = 0.15;\n    vec4 FG = vec4(0,0,1,1.0) + ((sin(iTime * FREQUENCY)+1.0)/2.0) * AMPLITUDE;\n    vec4 BG = vec4(0,1,0,1.0);\n    vec4 returnValue;\n    float aspectRatio = iResolution.y / iResolution.x;\n    uv.y *= aspectRatio;\n    circlePos.y *= aspectRatio;\n    float dist = distance(circlePos,uv);\n    float isOutOfCircle = smoothstep(radius-.002,radius+.002,dist);\n    vec4 col = mix(FG,BG,isOutOfCircle);\n    returnValue = vec4(col);\n    return returnValue;\n}\n\nvec4 number3(vec2 uv)\n{\n    uv.y *= iResolution.y/iResolution.x;\n    vec2 location1 = vec2(.5,.3);\n    vec2 location2 = vec2(.45,.25);\n    vec2 location3 = vec2(.55,.35);\n    float radius = .1;\n    vec3 bigColor = vec3(0);\n    vec3 color1 = vec3(1,0,0);\n    vec3 color2 = vec3(0,1,0);\n    vec3 color3 = vec3(0,0,2);\n    \n    vec4 layer1 = vec4(bigColor,1.0);\n    vec4 layer2 = vec4(color1,0.0);\n    vec4 layer3 = vec4(color2,0.0);\n    vec4 layer4 = vec4(color3,0.0);\n    \n    if(length(location1-uv) < radius)\n        layer2.a=1.0;\n    if(length(location2-uv) < radius)\n        layer3.a=.475;\n    if(length(location3-uv) < radius)\n        layer4.a=.475;\n    \n    vec4 composite = mix(layer1,layer2,layer2.a);\n    composite = mix(composite,layer3,layer3.a);\n    composite = mix(composite,layer4,layer4.a);\n    return composite;\n}\n\nvec4 number4(vec2 uv)\n{\n    const float FREQUENCY =2.0;\n    const float AMPLITUDE = 1.0;\n    vec4 image1 = texture(iChannel0,uv);\n    vec4 image2 = texture(iChannel1,uv);\n    float change = ((sin(iTime * FREQUENCY)+1.0)/2.0) * AMPLITUDE;\n    vec4 screen = mix(image1,image2,change);\n    return screen;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = number1(uv);\n    //fragColor = number2(uv);\n    //fragColor = number3(uv);\n    //fragColor = number4(uv);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 602], [604, 604, 628, 628, 1204], [1206, 1206, 1229, 1229, 2034], [2036, 2036, 2059, 2059, 2339], [2341, 2341, 2398, 2398, 2567]], "test": "untested"}
{"id": "7dKGzz", "name": "fbm-cloud", "author": "MarkarovZ", "description": "from https://thebookofshaders.com/13/?lan=ch", "tags": ["2d"], "likes": 5, "viewed": 94, "published": "Public", "date": "1631014070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(in vec2 _st)\n{\n    return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(in vec2 _st)\n{\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0,0.0));\n    float c = random(i + vec2(0.0,1.0));\n    float d = random(i + vec2(1.0,1.0));\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a,b,u.x)+(c - a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\n\n#define NUM_OCTAVES 5\nfloat fbm(in vec2 _st)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5),sin(0.5),-sin(0.5),cos(0.5));\n    for(int i = 0;i<NUM_OCTAVES;++i)\n    {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy*3.0;\n    vec3 color = vec3(0.0);\n    \n    vec2 q = vec2(0.);\n    q.x = fbm(st + 0.00*iTime);\n    q.y = fbm(st + vec2(1.0));\n    \n    vec2 r = vec2(0.);\n    r.x = fbm(st + 1.0*q + vec2(1.7,9.2)+0.15*iTime);\n    r.y = fbm(st + 1.0*q + vec2(8.3,2.8)+0.126*iTime);\n    \n    float f = fbm(st + r);\n    \n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.666667,0.666667,0.498039),\n                clamp((f*f)*4.0,0.0,1.0));\n                \n    color = mix(color,\n                vec3(0,0,0.164706),\n                clamp(length(q),0.0,1.0));\n         \n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n              \n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 100], [102, 102, 128, 128, 437], [461, 461, 485, 485, 763], [766, 766, 823, 823, 1607]], "test": "untested"}
{"id": "7dt3Rl", "name": "Ray Marching Test Part 2", "author": "dcyang", "description": "ray marching test ", "tags": ["raymarching"], "likes": 1, "viewed": 111, "published": "Public API", "date": "1630509649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.0;\n}\n\n/* 场景的SDF，目前只是一个球 */\nfloat sceneSDF(vec3 samplePoint){\n    return sphereSDF(samplePoint);\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP && depth < end;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceFromEyeToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * dir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 10.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 136, 170, 170, 210], [212, 255, 288, 288, 325], [327, 418, 510, 510, 762], [763, 848, 913, 913, 1045], [1047, 1142, 1171, 1171, 1481], [1482, 1580, 1672, 1672, 1964], [1965, 2059, 2135, 2135, 2357], [2358, 2358, 2415, 2415, 2966]], "test": "untested"}
{"id": "7dtGW2", "name": "Fractunnel v2", "author": "dirkadirkadan", "description": "Go deep. Full screen.", "tags": ["fractal", "tunnel"], "likes": 3, "viewed": 75, "published": "Public", "date": "1630686230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float eps = 0.001;\nvec2 eps2 = vec2(eps);\n\nvec3 color(vec2 p) {\n    float x = atan(p.y,p.x)/4.-.57;\n    float y = mod(iTime*.2+.5/sqrt(length(p))-1.2, 1.);\n\n    float bail=100.;\n    vec2 a = vec2(x,y);\n    vec3 col = vec3(0.);\n    for (int i=0; i < 75; i++)\n    {\n        a += vec2(a.x*a.x-a.y*a.y,a.x*a.y*2.)+vec2(.123, .134);\n        float af = clamp(0., 1., length(a));\n        vec2 ac = normalize(a);\n        col = 1.*vec3(.55*ac.x+0.2*ac.y+0.3*p.x, .47*ac.y, af);\n        col += vec3(1.-length(p));\n        col = mix(vec3(1.), sqrt(col), length(p)*3.);\n        if (length(a) > bail)\n        {\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 col = (color(p) + \n                color(p+eps2))/2.;\n                \n    col = pow(col-.0, vec3(8.));\n                \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 69, 69, 661], [663, 663, 720, 720, 945]], "test": "untested"}
{"id": "7dtGWB", "name": "RZ Basics of Fragment Shaders", "author": "raymondzheng", "description": "GRP-200 first assignment", "tags": ["grp200"], "likes": 2, "viewed": 22, "published": "Public", "date": "1631143401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Create a Gradient that moves vertically.\nvec3 questionOne(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(.1, uv.y, .5);\n    return col;\n}\n// Create a split-screen of four quadrants. Choose any 4 colors.\nvec3 questionTwo(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0,1,0);\n    if (uv.x > .5) {\n        col = vec3(1,0,0);\n    }\n    if (uv.y > .5) {\n        col = vec3(0,0,1);\n    }\n    if (uv.y > .5 && uv.x > .5) {\n        col = vec3(1,1,0);\n    }\n    return col;\n}\n\nfloat magnitudeCalc(vec3 color) {\n    return sqrt(pow(color.x, 2.0) + pow(color.y, 2.0) + pow(color.z, 2.0));\n}\n// Create a \"heat\" finder. Basically, if the magnitude/brightness of any color is greater than X then turn it red. \n// X should be a variable. By default, set it to 0.5.\nvec3 questionThree(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0, uv.x, uv.x);\n    float X = 0.5;\n    if (magnitudeCalc(color) >= X) {\n      color = vec3(1,0,0);\n    }\n    return color;\n}\n// Bonus: Create a striped pattern of any two colors. The colors should be variable.\nvec3 questionFour(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    // Random color code from Shadertoy example.\n    vec3 randColOne = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 randColTwo = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(4,2,0));\n    vec3 col = randColOne;\n    if (int(uv.x * float(10)) % 2 == 1) {\n        col = randColTwo;\n    } else {\n        col = randColOne;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3(0,0,0);\n\n    // Output to screen\n\n    //col = questionOne(fragCoord);\n    //col = questionTwo(fragCoord);\n    //col = questionThree(fragCoord);\n    col = questionFour(fragCoord);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 78, 78, 171], [172, 237, 271, 271, 532], [534, 534, 567, 567, 645], [646, 816, 852, 852, 1039], [1040, 1125, 1160, 1160, 1533], [1535, 1535, 1592, 1592, 1826]], "test": "untested"}
{"id": "7dtXz4", "name": "ninofiliu/worley-noise-3d", "author": "ninofiliu", "description": "2D slicing of a 3D Worley noise", "tags": ["noise"], "likes": 1, "viewed": 32, "published": "Public", "date": "1632782026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand1(in float x) {\n    return fract(158789.0*sin(x));\n}\n\nfloat worley_3d(vec3 current, vec3 sizes, int nb_x, int nb_y, int nb_z) {    \n    float min_dist = sizes.x+sizes.y+sizes.z;\n    int current_xi = int(current.x/sizes.x);\n    int current_yi = int(current.y/sizes.y);\n    int current_zi = int(current.z/sizes.z);\n    \n    for (int xi = current_xi-1; xi < current_xi+2; xi++) {\n    for (int yi = current_yi-1; yi < current_yi+2; yi++) {\n    for (int zi = current_zi-1; zi < current_zi+2; zi++) {\n        vec3 point = vec3(\n            sizes.x/float(nb_x)*(float(xi)+rand1(float(xi+yi+zi))),\n            sizes.y/float(nb_y)*(float(yi)+rand1(0.789*float(xi+yi+zi))),\n            sizes.z/float(nb_z)*(float(zi)+rand1(0.456*float(xi+yi+zi)))\n        );\n        float dist = distance(current, point);\n        if (dist < min_dist) {\n            min_dist = dist;\n        }\n    }\n    }\n    }\n    \n    return min_dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float depth = min(iResolution.x, iResolution.y);\n    vec3 current = vec3(fragCoord.x, fragCoord.y, depth*mod(iTime*0.2, 1.0));\n    vec3 sizes = vec3(iResolution.x, iResolution.y, depth);\n    float w = worley_3d(current, sizes, 5, 5, 5);\n    float light = atan(w/depth)/1.58;\n    fragColor = vec4(vec3(light), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 62], [64, 64, 137, 137, 920], [922, 922, 977, 977, 1298]], "test": "untested"}
{"id": "7dV3Dy", "name": "Twisty Torus Dudes", "author": "SnoopethDuckDuck", "description": "Following along with the art of code's torus video and made this, the colors are a bit off but I like it", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 124, "published": "Public API", "date": "1632157748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat myAbs(float k) {\n    return (1. - exp2(-4. * abs(k))) * abs(k);\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n   \n    float a =atan(p.x,p.z);\n   // p.xz *= Rot(3.1415 * cos(a + iTime));\n    p.x += 0.5 * cos(3. * a + 0.7 * iTime + myAbs(p.y) - 0.4);\n    p.z += 0.5 * sin(1.*a + iTime + myAbs(p.y) - 0.4);\n    //p.z += 0.5 * sin(2. * a + iTime);\n    p.y *= 0.;// + 0.01 * Hash21(100. * p.xz);\n    float d = myAbs(p.x) + myAbs(p.y) +  myAbs(p.z) - r;\n    return 0.35 * d;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sharpFunc(float x) {\n    return 1.-abs(cos(x));\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.;\n    float r2 = 0.08;\n    vec2 cp = vec2(length(p.xz) - r1, p.y);\n    float a = atan(p.x,p.z);\n    cp *= Rot(1.5 * a);\n    cp.x = abs(cp.x) - 0.4 - 0.4 * abs(cp.y);\n    cp.y = abs(cp.y) - 0.4 ;\n    vec3 e = vec3(1. + cos(10. * a + 4. * iTime), 0., 1. + sin(10. * a + 4. * iTime));\n  //  float d = length(cp) + .05 * smoothstep(0.,-1.,cos(10. * a + 4. * iTime)) *length(p + e) - r2;\n    float td = length(cp) + \n              .5 * sharpFunc(.5 * a + 3.1415 * cos(0.5 * a + iTime)) * length( p ) \n              - r2;\n    td *= 0.5;\n    //float bd = sdBox(p - vec3(0), vec3(0.5));\n    float sd = sdSphere(p, 0.8); //1.2\n    return min(td,sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y * .5 + .5;\n    float b1 = .5 + .5 * cos(iTime + (2./3.) * 3.1415);\n    float b2 = .5 + .5 * cos(iTime + (4./3.) * 3.1415);\n    float b3 = .5 + .5 * cos(iTime);\n    \n    \n    vec3 col = mix(vec3(b1,b2,b3), vec3(0.01 * Hash21(rd.xz)), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float t = -0.2 * iTime;\n    vec3 ro = vec3(5. * cos(t), 6. * cos(0.6 * iTime), 5. * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n     col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float spec = pow(max(0., r.y), 24.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(Bg(r), vec3(dif), 0.5);\n        col = 1.- 16. * col * col * (1.-col) * (1.-col) + spec;\n       // col = vec3(spec);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3Dy.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1580, 1580, 1674], [1676, 1676, 1698, 1698, 1747], [1750, 1750, 1783, 1783, 2144], [2146, 2146, 2175, 2175, 2256], [2258, 2258, 2284, 2284, 2313], [2315, 2315, 2338, 2338, 2998], [3000, 3000, 3034, 3034, 3245], [3247, 3247, 3271, 3271, 3461], [3463, 3463, 3513, 3513, 3704], [3706, 3706, 3724, 3724, 3998], [4000, 4000, 4057, 4057, 4918]], "test": "untested"}
{"id": "7dV3W3", "name": "Lava Lamp :)", "author": "SpencerKuan", "description": "A simple shader with mostly PBR lighting. ", "tags": ["raymarching", "pbr"], "likes": 6, "viewed": 84, "published": "Public API", "date": "1632343202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\nI originally created this on Khan Academy :)\n\n\n\n*/\n\n\n\n\nprecision lowp float;\nconst vec2 u_res = vec2(1280, 720);\n\n/* uncomment for anti-aliasing: */\n//#define MULTIPASS; \n\n#define pi 3.1415926\n\n//point-light source structure\nstruct Light {\n    vec3 o;\n    vec3 col;\n};\n\n//light ray structure\nstruct lightR {\n    vec3 col;\n    vec3 dir;\n};\n\n//material structure\nstruct material {\n    vec3 albedo;\n    float rough;\n    float metal;\n};\n\n//lights array\nLight lights[4];\n\n//sdBox, sdCone, and smin by Inigo Quilez\nfloat sdBox( vec3 p, vec3 b ) \n{ \n    vec3 q = abs(p) - b; \n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); \n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n\n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat blob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 30.0;\n    float s = clamp((h + 50.0) / 50.0, 0.5, 1.0);\n    return length(p + vec3(i.x, h, i.y)) - i.w * s;\n}\n\n/*float Bblob(vec3 p, vec4 i, float t)\n{\n    float h = sin(t + i.z) * 150.0;\n    return length(p + vec3(i.x, h - 20.0, i.y)) - i.w;\n}*/\n\n\n//transparent signed dist func\nfloat tsdf(vec3 p)\n{\n    float shape = max(sdCone(p+vec3(0,-180,0),vec2(sin(.09),cos(.09)),188.0), p.y - 70.0);\n\n    float d = max(shape, p.y - 49.3);\n\n    return d;\n}\n\n\n//main signed dist function\nfloat sdf(vec3 p)\n{\n\n    //time\n    float t = iTime * 0.2;\n\n    //floor\n    float d = p.y + 80.0;\n\n    //pedestal\n    d = min(d, sdBox(p+vec3(0,70,0),vec3(40,10,40)));\n\n    //walls\n    d = min(d, -sdBox(p, vec3(200)));\n\n    //translated blob position\n    vec3 mp = p + vec3(0, -20, 0);\n\n    //lamp components\n    float top = max(sdCone(p+vec3(0,-90,0),vec2(sin(.3),cos(.3)),40.), p.y - 70.0);\n    float bottom = max(sdCone(-p+vec3(0,-49,0),vec2(sin(.4),cos(.4)),40.), -p.y - 50.);\n    float base = sdCone(p+vec3(0,20,0),vec2(sin(.4),cos(.4)),40.);\n\n    //adding the lamp pieces\n    d = min(d, top);\n    d = min(d, bottom);\n    d = min(d, base);\n\n    //lava blobs\n    float b = d;\n\n    b = smin(b, blob(mp, vec4(-6,5,1,5), t), 10.);\n    b = smin(b, blob(mp, vec4(-3,0,2.3,5), t), 10.);\n    b = smin(b, blob(mp, vec4(0,8,3,2), t), 10.);\n    b = smin(b, blob(mp, vec4(0,7,4,2), t), 10.);\n    b = smin(b, blob(mp, vec4(-8,-4,5,3), t), 10.);\n    b = smin(b, blob(mp, vec4(7,0,6,3), t), 10.);\n    b = smin(b, blob(mp, vec4(2,2,7,4), t), 10.);\n\n    //constrain blobs to the container\n    float container = tsdf(vec3(p.xz, clamp(p.y, -3.0, 44.0)).xzy);\n    b = max(b, container + 2.0);\n    b = max(b, p.y - 50.0);\n    b = max(b, -p.y - 10.0);\n\n    d = min(d, b);\n\n    return d;\n}\n\nmaterial getMaterial(vec3 p)\n{\n\n    //walls\n    if(max(abs(p.x), abs(p.z)) > 199.0){\n        return material(\n            vec3(1),\n            0.1,\n            0.0\n        );\n    }\n\n    if(max(abs(p.x), abs(p.z)) < 50.0)\n    {\n        //blob stuff\n        if( p.y > -11.0 && p.y < 49.9 && length(p.xz) < 16.0)\n        {\n            return material(\n                vec3(0.4, 0.1, 0.4),\n                0.1,\n                0.0\n            );\n        }\n\n        //shiny lamp metal\n        if( p.y > -59.5 && p.y < 80.0)\n        {\n            return material(\n                vec3(0.2),\n                0.2,\n                1.0\n            );\n        }\n    }\n\n    return material(\n        vec3(0.1, 0.4, 0.5),\n        1.0,\n        0.0\n    );\n\n}\n\n//normal calculation\nvec3 getNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = sdf(pos);\n    return normalize(vec3(\n        sdf(pos + vec3(h, 0, 0)) - dist1,\n        sdf(pos + vec3(0, h, 0)) - dist1,\n        sdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//glass normal calculation\nvec3 getGlassNormal(vec3 pos)\n{\n\n    //epsilon value\n    float h = 0.1;\n\n    float dist1 = tsdf(pos);\n    return normalize(vec3(\n        tsdf(pos + vec3(h, 0, 0)) - dist1,\n        tsdf(pos + vec3(0, h, 0)) - dist1,\n        tsdf(pos + vec3(0, 0, h)) - dist1\n    ));\n}\n\n//create a ray for a given screen position\nvec3 createRay(vec2 pos)\n{\n    return normalize(vec3(pos, 200.0));\n}\n\n//raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 70;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = sdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat glassmarch(vec3 ro, vec3 rd, out bool hit)\n{\n    const int MAX_STEPS = 20;\n    const float epsilon = 0.5;\n\n    hit = false;\n    float totalDist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i ++){\n        float d = tsdf(ro + rd * totalDist);\n        if(abs(d) < epsilon){\n            hit = true;\n            break;\n        }\n        totalDist += d;\n    }\n    return totalDist;\n}\n\nfloat shadowmarch(vec3 rc, vec3 ld, float md)\n{\n    const int MAX_STEPS = 50;\n    const float step = 0.1;\n\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        float s = sdf(rc + ld * t);\n        if(t > md) return 1.0;\n        if(s < 0.0) return 0.0;\n        t += max(step, s);\n    }\n\n    return 1.0;\n}\n\n//normal distribution function\nfloat NDF(vec3 h, vec3 n, float a)\n{\n    float a2 = a * a;\n    float dotHN = dot(h, n);\n    float x = dotHN * dotHN * (a2 - 1.0) + 1.0;\n\n    return a2 / (pi * x * x);\n}\n\n//geometry function\nfloat GF(vec3 v, vec3 n, float a)\n{\n    float dotNV = max(dot(n, -v), 0.0);\n    float a2 = a * a;\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n\n    return dotNV / (dotNV * (1.0 - k) + k);\n}\n\n//fresnel function\nvec3 FF(vec3 v, vec3 n, vec3 f0)\n{\n    float x = clamp(1.0 - dot(v, n), 0.0, 1.0);\n    return f0 + (1.0 - f0) * pow(x, 5.0);\n}\n\n//calculate contribution of individual light\nvec3 calcLight (material c, vec3 n, vec3 rd, lightR lr)\n{\n\n    vec3 dir = lr.dir;\n    vec3 l = lr.col;\n\n    //material values\n    vec3 a = c.albedo;\n    float rough = c.rough;\n    float metal = c.metal;\n\n    //halfway vector\n    vec3 h = normalize(rd + dir);\n\n    vec3 f0 = mix(vec3(0.01), a, metal);\n\n    //normal distribution\n    float nd = NDF(dir, n, rough);\n\n    //geometry occulsion\n    float g = GF(dir, n, rough)*GF(rd, n, rough);\n\n    //fresnel\n    vec3 f = FF(-rd, n, f0);\n\n    //some dot products\n    float dotDN = max(dot(-dir, n), 0.0);\n    float dotRN = max(dot(-rd, n), 0.0);\n\n    //specular denominator\n    float specDenom = 2.0 * dotDN * dotRN + .0001;\n    vec3 spec = g * nd * f / specDenom;\n\n    //diffuse contribution\n    vec3 kd = (vec3(1) - f) * (1.0 - metal);\n\n    vec3 fin = ((kd * a / pi) + spec) * l * dotDN;\n    return fin;\n}\n\n//calculate contribution of all lights\nvec3 doLighting(material c, vec3 n, vec3 rc, vec3 rd, bool doShadow)\n{\n    vec3 fCol = vec3(0.0);\n\n    const int len = 4;\n    for(int i = 0; i < 4; i++)\n    {\n        //get the light\n        Light light = lights[i];\n\n        //find light ray direction\n        vec3 dir = normalize(rc - light.o);\n\n        //light radius\n        float r = length(rc - light.o);\n\n        //light brightness (attenuation)\n        float b = 1.0 / r;\n\n        //resulting light ray color\n        vec3 l = light.col * b;\n\n        //light ray\n        lightR lr = lightR(l, dir);\n\n        //shadows\n        float s = doShadow ? shadowmarch(rc, -dir, r) : 1.0;\n\n        //final light contribution\n        vec3 fin = calcLight(c, n, rd, lr) * s;\n\n        fCol += fin;\n    }\n\n    //ambient light\n    fCol += c.albedo * (1.0 - c.metal) * 0.1;\n\n\n    //global directional lighting \n    //const vec3 sCol = vec3(0.1);\n    //const vec3 sDir = normalize(vec3(1, -5, 0));\n    //float s = shadowmarch(rc, -sDir);\n    //fCol += calcLight(c, n, rd, lightR(sCol, sDir))*s;\n\n    //fog\n    float fog = exp(-length(rc) * 0.01);\n\n    return fCol * fog;\n}\n\n//create a matrix\nmat3 yMat(float a){\n    return mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 xMat(float a){\n    return mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nvec4 shadeP (float t, vec3 cam, mat3 rot, vec2 unit)\n{\n    //ray initial values\n    vec3 ro = rot * cam;\n    vec3 rd = rot * createRay(unit);\n\n    //raymarch the ray\n    bool hit;\n    float d = raymarch(ro, rd, hit);\n\n\n    //fragment color\n    vec3 col = vec3(0);\n\n    if(!hit){\n        return vec4(col, 1);\n    }\n\n    //find ray collision\n    vec3 rc = ro + rd * d;\n\n    //find collision normal\n    vec3 normal = getNormal(rc);\n\n    //find material\n    material c = getMaterial(rc);\n\n    //raymarch the glass\n    bool glass;\n\n    const material glassMat = material(vec3(1), 0.4, 1.0);\n    const vec3 glassTint = vec3(2, 1, 2);\n\n    float gd = glassmarch(ro, rd, glass);\n    vec3 gc = gd * rd + ro;\n    bool glassVis = gd < d || !hit;\n\n    //shade material\n    col = doLighting(c, normal, rc, rd, true);\n\n    //glass shading\n    if(glass && glassVis)\n    {\n        col *= glassTint;\n        col += doLighting(glassMat, getGlassNormal(gc), gc, rd, false) * 0.1;\n\n\n    }\n\n    //cheap HDR\n    col = col / (col + 1.0);\n\n    //gamma correction\n    col = pow(col, vec3(1.0 / 2.2));\n\n    return vec4(col, 1);\n}       \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set the light positions\n    lights[0] = Light(\n        vec3(80, 10, 100), vec3(200, 100, 100)\n    );\n\n    lights[1] = Light(\n        vec3(120, 80, -130), vec3(250, 250, 500)\n    );\n\n    lights[2] = Light(\n        vec3(-50, 120, 120), vec3(300)\n    );\n\n    lights[3] = Light(\n        vec3(-90, 110, -80), vec3(100, 200, 100)\n    );\n\n    //time increment\n    float t = mod(iTime * 0.4, 2.0 * pi);\n\n    //create rotation matrix\n    mat3 rot = yMat(t) * xMat(sin(t)*.1-0.4);\n\n    //find the screen scale\n    float scale = 2.0 / min(iResolution.x, iResolution.y);\n\n    //create clip-space-ish coordinates\n    vec2 clip = (fragCoord.xy - iResolution.xy / 2.0)*scale;\n\n    //translate clip space into unit space\n    vec2 unit = clip * 100.0;\n\n    //camera position\n    const vec3 cam = vec3(10, -10, -199);\n\n\n    # ifdef MULTIPASS\n        fragColor = (\n            shadeP(t, cam, rot, unit) + \n            shadeP(t, cam, rot, unit + vec2(0.25))\n        ) * 0.5;\n\n    # else\n        fragColor = shadeP(t, cam, rot, unit);\n\n    # endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3W3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 514, 546, 546, 638], [640, 640, 679, 679, 763], [765, 765, 804, 938, 1269], [1271, 1271, 1308, 1308, 1447], [1587, 1618, 1638, 1638, 1785], [1788, 1816, 1835, 1847, 3087], [3089, 3089, 3119, 3132, 3831], [3833, 3854, 3880, 3901, 4111], [4113, 4140, 4171, 4192, 4406], [4408, 4451, 4477, 4477, 4519], [4521, 4540, 4588, 4588, 4916], [4918, 4918, 4968, 4968, 5297], [5299, 5299, 5346, 5346, 5615], [5617, 5648, 5684, 5684, 5816], [5818, 5838, 5873, 5873, 6025], [6027, 6046, 6080, 6080, 6172], [6174, 6219, 6276, 6276, 7071], [7073, 7112, 7182, 7182, 8223], [8225, 8243, 8262, 8262, 8329], [8331, 8331, 8350, 8350, 8417], [8419, 8419, 8473, 8498, 9522], [9532, 9532, 9589, 9620, 10625]], "test": "untested"}
{"id": "7dV3Wc", "name": "14/49", "author": "tono", "description": "Continued from 7/49", "tags": ["49"], "likes": 3, "viewed": 60, "published": "Public", "date": "1632354303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n    u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 op = p;\n    //o = length(p) - 3.;\n    o = p.y + 4.;\n    o -= noise(p/5. + iTime/13.) * 2.1;\n    // o = max(length(p)-2.8,o);\n    \n    if(o < 1.)\n    {\n    \to -= fbm(p*2. + iTime)/1.3;\n    }\n    // float l = \n    // o = min(o,l);\n    o*=.4;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec3 render(vec3 cp , vec3 rd,vec3 l,vec3 bg)\n{\n    float depth = 0.;\n    vec3 col = vec3(0.);\n    float trans = 1.;\n    float totaldens = 0.;\n    float diff = 0.;\n    float emit = 0.;\n    vec3 p = cp;\n    float t = iTime/2.;\n    float tt = fbm(iTime * 12. * vec3(1.));\n    for(int i = 0 ; i< 30 ; i++)\n    {\n        vec2 d = map(p);\n        p += rd * 0.03;\n   \t\tfloat dens = 1. - smoothstep(0.,.3,d.x);\n        totaldens += dens;\n        trans *= dens;\n        if(totaldens > 1. && diff <= 0.)\n        {\n            totaldens = 0.;\n            //表面から遠いほど内側\n            diff = clamp(1.-map(p).x,0.,1.);\n            emit = pow( smoothstep(0.1,.0,map(p).x) ,10.);\n            col += step(0.7,tt)*clamp(noise(p + t)-.5,0.,1.) * vec3(.0,.3,.7) * 3.;\n        }\n        depth += d.x;\n    }\n    trans = (1. - pow(totaldens/30.,10.5));\n    trans = smoothstep(0.,1.,trans);\n    emit = mix(emit*trans,1.,.2);\n    col = col + vec3(.5);\n    col = mix(col,bg,pow(trans,1.25) );\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-9.);\n    vec3 target = vec3(0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    fov = 2.5-dot(p,p)/2.;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    vec3 lightning = vec3(1.,1.,0.);\n    \n    p.x += ( fbm(vec3(p.xxy + iTime)*2.)-.5);\n    float th = sin(p.x * 10.) * step(fract(iTime*100. + p.x * 10.)-.5,.1);\n    th *= step(0.9,clamp(noise(iTime*3. + p.xxx*24.),0.,1.));\n    th *= step(p.y,.8-abs(sin(iTime+p.x*13.))*.8);\n    lightning *= clamp(th-.99,0.,1.) * 100.;\n    col += lightning;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(map(pos).x - vec3(map(pos - e.xyy).x , map(pos - e.yxy).x,map(pos - e.yyx).x));\n        //col = N;\n        vec3 sun = normalize(vec3(1.,-1.,.3));\n        col += render(pos,rd,sun,vec3(0.));\n        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [62, 62, 82, 82, 177], [178, 178, 199, 199, 779], [781, 781, 800, 800, 960], [962, 962, 980, 980, 1292], [1294, 1294, 1325, 1325, 1592], [1594, 1594, 1641, 1641, 2597], [2599, 2599, 2656, 2656, 3822]], "test": "untested"}
{"id": "7dV3WD", "name": "doctor pimple popper", "author": "supah", "description": "Pimple popper", "tags": ["sin", "pimple", "popper"], "likes": 1, "viewed": 42, "published": "Public", "date": "1631604935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    float d = sin(2. * iTime - length(uv) * 15.);\n    d = smoothstep(.2, .2, d * length(sin(uv * 40.) * .45));\n    fragColor = vec4(vec3(d),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2543, 2543, 2600, 2600, 2811]], "test": "untested"}
{"id": "7dV3zV", "name": "Desert mountains", "author": "jarble", "description": "A simple desert terrain based on Karang's \"Desert biome\" shader.", "tags": ["procedural", "planet", "mountain", "desert", "biome"], "likes": 8, "viewed": 204, "published": "Public API", "date": "1631819277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    float f2 = .1; //this constant changes the variation in mountain height\n    \n    float f1 = f2;\n    float f3 = 1.-f1;\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        uv += vec2(amplitude,freq);\n        n1 = abs(noise((uv) * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 2.1-amplitude;\n        amplitude *= .45;\n        \n        \n        float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx;\n        uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    \n    return -value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dV3zV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 423], [425, 425, 464, 570, 1461], [1464, 1464, 1495, 1495, 1757], [1759, 1823, 1868, 1868, 2154], [2156, 2156, 2194, 2194, 2449], [2451, 2451, 2518, 2518, 2745], [2747, 2747, 2778, 2778, 4195], [4263, 4263, 4320, 4320, 5122]], "test": "untested"}
{"id": "7dVGDc", "name": "Real Projective Triangle Tiling", "author": "stevejtrettel", "description": "A tiling of a convex domain in real projective space, as a deformation of a hyperbolic triangle group", "tags": ["tiling"], "likes": 3, "viewed": 92, "published": "Public", "date": "1632367587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159;\n\n\n//------------------------------------------\n//Real Projective Reflections\n//------------------------------------------\n\n\n//the structure defining a mirror in real projective space\nstruct Mirror{\n    vec3 halfSpace;\n    mat3 reflection;\n    };\n    \n    \n //checking if you are inside a half space with normal vec normal\nbool inside(vec3 p, Mirror mirror){\n    return dot(p,mirror.halfSpace)>0.;\n}\n\n\n\n//if p is on the wrong side of the half space, perform the reflection\nvoid reflectIn(inout vec3 p, Mirror mirror,inout float invCount){\n\n    if(!inside(p,mirror)){\n        p=mirror.reflection*p;\n        \n        //project back down to keep entries small?\n        p/=p.z;\n        \n        invCount+=1.;\n    }\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n  Mirror M1,M2,M3;\n  \n  \n  void setupFD(float d){\n  //for the 334 triangle group\n  //this is computed separately, in mathematica\n  \n  float sqrt3=sqrt(3.);\n  \n  M1.halfSpace=vec3(0,1,0);\n  M1.reflection=mat3(\n  1,0,0,\n  0,-1,0,\n  0,0,1\n  );\n  \n  \n  M2.halfSpace=vec3(sqrt3,-1.,0);\n  M2.reflection=mat3(\n  -0.5,sqrt3/2.,0.,\n  sqrt3/2.,0.5,0.,\n  0.,0.,1.\n  );\n  \n  \n  M3.halfSpace=vec3(-1./d,-2./sqrt3+1./(sqrt3*d),1.);\n  M3.reflection=mat3(\n  1.+1./(2.-4.*d)+2./(d-2.),sqrt3/(2.-4.*d), 1./(1.-2.*d)+1./(d-2.)+1./d,\n  (7.*d-2.)/(2.*sqrt3*(d-2.)),1./2.,(2.+d*(3.*d-4.))/(sqrt3*d*(d-2.)),\n  d*(2.-7.*d)/(4.-10.*d+4.*d*d),sqrt3*d/(4.*d-2.),-d*(1.+d)/(2.-5.*d+2.*d*d)\n  );\n  \n  }\n  \n  \n//reflect in each wall of the fundamental domain if needed\n  void reflectInFD(inout vec3 p,inout float invCount){\n    reflectIn(p,M1,invCount);\n    reflectIn(p,M2,invCount);\n    reflectIn(p,M3,invCount);\n}\n\n\n//this function checks if p is inside our fundamental domain or not\n    bool insideFD(vec3 p){\n       return inside(p,M1)&&inside(p,M2)&&inside(p,M3);\n    }\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec3 p,inout float invCount){\n\n\n    for(int i=0;i<30;i++){\n\n        reflectInFD(p,invCount);\n        \n        if(insideFD(p)){\n            return;\n        }\n    }\n\n    invCount=-1.;\n\n}\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n\n//\"unprojectivize\" a point in an affine patch to a representative in R3\nvec3 toR3(vec2 p){\n    return vec3(p,1.);\n}\n\n//project to affine patch z=1\nvec2 proj(vec3 p){\n    return p.xy/p.z;\n    }\n    \n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n\n    //rescale this how you like\n    uv = 7.*vec2(1,iResolution.y/iResolution.x)*uv;\n\n    return uv;\n}\n\n\n\n    \n//------------------------------------------\n//coloring the fundamental domain\n//------------------------------------------\n\nvec3 tilingColor(float invCount){\n\n    vec3 tilingColor;\n\n    if(invCount<0.){\n        //if we didnt get into the fundamental domain\n        //color it black//BETTER: A DEBUG COLOR\n        tilingColor=vec3(0.2);\n        //0.6*vec3(71,58,153)/255.;\n    }\n\n    else {\n    \n        //we did get into the fundamental domain:\n        float parity=mod(invCount, 2.);\n\n        \n            if (parity==0.){\n                tilingColor=vec3(116, 161, 250)/255.;\n            }\n            else { //parity=1.\n                tilingColor=vec3(120, 170, 250)/255.;\n           }\n\n       }\n\n    return tilingColor;\n\n}\n\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n\n    //map into R3\n    vec3 p=toR3(uv);\n    \n    setupFD(0.89+0.3*sin(iTime));\n    \n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n    \n    vec3 col;\n    \n    ///if(insideFD(p)){col=vec3(1);}\n\n    // Time varying pixel color\n    col = tilingColor(invCount);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 346, 381, 381, 422], [426, 496, 561, 561, 735], [740, 891, 913, 992, 1537], [1544, 1605, 1657, 1657, 1749], [1752, 1824, 1846, 1846, 1908], [1911, 2092, 2141, 2141, 2296], [2438, 2510, 2528, 2528, 2553], [2555, 2585, 2603, 2603, 2630], [2637, 2765, 2806, 2866, 3020], [3029, 3154, 3187, 3187, 3757], [3761, 3878, 3935, 3960, 4370]], "test": "untested"}
{"id": "7dVGDd", "name": "Box Singularity", "author": "Tater", "description": "Can you believe I'm still not done with this subdivision thing? ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 25, "viewed": 343, "published": "Public API", "date": "1632452634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n//https://www.shadertoy.com/view/fdyGDt\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\n//No Cell bounds SDF of the blocks\nfloat nsdf = 0.;\nbool rnsdf = false;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/8.)+0.2;\n    \n    float MIN_SIZE = .2;\n    float ITERS = 12.;\n    float PAD_FACTOR = 1.05;\n    \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        // divide the box into eight\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        //Use this to remove the random divisions\n        /*\n        divHash = vec3(\n            0.49,\n            0.5,\n            0.51\n        );\n        //*/\n        vec3 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE*PAD_FACTOR , dMax - MIN_SIZE*PAD_FACTOR );\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        \n        float minSize = min( minAxis.x, min( minAxis.y, minAxis.z ) );\n        bool smallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        //if (i - 1. > MIN_ITERS && h11( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if (smallEnough && i  > 0.) { willBreak = true; }\n        if( willBreak ) {\n            break;\n        }\n    \n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        // id will be used for coloring and hash seeding\n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n\n    \n    if(any(isEdge)) {\n    \n        float expand = 1.2+0.75*(sin(length(center+100.0)*0.4+t*3.0)*0.5+0.5)*0.75;\n        //expand = 1.5; \n        if(isEdge.x){\n        dim.x+=abs(center.x*expand-center.x)*2.0;\n        center.x*=expand;\n        }\n        if(isEdge.y){\n        dim.y+=abs(center.y*expand-center.y)*2.0;\n        center.y*=expand;\n        }\n        if(isEdge.z){\n        dim.z+=abs(center.z*expand-center.z)*2.0;\n        center.z*=expand;\n        }\n        //id = 1.;\n    }\n    \n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n\n\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n\n    nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(10,10,10);\n    vec3 rd2 = rdg;\n    p.yz*=rot(t*0.5);\n    rd2.yz*=rot(t*0.5);\n    p.xy*=rot(t*0.5);\n    rd2.xy*=rot(t*0.5);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*1.3)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.55;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n   // else ro.xz*=rot(t*0.3);\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.7)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres;\n        col*=pow(ao,0.2);\n        \n    }\n    col = pow(col,vec3(0.9));\n    vec3 bg = vec3(0.698,0.710,0.878)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 402, 469, 469, 508], [509, 509, 529, 529, 600], [601, 601, 622, 622, 674], [675, 675, 701, 701, 760], [761, 774, 804, 804, 891], [893, 893, 923, 923, 1026], [1047, 1119, 1158, 1158, 4188], [4190, 4190, 4207, 4207, 4527], [4528, 4528, 4546, 4546, 4674], [4675, 4675, 4732, 4732, 6401]], "test": "untested"}
{"id": "7dVGDt", "name": "Exclamation point", "author": "dysangel", "description": "was playing around with the line segment shader and discovered this", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 2, "viewed": 31, "published": "Public", "date": "1632425303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-1.1*h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    //float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    float th = 0.1;\n    \n\tfloat d = udSegment( p, v1, v2 ) - th;\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = udSegment(m, v1, v2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1216, 1377, 1429, 1429, 1556], [1558, 1558, 1615, 1615, 2466]], "test": "untested"}
{"id": "7dVGDW", "name": "Badlands v2", "author": "jarble", "description": "Yet another terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "erosion", "badlands"], "likes": 4, "viewed": 116, "published": "Public API", "date": "1631591076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\n\n#define OCTAVES 4\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = .75;\n    float freq = 1.;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = (noise(uv * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-(n1) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.;\n        \n        uv = uv.yx;\n        float f1 = .1*noise(uv);\n        value *= .9+f1;\n        freq += f1;\n        \n        //value *= .9;\n\n}\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+4);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.5;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 85], [106, 106, 141, 190, 710], [712, 712, 734, 734, 764], [766, 766, 796, 796, 846], [848, 848, 868, 868, 922], [924, 924, 957, 957, 1151], [1153, 1153, 1220, 1220, 1438], [1440, 1440, 1492, 1492, 2037], [2039, 2039, 2090, 2090, 2291], [2293, 2293, 2319, 2319, 2395], [2464, 2464, 2521, 2521, 4478]], "test": "untested"}
{"id": "7dVGRd", "name": "Ethereal capsule", "author": "SnoopethDuckDuck", "description": "First time raymarching so I think it's going well!\n\n( this is me just trying to break things)", "tags": ["cool"], "likes": 2, "viewed": 116, "published": "Public API", "date": "1632000997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 10\n#define MAX_DIST 100.\n#define SURF_DIST 1.\n\nfloat myLength(vec3 p) {\n    float theta = atan(p.y, p.x);\n    float beta = atan(p.y, p.z);\n    float x = 0.5 * (1. + cos(beta + 0.3 * iTime));\n    float z = 0.5 * (1. + sin(theta + 0.3 * iTime));\n    x = 16. * x * x * (1.-x) * (1.-x);\n    z = 16. * z * z * (1.-z) * (1.-z);\n    return sqrt(pow(p.x + x, 2.) + p.y * p.y + pow(p.z + z, 2.));\n\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    //t = 0.8 * t + 0.2 * 4. * t * (1.-t);\n    vec3 c = a + t * ab;\n    float d = myLength(p - c) - r;\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1.3 + 0.2 * cos(iTime), 6, 1);\n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    float b = 0.5 * (1. + cos(0.5 * iTime));\n    \n    float cd = sdCapsule(p, vec3(-cos(-iTime),1.5,6. + sin(-iTime)), vec3(cos(-iTime),1,6.-sin(-iTime)), .8);\n   // float cd2 = sdCapsule(p, vec3(-sin(-iTime),1,6. + cos(-iTime)), vec3(sin(-iTime),1.5,6.-cos(-iTime)), .8);\n   \n   \n    float d = min(cd, planeDist);\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + 1.4 * dO * rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO>MAX_DIST || dO<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 7. + 3. * cos(0.45 * iTime), 3);\n    vec3 lightPos2 = lightPos;\n    vec2 v = 6. * vec2(cos(0.4 * iTime), sin(0.4 * iTime));\n    lightPos.xz += v;\n    lightPos2.xz -= v;\n    vec3 l = normalize(lightPos - p);\n    vec3 l2 = normalize(lightPos2 - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    float dif2 = clamp(dot(n,l2),0.,1.);\n    //dif = 16. * dif * dif * (1.-dif) * (1.-dif);\n    dif *= dif;\n    dif2 *= dif2;\n    float d = RayMarch(p + n * SURF_DIST * 2., l);\n   // if (d<length(lightPos-p))\n     //   dif *= .1;\n\n    return dif + dif2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro - 2. * rd * d;\n    \n    float dif = GetLight(p); \n    dif = 16. * dif * dif *(1.-dif) * (1.-dif);\n    col = vec3(dif);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 89, 89, 408], [410, 410, 460, 460, 689], [691, 691, 714, 714, 1177], [1180, 1180, 1214, 1214, 1437], [1439, 1439, 1463, 1463, 1664], [1666, 1666, 1690, 1690, 2294], [2296, 2296, 2353, 2353, 2737]], "test": "untested"}
{"id": "7dVGWc", "name": "pendant shape", "author": "mds2", "description": "prototyping a shape I'm considering getting 3d printed as a necklace pendant. Experimenting with super-ellipse toroids.  Dirt simple lighting.", "tags": ["raycast", "sdf", "squircle"], "likes": 3, "viewed": 118, "published": "Public API", "date": "1632352045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 20.0\n\nconst float rad1 = 1.0;\nconst float rad2 = 0.075;\n\nfloat squircle_toroid(in vec3 pt, in float radius1, in float radius2, in float squish) {\n  vec3 pows = pt * pt;\n  pows = pows * pows;\n  float radial = sqrt(sqrt(pows.x + pows.z)) - radius1;\n  radial = radial * radial;\n  radial = radial * radial;\n  return sqrt(sqrt(squish * radial + pows.y)) - radius2;\n}\n\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\n\nfloat sdf(in vec3 pt) {\n  float v1 = squircle_toroid(pt, rad1, rad2, 0.5);\n  float v2 = squircle_toroid((-pt - 0.84 * vec3(1.25 * rad1, 0.0, 1.25 * rad1)).yzx +\n                             vec3(0.25 * rad1, 0.25 * rad1, 0.0),\n                             0.125 * rad1,\n                             rad2,\n                             4.0);\n  return checked_smooth_min(v1, v2, 0.2 * rad1);\n}\n\nfloat rayCast(in vec3 orig, in vec3 dir) {\n  float along = 0.0;\n  \n  for(int i = 0; i < 256; ++i) {\n    vec3 p = orig + along * dir;\n    float dist = sdf(p);\n    if (along > MAX_DIST || dist < 1.0e-5) {\n      return along;\n    }\n    along += 0.75 * dist;\n  }\n  return along;\n}\n\nvec3 sdfGrad(in vec3 pt) {\n  const float h = 0.001;\n  const float inv_h = 1000.0;\n  float v = sdf(pt);\n  return inv_h * vec3(sdf(pt + vec3(h, 0.0, 0.0)) - v,\n                      sdf(pt + vec3(0.0, h, 0.0)) - v,\n                      sdf(pt + vec3(0.0, 0.0, h)) - v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.0 / min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) * scale;\n    \n    vec3 dir = normalize(vec3(uv, -3.0));\n    vec3 orig = vec3(0.0, 0.0, 4.0);\n    \n    const mat3 pitch = mat3(1.0, 0.0, 0.0,\n                            0.0, 0.8, -0.6,\n                            0.0, 0.6, 0.8);\n\n    float ct = cos(iTime);\n    float st = sin(iTime);\n    mat3 yaw = mat3(ct, 0.0, st,\n                    0.0, 1.0, 0.0,\n                    -st, 0.0, ct);\n    \n    dir = pitch * yaw * dir;\n    orig = pitch * yaw * orig;\n    vec3 bounce = dir;\n\n    float blend = 0.25;\n    float d = rayCast(orig, dir);\n    \n    if (d < MAX_DIST) {\n      vec3 pt = orig + d * dir;\n      vec3 norm = normalize(sdfGrad(pt));\n      blend = 1.0;\n      bounce = reflect(dir, norm);\n    }\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * bounce;\n    \n    col = mix(vec3(0.5), col, blend);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 162, 162, 378], [380, 380, 459, 459, 548], [550, 550, 628, 693, 757], [759, 759, 819, 819, 860], [862, 862, 942, 942, 1070], [1073, 1073, 1096, 1096, 1463], [1465, 1465, 1507, 1507, 1741], [1743, 1743, 1769, 1769, 2013], [2016, 2016, 2073, 2073, 3097]], "test": "untested"}
{"id": "7dVGzt", "name": "Sinkholes", "author": "jarble", "description": "An eroded terrain with many gaping holes.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "mountain", "desert", "erosion", "hill"], "likes": 5, "viewed": 184, "published": "Public API", "date": "1631992858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq)-n1*value);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.1-amplitude;\n        amplitude *= 1./3.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1475], [1478, 1478, 1509, 1509, 1771], [1773, 1837, 1882, 1882, 2168], [2170, 2170, 2208, 2208, 2463], [2465, 2465, 2532, 2532, 2759], [2761, 2761, 2792, 2792, 4209], [4211, 4211, 4268, 4268, 4902]], "test": "untested"}
{"id": "7dy3R3", "name": "Onward to Thule", "author": "TEttinger", "description": "Thule, the fabled northern-most land! This is like my previous Northern Journey and Northern Warbler shaders combined. It's also somewhat more colorful.", "tags": ["noise", "plasma", "lights", "northern", "thule"], "likes": 8, "viewed": 207, "published": "Public API", "date": "1631845924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con.yzx)\n    + swayRandomized(c + 1.1, con.zxy)\n    + swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 64.0 + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx).xy * 32.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con + COEFFS);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * (3.14159265)) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 548], [550, 764, 795, 795, 933], [935, 935, 992, 1042, 1704]], "test": "untested"}
{"id": "7dy3Ry", "name": "Hue Shift + Noise", "author": "deerfeeder", "description": "github goodies", "tags": ["functions"], "likes": 0, "viewed": 25, "published": "Public", "date": "1631730008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\nfloat n( vec2 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin2D.glsl\n\n    // establish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4( Pi, Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi.xy + 1.0 );\n    Pt = Pt - floor(Pt * ( 1.0 / 71.0 )) * 71.0;\n    Pt += vec2( 26.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec4 hash_x = fract( Pt * ( 1.0 / 951.135664 ) );\n    vec4 hash_y = fract( Pt * ( 1.0 / 642.949883 ) );\n\n    // calculate the gradient results\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt( grad_x * grad_x + grad_y * grad_y ) * ( grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww );\n\n    // Classic Perlin Interpolation\n    grad_results *= 1.4142135623730950488016887242097;  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.5)\n    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n    vec4 blend2 = vec4( blend, vec2( 1.0 - blend ) );\n    return dot( grad_results, blend2.zxzx * blend2.wwyy );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // Time varying pixel color\n    float  swave = sin(iTime*0.1);\n    float  cwave = cos(iTime*0.02);\n    float  r = n(uv.xx*(iTime*0.01)*swave*cwave*100.0)*n(uv*10.0);\n    r += n(vec2(tanh(uv.x)))*0.5;\n    r = smoothstep(r, 0.03,0.42);\n\n    // Output to screen\n    fragColor = vec4(hueShift(vec3(1.0-r*0.1,0.5+(1.0+r)*0.2,0.8),sin(iTime*0.1)*3.14),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 112, 112, 887], [888, 888, 907, 1029, 2035], [2038, 2038, 2095, 2145, 2547]], "test": "untested"}
{"id": "7dy3zt", "name": "holopunk", "author": "fofod", "description": "cool holo ring punk fx", "tags": ["punk"], "likes": 2, "viewed": 131, "published": "Public API", "date": "1631942252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xx -.5);\n\t//vec2 uv = (fragCoord.xy / iResolution.xx - 0.5)；\n\t float c = 0.02;\n         uv.y+=.22;\n\t//uv*= abs(cos(iTime) + 1.);\n    float iiTime = iTime * 0.1;\n\tuv*= mat2(sin(iiTime),cos(iiTime),-cos(iiTime),sin(iiTime));\n\tvec3 p = vec3(uv,1.0);\n\tc = .3/length(uv);\n\tvec3 mask = fract(p*10.);\n\tvec3 mask1 = fract(p*100.);\n\tmask*= vec3(.3,0.,0.);\n\tif(mask.x > .05 && mask.y > .05) {\n\t\tmask = vec3(0.);\n\t} else {\n\t\tmask = vec3(1.)*c;\n\t}\n\tif(mask1.x > .05 && mask1.y > .05) {\n\t\tmask1 = vec3(0.);\n\t} else {\n\t\tmask1 = vec3(1.)*c;\n\t}\n\tmask += mask1;\n\tvec3 col = mask * abs(sin(iiTime))* abs(sin(iiTime)) * vec3(p +.3);\n\n    // Output to screen\n    fragColor = vec4(cos(iTime * col) * sin(iTime * col) + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dy3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 856]], "test": "untested"}
{"id": "7dyGDh", "name": "Rounded Polyline ", "author": "kastorp", "description": "Polyline with constant curvature on nodes\nuse mouse to change radius and thickness", "tags": ["2d", "arc", "polyline"], "likes": 16, "viewed": 162, "published": "Public", "date": "1631526440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Rounded Polyline by Kastorp\n//----------------------------------\n// I'm having much fun with 2d geometry, arcs, intersections\n// in a simple simulation of gears and belts \n//\n// TODO:\n//  - optimize performances\n//  - configurable radius and rounding algorithm for each node\n//  - 3d version using extrusion\n//------------------------------------\n#define R iResolution\n#define plotBelt(c1,c2, func) { vec3 fn =func;  dist=min(dist,fn.x); ldist+= (fn.x<=0.? fn.y*fn.z : fn.z); if(tdist==0. && fn.x<0.) tdist =ldist; \\\n    col = mix(mix(c1,c2,fn.y),col,smoothstep(0.,.004,fn.x));  }\n#define plotGear(sw, c1,c2,pos, func) {float fn = func; dist=min(dist,fn); \\\n    col = mix((sw?c1:c2)* (sw? angle(pos,vec2(sin(-iTime/r),cos(-iTime/r))): angle(pos,vec2(sin(iTime/r),cos(iTime/r))))/2./PI ,col,smoothstep(0.,.004,fn)); }\n\n#define PI 3.1415\nconst int N= 8; //number of nodes \n//#define RANDOM //randomize nodes\n\n//------------------------------------\n\n// line/line intersection (Iapafoto)\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x*n1.y-n0.y*n1.x; \n    if(d==0.) return vec2(0);\n    vec2 p = (p0-p1)/d;\n    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y); \n}\n\n// line/circle intersection\nvec2 intersect(vec2 p0, vec2 n, vec2 center, float r) {\n    vec2 c=p0-center;\n    float b= dot(n,c),\n          d = sqrt(b*b +r*r - dot(c,c));\n     return vec2( -b+d,-b-d);    \n}\n//angle between normals\nfloat angle(in vec2  p,in  vec2 n){\n    vec2 c= p *mat2(n.x,n.y,-n.y,n.x);\n    float a= atan(c.y,c.x);\n    if(a<0.)  a= 2.*PI +a;  \n    return a;\n}\n\n//based on Iq SDF function\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{   \n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y) {\n        vec2  b = scb*(ra+rb), a=scb*(ra-rb),pa=p-a, ba = b-a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h );\n    }\n    return abs( length(p)-ra) -rb;\n}\n\n// arc with normals as parameters\n//type=0: ordered arc, =1: always shorter, -1= always longer\nvec3 sdArcExt( in vec2 p, in vec2 na, in vec2 nb, in float ra,in float rb,bool swap,bool longer)\n{  \n    if(swap) {vec2 temp=na;na=nb;nb=temp;}\n    float an =  angle(p ,na),at=angle(nb,na) ;      \n    vec2 ta =  normalize(na+nb) *mat2(0,1,-1,0) *sign(na.x*nb.y - na.y*nb.x),  \n         tb =  na *mat2(ta.x,ta.y,-ta.y,ta.x); \n    if(tb.x<0.) tb.x=-tb.x;\n    return vec3(sdArc(p,ta,tb,ra,rb),(swap? 1.-  an /at : an / at), at*ra );\n}\n\nvec3 sdSegmentExt( in vec2 p, in vec2 a, in vec2 b , in float tk)\n{\n    vec2 n=normalize(b-a), l= vec2(length(b-a)*.5,tk);\n    p=(p-a)*mat2(n.x,n.y,-n.y,n.x) -vec2(l.x,0);\n    vec2 d = abs(p)-l;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),p.x/l.x/2.+.5,l.x*2.);\n}\n\n//segment-arc-segment\nvec4 roundCorner( vec2 a, vec2 b, vec2 c, float r)\n{   \n    //segment ab\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    //parallel ab on c side\n    vec2 a1 = a + pab;\n    \n    //segment bc\n    vec2 nbc= normalize(c-b),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    //parallel bc on a side\n    vec2 b1 = b + pbc;  \n    \n    //intersection\n    vec2 d = a1 + intersect(a1,nab,b1,nbc).x*nab;  //center of inscribed circle\n           \n    //arc-segment intersection\n    vec2 e = d  - pab;  //intersection arc, segment ab\n    vec2 f = d  - pbc;  //intersection arc, segment cb\n    \n    float de= distance(e,b),df=distance(f,b);\n    return vec4(de,df,d);             \n}\n\n//segment-arc-arc-segment\nvec4 roundCorner2( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 d = b + pab;\n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    vec2 b1 = b -  pbc,\n         e = b1  + nbc*  intersect(b1,nbc,d,2.*r).y;      \n    return vec4( d ,  e);\n}   \n\n//segment-arc-arc-arc-segment\nvec4 roundCorner3( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 a1 = b - pab,\n         e = a1  + nab*  intersect(a1,nab,b,2.*r).y; \n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-b,tbc));\n    vec2 c1 = b -  pbc,\n         f = c1  + nbc*  intersect(c1,nbc,b,2.*r).y;     \n    return vec4( e ,  f);\n}  \n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 getK(int i){\n        float s= float(i*i)/float(N*N) +.05;\n#ifdef RANDOM        \n        vec2 k =hash21(float(i))*.8-.4;\n#else        \n        const vec2[8] KK = vec2[8](vec2(.4,.4), vec2(0,0), vec2(-.3,.4), vec2(-.4,0),vec2(-.2,-.4), vec2(0,-.4), vec2(0.2,0.1), vec2(.3,-.3)) ;  \n        vec2 k= KK[i];\n#endif        \n        k.x*=R.x/R.y;\n        k +=vec2(sin(iTime*(s-.3) +s  +5.),cos(iTime*(s-.3)+s +5.))*.07 ;\n        return k;\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-R.xy*.5 + U)/R.y *1.;\n    vec3 col = vec3(0.25);  \n        \n    float r =iMouse.z>0.? iMouse.y/R.y *.07 +.04 : .08,\n          tk=iMouse.z>0.? iMouse.x/R.x *.02 : .01;\n\n    float dist=1e5,tdist=0.,ldist=0.; //SDF distance, cumulated path distance, local path distance\n    \n    for(int i=min(iFrame,0);i<N;i++)\n    {\n        //b = node, a and c = polyline mid points\n        vec2 b=getK((i+1)%N), a=(getK(i)+b)/2., c=(getK((i+2)%N)+b)/2.;\n       \n        //control point:\n         col = mix(vec3(0),col,smoothstep(0.,.002,-tk+ length(p-b)));\n                 \n        // try to use 1 arc\n        vec4 v = roundCorner(a,b,c, r);      \n        if((i%2==1)&&  v.x<distance(a,b) && v.y < distance(c,b)) {\n            //ok is compatible, draw it                        \n            vec2 nab=normalize(b-a),\n                 ncb=normalize(c-b),\n                 e= b - v.x*nab,\n                 f= b + v.y*ncb,\n                 d=v.zw;\n                 \n            bool swap =nab.x*ncb.y>nab.y*ncb.x ;\n            plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-d, tk-r  + length(p-d));\n            plotBelt(vec3(.8),vec3(8.,0,.8), sdSegmentExt(p,a,e,tk));                      \n            plotBelt(vec3(1,0,1),vec3(1,0,0),  sdArcExt(p-d,normalize(e-d),normalize(f-d),r,tk,!swap,false));           \n            plotBelt(vec3(.8,0,0),vec3(.8), sdSegmentExt(p,f,c,tk));            \n        } else {\n            // try to use 2 arcs \n            //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;            \n            //if(  distance(c,b)<distance(a,b)) {a=(ki+b)/2.; c=(km+b)/2.;}\n            \n            vec4 v2 = roundCorner2(  a,b,c,  r);\n            vec2 nab=normalize(b-a),\n                 nbc=normalize(b-c),\n                 a1=v2.xy,\n                 c1=v2.zw,\n                 f=(a1+c1)/2.,\n                 a2=b,\n                 c2=b+ intersect(b,nbc,c1,vec2(nbc.y,-nbc.x)).x*nbc;\n                 \n            if( distance(b,c)>distance(b,c2) ){\n                bool swap = nab.x*nbc.y>nab.y*nbc.x;\n                plotGear(!swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-a1, tk-r  + length(p-a1));\n                plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-c1, tk-r  + length(p-c1));                \n                plotBelt(vec3(.8),vec3(.8,0,.8),  sdSegmentExt(p,a,a2,tk));                                         \n                plotBelt(vec3(1,0,0),vec3(1,0,1), sdArcExt(p-a1,normalize(a2-a1),normalize(f-a1),r,tk,swap,true));\n                plotBelt(vec3(1,0,1), vec3(1,1,0), sdArcExt(p-c1,normalize(f-c1),normalize(c2-c1),r,tk,!swap,false));\n                plotBelt(vec3(.8,.8,0), vec3(.8), sdSegmentExt(p,c2,c,tk));\n       \n            }else{\n                // try to use 3 arcs\n                //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;\n                vec4 v2 = roundCorner3(  a,b,c,r);\n                vec2 nab=normalize(b-a),\n                     nbc=normalize(b-c),\n                     e = v2.xy,\n                     f = v2.zw,                \n                     a1=(e+b)/2.,\n                     c1=(f+b)/2.,\n                     a2= b+ intersect(b,nab,e,vec2(nab.y,-nab.x)).x*nab,\n                     c2= b+ intersect(b,nbc,f,vec2(nbc.y,-nbc.x)).x*nbc;       \n\n                  if(distance(a,b)>distance(b,a2) && distance(b,c)>distance(b,c2)){\n                    //ok is compatible, draw it \n                    bool swap = nab.x*nbc.y>nab.y*nbc.x;\n\n                    plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-e, tk-r  + length(p-e));\n                    plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-f, tk-r  + length(p-f));\n                    plotGear(!swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-b, tk-r  + length(p-b));\n                    plotBelt(vec3(.8),vec3(.8,.8,.0), sdSegmentExt(p,a,a2,tk));                               \n                    plotBelt(vec3(1,1,0),vec3(1,0,1), sdArcExt(p-e,normalize(a2-e),normalize(a1-e),r,tk,!swap,false));\n                    plotBelt(vec3(1,0,1),vec3(1,0,0), sdArcExt(p-b,normalize(a1-b),normalize(c1-b),r,tk,swap,false));                               \n                    plotBelt(vec3(1,0,0),vec3(1,1,0), sdArcExt(p-f,normalize(c1-f),normalize(c2-f),r,tk,!swap,false));\n                    plotBelt(vec3(.8,.8,0.),vec3(.8), sdSegmentExt(p,c2,c,tk));                \n                  }else{\n                    //segments too short - skip rounding\n                    plotBelt(vec3(.8),vec3(8.,0,0), sdSegmentExt(p,a,b,tk));\n                    plotBelt(vec3(.8,0,0),vec3(.8), sdSegmentExt(p,b,c,tk));\n                  }\n              }\n        }\n    }\n       \n     if(tdist>0.) col+=  smoothstep(0.1,.15, mod(iTime-tdist, .3));\n     if(tdist==0.) col +=vec3(dist*1.);\n     \n     if(iMouse.z>0.){\n         col = vec3(0.9,0.6,0.3); if(dist<0.) col= vec3(1,1,tdist*10.);\n        col *= 1.0 - exp(-3.0*abs(dist));\n        col *= 0.8 + 0.2*cos(250.0*dist);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(dist)) );\n     }  \n    // Output to screen\n    O = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[949, 986, 1038, 1038, 1186], [1188, 1216, 1271, 1271, 1393], [1394, 1418, 1453, 1453, 1565], [1567, 1594, 1672, 1672, 1969], [1971, 2066, 2164, 2164, 2497], [2499, 2499, 2566, 2566, 2777], [2779, 2801, 2853, 2873, 3558], [3560, 3586, 3638, 3638, 3981], [3986, 4016, 4068, 4068, 4465], [4469, 4469, 4491, 4491, 4620], [4621, 4621, 4638, 4638, 5059], [5060, 5127, 5168, 5218, 10199]], "test": "untested"}
{"id": "7dyGDW", "name": "cloudyStuff", "author": "stephenl7797", "description": "cloudy stuff.\nLooks drastically different on different platforms :/", "tags": ["abstract"], "likes": 12, "viewed": 260, "published": "Public API", "date": "1631570883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash31(vec3 p) {\n    float q = dot(p,vec3(170.1,110.7,100.6));\n\treturn fract(sin(q)*480.5453);\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += hash31(floor(p*2.5+100.)) * .1;\n    f += hash31(floor(p*2.+200.)) * .5;\n    f += hash31(floor(p*1.+200.)) * 1.;\n    f += hash31(floor(p/2.+200.)) * .5;\n    f += hash31(floor(p/4.+400.)) * .25;\n    f += hash31(floor(p/8.+400.)) * .25;\n    f += hash31(floor(p/16.+400.)) * .25;\n    return f / 3.65;\n}\nvec3 calcNormal(vec3 p) {\n    float d = .4;\n    return normalize(vec3(\n        fbm(p+vec3(d,0.,0.)) - fbm(p-vec3(d,0.,0.)),\n        fbm(p+vec3(0.,d,0.)) - fbm(p-vec3(0.,d,0.)),\n        fbm(p+vec3(0.,0.,d)) - fbm(p-vec3(0.,0.,d))));\n}\n\n// The ray is rotated along z axis while marching, which gives a slight spiral.\nvec3 rot(vec3 x, float t) {\n    return normalize(vec3(x.x-x.y*t, x.y+x.x*t, x.z));\n}\nvec3 map(vec3 ro, vec3 rd) {\n    float t = 0.9, d = 10.;\n    for (int it=0; it<53; it++) {\n        vec3 rp = ro + t*rd;\n        rd = rot(rd, .023);\n        d = fbm(rp);\n        t += d * .992;\n    }\n    return ro + t * rd;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x += fract(sin(uv.x*250.3+uv.y*400.)*280.24) * .00051;\n\n    vec3 col = vec3(0.);\n    \n    \n    \n    //vec3 ro = vec3(cos(iTime), sin(iTime) ,-2.5 + iTime * .71);\n    vec3 ro = vec3(0.,0. ,-2.5 + iTime);\n    //vec3 ro = vec3(iTime,iTime ,-2.5 + iTime);\n    \n    vec3 rd = normalize(vec3((uv-.5)*vec2(1.0,iResolution.y/iResolution.x),.075));\n    \n    if (iMouse.z > .5) {\n        float pitch = (iMouse.y/iResolution.y-.5)*3., yaw = (iMouse.x/iResolution.x-.5)*3.;\n        rd = mat3(1., 0., 0.,   0., cos(pitch), -sin(pitch),   0., sin(pitch), cos(pitch)) *\n             mat3(cos(yaw), 0., -sin(yaw),   0.,1.,0.,  sin(yaw),0.,cos(yaw)) * rd;\n    }\n    \n    vec3 rp = map(ro,rd);\n    float d = length(rp-ro);\n    \n    float v = clamp(d * .034, 0.,1.);\n\n    col.rgb = clamp(pow(v,9.)*(10.*pal(v*v, vec3(0.0,0.0,0.0),vec3(0.5,0.50,0.98),vec3(-1.,.50,.0),vec3(0.10,0.72,0.1))),0.,1.);\n    col.rgb += .8 * clamp(v*pal(v, vec3(0.01,0.0,0.07),vec3(0.9,0.0,0.999),vec3(.85,.0,.65),vec3(0.4,0.0,0.5) ),0.,1.);\n    \n    vec3 n = calcNormal(rp);\n    col.rgb += clamp(v*v*pow(abs(n.z),3.) * vec3(.05,.716,.91) * 1.2, 0.,1.);\n    col.rgb += clamp(v*pow((n.y-.1),5.) * vec3(.75,.7216,.01) * .97, 0.,1.);\n    col.r = pow(col.r,1.25);\n    //col.g = pow(col.g,2.5);\n    //col.b = pow(col.b,2.5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 103], [105, 105, 124, 124, 450], [451, 451, 476, 476, 684], [686, 766, 793, 793, 850], [851, 851, 879, 879, 1074], [1076, 1076, 1144, 1144, 1187], [1189, 1189, 1246, 1246, 2603]], "test": "untested"}
{"id": "7dyGWV", "name": "Insane Bumpy Terrain", "author": "jarble", "description": "A bumpy hilly landscape based on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "desert", "hill"], "likes": 5, "viewed": 150, "published": "Public API", "date": "1632193637", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .25;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv) * freq);\n        n1 = abs(n2+n1+freq);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value-n1 * amplitude);\n        freq *= 1.5+1./(1.+amplitude);\n        amplitude *= (1./(1.+freq));\n        \n\n        uv = uv.yx+n1/(1.+amplitude);\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1)*2.;\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1287], [1290, 1290, 1321, 1321, 1583], [1585, 1649, 1694, 1694, 1980], [1982, 1982, 2020, 2020, 2275], [2277, 2277, 2344, 2344, 2571], [2573, 2573, 2604, 2604, 4021], [4023, 4023, 4080, 4080, 4717]], "test": "untested"}
{"id": "7s33Rs", "name": "sexy sci-fi health bar", "author": "cedric_h", "description": "gets very dramatic at the end, or at least I sure think so :P", "tags": ["hexagon", "scifi", "hexagonal", "glowing", "sexy", "energy", "healthbar"], "likes": 8, "viewed": 258, "published": "Public API", "date": "1630464649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* source: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm */\nfloat sdPolygon(in vec2 p, in vec2[6] v) {\n  const int num = v.length();\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=num-1; i<num; j=i, i++ ) {\n    // distance\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n\n    // winding number from http://geomalgorithms.com/a03-_inclusion.html\n    bvec3 cond = bvec3( p.y>=v[i].y, \n        p.y <v[j].y, \n        e.x*w.y>e.y*w.x );\n    if( all(cond) || all(not(cond)) ) s=-s;  \n  }\n\n  return s*sqrt(d);\n}\n\nfloat hex(vec2 p, float s) {\n  p.x *= 0.57735*2.0;\n  p.y += mod(floor(p.x), 2.0)*0.5;\n  p = abs((mod(p, 1.0) - 0.5));\n  return smoothstep(1.0, 0.1, abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0) / (0.38 + s));\n}\n\nfloat inv_lerp(float from, float to, float value){\n  return max(0.0, min(1.0, (value - from) / (to - from)));\n}\n\n/* source: https://easings.net */\nfloat easeOutCirc(float x) {\n  return sqrt(1.0 - pow(x - 1.0, 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  float hp = 1.0 - easeOutCirc(mod(iTime, 50.0) / 50.0);\n\n  vec2[] polygon = vec2[](\n    vec2(0.97, 0.97),\n    vec2(0.13, 0.97),\n    vec2(0.03, 0.32),\n    vec2(0.73, 0.32),\n    vec2(0.77, 0.03),\n    vec2(0.97, 0.03)\n  );\n  for (int i = 0; i < polygon.length(); i++)\n    polygon[i] = (polygon[i] + vec2(0, 3)) / vec2(1, 5);\n\n  float d = sdPolygon(uv, polygon);\n\n  float cd = 0.7*(1.0-smoothstep(0.01,0.02, abs(d))) + (1.0-smoothstep(-0.03,0.03, abs(0.02 - d)));\n  // cd = step(0.4, cd)*cd;\n  vec3 c = vec3(cd) * vec3(0.575, 0.5, 0.7);\n  float lowhp = inv_lerp(0.3, 0.27, hp);\n  float h = hex(fragCoord * 0.04, lowhp * 0.2 * abs(sin(7.0*iTime)));\n  float hpx = (1.15 * (1.0 - uv.x)) - 0.08;\n  vec3 cbase = mix(vec3(1.0, 0.0, 1.0-0.8*lowhp), vec3(0.4, 0.2, 0.4), inv_lerp(hp-0.03, hp, hpx));\n  c += float(!(c.x > 0.0)) * max(0.0, -d)/0.06 * cbase * h;\n\n  fragColor = vec4(vec3(c*0.7), 1.0-sign(d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s33Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 86, 128, 128, 639], [641, 641, 669, 669, 844], [846, 846, 896, 896, 957], [959, 993, 1021, 1021, 1063], [1065, 1065, 1120, 1120, 2056]], "test": "untested"}
{"id": "7s3GDf", "name": "Gerd Muller 2021", "author": "yasuo", "description": "Robot modeling design. This one is not a reproduction. I designed this by myself. I know we can do this more detailed one using the 3D model software but it is what it is. I love to do this with all by the shader.", "tags": ["modeling", "robot"], "likes": 13, "viewed": 185, "published": "Public API", "date": "1630744595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define EDGE_WIDTH 0.003\n#define MATERIAL_BODY 0\n#define MATERIAL_SKELTON 1\n#define MATERIAL_EYE 2\n#define MATERIAL_BOX 3\n\n#define ZERO (min(iFrame,0))\n\nfloat edge;\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat dTaperBox(vec3 p, vec3 b, float angle, float bottomDist) {\n    vec3 prevP = p;\n    float d = B3D(p,b);\n    float a = radians(angle);\n    p.x = abs(p.x);\n    p.x-=bottomDist;    \n    d = max(Slice(p.xy,a),d);\n\n    p = prevP;\n    a = radians(angle);\n    p.z = abs(p.z);\n    p.z-=bottomDist;\n    d = max(Slice(p.zy,a),d);\n\n    return d;\n}\n\nfloat leg(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.06,0.09,0.07));\n    \n    float a = radians(45.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.065;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.055;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d);    \n    \n    return d;\n}\n\nvec2 drawLeg(vec3 p){\n    vec3 prevP = p;\n    \n    p.z*=0.7;\n    p.x=abs(p.x);\n    p.x-=0.028;\n    float d = dTaperBox(p,vec3(0.021,0.035,0.14),60.0,0.1);\n    p = prevP;\n    \n    p.zy = abs(p.zy);\n    p.zy-=0.2;    \n    float maskd = max(Slice(p.zy,radians(-42.0)),B3D(prevP-vec3(0.0,-0.03,0.0),vec3(0.1,0.02,0.2)));\n    \n    d = max(-maskd,d);\n    vec2 res = vec2(d, MATERIAL_SKELTON);\n    \n    p = prevP;\n    p.yz*=Rot(radians(10.0));\n    d = leg(p-vec3(0.0,0.12,0.01));\n    \n    p = prevP;\n    p.yz*=Rot(radians(-20.0));\n    p*=vec3(0.8,0.7,0.8);\n    \n    float d2 = leg(p-vec3(0.0,0.21,-0.07));\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = sdCappedCylinder(p-vec3(0.0,0.21,-0.01),0.035,0.08);\n    d = min(d,d2);\n    \n    p.yz*=Rot(radians(20.0));\n    d2 = B3D(p-vec3(0.0,0.17,-0.04),vec3(0.015,0.08,0.01));\n    d = min(d,d2);\n    \n    vec2 res2 = vec2(d, MATERIAL_BODY);\n    return combine(res,res2);\n}\n\nfloat sholuder(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.13,0.1,0.07));\n    \n    float a = radians(50.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.075;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    p.xz = abs(p.xz);\n    p.xz-=0.085;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.x+=0.12;    \n    d = max(-Slice(p.xy,a),d);    \n    \n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.065;\n    d = max(-B3D(p-vec3(0.07,0.0,0.0),vec3(0.01,0.06,0.02)),d); \n    \n    return d;\n}\n\nfloat armWithSheild(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.07,0.06,0.09));\n    \n    float a = radians(45.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.065;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(30.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.06;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d);    \n    \n    p = prevP;\n    float d2 = B3D(p-vec3(-0.075,0.0,0.05),vec3(0.01,0.05,0.12));\n    \n    p.y = abs(p.y);\n    p.y-=0.03;\n    d2 = max(-B3D(p-vec3(-0.082,0.0,0.05),vec3(0.005,0.005,0.13)),d2);\n    \n    return min(d,d2);\n}\n\nfloat hand(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.02,0.04,0.04));\n    \n    float a = radians(-120.0);\n    p.xz+=0.01;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    d = max(-B3D(p-vec3(0.015,0.0,0.01),vec3(0.01,0.05,0.015)),d);\n    \n    return d;\n}\n\nvec2 drawArm(vec3 p){\n    vec3 prevP = p;\n    float d = sholuder(p);\n    \n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    float x = 0.01;\n    d = B3D(p-vec3(x,-0.15,0.0),vec3(0.04,0.1,0.035));\n    \n    float d2 = B3D(p-vec3(x,-0.25,-0.03),vec3(0.04,0.04,0.065));\n    d = min(d,d2);\n    d2 = sdCappedCylinder(p-vec3(x,-0.24,0.0),0.06,0.05);\n    d = min(d,d2);\n    \n    vec2 res2 = vec2(d, MATERIAL_SKELTON);\n    \n    d = armWithSheild(p-vec3(x,-0.25,-0.165));\n    vec2 res3 = vec2(d, MATERIAL_BODY);\n    \n    d = hand(p-vec3(x,-0.25,-0.298));\n    vec2 res4 = vec2(d, MATERIAL_SKELTON);\n    \n    return combine(res,combine(res2,combine(res3,res4)));\n}\n\nfloat bodyTop(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.15,0.15,0.2));\n    \n    float a = radians(50.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.12;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(-40.0);\n    p.xy = abs(p.xz);\n    p.xy-=0.26;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.02;\n    p.x = abs(p.x);\n    p.x-=0.02;\n    d = max(-B3D(p-vec3(0.0,0.0,-0.198),vec3(0.007,0.04,0.03)),d);\n    \n    return d;\n}\n\nfloat bodyBtm(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.06,0.1,0.16));\n    \n    float a = radians(35.0);\n    p.zy = abs(p.zy);\n    p.zy-=vec2(0.1,0.13);    \n    d = max(Slice(p.zy,a),d);\n    \n    return d;\n}\n\nvec2 drawBody(vec3 p){\n    vec3 prevP = p;\n    float d = bodyBtm(p-vec3(0.0,-0.1,0.0));\n    float d2 = bodyTop(p-vec3(0.0,0.1,0.0));\n    d = min(d,d2);\n    vec2 res = vec2(d, MATERIAL_BODY);\n    return res;\n}\n\nvec2 drawHead(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.05,0.04,0.1));\n    float a = radians(40.0);   \n    d = max(Slice(p.yz,a),d);\n    d = max(-B3D(p-vec3(0.0,0.0,-0.1),vec3(0.3,0.01,0.01)),d);\n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    d = B3D(p-vec3(sin(-iTime*2.5)*0.01,0.0,-0.1),vec3(0.025,0.005,0.01));\n    vec2 res2 = vec2(d, MATERIAL_EYE);\n    \n    return combine(res,res2);\n}\n\nvec2 drawBox(vec3 p){\n    vec3 prevP = p;\n    vec3 size = vec3(3.5,0.01,3.5);\n    p.z-=iTime*1.5;\n    p.y+=noise3d(p*80.0)*0.005;\n    p.z=mod(p.z,2.)-1.0;\n    \n    float d = B3D(p,size);\n    p = prevP;\n    float d2 = B3D(p,size);\n    d = max(B3D(p,size),d);\n    vec2 res = vec2(d, MATERIAL_BOX);\n    return res;\n}\n\nvec2 drawCannon(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.17,0.04,0.15));\n    \n    float a = radians(25.0);\n    p.zy = abs(p.zy);\n    p.zy-=0.1;    \n    d = max(Slice(p.zy,a),d);\n    \n    p = prevP;\n    a = radians(20.0);\n    p.xz = abs(p.xz);\n    p.xz-=0.085;    \n    d = max(Slice(p.xz,a),d);\n    \n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.055;    \n    d = max(Slice(p.xy,a),d); \n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.03; \n    float d2 = B3D(p-vec3(0.0,0.0,-0.13),vec3(0.03));    \n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z = abs(p.z);\n    p.z-=0.1;\n    d2 = B3D(p,vec3(0.18,0.05,0.005));\n    p = prevP;\n    p.xy = abs(p.xy);\n    p.xy-=0.065;  \n    d2 = max(Slice(p.xy,a),d2);\n    d = min(d,d2);\n    \n    vec2 res = vec2(d, MATERIAL_BODY);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.03; \n    d = B3D(p-vec3(0.0,0.0,-0.12),vec3(0.02));\n    vec2 res2 = vec2(d, MATERIAL_SKELTON);\n    \n    return combine(res,res2);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 originalP = p;\n    \n    p.x += sin(iTime*2.2)*0.12;\n    p+=noise3d(p*300.0)*0.001;\n    vec3 prevP = p;\n\n    p.x = abs(p.x);\n    p.x-=0.12;\n    vec2 dleg = drawLeg(p-vec3(0.0,-0.42,-0.05));\n    p = prevP;\n    \n    p.x = abs(p.x);\n    \n    p.x-=0.29;\n    p.x*=-1.0;\n    vec2 dCannon = drawCannon(p-vec3(0.0,0.42,0.03));\n    vec2 darm = drawArm(p-vec3(0.0,0.28,0.0));\n    p = prevP;\n    vec2 dBody = drawBody(p-vec3(0.0,0.1,0.0));\n    vec2 dhead = drawHead(p-vec3(0.0,0.39,0.015));\n    \n    p = originalP;\n    vec2 dBox = drawBox(p-vec3(0.0,-0.47,0.0));\n    \n    vec2 model = combine(combine(dleg,darm),combine(dBody,dhead));\n    return combine(combine(model,dCannon),dBox);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dist = dS.x;\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(stepnum == MAX_STEPS){\n            if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.0005) {\n                edge = 1.0;\n            }\n            if (dist < lastDistEval) lastDistEval = dist;\n        }\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat bodyPaint(vec2 p, float sc, float flip){\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float rand = hash12(id);\n    float lineW = 0.14;\n    \n    if(rand<0.5 || rand>=0.8){\n        float dir = (rand>=0.8)?1.0:-1.0;\n        uv*=Rot(radians(dir*45.0*flip));\n        uv.x = abs(uv.x);\n        uv.x-=0.355;\n        lineW = 0.1;\n    }\n    \n    lineW*=sc;\n    float d = max(-(uv.x+(lineW*0.5)),(uv.x-(lineW*0.5)));\n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 np = p;\n    float xanim = sin(iTime*2.2)*0.12;\n    if(mat == MATERIAL_BODY){\n        np.x += xanim;\n        float d = bodyPaint(np.xy*30.0,1.0,1.0);\n        float nn = noise3d(np*30.0)*0.2;\n        float sn = hash12(np.xy*100.0)*0.1;\n\n        vec3 bcol = mix(vec3(0.3,0.4,0.3)+nn-sn,vec3(0.1,0.2,0.1),S(p.xy,d,0.0));\n        col = diffuseMaterial(n,rd,p,bcol);\n    } else if(mat == MATERIAL_SKELTON) {\n        np.x += xanim;\n        float nn = noise3d(np*100.0)*0.1;\n        float sn = hash12(np.xy*100.0)*0.1;\n        col = diffuseMaterial(n,rd,p,vec3(0.2)+nn+sn);\n        col*=1.5;\n    } else if(mat == MATERIAL_BOX) {\n        np.z-=iTime*1.5;\n        vec3 prevNp = np;\n        float nn = noise3d(np*5.0)*0.08;\n        float sn = hash12(np.xz*100.0)*0.1;\n        vec3 bcol = vec3(0.6,0.65,0.7)+nn+sn;\n\n        np.z= mod(np.z,0.8)-0.4;\n        float d = B(np.xz,vec2(0.02,0.2));\n        bcol = mix(bcol,vec3(1.0),S(p.xy,d,0.0));\n        np.x = abs(np.x);\n        np.x-=1.5;\n        d = B(np.xz,vec2(0.02,0.4));\n        bcol = mix(bcol,vec3(1.0),S(p.xy,d,0.0));\n        \n        col = diffuseMaterial(n,rd,p,bcol);\n    } else if(mat == MATERIAL_EYE){\n        col = diffuseMaterial(n,rd,p,vec3(0.5,0.0,0.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float handShakeY = noise3d(vec3(iTime*2.0,iTime*2.1,iTime*2.2))*0.15;\n    float handShakeX = noise3d(vec3(iTime*2.1,iTime*2.2,iTime*2.1))*0.3;\n    #if USE_MOUSE == 1\n    handShakeY = 0.0;\n    handShakeX = 0.0;\n    #endif\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 1.3);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-10.0));\n    if(iMouse.z>0.){\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.xz *= Rot(radians(180.0+iTime*20.0));\n    }\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col = mix(col,vec3(0.6),edge);\n        col *= exp( -0.038*d.x*d.x*d.x );//fog\n    } else {\n        rd.z-=iTime*1.2;\n        // dust effect\n        float c = noise3d(rd) * 0.5 + noise3d(rd * 5.0) * 0.25 + noise3d(rd * 10.0) * 0.1;\n        uv.y-=0.07;\n        col = mix(vec3(0.3,0.3,0.1)+(c*0.2),vec3(0.0),-uv.y+1.0);   \n    }\n    \n    // POST EFFECTS\n    float cline = mod(fragCoord.y, 4.0) < 2.0 ? 0.5 : 1.0;\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0)*(cline*1.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3GDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 616, 641, 641, 980], [982, 1001, 1023, 1023, 1140], [1142, 1142, 1178, 1178, 1220], [1222, 1297, 1349, 1349, 1456], [1458, 1458, 1485, 1485, 1539], [1541, 1541, 1605, 1605, 1882], [1884, 1884, 1902, 1902, 2306], [2308, 2308, 2329, 2329, 3222], [3224, 3224, 3247, 3247, 3748], [3750, 3750, 3778, 3778, 4386], [4388, 4388, 4407, 4407, 4664], [4666, 4666, 4687, 4687, 5315], [5317, 5317, 5339, 5339, 5801], [5803, 5803, 5825, 5825, 6024], [6026, 6026, 6048, 6048, 6234], [6236, 6236, 6258, 6258, 6640], [6642, 6642, 6663, 6663, 6955], [6957, 6957, 6981, 6981, 7920], [7922, 7922, 7944, 7944, 8627], [8629, 8629, 8687, 8687, 9253], [9255, 9255, 9279, 9279, 9480], [9482, 9482, 9524, 9524, 9719], [9721, 9762, 9811, 9811, 10102], [10104, 10104, 10161, 10161, 10780], [10782, 10782, 10828, 10828, 11222], [11224, 11224, 11283, 11283, 12524], [12526, 12526, 12583, 12583, 14069]], "test": "untested"}
{"id": "7sc3W2", "name": "RainDropOnWindow", "author": "hugohuang", "description": "rain drop on window", "tags": ["rain"], "likes": 0, "viewed": 48, "published": "Public", "date": "1630649470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat N11(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat N12(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define SPEED     0.1\n#define GRIDW    10.0\n#define GRIDH     2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0., 0., 0.);\n\n    vec2 gridsWH = vec2(GRIDW, GRIDH);\n    vec2 ratio = iResolution.xy/gridsWH;\n    ratio /= ratio.y;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1. - uv.y;\n    uv.y = fract(uv.y - iTime*SPEED);\n    \n    vec2 cellUV = fract(uv*gridsWH);\n    cellUV -= 0.5;\n\n    float v = uv.y*10.;\n    vec2 offset = vec2(sin(3.*v)*pow(sin(v), 6.)*.3,\n        -sin(iTime + sin(iTime + sin(iTime)*0.5)) * 0.4);\n    offset.x = 0.;\n    offset.y -= (cellUV.x - offset.x)*(cellUV.x - offset.x);\n    vec2 dropPos = (cellUV + offset)*ratio;\n\n    float drop = smoothstep(0.06, 0.04, length(dropPos));\n    vec2 trailUV = cellUV - vec2(offset.x, iTime*SPEED);\n    trailUV.y = fract(cellUV.y*8.);\n    trailUV.y -= 0.5;\n    trailUV *= ratio;\n    trailUV.y /= 8.0;\n    float trail = smoothstep(0.04, 0.02, length(trailUV));\n    trail *= smoothstep(0.01, -0.01, dropPos.y);\n    trail *= smoothstep(-0.5, offset.y, dropPos.y);\n\n    color += vec3(drop);\n    color += vec3(trail);\n/*\n    vec2 offset = vec2(0., 0.);\n    offset.x = sin(uv.y*30.)*pow(sin(uv.y*10.),6.) * .3;\n    offset.y = -sin(iTime + sin(iTime + sin(iTime)*0.5)) * .4;\n\n    vec2 cellUV = uv * gridsWH;\n    cellUV = fract(cellUV);\n    cellUV -= .5;\n    offset.y += (cellUV.x-offset.x) * (cellUV.x - offset.x);\n\n    vec2 dropPos = vec2((cellUV.x - offset.x)/ratio, cellUV.y);\n    dropPos += offset;\n    color.x += smoothstep(.1, .09, length(dropPos));\n    \n    vec2 trailPos = vec2((cellUV.x-offset.x)/ratio, cellUV.y);\n    trailPos += offset;\n    trailPos.y = (fract(trailPos.y*8.) - .5) / 8.;\n    float rTrail = smoothstep(.06, .04, length(trailPos));\n    rTrail *= smoothstep(0.05, -0.05, dropPos.y);\n    rTrail *= smoothstep(-0.5, offset.y, cellUV.y);\n    color.x += rTrail;\n*/\n\n    // Debug\n    if (cellUV.x > .49 || cellUV.y > .49) {\n        // color.x = 1.;\n    }\n    \n\n    fragColor = vec4(color,0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 69], [70, 70, 89, 125, 297], [298, 298, 317, 373, 516], [585, 585, 642, 642, 2527]], "test": "untested"}
{"id": "7scSR7", "name": "blob field", "author": "drschizzo", "description": "use RIGHT,UP,LEFT arrows to toggle lights\nuse mouse to move the main light and the camera", "tags": ["raymarching", "wip"], "likes": 2, "viewed": 110, "published": "Public API", "date": "1632902499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define lin2sRGB(x) ( x <= .0031308 ? (x)*12.92 : 1.055*pow(x,1./2.4) - .055 )\n\n\nconst float ANIM_SPEED=2.;\n\n\nconst float SEED=3.42;\n\nconst int MAX_STEP=80;\nconst float MIN_DIST=.005;\nconst float MAX_DIST=80.;\n\n\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\n\nstruct Light{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nstruct Hit{\n    float dist;\n    vec4 objId;\n    vec3 pos;\n    vec3 normal;    \n};\n\n//  from DAVE HOSKINS\nvec3 N13(float p) {\n    p=p*SEED;\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat map01(float min,float max, float val){\n    return val=clamp((val-min)/(max-min),0.,1.);\n}\n\n \n\nvec4 getSphere(float n){\n    float nb=n;\n    float t=iTime/ANIM_SPEED;\n    vec3 p=N13(nb);\n    nb=nb*p.x;\n    float b=4.;\n    float z=-6.+3.*(sin(t*2.+b*float(nb))*0.5+.5);\n    float w=min(b/1.5,1.2)*pow((1.-(-z-3.)/3.),2.);\n    return vec4(p.x*1.5+cos(z*3.+n)*.4,p.y*1.5+sin(z*3.+n)*.4,z,w*1.2);\n    \n}\n\n//from https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 sminN( float a, float b, float k, float n )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nfloat computeId(vec3 p,vec3 rep){\n   \n    return dot(floor((rep*.5+p)/rep),vec3(1.,10.,100.));\n    \n}\n\n\nHit getDist(vec3 p){\n    float fact=.8;\n\n    vec3 orip=p;\n    \n    vec3 rep=vec3(3.*fact,3.*fact,15.);\n    float idOffset;\n\n    \n    p=mod(p+rep/2.,rep)-rep/2.;\n    \n    \n   \n    float dist=MAX_DIST;\n    int objId=-1;\n    int sphereId=0;\n     \n    \n   vec3 col=vec3(0.);\n    \n    \n    for(float i=-1.;i<=1.;i++){\n        for(float j=-1.;j<=1.;j++){\n            \n            vec3 p1=vec3(orip.x+i*rep.x,orip.y+j*rep.y,orip.z);\n            \n            idOffset=computeId(p1,rep);\n            vec4 sphere=getSphere(idOffset);\n            sphere.x=sphere.x+i*rep.x;\n            sphere.y=sphere.y+j*rep.y;\n           \n            float d1=length(p-sphere.xyz)-sphere.w;\n            //float d1=sdBox(p-sphere.xyz,vec3(sphere.w*fact));\n            col+=N13(idOffset)*pow(max(min(1.-d1,1.),0.),3.);\n\n            dist=sminN(dist,d1,2.*fact,4.).x;\n        }\n    }\n\n    \n    objId=int(idOffset);\n\n    dist*=.5;\n    return Hit(dist,vec4(objId,col),vec3(0),vec3(0));\n}\n\n\n\nvec3 getNormal(vec3 pos){\n    vec2 e=vec2(.05,0);\n    float dist=getDist(pos).dist;\n    vec3 n=vec3(\n        dist-getDist(pos-e.xyy).dist,\n        dist-getDist(pos-e.yxy).dist,\n        dist-getDist(pos-e.yyx).dist);\n    return normalize(n);\n}\n\nHit rayMarch(vec3 o,vec3 ray){\n    float totalDist=0.;\n    Hit hit;\n    for(int i=0;i<MAX_STEP;i++){\n        vec3 p=o+totalDist*ray;\n        hit=getDist(p);\n        totalDist+=hit.dist*2.*(.5+map01(0.,60.,totalDist));\n        if(hit.dist<MIN_DIST||totalDist>MAX_DIST) break ;\n    }\n    if(totalDist<MAX_DIST){\n        vec3 pos=o+ray*totalDist;\n        return Hit(totalDist,hit.objId,pos,getNormal(pos));\n    }\n    else{\n        return Hit(totalDist,vec4(-1),vec3(0),vec3(MAX_DIST));\n    }\n    \n}\n\nvec3 shadePixel(vec3 pos, vec3 n, Light light,vec3 viewDir){\n\n    float intensity=1./pow(length(pos-light.pos),2.)*light.intensity;\n    float diffuse=dot(normalize(light.pos-pos),n);\n    float shadow=1.;//softshadow( pos, light.pos, 0.01, 10., 5.);\n    diffuse=clamp(diffuse,0.,1.)*shadow;\n\n\n    vec3 r=normalize(light.pos-viewDir-pos);\n    float spec=pow(max(dot(n, r),0.), 90.)*shadow;\n    \n    float ret=diffuse;\n    ret +=  spec;\n\n    return ret*intensity*light.color;\n}\n\nfloat getzoffset(){\n   return iTime/ANIM_SPEED*10.;\n}\n\nvec2 getmousePos(){\n    return ((iMouse.xy-.5*iResolution.xy)/iResolution.y);\n\n}\n\n\nvec3 computeLighting(vec3 hitPos,vec3 n,vec3 ray){\n\n  bool disableLight1=texelFetch( iChannel1, ivec2(KEY_LEFT,2),0 ).x>0.;\n    bool disableLight2=texelFetch( iChannel1, ivec2(KEY_RIGHT,2),0 ).x>0.;\n    bool disableLight3=texelFetch( iChannel1, ivec2(KEY_UP,2),0 ).x>0.;\nfloat zoffset=getzoffset();\n\nLight lights[]=Light[](Light(vec3(getmousePos()*20.,30.-zoffset),disableLight3?0.:100.,vec3(1.,1.,1.)),\n                           Light(vec3(-8,3.,8.-zoffset),disableLight1?0.:100.,vec3(1.,.8,0.)),\n                           Light(vec3(8,-3.,8.-zoffset),disableLight2?0.:150.,vec3(0.,0.,1.)));\n\n\n    vec3 col=vec3(0.);\n    for(int i=0;i<3;i++){\n        vec3 shadingColor=shadePixel(hitPos,n,lights[i],ray);\n        \n        col+=shadingColor;\n   }\n   return col;\n}\n\n\n\nvec4 render(inout vec3 ro, inout vec3 ray,inout float fresnel, out bool doreflect){\n\n \n    \n    Hit hit=rayMarch(ro,ray);\n    \n    ro=hit.pos+hit.normal*0.003;\n    ray=reflect(ray,hit.normal);\n    fresnel=1.-dot(hit.normal,ray);\n    \n    vec4 colSphere;\n    \n    //only compute reflexion on close objects\n    if(hit.dist<15.)\n        doreflect=true;\n   \n    if(hit.objId.y!=-1.){\n        vec3 col=computeLighting(hit.pos,hit.normal,ray);\n        vec3 colsp=hit.objId.yzw;\n        colSphere = vec4(col.xyz*colsp,1.0);\n        \n    }\n    \n    return colSphere;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime/ANIM_SPEED;\n    \n    vec2 mousePos=getmousePos();\n    \n    float zoffset=t*10.;\n    \n    //camera model from https://www.youtube.com/watch?v=PBxuVlp7nuM\n    vec3 camera=vec3(mousePos*8.,30.-zoffset);//-20.*(1.+sin(t)));\n    vec3 lookAt=vec3(mousePos*4.,-zoffset);\n    float zoom=1.;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    \n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    bool doreflect=false;\n\n    float fresnel=0.;\n    fragColor=render(camera,ray,fresnel,doreflect);\n    if(doreflect){\n    float savefresnel=fresnel;\n    fragColor+=render(camera,ray,fresnel,doreflect)*pow(map01(.3,.7,savefresnel),3.);\n    }\n   //gamma correction\n    fragColor.r=lin2sRGB(fragColor.r);\n    fragColor.g=lin2sRGB(fragColor.g);\n    fragColor.b=lin2sRGB(fragColor.b);\n    \n    \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scSR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[445, 467, 486, 486, 633], [635, 635, 658, 658, 710], [713, 713, 757, 757, 808], [813, 813, 837, 837, 1116], [1118, 1179, 1229, 1229, 1372], [1374, 1374, 1407, 1407, 1475], [1478, 1478, 1498, 1498, 2434], [2438, 2438, 2463, 2463, 2680], [2682, 2682, 2712, 2712, 3177], [3179, 3179, 3239, 3239, 3653], [3655, 3655, 3674, 3674, 3708], [3710, 3710, 3729, 3729, 3790], [3793, 3793, 3843, 3843, 4558], [4562, 4562, 4645, 4645, 5122], [5127, 5127, 5184, 5184, 6144]], "test": "untested"}
{"id": "7scXWH", "name": "Rain - 1", "author": "1rosehip", "description": "rain", "tags": ["rain"], "likes": 5, "viewed": 59, "published": "Public", "date": "1633027485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define NUM_LAYERS 5.0\n\n/**\n * create a rotation matrix for the given angle in radians\n */\nmat2 getRotationMatrix(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s,\n                s, c);\n}\n\n/**\n * random that returns float in range [0.0, 1.0]\n */\nfloat random(vec2 pos) {\n    pos = fract(pos * vec2(123.34, 456.21));\n    pos += dot(pos, pos + 45.32);\n    return fract(pos.x * pos.y);\n}\n\n/**\n * scale a range [min,max] to [a,b]\n * f(x) = (b-a)*(x - min)/(max - min) + a\n */\nfloat convertRange(float minimal, float maximal, float a, float b, float x){\n    return (b-a)*(x - minimal)/(maximal - minimal) + a;\n}\n\n/**\n * draw a drop :)\n */\nfloat createDrop(vec2 uv, float width) {\n    \n    float soft = 0.0; //width / 0.5;\n\n    // draw a centered vertical line\n    float drop = smoothstep(0.5 + width, 0.5 + width + soft, uv.x) + smoothstep(uv.x, uv.x + soft, 0.5 - width);\n\n    drop = (1.0 - drop) * (step(0.5, uv.y));\n\n    // make it white\n    return drop;\n}\n\nvec3 createLayer(vec2 uv){\n    \n    vec3 result = vec3(0);\n\n    // create multiple copies of the screen\n    vec2 copies = fract(uv);\n    vec2 index = floor(uv);\n\n    // create a drop\n    float drop = createDrop(copies, 0.005);\n\n    // create a random color\n    float rnd = random(index);\n    vec3 randomColor = sin(vec3(0.349, 0.4039, 1.0) * rnd);\n    \n    // set drop color\n    result = mix(result, randomColor, drop);\n\n    return result;\n}\n\n/*\nfunction easeOutQuart(x: number): number {\n    return 1.0 - pow(1.0 - x, 4.0);\n}   \n*/\n\n/**\n * entry point\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // normalize coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime * 3.0;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // set background color\n    vec3 color = mix(col, vec3(0.0), sqrt(uv.y));\n\n    // rotate the rain ;)\n    mat2 matr = getRotationMatrix(10.0 * 3.14 / 180.0);\n    uv = (matr * (uv - 0.5)) + 0.5;\n\n    for(float i=0.0; i<1.0; i += 1.0 / NUM_LAYERS) {\n        float depth = fract(i) + 0.5;\n\n        // make depth in the required range\n        float scale = mix(15.0, 5.0, depth);\n\n        // create one time\n        vec2 bbb = vec2(0.0, time * depth);\n        vec3 layer = createLayer((uv + bbb) * scale);\n        color = mix(color, vec3(1.0, 1.0, 1.0), layer);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 137, 174, 174, 275], [277, 334, 358, 358, 472], [474, 560, 636, 636, 694], [696, 722, 762, 762, 1042], [1044, 1044, 1070, 1070, 1485], [1578, 1601, 1657, 1686, 2459]], "test": "untested"}
{"id": "7sd3DS", "name": "4d perlin noise", "author": "Sprocket", "description": "Demo of a 4d perlin noise function", "tags": ["perlinnoise", "4d"], "likes": 1, "viewed": 72, "published": "Public", "date": "1630606188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------- From https://www.shadertoy.com/view/4djSRW -------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 random_gradient(vec4 vector)\n{\n    return hash44(vector) * 2.0 - 1.0;\n}\n\nfloat perlin_noise(vec4 point)\n{\n    vec4 gridCell = floor(point);\n    vec4 local = point - gridCell;\n\n    vec4 weight = local * local * (3.0 - 2.0 * local);\n\n    return mix(//W\n        mix(//w0 z\n            mix(//w0 z0 y\n                mix(//w0 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,0),\n                        random_gradient(gridCell + vec4(0,0,0,0))),\n                    dot(\n                        local - vec4(1,0,0,0),\n                        random_gradient(gridCell + vec4(1,0,0,0))),\n                    weight.x),\n                mix(//w0 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,0),\n                        random_gradient(gridCell + vec4(0,1,0,0))),\n                    dot(\n                        local - vec4(1,1,0,0),\n                        random_gradient(gridCell + vec4(1,1,0,0))),\n                    weight.x),\n                weight.y),\n            mix(//w0 z1 y\n                mix(//w0 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,0),\n                        random_gradient(gridCell + vec4(0,0,1,0))),\n                    dot(\n                        local - vec4(1,0,1,0),\n                        random_gradient(gridCell + vec4(1,0,1,0))),\n                    weight.x),\n                mix(//w0 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,0),\n                        random_gradient(gridCell + vec4(0,1,1,0))),\n                    dot(\n                        local - vec4(1,1,1,0),\n                        random_gradient(gridCell + vec4(1,1,1,0))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        mix(//w1 z\n            mix(//w1 z0 y\n                mix(//w1 z0 y0 x\n                    dot(\n                        local - vec4(0,0,0,1),\n                        random_gradient(gridCell + vec4(0,0,0,1))),\n                    dot(\n                        local - vec4(1,0,0,1),\n                        random_gradient(gridCell + vec4(1,0,0,1))),\n                    weight.x),\n                mix(//w1 z0 y1 x\n                    dot(\n                        local - vec4(0,1,0,1),\n                        random_gradient(gridCell + vec4(0,1,0,1))),\n                    dot(\n                        local - vec4(1,1,0,1),\n                        random_gradient(gridCell + vec4(1,1,0,1))),\n                    weight.x),\n                weight.y),\n            mix(//w1 z1 y\n                mix(//w1 z1 y0 x\n                    dot(\n                        local - vec4(0,0,1,1),\n                        random_gradient(gridCell + vec4(0,0,1,1))),\n                    dot(\n                        local - vec4(1,0,1,1),\n                        random_gradient(gridCell + vec4(1,0,1,1))),\n                    weight.x),\n                mix(//w1 z1 y1 x\n                    dot(\n                        local - vec4(0,1,1,1),\n                        random_gradient(gridCell + vec4(0,1,1,1))),\n                    dot(\n                        local - vec4(1,1,1,1),\n                        random_gradient(gridCell + vec4(1,1,1,1))),\n                    weight.x),\n                weight.y),\n            weight.z),\n        weight.w);\n}\n\nfloat noise(vec3 point)\n{\n    return perlin_noise(vec4(point, iTime)) * 0.5 + 0.5;\n}\n\nfloat sample_point(vec3 point)\n{\n    return noise(point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = vec3(sample_point(vec3(uv * 8., iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sd3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 102, 102, 239], [241, 241, 276, 276, 317], [319, 319, 351, 351, 3565], [3567, 3567, 3592, 3592, 3651], [3653, 3653, 3685, 3685, 3712], [3714, 3714, 3771, 3821, 4012]], "test": "untested"}
{"id": "7sd3zf", "name": "_____", "author": "Youko_Hidemitsu", "description": "asas", "tags": ["ass"], "likes": 5, "viewed": 98, "published": "Public", "date": "1630461928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define bridthness 1.2\n\nvec3 point(float dist, float phase, float speed){\n    float r = abs(cos(radians(iTime*speed + phase)))*1.5/dist ;\n    float g = abs(cos(radians(iTime*speed+90. + phase)))*1.25/dist;\n    float b = abs(cos(radians(iTime*speed+45. + phase)))*2./dist;\n    return vec3(r, g, b);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy/2.;\n    \n    vec3 col = vec3(0.,0.,0.);\n    for(float i = 0.; i < 21.; i++){\n        col += point(\n            distance(fragCoord.xy, iResolution.xy/2. + i*10.),\n            i*18.f,\n            48.f\n        );\n    }\n    \n    for(float i = 0.; i < 21.; i++){\n        col += point(\n            distance(fragCoord.xy, iResolution.xy/2. + vec2(i*10., 0.)),\n            i*18.f,\n            -48.f\n        );\n    }\n    \n     for(float i = 0.; i < 21.; i++){\n        col += point(\n            distance(fragCoord.xy, iResolution.xy/2. + vec2(200., i*10.)),\n            i*18.f,\n            -48.f\n        );\n    }\n    \n    fragColor = vec4(col/bridthness, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sd3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 73, 73, 299], [303, 303, 360, 360, 1055]], "test": "untested"}
{"id": "7sdGRl", "name": "Project2 :)", "author": "oaisa", "description": "description", "tags": ["project"], "likes": 2, "viewed": 39, "published": "Public", "date": "1630635945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float zoom = cos(iTime)*5.0+2.5;\n    vec2 uv = fragCoord.xy/iResolution.xy*zoom-zoom/2.0;\n    float n = cos(0.03*iTime)*4.0+4.0;\n    float d = sin(0.03*iTime)*4.0+4.0;\n    \n    float r = 0.0;\n    float a = 3.0;\n    float x = 0.0;\n    float theta = atan(uv.y, uv.x);\n    \n    for(int i=0; i<15; i++) {\n        r = a*(cos(n/d*theta));\n        theta += PI *2.0;\n        float temp = abs(length(uv) - r);\n        x += 1.0 - smoothstep(-3.5,3.5, temp / fwidth(length(uv) - r));       \n    }\n   \n    fragColor.r = sin(x*7.0+sin(iTime*0.8))*.5+.5;\n    fragColor.g = sin(x*7.0+sin(iTime*0.6))*.5+.5;\n    fragColor.b = sin(x*7.0+sin(iTime*0.6))*.5+.5;\n    \n    fragColor.rgb = vec3(fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 774]], "test": "untested"}
{"id": "7sdGWf", "name": "powerpuff heart", "author": "charstiles", "description": "made this really quickly for my friends birthday card, \nbasically all credited barrowed stuff, heart equation is from iq comment https://www.shadertoy.com/view/XdcyW8\ncould be better, but im just throwing this up ", "tags": ["sdf", "heart", "powerpuff"], "likes": 0, "viewed": 110, "published": "Public API", "date": "1630796764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm \nvec3 cosPalette( float t , vec3 brightness, vec3 contrast, vec3 osc, vec3 phase)\n{\n\n    return brightness + contrast*cos( 6.28318*(osc*t+phase) );\n} \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \n    //vec2 uv = squareFrame(iResolution.xy, fragCoord);\n\n    vec2 uv = fragCoord/iResolution.xy * 2.0 -1.;\n    uv *=2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    // heart equation from a comment from iq https://www.shadertoy.com/view/XdcyW8\n    //https://www.wolframalpha.com/input/?i=%28x%5E2%2B%281.2*y-sqrt%28abs%28x%29%29%29%5E2%E2%88%921%29+%3D+0+for+-1.5+%3C+x+%3C+1.5%2C+-1.5+%3C+y+%3C+1.5\n    vec3 heart = vec3((pow(abs(uv.x),2.)+pow(abs(1.2*uv.y-sqrt(abs(uv.x))),2.)-1.) );\n    vec3 brightness = vec3(0.8);\n    vec3 contrast = vec3(0.15,0.1,0.3);\n    // the numbers that divide time are pretty arbitrary, as long as they are not the same and are somewhere between 10-100 id say it gives the desired effect\n    vec3 osc = vec3(0.1,cos(iTime/13.),cos(iTime/11.));\n    vec3 phase = vec3(0.2,0.5,0.1);\n    vec3 col = cosPalette(heart.x/3., brightness, contrast, osc, phase);\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 67, 149, 149, 215], [219, 219, 274, 332, 1212]], "test": "untested"}
{"id": "7sdGWX", "name": "Goop?", "author": "PrenexNormalForm", "description": "Goop?\nclick to see the points around which the goop is centered", "tags": ["2d"], "likes": 0, "viewed": 66, "published": "Public", "date": "1630785554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fade( float holdDuration0, float holdDuration1, float transitionDuration, float time ) {\n    float pi = 3.1415926535897932384626433832795;\n    \n    time = mod(time, (holdDuration0 + holdDuration1 + 2. * transitionDuration));\n    \n    if (time < holdDuration0) {\n        return 0.;\n    } else if (time < holdDuration0 + transitionDuration) {\n        return 0.5 * (1. - cos((time - holdDuration0) * pi / transitionDuration));\n    } else if (time < holdDuration0 + transitionDuration + holdDuration1) {\n        return 1.;\n    } else {\n        return 0.5 * (1. + cos((time - holdDuration0 - transitionDuration - holdDuration1) * pi / transitionDuration));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pi = 3.1415926535897932384626433832795;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 pos = vec2(uv.x * iResolution.x / iResolution.y, uv.y);\n    vec2 center = vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    //float time = 1.;\n    float time = iTime;\n    \n    float r1 = 0.08;\n    float r2 = 0.06;\n    float r3 = 0.04;\n    float r4 = 0.1;\n    float r5 = 0.04;\n    float r6 = 0.05;\n    //float rMouse = 0.1;\n    \n    vec2 v1 = vec2(cos(time * sqrt(2.0)) * 0.7, 0.0) + center;\n    vec2 v2 = vec2(0.0, sin(time) * (0.5 - 2.0 * r2)) + center;\n    vec2 v3 = vec2(cos(time) * 0.6, sin(time) * 0.3) + center;\n    vec2 v4 = vec2(cos(time * 0.2) * (center.x - r4) * 0.8, sin(time * 2.5) * 0.3) + center;\n    vec2 v5 = vec2(cos(time * 5. / pi) * 0.3 - 0.3, sin(time * 5. / pi) * 0.3) + center;\n    vec2 v6 = vec2(cos(time * 6. / pi) * 0.3 + 0.3, -sin(time * 6. / pi) * 0.3) + center;\n    //vec2 vMouse = iMouse.xy / iResolution.yy;\n    \n    float d1 = distance(pos, v1);\n    float d2 = distance(pos, v2);\n    float d3 = distance(pos, v3);\n    float d4 = distance(pos, v4);\n    float d5 = distance(pos, v5);\n    float d6 = distance(pos, v6);\n    //float dMouse = distance(pos, vMouse);\n    \n    float field =  1. / (r1 / d1 + r2 / d2 + r3 / d3 + r4 / d4 + r5 / d5 + r6 / d6);\n    \n    float circWidth = 0.003;\n    \n    //Anti-aliasing\n    float inGoop = 1. - smoothstep(1. - 2. * fwidth(field), 1., field);\n    \n    vec3 color;\n    \n    //rainbow\n    if (iMouse.z > 0.5) {\n        float sCurve = 0.5 * (1. - cos(field * pi));\n\n        vec3 magenta = vec3(1., 0., 1.);\n        vec3 blue = vec3(0., 0., 1.);\n        vec3 cyan = vec3(0., 1., 1.);\n        vec3 green = vec3(0., 1., 0.);\n        vec3 yaller = vec3(1., 1., 0.);\n        vec3 rot = vec3(1., 0., 0.);\n        float interpVal = mod(sCurve, 0.2) * 5.;\n        vec3 colorRainbow;\n        if (sCurve < 0.2) {\n            colorRainbow = mix(rot, yaller, sCurve * 5.);\n        } else if (sCurve < 0.4) {\n            colorRainbow = mix(yaller, green, (sCurve - 0.2) * 5.);\n        } else if (sCurve < 0.6) {\n            colorRainbow = mix(green, cyan, (sCurve - 0.4) * 5.);\n        } else if (sCurve < 0.8) {\n            colorRainbow = mix(cyan, blue, (sCurve - 0.6) * 5.);\n        } else {\n            colorRainbow = mix(blue, magenta, (sCurve - 0.8) * 5.);\n        }\n        color = colorRainbow * inGoop;\n    } else {\n    \n        //non-rainbow\n        // old colors without gamma correction\n        //vec3 goopThickColor = vec3(1., 0.8, 0.9);\n        //vec3 goopThinColor = (vec3(0.25, 1., 1.) + goopThickColor) * 0.5;\n        vec3 goopThickColor = vec3(0.9, 0.4, 0.7);\n        vec3 goopThinColor = (vec3(0.2, 0.8, 0.8));\n        float circleQuadrant = sqrt(1.-field*field);\n        vec3 colorNonRainbow = mix(goopThinColor, goopThickColor, circleQuadrant);\n        color = colorNonRainbow * inGoop;\n    }\n    \n    //float rainbowFade = fade(10.0, 1.0, 0.5, iTime);\n    //vec3 color = mix(colorNonRainbow, colorRainbow,  rainbowFade) * inGoop;\n    \n    //gamma correction\n    //like this really needs it\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, inGoop);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 665], [668, 668, 725, 725, 3943]], "test": "untested"}
{"id": "7sdSz7", "name": "Neyret's Northern Code Golf", "author": "TEttinger", "description": "This nice amorphous blob of color is the result of a comment by Fabrice Neyret on my Northern Elves shader ( https://www.shadertoy.com/view/fsdSRH ). It is different from Elves, but still very nice.", "tags": ["noise", "plasma", "lights", "golf", "northern", "elves"], "likes": 6, "viewed": 104, "published": "Public", "date": "1632902907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define H(s,v)   sin( s + (v).zxy - cos(s.zxy + (v).yzx) + cos(s.yzx + v) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = U/8. + sin(iTime);\n    \n    vec3 d = vec3(11.1, 14.3, 8.2),\n         t = iTime/d,\n         v = (U.x * H( vec3(2,6,4), t - d.yzx)\n                + U.y * H( vec3(3,7,5), t + d    )\n                ) /4.,\n         K = vec3(3,5,6);\n    \n    O.rgb = H(3.+K,((v+H(K,v))/2. +H(1.62+K, (v+H(K,v))/2. ) *3.)) * .5 + .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdSz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 115, 115, 437]], "test": "untested"}
{"id": "7sdXRH", "name": "Glacial valleys v2", "author": "jarble", "description": "A mountain terrain based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "ice", "snow", "mountain", "erosion"], "likes": 4, "viewed": 181, "published": "Public API", "date": "1632677701", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.5;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = noise(uv*freq) -n1*value*amplitude;\n        //n1 = noise(uv*freq+n1/2.);\n        //n1 = noise(uv * freq)-n1;\n        //float n1 = noise(uv * freq+noise(uv1));\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n1-1.) * amplitude);\n        \n        amplitude *= 1./5.+1./(5.-value);\n        \n        freq *= 2.05;\n        //uv1 = uv*freq;\n\n        uv = uv.yx-(n1*(amplitude)-n1/freq);\n        //uv = uv.yx-vec2(n1*(amplitude)-n1/freq,n1/freq);\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,OCTAVES+2);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,4)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 79], [100, 100, 135, 184, 873], [875, 875, 897, 897, 927], [929, 929, 959, 959, 1009], [1011, 1011, 1031, 1031, 1085], [1087, 1087, 1120, 1120, 1314], [1316, 1316, 1383, 1383, 1601], [1603, 1603, 1655, 1655, 2200], [2202, 2202, 2253, 2253, 2454], [2456, 2456, 2482, 2482, 2558], [2627, 2627, 2684, 2684, 4644]], "test": "untested"}
{"id": "7sdXz7", "name": "Simple circles", "author": "mrange", "description": "License CC0: Simple circle tiling\nBeen working too much lately to do shader stuff.\nBut today I experimented a bit with tiling so thought I share", "tags": ["2d"], "likes": 3, "viewed": 103, "published": "Public API", "date": "1632903320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Simple circle tiling\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Hexler, found: Kodelife example Grid\nfloat hash(vec2 uv) {\n  return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat df(vec2 p, out float n, out float sc) {\n  vec2 pp = p;\n  \n  float sz = 2.0;\n  \n  float r = 0.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    vec2 nn = mod2(pp, vec2(sz));\n    sz /= 3.0;\n    float rr = hash(nn+123.4);\n    r += rr;\n    if (rr < 0.5) break;\n  }\n  \n  float d = circle(pp, 1.25*sz);\n  \n  n = fract(r);\n  sc = sz;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  p += r*vec2(cos(a), sin(a));\n  p *= ROT(-a+0.25);\n  float n = 0.0;\n  float sc = 0.0;\n  float d = df(p, n, sc)*z;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3(n-0.25*d/sc, 0.5+0.5*d/sc, 1.0);\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXz7.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[334, 486, 508, 508, 654], [656, 950, 981, 981, 1007], [1009, 1095, 1131, 1131, 1225], [1227, 1293, 1314, 1314, 1382], [1384, 1384, 1429, 1429, 1722], [1724, 1811, 1847, 1891, 2162], [2164, 2164, 2219, 2219, 2762]], "test": "untested"}
{"id": "7sdXz8", "name": "Vanes", "author": "1rosehip", "description": "Rectangles rotating around the left top corner.", "tags": ["rotation", "vanes"], "likes": 1, "viewed": 21, "published": "Public", "date": "1632669935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * create a rotation matrix for the given angle in radians\n */\nmat2 getRotationMatrix(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s,\n                s, c);\n}\n\n\n/**\n draw a rectangle\n*/\nvec3 rect(vec2 position, vec2 center, vec2 anchor, vec2 size) {\n    vec3 color = vec3(1.0, 1.0, 1.0);\n\n    vec2 pos = position - center;\n\n    float halfW = size.x / 2.0;\n    float halfH = size.y / 2.0;\n\n    color *= step(-halfW - anchor.x, pos.x) - step(halfW - anchor.x, pos.x);\n    color *= step(-halfH - anchor.y, pos.y) - step(halfH - anchor.y, pos.y);\n    \n    return color;\n}\n\n/**\n * draw a stick\n */\nvec3 stick(vec2 position, vec2 center){\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec2 pos = position - center;\n    \n    float lineSize = 0.005;\n    float verticalLine = smoothstep(lineSize, lineSize + lineSize / 2.0, abs(pos.x + 0.1 * sin(5.0 * pos.y)));\n    color *= 1.0 - (1.0 - verticalLine) * (smoothstep(0.1, 0.0, pos.y));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y - vec2(0.5, 0.0);\n    uv = mod(uv, 1.0);\n    \n    vec3 color = vec3(0.31, 0.02, 0.37);\n\n    vec2 center = vec2(0.5, 0.5);\n    mat2 mat = getRotationMatrix((iTime + uv.x));\n    vec2 pos = mat * (uv - center) + center;\n\n    // stick\n    color = mix(vec3(0.5922, 0.4078, 0.6), color, stick(uv, center));\n    vec2 size = vec2(0.4, 0.2);\n    \n    vec3 rect1 = rect(pos, center, -size / 2.0, size);\n    color = mix(color, vec3(1.0, 0.8549, 0.9765), rect1);\n\n    vec3 rect2 = rect(pos, center, vec2(size.y, -size.x) / 2.0, size.yx);\n    color = mix(color, vec3(0.8549, 0.9608, 1.3), rect2);\n\n    vec3 rect3 = rect(pos, center, size / 2.0, size);\n    color = mix(color, vec3(0.8549, 1.0, 0.9451), rect3);\n\n    vec3 rect4 = rect(pos, center, vec2(-size.y, size.x) / 2.0, size.yx);\n    color = mix(color, vec3(0.9961, 1.0, 0.8549), rect4);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdXz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 104, 104, 205], [208, 233, 296, 296, 614], [616, 640, 679, 679, 989], [991, 991, 1048, 1048, 1953]], "test": "untested"}
{"id": "7sG3D1", "name": "simple move moon", "author": "huataishi", "description": "just study", "tags": ["moon"], "likes": 9, "viewed": 340, "published": "Public", "date": "1631460878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"simple move  moon\" \n// \"by huataishi\"\n\n#define PI 3.1415\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,b) S(x, x+b, z)*S(y+b, y, z)\n#define saturate(x) clamp(x,0.,1.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\n#define MOONPOS vec2(1, .8)\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel1, p*1.00 ).x + \n           0.2500*texture( iChannel1, p*2.02 ).x + \n           0.1250*texture( iChannel1, p*4.03 ).x + \n           0.0625*texture( iChannel1, p*8.04 ).x;\n}\n//----------------------------------------------------------------------------------------\n\n//  1 out, 2 in...\nfloat hash(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 moon(vec3 col,vec2 fragCoord) {\n    float t = iTime -floor(iTime/60.)*60.;\n    vec2 p = (2.*fragCoord) / iResolution.y;\n       \n    float f = fbm( 0.002*vec2(p.x,1.0)/p.y );\n     \n   p -= (sin(t/120.)/.3);\n   p.x -= t/40.;\n    // moon\n    float d = length(p);\n    vec3 moon = vec3(0.98,0.97,0.95)*(1.0-0.1*smoothstep(0.2,0.5,f));\n    col += 0.8*moon*exp(-4.0*d)*vec3(1.1,1.0,0.8);\n    col += 0.2*moon*exp(-2.0*d);\n    moon *= 0.85+0.15*smoothstep(0.25,0.7,fbm(0.08*p+0.3));\n    col = mix( col, moon, 1.0-smoothstep(0.2,0.215,d) );\n    \n    \n    return vec4(col,1.);\n}\n\n\nfloat stars(vec2 uv, float t) {\n    \n    float n1 = hash(uv*10000.);\n    float n2 = hash(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime/7.;\n     \n    vec4 col = vec4(.1,.15,.2,1.);\n    col += stars(uv, t);\n    col = moon(col.xyz,fragCoord);\n \n    \n    fragColor = vec4(col);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 246, 267, 267, 475], [568, 587, 607, 607, 723], [725, 725, 761, 761, 1297], [1300, 1300, 1331, 1331, 1666], [1668, 1668, 1725, 1725, 1928]], "test": "untested"}
{"id": "7sG3Wh", "name": "wallpaper_moon", "author": "Antoine54652", "description": ".", "tags": ["moon"], "likes": 10, "viewed": 129, "published": "Public", "date": "1631815248", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur){\n    //wb = long bas, wt = long haut, yb = espacement entre le bas et le milieu, yt = espacement entre le haut et le milieu\n    float m = S(-blur, blur, p.y - yb);\n    m *= S(blur, -blur, p.y - yt);\n    \n    p.x = abs(p.x);\n    \n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= S(blur, -blur, p.x - w);\n    return m;\n}\n\nvec4 Tree(vec2 uv, vec3 col, float blur, float stage){\n    float m = TaperBox(uv, 0.03, 0.03, 0.0, 1.0/(stage+1.0), blur);\n    float shadow = 0.0;\n    \n    for(float i = 1.0; i < (stage+1.0); i++){\n        m += TaperBox(vec2(uv.x, uv.y-1.0/(stage+1.0)), (stage-i)*0.05+0.1, (stage-i)*0.05, 1.0/(stage+1.0)*(i-1.0), 1.0/(stage+1.0)*i, blur);\n        vec2 _uv = uv;\n        if((int(i)%2)==0){\n            _uv -= vec2(0.25, 0);\n        }\n        else{\n            _uv += vec2(0.25, 0);\n        }\n        shadow += TaperBox(_uv, 0.1, 0.5, 1.0/(stage+1.0)*i-0.05, 1.0/(stage+1.0)*i, blur);\n    }\n    \n    col -= shadow * 0.8;\n    \n    return vec4(col, m);\n}\n\nfloat GetHeight(float x){\n    return sin(x*0.494)+sin(x)*0.3;\n}\n\nvec4 Layer(vec2 uv, float blur){\n    vec4 col = vec4(0);\n    \n    float id = floor(uv.x);\n    float n = fract(sin(id*532.45)*5541.21)*2.0-1.0;\n    float x = n*0.3;\n    float y = GetHeight(uv.x);\n    float ground = S(blur, -blur, uv.y+y);\n    col += ground;\n    \n    y = GetHeight(id+0.5+x);\n    uv.x = fract(uv.x)-0.5;\n    \n    vec4 tree = Tree((uv-vec2(x, -y-0.01))*vec2(1.0, 1.0+n*0.2), vec3(1.0), blur, float(int(3.5+sin(x)*3.0)));\n    col = mix(col, tree, tree.a);\n    col.a = max(ground, col.a);\n    return col;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(534.02, 964.547));\n    p += dot(p, p+531.154);\n    return fract(p.x*p.y);\n}\n\nfloat Stars(vec2 uv){\n    float v = TaperBox(uv * Rot(0.5) - vec2(-0.3, 0.1), 0.1, 0.1, -2.0, 0.5, 0.3);\n    return pow(Hash21(uv), 300.0/pow(v+1.0, 4.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec2 M = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    \n    float t = iTime*0.5;\n    \n    float blur;\n    \n    vec4 layer;\n    \n    vec4 col = vec4(0.0);\n    col += Stars(uv);\n    \n    float moon = S(0.01, -0.01, length(uv-vec2(0.4, 0.2))-0.15);\n    col *= 1.0-moon;\n    moon *= S(-0.01, 0.1, length(uv-vec2(0.48, 0.24))-0.15);\n    col += moon;\n    \n    for(float i = 0.0; i<1.0; i+=1.0/10.){\n        blur = mix(0.04, 0.001, i);\n        float scale = mix(30.0, 1.0, i);\n        layer = Layer(uv*scale+vec2(t+sin(i)*1354.2, i*2.0)-M, blur);\n        layer.rgb *= (1.0-i)*vec3(0.9, 0.9, 1.0);\n        \n        col = mix(col, layer, layer.a);\n    }\n    layer = Layer(uv+vec2(t, 1.5)-M, 0.07);\n\n    col = mix(col, layer*0.1, layer.a);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 58, 58, 120], [122, 122, 197, 320, 526], [528, 528, 582, 582, 1180], [1182, 1182, 1207, 1207, 1245], [1247, 1247, 1279, 1279, 1765], [1767, 1767, 1788, 1788, 1885], [1887, 1887, 1908, 1908, 2044], [2046, 2046, 2103, 2103, 2928]], "test": "untested"}
{"id": "7sG3Ww", "name": "Gamma Curve", "author": "mosan_hoshi", "description": "practice for 2d chart", "tags": ["2d", "chart"], "likes": 3, "viewed": 144, "published": "Public API", "date": "1631641155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// written by mossan-hoshi( https://twitter.com/mossan_hoshi )\n\n#define MAX_GAMMA  2.2\n#define MARGIN  0.1\n#define IN_OUT_COLOR cyan\n\nvoid drawLine(vec2 p1, vec2 p2){\n\n}\n\nfloat gamma_function(float x, float gamma){\n  return  pow(x,1.0/gamma);\n}\n \nvoid gamma_curve(vec2 uv, float gamma, inout vec4 fragColor){\n  if(abs(uv.y - gamma_function(uv.x,gamma)) < 0.002 ){\n      vec3 color = vec3(0.8,0.5,0.8);\n      fragColor=vec4(color,1.0);\n  }\n}\n\nvoid in_out_line(float x, vec2 uv, float gamma, inout vec4 fragColor){\n  if((uv.y < gamma_function(x,gamma)&&(abs(uv.x - x) < 0.002))){\n      vec3 color = vec3(0.5,0.8,0.8);\n      fragColor=vec4(color,1.0);\n  }else if((abs(uv.y - gamma_function(x,gamma)) < 0.002)&&(uv.x < x)){\n      vec3 color = vec3(0.5,0.8,0.8);\n      fragColor=vec4(color,1.0);\n  }\n}\n \nvoid in_out_wave(float x, float input_range, vec2 uv, float gamma, float iTime, inout vec4 fragColor){\n  float x_max = x+input_range;\n  float x_min = x-input_range;\n  float y_max = gamma_function(x_max,gamma);\n  float y_min = gamma_function(x_min,gamma);\n  float y = (y_min + y_max) / 2.;\n  if((uv.y < gamma_function(uv.x,gamma)&&(abs(uv.x - (x + input_range * cos(100. * uv.y - 10. *iTime))) < 0.004))){\n      vec3 color = vec3(0.2,0.6,0.6);\n      fragColor=vec4(color,1.0);\n  }else if((uv.y > gamma_function(uv.x,gamma))&&\n           (abs(uv.y - ( y + ((y_max - y_min)/2.0) * cos(100. * uv.x + 10. *iTime))) < 0.004)){\n      vec3 color = vec3(0.2,0.6,0.6);\n      fragColor=vec4(color,1.0);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const \n  // normalize position(x,y:.0~1.0)\n  vec2 uv= fragCoord.xy/ min(iResolution.x,iResolution.y);\n  uv = uv * (1.0 + (2. * MARGIN));\n  vec2 offset = ((iResolution.xy / min(iResolution.x,iResolution.y)) - 1.0)/2.0;\n  \n  // draw color tiles\n  if((uv.x >= offset.x+MARGIN)&&(uv.x <= (1.007 + offset.x+MARGIN))&&\n     (uv.y >= offset.y+MARGIN)&&(uv.y <= (1.007 + offset.y+MARGIN))){\n\n    // background\n    if((uv.x>offset.x+MARGIN)&&(uv.x<1.0 + offset.x+MARGIN)){\n      float value = 0.9;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // thin lines\n    if(((mod(uv.x-offset.x, MARGIN) < 0.002)&&(mod(uv.y-offset.y,0.005) < 0.002))||\n       ((mod(uv.y-offset.y, MARGIN) < 0.002)&&(mod(uv.x-offset.x,0.005) < 0.002))){\n      float value = 0.2;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // thick lines\n    if((mod(uv.x-offset.x-MARGIN,0.5) < 0.007)||(mod(uv.y-offset.y-MARGIN,0.5) < 0.007)){\n      float value = 0.2;\n      fragColor=vec4(value,value,value,1.0);\n    }\n\n    // gamma curve\n    float range = MAX_GAMMA - 1.0 / MAX_GAMMA;\n    float gamma = MAX_GAMMA + (range / 2.)*(cos(iTime) - 1.0);\n    gamma_curve(uv - offset - MARGIN, gamma, fragColor);\n\n    // lines\n    float line_x = 0.3;\n    float input_range = 0.1;\n    in_out_line(line_x - input_range, uv - offset - MARGIN, gamma,fragColor);\n    in_out_line(line_x + input_range, uv - offset - MARGIN, gamma,fragColor);\n\n    // wave \n   in_out_wave(line_x, input_range, uv - offset - MARGIN, gamma, iTime,fragColor);\n    \n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3Ww.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 134, 166, 166, 169], [171, 171, 214, 214, 244], [247, 247, 308, 308, 440], [442, 442, 512, 512, 796], [799, 799, 901, 901, 1496], [1498, 1498, 1554, 1602, 3066]], "test": "untested"}
{"id": "7sG3zd", "name": "snowflake lattice", "author": "pali6", "description": "It's the previous project but now all layers overlaid on top of each other and inverted pretty much.", "tags": ["tiling", "penrose"], "likes": 9, "viewed": 157, "published": "Public API", "date": "1631958550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DEPTH 21\n#define PHI ((1. + sqrt(5.)) / 2.)\n#define PI 3.141592653589\n//#define DEPTH int(round(16. - 7. * cos(iTime / 5.)))\n\n\n#define S(M, O) (0.5 + 0.5 * sin(O + M * pos.x)) / 6.\n#define C(M, O) (0.5 + 0.5 * cos(O + M * pos.y)) / 6.\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool onRight(vec2 a, vec2 b, vec2 x)\n{\n    return cross(vec3(a - b, 0), vec3(x - b, 0)).z > 0.;\n}\n\nfloat cr(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat cr(vec2 a, vec2 b, vec2 c)\n{\n    return cr(b - a, c - b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = fragCoord / iResolution.xx;\n    \n    float scale = 72. + 18. * sin(iTime / 10.) + 20. * sin(4. + iTime / 15.) + 30. * sin(iTime / 6.);\n    vec2 camPos = vec2(0.5, 0.5);\n    float SF = 1. / pow(scale, 0.3);\n    camPos += vec2(0.02 * sin(iTime / 15.), -0.07 * cos(iTime / 19.)) * SF;\n    camPos += vec2(-0.1 * sin(3. + iTime / 37.), -0.1 * cos(4. + iTime / 27.)) * SF;\n    camPos += vec2(0.07 * sin(9. + iTime / 47.), -0.08 * cos(20. + iTime / 31.)) * SF;\n    camPos += vec2(0.04 * sin(19. + iTime / 7.), 0.06 * cos(25. + iTime / 5.)) * SF;\n    \n    pos -= vec2(0.5, 0.5);\n    pos = rotate(pos, iTime / 30. + PI * cos(iTime / 37.) + 2. * PI * sin(iTime / 87. + 10.));\n    pos /= scale;\n    pos += camPos;\n    \n    vec2 ota = vec2(-1., 0.);\n    vec2 otb = vec2(2., 0.);\n    \n    vec2 ta = ota;\n    vec2 tb = otb;\n    vec2 tc;\n    bool gn = true;\n    float fl = -1.;\n    \n    float f = 0.;\n    \n    // vec2 otc;\n    \n    float nDark = 0.;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        vec2 next;\n        if(gn)\n            tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n        else\n            tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n            \n        if(!(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n          !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5))\n        {\n            nDark += 1.;\n        }\n        \n        \n        if(gn)\n        {\n            next = tb + (ta - tb) / PHI;\n            if(abs(cr(next, tc, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(next, tc, pos) * cr(next, tc, tb) > 0.)//onRight(next, tc, pos))\n            {\n                gn = false;\n                ta = next;\n                tb = tc;\n                fl *= -1.;\n                i--;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        else\n        {\n            next = tc + (tb - tc) / PHI;\n            if(abs(cr(ta, next, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(ta, next, pos) * cr(ta, next, tb) > 0.)//onRight(ta, next, pos))\n            {\n                gn = false;\n                ta = tb;\n                tb = next;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        //if(i == 0)\n        //    otc = tc;\n    }\n    /*\n    fragColor =\n        (1. - nDark / float(DEPTH)) * vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        ) * 1.8 +\n        (nDark / float(DEPTH)) * vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n    */\n    fragColor =\n        (nDark / float(DEPTH)) * vec4(\n            0.10 + S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.) + S(1., 42.) + C(1.5, 73.),\n            0.10 + C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.) + S(1.2, 49.) + C(0.9, 79.),\n            0.15 + S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.) + S(0.7, 13.) + C(0.11, 31.),\n            1.\n        ) * 1.5;\n\n    /*\n    if(gn)\n        tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n    else\n        tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n    \n    if(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n      !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5)\n    {\n        fragColor = vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        );\n    }\n    else\n        fragColor = vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n        */\n    \n    // if(f > 0.) fragColor = vec4(1, 0, 0, 1);\n    \n    /*\n    if(length(uv - ota) <= 0.01)\n        fragColor += vec4(0.5, -0.5, -0.5, 0.0);\n    if(length(uv - otb) <= 0.01)\n        fragColor += vec4(-0.5, 0.5, -0.5, 0.0);\n    if(length(uv - otc) <= 0.01)\n        fragColor += vec4(-0.5, -0.5, 0.5, 0.0);\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sG3zd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 244, 274, 274, 358], [360, 360, 398, 398, 457], [459, 459, 485, 485, 521], [523, 523, 557, 557, 588], [590, 590, 645, 645, 5258]], "test": "untested"}
{"id": "7sGGWD", "name": "дед инсайд маус", "author": "nikitakrutoy", "description": "CG course sdf practice", "tags": ["sdf", "trip"], "likes": 3, "viewed": 61, "published": "Public", "date": "1631566901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat prism(vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.7+p.y*0.3,-p.y)-h.x*0.5);\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat smax ( float a, float b, float k )\n{\n\tfloat res = exp ( k*a ) + exp ( k*b );\n\treturn log ( res ) / k;\n}\n\n\nfloat scene_eyes(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    float k = min(\n        sphere(q, vec3(0.45, -0.7, 0.2), 0.3),\n        sphere(q, vec3(-0.45, -0.7, 0.2), 0.3)\n    );\n    return k;\n}\n\n\nfloat scene_head(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    \n    // prism transform\n    vec3 q2 = q + vec3(0., 1.6, 1.);\n    mat3 m2 = rotateY(PI / 2.) * rotateZ(PI / 180. * 30.);\n    q2 *= m2;\n    \n    float k = max(\n        -prism(q2, vec2(1., 1.5)),\n        sphere(q, vec3(0., 0., 0.), 1.)\n    );\n    \n    // ear radius\n    float a = 2.;\n    // ear thickness\n    float d = 0.2;\n    \n    vec3 ear_position1 = vec3(-1.1, 0, 1.0);\n    vec3 ear_position2 = vec3(1.1, 0, 1.0);\n        \n    float s1 =  smax(\n        -sphere(q,ear_position1 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position1, 1.), 10.0\n    );\n        \n    float s2 = smax(\n        sphere(q, ear_position1 + vec3(0., -a + d, 0.), a),\n        s1, 10.0\n    );\n    \n    float s3 =  smax(\n        -sphere(q,ear_position2 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position2, 1.), 10.0\n    );\n        \n    float s4 = smax(\n        sphere(q, ear_position2 + vec3(0., -a + d, 0.), a),\n        s3, 10.0\n    );\n    \n    \n    return min(s4, min(s2, k));\n}\n\n\nfloat scene(vec3 pos, mat3 m, int n) {\n    float dist;\n    if (n == 0) {\n\n        dist = scene_head ( pos, m );\n    }\n    else {\n        dist = scene_eyes ( pos, m );\n    } \n    return dist;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, mat3 m, int n)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n    int stepNum = 70;\n\tfor ( int steps = 0; steps < stepNum; steps++ )\n\t{\n        float dist = scene(p, m, n);\n\n        p += dist * dir;\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, mat3 m, int n)\n{\n    float eps = 0.01;\n    float e   = max (d * 0.5, eps );\n    float dx1 = scene(z + vec3(e, 0, 0), m, n);\n    float dx2 = scene(z - vec3(e, 0, 0), m, n);\n    float dy1 = scene(z + vec3(0, e, 0), m, n);\n    float dy2 = scene(z - vec3(0, e, 0), m, n);\n    float dz1 = scene(z + vec3(0, 0, e), m, n);\n    float dz2 = scene(z - vec3(0, 0, e), m, n);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 background(vec2 uv) {\n    //source: https://www.shadertoy.com/view/Xt2BDG\n    \n    vec4 result = vec4(0,0,0,1);\n\n    float t = 1.;\n    float offset = -5. * iTime;\n    float base = 100. * length(uv);\n\n    float d = sin(-iTime + 15. * length(uv));\n    d *= d * d;\n\n    mat2 rot = rotate(5. * length(uv));\n    uv += .5;\n    \n    uv = abs(rot * uv);\n    \n    for (int p = 0; p < 3; p++)\n    {\n        result[p] = sin(offset + t * base) - cos(20. * uv.x) - cos(20. * uv.y);\n        t += 0.05;\n    }\n\n    result.xyz *= result.xyz;\n    result.xyz = 1. - result.xyz;\n    \n    return result * d;\n}\n\nvec3 lightPos = vec3(0, -6., 0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    mat3 m;\n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    if ( iMouse.z > 0.) {\n        m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x );\n    }\n    else {\n        m = mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n    \n    vec3 cameraPos = vec3(0.,-5., 0.);\n    vec3 cameraForward = vec3(0., 1, 0.);\n    vec3 cameraUp = vec3 (0., 0., 1.);\n    float cameraFocus = 5.;\n    \n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\n    \n    vec3 from = vec3(uv.x, (cameraPos + cameraForward * cameraFocus).z, uv.y);\n    vec3 dir = normalize(from - cameraPos);\n    \n    bool hit;\n    vec3 p1 = trace(cameraPos, dir, hit, m, 0);\n    float d1 = length(cameraPos - p1);\n     float c1 = length(p1);\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 surfaceColor = vec3(1., 1., 1.);\n    \n    vec4 col;\n    \n    if (hit) {\n\n       vec3 l = normalize(lightPos - p1);\n       vec3 n = generateNormal(p1, 0.001, m, 0);\n       vec3 v = normalize(cameraPos - p1);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n\n       col = 0.5*vec4 ( diffuse ) * vec4(1.0, 0.1, 0.4, 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n    else {\n       col = background(uv / 2.);\n    }\n   \n    vec3 p2 = trace(cameraPos, dir, hit, m, 1);\n    float d2 = length(cameraPos - p2);\n    float c2 = length(p2);\n\n    if (hit && (d2 < d1)) {\n\n       vec3 l = normalize(lightPos - p2);\n       vec3 n = generateNormal(p2, 0.001, m, 1);\n       vec3 v = normalize(cameraPos - p2);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n       \n       float t = abs(sin(70. * c2 + 20. * iTime) - 0.9);\n\n       col = 0.5 * vec4 ( diffuse ) * vec4(t, abs(t - 0.9), abs(t - 0.3), 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 198], [200, 200, 227, 227, 374], [377, 377, 404, 404, 551], [554, 554, 614, 614, 667], [669, 669, 699, 699, 781], [784, 784, 826, 826, 896], [899, 899, 941, 941, 1008], [1011, 1011, 1047, 1047, 1205], [1208, 1208, 1244, 1244, 2229], [2232, 2232, 2270, 2270, 2424], [2427, 2427, 2497, 2497, 2845], [2847, 2847, 2902, 2902, 3323], [3327, 3327, 3353, 3353, 3438], [3441, 3441, 3467, 3519, 4034], [4071, 4071, 4128, 4178, 6350]], "test": "untested"}
{"id": "7sGGWy", "name": "LGBT+ Flag", "author": "Ravbug", "description": "Generating the lgbt flag using hsv", "tags": ["animation", "flag", "hsv", "gay", "hsb", "lgbt"], "likes": 2, "viewed": 132, "published": "Public API", "date": "1632072531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// set to 0 to disable the waving animation\n#define WAVE 1\n\n// adjust the number of stripes\nconst float stripes = 6.0;\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n// linear value remap\nfloat remap(float value, float low1, float high1, float low2, float high2){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// step function w/ floor\nfloat stepf(float value,float steps){\n    return remap(floor(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// used to control position on the rainbow\nfloat hsbinfcufve(float x){\n    return pow(x,1.5);\n}\n\n// used to control brightness\nfloat b(float x){\n    return 1.0 - pow(x,3.0);\n}\n\n// prevent wraparound\nfloat clampInRange(float x){\n    return ((x >= 0.0 && x <= 1.0) ? x : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     #if WAVE\n     uv.y += (sin(10.0*(-iTime/3.0+uv.x))*0.03);\n     uv.y = clampInRange(uv.y);\n     #endif\n\n     // calculate where to sample on rainbow\n     float coord = hsbinfcufve(stepf(1.0-uv.y,stripes));\n     \n     // calculate color & brightness\n     vec3 resCol = hsb2rgb(vec3(coord,1.0,b(coord)));\n \n\n    // Output to screen\n    fragColor = vec4(resCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 194, 220, 220, 452], [455, 477, 552, 552, 622], [624, 650, 687, 687, 764], [766, 809, 836, 836, 861], [863, 893, 910, 910, 941], [943, 965, 993, 993, 1042], [1044, 1044, 1101, 1152, 1563]], "test": "untested"}
{"id": "7sGGWz", "name": "Gooey Lava Lamp", "author": "itslinaaaa", "description": "A gooey honey lava lamp, try clicking on different positions to change the gooeyness and the lighting", "tags": ["lava", "gooey"], "likes": 8, "viewed": 91, "published": "Public", "date": "1631323963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat sphereSDF ( vec3 position, vec3 center, float radius ) {\n    float distance = length(center - position) - radius;\n    return distance;\n}\n\nfloat planeSDF ( vec3 position, vec3 start, vec3 direction ) {\n    float distance = dot(position - start, direction );\n    return distance;\n}\n\n\nfloat smin(float k, float a, float b) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    float y = mix(a, b, h) - k*h*(1.0-h);\n    return y;\n}\n\n\nfloat SDF ( vec3 position ) {\n    // Add all of the walls\n    float ground = planeSDF(position, vec3(0, -10, 0), vec3(0, 1, 0));\n    float roof = planeSDF(position, vec3(0, 10, 0), vec3(0, -1, 0));\n    float left = planeSDF(position, vec3(-20, 0, 0), vec3(1, 0, 0));\n    float right = planeSDF(position, vec3(28, 0, 0), vec3(-1, 0, 0));\n    float back = planeSDF(position, vec3(0, 0, 50), vec3(0, 0, -1));\n    \n    // Add the spheres\n    float t = iTime / 5.0;\n    float s1 = sphereSDF(position, vec3(0, 0, 30) + vec3(5, 20, 3) * sin(t), 3.0);\n    float s2 = sphereSDF(position, vec3(-4, 0, 30) + vec3(0, 20, 0) * sin(3.2 * t), 2.0);\n    float s3 = sphereSDF(position, vec3(2, 0, 32) + vec3(5, 20, 0) * sin(2.16 * t), 1.0);\n    float s4 = sphereSDF(position, vec3(1, 0, 34) + vec3(0, 20, 2) * sin(2.86 * t), 2.1);\n    float s5 = sphereSDF(position, vec3(2, 0, 30) + vec3(0, 20, 0) * sin(3.46 * t), 2.3);\n    \n    // Blend everything together to make goo\n    float blend = iMouse.y == 0.0 ? 10.0 : iMouse.y/50.0;\n    float nearest = \n        // Blend the walls\n        smin( blend, ground,\n        smin( blend, roof,\n        smin( blend, left,\n        smin( blend, right,\n        smin( blend, back,\n        \n        // Blend the spheres\n        smin( blend, s1,\n        smin( blend, s2,\n        smin( blend, s3,\n        smin( blend, s4,\n        s5\n    )))))))));\n    return nearest;\n}\n\n\nvec3 getNormal ( vec3 p ) {\n    #define eps 0.0001\n    float dx = SDF(p + vec3(eps, 0, 0)) - SDF(p - vec3(eps, 0, 0));\n    float dy = SDF(p + vec3(0, eps, 0)) - SDF(p - vec3(0, eps, 0));\n    float dz = SDF(p + vec3(0, 0, eps)) - SDF(p - vec3(0, 0, eps));\n    vec3 approxGrad = vec3(dx, dy, dz);\n    vec3 normal = normalize(approxGrad);\n    return normal;\n}\n\n\n\nfloat raymarch ( vec3 start, vec3 direction ) {\n    // Take a number of steps in the right direction\n    #define maxSteps 100\n    float converged = 0.0001;\n    float distance = 0.0;\n    vec3 current = start;\n    for(int i=0; i < maxSteps;i++){;\n        // Find the minimum distance and move by that amount\n        float surfaceDistance = SDF(current);\n        if ( surfaceDistance < converged ) return distance;\n        \n        // Take a step by the given amount\n        distance += surfaceDistance;\n        current += surfaceDistance * direction;\n    }\n    return distance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 5, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = iMouse.x == 0.0 ? 0.6 : iMouse.x / iResolution.x;\n    vec3 specular = vec3(0.96, 0.74, 0.08);\n    vec3 diffuse = vec3(0.62, 0.46, 0.12);\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = getNormal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 0.5 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n    if ( brightness < 0.0 ) return diffuse;\n    vec3 color = brightness * specular * shadow + diffuse ;\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Get the UV coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Get the normalized coordinates and the ray position\n    vec3 camera = vec3(0.0, 0.0, -1.0-0.15*sin(iTime));\n    vec3 start = vec3(uv, 0.0);\n    vec3 direction = start - camera;\n\n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 65, 65, 145], [147, 147, 209, 209, 288], [291, 291, 330, 330, 438], [441, 441, 470, 498, 1824], [1827, 1827, 1854, 1854, 2183], [2187, 2187, 2234, 2287, 2764], [2767, 2767, 2799, 2837, 3755], [3760, 3760, 3817, 3847, 4474]], "test": "untested"}
{"id": "7sK3DR", "name": "Polygon Landscapes", "author": "byt3_m3chanic", "description": "Trying to master the art of placing items on a noise generated ground - and not float above or crash under. \n// also I guess I'm still tweaking this - lol, hard to put a shader down.", "tags": ["draftdiamondsancds"], "likes": 27, "viewed": 316, "published": "Public API", "date": "1631613280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Polygon Landsacpes\n    9/13/21 @byt3_m3chanic\n    \n    Putting stuff on the ground and making it look half \n    way natural is hard, beginning experiments with it.\n    \n    need better noise functions...\n    \n    Rock shape/object from @gaz https://twitter.com/gaziya5/status/1436924535463309318\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    65.\n#define MIN_DIST    .0005\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat hash21(vec2 p) {\n    // @Dave_Hoskins - Hash without sine\n    // but it's HEAVY compile time / sadly and it looks better..\n    // so using other low cost hash for now..\n    \n\t//vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //p3 += dot(p3, p3.yzx + 33.33);\n    //return fract((p3.x + p3.y) * p3.z);\n    return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); \n}\n\nfloat noise (in vec2 uv) {\n    // @morgan3d https://www.shadertoy.com/view/4dS3Wd\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1., 0.));\n    float c = hash21(i + vec2(0., 1.));\n    float d = hash21(i + vec2(1., 1.));\n    vec2 u = f;// * f * (3.-2.*f);  @Shane's tip for polygonized look..\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b)* u.x * u.y;\n}\n\n//generate terrain using above noise algorithm\nfloat fbm( vec2 p, float freq ) {\t\n\tfloat h = -1.5;\n\tfloat w = 2.50;\n\tfloat m = 0.25;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noise((p * m));\n\t\tw *= 0.5; m *= 2.0;\n\t}\n\treturn h;\n}\n\nfloat gaz( vec3 p, float s) {\n    float e = abs(p.x+p.y)+abs(p.y+p.z)+abs(p.z+p.x)+abs(p.x-p.y)+abs(p.y-p.z)+abs(p.z-p.x)-s;\n    return e/3.5;\n}\n\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat box(vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//http://mercury.sexy/hg_sdf/\nconst float angle = 2.*PI/6.;\nconst float hfang = angle*.5;\nvoid mpolar(inout vec2 p) {\n    float a = atan(p.y, p.x) + hfang;\n    float c = floor(a/angle);\n    a = mod(a,angle) - hfang;\n    p = vec2(cos(a), sin(a))*length(p);\n} \n\n//globals\nvec3 hitPoint,hit;\nvec2 gid,sid;\nfloat mvt = 0.,snh,gnh;\nmat2 turn,wts;\n\nconst float sz = .325;\nconst float hf = sz*.5;\nconst float db = sz *2.;\nconst float detail = 4.;\nconst float pwr = 1.75;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    p.y+=4.;\n    p.x+=mvt;\n    float ter = fbm(p.xz*sz,detail)*pwr;\n    float d2 = p.y - ter;\n    \n    if(d2<res.x) {\n       res = vec2(d2,2.);\n       hit=p;\n       gnh=ter;\n    }\n\n    vec2 id = floor(p.xz*sz) + .5;    \n    vec2 r = p.xz - id/sz;\n    vec3 q = vec3(r.x,p.y,r.y);\n    float hs = hash21(id);\n    float xtr = fbm(id,detail)*pwr;\n    vec3 qq=q-vec3(0,xtr+.2,0);\n\n    mat2 htn = rot(-hs*PI2);\n    qq.yz*= htn;\n    qq.xz*= htn;\n\n    float df = gaz(qq,4.5*hs*hs);\n    if(df<res.x && hs>.5 && xtr>1.75) {\n        res=vec2(df,3.);\n        hit=p;\n        gnh=xtr;\n        gid=id;\n    }\n    \n    float zz = 1.25;\n    vec2 fid = floor(p.xz*zz) + .5;    \n    vec2 fr = p.xz - fid/zz;\n    vec3 fq = vec3(fr.x,p.y,fr.y);\n    \n    hs = hash21(fid);\n    qq=fq-vec3(0,ter+.001,0);\n\n    mpolar(qq.xz);      \n    float adjust = sin(qq.x*12.);\n    float flwr= box(qq,vec3(.3,smoothstep(.01,.35,.035*adjust),.035*adjust));\n    if(flwr<res.x && hs<.1 ) {\n        res=vec2(flwr,4.);\n        hit=qq;\n        gnh=ter;\n        gid=fid;\n    }\n\n    float cells = 8.;\n    vec3 qz = p-vec3(mvt,7.25,0);\n    qz.xz*=turn;\n    // Polar Repetion \n    // @Shane showed me this in one of my first\n    // shaders!\n    float a = atan(qz.z, qz.x);\n    float ia = floor(a/6.2831853*cells);\n    ia = (ia + .5)/cells*6.2831853;\n\n    float ws = -mod(ia,.0);\n    float cy = sin( ws*4. + (T * .25) * PI) * 1.5;\n    qz.y +=cy;\n\n    qz.xz *= rot(ia);\n    qz.x -= 6.5;\n  \n    wts = rot(ws+T);\n    qz.zy*=wts;\n    qz.xz*=wts;\n\n    float dx = zag(qz,.25);\n    if(dx<res.x) {\n        res=vec2(dx,5.);\n        hit=qz;\n        gnh=ws;\n    }\n    \n    return res;\n}\n\n// normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e ).x + \n        h.yyx*map( p + h.yyx*e ).x + \n        h.yxy*map( p + h.yxy*e ).x + \n        h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 vor3D(in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tfloat tx = hash21(floor(p.xy));\n    float ty = hash21(floor(p.zx));\n    float tz = hash21(floor(p.yz));\n    return vec3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 glintz( vec3 lcol, vec3 pos, vec3 n, vec3 rd, vec3 lpos, float fresnel) {\n    vec3 mate = vec3(0);\n    vec3 h = normalize(lpos-rd);\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos);\n    vec3 glints=vec3(0);\n    vec3 tcoord;\n    float pw,q,anisotropy;\n \n    //build layers\n    for(int i = 0; i < 2;i++) {\n\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n        \n        vec3 aniso = vec3(vor3D(tcoord.zyx*pw,n).yy, vor3D(tcoord.xyz*vec3(pw,-pw,-pw),n).y)*1.0-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n \n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n    return  mix(light*vec3(0.3), vec3(.05), fresnel) + glints + lcol * .3;\n}\n\n// compact sky based on \n// @Shane https://www.shadertoy.com/view/WdtBzn\nvec3 ACESFilm(in vec3 x) { return clamp((x*(.6275*x+.015))/(x*(.6075*x+.295)+.14),0.,1.); }\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld, float ison) { \n    rd.y+=.2;\n    rd.z *= .95 - length(rd.xy)*.5;\n    rd = normalize(rd);\n\n    vec3 Rayleigh = vec3(1), Mie = vec3(1); \n    // rayleigh / mie\n    vec3 betaR = vec3(5.8e-2, 1.35e-1, 3.31e-1), betaM = vec3(4e-2); \n    float zAng = max(2e-6, rd.y);\n    // scatter - Klassen's model.\n    vec3 extinction = exp(-(betaR*1. + betaM*1.)/zAng);\t\n    vec3 col = 2.*(1. - extinction);\n    // dist clouds\n    float t = (1e5 - ro.y - .15)/(rd.y + .45);\n    vec2 uv = (ro + t*rd).xz;\n\tif(t>0.&&ison>0.) {\n        col = mix(col, vec3(3), smoothstep(1.,.475,  fbm(5.*uv/1e5,5.))*\n                                smoothstep(.15, .85, rd.y*.5 + .5)*.4);  \n    }\n\n    return clamp(ACESFilm(col), 0., 1.);\n} \n\nvec3 sky = vec3(0);\n\nvec3 hue(float a, float b, float c) {\n    return b+c*cos(PI2*a*(vec3(1.25,.5,.25)*vec3(.99,.97,.96))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n\n    float  m = 0.;\n    vec3 p = ro;\n    for (int i = 0; i<128;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32 ? ray.x*.25 : ray.x*.75; \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    sid=gid;\n    snh=gnh;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n      \tvec3 n = normal(p, d);\n        \n        vec3 lpos = vec3(-11.,15,18.);\n        vec3 l = normalize(lpos-p);    \n        float diff = clamp(dot(n,l),0.,1.);\n        float shdw = 1., t = .01;\n\n        for(int i=0; i<24; i++){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) {shdw = 0.; break;}\n            shdw = min(shdw, 14.*h/t);\n            t += h * .8;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n\n        float fresnel = pow(1.0 + dot(n,rd), 2.0);\n        fresnel = mix( 0.0, 0.95, fresnel );\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.5 * pow(max(dot(view, ret), 0.), 24.);\n\n        ref=vec3(.0);\n        vec3 h = vec3(.5);\n        \n        if(m==2.) {\n            vec3 c = mix(vec3(0.647,0.573,0.192),vec3(0.082,0.459,0.145),clamp(.1+snh*.5,0.,1.));\n            h = glintz(c, hitPoint*.05, n, rd, l, fresnel);\n        }\n        if(m==3.) {\n            h = clamp(hue((snh+fresnel)*3.25,.80,.15)*.85,vec3(.1),vec3(1.));\n            ref = h-fresnel;\n        }\n        if(m==4.) {    \n            h = vec3(0.329,0.580,0.020);\n            ref = h-fresnel;\n        }\n        if(m==5.) {    \n            h = vec3(0.286+fresnel,0.576+fresnel,0.953);//hue((snh+fresnel)*3.25,.65,.35);\n            ref = h-fresnel;\n        }\n        C += h * diff+spec;\n        C = mix(vec3(0.392,0.502,0.565),C,  exp(-.000015*d*d*d));\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    \n    C=clamp(C,vec3(.03),vec3(1.));\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    mvt= 280.;//+T*.733;\n    turn = rot(T*.2);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float sf = .5*sin(T*.1);\n    vec3 ro = vec3(0,1.65,13.+sf);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy == vec2(0) ? .0 : .07+(M.y/R.y * .0625 - .03125) * PI;\n    float y = M.xy == vec2(0) ? .0 : -(M.x/R.x * .5 - .25) * PI;\n    float sx = .3*cos(T*.1);\n    mat2 rx = rot(x), ry=rot(y+sx);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n    \n    // sky and vars\n    sky = getSky(ro,rd,vec3(.0,.02,1.01),1.);\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fill=vec3(1.);\n    \n    // ref loop @BigWIngs\n    float d =0.;\n    float a =0.;\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d);\n        C += pass.rgb*fill;\n        fill*=ref;\n        if(i==0.)a=d;\n    }\n\n    C = mix(sky,C, exp(-.000015*a*a*a));\n    C = pow(C, vec3(.4545));\n    C = clamp(C,vec3(.03),vec3(1.));\n    O = vec4(C,1.0);\n}\n// end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sK3DR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 567, 586, 586, 631], [633, 633, 655, 933, 994], [996, 996, 1022, 1077, 1420], [1422, 1469, 1502, 1502, 1656], [1658, 1658, 1687, 1687, 1802], [1804, 1804, 1832, 1832, 1994], [1996, 1996, 2024, 2024, 2115], [2117, 2207, 2234, 2234, 2374], [2377, 2582, 2600, 2600, 4252], [4254, 4264, 4294, 4294, 4533], [4535, 4535, 4569, 4569, 4773], [4775, 4775, 4853, 4853, 6130], [6132, 6205, 6231, 6231, 6296], [6298, 6298, 6350, 6350, 7039], [7063, 7063, 7100, 7100, 7168], [7170, 7170, 7255, 7255, 9302], [9304, 9304, 9345, 9359, 10331]], "test": "untested"}
{"id": "7sK3zK", "name": "Fork 4D raymarc ArthMax 952", "author": "ArthMax", "description": "Objects of scene are completelly fixed, no animation of geometry, only camera moving in 4D space.\n", "tags": ["raymarching", "4d", "geometry", "tesseract", "3sphere"], "likes": 1, "viewed": 102, "published": "Public", "date": "1631820202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by sebastien durand - 2013 \n// Modified by ArthMax - 2021 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on iq famous exemple\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n // Change this to improve quality (3 is good)\n#define ANTIALIASING 3\n\n#define RAY_STEP 200\n//#define DRAWAXES\n\n                   float minIn(in vec4 r){\n                        float m=r.x;\n                         if(m>r.y)m=r.y;\n                         if(m>r.z)m=r.z;\n                         if(m>r.w)m=r.w;\n                          return m;\n                       }   \n                   float maxIn(in vec4 r){\n                        float M=r.x;\n                         if(M<r.y)M=r.y;\n                         if(M<r.z)M=r.z;\n                         if(M<r.w)M=r.w;\n                          return M;\n                       }       \n            \n                float sdPlane( vec4 p ) {\n                \treturn p.y;\n                }\n                \n                // 3-sphere (4d sphere)\n                float sdSphere( vec4 p, float r ) {\n                    return length(p)-r;\n                }\n                \n                float sdEllipsoid( in vec4 p, in vec4 r) {\n                    return (length(p/r) - 1.) * minIn(r);\n                }\n                \n                // tesseract (4d hypercube)\n                float sdTesseract( vec4 p, vec4 b ) {\n                  vec4 d = abs(p) - b;\n                   return min(maxIn(d),0.0) + length(max(d,0.0));\n                }\n                \n                float udRoundTesseract( vec4 p, vec4 b, float r) {\n                  return length(max(abs(p)-b,0.0))-r;\n                }\n                \n                float sdCapsule( vec4 p, vec4 a, vec4 b, float r ) {\n                \tvec4 pa = p - a;\n                \tvec4 ba = b - a;\n                \t float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n                \t  return length( pa - ba*h ) - r;\n                }\n                \n                \n                float sdCylinder(in vec4 p,in vec2 h ) {\n                  return max(length(p.xzw)-h.x, abs(p.y)-h.y );\n                }\n                \n                float sdCone(in vec4 p,in vec2 h ) {\n                  return max( length(p.xzw)-h.x, abs(p.y)-h.y) - h.x*p.y;\n                }\n                \n                // http://eusebeia.dyndns.org/4d/cubinder\n                float sdCubicalCylinder(vec4 p, vec3 rh1h2) {\n                \tvec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;\n                \t return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));\n                }\n                \n                // http://eusebeia.dyndns.org/4d/duocylinder\n                float sdDuoCylinder( vec4 p, vec2 r1r2) {\n                  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;\n                   return min(max(d.x,d.y),0.) + length(max(d,0.));\n                }\n                \n                \n                float opS( float d1, float d2 ) {\n                    return max(-d2,d1);\n                }\n                \n                vec2 opU( vec2 d1, vec2 d2 ) {\n                \treturn (d1.x<d2.x) ? d1 : d2;\n                }\n                \n                vec4 opRep( vec4 p, vec4 c ) {\n                    return mod(p,c)-0.5*c;\n                }\n                \n                vec4 opRepW(vec4 p, float c) {\n                \tp.w = mod(p.w,c)-0.5*c;\n                     return p;\n                }\n                \n                vec4 opTwist( vec4 p ) {\n                    float  c = cos(10.0*p.y+10.0);\n                    float  s = sin(10.0*p.y+10.0);\n                     mat2   m = mat2(c,-s,s,c);\n                      return vec4(m*p.xz,p.y, p.w);\n                }\n            \n            //----------------------------------------------------------------------\n            \n            vec2 map( in vec4 pos ) {\n                vec2 res = vec2(99999.,0);\n            \n                 #ifdef DRAWAXES\n                 //\tpos.xy *= mat2(c2,-s2,s2,c2);\n                 \t\n                 \tres = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(10.,0.,0.,0.), 0.05  ), 31.9 ) );\n                 \tres = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,10.,0.,0.), 0.05  ), 41.9 ) );\n                 \tres = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,10.,0.), 0.05  ), 51.9 ) );\n                 \tres = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,0.,10.), 0.05  ), 61.9 ) );\n                 #else\n                 \tres = vec2(sdPlane(pos),1.);\n                 #endif\n                 \n                    res = opU( res, vec2(sdCubicalCylinder(pos-vec4(-.5,.3, -.8, .1), vec3(.2,.3,.2)), 60.9 ) );\n                    res = opU( res, vec2(sdDuoCylinder( pos-vec4(-.2,.3, -.2, -.1), vec2(.2,.3) ), 53.9 ) );\n                    \n                    \n            \t    res = opU( res, vec2( sdTesseract(       pos-vec4( 1.0,0.25, 0.1, 0.2), vec4(0.25) ), 3.0 ) );\n                    \n            \t    res = opU( res, vec2( sdCapsule(   pos,vec4(-1.3,0.20,-0.1, -.3), vec4(-1.0,0.20,0.2,1.5), 0.1  ), 31.9 ) );\n            \t    res = opU( res, vec2( sdCylinder(  pos-vec4( 1.0,0.30,-1.0, -.5), vec2(0.1,0.2) ), 4.0 ) );\n            \t//res = opU( res, vec2( sdCone(      pos-vec4( 1.0,0.30,-1.0, 0.10), vec2(0.1,0.4) ), 4.0 ) );\n            \t\n            \t\n            \tvec4 posPeriodicSphere=pos; \n                 float d=2.0;\n                 posPeriodicSphere.w = mod(pos.w,d)-.5*d;\n                  res = opU( res, vec2( sdSphere(posPeriodicSphere-vec4( 0.0,0.25, 0.0, 0.25), 0.25 ), 46.9 ) );\n              //  res = opU( res, vec2( sdEllipsoid(pos-vec4( 0.0,0.25, 0.0, 0.25), vec4(.25,.1,.15,.3) ), 46.9 ) );\n              \n                vec4 posPeriodicRoundTesseract=pos; \n                   \n                   posPeriodicRoundTesseract = mod(pos,d)-.5*d;\n                    res = opU( res, vec2( udRoundTesseract(  posPeriodicRoundTesseract-vec4( 1.0,0.25, 1.0, 0.0), vec4(0.15), 0.1 ), 41.0 ) );\n                    \n            \t     return res;\n            }\n        \n        \n        vec2 castRay( in vec4 ro, in vec4 rd, in float maxd ) {\n            float t = 2.0;\n        \tfloat precis = 0.0005;\n             float h=precis*2.0;\n    \n        \tvec2 res;\n            for( int i=0; i<RAY_STEP; i++ ) {\n                if (abs(h)<precis || t>maxd ) break;\n                 \n                 t += h;\n                  res = map( ro+rd*t );\n                   h = res.x;\n            }\n             return vec2( t, t>=maxd ? -1. : res.y );\n        }\n    \n        float softshadow( in vec4 ro, in vec4 rd, in float mint) {\n        \tfloat res = 1.0;\n            float h,t = mint;\n             for( int i=0; i<15; i++ ) {\n                 h = map( ro + rd*t ).x;\n                  res = min( res, 7.*h/t );\n                   t += 0.028;\n             }\n              return clamp( res-.6, 0.0, 1.0 );\n        }\n    \n        const vec2 eps = vec2( 0.001, 0.0);\n        vec4 calcNormal( in vec4 pos ){\n        \treturn normalize(vec4(\n        \t    map(pos+eps.xyyy).x - map(pos-eps.xyyy).x,\n        \t    map(pos+eps.yxyy).x - map(pos-eps.yxyy).x,\n        \t    map(pos+eps.yyxy).x - map(pos-eps.yyxy).x,\n        \t\tmap(pos+eps.yyyx).x - map(pos-eps.yyyx).x\n        \t));\n        }\n    \n        float calcAO( in vec4 pos, in vec4 nor ){\n        \tfloat dd, hr, totao = 0.0;\n            float sca = 1.0;\n            vec4 aopos; \n             for( int aoi=0; aoi<5; aoi++ ) {\n                 hr = 0.01 + 0.05*float(aoi);\n                  aopos =  nor * hr + pos;\n                   totao += -(map( aopos ).x-hr)*sca;\n                   \n                    sca *= 0.75;\n            }\n             return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n        }\n    \n    vec3 render( in vec4 ro, in vec4 rd ){ \n        vec3 col = vec3(0);\n        vec2 res = castRay(ro,rd, 19.0);\n         float t = res.x;\n    \t float m = res.y;\n          if( m>-0.5 )\n          {\n            vec4 pos = ro + t*rd;\n             vec4 nor = calcNormal( pos );\n          \n    \t  \tcol = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    \t  \t\n              float ao = calcAO( pos, nor );\n          \n    \t  \tvec4 lig = normalize( vec4(-0.6, 0.7, -0.5, 0.5) );\n    \t  \t   float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n               float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n               float bac = clamp( dot( nor, normalize(vec4(-lig.x,0.0,-lig.z,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n          \n    \t  \tfloat sh = 1.0;\n    \t  \t    if( dif>0.02 ) { sh = softshadow( pos, lig, 0.025); dif *= sh; }\n          \n    \t  \tvec3 brdf = vec3(0.0);\n    \t  \t    brdf += 0.20*amb*vec3(0.0,0.93,0.13)*ao;\n                brdf += .2*bac*vec3(0.15)*ao;\n                brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n          \n    \t  \t   float pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n    \t  \t    float spe = sh*pow(pp,16.0);\n    \t  \t   float fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n          \n    \t  \t     col = col*brdf + vec3(1.0)*col*spe + 0.7*fre*(0.5+0.5*col);\n    \t  }\n          \n    \t    col *= exp( -0.01*t*t );\n          \n    \t     return vec3( clamp(col,0.0,1.0) );\n    }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     vec2 mo = vec2(1.0,0.0); \n           mo += iMouse.xy/iResolution.xy;\t \n     \n\tfloat time = iTime/8.0;\n\tvec3 colorSum = vec3(0.);\n\n          \t// rotation around xy plane\n\tfloat \n\t\ta = time/2.03,\n\t\tb = time/2.1,\n\t\t c1 = cos(a)*mo.x, s1 = sin(a)*mo.y,\n\t\t c2 = cos(b)*mo.x, s2 = sin(b)*mo.y;\n\t      mat2 rot1 = mat2(c1,-s1,s1,c1),\n               rot2 = mat2(c2,-s2,s2,c2);\n    \n    vec4 rd,\n        ro = vec4( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x),0.),\n        ta = vec4( -0.5, -0.4, 0.5, 0. ),\n         cw = normalize( ta-ro ),\n        cp = vec4( 0., 1., 0., 0. ),\n          cu = normalize( vec4(cross(cw.xyz,cp.xyz),0.)),\n           cv = normalize( vec4(cross(cu.xyz,cw.xyz),0.));\n\n           // Rotation of 4D scene\n            ro.zw *= rot1;\n           \tro.xw *= rot2;\n    \nfloat fA=float(ANTIALIASING);               \nfloat aspect=iResolution.x/iResolution.y;\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float fi=6.28*float(i)/fA; \n\t\t vec2 q = (fragCoord.xy+.4*vec2(cos(fi),sin(fi)))/iResolution.xy;\n\t\t  vec2 p = -1.0+2.0*q;\n\t\t        p.x *= aspect;\n\n         \t\t// Camera is still a 2D plane because human vision is in 2D (brain recalculates 3D)\n         \t\t// (The scene is time rotated around xy plan)\n         \t\t rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n         \t\t// Rotation of 4D scene\n             \t  rd.zw *= rot1;\n         \t\t  rd.xw *= rot2;\n        \n\t\t           colorSum += sqrt(render( ro, rd ));\n#if (ANTIALIASING > 1)\t\n\t}\n     fragColor = vec4(colorSum/fA, 1.);\n#else\n\tfragColor=vec4(colorSum, 1.);\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sK3zK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[371, 410, 433, 433, 654], [677, 677, 700, 700, 921], [958, 958, 983, 983, 1030], [1064, 1104, 1139, 1139, 1197], [1231, 1231, 1273, 1273, 1349], [1383, 1427, 1464, 1464, 1587], [1621, 1621, 1671, 1671, 1743], [1777, 1777, 1829, 1829, 2036], [2087, 2087, 2127, 2127, 2209], [2243, 2243, 2279, 2279, 2371], [2405, 2463, 2508, 2508, 2671], [2705, 2766, 2807, 2807, 2965], [3016, 3016, 3049, 3049, 3107], [3141, 3141, 3171, 3171, 3236], [3270, 3270, 3300, 3300, 3361], [3395, 3395, 3425, 3425, 3515], [3549, 3549, 3573, 3573, 3793], [3819, 3917, 3942, 3942, 6120], [6147, 6147, 6202, 6202, 6608], [6622, 6622, 6680, 6680, 6966], [7024, 7024, 7055, 7055, 7330], [7344, 7344, 7385, 7385, 7797], [7807, 7807, 7845, 7845, 9222], [9226, 9226, 9283, 9283, 10909]], "test": "untested"}
{"id": "7sKGD3", "name": "Line Mesh Pulsate", "author": "vlader08", "description": "desc", "tags": ["line", "mesh", "connected"], "likes": 11, "viewed": 257, "published": "Public", "date": "1632473477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat N21(vec2 p) {\n\n    p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    \n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\n    float n = N21(p);\n    \n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 off) {\n\n    vec2 n = N22(id + off) * iTime;\n    \n    return off + sin(n) * .4;\n}\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    \n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    \n    return length(pa - ba * t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    \n    float d = DistLine(p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2 - .75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for(float y = -1.; y <= 1.; y++) {\n        for(float x = -1.; x <= 1.; x++) {\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    float t = iTime*10.;\n    \n    for(int i = 0; i < 9; i++) {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv) * 20.;\n        float sparkle = 1./dot(j, j);\n       \n        float x_ = fract(p[i].x);\n        \n        m += sparkle * (sin(t + x_ * 10.0) * 0.5 + 0.5);\n    }\n    \n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[5], p[7]);\n    m += Line(gv, p[7], p[3]);\n    \n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) - .5;\n\n    float gradient = uv.y;\n\n    float m = 0.;\n    float t = iTime * .1;\n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    \n    uv *= rot;\n    mouse *= rot;\n    \n    for(float i = 0.; i < 1.; i += 1./4.) {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        \n        float fade = S(0., .5, z) * S(1., .8, z);\n        \n        m += Layer(uv * size + i * 20. - mouse) * fade ; // * ((i+1.) * 0.2)\n    }\n    \n    vec3 base = sin(t * 25. * vec3(.345, .456, .657)) * .4 + .6;\n    \n    vec3 col = m * base;\n    \n    col -= gradient * base;\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 59, 59, 165], [167, 167, 185, 185, 245], [247, 247, 279, 279, 353], [355, 355, 395, 395, 534], [536, 536, 572, 572, 743], [745, 745, 767, 767, 1472], [1474, 1474, 1529, 1529, 2280]], "test": "untested"}
{"id": "7sKGRy", "name": "Iterative Subdivison Fractal", "author": "Tater", "description": "Does this count as a fractal? Not sure. \n\nBased on 2D version from my previous shader: [url]https://www.shadertoy.com/view/7sV3WD[/url]", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 28, "viewed": 466, "published": "Public API", "date": "1631940566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MDIST 150.0\n#define STEPS 300.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat volume(vec3 a){\n    return a.x*a.y*a.z;\n}\n//Based on code from bigwings comment here\n//https://www.shadertoy.com/view/Wl3fD2\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    p/=b;\n    vec3 dir = sign(rd)*.5;   \n    vec3 rc = (dir-p)/rd;\n    rc*=b;\n    float dc = min(min(rc.x, rc.y), rc.z)+0.001;\n    return dc;\n}\n\nvec3 rdg = vec3(0);\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime;\n      \n    vec2 xRange = vec2(-0.5,0.5)*scl.x;\n    vec2 yRange = vec2(-0.5,0.5)*scl.y;\n    vec2 zRange = vec2(-0.5,0.5)*scl.z;\n    float id = 0.;\n    float seed = floor(t/6.)+0.1;\n    \n    //Some parameters to play with :D\n    float minSize = 0.15;\n    float iters = 12.;\n    float minIters = 1.;\n    float breakChance = 0.0;\n    float maxVolume = 5.0;\n    float destructionChance = 0.5;\n    float maxCenterDist = 4.5;\n    float padFact = 1.01;\n    \n    float xLength=0.;\n    float yLength=0.;\n    float zLength=0.;\n    \n    for(float i = 0.;i<iters;i++){\n        xLength = xRange.y-xRange.x;\n        yLength = yRange.y-yRange.x;\n        zLength = zRange.y-zRange.x;\n        \n        float dividex = h21(vec2(i+id,seed))*(xLength)+xRange.x;\n        float dividey = h21(vec2(i+id,seed))*(yLength)+yRange.x;\n        float dividez = h21(vec2(i+id,seed))*(zLength)+zRange.x;\n        \n        dividex= clamp(dividex,xRange.x+minSize*padFact,xRange.y-minSize*padFact);\n        dividey= clamp(dividey,yRange.x+minSize*padFact,yRange.y-minSize*padFact);\n        dividez= clamp(dividez,zRange.x+minSize*padFact,zRange.y-minSize*padFact);\n        \n        float mn = min(length(xRange.x-dividex),length(xRange.y-dividex));\n        mn = min(mn,min(length(yRange.x-dividey),length(yRange.y-dividey)));\n        mn = min(mn,min(length(zRange.x-dividez),length(zRange.y-dividez)));\n        bool willBreak = false;\n        if(i-1.>minIters && h11(id)<breakChance) willBreak = true;\n        if(mn<minSize&&i-1.>minIters||i==iters-1.) willBreak = true;\n        if(willBreak) {\n        //id = i*0.1*seed;\n        break;\n        }\n        vec3 diff = vec3(0);\n        if(p.x<dividex){\n            xRange = vec2(xRange.x,dividex);\n            diff.x+=dividex;\n        }\n        else{\n            xRange = vec2(dividex,xRange.y);\n            diff.x-=dividey;\n        }\n        if(p.y<dividey){\n            yRange = vec2(yRange.x,dividey);\n            diff.y-=dividex;\n        }\n        else{\n            yRange = vec2(dividey,yRange.y);\n            diff.y+=dividey;\n        }\n        if(p.z<dividez){\n            zRange = vec2(zRange.x,dividez);\n            diff.z-=dividex;\n        }\n        else{\n            zRange = vec2(dividez,zRange.y);\n            diff.z+=dividez;\n        }\n\n        id = length(diff+10.0);\n    }\n    \n    float volume = volume(vec3(xLength,yLength,zLength));\n    vec3 center = vec3((xRange.x+xRange.y)/2.,(yRange.x+yRange.y)/2.,(zRange.x+zRange.y)/2.);\n\n    //huge improvment in performance by using distance to intersection of empty cell\n    //to remove boxes (instead of using a negative box sdf)\n    //But it seems to cause artifacts rarely, idk why\n    float b = dibox(p-center,vec3(xLength,yLength,zLength),rd);\n    \n    float shr = 1.0-abs(pow(abs(cos(mod(t,6.)*pi/6.)),6.0));\n    shr = smoothstep(0.,1.,shr);\n    vec3 d = abs(center);\n    center.y-=yLength*(1.0-shr)*0.5;\n    yLength*=shr;\n    float a = box(p-center,vec3(xLength,yLength,zLength)*0.5);\n\n    //I found this helps to remove some of the artifacts from using the empty box intersection\n    if(abs(p.x)>scl.x*0.5) b=-a;\n    if(abs(p.z)>scl.z*0.5) b=-a;\n    \n    a=min(a,b);\n    if(max(d.x,max(d.y*0.5,d.z))>maxCenterDist)a=b;\n    else if(volume>maxVolume)a=b;\n    else if (h11(id*1.1)<destructionChance)a=b;\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec2 map(vec3 p){\n    float t = iTime;\n    p.y-=1.0;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 scl = vec3(10.0,14.,10);\n    vec3 rd2 = rdg;\n    a = blocks(p,scl,rdg)+0.02;\n    \n    a.x = max(box(p,vec3(scl*0.49)),a.x);\n    \n    p.y+=scl.y*0.5+5.2;\n    b.x = ebox(p,vec3(5.2))-0.2;\n    \n    a=(a.x<b.x)?a:b;\n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.00005,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,5,-20);\n    if(iMouse.z>0.){\n    ro.zx*=rot(7.0*iMouse.x/iResolution.x);\n    }\n    else ro.zx*=rot(iTime*0.3);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(abs(d.x)<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1,-1));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        vec3 e = vec3(0.5);\n        \n        vec3 al = pal(d.y*0.1,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n        if(d.y==2.0) al = vec3(1.);\n        col = al;\n        \n        //float diff = length(sin(n*2.)*.5+.8)/sqrt(3.);\n        float diff = mix(0.7,1.0,dot(ld,n)*0.5+0.5);\n\n        col = al*diff;\n        \n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<50.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }     \n        col*=shadow;\n    }\n    vec3 bg = mix(vec3(0.173,0.231,0.686),vec3(0.361,0.753,1.000),rd.y*0.5+0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n/*\n#define AA 2.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            rdg = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 127, 194, 194, 233], [234, 234, 254, 254, 325], [326, 326, 347, 347, 399], [400, 400, 426, 426, 485], [486, 486, 513, 513, 600], [601, 601, 622, 622, 648], [649, 732, 767, 767, 911], [933, 933, 972, 972, 4330], [4332, 4332, 4349, 4349, 4682], [4683, 4683, 4701, 4701, 4832], [4833, 4833, 4890, 4890, 6447]], "test": "untested"}
{"id": "7st3Rs", "name": "Shader Assignment 1", "author": "Th3FenrisWolf", "description": "Simple shader", "tags": ["schoolproject"], "likes": 1, "viewed": 38, "published": "Public", "date": "1630694512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    // Time varying pixel color\n    if(uv.x > 0.25 && uv.x < 0.75 && uv.y > 0.25 && uv.y < 0.75){\n        col = vec3(sin(iTime + vec3(0,2,4)) * cos(uv.x * iResolution.x / 10.0) / cos(uv.y * iResolution.y / 10.0));\n    }\n    else{\n        if(mod(iTime, 10.0) < 5.0){\n            col = vec3(sin(uv.x) * cos(uv.y) * mod(-iTime, 5.0), 0.5, cos(uv.x) * sin(uv.y) * mod(iTime, 5.0));\n        }\n        else{\n            col = vec3(sin(uv.x) * cos(uv.y) * mod(iTime, 5.0), 0.5, cos(uv.x) * sin(uv.y) * mod(-iTime, 5.0));\n        }\n    }\n    \n    vec4 pic = texture(iChannel0, col.xy);\n    \n    vec3 pic3 = vec3(pic.xyz);\n    \n    // Output to screen\n    fragColor = vec4(mix(col.rgb,pic3.rgb, cos(iTime*0.7)),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7st3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 872]], "test": "untested"}
{"id": "7stGWj", "name": "3D GLOW TUTORIAL", "author": "alro", "description": "How to render glow in a ray marched scene.", "tags": ["3d", "sdf", "tutorial", "light", "glow"], "likes": 17, "viewed": 465, "published": "Public", "date": "1630675756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 1e-6;\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 1e-6), intensity);\t\n}\n\n\n//----------------------------- Camera ------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n    vec3 zaxis = normalize(targetDir);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\n\n//-------------------------- SDF and scene ---------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torusSDF( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat getSDF(vec3 position) {\n   \tfloat angle = iTime;\n    vec3 axis = normalize(vec3(1.0, 1.0, 1.0));\n    position = rotate(position, vec4(axis * sin(-angle*0.5), cos(-angle*0.5))); \n    return torusSDF(position, vec2(1.0, 0.2));\n\n}\n\n\n//---------------------------- Raymarching ----------------------------\n\n// Glow variable is passed in by reference using the keyword inout. The result written in this\n// function can be read afterwards from where it was called.\nfloat distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, inout float glow) {\n\t\n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n    \n    // For a set number of steps\n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        // Get the SDF value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir);\n        \n        // Calculate the glow at the current distance using the distance based glow function\n        // Accumulate this value over the whole view ray\n        // The smaller the step size, the smoother the final result\n        glow += getGlow(dist, 1e-3, 0.55);\n        \n        // If the distance is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if(dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += dist;\n        \n        // Test if we have left the scene\n        if(depth >= end){\n            return end;\n        }\n    }\n    \n    // Return max value if we hit nothing but remain in the scene after max steps\n    return end;\n}\n\n\n//----------------------- Tonemapping and render ------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord);\n    \n    //----------------- Define a camera -----------------\n\n    vec3 cameraPos = vec3(2.0);\n    \n    vec3 target = -normalize(cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, target, up);\n    \n    //---------------------------------------------------\n\n    // Transform the ray to point in the correct direction\n    rayDir = viewMatrix * rayDir;\n\n    // Initialize glow to 0\n    float glow = 0.0;\n    \n    // Find the distance to where the ray stops, pass in the glow variable to be accumulated\n    float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST, glow);\n    \n    // Dist can now be used to render surfaces in the scene. We will only render the glow\n  \n    vec3 glowColour = vec3(0.2, 0.5, 1.0);\n    \n    // Glow now holds the value from the ray marching\n    vec3 col = glow * glowColour;\n\n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = pow(col, vec3(0.4545));\n        \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 153, 210, 210, 263], [266, 337, 391, 391, 548], [550, 639, 689, 689, 858], [861, 933, 961, 961, 1023], [1025, 1099, 1132, 1132, 1202], [1204, 1204, 1233, 1233, 1437], [1513, 1669, 1763, 1840, 3040], [3118, 3196, 3218, 3218, 3306], [3308, 3308, 3364, 3442, 4536]], "test": "untested"}
{"id": "7stSWn", "name": "21/49", "author": "tono", "description": "Asari clams were delicious, so I made some asari clams.\nFrozen peeled asari clams are very convenient!", "tags": ["49"], "likes": 3, "viewed": 47, "published": "Public", "date": "1632964574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo(vec3 p,vec3 s){p = abs(p) - s;return max(p.x,max(p.y,p.z));}\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\nfloat pi = acos(-1.);\nvec3 pmod(vec2 p, float r){float a = atan(p.x,p.y)+pi/r;float n = (pi*2.)/r;return vec3(p*rot(-(floor(a/n)*n)),floor(a/n) );}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\nvec3 objectpos;\nvec2 toPolar(vec2 p)\n{\n    return vec2(length(p),atan(p.y,p.x));\n}\nfloat shell(vec3 p , float a)\n{\n    p.xz *= rot(pi);\n    vec3 scale = vec3(1.,1.,1.);\n    p.xz = clamp(p.xz,-pi/2.,pi/2.);\n    scale.x *= (sin(p.z + .96) + 1.4)/2.;\n    scale.y /= (sin(length(p.xz + vec2(0.,1.) * 2.) + 3.1) + 3.)/1. * 1.;\n    p.y = abs(p.y)+.06;\n    vec2 shift = vec2(0.,1.);\n    vec3 pp = p;\n    p.yz = (p.yz + shift) * rot( step(0.,p.y)*(sin(iTime/3. + a * 10.) - 1.)/2. ) - shift;\n    objectpos = p;\n    float o = scaleSphere(p,scale,1.);\n    o = max(o,-scaleSphere(p + vec3(0.,.4,-0.03),scale/.95,1.));\n    \n    if(o < 1.)\n    {\n        o -= sin(length(p.xz + vec2(0.,1.)) * 100.)/(3. + length(p.xz + vec2(0.,1.))*1700. );\n    }\n    \n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 op = p;\n    float range = 4.3;\n    vec2 areaid = floor(p.xz/range);\n    float a = random(areaid);\n    //p.x += areaid.y/12.;\n    p.xz = mod(p.xz,range) - range/2.;\n    \n    p.x += random(areaid.yy * 12.) * 1.3;\n    p.xz *= rot(a * 10.);\n    p.yz *= rot(-a * 1.3);\n    p.y += sin(a*10.) * .3;\n    p.y -= .5;\n    if(random(areaid*10.) < .3)\n    {\n        o = shell(p,a);\n    }\n    \n    p.xz = mod(p.xz,3.) - 1.5;\n    \n    \n    float sand = -op.y + 0.2 + noise(op/3.);\n    if(sand < 1.)\n    {\n    \tsand -= fbm(op)/2.;\n        if(sand < 0.1)\n        {\n            sand -= noise(op*30.)/100.;\n        }\n    }\n    if(o > sand)\n    {\n\t\to = min(sand,o);\n        id = 1.;\n    }\n    o *= .9;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 60.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec2 shadowmarch(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 66 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 4.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec3 shellCol(vec3 pos)\n{\n    vec3 o = vec3(0.);\n    o = objectpos;\n    vec3 op = objectpos;\n    o = vec3(1.,.9,.9);\n    o -= fbm(pos*10.) * vec3(0.1,0.1,.5);\n    o -= vec3(1.) * fbm(op) * smoothstep(0.,1.,length(op.yz)*sign(op.z) ) * 1.;\n    o -= mix((sin(length(op.xz + vec2(0.,1.5)) * 60. + fbm(op * 2. + pos) * 20.) + 1. )/10. , 0. , .5);\n    vec2 pol = toPolar(op.xz + vec2(0.,1.));\n    o -= sin(pol.y * 40. + fbm(pos * 4.)*10. ) * fbm(pos) * .3;\n    return o;\n}\n\nvec3 skyCol(vec3 rd)\n{\n    vec3 o = vec3(1.);\n    float y = smoothstep(0.,1.,-rd.y);\n    o = mix(vec3(0.6,1.,1.),vec3(0.8,0.7,0.7),y);\n    o *= step(rd.y-.06 , 0.);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 f = vec3(0.);\n    \n    float t = floor(iTime*1.3) + pow(fract(iTime*1.3),1.1);\n    f.z += t*1.8;\n    p *= rot(sin(sin(iTime ))/62.);\n\tf.y += f.x + sin( iTime*1.3 * pi)/13.;\n\tvec3 cp = vec3(16.,-3.,-16.) ;\n    \n    cp += f;\n    //cp.yz *= rot(sin(iTime)/2. + 1.5);\n    f.x += (fbm(vec3( iTime * 1.))-.5) * 1.3;\n   // f.y += f.x +cos(iTime/2.) * 2. ;\n    vec3 target = vec3(0.) + f;\n    \n    vec3 col = vec3(1.,0.,1.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 1.2 - dot(p,p)/8.;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    \n    vec3 sky = skyCol(rd);\n    col = sky;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(map(pos).x - vec3(map(pos - e.xyy).x , map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        //sun.xz *= rot(iTime);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        vec3 mat = vec3(1.);\n        if(d.y == 0.)\n        {\n            mat = shellCol(pos);\n            sp = pow(sp,10.)/6.;\n        }else {\n            sp = pow(sp,103.)/2.;\n        }\n        float up = max(0.,dot(N,vec3(0.,-1.,0.)) );\n        float down = max(0.,dot(N,vec3(0.,1.,0.)) );\n        \n        col = sp * vec3(1.) + diff * mat;\n        float shadow = step(shadowmarch(pos + N * 0.1,-sun).x,0.);\n        col.rgb *= shadow;\n        col.rgb +=  + up * vec3(.2,0.2,.5) + down * vec3(.3,.3,.4);\n        float t = 1. - exp(-.0000003 * d.x * d.x);\n        //col = mix(col,sky,t);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [62, 62, 86, 86, 131], [132, 132, 182, 182, 252], [275, 275, 302, 302, 400], [401, 401, 421, 421, 516], [518, 518, 539, 539, 1121], [1123, 1123, 1142, 1142, 1302], [1303, 1303, 1330, 1330, 1447], [1464, 1464, 1486, 1486, 1530], [1531, 1531, 1562, 1562, 2201], [2203, 2203, 2221, 2221, 2975], [2977, 2977, 3008, 3008, 3307], [3309, 3309, 3346, 3346, 3642], [3644, 3644, 3669, 3669, 4111], [4113, 4113, 4135, 4135, 4293], [4295, 4295, 4352, 4352, 6240]], "test": "untested"}
{"id": "7stSzN", "name": "Northern Melter", "author": "TEttinger", "description": "This changes the \"Northern Elves\" shader drastically by switching from sin and cos to Quilez' Basic Noise. It looks like melting liquid metal, which is fun.", "tags": ["noise", "basic", "plasma", "metal", "melter", "northern"], "likes": 5, "viewed": 199, "published": "Public API", "date": "1632800610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 69.42; // starts off with a \"melting face\"\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\nconst vec3 SECTION = fract(COEFFS.zxy - COEFFS.yzx * 1.618);\n\n// Quilez Basic Noise, from https://www.shadertoy.com/view/3sd3Rs (MIT-license)\nvec3 bas( vec3 x )\n{\n    // setup    \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    vec3 s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    vec3 k = fract(SECTION * i + i.yzx);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// this is different from other swayRandomized in Northern demos because it uses Quilez basic noise instead of trigonometry.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return bas(seed.xyz + value.zxy - bas(seed.zxy + value.yzx) + bas(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con)\n    ) * 0.5;\n    //+ swayRandomized(c + 1.1, con.xyz)\n    //+ swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = (fragCoord + cos(iTime * 0.3) * 64.0) * (2.125 + sin(iTime * 0.25));\n    vec2 uv = (fragCoord * 0.1) + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx - fragCoord.yxy * 0.004).xy * 42.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj.yzx)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con);\n    \n    fragColor = vec4(sin(con * 3.1416) * 0.5 + 0.5,1.0);\n//    fragColor = vec4(swayRandomized(COEFFS + 3.0, con) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stSzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 439, 459, 476, 752], [754, 879, 923, 923, 1019], [1021, 1235, 1266, 1266, 1417], [1419, 1419, 1476, 1561, 2272]], "test": "untested"}
{"id": "7stXzM", "name": "RayMarch_learning", "author": "hail", "description": "刚开始学RayMarch，记录一下(", "tags": ["raymarch"], "likes": 0, "viewed": 35, "published": "Public", "date": "1632898456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Max_Steps 100\n#define Max_Dist 100.0\n\nfloat SphereDis(vec3 p){\n    //定义一个球型,坐标在(0,1,6)\n    vec4 sphere = vec4(1, 1, 4, 1);\n    sphere.x += sin(iTime) * 2.0;\n    //计算点p到球的距离\n    float sphereDis = length(p - sphere.xyz) - sphere.w;\n    return sphereDis;\n}\n//b是box尺寸\nfloat BoxDis(vec3 p, vec3 b){\n    //设定box的坐标\n    p -= vec3(-2, 1, 4);\n    //计算p到box距离\n    vec3 q = abs(p) - b;\n    float boxDis = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return boxDis;\n}\n\n//光滑混合\nfloat opSmoothUnion(float d1, float d2, float k){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat GetDis(vec3 p){\n    float sphereDis = SphereDis(p);\n    float boxDis = BoxDis(p, vec3(1, 1, 1));\n    //融合\n    float combine = opSmoothUnion(sphereDis, boxDis, 0.8);\n\n    float dis = min(combine, p.y);\n    dis = min(dis, boxDis);\n    return dis;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDis(p);\n    //通过偏移量计算normal\n    vec3 n = d - vec3(GetDis(p - vec3(0.01, 0, 0)),\n                      GetDis(p - vec3(0, 0.01, 0)),\n                      GetDis(p - vec3(0, 0, 0.01)));\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rDir){\n    float stepDis = 0.0;\n    //Max_Steps是设定的最大步进次数\n    for(int i=0; i<Max_Steps; i++){\n        // p 点为步进后的坐标\n        vec3 p = ro + rDir * stepDis;\n        //GetDis获取离p点最近的物体的距离(稍后实现这个函数)\n        float tempDis = GetDis(p);\n        stepDis += tempDis;\n        if(tempDis < 0.01 || stepDis > Max_Dist)\n            break;\n    }\n    return stepDis;\n}\n\nfloat GetDiff(vec3 p){\n    vec3 lPos = vec3(3, 8, 3);\n    //\n    lPos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n\n    vec3 lDir = normalize(lPos - p);  \n    vec3 n = GetNormal(p);\n\n    float diff = clamp(dot(n, lDir), 0.0, 1.0);\n\n    //shadow\n    float p2lDis = RayMarch(p + n * 0.02, lDir);\n    if(p2lDis < length(lPos - p))\n        diff *= 0.1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //把uv坐标限制到(-1,1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    //ro是摄像机坐标\n    vec3 ro = vec3(0, 1, 0);\n    //rDir是摄像机到每个像素点的方向向量\n    vec3 rDir = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rDir);\n    vec3 p = ro + d * rDir;\n    float diff = GetDiff(p);\n\n    vec3 col = vec3(diff);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stXzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 70, 112, 295], [296, 312, 341, 366, 539], [541, 556, 605, 605, 704], [706, 706, 727, 727, 962], [964, 964, 987, 987, 1230], [1232, 1232, 1267, 1267, 1689], [1691, 1691, 1713, 1713, 2060], [2062, 2062, 2118, 2151, 2540]], "test": "untested"}
{"id": "7sV3RV", "name": "Walking on a torus", "author": "MagmaMcFry", "description": "What a 2D creature (the white dot) walking on a torus of revolution would see in all directions if light travelled geodesically on the torus surface. In other words, an azimuthal equidistant torus map.\n", "tags": ["torus", "map", "projection", "geodesic", "azimuthal", "equidistant"], "likes": 6, "viewed": 106, "published": "Public", "date": "1631818059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//// This shader displays the view of someone (the white dot) living on the surface of a torus of revolution.\n//// The red part is the positively curved outer part of the torus,\n//// the blue part is the negatively curved inner part.\n\n// The tube radius is always 1. The midradius is the radius of the circle followed by the tube.\nconst float midradius = 1.5;\n// If the midradius is close to or less than 1, significant numerical instability will occur,\n// and you need to crank up the number of integration steps below.\n\n// Number of numerical integration steps to compute geodesic differential equation\n// Increase to improve numerical accuracy and fix yellow areas, decrease for performance\nconst int integrationSteps = 40;\n\n// Length of a unit, in pixels. Larger values will zoom the screen out.\n// This may require more integration steps for accuracy at large distances.\nconst float unitLength = 20.0;\n\n// Number of latitude/longitude lines\nconst float latitudeLines = 8.0;\nconst float longitudeLines = midradius * latitudeLines;\n\n// Parametrization of the torus:\n// P = ((m+cos(y))cos(x), ((m+cos(y))sin(x), sin(y))\n// m is the midradius\n\n// Geodesic differential equation:\n// (m+cos(y))x'' - sin(y)x'y' = 0\n// 2y'' + sin(y)x'x' = 0\n\n// Given position and velocity of a curve in parameter space representing a geodesic, compute second derivatives of that curve.\nvec2 dd(vec2 pos, vec2 dpos) {\n    vec2 ddpos;\n    ddpos.x = sin(pos.y) * dpos.x * dpos.y / (midradius+cos(pos.y));\n    ddpos.y = -sin(pos.y) * dpos.x * dpos.x / 2.0;\n    return ddpos;\n}\n\n// Convert second-order 2D differential equation function to first-order 4D\nvec4 D(vec4 pdp) {\n    return vec4(pdp.zw, dd(pdp.xy, pdp.zw));\n}\n\n// Euler method\nvec4 step_eu(vec4 v, float dt) {\n    vec4 Dv = D(v);\n    return v + dt * Dv;\n}\n\n// Midpoint method\nvec4 step_mp(vec4 v, float dt) {\n    vec4 Dv = D(v);\n    vec4 Dvm = D(v + 0.5 * dt * Dv);\n    return v + dt * Dvm;\n}\n\n// Classic 4-step Runge-Kutta method\nvec4 step_rk(vec4 v, float dt) {\n    vec4 Dv1 = D(v);\n    vec4 Dv2 = D(v + 0.5 * dt * Dv1);\n    vec4 Dv3 = D(v + 0.5 * dt * Dv2);\n    vec4 Dv4 = D(v + dt * Dv3);\n    return v + dt * (Dv1 + 2.0 * Dv2 + 2.0 * Dv3 + Dv4) / 6.0;\n}\n\nvec3 gridColor(vec2 uv) {\n    float p = 2.0;\n    float pi = 3.14159265359;\n    vec2 r = abs(2.0*fract(uv/vec2(2.0*pi/longitudeLines, 2.0*pi/latitudeLines))-vec2(1.0, 1.0));\n    float g = 0.5*float(r.x > 0.9) + 0.8*float(r.y > 0.9);\n    return vec3(cos(uv.y), g, -cos(uv.y));\n}\n\n// Iteratively follow geodesic in small steps\nvec2 iter(vec2 uv, vec2 pos0) {\n    // Convert screen coordinates to tangent coordinates isometrically\n    vec2 dpos0 = uv/vec2(midradius+cos(pos0.y), 1.0);\n    vec4 pdp = vec4(pos0, dpos0);\n    const float stepSize = 1.0 / float(integrationSteps);\n    for (int i = 0; i < integrationSteps; ++i) {\n        pdp = step_rk(pdp, stepSize);\n    }\n    return pdp.xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / unitLength;\n    vec2 pos0 = vec2(0.0, iTime);\n    vec4 visibleColor = vec4(gridColor(iter(uv, pos0)), 1.0);\n    vec4 dotColor = vec4(1.0, 1.0, 1.0, 1.0);\n    fragColor = mix(visibleColor, dotColor, float(dot(uv, uv) < 0.03));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sV3RV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1240, 1368, 1398, 1398, 1554], [1556, 1632, 1650, 1650, 1697], [1699, 1715, 1747, 1747, 1793], [1795, 1814, 1846, 1846, 1930], [1932, 1969, 2001, 2001, 2195], [2197, 2197, 2222, 2222, 2473], [2475, 2521, 2552, 2623, 2883], [2885, 2885, 2940, 2940, 3215]], "test": "untested"}
{"id": "7sVGRd", "name": "Gay Flag", "author": "Ravbug", "description": "The 'g' in GPU stands for gay", "tags": ["gay", "lgbt"], "likes": 1, "viewed": 117, "published": "Public API", "date": "1632007995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// set to 0 to disable the waving animation\n#define WAVE 1\n\n// adjust the number of stripes\nconst float steps = 2.0;\n\n// linear value remap\nfloat remap(float value, float low1, float high1, float low2, float high2){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// step function w/ floor\nfloat stepf(float value){\n    return remap(floor(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// step function w/ ceiling \nfloat stepc(float value){\n    return remap(ceil(remap(value,0.0,1.0,0.0,steps)),0.0,steps,0.0,1.0);\n}\n\n// keep in range\nfloat clampInRange(float x){\n    return ((x >= 0.0 && x <= 1.0) ? 1.0 : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = fragCoord/iResolution.xy;\n     #if WAVE\n     uv.y += (sin(10.0*(-iTime/3.0+uv.x))*0.03);\n     #endif\n\n     // green, white, blue\n     vec3 col1 = vec3(0.24,0.54,0.44);\n     vec3 col2 = vec3(1.0,1.0,1.0);\n     vec3 col3 = vec3(0.22,0.13,0.45);\n     \n     float diff = 0.4;\n     \n     // gradient + step function\n     vec3 colorTop = mix(col1,col2,stepf(1.0-remap(uv.y,1.0-diff,1.0,0.0,1.0)));\n     vec3 colorBot = mix(col2,col3,stepc(1.0-remap(uv.y,0.0,diff,0.0,1.0)));\n     \n     vec3 resCol = uv.y < 0.5 ? colorBot : colorTop;\n \n\n    // Output to screen\n    fragColor = vec4(resCol * clampInRange(uv.y),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 140, 215, 215, 285], [287, 313, 338, 338, 415], [417, 446, 471, 471, 547], [549, 566, 594, 594, 645], [647, 647, 704, 755, 1382]], "test": "untested"}
{"id": "7sVGRy", "name": "CIS-566: Lab 1 - Q2", "author": "raykim1996", "description": "shader", "tags": ["shader"], "likes": 1, "viewed": 41, "published": "Public", "date": "1631763138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\n\n#define PI 3.1415926535\n\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n//20 spikes\nfloat spikeNum = 20.0;\n\nvec4 q1(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n    float angle = atan(uv.x, uv.y);\n\tfloat t = sin(angle);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return center + rotatedPoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n    \n    vec2 pos = center - uv;\n    float angle = atan(pos.x, pos.y);\n    radius = (40.0 * (sin(5.0 * angle) + 2.0)) * cos(iTime) + 100.0;\n\tvec4 layer2 = circle(rotatePoint2d(uv, center, angle), center, radius, red);\n    //vec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 139, 176, 176, 225], [227, 290, 351, 351, 455], [457, 493, 550, 550, 682], [684, 744, 799, 799, 1082], [1084, 1084, 1141, 1141, 1709]], "test": "untested"}
{"id": "7sy3Wh", "name": "china flag", "author": "huataishi", "description": "china flag ", "tags": ["flagshaderchina"], "likes": 3, "viewed": 89, "published": "Public", "date": "1631437422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"The china Flag\" \n// by huataishi \n\nvec3 WHITE = vec3(1);\nvec3 RED = vec3(255, 0, 0)/255.;\nvec3 YELLOW = vec3(255, 255, 0)/255.;\nfloat BIGSTARTSIZE = 0.051;\nfloat ROTATO = 18.;\n\nfloat Star(vec2 uv, float size,vec2 pos,float rotato) {\n   uv.x *= iResolution.x / iResolution.y;\n   uv -= pos;\n   uv *= mat2(cos(3.14*rotato/180.),-sin(3.14*rotato/180.),sin(3.14*rotato/180.),cos(3.14*rotato/180.));\n   float a = mod( atan(uv.x,uv.y)*5.,6.28 ) / 5. -3.14/5.,\n      angle = 3.14*(.5+.2),\n          d = length(uv)*  sin(angle+abs(a)),\n          w = fwidth(d);\n    return length(uv)>.8 ? 0. : smoothstep(size + .005, size - .005, d);\n}\n\n\nvec3 Flag(vec2 uv,vec2 fragCoord ) {\n    float y = sin(uv.y*3.1415*13.);\n    float w = fwidth(y);\n    w = 0.01;\n    vec3 col = RED;\n   \n    col = mix(col, YELLOW, Star(uv, BIGSTARTSIZE,vec2(5./30. * iResolution.x / iResolution.y,1.-6./20.),0.));\n    col = mix(col, YELLOW, Star(uv, BIGSTARTSIZE/3.,vec2(10./30. * iResolution.x / iResolution.y,1.-2./20.),ROTATO));\n    col = mix(col, YELLOW, Star(uv, BIGSTARTSIZE/3.,vec2(12./30. * iResolution.x / iResolution.y,1.-4./20.),-ROTATO));\n    col = mix(col, YELLOW, Star(uv, BIGSTARTSIZE/3.,vec2(12./30. * iResolution.x / iResolution.y,1.-7./20.),0.));\n    col = mix(col, YELLOW, Star(uv, BIGSTARTSIZE/3.,vec2(10./30. * iResolution.x / iResolution.y,1.-9./20.),ROTATO));\n    col *= smoothstep(w, .0, abs(uv.y-.5)-.5+w);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    float t = uv.x*7.-2.*iTime+uv.y*3.;\n    uv.y += sin(t)*.05;\n    \n    vec3 col = Flag(uv,fragCoord);\n    \n  col *= .7+cos(t)*.3;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sy3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 181, 236, 236, 630], [633, 633, 669, 669, 1414], [1417, 1417, 1474, 1474, 1687]], "test": "untested"}
{"id": "7syGDD", "name": "PBR SDF Demo", "author": "steps3d", "description": "Complex animated SDF shape with PBR", "tags": ["sdf", "pbr"], "likes": 1, "viewed": 60, "published": "Public", "date": "1631556391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0 + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n    \n    //return dSphere ( p, vec3 ( 2, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.7, 0.1, 0.1 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v );\n\t} \n\n        // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 184, 211, 211, 358], [360, 398, 425, 425, 572], [574, 574, 611, 611, 676], [678, 678, 707, 707, 775], [777, 777, 806, 806, 893], [896, 896, 929, 929, 1010], [1012, 1012, 1054, 1054, 1124], [1126, 1126, 1151, 1246, 1290], [1292, 1292, 1328, 1328, 1539], [1541, 1541, 1608, 1608, 1923], [1925, 1925, 1977, 1977, 2346], [2548, 2576, 2623, 2623, 2737], [2739, 2739, 2788, 2788, 2928], [2930, 2930, 2985, 2985, 3141], [3143, 3143, 3193, 3193, 3340], [3342, 3342, 3408, 3408, 3550], [3552, 3552, 3598, 3598, 3634], [3636, 3636, 3694, 3694, 3726], [3728, 3728, 3800, 3800, 3859], [3861, 3861, 3927, 3927, 4618], [4620, 4620, 4677, 4732, 5587]], "test": "untested"}
{"id": "7syGWW", "name": "More swirly stuff", "author": "SnoopethDuckDuck", "description": "very sloppy code, avert your eyes", "tags": ["cool"], "likes": 2, "viewed": 121, "published": "Public API", "date": "1631543843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 0.1;\n\n    float t = iTime;//mod(iTime, 2. * 3.14159);\n    float b = 0.5 * (1. + cos(0.2 * t));   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.5 * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float theta = atan(uv.y, uv.x);\n    \n    uv = vec2(1.6 * uv.x - 1.2 * uv.y * cos(4. * theta + t), 1.2 * uv.x * sin(3. * theta + t) + 1.6 * uv.y);\n\n    //float theta = atan(uv.y, uv.x);\n    \n    float d = b * ( abs(uv.x) + abs(uv.y))\n            + (1.-b) * ( max(abs(uv.x), abs(uv.y)));\n            \n    float r = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    r = 4. * r * (1.-r);\n    \n    t += a;\n    \n     float g = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    g = 4. * g * (1.-g);\n    \n    t -= 2. * a;\n    \n     float b2 = 1. - smoothstep(cos(10. * d + 5. * theta + t)- sin(3. * d + 2. * theta + t), 0.25 + 0.1 * cos(2. * t), 0.5);\n    b2 = 4. * b2 * (1.-b2);\n    \n    \n    \n    fragColor = vec4(r,g,b2,1.) * 1.4 * (1.-d * d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1160]], "test": "untested"}
{"id": "fd33Ds", "name": "Ray Marching goes wrong", "author": "Spartansky", "description": "Following multiple tutorials from The Art of Code and Inigo Quilez.\n\nI was trying to put a Sphere in the middle and things went crazy. Even without the sphere I was doing some weird stuff. Thought it looked cool.", "tags": ["raymarching", "torus", "beginner"], "likes": 0, "viewed": 70, "published": "Public", "date": "1630863444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPentagon2d( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat GetDist(vec3 p){\n    vec2 torRad = vec2(1.3, 1.);\n    vec2 cp = vec2(length(p.xz) - torRad.x, p.y);\n    float a = atan(p.x, p.z); // polar angle between -pi and pi\n    cp *= Rot(a * 3. + iTime);\n    cp.y = abs(cp.y) - .3;\n    \n    float d = length(cp) - torRad.y;\n    d = sdPentagon2d(cp, .1) - .1;\n    \n    float t = .2 * (sin(iTime) + 80.);\n    float displacement = sin(t * p.x) * cos(t * p.y) * sin(t * p.z) * (sin(iTime * .35) + 1.);\n    \n    return min(d, sdSphere(vec3(0., 0., 0.), .1)) + displacement;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    \n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lp){\n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*2., l);\n    \n    if(d < length(lp - p)) dif *= .6;\n    \n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n    vec3 f = normalize(l - p),\n        r = normalize(cross(vec3(0, 1, 0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u,\n        d = normalize(i);\n        \n     return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14 + 1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0, 0), 1.);\n    vec3 col = vec3 (0.);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        float dif = GetLight(p, vec3(3, 4, -3));\n        dif += GetLight(p, vec3(-3, -4, 3));\n        col = vec3(.2, .9, .2) * dif;\n    }\n    \n    col *= pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd33Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 85, 85, 161], [163, 163, 195, 195, 223], [225, 225, 270, 270, 552], [554, 554, 576, 576, 1070], [1072, 1072, 1105, 1105, 1331], [1332, 1332, 1355, 1355, 1558], [1560, 1560, 1592, 1592, 1811], [1813, 1813, 1862, 1862, 2074], [2076, 2076, 2133, 2133, 2729]], "test": "untested"}
{"id": "fd3Gzl", "name": "raytrace test", "author": "deltuhvee", "description": "basic raymarcher just to learn GLSL", "tags": ["raymarch"], "likes": 1, "viewed": 25, "published": "Public", "date": "1631311983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float epsilon = 0.04;\nconst float bias = 0.004;\nconst float maxDistance = 200.0;\nconst int maxReflections = 4; //can GREATLY affect compilation/render time\n\nvec3 rotate_vector( vec4 quat, vec3 vec ) //shamelessly stolen\n{\nreturn vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );\n}\n\nstruct Ray\n{\n    vec3 position;\n    vec3 incident;\n    int object;\n    int reflectChild;\n    int refractChild;\n    vec3 color;\n};\n\nstruct Material\n{\n    vec3 color;\n    float specularity;\n    float roughness;\n    float transmission;\n};\n\nstruct Object\n{\n    vec3 position;\n    Material material;\n    int type;\n    float data[1];\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    float intensity;\n    int sphere;\n};\n\nvec3 getSkyColor(vec3 dir)\n{\n    float y = normalize(dir).y;\n    return vec3(0.7-0.9*y,0.8-0.9*y,1.0-0.5*y);\n}\n\nfloat sphereDist(vec3 ray, vec3 pos, float rad)\n{\n    return length(ray - pos) - rad;\n}\n\nvec3 sphereN (vec3 ray, vec3 pos)\n{\n    return normalize(ray - pos);\n}\n\nfloat planeDist(vec3 ray, vec3 pos)\n{\n    return ray.y - pos.y;\n}\n\nvec3 planeN()\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\nObject getObject(int object) \n{\n    switch (object) \n    {\n    case 0:\n        return Object( vec3(0.0,10.0*cos(iTime*1.1),0.0), Material(vec3(0.0,0.0,1.0), 0.0, 1.0, 1.0) , 1, float[1](25.0));\n        break;\n    case 1:\n        return Object( vec3(50.0*cos(-iTime*1.5),5.0*cos(iTime*3.0),50.0*sin(-iTime*1.5)), Material(vec3(1.0,0.0,0.0), 0.3, 1.0, 0.0) , 1, float[1](10.0));\n        break;\n    case 2:\n        return Object( vec3(-25.0*sin(iTime),-25.,25.0*cos(iTime)), Material(vec3(1.0,1.0,0.0), 0.0, 1.0, 0.0) , 1, float[1](5.0));\n        break;\n    case 3:\n        return Object( vec3(0.0,-35.0,0.0), Material(vec3(0.0,1.0,0.0), 0.0, 1.0, 0.0), 2, float[1](0.0));\n        break;\n    }\n}\nint sceneLength = 4;\n\nLight getLight(int light)\n{\n    switch (light)\n    {\n    case 0:\n        return Light(vec3(1.0,1.0,-1.0), vec3(1.0,1.0,1.0), 4.0, 1.0, 0);\n        break;\n    }\n}\nint lightsLength = 2;\n\nfloat minDist(vec3 ray, out int object)\n{ \n    float dist = 1000.0;\n    float compareDist = 1000.0;\n    \n    for(int i = 0; i + 1 <= sceneLength; i++) \n    {\n        if(getObject(i).type == 1)\n        {\n            compareDist = sphereDist(ray, getObject(i).position, getObject(i).data[0]);\n        }\n        else if(getObject(i).type == 2)\n        {\n            compareDist = planeDist(ray, getObject(i).position);\n        }\n        //more types here\n        \n        if(abs(compareDist) < dist)\n        {\n            dist = compareDist;\n            object = i;\n        }\n    }\n    \n    return dist;\n    \n}\n\nvec3 getNormal(vec3 ray, int object)\n{\n    vec3 normal;\n    \n    if(getObject(object).type == 1)\n    {\n        normal = sphereN(ray, getObject(object).position);\n    }\n    else if(getObject(object).type == 2)\n    {\n        normal = planeN();\n    }\n    //more types here\n    \n    return normal;\n}\n\nvec2 fresnel(float ior, float theta1, float theta2)\n{\n    //it's actually cosine of theta, not theta itself\n    float n1 = ior;\n    float n2 = 1.0;\n    float Fpa = pow((n2*theta1-n1*theta2)/(n2*theta1+n1*theta2),2.0);\n    float Fpe = pow((n1*theta2-n2*theta1)/(n1*theta2+n2*theta1),2.0);\n    float Fr = (Fpa+Fpe)/2.0;\n    float Ft = 1.0-Fr;\n    return vec2(Fr, Ft);\n}\n\nvec4 castShadow(vec3 position) //TODO: colored lights, multiple light sources\n{\n    vec3 ray = position;\n    int objectHit;\n    float dist;\n    vec3 color;\n    vec3 direction;\n    float intensity;\n    \n    for(int i = 0; i + 1 <= lightsLength; i++)\n    {\n        if(getLight(i).sphere == 0)\n        {\n            direction = normalize(getLight(i).position);\n            \n            \n        } else \n        {\n           direction = normalize(getLight(i).position - position);\n        }\n        \n        ray += direction; //possibly replace this with one based on normal\n        do \n        {\n            dist = minDist(ray, objectHit);\n            ray += direction * (dist + bias);  \n        } while(dist >= epsilon && length(ray) < maxDistance);\n     \n        if(dist >= epsilon)\n        {\n             color += getLight(i).color * getLight(i).intensity;\n             intensity += getLight(i).intensity;\n             intensity = 1.0;\n        }\n        \n    }\n    return vec4(color, intensity);\n}\n\nvec4 selfShadow(vec3 position, int object) //TODO: same as castShadow()\n{\n    int objectHit;\n    vec4 color;\n    for(int i = 0; i + 1 <= lightsLength; i++)\n    {\n        if(getLight(i).sphere == 0)\n        {\n            return vec4(getLight(i).color, max(0.0, min(1.0, minDist(position + normalize(getLight(i).position), objectHit))));\n            \n        } else \n        {\n           return vec4(getLight(i).color, max(0.0, min(1.0, minDist(position + normalize(getLight(i).position - position), objectHit))));\n        }\n    }\n    \n    //return color;\n}\n\n\nRay castReflection(vec3 position, vec3 incident, int object)\n{\n    vec3 ray = position;\n    int objectHit;\n    float dist;\n    vec3 color;\n    vec3 normal;\n    int reflections = 0;\n    vec3 direction;\n    \n    normal = getNormal(ray, object);\n    ray += normal * 0.3; //this may be too low! check this if issues come up\n    direction = reflect(incident, normal); //introduce randomness with roughness (via rotating normal)\n    do \n    {\n        dist = minDist(ray, object);\n        ray += direction * (dist + bias);  \n    } \n    while(dist >= epsilon && length(ray) < maxDistance);\n    if(dist <= epsilon)\n    {\n        return Ray(ray,direction,object,-1,-1,getObject(object).material.color);\n    } else\n    {\n        return Ray(ray,direction,-1,-1,-1,getSkyColor(direction));\n    }\n}\n\nRay castRefraction(vec3 position, vec3 incident, int object) \n{\n    vec3 ray = position;\n    int objectHit = object;\n    float dist;\n    vec3 color;\n    vec3 normal;\n    int reflections = 0;\n    vec3 direction;\n    vec3 refractionIncident;\n    \n    normal = getNormal(ray, object);\n    ray -= normal * 0.3; \n    direction = refract(incident, 1.0*normal, 0.55); //introduce randomness with roughness (via rotating normal)\n    if(direction == vec3(0.0,0.0,0.0))\n    {\n        direction = reflect(incident, normal);\n    }\n    refractionIncident = direction;\n    do \n    {\n        dist = abs(minDist(ray, object));\n        ray += direction * (dist + bias);  \n    } \n    while(dist >= epsilon && length(ray) < maxDistance);\n    \n    \n    if(object == objectHit)\n    {\n        //return Ray(ray,direction,1,-1,-1,vec3(1.0,1.0,1.0));\n        normal = getNormal(ray, object);\n        ray += normal * 1.0; \n        direction = refract(refractionIncident, -1.0*normal, 1.8); //introduce randomness with roughness (via rotating normal)\n        if(direction == vec3(0.0,0.0,0.0))\n        {\n            direction = reflect(refractionIncident, -1.0*normal);\n        }\n        do \n        {\n            dist = abs(minDist(ray, object));\n            ray += direction * (dist + bias);  \n        } \n        while(dist >= epsilon && length(ray) < maxDistance);\n    }\n    \n    \n    if(dist <= epsilon)\n    {\n        //return Ray(ray,direction,int(ray.x)%3,-1,-1,vec3(1.0,1.0,1.0));\n        return Ray(ray,direction,object,-1,-1,getObject(object).material.color);\n    } else\n    {\n        //return Ray(ray,direction,int(direction.x*100.0)%3,-1, -1,vec3(1.0,1.0,1.0));\n        return Ray(ray,direction,-1,-1,-1,getSkyColor(direction));\n    }\n}\n\nvec3 castRay(vec3 position, vec3 direction)\n{\n    vec3 ray = position;\n    int objectHit;\n    float dist;\n    vec3 color;\n    float shadowColor;\n    vec3 reflectionColor;\n    vec3 refractionColor;\n    vec3 objectColor;\n    int reflections = 0;\n    float spec;\n    float tran;\n    int object;\n    int newObject;\n    const int raysIndexLength = int(pow(2.0,float(maxReflections))-1.0);\n    Ray rays[raysIndexLength];//pos inc ob lc rc col\n    \n    do \n    {\n        dist = minDist(ray, objectHit);\n        ray += direction * dist + bias;  \n    } while(dist >= epsilon && length(ray) < maxDistance);\n        \n    if(dist <= epsilon)\n    {\n        spec = getObject(objectHit).material.specularity;\n        tran = getObject(objectHit).material.transmission;\n        if(spec > 0.0 || tran > 0.0)\n        {\n            color = getObject(objectHit).material.color * min(castShadow(ray).w, selfShadow(ray, objectHit).w);\n            rays[0] = Ray(ray, direction, objectHit, 1, 2, color);\n            if(spec > 0.0)\n            {\n            rays[1] = Ray(ray, direction, objectHit, 0, 0, vec3(0.0));\n            } else { rays[1] = Ray(vec3(0.0),vec3(0.0),-1,-1,-1,vec3(0.0)); }\n            \n            if(tran > 0.0)\n            {\n            rays[2] = Ray(ray, direction, objectHit, 0, 0, vec3(0.0));\n            } else { rays[2] = Ray(vec3(0.0),vec3(0.0),-1,-1,-1,vec3(0.0)); }\n        } else\n        {\n            return getObject(objectHit).material.color * min(castShadow(ray).w, selfShadow(ray, objectHit).w);\n        }\n    \n    } else\n    {\n        return getSkyColor(direction);\n    }\n    \n    for(int i=1;i < rays.length(); i++)\n    {\n        if(rays[i].object != -1)\n        {\n            ray = rays[i].position;\n            direction = rays[i].incident;\n            object = rays[i].object;\n            \n            if(getObject(rays[i].object).material.specularity > 0.0) //float point error possible?\n            {\n                rays[i] = castReflection(ray, direction, object);\n                if((2*(i+1)) <= raysIndexLength)\n                {\n                    rays[(2*(i+1))-1] = rays[i];\n                    rays[i].reflectChild = (2*(i+1))-1;\n                    rays[i].refractChild = 2*(i+1);\n                } else\n                {\n                    rays[i].reflectChild = -1;\n                    rays[i].refractChild = -1;\n                }\n                \n            } else\n            {\n                rays[(2*(i+1))-1] = Ray(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), -1, -1, -1, vec3(0.0,0.0,0.0));\n            }\n            \n            if(getObject(rays[i].object).material.transmission > 0.0) //float point error possible?\n            {\n                rays[i] = castRefraction(ray, direction, object);\n                if((2*(i+1)-1) <= raysIndexLength)\n                {\n                    rays[(2*(i+1))] = rays[i];\n                    rays[i].reflectChild = (2*(i+1))-1;\n                    rays[i].refractChild = 2*(i+1);\n                } else\n                {\n                    rays[i].reflectChild = -1;\n                    rays[i].refractChild = -1;\n                }\n            } else \n            {\n                rays[2*(i+1)] = Ray(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), -1, -1, -1, vec3(0.0,0.0,0.0));\n            }\n            \n            \n        } else if(rays[i].object == -1)\n        {\n            rays[(2*(i+1))-1] = Ray(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), -1, -1, -1, vec3(0.0,0.0,0.0));\n            rays[2*(i+1)] = Ray(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0), -1, -1, -1, vec3(0.0,0.0,0.0));\n        }\n    }\n    for(int i=1;i <= rays.length(); i++)\n    {\n        if(rays[rays.length()-i].reflectChild != -1)\n        {\n            reflectionColor = rays[rays[rays.length()-i].reflectChild].color;\n        }\n        if(rays[rays.length()-i].refractChild != -1)\n        {\n            refractionColor = rays[rays[rays.length()-i].refractChild].color;\n        }\n        //get snells law (fresnel) in here eventually instead of this lerp\n        \n        if(length(rays[rays.length()-i].position) < maxDistance)\n        {\n            object = rays[rays.length()-i].object;\n            spec = getObject(object).material.specularity;\n            tran = getObject(object).material.transmission;\n            \n            objectColor = getObject(object).material.color * min(castShadow(rays[rays.length()-i].position).w, selfShadow(rays[rays.length()-i].position, object).w);\n            if(spec > 0.0)\n            {\n                objectColor = mix(objectColor,reflectionColor, spec);\n            }\n            if(tran > 0.0)\n            {\n                objectColor = mix(objectColor,refractionColor, tran);\n            }\n        \n            rays[rays.length()-i].color = objectColor;\n        } else {rays[rays.length()-i].color = getSkyColor(rays[rays.length()-i].incident);} \n    }\n    return rays[0].color; //the issue is happening with objects 1+. Object 0 reflects ok but everything else breaks\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    int remove;\n    vec4 quat = vec4(0.0, cos(iTime*0.5), 0.0, sin(iTime*0.5));\n    vec3 col = castRay(vec3(sin(iTime)*100.0,0.0,cos(iTime)*100.0), rotate_vector(quat , normalize(vec3((uv.x*2.0-1.0)*aspectRatio, uv.y*2.0-1.0, 2.0))) );\n    fragColor = vec4(col,1.0);//col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3Gzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 163, 227, 227, 306], [749, 749, 777, 777, 859], [861, 861, 910, 910, 948], [950, 950, 985, 985, 1020], [1022, 1022, 1059, 1059, 1087], [1089, 1089, 1104, 1104, 1138], [1140, 1140, 1171, 1171, 1832], [1855, 1855, 1882, 1882, 2016], [2040, 2040, 2081, 2081, 2647], [2649, 2649, 2687, 2687, 2944], [2946, 2946, 2999, 3053, 3313], [3315, 3315, 3394, 3394, 4312], [4314, 4314, 4387, 4387, 4869], [4872, 4872, 4934, 4934, 5656], [5658, 5658, 5721, 5721, 7378], [7380, 7380, 7425, 7425, 12328], [12330, 12330, 12387, 12437, 12818]], "test": "untested"}
{"id": "fd3SR4", "name": "2d rasterizer", "author": "icantcomeupwithausername", "description": "simple 2d rasterizer that renders a quad\nedit: fixed color interpolation", "tags": ["rasterizer", "triangle", "quad"], "likes": 4, "viewed": 69, "published": "Public", "date": "1632689859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define clearColor vec3(0.0)\n#define vertexCount 6\n\n//defines a vertex\nstruct Vertex{\n    vec3 position, color;\n};\n\n//verticies\nVertex verticies[vertexCount];\n\n//doing this so it can run on older versions of glsl\nvoid initVerticies(){\n    verticies[0] = Vertex(vec3(-0.5,0.5,0.0),vec3(0.0,1.0,0.0));\n    verticies[1] = Vertex(vec3(0.5,0.5,0.0),vec3(0.0,0.0,0.0));\n    verticies[2] = Vertex(vec3(0.5,-0.5,0.0),vec3(0.0,0.0,1.0));\n    verticies[3] = Vertex(vec3(0.5,-0.5,0.0),vec3(0.0,0.0,1.0));\n    verticies[4] = Vertex(vec3(-0.5,-0.5,0.0),vec3(1.0,0.0,0.0));\n    verticies[5] = Vertex(vec3(-0.5,0.5,0.0),vec3(0.0,1.0,0.0));\n}\n\n//checks if point is in triangle\nbool pointInTriangle(vec2 a, vec3 b, vec2 c){\n    return ((c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x)>=0.0);\n}\n\n//interpolation\nvec3 interpolate(vec3 v1,vec3 v2,vec3 v3,vec3 a,vec3 b,vec3 c,vec2 uv){\n    float h = ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    float weight1 = ((v2.y-v3.y)*(uv.x-v3.x)+(v3.x-v2.x)*(uv.y-v3.y))/h;\n    float weight2 = ((v3.y-v1.y)*(uv.x-v3.x)+(v1.x-v3.x)*(uv.y-v3.y))/h;\n    float weight3 = 1.0-weight1-weight2;\n\n    return a*weight1+b*weight2+c*weight3/(weight1+weight2+weight3);\n}\n\n//rotation on z axis\nmat4 rotateZ(float rotation){\n    float sr = sin(rotation);\n    float cr = cos(rotation);\n    \n    return mat4(cr,-sr,0.0,0.0,\n                sr,cr,0.0,0.0,\n                0.0,0.0,1.0,0.0,\n                0.0,0.0,0.0,1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    initVerticies();\n\n    //normalize pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = clearColor;\n    \n    //loop through each vertex\n    for(int i=0;i<vertexCount;i+=3){\n        Vertex v1 = verticies[i];\n        Vertex v2 = verticies[i+1];\n        Vertex v3 = verticies[i+2];\n        \n        //make rotation matrix\n        mat4 rotation = rotateZ(iTime);\n        \n        //rotate vertex positions\n        vec3 va = (vec4(v1.position,1.0)*rotation).xyz;\n        vec3 vb = (vec4(v2.position,1.0)*rotation).xyz;\n        vec3 vc = (vec4(v3.position,1.0)*rotation).xyz;\n        \n        //check if point is in triangle\n        bool ia = pointInTriangle(va.xy,vb,uv);\n        bool ib = pointInTriangle(vb.xy,vc,uv);\n        bool ic = pointInTriangle(vc.xy,va,uv);\n        \n        if(ia==ib&&ib==ic){\n            //calculate pixel color if in triangle\n            col = interpolate(va,vb,vc,v1.color,v2.color,v3.color,uv);\n            break;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 213, 234, 234, 626], [628, 661, 706, 706, 767], [769, 785, 856, 856, 1179], [1181, 1202, 1231, 1231, 1428], [1431, 1431, 1485, 1485, 2555]], "test": "untested"}
{"id": "fd3SRN", "name": "Deconstructive Cube ", "author": "Tater", "description": "You can turn on shadows if you have extra fps. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 45, "viewed": 539, "published": "Public API", "date": "1632725036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n//https://www.shadertoy.com/view/fdyGDt\n//https://www.shadertoy.com/view/7dVGDd\n\n//heavily inspired by\n//https://twitter.com/adamswaab/status/1437498093797212165\n\n//Toggle Shadows\n//#define USE_SHADOWS \n\n\n\n\n#define MDIST 350.0\n#define STEPS 128.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//iq box sdf\nfloat ebox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec3 rdg = vec3(0);\nfloat nsdf = 0.;\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    vec3 po = p;\n    float t = iTime;\n    \n    bvec3 isEdge = bvec3(true);\n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    vec3 dMini = dMin;\n    vec3 dMaxi = dMax;\n    \n    float id = 0.;\n    float seed = floor(t/4.);\n    \n    float MIN_SIZE = 0.5;\n    float ITERS = 5.;\n    float PAD_FACTOR = 1.01;\n    float BREAK_CHANCE = 0.2;\n   \n    vec3 dim = dMax - dMin;\n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        if(i==0.0){\n        divHash = vec3(0.49,0.5,.51);\n        }\n        if(i>0.){\n            vec3 center = -(dMin + dMax)/2.0;\n\n            vec3 cs = vec3(0.3);\n            divHash = clamp(divHash,vec3(cs*sign(center)),vec3(1.0-cs*sign(-center)));\n\n        }\n        vec3 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE * PAD_FACTOR , dMax - MIN_SIZE * PAD_FACTOR );\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        \n        float minSize = min( minAxis.x, min( minAxis.y, minAxis.z ) );\n        bool smallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        if (i  > 0. && h11( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if (smallEnough && i  > 0.) { willBreak = true; }\n        if( willBreak ) {\n            break;\n        }\n\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        float pad = 0.01;\n        if(dMaxi.x>dMax.x+pad&&dMini.x<dMin.x-pad)isEdge.x=false;\n        if(dMaxi.y>dMax.y+pad&&dMini.y<dMin.y-pad)isEdge.y=false;\n        if(dMaxi.z>dMax.z+pad&&dMini.z<dMin.z-pad)isEdge.z=false;\n        \n        \n        vec3 diff = mix( -divide, divide, step( p, divide));\n        id = length(diff + 1.0);\n    \n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n    float b = 0.;\n\n    \n    if(any(isEdge)) {\n        float expand = 1.0+(3.0-h11(id)*3.)*swave(t*3.0+h11(id)*1.5,0.17);\n        if(isEdge.x){\n        center.x*=expand;\n        }\n        else if(isEdge.y){\n        center.y*=expand;\n        }\n        else if(isEdge.z){\n        center.z*=expand;\n        }\n    }\n    vec3 edgeAxis = mix(dMin, dMax, step(0.0, rd));\n    vec3 dAxis = abs(p - edgeAxis) / (abs(rd) + 1E-4);\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    b= dEdge;\n\n    vec3 d = abs(center);\n    dim-=0.4;\n    float a = ebox(p-center,dim*0.5)-0.2;\n\n    if(!any(isEdge)){\n        a=b;\n\n        nsdf =5.;\n    }\n    else nsdf = a;\n    a = min(a, b);\n\n    \n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n\nvec3 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(1);\n\n    vec3 scl = vec3(10.);\n    vec3 rd2 = rdg;\n\n    p.xz*=rot(t);\n    rd2.xz*=rot(t);\n    p.xy*=rot(pi/4.);\n    rd2.xy*=rot(pi/4.);\n    a = blocks(p,scl,rd2)+0.01;\n    \n   \n    a.x = max(box(p,vec3(scl*2.0)),a.x);\n    \n\n    return vec3(a,nsdf);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,3.5,-20)*2.;\n    if(iMouse.z>0.){\n    ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(0.99)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec3 d = vec3(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(abs(d.x)<0.0001||i==STEPS-1.){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.,1.,0));\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.4,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        \n        \n        float shadow = 1.;\n        \n#ifdef USE_SHADOWS\n        rdg = ld;\n        for(float h = 0.09; h<10.0;){\n            vec3 dd = map(p+ld*h+n*0.2);\n            if(dd.x<0.001){shadow = 0.3; break;}\n            //shadow = min(shadow,dd.z*20.0);\n            h+=dd.x;\n        }\n#endif\n        \n        //lighting EQs from @blackle\n        float spec = length(sin(r*5.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*0.9;\n        \n        float diff = length(sin(n*2.)*.5+.65)/sqrt(3.);\n        \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).z)\n        float ao = AO(0.3,n,p)*AO(.5,n,p)*AO(.9,n,p);\n        col = al*diff+pow(spec,5.0)*fres*shadow;\n        col*=pow(ao,0.2);\n        col*=max(shadow,0.7);\n\n    }\n    col = pow(col,vec3(0.9));\n    vec3 bg = vec3(0.698,0.710,0.878)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,pow(clamp(dO/MDIST,0.,1.),2.0));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3SRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 519, 586, 586, 625], [626, 626, 646, 646, 717], [718, 718, 739, 739, 791], [792, 792, 818, 818, 877], [878, 891, 920, 920, 1007], [1009, 1009, 1039, 1039, 1142], [1180, 1180, 1219, 1219, 3981], [3983, 3983, 4000, 4000, 4307], [4308, 4308, 4326, 4326, 4454], [4455, 4455, 4512, 4512, 6493]], "test": "untested"}
{"id": "fdcGWs", "name": "vidya flashing boxes", "author": "vidya", "description": "animated rectangle boxes", "tags": ["flashing", "rectangle", "boxes"], "likes": 0, "viewed": 19, "published": "Public", "date": "1630831456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rect(vec2 uv, vec3 color, float blur, float animSpeed, vec4 dim) {\n    float anim = abs(sin(iTime * animSpeed)) * blur;\n    \n    vec2 bottom_left = vec2(smoothstep(dim.x-anim, dim.x+anim, uv.x), smoothstep(dim.y-anim, dim.y+anim, uv.y));\n    vec2 top_right = vec2(1.0-smoothstep(dim.z-anim, dim.z+anim, uv.x), 1.0-smoothstep(dim.w-anim, dim.w+anim, uv.y));\n    \n    vec3 result = bottom_left.x * bottom_left.y * top_right.x * top_right.y * color;\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 0.0, 1.0);\n    \n    vec3 r1 = rect( uv, red, 0.09, 1.0, vec4(0.1, 0.8, 0.2, 0.9) );\n    \n    vec3 r2 = rect( uv, green, 0.06, 0.75, vec4(0.1, 0.6, 0.2, 0.7) );\n    \n    vec3 r3 = rect( uv, blue, 0.03, 0.5, vec4(0.3, 0.8, 0.4, 0.9) );\n    \n    vec3 r4 = rect( uv, yellow, 0.2, 2.0, vec4(0.3, 0.6, 0.4, 0.7) );\n    \n    vec3 col = r1 + r2 + r3 + r4;\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 71, 71, 472], [475, 475, 532, 532, 1096]], "test": "untested"}
{"id": "fdcSR4", "name": "hello_triangle", "author": "rytis_p", "description": "Playing around; sines, Voronoi, triangle, kinda spheres. Also, kinda slow (:", "tags": ["2d", "voronoi"], "likes": 8, "viewed": 164, "published": "Public API", "date": "1632693035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat pretty_sine(vec2 uv)\n{\n    float d = (sin(uv.x) - uv.y);\n    float d1 = 4.0 * d;\n    float d2 = 16.0 * d;\n    float sine = 0.5 * sin(uv.x + iTime);\n    float s = mix(d1, d2, sine + 0.5);\n    float result = 1.0 + 0.75 * (-sine + 0.5) - abs(s);\n    return result;\n}\n\nfloat circle(vec2 p, float r) \n{\n    float result = length(p) - r;\n    return result;\n}\n\n// NOTE(rytis): Taken from https://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nvec2 random2(vec2 p)\n{\n    vec2 result = fract(sin(vec2(dot(p, vec2(389.9, 441.1)),\n                                 dot(p, vec2(598.3, 290.4)))) * PI * 20000.0);\n    return result;\n}\n\nstruct Pretty_Sine_Data\n{\n    vec2 uv;\n    vec3 color;\n    float multiplier;\n};\nvec4 edge(vec2 uv, vec2 p0, vec2 p1)\n{\n    vec2 diff = p1 - p0;\n    vec2 n_diff = normalize(diff);\n    float half_diff_length = 0.5 * length(diff);\n    vec2 uv_x = vec2(1.0, 0.0);\n    vec2 uv_y = vec2(0.0, 1.0);\n    \n    float cos_a = dot(uv_x, n_diff);\n    float sin_a = dot(uv_y, n_diff);\n    vec2 p = vec2(cos_a * uv.x + sin_a * uv.y,\n                  -sin_a * uv.x + cos_a * uv.y);\n\n    vec2 offset = 0.5 * (p0 + p1);\n    vec2 xn = cos_a * uv_x + sin_a * uv_y;\n    vec2 yn = -sin_a * uv_x + cos_a * uv_y;\n    \n    vec2 new_offset = vec2(dot(offset, xn), dot(offset, yn));\n    \n    p -= new_offset;\n    \n    Pretty_Sine_Data data[8] = Pretty_Sine_Data[8](\n        Pretty_Sine_Data(      vec2(p.x + 0.22 * iTime, 2.0 * p.y),       vec3(0.5, 0.5, 2.0),  1.0),\n        Pretty_Sine_Data(      vec2(p.x + 0.13 * iTime, 1.6 * p.y),       vec3(0.3, 0.7, 1.0),  1.0),\n        Pretty_Sine_Data(2.0 * vec2(p.x + iTime, 2.0 * p.y),              vec3(0.8, 0.2, 0.6),  1.0),\n        Pretty_Sine_Data(1.3 * vec2(p.x + 0.5 * iTime, 1.7 * p.y),        vec3(0.4, 0.3, 0.7),  1.0),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime, 2.5 * p.y),              vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.5, 2.5 * p.y), 0.8  * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(0.8 * vec2(p.x - iTime + 0.9, 2.5 * p.y), 0.64 * vec3(0.8, 1.3, 0.8),  0.5),\n        Pretty_Sine_Data(3.5 * vec2(p.x - 1.24 * iTime, p.y),             vec3(1.7, 0.7, 0.0),  1.0)\n    );\n    \n    float output_dist = 0.0;\n    vec3 output_color = vec3(0.0);\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        float d = pretty_sine(data[i].uv);\n        float limit = (p.x < -half_diff_length || p.x > half_diff_length) ? 0.0 : 1.0;\n        float cd = limit * data[i].multiplier * clamp(d, 0.0, 1.0);\n        output_color += cd * data[i].color;\n        output_dist += cd;\n    }\n    return vec4(output_color, -0.125 * output_dist);\n}\n\n// NOTE(rytis): Taken from https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/\nfloat edge_f(vec2 p, vec2 e0, vec2 e1)\n{\n    float result = (e0.y - e1.y) * p.x + (e1.x - e0.x) * p.y + e0.x * e1.y - e0.y * e1.x;\n    return result;\n}\n\nstruct Point\n{\n    vec3 color;\n    float d;\n    vec2 p;\n};\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n    uv.x -= 0.5 * (aspect_ratio - 1.0);\n    uv = uv * 2.0 - 1.0;\n    \n    uv *= 8.0;\n\n    vec2 p0 = vec2(-3.0 + sin(iTime), -5.0 + cos(iTime));\n    vec2 p1 = vec2(7.0 + cos(0.5 * iTime), 0.0 - sin(iTime));\n    vec2 p2 = vec2(-2.0 + cos(0.5 * iTime), 5.0 - sin(0.44 * iTime));\n\n    Point points[3] = Point[3](\n        Point(vec3(0.5), circle(uv - p0, 1.2), p0),\n        Point(vec3(0.5), circle(uv - p1, 1.2), p1),\n        Point(vec3(0.5), circle(uv - p2, 1.2), p2)\n    );\n    \n    vec3 color = vec3(0.0);\n    float area_tri = 0.5 * edge_f(p0, p1, p2);\n    float inv_area_tri = 1.0 / area_tri;\n    float area_p01 = edge_f(uv, p0, p1);\n    float area_p12 = edge_f(uv, p1, p2);\n    float area_p20 = edge_f(uv, p2, p0);\n\n    float multiplier = smoothstep(-0.25, 0.5, -inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    float waves = 0.0;\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 8.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(vec2(uv.x, -uv.y) / 4.0));\n    waves += multiplier * smoothstep(1.0, 1.5, pretty_sine(uv / 2.0));\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n    float min_dist = 1.0;\n    for(int i = -1; i <= 1; ++i)\n    {\n        for(int j = -1; j <= 1; ++j)\n        {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 random_point = random2(i_uv + neighbor);\n            random_point = 0.5 + 0.5 * vec2(sin(2.0 * PI * random_point + 0.5 * iTime));\n            vec2 diff = neighbor + random_point - f_uv;\n            float dist = length(diff);\n            min_dist = min(dist, min_dist);\n        }\n    }\n    vec2 waves_smooth = smin(min_dist, waves, 0.1);\n    color += multiplier * 3.0 * smoothstep(0.5, -0.5, -waves_smooth.y) * vec3(0.20, 0.23, 0.3);\n    color += multiplier * min_dist * vec3(0.20, 0.23, 0.3);\n    \n    \n    if(area_p01 >= 0.0 && area_p12 >= 0.0 && area_p20 >= 0.0)\n    {\n        color = mix(color, vec3(0.5), 3.0 * inv_area_tri * min(min(area_p01, area_p12), area_p20));\n    }\n    \n    vec4 e0 = edge(uv, p0, p1);\n    vec4 e1 = edge(uv, p1, p2);\n    vec4 e2 = edge(uv, p2, p0);\n    color += e0.xyz;\n    color += e1.xyz;\n    color += e2.xyz;\n    float edge_dist = min(min(e0.w, e1.w), e2.w);\n    for(int i = 0; i < 3; ++i)\n    {\n        if(points[i].d < edge_dist)\n        {\n            vec2 smooth_dist = smin(points[i].d, edge_dist, 0.3);\n            vec2 p_on_sphere = uv - points[i].p;\n            vec3 sphere_normal = normalize(vec3(p_on_sphere.x, p_on_sphere.y, smooth_dist.x));\n            vec3 light_dir = normalize(-vec3(uv.x, uv.y, 4.0));\n            float atten = max(dot(sphere_normal, light_dir), 0.0);\n            color = mix(points[i].color * (0.5 + 0.5 * atten * atten), color, smooth_dist.y);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 295], [297, 297, 329, 329, 384], [386, 463, 503, 503, 647], [649, 649, 671, 671, 832], [914, 914, 952, 952, 2836], [2838, 2933, 2973, 2973, 3084], [3145, 3145, 3200, 3200, 6097]], "test": "untested"}
{"id": "fdcSzH", "name": "Lasergame", "author": "supah", "description": "Laser game", "tags": ["game", "atan", "laser"], "likes": 1, "viewed": 44, "published": "Public", "date": "1632568527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define P 3.14159265\nmat2 r(float a){\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\nfloat m (vec2 u, float t) {\n    u *= r(t);\n    return S(-P,P,atan(u.x, u.y)) * S(0.45, 1., 1. - length(u));\n}\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    float t = iTime;\n    vec2 u = (I-.5*R)/R.y;\n    float c1 = m(vec2(u.x + .25, u.y), sin(t)*P+P*.5);\n    float c2 = m(vec2(u.x - .25, u.y), sin(-t)*P+P*.5);\n    vec3 C1 = vec3(0.1, 0.1, 0.9);\n    vec3 C2 = vec3(0.9, 0.1, 0.1);\n    O = vec4(mix(C1, C2, c1) * mix(C1, C2, 1. - c2),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcSzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 58, 58, 124], [125, 125, 152, 152, 234], [235, 235, 276, 276, 594]], "test": "untested"}
{"id": "fdcXRM", "name": "hyz霓虹学习", "author": "huangyz", "description": "学习用", "tags": ["2d"], "likes": 8, "viewed": 96, "published": "Public", "date": "1632975186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat rand(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat drawLayer(float cellNum,vec2 uv){\n    //纹理坐标放大cellNum倍，目的是为了将屏幕分割成cellNum * (cellNum*ratio)块，然后计算出coord和pt\n    vec2 uv0 = uv*cellNum;\n    //避免排列太整齐，根据y坐标随机左右平移\n    uv0.x+=rand(vec2(floor(uv0.y)));\n    \n    //当前是哪一个格子\n    vec2 coord = floor(uv0);\n    //当前这个点，在这个格子内的坐标，xy的值范围【0,1】\n    vec2 pt = fract(uv0);\n    \n    //随机出一个半径大小，此时为【0,1】\n    float radius = rand(coord);\n    //一个跟半径相关的亮度\n    float strength = radius;\n    \n    //真实径范围【0.2,0.45】*1.0/cellNum;\n    radius = radius*0.25+0.2;\n    \n    //去掉2/3的点\n    if(mod(radius*10.0,3.0)<2.0){\n        return 0.0;\n    }\n    \n    //当前点距离圆心的范围\n    float dis = distance(pt,vec2(0.5,0.5));\n    \n    //强度最后再整体根据cellNum区分一下，加强层次感\n    strength*=1.0/cellNum*12.0;\n    //strength*=1.0-dis*2.0;\n\n    //画圆\n    float a = smoothstep(radius-0.03,radius,dis);\n    a = 1.0-a;\n    \n    a*=strength;\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //纹理坐标归一化，y轴0-1\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    //三层颜色\n    vec3 arr[3];\n    arr[0] = vec3(0.64,0.18,0.80);    \n    arr[1] = vec3(0.67,0.71,0.31);\n    arr[2] = vec3(0.9,0.0,0.2);\n    \n    //背景色\n    vec3 color_left = vec3(0.79,0.28,0.29);\n    vec3 color_right = vec3(0.4,0.4,0.2);\n    \n    float z = 0.0;//记录这个点是否已经绘制过\n    //分三层绘制，颜色相加\n    for(int i=0;i<=2;i++){\n        vec3 color = arr[i];\n        //cellNum 每一层将屏幕分成多少个格子\n        float cellNum = float(i)*2.5+5.0;\n        //随机出一个方向，根据时间做偏移\n        vec2 uvoff = vec2( rand( vec2(cellNum*2.0) ), 0.5+0.5*rand( vec2( cellNum * 12.0 ) ) );\n        uvoff = uvoff * iTime * 0.1;\n        vec2 pt = uv+uvoff;\n        \n        //当前坐标的透明度\n        float a=drawLayer(cellNum,pt);\n        \n        //已经有颜色的，避免覆盖，以免分层穿帮\n        if(z<0.01){\n            col += color*a;\n        }\n        z += a;\n    }\n    \n    col+=mix(color_left,color_right,uv.x);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [91, 91, 130, 257, 1221], [1223, 1223, 1280, 1318, 2465]], "test": "untested"}
{"id": "fdcXWH", "name": "random point gradients:  h/t/b", "author": "FabriceNeyret2", "description": "point distribution gradient, rather than pixel noise gradient as in https://shadertoy.com/view/fscSWH\nclick to see tiles.\ntop: pos = white noise  procedural ( float hash )\nmid: pos = white noise  texture\nbottom: pos = blue noise ( no effect here :-) ).", "tags": ["gradient", "poisson", "hash", "dithering", "bluenoise", "whitenoise", "pointdistribution"], "likes": 3, "viewed": 186, "published": "Public API", "date": "1633006205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lagrangian variant of https://shadertoy.com/view/fscSWH\n\n#define hash(p)  fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define T(c)     texelFetch(c, ivec2(U) % textureSize(c,0).xy, 0).xy \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P = u/R, T,D,H;\n    u.x += float(iFrame);\n    T = u / 16.;\n    O-=O;\n    float d = 99.;\n    for ( float i=0.; i < 256.*(1.-P.x); i++ ) {\n        U = floor(T) + i*13.7;\n        H =   P.y > .66 ? hash(U)\n            : P.y > .33 ? T(iChannel0) \n            :             T(iChannel1);\n        D = fract(T) - H;\n        d = min(d, dot(D,D));\n     // O = max(O, 1.3 - 16.*sqrt(d) );\n     // O += (1.-O) * clamp( 1.3 - 16.*sqrt(d) , 0.,1.);\n    }\n        \n    O = vec4( 1.3 - 16.*sqrt(d) );   // draw closest point\n    if ( int(u.y) % (int(R.y)/3) == 0 ) O = vec4(1,0,0,1); // horizontal separator\n    u = fract((u-.5)/16.);\n    if ( iMouse.z>0. && u.x*u.y==0.) O = vec4(0,0,1,1);    // if click, draw grid\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcXWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 210, 248, 248, 983]], "test": "untested"}
{"id": "fdd3DB", "name": "Ray Marching Test Part 3", "author": "dcyang", "description": "ray marching view matrix", "tags": ["raymarching"], "likes": 0, "viewed": 91, "published": "Public API", "date": "1630594251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n/* 一个立方体的SDF */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.414;\n}\n\n/* 场景的SDF，为球和立方体的交集 */\nfloat sceneSDF(vec3 samplePoint){\n    float res = max(cubeSDF(samplePoint),sphereSDF(samplePoint));\n    return res;\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP && depth < end;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\n/* 摄像机的旋转矩阵 */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 v = normalize(eye - center);\n    vec3 r = normalize(cross(up,v));\n    vec3 u = cross(v,r);\n    vec3 t = vec3(-dot(eye,r),-dot(eye,u),-dot(eye,v));\n    return mat4(\n        vec4(r,t.x),\n        vec4(u,t.y),\n        vec4(v,t.z),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    mat4 rotateMatrix = viewMatrix(eye,vec3(0.0),vec3(0.0,1.0,0.0));\n    vec3 worldDir = (rotateMatrix*vec4(viewDir,0.0)).xyz;\n    float dist = shortestDistanceFromEyeToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 5.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 141, 164, 315, 752], [754, 776, 810, 810, 852], [854, 903, 936, 936, 1020], [1022, 1113, 1205, 1205, 1457], [1458, 1543, 1608, 1608, 1740], [1742, 1837, 1866, 1866, 2176], [2177, 2275, 2367, 2367, 2659], [2660, 2754, 2830, 2830, 3052], [3053, 3084, 3133, 3133, 3408], [3409, 3409, 3466, 3466, 4157]], "test": "untested"}
{"id": "fdd3Wj", "name": "Cubic Waves", "author": "lambmeow", "description": "Wanna get back on the groove of things", "tags": ["raymarch", "sdf", "cube", "sin", "trig"], "likes": 9, "viewed": 179, "published": "Public API", "date": "1630655207", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat2 rot(float f)\n{\n\tfloat c = cos(f), s = sin(f);\n\treturn mat2(c ,-s,s,c);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat scene(vec3 p) \n{\n\tfloat oz = p.z;\n\t\n\tp.z = mod(p.z + 1., 1.) - 1.;\n\tfloat res = 1000.;\n\t\n\tfor(int i = 0; i < 20; i++)\n\t{\n\t\tfloat offset = iTime +  float(i) + oz ;\n\t\tvec3 rotp = p;\n\t\trotp.xy *= rot(iTime*0.5 + float(i) - oz );\n\t\t//rotp.xz *= rot (time + oz) * 0.001;\n\t\tres  = min( res, box(rotp - vec3(sin(offset) , cos(offset), 0),vec3(0.45 *abs(sin(iTime - sin(float(i) * 0.05) * 2.) + cos(iTime *0.55) *0.5)))); \n\t}\n\treturn res;\n}\n\nvec4 ray(vec3 ro, vec3 rd)\n{\n\tfloat dist = 0., closest = 255.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tvec3 pos = ro + rd * dist;\n\t\tfloat len = scene(pos);\n\t\t\n\t\tdist += len;\n\t\tclosest = min(len, closest);\n\t\t\n\t\tif ( len < 0.001 || dist > 100.)\n\t\t\tbreak;\n\t}\n\treturn vec4(ro + rd * dist, dist);\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 eps = vec2(0.01, 0);\n\treturn normalize(scene(p) - vec3(scene(p - eps.xyy) , scene(p - eps.yxy), scene(p - eps.yyx)));\n}\n\nvec4 color(vec4 res, vec3 lp, vec2 u)\n{\n\tvec3 n = norm(res.xyz), p = res.xyz;\n\tvec3 ldir = lp - p, nldir = normalize(ldir);\n\n\tvec3 amb = vec3(0, .5, 1) * u.x;\n\t\t\n\tif(res.w > 12.) \n\t return vec4(amb , 1.);\n\t \n\tvec3 diff = vec3(0.7, .4, 1) * dot(nldir, n);\n\t\n\tvec3 glow = vec3(0, .3, 0) * (1.- res.w/10.);\n\tvec3 color = clamp(diff, 0.,1.) + clamp(amb,0.,1.) * 0.1;\n\t\n\tcolor = mix(color, amb, res.w/10.);\n\treturn vec4(color , 1); //vec4(dot(n, normalize(ldir))) * (1/(1 + dot(ldir, ldir)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy, u = (2. *  fragCoord - r)/r.y; \n\t\n\tvec3 ro = vec3(0, 0, -10. + iTime * 4.), rd = normalize(vec3(u, 2.));\n\t\n\tfragColor = color(ray(ro,rd), ro, u + 2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 78], [80, 80, 107, 107, 193], [194, 194, 216, 216, 632], [634, 634, 662, 662, 923], [925, 925, 944, 944, 1070], [1072, 1072, 1111, 1111, 1561], [1565, 1565, 1622, 1622, 1804]], "test": "untested"}
{"id": "fddXRn", "name": "A Test", "author": "Geotale", "description": "Also known as \"Infinite colorful spheres be covered by colorful infinite spinning boxes being cut by a spinning infinite box\"\nThis is a test for a JSON auto-generator, this being the non-minified code (except I added the time, colorfulness, and modulo)", "tags": ["raymarcher"], "likes": 1, "viewed": 77, "published": "Public", "date": "1632499159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float a(vec3 a,float b){return length(a)-b;}float b(vec3 a,vec3 b){vec3 c=abs(a)-b;return length(max(c,0.))+min(max(c.x,max(c.y,c.z)),0.);}\n\t\tvec3 i(vec3 a,vec3 b){\n\t\t\ta=vec3(a.x,a.y*cos(b.x)-a.z*sin(b.x),a.y*sin(b.x)+a.z*cos(b.x));\n\t\t\ta=vec3(a.z*sin(b.y)+a.x*cos(b.y),a.y,a.z*cos(b.y)-a.x*sin(b.y));\n\t\t\treturn vec3(a.x*cos(b.z)-a.y*sin(b.z),a.x*sin(b.z)+a.y*cos(b.z),a.z);\n\t\t}\n\t\tint j=0;\n\t\tvec2 g(vec3 g){\n\t\t\tvec2 h=vec2(1e3,-1),\n\n\tj=vec2(a(mod(g+10.,20.)-10.,.7071067811865476),0);if(j.x<h.x)h=j;j=vec2(max(b(i(mod(g+10.,20.)-10.,vec3(.2999999999999998,.9000000000000004,.40000000000000036)*iTime),vec3(1,1,1)),-(i(g,vec3(1.,-.5,.75)*iTime).y)),0);if(j.x<h.x)h=j;\n\n\t\t\treturn h;\n\t\t}\n\n\t\tvec2 h(vec3 a,vec3 b,float c){\n\t\t\tfloat d=0.;\n\t\t\tfor(int e=0;e<256&&d<c;e++){\n\t\t\t\tvec2 f=g(a+d*b);\n\t\t\t\td+=f.x;\n\t\t\t\tif(f.x<1e-3)\n\t\t\t\t\treturn vec2(d,f.y);\n\t\t\t}\n\t\t\treturn vec2(0,-1);\n\t\t}\n\n\t\tvoid mainImage(out vec4 a,vec2 b){\n\t\t\tb=b/iResolution.xy*2.-1.;\n\t\t\tb.y*=iResolution.y/iResolution.x;\n\n\t\t\tvec3 c=i(vec3(0,0,-5),vec3(0,0,0));\n\t\t\tvec3 d=i(normalize(vec3(b,1)),vec3(0,0,0));\n\n\t\t\tb=h(c,d,1e3);\n\t\t\tif(b.y>=0.){\n\t\t\t\tc+=(b.x-2e-3)*d;\n\t\t\t\tvec3 e=1e-5*vec3(1,-1,0);\n\t\t\t\te=normalize(\n\t\t\t\t\te.xyy*g(c+e.xyy).x+\n\t\t\t\t\te.yxy*g(c+e.yxy).x+\n\t\t\t\t\te.yyx*g(c+e.yyx).x+\n\t\t\t\t\te.xxx*g(c+e.xxx).x\n\t\t\t\t);\n\t\t\t\ta=vec4(dot(e,normalize(3.0*sin(vec3(1,2,-3)*iTime)-c))*(vec3[3](vec3(0,0,0),vec3(0,0,0),vec3(0,0,0))[int(b.y)]+.5+.5*vec3(sin(c.x),sin(c.y),sin(c.z))),1);\n\t\t\t\tif(h(c,normalize(3.0*sin(vec3(1,2,-3)*iTime)-c),length(c-vec3(1,2,-3))).y>=0.)\n\t\t\t\t\ta.xyz*=.5;\n\t\t\t}else a=vec4(0,0,0,1);\n\t\t}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 44], [44, 44, 67, 67, 139], [142, 142, 164, 164, 377], [391, 391, 406, 406, 683], [687, 687, 717, 717, 870], [874, 874, 908, 908, 1557]], "test": "untested"}
{"id": "fdG3DW", "name": "Caleidoscopic voronoi circles", "author": "kristoflovas", "description": "...", "tags": ["circles"], "likes": 5, "viewed": 150, "published": "Public API", "date": "1631560977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x,0.,1.);\n\nfloat Circle01(vec2 coord,vec2 offset,float minsize, float maxsize, float sizealpha,float linewidth)\n{\nfloat circle = 1.-saturate(ceil(abs(distance(fract(coord)+offset,vec2(.5))-mix(minsize,maxsize,sizealpha))-linewidth/2.));\nreturn circle;\n}\n\nfloat circularsine(vec2 coord,vec2 offset,float cells,float wavefreq,float speed)\n{\nreturn (sin(distance((floor(coord)-cells/2.)-offset,vec2(0.))/wavefreq-iTime*speed)+1.)/2.;\n}\n\n\nconst float cells = 12.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat ar = iResolution.x/iResolution.y;\nvec2 uv = fragCoord/iResolution.xy;\nuv = vec2(uv.x,1.-uv.y)*vec2(ar,1.)-vec2((ar-1.)/2.,0.);\n\nfloat circles = 0.;\nfloat minsize = -0.1;\nfloat maxsize = 1.5;\nvec2 curpos = vec2(0.);\n\nvec2 biguv = uv*cells;\n\nfor(int x=-1;2>x;x++)\n{\ncurpos.x=float(x);\n\nfor(int y=-1;2>y;y++)\n{\ncurpos.y=float(y);\n\nfloat sine =circularsine(biguv,curpos,cells,2.,.5);\nfloat c =Circle01(biguv,curpos,minsize, maxsize, sine,.05);\n\ncircles =max(circles,c);\n}}\n    // Output to screen\n    fragColor = vec4(circles);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdG3DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 139, 139, 279], [281, 281, 364, 364, 458], [487, 487, 544, 544, 1077]], "test": "untested"}
{"id": "fdGGWd", "name": "in and not in", "author": "PoetLuchnik", "description": "don't look too long\n(ю_ю)", "tags": ["triangle", "epic"], "likes": 4, "viewed": 114, "published": "Public API", "date": "1632379140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nbool PixelInTriangle(vec3 p, vec3 v0, vec3 v1, vec3 v2) {\n    // my thanks to /user/meteotrix\n    vec3 projd_v0 = vec3(v0.xy, 0.0);\n    vec3 projd_v1 = vec3(v1.xy, 0.0);\n    vec3 projd_v2 = vec3(v2.xy, 0.0);\n    \n    vec3 edge01 = projd_v1 - projd_v0;\n    vec3 edge12 = projd_v2 - projd_v1;\n    vec3 edge20 = projd_v0 - projd_v2;\n    vec3 edge0P = p - projd_v0;\n    vec3 edge1P = p - projd_v1;\n    vec3 edge2P = p - projd_v2;\n\n    return (cross(edge01, edge0P).z >= 0.0) && (cross(edge12, edge1P).z >= 0.0) && (cross(edge20, edge2P).z >= 0.0);\n}\n\nbool RecursiveInTriangle(int count, vec3 p, vec3 v0, vec3 v1, vec3 v2) {\n    bool answer = false;\n    \n    while (count > 0) {\n        if (PixelInTriangle(p, v0, v1, v2)) {\n            answer = !answer;\n        }\n        vec3 t0 = (v0 + v1) / 2.0;\n        vec3 t1 = (v1 + v2) / 2.0;\n        vec3 t2 = (v2 + v0) / 2.0;\n        v0 = t0;\n        v1 = t1;\n        v2 = t2;\n        count--;\n    }\n    \n    return answer;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    vec3 col = vec3(0);\n    \n    float size = (iResolution.x * (0.5 + iTime * iTime * 0.02));\n    float angle = iTime * 0.7; // \n    vec3 center = vec3(iResolution.xy / 2.0, 0.0);\n    \n    //vertices\n    vec3 v0 = center + vec3(cos(angle) * size, sin(angle) * size, 0.0);\n    angle += 120.0 * 3.14159265359 / 180.0;\n    vec3 v1 = center + vec3(cos(angle) * size, sin(angle) * size, 0.0);\n    angle += 120.0 * 3.14159265359 / 180.0;\n    vec3 v2 = center + vec3(cos(angle) * size, sin(angle) * size, 0.0);\n\n    vec3 pixel = vec3(uv.xy,0.0);\n\n    col += (RecursiveInTriangle(20, pixel, v0, v1, v2) ? 1.0 : 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 94, 546], [548, 548, 620, 620, 965], [967, 967, 1022, 1072, 1764]], "test": "untested"}
{"id": "fdK3DD", "name": "Pixel Spirit Deck, Dynamic", "author": "chenglou", "description": "All 50 cards from [url=https://patriciogonzalezvivo.github.io/PixelSpiritDeck]Pixel Spirit[/url].\n[b]Mouse click a card to see the bigger version![/b]\nSlightly modified to add dynamism and anti-aliasing.", "tags": ["sdf", "symbol", "cards", "icon", "pixelspirit"], "likes": 44, "viewed": 630, "published": "Public API", "date": "1631597686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Original code from https://patriciogonzalezvivo.github.io/PixelSpiritDeck */\n\n// These 2 are the main tweaks we're gonna add to an icon\n// We can make bigger tweaks, but we don't wanna write the \n// icon differently; just small deltas.\n#define S (1. + sin(iTime) / 4.)\n#define C (1. + cos(iTime) / 4.)\n\n// Aliasing is apparent when things move. The original Pixel\n// Spirit cards use `step` everywhere. Change most of them to\n// smoothstep for anti-aliasing. Some later icons still need \n// regular `step` due to their idiosyncratic usages\nfloat sstep(float a, float b) {\n    return smoothstep(a - .005, a + .005, b);\n}\n\n// === Start!\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n// === All the utils, with their original card numbers\n\nfloat stroke(float x, float s, float w) { // 04\n    float d = sstep(s, x + w / 2.) - sstep(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\nfloat circleSDF(vec2 st) { // 08\n    return length(st - 0.5) * 2.;\n}\nfloat fill(float x, float size) { // 09\n    return 1. - sstep(size, x);\n}\nfloat rectSDF(vec2 st, vec2 s) { // 10\n    st = st * 2. - 1.;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\nfloat crossSDF(vec2 st, float s) { // 11\n    vec2 size = vec2(0.25, s);\n    return min(rectSDF(st, size.xy), rectSDF(st, size.yx));\n}\nfloat flip(float v, float pct) { // 12\n    return mix(v, 1. - v, pct);\n}\nfloat vesicaSDF(vec2 st, float w) { // 14\n    vec2 offset = vec2(w * .5, 0.);\n    return max(circleSDF(st - offset), circleSDF(st + offset));\n}\nfloat triSDF(vec2 st) { // 16\n    st = (2. * st - 1.) * 2.;\n    return max(abs(st.x) * 0.866025 + st.y * .5, -st.y * .5);\n}\nfloat rhombSDF(vec2 st) { // 17\n    return max(triSDF(st), triSDF(vec2(st.x, 1. - st.y)));\n}\nvec2 rotate(vec2 st, float a) { // 19\n    st = mat2(cos(a), -sin(a), sin(a), cos(a)) * (st - .5);\n    return st + .5;\n}\nfloat polySDF(vec2 st, int V) { // 26\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a) * r;\n}\nfloat hexSDF(vec2 st) { // 27\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y * .5);\n}\nfloat starSDF(vec2 st, int V, float s) { // 28\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)), st));\n}\nfloat raysSDF(vec2 st, int N) { // 30\n    st -= .5;\n    return fract(atan(st.y, st.x) / TAU * float(N));\n}\nfloat heartSDF(vec2 st) { // 34\n    st -= vec2(.5, .8);\n    float r = length(st) * 5.;\n    st = normalize(st);\n    return r -\n        ((st.y * pow(abs(st.x), 0.67)) /\n        (st.y + 1.5) - 2. * st.y + 1.26);\n}\nfloat bridge(float c, float d, float s, float w) { // 35\n    c *= 1. - stroke(d, s, w * 2.);\n    return c + stroke(d, s, w);\n}\nfloat spiralSDF(vec2 st, float t) { // 47\n    st -= .5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\nvec2 scale(vec2 st, vec2 s) {\n    return (st - .5) * s + .5;\n}\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2. - 1.;\n    float r = length(st) * 2.;\n    float a = atan(st.y, st.x);\n    float v = float(N) * .5;\n    return 1. - (abs(cos(a * v)) * .5 + .5) / r;\n}\n\n// === Cards\n\nfloat draw(vec2 st, vec2 tileXY, vec2 count) {\n    // y is bottom to top, but we want to show things from top to bottom. Convert\n    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    float color = 0.;\n    \n    switch (cardNumber) {\n    case 0: { // void\n        color = 0.;\n        break;\n    }\n    case 1: { // justice\n        color = sstep(0.5 * S, st.x);\n        break;\n    }\n    case 2: { // strength\n        color = sstep(0.5 + cos(st.y * PI + iTime/2.) * 0.25, st.x);\n        break;\n    }\n    case 3: { // death\n        color = sstep(0.5, (st.x * S + st.y * C) * 0.5);\n        break;\n    }\n    case 4: { // wall\n        color = stroke(st.x, 0.5, 0.15*S);  \n        break;\n    }\n    case 5: { // temperance\n        float offset = cos(st.y * PI + iTime) * 0.15;\n        color = stroke(st.x, .28 + offset, 0.1);\n        color += stroke(st.x, .5 + offset, 0.1);\n        color += stroke(st.x, .72 + offset, 0.1);\n        break;\n    }\n    case 6: { // branch\n        float offset = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(offset, 0.5, 0.1 * S);\n        break;\n    }\n    case 7: { // the hanged man\n        float sdf = 0.5 + (st.x - st.y) * 0.5;\n        color = stroke(sdf, 0.5, 0.1 * C);\n        float sdf_inv = (st.x + st.y) * 0.5;\n        color += stroke(sdf_inv, 0.5, 0.1 * C);\n        break;\n    }\n    case 8: { // the high priestess\n        color = stroke(circleSDF(st), 0.5 * S, 0.05 * C);\n        break;\n    }\n    case 9: { // the moon\n        color = fill(circleSDF(st), 0.65);\n        vec2 offset = vec2(0.1, 0.05);\n        color -= fill(circleSDF(st - offset * S), 0.5);\n        break;\n    }\n    case 10: { // the emperor\n        float sdf = rectSDF(st, vec2(1.));\n        color = stroke(sdf, .5 * C, .125);\n        color += fill(sdf, .1 * S);\n        break;\n    }\n    case 11: { // the hierophant\n        float rect = rectSDF(st, vec2(1));\n        color = fill(rect, .5);\n        float cross = crossSDF(st, 1.);\n        color *= sstep(.5, fract(cross * 3. + iTime));\n        color *= sstep(1., cross);\n        color += fill(cross, .5);\n        color += stroke(rect, .65, .05);\n        color += stroke(rect, .75, .025);\n        break;\n    }\n    case 12: { // the tower\n        float rect = rectSDF(st, vec2(.5, 1.));\n        float diag = (st.x * C + st.y * S) * .5;\n        color = flip(fill(rect, .6), stroke(diag, .5, .01));\n        break;\n    }\n    case 13: { // merge\n        vec2 offset = vec2(.15 * S, 0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = flip(stroke(left, .5, .05), fill(right, 0.525));\n        break;\n    }\n    case 14: { // hope\n        float sdf = vesicaSDF(st, .2 * S);\n        color = flip(fill(sdf, .5), sstep((st.x + st.y) * .5, .5));\n        break;\n    }\n    case 15: { // the temple\n        st.y = 1. - st.y;\n        vec2 ts = vec2(st.x, .82 - st.y);\n        color = fill(triSDF(st), .7);\n        color -= fill(triSDF(ts), .36);\n        break;\n    }\n    case 16: { // the summit\n        float circle = circleSDF(st - vec2(.0, .1));\n        float triangle = triSDF(st + vec2(.0, .1));\n        color = stroke(circle, .5 * C, .1);\n        color *= sstep(.55, triangle);\n        color += fill(triangle, .45);\n        break;\n    }\n    case 17: { // the diamond\n        float sdf = rhombSDF(st);\n        color = fill(sdf, .425 * S);\n        color += stroke(sdf, .5 * S, .05);\n        color += stroke(sdf, .6 * C, .03);\n        break;\n    }\n    case 18: { // the hermit\n        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    \n        break;\n    }\n    case 19: { // intuition\n        st = rotate(st, radians(-25.) * S);\n        float sdf = triSDF(st);\n        sdf /= triSDF(st + vec2(0., .2 * C));\n        color = fill(abs(sdf), .56);\n        break;\n    }\n    case 20: { // the stone\n        st = rotate(st, radians(45.));\n        color = fill(rectSDF(st, vec2(1.)), .4);\n        color *= 1. - stroke(st.x, .5 * S, .02);\n        color *= 1. - stroke(st.y, .5 * C, .02);\n        break;\n    }\n    case 21: { // the mountain\n        st = rotate(st, radians(-45.));\n        float off = .12 * S;\n        vec2 s = vec2(1.);\n        color = fill(rectSDF(st + off, s), .2 * C);\n        color += fill(rectSDF(st - off, s), .2 * C);\n        float r = rectSDF(st, s);\n        color *= sstep(.33, r);\n        color += fill(r, .3);\n        break;\n    }\n    case 22: { // the shadow\n        st = rotate(vec2(st.x, 1. - st.y), radians(45.));\n        vec2 s = vec2(1.);\n        color += fill(rectSDF(st - .025 * S, s), .4);\n        color += fill(rectSDF(st + .025, s), .4);\n        color *= sstep(0.38, rectSDF(st + .025, s));\n        break;\n    }\n    case 23: { // opposite\n        st = rotate(st, radians(-45.));\n        vec2 s = vec2(1.);\n        float o = .05 * S * 1.5;\n        color += flip(\n            fill(rectSDF(st - o, s), .4), \n            fill(rectSDF(st + o, s), .4)\n        );\n        break;\n    }\n    case 24: { // the oak\n        st = rotate(st, radians(45.));\n        float r1 = rectSDF(st, vec2(1.) * S);\n        float r2 = rectSDF(st + .15 * S, vec2(1.));\n        color += stroke(r1, .5, .05);\n        color *= sstep(.325, r2);\n        color += stroke(r2, .325, .05) * fill(r1, .525);\n        color += stroke(r2, .2, .05);\n        break;\n    }\n    case 25: { // ripples\n        st = rotate(st, radians(-45.)) - .08;\n        for (int i = 0; i < 4; i++) {\n            float r = rectSDF(st, vec2(1.) * S);\n            color += stroke(r, .19, .04);\n            st += .05;\n        }\n        break;\n    }\n    case 26: { // the empress\n        float d1 = polySDF(st, 5);\n        vec2 ts = vec2(st.x, 1. - st.y);\n        float d2 = polySDF(ts, 5);\n        color = fill(d1, .75) * fill(fract(d1 * 5. - iTime/2.), .5);\n        color -= fill(d1, .6) * fill(fract(d2 * 4.9 - iTime/2.), .45);\n        break;\n    }\n    case 27: { // bundle\n        st = st.yx;\n        color = stroke(hexSDF(st), .6 * C, .1);\n        color += fill(hexSDF(st - vec2(-.06, -.1) * S), .15);\n        color += fill(hexSDF(st - vec2(-.06, .1) * S), .15);\n        color += fill(hexSDF(st - vec2(.11, 0.) * S), .15);\n        break;\n    }\n    case 28: { // the devil\n        color += stroke(circleSDF(st), .8 * C, .05);\n        st.y = 1. - st.y;\n        float s = starSDF(st.yx, 5, .1);\n        color *= sstep(.7 * C, s);\n        color += stroke(s, .4 * S, .1);\n        break;\n    }\n    case 29: { // the sun\n        float bg = starSDF(st, 16, .1 * S);\n        color += fill(bg, 1.3);\n        float l = 0.;\n        for (float i = 0.; i < 8.; i++) {\n            vec2 xy = rotate(st, QTR_PI * i+iTime/4.);\n            xy.y -= .3;\n            float tri = polySDF(xy, 3);\n            color += fill(tri, .3);\n            l += stroke(tri, .3 * S, .03);\n        }\n        color *= 1. - l;\n        float c = polySDF(st, 8);\n        color -= stroke(c, .15, .04);\n        break;\n    }\n    case 30: { // the star\n        color = stroke(raysSDF(st, 8), .5, .15 * C * 2.);\n        float inner = starSDF(st.xy, 6, .09 * S);\n        float outer = starSDF(st.yx, 6, .09 * S);\n        color *= sstep(.7, outer);\n        color += fill(outer, .5);\n        color -= stroke(inner, .25, .06);\n        color += stroke(outer, .6, .05);\n        break;\n    }\n    case 31: { // judgement\n        color = flip(\n            stroke(raysSDF(rotate(st, -iTime/8.), 28), .5, .2), \n            fill(st.y, .5)\n        );\n        float rect = rectSDF(st, vec2(1) * S);\n        color *= sstep(.25, rect);\n        color += fill(rect, .2);\n        break;\n    }\n    case 32: { // wheel of fortune\n        float sdf = polySDF(rotate(st.yx, C), 8);\n        color = fill(sdf, .5);\n        color *= stroke(raysSDF(rotate(st, C), 8), .5, .2);\n        color *= sstep(.27, sdf);\n        color += stroke(sdf, .2, .05);\n        color += stroke(sdf, .6, .1);\n        break;\n    }\n    case 33: { // vision\n        float v1 = vesicaSDF(st, .5);\n        vec2 st2 = st.yx + vec2(.04, .0);\n        float v2 = vesicaSDF(st2, .7);\n        color = stroke(v2, 1., .05);\n        st = rotate(st, iTime/2.);\n        color += fill(v2, 1.) * stroke(circleSDF(st - vec2(.05)), .3 , .05);\n        color += fill(raysSDF(st, 50), .2) *\n            fill(v1, 1.25) *\n            sstep(1., v2);\n        break;\n    }\n    case 34: { // the lovers\n        color = fill(heartSDF(st), .5 * C * 1.2);\n        color -= stroke(polySDF(st, 3), .15 * S * 1.1, .05);\n        break;\n    }\n    case 35: { // the magician\n        st.x = flip(st.x, step(.5, st.y));\n        vec2 offset = vec2(.15 * S, .0);\n        float left = circleSDF(st + offset);\n        float right = circleSDF(st - offset);\n        color = stroke(left, .4 * S, .075);\n        color = bridge(color, right, .4 * S, .075);\n        break;\n    }\n    case 36: { // the link\n        st = st.yx;\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.1, .0);\n        vec2 s = vec2(1.) * C;\n        float a = radians(45.) + iTime/2.;\n        float l = rectSDF(rotate(st + o, a), s);\n        float r = rectSDF(rotate(st - o, -a), s);\n        color = stroke(l, .3, .1);\n        color = bridge(color, r, .3, .1);\n        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);\n        break;\n    }\n    case 37: { // holding together\n        st.x = mix(1. - st.x, st.x, step(.5, st.y));\n        vec2 o = vec2(.05, .0);\n        vec2 s = vec2(1.);\n        float a = radians(45.);\n        float l = rectSDF(rotate(st + o, a * S), s);\n        float r = rectSDF(rotate(st - o, -a * S), s);\n        color = stroke(l, .145, .098);\n        color = bridge(color, r, .145, .098);\n        break;\n    }\n    case 38: { // the chariot\n        float r1 = rectSDF(st, vec2(1.));\n        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));\n        float inv = step(.5, (st.x + st.y) * .5);\n        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));\n        float w = .075 * S * 1.2;\n        color = stroke(r1, .5, w) + stroke(r2, .5, w);\n        float bridges = mix(r1, r2, inv);\n        color = bridge(color, bridges, .5, w);\n        break;\n    }\n    case 39: { // the loop\n        float inv = sstep(.5, st.y);\n        st = rotate(st, radians(-45.)) - .2;\n        st = mix(st, .6 - st, sstep(.5, inv));\n        for (int i = 0; i < 5; i++) {\n            float r = rectSDF(st, vec2(1.));\n            float s = .25;\n            s -= abs(float(i) * .1 - .2);\n            color = bridge(color, r, s, .05 * S);\n            st += .1;\n        }\n        break;\n    }\n    case 40: { // turning point\n        st = rotate(st, radians(-60.) + iTime/4.);\n        st.y = flip(st.y, step(.5, st.x));\n        st.y += .25;\n        float down = polySDF(st, 3);\n        st.y = 1.5 - st.y;\n        float top = polySDF(st, 3);\n        color = stroke(top, .4, .15 * S);\n        color = bridge(color, down, .4, .15 * S);\n        break;\n    }\n    case 41: { // trinity\n        st.y = 1. - st.y;\n        float s = .25 * C*1.3;\n        float t1 = polySDF(st + vec2(.0, .175), 3);\n        float t2 = polySDF(st + vec2(.1, .0), 3);\n        float t3 = polySDF(st - vec2(.1, .0), 3);\n        color = stroke(t1, s, .08) +\n                stroke(t2, s, .08) +\n                stroke(t3, s, .08);\n        float bridges = mix(\n            mix(t1, t2, step(.5, st.y)),\n            mix(t3, t2, step(.5, st.y)),\n            step(.5, st.x)\n        );\n        color = bridge(color, bridges, s, .08);\n        break;\n    }\n    case 42: { // the cauldron\n        float n = 12.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .189;\n            float vsc = vesicaSDF(xy, .3);\n            color *= 1. - stroke(vsc, .45 * S, .1) * sstep(.5, xy.y);\n            color += stroke(vsc, .45 * S, .05);\n        }\n        break;\n    }\n    case 43: { // the elders\n        float n = 3.;\n        float a = TAU / n;\n        for (float i = 0.; i < n * 2.; i++) {\n            vec2 xy = rotate(st, a * i);\n            xy.y -= .09;\n            float vsc = vesicaSDF(xy, .3);\n            color = mix(\n                color + stroke(vsc, .5, .1*S),\n                mix(color, bridge(color, vsc, .5, .1*S), step(xy.x, .5) - step(xy.y, .4)),\n                step(3., i)\n            );\n            \n        }\n        break;\n    }\n    case 44: { // the core\n        float star = starSDF(st, 8, .063);\n        color += fill(star, 1.22);\n        float n = 8.;\n        float a = TAU / n;\n        for (float i = 0.; i < n; i++) {\n            vec2 xy = rotate(st, 0.39 + a * i);\n            xy = scale(xy, vec2(1., .72) * S);\n            xy.y -= .125;\n            color *= sstep(.235, rhombSDF(xy));\n        }\n        break;\n    }\n    case 45: { // inner truth\n        st -= .5;\n        float r = dot(st, st);\n        float a = atan(st.y, st.x) / PI;\n        vec2 uv = vec2(a, r);\n        vec2 grid = vec2(5., log(r) * 20. * S);\n        vec2 uv_i = floor(uv * grid);\n        uv.x += .5 * mod(uv_i.y, 2.);\n        vec2 uv_f = fract(uv * grid);\n        float shape = rhombSDF(uv_f);\n        color += fill(shape, .9) * sstep(.75, 1. - r);\n        break;\n    }\n    case 46: { // the world\n        color = fill(flowerSDF(rotate(st, -iTime/4.), 5), .25*C);\n        color -= sstep(.95, starSDF(rotate(st, 0.628 - iTime/4.), 5, .1*S));\n        color = clamp(color, 0., 1.);\n        float circle = circleSDF(st);\n        color -= stroke(circle, .1, .05);\n        color += stroke(circle, .8, .07);\n        break;\n    }\n    case 47: { // the fool\n        color = sstep(.5, spiralSDF(rotate(st, iTime/2.), .13 * S));\n        break;\n    }\n    case 48: { // enlightenment\n        color = 1.;\n        break;\n    }\n    case 49: { // elements. Added by me. Approximated\n        st = rotate(st, -iTime/4.);\n        float d = .15;\n        float r = .3 * S;\n        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), r);\n        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), r);\n        color += fill(circleSDF(st - vec2(d, 0.)), r);\n        st = st.yx;\n        st.y = 1. - st.y;\n        color *= 1. - fill(triSDF(st-vec2(0, .02)), .13);\n        color += stroke(circleSDF(st), .8, .08);\n        break;\n    }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(10, 5);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    \n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.8, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y);\n    \n    float color = draw(st, tileXY, count);\n    color = clamp(color + grid, 0., 1.);\n    \n    if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        \n        color *= 0.15;\n        color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 543, 574, 574, 622], [723, 779, 820, 826, 916], [917, 917, 943, 949, 985], [986, 986, 1019, 1025, 1059], [1060, 1060, 1092, 1098, 1173], [1174, 1174, 1208, 1214, 1307], [1308, 1308, 1340, 1346, 1380], [1381, 1381, 1416, 1422, 1524], [1525, 1525, 1548, 1554, 1648], [1649, 1649, 1674, 1680, 1741], [1742, 1742, 1773, 1779, 1861], [1862, 1862, 1893, 1899, 2064], [2065, 2065, 2088, 2094, 2180], [2181, 2181, 2221, 2227, 2465], [2466, 2466, 2497, 2503, 2572], [2573, 2573, 2598, 2604, 2783], [2784, 2784, 2834, 2840, 2910], [2911, 2911, 2946, 2952, 3079], [3080, 3080, 3109, 3109, 3142], [3143, 3143, 3176, 3176, 3342], [3344, 3358, 3404, 3486, 17524], [17526, 17526, 17583, 17583, 18570]], "test": "untested"}
{"id": "fdK3RR", "name": "Walking Rainbow", "author": "oneshade", "description": "Animating [url=https://www.shadertoy.com/view/fddGDs]https://www.shadertoy.com/view/fddGDs[/url].", "tags": ["bezier", "animation", "rainbow", "walk"], "likes": 13, "viewed": 103, "published": "Public", "date": "1630962359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Length between a starting (t1) and ending (t2) position\nfloat bezierArclength(in float t1, in float t2, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    vec2 t = (u * vec2(t1, t2) + v) / sqrt(dis);\n    vec2 y = asinh(t) + t * sqrt(t * t + 1.0);\n    return (y.y - y.x) * dis / pow(u, 1.5);\n}\n\n// Newton-Raphson solver for inverse arclength\nfloat bezierInvArclength(in float d, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    float sdis = sqrt(dis);\n    float disu = dis / u;\n    float k = dis / pow(u, 1.5);\n\n    float y = v / sdis;\n    d += (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n\n    float t = ((sqrt(disu + u * abs(d)) - sqrt(disu)) * sign(d) - v) / u;\n    for (int n=0; n < 5; n++) {\n        float y = (u * t + v) / sdis;\n        float arclen = (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n        float arcint = 2.0 * sqrt((u * t + 2.0 * v) * t + w);\n        t -= (arclen - d) / arcint;\n    }\n\n    return t;\n}\n\n// ---------- Helper functions ----------\nvec3 hue2rgb(in float hue) {\n    return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n}\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 c = floor(p);\n    vec2 f = fract(p);//smoothstep(0.0, 1.0, fract(p));\n\n    float bl = Hash21(c);\n    float br = Hash21(c + vec2(1.0, 0.0));\n    float tl = Hash21(c + vec2(0.0, 1.0));\n    float tr = Hash21(c + 1.0);\n\n    return mix(mix(bl, br, f.x), mix(tl, tr, f.x), f.y);\n}\n\n// ---------- SDFs ----------\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Returns vec2(shortest distance to the curve, parameter of the nearest position on the curve)\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec2 sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return vec2(length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        float d1 = dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x));\n        float d2 = dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y));\n        return d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Color bands in the background\n    color = vec3(floor(snoise(vec2(uv.y * 4.0, 0.1 * iTime)) * 5.0) * 0.25);\n    color *= step(0.0, 0.2 - snoise(vec2(uv.y * 10.0, iTime)));\n    color *= fragCoord.y / iResolution.y;\n\n    // Control points\n    vec2 a = vec2(-1.0, -0.5);\n    vec2 b = vec2(-0.5, 0.25);\n    vec2 c = vec2(0.0, -0.5);\n\n    float time = mod(iTime, 6.28);\n    uv.x += time / 6.28 * 2.0 - 0.5;\n    float transition = 0.5 - 0.5 * cos(min(time, 3.14));\n\n    // Rotate back segment forward\n    a -= c;\n    a *= Rotate2D(3.14 * transition);\n    a += c;\n\n    b.x = mix(-0.5, 0.5, transition);\n\n    // Repeat, but this time with the forward (now back) segment\n    if (time > 3.14) {\n        float transition = 0.5 + 0.5 * cos(time);\n\n        c -= a;\n        c *= Rotate2D(3.14 * transition);\n        c += a;\n\n        b.x = mix(0.5, 1.5, transition);\n    }\n\n    // Poles or whatever its walking on\n    drawSDF(sdBox(vec2(fract(uv.x + 0.5) - 0.5, uv.y + 10.55), vec2(0.05, 9.95)) - 0.05, vec3(0.0, 0.8, 0.6));\n\n    // Bezier curve\n    vec2 bezClosest = sdBezier(uv, a, b, c);\n    float bezLength = bezierArclength(0.0, 1.0, a, b, c);\n    bezClosest.y = bezierArclength(0.0, bezClosest.y, a, b, c) / bezLength;\n    drawSDF(bezClosest.x - 0.05, hue2rgb(bezClosest.y));\n\n    // Plot rotating stars at regular intervals\n    mat2 rot = Rotate2D(iTime);\n\n    float du = bezLength / 5.0;\n    for (float u=0.0; u < 6.0; u++) {\n        float t = bezierInvArclength(u * du, a, b, c);\n        vec2 pos = mix(mix(a, b, t), mix(b, c, t), t);\n\n        mat2 starRot = rot;\n        if (int(u) % 2 == 0) starRot = transpose(starRot); // Alternate rotation direction\n\n        drawSDF(sdStar5((uv - pos) * starRot, 0.05, 0.5), vec3(0.25, 0.0, 0.5));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 141, 141, 453], [455, 502, 573, 573, 1233], [1235, 1277, 1305, 1305, 1409], [1411, 1411, 1438, 1438, 1504], [1506, 1547, 1573, 1573, 1659], [1661, 1702, 1727, 1727, 1838], [1840, 1840, 1865, 1865, 2149], [2151, 2260, 2311, 2311, 2722], [2724, 2820, 2843, 2843, 2863], [2864, 2864, 2926, 2926, 4189], [4191, 4191, 4226, 4226, 4306], [4308, 4308, 4355, 4355, 4463], [4545, 4545, 4600, 4600, 6606]], "test": "untested"}
{"id": "fdK3Ry", "name": "camera & color", "author": "shunyadezain", "description": "Adding colors & a camera", "tags": ["raymarching"], "likes": 3, "viewed": 60, "published": "Public", "date": "1631748232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// references: \n// https://gaz.hateblo.jp/entry/2019/05/11/215943\n// https://gaz.hateblo.jp/entry/2019/05/11/225351\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nconst float speed = 2.;\n\nfloat deSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat de1(vec3 p)\n{\n    float h=sin(iTime)*.5+.5;\n    p.x-=clamp(p.x,-h,h);\n    p.zy *= rot(iTime*speed);\n    return length(vec2(length(p.xy)- 1.,p.z))-.5;\n}\n\n\nfloat de2(vec3 p){\n\n    vec3 bp = p - vec3(0,0,sin(iTime*speed)*5.);\n    \n    return deSphere(bp, .45);\n}\n\nfloat map(vec3 p)\n{\n    return min(de1(p), de2(p));\n}\n\nvec3 doColor(vec3 p)\n{\n    const float precis = 0.01;\n    if (de1(p)<precis) return vec3(0,.3,.3);\n    if (de2(p)<precis) return vec3(2,.4,.1);\n    return vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,0,sin(iTime) * 3. -8.);\n    ro.zx*=rot(iTime*0.5);\n    vec3 rd=normalize(vec3(uv,2));\n    \n    //camera\n    vec3 ta=vec3(0,0,0); \n    vec3 w=normalize(ta-ro);\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\n    vec3 v=cross(u,w);\n    mat3 lookat=mat3(u,v,w);\n    rd=lookat*rd;\n    //\n    \n    float d,i,t=0.0;\n    vec3 p=ro;\n    vec3 col=vec3(0);\n    for(i=1.0;i>0.0;i-=1./50.0)\n    {\n        t+=d=map(p);\n        if(d<0.001)\n        {\n            col = doColor(p);\n            col /=i*i*i; \n            break;\n        }\n        p+=rd*d;\n    }\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 192, 227, 227, 251], [254, 254, 273, 273, 411], [414, 414, 432, 432, 519], [521, 521, 540, 540, 574], [576, 576, 598, 598, 741], [743, 743, 800, 800, 1448]], "test": "untested"}
{"id": "fdK3zG", "name": "The Ghosts of Numbers", "author": "tomachi", "description": "Started with a cube. Ended up with this. ", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 51, "published": "Public", "date": "1631742645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sdGyroid(vec3 p) {\n    p *= -50.+ iTime;\n    return dot(sin(p), cos(p.zxy));\n}\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float gyroid = sdGyroid(p);\n    return dot(box, gyroid);\n    return gyroid;\n    return box;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0),1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = n * vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdK3zG.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1587, 1587, 1668], [1669, 1669, 1693, 1693, 1753], [1755, 1755, 1778, 1778, 1911], [1913, 1913, 1947, 1947, 2158], [2160, 2160, 2184, 2184, 2374], [2376, 2376, 2426, 2426, 2617], [2619, 2619, 2676, 2676, 3286]], "test": "untested"}
{"id": "fdKGDw", "name": "Fork дед инсайд oneWisdom 723", "author": "oneWisdom", "description": "CG course sdf practice", "tags": ["sdf", "trip"], "likes": 0, "viewed": 99, "published": "Public API", "date": "1631655604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat sphere(vec3 pos, vec3 spherePos, float sphereRadius) {\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat prism(vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.7+p.y*0.3,-p.y)-h.x*0.5);\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat smax ( float a, float b, float k )\n{\n\tfloat res = exp ( k*a ) + exp ( k*b );\n\treturn log ( res ) / k;\n}\n\n\nfloat scene_eyes(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    float k = min(\n        sphere(q, vec3(0.45, -0.7, 0.2), 0.3),\n        sphere(q, vec3(-0.45, -0.7, 0.2), 0.3)\n    );\n    return k;\n}\n\n\nfloat scene_head(vec3 pos, mat3 m) {\n    vec3 q = m * pos;\n    \n    // prism transform\n    vec3 q2 = q + vec3(0., 1.6, 1.);\n    mat3 m2 = rotateY(PI / 2.) * rotateZ(PI / 180. * 30.);\n    q2 *= m2;\n    \n    float k = max(\n        -prism(q2, vec2(1., 1.5)),\n        sphere(q, vec3(0., 0., 0.), 1.)\n    );\n    \n    // ear radius\n    float a = 2.;\n    // ear thickness\n    float d = 0.2;\n    \n    vec3 ear_position1 = vec3(-1.1, 0, 1.0);\n    vec3 ear_position2 = vec3(1.1, 0, 1.0);\n        \n    float s1 =  smax(\n        -sphere(q,ear_position1 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position1, 1.), 10.0\n    );\n        \n    float s2 = smax(\n        sphere(q, ear_position1 + vec3(0., -a + d, 0.), a),\n        s1, 10.0\n    );\n    \n    float s3 =  smax(\n        -sphere(q,ear_position2 +  vec3(0., -a, 0.), a),\n        sphere(q, ear_position2, 1.), 10.0\n    );\n        \n    float s4 = smax(\n        sphere(q, ear_position2 + vec3(0., -a + d, 0.), a),\n        s3, 10.0\n    );\n    \n    \n    return min(s4, min(s2, k));\n}\n\n\nfloat scene(vec3 pos, mat3 m, int n) {\n    float dist;\n    if (n == 0) {\n\n        dist = scene_head ( pos, m );\n    }\n    else {\n        dist = scene_eyes ( pos, m );\n    } \n    return dist;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, mat3 m, int n)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n    int stepNum = 70;\n\tfor ( int steps = 0; steps < stepNum; steps++ )\n\t{\n        float dist = scene(p, m, n);\n\n        p += dist * dir;\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\t\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, mat3 m, int n)\n{\n    float eps = 0.01;\n    float e   = max (d * 0.5, eps );\n    float dx1 = scene(z + vec3(e, 0, 0), m, n);\n    float dx2 = scene(z - vec3(e, 0, 0), m, n);\n    float dy1 = scene(z + vec3(0, e, 0), m, n);\n    float dy2 = scene(z - vec3(0, e, 0), m, n);\n    float dz1 = scene(z + vec3(0, 0, e), m, n);\n    float dz2 = scene(z - vec3(0, 0, e), m, n);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n\nmat2 rotate(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 background(vec2 uv) {\n    //source: https://www.shadertoy.com/view/Xt2BDG\n    \n    vec4 result = vec4(0,0,0,1);\n\n    float t = 1.;\n    float offset = -5. * iTime;\n    float base = 100. * length(uv);\n\n    float d = sin(-iTime + 15. * length(uv));\n    d *= d * d;\n\n    mat2 rot = rotate(5. * length(uv));\n    uv += .5;\n    \n    uv = abs(rot * uv);\n    \n    for (int p = 0; p < 3; p++)\n    {\n        result[p] = sin(offset + t * base) - cos(20. * uv.x) - cos(20. * uv.y);\n        t += 0.05;\n    }\n\n    result.xyz *= result.xyz;\n    result.xyz = 1. - result.xyz;\n    \n    return result * d;\n}\n\nvec3 lightPos = vec3(0, -6., 0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    mat3 m;\n    \n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    if ( iMouse.z > 0.) {\n        m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x );\n    }\n    else {\n        m = mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n    \n    vec3 cameraPos = vec3(0.,-5.-sin(iTime)*4., 0.);\n    vec3 cameraForward = vec3(0., 1, 0.);\n    vec3 cameraUp = vec3 (0., 0., 1.);\n    float cameraFocus = 5.;\n    \n    vec2 scale = 9. * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\n    \n    vec3 from = vec3(uv.x, (cameraPos + cameraForward * cameraFocus).z, uv.y);\n    vec3 dir = normalize(from - cameraPos);\n    \n    bool hit;\n    vec3 p1 = trace(cameraPos, dir, hit, m, 0);\n    float d1 = length(cameraPos - p1);\n     float c1 = length(p1);\n    \n    vec3 backgroundColor = vec3(0., 0., 0.);\n    vec3 surfaceColor = vec3(1., 1., 1.);\n    \n    vec4 col;\n    \n    if (hit) {\n\n       vec3 l = normalize(lightPos - p1);\n       vec3 n = generateNormal(p1, 0.001, m, 0);\n       vec3 v = normalize(cameraPos - p1);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n\n       col = 0.5*vec4 ( diffuse ) * vec4(1.0, 0.1, 0.4, 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n    else {\n       col = background(uv / 2.);\n    }\n   \n    vec3 p2 = trace(cameraPos, dir, hit, m, 1);\n    float d2 = length(cameraPos - p2);\n    float c2 = length(p2);\n\n    if (hit && (d2 < d1)) {\n\n       vec3 l = normalize(lightPos - p2);\n       vec3 n = generateNormal(p2, 0.001, m, 1);\n       vec3 v = normalize(cameraPos - p2);\n       float diffuse = max(0., dot(n, l));\n\n       vec3  h  = normalize ( l + v );\n       float hn = max ( 0.0, dot ( h, n ) );\n       float specular = pow ( hn, 150.0 );\n       \n       float t = abs(sin(70. * c2 + 20. * iTime) - 0.9);\n\n       col = 0.5 * vec4 ( diffuse ) * vec4(t, abs(t - 0.9), abs(t - 0.3), 1) + 0.5 * specular * vec4 ( 1, 1, 1, 1 );\n    }\n\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 198], [200, 200, 227, 227, 374], [377, 377, 404, 404, 551], [554, 554, 614, 614, 667], [669, 669, 699, 699, 781], [784, 784, 826, 826, 896], [899, 899, 941, 941, 1008], [1011, 1011, 1047, 1047, 1205], [1208, 1208, 1244, 1244, 2229], [2232, 2232, 2270, 2270, 2424], [2427, 2427, 2497, 2497, 2845], [2847, 2847, 2902, 2902, 3323], [3327, 3327, 3353, 3353, 3438], [3441, 3441, 3467, 3519, 4034], [4071, 4071, 4128, 4178, 6364]], "test": "untested"}
{"id": "fdt3DB", "name": "basic shader test 1", "author": "ayanamy", "description": "test", "tags": ["test"], "likes": 1, "viewed": 35, "published": "Public", "date": "1630593859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n\n    float y = sin(st.x*10.0-iTime*2.0)/2.2 + 0.5;\n    //float y = tan(st.x*10.0-iTime*2.0)/10.0+0.5;\n    //float y = (1.0/1000.0*st.x-iTime)+0.5;\n\n    float pct = plot(st,y);\n    vec3 color = pct*vec3(y, st.x,0.0);\n\n    fragColor = vec4(color,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 181, 181, 478]], "test": "untested"}
{"id": "fdt3WX", "name": "tetrahedron in cube 2", "author": "FabriceNeyret2", "description": "tribute to https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm  ;-)\n( how to compute centered finite differences with only 4 fetches ).", "tags": ["raymarching", "short"], "likes": 5, "viewed": 159, "published": "Public API", "date": "1630752072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/7s33Df\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,c,m=t; \n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 7./R, q,a,                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(1) ; O.x > 0. && t > .01 ; O-=.01 )\n        q = p,\n        q.yz *= rot( .5-6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        t = abs( c = max(a.x,max(a.y,a.z)) - 1.)-.01 ,        // cube\n        m = min(m,c),                                         // memo closest to cube\n#define A(x,y,z) dot(q,vec3(x,y,z))/sqrt(3.)\n#define D(x,y,z) min( abs(.9-A(x,y,z))-.15 , 1.3-A(x,y,z) ) \n        t = max(t, min(min(D(1,1,-1),D(1,-1,1)),min(D(-1,1,1),D(-1,-1,-1))) ), // tetrahedron strips\n        p += t*D;                                             // step forward = dist to obj          \n\n    if (t>c) O *= .7;\n    O.b += exp(-20.*m);  // transparent blue cube via ~glow\n}\n\n\n\n\n\n/* // smart AA https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n} */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 142, 178, 178, 1277]], "test": "untested"}
{"id": "fdtGRs", "name": "Graph_2D_sidps", "author": "kingcrimson1112", "description": "A shader to display equations as form of a 2D Graph", "tags": ["2d", "graph", "equations"], "likes": 0, "viewed": 61, "published": "Public", "date": "1630496464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AREA_GRAPH 0\n\n// Graph Color Properties\nvec3 bgColor = vec3(0.05f);\nvec3 gridColor = vec3(0.25f, 0.75f, 0.25f);\nvec3 axesColor = vec3(0.9f, 0.9f, 0.1f);\nvec3 eqColor = vec3(0.15f, 0.65f, 0.95f);\n\n// Graph Render Properties\nfloat yLimit = 6.0f;\nfloat gridWidth = 0.2f;\nint pixelWidth = 2;\n\n// Equation Properties\nfloat errorMargin = 0.25f;\n\n// Gets f(x, y)\nfloat get_result(vec2 point)\n{\n    //float radius = 25.0f * ((sin(iTime * 1.5f) + 1.0f) / 2.0f) + 0.05f;\n    // f(x,y) = y^2 + x^2 - R\n    //float res = ((point.y * point.y) + (point.x * point.x) - radius);\n    float phase=sin(iTime*3.0f)*5.0f;\n    float res = point.y - sin(abs(point.x+phase)) * sqrt(abs(point.x)) * cos(iTime * 3.0f) * 2.0f;\n    return res;\n}\n\n// Checks if the point satifies the result equation\nbool check_equation(vec2 point)\n{\n    bool status = false;\n    float result = get_result(point);\n    \n    // Points that lie on the Curve\n#if !AREA_GRAPH\n    if(abs(result) < errorMargin)\n    {\n        status = true;\n    }\n#else\n    // All points inside the Curve\n    if(result < errorMargin)\n    {\n        status = true;\n    }\n#endif\n    return status;\n}\n\n// Gets the integer part of A ==> (1.2 => 1) and (-1.2 => -1)\nfloat get_int(float a)\n{\n    if(a < 0.0f)\n    {\n        return float(-1 * int(-1.0f * a));\n    }\n    return float(int(a));\n}\n\n// Gets the fractional part of A ==> (1.2 => 0.2) and (-1.3 => 0.3)\nfloat get_frac(float a)\n{\n    return abs(a - get_int(a));\n}\n\n// Returns the pixel in screen space\nfloat get_pixel(float a, float limit, float res)\n{\n    // A is from (-(L+1), (L+1))\n    // From (-1, 1)\n    a = a / (limit + 1.0f);\n    // From (0 , 1)\n    a = (a + 1.0f) / 2.0f;\n    // From (0 , res)\n    a *= res;\n    return a;\n}\n\n// Checks if the point lies on the Axes lines\nbool check_point(float pos, float limit, float resolution)\n{\n    bool status = false;\n    float width = gridWidth;\n    float fracPart = get_frac(pos);\n    float intPart = get_int(pos);\n    if(intPart == 0.0f)\n    {\n        width /= 2.0f;\n        if(width < 0.02f)\n        {\n            width = 0.02f;\n        }\n    }\n    if(abs(fracPart) < width)\n    {\n       float pixelVal = get_pixel(pos, limit, resolution);\n       float correctVal = get_int(get_pixel(intPart, limit, resolution));\n       float dist = abs(pixelVal - correctVal);\n       float testDist = float(pixelWidth);\n       if(intPart == 0.0f)\n       {\n           // testDist /= 2.0f;\n           testDist = get_int(testDist);\n       }\n       if(dist <= testDist)\n       {\n           status = true;\n       }\n    }\n    return status;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // 1. Setup Data\n    \n    // Gets the Y limit for square grid\n    float xLimit = (yLimit + 1.0f) * (iResolution.x / iResolution.y) - 1.0f;\n    \n    // From (0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // From (-1 to 1)\n    vec2 pos = (uv * 2.0f) - 1.0f;\n    \n    // From (-X to X, -Y to Y)\n    pos.x *= (xLimit + 1.0f);\n    pos.y *= (yLimit + 1.0f);\n    \n    // 2. Setup Color\n    \n    // a. Default Color is the Background\n    vec3 col = bgColor;\n    \n    // b. If the point lies on the grid lines, then change color\n    if(check_point(pos.x, xLimit , iResolution.x) || check_point(pos.y, yLimit, iResolution.y))\n    {\n        col = gridColor;\n        if((check_point(pos.x, xLimit , iResolution.x) && get_int(pos.x) == 0.0f) || \n            (check_point(pos.y, yLimit , iResolution.y) && get_int(pos.y) == 0.0f))\n        {\n            col = axesColor;\n        }\n    }\n    \n    // c. If the point satisfies the Equation, then change color\n    if(check_equation(pos))\n    {\n        col = eqColor;\n    }\n\n    // 3. Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 364, 394, 570, 725], [727, 779, 812, 812, 1134], [1136, 1198, 1222, 1222, 1322], [1324, 1392, 1417, 1417, 1451], [1453, 1490, 1540, 1593, 1720], [1722, 1768, 1828, 1828, 2561], [2564, 2564, 2619, 2685, 3702]], "test": "untested"}
{"id": "fdV3Rm", "name": "Candy Stacks", "author": "byt3_m3chanic", "description": "Some work on timing / animation / stacking stuff. Probably have more around this theme - I like the mechanics / taking vec - time + traveled to change animation", "tags": ["raymarching", "animation", "truchet", "motion", "timing"], "likes": 18, "viewed": 242, "published": "Public API", "date": "1631333802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n    \n    Candy Stacks \n    @byt3_m3chanic | 09/10/21\n\n    work on some timing/motion stuff.\n    built mechanics first\n    \n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    150.\n#define MIN_DIST    .001\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0., 1.); }\n\n//@iq shapes and extrude\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat cyl( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\nfloat opx( in vec3 p, float d, in float h ) {\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n// gear\nfloat gear(vec3 p, float radius, float thick, float hl) {\n    float hole = (radius*.25);\n    float sp = floor(radius*PI);\n    float gs = length(p.xy)-radius;\n    float gw = abs(sin(atan(p.y,p.x)*sp)*.2);\n    gs +=smoothstep(.05,.45,gw);\n    float cog= hl<1. ? max(opx(p,gs,thick),-(length(p.xy)-hole)) : opx(p,gs,thick);\n    return cog;\n}\n// consts\nconst float size = 4.;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n// globals\nfloat floorspeed;\nfloat ga1,ga2,ga3,ga4;\n\nvec3 hit=vec3(0),hitPoint,gid,sid;\nvec3 speed = vec3(0);\nmat2 r45,turn,spin;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id;\n    vec3 p2, q;\n    for(int i = 0; i<2; i++)\n    {\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n\n        float ff = qf-size;\n        float lent= ff<floorspeed-3. ? 7. : clamp(ga4,0.,1.)*7. ;\n        float fent= ff<floorspeed-3. ? 5. : clamp(ga4,0.,1.)*5. ;\n        vec3 r = q;\n        p2=q;\n        q.z=abs(q.z)-19.;\n        \n        float pole = (ff<floorspeed+1.&& i==0) ? min(cyl(q-vec3(0,lent+1.5,0),.25,lent+.5),\n        length(q-vec3(0,(lent+1.5)*2.,0))-(.75)) : 1e5;\n        \n        float pcap = max(cyl(q,.85,1.), -cyl(q,.45,2.) );\n        pcap = min(box(q,vec3(1.9,.1,1.5)),pcap);\n        pole=min(pcap,pole);\n        if(pole<res.x){\n            res = vec2(pole,5.);\n            hit=q;\n            gid = vec3(qf,0,0);\n        }  \n        \n        float qw=q.z - 2.;     \n        float wave = .5*sin(qw*1.5-T*4.+ff);\n        wave = mix(wave,0.,clamp(1.-((qw-1.5)*.5),0.,.8));\n        q.x-= wave*2.;\n        q.y-= wave;\n        \n        vec3 fq = q-vec3(0,(lent*2.),fent);\n        float flag=(ff<floorspeed+1.&& i==0) ? box(fq,vec3(.05,2.5,fent)) : 1e5;\n        if(flag<res.x){\n            res = vec2(flag,1.);\n            hit=fq;\n            gid = vec3(qf,0,0);\n        }\n\n        lent= ff<floorspeed+5. ? 0. : ff>floorspeed+6. ? 3.25 : clamp(1.-ga3,0.,1.)*3.25;\n        float ent= ff<floorspeed+35. ? 0. : ff>floorspeed+38. ? 38. : clamp(1.-ga3,0.,1.)*38.;\n        \n        if(i==0) ent = -ent;\n        float d3=box(r-vec3(0,(lent*3.)-2.,ent),vec3(2,2,14.));\n        if(d3<res.x){\n            res = vec2(d3,3.);\n            hit= r-vec3(0,(lent*3.)-2.,ent);\n            gid = vec3(qf,0,0);\n        }\n        \n    }\n\n    vec3 pb = vec3(p.x-speed.x-25.,p.y-19.,p.z-11.);\n    pb.xy*=spin;\n    float bls = gear(pb, 9.,1.5,1.);\n    vec3 pp = vec3(p.x-speed.x-29.,p.y-3.,p.z);\n    vec3 pq = vec3(p.x-speed.x-16.,p.y-3.,p.z);\n    \n    float beam = min(length(pp.xy)-.45,length(pq.xy)-.45);\n    beam = min(cyl(pb.yzx-vec3(0,22,0),1.25,25.25),beam);\n    beam = min(cyl(pb+vec3(0,0,2.4),.5,1.85),beam);\n    pp.xy*=turn; pq.xy*=turn;\n    bls = min(gear(pp, 3.,14.75,0.),bls);\n    bls = min(gear(pq, 3.,14.75,0.),bls);\n   \n    if(bls<res.x){\n        res=vec2(bls,4.);\n        hit=p2;\n    }\n    if(beam<res.x){\n        res=vec2(beam,5.);\n        hit=pb;\n    }\n    float fl=max(p.y,-box(p2,vec3(8.,4.,16.)) );\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 hue(float t){ \n    const vec3 c = vec3(.122,.467,.918);\n    return .45 + .35*cos(PI2*t*(c+vec3(.878,.969,.851))); \n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,128);\n    hitPoint=hit;  \n    sid=gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(25.,125.,-75.);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint+vec3(size,5,size);\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.;\n        for( float t=.0; t < 38.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += t<12.? h*.5 : h;\n            if( shdw<MIN_DIST || t>38. ) break;\n        }\n\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec = 0.3 * pow(max(dot(view, ret), 0.), 20.);\n        float clr;\n        \n        // materials\n        if(m==1.){\n            h=vec3(.745,.933,.929);\n            vec2 f = fract(hp.zy)-.5;\n            if(f.x*f.y>0.||hp.y<0.) h*=.25;    \n            ref = h-fresnel;     \n        }\n        if(m==2.){\n            h=vec3(.192,.306,.302);\n            vec2 f = fract(hp.xz/(dbl*2.))-.5;\n            if(f.x*f.y>0.) h=vec3(.220,.698,.682);\n            if( hp.y<1.1 ) h=vec3(.133,.247,.243);\n            ref =(f.x*f.y>0. && hp.y>1.1) ? vec3(.35)-fresnel:vec3(0.); \n        }\n        if(m==3.){\n            h = hue((50.+sid.x)*.0025);\n            float px = .05;\n            vec2 grid = fract(hp.xz/hlf)-.5;\n            vec2 id = floor(hp.xz/hlf);\n            float hs = hash21(id+sid.x);\n            if(hs>.5) grid.x*=-1.;\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n            float circle = length(gx)-.5;\n            circle=(chk>.5 ^^ hs<.5) ? smoothstep(-px,px,circle) : smoothstep(px,-px,circle);\n            h = mix(h, vec3(.08),circle);\n            if(hp.y<6.99) h=vec3(.8); \n            if(hp.y<6.99&&hp.y>6.) h=vec3(.2);\n            ref = (h*.4)-fresnel;\n        }\n        if(m==4.) {\n            ref = vec3(.1)-fresnel;\n            h=vec3(.2);\n        }\n        if(m==5.) {\n            ref = vec3(.2)-fresnel;\n            h=vec3(.4);\n        }\n        C = (diff*h)+spec;\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {   \n    // precal\n    r45=rot(-0.78539816339); \n    float time = (T+40.)*12.;\n    float tmod = mod(time, 10.);\n    float t3 = lsp(5., 10., tmod);\n    \n    float fmod = mod(time, 20.);\n    float t2 = lsp(10., 20., fmod);\n    \n    ga1 = (time*.1);\n    ga3 = (tmod<5.?t3+1. :t3);\n    ga4 = (fmod<10.?t2+1. :t2);\n    \n    speed = vec3(abs(ga1*size),0,0);\n    floorspeed=floor(speed.x);\n    turn=rot(ga1);\n    spin=rot(-ga1*.38);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*42.,-42.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    ro.yz*=r45;ro.xz*=r45;\n    rd.yz*=r45;rd.xz*=r45;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fill=vec3(1);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fill;\n        fill*=ref;\n    }\n    // mixdown \n    float vin = length((2.*F.xy-R.xy)/R.x)-.175;\n    C = mix(C,C*.5,smoothstep(.0,.8,vin));\n    C = clamp(C,vec3(.015),vec3(1));\n    // gamma\n    C = pow(C, vec3(.4545));\n    // output\n    O = vec4(C,1.);\n}\n//end\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 296, 314, 314, 359], [360, 360, 381, 381, 436], [437, 437, 481, 481, 534], [536, 561, 588, 588, 677], [678, 678, 717, 717, 822], [823, 823, 868, 868, 961], [962, 970, 1027, 1027, 1308], [1396, 1527, 1548, 1548, 4114], [4116, 4116, 4146, 4146, 4385], [4387, 4387, 4432, 4432, 4662], [4664, 4664, 4682, 4682, 4785], [4787, 4787, 4870, 4870, 7445], [7447, 7447, 7488, 7505, 8549]], "test": "untested"}
{"id": "fdV3Wt", "name": "Ascending onions", "author": "SnoopethDuckDuck", "description": "No idea how this works, somehow botched transparency into existence and a few artifacts on top of the oniony bits, but looks gd", "tags": ["raymarching", "template", "artofcode"], "likes": 5, "viewed": 169, "published": "Public API", "date": "1632420688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    //float d = sdBox(p, vec3(1));\n    float r1 = 2. + cos(p.y + iTime);\n    float r2 = 0.2;\n    \n    float d1 = length(p.xz) - r1;\n\n    float a = atan(p.x,p.z);\n    float b = .5 + .5 * cos(iTime);\n    \n    float cd = length(p.xz) - 0.2\n    - abs(pow(cos(0.8 * p.y - iTime),1.5 + .5 * cos(iTime)));\n \n    p.y = cos(1. + 3. * cos(3. * a + p.z + p.x + iTime) * cos(3. * p.y));\n    float td2 = length(vec2(d1, -0.3 + 0.2 *sin(2. +  p.y - 0.4 * iTime) -0.2 * cos(2. * a + 4. *iTime))) -r2;\n    \n    // 0.5 *\n    td2 += 0.8 * cos(0.4 * iTime) *(0.9 * cos(5. * a + 2. * iTime));\n    \n    cd -= 0.3 * cos(0.5 * p.y + iTime);\n    cd *= 0.5;\n    \n    return min(cd, td2* 0.5);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    n *= (n-1.); // i added this\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.5,0.,0.),vec3(0.),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(8. * cos(iTime), 4. + 0.6 * iTime, 8. * sin(iTime));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,-2. + 0.6 * iTime,0), 0.85 + 0.05 * cos(iTime));\n    vec3 col = vec3(0);\n    col += Bg(rd);\n   \n    float d = RayMarch(ro, rd);\n    d =  RayMarch(ro + rd * 2. * d, -rd);\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float spec = pow(max(0., r.y),16.);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        dif = 4. * dif * (1.-dif);\n        col = vec3(dif);\n        float a = atan(p.x,p.z);\n        col = mix(Bg(r), vec3(spec), 1.) + 0.2 * spec + Bg(r) * 0.6 *cos(2. * a + 0.1 * p.y + iTime);\n      //  col = mix(col, vec3(.5 + .5 * cos(iTime),0.,0.),.1);\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3Wt.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1475, 1494, 1494, 1556], [1558, 1558, 1597, 1597, 1689], [1691, 1691, 1720, 1720, 1801], [1804, 1804, 1827, 1862, 2497], [2499, 2499, 2533, 2533, 2744], [2746, 2746, 2770, 2770, 2989], [2991, 2991, 3041, 3041, 3232], [3234, 3234, 3252, 3252, 3350], [3352, 3352, 3409, 3409, 4441]], "test": "untested"}
{"id": "fdV3zW", "name": "Discotec", "author": "supah", "description": "Disco lights", "tags": ["waves", "disco", "lights", "gradients"], "likes": 12, "viewed": 182, "published": "Public", "date": "1631192506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat plot(vec2 st, float pct){\n  float cut = 0.0073;\n  return  smoothstep( pct-cut, pct, st.y) -\n          smoothstep( pct, pct+cut, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y; // -.5 <> .5\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < 30.; i += 1.) {\n        float inc = i / 30.;\n        float l = plot(\n            uv * .5, 0.13 * cnoise(\n            vec3(\n                smoothstep(0.5, 0., .4 * length(uv)) * 4. + iTime, \n                .2 * iTime + .2 * uv.x,\n                -i * 0.02\n            )\n           ));\n        vec3 c = mix(vec3(1., uv.x + .5 - (sin(iTime) * .5), 1. - uv.x), vec3(uv.x + .5, .5 + (sin(uv.x + iTime) * .5), .5 - uv.x), inc);\n        col += vec3(l * c * .3);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdV3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2542, 2542, 2573, 2573, 2684], [2686, 2686, 2743, 2743, 3398]], "test": "untested"}
{"id": "fdVGDc", "name": "rr", "author": "aliva", "description": "d", "tags": ["ss"], "likes": 3, "viewed": 108, "published": "Public API", "date": "1632334444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SceneDurationSeconds = 400.;\nconst float Complexity = 18.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.7031, 1500, .0953, .3099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/max(iResolution.x, iResolution.y);\n    uv.x --;\n    uv /= 4.;\n\n    float scene = floor((iTime+98.)/SceneDurationSeconds);\n    vec4 hscene = hash42(vec2(scene));\n    uv += scene;\n    \n    float t = iTime*mix(.01,.06,hscene.y);\n    uv -= t*.5;\n\n    vec2 uvn = C/iResolution.xy-.5;\n    float ds = max(abs(uvn.x), abs(uvn.y))*4.;\n    \n    for (float i = 1.; i < Complexity; ++ i) {\n        vec2 c = floor(uv);\n        vec4 h = hash42(c);\n        vec2 p = fract(uv);\n        vec2 a = abs(p-.5);\n        float sd = .5-max(a.x, a.y);\n        o = h*sqrt(sd)*4.;\n        uv *= 2.;\n        float sc = 1./i;\n        uv += fract(abs(fract(uv.yx/sc+t)-.5)*sc-1.) * sign(hscene.x - .5);\n    }\n  \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 93, 93, 240], [242, 242, 278, 278, 978]], "test": "untested"}
{"id": "fdVGDh", "name": "2d electromagnetic potential ", "author": "Lay", "description": "Thisi is a visualization of conformal map applied to problem to find potential of charged 2d particle being placed between two conductors\n\nfwidth is used so fullscreen is preferred", "tags": ["complexanalysis"], "likes": 3, "viewed": 55, "published": "Public", "date": "1631917262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float scale = 1.; // try 2. or 3.\n\nvec2 complex_log(vec2 z)\n{\n    return vec2(log(length(z)), atan(z.x, z.y));\n}\n\nvec2 complex_exp(vec2 z)\n{\n    return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y));\n}\n\nvec2 position(float t)\n{\n    t *= 3.14;\n    return vec2(cos(t), sin(t));\n}\n\nfloat potential(vec2 uv, float t)\n{\n    vec2 p = position(t);\n    vec2 n = p; n.y = -n.y;\n    float pot = -log(length(uv - p)) + log(length(uv - n));\n    return 1. * pot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.5 * iResolution.x/iResolution.y;\n    uv *= 3.14;\n    float time = fract(0.04 * iTime);\n    time = clamp(time, .0, .5) - 0.5 * time;\n    time *= 8.;\n    time -= .5;\n    time = smoothstep(0., 1., time);\n    uv *= scale;\n    uv = (1. - time) * uv + time * complex_exp(uv);\n\n    float t = 0.4 * sin(0.3 * iTime) + 0.5;\n    vec2 pos = position(t);\n    vec2 pos_neg = pos;\n    pos_neg.y = - pos_neg.y;\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(1.) * max(0., cos((30. * atan(uv.x, uv.y))) * smoothstep(0.009, 0.003, abs(1. - length(uv))));\n    col += vec3(1.) * smoothstep(0.02 * abs(uv.x), 0.01 * abs(uv.x), abs(uv.y));\n    \n    col.b += smoothstep(.04, .03, length(uv - pos));\n    col.r += smoothstep(.04, .03, length(uv - pos_neg));\n    \n    float fw = fwidth(25./(sqrt(abs(potential(uv, t)))));\n    float moire = abs(fw);\n    moire = smoothstep(2.2, .2, moire);\n    \n    float pot = potential(uv, t);\n    float bl = pot;\n    bl = smoothstep(1. - moire, 1., cos(25./(sqrt(bl))));\n    bl *= ( 1. - smoothstep(.1, .04, length(uv - pos)));\n    \n    float rd = -pot;\n    rd = smoothstep(1. - moire, 1., cos(25./(sqrt(rd))));\n    rd *= ( 1. - smoothstep(.1, .04, length(uv - pos_neg)));\n    \n    col.b += bl * moire;\n    col.r += rd * moire;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 35, 61, 61, 112], [114, 114, 140, 140, 201], [203, 203, 227, 227, 277], [279, 279, 314, 314, 451], [453, 453, 510, 560, 1894]], "test": "untested"}
{"id": "fdVGRD", "name": "Ribbons No Segment Edit?????????", "author": "Insidious_Scripter", "description": "OG: https://www.shadertoy.com/view/XdlSDs\nGood for a bg...", "tags": ["ribbon"], "likes": 4, "viewed": 65, "published": "Public", "date": "1631195419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float tau = 3.1415926535*2.0;\n    float a = atan(p.x,p.y);\n    float r = length(p)*0.75;\n    vec2 uv = vec2(a/tau,r);\n\t\n\t//get the color\n\tfloat xCol = (uv.x - (iTime / 3.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\n\t// draw color beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = (0.7+0.5*cos(uv.x*10.0*tau*0.15*clamp(floor(cos(iTime)), 0.0, 10.0))) * abs(1.0 / (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\tfragColor = vec4((( horBeam) * horColour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 871]], "test": "untested"}
{"id": "fdVGRy", "name": "CIS-566: Lab 1 - Q1", "author": "raykim1996", "description": "Shader\n", "tags": ["shader"], "likes": 1, "viewed": 17, "published": "Public", "date": "1631761990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\n\n#define PI 3.1415926535\n\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n//20 spikes\nfloat spikeNum = 20.0;\n\nvec4 q1(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n    float angle = atan(uv.x, uv.y);\n\tfloat t = sin(angle);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n    \n    vec2 pos = center - uv;\n    float angle = atan(pos.x, pos.y);\n    radius += ((40.0 * (cos(angle * 20.0))) + 10.0) * cos(iTime * 1.5);\n\tvec4 layer2 = circle(uv, center, radius, red);\n    //vec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 139, 176, 176, 225], [227, 290, 351, 351, 455], [457, 493, 550, 550, 682], [684, 744, 799, 799, 1073], [1075, 1075, 1132, 1132, 1673]], "test": "untested"}
{"id": "fdVGWm", "name": "Vaporwave Aesthetics", "author": "wildniklin", "description": ".", "tags": ["vaporwave"], "likes": 4, "viewed": 132, "published": "Public API", "date": "1631660500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.01;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGrid(vec3 p) {\n    //return min(length(p.xy), length(p.zy)); // this line is slower than the code below\n    p *= p;\n    return sqrt(min(p.x + p.y, p.y + p.z));\n}\n\nfloat map(vec3 p) {\n    return sdGrid(vec3(fract(p.x) - 0.5, p.y, fract(p.z) - 0.5)) - 0.02;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float sd = map(ro + (rd * d));\n        d += sd;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(sd) <= MIN_DIST) return d;\n    }\n    return MAX_DIST;\n}\n\nvec3 sky(vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    float y = rd.y + 0.056;\n    \n    float k = smoothstep(0.4, 0.0, y);\n    \n    col += 0.2 * smoothstep(0.9, 1.0, texture(iChannel3, sin(rd.xy) + sin(rd.zy)).x) * smoothstep(1.0, 0.7, k);\n    \n    col += (mix(vec3(0.1, 0.2, 1.0), vec3(0.85, 0.2, 1.0), k) * k) * step(0.0, y);\n    \n    col += vec3(1.5) * smoothstep(0.01, 0.0, y);\n    \n    //col = mix(col, vec3(0.9, 0.8, 0.3) * 2.2, smoothstep(0.99, 0.993, rd.z) * (smoothstep(0.08, 0.1, rd.y) + (smoothstep(0.05, 0.065, rd.y) * smoothstep(0.08, 0.065, rd.y) * 0.8) + (smoothstep(0.05, 0.035, rd.y) * smoothstep(0.02, 0.035, rd.y) * 0.6) + (smoothstep(0.02, 0.005, rd.y) * smoothstep(0.005, 0.02, rd.y) * 0.4)));\n    col = mix(col, vec3(0.9, 0.8, 0.3) * 2.2, smoothstep(0.99, 0.993, rd.z) * mix(1.0, ((sin(rd.y * 3.1415 * 70.0) * 0.5) + 0.5) * smoothstep(-0.08, 0.01, rd.y), step(rd.y, 0.006)));\n    \n    col *= 0.8;\n    \n    return col;\n}\n\nfloat marchplane(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float sd = ro.y + (rd.y * d);\n        d += sd;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(sd) <= MIN_DIST) return d;\n    }\n    return MAX_DIST;\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 3.0, iTime * 3.0);\n    vec3 rd = normalize(vec3(uv, 1.7));\n    \n    vec3 col = vec3(0.0);\n    \n    float d = march(ro, rd);\n    vec3 p = ro + (rd * d);\n    \n    if(d < MAX_DIST) {\n        col = vec3(0.5, 0.2, 0.8) * 2.0;\n    }\n    \n    // bloom\n    float dplane = marchplane(ro, rd);\n    vec3 pplane = ro + (rd * dplane);\n    vec2 gridf = fract(pplane.xz - 0.5);\n    col += vec3(0.5, 0.2, 0.8) * 0.8 * (smoothstep(0.2, 0.0, gridf.x) + smoothstep(0.8, 1.0, gridf.x) + smoothstep(0.4 + log(p.z - ro.z) * 0.05, 0.0, gridf.y) + smoothstep(0.6 - log(p.z - ro.z) * 0.05, 1.0, gridf.y));\n    \n    col = mix(col, sky(rd), dplane / MAX_DIST);\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 106, 106, 172], [174, 174, 196, 285, 343], [345, 345, 364, 364, 439], [441, 441, 472, 472, 701], [703, 703, 722, 722, 1644], [1646, 1646, 1682, 1682, 1910], [1912, 1912, 1948, 1948, 2718]], "test": "untested"}
{"id": "fdVGWW", "name": "Ed Balls", "author": "SnoopethDuckDuck", "description": "more messing around", "tags": ["cool"], "likes": 3, "viewed": 108, "published": "Public API", "date": "1631560661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float myLength(vec2 uv, float t) {\n    return abs(uv.x * (1. + 0.5 * cos(t))) + abs(uv.y * (1. + 0.5 * sin(t)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.3 * iTime;\n    float s = 0.5 * (1. + cos(t));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (12. + 2. * cos(0.45 * t)) *(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n     float theta = atan(uv.y, uv.x);\n    uv = vec2(cos(uv.x + theta + 0.9 * t), sin(uv.y + theta + 0.9 * t));\n    //float theta =  atan(uv.y, uv.x);\n    // Time varying pixel color\n    float d = smoothstep(myLength(uv + 0.1 * vec2(cos(t),sin(t)), 4. * t),\n                         0.2 * sin(1. * theta + t) * cos(1. * theta +  t), \n                         0.1);\n    float r = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    r *= 10. * d * (1.-d);\n    \n    d += 0.005 * cos(theta + t);\n    \n    float g = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    g *= 10. * d * (1.-d);\n    \n    d -= 0.01 * cos(theta + t);\n    \n    float b = step(16. * d * (1.-d) * d * (1.-d), 0.1);\n    b *= 10. * d * (1.-d);\n    \n    \n    // Output to screen\n    fragColor = vec4(g,r,b, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 114], [116, 116, 173, 173, 1143]], "test": "untested"}
{"id": "fdy3Dc", "name": "triangle wave vfx", "author": "pugbyte", "description": "Simple example replicating the damage indicator from here: https://www.youtube.com/watch?v=xvuTdf-GGs4&t=29s", "tags": ["2d"], "likes": 0, "viewed": 62, "published": "Public API", "date": "1632287198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://en.wikipedia.org/wiki/Triangle_wave\nfloat triangleWave(float t, float period) {\n    return 2. * abs(t/period - floor(t/period + .5));\n}\n\nfloat edgeEffect(float x, float y, float scale, float iTime) {\n    \n    // Make these shader uniforms and use game logic to manipulate the effect\n    float period = .07;\n    float amplitude = .07;\n    float border = mix(.0, .2, sin(iTime)*.5+.5);\n    float wave = mix(.0, .06, sin(x*scale*15.+iTime*10.)*.5+.5);\n    float shift = -iTime*.3;\n    \n    float ty = triangleWave(scale*(x+shift), period);\n    \n    return step(1.-abs(y), scale*(ty*amplitude+border+wave));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    float aspectRatio = iResolution.y/iResolution.x;\n    \n    vec3 col = vec3(0);\n    vec3 rainbow = hsv2rgb(vec3(iTime*.1, .9, .9));\n    \n    // top/bottom\n    col = mix(col, rainbow, edgeEffect(uv.x, uv.y, 1., iTime));\n    // left/right\n    col = mix(col, rainbow, edgeEffect(uv.y, uv.x, aspectRatio, iTime));\n\n    // Gamma correction\n    col = pow(max(col,0.), vec3(1./2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 59, 81, 81, 250], [252, 299, 342, 342, 398], [400, 400, 462, 545, 868], [870, 870, 927, 978, 1469]], "test": "untested"}
{"id": "fdy3DW", "name": "Spruce Goose", "author": "dr2", "description": "Possibly the undesigned Mk.II version; flies about as well", "tags": ["airplane", "wake", "hughes", "seaplane"], "likes": 25, "viewed": 218, "published": "Public API", "date": "1631534996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Spruce Goose\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 17 in \"Aeroplane\" series\n    \"River Flight\"              (4sSXDG)\n    \"Spitfire Pursuit\"          (4dSSWV)\n    \"Alpine Jets\"               (Xll3Rr)\n    \"Canyon Roller\"             (4tlGDM)\n    \"Biplanes in the Badlands\"  (MlX3Rf)\n    \"Albert's Canyon\"           (4lXGRl)\n    \"Yellow Moth\"               (MtXGzs)\n    \"Shootout in Red Canyon\"    (XsVXWG)\n    \"Aerobatics\"                (XltGRM)\n    \"Pack Ice\"                  (ldScDt)\n    \"Red Canyon 2\"              (ldlBRM)\n    \"Cockpit View\"              (MsffWn)\n    \"Arctic Patrol\"             (lsBfzy)\n    \"River Flight 2\"            (4l3cz8)\n    \"Ekranoplan\"                (Wd3fDH)\n    \"Suborbital Flight\"         (stXSDs)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, flyPos, flyVel;\nfloat tCur, dstFar, flyRol, wkFac;\nint idObj;\nconst int idFus = 1, idCkp = 2, idEng = 3, idHul = 4, idWngM = 5, idWngT = 6, idTail = 7,\n   idFlt = 8, idLeg = 9, idAnt = 10;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wsp, wcr, s, w, t, dy;\n  dMin = dstFar;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  w = 1.;\n  dy = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    dy = 0.02 * s;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.04 * s;\n    dy = -0.02 * s;\n  }\n  d = PrCapsDf (q - vec3 (0., dy, 0.), w, 7.);\n  DMINQ (idFus);\n  q = p;\n  q.yz -= vec2 (0.4, 3.7);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  wsp = 5.;\n  wcr = 1.4;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (wsp, 0.8, 1.);\n  s = (q.z - 0.3) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (abs (q.x - 0.45) - 2.15, q.z - 0.065 * q.x + 1.),\n     vec2 (2., 0.2))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngM);\n  wsp = 2.4;\n  wcr = 0.65;\n  q = p;\n  q.x = abs (q.x);\n  t = wcr * (1. - 0.25 * q.x / wsp);\n  q -= vec3 (0., 1.4, -6.2);\n  s = (q.z - 0.1) / wcr;\n  d = min (wsp - q.x, abs (PrBox2Df (vec2 (q.x - 1.4, q.z - 0.03 * q.x + 0.35),\n     vec2 (0.8, 0.15))));\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idWngT);\n  wsp = 1.3;\n  wcr = 1.;\n  q = p;\n  t = wcr * (1. - 0.25 * q.y / wsp);\n  q.yz -= vec2 (1.6, -6.3);\n  s = (q.z + 0.2 * q.y / wsp - 0.1) / wcr;\n  d = min (wsp - abs (q.y), abs (PrBox2Df (vec2 (q.y - 0.25, q.z + (0.2 / wsp - 0.19) * q.y + 0.57),\n     vec2 (0.75, 0.17))));\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.2 * q.y / wsp), 0.12 * (t - s * s), t), - d, 0.05);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.1);\n  w = 0.2 * (1. - 0.5 * q.z * q.z);\n  d = min (max (PrCapsDf (q, w, 0.9), q.z - 0.5), PrCapsDf (q, 0.13, 0.55));\n  DMINQ (idEng);\n  q = p;\n  q.yz -= vec2 (-0.8, 4.);\n  w = 0.55;\n  t = 0.3;\n  s = q.z * q.z;\n  if (q.z > 0.) {\n    w *= 1. - 0.1 * s;\n    q.y -= 0.025 * s;\n    t -= 0.05 * s;\n  } else {\n    w *= 1. - 0.01 * s;\n  }\n  w *= 1. + q.y;\n  d = PrRoundBoxDf (q, vec3 (w, t, 5.5 + 0.1 * q.y), 0.1);\n  DMINQ (idHul);\n  q = p;\n  q.x = abs (q.x);\n  q.xz -= vec2 (6.5, 1.1);\n  q.z = dot (vec2 (abs (q.z) - 0.3, q.y), sin (0.03 * pi * sign (q.z) + vec2 (0.5 * pi, 0.)));\n  d = max (PrCaps2Df (q.xz, 0.03, 0.12), abs (q.y) - 0.75);\n  DMINQ (idLeg);\n  q.yz -= vec2 (-0.83, 0.1);\n  d = max (PrCapsDf (q, 0.25, 0.5), q.y - 0.13);\n  DMINQ (idFlt);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 1.1, 3.);\n  d = PrCapsDf (q.xzy, 0.03, 0.15);\n  DMINQ (idAnt);\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 3.5) - 1.2);\n  q -= vec3 (0.6, 0.8, 2.65);\n  d = PrCylDf (q, 0.55, 0.02);\n  qHit = q;\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, gCol4;\n  float s;\n  col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n  gCol4 = vec4 (0.9, 0.5, 0.2, 0.2);\n  if (idObj == idFus) {\n    col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (PrRoundBox2Df (vec2 (qHit.y - 0.2,\n       abs (qHit.z - 1.) - 2.5), vec2 (0.35, 0.12), 0.05)));\n    if (PrRoundBox2Df (vec2 (qHit.y - 0.3, mod (qHit.z + 0.5, 1.) - 0.5),\n       vec2 (0.15, 0.08), 0.05) < 0. && abs (qHit.z) < 4.5) col4 = vec4 (0., 0., 0., -2.);\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (abs (qHit.y + 0.4) - 0.04)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.5 && qHit.y < 0.53 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.25) - 0.25) > 0.03) col4 = vec4 (0., 0., 0., -2.);\n  } else if (idObj == idWngM) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.x - 2., qHit.z - 0.1)) - 0.4) - 0.1) - 0.02));\n    if (length (vec2 (abs (qHit.x - 5.), qHit.z - 0.8)) < 0.1) col4 = vec4 (0.8, 0., 0., -1.);\n  } else if (idObj == idTail) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025,\n       abs (abs (length (vec2 (qHit.y - 0.5, qHit.z - 0.05)) - 0.2) - 0.05) - 0.02));\n    if (length (vec2 (qHit.y - 1.3, qHit.z + 0.65)) < 0.12) col4 = vec4 (0.9, 0.9, 0.3, -1.);       \n  } else if (idObj == idEng) {\n     col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (qHit.z - 0.35) - 0.03);\n     col4 = mix (col4, gCol4, step (0.52, qHit.z));\n  } else if (idObj == idHul || idObj == idFlt) {\n    col4 *= 0.93 + 0.07 * sin (128. * sin (qHit.y));\n  } else if (idObj == idLeg) {\n    col4 = mix (gCol4, col4, smoothstep (0., 0.025, abs (qHit.z) - 0.01));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, t, tw, cs;\n  float wFreq, wAmp, h;\n  h = 0.;\n  if (d < 0.3 * dstFar) {\n    qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n    wFreq = 0.4;\n    wAmp = 0.1;\n    tw = 0.5 * tCur * vec2 (1., -1.);\n    q = p;\n    q += flyVel.xz * tCur;\n    for (int j = 0; j < 5; j ++) {\n      q *= qRot;\n      t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n      v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n      t = 1. - sqrt (v4.xz * v4.yw);\n      t *= t;\n      t *= t;\n      h += wAmp * (t.x + t.y);\n      wFreq *= 2.;\n      wAmp *= 0.5;\n    }\n    h += 0.3 * wkFac * (1. - smoothstep (0.3, 1.5, length (vec2 (abs (p.x) - 1.3, 0.1 * p.y + 1.1))));\n    h *= 1. - smoothstep (0.1, 0.3, d / dstFar);\n  }\n  return h;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz, s)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  float h;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  h = WaveHt (p.xz, d);\n  return vec4 (normalize (vec3 (h - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy, h);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.4, 1.) + 0.2 * pow (1. - rd.y, 5.),\n     vec3 (0.9), clamp (Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz +\n     0.5 * tCur)) * rd.y + 0.2, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vh4;\n  vec3 col, vn, rw, vnw, row, rdw, roo, rdo, watCol, c;\n  float dstObj, dstWat, f, sh, hw, wkFacF, nDotL;\n  bool waterRefl;\n  flyVel = vec3 (0., 0., 7.);\n  flyRol = 0.005 * pi * sin (0.1 * pi * tCur);\n  wkFac = 1. - smoothstep (0., 0.5, flyPos.y - 1.2);\n  wkFacF = 0.7 * (1. - smoothstep (0., 0.5, flyPos.y - 0.95));\n  roo = ro;\n  rdo = rd;\n  if (rd.y < 0.) {\n    dstWat = - ro.y / rd.y;\n    if (dstWat < 0.3 * dstFar) dstWat = WaveRay (ro, rd);\n  } else dstWat = dstFar;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    if (k == 0 || waterRefl) dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      waterRefl = (dstWat < min (dstFar, dstObj));\n      if (waterRefl) {\n        ro += dstWat * rd;\n        vh4 = WaveNf (ro, dstWat);\n        vnw = vh4.xyz;\n        hw = vh4.w;\n        row = ro;\n        rdw = rd;\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n      }\n    }\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    if (col4.a >= 0.) {\n      sh = waterRefl ? 1. : ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n         0.8 * sh * nDotL * nDotL) + col4.a * step (0.95, sh) * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.7 + 0.3 * max (- dot (rd, vn), 0.));\n    }\n    if (col4.a == -2. || col4.a >= 0.) {\n      rd = reflect (rd, vn);\n      c = SkyCol (ro, rd);\n      if (col4.a == -2.) col = 0.4 * (c * c + 0.5);\n      else if (rd.y > 0.) col = mix (col, c, 0.05);\n    }\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    f = (1. - smoothstep (0.1, 1.5, length (vec2 (0.3 * row.x, 0.06 * row.z + 1.)))) * wkFac;\n    f = max (f, (1. - smoothstep (0.1, 1., length (vec2 (0.8 * (abs (row.x) - 6.5),\n       0.1 * row.z + 0.5)))) * wkFacF);\n    rw = row + flyVel * tCur;\n    vnw = VaryNf (rw, vnw, (1. + 5. * f) * (1. - smoothstep (0.1, 0.4, dstWat / dstFar)));\n    watCol = mix (vec3 (0.1, 0.35, 0.4), vec3 (0.1, 0.3, 0.25),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * rw.xz))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.8 * col, 0.2 + 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (1.), 0.5 * (1. - smoothstep (0., 0.1, f)) * pow (clamp (0.1 * hw +\n         Fbm2 (0.5 * rw.xz), 0., 1.), 8.));\n    col = mix (col, vec3 (1.) * (0.7 + 0.3 * Fbm2 (64. * rw.xz)), f);\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.6, 0.95, dstWat / dstFar));\n  }\n  if (TrObjRay (roo, rdo) < min (min (dstObj, dstWat), dstFar)) col = mix (col,\n     mix (vec3 (1., 0.6, 0.3), vec3 (1.), step (0.05, abs (length (qHit.xy) - 0.45))), 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  } else {\n    az -= 0.025 * pi * tCur;\n    el -= 0.05 * pi * sin (0.04 * pi * tCur);\n  }\n  el = clamp (el, 0.07 * pi, 0.3 * pi);\n  flyPos = vec3 (0., 1.2 + 4. * SmoothBump (0.25, 0.75, 0.15, mod (0.02 * tCur, 1.)), 0.);\n  ro = 35. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.).xzy;\n  vuMat = DirVuMat (normalize (flyPos - ro));\n  zmFac = 5.5;\n  dstFar = 250.;\n  sunDir = normalize (vec3 (1., 1.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3DW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[120, 1818, 1840, 1840, 4360], [4362, 4362, 4395, 4395, 4578], [4580, 4580, 4601, 4601, 4856], [4858, 4858, 4882, 4882, 5088], [5090, 5090, 5125, 5125, 5309], [5311, 5311, 5329, 5329, 6966], [6968, 6968, 7005, 7005, 7234], [7236, 7236, 7268, 7268, 8021], [8023, 8023, 8057, 8057, 8560], [8562, 8562, 8593, 8593, 8795], [8797, 8797, 8829, 8829, 9034], [9036, 9036, 9071, 9071, 11933], [11935, 11935, 11991, 11991, 13245], [13247, 13247, 13293, 13293, 13340], [13342, 13342, 13375, 13375, 13464], [13466, 13466, 13513, 13513, 13560], [13562, 13562, 13604, 13604, 13655], [13657, 13657, 13700, 13700, 13764], [13766, 13766, 13810, 13810, 13870], [13872, 13872, 13917, 13917, 14009], [14011, 14011, 14056, 14056, 14094], [14096, 14096, 14153, 14153, 14236], [14238, 14238, 14263, 14263, 14432], [14434, 14434, 14464, 14464, 14577], [14579, 14579, 14610, 14610, 14674], [14708, 14708, 14732, 14732, 14844], [14846, 14846, 14870, 14870, 14933], [14935, 14935, 14960, 14960, 15146], [15148, 15148, 15173, 15173, 15510], [15512, 15512, 15533, 15533, 15688], [15690, 15690, 15719, 15719, 15931], [15933, 15933, 15972, 15972, 16224]], "test": "untested"}
{"id": "fdy3WG", "name": "Fractal 77_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 27, "viewed": 352, "published": "Public API", "date": "1632022879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.08*exp(-i*i*e))\n    {\n        p=g*d;\n        p.z-=.6;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        s=4.;\n        for(int j=0;j++<8;)\n            p=abs(p),p=p.x<p.y?p.zxy:p.zyx,\n            s*=e=1.8/min(dot(p,p),1.3),\n            p=p*e-vec3(12,3,3);\n        g+=e=length(p.xz)/s;\n  \n    }\n    O=pow(O,vec4(5));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 643]], "test": "untested"}
{"id": "fdy3z3", "name": "Hexagins", "author": "narida", "description": "Some shoddy workmanship.", "tags": ["2d", "hexagons", "myocdhatesthis"], "likes": 3, "viewed": 174, "published": "Public API", "date": "1631824494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\nprecision highp int;\n\nfloat banded(float bandCount, float t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec2 banded(float bandCount, vec2 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nvec3 banded(float bandCount, vec3 t) {\n  return clamp(floor(t * bandCount) / (bandCount - 1.0), 0.0, 1.0);\n}\nfloat banded(int bandCount, float t) {\n  return banded(float(bandCount), t);\n}\n\nbool between(float min, float max, float value) {\n    return min <= value && value <= max;\n}\n\nfloat unmix(float a, float b, float value) {\n  return (value - a) / (b - a);\n}\nvec3 unmix(float a, float b, vec3 value) {\n  return (value - a) / (b - a);\n}\n\nvec3 fromPolar(float radius, float phi, float z) {\n  return vec3(radius * cos(phi), radius * sin(phi), z);\n}\n\nvec2 fromPolar(float radius, float phi) {\n  return vec2(radius * cos(phi), radius * sin(phi));\n}\n\nvec2 fromPolar(vec2 polar) {\n  return fromPolar(polar.x, polar.y);\n}\n\nvec2 hex2xy(vec3 hex) {\n    float y = hex.t * 0.866;\n    float x = hex.s + hex.t / 2.0;\n    return vec2(x, y);\n}\n\n// correct the 3d coordinate of a hex coordinate.\nvec3 hexFix(vec2 hexXy) {\n    return vec3(hexXy, -(hexXy.x + hexXy.y));\n}\n\nvec3 hexRound(vec3 hex) {\n    vec3 r = floor(hex + 0.5);\n    vec3 diff = abs(r - hex);\n\n    if (diff.x > diff.y && diff.x > diff.z) {\n        r.x = -(r.y + r.z);\n    } else if (diff.y > diff.z) {\n        r.y = -(r.x + r.z);\n    } else {\n        r.z = -(r.x + r.y);\n    }\n\n    return r;\n}\n\nfloat max3(float a, float b, float c) {\n  return max(a, max(b, c));\n}\nfloat max3(vec3 v) {\n  return max(v.x, max(v.y, v.z));\n}\n\nfloat min3(float a, float b, float c) {\n    return min(a, min(b, c));\n}\n\nfloat min3(vec3 a) {\n    return min(a.x, min(a.y, a.z));\n}\n\nfloat hexSdf(vec3 hex) {\n//    hex.x += 2.*hex.y/.6;\n//    hex.z = -(hex.x+hex.y);\n//    return max3(abs(hex.xyz));\n    return max3(abs(hex.yzx + hex.zxy / 2.0));\n}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth_2315452051(vec3 hsv) {\n    vec3 rgb = clamp(\n    abs(mod(hsv.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0,\n    0.0, 1.0);\n\n    rgb = rgb*rgb*(3.0-2.0*rgb);// cubic smoothing\n\n    return hsv.z * mix(vec3(1.0), rgb, hsv.y);\n}\n\nconst float TAU = 6.283185307179586;\n// returns a random vector inside the unit circle\n// all points inside the circle are more likely,\n// ie. higher radiuses are more likely\nvec2 randomVector(vec2 random01) {\n    return fromPolar(sqrt(random01.x), random01.y * TAU);\n}\n\nfloat remix(float fromA, float fromB, float toA, float toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nvec4 remix(float fromA, float fromB, vec4 toA, vec4 toB, float value) {\n  return mix(toA, toB, unmix(fromA, fromB, value));\n}\n\nmat2 rot2d(float angleRad) {\n    float c = cos(angleRad), s = sin(angleRad);\n    return mat2(\n    c, -s,\n    s, c);\n}\n\nvec2 tri2xy(vec3 uvR) {\n    float y = uvR.t * 0.866;\n    float x = uvR.s + uvR.t / 2.0;\n    return vec2(x, y);\n}\nvec2 tri2xy(vec2 uv) {\n    float y = uv.t * 0.866;\n    float x = uv.s + uv.t / 2.0;\n    return vec2(x, y);\n}\n\nvec3 triCenter(vec3 uvR) {\n    vec3 base = floor(uvR);\n    vec2 centerOffset = mix(vec2(1./3.), vec2(2./3.), uvR.z);\n    return base + vec3(centerOffset, 0.0);\n}\n\nvec3 xy2hex(vec2 xy) {\n    float hex_t = xy.y / 0.866;\n    float hex_s = xy.x - hex_t / 2.0;\n    return vec3(hex_s, hex_t, -(hex_s + hex_t));\n}\n\nvec3 xy2tri(vec2 xy) {\n    float v = xy.y / 0.866;\n    float u = xy.x - v / 2.0;\n    float R = float(fract(u) + fract(v) > 1.0);\n    return vec3(u, v, R);\n}\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\nuvec2 pcg(uvec2 v) {\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v >> 16u);\n\n    return v;\n}\n\n// pcg3d renamed for overload\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec3 pcgf(out uvec3 v) {\n    v = pcg(v);\n    return vec3(v) / float(0xffffffffu);\n}\n\nvec4 linRgbColor(vec4 sRgbColor) {\n    return vec4(pow(sRgbColor.xyz, vec3(2.2)), sRgbColor.w);\n}\n\nvec4 getColorAt(ivec2 pos) {\n    uvec2 upos = uvec2(pos);\n\n    uvec3 rnd = uvec3(upos, upos.x ^ upos.y);\n    rnd = pcg(rnd);\n    rnd = pcg(rnd);\n    vec3 rndf = vec3(rnd) / float(0xffffffffu);\n    vec4 color = black;\n    //    color.xyz = rndf;\n    float s = .6;\n    //    float s = mix(.5, .7, color.y);\n    color.xyz = hsv2rgb_smooth_2315452051(vec3(rndf.x, s, 1.));\n    //        color.xyz = vec3(rndf.x);\n    color = linRgbColor(color);\n    //        return rnd.x>>31 == 0u ? black:white;\n    return color;\n}\n\nfloat calculateHexFalloff(float x) {\n    //        return  smoothstep(.3, .4, x);\n    return smoothstep(.520, .530, x);\n    //        return banded(5., smoothstep(a, a+.3, x));\n    //    return escalator(3., smoothstep(.4, .6, x), highResTimeStamp*.0001);\n}\n\nvec4 mix3(float s, float t, float u, vec4 a, vec4 b, vec4 c) {\n    return (a * s + b * t + c * u) / (s + t + u);\n}\n\nvec4 blend(vec4 source, vec4 dest) {\n    return source + dest * (1. - source.w);\n}\n\nvoid sortLayers2(out ivec2 a, out ivec2 b) {\n    if (a.x > b.x) {\n        ivec2 tmp = b; b = a; a = tmp;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 scaledCoord = fragCoord / min(iResolution.x, iResolution.y);\n    //    scaledCoord = mix(vec2(-1.), vec2(1.), scaledCoord);\n    scaledCoord *= 22.;\n    scaledCoord += iTime * normalize(vec2(100., 1.)) * 2.;\n\n    // UNIT GRID\n    vec2 unitGridDistances = scaledCoord - round(scaledCoord);\n    if (abs(unitGridDistances.x) < .01 || abs(unitGridDistances.y) < .01) {\n        fragColor = vec4(scaledCoord, 0., 1.);\n        //        return;\n    }\n\n    // TRIANGLE CENTER CIRCLES\n    vec3 tri = xy2tri(scaledCoord);\n    vec3 triTriangleCenter = triCenter(tri);\n    vec2 xyTriangleCenter = tri2xy(triTriangleCenter);\n    if (distance(xyTriangleCenter, scaledCoord) <.1) {\n        fragColor = black;\n        //                return;\n    }\n    vec3 triFract = fract(tri);\n    // TRIANGLE GRID\n    float w = .01;\n    if (abs(triFract.x-.5) > .5-w\n    || abs(triFract.y-.5) > .5-w\n    || abs(triFract.x + triFract.y - 1.) <w) {\n        fragColor = black;\n        //                        return;\n    }\n\n    // RENDER HEXAGONS\n    // As hexagons can potentially overlap each other, we cannot just calculate the nearest hexagon center and get the\n    // distance from that. Instead, we use the fact that each corner of a hex touches at most 3 triangles. Each corner\n    // of a hex matches the center of a triangle in a triangle grid (see above).\n    // For every triangle, we calculate the nearest three hex centers, and calculate the color of that hex and the\n    // distance to it.\n\n    // Depending on if we are in a up or down triangle, the offsets are differnt.\n    // Mobile browsers do NOT like vec2[3]:\n    // vec2[3] offsets = vec2[3](vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    mat3x2 offsets = mat3x2(vec2(1, 0), vec2(0, 1), mix(vec2(0), vec2(1), tri.z));\n    vec4[3] colors;\n    ivec2[3] order; // (z-index, i)\n    for (int i = 0; i < 3; i++) {\n        vec3 hexHexagonCenter = hexFix(floor(tri.xy) + offsets[i]);\n        vec2 xyHexagonCenter = hex2xy(hexHexagonCenter);\n        vec2 xyDiff = scaledCoord - xyHexagonCenter;\n        vec4 c = getColorAt(ivec2(hexHexagonCenter));\n        uvec2 upos = uvec2(ivec2(hexHexagonCenter));\n        uvec3 rnd = uvec3(upos, upos.x^upos.y);\n        vec3 rndf = pcgf(rnd);\n        // Calculate a smaller random int, so we can trigger random effects on specific values.\n        uint rndx = rnd.x >> 22;\n        //                uint rndx = rnd.x >> 28;\n        if (rndx == 7u) {\n            // angle wrong\n            xyDiff.xy *= rot2d(rndf.y);\n        }\n        if (rndx == 3u) {\n            // wrong position\n            xyDiff += .2*randomVector(rndf.yz);\n        }\n        if (rndx == 2u) {\n            // grayscale\n            c.xyz = c.xxx;\n        }\n        float d = hexSdf(xy2hex(xyDiff));\n\n        if (rndx == 4u) {\n            // wrong size\n            d += mix(-.15, .15, rndf.y);\n        }\n        if (rndx == 5u) {\n            // wrong shape: circle\n            d = length(xyDiff)*.9;\n        }\n        if (rndx == 6u) {\n            // wrong shape: square\n            d = max(abs(xyDiff.x), abs(xyDiff.y));\n        }\n        colors[i] = c*(calculateHexFalloff(1.-d));\n        order[i] = ivec2(hexHexagonCenter.x  + hexHexagonCenter.y*1000., i);\n    }\n\n    // Sort the hexagons into a consistent order, so there are no discontinuities at the triangle borders.\n    sortLayers2(order[0], order[1]);\n    sortLayers2(order[1], order[2]);\n    sortLayers2(order[0], order[1]);\n\n    // Blend colors together according to sorted order.\n    fragColor = black;\n    for (int i = 0; i < 3; i++) {\n        int j = order[i].y;\n        fragColor = blend(colors[j], fragColor);\n    }\n\n    // gamma correction\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0/2.2)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdy3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 85, 85, 155], [156, 156, 194, 194, 264], [265, 265, 303, 303, 373], [374, 374, 412, 412, 452], [454, 454, 503, 503, 546], [548, 548, 592, 592, 626], [627, 627, 669, 669, 703], [705, 705, 755, 755, 813], [815, 815, 856, 856, 911], [913, 913, 941, 941, 981], [983, 983, 1006, 1006, 1095], [1097, 1147, 1172, 1172, 1220], [1222, 1222, 1247, 1247, 1509], [1511, 1511, 1550, 1550, 1580], [1581, 1581, 1601, 1601, 1637], [1639, 1639, 1678, 1678, 1710], [1712, 1712, 1732, 1732, 1770], [1772, 1772, 1796, 1887, 1936], [1938, 1970, 2012, 2012, 2209], [2248, 2386, 2420, 2420, 2480], [2482, 2482, 2556, 2556, 2610], [2612, 2612, 2683, 2683, 2737], [2739, 2739, 2767, 2767, 2856], [2858, 2858, 2881, 2881, 2970], [2971, 2971, 2993, 2993, 3079], [3081, 3081, 3107, 3107, 3242], [3244, 3244, 3266, 3266, 3387], [3389, 3389, 3411, 3411, 3545], [3594, 3594, 3614, 3614, 3827], [3829, 3904, 3924, 3924, 4120], [4121, 4121, 4145, 4145, 4204], [4206, 4206, 4240, 4240, 4303], [4305, 4305, 4333, 4333, 4817], [4819, 4819, 4855, 4900, 5076], [5078, 5078, 5140, 5140, 5192], [5194, 5194, 5230, 5230, 5276], [5278, 5278, 5322, 5322, 5390], [5392, 5392, 5449, 5449, 9183]], "test": "untested"}
{"id": "fdyGDt", "name": "Animated Subdivision 3D", "author": "Tater", "description": "I might keep making these until I run out of ideas. ", "tags": ["3d", "raymarching", "cubes", "subdivision", "subdivide"], "likes": 19, "viewed": 301, "published": "Public API", "date": "1632383518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Building on ideas from \n//https://www.shadertoy.com/view/NsKGDy\n//https://www.shadertoy.com/view/7sKGRy\n//https://www.shadertoy.com/view/fsyGD3\n\n#define MDIST 350.0\n#define STEPS 200.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\n//global ray direction\nvec3 rdg = vec3(0);\n//block scale factor\nfloat gscl = 1.;\n\nvec2 blocks(vec3 p, vec3 scl, vec3 rd){\n    float t = iTime*(11./8.);\n      \n    vec3 dMin = vec3(-0.5) * scl;\n    vec3 dMax = vec3(0.5) * scl;\n    float id = 0.;\n    \n    \n    float MIN_SIZE = 0.3;\n    float ITERS = 6.;\n    float MIN_ITERS = 1.;\n    float PAD_FACTOR = 1.01;\n    float seed = floor(t/(ITERS+5.0))+0.1;\n    t = mod(t,ITERS+5.0);\n\n    //Offset and clamp the time at 0 so the cube stays uncut for a short time\n    t= clamp(t-1.0,0.0,ITERS);\n    \n    //calculate initial box dimensions\n    vec3 dim = dMax - dMin;\n    \n    //Big thanks for @0b5vr for cleaner version of subdiv algo\n    for (float i = 0.; i < ITERS; i++) {\n    \n        //If this is the final cut when animating then break\n        if(i>floor(t)) break;\n        \n        //divide the box into eight\n        vec3 divHash = vec3(\n            h21( vec2( i + id, seed )),\n            h21( vec2( i + id + 2.44, seed )),\n            h21( vec2( i + id + 7.83, seed ))\n        );\n        vec3 divide = divHash * dim + dMin;\n        \n        //Clamp Division Line\n        divide = clamp(divide, dMin + MIN_SIZE * PAD_FACTOR, dMax - MIN_SIZE * PAD_FACTOR);\n        \n        //Un-altered division line for coloring moving cells \n        vec3 divideFull = divide;\n        \n        //find smallest dimension of divison\n        vec3 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min(minAxis.x, min(minAxis.y, minAxis.z));\n        \n        //if the next cut will be below the minimum cut size then break out\n        if (minSize < MIN_SIZE && i + 1. > MIN_ITERS) {break ;}\n\n        //If the current iteration is the cutting one\n        //Smooth it between 0 and its final position\n        float tt = smoothstep(0.,1.,fract(t));\n        if(i == floor(t) &&mod(t,2.0)<1.0){\n            divide=mix(dMin,divide,tt);\n        }\n        else if(i == floor(t)){\n            divide=mix(dMax,divide,tt);\n        }\n\n        \n        // update the box domain\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n\n        // id will be used for coloring and hash seeding\n        vec3 diff = mix( -divideFull, divideFull, step( p, divide));\n        id = length(diff + 10.0);\n    \n        // recalculate the dimension\n        dim = dMax - dMin;\n    }\n    float volume = dim.x*dim.y*dim.z;\n    vec3 center = (dMin + dMax)/2.0;\n\n    //Calculate the distance to the outside of the current cell bounds\n    //to avoid overstepping\n    vec3 edgeAxis = mix( dMin, dMax, step( 0.0, rd ) );\n    vec3 dAxis = abs( p - edgeAxis ) / ( abs( rd ) + 1E-4 );\n    float dEdge = min(dAxis.x,min(dAxis.y,dAxis.z));\n    float b=dEdge;\n\n    vec3 d = abs(center);\n\n    //Scale the cubes down so they stay the same size when they \"explode\"\n    dim*=gscl;\n    float a = box(p-center,dim*0.5);\n    \n    //Take the minimum between the actual box and the intersection \n    //to the outside of the cell\n    a = min(a, b);\n    \n    //extra randomize the ID\n    id = h11(id)*1000.0;\n\n    return vec2(a,id);\n}\n//This is a smooth square wave approximation function but I really like\n//The curve it makes so I'm using it instead of a smoothstep to animate the\n//spin and \"explode\". It's a bit long because I made it start at 0 and repeat every 3. \nfloat swave(float x, float a){\n    return (sin(x*pi/3.-pi/2.)/sqrt(a*a+sin(x*pi/3.-pi/2.)*sin(x*pi/3.-pi/2.))+1./sqrt(a*a+1.))*0.5;\n}\nvec2 map(vec3 p){\n    float t = iTime*(11./8.);\n    //The cycle for the spinning and explosion doesn't exaclty line up\n    //with the cycle for the cutting because the spin needs to continue after the\n    //cuts have reset, so the cycle is offset fowards a bit\n    t = mod(t-1.0,11.0)+1.0;\n    \n    //timing out the spin+explode animation and making sure it happens\n    //once per cycle\n    float wav = swave(clamp(t*0.78-4.0,0.0,6.0),0.1);\n    \n    //Set the global scale variable that controls the exploding of boxes\n    gscl = 1.0-wav*0.5;\n    \n    //rotation amount\n    float rotd = wav*pi*4.02;\n    \n    //rotate the cube\n    p.xz*=rot(rotd);\n    \n    //move the cube up when it rotates so it fits nicely in the screen\n    p.y-=wav*3.0;\n    \n    //Scale space so the entire thing gets bigger (but the boxes are later re-sized,\n    //so it looks like they stay the same time)\n    p*=gscl;\n    \n    //Initalize output sdf, with vec2 for ID\n    vec2 a = vec2(1);\n    \n    //Size of the subdivision fractal\n    vec3 scl = vec3(10);\n    \n    //get the global ray direction and rotate it with the same rotation\n    //as the cube so that the outside cell intersection still works correctly\n    vec3 rd2 = rdg;\n    rd2.xz*=rot(rotd);\n    \n    a = blocks(p,scl,rd2)+0.01;\n    \n    //use a box to optimize areas outside of the fractal to minimize steps\n    //Also I found you can instead the step distance of the fractal when it explodes\n    //without causing artifacts which is free performance\n    a.x = max(box(p,vec3(scl*0.49)),a.x*(1.0+wav));\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.0001,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11.5,-20)*1.45;\n    if(iMouse.z>0.){\n    ro.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n    }\n    ro.xz*=rot(-pi/4.);\n    vec3 lk = vec3(0,0.,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(gscl*0.9+0.13)+uv.x*r+uv.y*cross(f,r));    \n    rdg = rd;\n    vec3 p = ro;\n    float dO = 0.;\n    vec2 d = vec2(0);\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.99;\n        if(d.x<0.0001){\n            hit = true;\n            break;\n        }\n        if(d.x>MDIST||i==STEPS-1.){\n            dO=MDIST;\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,0.9,-0.9));\n        vec3 n = norm(p);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.y)*0.8-0.15,e*1.3,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        float diff = length(sin(n*2.)*.5+.8)/sqrt(3.);\n        col = al*diff;\n        float shadow = 1.;\n        \n        //Mini hard shadow code\n        //Need to make sure global ray direction is updated\n        rdg = ld;\n        for(float h = 0.09; h<10.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }     \n        col*=shadow;\n    }\n    vec3 bg = vec3(0.741,0.498,0.498)*(1.0-length(uv)*0.5);\n    col = mix(col,bg,dO/MDIST);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 312, 379, 379, 418], [419, 419, 439, 439, 510], [511, 511, 532, 532, 584], [585, 585, 611, 611, 670], [715, 754, 793, 793, 3767], [3768, 4004, 4034, 4034, 4137], [4138, 4138, 4155, 4155, 5701], [5702, 5702, 5720, 5720, 5850], [5851, 5851, 5908, 5908, 7435]], "test": "untested"}
{"id": "fdyGz3", "name": "tiling that has neat gradients", "author": "pali6", "description": "It does recurson on Robinsion triangles. The code sucks.", "tags": ["tiling", "penrose"], "likes": 5, "viewed": 165, "published": "Public API", "date": "1631824819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DEPTH 15\n#define PHI ((1. + sqrt(5.)) / 2.)\n#define PI 3.141592653589\n//#define DEPTH int(round(16. - 7. * cos(iTime / 5.)))\n\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool onRight(vec2 a, vec2 b, vec2 x)\n{\n    return cross(vec3(a - b, 0), vec3(x - b, 0)).z > 0.;\n}\n\nfloat cr(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat cr(vec2 a, vec2 b, vec2 c)\n{\n    return cr(b - a, c - b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = fragCoord / iResolution.xx;\n    \n    float scale = 50. + 20. * sin(iTime / 10.) + 10. * sin(4. + iTime / 15.);\n    vec2 camPos = vec2(0.5, 0.5);\n    camPos += vec2(0.02 * sin(iTime / 15.), -0.07 * cos(iTime / 19.));\n    camPos += vec2(0.1 * sin(3. + iTime / 37.), -0.1 * cos(4. + iTime / 27.));\n    camPos += vec2(0.07 * sin(9. + iTime / 47.), -0.08 * cos(20. + iTime / 31.));\n    \n    pos -= vec2(0.5, 0.5);\n    pos /= scale;\n    pos += camPos;\n    \n    vec2 ota = vec2(-1., 0.);\n    vec2 otb = vec2(2., 0.);\n    \n    vec2 ta = ota;\n    vec2 tb = otb;\n    vec2 tc;\n    bool gn = true;\n    float fl = -1.;\n    \n    float f = 0.;\n    \n    // vec2 otc;\n    \n    for(int i = 0; i < DEPTH; i++)\n    {\n        vec2 next;\n        if(gn)\n        {\n            tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n            next = tb + (ta - tb) / PHI;\n            if(abs(cr(next, tc, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(next, tc, pos) * cr(next, tc, tb) > 0.)//onRight(next, tc, pos))\n            {\n                gn = false;\n                ta = next;\n                tb = tc;\n                fl *= -1.;\n                i--;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        else\n        {\n            tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n            next = tc + (tb - tc) / PHI;\n            if(abs(cr(ta, next, pos)) * float(i + 1) < 0.000001)\n                f = 1.;\n            if(cr(ta, next, pos) * cr(ta, next, tb) > 0.)//onRight(ta, next, pos))\n            {\n                gn = false;\n                ta = tb;\n                tb = next;\n            }\n            else\n            {\n                gn = true;\n                tb = ta;\n                ta = tc;\n            }\n        }\n        //if(i == 0)\n        //    otc = tc;\n    }\n\n    if(gn)\n        tc = ta + rotate(tb - ta, fl * PI / 5.) / PHI;\n    else\n        tc = ta + rotate(tb - ta, fl * 2. * PI / 5.) * PHI;\n\n    #define S(M, O) (0.5 + 0.5 * sin(O + M * pos.x)) / 4.\n    #define C(M, O) (0.5 + 0.5 * cos(O + M * pos.y)) / 4.\n    if(gn && min(length(pos - ta), length(pos - tb)) > length(ta - tb) / 3. || \\\n      !gn && length(pos - tb) <= length(tc - tb) * PHI / 3.5)\n    {\n        fragColor = vec4(\n            S(30., 0.) + C(10., 1.) + S(50., 6.) + S(99., 5.),\n            C(90., 0.) + S(70., 2.) + C(73., 8.) + C(67., 19.),\n            S(70., 0.5) + C(31., 7.) + S(55., 35.) + C(123., 5.),\n            1.\n        );\n    }\n    else\n        fragColor = vec4(\n            S(30., 10.) + C(10., 11.) + S(50., 16.) + S(99., 15.),\n            C(20., 10.) + S(70., 12.) + C(23., 18.) + C(67., 119.),\n            S(70., 10.5) + C(31., 17.) + S(55., 135.) + C(123., 15.),\n            1.\n        ) / 2.;\n        \n    \n    // if(f > 0.) fragColor = vec4(1, 0, 0, 1);\n    \n    /*\n    if(length(uv - ota) <= 0.01)\n        fragColor += vec4(0.5, -0.5, -0.5, 0.0);\n    if(length(uv - otb) <= 0.01)\n        fragColor += vec4(-0.5, 0.5, -0.5, 0.0);\n    if(length(uv - otc) <= 0.01)\n        fragColor += vec4(-0.5, -0.5, 0.5, 0.0);\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 135, 165, 165, 249], [251, 251, 289, 289, 348], [350, 350, 376, 376, 412], [414, 414, 448, 448, 479], [481, 481, 536, 536, 3738]], "test": "untested"}
{"id": "fdyGzK", "name": "Volume exp", "author": "green92", "description": "Volume", "tags": ["volume"], "likes": 2, "viewed": 41, "published": "Public", "date": "1631781998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Inter {\n    float t;\n    vec3 n;\n    vec3 c;\n};\n\nuint hash(uint x) {\n    x = x * 0xA789BCFDu;\n    x = (x ^ (x >> 16)) * 0xA789BCFDu;\n    return x;\n}\n\nfloat rand01(uint seed) {\n    return float(hash(seed) & 0x7FFFFFFFu) / float(0x7FFFFFFFu);\n}\n\nvec3 randvec3m11(uint seed) {\n    uint h = hash(seed);\n    return vec3(\n        float(h & 0xFFFFFFu),\n        float((h >> 1) & 0xFFFFFFu),\n        float((h >> 2) & 0xFFFFFFu)\n    ) / float(0xFFFFFFu) * 2.0 - 1.0;\n}\n\nfloat WorleyNoise(vec3 p, uint seed) {\n    ivec3 currentCell = ivec3(floor(p));\n    float minDistSq = 1e38;\n    for (int x=-1; x<=1; x++)\n    for (int y=-1; y<=1; y++)\n    for (int z=-1; z<=1; z++) {\n        ivec3 cell = currentCell + ivec3(x, y, z);\n        uint cellId = uint(cell.z * 0xF54B6267 + cell.y * 0xDE54 + cell.x) + seed;\n        vec3 offset = 0.5 + randvec3m11(cellId) * 0.5;\n        vec3 p2cp = vec3(cell) + offset - p;\n        float distSq = dot(p2cp, p2cp);\n        minDistSq = min(minDistSq, distSq);\n    }\n    return minDistSq;\n}\n\nRay CameraRay(vec2 pix, vec3 camPos, vec3 camTarget) {\n    vec2 pixm11 = 2.0 * pix / iResolution.xy - 1.0;\n    vec3 f = normalize(camTarget - camPos);\n    vec3 r = cross(f, vec3(0, 0, 1));\n    vec3 up = cross(r, f);\n    float ar = iResolution.y / iResolution.x;\n    return Ray(camPos, normalize(pixm11.x * r + pixm11.y * ar * up + f));\n}\n\nfloat SphereDist(vec3 center, float r, vec3 p) {\n    return length(p - center) - r;\n}\n\nfloat AABBDist(vec3 lower, vec3 upper, vec3 p) {\n    p -= (lower+upper) * 0.5;\n    vec3 b = upper - lower;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat OpSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SpheresUnion(vec3 p) {\n    vec3 s1c = vec3(0, sin(iTime / 2.0), cos(0.5*iTime));\n    vec3 s2c = vec3(0, cos(iTime / 10.0), sin(iTime));\n    vec3 s3c = vec3(sin(iTime), sin(iTime), 0.5);\n    float r = 1.0;\n    float d1 = SphereDist(s1c, 1.0, p);\n    float d2 = SphereDist(s2c, 1.0, p);\n    float d3 = SphereDist(s3c, 0.8, p);\n    float d4 = AABBDist(vec3(-0.25, -0.25, 0.25), vec3(0.25, 0.25, 0.75), p);\n    return OpSmoothUnion(OpSmoothUnion(OpSmoothUnion(d1, d2, 0.5), d3, 0.5), d4, 0.5)\n        + WorleyNoise(p * 10.0, 1u) * 0.05;\n}\n\n#define f(p) SpheresUnion(p)\n\n//https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 CalcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n\nInter RayMarch(Ray r) {\n    const int maxIter = 50;\n    vec3 p = r.o;\n    float t = 0.0;\n    float prevMinDist = 1e9;\n    for (int i=0; i<maxIter; i++) {\n        p = r.o + t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 1e-2) {\n            return Inter(t, CalcNormal(p), vec3(0, 1, 0));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            return Inter(1e9, vec3(0), vec3(0));\n        }\n        prevMinDist = minDist;\n        t += minDist;\n    }\n    return Inter(1e9, vec3(0), vec3(0));\n}\n\nvec4 RayMarchVolume(Ray r, Inter i, vec3 alb, float absCoef) {\n    const int maxIter = 30;\n    vec3 p = r.o + i.t * r.d;\n    float stepSize = 0.01;\n    float prevMinDist = 1e9;\n    vec3 col = vec3(0);\n    float transmittance = 1.0;\n    float prevTransmittance = 0.0;\n    for (int i=0; i<maxIter; i++) {\n        float t = float(i) * stepSize;\n        p += t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 0.0) {\n            prevTransmittance = transmittance;\n            transmittance *= exp(-absCoef * stepSize);\n            float currentTr = prevTransmittance - transmittance;\n            col += alb * currentTr * 3.0 * (10.0 / length(r.o - p));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            vec4(col, clamp(transmittance, 0.0, 1.0));\n        }\n    }\n    return vec4(col, clamp(transmittance, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(vec2(cos(iTime), sin(iTime)) * 5.0, 10);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 L = normalize(camTarget - camPos);\n    const vec3 E = vec3(0.9, 0.9, 0.9);\n    Ray r = CameraRay(fragCoord, camPos, camTarget);\n\n    Inter i = RayMarch(r);\n    vec3 col = vec3(0);\n    \n    if (i.t < 1e9) {\n        vec4 volumeCol = RayMarchVolume(r, i, vec3(1.0, 1.0, 1.0), 2.0);\n        col = volumeCol.rgb * volumeCol.a;\n        //col = dot(-L, i.n) * E * i.c;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //uint seed = uint(fragCoord.x + fragCoord.y * iResolution.x);\n    //fragColor = vec4(randvec3m11(seed), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 196], [198, 198, 223, 223, 290], [292, 292, 321, 321, 506], [508, 508, 546, 546, 1055], [1057, 1057, 1111, 1111, 1394], [1396, 1396, 1444, 1444, 1481], [1483, 1483, 1531, 1531, 1680], [1682, 1752, 1802, 1802, 1901], [1903, 1903, 1931, 1931, 2443], [2475, 2543, 2594, 2594, 2882], [2884, 2884, 2907, 2907, 3409], [3411, 3411, 3473, 3473, 4261], [4263, 4263, 4320, 4320, 4980]], "test": "untested"}
{"id": "fs33Wj", "name": "Fractal Milkshake", "author": "kekwizard", "description": "A variant of this:\n\nhttps://www.shadertoy.com/view/7sdGz2\n\nBut with a polynomial that changes over time. Not finished in any way, just playing around with the concept :)", "tags": ["fractal", "complex", "newton", "polynomial"], "likes": 0, "viewed": 59, "published": "Public API", "date": "1630617633", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raphael@gonku.de\n\n#define pi acos(-1.)\n#define angle(z) (atan(z.y/z.x) + pi * step(0.0, z.x))\n\n\n// -- some helper functions for complex numbers\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float v = (w.x * w.x + w.y * w.y);\n    vec2 r = vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y);\n    return r / v;\n}\n\n// Taken from \n// https://www.shadertoy.com/view/sdt3R2\n\nvec2 cmul(vec2 z, vec2 w) {\n    vec2 r = vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n    return r;\n}\n\nvec2 pol(vec2 z) {\n    float size = sign(z.x) * length(z);\n    float angle = angle(z);\n    return vec2(length(z), angle);\n}\n\nvec2 cart(vec2 pol) {\n    return pol.x * vec2(cos(pol.y), sin(pol.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    vec2 p1 = pol(z);\n    vec2 p = vec2(pow(p1.x, w.x) * exp(-w.y * p1.y), p1.y * w.x + log(p1.x) * w.y);\n    vec2 r = cart(p);\n    return r;\n}\n\nvec2 cpow(vec2 z, float w) {\n    return cpow(z, vec2(w, 0.0));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return cpow(z, float(w));\n}\n\n\n// --- main code\n\n\n#define NEWTON_ITER 20\n#define MOVE_ROOTS\n\n\n// P(z)\nvec2 func(vec2 z) {\n    return cpow(z, iTime / 4.0) + cpow(z, 2) - z + vec2(1.0, 0.0);\n}\n\n// P'(z)\nvec2 funcd(vec2 z) {\n    return cmul(vec2(iTime / 4.0, 0.0), cpow(z, 4)) + cmul(vec2(2.0, 0.0), z) - vec2(1.0, 0.0);\n}\n\nvec2 newton(vec2 z) {\n    vec2 t = func(z);\n    vec2 td = funcd(z);\n    return z - cdiv(t, td);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    float t = iTime / 8.;\n\n\n#ifdef MOVE_ROOTS\n    // actual complex roots of the function\n    // i added some terms to move the points over time\n    // mathematically speaking, this is nonsense\n    // it does look cool tho\n    vec2 roots[5] = vec2[5] (\n        vec2(-1.324, 0.0) + 0.5 * vec2(sin(iTime) * 0.65, cos(iTime * 0.8)), \n        vec2(0.0, -1.0) + 0.5 * vec2(cos(iTime * 0.55 + 11.5), sin(iTime * 0.618)),\n        vec2(0.0, 1.0) + 0.5 * vec2(cos(iTime + 15.5), sin(iTime * 0.18)), \n        vec2(0.6623, 0.5622), \n        vec2(0.6623, -0.5622)\n    );\n    \n#else\n     \n    \n    // actual roots of function\n    const vec2 roots[5] =  vec2[5](\n        vec2(-1.324, 0.0),\n        vec2(0.0, -1.0),\n        vec2(0.0, 1.0),\n        vec2(0.6623, 0.5622),\n        vec2(0.6623, -0.5622)\n    ); \n    \n\n#endif\n\n    \n    \n\n    const vec3 colors[5] = vec3[5] (\n        vec3(0.937, 0.278, 0.435), \n        vec3(1.00, 0.82, 0.40), \n        vec3(0.024, 0.83, 0.62), \n        vec3(0.06, 0.54, 0.69), \n        vec3(0.02, 0.23, 0.29)\n    );\n    \n    \n\n    // zoom + slight pan\n    vec2 r = (p / (t*t*t)) - vec2(0.5015, 0.0);\n\n\n    // newton\n    for(int i = 0; i < NEWTON_ITER; i++) {\n        r = newton(r);\n    }\n\n    // find closest root\n    float d = distance(r, roots[0]);\n    int ix = 0;\n    for(int i = 1; i < 5; i++) {\n        float nd = distance(r, roots[i]);\n        if(nd < d) {\n            d = nd;\n            ix = i;\n        }\n    }\n\n    fragColor = vec4(colors[ix], 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 148, 175, 175, 299], [301, 358, 385, 385, 466], [468, 468, 486, 486, 591], [593, 593, 614, 614, 665], [667, 667, 694, 694, 838], [840, 840, 868, 868, 904], [906, 906, 932, 932, 964], [1030, 1038, 1057, 1057, 1126], [1128, 1137, 1157, 1157, 1255], [1257, 1257, 1278, 1278, 1354], [1356, 1356, 1411, 1411, 2954]], "test": "untested"}
{"id": "fs3SRH", "name": "大龙猫 - WiReZ", "author": "totetmatt", "description": "Not so crappy, got some perf drop when close to wireframe but it's fine.", "tags": ["tunnel", "wireframe"], "likes": 5, "viewed": 158, "published": "Public API", "date": "1632560764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/**\n\n== Do not buy NFT made with my art. ==\n\n== Do not make NFT with my Creative-Commons artworks. ==\n\n== If you respect my art, remember and apply this. ==\n\n*/\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat elev(vec3 p){\n  float s = 0.;\n  vec4 pp= vec4(p*.5,1.1);\n  const float lim = 8.;\n  for(float i=0.;i<lim;i++){\n     pp.xzy = abs(pp.xzy)-vec3(1.125,1.5,1.2);\n        pp.xz*=rot(-.785+i);\n      pp *=1.3;\n  float m = min(pp.x,pp.z);\n      s += sqrt(clamp( \n       ( \n         tan(sin(m-pp.x*3.))\n         +tan(cos(m+pp.z*7.))\n    )/(pow(3.,i+1.))\n   \n    \n    ,-0.0,1.3))*.5;\n  }\n  return s/lim;\n}\nfloat diam2(vec2 p,float s){\n   p = abs(p);\n   return (p.x+p.y-s)*inversesqrt(3.);\n  }\nvec2 sdf(vec3 p){\n  p.xy *=rot(p.z*.3);\n  p.y = -(abs(p.y)-1.);\n  \n  vec2 h;\n  \n  vec3 hp= p;\n  h.x = dot(p,vec3(0.,1.,0.))+elev(hp)*2.0;;\n  //h.x = mix(h.x,+elev(hp+vec3(551.51,55.2,55.))*2.0,.5);\n  h.y= 1.;\n  \n  vec2 t ;\n  vec3 tp = p;\n  vec2 ltp = vec2(log(length(p.xy)),atan(p.y,p.x))*3.;\n  ltp.x +=iTime;\n\n  ltp = fract(ltp);\n  \n  \n  tp.y +=asin(sin(p.z));\n  tp.xy *= rot(tp.z*.1)*.7;\n  tp.xz /=2.;\n  tp.xz = fract(tp.xz)-.5;\n  \n  t.y =2.;\n  t.x = min(diam2(tp.zy,.05),diam2(tp.xy,.05));\n  \n  h = t.x < h.x ? t:h;\n \n  return h;\n  \n}\n\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n  vec3 pal(float t){return vec3(0.,.5,.0)+vec3(.0,.5,.1)*cos(6.28*(vec3(1.,1.0,10.)*t+vec3(.0,.3,.7)));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n\tvec3 col = vec3(.01);\n  vec3 ro = vec3(0.,0.2,-7.+iTime);\n\n  vec3 rt = vec3(0.+sin(iTime*.2)*3.,-1.0,ro.z+cos(iTime*.2)*10.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  rd.xy*=rot(iTime*.1);\n  vec3 rp =ro;\n  \n  vec3 light = ro+vec3(1.,2.,-1.);\n  float dd = 0.;\n  float side = 1.;\n  vec3 acc = vec3(0.);\n  float sat = 0.;\n  for(float i=0.;i<=128.;i++){\n    vec2 d = sdf(rp);\n    dd +=d.x;\n    d.x *=side;\n    if(dd>50.) break;\n    if(d.x < .001){\n      vec3 n = norm(rp,.005);\n      float diff = max(0.,dot(normalize(light-rp),n));\n        if(d.y == 1.){\n        \n          col = vec3(.02)*diff;\n          break;\n        } \n        if(d.y == 2.){\n            vec3 n2 = norm(rp,.001);\n          float l = length(n-n2);\n            float di = step(.1,l);\n            acc += vec3(di)*pal(+fract(rp.z*.1));\n            sat = min(1.,sat+sqrt(di));\n        \n          side *=-1.;\n              \n          rp +=rd*.05;\n         \n        \n          }\n      }\n    rp +=rd*d.x;\n    }\n col +=acc;\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 162, 180, 180, 227], [228, 228, 247, 247, 628], [629, 629, 657, 657, 715], [716, 716, 733, 733, 1253], [1281, 1281, 1308, 1308, 1384], [1387, 1387, 1405, 1405, 1489], [1491, 1491, 1548, 1598, 2806]], "test": "untested"}
{"id": "fs3Xz4", "name": "3d rasterizer", "author": "icantcomeupwithausername", "description": "3d rasterizer with depth sorting, lighting, and perspective projection", "tags": ["phong", "rasterizer"], "likes": 7, "viewed": 66, "published": "Public", "date": "1632710075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define clearColor vec3(0.407843137,0.690196078,0.847058824)\n#define vertexCount 36\n\n//projection variables\n#define pi acos(-1.0)\n#define fov 80.0\n\n//light direction\n#define lightDirection vec3(0.0,0.0,1.0)\n\n//-------//\n//structs//\n//-------//\n\nstruct Vertex{\n    vec3 position, normal;\n};\n\nstruct Material{\n    vec3 color;\n    float shininess;\n};\n\nstruct Varyings{\n    vec4 vt;\n    vec3 surfacePosition;\n};\n\n//----------------------//\n//verticies and material//\n//----------------------//\n\n//define material\nconst Material material = Material(vec3(0.4),800.0);\n\n//define verticies\nVertex verticies[vertexCount];\n\nvoid initVerticies(){\n\t//face 1\n\tverticies[0] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[1] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[2] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[3] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[4] = Vertex(vec3(-0.5,0.5,0.5),vec3(0.0,0.0,1.0)),\n\tverticies[5] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,0.0,1.0)),\n\n\t//face 2\n\tverticies[6] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[7] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[8] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[9] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[10] = Vertex(vec3(0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\tverticies[11] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,0.0,-1.0));\n\n\t//face 3\n\tverticies[12] = Vertex(vec3(0.5,-0.5,-0.5),vec3(1.0,0.0,0.0));\n\tverticies[13] = Vertex(vec3(0.5,0.5,-0.5),vec3(1.0,0.0,0.0));\n\tverticies[14] = Vertex(vec3(0.5,0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[15] = Vertex(vec3(0.5,0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[16] = Vertex(vec3(0.5,-0.5,0.5),vec3(1.0,0.0,0.0));\n\tverticies[17] = Vertex(vec3(0.5,-0.5,-0.5),vec3(1.0,0.0,0.0));\n\n\t//face 4\n\tverticies[18] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(-1.0,0.0,0.0));\n\tverticies[19] = Vertex(vec3(-0.5,-0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[20] = Vertex(vec3(-0.5,0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[21] = Vertex(vec3(-0.5,0.5,0.5),vec3(-1.0,0.0,0.0));\n\tverticies[22] = Vertex(vec3(-0.5,0.5,-0.5),vec3(-1.0,0.0,0.0));\n\tverticies[23] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(-1.0,0.0,0.0));\n\n\t//face 5\n\tverticies[24] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\tverticies[25] = Vertex(vec3(-0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[26] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[27] = Vertex(vec3(0.5,0.5,0.5),vec3(0.0,1.0,0.0));\n\tverticies[28] = Vertex(vec3(0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\tverticies[29] = Vertex(vec3(-0.5,0.5,-0.5),vec3(0.0,1.0,0.0));\n\n\t//face 6\n\tverticies[30] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n\tverticies[31] = Vertex(vec3(0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n\tverticies[32] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[33] = Vertex(vec3(0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[34] = Vertex(vec3(-0.5,-0.5,0.5),vec3(0.0,-1.0,0.0));\n\tverticies[35] = Vertex(vec3(-0.5,-0.5,-0.5),vec3(0.0,-1.0,0.0));\n}\n\n//--------------------//\n//projection functions//\n//--------------------//\n\n//used to project the verticies\nmat4 perspective(float aspect){\n    float ft = tan(pi*0.5-0.5*radians(fov));\n    float r = 1.0/(0.1-9e20);\n    \n    return mat4(ft/aspect,0.0,0.0,0.0,\n                0.0,ft,0.0,0.0,\n                0.0,0.0,(0.1+9e20)*r,-1.0,\n                0.0,0.0,0.1*9e20*r*2.0,0.0);\n}\n\n//used to translate the verticies \nmat4 translate(vec3 pos){\n    return mat4(1.0,0.0,0.0,pos.x,\n                0.0,1.0,0.0,pos.y,\n                0.0,0.0,1.0,pos.z,\n                0.0,0.0,0.0,1.0);\n}\n\n//rotation matricies\nmat4 rotateY(float rotation){\n\tfloat ysine = sin(rotation);\n\tfloat ycos = cos(rotation);\n\tfloat yoc = 1.0-ycos;\n\treturn mat4(ycos,0.0,ysine,0.0,\n\t\t\t\t0.0,yoc+ycos,0.0,0.0,\n\t\t\t\t-ysine,0.0,ycos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\nmat4 rotateX(float rotation){\n\tfloat xsine = sin(rotation);\n\tfloat xcos = cos(rotation);\n\tfloat xoc = 1.0-xcos;\n\treturn mat4(xoc+xcos,0.0,0.0,0.0,\n\t\t\t    0.0,xcos,-xsine,0.0,\n\t\t\t\t0.0,xsine,xcos,0.0,\n\t\t\t\t0.0,0.0,0.0,1.0);\n}\n\n//-------------//\n//interpolation//\n//-------------//\n\nvec3 interpolate(vec3 v1,vec3 v2,vec3 v3,vec3 a,vec3 b,vec3 c,vec2 uv){\n    float h = ((v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y));\n    float weight1 = ((v2.y-v3.y)*(uv.x-v3.x)+(v3.x-v2.x)*(uv.y-v3.y))/h;\n    float weight2 = ((v3.y-v1.y)*(uv.x-v3.x)+(v1.x-v3.x)*(uv.y-v3.y))/h;\n    float weight3 = 1.0-weight1-weight2;\n\n    return a*weight1+b*weight2+c*weight3/(weight1+weight2+weight3);\n}\n\n//---------//\n//edge test//\n//---------//\n\nfloat edge(vec2 a, vec3 b, vec2 c){\n    return (c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x);\n}\n\n/*\n *custom inverse and transpose functions so\n *this shader can run on mobile devices\n */\n\n//taken from https://chromium.googlesource.com/chromium/deps/mesa/+/f2ba7591b1407a7ee9209f842c50696914dc2ded/src/glsl/builtins/glsl/inverse.glsl \nmat4 inverse1(mat4 m){\n   float SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];\n   float SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];\n   float SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];\n   float SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];\n   float SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];\n   float SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];\n   float SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];\n   float SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n   float SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];\n   float SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];\n   float SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];\n   float SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];\n   float SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];\n   float SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];\n   float SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];\n   float SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];\n   float SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];\n   float SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];\n   float SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];\n   mat4 adj;\n   adj[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);\n   adj[1][0] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);\n   adj[2][0] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);\n   adj[3][0] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);\n   adj[0][1] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);\n   adj[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);\n   adj[2][1] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);\n   adj[3][1] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);\n   adj[0][2] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);\n   adj[1][2] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);\n   adj[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);\n   adj[3][2] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);\n   adj[0][3] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);\n   adj[1][3] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);\n   adj[2][3] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);\n   adj[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);\n   float det = (+ m[0][0] * adj[0][0]\n\t\t+ m[0][1] * adj[1][0]\n\t\t+ m[0][2] * adj[2][0]\n\t\t+ m[0][3] * adj[3][0]);\n   return adj / det;\n}\n\nmat4 transpose1(mat4 m){\n    vec4 a = m[0];\n    vec4 b = m[1];\n    vec4 c = m[2];\n    vec4 d = m[3];\n\n    return mat4(a.x,b.x,c.x,d.x,\n                a.y,b.y,c.y,d.y,\n                a.z,b.z,c.z,d.z,\n                a.w,b.w,c.w,d.w);\n}\n\n//-------//\n//shaders//\n//-------//\n\nVaryings vertexShader(Vertex vertex, mat4 projection, mat4 rotation){\n    //tranform vertex\n    vec4 vt = vec4(vertex.position,1.0)*projection;\n    \n    //calculate world position of surface\n    vec3 surfacePosition = (vec4(vertex.position,1.0)*rotation).xyz;\n    \n    return Varyings(vt,surfacePosition);\n}\n\nvec3 fragmentShader(vec3 normal, vec3 surfaceToCamera){\n    //normalize normal\n    normal = normalize(normal);\n    \n    //normalize surface to camera vector\n    surfaceToCamera = normalize(surfaceToCamera);\n    \n    //calculate half vector for specular calculation\n    vec3 halfv = normalize(lightDirection+surfaceToCamera);\n    \n    //calculate specular\n    float specular = clamp(pow(dot(normal, halfv),material.shininess),0.0,1.0);\n    \n    //calculate diffuse\n    float diffuse = clamp(dot(lightDirection,normal),0.0,1.0);\n    \n    return material.color*diffuse+specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    initVerticies();\n\n    //normalize pixel coordianates\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    \n    //camera position\n    vec3 cameraPos = vec3(0.0,0.0,7.0+sin(-iTime*0.5)*2.0);\n    \n    //output color\n    vec3 col = clearColor;\n    \n    //variable to store depth\n    float previousDepth = 9e20;\n    \n    //rasterization starts here\n    for(int i=0;i<vertexCount;i+=3){\n        Vertex vertexA = verticies[i];\n        Vertex vertexB = verticies[i+1];\n        Vertex vertexC = verticies[i+2];\n        \n        //assemble rotation matrix\n        mat4 rotationMatrix = rotateY(-iTime*0.5*0.5)*rotateX(-iTime*0.5);\n        \n        //assemble translation matrix\n        mat4 translationMatrix = translate(cameraPos);\n        \n        //assemble perspective matrix\n        mat4 perspectiveMatrix = perspective(iResolution.x/iResolution.y);\n        \n        //assemble projection matrix\n        mat4 projectionMatrix = rotationMatrix*inverse1(translationMatrix)*perspectiveMatrix;\n        \n        //transform verticies\n        Varyings ta = vertexShader(vertexA,projectionMatrix,rotationMatrix);\n        Varyings tb = vertexShader(vertexB,projectionMatrix,rotationMatrix);\n        Varyings tc = vertexShader(vertexC,projectionMatrix,rotationMatrix);\n        \n        //divide transformed verticies by w\n        vec3 va = (ta.vt/ta.vt.w).xyz;\n        vec3 vb = (tb.vt/tb.vt.w).xyz;\n        vec3 vc = (tc.vt/tc.vt.w).xyz;\n        \n        //test if pixel is in triangle\n        float tsa = edge(vb.xy,vc,uv);\n        float tsb = edge(vc.xy,va,uv);\n        float tsc = edge(va.xy,vb,uv);\n        \n        if(((tsa>=0.0)==(tsb>=0.0))&&((tsb>=0.0)==(tsc>=0.0))){\n            //calculate area\n            float area = edge(va.xy,vb,vc.xy);\n            \n            //divide by area\n            tsa/=area;\n            tsb/=area;\n            tsc/=area;\n            \n            //calculate pixel depth\n            float depth = va.z*tsa+vb.z*tsb+vc.z*tsc;\n            \n            //if depth is smaller than the stored depth then triangle is visible\n            if(depth<previousDepth){\n                //transform normal\n                vec3 normal = vertexA.normal*mat3(inverse1(transpose1(rotationMatrix)));\n                \n                //interpolate surface position\n                vec3 surfacePosition = interpolate(va,vb,vc,ta.surfacePosition,tb.surfacePosition,tc.surfacePosition,uv);\n                \n                //calculate surface to camera direction\n                vec3 surfaceToCamera = cameraPos-surfacePosition;\n                \n                //shade pixel\n                col = fragmentShader(normal, surfaceToCamera);\n                \n                //store the depth\n                previousDepth = depth;\n            }    \n        }        \n    }\n\n    //output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3Xz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[563, 614, 635, 645, 2996], [3074, 3106, 3137, 3137, 3378], [3380, 3415, 3440, 3440, 3581], [3583, 3604, 3633, 3633, 3823], [3825, 3825, 3854, 3854, 4047], [4049, 4104, 4175, 4175, 4498], [4500, 4543, 4578, 4578, 4632], [4726, 4872, 4894, 4894, 7660], [7662, 7662, 7686, 7686, 7898], [7900, 7937, 8006, 8028, 8244], [8246, 8246, 8301, 8324, 8823], [8825, 8825, 8879, 8879, 11714]], "test": "untested"}
{"id": "fscGW7", "name": "Haunted Quarry", "author": "104", "description": "ilikeloops", "tags": ["rocks"], "likes": 26, "viewed": 165, "published": "Public", "date": "1630759147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SceneDurationSeconds = 5.;\nconst float Complexity = 14.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/iResolution.x+100.;\n    uv.y *= .7; // nicer when vertical\n    float sd = 1.;\n    vec4 c = vec4(1);\n\n    float scene = floor((iTime+100.)/SceneDurationSeconds);\n    vec4 hscene = hash42(uv-uv+scene);\n    uv.x += scene;\n    float t = .03*iTime;\n\n    for (float i = 1.;i<Complexity;++i) {\n        vec2 cell = floor(uv);\n        vec4 h = hash42(cell+i);\n        vec4 h2 = hash42(h.xy);\n        vec2 p = cell + .5 + (h.xy-.5);\n        vec2 d = min(fract(uv), 1.-fract(uv));\n        uv *= 1.+(h.zw*2.);\n        uv += t*i*(h2.zw-.5)*vec2(1,.1)*2.;\n        uv *= rot2D((h.z-.5)*.1);\n        vec2 rotated = h.xy * rot2D(t*5.*h.w);\n        h.xy = rotated;\n        h = clamp(h,0.,1.);\n        sd *= pow(min(d.x,d.y), mix(.14, .22, h2.z));\n        c = mix(c,h,min(1.,sd+.15))/min(.78,i*.15);\n        c += h2.x*h2.y;\n    }\n\n    o = 1.-(c / Complexity);\n    o.rgb = mix(o.rgb,vec3(o.r+o.g+o.b)/3.,hscene.z);\n    o *= 1.2;\n    o = clamp(o,0.,1.);\n    vec2 uvn = C/iResolution.xy-.5;\n    o *= 1.-dot(uvn,uvn*1.6);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 91, 91, 239], [241, 241, 261, 261, 313], [315, 315, 351, 351, 1368]], "test": "untested"}
{"id": "fscXR8", "name": "Fractal 83_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 137, "published": "Public", "date": "1632551401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s;\n    for(;++i<99.;)\n    {\n        p=g*d;\n        p.z-=.2;\n        p=R(p,normalize(vec3(1,2,3)),iTime*.3);\n        s=3.;\n        for(int j=0;j++<8;)\n        {\n            p=abs(p),p=p.x<p.y?p.zxy:p.zyx;\n            s*=e=2./min(dot(p,p),1.2);\n            p=p*e-vec3(12,3,3);\n        }\n        g+=e=length(p.xz)/s+1e-4;\n        // color matrix test\n        mat3 m = mat3(\n            .9,.5,.2,\n            .4,.4,.4,\n            .3,.7,.9\n            );\n        O.rgb+=m*(H(log(s)*.8)+.5)*.008*exp(-.4/i/i/e);  \n    }\n    O=pow(O,vec4(12));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 788]], "test": "untested"}
{"id": "fsdGWf", "name": "thunderstorm", "author": "miloszmaki", "description": "thunderstorm in the mountains at night", "tags": ["clouds", "sky", "thunderstorm", "night", "mountains", "lightning"], "likes": 10, "viewed": 230, "published": "Public API", "date": "1630792324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x)\n{\n    return fract(sin(x)*75154.32912);\n}\n\nfloat rand3d(vec3 x)\n{\n    return fract(375.10297 * sin(dot(x, vec3(103.0139,227.0595,31.05914))));\n}\n\nfloat noise(float x)\n{\n    float i = floor(x);\n    float a = rand(i), b = rand(i+1.);\n    float f = x - i;\n    return mix(a,b,f);\n}\n\nfloat perlin(float x)\n{\n    float r=0.,s=1.,w=1.;\n    for (int i=0; i<6; i++) {\n        s *= 2.0;\n        w *= 0.5;\n        r += w * noise(s*x);\n    }\n    return r;\n}\n\nfloat noise3d(vec3 x)\n{\n    vec3 i = floor(x);\n    float i000 = rand3d(i+vec3(0.,0.,0.)), i001 = rand3d(i+vec3(0.,0.,1.));\n    float i010 = rand3d(i+vec3(0.,1.,0.)), i011 = rand3d(i+vec3(0.,1.,1.));\n    float i100 = rand3d(i+vec3(1.,0.,0.)), i101 = rand3d(i+vec3(1.,0.,1.));\n    float i110 = rand3d(i+vec3(1.,1.,0.)), i111 = rand3d(i+vec3(1.,1.,1.));\n    vec3 f = x - i;\n    return mix(mix(mix(i000,i001,f.z), mix(i010,i011,f.z), f.y),\n               mix(mix(i100,i101,f.z), mix(i110,i111,f.z), f.y), f.x);\n}\n\nfloat perlin3d(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise3d(s * x);\n    }\n    return r;\n}\n\nfloat f(float y)\n{\n    float w = 0.4; // width of strike\n    return w * (perlin(2. * y) - 0.5);\n}\n\nfloat plot(vec2 p, float d, bool thicker)\n{\n    if (thicker) d += 5. * abs(f(p.y + 0.001) - f(p.y));\n    return smoothstep(d, 0., abs(f(p.y) - p.x));\n}\n\nfloat cloud(vec2 uv, float speed, float scale, float cover)\n{\n    float c = perlin3d(vec3(uv * scale, iTime * speed * 2.));\n    return max(0., c - (1. - cover));\n}\n\nfloat mountain(vec2 uv, float scale, float offset, float h1, float h2)\n{\n    float h = h1 + perlin(scale*uv.x + offset) * (h2 - h1);\n    return smoothstep(h, h+0.01, uv.y);\n}\n\nvec3 render(vec2 uv)\n{\n    float x = iTime + 0.1;\n\n    float m = 0.25; // max duration of strike\n    float i = floor(x/m);\n    float f = x/m - i;\n    float k = 0.4; // frequency of strikes\n    float n = noise(i);\n    float t = ceil(n-k); // occurrence\n    float d = max(0., n-k) / (1.-k); // duration\n    float o = ceil(t - f - (1. - d)); // occurrence with duration\n    float gt = 0.1; // glare duration\n    float go = ceil(t - f - (1. - gt)); // glare occurrence\n    \n    float lightning = 0.;\n    float light = 0.;\n    float glare = 0.;\n    \n    if (o == 1.) {\n        vec2 uv2 = uv;\n        uv2.y += i * 2.; // select type of lightning\n        float p = (noise(i+10.) - 0.5) * 2.; // position of lightning\n        uv2.x -= p;\n        \n        float strike = plot(uv2, 0.01, true);\n        float glow = plot(uv2, 0.04, false);\n        float glow2 = plot(uv2, 1.5, false);\n\n        lightning = strike * 0.4 + glow * 0.15;\n\n        float h = noise(i+5.); // height\n        lightning *= smoothstep(h, h+0.05, uv.y + perlin(1.2*uv.x + 4.*h)*0.03);\n        lightning += glow2 * 0.3;\n        light = smoothstep(5., 0., abs(uv.x - p));\n        glare = go * light;\n    }\n    \n    vec3 clouds =\n        vec3(0.5,0.7,1.) * mix(0.6, 0.9, cloud(uv, 0.2, 0.1, 1.0)) +\n        vec3(0.7,0.8,1.) * 0.6 * cloud(uv*vec2(0.5,1.), 0.06, 0.8, 0.8) +\n        vec3(0.9,0.9,1.) * 0.3 * cloud(uv*vec2(0.1,1.), 0.08, 5.5, 0.6) +\n        vec3(1.,1.,1.) * 0.4 * cloud(uv*vec2(0.1,1.), 0.07, 10., 0.5);\n    \n    float horizon = mountain(uv, 0.8, 9., 0.3, 0.6);\n    vec3 terrain = mix(vec3(0.25,0.3,0.3)*0.5, 1.5*vec3(0.15,0.2,0.3),\n        1. - (1. - mountain(uv, 0.8, 3., 0.2, 0.4)) * 0.5 - \n        (1. - mountain(uv, 0.8, 17.5, 0.05, 0.25)) * 0.5);\n    \n    vec3 background = mix(terrain, clouds, horizon);\n    background *= (0.2 + light * 0.5);\n    \n    return vec3(background + lightning + glare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 2. * uv.x - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tfragColor = vec4(render(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 61], [63, 63, 85, 85, 164], [166, 166, 188, 188, 297], [299, 299, 322, 322, 465], [467, 467, 490, 490, 975], [977, 977, 1001, 1001, 1169], [1171, 1171, 1189, 1189, 1268], [1270, 1270, 1313, 1313, 1421], [1423, 1423, 1484, 1484, 1586], [1588, 1588, 1660, 1660, 1762], [1764, 1764, 1786, 1786, 3642], [3644, 3644, 3701, 3701, 3855]], "test": "untested"}
{"id": "fsdSRH", "name": "Northern Elves", "author": "TEttinger", "description": "It's a significant variation on my \"Onward to Thule\" shader, with more emphasis on strangely-shifting extremely-bright colors.", "tags": ["noise", "plasma", "lights", "northern", "elves"], "likes": 3, "viewed": 193, "published": "Public API", "date": "1632638397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 licensed, do what thou wilt.\n\n// change the seed to any not-too-huge float and the colors/shapes will change.\nconst float SEED = 420.69; // starts off nicely.\nconst vec3 COEFFS = fract((SEED + 23.4567) * vec3(0.8191725133961645, 0.6710436067037893, 0.5497004779019703)) + 0.5;\n\n// what's different here is mostly how swayRandomized() incorporates the x, y, and z of seed and value for each component.\nvec3 swayRandomized(vec3 seed, vec3 value)\n{\n    return sin(seed.xyz + value.zxy - cos(seed.zxy + value.yzx) + cos(seed.yzx + value.xyz));\n}\n\n// this function, if given steadily-increasing values in con, may return exponentially-rapidly-changing results.\n// even though it should always return a vec3 with components between -1 and 1, we use it carefully.\nvec3 cosmic(vec3 c, vec3 con)\n{\n    return (con\n    + swayRandomized(c, con)) * 0.5;\n//    + swayRandomized(c + 1.1, con.xyz)\n//    + swayRandomized(c + 2.2, con.xyz)) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//    vec2 uv = (fragCoord + cos(iTime * 0.3) * 64.0) * (2.125 + sin(iTime * 0.25));\n    vec2 uv = (fragCoord * 0.25) + swayRandomized(COEFFS.zxy, (iTime * 0.1875) * COEFFS.yzx - fragCoord.yxy * 0.01).xy * 42.0;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.0625;\n    vec3 adj = vec3(-1.11, 1.41, 1.61);\n    vec3 s = (swayRandomized(vec3(34.0, 76.0, 59.0), aTime + adj)) * 0.25;\n    vec3 c = (swayRandomized(vec3(27.0, 67.0, 45.0), aTime - adj.yzx)) * 0.25;\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    \n    con = cosmic(COEFFS, con);\n    con = cosmic(COEFFS + 1.618, con);\n    \n    fragColor = vec4(swayRandomized(COEFFS + 3.0, con * 4.0) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 408, 452, 452, 548], [550, 764, 795, 795, 941], [943, 943, 1000, 1085, 1743]], "test": "untested"}
{"id": "fsG3Rd", "name": "shaderbook8", "author": "danielgandolfi", "description": "exercise in https://thebookofshaders.com/08/: copy https://www.shadertoy.com/view/4s2SRt", "tags": ["shaderbook"], "likes": 0, "viewed": 32, "published": "Public", "date": "1631913167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define blue vec3(0.3,0.3,0.8)\n#define lightblue vec3(0.8,0.8,1.0)\n#define white vec3(1.0,1.0,1.0)\n\nmat2 createScaleMat(float scaleFac) {\nreturn mat2(scaleFac,0.0,0.0,scaleFac);\n}\n\nvec3 drawCrossAxes(\n    const vec2 uv,\n    const vec2 center,\n    const vec3 color,\n    const float maxAxisLength\n) {\n    vec2 uvCentered = uv - center;\n    vec2 viewQuartered = abs(uvCentered);\n    float areEqual = step(distance(viewQuartered.x, viewQuartered.y), 0.0015);\n    float isBeyondMaxLength = step(length(viewQuartered), maxAxisLength);\n    \n    return areEqual * \n        isBeyondMaxLength * \n        \n        color;\n}\n\nmat2 createRotationMatrix(float angle) {\n    return  mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 squarifyUv(\n    const vec2 uv,\n    const vec2 iRes\n) {\n    vec2 uvCentered = uv - vec2(0.5);\n    return vec2(\n        uvCentered.x*iRes.x/iRes.y,\n        uvCentered.y\n    ) + vec2(0.5);\n}\n\nvec3 drawRotatingLine(\n    vec2 uv,\n    vec3 color,\n    float lineLength\n) {\n    uv -= 0.5;\n    float fromCenter = dot(uv,uv);\n    if (fromCenter < lineLength) {\n        float isPixelOnLine = step(0.994,1.0-distance(uv.y,uv.x));\n        float isXGreaterThan0 = min(sign(uv.x),0.0);\n        float isYGreaterThan0 = min(sign(uv.y),0.0);\n        return isPixelOnLine * \n            isXGreaterThan0 * \n            isYGreaterThan0 * \n            color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 drawLineTrail(\n    vec2 uv,\n    vec3 color,\n    float lineLength\n){\n    uv -= 0.5;\n    float fromCenter = dot(uv,uv);\n    if (fromCenter < lineLength) {\n        float angle = atan(uv.y,uv.x);\n        float distanceFromDesiredAngle = distance(angle,-3.0*PI/4.0);\n        float isAngleAfterLine = step(-3.0*PI/4.0, angle);\n        float angleMul = max(\n            0.0,\n            (1.0 - distanceFromDesiredAngle) * isAngleAfterLine\n        );\n        return angleMul * color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 drawCircleLine(\n    const vec2 uv,\n    const vec2 center,\n    const vec3 color,\n    const float radius\n) {\n    \n    float distanceFromCircleCenter = distance(\n        center,\n        uv\n    );\n    float tolerance = 0.0031* distanceFromCircleCenter ;\n    return vec3(\n        step(radius-tolerance, distanceFromCircleCenter *distanceFromCircleCenter)* \n        step(distanceFromCircleCenter *distanceFromCircleCenter, radius+tolerance)\n    ) * color;\n}\n\nvec3 drawArc(\n    vec2 uv,\n    vec2 center,\n    float arcRadianStart,\n    float arcRadianEnd,\n    float distanceFromCenter,\n    vec3 color\n) {\n    uv -= center;\n    float angle = atan(uv.y,uv.x);\n    float fromCenter = length(uv);\n    float tolerance = 0.005;\n    float distanceFromCenterLimiter = step(\n        fromCenter,\n        distanceFromCenter+tolerance\n    );\n    \n    return\n        step(arcRadianStart, angle) *\n        step(angle, arcRadianEnd) * \n        smoothstep(\n            distanceFromCenter-tolerance,\n            distanceFromCenter+tolerance,\n            fromCenter\n        ) * distanceFromCenterLimiter *\n        color;\n}\n\nvec3 drawExternalArcs(\n    vec2 uv,\n    vec2 center,\n    float distanceFromCenter\n) {\n    float spaceBetween = 0.01*PI;\n    vec2 uvAbs = abs(uv - center) + center;\n    float startRadians = spaceBetween;\n    float endRadians = QUARTER_PI - spaceBetween;\n    \n    vec3 lowerArcs = drawArc(\n     uvAbs,\n     center,\n     startRadians,\n     endRadians,\n     distanceFromCenter,\n     blue\n    );\n    \n    vec3 higherArcs = drawArc(\n     uvAbs,\n     center,\n     QUARTER_PI + spaceBetween,\n     HALF_PI - spaceBetween,\n     distanceFromCenter,\n     vec3(0.7,0.7,0.8)\n    );\n    return lowerArcs + higherArcs;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 crossAxisColor = vec3(0.2,0.2,0.2);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = squarifyUv(fragCoord/iResolution.xy, iResolution.xy);\n    \n\n    // Output to screen\n    float rotationAngle = mod(iTime, 2.0*PI);\n    mat2 lineRotationMat = createRotationMatrix(rotationAngle);\n    fragColor = vec4(\n        drawCrossAxes(uv,vec2(0.5), crossAxisColor,0.4) +\n        drawCircleLine(uv, vec2(0.5), white, 0.15) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.075) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.025) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.00015) +\n        drawRotatingLine(\n           ((uv -0.5)* lineRotationMat)+0.5,\n            lightblue,\n            0.15\n        )+\n        drawLineTrail(\n            ((uv -0.5)* lineRotationMat)+0.5,\n            lightblue,\n            0.15\n        )+ \n        drawArc(\n            uv,\n            vec2(0.5),\n            -3.0*PI/4.0 + - (abs(sin(iTime/2.0))* PI/8.0),\n            -PI/4.0 + (abs(sin(iTime/2.0))* PI/8.0),\n            0.45,\n            blue\n        )+ \n        drawArc(\n            uv,\n            vec2(0.5),\n            PI/4.0 - (abs(sin(iTime/2.0))* PI/8.0),\n            3.0*PI/4.0 + (abs(sin(iTime/2.0))* PI/8.0),\n            0.45,\n            blue\n            \n        ) + drawExternalArcs(uv,vec2(0.5), 0.48)\n    ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3Rd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 211, 211, 253], [255, 255, 372, 372, 685], [687, 687, 727, 727, 796], [798, 798, 857, 857, 990], [992, 992, 1068, 1068, 1486], [1488, 1488, 1560, 1560, 2015], [2017, 2017, 2128, 2128, 2473], [2475, 2475, 2617, 2617, 3117], [3119, 3119, 3204, 3204, 3723], [3724, 3724, 3781, 3781, 5115]], "test": "untested"}
{"id": "fsG3zR", "name": "Slowtember 04-06: Shop", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 26, "viewed": 215, "published": "Public API", "date": "1630939829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.1415927\n#define E .002\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat estep(float threshold, float x, float e) {\n    return smoothstep(threshold + e, threshold - e, x);\n}\n\nfloat h(vec2 uv, float y0, float height, float e) {\n    return estep(y0 - height * .5, uv.y, -e) * estep(y0 + height * .5, uv.y, e);\n}\n\nfloat v(vec2 uv, float x0, float width, float e) {\n    return estep(x0 - width * .5, uv.x, -e) * estep(x0 + width * .5, uv.x, e);\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat rand(float seed) {\n    if (seed < .0)\n        seed *= -1.;\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec2 rot(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * 2. * PI) * uv.x - sin(angle * 2. * PI) * uv.y,\n        sin(angle * 2. * PI) * uv.x + cos(angle * 2. * PI) * uv.y\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circle(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return estep(min(size.x, size.y) * .5, length(uv), e * 2.);\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return \n        estep(size.x * .5, uv.x, e) *\n        estep(-size.x * .5, uv.x, -e) *\n        estep(size.y * .5, uv.y, e) *\n        estep(-size.y * .5, uv.y, -e);\n}\n\nfloat tri(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        estep(-size.x * .5, uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(-size.x * .5, - uv.x - uv.y * size.x * .5 / size.y, -e * 2.) *\n        estep(.0, uv.y, -e);\n}\n\nfloat ell(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    float t;\n    float c;\n    vec2 p;\n    if (size.x >= size.y) {\n        t = size.x;\n        c = pow(pow(size.x * .5, 2.) - pow(size.y * .5, 2.), .5);\n        p = vec2(c, .0);\n    } else {\n        t = size.y;\n        c = pow(pow(size.y * .5, 2.) - pow(size.x * .5, 2.), .5);\n        p = vec2(.0, c);\n    }\n    return estep(t, length(uv - p) + length(uv + p), e * 4.);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat circleh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    return n(\n        circle(uv, vec2(.0), size, .0, .0, e) - \n        circle(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\nfloat recth(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rect(uv, vec2(.0), size, .0, .0, e) - \n        rect(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n// WIP\nfloat trih(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        tri(uv, vec2(.0), size, .0, .0, e) - \n        tri(uv, vec2(.0, -r * .2), size - vec2(r * pow(2., .5)), .0, .0, e)\n    );\n}\n\nfloat ellh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        ell(uv, vec2(.0), size, .0, .0, e) - \n        ell(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / (2. * PI);\n    return n(\n        circle(uv, p1, vec2(size), .0, .0, e) +\n        circle(uv, p2, vec2(size), .0, .0, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), .0, -angle, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectr(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, vec2(r), .0, .0, e) +\n        circle(uv, - v1, vec2(r), .0, .0, e) +\n        circle(uv, + v2, vec2(r), .0, .0, e) +\n        circle(uv, - v2, vec2(r), .0, .0, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, .0, e)\n    );\n}\n\nfloat rectr2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, .0, E)\n    );\n}\n\nfloat trir(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    vec2 v3 = (v1 + v2) * .5;\n    return n(\n        line(uv, -v1, v3, r, e) +\n        line(uv, -v1, -v2, r, e) +\n        line(uv, v3, -v2, r, e) +\n        tri(uv, vec2(.0), size - vec2(r), .0, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rectrh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        rectr(uv, vec2(.0), size, r, .0, e) -\n        rectr(uv, vec2(.0), size - vec2(r), r, .0, e)\n    );\n}\n\n// WIP\nfloat trirh(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return n(\n        trir(uv, vec2(.0), size, r, .0, e) -\n        trir(uv, vec2(.0, -r * .2), size - vec2(r), r, .0, e)\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n#define BG_PLANK_W .6\n#define BG_PLANK_H .15\n#define PLANK_LIGHT vec3(.48, .36, .23)\n#define PLANK_DARK vec3(.28, .20, .14)\n\n#define CORK vec3(.66, .44, .23)\n\nfloat plank_text(vec2 uv, vec2 size, float plank_seed, float range) {\n    if (rand(plank_seed++) > .5)\n        uv.x = (size.x - uv.x);\n        return h(\n                uv + vec2(.0, sin(uv.x * (15. + 15. * rand(plank_seed++))) * .002),\n                size.y * (.05 + .9 * rand(plank_seed++)),\n                cos(uv.x * (10. + range * (rand(plank_seed++) - .5))) * .01\n                , E);\n}\n\nfloat plank_dark(vec2 uv, vec2 size, float plank_seed) {\n    float m = .0;\n    \n    m += plank_text(uv, size, plank_seed++, 3.);\n    m += plank_text(uv, size, plank_seed++, 3.);\n    \n    m += v(uv, -.005, .02, E);\n    m += h(uv, -.005, .02, E);\n    m += v(uv, size.x + .005, .02, E);\n    m += h(uv, size.y + .005, .02, E);\n    \n    return n(m);\n}\n\nvec3 plank(vec3 c, vec2 uv, vec2 center, vec2 size, float plank_seed, float color_shift) {\n    uv += size * .5 - center;\n    \n    vec3 c0 = PLANK_LIGHT - rand(plank_seed++) * .02 + color_shift;\n    vec3 c1 = PLANK_DARK;\n    \n    float pmask = rect(uv, size * .5, size, .0, .0, E);\n    float pmask2 = rect(uv, size * .5, size - .005, .0, .0, E);\n    \n    c = mask(c, c0, pmask2);\n    \n    for(int i = 0; i < 50; i++)\n        c = mask(c, c1, pmask2 * rand(plank_seed++) * .2 * plank_text(uv, size, plank_seed++, 20.));\n    \n    plank_seed++;\n    \n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(.005), size, plank_seed));\n    c = mask(c, c0 * 1.3, pmask2 * .5 * plank_dark(uv + vec2(-.005), size, plank_seed));\n    c = mask(c, c1, pmask * plank_dark(uv, size, plank_seed));\n\n    return c;\n}\n\nvec3 background(vec2 uv0) {\n    vec2 size = vec2(BG_PLANK_W, BG_PLANK_H);\n\n    uv0.x += mod(uv0.y, 2. * size.y) < size.y ? size.x * .5 : .0;\n    vec2 uv = vec2(mod(uv0.x, size.x), mod(uv0.y, size.y));\n    \n    float plank_seed = floor(uv0.x / size.x) * 938. + floor(uv0.y / size.y) * 324. + 100.;\n\n    return plank(PLANK_DARK, uv, size * .5, size, plank_seed, .0);\n}\n\nfloat writing(vec2 uv, vec2 center, vec2 size, float ampl, float angle, float seed, float e) {\n    uv -= center;\n    uv = rot(uv, angle);\n    return  h(\n        vec2(uv.x, uv.y + sin((uv.x + rand(seed++)) * 123.) * sin((uv.x + rand(seed++)) * 256.) * sin((uv.x + rand(seed++)) * 89.) * sin((uv.x + rand(seed++)) * 111.) * ampl), \n        .0, size.y * .25, E) * rect(uv, vec2((rand(seed++) - .5) * size.x * .1, (rand(seed++) - .5) * size.y * .5), vec2(size.x * .9 - rand(seed++) * size.x * .6, size.y), .0, .0, e);\n}\n\nvec3 shelf(vec3 c, vec2 uv, float seed) {\n    float shadow = n(\n        rect(uv, vec2(.03, -.18), vec2(.35, .1), .0, .0, E) +\n        tri(uv, vec2(.175, -.115), vec2(.06, .03), .0, .0, E) +\n        tri(uv, vec2(-.16, -.20), vec2(.06, .03), .0, .75, E)\n    );\n\n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    float label_x = (rand(seed++) - .5) * .2;\n    \n    float shadow2 = n (\n        rect(uv + vec2(-.02, .02), vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv + vec2(-.02, .02), vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow2);\n    \n    c = mask(c, vec3(.9, .9, .85), n(\n        rect(uv, vec2(label_x, -.08), vec2(.10, .05) ,.0, .0, E) +\n        tri(uv, vec2(label_x - .05, -.08), vec2(.02, .045) ,.0, .0, E)\n    ));\n    c = mask(c, vec3(.9, .9, .85) * .9, tri(uv, vec2(label_x + .05, -.08), vec2(.02, .045) ,.0, .0, E));\n\n    float price = 1. + floor(rand(seed++) * 4.);\n    \n    float x;\n    \n    for(float i = 0.; i < price; i++) {\n        x = label_x - .015 - (i - price * .5) * .021 + (uv.y + .08) * .10;\n        c = mask(c, vec3(.2), v(uv, x + sin(uv.y * 600.) * .008, .005, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .02) ,.0, .0, E));\n        c = mask(c, vec3(.2), v(uv, x, .003, E) * rect(uv, vec2(label_x, -.08), vec2(.10, .025) ,.0, .0, E));\n    }\n\n    c = plank(c, uv, vec2(.0, -.15), vec2(.35, .1), seed, -.04);\n    \n    return c;\n}\n\nvec3 potion(vec3 c, vec2 uv, float seed) {\n\n    float bg, outside, shadow, liquid_mask;\n    \n    float form = rand(seed++);\n    \n    vec2 label_pos = vec2((rand(seed++) - .5) * .02, -.01 + (rand(seed++) - .5) * .02);\n    \n    if(form < .333) {\n        bg = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        outside = n(\n            ellh(uv, vec2(.0, -.01), vec2(.2, .18), .03, .0, E) +\n            ellh(uv, vec2(.01, -.03), vec2(.2, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = ell(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n        \n        liquid_mask = ell(uv, vec2(.0, -.01), vec2(.2, .18), .0, .0, E);\n    } else if(form < .66) {\n        bg = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        outside = n(\n            recth(uv, vec2(.0, -.01), vec2(.15, .18), .03, .0, E) +\n            recth(uv, vec2(.02, -.03), vec2(.15, .18), .03, .0, E) *\n            rect(uv, vec2(-.05, .04), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = rect(uv + vec2(-.03, .03), vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n        \n        liquid_mask = rect(uv, vec2(.0, -.01), vec2(.15, .18), .0, .0, E);\n    } else {\n        bg = n (\n            tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E) -\n            rect(uv, vec2(.0, .15), vec2(.1, .1), .0, .0, E)\n        );\n        outside = n(\n            trih(uv, vec2(.0, .01), vec2(.23, .23), .04, .0, E) +\n            trih(uv, vec2(.01, -.02), vec2(.23, .23), .03, .0, E) *\n            rect(uv, vec2(-.03, .0), vec2(.03, .08), .0, .0, E * 5.) * .7\n        );\n        \n        shadow = tri(uv + vec2(-.03, .03), vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        liquid_mask = tri(uv, vec2(.0, .01), vec2(.23, .23), .0, .0, E);\n        \n        label_pos += vec2(.0, -.03);\n    }       \n\n    bg = n(bg + rect(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E));\n\n    outside = n(\n        outside +\n        recth(uv, vec2(.0, .10), vec2(.06, .07), .03, .0, E) -\n        rect(uv, vec2(.0, .10), vec2(.03, .08), .0, .0, E) * 2.\n    );\n    \n    float cork = n (\n        tri(uv, vec2(.0, .105), vec2(.05, .1), .0, .5, E) -\n        rect(uv, vec2(.0, .08), vec2(.033, .06), .0, .0, E)\n    );\n    \n    shadow = n (\n        shadow +\n        rect(uv + vec2(-.03, .03), vec2(.0, .10), vec2(.06, .07), .03, .0, E) +\n        tri(uv + vec2(-.03, .03), vec2(.0, .105), vec2(.05, .1), .0, .5, E)\n    );\n    \n    float liquid_h = .1 + rand(seed++) * .2;\n    \n    float liquid = n (\n        liquid_mask * h(uv, -.1 + liquid_h * .5 * .5, liquid_h * .5, E)\n        - outside\n    );\n    \n    c = mask(c, vec3(.0), .3 * shadow);\n    \n    c = mask(c, mask(col(rand(seed++)), col(rand(seed++ + 20.)), (uv.y + .18 - liquid_h * .5) * 13.), liquid);\n    c = mask(c, CORK + .05 * rand(seed++), cork);\n    c = mask(c, vec3(1.), .3 * bg);\n    c = mask(c, vec3(1.), .7 * outside);\n    \n    float label_angle = (rand(seed++) - .5) * .05;\n    float label_width = .07 + rand(seed++) * .04;\n    \n    c = mask(c, vec3(.9, .9, .8 + rand(seed++) * .1), rect(uv, label_pos, vec2(label_width, .04), .0, label_angle, E));\n    \n    c = mask(c, vec3(.2 + (rand(seed++) - .5) * .1), writing(uv, label_pos, vec2(label_width, .04), .01, label_angle, seed++, E));\n    \n    c = shelf(c, uv, seed++);\n    \n    return c;\n}\n\nvec3 image(vec2 uv0, float t) {\n    vec3 c = vec3(.0);\n    \n    vec2 uv = uv0 - vec2(t * .1);\n    \n    c = background(uv);\n\n    float seed = floor(uv.x * 2.) * 493. + floor(uv.y * 2.) * 482.;\n    \n    c = potion(c, mod(uv, .5) - .25, seed);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    if (size < .00001)\n        return image(uv, t0);\n\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 c = colorShiftImage(uv, iTime, iTime * 5., .0);\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsG3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 200, 218, 218, 252], [254, 254, 302, 302, 360], [362, 362, 413, 413, 496], [498, 498, 548, 548, 629], [631, 631, 648, 648, 692], [694, 694, 732, 732, 774], [776, 776, 800, 800, 925], [927, 927, 946, 946, 1115], [1117, 1117, 1149, 1149, 1308], [1310, 1473, 1551, 1551, 1635], [1637, 1637, 1713, 1713, 1925], [1927, 1927, 2002, 2002, 2271], [2273, 2273, 2348, 2348, 2762], [2764, 2927, 3006, 3006, 3152], [3154, 3154, 3231, 3231, 3398], [3400, 3407, 3483, 3483, 3671], [3673, 3673, 3749, 3749, 3914], [3916, 4079, 4139, 4139, 4410], [4412, 4575, 4652, 4652, 5122], [5124, 5124, 5202, 5202, 5393], [5395, 5395, 5471, 5471, 5814], [5816, 5979, 6057, 6057, 6223], [6225, 6232, 6309, 6309, 6482], [6484, 6806, 6875, 6875, 7200], [7202, 7202, 7258, 7258, 7548], [7550, 7550, 7640, 7640, 8351], [8353, 8353, 8380, 8380, 8719], [8721, 8721, 8815, 8815, 9236], [9238, 9238, 9279, 9279, 10664], [10666, 10666, 10708, 10708, 14033], [14035, 14035, 14066, 14066, 14296], [14298, 14298, 14361, 14361, 14676], [14678, 14678, 14733, 14733, 14927]], "test": "untested"}
{"id": "fsGGDG", "name": "tunnel and distortion", "author": "heycharlieabbott", "description": "https://www.instagram.com/heycharlieabbott/", "tags": ["tunnel", "monochrome", "perspective"], "likes": 0, "viewed": 131, "published": "Public API", "date": "1632026328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3( 0.,0.,0.);\n    \n    float time = iTime;\n    \n    uv *= rotate2d( sin(uv.y * uv.x * 2.9) *sin(time/5.)/4. );\n   \n   \n    uv *= abs(cos(uv/1.8) +0.2);\n    \n    vec2 pos = vec2(0.5 + cos(time)/1.3,0.5 + sin(time)/8.) - uv;\n    float r = length(pos) * 80.;\n    float a = atan(cos(pos.x),sin(pos.y+ time/2.));\n    \n    a = abs(a*30.);\n    \n    r/= 30. * abs(sin(time)/3. + 1.);\n    float pattern = smoothstep(sin(pos.y*15. + time),sin(time/9.),cos(a/r + time * 20.)) * (pow(r,7.));\n    \n    col = vec3(pattern);\n    \n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 114], [119, 119, 176, 176, 790]], "test": "untested"}
{"id": "fsGGRy", "name": "Zone plate", "author": "mosan_hoshi", "description": "Circular zone plate", "tags": ["2d", "resolution", "viewerwarning"], "likes": 2, "viewed": 146, "published": "Public API", "date": "1631712206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// written by mossan-hoshi( https://twitter.com/mossan_hoshi )\n\n#define K 1000.\n#define THRESHOLD\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const \n  // normalize position(x,y:.0~1.0)\n  vec2 uv= ((fragCoord.xy - .5 * iResolution.xy)/ min(iResolution.x,iResolution.y));\n  \n  // circular zone plate\n  float value = (1. + cos(K * mod(iTime, 20.) * dot(uv,uv)))* .5;\n  if(iMouse.z > 0.){ \n    // binalize on mouse down\n    value = step(.5,value);\n  }\n  fragColor=vec4(value,value,value,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 156, 204, 509]], "test": "untested"}
{"id": "fsGGWG", "name": "Magic Loader", "author": "Krischan", "description": "Modified, customizable Loader Animation for my game. Original by munrocket https://www.shadertoy.com/view/td3czf - three particles look better than just one :-D", "tags": ["glow", "particle", "loader"], "likes": 20, "viewed": 331, "published": "Public API", "date": "1632015907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ================================================================================================\n//\n// MAGIC LOADER ANIMATION\n// original: https://www.shadertoy.com/view/td3czf\n// modified by Krischan\n//\n// ================================================================================================\n\nfloat SCALE = 0.5;\nfloat SPEED = 0.25;\nfloat INTENSITY = 20.0;\nfloat LENGTH = 0.5;\nfloat RADIUS = 0.020;\nfloat FADING = 0.125;\nfloat GLOW = 2.0;\n\n#define M_2_PI 6.28318530\n\n// optimized 2d version of https://www.shadertoy.com/view/ldj3Wh\nvec2 sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n    vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n    return vec2(length(d+(c+b*t)*t),t);\n}\n\nvec2 circle(float t){\n    float x = SCALE * sin(t);\n    float y = SCALE * cos(t);\n    return vec2(x, y);\n}\n\nvec2 leminiscate(float t){\n    float x = (SCALE * (cos(t) / (1.0 + sin(t) * sin(t))));\n    float y = (SCALE * (sin(t) * cos(t) / (1.0 + sin(t) * sin(t))));\n    return vec2(x, y);\n}\n\n// inspired by https://www.shadertoy.com/view/wdy3DD\nfloat mapinfinite(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = leminiscate(t * M_2_PI);\n    vec2 p2 = leminiscate((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = leminiscate((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nfloat mapcircle(vec2 pos,float sp){\n    float t = fract(-SPEED * iTime*sp);\n    float dl = LENGTH / INTENSITY;\n    vec2 p1 = circle(t * M_2_PI);\n    vec2 p2 = circle((dl + t) * M_2_PI);\n    vec2 c = (p1 + p2) / 2.0;\n    float d = 1e9;\n    \n    for(float i = 2.0; i < INTENSITY; i++){\n        p1 = p2;\n        p2 = circle((i * dl + t) * M_2_PI);\n        vec2 c_prev = c;\n        c = (p1 + p2) / 2.;\n        vec2 f = sdBezier(pos, c_prev, p1, c);\n        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    float dist1 = mapcircle(uv.yx*vec2(1.0,0.66),1.0);\n\tfloat dist2 = mapinfinite(uv.xy*vec2(0.66,1.0),2.0);\n\tfloat dist3 = mapcircle(uv.xy*vec2(1.0,0.88),4.0);\n    \n    vec3 col1 = vec3(1.0, 0.55, 0.25) * pow(RADIUS/dist1, GLOW);\n\tvec3 col2 = vec3(0.55, 1.00, 0.25) * pow(RADIUS/dist2, GLOW);\n\tvec3 col3 = vec3(0.25, 0.55, 1.00) * pow(RADIUS/dist3, GLOW);\n\t\n\tvec3 col=(col1+col2+col3)*(2.*GLOW);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[481, 546, 595, 595, 1170], [1172, 1172, 1193, 1193, 1278], [1280, 1280, 1306, 1306, 1460], [1462, 1515, 1552, 1552, 2056], [2058, 2058, 2093, 2093, 2582], [2584, 2584, 2640, 2640, 3143]], "test": "untested"}
{"id": "fsGGWW", "name": "Colorful Chaos", "author": "fihade", "description": "Colorful Chaos.", "tags": ["2dcolor"], "likes": 0, "viewed": 108, "published": "Public API", "date": "1631522755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define V vec3\n#define m(p) (length(mod(p,4.)-2.)-2.)\n\n\nvoid mainImage(out vec4 O, vec2 I){\n   \n    V a = iResolution, b=iMouse.xyz,\n    c = 10.*(b/a-.5)*sign(b),\n    d = V(a.y/.5,I+I-a.xy),\n    p = d-d; p.x=iTime;\n    d.xy *= mat2(sin(vec4(0,100,55,0)+c.x)); \n    d /= length(d);\n   \n    c = p;\n    float e = I.x/a.x*4.,\n    L = float(16),\n    z = L;\n    \n    for( int i = 1; i < 20; i++ ){\n        a = sign(d);\n        b = fract(-c*z*a);\n        b += step(b,-b);\n        a *= b/d;\n        b = min(a.xxx,min(a.y,a.z));\n        c += d*b/z;\n        z *= m(ceil(c*z+d*step(a,b))/z-.5/z)*z<.8?2.:1.;\n    }\n\n    O.rgb = (mod(ceil(c*z/2.),3.)+.1)/V(9.+dot(p-c,p-c))*(m(c)*z);\n    O *= 1.2-.8 * pow(abs(mod(e+e,2.)-1.),3.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 91, 91, 719]], "test": "untested"}
{"id": "fsGGWy", "name": "Pulsar Neutron Star", "author": "DLC", "description": "Simple Pulsar star using smoothstep func for rays", "tags": ["pulsar"], "likes": 4, "viewed": 113, "published": "Public API", "date": "1632033500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D rotation matrix\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n//star\n    col.b += 0.15 * sin(14.0*iTime);\n    col.b += mix(0.05, 1.0, 0.06 / length(uv));\n//rotate uv\n    uv = rotate(uv, 3.0*iTime);\n//rays\n    float m = smoothstep(0.25 * smoothstep(-0.5, 0.5, (abs(uv.y) - 0.4)), 0.0, abs(uv.x));\n    col.b += m * abs(sin(5.0*iTime));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 52, 52, 148], [151, 151, 206, 206, 609]], "test": "untested"}
{"id": "fsK3Rt", "name": "Eroded sandstone hills", "author": "jarble", "description": "A simple hill terrain with realistic-looking erosion.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "mountain", "desert", "erosion", "hill"], "likes": 10, "viewed": 194, "published": "Public API", "date": "1631961937", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 2./3.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.-amplitude;\n        amplitude *= 1./3.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3Rt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1468], [1471, 1471, 1502, 1502, 1764], [1766, 1830, 1875, 1875, 2161], [2163, 2163, 2201, 2201, 2456], [2458, 2458, 2525, 2525, 2752], [2754, 2754, 2785, 2785, 4202], [4204, 4204, 4261, 4261, 4895]], "test": "untested"}
{"id": "fsK3WG", "name": "PBR Green dude", "author": "NataliaP", "description": "CookTorrance lightening", "tags": ["pbrsdf"], "likes": 3, "viewed": 53, "published": "Public", "date": "1632089746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define asp iResolution.x/iResolution.y\nconst vec3  eye      = vec3 ( 0, 0, 3);\nconst vec3  light    = vec3  ( 1.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat dBox ( vec3 p, vec3 b )\n{\n\treturn length8 ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat smax ( float a, float b, float k )\n{\n\tfloat res = exp ( k*a ) + exp ( k*b );\n\treturn log ( res ) / k;\n}\n\nfloat dCone ( vec3 p, vec2 c, float h)\n{\n    float q = length ( p.xy );\n    return smax(dot ( c, vec2 ( q, p.z ) ), -h - p.z, 20.0);\n}\n\nfloat dGreenDude (in vec3 q) \n{\n    q -= vec3(0, 0, 0.35);\n    return min(min(min(dBox ( q, vec3 ( 0.5, 0.5, 0.7 )), \n      dBox ( q + vec3( 0.0, 0.0, 0.8), vec3 ( 0.4, 0.4, 0.4 ))),\n      dBox ( q + vec3( - 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 ))),\n      dBox ( q + vec3( + 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 )));\n}\n\nfloat dHat (vec3 p)\n{\n    p += vec3( 0, 0, 1.35 );\n    return dCone(-p, vec2(0.06, 0.15), 0.7);\n}\n\nfloat circle(vec2 uv,float radius,float blur){\n\tfloat d = length(uv);\n    return smoothstep(radius,radius-blur,d);\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p*rotateX(0.5 * abs(cos(iTime)))*rotateX(1.7);\n   \n   return min(dGreenDude(q), dHat(q));\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n// eye sensitivity in the rgb range\nconst vec3 lum = vec3(0.2126, 0.7152, 0.0722);\n\n// returns brightness\nfloat height(in vec2 tx)\n{\n    return dot(texture(iChannel0, tx).rgb, lum);\n}\n\nvec3 bump (in vec2 tx) \n{\n    float v = height (tx);\n    float vx = height(vec2(tx.x + 0.01, tx.y));\n    float vy = height(vec2(tx.x, tx.y + 0.01));\n    \n    return normalize(vec3(vx - v, vy - v, 0.99));\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nconst float roughness = 0.27;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.0, 0.9, 0.8 );\nconst float gamma = 10.0;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.4 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n//////////////////////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n        vec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n        \n        //n = bump( p.xy );\n        \n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v );\n\n\t}\n    \n    // Background\n    vec2 uv1 = fragCoord/iResolution.xy;\n    uv1-=vec2(0.5,1.1);\n    uv1.x*=asp;\n    vec2 st = uv1;\n    float d = length(uv1);\n    float radius = 0.5;\n    float blur = 0.49;\n    float c = smoothstep(radius+sin(iTime)*.1,radius-blur+sin(iTime)*.05,d);\n    float dd = smoothstep(radius-0.3,radius-0.3-0.04,d);\n   \n\tfloat n = c-dd;\n    fragColor +=clamp(n,0.,1.)*1.2*vec4(0.2,0.5,0.9,1.);\n    fragColor += dd*vec4(0.2,0.5,(1.-dd),1.);\n    fragColor+=dd;\n    fragColor +=vec4( st.y)*vec4(0.2,0.5,0.9,1.)*0.6*(1.-fragColor.b);\n\n    // Output to screen\n    color *= 1.5*textureLod(iChannel0, p.xy, 0.0);\n    \n    fragColor = max(color, fragColor);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 223, 250, 250, 397], [399, 437, 464, 464, 611], [613, 613, 642, 642, 710], [712, 712, 741, 741, 828], [830, 830, 861, 861, 911], [913, 913, 950, 950, 984], [986, 986, 1028, 1028, 1098], [1100, 1100, 1142, 1142, 1209], [1211, 1211, 1251, 1251, 1345], [1347, 1347, 1378, 1378, 1667], [1669, 1669, 1690, 1690, 1766], [1768, 1768, 1814, 1814, 1884], [1886, 1886, 1922, 1922, 2030], [2032, 2032, 2099, 2099, 2414], [2416, 2416, 2468, 2468, 2837], [2923, 2945, 2971, 2971, 3022], [3024, 3024, 3049, 3049, 3229], [3522, 3550, 3597, 3597, 3711], [3713, 3713, 3762, 3762, 3902], [3904, 3904, 3959, 3959, 4115], [4117, 4117, 4167, 4167, 4314], [4316, 4316, 4382, 4382, 4524], [4526, 4526, 4572, 4572, 4608], [4610, 4610, 4668, 4668, 4700], [4702, 4702, 4774, 4774, 4833], [4835, 4835, 4901, 4901, 5591], [5592, 5681, 5738, 5788, 7308]], "test": "untested"}
{"id": "fsK3z3", "name": "Path Arc SDF", "author": "TheTurk", "description": "Distance function for an arc that can be used as a building block to create complex shapes. For straight line semgents see: [url]https://www.shadertoy.com/view/NsK3z3[/url].", "tags": ["distancefield", "sdf", "distance", "path", "arc", "roundedcorners"], "likes": 0, "viewed": 64, "published": "Public", "date": "1631882723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nconstructs an arc given 3 points of two intersecting lines that will be tangent to the arc. \nAssigns the arc end point to currentPoint so that it can be used to continue the contour.\nclockwise order = 1\ncounter-clockwise order = -1\n*/\n\nfloat arc(vec2 position, inout vec2 currentPoint, vec2 tangent1End, vec2 tangent2End, float radius, float windingOrder) {\n    position = position - tangent1End;\n    vec2 a = currentPoint - tangent1End;\n    vec2 b = tangent2End - tangent1End;\n    float length1 = length(a);\n    float length2 = length(b);\n    a /= length1;\n    b /= length2;\n    vec2 center = (a + b) * radius / (windingOrder * (a.x * b.y - a.y * b.x));\n    float s1 = dot(position - center, a);\n    float s2 = dot(position - center, b);\n    vec2 d1 = position - a * clamp(dot(position, a), 0.0, length1);\n    length2 = dot(center, b);\n    vec2 d2 = position - b * clamp(dot(position, b), 0.0, length2);\n    if (s1 < 0.0 && s2 < 0.0) {\n        currentPoint = tangent1End + b * length2;\n        return length(position - center) - radius;\n    }\n    float s3 = windingOrder * (a.y * position.x - a.x * position.y);\n    float s4 = windingOrder * (b.x * position.y - b.y * position.x); \n    float s = (s3 < 0.0 && s4 < 0.0) ? -1.0 : 1.0;\n    currentPoint = tangent1End + b * length2;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\n/*\nconstructs an arc given 3 points of two intersecting lines that will be tangent to the arc. \nAssigns the arc end point to currentPoint so that it can be used to continue the contour.\nassumes a clockwise winding order.\n*/\n\nfloat arc(vec2 position, inout vec2 currentPoint, vec2 tangent1End, vec2 tangent2End, float radius) {\n    position = position - tangent1End;\n    vec2 a = currentPoint - tangent1End;\n    vec2 b = tangent2End - tangent1End;\n    float length1 = length(a);\n    float length2 = length(b);\n    a /= length1;\n    b /= length2;\n    vec2 center = (a + b) * radius / (a.x * b.y - a.y * b.x);\n    float s1 = dot(position - center, a);\n    float s2 = dot(position - center, b);\n    vec2 d1 = position - a * clamp(dot(position, a), 0.0, length1);\n    length2 = dot(center, b);\n    vec2 d2 = position - b * clamp(dot(position, b), 0.0, length2);\n    if (s1 < 0.0 && s2 < 0.0) {\n        currentPoint = tangent1End + b * length2;\n        return length(position - center) - radius;\n    }\n    float s3 = a.y * position.x - a.x * position.y;\n    float s4 = b.x * position.y - b.y * position.x; \n    float s = (s3 < 0.0 && s4 < 0.0) ? -1.0 : 1.0;\n    currentPoint = tangent1End + b * length2;\n    return sqrt(min(dot(d1, d1), dot(d2, d2))) * s;\n}\n\n/* \nconstructs a straight line segment given two points.\nassumes a clockwise winding order.\n*/\n\nfloat line(vec2 position, inout vec2 currentPoint, vec2 end) {\n    position = position - currentPoint;\n    end = end - currentPoint;\n    float height = clamp(dot(position, end) / dot(end, end), 0.0, 1.0);\n    float d = length(position - end * height);\n    float s = sign(end.x * position.y - end.y * position.x); \n    currentPoint = end + currentPoint;\n    return d * s;\n}\n\n// example\nfloat trapezoid(vec2 position, float halfWidth1, float halfWidth2, float halfHeight, float cornerRadius) {\n    position.x = abs(position.x);\n    vec2 currentPoint = vec2(0.0, halfHeight);\n    float d1 = arc(position, currentPoint, vec2(halfWidth2, halfHeight), vec2(halfWidth1, -halfHeight), cornerRadius);\n    float d2 = line(position, currentPoint, vec2(halfWidth1, -halfHeight));\n    float d3 = line(position, currentPoint, vec2(0.0, -halfHeight));\n    return min(min(abs(d1), abs(d2)), abs(d3)) * sign(max(max(d1, d2), d3));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n   \n    vec2 currentPoint = vec2(0.0, -0.5);\n    vec2 tangentEnd1 = vec2(0.0, 0.5);\n    float angle = (sin(iTime + 1.0) + 1.0) * 0.5 * 3.14159;\n    vec2 tangentEnd2 = tangentEnd1 + 2.0 * vec2(cos(angle), sin(angle));\n    tangentEnd2 = tangentEnd1 + vec2(cos(angle), sin(angle));\n    float radius = 0.5;\n    float windingOrder = sign(tangentEnd2.x);\n    float d = arc(position, currentPoint, tangentEnd1, tangentEnd2, radius, windingOrder);\n    d *= windingOrder;\n\n    // d = trapezoid(position, 0.65, 0.35, 0.5, 0.25); // example \n    \n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n    if (iMouse.z > 0.001) {\n        vec2 mousePosition = iMouse.xy / iResolution.xy;\n        mousePosition = (mousePosition * 2.0) - 1.0;\n        mousePosition.x *= iResolution.x / iResolution.y;\n        vec2 currentPoint = vec2(0.0, -0.5);\n        float d = arc(mousePosition, currentPoint, tangentEnd1, tangentEnd2, radius, windingOrder);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.0025, abs(length(position - mousePosition) - abs(d)) - 0.0025));\n    }\n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3z3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 239, 360, 360, 1336], [1338, 1563, 1664, 1664, 2589], [2591, 2687, 2749, 2749, 3059], [3061, 3072, 3178, 3178, 3602], [3604, 3604, 3659, 3659, 5158]], "test": "untested"}
{"id": "fsK3zR", "name": "Yay the sdf works", "author": "Bloodwyn", "description": "I must give a description\n\nMy First Shader...", "tags": ["sdf"], "likes": 1, "viewed": 41, "published": "Public", "date": "1630967280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k ){\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(0);\n    \n    float v = 1./3.;\n    vec2 AAoffsets[4] = vec2[](\n        vec2(v,v),\n        vec2(v,-v),\n        vec2(-v,v),\n        vec2(-v,-v)\n     );\n    \n    \n    for(int i = 0; i < AAoffsets.length(); i++){\n        vec2 uv =  (2. * (fragCoord + AAoffsets[i]) - iResolution.xy) / iResolution.xy;\n\n\n        uv.y /= iResolution.x / iResolution.y;\n\n        vec2 P = vec2(0,0);\n        vec2 R = vec2(0.2,0.1);\n        \n        float t = fract(iTime);\n        t = t * t * t * (t * (t * 6. - 15.) + 10.);\n        \n        uv.x += \n            float(int(iTime) & 1) * (t*2.5f - 1.25) +\n            float(int(iTime)+1 & 1) * ((1.-t)*2.5f - 1.25);\n            \n        uv.y += sin(iTime*10.)/3.5;\n\n        float d = length(max(abs(uv)-R, 0.));\n\n        total += vec3(fract(d*15.));\n    }\n    \n    total /= float(AAoffsets.length());\n    \n    fragColor = vec4(total, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 112], [114, 114, 171, 171, 1060]], "test": "untested"}
{"id": "fsK3zW", "name": "zig zag spinner", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 3, "viewed": 40, "published": "Public", "date": "1631242158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307\n#define sint(x) (sin((x) * TAU))\n\nfloat stairs(float x, float max_) {\n    return min(1.0, fract(x) / max_);\n}\n\nfloat stripes(float x, float thres) {\n    return step(fract(x), thres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 5.);\n    \n    // normalizes coords so that center is (0,0) and diagonals are length 1\n    vec2 uv = (fragCoord / length(iResolution.xy)\n\t- (iResolution.xy / length(iResolution.xy) / 2.)) * 2.;\n    float dist = 0.8 * log(uv.x * uv.x + uv.y * uv.y);\n    float angle = atan(uv.y, uv.x) / TAU;\n    \n    float dist_ = stairs(t + 2. * sint(t) + dist, 0.6) - dist;\n    float spiral = stripes(2. * t + 1.3 * dist_ + angle * 3., 0.4 + 0.3 * sint(t + 0.25));\n    float circle = stripes(3. * t + 0.3 * (dist + sint(dist)), 0.4);\n    \n    vec3 col_base = vec3(79, 71, 137) / 255.;\n    vec3 col_stripe = vec3(32, 19, 53) / 255.;\n    vec3 col_bolt = vec3(252, 231, 98) / 255.;\n\n    vec3 col = mix(\n        mix(\n            col_base,\n            col_stripe,\n            circle\n        ),\n        col_bolt,\n        spiral\n    );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsK3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 93, 93, 133], [135, 135, 172, 172, 208], [210, 210, 267, 267, 1165]], "test": "untested"}
{"id": "fsKGDV", "name": "jiahao：【故障3-1】错位线条故障", "author": "LokaHer", "description": " ", "tags": [], "likes": 0, "viewed": 11, "published": "Public", "date": "1632223942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _LinesWidth (0.8) //越小越宽\n#define _Amount (0.3) //控制线条数量，1就无了\n#define _Offset (0.9) //控制线条的强度\n#define _Alpha (0.9) //混合比例\n\nfloat randomNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(1.9898, 7.233))) * 43758.5453123);\n}\n\nfloat trunc(float x, float num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nvec2 trunc(vec2 x, vec2 num_levels)\n{\n    return floor(x * num_levels) / num_levels;\n}\n\nvec3 rgb2yuv(vec3 rgb)\n{\n    vec3 yuv;\n    yuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));\n    yuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));\n    yuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));\n    return yuv;\n}\n\t\nvec3 yuv2rgb(vec3 yuv)\n{\n    vec3 rgb;\n    rgb.r = yuv.x + yuv.z * 1.13983;\n    rgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);\n    rgb.b = yuv.x + yuv.y * 2.03211;\n    return rgb;\n}\n\nvec3 LineBlockGlitch(vec2 uv)\n{\n    float truncTime = trunc(iTime, 4.0);\n    float uv_trunc = randomNoise(trunc(uv.yy, vec2(8., 8.)) + vec2(100.0 * truncTime));\n    //return vec3(uv_trunc); ------------------------------1\n    \n    float uv_randomTrunc = 6. * trunc(iTime, 24. * uv_trunc);\n    //return vec3(uv_randomTrunc); ------------------------2\n    \n    float blockLine_random = 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(8. * _LinesWidth, 8. * _LinesWidth)));\n    blockLine_random += 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(7., 7.)));\n    blockLine_random = blockLine_random * 2.0 - 1.0;\t\n    blockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4), 0., 1.);\n    blockLine_random = mix(0., blockLine_random, _Offset);\n    //return vec3(blockLine_random);-----------------------3\n    \n    vec2 uv_blockLine = uv;\n    uv_blockLine = clamp(uv_blockLine + vec2(0.1 * blockLine_random, 0.), 0., 1.);\n    \n    vec3 col = texture(iChannel0, abs(uv_blockLine)).xyz;\n    //return col; -----------------------------------------4\n    \n    col = rgb2yuv(col);\n    col.y /= 2. - 3. * abs(blockLine_random) * clamp(0.5 -  blockLine_random, 0., 1.); //Chrominance\n    col.z += 3.25 *  blockLine_random * clamp( blockLine_random - .5, 0., 1.);  //Chroma\n    col = yuv2rgb(col);\n    \n    vec3 ori_col = texture(iChannel0, uv).xyz;\n    return mix(ori_col, col, vec3(_Alpha));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = LineBlockGlitch(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 210, 210, 283], [285, 285, 325, 325, 374], [376, 376, 413, 413, 462], [464, 464, 488, 488, 679], [682, 682, 706, 706, 871], [873, 873, 904, 904, 2302], [2304, 2304, 2361, 2411, 2578]], "test": "untested"}
{"id": "fsKGRD", "name": "blotchy spirals", "author": "HaleyHalcyon", "description": "a", "tags": ["perlinnoise"], "likes": 3, "viewed": 69, "published": "Public", "date": "1631242224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 2.5);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  float dist = log(uv.x * uv.x + uv.y * uv.y);\n  float angle = atan(uv.y, uv.x) / TAU;\n\n  float noise = perlin(uv * 10.5, time);\n  noise += 0.5  * perlin(uv * 34.0, -2. * time);\n  noise *= max(0.0, dist * 0.2 + 2.);\n  \n  vec3 colBase = vec3(88, 125, 113) / 255.;\n  vec3 colSp1 = vec3(181, 221, 164) / 255.;\n  vec3 colSp2 = vec3(117, 70, 104) / 255.;\n  \n  float spiral1 = step(fract(0.2 * noise + 2. * angle + 0.5 * dist + time), 0.4);\n  float spiral2 = step(fract(0.2 * noise + 2. * angle + 0.5 * dist + 2. * time + 0.5), 0.2);\n  vec3 col = mix(\n      mix(\n          colBase, colSp1, spiral1\n      ), colSp2, spiral2\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 98, 117, 117, 274], [275, 314, 333, 333, 384], [385, 402, 434, 434, 607], [608, 628, 665, 665, 1085], [1087, 1087, 1144, 1144, 2025]], "test": "untested"}
{"id": "fsKGW3", "name": "waves109012", "author": "OscarSaharoy", "description": "its wavy", "tags": ["wavy"], "likes": 1, "viewed": 36, "published": "Public", "date": "1632319658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash11(float p) {\n\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float te = 0.0;\n    \n    for( int i = -5; i < 35; ++i ) {\n    \n        float height = float(i)/40.0;\n\n        vec2  auv = vec2( uv.x+height*1.7, height*1.8 ); \n        float s = height + noise((auv + iTime*0.032)*5.0) * 0.02 + noise(auv + iTime*0.05) * 0.02;\n        float d = (uv.y - s) * 100.0;\n\n        float e = (10.3*d / ( 0.2 + abs(d) ) + d) * pow(4.0, -abs(d)) * 0.1;\n        te += e;\n    }\n    \n    vec3 c = vec3( 0.64, 0.65, 0.6 ) + te;\n    fragColor += vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 110], [112, 112, 169, 169, 302], [304, 304, 330, 330, 809], [811, 811, 868, 919, 1445]], "test": "untested"}
{"id": "fstGD2", "name": "大龙猫 - Asleep From Day ", "author": "totetmatt", "description": "For once, a shader that doesn't try to kill you. Breath and enjoy.", "tags": ["cloud", "fly"], "likes": 5, "viewed": 183, "published": "Public API", "date": "1630692350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMostly a rip off of https://iquilezles.org/www/articles/fbmsdf/fbmsdf.htm\n*/\nfloat box3(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n     return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.z,q.y)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h)-k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat qqq(vec3 p){\n    vec3 id = floor(p);\n    p = fract(p)-.5;\n    float h = length(p)-(.25-.15*fract(10.*sin(100.*id.x*id.y-id.z*100.)) );\n  \n    return h;\n}\n\nvec3 op;\n// Iq sdFbm\nfloat sdFbm( vec3 p, float d )\n{\n   float s = 1.0;\n   for( int i=0; i<11; i++ )\n   {\n       // evaluate new octave\n       float n = s*qqq(p);\n      //p.xy*=rot(-.785*float(i)+float(i));\n       // add\n       n = smax(n,d-0.1*s,0.3*s);\n       d = smin(n,d      ,0.3*s);\n    \n       // prepare next octave\n       p = mat3( 0.00, 1.60, 1.20,\n                -1.80, 0.72,-0.96,\n                -1.20,-1.96, 1.28 )*p;\n       s = 0.5*s;\n   }\n   return d;\n}\nvec3 tp;\nvec2 sdf(vec3 p){\n   tp =p;\n   p.z +=iTime*.01;\n   op =p ;\n    vec2 h;\n    h.x = dot(p,vec3(0.,1.,0.))+.2;\n   \n    float q = sdFbm(p,h.x); \n    h.x = mix(q,abs(q)-.01,.5);\n    h.y = 1.;\n\n    vec2 t ;\n    \n    tp.y +=.05;\n    tp.z +=4.85;\n    \n    tp.xz*=rot(.6);\n    t.x = box3(tp,vec3(.25,.005,.05-abs(tp.x*tp.x)*0.3));\n    tp.x-=.15;\n    tp.y+=.015;\n    t.x = min(max(abs(tp.z)-.05,length(tp.xy)-.02),t.x);\n    t.y = 2.;\n    h = t.x <= h.x ? t:h;\n    return h;\n    \n}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec3 ro =  mod(iTime,30.) < 10. ? vec3(0.,0.0,-5.): vec3(0.,-.1,5.);\n        vec3 rt = mod(iTime,30.) < 10. ? vec3(45.,0.,.0): vec3(0.,-.15,100.);\n    vec3 rp = ro;\n        vec3 z = normalize(rt-ro);\n        vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n        vec3 y = normalize(cross(z,x));\n        \n    vec3 rd = normalize(mat3(x,y,z)*vec3(uv,1.));\n\n\n    vec3 light = vec3(1.,50.,-0.);\n    vec3 col = mix(vec3(.3,.5,.8),vec3(.1,.5,.9),clamp(uv.y,0.,1.));\n    vec3 acc = vec3(0.);\n    float dd = 0.;\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        dd +=abs(d.x);\n        if(dd > 25.) break;\n        if(d.y==1.){\n        acc += vec3(1.)*exp(128.*-abs(d.x))/(256.-sin(op.z*op.x+iTime)*50.);\n                d.x = max(.0011,abs(d.x));\n        }\n\n        if(length(rp) > 50.) break;\n        if(d.x <.001){\n            vec3 n = norm(rp,.003);\n            float dif = dot(normalize(light-rp),n);\n            col = vec3(.5)*dif;\n            \n            break;\n        }\n        rp +=rd*d.x;\n    \n    }\n    col +=acc;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4llSWj", "previewfilepath": "https://soundcloud.com/azuresunmusic/50-000-miles-high-chemical-bros-rmxd-by-points-g-azuresunrecords", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/azuresunmusic/50-000-miles-high-chemical-bros-rmxd-by-points-g-azuresunrecords", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 106, 106, 198], [199, 199, 217, 217, 264], [266, 266, 305, 305, 390], [392, 392, 432, 432, 461], [463, 463, 481, 481, 622], [633, 645, 677, 677, 1094], [1104, 1104, 1121, 1121, 1573], [1600, 1600, 1626, 1626, 1704], [1705, 1705, 1760, 1760, 2892]], "test": "untested"}
{"id": "fstGRl", "name": "HelloShader1", "author": "Cook_48427", "description": "My first Shader", "tags": ["tutorial"], "likes": 0, "viewed": 29, "published": "Public", "date": "1630722527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592653589793238462643;\n\nfloat random(const vec2 st);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //vec2 squareOrigin = vec2(vel.x*mod((iTime/10.0), 1.0), vel.y*mod((iTime/10.0), 1.0));\n    vec2 squareOrigin = vec2(.4*sin((iTime/10.0)*PI)+.4, .3);\n\n    vec3 col = texture(iChannel1, uv.xy).rgb;\n    col.z = sin(.3*iTime);\n    \n    if(uv.x > squareOrigin.x && uv.x < squareOrigin.x+.2 && uv.y > squareOrigin.y && uv.y < squareOrigin.y+.3) {\n        col = texture(iChannel0, vec2(uv.x-squareOrigin.x, mod(squareOrigin.y*iTime/10.0, 1.0))).rgb;\n    }\n    \n    //creates a block wherever the mouse clicks\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(uv.x > (mouse.x - .03) && uv.x < (mouse.x + .03) && uv.y > (mouse.y - .05) && uv.y < (mouse.y + .05)){\n        col = vec3(.3, .3, .8);\n    }\n    col.xyz += mod(random(uv), .4);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat random(const vec2 st){\n    return fract(sin(dot(st, vec2(12.9898, 78.233)))*43758.5453123);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 133, 183, 1024], [1026, 1026, 1054, 1054, 1125]], "test": "untested"}
{"id": "fstSRH", "name": "Voxels Explained", "author": "Xor", "description": "This is the cleaned and commented version of my [url=https://www.shadertoy.com/view/sstXRn]tiny voxel tracer[/url]\nI hope you find something useful in here!", "tags": ["voxel", "golf"], "likes": 20, "viewed": 355, "published": "Public", "date": "1632630461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Compressed version: https://www.shadertoy.com/view/sstXRn\n\n//Voxel map (approximate SDF)\nfloat map(vec3 pos)\n{\n    return length(mod(pos,18.0)-9.0) - 9.5+sin(pos.z*0.3-iTime*0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 res = iResolution.xy;   //View resolution\n    \n    vec3 cam = vec3(sin(iTime*0.2+res), iTime),         //Camera position\n    pos = cam,                                          //Pixel position\n    ray = normalize(vec3(fragCoord*2.0 - res, res.y)),  //Ray direction\n    cell = vec3(0,0,0);                                 //Voxel cell\n    \n    //Step up to 100 voxels.\n    for(int i = 0; i<100; i++)\n    {\n        //Axis distance to nearest cell (with a small bias).\n        vec3 dist = fract(-pos * sign(ray)) + 1e-4,\n        //Alternative version (produces artifacts after a while)\n        //vec3 dist = 1.0-fract(pos * sign(ray)),\n        //Raytraced distance to each axis.\n        leng = dist / abs(ray),\n        //Nearest axis' raytrace distance (as a vec3).\n        near = min(leng.xxx, min(leng.yyy, leng.zzz));\n        \n        //Step to the nearest voxel cell.\n        pos += ray * near;\n        //Get the cell position (center of the voxel).\n        cell = ceil(pos) - 0.5;\n        //Stop if we hit a voxel.\n        if (map(cell) < 0.0) break;\n    }\n\n    //Rainbow color based off the voxel cell position.\n    vec3 color = sin(cell.z+vec3(0,2,4)) * 0.5 + 0.5;\n    //Square for gamma encoding.\n    color *= color;\n    \n    //Compute cheap ambient occlusion from the SDF.\n    float ao = smoothstep(-1.0, 1.0, map(pos)),\n    //Fade out to black using the distance.\n    fog = min(1.0, exp(1.0 - length(pos-cam)/8.0));\n    \n    //Output final color with ao and fog (sqrt for gamma correction).\n    fragColor = vec4(sqrt(color * ao * fog),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 91, 112, 112, 183], [185, 185, 240, 240, 1798]], "test": "untested"}
{"id": "fstSW8", "name": "Closest point on line", "author": "zheck", "description": "Shader to do some maths to find the closest point on a line to a point in space. If the red circle was to collide with the green circle then push it to a point along the line the minimum distance away without clipping it. ", "tags": ["point", "closest"], "likes": 3, "viewed": 71, "published": "Public", "date": "1633038497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UV_ORIGIN 0.5\n#define LINE_THICKNESS 0.0025\n\nconst vec3 red = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue = vec3(0., 0., 1.);\n\nfloat df_line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n    float edge = 1.0/min(iResolution.x, iResolution.y);\n    return smoothstep(edge, -edge, length(pa - ba * h) - LINE_THICKNESS);\n}\n\nfloat drawCircle(vec2 position, float radius)\n{\n    float smaller = min(iResolution.x, iResolution.y);\n    float edge = 1.0/smaller;\n    return smoothstep(edge, -edge, length(position) - radius);\n}\n\nvec2 FindNearestPointOnLine(vec2 origin, vec2 end, vec2 point)\n{\n    //Get heading\n    vec2 heading = (end - origin);\n    float magnitudeMax = length(heading);\n    heading = normalize(heading);\n\n    //Do projection from the point but clamp it\n    vec2 lhs = point - origin;\n    float dotP = dot(lhs, heading);\n    dotP = clamp(dotP, 0.0f, magnitudeMax);\n    return origin + heading * dotP;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    // Basic setup stuff\n    float smaller = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord-UV_ORIGIN*iResolution.xy)/smaller;\n    \n    // Define some points to draw a white line\n    vec2 pointA = vec2(-0.35, 0.0);\n    vec2 pointB = vec2( 0.35, 0.0);\n    \n    vec2 greenCircle = vec2( 0.0, sin(iTime) * 0.1);\n    float greenRadius = 0.05;\n    \n    vec2 blueCircle = (iMouse.xy-UV_ORIGIN*iResolution.xy)/min(iResolution.x, iResolution.y);\n    float blueRadius = 0.025;\n    \n    vec2 redCircle = FindNearestPointOnLine(pointA, pointB, blueCircle);\n    float redRadius = 0.05;\n\n    vec2 pureCircle = redCircle;\n\n    // If red circle is inside green circle\n    if( distance(redCircle, greenCircle) < greenRadius + redRadius )\n    {\n        vec2 closestFromGreen = FindNearestPointOnLine(pointA, pointB, greenCircle);\n        float aLength = distance(greenCircle, closestFromGreen);\n        float cLength = redRadius + greenRadius;\n        float bLength = sqrt(pow(cLength, 2.0) - pow(aLength, 2.0));\n        redCircle = closestFromGreen + (normalize(redCircle - closestFromGreen) * bLength);\n    }\n    \n    // Draw all the stuff, basically. None of this has anything to do with the math involved in finding these points.\n    col += df_line(uv, pointA, pointB);\n    col += drawCircle(uv - greenCircle, greenRadius) * green;\n    col += drawCircle(uv - blueCircle, blueRadius) * blue;\n    col += drawCircle(uv - redCircle, redRadius) * red;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 201, 201, 420], [422, 422, 469, 469, 619], [621, 621, 685, 703, 1012], [1014, 1014, 1071, 1071, 2596]], "test": "untested"}
{"id": "fstSWn", "name": "Isozig (RAA)", "author": "paniq", "description": "dipole based field rendered with revised affine arithmetic. ", "tags": ["raymarching", "dipole", "raa", "winding"], "likes": 7, "viewed": 234, "published": "Public API", "date": "1633013312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// uncomment for simple interactive six point demo\n//#define TEST_SIXAXIS\n\n\n#define MAX_LEVEL 16u\n#define MAX_STEPS 100\n\n// revised affine form of rank 1\nstruct raf1 {\n    float x0;\n    float x1;\n    float e;\n};\n\nstruct raf1x3 {\n    raf1 x;\n    raf1 y;\n    raf1 z;\n};\n\nraf1 ra_const(float x) {\n    return raf1(x, 0.0, 0.0);\n}\nfloat ra_radius(raf1 a) {\n    return abs(a.x1) + a.e;\n}\nvec2 ra_interval(raf1 a) {\n    float r = ra_radius(a);\n    return vec2(a.x0 - r, a.x0 + r);\n}\n\nraf1 ra_add(raf1 a, raf1 b) {\n\treturn raf1(a.x0 + b.x0, a.x1 + b.x1, a.e + b.e);\n}\nraf1 ra_add(raf1 a, float b) {\n\treturn raf1(a.x0 + b, a.x1, a.e);\n}\nraf1 ra_add(float a, raf1 b) {\n\treturn raf1(a + b.x0, b.x1, b.e);\n}\nraf1x3 ra_add(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_add(a.x,b.x),ra_add(a.y,b.y),ra_add(a.z,b.z));\n}\n\nraf1 ra_sub(raf1 a, raf1 b) {\n\treturn raf1(a.x0 - b.x0, a.x1 - b.x1, a.e + b.e);\n}\nraf1 ra_sub(raf1 a, float b) {\n\treturn raf1(a.x0 - b, a.x1, a.e);\n}\nraf1 ra_sub(float a, raf1 b) {\n\treturn raf1(a - b.x0, -b.x1, b.e);\n}\nraf1x3 ra_sub(raf1x3 a, vec3 b) {\n\treturn raf1x3(ra_sub(a.x,b.x),ra_sub(a.y,b.y),ra_sub(a.z,b.z));\n}\n\nraf1 ra_neg(raf1 a) {\n\treturn raf1(-a.x0, -a.x1, a.e);\n}\n\nraf1 ra_mul(raf1 a, raf1 b) {\n    float s = abs(a.x1);\n    float t = abs(b.x1);\n    float w = dot(a.x1, b.x1);\n    float u = s;\n    float v = t;\n    return raf1(\n        a.x0 * b.x0 + 0.5 * w,\n        a.x0 * b.x1 + a.x1 * b.x0,\n        a.e * b.e\n        + b.e * (abs(a.x0) + u)\n        + a.e * (abs(b.x0) + v)\n        + u * v\n        - 0.5 * dot(s, t));\n}\nraf1 ra_mul(raf1 a, float b) {\n    return raf1(\n        a.x0 * b,\n        a.x1 * b,\n        a.e * abs(b));\n}\nraf1 ra_mul(float a, raf1 b) {\n    return ra_mul(b, a);\n}\nraf1x3 ra_mul(raf1 a, vec3 b) {\n\treturn raf1x3(ra_mul(a,b.x),ra_mul(a,b.y),ra_mul(a,b.z));\n}\n\nraf1 ra_rcp(raf1 a) {\n    vec2 i = ra_interval(a);\n    float i0i1 = i[0]*i[1];\n    if (i0i1 < 0.0) {\n        return raf1(1.0/a.x0, 0.0, 1.0/0.0);\n    } else {\n        vec2 ab = 1.0 / i;\n        float h = sign(i[0]) / sqrt(i0i1);\n        float c = (ab[0]+ab[1]) * 0.5;\n        float nalpha = ab[0] * ab[1];\n        float alpha = -nalpha;\n        float zeta = c + h;\n        float delta = abs(c-h);\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            nalpha * a.e + delta);\n    }\n}\n\nraf1 ra_div(raf1 a, raf1 b) {\n    return ra_mul(a, ra_rcp(b));\n}\n\nraf1 ra_pow2(raf1 a) {\n    float w = 0.5 * a.x1 * a.x1;\n    return raf1(\n        a.x0 * a.x0 + w,\n        2.0 * a.x0 * a.x1,\n        a.e * (1.0 + 2.0 * (abs(a.x0) + abs(a.x1))) + w);\n}\n\nraf1 ra_dot(raf1x3 a, raf1x3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a, vec3 b) {\n    return ra_add(ra_add(ra_mul(a.x, b.x),ra_mul(a.y, b.y)),ra_mul(a.z, b.z));\n}\n\nraf1 ra_dot(raf1x3 a) {\n    return ra_add(ra_add(ra_pow2(a.x),ra_pow2(a.y)),ra_pow2(a.z));\n}\n\nraf1 ra_sqrt(raf1 x) {\n    vec2 i = ra_interval(x);\n    if (i[1] < 0.0) return ra_const(0.0);\n    i[0] = max(i[0], 0.0);\n    vec2 sq = sqrt(i);\n    float c = sq[1] + sq[0];\n    float h = sq[1] - sq[0];\n    float alpha = 1.0 / c;\n    float dzeta = c / 8.0 + 0.5 * sq[0] * sq[1] / c;\n    float delta = h * h / (8.0 * c);\n    return raf1(\n        alpha * x.x0 + dzeta,\n        alpha * x.x1,\n        alpha * x.e + delta);\n}\n\nraf1 ra_length(raf1x3 a) {\n    return ra_sqrt(ra_dot(a));\n}\n\nraf1 ra_abs (raf1 a) {\n    vec2 i = ra_interval(a);\n    if (i[0]*i[1] >= 0.0) {\n        return raf1(abs(a.x0), a.x1 * sign(a.x0), a.e);\n    } else {\n    #if 0\n        // keep ambiguous case in a box\n        vec2 j = abs(i);\n        i = (i[0]>=0.0)?j:(i[1]<0.0)?j.yx:vec2(0.0,max(j[0],j[1]));\n        return raf1((i[0]+i[1])*0.5, 0.0, (i[1]-i[0])*0.5);\n    #else\n        vec2 ab = abs(i);\n        float alpha = (ab[1] - ab[0]) / (i[1] - i[0]);\n        float zeta = (ab[0] - i[0] * alpha) * 0.5;\n        float delta = zeta;\n\n        return raf1(\n            alpha * a.x0 + zeta,\n            alpha * a.x1,\n            abs(alpha) * a.e + delta);\n\t#endif\n    }\n}\n\n// crude approximation for min/max\n// there are more opportunities for truncation here, as only\n// the overlapping parallelogram and either one or both top parts (max)\n// or bottom parts (min) of each argument need to be bounded.\n// e.g. if all minimum values of a are above the minimum values of b,\n// regardless of any overlapping, only a needs to be considered for max(a,b).\n\nraf1 ra_max(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[0] >= ib[1])\n        return a;\n    else if (ib[0] >= ia[1])\n        return b;\n    else {\n\t    return ra_mul(ra_add(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_min(raf1 a, raf1 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[1] <= ib[0])\n        return a;\n    else if (ib[1] <= ia[0])\n        return b;\n    else {\n\t    return ra_mul(ra_sub(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf1 ra_zero(raf1 x, raf1 y) {\n    float dxdy = x.x1 / y.x1;\n    return raf1(x.x0 - dxdy * y.x0, dxdy * y.e, 0.0);\n}\n\nvec2 get_range(uint c, uint level) {\n#if 1\n    float r = exp2( -float(level) );\n    const float k = exp2( -float(MAX_LEVEL) );\n    float center = (float(c)*k) * 2.0 - 1.0 + r;\n#else\n    float r = 1.0 / float(1u << level);\n    float center = (float(c) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;\n#endif\n    center += 1.0;\n    return vec2(center, r);\n}\n\nuint find_lsb(uint value) {\n#if 1\n    // findLSB() hack\n    return uint(log2(float(value & -value)));\n#else\n    // with GL4, this loop can be replaced with\n    // a single use of findLSB()\n    uint count = 0u;\n    for (uint i = 0u; i < MAX_LEVEL; ++i) {\n        if ((value & 1u) != 0u)\n            break;\n        count += 1u;\n        value >>= 1u;\n    }\n    return count;\n#endif\n}\n\nuint lowest_level(uint p) {\n    uint used_levels = min(MAX_LEVEL, find_lsb(p));\n    return MAX_LEVEL - used_levels;\n}\n\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nconst float PI = 3.14159265359;\n\nraf1 ra_dipole(raf1x3 p, vec3 n, float a) {\n    raf1 u = ra_dot(p, -n*a);\n    raf1 v = ra_dot(p);\n    v = ra_mul(v, ra_sqrt(v));\n    return ra_div(u, v);\n}\n\nraf1 ra_map( raf1x3 p ) {\n#if 0\n    p.y = ra_add(p.y, 0.3);\n    raf1 d = ra_const(0.0);\n    const int N = 80;\n    float u = sin(iTime)*0.5+0.5;\n    for (int i = 0; i < N; ++i) {\n        float x = float(i);\n        float a = x * 2.39996322972865332;\n        vec2 n = vec2(cos(a), sin(a));\n        float r = (x + 1.0) / float(N);\n        float h = mix(x / float(N), 1.0 - x / float(N),u);\n        float A = r*0.2;//pow(r,2.5)*0.3;//4.0 * PI 1 r * r / 8.0;\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(n.x*r, h, n.y*r)), normalize(vec3(n.x, u*2.0-1.0, n.y)), A));\n    }\n    \n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#elif defined(TEST_SIXAXIS)\n    float r = 0.5;\n    float a = 4.0 * PI * r * r / 6.0 * (iMouse.y / iResolution.y) * 4.0;\n    raf1 d = ra_dipole(ra_sub(p, vec3(r, 0.0, 0.0)), normalize(vec3(cos(iTime), sin(iTime), 0.0)), a);\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(-r, 0.0, 0.0)), normalize(vec3(-1.0, 0.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, r, 0.0)), normalize(vec3(0.0, 1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, -r, 0.0)), normalize(vec3(0.0, -1.0, 0.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, r)), normalize(vec3(0.0, 0.0, 1.0)), a));\n    d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -r)), normalize(vec3(0.0, 0.0, -1.0)), a));\n\n    return ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n#else\n    const int N = 8;\n    float A = 4.0 * PI * 0.25 / float(N) * 0.25;\n\n    raf1 d = ra_const(0.0);\n    for (int i = 0; i < N; ++i) {\n        float q = float(i)/float(N);\n        float a = q * 2.0 * PI;\n        float w0 = sin(a*3.0 + 0.1*iTime*2.0*PI);\n        float ae = a + w0*2.0*PI;\n        float s = sin(a);\n        float c = cos(a);\n        d = ra_add(d, ra_dipole(ra_sub(p, vec3(c, s, 0.0)*0.5), normalize(vec3(cos(ae), sin(ae), 0.0)), A*(w0*0.5+0.5)*8.0));\n    }    \n    //d = ra_add(d, ra_dipole(ra_sub(p, vec3(0.0, 0.0, -0.5)), normalize(vec3(0.0, 0.0, 1.0)), A*32.0));\n    \n    d = ra_neg(ra_add(ra_mul(d, 1.0/(4.0 * PI)), -0.5));\n    return d;\n#endif\n}\n\nraf1x3 ra_grad(vec3 pos, vec3 eps) {\n    return raf1x3(raf1(pos.x, eps.x, 0.0), raf1(pos.y, eps.y, 0.0), raf1(pos.z, eps.z, 0.0));\n}\n\nvec3 gradient( in vec3 pos ) {\n    const float eps = 0.001;\n\n    return -normalize(vec3(ra_map(ra_grad(pos, vec3(eps,0,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,eps,0))).x1,\n                     ra_map(ra_grad(pos, vec3(0,0,eps))).x1));\n}\n\nfloat calcIntersectionRA( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n    float threshold = get_range(0u, MAX_LEVEL).y;        \n    uint p = 0u;\n    uint level = 0u;\n    float maxd = 10.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        steps = i;\n        const uint topstep = 1u << MAX_LEVEL;\n        if (p >= topstep)\n            break;\n        vec2 rc = get_range(p, level);\n        raf1 t = raf1(rc.x, rc.y, 0.0);\n        raf1 d = ra_map(ra_add(ra_mul(t, rd * maxd), ro));\n        uint stepsz = topstep >> level;\n        // visualize interval\n        vec2 iv = ra_interval(d);\n        // interval crosses zero?\n        bool hit = (iv.x*iv.y < 0.0);\n        if (hit) {\n            // if we have prematurely reached our\n            // desired precision, exit early                \n            if ((d.e <= threshold) || (level == MAX_LEVEL)) {\n                vec2 pr = ra_interval(ra_zero(raf1(rc.x,rc.y,0.0), d));\n                return maxd * (pr[0]+pr[1])/2.0;\n            }\n            // reached maximum precision\n            if (level == MAX_LEVEL)\n                break;\n        }\n        if (hit && (level < MAX_LEVEL)) {\n            level += 1u;\n        } else {\n            p += stepsz;\n            level = lowest_level(p);\n        }\n    }\n    return -1.0;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, out vec3 normal, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n    vec2 m = (-resolution.xy + 2.0*iMouse.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,6.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    float w = (iMouse.z > 0.5)?m.x:0.0;\n\n\t// raymarch\n    float t = calcIntersectionRA( ro, rd, 1.0 / resolution, bias, steps );\n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        normal = -gradient(position);\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;\n\n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    vec3 normal;\n    int steps;\n    bool hit = dorender(dist, steps, pos, normal, fragCoord, resolution, 1.0);\n\n    fragColor = vec4(vec3(0.0),1.0);\n#if 0\n    if (hit) {\n        vec3 nor = calcNormal(pos);\n        fragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n    }\n#else\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    ivec3 p = ivec3(pos*10.0);\n    c2 = mix(c2, vec3(float((p.x ^ p.y ^ p.z) % 3)/2.0), 0.1);    \n\n    fragColor = vec4(normal*0.5+0.5,1.0);\n#endif\n}", "image_inputs": [{"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstSWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 269, 293, 293, 325], [326, 326, 351, 351, 381], [382, 382, 408, 408, 475], [477, 477, 506, 506, 559], [560, 560, 590, 590, 627], [628, 628, 658, 658, 695], [696, 696, 729, 729, 796], [798, 798, 827, 827, 880], [881, 881, 911, 911, 948], [949, 949, 979, 979, 1017], [1018, 1018, 1051, 1051, 1118], [1120, 1120, 1141, 1141, 1176], [1178, 1178, 1207, 1207, 1533], [1534, 1534, 1564, 1564, 1642], [1643, 1643, 1673, 1673, 1700], [1701, 1701, 1732, 1732, 1793], [1795, 1795, 1816, 1816, 2314], [2316, 2316, 2345, 2345, 2380], [2382, 2382, 2404, 2404, 2566], [2568, 2568, 2601, 2601, 2682], [2684, 2684, 2715, 2715, 2796], [2798, 2798, 2821, 2821, 2890], [2892, 2892, 2914, 2914, 3311], [3313, 3313, 3339, 3339, 3372], [3374, 3374, 3396, 3396, 4031], [4033, 4412, 4441, 4441, 4675], [4677, 4677, 4706, 4706, 4940], [4942, 4942, 4972, 4972, 5058], [5060, 5060, 5096, 5096, 5409], [5411, 5411, 5438, 5438, 5791], [5793, 5793, 5820, 5820, 5910], [5913, 5913, 5996, 5996, 6119], [6121, 6121, 6148, 6148, 6183], [6218, 6218, 6261, 6261, 6373], [6375, 6375, 6400, 6400, 8443], [8445, 8445, 8481, 8481, 8577], [8579, 8579, 8609, 8609, 8832], [8834, 8834, 8925, 8925, 10128], [10131, 10131, 10195, 10195, 10373], [10375, 10375, 10512, 10512, 11504], [11506, 11506, 11532, 11532, 11617], [11619, 11667, 11692, 11692, 11750], [11753, 11753, 11809, 11809, 12393]], "test": "untested"}
{"id": "fsV3Dd", "name": "asdasdasdasdasddasdasdasdasd", "author": "raymondzheng", "description": "asd", "tags": ["asd"], "likes": 0, "viewed": 14, "published": "Public", "date": "1632420021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // const colors\n    vec3 YELLOW = vec3(1.0,0.9,0);\n    vec3 ORANGE = vec3(1.0,0.3,0);\n    \n    // declaring variables\n    float aspectRatio = iResolution.y / iResolution.x;\n    float radius = 0.1;\n    float amplitude = 0.6;\n    float frequency = 0.5;\n    float amplitudeDawn = 0.3;\n    float yModification = 0.25;\n    \n    // fixing circle to screen res\n    uv.y *= aspectRatio;\n    vec2 center = vec2(0.5, (0.5 - yModification)- abs(sin(iTime * frequency) * amplitude));\n    \n    float dist = distance(center, uv);\n    \n\n    vec3 outPut = mix(ORANGE, YELLOW, uv.y);\n    outPut *= abs( 1.0 / sin(iTime * frequency) * amplitudeDawn);\n    float isOutCircle = step(dist, radius);\n    outPut = mix(outPut, YELLOW, isOutCircle);\n\n    // Output to screen\n    fragColor = vec4(outPut,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 941]], "test": "untested"}
{"id": "fsV3WD", "name": "Sea of Pearls", "author": "Tater", "description": "I used all the domain repetition tricks I know for this one. ", "tags": ["3d", "raymarching", "underwater"], "likes": 23, "viewed": 251, "published": "Public API", "date": "1631578385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926535\n#define STEPS 500.0\n#define MDIST 200.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(453.2734,255.4363)))*994.3434);\n}\nvec3 rdg;\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nvec3 map(vec3 p){\n    vec3 po = p;\n    vec2 a = vec2(1);\n    //vec2 b = vec2(2);\n    float t =iTime;\n    p.x+=t;\n    \n    float m = 2.; //Adjust the sphere size here :)\n    \n    vec2 id3 = floor(p.xz/m)+0.5;\n    p.x+=id3.y;\n    vec2 id2 = floor(p.xz/m)+0.5;\n    float hash =h21(mod(id2,100.0));\n    p.y+=(hash-0.5);\n    id2*=rot(-pi/6.0);\n    p.y+=sin(id2.x+t)*0.7;\n    p.y+=sin(id2.x*0.6+t)*0.4;\n    p.y+=sin(id2.x*0.3+t)*0.2;\n    id2*=rot(pi/6.0)*0.3;\n    p.y+=sin(id2.y+t)*0.7;\n    po = p;\n    float dc = 0.;\n    {\n        vec3 p2=p/vec3(m);\n        vec3 id = floor(p2);\n        vec3 dir = sign(rdg)*.5;\n        vec3 q = fract(p2)-.5;\n        vec3 rc = (dir-q)/rdg;\n        rc*=m;\n        dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    }\n    p.xz = pmod(p.xz,m);\n    t+=hash*200.;\n    //t*=-1.;\n    //////////////////////////////////\n    //////////////////////////////////\n    float spd = .025;\n    t*=spd;\n    float lscl = m;\n    float le = -mod(t * lscl,lscl); \n    float tscl = 650.; \n    float te = tscl - mod(t * tscl,tscl); \n    float scl = 0.; \n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            mid = true;\n            id = floor(t);\n        }\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n            //mid = true;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    //////////////////////////////////\n    //////////////////////////////////\n    \n    a.x = length(p)-m*0.98*0.5;\n    \n    a.x = max(-po.z-16.,a.x);\n    float c = a.x;\n    a.x = min(a.x,dc);\n    \n    if(mid)a.x = min(a.x,max(-(-po.y+le),0.1));\n    a.y = id;\n    return vec3(a,c);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvec3 light(vec3 p, vec3 rd){\n    vec3 col = vec3(0);\n    vec3 ld = normalize(vec3(1,1,-1));\n    vec3 n = norm(p);\n    float fres = 1.-abs(dot(rd,n))*.6;\n    col = vec3(clamp(fres,0.,1.));\n    \n    float sss = 0.6;\n        for(float i=1.; i<40.; ++i){\n        float dist = i*0.1;\n        sss += 0.04*smoothstep(0.,1.,map(p+ld*dist).z/dist);\n    }\n    col*=sss;\n    \n    vec3 p2 = p;\n    p2.xz*=rot(0.1+cos(iTime*0.2)*0.3);\n    col*=mix(vec3(0.310,0.471,0.953),vec3(0.106,0.137,0.553),sin(p2.z+p2.x)*0.5+0.5);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(1,10,-25);\n    vec3 lk = vec3(1.01,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));\n    rdg=rd;\n    vec3 p = vec3(0);\n    vec3 d = vec3(0);\n    float dO = 0.;\n    bool hit = false;\n    for(float i =0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO += d.x*1.25;\n        if(abs(d.x)<0.005){\n            hit =true;\n            break;\n        }\n        if(dO>MDIST){\n            dO=MDIST;\n            p = ro+rd*dO;\n            break;\n        }   \n    }\n    if(hit){\n        col = light(p,rd);\n    }\n\n    //Fog\n    col*=clamp(p.y*0.15+1.0,-1.,1.);\n    col = pow(col,vec3(0.6));;\n    vec3 bg = mix(vec3(0.000,0.12,0.400),vec3(0.439,0.784,1.000),max(rd.y+0.6,0.));\n    col = mix(col,bg,clamp(length(p-ro*0.5)/60.,0.,1.));\n\n    fragColor = vec4(col,0.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 169, 169, 235], [246, 246, 272, 272, 330], [331, 331, 348, 348, 2271], [2272, 2272, 2290, 2290, 2418], [2419, 2419, 2447, 2447, 2944], [2945, 2945, 3001, 3001, 3970]], "test": "untested"}
{"id": "fsV3WG", "name": "SDF PBR", "author": "helgust", "description": "nice", "tags": ["sdf", "pbr"], "likes": 1, "viewed": 35, "published": "Public", "date": "1632149773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 eye = vec3(0,0,10);\nconst vec3 light = vec3(0.0,5.0,10.0);\nconst int maxSteps = 100;\nconst float eps = 0.01;\n\n\nfloat smin (float a, float b, float k)\n{\n    float res = exp(-k*a)+exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\nreturn length ( p.xz - c.xy ) - c.z+0.03* cos(5.0*p.y + iTime)+0.02 * sin(20.0*p.z + iTime) ;\n}\n\nfloat dSphere (vec3 p, vec3 c)\n{\n    return length(p - c) - 1.0 +0.03 * sin(20.0*p.y + iTime);\n}\n\nfloat dEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat length8 (in vec2 p)\n{\n    return pow(pow(p.x,8.0) + pow (p.y,8.0),1.0/8.0);\n}\n\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus (vec3 p, vec3 t)\n{\n    vec2  q=vec2(length8 (p.xz) - t.x,p.y);\n    return length8(q) - t.y;\n}\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1,0,0),\n            vec3(0,c,-s),\n            vec3(0,s,c));\n}\n\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,-s,0),\n            vec3(s,c,0),\n            vec3(0,0,1));\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,0,s),\n            vec3(0,1,0),\n            vec3(-s,0,c));\n}\n\nfloat sdf (in vec3 p,in mat3 m)\n{\n    vec3 q = m*p;\n    vec3 o = q*rotateX(90.0);\n    \n    return smin(smin(dEllipsoid(q,vec3(1,5,1)),dCyl(rotateX(-90.0)*q,vec3(0,0,1)),7.0),smin(dSphere(q,vec3(0,5,0)),dSphere(q,vec3(0,-5,0)),8.0),9.0);\n}  \nvec3 generateNormal (vec3 z, float d,in mat3 m)\n{\n    float e  = max(d * 0.5,eps);\n    float dx1 = sdf(z+ vec3(e,0,0),m);\n    float dx2 = sdf(z- vec3(e,0,0),m);\n    float dy1 = sdf(z+ vec3(0,e,0),m);\n    float dy2 = sdf(z- vec3(0,e,0),m);\n    float dz1 = sdf(z+ vec3(0,0,e),m);\n    float dz2 = sdf(z- vec3(0,0,e),m);\n    \n    return normalize (vec3 (dx1 - dx2,dy1-dy2,dz1-dz2));\n}\n\n\n\nconst float roughness = 0.4;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.8, 0.4, 0.0 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.0;\n    \n    hit =false;\n    \n    for (int steps = 0; steps < maxSteps; steps++)\n    {\n        float dist = sdf(p,m);\n        \n        if(dist < 0.001)\n        {\n            hit = true;\n        }\n        totalDist+=dist;\n        \n        if(totalDist > 20.0)\n            break;\n           p+=dist*dir;\n    }\n    \n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 12.0 * iResolution.xy / max(iResolution.x,iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2 (0.5));\n    vec3 dir = normalize (vec3 (uv,0) - eye);\n    vec4 color = vec4(0,0,0,1);\n    vec3 p = trace(eye,dir,hit,m);\n    \n    if(hit)\n    {\n     vec3 l = normalize(light - p);\n     vec3 v = normalize(eye - p);\n     vec3 n = generateNormal(p,0.001,m);\n     vec3 r = l-2.0*max(0.0,dot(l,n))*n;\n     float nl = max(0.0,dot(n,l));\n     vec3 h = normalize(l+v);\n     float hn = max(0.0,dot(-v,r));\n     float sp = pow (hn,90.0);\n     \n     \n     color = 0.5*vec4(nl) + sp*vec4(1,0,0,1);\n     color = cookTorrance ( p, n, l, v );\n    }\n\n    // Output   to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3WG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 162, 162, 225], [227, 227, 259, 259, 330], [332, 332, 363, 363, 459], [461, 461, 493, 493, 557], [559, 559, 595, 595, 678], [680, 680, 707, 707, 763], [766, 766, 795, 795, 882], [885, 885, 916, 916, 991], [993, 993, 1020, 1020, 1155], [1157, 1157, 1184, 1184, 1319], [1321, 1321, 1348, 1348, 1483], [1485, 1485, 1518, 1518, 1723], [1726, 1726, 1775, 1775, 2106], [2310, 2338, 2385, 2385, 2499], [2501, 2501, 2550, 2550, 2690], [2692, 2692, 2747, 2747, 2903], [2905, 2905, 2955, 2955, 3102], [3104, 3104, 3170, 3170, 3312], [3314, 3314, 3360, 3360, 3396], [3398, 3398, 3456, 3456, 3488], [3490, 3490, 3562, 3562, 3621], [3623, 3623, 3689, 3689, 4380], [4383, 4383, 4447, 4447, 4818], [4819, 4819, 4876, 4926, 5784]], "test": "untested"}
{"id": "fsV3zt", "name": "cube&julia set", "author": "AndryM793", "description": "test cube & Julia set", "tags": ["cube"], "likes": 1, "viewed": 34, "published": "Public", "date": "1631987255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int accuracy = 25;\nconst float jlen = 2.;\nconst vec3 axis = vec3(0.,1.,1.);\nconst float battery = 0.02;\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return (-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return (tN > 0.)?tN:tF;\n}\n\n\nfloat lengthToJulia(in vec2 p, in vec2 c){\n    int i = 0;\n    for(float t; i <= accuracy;){\n        t = (p.x*p.x) - (p.y*p.y);\n        p.y = (p.x*p.y) + (p.y*p.x);\n        p.x = t;\n        p += c;\n        if(length(p) > jlen){ break; }\n        i++;\n    }\n    return float(i) / float(accuracy);\n}\n\n\nfloat figureNoise(in vec2 x, float seed){\n    return fract(tan(dot(x, vec2(10.58927, 10.89820471)/seed/50.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.y;\n    mat3 rt = rotationMatrix(axis, iTime);\n    vec3 start = vec3(0, 0, -5) * rt;\n    vec3 rd = normalize(vec3(uv, 0.7)) * rt;\n    vec3 n;\n    float bl = boxIntersection(start, rd, vec3(1.7,1.7,1.7), n);\n    if(bl > 0.){ \n        vec3 ts = rd*bl + start;\n        vec2 c = vec2(sin(iTime)*sin(iTime/30.), cos(iTime));\n        vec2 p;\n        if(abs(n.x) > 0.){ p = ts.yz; }else if(abs(n.y) > 0.){ p = ts.xz; }else{ p = ts.xy; }\n        float jl = lengthToJulia(p, c);\n        if(false){//jl >= 1.\n            fragColor = vec4(1., 1., 1., 1.0) * figureNoise(fragCoord, iTime-float(int(iTime)));\n        }\n        else{\n            vec3 light = normalize(vec3(-sin(iTime*2.), cos(iTime*4.), -sin(iTime)));\n            fragColor = vec4(1.0 - battery, battery, 0.0, 1.0) * (jl+max(0., dot(light, n))); \n        }\n    }\n    else{ fragColor = vec4(1., 1., 1., 1.0) * figureNoise(fragCoord, iTime-float(int(iTime))); }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 163, 163, 616], [619, 619, 703, 703, 1178], [1181, 1181, 1223, 1223, 1476], [1479, 1479, 1520, 1520, 1591], [1593, 1593, 1650, 1650, 2628]], "test": "untested"}
{"id": "fsV3zW", "name": "seething tunnel", "author": "HaleyHalcyon", "description": "a", "tags": ["perlinnoise"], "likes": 3, "viewed": 62, "published": "Public", "date": "1631241700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define CELLS_AROUND (12.)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, CELLS_AROUND));\n  float n = (float(hash(x + hash(y))) / 256.) + (time * TAU);\n  return vec2(cos(n), sin(n));\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n// stripes of color\nconst vec3[] colors = vec3[](\n  vec3(142, 202, 230)/255.,\n  vec3(33, 158, 188)/255.,\n  vec3(2, 48, 71)/255.,\n  vec3(255, 183, 3)/255.,\n  vec3(251, 133, 0)/255.,\n  vec3(105, 46, 22)/255.\n);\nvec3 stripes(float n) {\n  return mix(\n    colors[uint(n + 6.0) % 6u],\n    colors[uint(n + 7.0) % 6u],\n    smoothstep(15./16., 1.0, fract(n))\n  );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 4.);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  vec2 rt = vec2(2.1 * log(length(uv)), atan(uv.y, uv.x) * CELLS_AROUND / TAU);\n  float  value = rt.x * 0.5;\n  value += 0.5  * perlin(rt *  2.0, 0.);\n  value += 0.8  * perlin(rt *  7.0, 0.8);\n  // Output to screen\n  fragColor = vec4(\n    stripes(256. + value - time * 6.), 1\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsV3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 125, 144, 144, 275], [276, 315, 334, 334, 385], [386, 403, 435, 435, 606], [607, 627, 664, 664, 1058], [1059, 1268, 1291, 1291, 1415], [1416, 1416, 1473, 1473, 1951]], "test": "untested"}
{"id": "fsVGDR", "name": "weird little circle", "author": "HaleyHalcyon", "description": "a", "tags": ["perlinnoise"], "likes": 1, "viewed": 36, "published": "Public", "date": "1631350669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// Reverse lerp and keeps the value between 0. and 1.\nfloat map(float vmin, float vmax, float v) {\n    return clamp(\n        (v-vmin)/(vmax-vmin), // reverse lerp\n        0., 1. // clamp\n    );\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// Fade function defined by Ken Perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// Corner vector for Perlin noise\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// Perlin generator.\n// Coordinates can loop an integer number of cells,\n// including in only 1 coordinate\n// * uv: coordinates\n// * offset: time from 0 to 1 (will loop around)\n// * loop: number of cells to loop around\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  // loop coordinates\n  if (loop.x > 0.) {uv.x = mod(uv.x, loop.x);}\n  if (loop.y > 0.) {uv.y = mod(uv.y, loop.y);}\n  vec2 i = floor(uv); // floored coordinates\n  vec2 n = floor(uv + 1.); // next coordinates\n  // loop next coordinates for wrap-around\n  if (loop.x > 0.) {n.x = mod(uv.x + 1., loop.x);}\n  if (loop.y > 0.) {n.y = mod(uv.y + 1., loop.y);}\n  // blending ratio\n  vec2 f = fract(uv);\n  vec2 u = fade(f);\n  offset = fract(offset);\n  // monstrous meta-mix expression\n  return\n  mix( // mix vertically\n    mix( // mix top horizontally\n      dot(cvec(i,              offset), f - vec2(0.0,0.0)),\n      dot(cvec(vec2(n.x, i.y), offset), f - vec2(1.0,0.0)),\n    u.x),\n    mix( // mix bottom horizontally\n      dot(cvec(vec2(i.x, n.y), offset), f - vec2(0.0,1.0)),\n      dot(cvec(n,              offset), f - vec2(1.0,1.0)),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 6.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // use log distance for perspective/tunnel effect\n    float dist = log(uv.x * uv.x + uv.y * uv.y);\n    float angle = atan(uv.y, uv.x) / TAU;\n    vec2 rt = vec2(0.5 + dist * 2., angle * 24. + dist * 0.2);\n    // generate noise\n    float noise = 1.0 * perlin(\n        rt * 1. + vec2(-10., 16.) * time,\n        time,\n        vec2(10., 24.)\n    );\n    noise += 0.3 * perlin(\n        rt * 3. + vec2(-20., 16.) * time,\n        -2. * time,\n        vec2(20., 24.)\n    );\n    //noise *= max(0.0, dist * 0.2 + 2.);\n    // calculate the total \"brightness\" of the image\n    float bright = noise + rt.x * 0.4;\n    \n    // add some smoldering from the perimeter\n    float smolder = \n        sin(dist + (3. * time * TAU)) * 0.8\n        + sin(dist + (3. * (time - 0.2) * TAU)) * 0.4;\n    bright += smolder;\n    \n    bright = max(-2., bright);\n    \n    // separately, add little stars\n    float stars = perlin(\n        uv * 16. + vec2(0., -7.) * time,\n        time,\n        vec2(0., 7.)\n    );\n    stars += perlin(\n        uv * 37. + vec2(0., -7.) * time,\n        time,\n        vec2(0., 7.)\n    );\n    \n    // add symbol in the center\n    float letterSize = 0.185 + (0.025 * sin(8. * time * TAU));\n    // check if the region is within the square region around the center\n    if (abs(uv.x) < letterSize * 0.9 && abs(uv.y) < letterSize * 0.9) {\n        bright += 1. * texture(\n            iChannel0, // the letter texture thing\n            (uv / 2. // zoom out for +-2 unit side length\n            / letterSize // zoom in to fit our cut-out region\n            + \n                vec2(floor(time * 16.), floor(fract(time * 16.) * 16.)) // character offset\n                             // take the ascii code in hex, y is high nybble, x is low nybble\n                             // e.g. ? is (15, 3) because its ASCII code is 0x3F\n                             // this texture has other symbols in place of control or whitespace characters\n                             // like eighth note in 0x0A\n                + vec2(0.5, -0.5)\n            ) / 16. // zoom in for 16 characters tall and wide texture\n        ).r;\n    }\n    \n    // map the brightness to colors\n    float bright0 = map(\n        -1.5, -1.45, bright\n    );\n    float bright1 = map(\n        -0.5, -0.45, bright\n    );\n    vec3 col = mix(\n        HEX(0xfec157),\n        mix(\n            HEX(0xe5502f),\n            mix(\n                HEX(0x793c37), HEX(0xFFFF9f), step(\n                    0.5, stars\n                )\n            ),\n            bright1\n        ), bright0\n    );\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVGDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 152, 196, 196, 293], [295, 366, 385, 385, 542], [543, 582, 601, 601, 652], [653, 687, 719, 719, 892], [893, 1112, 1160, 1182, 2009], [2011, 2011, 2068, 2096, 4848]], "test": "untested"}
{"id": "fsVGDV", "name": "jiahao：【故障7-1】模拟噪点故障", "author": "LokaHer", "description": " ", "tags": [], "likes": 0, "viewed": 13, "published": "Public", "date": "1632310067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _Speed (0.1)\n#define _LuminanceJitterThreshold (0.5)\n#define _Fading (0.7)\n\nvec2 Speed()\n{\n    return vec2(_Speed, _Speed);\n}\n\nfloat randomNoise(vec2 c)\n{\n    return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 iTimeV2()\n{\n    return vec2(iTime, iTime);\n}\n\n\nvec3 AnalogNoiseGlitch(vec2 uv)\n{\n    float noiseX = randomNoise(iTimeV2() * Speed() + uv);\n    float noiseY = randomNoise(iTimeV2() * Speed() - uv);\n    float noiseZ = randomNoise(iTimeV2() * Speed() + uv);\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 noise_col = col;\n    \n    float luminance = dot(noise_col, vec3(0.22, 0.707, 0.071));\n    \n    if(randomNoise(vec2(iTime * _Speed, iTime * _Speed)) > _LuminanceJitterThreshold)\n    {\n        noise_col = vec3(luminance, luminance, luminance);\n    }\n    \n    \n    noise_col += 0.25 * vec3(noiseX, noiseY, noiseZ) - 0.125;\n    \n    noise_col = mix(col, noise_col, _Fading);\n    return noise_col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = AnalogNoiseGlitch(uv);  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 98, 98, 133], [135, 135, 162, 162, 234], [236, 236, 252, 252, 285], [288, 288, 321, 321, 947], [949, 949, 1006, 1056, 1231]], "test": "untested"}
{"id": "fsy3RG", "name": "Something  gaz 228", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 6, "viewed": 193, "published": "Public API", "date": "1631708706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,d=normalize(vec3((C-.5*r.xy)/r.y,1.));\n    for(float i=0.,g,e=1.;++i<60.||e>.01;e<.01?O.xyz+=cos(d*p)/i:p){\n        p=g*d;\n        p=R(p, vec3(.577), iTime*.3);\n        for(int j=0;j++<9;)\n            p.xy=length(p.xy)*sin(vec2(0,1.57)+sin(atan(p.x,p.y)*3.)/3.),\n            p.y-=7.,\n            p=p.yzx,\n            p=R(p,vec3(1,0,0),.2);\n        g+=e=dot(abs(p),vec3(.3,.7,.2))-.8;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsy3RG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 95, 95, 527]], "test": "untested"}
{"id": "fsy3zD", "name": "nature love", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 3, "viewed": 42, "published": "Public", "date": "1631241541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Debug feature:\n// Toggle this to 1 if you want to see the coordinates used by the texture\n#define DISABLE_TEXTURES 0\n// How many times should the textusre repeat as the angle makes 1 complete turn?\n// For square textures, I recommend 4ish\n#define TEXTURE_HLOOPS 4\n\nfloat distHeart(float x, float y)\n{\n    float n = -0.5 * abs(x) + y;\n    return log(\n        x * x + 1.5 * n * n\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizes coords so that center is (0,0) and diagonals are length 1\n    vec2 uv = (fragCoord / length(iResolution.xy)\n\t- (iResolution.xy / length(iResolution.xy) / 2.)) * 2.;\n    // weird hybrid distance function\n    float r = length(uv);\n    r = log(r) * 0.6 + r * -0.3;\n    // angle from 0 to 1\n    float angle = atan(uv.y, uv.x) / (2. * 3.1415927);\n    float t = fract(iTime / 5.0);\n    \n    // the texture X and Y coords\n    float spiral1 = r * 1.0 + angle * 1. + t * 1.;\n    float spiral2 = r * 0.2 + angle * -float(TEXTURE_HLOOPS) + t * 2.;\n    \n    vec2 txUV = vec2(spiral2, spiral1);\n    \n    // Time varying pixel color\n    #if DISABLE_TEXTURES\n    vec3 col = vec3(fract(txUV).xy, 0.0);\n    #else\n    vec3 col = mix(\n        vec3(0.2, 0.1, 0.0),\n        vec3(0.6, 0.4, 0.1),\n        texture(iChannel0, txUV).r\n    );\n            float rings = smoothstep(0.5, 1.0, sin(3.1415927 * 2. * (t * 5. + distHeart(uv.x, uv.y) * 0.5 )));\n    col = mix(\n        col,\n        vec3(1.0, 0.2, 0.4),\n        rings\n    ) + 0.1 * rings;\n    #endif\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsy3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 268, 303, 303, 389], [392, 392, 449, 525, 1554]], "test": "untested"}
{"id": "fsy3zG", "name": "Isosceles Trapezoid SDF", "author": "TheTurk", "description": "Distance function for an isosceles trapezoid. A slightly simpler implementation of [url]https://www.shadertoy.com/view/MlycD3[/url]. This is the basis for a truncated cone [url]https://www.shadertoy.com/view/Nl33W8[/url].", "tags": ["distancefield", "sdf", "distance", "trapezoid", "primitive", "isosceles"], "likes": 3, "viewed": 47, "published": "Public", "date": "1631709952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float trapezoid(vec2 position, float halfWidth1, float halfWidth2, float halfHeight) {\n    position.x = abs(position.x);\n    position.x -= (halfWidth2 + halfWidth1) * 0.5;\n    vec2 end = vec2((halfWidth2 - halfWidth1) * 0.5, halfHeight);\n    vec2 segment = position - end * clamp(dot(position, end) / dot(end, end), -1.0, 1.0);\n    float d = length(segment);\n    if (segment.x > 0.0) {\n        return d;\n    }\n    return max(-d, abs(position.y) - halfHeight);\n}\n\n/*\n// alternative version without branching\nfloat trapezoid(vec2 position, float halfWidth1, float halfWidth2, float halfHeight) {\n   position.x = abs(position.x);\n   vec2 d1 = vec2(max(position.x - halfWidth1, 0.0), -position.y - halfHeight);\n   vec2 d2 = vec2(max(position.x - halfWidth2, 0.0), position.y - halfHeight);\n   position -= vec2(halfWidth1, -halfHeight);\n   vec2 end = vec2(halfWidth2 - halfWidth1, halfHeight * 2.0);\n   vec2 d3 = position - end * clamp(dot(position, end) / dot(end, end), 0.0, 1.0);\n   return sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3))) * sign(max(max(d1.y, d2.y), d3.x));\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy;\n    position = (position * 2.0) - 1.0;\n    position.x *= iResolution.x / iResolution.y;\n\n    float halfWidth1 = 0.2 + 0.15 * sin(iTime * 1.3);\n    float halfWidth2 = 0.2 + 0.15 * sin(iTime * 1.4 + 1.1);\n    float halfHeight = 0.5 + 0.2 * sin(1.3 * iTime);\n    float d = trapezoid(position, halfWidth1, halfWidth2, halfHeight);\n\n    // same colorization that Inigo Quilez uses in his shaders\n    vec3 color = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7); // base color\n    color *= 1.0 - exp(-4.0 * abs(d)); // gradient\n\tcolor *= 0.8 + 0.2 * cos(120.0 * d); // ripples\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n    if (iMouse.z > 0.001) {\n        vec2 mousePosition = iMouse.xy / iResolution.xy;\n        mousePosition = (mousePosition * 2.0) - 1.0;\n        mousePosition.x *= iResolution.x / iResolution.y;\n        float d = trapezoid(mousePosition, halfWidth1, halfWidth2, halfHeight);\n        color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.0025, abs(length(position - mousePosition) - abs(d)) - 0.0025));\n    }\n    fragColor = vec4(color, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsy3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 461], [463, 1084, 1139, 1139, 2277]], "test": "untested"}
{"id": "fsyGDw", "name": "大龙猫 - Space Debrit", "author": "totetmatt", "description": "F simple, nothing fancy but don't know, I like it :) ", "tags": ["space"], "likes": 20, "viewed": 325, "published": "Public API", "date": "1631624587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat diam(vec3 p,float s){\n     p = abs(p);\n     return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\nvec2 sdf(vec3 p){\n    p.xz*=rot(iTime*.1);\n    vec2 h;\n    h.x = 1000.+length(p)-1.;\n    vec4 pp = vec4(p,1.);\n    float s = 0.;\n    for(float i=0.;i<=9.;i++){\n        pp.xyz = abs(pp.xyz)-9.95;;\n        pp*=1.7;\n        pp.xz*=rot(.785+i);\n        pp.xy*=rot(-.785+i);\n        float q = (diam(pp.xyz,1.95))/pp.a;\n        h.x = mod(i,2.)==0. ? mix(q,h.x,0.75): min(q,h.x);\n        s+=clamp(cos(pp.y)+sin(pp.x),0.,1.);\n    }\n    s/=pp.a*1.8;\n    h.x = min(length(p)-1.-s,h.x);\n    h.y = 1.;\n    return h;\n}\n\n#define q(s) s*sdf(p+s).x\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define gao(rp,n) (ao(rp,n,.1)+ao(rp,n,.3)+ao(rp,n,.7))\nvec3 norm(vec3 p,float ee){ vec2 e=vec2(-ee,ee) ; return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=.5;\n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rp = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(.1);\n    vec3 light = vec3(1.,2.,-3.);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(d.x <=.001){\n            vec3 n = norm(rp,.0003);\n            float diff =max(0.,dot(normalize(light-rp),n));\n            col = vec3(1.)*diff;\n            col = mix(vec3(.1),col,gao(rp,n)/2.);\n            break;\n        \n        }\n        rp+=rd*d.x;\n    \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [66, 66, 93, 93, 157], [158, 158, 175, 175, 663], [784, 784, 811, 811, 889], [890, 890, 945, 945, 1537]], "test": "untested"}
{"id": "fsyGWD", "name": "Satisfying diamond", "author": "SnoopethDuckDuck", "description": "Sloppy code, dont know how it works, looks okay I think", "tags": ["cool"], "likes": 3, "viewed": 154, "published": "Public API", "date": "1631536700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = 0.04;\n\n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -.5* iResolution.xy) / iResolution.y;\n    float theta = atan(uv.y,uv.x);\n\n    float d = 2. * cos(t) * 0.75 * (abs(uv.x * uv.y) * (1. + 0.1 * cos(2. * theta + t)) + abs(uv.x) + abs(uv.y));\n    \n\n    float r = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    r += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    r *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    t += a;\n    \n    float g = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    g += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    g *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    t -= 2. * a;\n    \n    float b = 0.5 * smoothstep(d + 0.1 * cos(cos(2. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.35 + 0.15 * cos(t));\n    b += 0.5 * smoothstep(d + 0. * cos(cos(1. * theta +  t)), \n                         d + 0.054 + 0.023 * (1. + cos(t)),\n                         0.25 + 0.05 * cos(t));\n    b *= 1. + cos(0.25 * 3.14159 * (cos(5. * theta ) - sin(7. * theta )) + t);\n    \n    \n    \n    //e *= cos(t); //e *= 16. * d * d * (1. - d) * (1.-d);\n    //e = 0.9 * cos(e);\n    // Output to screen\n    fragColor = vec4(g,r,b,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1854]], "test": "untested"}
{"id": "Nd3GWs", "name": "vidya focus rectangle", "author": "vidya", "description": "blurs rectangle", "tags": ["rectangle"], "likes": 0, "viewed": 23, "published": "Public", "date": "1630828530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 red = vec3(1.0, vec2(0.0));\n    \n    float anim = abs(sin(iTime)) * 0.05;\n    \n    vec2 bottom_left = smoothstep(0.1-anim, 0.1+anim, uv);\n    vec2 top_right = 1.0-smoothstep(0.9-anim, 0.9+anim, uv);\n    \n    vec3 col = bottom_left.x * bottom_left.y * top_right.x * top_right.y * red;\n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 427]], "test": "untested"}
{"id": "Nd3Xz4", "name": "Let The Questions Begin!", "author": "Geotale", "description": "From PMD\nCode might seem weird, that's because it was written in Scratch first\nUsed Desmos to get all data, from background colors (or, specifically, how to lerp between them), to getting the long functions for the sine wave patterns\nStill unfinished...", "tags": ["pokemon"], "likes": 2, "viewed": 51, "published": "Public", "date": "1632708289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NATIVEFPS 30.0\n#define NATIVEWIDTH 256.0\n#define NATIVEHEIGHT 192.0\n\n\n#define TYPE 1\n// Types:\n// 0: Rescue Team\n// 1: Explorers\n\n// More attention to detail was put into Explorers', so\n// Rescue Team's background may be inaccurate\n// Even still, I tried to put in as much detail as\n// I could without going replotting and graphing the\n// entire background again.\n\n\n// I'd like to see this on mobile as well\n// It just so happens that Safari doesn't support WebGL2\n// Is anyone suprised, though?\n// If you want better code, uncomment this below line\n//#define WEBGL2\n\nvec3 col = vec3(0.0);\nvec2 uv = vec2(0.0);\n\n#ifdef WEBGL2\n    const vec3 bgCols[] = vec3[](vec3(81, 149, 249) / 255.0, vec3(249, 159, 253) / 255.0, vec3(233, 0, 0) / 255.0, vec3(253, 255, 81) / 255.0, vec3(20, 255, 9) / 255.0, vec3(22, 255, 253) / 255.0, vec3(81, 149, 249) / 255.0);\n    const int bgTimes[] = int[](0, 38, 77, 149, 183, 221, 253);\n#endif\n\nvoid update(float top, float bottom, float adj){\n#if TYPE == 0\n    if(uv.x < top && uv.x > bottom)\n        col = mix(col, vec3(1.0), 1.0 - adj);\n#else\n    if(uv.y < top && uv.y > bottom)\n        col = mix(col, vec3(1.0), 1.0 - adj);\n#endif\n}\n\nvoid renderLine(float bgTop, float bgBottom){\n    update(bgTop, bgBottom, 0.92);\n#if TYPE == 0\n    update(bgTop - 6.0 / NATIVEHEIGHT, bgBottom + 6.0 / NATIVEHEIGHT, 0.91);\n    update(bgTop - 13.0 / NATIVEHEIGHT, bgBottom + 13.0 / NATIVEHEIGHT, 0.93);\n    update(bgTop - 18.0 / NATIVEHEIGHT, bgBottom + 18.0 / NATIVEHEIGHT, 0.91);\n    update(bgTop - 33.0 / NATIVEHEIGHT, bgBottom + 33.0 / NATIVEHEIGHT, 0.90);\n    update(bgTop - 45.0 / NATIVEHEIGHT, bgBottom + 45.0 / NATIVEHEIGHT, 0.90);\n#else\n    update(bgTop - 6.0 / NATIVEWIDTH, bgBottom + 6.0 / NATIVEWIDTH, 0.91);\n    update(bgTop - 13.0 / NATIVEWIDTH, bgBottom + 13.0 / NATIVEWIDTH, 0.93);\n    update(bgTop - 18.0 / NATIVEWIDTH, bgBottom + 18.0 / NATIVEWIDTH, 0.91);\n    update(bgTop - 33.0 / NATIVEWIDTH, bgBottom + 33.0 / NATIVEWIDTH, 0.90);\n    update(bgTop - 45.0 / NATIVEWIDTH, bgBottom + 45.0 / NATIVEWIDTH, 0.90);\n#endif\n}\n\nvoid drawBGBack(float time){\n#if TYPE == 0\n    float x = uv.y / 1.3 - (1.0 / NATIVEHEIGHT) * (time * NATIVEFPS);\n#else\n    float x = uv.x - (1.0 / NATIVEWIDTH) * (time * NATIVEFPS);\n#endif\n\n    float bgTop = (-0.0426433 + 0.0394222 * sin(radians(1902.35 * (x + -27.6116)))) * (2.28179 + 0.0862196 * sin(radians(809.264 * (x + -0.757424)))) + (-0.00474197 + -0.00264045 * sin(radians(1416.44 * (x + 1477.3)))) * (9.38588 + 5.07275 * sin(radians(493.459 * (x + 0.0721132))));\n\n#if TYPE == 0\n    bgTop = 0.9 * (bgTop + 0.5) + 0.5;\n    float bgBottom = bgTop - 0.68;\n#else\n    bgTop++;\n    float bgBottom = bgTop - 0.7093;\n#endif\n\n    renderLine(bgTop, bgBottom);\n}\n\nvoid drawBGFront(float time){\n#if TYPE == 0\n    float x = uv.y / 1.3 + (1.0 / NATIVEHEIGHT) * (time * NATIVEFPS);\n#else\n    float x = uv.x + (1.0 / NATIVEWIDTH) * (time * NATIVEFPS);\n#endif\n\n    float bgTop = (-0.110044 + -0.0397038 * sin(radians(1901.41 * (x + -27.6445)))) * (2.2744 + 0.0124096 * sin(radians(659.047 * (x + -0.289466)))) + (0.00243566 + 0.00133353 * sin(radians(1405.64 * (x + 1488.2)))) * (13.9209 + 7.81294 * sin(radians(458.99 * (x + -0.00861981))));\n\n#if TYPE == 0\n    bgTop = 0.9 * (bgTop + 0.5) + 0.5;\n    float bgBottom = bgTop - 0.531975;\n#else\n    bgTop++;\n    float bgBottom = bgTop - 0.7093;\n#endif\n\n    renderLine(bgTop, bgBottom);\n}\n\nvoid initBG(float time){\n    float bgTime = mod(NATIVEFPS * time, 253.0);\n\n#ifdef WEBGL2\n    int bgTimeInt = int(bgTime);\n    int bgItem = 0;\n\n    while(bgTimes[bgItem] <= bgTimeInt)\n        bgItem++;\n    bgItem--;\n    \n    float bgLerp = (bgTime - float(bgTimes[bgItem])) / (float(bgTimes[bgItem + 1] - bgTimes[bgItem]));\n    col = mix(bgCols[bgItem], bgCols[bgItem + 1], bgLerp);\n#else\n    vec3 bgCol = vec3(81, 149, 249) / 255.0;\n    vec3 nextCol = vec3(249, 159, 253) / 255.0;\n\n    float closeTime = 0.0;\n    float nextTime = 38.0;\n\n    if(bgTime > 38.0){\n        bgCol = nextCol;\n        closeTime = nextTime;\n        nextTime = 77.0;\n        nextCol = vec3(233, 0, 0) / 255.0;\n        if(bgTime > 77.0){\n            bgCol = nextCol;\n            closeTime = nextTime;\n            nextTime = 149.0;\n            nextCol = vec3(253, 255, 81) / 255.0;\n            if(bgTime > 149.0){\n                bgCol = nextCol;\n                closeTime = nextTime;\n                nextTime = 183.0;\n                nextCol = vec3(20, 255, 9) / 255.0;\n                if(bgTime > 183.0){\n                    bgCol = nextCol;\n                    closeTime = nextTime;\n                    nextTime = 221.0;\n                    nextCol = vec3(22, 255, 253) / 255.0;\n                    if(bgTime > 221.0){\n                        bgCol = nextCol;\n                        closeTime = nextTime;\n                        nextTime = 253.0;\n                        nextCol = vec3(81, 149, 249) / 255.0;\n                    }\n                }\n            }\n        }\n    }\n\n    float bgLerp = (bgTime - closeTime) / (nextTime - closeTime);\n    col = mix(bgCol, nextCol, bgLerp);\n#endif\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    uv = fragCoord / iResolution.xy;\n\n#if TYPE == 0\n    initBG(iTime + 6.1);\n    drawBGBack(iTime + 6.1);\n    drawBGFront(iTime + 6.1);\n#else\n    initBG(iTime + 2.5);\n    drawBGBack(iTime + 2.5);\n    drawBGFront(iTime + 2.5);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3Xz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 932, 980, 980, 1173], [1175, 1175, 1220, 1220, 2060], [2062, 2062, 2090, 2090, 2723], [2725, 2725, 2754, 2754, 3389], [3391, 3391, 3415, 3415, 5059], [5062, 5062, 5116, 5116, 5384]], "test": "untested"}
{"id": "Nd3XzM", "name": "point-in-triangle", "author": "Arthas_me", "description": "Determine if a point is in a triangle.", "tags": ["sdf"], "likes": 1, "viewed": 116, "published": "Public API", "date": "1632820542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 n) {\n    return length((p - a) - dot((p - a), n) * n);\n}\n\n\nbool pointInTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    return cross(b - a, p - a).z > 0. &&\n        cross(c - b, p - b).z > 0. &&\n        cross(a - c, p - c).z > 0.;\n}\n\n\nvec2 lineIntersection(in vec2 p1, in vec2 n1, in vec2 p2, in vec2 n2) {\n  float a = n1[1] / (n1[0] + 1e-10);\n  float c = p1[1] - a * p1[0];\n\n  float b = n2[1] / (n2[0] + 1e-10);\n  float d = p2[1] - b * p2[0];\n\n  float x = (d - c) / (a - b);\n  float y = a * x + c;\n\n  return vec2(x, y);\n}\n\n\nfloat N = sqrt(0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y; // -1 <> 1 by height\n\n    float r = 0.01;\n\n    vec2 a1 = vec2(0.7, 0.), n1 = vec2(N, N);\n    vec2 a2 = vec2(0.7, 0.), n2 = vec2(-N, N);\n    vec2 a3 = vec2(0., 0.), n3 = vec2(sin(iTime) , cos(iTime));\n    \n\n    float c = sdLine(p, a1, n1) - r;\n    c = min(c, sdLine(p, a2, n2) - r);\n    c = min(c, sdLine(p, a3, n3) - r);\n    \n    \n    vec3 A = vec3(lineIntersection(a3, n3, a1, n1), 0.);\n    vec3 B = vec3(lineIntersection(a1, n1, a2, n2), 0.);\n    vec3 C = vec3(lineIntersection(a3, n3, a2, n2), 0.);\n\n    float x = pointInTriangle(vec3(p, 0.), A, B, C) && c > 0.08 ? 1. : 0.;\n    c = step(c, 0.02);\n    c = max(c, x);\n    c *= (1. - pow(length(p), 2.));\n\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3XzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 49, 49, 101], [104, 104, 170, 170, 287], [290, 290, 361, 361, 577], [602, 602, 659, 659, 1459]], "test": "untested"}
{"id": "Ndc3Ws", "name": "vidya flashing circles", "author": "vidya", "description": "animate circles using blue effect", "tags": ["circle", "flashing"], "likes": 0, "viewed": 36, "published": "Public", "date": "1630837577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 circle(float aspect, vec2 uv, float radius, vec3 color, float blur, float animSpeed, vec2 pos) {\n    float anim = abs(sin(iTime*animSpeed))*blur;\n    vec3 result = vec3(smoothstep(radius-anim, radius+anim, distance(uv, vec2(pos.x*aspect, pos.y))));\n    result = (1.0-result) * color;\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n\n    vec3 c1 = circle(aspect, uv, 0.2, red, 0.31, 4.1, vec2(0.81, 0.7));\n    \n    vec3 c2 = circle(aspect, uv, 0.15, green, 0.05, 1.0, vec2(0.12, 0.21));\n    \n    vec3 c3 = circle(aspect, uv, 0.23, blue, 0.03, 2.1, vec2(0.58, 0.3));\n    \n    vec3 c4 = circle(aspect, uv, 0.1, yellow, 0.1, 1.1, vec2(0.3, 0.5));\n\n    vec3 col = c1 + c2 + c3 + c4;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 101, 101, 309], [313, 313, 370, 420, 1088]], "test": "untested"}
{"id": "Ndc3zl", "name": "up in the cloud sea", "author": "mdb", "description": "test of rendering different layers with parallax", "tags": ["cloud", "parallax", "art", "train", "colorpalette", "stylised"], "likes": 124, "viewed": 1437, "published": "Public API", "date": "1630447622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 p = floor(x);\n\tfloat a = texture(iChannel0, (p+vec2(0.0, 0.0))/1024.0).x;\n\tfloat b = texture(iChannel0, (p+vec2(1.0,0.0))/1024.0).x;\n\tfloat c = texture(iChannel0, (p+vec2(0.0,1.0))/1024.0).x;\n\tfloat d = texture(iChannel0, (p+vec2(1.0,1.0))/1024.0).x;\n\n    \n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nfloat fbm(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.7;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\nfloat fbm2(vec2 x, int detail){\n    float a = 0.0;\n    float b = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < detail; i++){\n        float n = noise(x);\n        a += b*n;\n        t += b;\n        b *= 0.9;\n        x *= 2.0; \n    \n    }\n    return a/t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    //uv.x += iTime;\n    vec3 col = vec3(0.58, 0.7, 1.0);\n    \n    // clouds ///////////////////////////////////////////////////////\n    float midlevel;\n    float h;\n    float disp;\n    float dist;\n    float t = iTime*4.0;\n    vec2 uv2;\n    \n    // c1\n    midlevel = 1.0;\n    disp = 5.0;\n    dist = 100.0;\n    uv2 = uv + vec2(t/dist + 3.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.94, 0.91);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.92, 0.85, 0.82);\n    \n    // c2\n    midlevel = 0.9;\n    disp = 3.0;\n    dist = 70.0;\n    uv2 = uv + vec2(t/dist + 7.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.74, 0.35, 0.30);\n    if(uv.y < h + midlevel - 0.05) col = vec3(0.60, 0.30, 0.27);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.56, 0.25, 0.22);\n    \n    // c3\n    midlevel = 0.8;\n    disp = 2.7;\n    dist = 60.0;\n    uv2 = uv + vec2(t/dist + 9.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.76, 0.60);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.93, 0.58, 0.35);\n    \n    // c4\n    midlevel = 0.7;\n    disp = 2.7;\n    dist = 50.0;\n    uv2 = uv + vec2(t/dist + 12.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.80, 0.40, 0.34);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.73, 0.36, 0.30);\n    \n    // c5\n    midlevel = 0.75;\n    disp = 3.5;\n    dist = 45.0;\n    uv2 = uv + vec2(t/dist + 15.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.62, 0.44);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.90, 0.55, 0.40);\n    if(uv.y < h + midlevel - 0.15) col = vec3(0.98, 0.50, 0.24);\n    if(uv.y < h + midlevel - 0.2) col = vec3(1.0, 0.55, 0.33);\n    \n    // c6\n    midlevel = 0.6;\n    disp = 2.0;\n    dist = 40.0;\n    uv2 = uv + vec2(t/dist + 18.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.76, 0.60);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.95, 0.66, 0.48);\n    \n    // c7\n    midlevel = 0.5;\n    disp = 2.5;\n    dist = 35.0;\n    uv2 = uv + vec2(t/dist + 18.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.48, 0.35);\n    if(uv.y < h + midlevel - 0.05) col = vec3(0.98, 0.42, 0.28);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.88, 0.38, 0.24);\n    \n    // c8\n    midlevel = 0.5;\n    disp = 2.3;\n    dist = 30.0;\n    uv2 = uv + vec2(t/dist + 20.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.99, 0.29, 0.20);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.80, 0.24, 0.17);\n    if(uv.y < h + midlevel - 0.08) col = vec3(0.53, 0.35, 0.32);\n    if(uv.y < h + midlevel - 0.12) col = vec3(0.41, 0.27, 0.27);\n    \n    // c9\n    midlevel = 0.45;\n    disp = 2.0;\n    dist = 25.0;\n    uv2 = uv + vec2(t/dist + 23.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(1.0, 0.62, 0.44);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.98, 0.57, 0.36);\n    \n    // c10\n    midlevel = 0.35;\n    disp = 3.5;\n    dist = 20.0;\n    uv2 = uv + vec2(t/dist + 27.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.77, 0.48, 0.46);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.66, 0.42, 0.40);\n    if(uv.y < h + midlevel - 0.08) col = vec3(0.55, 0.42, 0.41);\n    if(uv.y < h + midlevel - 0.12) col = vec3(0.43, 0.32, 0.31);\n    \n    // c11\n    midlevel = 0.35;\n    disp = 1.0;\n    dist = 15.0;\n    uv2 = uv + vec2(t/dist + 30.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.95, 0.80, 0.77);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.98, 0.76, 0.64);\n    \n    // c12\n    midlevel = 0.3;\n    disp = 0.9;\n    dist = 10.0;\n    uv2 = uv + vec2(t/dist + 32.5, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.95, 0.45, 0.30);\n    if(uv.y < h + midlevel - 0.07) col = vec3(0.88, 0.38, 0.24);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.68, 0.28, 0.19);\n    if(uv.y < h + midlevel - 0.14) col = vec3(0.48, 0.19, 0.20);\n    \n    \n    \n    // train /////////////////////////////////////////////////////////////////////\n    float k;\n    uv.y -= 0.2;\n    // choo choo\n    k = 1.0;\n    uv2 = fract(uv*9.0);\n    float wagon = 1.0;\n    wagon *= 1.0 - step(0.45, uv.x);\n    wagon *= 1.0 - step(0.115, uv.y);\n    wagon *= step(0.103, uv.y);\n    wagon *= step(0.05, 1.0 - abs(uv2.x*2.0 - 1.0));\n    \n    float join = 1.0; \n    join *= 1.0 - step(0.45, uv.x);\n    join *= 1.0 - step(0.11, uv.y);\n    join *= step(0.107, uv.y);\n    \n    \n    float roof = 1.0;\n    roof *= 1.0 - step(0.45, uv.x);\n    roof *= 1.0 - step(0.117, uv.y);\n    roof *= step(0.11, uv.y);\n    roof *= step(0.15, 1.0 - abs(uv2.x*2.0 - 1.0));\n    \n    float loco = 1.0;\n    loco *= 1.0 - step(0.5, uv.x);\n    loco *= step(0.45, uv.x);\n    loco *= 1.0 - step(0.112, uv.y);\n    loco *= step(0.103, uv.y);\n    \n    float chem1 = 1.0;\n    chem1 *= 1.0 - step(0.495, uv.x);\n    chem1 *= step(0.49, uv.x);\n    chem1 *= 1.0 - step(0.12, uv.y);\n    chem1 *= step(0.103, uv.y);\n    \n    float chem2 = 1.0;\n    chem2 *= 1.0 - step(0.496, uv.x);\n    chem2 *= step(0.488, uv.x);\n    chem2 *= 1.0 - step(0.123, uv.y);\n    chem2 *= step(0.12, uv.y);\n    \n    float locoRoof = 1.0;\n    locoRoof *= 1.0 - step(0.47, uv.x);\n    locoRoof *= step(0.443, uv.x);\n    locoRoof *= 1.0 - step(0.117, uv.y);\n    locoRoof *= step(0.11, uv.y);\n    \n    \n    \n    col = mix(col, vec3(0.18, 0.12, 0.15), join);\n    col =  mix(col, vec3(0.48, 0.19, 0.20), wagon);\n    col = mix(col, vec3(0.18, 0.12, 0.15), roof);\n    \n    col = mix(col, vec3(0.38, 0.19, 0.20), loco);\n    col = mix(col, vec3(0.38, 0.19, 0.20), chem1);\n    col = mix(col, vec3(0.18, 0.12, 0.15), locoRoof);\n    col = mix(col, vec3(0.18, 0.12, 0.15), chem2);\n    // loco smoke //////\n    \n    dist = 5.0;\n    uv2 = uv + vec2(t/dist + 3.5, 0.0);\n    uv2.x -= t/dist*0.2;\n    h = fbm2(uv2, 8) - 0.55;\n    \n    if(uv.x < 0.49){\n        float x = -uv.x + 0.49;\n        float y = abs(uv.y + h*0.4 - 0.16*sqrt(x) - 0.12) - 0.8*x*exp(-x*10.0);\n        if(y < 0.0) col = vec3(1.0, 0.94, 0.91);\n        if(y < - 0.02) col = vec3(0.92, 0.85, 0.82);\n    }\n    \n    //bridge ///////\n    dist = 5.0;\n    uv2 = uv + vec2(t/dist + 32.5, 0.0);\n    uv2.x = fract(uv2.x*3.0);\n    k = 1.0;\n    k *= smoothstep(0.001, 0.003, abs(uv2.y - pow(uv2.x - 0.5, 2.0)*0.15 - 0.12));\n    k *= min(step(0.05, 1.0 - abs(uv2.x*2.0 - 1.0))\n         +   step(0.17, uv2.y), 1.0);\n    k *= min(smoothstep(0.02, 0.05, 1.0 - abs(uv2.x*2.0 - 1.0))\n         +   step(0.177, uv2.y), 1.0);\n         \n    k *= min(step(0.1, uv2.y)\n           + smoothstep(-0.09, -0.085, -uv2.y - 0.001/(1.0 - abs(uv2.x*2.0 - 1.0))), 1.0);\n           \n    k *= min(smoothstep(0.05, 0.3, 1.0 - abs(fract(uv2.x*16.0)*2.0 - 1.0))\n         +   step(0.12, uv2.y - pow(uv2.x - 0.5, 2.0)*0.15)\n         +   step(-0.1, -uv2.y), 1.0);\n    col = mix(vec3(0.29, 0.09, 0.08), col, k);\n    \n    \n    \n    // clouds foreground //////////////////////////////////////////////////////////////\n    // c13\n    midlevel = 0.05;\n    disp = 1.7;\n    dist = 4.0;\n    uv2 = uv + vec2(t/dist + 38.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.95, 0.80, 0.77);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.98, 0.76, 0.64);\n    if(uv.y < h + midlevel - 0.1) col = vec3(0.95, 0.66, 0.48);\n    \n    // c14\n    midlevel = -0.1;\n    disp = 1.7;\n    dist = 2.0;\n    uv2 = uv + vec2(t/dist + 40.0, 0.0);\n    h = (fbm(uv2, 8) - 0.5)*disp;\n    if(uv.y < h + midlevel) col = vec3(0.77, 0.48, 0.46);\n    if(uv.y < h + midlevel - 0.04) col = vec3(0.66, 0.42, 0.40);\n    if(uv.y < h + midlevel - 0.08) col = vec3(0.55, 0.42, 0.41);\n    if(uv.y < h + midlevel - 0.12) col = vec3(0.43, 0.32, 0.31);\n    \n\n    // Output to screen\n    uv = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.3 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3zl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 447], [449, 449, 479, 479, 701], [703, 703, 734, 734, 956], [959, 959, 1016, 1016, 9007]], "test": "untested"}
{"id": "NdcGDj", "name": "Abstractions", "author": "Tater", "description": "A shader for sableraph's weekly creative code challenge, theme was \"architecture\".\n\nIt's a little bit artifacty but the AA sorta covers it up.\n\nSpin with mouse", "tags": ["3d", "raymarching", "abstract", "architecture"], "likes": 21, "viewed": 243, "published": "Public API", "date": "1630637840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 150.0\n#define MDIST 100.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvec3 rdg = vec3(0);\nfloat h21(vec2 p){\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\nfloat h13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*-tan(5.0*pi/6.0);\n}\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nbool filled(vec3 id){\n    if(id.y<0.) return true;\n    float cyc = floor(iTime*0.15);\n    float hash = h13(id+cyc);\n    cyc = mod(cyc,3.0);\n    //I had to do this uglyness because compiler keeps tryning to inline everything\n    //(this saves like 2 seconds of compile time)\n    float w1 = max(abs(id.x),abs(id.z));\n    float w2 = length(id.y*id.y);\n    float w3 = 0.3;\n    if(cyc==0.0) w1 = length(id.xz);\n    if(cyc==2.0) {w2 = abs(id.y);w3 = 0.4; }\n    return(hash+w1*w3+w2*0.01<0.85);\n}\nvec2 map(vec3 p){\n    float t = iTime;\n    vec3 po = p;\n    vec2 a = vec2(9999.,1);\n    vec2 b = vec2(2);\n    \n    vec3 id = floor(p);\n    //float hash = h13(id+floor(t*0.1));\n    vec3 dir = sign(rdg)*.5;\n    vec3 q = fract(p)-.5;\n    //q = vec3(q.x,q.y,q.z);\n    vec3 rc = (dir-q)/rdg;\n\n    float dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    bool ifilled = filled(id);\n    if(max(id.x,id.z)<5.0){\n        if(ifilled)a.x = box(q,vec3(0.5));\n        float nbors = 0.;\n        vec3 off = vec3(0);\n        if(filled(id+vec3(1,0,0))){nbors++;off+=vec3(1,0,0);}\n        if(filled(id+vec3(0,1,0))){nbors++;off+=vec3(0,1,0);}\n        if(filled(id+vec3(0,0,1))){nbors++;off+=vec3(0,0,1);}\n        if(filled(id+vec3(-1,0,0))){nbors++;off+=vec3(-1,0,0);}\n        if(filled(id+vec3(0,-1,0))){nbors++;off+=vec3(0,-1,0);}\n        if(filled(id+vec3(0,0,-1))){nbors++;off+=vec3(0,0,-1);}\n        if(nbors==3.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.)*0.6);\n        float hh = h13(id+floor(iTime*0.15));\n        if(nbors==2.0&&!ifilled&&hh>0.33){\n            vec3 p2 = q+off*0.71;\n            p2.xy*=rot((1.0-abs(off.z))*pi/4.);\n            p2.yz*=rot((1.0-abs(off.x))*pi/4.);\n            p2.zx*=rot((1.0-abs(off.y))*pi/4.);\n            float cut = box(p2,vec3(1.0));\n            a.x = max(box(q,vec3(0.5)),-cut*0.6)*0.7;\n        }\n        else if(hh>0.26&&nbors==2.0&&!ifilled)a.x = max(box(q,vec3(0.5)),-(length(q+off*0.5)-1.1)*0.6);\n        \n        if(nbors==2.0&&!ifilled&&off==vec3(0))a.x = box(q,vec3(0.5));\n       // if(nbors==3.0&&!ifilled)a.x = box(q,vec3(0.5));\n    }\n    b.x = p.y;\n    a=(a.x<b.x)?a:b;\n    dc = max(dc,box(po,vec3(4,50,4)));\n    a.x = min(a.x,dc);\n    \n    return a;\n}\nvec3 norm(vec3 p,float s){\n    vec2 e = vec2(s,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,6,-13);\n    if(iMouse.z>0.){\n    ro.xz*=rot(10.0*iMouse.x/iResolution.x);\n    }\n    else ro.xz*=rot(iTime*0.3);\n\n    vec3 lk = vec3(0,3.5,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.1+uv.x*r+uv.y*cross(f,r);\n    rdg = rd;\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO= 0., shad = 0.;\n    bool hit = false;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if((d.x)<0.005){\n            hit = true;\n            shad = i/STEPS;\n            break;\n        }\n        if(dO>MDIST){\n            break;\n        }\n    }\n    if(hit){\n        vec3 ld = normalize(vec3(0.5,1.01,-1));\n        //ld.xz*=rot(iTime*0.3);\n        vec3 n = norm(p,0.001);\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),5.0);\n        //float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n        float diff = dot(n, ld)*0.4+0.6;\n        vec3 al = vec3(1);\n        ld.xy*=rot(h21(uv)*0.005);\n        ld.yz*=rot(h21(uv+1.)*0.005);\n        ld.zx*=rot(h21(uv+2.)*0.005);\n        float shadow = 1.;\n        rdg = ld;\n        for(float h = 0.05; h<20.;){\n            float dd = map(p+ld*h).x;\n            if(dd<0.001){shadow = 0.6; break;}\n            h+=dd;\n        }\n        //shadow = max(shadow,0.8);\n        \n        //AO & soft shadow doesn't work because of the domain rep tricks, oh well\n        \n        diff -=(h21(uv)-0.4)*(pow(1.0-diff*shadow,9.0))*4.0;\n        col=al*diff+pow(spec,2.0)*0.1*shadow;\n        col*=shadow;\n    }\n    else{\n    col = mix(vec3(0.6),vec3(0.647,0.647,0.694),uv.y);\n    }\n    //col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}\n\n//if you have a very good GPU you can crank up the AA and it looks a lot better\n#if HW_PERFORMANCE==0\n#define AA 1.0\n#else\n#define AA 2.0 \n#endif\n\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 152, 152, 218], [219, 219, 238, 238, 341], [342, 342, 371, 371, 430], [431, 431, 457, 457, 515], [516, 516, 537, 537, 1005], [1006, 1006, 1023, 1023, 2702], [2703, 2703, 2729, 2729, 2853], [2854, 2854, 2907, 2907, 4689], [4691, 4866, 4923, 4923, 5337]], "test": "untested"}
{"id": "Ndd3DB", "name": "Ray Marching Test Part 4", "author": "dcyang", "description": "ray marching: and or eor sub", "tags": ["raymarching"], "likes": 0, "viewed": 100, "published": "Public API", "date": "1630595580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEP = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n/* 交*/\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/* 并*/\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/* 差*/\nfloat subtractSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n/* 异或*/\nfloat eorSDF(float distA, float distB) {\n    return subtractSDF(unionSDF(distA,distB),intersectSDF(distA,distB));\n}\n/* 圆柱的SDF*/\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n/* 一个立方体的SDF */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/* 一个球的SDF */\nfloat sphereSDF(vec3 samplePoint){\n    return length(samplePoint) - 1.414;\n}\n\n/* 场景的SDF，为球和立方体的交集 */\nfloat sceneSDF(vec3 samplePoint){\n    float res = subtractSDF(intersectSDF(sphereSDF(samplePoint),cubeSDF(samplePoint)),cylinderSDF(samplePoint,4.0,0.5));\n    return res;\n}\n\n/* 从眼睛朝某一方向，发出光线，直到击中场景表面，之间的距离 */\nfloat shortestDistanceFromEyeToSurface(vec3 eye, vec3 rayDirection, float start, float end){\n    float depth = start;\n    for(int i = 0; i < MAX_STEP;i++){\n        float dist = sceneSDF(eye+depth*rayDirection);\n        if(dist < EPSILON) \n            return depth;\n        else \n            depth += dist;\n        if(depth >=end)\n           return end;\n            \n    }\n    return end;\n}\n/* 根据视场角以及视口的尺寸，生成到每一个像素的光线方向 */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/* 根据SDF的梯度来估计法线方向 \n   p 点在SDF表面，n = (dp/dx,dp/dy,dp/dz)\n\n*/\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n/* 计算 Phong 光照 c = c_r(c_a + c_l*max(0.0,dot(N,L)) + c_l*c_p*pow(max(0.0,dot(R,E)),s))\n*/\nvec3 PhongLight(vec3 c_r, vec3 c_a, vec3 c_p, vec3 c_l,vec3 eye, vec3 p_l, vec3 p, float s){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(p_l - p);\n    vec3 E = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotNL = max(0.0,dot(N,L));\n    float dotRE = max(0.0,dot(R,E));\n    vec3 c = c_r*(c_a + c_l*dotNL + c_l*c_p*pow(dotRE,s));\n    return c;\n}\n/* 计算光照，在这个函数设定光源参数，然后调用 PhongLight 计算光照\n*/\nvec3 illumination(vec3 c_r, vec3 c_a, vec3 c_p, vec3 eye, vec3 p, float s) {\n    vec3 c_l = vec3(1.0);\n    vec3 p_l = vec3(4.0 * sin(iTime),\n                          1.0,\n                          4.0 * cos(iTime));\n    vec3 color = PhongLight(c_r,c_a,c_p,c_l,eye,p_l,p,s);    \n    return color;\n}\n/* 摄像机的旋转矩阵 */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 v = normalize(eye - center);\n    vec3 r = normalize(cross(up,v));\n    vec3 u = cross(v,r);\n    vec3 t = vec3(-dot(eye,r),-dot(eye,u),-dot(eye,v));\n    return mat4(\n        vec4(r,t.x),\n        vec4(u,t.y),\n        vec4(v,t.z),\n        vec4(0.0,0.0,0.0,1.0)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0, 5.0, 5.0);\n    mat4 rotateMatrix = viewMatrix(eye,vec3(0.0),vec3(0.0,1.0,0.0));\n    vec3 worldDir = (rotateMatrix*vec4(viewDir,0.0)).xyz;\n    float dist = shortestDistanceFromEyeToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 c_r = vec3(0.0, 1.0, 1.0);\n    vec3 c_a = vec3(0.2, 0.2, 0.2);\n    vec3 c_p = vec3(1.0, 1.0, 1.0);\n    float s = 5.0;\n    \n    vec3 color =  illumination(c_r, c_a, c_p, eye, p, s);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 122, 168, 168, 200], [202, 211, 253, 253, 285], [287, 296, 341, 341, 374], [375, 387, 427, 427, 502], [503, 521, 566, 635, 1241], [1242, 1270, 1293, 1444, 1881], [1883, 1905, 1939, 1939, 1981], [1983, 2032, 2065, 2065, 2204], [2206, 2297, 2389, 2389, 2686], [2687, 2772, 2837, 2837, 2969], [2971, 3066, 3095, 3095, 3405], [3406, 3504, 3596, 3596, 3888], [3889, 3983, 4059, 4059, 4281], [4282, 4313, 4362, 4362, 4637], [4638, 4638, 4695, 4695, 5386]], "test": "untested"}
{"id": "NddGzs", "name": "Pseudo Hyper Hexagonest", "author": "pdkl95", "description": "A shader in the style of the \"Hyper Hexagonest\" level from Terry Cavanagh's wonderful game Super Hexagon.\n\n(the screen spinning is unfortunately a not-very-accurate hack :(  ~sigh~ )", "tags": ["hexagon", "superhexagon", "hyperhexagonest"], "likes": 5, "viewed": 62, "published": "Public", "date": "1630502984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*****************************************\n * Pseudo-Super-Hexagon (ver: 1.1, 2020) *\n *    shader by PDKL95                   *\n *                                       *\n * (with apologies to Terry Cavanagh)    *\n *****************************************/\n\n\n#define TAU 6.283185307179586\n\n#define NSEC 6*\n#define SPINRATE 3.0\n#define DEPTHRATE 10.0\n#define DEPTHSCALE 10.0\n#define INNERWALLSIZE 0.01\n#define INNERRADIUS 0.2\n#define INNERBEATSIZE 0.01\n#define INNERBEATRATE 6.0\n\n#define COLORSPEED 1.8\n\n#define COLOR_1_FG  vec3(0.96, 0.96, 0.96)\n#define COLOR_1_BG1 vec3(0.67, 0.67, 0.67)\n#define COLOR_1_BG2 vec3(0.53, 0.53, 0.53)\n#define COLOR_2_FG  vec3(0.93, 0.93, 0.93)\n#define COLOR_2_BG1 vec3(0.44, 0.44, 0.44)\n#define COLOR_2_BG2 vec3(0.35, 0.35, 0.35)\n\n#define nsin(x) ((sin(x) + 1.0) / 2.0)\n\n#define NUMWALLS 128\n\nconst int BIT_COUNT = 8;\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a = a / 2;\n        b = b / 2;\n        n = n * 2;\n\n        if(!(a > 0 && b > 0)) {\n            break;\n        }\n    }\n    return result;\n}\n\nvec3 rgb2hsv(in vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 point, in float rads)\n{\n    float cs = cos(rads);\n    float sn = sin(rads);\n    return point * mat2(cs, -sn, sn, cs);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float px = 1.0/iResolution.y;\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = (uv * 2.0) - 1.0;\n\n    if (aspect < 1.0) {\n        aspect = 1.0/aspect;\n        position.x *= aspect;\n    } else {\n        position.y *= aspect;\n    }\n\n    float spintime = iTime * SPINRATE;\n    spintime = (0.4 * spintime) + sin(0.7 * spintime) + sin(0.2 * spintime);\n    float spin = mod(spintime, TAU);\n\n    float realdepth = iTime * DEPTHRATE;\n\n    vec2 rposition = rotate(position, spin);\n\n#if 0\n    const mat3 proj_matrix = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(    0.0, 3.0/4.0, 0.0),\n        vec3(    0.0, 0.0, 0.5)\n    );\n\n    float r3d_theta_x = (TAU/12.0) * sin(iTime * 2.0);\n    float r3d_sintx = sin(r3d_theta_x);\n    float r3d_costx = cos(r3d_theta_x);\n    mat3 rotx_matrix = mat3(\n        vec3(1.0,        0.0,       0.0),\n        vec3(0.0,  r3d_costx, r3d_sintx),\n        vec3(0.0, -r3d_sintx, r3d_costx)\n    );\n\n    float r3d_theta_y = (TAU/16.0) * sin(iTime * 0.4);\n    float r3d_sinty = sin(r3d_theta_y);\n    float r3d_costy = cos(r3d_theta_y);\n    mat3 roty_matrix = mat3(\n        vec3( r3d_costy, 0.0, r3d_sinty),\n        vec3(       0.0, 1.0,       0.0),\n        vec3(-r3d_sinty, 0.0, r3d_costy)\n    );\n\n    vec3 pos3 = vec3(rposition.xy, 0.0);\n    vec3 proj_pos = proj_matrix * pos3;\n    float perspective_factor = proj_pos.z * 0.5 + 1.0;\n    rposition = proj_pos.xy/perspective_factor;\n#endif\n\n    float r = length(rposition);\n    float theta = atan(rposition.y, rposition.x);\n    theta += TAU/2.0;\n    float section = 6.0 * (theta/TAU);\n    float zone = floor(section);\n    float zonefrag = mod(section, 1.0);\n    float odd  = mod(zone, 2.0);\n\n    float color_fade = nsin(iTime * COLORSPEED);\n    vec3 color_fg  = mix(COLOR_1_FG,  COLOR_2_FG,  color_fade);\n    vec3 color_bg1 = mix(COLOR_1_BG1, COLOR_2_BG1, color_fade);\n    vec3 color_bg2 = mix(COLOR_1_BG2, COLOR_2_BG2, color_fade);\n\n    vec3 color = mix(color_bg1, color_bg2, odd);\n\n    float dist_to_edge = abs(zonefrag - 0.5) * 2.0;\n    float angle_to_edge = dist_to_edge * (TAU / 12.0);\n\n    float hexradius = cos(TAU - angle_to_edge) * r;\n    float depth = (hexradius * DEPTHSCALE) + realdepth;\n\n    float ib = INNERBEATRATE * iTime;\n    float ir = 2.1 +\n        (3.0 * sin(ib)) +\n        (4.0 * cos(ib)) -\n        (      sin(ib * 2.0)) -\n        (2.1 * cos(ib * 2.0));\n    ir = INNERRADIUS - (INNERBEATSIZE * abs(ir));\n\n    if (hexradius < ir) {\n        if ((ir - hexradius) < INNERWALLSIZE) {\n            color = color_fg;\n        }\n    } else {\n        // float row = floor(depth);\n        // float oddrow = mod(row, 2.0);\n        // color = mix(color_fg, color, oddrow);\n\n        float moddepth = floor(mod(depth, 128.0));\n        int wallidx = int(moddepth);\n\n#define wall(idx, val) if (wallidx == (idx)) { curwall = (val); } else\n\n#define MAXWALL 126\n\tint curwall = 0;\n        if (wallidx < MAXWALL) {\n\t    if (wallidx < 37) {\n\t\tif (wallidx < 19) {\n\t\t    wall( 1, 0x2a)\n        \t    wall( 4, 0x15)\n        \t    wall( 7, 0x2a)\n        \t    wall(10, 0x15)\n        \t    wall(13, 0x2a)\n        \t    wall(16, 0x1b)\n\t\t    {}\n\t\t} else {\n        \t    wall(19, 0x2d)\n        \t    wall(22, 0x36)\n\t\t    wall(25, 0x2d)\n        \t    wall(28, 0x1b)\n        \t    wall(31, 0x36)\n        \t    wall(34, 0x2f)\n\t\t    {}\n\t\t}\n\t    } else if (wallidx < 67) {\n\t\tif (wallidx < 53) {\n\t\t    wall(37, 0x1b)\n        \t    wall(38, 0x09)\n        \t    wall(39, 0x24)\n        \t    wall(40, 0x12)\n        \t    wall(41, 0x09)\n        \t    wall(42, 0x24)\n        \t    wall(43, 0x12)\n        \t    wall(44, 0x09)\n        \t    wall(45, 0x2d)\n        \t    wall(50, 0x3e)\n\t\t    {}\n\t        } else {\n\t\t    wall(53, 0x1b)\n        \t    wall(54, 0x12)\n        \t    wall(55, 0x24)\n        \t    wall(56, 0x09)\n        \t    wall(57, 0x12)\n        \t    wall(58, 0x24)\n        \t    wall(59, 0x09)\n        \t    wall(60, 0x12)\n        \t    wall(61, 0x36)\n\t\t    {}\n\t\t}\n\t    } else {\n\t\tif (wallidx < 104) {\n\t\t    wall(67, 0x1f)\n        \t    wall(72, 0x3b)\n        \t    wall(77, 0x1f)\n        \t    wall(83, 0x1f)\n        \t    wall(88, 0x3b)\n        \t    wall(93, 0x2f)\n        \t    wall(99, 0x1f)\n\t\t    {}\n\t\t} else {\n\t\t    wall(104, 0x3b)\n        \t    wall(109, 0x3e)\n        \t    wall(114, 0x2a)\n        \t    wall(116, 0x2a)\n        \t    wall(120, 0x1f)\n        \t    wall(125, 0x2f)\n\t\t    {}\n\t\t}\n\t    }\n        }\n\n\t\n\tint mask = 1;\n\tint izone = int(zone);\n#define zmask(z,m) if (izone == z) {mask = m; } else\n\tzmask(1, 2)\n\tzmask(2, 4)\n\tzmask(3, 8)\n\tzmask(4, 16)\n\tzmask(5, 32)\n\t{}\n\n\tcurwall = and(curwall, mask);\n        if (curwall > 0) {\n            color = color_fg;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 852, 876, 876, 906], [908, 908, 931, 931, 1244], [1246, 1246, 1271, 1271, 1602], [1604, 1604, 1629, 1629, 1798], [1800, 1800, 1843, 1843, 1939], [1941, 1941, 1996, 1996, 6707]], "test": "untested"}
{"id": "NddXRn", "name": "Geometric Altar", "author": "Flopine", "description": "Trying the clean domain repetition presenting by Blackle on Perfect Pistons <3\nhttps://youtu.be/I8fmkLK1OKg\nhttps://www.shadertoy.com/view/WtXcWB", "tags": ["raymarching", "repetition", "animation", "isometric"], "likes": 24, "viewed": 224, "published": "Public", "date": "1632499747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n\n// Trying the clean domain repetition \n// presenting by Blackle on Perfect Pistons <3\n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n#define PI acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x<0.)?-1.:1., 0.);\n    else return vec2(0., (p.y<0.)?-1.:1.);\n}\n\nfloat box (vec3 p , vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\n\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 center = floor(p.xz)+.5;\n    vec2 neighbour = center + edge(p.xz-center);    \n    float py = sin(length(center)+iTime)*1.5;\n    \n    float me = box(p-vec3(center.x, 0., center.y), vec3(.4,2.+py,.4))-.05;\n    float next = box(p-vec3(neighbour.x, 0., neighbour.y), vec3(.4, 3.5, .4))-.05;\n    float set = min(me,next);\n    \n    return set;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv*3.,-30.), rd=vec3(0.,0.1,1.),p=ro,\n    col=vec3(0.),l=normalize(vec3(1.,2.,-2.));\n\n    bool hit=false;\n    for (float i=0.; i<100.; i++)\n    {\n        float d= SDF(p);\n        if (d<0.001)\n        {hit=true;break;}\n        p += d*rd;\n    }\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = dot(n,l)*.5+.5;\n        float ao = AO(0.1,p,n)+AO(0.35,p,n)+AO(0.75,p,n);\n        col = vec3(1.)*light*(ao/2.);\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 603, 623, 623, 745], [747, 747, 776, 776, 861], [864, 864, 884, 884, 1299], [1301, 1301, 1324, 1324, 1438], [1440, 1440, 1478, 1478, 1516], [1518, 1518, 1575, 1575, 2129]], "test": "untested"}
{"id": "NddXzH", "name": "Supah Breathe", "author": "supah", "description": "glsl transposition of https://codepen.io/supah/pen/OJXJgZq", "tags": ["waves", "rings", "breath", "supah"], "likes": 13, "viewed": 263, "published": "Public", "date": "1632649834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define P 3.14159265\nfloat b(vec2 u, vec2 R, float r, float d, float f) {\n    vec2 U = (u-.5)*vec2(R.x/R.y,1.);\n    float o = length(U),\n          t = d+iTime*6.,\n          l = r + S(.1,1.,abs(u.y))*(sin(t - atan(U.x,U.y)*7.)*f)*.08,\n          w = .004;\n    return S(l, l+.005,o)-S(l+w, l+w+.005,o);\n}\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    vec2 R = iResolution.xy,\n         u = I/R.xy;\n    vec3 r = vec3(0.1, 0.1, 0.3)*1.-length(u-.5)*.2;\n    for (float i = 0.;i < 6.;i++){\n        r += vec3(0.9,.2+i*.1,.8)*b(u,R,.35-i*0.014,i,.2+i*.02);\n    }\n    O = vec4(r,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 94, 94, 322], [323, 323, 362, 362, 592]], "test": "untested"}
{"id": "NdG3Rc", "name": "Cosine Rainbow", "author": "Krischan", "description": "A single line function creates a nice RGB rainbow by just taking a value from 0...1\nOriginal by keyuliang https://www.shadertoy.com/view/Nt2XWc\n", "tags": ["color", "gradient", "rgb", "rainbow"], "likes": 3, "viewed": 198, "published": "Public API", "date": "1631833364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rainbow(u) .5 + .5 * cos( atan(u.x,u.y) + 6.3 * iTime + vec3(0,23,21) )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U -= .5* iResolution.xy;\n    O = vec4(rainbow(U),1.0);\n}\n\n// original version\n/*\n#define rainbow(a) .5 + .5 * cos(6.283 * (a + vec3(0.,.33,.66)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x+=length(uv);\n    \n    fragColor = vec4(rainbow(fract(atan(uv.x, uv.y) / 3.1415 + iTime)),1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3Rc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 122, 122, 183]], "test": "untested"}
{"id": "NdG3Wm", "name": "Never Moon A WereWolf", "author": "Radical_Ed", "description": "Abbiamo condannato il lupo non per quello che è, ma per quello che abbiamo deliberatamente ed erroneamente percepito che fosse - l'immagine mitizzata di uno spietato assassino selvaggio - Che, in realtà, non è altro che l’immagine riflessa di noi stessi. ", "tags": ["moon", "wolf"], "likes": 0, "viewed": 39, "published": "Public", "date": "1631633606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// rework of this GLSL Shader https://glslsandbox.com/e#73033.0 \n\nprecision mediump float;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec3 Color = vec3(0.9, 0.9, 0.9);\n\tfloat col = -0.2;\n\tvec2 a = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x,iResolution.y);\n\tfloat t=iTime/21.0;\n\tfor(float i=0.0;i<15.0;i++)\n\t{\n\t  float si = sin(t)/3.7;\n\t  col += 0.19 / abs(length(a*3. + vec2(si*40. , si*20. )) - 0.1);\n\t}\n\tfragColor = vec4(vec3(Color * col), 1.0);\n}", "image_inputs": [{"id": "XtlXD2", "previewfilepath": "https://soundcloud.com/bz-akira-santjago/never-moon-a-werewolf-bz-akira-santjago", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bz-akira-santjago/never-moon-a-werewolf-bz-akira-santjago", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3Wm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 150, 150, 484]], "test": "untested"}
{"id": "NdG3WR", "name": "Bands Remix BG", "author": "Insidious_Scripter", "description": "yea", "tags": ["ribbonsbg"], "likes": 0, "viewed": 66, "published": "Public", "date": "1631294996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime )),\n                      glowWidth * (2.0 - sin(iTime)),\n                      glowWidth * (2.0 - cos(iTime)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3WR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 85, 85, 144], [146, 146, 172, 172, 270], [272, 272, 329, 329, 1046]], "test": "untested"}
{"id": "NdG3zD", "name": "square in the circle", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 5, "viewed": 41, "published": "Public", "date": "1631149249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LOOPLEN 3.6\n#define TAU (2. * 3.14159265359)\n#define SCALE 18.0\n#define SPEED -8.0\n#define TOGGLE_DIST 8.0\n\n// i want hex code\nvec3 hex(int value) {\n    return vec3(\n        (value >> 16) & 255,\n        (value >>  8) & 255,\n         value        & 255\n    ) / 255.;\n}\n\n// angle as radians\nfloat square(vec2 uv, float angle) {\n// janky implem of rotation matrix\n    vec2 aVec = vec2(\n        cos(angle), sin(angle)\n    );\n    uv = vec2(\n        uv.x * aVec.x - uv.y * aVec.y,\n        uv.x * aVec.y + uv.y * aVec.x\n    );\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / LOOPLEN);\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * SCALE;\n\n    float offset = time * SPEED;\n    float rotation = sin(TAU * 0.25 * min(1.0, fract(time * 2.) * 2.)) * TAU / 4.;\n    float squDist = square(uv, rotation);\n    float cirDist = length(uv);\n    \n    // toggling color\n    float stripeThres = max(0.1, 0.9 - fract(time * 4.) * 2.);\n    vec3 squCol = hex(0x373E6D);\n    if (fract(squDist - offset) < stripeThres) {\n        squCol = hex(0xF94C7E);\n    }\n    vec3 cirCol = hex(0xE7AE38);\n    if (fract(cirDist - offset) < stripeThres) {\n        cirCol = hex(0x320C47);\n    }\n    \n    vec3 col = hex(0xFF00FF);\n    float toggleOffset = time * TOGGLE_DIST;\n    for (int i = -3; i < 3; i++) {\n        if (cirDist - toggleOffset < TOGGLE_DIST * float(i)) {\n            col = cirCol; break;\n        } else if (squDist - toggleOffset < TOGGLE_DIST * (float(i) + 0.5)) {\n            col = squCol; break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 135, 156, 156, 275], [277, 297, 333, 368, 567], [569, 569, 626, 626, 1772]], "test": "untested"}
{"id": "NdG3zw", "name": "Audio Reactive Galaxy", "author": "JelyMe314", "description": "A version of CBS's simplicity galaxy shader, to be used with lively wallpaper.", "tags": ["fractal"], "likes": 9, "viewed": 313, "published": "Public", "date": "1631215146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdG3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 255, 255, 642], [644, 680, 714, 714, 1101], [1103, 1103, 1127, 1127, 1310], [1313, 1313, 1370, 1370, 2789]], "test": "untested"}
{"id": "NdGGDD", "name": "Fork 2D Clouds (slow)", "author": "rafaelchampion", "description": "Used in 2 different demos:\nhttp://www.pouet.net/prod.php?which=66590\nand\nhttp://www.pouet.net/prod.php?which=68483", "tags": ["fractal", "noise", "clouds", "fbm"], "likes": 4, "viewed": 83, "published": "Public", "date": "1631539691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float cloudscale = 1.0;\nconst float speed = 0.005;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.1;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 362, 362, 475], [477, 477, 503, 503, 1027], [1029, 1029, 1048, 1048, 1202], [1204, 1256, 1313, 1313, 2935]], "test": "untested"}
{"id": "NdGGR1", "name": "Twisted Squares", "author": "jin_x", "description": "Just twisted squares :)", "tags": ["squares", "twist"], "likes": 2, "viewed": 50, "published": "Public", "date": "1631038141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (y = -0.5..0.5, x = -xres/yres/2..xres/yres/2)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.x *= ar;\n\n    // Background\n    vec3 col = vec3(0., sin((atan(uv.y, uv.x)+iTime*.3)*20. + 10./length(uv)) * (sin(iTime*3.)*.15+.3), 0.);\n    \n    float size = .0025;\n    for (int i = 0; i < 100; ++i, size *= 1.05) {\n        // Rotate image\n        float a = iTime*(3.-float(i)*.035), sa = sin(a), ca = cos(a);\n        vec2 uvr = uv * mat2(ca, -sa, sa, ca);\n        // Calculate color\n        if (abs(uvr.x) < size && abs(uvr.y) < size) {\n            col = vec3(float((i+1) & 1)*float(i)*.05, float(100-i)*.05, i & 1);\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 137, 855]], "test": "untested"}
{"id": "NdGGRD", "name": "Scaling 2D Matrice with Circles", "author": "xXx_T0SHIII_xXx", "description": "Learning about Matrices and Scaling. ", "tags": ["2d", "simple", "circle", "scaling", "matrice"], "likes": 1, "viewed": 34, "published": "Public", "date": "1631142682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Matrice for scale 2D\nmat2 Scale2D(vec2 scale)\n{\n    return mat2(scale.x,0.0,\n                             0.0,scale.y);\n}\n\n//Circle Function\nfloat Circle(vec2 uv, float r)\n{\n    vec2 pos = uv - vec2(.5);\n    float c = length(pos);\n    return smoothstep(r,r+1.5/iResolution.y,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //Visualize UV\n    vec3 col =vec3(uv,0.);\n    //Scale UV by float\n    uv*= 4.;\n    //Create Grid\n    uv= fract(uv);\n    //move uv to vec2(0,0)\n    uv-=vec2(.5);\n    //Scale uv with Scaling Matrice\n    uv = Scale2D(vec2(sin(iTime)))*uv;\n    //move back to center\n    uv+= vec2(.5);\n   \n   //Visualize Circles\n    col = vec3(Circle(uv,.2));\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 49, 49, 123], [125, 143, 175, 175, 282], [284, 284, 341, 391, 862]], "test": "untested"}
{"id": "NdGGRK", "name": "Cross function piston", "author": "gaz", "description": "A test to see the behavior of cross ()", "tags": ["cross"], "likes": 11, "viewed": 197, "published": "Public API", "date": "1631802342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxd=80.0;\n\nvec3 rot(inout vec3 p,vec3 axis,float theta){\n\taxis=normalize(axis);\n\treturn mix(axis*dot(p,axis),p,cos(theta))+sin(theta)*cross(p,axis);\n}\n\n\nvec2 polarAbs(vec2 p,float n)\n{\n  n*=0.5;\n  float a = asin(sin(atan(p.x,p.y)*n))/n;\n  return vec2(sin(a),cos(a))*length(p);\n}\n\nfloat lpNorm(vec2 p, float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\n\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+2315.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);\n    }\n    return p;\n}\n\nvec3 targetVector0()\n{\n    return randVec(32892.+floor(iTime/2.));\n}\n\nvec3 axisVector()\n{\n    vec3 a = targetVector0();\n    vec3 b = a.yzx;\n    for(int i=0;i<100;i++)\n    {\n        if (all(equal(a, b))==false) break;\n        b.z += 0.1;\n        b = normalize(b);\n    }\n    vec3 w = a;\n    vec3 u = normalize(cross(b,w));\n    vec3 v = cross(w,u);\n    return v;\n}\n\nvec3 targetVectorA()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = -iTime;\n    return rot(v,a,t);    \n}\n\nvec3 targetVectorB()\n{\n    vec3 v = targetVector0();\n    vec3 a = axisVector();\n    float t = iTime;\n    return rot(v,a,t);\n}\n\n\nfloat deA(vec3 p)\n{\n    float de =1.;\n    vec3 target = targetVectorA();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    //p = inverse(mat3(u,v,w)) * p;\n    p = p * mat3(u,v,w);\n    vec3 q=p;\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de = min(de,length(p)-.01);\n    q.xz=polarAbs(q.xz,24.);\n    q.z-=1.12;\n    return min(de,(lpNorm(q,5.0)-.091+q.z*.3)*.8);\n}\n\nfloat deB(vec3 p)\n{\n    float de=1.;\n    vec3 target = targetVectorB();\n    vec3 axis = axisVector();\n    vec3 w = normalize(target);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = vec3(dot(p,u), dot(p,v), dot(p,w));\n    de=min(de,lpNorm(vec2(length(p.yz)-.95,p.x),5.0)-.07);\n    de=min(de,lpNorm(vec2(length(p.xz)-1.,p.y),5.0)-.1);\n    de=min(de,lpNorm(vec2(length(p.xz)-.15,p.y),5.0)-.07);\n    p.x -= clamp(p.x, -0.1, 0.1);\n    p.y -= clamp(p.y, -0.02, 0.02);\n    p.z -= clamp(p.z, 0.1, 1.0);\n    de=min(de, length(p)-.01);\n    return de;\n}\n\nfloat deC(vec3 p)\n{\n    vec3 targetA = normalize(targetVectorA());\n    vec3 targetB = normalize(targetVectorB());\n    // cross() test\n    vec3 cx = cross(targetA, targetB);\n    vec3 axis = targetA;\n    vec3 w = normalize(cx);\n    vec3 u = normalize(cross(axis,w));\n    vec3 v = cross(w,u);\n    p = transpose(mat3(u,v,w)) * p;\n    //p = p * mat3(u,v,w);       \n    float len = length(cx); \n    p.z -= clamp(p.z, 0.0, len);\n    return lpNorm(p,3.)-.1;\n}\n\nfloat map(vec3 p)\n{\n    float de = 1.;\n    de = min(de, deA(p));\n    de = min(de, deB(p));\n    de = min(de, deC(p));\n    de = min(de, p.y + 1.2);\n    return de;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n    if(deC(p)<0.001) return vec3(1.8,0.5,0.2);\n    return vec3(0.3,0.5,0.8)+cos(p*0.5)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=vec3(1.5);\n    vec3 ta = randCurve(iTime*.3,1234.6)*.4;\n    vec3 rd = normalize(vec3(uv,2.0));\n    vec3 w = normalize(ta-ro);\n    vec3 u = normalize(cross(w,vec3(0,1,0)));\n    vec3 v = cross(u,w);\n    rd = mat3(u,v,w) * rd;\n    vec3 col= vec3(0.05,0.05,0.1);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n    \tvec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,5,1);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n    \tfloat sha = min(1.,calcShadow( lightPos, -li, len )+.8);\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.5;\n    \tcol *= max(0.5+0.5*n.y, 0.0);\n    \tcol *= exp2(-1.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n    \tcol += vec3(0.8,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 10.0);\n    \tcol = mix(vec3(0.1,0.1,0.2),col, exp(-0.03*t*t));\n    }\n    fragColor.xyz = col;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 69, 69, 163], [166, 166, 197, 197, 291], [293, 293, 324, 324, 382], [385, 385, 416, 416, 478], [519, 519, 542, 542, 642], [644, 644, 677, 677, 806], [808, 808, 830, 830, 876], [878, 878, 897, 897, 1169], [1171, 1171, 1193, 1193, 1301], [1303, 1303, 1325, 1325, 1428], [1431, 1431, 1450, 1450, 1936], [1938, 1938, 1957, 1957, 2505], [2507, 2507, 2526, 2526, 2958], [2960, 2960, 2979, 2979, 3122], [3124, 3124, 3149, 3149, 3292], [3294, 3294, 3348, 3348, 3515], [3517, 3517, 3569, 3569, 3652], [3654, 3654, 3676, 3676, 3772], [3774, 3774, 3831, 3831, 4954]], "test": "untested"}
{"id": "NdGGWV", "name": "newbie raymarching example", "author": "wlievens", "description": "raymarching example", "tags": ["raymarching"], "likes": 2, "viewed": 65, "published": "Public", "date": "1632228727", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEPS = 150;\nconst float SURFACE = 0.001;\nconst float MAXIMUM = 5000.0;\nconst float SHADOW_FACTOR = 0.15;\nconst float BOUNCE_MARGIN = 0.01;\nconst float PI = 3.1415925;\n\nconst float MATERIAL_LIGHT = 5.0;\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(+c, -s, +s, +c);\n}\n\nvec2 minSample(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 maxSample(vec2 a, vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nfloat distanceSphere(vec3 position, vec4 sphere) {\n    return length(position - sphere.xyz) - sphere.a;\n}\n\nfloat distanceBox(vec3 position, vec3 center, vec3 size) {\n    vec3 d = abs(center - position) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat distanceCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opDifference(vec2 a, vec2 b) {\n    return vec2(max(a.x, -b.x), a.y);\n}\n\nvec2 opUnion(vec2 a, vec2 b) {\n    if (a.x <= b.x) {\n        return a;\n    }\n    return b;\n}\n\nvec2 opBlend(vec2 a, vec2 b, float k) {\n    float mat = a.y;\n    float h = clamp(0.5 + 0.5 * (a.x - b.x) / k, 0.0, 1.0);\n    float d = mix(a.x, b.x, h) - k * h * (1.0 - h); \n    return vec2(d, mat);\n}\n\nvec2 sampleScene(vec3 position) {\n    vec4 sphere1 = vec4(0.4, 0.8, 3.0, 0.4);\n    vec4 sphere2 = vec4(-0.5, 0.9, 3.0, 0.4);\n    sphere1.y += sin(iTime) * 0.4;\n    sphere2.x += cos(iTime) * 0.8;\n    sphere2.z += sin(iTime) * 0.8;\n    vec3 box1Center = vec3(-1.0, 1.3, 0.9);\n    vec3 box1Size = vec3(0.2) + cos(iTime) * 0.025;\n    \n    float fx = floor(mod(position.x, 2.0));\n    float fz = floor(mod(position.z, 2.0));\n    vec2 d0 = vec2(position.y, 1.0 + floor(mod(fx + fz, 2.0)));\n    vec2 d1 = vec2(distanceSphere(position, sphere1), 2.0);\n    vec2 d2 = vec2(distanceSphere(position, sphere2), 2.0);\n    vec2 d3 = vec2(distanceBox(position, box1Center, box1Size), 3.0);\n    vec2 d4 = vec2(abs(position.x + 2.0), 3.0);\n    vec3 p = position - vec3(0.0, 1.0, 1.0);\n   \n    vec2 scene = vec2(1e9, 0.0);\n    scene = minSample(scene, d0);\n    scene = minSample(scene, d1);\n    scene = minSample(scene, d2);\n    scene = minSample(scene, d3);\n    scene = minSample(scene, d4);\n    \n    vec4 c = vec4(0.5, 1.0, 1.0, 0.30);\n    float ch = 0.35;\n    int l1 = 10;\n    int l2 = 24;\n    \n    vec2 d5 = vec2(distanceCylinder(c.xyz - position, vec2(c.w, ch)), 4.0);\n    vec2 d6 = vec2(distanceCylinder(c.xyz - position, vec2(c.w * 0.99, ch + 0.01)), 4.0);\n    vec2 d7 = vec2(distanceSphere(position, vec4(c.xyz, c.w * 0.25)), MATERIAL_LIGHT);\n    d5 = opDifference(d5, d6);\n    d5 = opUnion(d5, d7);\n    if (d5.x < 0.01) {\n        for (int i1 = 0; i1 < l1; ++i1) {\n            float r1 = float(i1) / (float(l1) - 1.0);\n            for (int i2 = 0; i2 < l2; ++i2) {\n                float r2 = float(i2) / float(l2);\n                float a = PI * 2.0 * r2;\n                vec4 p = vec4(\n                    c.x + cos(a) * c.w,\n                    c.y - ch + ch * 2.0 * r1,\n                    c.z + sin(a) * c.w,\n                    0.99 * PI * c.w / float(l2)\n                );\n                vec2 d = vec2(distanceSphere(position, p), 1.0);\n                d5 = opDifference(d5, d);\n            }\n        }\n    }\n    scene = minSample(scene, d5);\n    \n    return scene;\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float rayDistance = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        vec3 position = rayOrigin + rayDirection * rayDistance;\n        vec2 scene = sampleScene(position);\n        if (scene.x < SURFACE) {\n            return vec2(rayDistance, scene.y);\n        }\n        if (rayDistance > MAXIMUM) {\n            break;\n        }\n        rayDistance += scene.x;\n    }\n\n    return vec2(MAXIMUM, 0.0);\n}\n\nvec3 estimateNormal(vec3 position)\n{\n    vec3 step = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        sampleScene(position + step.xyy).x - sampleScene(position - step.xyy).x,\n        sampleScene(position + step.yxy).x - sampleScene(position - step.yxy).x,\n        sampleScene(position + step.yyx).x - sampleScene(position - step.yyx).x\n    ));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt; )\n    {\n        vec2 h = sampleScene(ro + rd * t);\n        if( h.x < SURFACE)\n        {\n            return h.y == MATERIAL_LIGHT ? res : 0.0;\n        }\n        if (h.y != MATERIAL_LIGHT)\n        {\n            res = min(res, k * h.x / t);\n        }\n        t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4[] lights = vec4[] (\n        // vec4(2.0, 5.0, -2.0, 30.0),\n        vec4(0.5, 1.0, 1.0, 15.0)\n    );\n    // lights[0].xz += vec2(cos(iTime), sin(iTime)) * 6.0;\n    // lights[1].xz -= vec2(cos(iTime), sin(iTime)) * 4.0;\n\n    vec2 uv = 2.0 * (fragCoord / iResolution.xx) - 1.0;\n\n    vec3 cameraPosition = vec3(0.0, 1.85, -1.45);\n    // cameraPosition.z += cos(iTime) * 1.6;\n    // cameraPosition.z += 1.65;\n    vec3 cameraRay = normalize(vec3(uv, 1.0));\n    \n    vec2 target = rayMarch(cameraPosition, cameraRay);\n    float distance = target.x;\n    vec3 point = cameraPosition + cameraRay * distance;\n    vec3 normal = estimateNormal(point);\n    float material = target.y;\n    \n    float intensity = 0.1;\n    vec3 color;\n    \n    if (material == 0.0) {\n        // Sky\n        color = vec3(0.6, 0.7, 1.0);\n        intensity = 0.4;\n    } else if (material == MATERIAL_LIGHT) {\n        color = vec3(1.0, 1.0, 1.0);\n         intensity = 1.0;\n   } else {\n        if (material == 1.0) {\n            color = vec3(0.8, 0.8, 0.8);\n        }\n        if (material == 2.0) {\n            color = vec3(0.25, 0.3, 0.4);\n        }\n        if (material == 3.0) {\n            color = vec3(0.85, 0.76, 0.65);\n        }\n        if (material == 4.0) {\n            color = vec3(0.75, 0.81, 0.55);\n        }\n        \n        for (int n = 0; n < lights.length(); ++n) {\n            vec4 light = lights[n];\n            vec3 lightToPoint = light.xyz - point;\n            vec3 lightDirection = normalize(lightToPoint);\n            float lightDistance = length(lightToPoint);\n            vec3 start = point + lightDirection * BOUNCE_MARGIN;\n            float factor = shadow(start, lightDirection, 0.0, 10.0, 240.0);\n            float lightIntensity = (0.5+0.1*sin(3.0*iTime))* max(0.0, dot(normal, lightDirection)) * light.a / lightDistance / lightDistance;\n            intensity += lightIntensity * (0.2 + 0.8 * factor);\n        }\n    }\n    intensity = clamp(intensity, 0.0, 1.0);\n    \n    color *= intensity;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGGWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 236, 236, 315], [317, 317, 349, 349, 381], [383, 383, 415, 415, 447], [449, 449, 499, 499, 554], [556, 556, 614, 614, 728], [730, 730, 770, 770, 873], [875, 875, 910, 910, 950], [952, 952, 982, 982, 1044], [1046, 1046, 1085, 1085, 1246], [1248, 1248, 1281, 1281, 3311], [3313, 3313, 3363, 3363, 3766], [3768, 3768, 3804, 3804, 4123], [4125, 4125, 4190, 4190, 4536], [4538, 4538, 4593, 4593, 6619]], "test": "untested"}
{"id": "NdK3DD", "name": "Green matrix dude", "author": "NataliaP", "description": "_", "tags": ["sdf"], "likes": 5, "viewed": 70, "published": "Public", "date": "1631577512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r(s) fract(43.*sin(s.x*13.+s.y*78.))\n\nconst vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat dBox ( vec3 p, vec3 b )\n{\n\treturn length8 ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat dGreenDude (in vec3 q) \n{\n    return min(min(min(dBox ( q, vec3 ( 0.5, 0.5, 0.7 )), \n      dBox ( q + vec3( 0.0, 0.0, 0.8), vec3 ( 0.4, 0.4, 0.4 ))),\n      dBox ( q + vec3( - 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 ))),\n      dBox ( q + vec3( + 0.7, 0.0, -0.9), vec3 ( 0.2, 0.5, 0.2 )));\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p + vec3(cos(iTime), sin(iTime), 0);\n   \n   return dGreenDude(q);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 i = fragCoord;\n    vec2 j = fract(i*=50./iResolution.x), \n        p1 = i-j+ vec2(2,floor(iTime*20.*fract(sin(i-j).x)));\n    i      = abs(j-.5);\n    vec4 o =  vec4(r(floor(p1*23.+5.*j))>.5&&i.x<.3&&i.y<.45 ?   1. - r(p1)*\n         (2.-dot(i,i)*6.)  :  1.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 10.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t}\n\n    // Output to screen\n    fragColor = 1.2*color - 0.18*o;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 230, 257, 257, 404], [406, 444, 471, 471, 618], [620, 620, 649, 649, 717], [719, 719, 748, 748, 835], [837, 837, 868, 868, 918], [920, 920, 962, 962, 1032], [1034, 1034, 1065, 1065, 1327], [1329, 1329, 1365, 1365, 1449], [1451, 1451, 1518, 1518, 1833], [1835, 1835, 1887, 1887, 2256], [2258, 2258, 2315, 2315, 3508]], "test": "untested"}
{"id": "NdK3Rm", "name": "Sunrise of REBOP", "author": "Radical_Ed", "description": "Radical Ed", "tags": ["sunrise"], "likes": 0, "viewed": 16, "published": "Public", "date": "1631271291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sunrise, Radical Ed\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\n\n\nvec3 colorA = vec3(1.0,0.0,0.0);\nvec3 colorB = vec3(0.7,0.7,1.0);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.2, pct, st.y); -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n\n    vec3 pct = vec3(abs(sin(iTime*0.03))+0.4);\n    vec3 pct2 = vec3(abs(sin(iTime*0.03)));\n    float yx=pct.x;\n   \n\n    color = mix(colorA, colorB, pct.x);\n    color = mix(color,vec3(0.8*(pct2.x),0.6*(pct2.x),0.6*(pct2.x)),plot(st,pct.x-0.3));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "XlsXW2", "previewfilepath": "https://soundcloud.com/subpop/jon-benjamin-jazz-daredevil-also-sprach-zarathustra-theme-from-2001-a-space-odyssey", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/subpop/jon-benjamin-jazz-daredevil-also-sprach-zarathustra-theme-from-2001-a-space-odyssey", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdK3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 165, 197, 197, 288], [290, 290, 347, 347, 704]], "test": "untested"}
{"id": "NdKGDw", "name": "Fork SuperNovae oneWisdom 281", "author": "oneWisdom", "description": "https://www.shadertoy.com/view/lts3RB \nChanged speed", "tags": ["fractal", "burning", "mouseinput", "supernovae", "fusion"], "likes": 4, "viewed": 192, "published": "Public API", "date": "1631655316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader:   SuperNovaeFusion.glsl            by   I.G.P\n// original: https://www.shadertoy.com/view/4tfGRr\n// use mouse to rotate and look around\n//---------------------------------------------------------\n\n#define time iTime \n#define mouse iMouse\n#define resolution iResolution\n//varying vec2 surfacePosition;\n//varying vec2 surfaceSize;\n\n//---------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  \n{ \n    return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );\n}\n\nvec3 dmul( vec3 a, vec3 b )  \n{\n    float r = length(a);   \n    b.xy = cmul(normalize(a.xy), b.xy);\n    b.yz = cmul(normalize(a.yz), b.yz);\n    b.xz += 0.3 * cmul(normalize(a.xz), b.xz);\n    return r*b;\n}\n\nfloat field(in vec3 p) \n{\n    float res = 0.0;\n    vec3 c = p;\n    for (int i = 0; i < 10; ++i) \n    {\n        p = abs(p) / dot(p,p) - 1.0;\n        p = dmul(p,p) + 0.7;\n        res += exp(-6.0 * abs(dot(p,c)-0.15));\n    }\n    return max(0.0, res / 3.0);\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 1.5;\n    float dt = 0.25;\n    vec3 col = vec3(0.0);\n    for( int i=20; i<25; i++ )\n    {\n        float c = field(ro+t*rd);               \n        t+=dt / (0.35+c*c);\n        c = max(5.0 * c - .9, 0.0);\n        c = c*c*c*c;\n        col = 0.04*col + 0.04*vec3(0.1*c*c, 0.2*c, 0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= resolution.x / resolution.y;\n    //p += surfacePosition - 0.5;\n    float camspeed=1.8;\n    // camera\n    float angle = camspeed*time + 0.01 * mouse.x;\n    vec3 ro = vec3(3.2*cos(angle) + 0.5, 0.0 , 3.2*sin(angle) +0.5);\n    vec3 ta = vec3(0.0, 1.2 - 0.01*mouse.y, 0.0);\n    vec3 ww = normalize (ta - ro );\n    vec3 uu = normalize (cross (ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize (cross (uu, ww));\n    vec3 rd = normalize (p.x*uu + p.y*vv + 4.0*ww);\n    \n    // raymarch\n    vec3 col = raycast(ro, rd);\n    \n    // shade\n    col =  0.3 *(log(1.0+0.2*col));\n    fragColor = vec4(sqrt(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 462, 493, 493, 553], [555, 555, 586, 586, 759], [761, 761, 786, 786, 1016], [1018, 1018, 1055, 1055, 1373], [1375, 1375, 1432, 1432, 2121]], "test": "untested"}
{"id": "NdKGDz", "name": "The Abyss", "author": "dean_the_coder", "description": "The Abyss movie from 1989, where a friendly 'visitor' has a look around the underwater habitat.\n(It's deliberately a bit dark.)\nYouTube: https://youtu.be/SZqlIZMQU6U\nYouTube (360°): https://youtu.be/-ayBRXhEDoU", "tags": ["3d", "raymarching", "reflection", "refraction", "water", "caustics", "movie", "tentacle", "cineshader"], "likes": 33, "viewed": 1165, "published": "Public API", "date": "1631364085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'The Abyss' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NdKGDz (YouTube: https://youtu.be/SZqlIZMQU6U)\n//\n// YouTube: https://youtu.be/SZqlIZMQU6U\n// YouTube (360°): https://youtu.be/-ayBRXhEDoU\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Abyss movie from 1989, where a friendly 'visitor'\n// has a look around an underwater habitat.\n//\n// Quote: \"Keep your pantyhose on...\"\n//\n// Tricks to get the performance:\n// - The water and scene are raymarched separately, as only\n//   the water is reflective. When reflecting only the background\n//   needs to be processed.\n//   This also allows different max marching steps for each.\n// - Similarly I have two normal functions.\n//   One for the water, one for everything else.\n// - Textures applied during the lighting calculations, as far\n//   as possible.\n// - Fake shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define U\tnormalize\n#define L\tlength\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define minH(a, b)\t{ float h_ = a; if (h_ < h.x) h = vec2(h_, b); }\n\nfloat t, g = 0., g2 = 0.;\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max2(v.yz)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn L(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, vec2 hr) {\n\tp.x -= clamp(p.x, 0., hr.x);\n\treturn L(p) - hr.y;\n}\n\nfloat honk(inout vec3 p, mat2 rot, float h, float r) {\n\tp.xy *= rot;\n\tfloat d = cap(p, vec2(h * .88, r));\n\tp.x -= h;\n\treturn d;\n}\n\n// Find most dominant uv coords.\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.yz : n.y == m ? p.xz : p.xy;\n}\n\nfloat surf(vec2 p1, vec2 p2) {\n\tfloat d = t * .4;\n\treturn n31(vec3(p1.x + d, p1.y, d)) * .3 + n31(vec3(p2, d) * 2.) * .1 + n31(vec3(p2 + d * .5, d) * 3.6) * .05;\n}\n\nfloat face(vec3 p, float o) {\n\tfloat f, d,\n\t      ox = p.x;\n\tp.x = abs(p.x) - .15;\n\tp.y += .05;\n\tp.z += .15 - .3 + .3 * S(27., 30., t);\n\tf = S(29.5, 31., t);\n\td = L(p) - .08;\n\tp.x = ox;\n\tp.y -= .3 - 1. + cos(ox * 1.5 * (.3 + f * .8));\n\to = max(o, -box(p, vec3(.15 + f * .1, .02 + f * .015, .09)));\n\treturn -smin(-o, d, .03);\n}\n\nfloat wat(vec3 p) {\n\tvec3 h1, h2, h3, h4,\n\t     op = p;\n\tp.z -= 3.;\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Pool.\n\tfloat d, s = surf(p.xz, op.xz);\n\n\t// Clip pool to pool walls.\n\td = max(p.y + 6., box(p, vec3(8, 66, 8)));\n\n\t// Tentacle.\n\tp -= vec3(3, -7, 3);\n\tvec3 phNow = vec3(.3, .1, 0) * S(6., 10., t);\n\tphNow = mix(mix(mix(mix(mix(phNow, vec3(.37, -.12, 0), S(11., 13., t)), vec3(.3, .1, 0), S(14., 16., t)), vec3(1.09, .23, 0), S(16., 20., t)), vec3(.3, .1, 0), S(22., 24., t)), vec3(.31, .02, 1), S(24., 27., t));\n\tphNow *= S(35.5, 34., t);\n\tphNow.x += .01;\n\tp.y -= .2 * sin(t);\n\tmat2 bf = rot(phNow.z * .9);\n\tp.xz *= rot(.8 - phNow.y * 2.);\n\th1 = vec3(1.4, phNow.x * 4.5, 1.3 * (.5 + .5 * phNow.x));\n\td = smin(d, honk(p, rot(h1.x), h1.y, mix(1.5, h1.z, sat(p.y / h1.y))), 2.5); // angle, length, radius\n\tp.xy *= bf;\n\th2 = vec3(-.7 * phNow.x, h1.yz * vec2(.8, .9));\n\td = smin(d, honk(p, rot(h2.x), h2.y, mix(h1.z, h2.z, sat(p.x / h2.y))), .2);\n\tp.xz *= rot(-phNow.y);\n\th3 = vec3(-.4 * phNow.x, h2.yz * vec2(2.5, .7));\n\td = smin(d, honk(p, rot(h3.x), h3.y, mix(h2.z, h3.z, sat(p.x / h3.y))), .1);\n\tp.xz *= rot(phNow.y * -3.);\n\tp.xy *= bf;\n\th4 = vec3(-.2 * phNow.x, h3.yz * vec2(.4 + dot(phNow.xz, vec2(.15, 1)), .7));\n\td = smin(d, honk(p, rot(h4.x), h4.y, mix(h3.z, h4.z, sat(p.x / h4.y))), .2);\n\td -= s * S01(L(p) - .5 * (S(26.5, 27.5, t) - S(34., 34.5, t)));\n\td = face(p.zyx, d);\n\tg2 += .01 / (4. + d * d);\n\treturn d;\n}\n\nfloat pipe(vec3 p, float r) { return L(p.yz) - r - min(step(.96, fract(p.x * .2)) * r * .2, .1); }\n\nvec2 env(vec3 p) {\n\tp.z -= 3.;\n\tfloat d = max(abs(p.z - 30.), 20. - p.x);\n\n\t// Twist room.\n\tp.xz *= mat2(.707, .707, -.707, .707);\n\n\t// Left wall.\n\td = min(min(d, max(abs(20. - abs(p.z)) - 1.5, p.x - 24.)), 34. - p.z);\n\n\t// Right walls.\n\td = min(min(d, max(abs(25. - abs(p.x)) - 1.5, p.z - 7.7 - step(p.x, 0.) * 12.)), max(abs(5.2 - p.z) - .1, 24. - p.x));\n\n\t// Ceiling.\n\td = smin(d, 10. - p.y, 1.);\n\n\t// Right corner box.\n\td = min(d, max(box(p - vec3(21, 0, 12.6), vec3(2.5, 66, 6)), -box(p - vec3(32, 0, 12.6), vec3(10, 66, 5))));\n\n\t// Left door.\n\td = max(d, .5 - box(p - vec3(4, 0, 20), vec3(4, 4, 2)));\n\n\t// Right doors.\n\tvec3 q = p;\n\tq.y -= .8;\n\tq.z = abs(q.z - 7.) - 5.;\n\tif (p.x > 0.) d = max(max(d, 3. - box(q, vec3(26, 2, 0))), 4. - box(q, vec3(15.4, 2.8, 1)));\n\tvec2 h = vec2(d, 3);\n\n\t// Lamp.\n\td = cap(p.yxz - vec3(5, 23, -3), vec2(1.2, .6));\n\tg += .02 / (1. + d * d);\n\tminH(d, 5.);\n\n\t// Ground/pool hole.\n\tminH(max(p.y + 5., -box(p, vec3(8, 66, 8))), 2.);\n\n\t// Wall pipes.\n\tq = p.yxz - vec3(1, 20.5, 6.4);\n\tq.y = abs(abs(q.y) - .5) - .5;\n\td = pipe(q, .2);\n\n\t// LHS big jobs.\n\tq = p - vec3(0, 9, 18.5);\n\tq.y = abs(q.y) - .6;\n\td = min(d, pipe(q, .5));\n\n\t// Light wires.\n\tq = p.yzx - vec3(0, -11, 23.5);\n\tq.y = abs(abs(q.y) - 6.) - .3;\n\td = min(d, pipe(q, .2));\n\n\t// Roof big jobs.\n\tq = p - vec3(0, 9, 10);\n\tq.z = abs(abs(q.z + 3.5) - 3.) - 1.;\n\td = min(d, pipe(q, .7));\n\n\t// Corridor pipe.\n\td = min(d, pipe(p - vec3(0, -3, 32), 1.));\n\n\t// Floor pipe.\n\tq = p.zxy - vec3(1, 23, -4);\n\td = min(d, max(pipe(q, .8), p.z + 3.));\n\tq.x += 4.;\n\tminH(min(d, L(q) - .8), 4.);\n\treturn h;\n}\n\n// Environment normal.\nvec3 Ne(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * env(p + e * h).x;\n\t}\n\n\treturn U(n);\n}\n\n// Water normal.\nvec3 Nw(vec3 p) {\n\tfloat h = L(p) * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * wat(p + e * h);\n\t}\n\n\treturn U(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float d) {\n\tp += d * n;\n\treturn min(wat(p) * .4, env(p).x) / d;\n}\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -4e-4); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, vec2 h) {\n\tif (h.y == 5.) return vec3(1.8 * L(n.xz) + .2);\n\tvec3 c, ld2,\n\t     ld = U(vec3(0, -5, 0) - p);\n\tfloat l1, l2, fre,\n\t      ao = mix(ao(p, n, .2), ao(p, n, 2.), .7),\n\t      sha = 1.,\n\t      l2c = 1.;\n\tvec2 spe = vec2(1.22, .1);\n\tif (h.y == 1.) {\n        // Tentacle.\n\t\tc = vec3(.35, .71, .53) * 1.6 * S(1., -5., p.y);\n\t\tspe = vec2(100, 8);\n\t}\n\telse {\n\t\tfloat n10 = n31(p * 10.);\n\t\tif (h.y == 3.) {\n            // Walls.\n\t\t\tc = vec3(1, .8, .6) - n10 * .06 - n31(p * .5) * .1;\n\t\t\tl2c = .05;\n\t\t}\n\t\telse if (h.y == 4.) {\n            // Pipes.\n\t\t\tc = vec3(1.85, .4, .235);\n\t\t\tspe = vec2(4, .3);\n\t\t}\n\t\telse if (h.y == 2.) {\n            // Chevrons.\n\t\t\tfloat f = step(-6., p.y) * step(max2(abs(p.xz * mat2(.7, .7, -.7, .7) - 2.)), 10.);\n\t\t\tc = mix(vec3(.2), f * (.01 + step(.5, fract(p.x + .75))) * vec3(16, 6, 1), f) * (.4 + .6 * n10);\n\t\t}\n\n\t\tsha = .3 + .7 * sat(S(-3.5, -2., p.y) + step(p.y, -5.));\n\n\t\t// Caustics.\n\t\tvec2 uv = proj(p, n) * .3 + t * .1,\n\t\t     dd = vec2(.1, 0);\n\t\tdd = vec2(surf(uv + dd, uv.yx + dd), surf(uv + dd.yx, uv.yx + dd.yx));\n\t\tc += pow(S01(abs(L((surf(uv, uv.yx) - dd) / .05) - .5)), 3.) * 4.;\n\t}\n\n\t// Primary and secondary lights.\n\tld2 = U(vec3(10, 15, 10) - p);\n\tl1 = sat(.1 + .9 * dot(ld, n)) * (.4 + .6 * ao);\n\tl2 = sat(dot(ld2, n)) * .01 + pow(sat(dot(rd, reflect(ld2, n))), spe.x) * spe.y;\n\tfre = S(.7, .8, 1. + dot(rd, n)) * .1;\n\n\t// Light falloff.\n\tl1 *= S(25., 1., L(vec3(0, -5, 0) - p)) * .8 + .025;\n\tl2 *= (.5 * S(30., 45., L(p)) + S(30., 5., L(vec3(10, 15, 10) - p))) * l2c * ao;\n\tl1 += S01(g2);\n\n\t// Combine into final color.\n\treturn mix(l1 * sha * vec3(.12, 1, 2.5) * c + l2, vec3(.012, .1, .25), fre * sha) + g;\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0),\n\t     col = vec3(0);\n\tfloat i, d;\n\n\t// March the water.\n\tfor (i = Z0; i < 70.; i++) {\n\t\td = wat(p);\n\t\tif (abs(d) < .0015) break;\n\t\tp += d * rd;\n\t}\n\n\tvec2 h;\n\tif (abs(d) < .0015) {\n\t\tvec3 ord,\n\t\t     n = Nw(p);\n\t\tcol = lights(p, rd, n, vec2(d, 1));\n\t\tvec3 watP = p;\n\t\tord = rd;\n\n\t\t// Hit the water - Get reflection.\n\t\trd = U(reflect(p, n));\n\t\tfor (i = Z0; i < 120.; i++) {\n\t\t\th = env(p);\n\t\t\tif (abs(h.x) < .0015) break;\n\t\t\tp += h.x * rd;\n\t\t}\n\n\t\tif (abs(h.x) < .0015) col = mix(col, lights(p, rd, Ne(p), h) * fog(watP - p), .5);\n\n\t\t// ...and now the refraction.\n\t\tp = watP;\n\t\trd = refract(ord, n, .75);\n\t}\n\telse p = vec3(0);\n\n\t// March the environment.\n\tfor (i = Z0; i < 70.; i++) {\n\t\th = env(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\tp += h.x * rd;\n\t}\n\n\treturn col + lights(p, rd, Ne(p), h) * fog(p);\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t) * S(40., 39., t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 m = mix(vec2(.744, .175), vec2(-.138, .138), S(0., 3.5, t)),\n\t\t uv = (fc - .5 * R.xy) / R.y,\n\t\t q = fc.xy / R.xy;\n\tm = mix(mix(mix(mix(mix(m, vec2(.031, -.208), S(2.5, 7., t)), vec2(.031, .042), S(8.5, 12., t)), vec2(.313, .208), S(16.5, 21., t)), vec2(.069, -.142), S(23., 28.5, t)), vec2(0, -.554), S(34., 37., t));\n\tvec3 lookAt = vec3(0, -.2, 1);\n\tlookAt.yz *= rot(m.y);\n\tlookAt.xz *= rot(m.x);\n\tvec3 r = U(cross(vec3(0, 1, 0), lookAt)),\n         col = scene(U(lookAt + r * uv.x + cross(lookAt, r) * uv.y));\n\tcol *= .1 + .9 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1095, 1471, 1490, 1490, 1831], [1833, 1833, 1872, 1872, 1954], [1956, 1956, 1976, 1976, 2000], [2002, 2002, 2022, 2022, 2053], [2055, 2055, 2074, 2074, 2141], [2143, 2143, 2170, 2170, 2236], [2238, 2238, 2266, 2266, 2319], [2321, 2321, 2375, 2375, 2450], [2452, 2485, 2512, 2512, 2597], [2599, 2599, 2629, 2629, 2762], [2764, 2764, 2793, 2793, 3090], [3092, 3092, 3111, 3111, 4539], [4541, 4541, 4570, 4570, 4639], [4641, 4641, 4659, 4659, 6227], [6229, 6252, 6269, 6269, 6483], [6485, 6502, 6519, 6519, 6731], [6733, 6761, 6796, 6796, 6851], [6853, 6853, 6872, 6872, 6905], [6907, 6907, 6953, 6953, 8603], [8605, 8605, 8626, 8626, 9442], [9532, 9532, 9592, 9592, 9675], [9677, 9677, 9722, 9722, 10357]], "test": "untested"}
{"id": "NdKGRt", "name": "Linear Shader Divider", "author": "JonathanMerfy", "description": "Linear Shader Divider", "tags": ["standart"], "likes": 2, "viewed": 28, "published": "Public", "date": "1631960102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    if (int(fragCoord.x) % 10 == 0) col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 352]], "test": "untested"}
{"id": "NdKGRz", "name": "No Basis In Reality", "author": "prishainabox", "description": "References to learn:\nInigo Quilez's website and videos.\nhttps://learnopengl.com/\nThe Book of Shaders: https://thebookofshaders.com/", "tags": ["raymarching"], "likes": 2, "viewed": 58, "published": "Public API", "date": "1631498340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.001;\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfEllipsoid(in vec3 pt, in vec3 rad) {\n    float k0 = length(pt/rad);\n    float k1 = length(pt/(rad*rad));\n    return k0 * (k0-1.0)/k1;\n}\n\nfloat sdfCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\n\n// SDF SCENE\n// materials\n// -1.0 -> sky\n// 0.0 -> grass\n\nvec4 sdfScene(in vec3 pt) {\n\n    float time = iTime;\n    \n    vec4 res = vec4(1000.0, -1.0, 0.0, 1.0);\n    \n    // water?\n    {\n        float water = sdfSphere(pt, 1.12) + 0.01 * (\n            sin(pt.x * 20.0 + sin(pt.y * 30.0) * 0.8) * \n            sin(pt.y * 20.0 + sin(pt.x * 10.0)) * \n            sin(pt.z * 20.0 + sin(pt.x * 10.0))\n        ) - 0.05 * fractalNoise(pt);\n        if(water > 2.0) return res;\n        if (water < res.x) {\n            res.y = 0.0;\n        }\n        res.x = min(res.x, water);\n    }\n    \n    // planet\n    {\n        float ground = 0.5 * sdfSphere(pt, 0.9) - 0.3 * fractalNoise(pt * 0.7);// - 0.05 * noise(pt);\n        ground -= 0.05 * sin(pt.x * 10.0) * sin(pt.y * 10.0) * sin(pt.z * 10.0);\n        if (ground < res.x) {\n            res.y = 1.0;\n        }\n        res.x = min(res.x, ground);\n    }\n    \n    return res;\n    \n}\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy).x - sdfScene(pt - h.xyy).x,\n       sdfScene(pt + h.yxy).x - sdfScene(pt - h.yxy).x,\n       sdfScene(pt + h.yyx).x - sdfScene(pt - h.yyx).x\n    ));\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd) {\n    \n    // result\n    // res.x = closest distance\n    // res.y = material\n    // res.z\n    // res.w\n    vec4 res = vec4(-1.0, -1.0, 0.0, 1.0);\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        vec4 h = sdfScene(ro + td*rd);\n        // if distance is really close, break\n        if (abs(h.x) < (0.0001*td)) {\n           res = vec4(td, h.yzw);\n           break;\n        }\n        // add to total distance\n        td += h.x;\n    }\n       \n    return res;\n    \n}\n\nfloat smoothShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        float d = sdfScene(ro + td*rd).x;\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in vec3 lightDir, in vec3 clr, in float shininess, in float shadowK) {\n    float dif = uclamp(dot(nor, lightDir));\n    float shadow = smoothShadow(pt, lightDir, shadowK);\n    vec3 ref = reflect(lightDir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), shininess);\n    // return  dif * clr * shadow * spec + dif * clr * shadow; \n    return  dif * clr * shadow * (spec + 1.0);\n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd) {\n\n    // cast ray, return dist to closest object and material\n    // obj.x = distance, obj.y = material index\n    // obj.z = , obj.w = \n    vec4 res = castRay(ro, rd);\n    vec3 pt = ro + res.x*rd;\n    \n    float time = iTime;\n    \n    // COLORS\n    vec3 planetClr = vec3(0.08, 0.01, 0.13);\n    vec3 skyClr = vec3(0.05, 0.18, 0.45) * 0.01;\n    vec3 waterClr = vec3(0.335, 0.214, 0.147);\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (res.x < 0.0) return clr;\n    \n    float mat = res.y; // material\n    float shininess = 5.0;\n    vec3 nor = calcNormal(pt);\n    \n    if (mat == 0.0) {\n        clr = waterClr;\n        shininess = 200.0;\n    } else if (mat == 1.0) {\n        shininess = 100.0;//(pow(random(pt), 2.0) * 2.0 - 1.0) * 50.0 + 100.0;\n        clr = planetClr - 0.1*fractalNoise(pt);// -  sin(pt.x * 7.0) * sin(pt.x * 5.0) * sin(pt.y * 10.0) * vec3(0.1, 0.02, 0.04) * fractalNoise(pt) * vec3(0.4, 0.2, 0.9);\n    }\n    \n    if (mat == 0.0 || mat == 1.0) {\n        float k = uclamp( \n            sin(pt.y * (40.0 + 10.0*(1.0 + sin(pt.y * 20.0))) + \n            sin(pt.z * 30.0 + sin(pt.x * 10.0))) \n        );\n        vec3 c = vec3(\n            0.1 + 0.31 * sin(pt.y * 10.0), \n            0.1 + 0.05 * sin(pt.z * 10.0), \n            0.08 + 0.02 * sin(pt.z * 20.0)\n        );\n        clr += k * c * (0.8 - 0.6*mat);\n        clr *= 0.3;\n    }\n    \n    // LIGHTS\n    \n    vec3 sunClr = 0.4 * vec3(9.8, 6.0, 5.5);\n    vec3 moonClr = vec3(2.13, 2.40, 3.46) * 0.5;\n    \n    vec3 sunDir = normalize(vec3(0.6, 0.55, 0.5) * 2.0 - pt); // directional\n    vec3 moonDir = normalize(vec3(-0.6, 0.0, -0.5) * 3.0 - pt);\n   \n    // CALCULATE COLOR\n    vec3 light = vec3(0.01);\n    light += calcLighting(pt, rd, nor, sunDir, sunClr, shininess, 10.0);\n    light += calcLighting(pt, rd, nor, moonDir, moonClr, shininess, 4.0);\n    // misc lights\n    light += 0.5 * calcLighting(\n        pt, rd, nor, \n        normalize(vec3(0.5, -0.2, 0.1) * 2.5 - pt), 0.5 * vec3(5, 2, 1),\n        shininess, 6.0\n    ); // orangey\n    light += 0.5 * calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.2, 0.5) * 2.3 - pt),\n        0.5 * vec3(8, 2, 4), shininess, 3.0\n    ); // red\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(1.9, 0.6, -0.9) * 0.62 - pt),\n        0.5 * vec3(4, 5, 2), shininess, 9.0\n    ); // yellow\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(-0.5, -0.2, 0.1) * 2.5 - pt),\n        vec3(1, 5, 3), shininess, 10.0\n    ); // blue green\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.0, 0.0, -0.5) * 3.0 - pt),\n        0.5 * vec3(6, 5, 4.5), shininess, 8.0\n    ); // pinkish\n    // misc moving lights\n    light += calcLighting(\n        pt, rd, nor,\n        normalize(vec3(0.2 + 0.4*sin(time * 5.0), -0.2 + 0.4*sin(time * 2.0), 0.5 - cos(time)) * 1.2 - pt),\n        vec3(2, 2, 5), shininess, 8.0\n    ); // blue\n    \n    clr *= light;\n    \n    clr = pow(clr, vec3(0.4545));\n    return clr;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime;\n    vec2 mouse = iMouse.xy;\n    vec2 res = iResolution.xy;\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0, 0.0, 0);\n    // ray origin\n    float r = 2.5;\n    vec3 ro = target + vec3(cos(time * 0.5) * r,  0.0, -sin(time * 0.5) * r);\n    \n    vec3 forward = normalize(target - ro); // cam w\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0))); // cam u\n    vec3 up = normalize(cross(right, forward)); // cam v\n    \n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    \n    // calculate color based on distance, etc\n    vec3 clr = calcClr(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 57, 82, 82, 117], [119, 151, 204, 204, 293], [295, 316, 342, 342, 395], [397, 397, 422, 422, 498], [500, 500, 525, 525, 610], [612, 612, 638, 638, 1322], [1324, 1324, 1357, 1357, 1560], [1562, 1571, 1614, 1614, 1645], [1647, 1647, 1692, 1692, 1791], [1793, 1793, 1857, 1857, 2001], [2004, 2062, 2089, 2089, 2919], [2921, 2921, 2950, 2950, 3253], [3255, 3255, 3293, 3394, 3816], [3818, 3818, 3874, 3874, 4266], [4268, 4268, 4393, 4393, 4700], [4702, 4702, 4740, 4875, 7763], [7765, 7765, 7822, 7822, 8591]], "test": "untested"}
{"id": "NdKGWD", "name": "Rotating cylinder", "author": "erikwolf", "description": "Rotating cylinder", "tags": ["rotating", "cylinder"], "likes": 6, "viewed": 60, "published": "Public", "date": "1631645306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXH 8\n#define RAD 1.5\n#define MAXC 14\n#define CAM_DIST 1.5\n\nmat4 transZMatrix(float zValue) {\n    return mat4(1., 0., 0., 0.,\n                0., 1., 0., 0.,\n                0., 0., 1., 0.,\n                0., 0., zValue, 1.);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from -.5 to .5)\n    uv -= .5;\n\n    // Isotropic (x: -.8889 .. .8889, y: -.5 to .5) for iResolution = <800, 450>\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Define points in space\n    vec3 points[MAXH*MAXC];\n    for (int h = 0; h < MAXH; ++h) {\n       float y = -3. + 6.*float(h)/float(MAXH - 1);\n       for (int i = 0; i < MAXC; ++i) {\n          float angle = float(i)/float(MAXC)*2.*radians(180.);\n          float x = RAD * cos(angle);\n          float z = RAD * sin(angle) - 12.;\n          points[h*MAXC + i] = vec3(x, y, z);\n       }\n    }\n\n    mat4 m = transZMatrix(-12.) * rotationMatrix(vec3(-1.,0.,1.), iTime) * transZMatrix(12.);\n    for (int i = 0; i < MAXH*MAXC; ++i) {\n       points[i] = (m * vec4(points[i], 1.)).xyz;\n    }\n    \n    // Camera position, ray to screen & color\n    vec3 camPos = vec3(0, 0, CAM_DIST);\n    vec3 rayToScreen = vec3(uv.xy, 0) - camPos;\n    vec3 clr = vec3(0., 0., 0.);\n    \n    for (int h = 0; h < MAXH; ++h) {\n        float q = 0.;\n        float g = float(h)/float(MAXH-1);\n        for (int i = 0; i < MAXC; ++i) {\n           vec3 pis = points[h*MAXC + i];  // Point in space\n\n           float parallelogramArea = length(cross(rayToScreen, pis - camPos));\n           float distanceFromRay = parallelogramArea / length(rayToScreen);\n\n           q = max(q, smoothstep(.15, .1, distanceFromRay));\n           clr = mix(clr, vec3(.9,g,0.), q);\n        }\n    }\n    fragColor = vec4(clr,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 102, 102, 237], [239, 239, 284, 284, 912], [914, 914, 971, 1021, 2535]], "test": "untested"}
{"id": "NdKGWG", "name": "brief study of iridescent snails", "author": "pali6", "description": "Ok, tehcnically just snail *shells* but that's better than no snail at all!\n\nVectors go brr until they hit a colour on a \"ring\" around the screen.\nNumber of iterations corresponds to saturation and value, angle corresponds to hue.", "tags": ["iterative"], "likes": 1, "viewed": 113, "published": "Public API", "date": "1632084252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER 40\n#define BOUNDARY 2.\n#define PI 3.141592653589\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime + 4.;\n    vec2 uv = fragCoord / iResolution.xy * 2. - vec2(1., 1.);\n    vec2 last = uv;\n    uv *= 2.;\n    \n    int i = 0;\n    for(; i < MAX_ITER; i++)\n    {\n        if(length(uv) > BOUNDARY)\n        {\n            uv = last + (uv - last) * ((BOUNDARY - length(last)) / (length(uv) - length(last)));\n            break;\n        }\n        last = uv;\n        uv = rotate(uv, 0.01 * PI * sin(time / 10.));\n        uv *= 1.03;\n        uv += vec2(cos(time / 5.), sin(time / 5.)) * 0.4;\n        uv += 0.5 * rotate(uv, PI / 2.);\n    }\n    if(false && length(uv) < BOUNDARY - 0.05)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    float h = atan(uv.y, uv.x) / (2. * PI) + 0.5;\n    float s = float(i) / float(MAX_ITER);\n    float v = s;\n    s *= 1.5;\n    fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 258], [260, 260, 290, 290, 374], [376, 376, 433, 433, 1258]], "test": "untested"}
{"id": "NdKGWh", "name": "XOR ripples (245 chars)", "author": "hnh", "description": "Drag the mouse to vary wavelength (x) and twist (y).\nMost reasonable settings are at bottom/center.", "tags": ["ripples", "interactive", "xor", "monochrome", "short", "golf"], "likes": 4, "viewed": 130, "published": "Public API", "date": "1631476327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nThis little shader is the result of messing around with https://www.shadertoy.com/view/NsKGRh \nand its shortened version by FabriceNeyret2.\nIt's some twist and rippling applied to a pattern generated from simple integer logic. \nIn FabriceNeyret2's https://www.shadertoy.com/view/MdlfRM you can see that the \"&\" operation\nresults in the typical XOR-pattern. \n*/\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n//*   // switch: \"//*\" -> \"/*\"\n// Shrinked, antialiased version by Xor\n\n    O-=O;\n    vec2 r,u,R = iResolution.xy,\n    m = iMouse.xy/R;\n    m = m==-m? vec2(.6,.07):m;\n    \n    for(int i = 0;i<9;)\n        u = U+vec2(i%3,i++/3)/3.,\n        r = length(u-= .5*R)+R-R,\n        u = u*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r,\n        O += sqrt(vec4(int(u) & int(u.y))/r.x)/9.;\n\n/*/\n// Minimal version (128 chars)\n// no mouse, antialiasing, gamma correction\n//  float r= length(U-= .5*iResolution.xy);\n//  U= U*sin(.05*r - 4.*iTime) + .3*r;\n//  O= vec4(int(U) & int(U.y))/r;\n\n\n// Original version\n  float r= length(U-= .5*iResolution.xy);\n  vec2 m= iMouse.xy/iResolution.xy;\n  if(m==vec2(0.)){m= vec2(.6,.07);}  // default parameters - better way?  \n  U= U*sin(r/exp(5.*m.x) - 4.*iTime) + 4.*m.y*r;\n  \n  // Variants\n  O= sqrt(vec4(int(U.x) & int(U.y))/r);\n  //O= vec4(int(U.x) & int(U.y))/r;  \n  //O= 6.*sqrt(vec4(int(U.x) & int(U.y)))/r;\n  //O= .5+log(vec4(int(U.x+r) & int(U.y+r))/r);  \n//*/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 366, 402, 473, 1391]], "test": "untested"}
{"id": "NdKGzz", "name": "2D fog", "author": "MrDevin", "description": "2D fog", "tags": ["2dfog"], "likes": 5, "viewed": 100, "published": "Public", "date": "1630983780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat random(vec2 _st)\n{\n    return fract(sin(dot(_st.xy,\n                         vec2(0.630, 0.710))) *\n        43759.329);\n}\n\n//柏林噪声\nfloat noise(vec2 _st)\n{\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 6\n\n//布朗分形\nfloat fbm(vec2 _st)\n{\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0, 100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n\n    for (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n        v += a * noise(_st);\n        //_st = mul(_st, rot) * 2.0 + shift;\n        _st = _st*rot * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 FilterColor(vec3 color1, vec3 color2)\n{\n    //变亮\n    //Y(亮度)=(0.299*R)+(0.587*G)+(0.114*B)\n    //float brightness1 = (0.299 * color1.r) + (0.587 * color1.g) + (0.114 * color1.b);\n    //float breghtness2 = (0.299 * color2.r) + (0.587 * color2.g) + (0.114 * color2.b);\n    //return brightness1 > breghtness2 ? color1 : color2;\n\n    //滤色\n    return 1.0 - (1.0 - color1) * (1.0 - color2);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 backcolor = texture(iChannel0, uv).rgb;\n    uv.y = 1.0 - uv.y;\n    \n    \n    vec2 st = uv * 10.0f;\n    st.x += iTime * 0.1f;\n    st.y -= iTime * 0.2f;\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    vec3 color;\n\n    vec2 q;\n    q.x = fbm(st + 0.00 * iTime*5.0);\n    q.y = fbm(st + vec2(1.0, 1.0));\n\n    vec2 r;\n    r.x = fbm(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime*5.0);\n    r.y = fbm(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime*5.0);\n\n    float f = fbm(st + r);\n\n    color = mix(vec3(1.0, 1.0, 1.0),\n                vec3(1.0, 1.0, 1.0),\n                clamp((f * f) * 4.0, 0.0, 1.0));\n\n    color = mix(color,\n                vec3(1.0, 1.0, 1.0),\n                clamp(length(q), 0.0, 1.0));\n\n    color = mix(color,\n                vec3(1.0, 1.0, 1.0),\n                clamp(length(r.x), 0.0, 1.0));\n\n    vec3 cloud = vec3((f * f * f + 0.3 * f * f + 0.5 * f) * color);\n\n    cloud = mix(vec3(0.0f, 0.0f, 0.0f), cloud, uv.y);\n    \n    fragColor = vec4(FilterColor(cloud, backcolor), 1.);\n    \n    \n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 27, 27, 130], [132, 147, 170, 170, 518], [543, 558, 579, 579, 937], [939, 939, 983, 1290, 1342], [1346, 1346, 1403, 1403, 2458]], "test": "untested"}
{"id": "Ndt3Ws", "name": "Badlands", "author": "jarble", "description": "A jagged rocky landscape based on zchajax's [url=https://www.shadertoy.com/view/3dXcW2]\"simple terrain\"[/url] shader.", "tags": ["noise", "terrain", "fbm", "erosion", "badlands"], "likes": 9, "viewed": 187, "published": "Public API", "date": "1631248183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    //return sin(uv.x/1.6)+cos(-uv.y*1.6);\n    return vec2(sin(uv.x/1.5),cos(uv.y*1.5));\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 1.;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        vec2 n2 = noise(uv * freq-n1);\n        n1 = abs(n2.x+n2.y-n1)-value;\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n1-.5) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.1;\n        \n        uv = uv.yx;\n        //value *= .9;\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos,OCTAVES);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,4)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    //if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    //}\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 87, 135], [156, 156, 191, 240, 721], [723, 723, 745, 745, 775], [777, 777, 807, 807, 857], [859, 859, 879, 879, 926], [928, 928, 961, 961, 1155], [1157, 1157, 1224, 1224, 1442], [1444, 1444, 1496, 1496, 2041], [2043, 2043, 2094, 2094, 2295], [2297, 2297, 2323, 2323, 2399], [2468, 2468, 2525, 2525, 4476]], "test": "untested"}
{"id": "NdtXR8", "name": "Rainbow screensaver animation", "author": "takumif", "description": " ", "tags": ["colorful", "animation", "background", "rainbow", "screensaver"], "likes": 2, "viewed": 140, "published": "Public API", "date": "1632615438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = iTime*0.2;\n    \n    // Calculate two points on screen.\n    \n    vec2 c1 = vec2(sin(time)*0.5, cos(iTime)*0.7);\n    vec2 c2 = vec2(sin(time*0.7)*0.9, cos(iTime*0.65)*0.6);\n    \n    //Determine length to point 1 & calculate color.\n    float d1 = length( uv - c1);\n    vec3 col1 = palette( d1+time,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\t\n    //Determine length to point 2 & calculate color.\n    float d2 = length( uv - c2);\n    vec3 col2 = palette( d2+time,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\n    \n    // Output to screen\n    fragColor = vec4( (col1+col2) / 2.0 ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 111, 111, 154], [156, 156, 213, 263, 968]], "test": "untested"}
{"id": "NdV3Dw", "name": "Crystal Ball Rainfall", "author": "Drakyen", "description": "@Tater suggested I upgrade the lighting on his geometry from https://www.shadertoy.com/view/fsV3WD , and I gladly did so!", "tags": ["3d", "raymarching", "transparency", "glow"], "likes": 20, "viewed": 159, "published": "Public", "date": "1631658446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Geometry by Tater\n//-------------------------------------------------------------\n#define pi 3.1415926535\n#define STEPS 500.0\n#define MDIST 200.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(453.2734,255.4363)))*994.3434);\n}\nvec3 rdg;\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat t; vec3 glw;\n\n\nvec2 mp(vec3 p)\n{  \n  vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    float t =iTime;\n    p.x+=t;\n    \n    float m = 2.;\n    \n    vec2 id3 = floor(p.xz/m)+0.5;\n    p.x+=id3.y;\n    vec2 id2 = floor(p.xz/m)+0.5;\n    float hash =h21(mod(id2,100.0));\n    p.y+=(hash-0.5);\n    id2*=rot(-pi/6.0);\n    p.y+=sin(id2.x+t)*0.7;\n    p.y+=sin(id2.x*0.6+t)*0.4;\n    p.y+=sin(id2.x*0.3+t)*0.2;\n    id2*=rot(pi/6.0)*0.3;\n    p.y+=sin(id2.y+t)*0.7;\n    po = p;\n    float dc = 0.;\n    {\n        vec3 p2=p/vec3(m);\n        vec3 id = floor(p2);\n        vec3 dir = sign(rdg)*.5;\n        vec3 q = fract(p2)-.5;\n        vec3 rc = (dir-q)/rdg;\n        rc*=m;\n        dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    }\n    p.xz = pmod(p.xz,m);\n    t+=hash*200.;\n    float spd = .025;\n    t*=spd;\n    float lscl = m;\n    float le = -mod(t * lscl,lscl); \n    float tscl = 650.; \n    float te = tscl - mod(t * tscl,tscl); \n    float scl = 0.; \n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            mid = true;\n            id = floor(t);\n        }\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    \n    a.x = length(p)-m*0.98*0.5;\n    b.x = length(p)-0.15*m;\n    b.x = max(-po.z-16.,b.x);\n    glw+=((0.01/(0.01+b.x*b.x))/35.)*m;\n    \n    a.x = max(-po.z-16.,a.x);\n    a.x = min(a.x,dc);\n    \n    if(mid)a.x = min(a.x,max(-(-po.y+le),0.1));\n    a.y = id+100.;\n    return a;\n}\n\n//Lighting and vfx by me!\n//--------------------------------------------------\nvec2 tr(vec3 ro, vec3 rd, float f)\n{\n  vec2 d = vec2(0);\n  for(int i = 0; i < 128; i++)\n  {\n    vec3 p=ro+rd*d.x;\n    vec2 s=mp(p);s.x*=f;\n    d.x+=s.x;d.y=s.y;\n    if(d.x>64.||s.x<0.001)break;\n  }\n  if(d.x>64.)d.y=0.;return d;\n}\n\nvec3 nm(vec3 p)\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 ro, vec3 n,vec4 bg)\n{\n  if(h.a==0.)return bg; \n  h.a=mod(h.a,3.)+1.;\n  vec4 a=h.a==1.?vec4(0.600,0.204,0.996,0.2):h.a==2.?vec4(0.000,0.431,1.000,0.3):vec4(0.761,0.239,1.000,0.4); \n  float d=dot(n,-rd);\n  float dd=max(d,0.); \n  float f=clamp(pow(1.-d,4.),0.,1.);\n  float s=(pow(abs(dot(reflect(rd,n),-rd)),40.)*10.);\n  if(h.a>1.)s*=0.05;\n  vec4 col = vec4(mix(a.rgb*dd+s,bg.rgb,f),a.a); \n  col.rgb = pow(col.rgb,vec3(0.6));;\n  col.rgb = mix(col.rgb,bg.rgb,clamp(length(h.xyz-ro*0.5)/50.,0.,1.));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  t=iTime;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1.); \n  float ts=1.,io=1.15;\n  vec3 ro = vec3(1,10,-25);\n  vec3 lk = vec3(1.01,2,0);\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));\n  vec4 bg = vec4(mix(vec3(0.102,0.239,0.557),vec3(0.678,0.565,0.996),max(rd.y+0.6,0.)),1.);\n  rdg=rd;vec3 rog=ro;\n  vec3 oro=ro,ord=rd,cp,cn,rc,cc;\n  for(int i=0;i<3;i++)\n  {\n    vec2 fh=tr(oro,ord,1.);\n    cp=oro+ord*fh.x;cn=nm(cp);\n    vec4 c=px(vec4(cp,fh.y),ord,oro,cn,bg);\n    if(fh.y==0.||c.a==1.) {cc=mix(cc,c.rgb,ts); break;}\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./io);\n    vec2 bh=tr(ro,rd,-1.);\n    cp=ro+rd*bh.x;cn=nm(cp);\n    oro=cp+cn*0.01;ord=refract(rd,-cn,io);\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn);\n    cc=mix(cc,c.rgb,ts);ts-=c.a;\n    if(ts<=0.)break;\n  }\n  cc = mix(cc+glw,bg.rgb,clamp(length(oro-rog*0.5)/60.,0.,1.));\n  fragColor=vec4(cc,1.);\n}\n//-------------------------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3Dw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 235, 253, 253, 319], [330, 330, 356, 356, 414], [436, 436, 453, 453, 2221], [2223, 2302, 2338, 2338, 2531], [2533, 2533, 2550, 2550, 2653], [2655, 2655, 2706, 2706, 3195], [3197, 3197, 3252, 3252, 4277]], "test": "untested"}
{"id": "NdV3WD", "name": "Black flower thing", "author": "SnoopethDuckDuck", "description": "messy code as always", "tags": ["cool"], "likes": 1, "viewed": 103, "published": "Public API", "date": "1631572308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.5 * iTime;\n\n    vec2 uv = (1.1 + 0.3 * cos(0.31 * t)) * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float theta = atan(uv.y, uv.x);\n    \n    float x = uv.x + 0.3 * cos(2. * theta + 1.1 * t);\n    float y = uv.y + 0.3 * sin(2. * theta + 1.1 * t);\n    \n    float d = max(abs(x) / abs(1.5 + y), abs(y) / abs(1.5 + x));\n    float d2 = max(abs(x), abs(y));\n    \n    float e = step(d, 0.2);\n    e *= (1.-5. * d);\n    e *= cos(t + 3. * theta) * sin(theta + 2. * t);\n    e = 4. * e * (1.-e);\n    e *= e;\n    \n    float e2 = step(d2, 0.2);\n    e2 *= (1.-5. * d2);\n    e2 *= cos(t + 3. * theta) * sin(theta + 2. * t);\n    e2 = 4. * e2 * (1.-e2);\n    e2 *= e2;\n    \n    fragColor = vec4(0.5* (1. + cos(uv.x + t)), 0.5 * (1. + sin(uv.y + t)), 1., 1.) * (1. - 4. * abs(e-e2));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3WD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 859]], "test": "untested"}
{"id": "NdV3Wh", "name": "Bouncing Truchet Tiling", "author": "xXx_T0SHIII_xXx", "description": "Playing around with Truchet Tiling, seeing what neat things I can do. Please drop some neat tricks to do with this and I'll see what I can do with it!\n\nThank you for checking out my Shader!! <3 ", "tags": ["math", "colorful", "shader", "truchet", "tiling", "artistic", "coding"], "likes": 7, "viewed": 67, "published": "Public", "date": "1631469201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash221(vec2 p)\n{\n  p = fract(p*vec2(234.34,456.23));\n  p+= dot(p,p+34.32);\n  return fract(p.x+p.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        //Control Variables\n        float tiling = cos(iTime/2.)*20.+20.;\n        float t = iTime;\n        float width = .1;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Rotation Variables\n    float Angle = (3.141592653589*t)/10.;\n    float A = cos(Angle);\n    float S = sin(Angle);\n    \n    //Rotate UV\n  uv*=mat2(A,-S,S,A);\n  \n  //Scale Uv by Tiling\n    vec2 bv = uv*tiling;\n    \n    //Make Grid\n    vec2 gv = fract(bv)-.5;\n    \n    //Set ids\n    vec2 id = floor(bv);\n    \n    //Random Flipping\n    float n = Hash221(id);\n    if(n<sin(t/2.)*.5+.5)gv.x*=-1.;\n    \n    //Color masks\n    float c = length(uv);\n    float c2 = length(gv);\n    \n    //Get Distances for lines\n    float d = abs(abs(gv.x+gv.y)-.5);\n    float d2 = length(gv-sign(gv.x+gv.y+0.001)*.5)-.5;\n    \n    //SmoothLines\n    float s = smoothstep(.01,-.01-1.5/iResolution.y,abs(d)-width); // Change d to d2 for Circular lines\n   \n    // visualize\n    vec3 col = vec3(s);\n    //if(gv.x >.48||gv.y>.48) col += 1.; //Draw Outline of each grid square\n    col.r *= sin(c-t); // Animated red Channel\n    col.g *= cos(c2+t)/2.; //Animated green channel\n    col.rgb -= c/1.; // Create Vignette\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdV3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 109], [111, 111, 168, 197, 1458]], "test": "untested"}
{"id": "NdVGRh", "name": "Area of a Squircle", "author": "oneshade", "description": "[url=https://www.youtube.com/watch?v=gjtTcyWL0NA]https://www.youtube.com/watch?v=gjtTcyWL0NA[/url]", "tags": ["math", "area", "squircle"], "likes": 17, "viewed": 127, "published": "Public", "date": "1631058676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Desmos graph: https://www.desmos.com/calculator/627ebn1ycs\n#define drawSDF(dist, col) color = mix(color, col.rgb, smoothstep(unit, 0.0, dist) * col.a)\n\n// https://www.shadertoy.com/view/3lfGD7\nfloat Gamma(in float x) {\n    const float pi = 3.14159265359;\n    float xx = x > 1.0 ? x : 1.0 - x;\n    float sum = 2.506628275635 + 225.525584619175 / (xx + 1.0) - 268.295973841305 / (xx + 2.0) + 80.9030806934622 / (xx + 3.0) - 5.007578639705 / (xx + 4.0) + 0.0114684895435 / (xx + 5.0);\n    float xh = xx + 5.65;\n    float y = exp((xx + 0.5) * log(xh) - xh) * sum / xx;\n    return x > 1.0 ? y : pi / (y * sin(pi * x));\n}\n\n// For general r, multiply by r^2\nfloat squircleArea(in float n) {\n    float a = Gamma(1.0 + 1.0 / n);\n    return 4.0 * a * a / Gamma(1.0 + 2.0 / n);\n}\n\nfloat dfSquircle(in vec2 p, in float r, in float n) {\n    return pow(pow(abs(p.x), n) + pow(abs(p.y), n), 1.0 / n) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(0.0, 0.169, 0.212);\n\n    // Shift the graph down and to the left side of the screen\n    vec2 shift = vec2(4.0 * iResolution.x / iResolution.y, 4.0);\n    uv += shift;\n\n    // Grid\n    drawSDF(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec4(0.0, 0.25, 0.5, 1.0));\n    drawSDF(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec4(0.0, 0.25, 0.5, 1.0));\n\n    // Draw the function\n    vec2 y = vec2(squircleArea(uv.x), 0.0);\n    y.y = (squircleArea(uv.x + 0.001) - y.x) / 0.001;\n    drawSDF(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.01, vec4(1.0, 0.0, 0.8, 1.0));\n\n    uv -= shift;\n\n    float n = mix(0.5, 10.0, 0.5 + 0.5 * sin(0.5 * iTime));\n    float r = 2.0;\n\n    float eps = 0.001;\n    float squircle = dfSquircle(uv, r, n);\n    squircle /= length((vec2(dfSquircle(uv + vec2(eps, 0.0), r, n), dfSquircle(uv + vec2(0.0, eps), r, n)) - squircle)) / eps;\n\n    uv += shift;\n    drawSDF(abs(uv.x - n), vec4(1.0, 0.0, 0.0, 1.0));\n    drawSDF(length(uv - vec2(n, squircleArea(n))) - 0.1, vec4(1.0, 0.8, 0.0, 1.0));\n\n    drawSDF(squircle, vec4(0.0, 1.0, 0.0, 0.25));\n    drawSDF(abs(squircle), vec4(0.0, 1.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 196, 221, 221, 618], [620, 654, 686, 686, 771], [773, 773, 826, 826, 894], [896, 896, 951, 951, 2232]], "test": "untested"}
{"id": "NdVGWz", "name": "Slowtember10-12: Cafe/Date", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 12, "viewed": 182, "published": "Public API", "date": "1631355126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define FAR 10.0\n#define MAX_RAY 92\n#define MAX_REF 16\n#define FOV 1.57\n#define OBJ_MIN_D 0.01\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nfloat smin( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\nfloat smod(float x, float m) {\n    return (1. - step(m * .95, mod(x, m))) * min(m, mod(x, m) * 1.05) + step(m * .95, mod(x, m)) * min(m, mod(-x, m) * 40.); \n}\n\nvec3 rot(vec3 v, vec3 c, vec3 a) {\n    return (v - c)\n    * mat3(1, 0, 0,\n         0, cos(a.x * 2. * PI), sin(a.x * 2. * PI),\n         0, -sin(a.x * 2. * PI), cos(a.x * 2. * PI))\n    * mat3(cos(a.y * 2. * PI), 0, sin(a.y * 2. * PI),\n         0, 1, 0,\n         -sin(a.y * 2. * PI), 0, cos(a.y * 2. * PI))\n    * mat3(cos(a.z * 2. * PI), sin(a.z * 2. * PI), 0,\n         -sin(a.z * 2. * PI), cos(a.z * 2. * PI), 0,\n         0, 0, 1) + c;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere(vec3 q, vec3 p, float r) {\n    return length(q - p) - r;\n}\n\nfloat plane(vec3 q, vec3 d, float offset) {\n    return dot(d, q) + offset;\n}\n\nfloat capsule(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab1 = p2 - p1;\n    vec3 ap1 = q - p1;\n    float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n    t1 = clamp(t1, 0., 1.);\n    vec3 c1 = p1 + t1 * ab1;\n    return length(q - c1) - r;\n}\n\nfloat torus(vec3 q, vec3 p, float r1, float r2) {\n    q -= p;\n    float x = length(q.xz) - r1;\n    return length(vec2(x, q.y)) - r2;\n}\n\nfloat box(vec3 q, vec3 p, vec3 s, float r) {\n    return length(max(abs(q - p) - s + r, 0.)) - r;\n}\n\nfloat cyl(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab2 = p2 - p1;\n    vec3 ap2 = q - p1;\n    float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n    vec3 c2 = p1 + t2 * ab2;\n    float d = length(q - c2) - r;\n    float y = (abs(t2 - .5) - .5) * length(ab2);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    return e + i;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define OBJ_COUNT 6\n\nfloat objects[OBJ_COUNT] = float[](FAR, FAR, FAR, FAR, FAR, FAR);\nvec3 objectsColor[OBJ_COUNT] = vec3[](vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.));\nconst float objectsRef[OBJ_COUNT] = float[](.4,.0,.0,.0,.3,.1);\n\nvoid setObjects(vec3 q) {\n    objects[0] = FAR;\n    objects[0] = min(objects[0], plane(q, vec3(.0, 1., .0), 0.));\n    \n    vec3 q2 = q;\n    q2.x = mod(q.x, 2.);\n    q2.z = mod(q.z, 1.);\n    \n    float chair_seed = abs(floor(q.x)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    float table_seed = abs(floor(q.x * .5)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    \n    vec3 q3 = q2;\n    if(q2.x < 1.) {\n        q3.x = 1. - q2.x + .1 * rand(chair_seed++);\n    } else if (q2.x < 2.) {\n        q3.x -= 1. + .1 * rand(chair_seed++);\n    }\n    \n    vec3 q4 = rot(q3, vec3(.5), vec3(.0, .04 * (rand(chair_seed++) - .5),.0));\n    \n    objects[1] = FAR;\n    objects[1] = min(objects[1], box(q4, vec3(.5, .3, .5), vec3(.2, .02, .2), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .69), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .31), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .31), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .69), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .59, .5), vec3(.01, .05, .2), .005));\n    \n    objects[2] = FAR;\n    objects[2] = min(objects[2], box(q4, vec3(.49, .33, .5), vec3(.24, .02 + .0005 * sin(q2.x * 200.) * sin(q2.z * 200.), .25), .1));\n    objects[2] = min(objects[2], box(q4, vec3(.65, .59, .5), vec3(.03 + .0005 * sin(q2.y * 200.) * sin(q2.z * 200.), .1, .22), .05));\n    \n    q2 = rot(q2, vec3(.5), vec3(.0, .01 * (rand(table_seed++) - .5),.0));\n    \n    objects[3] = FAR;\n    objects[3] = min(objects[3], box(q2, vec3(1., .5, .5), vec3(.3, .02, .3), .0));\n    \n    objects[4] = FAR;\n    objects[4] = min(objects[4], cyl(q2, vec3(1., .0, .5), vec3(1., .5, .5), .05));\n    \n    vec3 cup_center = vec3(.2 - .1 * rand(chair_seed++), .0, .5 + .2 * (rand(chair_seed++) - .5));\n    \n    vec3 q5 = rot(q3, cup_center, vec3(.0, rand(chair_seed++),.0));\n    \n    objects[5] = FAR;\n    objects[5] = min(objects[5], cyl(q5, cup_center + vec3(.0, .51 + length(q3.xz - cup_center.xz)* .3, .0), cup_center + vec3(.0, .52  + length(q3.xz - cup_center.xz)* .3, .0), .04));\n    objects[5] = min(objects[5], torus(q5, cup_center + vec3(.0, clamp(q3.y, .54, .56), .0), .02 + (q3.y - .54) * .6, .004));\n    \n    objects[5] = min(objects[5], torus(rot(q5, cup_center + vec3(.0, .55, .04), vec3(.0, .0, .25)), cup_center + vec3(.0, .55, .04), .01, .004));\n}\n\n#define TILING .3\n\nvoid setObjectColors(vec3 q) {\n\n    bool tile = (mod(q.x, 2. * TILING) < TILING) ^^ (mod(q.z, 2. * TILING) < TILING);\n\n    objectsColor[0] = tile ? vec3(.9) : vec3(.4, .0, .0);\n    objectsColor[1] = vec3(.8, .3, .1);\n    objectsColor[2] = vec3(.9);\n    objectsColor[3] = vec3(.8, .3, .1);\n    objectsColor[4] = vec3(.3);\n}\n\nfloat map(vec3 q) {\n    float d = FAR;\n    \n    setObjects(q);\n    \n    for(int i = 0; i < OBJ_COUNT; i++)\n        d = min(d, objects[i]);\n    \n    return d;\n}\n\nvec3 mapColor(vec3 q, float t) {\n    setObjects(q);\n    setObjectColors(q);\n    \n    vec3 c = vec3(.0);\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             c = objectsColor[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return c;\n}\n\nfloat mapRef(vec3 q, float t) {\n    setObjects(q);\n    \n    float ref = .0;\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             ref = objectsRef[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return ref;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, int max_d) {\n    float t = 0., d;\n    for(int i = 0; i < max_d; i++){\n        d = map(ro + rd * t);\n        if(abs(d) < .001 * (t * .25 + 1.) || t > FAR)  break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    //Tetrahedral normal\n    const vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 getHitColor(vec3 ro, vec3 rd, float t, vec3 lightPos) {\n    vec3 hit = ro + rd * t;\n    vec3 norm = normal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = mapColor(hit, t) * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return vec4(color, atten * occ);\n}\n\nvec3 getColor(vec2 uv, vec3 ro, vec3 dir, vec3 lightPos) {\n    vec3 fwd = normalize(dir);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    float t = rayMarch(ro, rd, MAX_RAY);\n    \n    vec3 outColor = vec3(.0);\n    \n    if(t < FAR) {\n        vec3 hit = ro + rd * t;\n        vec3 norm = normal(hit);\n        vec4 color = getHitColor(ro, rd, t, lightPos);\n        \n        vec3 ref = reflect(rd, norm);\n        float refQ = mapRef(hit, t);\n        float t2 = refQ <= .001 ? .0 : rayMarch(hit + ref * .1, ref, MAX_REF);\n        vec4 color2 = refQ <= .001 ? vec4(.0) : getHitColor(hit + ref * .1, ref, t2, lightPos);\n    \n        outColor = (color.xyz * (1. - refQ) + refQ * color2.xyz * color2.w) * color.w;\n    }\n    \n    outColor = mix(min(outColor, 1.), vec3(.0), 1. - exp(-t*t/FAR/FAR*10.));\n    \n    return outColor;\n}\n\n#define CAMERA_SPEED .5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pos = vec3(1. + 3. * cos(iTime * CAMERA_SPEED), 1. + sin(iTime * CAMERA_SPEED) * .2, 3. * sin(iTime * CAMERA_SPEED));\n    vec3 dir = vec3(3. * cos(iTime * CAMERA_SPEED + PI), -1.5, 3. * sin(iTime * CAMERA_SPEED + PI));\n    vec3 light = vec3(.0, 4., .0);\n    \n    vec3 c = getColor(uv, pos, dir, light);\n    \n    fragColor = vec4(sqrt(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 277, 301, 301, 386], [388, 388, 407, 407, 576], [578, 578, 618, 618, 712], [714, 714, 744, 744, 872], [874, 874, 908, 908, 1309], [1311, 1474, 1513, 1513, 1545], [1547, 1547, 1590, 1590, 1623], [1625, 1625, 1675, 1675, 1858], [1860, 1860, 1909, 1909, 1994], [1996, 1996, 2040, 2040, 2094], [2096, 2096, 2142, 2142, 2444], [2446, 2861, 2886, 2886, 5299], [5320, 5320, 5350, 5350, 5642], [5644, 5644, 5663, 5663, 5803], [5805, 5805, 5837, 5837, 6159], [6161, 6161, 6192, 6192, 6489], [6492, 6492, 6537, 6537, 6724], [6726, 6726, 6747, 6772, 6938], [6940, 6940, 6977, 6977, 7247], [7250, 7413, 7473, 7473, 8071], [8073, 8073, 8131, 8131, 8998], [9025, 9025, 9080, 9080, 9535]], "test": "untested"}
{"id": "NdVGzR", "name": "Fork Sum Zero Inverted", "author": "deerfeeder", "description": " ", "tags": ["basic"], "likes": 0, "viewed": 37, "published": "Public", "date": "1630966197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float s = 16.0;\n    // Time varying pixel color\n    vec3 col = 4.0*cos(iTime+uv.xyx*vec3(s*sin(iTime*0.01),s*cos(iTime*0.02),s*cos(uv.x+iTime*0.06)));\n       col = abs(col);\n    // Output to screen\n    fragColor = vec4(vec3(col.x*col.y*col.z),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVGzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 402]], "test": "untested"}
{"id": "Ndy3DV", "name": "Dune sandstorm", "author": "klk", "description": "Multioctave sine waves. Pseudo 3D desert landscape.", "tags": ["2d", "sand", "dune"], "likes": 8, "viewed": 233, "published": "Public API", "date": "1632175610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void wave(inout float x, inout float y, inout float z, float T, int octaves, float a)\n{\n\tfloat R=8.;\n\tfloat S=.03;\n\tfloat W=-.05;\n\t#define RRRRS R*=.72;S*=1.27;W*=1.21;\n\tfor(int s=0;s<octaves;s++)\n\t{\n\t\tfloat da=1.8+(sin(T*0.021)*0.1+.41*sin(float(s)*.71+T*0.02))*a;\n\t\tfloat dx=cos(da);\n\t\tfloat dy=sin(da);\n\t\tfloat t=-dot(vec2(x-320.,y-240.),vec2(dx,dy));\n\t\tfloat sa=sin(T*W+t*S)*R;\n\t\tfloat ca=cos(T*W+t*S)*R;\n\n\t\tx-=ca*dx*2.;\n\t\ty-=ca*dy*2.;\n\t\tz-=sa;\n\t\tRRRRS\n\t}\n}\n\nfloat chkr(vec2 p, float t)\n{\n    vec2 fxy=vec2(p.x,p.y);\n  \tfxy=abs(fract((fxy+0.5)/2.0)-0.5)-0.25;\n    fxy=clamp(fxy*t+0.5,0.0,1.0);\n    float f=mix(fxy.x,1.0-fxy.x,fxy.y);\n    return f;\n}\n\nfloat tex(vec2 p)\n{\n    //return chkr(p*.1,100.);\n    float z=0.;\n    p=vec2(p.x+p.y*.3,p.y-p.x*.3);\n    p.x=p.x+17.;\n    p.y=p.y-150.;\n    wave(p.x, p.y, z, 12.21-iTime*.01,6,10.);\n    p.x*=18.;\n    p.y*=19.;\n    return sin(p.y*0.04+.1*z)*z*.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*vec2(640.,480.);\n    vec2 uv0=uv;\n    float z=0.;\n    wave(uv.x, uv.y, z, iTime*20., 17,1.);\n    z=z+22.;\n    z*=0.018;\n    vec3 col = vec3(.3+z*1.2,.2+z*.9,.1+z*.6);\n    uv=uv0+0.5*(uv-uv0);\n    //col.rgb*=.9+.1*vec3(.75+.25*tex(vec2(uv0.x,uv.y+iTime*10.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 461], [463, 463, 492, 492, 653], [655, 655, 674, 704, 902], [904, 904, 961, 961, 1293]], "test": "untested"}
{"id": "Ndy3RG", "name": "Wave Room 3", "author": "dr2", "description": "Kinetic art in a pentakis dodecahedral room", "tags": ["waves", "projection", "pentakis"], "likes": 8, "viewed": 191, "published": "Public API", "date": "1631707053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wave Room 3\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar, tWav;\nint idObj;\nconst int idFace = 1, idEdge = 2;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  p.yz = Rot2D (p.yz, 0.067 * pi);\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2, s;\n  dMin = dstFar;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  s = abs (dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) + 2.);\n  d = SmoothMax (s - 0.07, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.03, 0.02);\n  DMIN (idEdge);\n  d = s - 0.02;\n  DMIN (idFace);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 4; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 8.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (- normalize (vec3 (0.4 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hn4;\n  vec3 col, vn, ltDir;\n  vec2 u;\n  float dstObj, rAz, rEl;\n  tWav = 0.2 * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idEdge) {\n      col4 = vec4 (0.95, 0.95, 1., 0.2);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == idFace) {\n      rAz = atan (ro.x, ro.z);\n      rEl = asin (ro.y / length (ro));\n      u = vec2 (rAz + pi, tan (2. * atan (0.5 * rEl))) / (2. * pi);\n      hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n      vn = StdVuMat (rEl, rAz) * normalize (hn4.xyz);\n      col4 = vec4 (mix (vec3 (1., 1., 0.3), vec3 (1., 0.4, 0.), smoothstep (0.3, 1., hn4.w)), 0.2);\n    }\n    ltDir = normalize (- ro);\n    col = col4.rgb * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * pi * tCur;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.8);\n  zmFac = 1.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = vec2 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac, uv.y);\n    rd = vuMat * normalize (vec3 (uvv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3RG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 557, 581, 581, 1166], [1168, 1168, 1190, 1190, 1638], [1640, 1640, 1673, 1673, 1856], [1858, 1858, 1879, 1879, 2136], [2138, 2138, 2161, 2161, 2694], [2696, 2696, 2719, 2719, 2946], [2948, 2948, 2983, 2983, 3878], [3895, 3895, 3951, 3951, 5015], [5017, 5017, 5048, 5048, 5112], [5114, 5114, 5159, 5159, 5251], [5253, 5253, 5298, 5298, 5336], [5338, 5338, 5368, 5368, 5481], [5483, 5483, 5519, 5519, 5725], [5759, 5759, 5783, 5783, 5895], [5897, 5897, 5922, 5922, 6108], [6110, 6110, 6139, 6139, 6351], [6353, 6353, 6392, 6392, 6649]], "test": "untested"}
{"id": "Ndy3zG", "name": "brotrenderer", "author": "samk9632", "description": "brot", "tags": ["fractal"], "likes": 18, "viewed": 215, "published": "Public", "date": "1631728174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float l = length(pos);\n    vec3 poss = pos;\n    float xx = poss.x*cos(rotation.y)+poss.z*sin(rotation.y);\n    float yy = poss.y;\n    \n    float zz = -pos.x*sin(rotation.y)+poss.z*cos(rotation.y);\n    \n    return vec3(xx, yy, zz);\n}\n\nvec3 fractal(vec3 coords, int iterations, float degreee, float xRot) {\n    float pi = 3.1415926;\n    float degree = 7.0;\n    vec3 coordsMod = coords.xyz;\n    for (int i = 0; i < iterations; i++) {\n        vec3 UV = vec3(coordsMod.xyz);\n        UV = vec3(1.0*length(UV), abs(UV.y)/UV.y*acos(UV.x/length(UV.xy))+xRot, abs(UV.z)/UV.z*asin(abs(UV.z)/length(UV)));\n        coordsMod = coords.xyz+pow(UV.x, degree)*vec3(cos(degree*UV.y)*cos(degree*UV.z), sin(degree*UV.y)*cos(degree*UV.z), sin(degree*UV.z));\n        \n    }\n    if (length(coordsMod) < 2.0) {\n        return vec3(0.3, 0.5, 1.0);\n        //return vec3(1.0);\n    } else {\n        return vec3(0.0);\n    }\n    \n    \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayCast(vec3 dir, vec3 pos, float xRot, vec2 coord) {\n    float density = 500.0;\n    float anisotropy = 0.0;\n    float pi = 3.1415926;\n    vec3 o = vec3(0.0);\n    float stepSize = 0.02;\n    float lightingStepSize = 0.05;\n    vec3 p = pos+dir*stepSize*rand(coord.xy);\n    vec3 n = vec3(0.0);\n    vec3 lightingDir = vec3(cos(-xRot+iTime*0.5), sin(-xRot+iTime*0.5), -sin(iTime*2.718/4.0));\n    lightingDir = lightingDir/length(lightingDir);\n    \n    float a = dot(dir, dir);\n    float b = 2.0*dot(dir, pos);\n    float c = dot(pos, pos) - pow(2.0, 2.0);\n    float discriminant = b*b-4.0*a*c;\n    \n    if (discriminant > 0.0) {\n        vec3 inPos = (-b - sqrt(discriminant))/(2.0*a)*dir+pos;\n        vec3 outPos = (-b + sqrt(discriminant))/(2.0*a)*dir+pos;\n        p = inPos+dir*stepSize*rand(coord.xy);\n        for (float j = 0.0; j < length(inPos-outPos); j += stepSize) {\n            p += dir*stepSize;\n            vec3 pp = p+lightingStepSize*lightingDir*rand(coord.xy);\n            vec3 l = vec3(0.0);\n            vec3 m;\n            if (length(p) < 2.0) {\n                m = fractal(p, 4, 8.0, xRot+iTime*0.0)*stepSize;\n                o += m;\n                if (length(o) > 1.0) {\n                    j = 2.0 + length(pos);\n                }\n            } else {\n                m = vec3(0.0);\n            }\n            if (length(m) > 0.0) {\n                for (vec3 k = p; length(pp) < 2.0; pp -= lightingStepSize*lightingDir) {\n                    l += fractal(pp, 4, 8.0, xRot)*stepSize;\n                    if (length(l) > 1.0) {\n                        pp = vec3(2.0);\n                \n                    }\n                }\n            }\n            \n            vec3 q = vec3(0.0);\n            q.x = stepSize*m.x*density*pow(2.0, -density*stepSize*length(o.x))*pow(2.0, -density*stepSize*length(l.x));\n            q.y = stepSize*m.y*density*pow(2.0, -density*stepSize*length(o.y))*pow(2.0, -density*stepSize*length(l.y));\n            q.z = stepSize*m.z*density*pow(2.0, -density*stepSize*length(o.z))*pow(2.0, -density*stepSize*length(l.z));\n            float cloudValAdjust = 0.3;\n            float cloudVal = 0.0;\n            float minV = 0.0;\n            float maxV = 1.0;\n            anisotropy = clamp((length(o*cloudValAdjust)/(length(o*cloudValAdjust)+1.0)-minV)/(maxV-minV), 0.0, 1.0)*-cloudVal+clamp(1.0-(length(o*cloudValAdjust)/(length(o*cloudValAdjust)+1.0)-minV)/(maxV-minV), 0.0, 1.0)*cloudVal;\n            if (anisotropy >= 0.0) {\n                q*=(1.0-anisotropy+pow(2.7, -anisotropy/(1.0-anisotropy)*(1.0-dot(-dir, lightingDir))));\n            } else {\n                q*=(1.0+anisotropy+pow(2.7, anisotropy/(1.0+anisotropy)*(1.0-dot(dir, lightingDir))));\n            }\n            n.x+=q.x;\n            n.y+=q.y;\n            n.z+=q.z;\n        }\n    }\n    return n;\n    \n    //return vec3(dot(dir, lightingDir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.x-0.5);\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    \n    //RayCasting\n    float dof = 1.0;\n    float r = 5.0;\n    float s = 10.0;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(-iTime*0.2, -s*(mouse.y+pi/2.0)));\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(iTime*0.2, s*(mouse.y+pi/2.0)));\n    \n    // Time varying pixel color\n    vec3 col = rayCast(camDir, camPos, -s*mouse.x, fragCoord);\n    \n    //col = (log(1.+col));\n    //col = clamp(col,0.,1.);\n    col *= 2.0;\n    col = col/(col+vec3(1.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndy3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 387], [389, 389, 459, 459, 1062], [1064, 1064, 1084, 1084, 1154], [1156, 1156, 1214, 1214, 4008], [4010, 4010, 4067, 4067, 4864]], "test": "untested"}
{"id": "NdyGD1", "name": "Spinny Frenzy", "author": "xXx_T0SHIII_xXx", "description": "Just something interesting I made using what I've learned from Tutorials and articles. \n\nHuge thank you to everyone who comments helpful tips and advice on my projects. It really means alot to learn for you guys and I really appreciate it! ", "tags": ["simple", "colorful", "animated", "trippy", "looping", "satisfying"], "likes": 1, "viewed": 52, "published": "Public", "date": "1631418027", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n\nfloat Xor(float a, float b)\n{\n    return a*(1.-b)+b*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n//Control Variables\nfloat t = iTime;\nfloat tiling = 4.;\nfloat tiles = 4.;\nfloat r = .3;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //Rotation variables\n    float A = PI*t/10.;\n    float e = cos(A);\n    float u = sin(A);\n    \n    //Rotate uv using rotation matrice\n    uv *= mat2(e,-u,u,e);\n    \n    //scale uv\n    vec2 bv = uv*tiling;\n    \n    //create grid\n    vec2 gv = fract(bv)-.5;\n    \n    //make ids\n    vec2 id = floor(bv);\n    vec2 id2 = fract(id/(tiles))-.5;\n    \n    //Make Circles\n    float d = length(uv);\n    float d2 = length(gv);\n    float d3 = length(id);\n    \n    //Smooth Circles\n    float c = smoothstep(r,r-1.5/iResolution.y,d);\n    float c2 = smoothstep(r,r-1.5/iResolution.y,d2);\n    float q = 0.;\n    \n    //Take in account circles adjacent to each other for overlapping\n    for(float y=-1.;y<=1.;y++)\n    {\n        for(float x=-1.;x<=1.;x++)\n        {\n            vec2 offs = vec2(x,y);\n            float d5 = length(gv - offs);\n            float d4 = length(id2+offs)*.3;\n            \n            r =  mix(.3,1.5,sin(t-d4)*.5+.5); \n            q =Xor(q, smoothstep(r,r-1.5/iResolution.y,d5));\n            \n        }\n    }\n    \n    \n    \n\n   //Visualize\n    vec3 col = vec3(0.);\n    col += q;\n    col.r *= sin(t-d)*2.;\n    col.g *= cos(t+d2)*3.;\n    col.b *= cos(col.r*col.g)*.5+.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyGD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 56, 56, 88], [90, 90, 147, 168, 1589]], "test": "untested"}
{"id": "NdyGRz", "name": "Smoothed Line Segment but jank", "author": "TimArt", "description": "Modified https://www.shadertoy.com/view/3tdSDj by IQ\n\nTrying to get a smoothed line segment SDF. Used smoothstep, but this approach suffers from artifacts when the line is vertical.", "tags": ["2d", "distancefield", "sdf", "line", "distance", "segment"], "likes": 1, "viewed": 120, "published": "Public API", "date": "1630946263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and line segment\n\n// Segment:              https://www.shadertoy.com/view/3tdSDj\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat normalizedX = (p.x - a.x) / (b.x - a.x);\n    float lineCenterY = mix (a.y, b.y, smoothstep(0.0f, 1.0f, normalizedX));\n    return lineCenterY - p.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tfloat zoom = 2.5;\n\tpos *= zoom;\n\n\tvec2 v1 = cos(iTime + vec2(0.,5.));\n\tvec2 v2 = cos(iTime + vec2(0.,5.) + 3.1);\n\tfloat thickness = .2 * (.5 + .5 * sin(iTime * 1.));\n\n\tfloat d = line_segment(pos, v1, v2) - thickness;\n\n\tvec3 color = vec3(1.) - sign(d) * vec3(0., 0., 0.);\n\tcolor *= 1.5 - exp(.5 * abs(d));\n\tcolor *= .5 + .3 * cos(120. * d);\n\tcolor = mix(color, vec3(1.), 1. - smoothstep(.0, .015, abs(d)));\n\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyGRz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1115, 1279, 1332, 1332, 1525], [1527, 1527, 1582, 1582, 2085]], "test": "untested"}
{"id": "NlSSD1", "name": "Inverted Hearts", "author": "rattlesneker", "description": "Quantization", "tags": ["quantization"], "likes": 2, "viewed": 74, "published": "Public", "date": "1632160436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int COLORS_SIZE = 4;\nconst vec3 ERR_COLOR = vec3(0.0, 0.0, 0.0);\n\nconst int SAMPLES_S = 4;\nconst int N_SAMPLES = SAMPLES_S * SAMPLES_S;\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat function(float x, float y, float t)\n{\n    float t2 = t / 2.0;\n    float t5 = t / 4.0;\n    float st2 = sin(t2);\n    float st5 = sin(t5);\n    float ct5 = cos(t5);\n    float tt5 = tan(t5);\n    \n    //return (x - st5 * 1.5*y) / (sin(st2 * x + y) * tan(st5 * x - y) + 3.0*sin(ct5 * x + y) + 0.1*st2*y);\n    //return (x - st5 * y) / (sin(x + st2 * y) * tan(st5 * x - y) + 4.0*sin(x + y) + 0.1*st2*y);\n    //return (x - y) / (sin(x + y) * tan(t7 * x - y) + 4.0*sin(x + y) + 0.1*t2 * y);\n    \n    //return (x - y) / (sin(x + y) * tan(x - y) + 4.0*sin(x + y) + 0.1*y);\n    //return (x - y) / (sin(t2 + x + y) * tan(x - y) + 4.0*sin(x + y) + 0.1*y);\n    return (tt5 + x - st5 * 1.5*y) / (sin(t2 + x + y) * tan(st5 * x - y) + 4.0*sin(x + y) + 0.1*st2*y);\n    //return tt5 * (x - 1.5*y) / (sin(x + y) * tan(x - y) + st5 * 3.0*sin(x + y) + 0.1*y);\n}\n\nvec2[N_SAMPLES] supersampling(vec2 coord, float pixSize)\n{\n    float sampleSize = pixSize / float(SAMPLES_S);\n    vec2 leftUp = coord - pixSize / 2.0 + sampleSize / 2.0; \n    \n    vec2 samples[N_SAMPLES];\n    for (int i = 0; i < SAMPLES_S; i++)\n    {\n        for (int j = 0; j < SAMPLES_S; j++)\n        {\n            vec2 sampl = leftUp + vec2(sampleSize * float(j), sampleSize * float(i)); \n            samples[i * SAMPLES_S + j] = sampl;\n        }\n    }\n    return samples;    \n}\n\nfloat atan2(float y, float x)\n{\n    if (x > 0.0)\n    {\n        return atan(y / x);\n    }\n    else if (x < 0.0 && y >= 0.0)\n    {\n        return atan(y / x) + M_PI;\n    }    \n    else if (x < 0.0 && y < 0.0)\n    {\n        return atan(y / x) - M_PI;\n    }\n    else if (x == 0.0 && y > 0.0)\n    {\n        return M_PI / 2.0;\n    }\n    else if (x == 0.0 && y < 0.0)\n    {\n        return -M_PI / 2.0; \n    }\n    return 0.0; // undefined\n}\n\n// transform classic uv into carthesian coordinates and use defined domains\nvec2 uvToCarthesian(vec2 uv, vec2 xDomain, vec2 yDomain)\n{\n    float x = xDomain.x + uv.x * (xDomain.y - xDomain.x);\n    float y = yDomain.x + uv.y * (yDomain.y - yDomain.x);\n    return vec2(x, y);\n}\n\n// transform quadrants into polar coordinates and use defined domains\nvec2 quadToPolar(vec2 quad, vec2 rDomain, vec2 phiDomain)\n{   \n    float r = sqrt(dot(quad, quad));\n    float extR = r * (rDomain.y - rDomain.x) + rDomain.x;\n    // Normalize phi and revert\n    float phi = 1.0 - abs(atan2(quad.y, quad.x)) / M_PI; \n    float extPhi = phi * (phiDomain.y - phiDomain.x) + phiDomain.x;\n    return vec2(extR, extPhi);\n}\n\nvec3 getColor(float value, vec2 range, vec4 colors[COLORS_SIZE])\n{\n    // Clamp to range\n    value = clamp(value, range.x, range.y);\n    \n    float len = range.y - range.x; \n    float norm = (value - range.x) / len;\n    \n    // Get two closest colors\n    vec3 color = ERR_COLOR;\n    for (int i = 0; i < COLORS_SIZE-1; i++)\n    {\n        vec4 curr = colors[i];\n        vec4 next = colors[i+1];\n        if (curr.w <= norm && norm <= next.w)\n        {\n            float btw = (norm - curr.w) / (next.w - curr.w);\n            color = mix(curr.xyz, next.xyz, btw);\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Function domain\n    const vec2 xDomain = vec2(0.0, 50.0);\n    const vec2 yDomain = vec2(-0.5, 22.0);\n    \n    // Function range\n    const vec2 range = vec2(-10.0, 1.75);\n    \n    // Colors\n    vec4 colors[COLORS_SIZE] = vec4[](\n        vec4(0.0, 0.0, 0.0, 0.0),\n        vec4(0.95, 0.01, 0.218, 0.15),\n        vec4(0.45, 0.0, 0.8, 0.65),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    \n    // uv - normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    // maxUv - one coordinate with maximal resolution is normalized other is trimmed\n    // quadrants - derived from maxUv - point (0.0, 0.0) is in the middle of the picture\n    float maxRes = max(iResolution.x, iResolution.y);\n    vec2 qRes = iResolution.xy / maxRes;\n    vec2 maxUv = fragCoord / maxRes;\n    maxUv.y = qRes.y - maxUv.y;\n    vec2 quadrants = 2.0 * maxUv - qRes;\n    float quadPixSize = 2.0 / maxRes;\n    \n    // Supersampling\n    vec2 samples[] = supersampling(quadrants, quadPixSize);\n    \n    vec3 totalColor = vec3(0.0);\n    for (int i = 0; i < N_SAMPLES; i++)\n    {\n        // Calculate coord\n        vec2 coord = quadToPolar(samples[i], xDomain, yDomain);\n\n        float value = function(coord.x, coord.y, iTime);\n\n        totalColor = totalColor + getColor(value, range, colors);\n    }\n    vec3 avgColor = totalColor / float(N_SAMPLES);    \n\n    // Output to screen\n    fragColor = vec4(avgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 242, 242, 1041], [1526, 1526, 1557, 1557, 1958], [1960, 2036, 2094, 2094, 2235], [2237, 2307, 2366, 2366, 2655], [2657, 2657, 2723, 2745, 3271], [3273, 3273, 3328, 3351, 4770]], "test": "untested"}
{"id": "NscXR4", "name": "Tetrahedral Gradient Looped", "author": "spalmer", "description": "riffing on Thomas Hooper's idea, which tweaks iq's simplex gradient [url=http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm]here[/url]\nleft=central difference, right=one of my simplex looped", "tags": ["gradient", "simplex", "derivative", "tetrahedral", "hooper"], "likes": 4, "viewed": 114, "published": "Public API", "date": "1632702913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I made some more variants of iq/Hooper simplex gradient\n\n// iq's looped simplex gradient, loop idea by Thomas Hooper\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm \"An Important Implementation Detail\"\n\nfloat dscene(vec3 q);\n\n#define IZERO min(0, iFrame)\n\n// WIP spalmer variant of Thomas Hooper's looped variant of iq's simplex gradient\n// works, not super efficient though with extra multiply by e.w etc.\nvec3 gscene4(vec3 q, float h)\n{\n\tvec3 n = vec3(0); vec4 e = vec4(1,1,1,-1);\n\tfor (int i = IZERO + 4; i-- > 0; e = e.yzwx)\n\t\tn -= dscene(q - h * e.w * e.xyz) * e.w * e.xyz;\n\treturn n;\n}\n\n// these were originally in March 3D https://shadertoy.com/view/tlGXDK\n\n// spalmer variant of Thomas Hooper's looped variant of iq's simplex gradient\nvec3 gscene3(vec3 q, float h)\n{\n\tvec3 n = vec3(0);\n\tfor (int i = IZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += dscene(q + e * h) * e;\n\t}\n\treturn n;\n}\n\n// a variation of iq/Hooper's simplex gradient made by Clément Baticle (a.k.a. Klems):\nvec3 gscene2(vec3 p, float h) // for function f(p)\n{\n\tvec3 n = vec3(0);\n\tfor (int i=IZERO; i<4; ++i)\n\t{\n\t\tvec3 e = (2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n\t\tn += e * dscene(p + e*h);\n\t}\n\treturn n;\n}\n\n// unlooped variation for comparison:\n\n// iq's simplex gradient, unlooped, so stresses compiler inlining scene:\n// I took from mandelbulb https://shadertoy.com/view/ltfSWn\nvec3 gscene1(vec3 q, float h)\n{\n\tvec2 e = h * vec2(1,-1);\n\treturn e.xyy * dscene(q + e.xyy) + \n\t       e.yyx * dscene(q + e.yyx) + \n\t       e.yxy * dscene(q + e.yxy) + \n\t       e.xxx * dscene(q + e.xxx);\n}\n\n// standard central difference gradient for comparison\nvec3 gscene0(vec3 q, float h)\n{\n    vec2 e = vec2(h * sqrt(3.), 0);  // sqrt(3.) to match lack of sqrt(1./3.) in others\n    return .5 * (vec3(\n       dscene(q + e.xyy),\n       dscene(q + e.yxy),\n       dscene(q + e.yyx)\n       ) - vec3(\n       dscene(q - e.xyy),\n       dscene(q - e.yxy),\n       dscene(q - e.yyx)\n       ));\n}\n// you can tell on left edge of sphere bottom that it\n// works differently than the simplex gradient does\n\n\nfloat dscene(vec3 q)\n{\n    return min(min(length(q) - 2., 6. - length(q)), q.y + 1.)\n        // any ideas to exhibit the technique better? maybe some patterned surface?\n        + dot(sin(q*16.), vec3(1)) * .015\n    ;\n}\n\n// fork of Nano March https://shadertoy.com/view/3s2fDW (still private because it's still not short enough to compete)\n// fork of Fabrice's helix https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 p)\n{\n    vec3 R = iResolution, r = R, q = 5./r.yyz;\n    // TODO maybe rotating the camera would allow witnessing artifacts on all sides\n    r = normalize(vec3(.5*r.xy - p, r.y) / r.y); // strangely backward\n    q -= 3. * r;\n    for (int i = 96 + IZERO; i-- > 0 && abs(O.a) > .01;\n         q -= r * (O.a = dscene(q)));\n    // really precision shouldn't be constant but should depend on the distance to camera etc.\n    // here just change w time so can see the effect it has.\n    // you can only really notice the gradient methodology when precis is large,\n    // otherwise it tends to just look \"correct\".\n    float precis = (1. - abs(sin(iTime))) * .1 + 1e-2; // * (1. + blur); // not too small, beware inaccuracies in far distance\n    // normalized gradient (normal) of scene at p\n    float split = sin(.3*iTime) * .5 + .5 - p.x / R.x; //r.x - .5*sin(.3*iTime); // splitscreen\n    vec3 g = split < 0. // compare\n        ? gscene3(q, precis) // right\n        : gscene0(q, precis) // left\n    , n = normalize(g);\n    O = vec4(1);\n//    O.rgb *= dot(n, vec3(sqrt(1./3.))); // lit\n    O.rgb *= n * .5 + .5;\n    O.rgb *= 1. - exp2(-4.* R.y * abs(split));\n//    n *= 1.001; //.999; // TEST\n    O.gb *= exp2(-5e3 * abs(1. - length(n))); // detect unnormalized normals\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 426, 457, 457, 610], [684, 762, 793, 793, 938], [940, 1028, 1080, 1080, 1233], [1274, 1407, 1438, 1438, 1612], [1614, 1669, 1700, 1700, 1995], [1996, 2104, 2126, 2126, 2322], [2324, 2505, 2541, 2541, 3800]], "test": "untested"}
{"id": "NscXR8", "name": "ARQVOID :: 240 chars", "author": "ENDESGA", "description": "///////", "tags": ["spiral", "golf", "void"], "likes": 16, "viewed": 306, "published": "Public API", "date": "1632549692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 240 chars by Xor (with aspect ratio fix)\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 p=iResolution,d = -.5*vec3(I+I-p.xy,p)/p.x,c = d-d, i=c;\n    for(;i.x<1.;c += length(sin(p.yx)+cos(p.xz+iTime))*d)\n        p = c,\n        p.z -= iTime+(i.x+=.01),\n        p.xy *= mat2(sin((p.z*=.1)+vec4(0,11,33,0)));\n    O = vec4(10,0,2.5,9)/length(c);\n}\n\n// ORIGINAL: 258 chars\n/*void mainImage(out vec4 O, in vec2 I) {\n    vec3 d = .5-vec3(I,1)/iResolution, p, c;\n    for(float i=0.;i<99.;i++) {\n        p = c;\n        p.z -= iTime+i*.01;\n        p.z *= .1;\n        p.xy *= mat2(sin(p.z),-cos(p.z),cos(p.z),sin(p.z));\n        c += length(sin(p.yx)+cos(p.xz+iTime))*d;\n    }\n    O.rgb = vec3(5./length(c))*vec3(2.,.0,.5);\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 80, 80, 344]], "test": "untested"}
{"id": "NscXRM", "name": "sdLine", "author": "Arthas_me", "description": "Distance to a line(represented by a point and direction)", "tags": ["sdf"], "likes": 0, "viewed": 105, "published": "Public API", "date": "1632818162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdLine(in vec2 p, in vec2 a, in vec2 d) {\n    return length((p - a) - dot((p - a), d) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 a = vec2(1., 0.);\n    vec2 dir = vec2(sin(iTime), cos(iTime));\n\n\tfloat d =  sdLine(p, a, dir) - 0.2;\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d =  sdLine(p, a, dir) - 0.2;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 48, 100], [102, 102, 159, 159, 875]], "test": "untested"}
{"id": "NscXzH", "name": "Gabor Filter Kernel", "author": "mosan_hoshi", "description": "Gabor Filter Kernel ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n(*) Gaussian is not Normalized.", "tags": ["2d", "imageprocessing", "spatialfilter"], "likes": 6, "viewed": 154, "published": "Public API", "date": "1632577914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// writen by mossan-hoshi\n//// twitter : https://twitter.com/mossan_hoshi\n//// GitHub : https://github.com/mossan-hoshi/\n//// ShaderToy : https://www.shadertoy.com/user/mosan_hoshi\n//\n// Gabor Filter ( http://www.cse.yorku.ca/~kosta/CompVis_Notes/gabor_filters.pdf )\n//\n\n\n#define PI 3.14159265359\n#define MARGIN 0.01\n#define PADDING 0.1\n#define TILE_LOCAL_LENGTH 10.\n#define TILE_LENGTH ((1. - 2. * ( MARGIN + PADDING)) / 3.)\n#define LEFT_CENTER   vec2(MARGIN + .5 * TILE_LENGTH                               , MARGIN + .5 * TILE_LENGTH)\n#define CENTER_CENTER vec2(MARGIN + .5 * TILE_LENGTH +       PADDING + TILE_LENGTH , MARGIN + .5 * TILE_LENGTH)\n#define RIGHT_CENTER  vec2(MARGIN + .5 * TILE_LENGTH + 2. * (PADDING + TILE_LENGTH), MARGIN + .5 * TILE_LENGTH)\n#define TEXT_WIDTH   (0.068)\n#define TEXT_START_Y (2. * MARGIN + TILE_LENGTH)\n#define TEXT_START_X (.3)\n// gaussian\n#define SIGMA_MIN .75\n#define SIGMA_MAX 3.\n#define GAUSSIAN_CONST_GAIN 0.3989422804  // 1./sqrt(2*PI)\n#define GAUSSIAN_TRANSITION_PERIOD 3.8\n// carrier\n#define CARRIER_WAVELENGTH_MIN .2\n#define CARRIER_WAVELENGTH_MAX .8\n#define CARRIER_WAVELENGTH_PERIOD 3.8\n#define CARRIER_ROTATION_PERIOD 20.\n\n\nvec3 displayGamma(vec3 rgb) {\n  // gamma(sRGB)\n  // https://knowledge.shade3d.jp/knowledgebase/%E3%82%AC%E3%83%B3%E3%83%9E2-2%E3%81%A8srgb%E3%81%AE%E9%81%95%E3%81%84\n  vec3 val1 = 12.92 * rgb;\n  vec3 val2 = vec3(pow(rgb.x, 1.0 / 2.2),pow(rgb.y, 1.0 / 2.2),pow(rgb.z, 1.0 / 2.2)) * 1.055 - 0.055;\n  return (1.0 - step(0.0031308,rgb)) * val1 + step(0.0031308,rgb) * val2;\n}\n\nfloat errorCheckUV(vec2 checkUV){\n  return float((checkUV.x < .0)||(checkUV.y < .0)||(checkUV.x > 1.)||(checkUV.y > 1.));\n}\n\nvec2 errorCheckUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckUV(checkUV);\n  return step(0.1,errorFlg) * (-1.,-1.) + (1.0 - step(0.1,errorFlg)) * returnUV;\n}\n\nfloat errorCheckLocalUV(vec2 checkUV){\n  return float((abs(checkUV.x) > .5 * TILE_LOCAL_LENGTH)||(abs(checkUV.y) > .5 * TILE_LOCAL_LENGTH));\n}\n\nvec2 errorCheckLocalUV(vec2 checkUV, vec2 returnUV){\n  float errorFlg = errorCheckLocalUV(checkUV);\n  return step(.1, errorFlg) * (-1. * TILE_LOCAL_LENGTH, -1. * TILE_LOCAL_LENGTH) + step(.1, 1. - errorFlg) * returnUV;\n}\n\nvec2 uv2LocalUV(vec2 uv, vec2 centerPoint){\n  vec2 localUV = TILE_LOCAL_LENGTH * vec2((uv.x - centerPoint.x)/ TILE_LENGTH, \n                                          (uv.y - centerPoint.y)/ TILE_LENGTH);\n  return errorCheckLocalUV(localUV, localUV);\n}\n\nfloat waveValue(float period,float  minVal,float  maxVal){\n  return (cos(2. * PI * iTime / period) + 1.) * .5 * (maxVal - minVal) + minVal;\n}\n\nvec2 localUV2uv(vec2 localUV, vec2 startPoint){\n  vec2 gainedLocalUV = vec2(localUV.x * TILE_LENGTH, \n                            localUV.y * TILE_LENGTH);\n  vec2 uv = vec2((gainedLocalUV.x + startPoint.x) , \n                 (gainedLocalUV.y + startPoint.y) );\n  return errorCheckUV(localUV, uv);\n}\n\nvec3 gaussian(vec2 uv, float sigma){\n  float channelValue = GAUSSIAN_CONST_GAIN * exp(-dot(uv,uv)/(2. * sigma * sigma)); // / sigma; // Here I don't apply normalization because of visibility.\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nvec3 carrier(vec2 uv, float carrier_wavelength, float rotation_angle){\n  vec2[2] rotation_matrix = vec2[](\n    vec2(cos(rotation_angle),-sin(rotation_angle)),\n    vec2(sin(rotation_angle), cos(rotation_angle))\n  );\n  vec2 rotatedUV = vec2(dot(rotation_matrix[0],uv),\n                        dot(rotation_matrix[1],uv));\n  float channelValue = (cos(rotatedUV.x / carrier_wavelength) ) ;\n  return vec3(channelValue, channelValue, channelValue);\n}\n\nfloat lineMask(vec2 uv, vec2 linePoint1,vec2 linePoint2, float threshold){\n  // rotate line to y-axis\n  vec2 v1 = (linePoint1 - linePoint2);\n  float lineLength = sqrt(dot(v1,v1));\n  v1 = v1 / lineLength;\n  float theta = atan(v1.x, v1.y);\n  vec2[2] rotateMat = vec2[](\n    vec2(cos(theta), -sin(theta)),\n    vec2(sin(theta),  cos(theta))\n  );\n  vec2 rotatedUV = vec2((dot(rotateMat[0], (uv - linePoint2))),\n                        (dot(rotateMat[1], (uv - linePoint2))));\n  return float(\n               (abs(rotatedUV.x ) < threshold)&&\n               (rotatedUV.y       > -threshold)&&\n               (rotatedUV.y       < lineLength + threshold)\n               );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // const\n  float sigma = waveValue(GAUSSIAN_TRANSITION_PERIOD, SIGMA_MAX, SIGMA_MIN);\n  float carrier_wavelength = waveValue(CARRIER_WAVELENGTH_PERIOD, CARRIER_WAVELENGTH_MAX, CARRIER_WAVELENGTH_MIN);\n  float rotation_angle = mod(2. * PI * iTime / CARRIER_ROTATION_PERIOD, 2. * PI);\n\n  // normalize position(x,y:.0~1.0)\n  vec2 uv = fragCoord.xy/ iResolution.x;\n\n  // get local positions\n  vec2 leftUV = uv2LocalUV(uv, LEFT_CENTER);\n  vec2 centerUV = uv2LocalUV(uv, CENTER_CENTER);\n  vec2 rightUV = uv2LocalUV(uv, RIGHT_CENTER);\n\n  // draw gaussian (center)\n  vec3 leftGaussianRegion = gaussian(leftUV, sigma);\n  // draw gaussian (center)\n  vec3 centerCarrierRegion = carrier(centerUV, carrier_wavelength, rotation_angle);\n  \n  // draw gaussian (center)\n  vec3 rightGaussianRegion = gaussian(rightUV, sigma);\n  vec3 rightCarrierRegion = carrier(rightUV, carrier_wavelength, rotation_angle);\n  \n  // draw left side(image(iChannel0))\n  float leftMask = 1. - errorCheckLocalUV(leftUV);\n  float centerMask = 1. - errorCheckLocalUV(centerUV);\n  float rightMask = 1. - errorCheckLocalUV(rightUV);\n  vec3 rgb = leftMask   * (.5 + leftGaussianRegion) + \n             centerMask * centerCarrierRegion + \n             rightMask  * (.5 + rightGaussianRegion * rightCarrierRegion);\n  float lineMaskAll = // multiply\n                      lineMask(uv, vec2(.35, .1),vec2(.3 , .15), .004) + \n                      lineMask(uv, vec2(.3,  .1),vec2(.35, .15), .004) + \n                      // equal\n                      lineMask(uv, vec2(.65,  .12),vec2(.7, .12), .004) + \n                      lineMask(uv, vec2(.65,  .14),vec2(.7, .14), .004) +\n                      // text(gabor)\n                      //// G\n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +  \n                      lineMask(uv, vec2(.07   + TEXT_START_X, .025 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_START_X, .025 + TEXT_START_Y), .003) +\n                      //// A\n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) +\n                      //// B\n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y),\n                                   vec2(.075  + 2. * TEXT_WIDTH + TEXT_START_X, .036 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .05  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.056  + 2. * TEXT_WIDTH + TEXT_START_X, .033 + TEXT_START_Y),\n                                   vec2(.076  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y),\n                                   vec2(.073  + 2. * TEXT_WIDTH + TEXT_START_X, .03  + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y),\n                                   vec2(.072  + 2. * TEXT_WIDTH + TEXT_START_X, .01  + TEXT_START_Y), .003) +\n                      //// O\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .05 + TEXT_START_Y),\n                                   vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.08   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      lineMask(uv, vec2(.05   + 3. * TEXT_WIDTH + TEXT_START_X,  .03 + TEXT_START_Y),\n                                   vec2(.065  + 3. * TEXT_WIDTH + TEXT_START_X,  .01 + TEXT_START_Y), .003) +\n                      //// R\n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .03 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .05 + TEXT_START_Y),\n                                   vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) + \n                      lineMask(uv, vec2(.075  + 4. * TEXT_WIDTH + TEXT_START_X, .01 + TEXT_START_Y),\n                                   vec2(.055  + 4. * TEXT_WIDTH + TEXT_START_X, .035 + TEXT_START_Y), .003) \n                      ;\n  rgb = lineMaskAll * 1. + (1. - lineMaskAll) * rgb;\n\n  rgb = displayGamma(rgb);\n\n  fragColor=vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscXzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1019, 1174, 1203, 1339, 1545], [1547, 1547, 1580, 1580, 1670], [1672, 1672, 1719, 1719, 1844], [1846, 1846, 1884, 1884, 1988], [1990, 1990, 2042, 2042, 2210], [2212, 2212, 2255, 2255, 2463], [2465, 2465, 2523, 2523, 2606], [2608, 2608, 2655, 2655, 2907], [2909, 2909, 2945, 2945, 3159], [3161, 3161, 3231, 3231, 3605], [3607, 3607, 3681, 3708, 4272], [4274, 4274, 4330, 4341, 10936]], "test": "untested"}
{"id": "NsdXz7", "name": "Truchet Torus", "author": "wildniklin", "description": "that time when u were a kid and played in those indoor playgrounds... but it didn't have this terrifying lighting.", "tags": ["torus"], "likes": 7, "viewed": 136, "published": "Public API", "date": "1632871111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 50.0;\nconst float MIN_DIST = 0.001;\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 42.1581))) * 43758.5453123);\n}\n\nfloat sdTorus(vec3 p, float t) {\n  return length(vec2(length(p.xz) - t, p.y));\n}\n\nfloat sdTruchet(vec3 p) {\n    return min(min(sdTorus(p - vec3(0.5, 0.0, 0.5), 0.5), sdTorus(p.yxz + vec3(0.5, 0.0, 0.5), 0.5)), sdTorus(p.yzx + vec3(-0.5, 0.0, 0.5), 0.5));\n}\n\nfloat map(vec3 p) {\n    vec3 i = floor(p);\n    vec3 m = p - i - 0.5;\n    m.xz *= rot(floor(rand1(i) * 4.0) * PI * 0.5);\n    m.xy *= rot(floor(rand1(i + 62.0) * 4.0) * PI * 0.5);\n    m.yz *= rot(floor(rand1(i + 25.0) * 4.0) * PI * 0.5);\n    return sdTruchet(m) - 0.0625;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float ds = map(ro + (rd * d));\n        d += ds;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(ds) <= MIN_DIST) return d;\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat shadedPointLight(vec3 p, vec3 n, vec3 lp, float r) {\n    vec3 ln = lp - p;\n    float d = length(ln);\n    ln /= d;\n    \n    return max(0.0, dot(n, ln) * (1.0 - (d / r)) * ((march(p + ((n * MIN_DIST) * 2.0), ln) > d) ? 1.0 : 0.0));\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    \n    float t = (iTime * 0.5) + 50.0;\n    \n    vec3 ro = vec3(0.0, 0.0, t);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.yz *= rot(sin(t * PI * 0.05) * PI * 0.0625);\n    rd.xz *= rot(cos(t * PI * 0.05) * PI * 0.0625);\n\n    float d = march(ro, rd);\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    vec3 col = vec3(sin(p * PI * 0.5) * 0.25 + 0.5);\n    \n    vec3 light = vec3(0.0);\n    \n    light += shadedPointLight(p, n, ro + (sin(t * vec3(0.5, 0.2, 0.7)) * 0.25), 8.0);\n    light += shadedPointLight(p, n, ro + (sin(t * vec3(0.3, 0.8, 0.4)) * 0.25), 8.0);\n\n    col *= light;\n    \n    col = mix(col, vec3(0.0), smoothstep(0.0, MAX_DIST, d));\n\n    col *= smoothstep(1.0, -0.5, length(uv));\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdXz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 131, 131, 197], [199, 199, 220, 220, 301], [303, 303, 335, 335, 383], [385, 385, 410, 410, 559], [561, 561, 580, 580, 832], [834, 834, 865, 865, 1094], [1096, 1096, 1117, 1117, 1310], [1312, 1312, 1370, 1370, 1549], [1551, 1551, 1587, 1587, 2400]], "test": "untested"}
{"id": "NsG3DV", "name": " Bricks animation", "author": "pleroma", "description": "Bricks", "tags": ["2d"], "likes": 7, "viewed": 76, "published": "Public", "date": "1632174644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord=fragCoord.xy/iResolution.xy*15.0;\n    for(int n=1;n<20;n++)\n    {\n        float i=float(n);\n        coord +=vec2(sin(iTime)/i*sin(coord.y+iTime),sin(iTime)/i*sin(coord.x+iTime));\n        coord +=vec2(cos(iTime)/i*sin(coord.x+iTime),cos(iTime)/i*sin(coord.y+iTime));\n        \n    }\n    \n\n    vec3 color =vec3(0.5*sin(coord.x+iTime)+0.5,0.5*sin(coord.y+iTime)+0.5,0.5*atan(coord.y,coord.x)+0.5);\n    \n    fragColor=vec4(color,1.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsG3DV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 505]], "test": "untested"}
{"id": "NsG3RD", "name": "Fork RZ Basics  raymondzhe 963", "author": "raymondzheng", "description": "GRP-200 first assignment", "tags": ["grp200"], "likes": 1, "viewed": 22, "published": "Public", "date": "1631145080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Create a Gradient that moves vertically.\nvec3 questionOne(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(.1, uv.y, .5);\n    return col;\n}\n// Create a split-screen of four quadrants. Choose any 4 colors.\nvec3 questionTwo(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0,1,0);\n    if (uv.x > .5) {\n        col = vec3(1,0,0);\n    }\n    if (uv.y > .5) {\n        col = vec3(0,0,1);\n    }\n    if (uv.y > .5 && uv.x > .5) {\n        col = vec3(1,1,0);\n    }\n    return col;\n}\n\nfloat magnitudeCalc(vec3 color) {\n    return sqrt(pow(color.x, 2.0) + pow(color.y, 2.0) + pow(color.z, 2.0));\n}\n// Create a \"heat\" finder. Basically, if the magnitude/brightness of any color is greater than X then turn it red. \n// X should be a variable. By default, set it to 0.5.\nvec3 questionThree(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0, uv.x, uv.x);\n    float X = 0.5;\n    if (magnitudeCalc(color) >= X) {\n      color = vec3(1,0,0);\n    }\n    return color;\n}\n// Bonus: Create a striped pattern of any two colors. The colors should be variable.\nvec3 questionFour(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    // Random color code from Shadertoy example.\n    vec3 randColOne = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 randColTwo = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(4,2,0));\n    vec3 col = randColOne;\n    if (int(uv.x * float(10)) % 2 == 1) {\n        col = randColTwo;\n    } else {\n        col = randColOne;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3(0,0,0);\n\n    // Output to screen\n\n    //col = questionOne(fragCoord);\n    //col = questionTwo(fragCoord);\n    //col = questionThree(fragCoord);\n    col = questionFour(fragCoord);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsG3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 78, 78, 171], [172, 237, 271, 271, 532], [534, 534, 567, 567, 645], [646, 816, 852, 852, 1039], [1040, 1125, 1160, 1160, 1533], [1535, 1535, 1592, 1592, 1826]], "test": "untested"}
{"id": "NsG3zh", "name": "大龙猫 - Canyon Flight", "author": "totetmatt", "description": "Simple terrain, some reflection and trying to play with camera. Is it optimized ? OF COURSE NOT :D ", "tags": ["terrain", "camera", "clipping"], "likes": 4, "viewed": 164, "published": "Public API", "date": "1631034119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  p.z +=mod(iTime,100.);\n      vec2 id = floor(p.xz);\n      p.xz = asin(sin(p.xz)*.8);\n  vec2 h;\n\n    \n    vec4 pp = vec4(p,1.);\n    float mm = 10000.;\n    for(float i =0.;i<=16.;i++){\n            pp.xyz = abs(pp.xyz)-1.1;\n            pp.xz *=rot(.785*i+i);\n            \n            pp.yz *=rot((.29)*i);\n            float m =  min(pp.x,min(pp.y,pp.z));\n            mm = min(mm,m); // This was on nusan video I recently saw. Quite nice\n            pp*=1.11;\n            pp.xy = pp.x < pp.y ? pp.yx:pp.xy;\n            pp.x -=3.1;\n    }\n    h.x =     (length(pp.xyz)-1.5-mm*.01)/pp.a;\n    h.x = max(abs(length(p)-2.)-1.1,-h.x);\n    h.x = mix(box(p,vec3(1.)),h.x*.7,.5);\n    h.y = 1.;\n    h.x = max(-(length(pp.xz)-3.6)/pp.a,h.x);\n    \n    vec2 t;\n    t.x = dot(p,vec3(0.,1.,.0))-sin(pp.x*.1+pp.z*.1)*.1;\n    t.y = 2.;\n    h = t.x < h.x  ? t:h;\n    return h;\n}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,.7))\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(.1);\n    vec3 ro = vec3(0.,2.+sin(iTime*.33+3.0)*1.4,-5.);\n    vec3 rt = vec3(cos(iTime*.33)*2.,sin(iTime*.5),0.);\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rp = ro;\n    uv *=rot(cos(iTime*.3));\n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n    float dd =0.;\n    vec2 d;\n    d.y =-1.;\n    vec3 light = vec3(1.,2.,-3.);\n    for(float i=0.;i<=128.;i++){\n        d = sdf(rp);\n        dd +=d.x;\n        if(dd > 10.) {d.y= -1.; break;}\n        if(d.x<.001){\n            vec3 n = norm(rp,.0003);\n            if(d.y == 2.){\n                rd = normalize(reflect(rd,n));\n                rp +=rd*.01;\n                col +=vec3(.1,.1,.4);\n                continue;\n            }\n            float diff = max(0.,dot(normalize(light-rp),n));\n            col += vec3(1.)*diff;\n            col = mix(vec3(.1,.1,.2),vec3(1.,.9,.7),AO(rp,n)/1.7);\n            break;\n        }\n    rp+=rd*d.x;\n    }\n    if(d.y==-1.) col += mix(vec3(.2,.4,.8),vec3(.5,.6,.9),uv.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsG3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 116], [117, 117, 135, 135, 182], [183, 183, 200, 200, 1058], [1177, 1177, 1204, 1204, 1280], [1281, 1281, 1338, 1338, 2496]], "test": "untested"}
{"id": "NsGGzc", "name": "Fractal Raymarching test", "author": "samk9632", "description": "fractal", "tags": ["fractal"], "likes": 3, "viewed": 115, "published": "Public", "date": "1631855263", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float l = length(pos);\n    vec3 poss = pos;\n    float xx = poss.x*cos(rotation.y)+poss.z*sin(rotation.y);\n    float yy = poss.y;\n    float zz = -pos.x*sin(rotation.y)+poss.z*cos(rotation.y);\n    \n    return vec3(xx, yy, zz);\n}\n\nfloat DE(vec3 pos, int Iterations, float Power, float xRot, bool limit) {\n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    vec3 c = vec3(sin(iTime*0.17), cos(iTime*0.193), sin(iTime*0.237));\n    // convert to polar coordinates\n\tfloat phi1 = atan(z.y,z.x)+xRot;\n    // convert back to cartesian coordinates\n    z = vec3(length(z.xy)*vec2(sin(phi1), cos(phi1)), z.z);\n    c = z;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=c;\n\t}\n    if (limit == true) {\n        return max(0.5*log(r)*r/dr, 0.0009);\n    } else {\n        return abs(0.5*log(r)*r/dr);\n    }\n}\n\nvec3 rayCast(vec3 dir, vec3 pos, float xRot, vec2 coord, float threshold, int maxSteps, vec3 lightDir, int fractalSteps, float degree) {\n    float j = 0.0;\n    vec3 p = pos;\n    int i = 0;\n    bool intersect = false;\n    float f;\n    float lightInfo = 1.0;\n    vec3 normal = vec3(0.0);\n    float ambientLight = 0.1;\n    float a = dot(dir, dir);\n    float b = 2.0*dot(dir, pos);\n    float c = dot(pos, pos) - pow(2.0, 2.0);\n    float discriminant = b*b-4.0*a*c;\n    vec3 inPos = (-b - sqrt(discriminant))/(2.0*a)*dir+pos;\n    vec3 outPos = (-b + sqrt(discriminant))/(2.0*a)*dir+pos;\n    // convert to polar coordinates\n\tfloat phi1 = atan(lightDir.y,lightDir.x)+xRot;\n    // convert back to cartesian coordinates\n    lightDir = vec3(length(lightDir.xy)*vec2(sin(phi1), cos(phi1)), lightDir.z);\n    p = inPos;\n    if (discriminant > 0.0) {\n        for (int i = 0; i < maxSteps && length(p) < 2.01; i++) {\n            f = DE(p, fractalSteps, degree, xRot, false);\n            p += dir*f*0.9;\n\n            if (f < threshold*1.0) {\n                float fa = 3.1415926;\n                float fb = 3.1415926;\n                //get normals\n                float nx = DE(p - threshold*vec3(1.0, 0.0, 0.0), fractalSteps, degree, xRot, false);\n                float ny = DE(p - threshold*vec3(0.0, 1.0, 0.0), fractalSteps, degree, xRot, false);\n                float nz = DE(p - threshold*vec3(0.0, 0.0, 1.0), fractalSteps, degree, xRot, false);\n                normal = -normalize((vec3(nx, ny, nz) - f));\n                i = maxSteps + 1;\n                vec3 l = vec3(0.0);\n                \n                intersect = true;\n            }\n            j++;\n        }\n        if (intersect == true) {\n        f = 0.0;\n        vec3 l;\n        float fa = 3.1415;\n        float fb = 3.1415;\n            for (int k = 0; k < maxSteps && length(p+l) < 2.0; k++) {\n                float ff = DE(l+p, fractalSteps, degree, xRot, true);\n                f += ff;\n                l = -f * lightDir;\n                fa = ff/f;\n                //if (k > 1) {\n                    fa = min(fa, fb);\n                    fb = fa;\n                    lightInfo = min(clamp(fa*10.0, ambientLight, 1.0), (clamp(-dot(normal, lightDir), 0.0, 1.0)*(1.0-ambientLight)+ambientLight));\n                    \n                //}\n                if (k > 0 && f < threshold) {\n                    lightInfo = ambientLight;\n                    k = maxSteps;\n                }\n\n\n\n            }\n            return vec3(5.0/pow(1.02, j)*lightInfo);\n            return normal;\n        } else {\n            return vec3(0.0);\n        }\n        \n    } else {\n        return vec3(0.0);\n    }\n        \n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.x-0.5);\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    \n    //RayCasting\n    float dof = 1.0;\n    float r = 5.0;\n    float s = 10.0;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(-iTime*0.2, -s*(mouse.y+pi/2.0)));\n    vec3 lightDir = vec3(sin(0.5*iTime), cos(0.5*iTime), sin(0.327*iTime));\n    lightDir /= length(lightDir);\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(iTime*0.2, s*(mouse.y+pi/2.0)));\n    \n    // Time varying pixel color\n    vec3 col = rayCast(camDir, camPos, -s*mouse.x, fragCoord, 0.001, 75, lightDir, 12, 8.0);\n    \n    //col = (log(1.+col));\n    //col = clamp(col,0.,1.);\n    col *= 1.0;\n    col = col/(col+vec3(1.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGGzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 382], [384, 384, 457, 457, 1340], [1342, 1342, 1478, 1478, 4005], [4007, 4007, 4064, 4064, 5001]], "test": "untested"}
{"id": "NsK3DD", "name": "Linas Sphere Grid", "author": "itslinaaaa", "description": "Lotsa spheres", "tags": ["spheres"], "likes": 1, "viewed": 44, "published": "Public", "date": "1631890604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat sphereSDF ( vec3 position, vec3 center, float radius ) {\n    float distance = length(center - position) - radius;\n    return distance;\n}\n\n\nfloat SDF (vec3 position) {\n    float r = 1.3;\n    float d = 5.0 * r;\n    float i = floor(position.x / d);\n    float j = floor(position.y / d);\n    vec3 pos = vec3(mod(position.xy, d), position.z) - vec3(0, 0, iMouse.x / 20.);\n    vec3 spherePos = vec3(d / 2.0, d / 2.0, 20.0 + 5.0 * sin(10.0 * iTime + length(vec2(i, j))));\n    float sphere = sphereSDF(pos, spherePos, r);\n    return sphere;\n}\n\n\nvec3 normal (vec3 position) {\n    float dt = 0.0001;\n    float dx = SDF(position + vec3(dt, 0, 0)) - SDF(position - vec3(dt, 0, 0));\n    float dy = SDF(position + vec3(0, dt, 0)) - SDF(position - vec3(0, dt, 0));\n    float dz = SDF(position + vec3(0, 0, dt)) - SDF(position - vec3(0, 0, dt));\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    return normal;\n}\n\n\nfloat raymarch (vec3 start, vec3 direction) {\n    #define maxSteps 100\n    #define converged 0.001\n    vec3 position = start;\n    float totalDistance = 0.0;\n    for (int i = 0; i < maxSteps; i++ ) {\n        // Step forward by the SDF distance\n        float currentDistance = SDF(position);\n        totalDistance += currentDistance;\n        position += direction * currentDistance;\n        \n        // If we are close to a surface, stop iterating\n        if ( currentDistance < converged ) break;\n    }\n    return totalDistance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 5, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = 0.6;\n    vec3 specular = vec3(0.96, 0.74, 0.08);\n    vec3 diffuse = vec3(0.62, 0.46, 0.12);\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = normal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a reflection\n    \n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 0.5 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n    if ( brightness < 0.0 ) return diffuse;\n    vec3 color = brightness * specular * shadow + diffuse ;\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Setup the camera and the pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 start = vec3(uv, 0);\n    vec3 camera = vec3(0, 0, -1.0);\n    vec3 direction = normalize(start - camera);\n   \n    \n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(87, 66, 245, 0)/255.0;\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);    \n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3DD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 64, 64, 144], [147, 147, 174, 174, 541], [544, 544, 573, 573, 904], [907, 907, 952, 952, 1436], [1439, 1439, 1471, 1509, 2413], [2417, 2417, 2474, 2524, 3159]], "test": "untested"}
{"id": "NsK3DK", "name": "大龙猫 - Geode", "author": "totetmatt", "description": "No aa, glitchy af.", "tags": ["geode"], "likes": 6, "viewed": 196, "published": "Public API", "date": "1632245864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.z,q.y)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nvec2 sdf(vec3 p){\n\n vec2 h;\n float s = 1000.;\n\n vec4 pp = vec4(p,1.);\n pp.xyz = asin(sin(p.xyz));\n for(float i =0.;i<=8.;i++){\n   s = min(pp.x,min(pp.y,pp.z))/pp.a;\n    pp.xyz = abs(pp.xyz)-(.3),\n    pp.xz*=rot(.785*i+i);  \n    pp.yz = pp.y < pp.z ? pp.zy:pp.yz;\n    pp*=1.05;\n    pp.xy *=rot(-.785*i);\n  \n }\n s /=pp.a;\n\n h.x = mix(abs(length(p+vec3(0.,0.,0.))-19.)-.01,s*1.5,.5);\n\nh.x = max(-(abs(p.y)-(1.)  ),h.x);\nvec2 t ;\nt.x = min(length(p.xz)-15.-s*s*s,h.x);\nt.x = max(abs(p.y)-15.,t.x);\n h.y = 1.+s;\nt.y = 2.;\n h = t.x < h.x ? t:h;\n return h;\n    \n}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv*=rot(.13*iTime);\n    vec3 ro = vec3(20.*sin(iTime*.033),0.,20.*cos(iTime*.033));\n      \n    vec3 rp = ro;\n    \n    vec3 rt  = vec3(.1+10.*sin(iTime*.033),0.1,.1+20.*cos(iTime*.033));\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z,vec3(0,-1,0)));\n    vec3 y = normalize(cross(z,x));\n    \n    vec3 rd = mat3(x,y,z)*normalize(vec3(uv,.95));\n    vec3 light = vec3(1.+20.*sin(iTime*.033),2.,-1.+20.*cos(iTime*.033));\n    vec3 col = vec3(.01);\n    vec3 acc = vec3(0.);\n    for(float i=0.;i<=128.;i++){\n        vec2 d = sdf(rp);\n        if(d.y ==2.){\n            acc +=vec3(.01)*exp(-abs(d.x))/(15.+sin(atan(rp.x,rp.z)*40.)*14.);\n            d.x = max(0.,abs(d.x));\n        }\n        if(length(rp) > 100.) break;\n        if(d.x <.0001 && d.y != 2.){\n            vec3 n = norm(rp,.0003);\n            vec3 nn = norm(rp,.003);\n            float dif = dot(normalize(light-rp),n);\n            float spc = max(0.,dot(normalize(ro-rp),reflect(normalize(rp-light),n)));\n            spc = pow(spc,32.);\n          \n            col += max(0.,1.-dot(n,nn))*max(dif,spc)+vec3(1.9+sin(rp.y*10.),.9,1.9+cos(rp.x*10.))*spc*.59;\n            break;\n        }\n        rp +=rd*d.x;\n    \n    }\n    col = max(acc,col);\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 118], [119, 119, 137, 137, 184], [186, 186, 203, 203, 742], [769, 769, 795, 795, 873], [874, 874, 929, 929, 2243]], "test": "untested"}
{"id": "NsK3Wz", "name": "rainbow rings", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 2, "viewed": 70, "published": "Public", "date": "1631361021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define LOOPLEN 4.\n\n// adjusts the saturation\nvec3 sat(vec3 rgb)\n{\n    // Algorithm from Chapter 16 of \"OpenGL Shading Language\"\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, 2.5); // adjust strength here\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / LOOPLEN);\n    // Simulate lower framerate\n    time = floor(iTime * 20.) / 20. / LOOPLEN;\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // use log distance for perspective/tunnel effect\n    float dist = log(uv.x * uv.x + uv.y * uv.y);\n    float angle = atan(uv.y, uv.x);\n    \n    vec3 chanTime = 0.01 * vec3(-1, 0, 1) + time;\n    vec3 zoomTime = 1. * chanTime + 2.5 * sin(TAU * chanTime + dist * 0.5);\n    \n    vec3 col = smoothstep(-1.0, 1.0, sin(\n        dist * 7. + zoomTime * TAU\n    ));\n    \n    col += 0.3 * sin(dist * 4.5 + 3. * angle + (time + vec3(1, 0, 1) / 12.) * TAU);\n    \n    // Output to screen\n    fragColor = vec4(\n        sat(col), 1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 72, 92, 154, 306], [308, 308, 365, 393, 1155]], "test": "untested"}
{"id": "NsK3zR", "name": "Fork Sum Zero Hypno", "author": "deerfeeder", "description": " ", "tags": ["basic"], "likes": 3, "viewed": 153, "published": "Public API", "date": "1630967425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Fork Sum Zero Inverted\" by deerfeeder. https://shadertoy.com/view/NdVGzR\n// 2021-09-06 22:28:41\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  \n    float s = 80.0*sin(iTime*uv.x*uv.y);\n    uv.x=abs(uv.x);\n    // Time varying pixel color\n    vec3 col = cos(iTime+uv.xyx*vec3(s*sin(iTime*0.01),s*cos(iTime*0.02),s*cos(uv.x+iTime*0.06)));\n    col = abs(col);\n    // Output to screen\n    fragColor = vec4(vec3(col.x*col.y*col.z),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 166, 216, 571]], "test": "untested"}
{"id": "NsK3zy", "name": "Spinning Sun/Flower pqy", "author": "pqy", "description": "A simple circle for further experiments", "tags": ["circle"], "likes": 1, "viewed": 18, "published": "Public", "date": "1631757748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n \n \n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n    \n    vec2 center = iResolution.xy * 0.5;\n    \n    float time = sin(iTime);\n    \n    float angle = atan(fragCoord.x - center.x,fragCoord.y - center.y) + time*360.0*0.005;\n    \n    \n    \n    //get point normalized from center of screen\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    \n    float freq = sin(angle*20.0) * 20.0 * time;\n    \n    float freq2 = (abs(sin(angle*20.0))- abs(cos(angle*10.0))) * 50.0 * time;\n\n\tfloat radius = 0.25 * iResolution.y * (1.0 + cos(iTime) *0.5) + freq2  ;\n    \n    //radius *= time;\n    // Background layer\n\tvec4 layer1 = vec4(rgb(200.0, 250.0, 250.0), 1.0);\n\t\n\t// Circle\n\tvec3 pink = rgb(225.0, 150.0, 170.0);\n    vec3 yellow = rgb(225.0, 225.0, 170.0);\n    \n    \n    \n\tvec4 layer2 = circle(uv, center, radius, mix(pink,yellow,time));\n    \n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsK3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 116, 153, 153, 202], [206, 269, 330, 330, 434], [437, 497, 552, 552, 826], [828, 828, 885, 885, 1779]], "test": "untested"}
{"id": "NsKGDy", "name": "20210920_octree traversal", "author": "0b5vr", "description": "Inspired by https://www.shadertoy.com/view/7sKGRy\nA prequel of https://www.shadertoy.com/view/fdVGDy\n\nhaha\n\nclarify: it's a quad tree mapped to 2d, both ray and function are defined in vec3\n", "tags": ["quadtree", "octree"], "likes": 9, "viewed": 185, "published": "Public", "date": "1632141252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fs(i) (fract(sin((i)*114.514)*1919.810))\n\nstruct RectSubdivResult {\n    float volume;\n    vec3 center;\n    vec3 dimension;\n    vec3 domainMin;\n    vec3 domainMax;\n    float id;\n};\n\n/**\n * Ref: https://www.shadertoy.com/view/7sKGRy\n * @param p The input position\n * @param scale scale of the domain of the fractal\n */\nRectSubdivResult rectSubdiv( vec3 p, vec3 scale ) {\n    float t = iTime;\n\n    // several constants\n    const int ITERS = 12;\n    const int MIN_ITERS = 1;\n    const float MIN_SIZE = 0.15;\n    const float BREAK_CHANCE = 0.0;\n    const float PAD_FACTOR = 1.01;\n\n    // the domain of the fractal being generated\n    // will be modified in the iteration part\n    vec3 domainMin = vec3( -0.5 ) * scale;\n    vec3 domainMax = vec3( 0.5 ) * scale;\n\n    // id of the individual cube in the fractal\n    float id = 0.0;\n    \n    // random seed of cut positions\n    float seed = floor( t / 6.0 ) + 0.1;\n\n    // size of the current box determined by domainMin / domainMax\n    vec3 dimension = domainMax - domainMin;\n    \n    for ( int i = 0; i < ITERS; i ++ ) {\n        float fi = float( i );\n\n        // divide the box into eight\n        vec3 divideHash = vec3(\n            fs( dot( vec2( fi + id, seed ), vec2( 1.26, 2.72 ) ) ),\n            fs( dot( vec2( fi + id, seed ), vec2( 1.78, 0.47 ) ) ),\n            fs( dot( vec2( fi + id, seed ), vec2( 0.78, 2.25 ) ) )\n        );\n        vec3 divide = divideHash * dimension + domainMin;\n\n        // let the division line cut the box not too thin\n        divide = clamp( divide, domainMin + MIN_SIZE * PAD_FACTOR, domainMax - MIN_SIZE * PAD_FACTOR );\n        \n        // does this cut the box to the minimum preferrable size?\n        vec3 minSizeOfAxis = min( abs( domainMin - divide ), abs( domainMax - divide ) );\n        float minSize = min( minSizeOfAxis.x, min( minSizeOfAxis.y, minSizeOfAxis.z ) );\n        bool isSmallEnough = minSize < MIN_SIZE;\n\n        bool willBreak = false;\n        if ( i - 1 > MIN_ITERS && fs( id ) < BREAK_CHANCE ) { willBreak = true; }\n        if ( isSmallEnough && i - 1 > MIN_ITERS || i == ITERS - 1 ) { willBreak = true; }\n        if( willBreak ) {\n            // id = i * 0.1 * seed;\n            break;\n        }\n\n        // update the box domain\n        domainMax = mix( domainMax, divide, step( p, divide ) );\n        domainMin = mix( divide, domainMin, step( p, divide ) );\n\n        // id will be used for coloring and hash seeding\n        vec3 diff = mix( -divide, divide, step( p, divide ) );\n        id = length( diff + 10.0 );\n    \n        // recalculate the dimension\n        dimension = domainMax - domainMin;\n    }\n    \n    // calculate volume and center of the box\n    float volume = dimension.x * dimension.y * dimension.z;\n    vec3 center = ( domainMin + domainMax ) / 2.0;\n    \n    // prepare the result\n    RectSubdivResult result;\n    result.volume = volume;\n    result.center = center;\n    result.dimension = dimension;\n    result.domainMin = domainMin;\n    result.domainMax = domainMax;\n    result.id = id;\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3( 0.0 );\n\n    RectSubdivResult subdiv = rectSubdiv( vec3( p, 0.0 ), vec3( 2.0 ) );\n    col += fract( 55.5 * subdiv.center );\n    \n    vec3 ro = vec3( 0.0 );\n    vec3 rd = vec3( cos( 0.2 * iTime ), sin( 0.2 * iTime ), 0.0 );\n    float rl = 1E-4;\n    vec3 rp = ro + rd * rl;\n    \n    // draw a yellow dot\n    col += vec3( 1.0, 1.0, 0.0 ) * step( length( p - rp.xy ), 0.01 );\n    \n    for ( int i = 0; i < 40; i ++ ) {\n        subdiv = rectSubdiv( rp, vec3( 2.0 ) );\n        \n        // calc the length to an edge\n        vec3 edgeOfAxis = mix( subdiv.domainMin, subdiv.domainMax, step( 0.0, rd ) );\n        vec3 distToEdgeOfAxis = abs( rp - edgeOfAxis ) / ( abs( rd ) + 1E-4 );\n        float distToEdge = min(\n            distToEdgeOfAxis.x,\n            min(\n                distToEdgeOfAxis.y,\n                distToEdgeOfAxis.z\n            )\n        );\n        \n        rl += distToEdge + 1E-4;\n        rp = ro + rd * rl;\n    \n        // draw a yellow dot\n        col += vec3( 1.0, 1.0, 0.0 ) * step( length( p - rp.xy ), 0.01 );\n        \n        if ( any( greaterThan( abs( rp ), vec3( 1.0 ) ) ) ) {\n            break;\n        }\n    }\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 325, 376, 376, 3045], [3047, 3047, 3104, 3104, 4415]], "test": "untested"}
{"id": "NsKGRh", "name": "dream fractal", "author": "4eckme", "description": "dream fractal", "tags": ["fractal", "dream"], "likes": 5, "viewed": 110, "published": "Public", "date": "1631058543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void  mainImage(out vec4 color,in vec2 fragCoord){\n  vec2    coord = fragCoord-1.0*iResolution.xy/2.0;\n  float       x = coord.x;\n  float       y = coord.y;\n  float       t = iTime*4.0;\n  float       r = sqrt(x*x+y*y); \n  float      f1 = x*sin(r/t);\n  float      f2 = y*cos(r/t);\n  int     dream = abs(int(f1)&int(f2))&int(r*r);\n  //      dream = abs(int(f1)&int(f2));\n  //      dream = int(f1)&int(f2);\n  color         = vec4(dream);\n  //color       = vec4(1-dream);\n  //color       = vec4(dream, abs(int(f1))&abs(int(f2)), 1-dream*dream, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 545]], "test": "untested"}
{"id": "NsKGWD", "name": "Cabin in the Woods", "author": "andrew741", "description": "A cabin deep in the woods during the summer with day turning to night, the peaceful twinkling stars and the glow of the cabin. Note that theres on trees because they'er very hard and slow with ray marching.", "tags": ["raymarching", "noise", "sun", "shading", "specular", "stars", "moon", "metal", "emission", "cabin", "nigh", "ligh"], "likes": 7, "viewed": 79, "published": "Public", "date": "1631590474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by Andrew\n\nThe summer cabin in the woods\n\nThis shader took about 5 hours and was done in a single day and shows a run down cabin with a sheet metal roof.\nLet the faint glow of the cabin and the twinkling stars bring you back to those wodnerful sumer nights under the stars.\nLet the moon fill your eyes as it falls beyond the horizon and the sun comes up to welcome a new day.\n\nThis shader uses a varient of ray marching called sphere tracing to render the scene.\n\nI have been working hard on a shader called \"through the cosmos\" and it will be ready sometime soon and goes from earth through two solar\nsytem.\n*/\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\n// takes a uv coord and mouse pos and converts it to the rays direction\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// takes in a vec3 and returns a randomized vec3 (from another shader)\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i                   );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w                   );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// gets the distance to the ground\nfloat dstGround(vec3 p)\n{\n    float dst = p.y - noised(p * 0.2 + vec3(0., 1., 0.)).r + 4.;\n    \n    return dst;\n}\n\n\n// gets the distance to a place with a linear slope across the x and z\nfloat dstPlane(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    vec2 np = p.xz - pos.xz;\n    float dstY = abs(p.y - (slope.x * np.x + slope.y * np.y + pos.y)) - 0.01;\n    float dstXZ = max(abs(np.x) - s.x, abs(np.y) - s.y);\n    return max(dstY, dstXZ) * 0.7;\n}\n\n\n// takes the plane and bends it into sheet metal\nfloat dstSheetMetal(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(p + vec3(0., sin(p.x * 23.) * 0.025, 0.), slope, pos, s);\n    return dst * 0.7;\n}\n\n\n// the same as the sheet metal but wooden planks, it also positions them virtically\nfloat dstWoodenPlank(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(vec3(p.x, p.z, p.y), slope, vec3(pos.x, pos.z, pos.y), s);\n    return dst;\n}\n\n\n// the same as the orther plank but a different direction (idk if its north, north would be positive z)\nfloat dstWoodenPlankNorth(vec3 p, vec2 slope, vec3 pos, vec2 s)\n{\n    float dst = dstPlane(vec3(p.z, p.x, p.y), slope, vec3(pos.z, pos.x, pos.y), s);\n    return dst;\n}\n\n\n// specular reflection and diffusion (im not using the diffusion in this shader, its a hit or miss)\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// stores info on a material\nstruct Mat\n{\n    vec3 col, normal, glow;\n    float smoothness;\n    SpecularLight specular;\n};\n\n\n// stores info on a ray (after having been simulated)\nstruct Ray\n{\n    Mat mat;\n    vec3 cp, ro, rd;\n    float dst;\n    bool collided;\n};\n\n\n// returns info on the hit object so the material can be created\nstruct MatProperties\n{\n    vec3 col;\n    float glow, smoothness, shade_strength;\n};\n\n\n/*\nvec4 GetDst(vec3 p)\n{\n    float dst1 = dstSheetMetal(p, vec2(0., 0.75), vec3(2.5, 0., -4.5), vec2(5.));\n    float dst2 = length(p) - 1.;\n    \n    float dst = min(dst1, dst2);\n    \n    vec3 emmision = vec3(0.);\n    if (dst == dst2) emmision = mix(vec3(1., 1., 0.), vec3(0.), pow(clamp(dst2 * 0.2, 0., 1.), 0.4));\n    \n    return vec4(emmision, dst);\n}\n*/\n\n\n// gets the distance to a cilander\nfloat distToCilander(vec3 p, vec3 lineA, vec3 lineB, float r) {\n\tvec3 LineLine = lineB - lineA;\n    vec3 LinePoint = p - lineA;\n    \n    float t = dot(LineLine, LinePoint) / dot(LineLine, LineLine);\n    \n    vec3 center = lineA + (t * LineLine);\n    \n    float x = length(p - center) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(LineLine);\n    float e = length(max(vec2(x, y), 0.));\n    \n    float i = min(max(x, y), 0.);\n    \n    return e + i;\n}\n\n\n// using triplanar mapping to find the uv coord for a texture on any surface\nvec2 GetUV(vec3 p, vec3 normal)\n{\n    // the sharpness of the blending between different axises\n    float blendSharpness = 100.;\n    // finding the different axise's color\n    vec2 colX = p.zy;\n    vec2 colY = p.xz;\n    vec2 colZ = p.xy;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// gets the distance to the walls of the cabin (wooden walls)\nfloat dstCabin(vec3 p)\n{\n    vec3 p2 = vec3(p.x, p.y, abs(p.z + 1.1) - 3.6);  // making 2 walls for the price of one using a repeating coordinate space\n    vec3 p3 = vec3(abs(p.x + 0.2) - 4.2, p.y, p.z);  // making 2 walls for the price of one using a repeating coordinate space\n    float dst1 = dstWoodenPlank(p2, vec2(0.1, 0.025), vec3(-2.  + 3., -0.75, -2.), vec2(0.25, 2.));\n    float dst2 = dstWoodenPlank(p2, vec2(-0.1, -0.1), vec3(-2.6 + 3., -0.75, -2.), vec2(0.25, 2.));\n    float dst3 = dstWoodenPlank(p2, vec2(0.1, 0.), vec3(-3.2 + 3.   , -0.75, -2.), vec2(0.25, 2.));\n    float dst4 = dstWoodenPlank(p2, vec2(0., 0.05), vec3(-3.8 + 3.  , -0.75, -2.), vec2(0.25, 2.));\n    float dst5 = dstWoodenPlank(p2, vec2(0.2, 0.), vec3(-4.4 + 3.   , -0.75, -2.), vec2(0.25, 2.));\n\n    float dst = min(min(dst1, dst2), min(dst3, min(dst4, dst5)));\n    \n    dst1 = dstWoodenPlankNorth(p3, vec2(0.1, 0.025), vec3(-2.5, -0.75, -1.  + 1.), vec2(0.25, 2.));\n    dst2 = dstWoodenPlankNorth(p3, vec2(-0.1, -0.1), vec3(-2.5, -0.35, -1.6 + 1.), vec2(0.25, 2.4));\n    dst3 = dstWoodenPlankNorth(p3, vec2(0.1, 0.)   , vec3(-2.5, -0.25, -2.2 + 1.), vec2(0.25, 2.75));\n    dst4 = dstWoodenPlankNorth(p3, vec2(0., 0.05)  , vec3(-2.5, -0.35, -2.8 + 1.), vec2(0.25, 2.4));\n    dst5 = dstWoodenPlankNorth(p3, vec2(0.2, 0.)   , vec3(-2.5, -0.75, -3.4 + 1.), vec2(0.25, 2.));\n    float dst6 = dstWoodenPlankNorth(p3, vec2(0.2, 0.)   , vec3(-2.5, 0.75, -2. + 0.25), vec2(2., 0.25));\n   \n    dst = min(min(min(dst1, dst2), min(dst3, min(dst4, min(dst5, dst6)))), dst);\n\n    return dst;\n}\n\n\n// gets the distance to the roof and floor of the cabin (sheet metal)\nfloat dstCabinRoof(vec3 p)\n{\n    vec3 p2 = vec3(p.x, p.y, abs(p.z) - 0.9);  // making 2 sides of the roof/floor for the price of one using a repeating coordinate space\n    float dst1 = dstSheetMetal(p2, vec2(0., -0.9), vec3(0., 2., 0.), vec2(2., 0.8));\n    float dst2 = dstSheetMetal(p2, vec2(-0.025, 0.1), vec3(0., -1., 0.), vec2(2., 0.8));\n    // the light bulb\n    float dst3 = distToCilander(p + vec3(0.3, -0.6, 0.0), vec3(0., 0., 0.), vec3(0., 0.2, 0.), 0.01);\n    \n    float dst = min(dst1, min(dst2, dst3));\n    \n    return dst;\n}\n\n\n// gets the distance to the scene (there is a commented out function where i was messing with emmition in other ways then im using now and the raw version was that but without emission, this is the left over from that failed atempt)\nfloat GetDstRaw(vec3 p)\n{\n    float dst1 = dstCabinRoof(p + vec3(-3.5, 2.8, 4.));\n    float dst2 = length(p + vec3(-3.56 , 2.8, 4.) + vec3(0.3, -0.6, 0.0)) - 0.02;\n    float dst3 = dstCabin(p + vec3(-3.5, 3., 3.));\n    float dst4 = dstGround(p);\n    \n    float dst = min(min(dst1, dst2), min(dst3, dst4));\n    \n    return dst;\n}\n\n\n// gets the material properties so the material can be created\nMatProperties GetMat(vec3 p, vec3 normal, vec3 sun_dir)\n{\n    float dst1 = dstCabinRoof(p + vec3(-3.5, 2.8, 4.));\n    float dst2 = length(p + vec3(-3.56 , 2.8, 4.) + vec3(0.3, -0.6, 0.0)) - 0.02;\n    float dst3 = dstCabin(p + vec3(-3.5, 3., 3.));\n    float dst4 = dstGround(p);\n    \n    float dst = min(min(dst1, dst2), min(dst3, dst4));\n    \n    // the strength of the light\n    vec3 l = mix(vec3(1.75, 1.25, 0.), vec3(0.), pow(clamp(dst2 * 0.2 + max(floor(dot(sun_dir, vec3(0., 1., 0.)) + 0.4), 0.), 0., 1.), 0.4));\n    // checking which surface was hit\n    if (dst == dst1)  // sheet metal\n    {\n        vec3 col = texture(iChannel0, GetUV(p, normal) * 0.2).rgb;\n        float mask = abs(max(col.r - col.g, col.r - col.b)) + 0.9;\n        return MatProperties(col + l / mask, l.r / mask * 0.5, mask, 0.);\n    }\n    else if (dst == dst2)  // light bulb\n    {\n        vec3 col = vec3(1., 1., 0.5) * 4.;\n        return MatProperties(col * clamp(l.r, 0., 1.), 0., 1., 1.);\n    }\n    else if (dst == dst3)  // wooden plank\n    {\n        vec3 col1 = texture(iChannel2, GetUV(p, normal) * 0.4).rgb;\n        vec3 col2 = texture(iChannel1, GetUV(p, normal) * 0.4).rgb;\n        vec3 col = mix(col1, col2, 0.3 + col2 * 0.1);\n        float mask = length(col);\n        return MatProperties(col + l * 2.5, l.r * 0.5, 1., 0.);\n    }\n    else if (dst == dst4)  // ground (grass)\n    {\n        vec3 col = (texture(iChannel3, GetUV(p, normal) * 0.6).r * 0.6 + 0.4) * vec3(0.2, 0.8, 0.2);\n        float mask = abs(max(col.r - col.g, col.r - col.b)) + 0.7;\n        return MatProperties(col + l / mask * 1.3, l.r / mask * 1.1, 1., 0.);\n    }\n\n    return MatProperties(vec3(0.), 0., 0., 0.);\n}\n\n\n// gets the normal of the scene at a given position\n/*\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDstRaw(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDstRaw(p - e.xyy),\n        GetDstRaw(p - e.yxy),\n        GetDstRaw(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n*/\nvec3 GetNormal ( vec3 z)\n{\n    float e   =  0.01;\n    float dx1 = GetDstRaw(z + vec3(e, 0, 0));\n    float dx2 = GetDstRaw(z - vec3(e, 0, 0));\n    float dy1 = GetDstRaw(z + vec3(0, e, 0));\n    float dy2 = GetDstRaw(z - vec3(0, e, 0));\n    float dz1 = GetDstRaw(z + vec3(0, 0, e));\n    float dz2 = GetDstRaw(z - vec3(0, 0, e));\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\n// marches a ray through the scene\nRay MarchRay(vec3 ro, vec3 rd, vec3 sun_dir)\n{\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    float total_s = 0.;\n    vec3 glow = vec3(0.);\n    bool collided = false;\n    for (int s = 0; s < 200; s++)  // 200 steps\n    {\n        //vec4 data = GetDst(p);\n        //dst = data.w;\n        dst = GetDstRaw(p);\n        //glow = max(data.rgb, glow);\n        p += rd * dst;\n        dfs += dst;\n        \n        total_s = float(s);\n        \n        if (dfs > 20.) break;\n        if (dst < 0.02)  // a percision of 0.02\n        {\n            collided = true;\n            break;\n        }\n    }\n    \n    //glow /= total_s;\n    if (collided)  // checking if the ray collided to know if the color/material should be found\n    {\n        vec3 normal = GetNormal(p);\n        \n        MatProperties matProps = GetMat(p, normal, sun_dir);\n        SpecularLight spec = Specular(matProps.smoothness, normal, rd, sun_dir);\n        Mat mat = Mat((matProps.col + spec.highlight * (1. - matProps.shade_strength)) * mix(max(dot(normal, sun_dir) * 0.7 + 0.3 + matProps.glow, 0.), 1., matProps.shade_strength), normal, glow, matProps.smoothness, spec);\n        return Ray(mat, p, ro, rd, dfs, collided);\n    }\n    else  // the ray did not hit and a blank material will be created as there is nothing to render\n    {\n        return Ray(Mat(vec3(0.), vec3(0.), glow, 0., SpecularLight(0., 0.)), p, ro, rd, dfs, collided);\n    }\n}\n\n\n// renders soft shadows (credit to some other shader for this function)\nfloat SoftShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDstRaw(ro + rd*t);\n        if( h<0.001 )\n        {\n            return 0.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n// converts a vector3 to a float while randomizing it\nfloat hash31(vec3 p)\n{\n    return fract(sin(dot(p, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n}\n\n\n// rendering the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv coordinate\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // the mouse position\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // the sun direction\n    vec3 sun_dir = normalize(vec3(0.5, sin(iTime * 0.2 - 1.), 0.));\n\n    // setting the fov based on the scene\n    if (iTime < 11.) uv *= 3.75;\n    else uv *= 2.;\n\n    // finding the ray's direction\n    vec3 rd = Transform(uv, m, 0.);\n    // finding the camera's position based on the scene\n    vec3 ro;\n    if (iTime < 11.) ro = vec3(3., -2.5, -4.);\n    else ro = vec3(0., -1.5, -1.);\n\n    // the color (setting it to the sky color for starters)\n    vec3 col = vec3(0.05, 0.05, (rd.y * sun_dir.y) * 0.8 + 0.2) * 1.6;\n    // adding the sun\n    col = max(mix(col, vec3(1.5), pow(max(dot(rd, sun_dir), 0.), 275.)), 0.);\n\n    // marching the ray\n    Ray ray = MarchRay(ro, rd, sun_dir);\n    // checking if the ray hit anything\n    if (ray.collided)\n    {\n        // adding soft shadows\n        float shadow = SoftShadow(ray.cp + ray.mat.normal * 0.05, sun_dir, 0.05, 15., 30.) * 0.6 + 0.4;\n        ray.mat.col *= shadow;\n        // setting the color to the objects color\n        col = ray.mat.col;\n        col = pow(col, vec3(1. / 1.6));\n    }\n    //col += ray.mat.glow;\n    \n    // if it didnt collide then stars are rendered\n    if (!ray.collided)\n    {\n        // noise to make the stars blink\n        float sky_noise = round(noised(rd * 25. + iTime * 0.25).r * 0.5 + 0.5);\n        // rendering the stars\n        col = mix(col, vec3(1.), ceil(pow(hash31(floor(rd * 200.) / 200.), 12000.)) * clamp(clamp(rd.y + 0.2, 0., 1.) * pow(1. - col.b, 7.), 0., 1.) * sky_noise);\n        \n        // adding the moon\n        // the moons position (you have to rotate the ray's direction to not distort the value)\n        vec3 mp = vec3(rd.x, rot2D(vec2(rd.y, rd.z), 0.9 + iTime * 0.1));\n        vec3 mp2 = vec3(rd.x, rot2D(vec2(rd.y, rd.z), 0.99 + iTime * 0.1));\n        mp2 = vec3(rot2D(vec2(mp2.x, mp2.y), -0.075), mp2.z);\n        // the mask for the moon\n        float moon_mask = smoothstep(0.2, 0.15, length(mp.xz)) * smoothstep(0.15, 0.2, length(mp2.xz));\n        // adding the moon to the final color\n        col = mix(col, vec3(1.), clamp(moon_mask * clamp(clamp(rd.y + 0.2, 0., 1.) * pow(1. - col.b, 7.), 0., 1.), 0., 1.));\n    }\n    \n    //col = col + (pow((1. - length(col)) * 0.35, 2.));\n    \n    // the final color\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 671, 690, 690, 752], [755, 801, 851, 851, 1042], [1045, 1067, 1096, 1096, 1176], [1179, 1251, 1296, 1296, 1476], [1479, 1550, 1571, 1571, 1740], [1743, 1776, 1802, 1814, 3308], [3311, 3346, 3371, 3371, 3459], [3462, 3533, 3587, 3587, 3788], [3791, 3840, 3899, 3899, 4006], [4009, 4093, 4153, 4153, 4255], [4258, 4362, 4427, 4427, 4529], [4532, 4700, 4778, 4778, 5112], [5890, 5925, 5988, 5988, 6375], [6378, 6455, 6488, 6550, 6966], [6969, 7031, 7055, 7055, 8595], [8598, 8668, 8696, 8696, 9205], [9208, 9441, 9466, 9466, 9769], [9772, 9835, 9892, 9892, 11508], [11511, 11809, 11835, 11835, 12208], [12211, 12246, 12292, 12292, 13656], [13659, 13731, 13808, 13808, 14160], [14163, 14217, 14239, 14239, 14330], [14333, 14356, 14413, 14438, 16850]], "test": "untested"}
{"id": "NsKGWm", "name": "Uniforms - Workshop 2021", "author": "phathiipo", "description": "Explanation of uniforms for the Sidia Shader workshop 2021", "tags": ["uniforms"], "likes": 1, "viewed": 30, "published": "Public", "date": "1631660379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;  // Canvas size (width,height)\n//uniform vec2 u_mouse;       // mouse position in screen pixels\n//uniform float u_time;       // Time in seconds since load\n\n//uniform vec3 iResolution;   // viewport resolution (in pixels)\n//uniform vec4 iMouse;        // mouse pixel coords. xy: current, zw: click\n//uniform float iTime;        // shader playback time (in seconds)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(abs(sin(iTime)), 0.0, 0.0, 1.0);\n}\n\n// Other functions available\n// Some of those functions are: sin(), cos(), tan(), asin(), acos(), atan(), \n// pow(), exp(), log(), sqrt(), abs(), sign(), floor(), ceil(), fract(), mod(), min(), max() and clamp().\n\n// Play with the three channels (RGB) in different frequencies to get interesting patterns and behaviors.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 441, 498, 498, 554]], "test": "untested"}
{"id": "NsKGWy", "name": "logo-mtv", "author": "jorge2017a2", "description": "logo-mtv", "tags": ["logomtv"], "likes": 6, "viewed": 165, "published": "Public API", "date": "1632100123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n///por jorge2017a2...2021-sep-19\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 musicM(vec2 p, vec3 col)\n{\n     float sdb1= sdBox(p-vec2(-0.2,0.0), vec2(0.11,0.3) );//izq\n     float sdb2= sdBox(p-vec2(0.2,0.0), vec2(0.11,0.3) ); //der\n     float sdb3= sdBox(p-vec2(0.0,0.15), vec2(0.1,0.15) ); //centro\n     float sdt1= sdTriangleIsosceles(p-vec2(0.0,0.21), vec2(0.1,0.1) );\n     float sdt2= sdTriangleIsosceles(p-vec2(0.0,-0.1), vec2(0.1,0.11) );\n     sdb3= differenceSDF(sdb3, sdt1);\n     sdb3= unionSDF(sdb3, sdt2);\n     float sdtdmtv=unionSDF(sdb1, sdb3);\n     sdtdmtv=unionSDF(sdtdmtv, sdb2);\n     \n     col= DrawFigBorde(vec3(1.0,1.0,0.0)-p.y*1.5, col,sdtdmtv);\n     return col;\n}\n\nvec3 musicTv(vec2 p, vec3 col)\n{    float sdb1= sdBox(p-vec2(0.15,0.0), vec2(0.025,0.18) );\n     vec2 p1= rotatev2(p-vec2(0.15,0.12), radians(-25.0));\n     float sdb2= sdBox(p1, vec2(0.15,0.03) );//izq\n     float sunT=unionSDF(sdb1, sdb2);\n     vec2 p2= rotatev2(p-vec2(0.25,-0.05), radians(-10.0));\n     vec2 p3= rotatev2(p-vec2(0.33,-0.005), radians(25.0));\n     float sdbv1= sdBox(p2, vec2(0.025,0.12) );\n     float sdbv2= sdBox(p3, vec2(0.025,0.17) );\n     float sunv=unionSDF(sdbv1, sdbv2);\n     col= DrawFigBorde(vec3(1.0,0.0,0.0)-p.y*1.5, col,sunT);\n     col= DrawFigBorde(vec3(1.0,0.0,0.0)-p.y*1.5, col,sunv);\n     return col;\n}\n\nvec3 zigzag(vec2 p,vec3 colIn,  vec3 colOut)\n{\n     float wi=0.045;\n     float he=0.15;\n     float sk=0.1;\n     vec2 p1= rotatev2(p-vec2(0.2,0.0), radians(45.0));\n     float sdb1= sdBox(p1, vec2(0.025,0.12) );\n     vec2 p2= rotatev2(p-vec2(0.34,0.0), radians(-45.0));\n     float sdb2= sdBox(p2, vec2(0.025,0.12) );\n     \n     float sunb=unionSDF(sdb1, sdb2);\n     colOut= DrawFigBorde(colIn, colOut,sunb);\n     return colOut;\n} \n\nvec3 zig1(vec2 uv, vec3 colIn,vec3  colOut)\n{    float px=iTime;\n    vec2 uv2a=uv-vec2(px,0.0);\n    vec2 uv2b=uv-vec2(px,0.0);\n    uv2a.x= opRep1D(uv2a.x, 0.9 );\n    uv2a.y= opRep1D(uv2a.y, 0.22 );\n    \n    uv2b.x= opRep1D(uv2b.x+0.3, 0.9 );\n    uv2b.y= opRep1D(uv2b.y, 0.22 );\n    colOut=zigzag(uv2a,colIn,colOut);\n    colOut=zigzag(uv2b,colIn,colOut);\n    return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    vec3 col=vec3(1.0)-uv.y;\n    \n    col= zig1(uv, vec3(0.0,1.0,0.0), col);\n    \n    vec2 uv2=uv-vec2(1.0,0.0);\n    uv2= rotatev2(uv2, radians(45.0));\n    col= zig1(uv2, vec3(0.0,0.0,1.0), col);\n    \n    float py =uv.y + 0.015*sin(iTime*5.2 + uv.x*30.0);\n    \n    col= DrawFigBorde(vec3(0.5, 0., 1.)-uv.y*0.75, col, (py+0.3) );\n    col= DrawFig(vec3(1.0, 0., 0.)-uv.y, col, abs(py+0.33)-0.025 );\n    \n    col=musicM(uv, col);\n    col=musicTv(uv, col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 274, 308, 308, 403], [405, 436, 472, 472, 517], [523, 523, 562, 562, 606], [608, 652, 699, 699, 726], [727, 727, 770, 770, 797], [798, 798, 846, 846, 874], [880, 880, 942, 942, 1074], [1076, 1076, 1133, 1133, 1199], [1201, 1201, 1238, 1238, 1318], [1320, 1320, 1371, 1371, 1679], [1682, 1682, 1713, 1713, 2293], [2295, 2295, 2327, 2327, 2931], [2933, 2933, 2979, 2979, 3360], [3363, 3363, 3408, 3408, 3737], [3739, 3739, 3796, 3796, 4391]], "test": "untested"}
{"id": "NsKGzD", "name": "livecoding_2021_09_09", "author": "butadiene", "description": "shader", "tags": ["raymarching"], "likes": 5, "viewed": 186, "published": "Public API", "date": "1631198802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time mod(iTime,30.)\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n  \n  vec2 pmod(vec2 p,float n){\n    float np = 2.0*PI/n;\n    float r = atan(p.x,p.y)-0.5*np;\n    r = mod(r,np)-0.5*np;\n    return length(p)*vec2(cos(r),sin(r));\n    }\n  \n  \n  vec3 modfunc(vec3 p,float ss){\n    p.xz = pmod(p.xz,6.);\n    p.x -= ss;\n    return p;\n    }\n\nvec4 dist(vec3 p){\n  if(time>24.&&time<30.) p.z += 6.,p.y += 20.*time;\n  float kz = 30.;\n  if(time>18.&&time<24.)p = modfunc(p,22.);\n  if(time>24.&&time<30.)p = modfunc(p,22.),p.y = mod(p.y,kz)-0.5*kz;\n \n  float slllt = time;\n  if(time>24.&&time<30.)slllt = 23.9;\n  float sct = floor(mod(slllt*0.5,3.))+clamp(mod(slllt*1.5,3.),0.0,1.0);\n  if(time>24.&&time<30.)slllt =time;\n  float ksst = slllt+0.1;\n    \n  float sca = floor(ksst*0.5)+clamp(mod(ksst*1.5,3.),0.0,1.0);\n  float spt = 0.56+sct;\n    float d = box(p+vec3(0.,-0.3,-1.),vec3(spt*4.));\n  \n  float dc = 0.1;\n  for(int i = 0;i<1;i++){    \n    p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    }\n    d = max(d,box(p-vec3(0.3,0.6,0.3),vec3(0.2,0.5,0.2)));\n    \n        \n    p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    vec3 sssp = p;\n    \n        p = sin(clamp(p,-spt*PI,spt*PI))-0.1;\n    p.xz *= rot(0.3+sca);\n    p.yz *= rot(0.4+sca);\n    p.xy *= rot(sca);\n    p = abs(p)+0.;\n    \n    vec3 sc = vec3(0.02)+0.04*sin(PI*clamp(mod(time*1.5,3.),0.0,1.0));\n    sc += p.zxy*0.1+0.1*sssp;\n    sc *= 0.5;\n  vec3 col =sc;\n  return vec4(col,d);\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p =uv- 0.5;\n\tp /= vec2(iResolution.y / iResolution.x, 1);\n  float ra = 20.0;\n  if(time<6.) {ra = 20.0;}\n  else if(time<12.){ra = 10.0;}\n  if(time>18.&&time<24.) ra = 40.;\n  if(time>24.&&time<30.) ra = 1.3;\n  float rh =5.5;\n  if(time>12.&&time<18.)rh = 10.;\n  if(time>18.&&time<24.)rh = 14.;\n  if(time>24.&&time<30.)rh = 5.3;\n  float kt = time*0.3;\n  vec3 ro = vec3(ra*cos(kt),rh,ra*sin(kt));\n  vec3 ta = vec3(0);\n  \n  \n  \n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0,1,0));\n  vec3 up = cross(side,cdir);\n  float fov = 0.6;\n  vec3 rd = normalize(side*p.x+up*p.y+fov*cdir);\n  float d,t = 0.0;\n  float esp = 0.00001;\n  vec3 col = vec3(0.0);\n  vec3 ac = vec3(0.0);\n  for(int i = 0;i<127;i++){\n    vec4 rsd = dist(ro+rd*t);\n    d = rsd.w;\n    t += d;\n    if(d<esp) break;\n    ac += exp(-3.0*d)*rsd.xyz;\n    }\n  \n  col = 0.6*vec3(ac);\n  \n  col = pow(clamp(col,0.,1.),vec3(1.3));\n    \n  vec3 fincol =col;// vec3(p,0.);\n  \n   fragColor = vec4(fincol,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 69, 69, 120], [122, 122, 147, 147, 246], [252, 252, 278, 278, 413], [422, 422, 452, 452, 513], [515, 515, 533, 533, 1785], [1787, 1787, 1844, 1894, 2908]], "test": "untested"}
{"id": "Nst3DX", "name": "Gold Desert", "author": "yasuo", "description": "Gold Desart", "tags": ["dust", "desart"], "likes": 2, "viewed": 145, "published": "Public API", "date": "1630765614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 6.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL_SAND 0\n\n#define ZERO (min(iFrame,0))\n\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z += iTime*2.0;\n    p+=noise3d(p*1000.0)*0.001;\n    p.y+=noise3d(p*3.0)*0.15;\n    \n    return vec2(p.y,MATERIAL_SAND);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,2,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL_SAND){\n        vec3 np = p;\n        np.z += iTime*2.0;\n         float nn = noise3d(np*100.0)*0.2;\n        col = diffuseMaterial(n,rd,p,vec3(0.7,0.7,0.3)+nn);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float handShakeY = noise3d(vec3(iTime*2.0,iTime*2.1,iTime*2.2))*0.15;\n    float handShakeX = noise3d(vec3(iTime*2.1,iTime*2.2,iTime*2.1))*0.3;\n    \n    vec3 ro = vec3(handShakeX, handShakeY, 1.3);\n    ro.yz *= Rot(radians(-5.0));\n    ro.xz *= Rot(radians(iTime*5.0));\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.0001*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = mix(vec3(0.75,0.9,0.9)*0.5,vec3(0.8,0.9,0.9)*0.9,-uv.y+1.0);   \n    }\n    \n    // POST EFFECTS    \n    rd.z+=iTime*2.0;\n    \n    // dust effect\n    float c = noise3d(rd) * 0.5 + noise3d(rd * 5.0) * 0.25 + noise3d(rd * 10.0) * 0.1;    \n    col+=vec3(0.8,0.8,0.5)*c*0.5;\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 346, 371, 371, 710], [712, 712, 734, 734, 881], [883, 883, 941, 941, 1212], [1214, 1214, 1238, 1238, 1439], [1441, 1441, 1483, 1483, 1678], [1680, 1721, 1770, 1770, 2061], [2063, 2063, 2120, 2120, 2739], [2741, 2741, 2800, 2800, 3005], [3007, 3007, 3064, 3064, 4136]], "test": "untested"}
{"id": "NstSDn", "name": "Adaptive tile sizes", "author": "mrange", "description": "License CC0: Adaptive tile sizes\nBeen working too much lately to do shader stuff.\nBut today I experimented a bit with tiling so thought I share\n", "tags": ["2d"], "likes": 26, "viewed": 294, "published": "Public API", "date": "1632944654", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Adaptive tile sizes\n//  Been working too much lately to do shader stuff.\n//  But today I experimented a bit with tiling so thought I share\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n\nconst int max_iter = 6;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                    DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shape(vec2 p) {\n  const float z = 1.6;\n  p /= z;\n  p *= ROT(TIME*0.25);\n  p.y += 0.58;\n  float d = heart(p)*z;\n  return d;\n}\n\nfloat df(vec2 p, out int ii, out bool inside) {\n  float aa = 3.0/RESOLUTION.y;\n\n  float sz = 0.9;\n  float ds = shape(p);\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  return box(pp, vec2(r-aa));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float d = df(p, i, inside)*z;\n  float ds = shape(p)*z;\n  float ii = float(i)/float(max_iter);\n\n  if (!inside) d = abs(d)-aa;\n\n  vec3 col = vec3(0.0);\n  vec3 hsv = vec3((inside ? 0.1 : 0.6) +1.1*ii, 0.7, sqrt(max(1.0-ii, 0.0)));\n  vec3 rgb = hsv2rgb(hsv);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstSDn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[389, 541, 563, 563, 709], [1005, 1091, 1127, 1127, 1221], [1223, 1341, 1362, 1362, 1582], [1584, 1702, 1729, 1729, 1809], [1811, 1811, 1832, 1832, 1941], [1943, 1943, 1990, 1990, 2416], [2418, 2505, 2541, 2585, 2856], [2858, 2858, 2913, 2913, 3519]], "test": "untested"}
{"id": "NsV3Wc", "name": "Desert mountains v2", "author": "jarble", "description": "A simple desert terrain based on Karang's \"Desert biome\" shader.\n(Here's [url=https://www.shadertoy.com/view/NdcXzn]another version[/url] with a slightly more complicated formula).", "tags": ["procedural", "planet", "mountain", "desert", "biome"], "likes": 4, "viewed": 149, "published": "Public API", "date": "1632333483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 3./2.;\n    float freq = 1./3.;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        float n2 = noise((uv) * freq);\n        n1 = abs(n2-n1-.5-amplitude);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = abs(value-n1 * amplitude);\n        freq *= 1.25+freq+1./(1.+amplitude);\n        amplitude *= 1./3.;\n        \n\n        uv = uv.yx-n1/freq;\n\n        //value *= .9-.1*noise(uv/freq); //dunes\n\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\t//int norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tint norLOD = geoLOD;\n    vec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsV3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1290], [1293, 1293, 1324, 1324, 1586], [1588, 1652, 1697, 1697, 1983], [1985, 1985, 2023, 2023, 2278], [2280, 2280, 2347, 2347, 2574], [2576, 2576, 2607, 2607, 4051], [4053, 4053, 4110, 4110, 4744]], "test": "untested"}
{"id": "NsVGDD", "name": "Quad Tree Plus Circle", "author": "Yusef28", "description": "Mouse enabled\ncool harry potter themed functions\nInspired by https://www.shadertoy.com/view/lljSDy which I still don't understand completely", "tags": ["sdf", "tutorial", "comments", "quadtree", "harrypotter", "wellcommented"], "likes": 6, "viewed": 148, "published": "Public API", "date": "1631584168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//yore a wizard harry\n\n//a rotating vector\n#define wingardium_leviosa vec2(cos(iTime),sin(iTime))\n\n//from Fabrice,now I just need to find a spell for frame\n#define frame(p) vec2((p.xy*2.-iResolution.xy)/iResolution.y)\n\n//kind of like the open sesame of shadertoy\n#define alohamora frame(fragCoord)\n\n//kind of like what everyone thought Snape was doing but it was actually Quirl\n#define mobiliarbus frame(iMouse)\n\n//max layers of the quad tree\n#define max_layers 6\n\n//static factor to use each round\n#define scale_factor 2.\n\n//we use this to get the diagonal length of a quad in each layer\n//diagonal length of a square is side_length*sqrt(2) \n#define sqrt_of_2 1.41421356\n\n#define eps 1./iResolution.y\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    \n    vec2 uv = alohamora; //uv from -1. to 1.\n    vec2 global_uv = alohamora; //do it again just for fun\n    float scale = 2.; //starting scale \n    float radius = 0.34; //circle radius\n    float dist = 100.; //starting distance to circle \n    vec2 circle_coords = wingardium_leviosa;//move the circle around\n    \n    //if mouse is pressed, then you control the circle\n    if(iMouse.z > 0.5) circle_coords = mobiliarbus;\n    \n    //starting color\n    O = vec4(0.0);\n    O.r = .25;\n    \n    //find distance estimation to circle \n    float circle_dist = length(uv-circle_coords) - radius;\n    \n    //the plan is simple\n    \n    for(int i = 0; i < max_layers; i++){\n    \n        //we get a scaling variable of 2^n where n is layer number\n        scale = pow(scale_factor,float(i));\n        //we scale the global uv by it so from -1 -> 1\n        //we go to -2 -> 2 and then -4 -> 4 and so on\n        vec2 local_uv = global_uv*scale;\n        //we get the floor coordinates of this system for an id\n        //each QUAD then is a cell from one integer to the next (in 2d)\n        \n        // x: 1 -> 2 and y: 1 -> 2 is one quad\n        vec2 id = floor(local_uv);\n        //we use that id to get the centers for each quad local space\n        //and then immediately convert to global space by dividing again\n        //by our scale\n        //now we have a center coordinate, in global space, for \n        //every quad created in this layer\n        vec2 global_quad_center = (id + 0.5)/scale;\n        //we then find the lenght of one side in global space\n        //which is 1./scale (for example, if scale is 1, we have\n        //only 1 quad, so length is one\n        //if scale is 2, we have 4 quads with these dimentions\n        //\n        // x:0->0.5, y:0.5->1.  x:0.5->0.5, y:0.5->1.\n        //\n        // x:0->0.5, y:0->0.5   x:0.5->1., y:0.->0.5\n        //\n        //and you can see the math works because 1./2. gives a length\n        //of 0.5 which each quad has\n        \n        float quad_length = 1./scale;\n        \n        //we get the diagonal the cool way\n        float diagonal = quad_length*sqrt_of_2;\n        \n        //half it\n        float half_diagonal = diagonal/2.;\n        \n        //we want to find if our circle intersects the quad \n        //based on our quad's id (used to get center, blah blah blah)\n        //and that is approximated by this:\n        //if the distance between the quad center and the circle center\n        //is less than the sum of half the quad's diangona and\n        //the circle's radius, then the circle intersects the quad\n        float max_dist = half_diagonal + radius;\n        \n        //distance between circle center and quad center\n        float dist_between = length(circle_coords - global_quad_center);\n       \n       \n       //adding a sort of white vignette from one\n       //of iq's tileing shaders based on xo\n        vec2 u01 = fract(local_uv);\n        float vig = pow((1.-u01.x*u01.y*(1.-u01.x)*(1.-u01.y)\n        *1.*(float(max_layers-i)/float(max_layers))),300.3);\n        \n       \n       //the check, if true, we stop at this layer for this quad\n       //not more subdivisions\n        if(dist_between > max_dist) \n        {\n        \n        O.rgb += vig;\n        break;\n        \n        \n        }\n        //here I create borders for each quad and the math\n        //could be prettier but I transform the coords in every \n        //quad to be from 0 to 1. It's just the quads local coords\n        //minus the id. (or fract could work too)\n        vec2 local_0_to_1 = local_uv - id;\n        //then I translate left 0.5 so it's -0.5 -> 0.5\n        //and then abs so it's 0.5 <- 0 -> 0.5\n        vec2 abs_local = abs(local_0_to_1-0.5);\n        //I get the max like in a square sdf and if \n        //the value for that coord is more than 0.49 I say it's a border\n        //so make it white and break\n        //I try to subtracta small fraction of layer num over max layers\n        //but it doesn't really add anythin\n        if(max(abs_local.x,abs_local.y) > 0.49 \n        - float(i)/(20.*float(max_layers))) {\n            O ++; //stolen from fabrice\n            O.rgb += vig;\n            break;\n        }\n        //at the end of each round increase the color value by some standard\n        //amount\n        O.rbg += vec3(0.05, 0.1,0.08);\n\n    }\n   \n   //I through another circle on top like it fabrice's version to hind \n   //how the borders become a problem later on.\n   float circle_mask = 1.00-smoothstep(radius -eps, radius +eps,  length(uv-circle_coords) - radius*0.01);\n   vec3 circle_color =vec3(0.9);\n   O.rgb += circle_color*circle_mask/1.;\n   \n   \n   }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[524, 702, 751, 751, 5371]], "test": "untested"}
{"id": "NsVGWG", "name": "- swallow v1 -", "author": "anahit_movsesyan", "description": "A different version of https://www.shadertoy.com/view/NsyGzt", "tags": ["sdf", "bird", "walls", "swallow"], "likes": 11, "viewed": 173, "published": "Public API", "date": "1632087550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvec2 rotate(vec2 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -log2(exp2(-k * a) + exp2(-k * b)) / k;\n}\n\nfloat sdfFw(float d) {\n    return smoothstep(0., fwidth(d) * 1.5 * 720. / iResolution.y, d);\n}\n\nfloat sdf(float d) {\n    return smoothstep(0., .002 * 720. / iResolution.y, d);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat sdWing(vec2 q) {\n    float f1 = 5. * smoothstep(-0.9, 1.1, sin(iTime * 1.5));\n    float f2 = (sin(iTime * 18.) + 1.) * 1.5;\n\n    q = rotate(q, ((f1 * f2) / 19.) + PI / 2.02);\n    q.x -= sin(q.y * 22. + 1.5) * 0.01;\n    return sdLine(q, vec2(0., -0.45), vec2(0)) - 0.05 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdTail(vec2 q) {\n    float f = 5. * smoothstep(0.8, -1.9, 2. * sin(iTime*1.5));\n\n    q = rotate(q, f / 40. + PI / 2.25);\n    q.x -= sin(q.y * 7. + 1.) * 0.005 + sin(q.y * 15.) * 0.003;\n    return sdLine(q, vec2(0., -0.35), vec2(0)) - 0.035 * smoothstep(-0.23, 0., q.y);\n}\n \nfloat sdBird(vec2 p) {\n    float d, d1;\n    \n    // head\n    vec2 q = p - vec2(0.17, -0.045);\n    d = sdCircle(q, 0.045);\n    \n    q = p - vec2(0.205, -0.0415);\n    d1 = sdCircle(q, 0.03);\n    d = smoothMin(d, d1, 180.);\n    \n    // nose\n    q = p - vec2(0.2125, -0.055);\n    q = rotate(q, -PI / 3.5);\n    q.x -= sin(q.y * 0.01 + 1.) * 0.005 + sin(q.y * 0.01) * 0.005;\n    d1 = sdLine(q, vec2(0., -0.03), vec2(0)) - 0.0175 * smoothstep(-0.03, 0., q.y);\n    d = min(d, d1);\n    \n    // eye\n    q = p - vec2(0.21, -0.05);\n    d1 = sdCircle(q, 0.008);\n    d = max(d, -d1);\n    \n    // tail\n    q = p - vec2(0.08, -0.045);\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.08, -0.05);\n    q.y *= -1.;\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    // wings\n    q = p - vec2(0.105, -0.015);\n    d1 = sdWing(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.105, -0.075);\n    q.y *= -1.;\n    d1 = sdWing(q);\n    d = min(d, d1);\n\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/ max(iResolution.x, iResolution.y);\n    uv.y += sin(iTime * 1.55) / 10.;\n    \n    float signF = (step(fract(iTime / 5.) * 2. - 1., 0.) * 2. - 1.);\n    float bla = signF * (uv.x / 3. + fract(iTime / 2.5) * 2. - 1.);\n   \n    uv = rotate(uv, sin(iTime * 1.55 + PI / 3.5) / 10.);       \n    float k = 20.;\n    float birdD = smoothMin(sdBird(uv * 1.1), 1., 8.);\n    \n    float fd = mix(1. - sdf(smoothMin(birdD, -bla, k)), \n                   sdf(smoothMin(birdD, bla, k)), \n                   sdfFw(bla));\n    \n    vec3 c = vec3(sin(iTime / 5.) * 0.5 + 0.5, 0.8, 0.2);\n    fragColor = vec4((fd + 0.2) * (hsv2rgb(c) + 0.6), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 53, 53, 141], [143, 143, 187, 187, 240], [242, 242, 264, 264, 336], [338, 338, 358, 358, 419], [421, 421, 454, 454, 482], [484, 484, 521, 521, 653], [655, 655, 677, 677, 961], [963, 963, 985, 985, 1240], [1243, 1243, 1265, 1265, 2195], [2197, 2197, 2219, 2219, 2343], [2345, 2345, 2400, 2400, 3074]], "test": "untested"}
{"id": "NsVGzz", "name": "Nyan cat epic rad", "author": "floofinator7", "description": "waoah cool", "tags": ["truchet"], "likes": 8, "viewed": 62, "published": "Public", "date": "1630980664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 screenUV = fragCoord.xy/iResolution.xy;\n    \n    uv += iTime*.1;\n    uv *= 5.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); //random number between 0-1\n    float width =.25;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    vec2 cUv = gv-sign(gv.x+gv.y+.001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01,-.01, abs(d-.5)-width);\n    float angle = atan(cUv.x,cUv.y); // -pi to pi\n    float checker = mod(id.x+id.y,2.)*2.-1.;\n    float flow = sin(iTime+checker*angle*2.);\n    \n    float x = checker*angle/1.57-iTime*.3;\n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(x/2.,y);\n    \n    vec4 col = texture(iChannel0,fract(tUv))*mask;\n    if(col.a < .75) col = vec4(0.05,0,0.025,1);\n    \n    col.a = 1.;\n    //if(gv.x>.45 || gv.y>.45) col = vec3(1,0,0);\n    fragColor = col;\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 115], [117, 117, 174, 174, 1123]], "test": "untested"}
{"id": "Nsy3Dy", "name": "Fractal 78_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 29, "viewed": 443, "published": "Public API", "date": "1632057810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(\n        float i=0.,g=0.,e,s;\n        ++i<99.;\n        O.rgb+=mix(r/r,H(log(s)),.7)*.05*exp(-.45*i*i*e))\n    {\n        p=g*d-vec3(.05*sin(iTime*.5),.1,.7);\n        p=R(p,normalize(vec3(1,-2,2)),iTime*.5);\n        s=4.;\n        vec4 q=vec4(p,sin(iTime*.4)*.5);\n\t\tfor(int j=0;j++<8;)\n            q=abs(q),\n            q=q.x<q.y?q.zwxy:q.zwyx,\n            s*=e=1.35/min(dot(q,q),0.54),\n            q=q*e-vec4(0,4,.8,3);\n        g+=e=min(\n            length(q.w)/s,\n            length(cross(q.xyw,normalize(vec3(1,2,3))))/s-.0002\n        );\n    }\n    O=pow(O,vec4(5));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsy3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 801]], "test": "untested"}
{"id": "Nsy3zm", "name": "xor bit field", "author": "ntnl", "description": "minimal pattern generator using bitwise xor based on: \nhttps://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\nhttps://twitter.com/aemkei/status/1378106731386040322", "tags": ["xor", "bitwise"], "likes": 1, "viewed": 44, "published": "Public", "date": "1631228355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// minimal pattern generator using bitwise xor based on: \n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// https://twitter.com/aemkei/status/1378106731386040322\nvoid mainImage(out vec4 o,vec2 i){o=vec4(mod(float(int(i.x)^int(i.y)+iFrame),9.));}                 ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsy3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 197, 231, 231, 280]], "test": "untested"}
{"id": "NsyGDD", "name": "Overlaying Waves", "author": "Arrangemonk", "description": "tried to make waves for an ocean shader, ended up making a very inefficient noise function", "tags": ["wavesnoise"], "likes": 1, "viewed": 128, "published": "Public API", "date": "1631540739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Arrangemonk 2021, innefficient noise function\n//in the unlikely event of someone forking this: yeah, do that\n\nfloat PI  = 3.14159265359;\nfloat TAU = 6.28318530718;\nfloat E = 2.71828182846;\nfloat iters = 4.;\nfloat octaves = 128.;\n\nfloat wave(float x,float time)\n{\n   //return 1.-abs(sin(x * PI - time));\n   return sin(x * PI - time) *.5 + .5;\n}\n\nvec2 rot(vec2 uv, float phi)\n{\n    return vec2(sin(phi)*uv.x + cos(phi)*uv.y,cos(phi)*uv.x - sin(phi)*uv.y);\n}\n\nfloat rotfbm(vec3 pos)\n{\nfloat result = 0.;\nfloat m = 0.;\nfor(float i = 1.; i < octaves;i++)\n    {\n    float tmp = 1./i;\n    m += tmp;\n    result += wave(rot(pos.xy*i,PI * E * i).x * iters,pos.z)* tmp;\n    }\nreturn result /m;\n}\n\nvec3 NormalMap(in vec2 uv)\n{ \n    float p  = rotfbm(vec3(uv,iTime));\n    float h1 = rotfbm(vec3(uv + vec2(.1,0),iTime));\n    float v1 = rotfbm(vec3(uv + vec2(0,.1),iTime));      \n   \tvec2 normal = 0.5 + (p - vec2(h1, v1));\n    return normalize(vec3(normal, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\n    float val = rotfbm(vec3(uv,iTime));\n    vec3 col = NormalMap(uv);\n\n    // display as normals\n    //fragColor = vec4( col,1.0);\n    \n    // display as height\n    fragColor = vec4( val,val,val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 232, 264, 304, 345], [347, 347, 377, 377, 457], [459, 459, 483, 483, 686], [688, 688, 716, 716, 952], [954, 954, 1011, 1011, 1254]], "test": "untested"}
{"id": "NsyGDV", "name": "Soundshader X-lines", "author": "made", "description": "optimized for OLED", "tags": ["sound"], "likes": 5, "viewed": 306, "published": "Public API", "date": "1632171475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 128.0;\nconst float PI = 3.1415;\nconst float RADIUS = 1.5;\nconst float BRIGHTNESS = 0.15;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 color){\n    vec4 konvert = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 calc = abs(fract(color.xxx + konvert.xyz) * 6.0 - konvert.www);\n    return color.z * mix(konvert.xxx, clamp(calc - konvert.xxx, 0.0, 1.0), color.y);\n}\n\nfloat luma(vec3 color) {\n  //return dot(color, vec3(0.299, 0.587, 0.114));\n  return dot(color, vec3(0.299, 0.587, 0.5));\n}\n\nfloat getFrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getFrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getFrequency(index), getFrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getFrequency_blend(float x) {\n    return mix(getFrequency(x), getFrequency_smooth(x), 0.5);\n}\n\nvec3 circleIllumination(vec2 fragment, float radius) {\n\tfloat distance = length(fragment);\n\tfloat ring = 1.0 / abs(distance - radius - (getFrequency_smooth(0.0)/4.50));\n\t\n\t//float brightness = distance < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcolor += hsv2rgb( vec3( ( angle + iTime * 2.5 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * BRIGHTNESS;\n\t\n\tfloat frequency = max(getFrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcolor *= frequency;\n\t\n\t// Black halo\n\t//color *= smooth//step(radius * 0.5, radius, distance);\n\t\n\treturn color;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.5, 0.9, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * .99, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 1.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n\t\n    \n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n    color += doLine(rot, (RADIUS ), rot.x);\n    \n    float c1 = sin(iTime * SPEED);\n    float s1 = cos(iTime * SPEED);\n    vec2 rot1 = mat2(c1,s1,-s1,c1) * fragPos;\n    color += doLine(rot1, (RADIUS ), rot1.y);\n    \n\n    \n    \n    color += max(luma(color) - 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 181, 206, 206, 423], [425, 425, 449, 499, 547], [549, 549, 578, 578, 671], [673, 673, 709, 709, 920], [922, 922, 957, 957, 1021], [1023, 1023, 1077, 1077, 1627], [1629, 1629, 1680, 1680, 1931], [1933, 1933, 1990, 1990, 2591]], "test": "untested"}
{"id": "NsyGRc", "name": "Warping Flower", "author": "ndevlin", "description": "A colorful, warping flower that shifts using sin and cosin functions", "tags": ["warpingflower"], "likes": 2, "viewed": 21, "published": "Public", "date": "1631831737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Default Color\n    fragColor = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n    \n    float aspectRatio = 640.0f / 360.0f;\n    \n    vec2 center = vec2(0.5f, 0.5f);\n    \n    uv.x *= aspectRatio; // Make circular\n    \n    uv.x -= 0.4f; // Shift back to center\n    \n    vec2 uvCentered = uv - vec2(0.5, 0.5);\n    \n    \n    float theta = atan(uvCentered.x, uvCentered.y);\n    \n    float radiusAtPoint = 0.3;\n    \n    radiusAtPoint = 0.3f + (sin(cos(theta * 3.0f) + iTime * 2.0f)) / 7.0f;\n    \n    \n    \n    if(length(uv - center) < radiusAtPoint)\n    {\n         fragColor = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.0f);\n\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 48, 85, 85, 134], [137, 137, 194, 244, 919]], "test": "untested"}
{"id": "NsyGRV", "name": "Cool Shapes", "author": "cam93", "description": "cool shapes moving around, with changing colours.", "tags": ["trianglecameron"], "likes": 0, "viewed": 36, "published": "Public", "date": "1631801166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Triangle{\nvec2 A;\nvec2 B;\nvec2 C;\n};\n\nstruct Square{\nvec2 _A;\nvec2 _B;\nvec2 _C;\nvec2 _D;\n};\n\nfloat _signum(vec2 _a, vec2 _b, vec2 _c, vec2 _d){\n//calculate vectors AB and AC from points abc\nvec2 _AB = _b-_a;\nvec2 _AC = _c-_a;\nvec2 _AD = _d-_a;\n\nvec3 _AB_3D = vec3(_AB, 0.0);\nvec3 _AC_3D = vec3(_AC, 0.0);\nvec3 _AD_3D = vec3(_AD, 0.0);\n\n//calculate cross product\nvec3 _crossProduct = cross(_AB_3D, _AD_3D);\n\nreturn sign(_crossProduct.z);\n}\n\nfloat signum(vec2 a, vec2 b, vec2 c){\n//calculate vectors AB and AC from points abc\nvec2 AB = b-a;\nvec2 AC = c-a;\n\nvec3 AB_3D = vec3(AB, 0.0);\nvec3 AC_3D = vec3(AC, 0.0);\n\n//calculate cross product\nvec3 crossProduct = cross(AB_3D, AC_3D);\n\nreturn sign(crossProduct.z);\n}\n\nbool isInSquare(in vec2 point, in Square sq){\n\nfloat d1 = signum(sq._A, sq._B, point);\nfloat d2 = signum(sq._B, sq._C, point);\nfloat d3 = signum(sq._C, sq._D, point);\nfloat d4 = signum(sq._D, sq._A, point);\n\nif(((d1>0.0)&&(d2>0.0)&&(d3>0.0)&&(d4>0.0))||((d1<0.0)&&(d2<0.0)&&(d3<0.0)&&(d4<0.0)))\nreturn true;\nelse\nreturn false;\n}\n\nbool isInTriangle(in vec2 point, in Triangle tr){\n\nfloat d1 = signum(tr.A, tr.B, point);\nfloat d2 = signum(tr.B, tr.C, point);\nfloat d3 = signum(tr.C, tr.A, point);\n\nif(((d1>0.0)&&(d2>0.0)&&(d3>0.0))||((d1<0.0)&&(d2<0.0)&&(d3<0.0)))\nreturn true;\nelse\nreturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tr_disp_x = sin(iTime);\n        float sq_disp_y = sin(-iTime);\n    \n    Square sq;\n    sq._A = vec2(0.5,0.7 + sq_disp_y);\n    sq._B = vec2(1.0,0.5 + sq_disp_y);\n    sq._C = vec2(0.5,1.0 + sq_disp_y);\n    sq._D = vec2(0.0,0.5 + sq_disp_y);\n    \n    Triangle tr;\n    tr.A = vec2(-0.5 + tr_disp_x, 1.0);\n    tr.B = vec2(1.5 + tr_disp_x, 1.0);\n    tr.C = vec2(0.0 + tr_disp_x, 0.0);\n    \n    vec3 col = vec3(0.0);\n         \n    if(isInTriangle(uv, tr)){\n    col = 0.7 * 0.5/cos(iTime*uv.xyx-vec3(1,2,4)); \n    }\n     if(isInSquare(uv, sq)){\n    col = 0.6 * 0.4/cos((iTime*iTime)*uv.xyx-vec3(0,3,5)); \n    }\n    \n        vec3 _col = vec3(cos(fragCoord.x), cos(fragCoord.y), sin(fragCoord.x));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 150, 196, 445], [447, 447, 484, 530, 717], [719, 719, 764, 764, 1047], [1049, 1049, 1098, 1098, 1315], [1317, 1317, 1373, 1423, 2234]], "test": "untested"}
{"id": "NsyGWc", "name": "Fractal 79_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 26, "viewed": 411, "published": "Public", "date": "1632273510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    float i=0.,g=0.,e,s,a;\n    for(;++i<99.;){\n        p=d*g;\n        p.z+=iTime*.2;\n        p=R(p,vec3(1),1.2);\n        p=mod(p,2.)-1.;\n        // There is no basis for this line. \n        // It is written by mistake. \n        // I noticed later.\n        // However, since the picture is out, it is left as it is\n        p.xy=vec2(dot(p.xy,p.xy),length(p.xy)-1.);\n        s=3.;\n        for(int i=0;i++<5;){\n            p=vec3(10,2,1)-abs(p-vec3(10,5,1));\n            s*=e=12./clamp(dot(p,p),.2,8.);\n            p=abs(p)*e;\n        }\n        g+=e=min(length(p.xz),p.y)/s+.001;\n        a=cos(i*i/80.);\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.5)*a*a/e*6e-5;\n    }\n    O=pow(O,vec4(4));\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 913]], "test": "untested"}
{"id": "NsyGWd", "name": "Oscillo", "author": "tejas", "description": "passing sine wave", "tags": ["passingsinewave"], "likes": 0, "viewed": 29, "published": "Public", "date": "1632382212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float PI = 3.1415926f;\n    const float thickness = .02f;\n    const float speedFactor = .4f;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float yAxis = uv.y - .5f;\n    float amplitude = .5f * sin(iTime);\n    float passingSine = sin((uv.x + iTime * speedFactor) * 2.f * PI);\n    \n    float color = abs(yAxis - amplitude * passingSine) / thickness;\n\n    // Output to screen\n    fragColor = vec4(color, color, color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 492]], "test": "untested"}
{"id": "NsyGWm", "name": "Spider loop", "author": "supah", "description": "spider", "tags": ["lines", "loop", "spider"], "likes": 1, "viewed": 40, "published": "Public", "date": "1631631007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// DRAG \n// DRAG \n// DRAG \n// DRAG \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    float lines = 12. - floor((iMouse.x / iResolution.x) * 10.);\n    float num = lines / 2.;\n    float d = length(uv * sin(iTime + num * atan(uv.x, uv.y)));\n    d += length(uv) * 2.;\n    d = sin(d * 10. - iTime);\n    d = smoothstep(0.5, 0.5, d);\n    vec3 col = vec3(d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 93, 93, 459]], "test": "untested"}
{"id": "NsyGzK", "name": "flame PhJSuIXt", "author": "moka", "description": "//https://twitter.com/TaterGFX/status/1431191823142293506", "tags": ["flame"], "likes": 2, "viewed": 55, "published": "Public", "date": "1631784055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/7sc3RS\n//https://twitter.com/TaterGFX/status/1431191823142293506\n#define b(a) step(max(d.x,d.y),a)\nvoid mainImage(out vec4 O,vec2 C){\n\nfor(;O.w++<3.;){\nvec2 d,U=C.yx/iResolution.yx;\nU.y-=.5;U.x=U.x*.4+U.y*U.y;\nU.y+=U.x*sin(-iTime*9.+O.w*2.+U.x*25.)*.2;\nU.x-=asin(sin(U.y*34.))/20.;\nd=abs(U);O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),-1.);\n\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 132, 166, 166, 372]], "test": "untested"}
{"id": "NsyGzt", "name": "- swallow -", "author": "anahit_movsesyan", "description": "Wanted to create something like this \nhttps://33.media.tumblr.com/416c868980813011c098e56e8e81f28a/tumblr_nff3dhnTrO1qz6f9yo1_r2_500.gif\n\nNot even close? Oh well  :octopus: ", "tags": ["sdf", "bird", "walls", "swallow"], "likes": 10, "viewed": 184, "published": "Public API", "date": "1631912893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvec2 rotate(vec2 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat smoothMin(float a, float b, float k) {\n    return -log2(exp2(-k * a) + exp2(-k * b)) / k;\n}\n\nfloat sdfFw(float d) {\n    return smoothstep(0., fwidth(d) * 1.5 * 720. / iResolution.y, d);\n}\n\nfloat sdf(float d) {\n    return smoothstep(0., .002 * 720. / iResolution.y, d);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat sdWing(vec2 q) {\n    q = rotate(q, ((sin(iTime * 15.) + 0.5) / 3.5) + PI / 1.85);\n    q.x -= sin(q.y * 22. + 1.5) * 0.01 + sin(q.y * 25. + iTime * 15.) * 0.004;\n    return sdLine(q, vec2(0., -0.45), vec2(0)) - 0.05 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdTail(vec2 q) {\n    float f = 5. * smoothstep(0.8, -1.9, 2. * sin(iTime*1.5));\n    q = rotate(q, f / 60. + PI / 2.25);\n    q.x -= sin(q.y * 7. + 1.) * 0.005 + sin(q.y * 15.) * 0.003;\n    return sdLine(q, vec2(0., -0.35), vec2(0)) - 0.035 * smoothstep(-0.23, 0., q.y);\n}\n\nfloat sdHead(vec2 p) {\n    float d, d1;\n    \n    // head\n    vec2 q = p - vec2(0.17, -0.045);\n    d = sdCircle(q, 0.045);\n    \n    q = p - vec2(0.205, -0.0415);\n    d1 = sdCircle(q, 0.03);\n    d = smoothMin(d, d1, 180.);\n    \n    // nose\n    q = p - vec2(0.2125, -0.055);\n    q = rotate(q, -PI / 3.5);\n    q.x -= sin(q.y * 0.01 + 1.) * 0.005 + sin(q.y * 0.01) * 0.005;\n    d1 = sdLine(q, vec2(0., -0.03), vec2(0)) - 0.0175 * smoothstep(-0.03, 0., q.y);\n    d = min(d, d1);\n    \n    // eye\n    q = p - vec2(0.21, -0.05);\n    d1 = sdCircle(q, 0.008);\n    d = max(d, -d1);\n    \n    return d;\n}\n    \nfloat sdBird(vec2 p) {\n    float d = sdHead(p);\n    \n    // tail\n    vec2 q = p - vec2(0.08, -0.045);\n    float d1 = sdTail(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.08, -0.05);\n    q.y *= -1.;\n    d1 = sdTail(q);\n    d = min(d, d1);\n    \n    // wings\n    q = p - vec2(0.105, -0.015);\n    d1 = sdWing(q);\n    d = min(d, d1);\n    \n    q = p - vec2(0.105, -0.075);\n    q.y *= -1.;\n    d1 = sdWing(q);\n    d = min(d, d1);\n\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1.), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy)/ max(iResolution.x, iResolution.y);\n    uv.y += sin(iTime * 1.55) / 5.;\n    \n    float signF = (step(fract(iTime / 3.) * 2. - 1., 0.) * 2. - 1.);\n    float bla = signF * (uv.x / 3. + fract(iTime / 1.5) * 2. - 1.);\n   \n    uv = rotate(uv, sin(iTime * 1.55 + PI / 3.5) / 7.);       \n    \n    float fd = mix(1. - sdfFw(smoothMin(sdCircle(uv, 0.06), -bla, 8.)),\n                   sdf(smoothMin(sdBird(uv * 1.1), 1., 8.)),\n                   sdfFw(bla));\n    \n    fd = mix(fd, sdf(smoothMin(sdHead(uv * 1.1), bla + .001, 18.)), fd * sdfFw(bla));\n    \n    vec3 c = vec3(sin(iTime / 5.) * 0.5 + 0.5, 0.8, 0.2);\n    fragColor = vec4((fd + 0.2) * (hsv2rgb(c) + 0.6), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyGzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 53, 53, 141], [143, 143, 187, 187, 240], [242, 242, 264, 264, 336], [338, 338, 358, 358, 419], [421, 421, 454, 454, 482], [484, 484, 521, 521, 653], [655, 655, 677, 677, 907], [909, 909, 931, 931, 1185], [1187, 1187, 1209, 1209, 1777], [1783, 1783, 1805, 1805, 2224], [2226, 2226, 2248, 2248, 2372], [2374, 2374, 2429, 2429, 3143]], "test": "untested"}
{"id": "sd33Df", "name": "Map_2D_sidps", "author": "kingcrimson1112", "description": "A 2D Map shader using Perlin Noise", "tags": ["procedural", "noise", "perlinnoise", "maps"], "likes": 5, "viewed": 86, "published": "Public", "date": "1631460405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//----------------------------------------------------\n// TETXURE_SETTINGS\n//----------------------------------------------------\n#define TEXTURE_ROWS 100.0f\n#define GAMMA_CORRECTION 0\n\n// Gets the UV coordinate for Image\nvec2 get_uv(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv *= TEXTURE_ROWS;\n    // uv = (uv * 2.0f) - 1.0f;\n    uv.x *= (iResolution.x / iResolution.y);\n    return uv;\n}\n\n// Inverse Lerp Function\nfloat linear_step(float l, float u, float a)\n{\n    return ((a - l) / (u - l));\n}\n\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// PERLIN_NOISE_GENERATOR\n//----------------------------------------------------\n\nfloat fade(float t)\n{\n    return t * t * t * (t * ((t * 6.0f) - 15.0f) + 10.0f);\n}\n\nfloat grad(int hash, float x, float y, float z)\n{\n    int h = hash & 15;\n    // Convert lower 4 bits of hash into 12 gradient directions\n    float u = (h < 8) ? x : y,\n           v = ((h < 4) ? y : (h == 12 || h == 14 ? x : z));\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nint[512] p=int[512](151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\n             151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142,\n             8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,\n             35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,\n             134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41,\n             55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89,\n             18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226,\n             250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,\n             189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167,\n             43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246,\n             97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239,\n             107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n             138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180);\n\n// Returns noise value for position\nfloat noise(float x, float y, float z)\n{  \n    // Find the unit cube that contains the point\n    int X = int(floor(x)) & 255;\n    int Y = int(floor(y)) & 255;\n    int Z = int(floor(z)) & 255;\n\n    // Find relative x, y,z of point in cube\n    x -= floor(x);\n    y -= floor(y);\n    z -= floor(z);\n    \n    // Compute fade curves for each of x, y, z\n    float u = fade(x);\n    float v = fade(y);\n    float w = fade(z);\n\n    // Hash coordinates of the 8 cube corners\n    int A = p[X] + Y;\n    int AA = p[A] + Z;\n    int AB = p[A + 1] + Z;\n    int B = p[X + 1] + Y;\n    int BA = p[B] + Z;\n    int BB = p[B + 1] + Z;\n\n    // Add blended results from 8 corners of cube\n    float res = mix(\n        mix(\n            mix(grad(p[AA], x, y, z),\n                 grad(p[BA], x - 1.0f, y, z),\n                 u),\n            mix(grad(p[AB], x, y - 1.0f, z),\n                 grad(p[BB], x - 1.0f, y - 1.0f, z),\n                 u),\n            v),\n        mix(\n            mix(grad(p[AA + 1], x, y, z - 1.0f),\n                 grad(p[BA + 1], x - 1.0f, y, z - 1.0f),\n                 u),\n            mix(grad(p[AB + 1], x, y - 1.0f, z - 1.0f),\n                 grad(p[BB + 1], x - 1.0f, y - 1.0f, z - 1.0f),\n                 u),\n            v),\n        w);\n    return (res + 1.0f) / 2.0f;\n}\n\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// NOISE_GENERATOR\n//----------------------------------------------------\n#define NOISE_FUNCTION get_octave_noise\n#define SMOOTH_IL 1\n#define SCALE_FROM_CENTER 1\n#define LEVEL_OF_DETAIL 0\n#define NOISE_SCALE 20\n#define NUMBER_OCTAVES 4\n#define PERSISTANCE 0.5f\n#define LACUNARITY 2.0f\n#define NORMALIZE_OFFSET 0\n#define FALLOFF_CURVE 5\n#define FALLOFF_SHIFT 10\n\n// Generates a random noise between 0.0 and 1.0\nfloat rand(vec2 pos)\n{\n    return fract(sin(dot(pos, vec2(12.9898f, 78.233f))) * 43758.5453f);\n}\n\n// Gets the Random Noise Height\nfloat get_noise(vec2 pos,float time)\n{\n    pos *= float(TEXTURE_ROWS);\n#if LEVEL_OF_DETAIL\n    pos /= float(LEVEL_OF_DETAIL);\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos *= float(LEVEL_OF_DETAIL);\n#endif\n    return rand(pos);\n}\n\n// Gets the perlin noise for point b/w 0.0 and 1.0\nfloat perlin(vec2 pos)\n{\n    return noise(pos.x, pos.y, 0.0f);\n}\n\n// Gets the scaled perlin noise for point\nfloat get_perlin_noise(vec2 pos, float time)\n{\n    float rows = float(TEXTURE_ROWS);\n    float columns = rows * (iResolution.x / iResolution.y);\n    pos *= rows;\n    float scale = float(NOISE_SCALE);\n    if(scale <= 0.0f)\n    {\n        scale = 0.001f;\n    }\n    \n    float halfX = 0.0f;\n    float halfY = 0.0f;\n#if SCALE_FROM_CENTER\n    halfX = columns / 2.0f;\n    halfY = rows / 2.0f;\n#endif\n\n#if LEVEL_OF_DETAIL\n    pos /= float(LEVEL_OF_DETAIL);\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos *= float(LEVEL_OF_DETAIL);\n#endif\n     return perlin((pos - vec2(halfX,halfY)) / scale);\n}\n\n// Gets the scaled octave noise for point\nfloat get_octave_noise(vec2 pos, float timeRate)\n{\n    float rows = float(TEXTURE_ROWS);\n    pos *= rows;\n    float columns = rows*(iResolution.x / iResolution.y);\n    float scale = float(NOISE_SCALE);\n    if(scale <= 0.0f)\n    {\n        scale += 0.001f;\n    }\n    \n    int octaves = int(NUMBER_OCTAVES);\n    float lacunarity = max(LACUNARITY, 1.0f);\n    float persistence = min(PERSISTANCE, 1.0f);\n    \n    float halfX = 0.0f;\n    float halfY = 0.0f;\n#if SCALE_FROM_CENTER\n    halfX = columns / 2.0f;\n    halfY = rows / 2.0f;\n#endif\n\n    float[20] offsets=float[20](\n    0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n    0.0f, 0.0f, 0.0f, 0.0f, 0.0f\n    );\n    for(int i = 0; i < octaves * 2; i++)\n    {\n        offsets[i] = rand(vec2(pos.x, pos.y)) * 0.0f;\n    }\n    \n    float amplitude = 1.0f;\n    float frequency = 1.0f;\n    float noiseVal = 0.0f;\n    \n#if LEVEL_OF_DETAIL\n    pos = vec2(floor(pos.x), floor(pos.y));\n    pos /= float(LEVEL_OF_DETAIL);\n#endif\n\n    vec2 offset = timeRate * vec2(iTime * 1.25f, iTime * 1.25f);\n    scale += sin(iTime * 0.85f) * 0.0f;\n    \n    for (int i = 0; i < octaves; i++)\n    {\n#if NORMALIZE_OFFSET\n        float sampleX = (((pos.x-halfX) / scale) * frequency) + offset.x + offsets[i*2];\n        float sampleY = (((pos.y-halfY) / scale) * frequency) + offset.y + offsets[(i*2)+1];\n#else\n        float sampleX = (((pos.x-halfX + offset.x*scale) / scale) * frequency)  + offsets[i*2];\n        float sampleY = (((pos.y-halfY + offset.y*scale) / scale) * frequency)  + offsets[(i*2)+1];\n#endif\n        float noise = (perlin(vec2(sampleX, sampleY)) * 2.0f) - 1.0f;\n        noiseVal += noise * amplitude;\n        amplitude *= persistence;\n        frequency *= lacunarity;\n    }     \n#if SMOOTH_IL\n    noiseVal = smoothstep(-0.95f, 1.1f, noiseVal);\n#else\n    noiseVal = linear_step(-0.7f,0.85f,noiseVal);\n#endif\n    return noiseVal;\n}\n\n// Evaluates the falloff curve to match the border\nfloat eval_curve(float val)\n{\n    float a = float(FALLOFF_CURVE);\n    float b = float(FALLOFF_SHIFT);\n    val = pow(val, a) / (pow(val, a) + pow(b - (b * val), a));\n    return val;\n}\n\n// Returns the falloff map for map\nfloat falloff(vec2 pos,float time)\n{\n    pos.x /= (iResolution.x / iResolution.y);\n    pos = pos * 2.0f - 1.0f;\n    float val = max(abs(pos.x), abs(pos.y));\n    return clamp(eval_curve(val), 0.0f, 1.0f);\n}\n\n// Gets a Cloud Map\nfloat cloud_map(vec2 pos)\n{\n    vec2 offset=vec2(500.0f);\n    //offset+=vec2(iTime*0.0f);\n    float h = get_octave_noise(pos+offset,1.25f);\n    float th=0.75f;\n    h=(h<th)?0.0f:h;\n    return h;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\n\n//----------------------------------------------------\n// MAP_SETTINGS\n//----------------------------------------------------\n\n// Color for all regions\nvec3[8] regions = vec3[8](\nvec3(0.15f, 0.15f, 0.75f), // DARK BLUE\nvec3(0.2f, 0.5f, 1.0f), // OCEAN BLUE\nvec3(0.98f, 0.88f, 0.2f), // SAND YELLOW\nvec3(0.2f, 0.8f, 0.2f), // LIGHT GREEN\nvec3(0.2f, 0.60f, 0.2f), // DARK GREEN\nvec3(0.6f, 0.35f, 0.1f), // LIGHT BROWN\nvec3(0.25f, 0.1f, 0.05f), // DARK BROWN\nvec3(0.85f, 0.85f, 1.0f) // SNOW BLUE\n);\n\n// Start height for all regions\nfloat[8] heights = float[8](\n0.00f, // DEEP OCEAN\n0.025f, // OCEAN\n0.35f, // COAST\n0.365f, // PLAINS\n0.565f, // FORESTS\n0.695f, // HILLS\n0.82f, // MOUNTAINS\n0.93f // SNOW\n);\n\n// Gets the index of the region height lies in\nint get_region_index(float h)\n{\n    int index = -1;\n    for(int i = 0; i < 8; i++)\n    {\n        if(h >= heights[i])\n        {\n            index++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return index;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n#define APPLY_FALLOFF 1\n#define COLOR_MAP 1\n\n#define BLEND_REGIONS 1\n#define MIX_FACTOR 0.65f\n#define MIX_THRESHOLD 0.85f\n\n#define DRAW_CLOUDS 1\n#define CLOUD_BLEND 0.75f\n\n#define ENABLE_LIGHT 1\n#define LIGHT_ANGLE 240.0f\n#define LIGHT_ELEVATION_ANGLE 30.0f\n#define LIGHT_CHECK 0.015f\n#define LIGHT_INTENSITY 5.0f\n\nvec3 get_color(vec2 uv)\n{\n    bool insideMap=true;\n    float timeFac=0.85f;\n    vec3 shadowMap=vec3(1.0f);\n    bool applyShadow=false;\n    \n    // Get Height\n    float h= NOISE_FUNCTION(uv,timeFac);\n    vec3 col=vec3(h);\n    \n#if ENABLE_LIGHT\n    vec2 lightDir=vec2(1.0f,0.0f);\n    float theta=float(LIGHT_ANGLE+iTime*45.0f)*(3.1416f/180.0f);\n    mat2 rot=mat2(cos(theta), -sin(theta),\n                  sin(theta), cos(theta));\n    lightDir=normalize(lightDir*rot);\n    \n    float checkDist=float(LIGHT_CHECK);\n    float hP=NOISE_FUNCTION(uv-lightDir*checkDist,timeFac);\n    \n    float xDiff=checkDist;\n    float yDiff=(hP-h);\n    float delH=tan(LIGHT_ELEVATION_ANGLE*(3.1416f/180.0f))*xDiff;\n    \n    if(insideMap)\n    {\n        if(yDiff<delH)\n        {\n            yDiff=0.0f;\n        }\n        yDiff=1.0f-yDiff;\n        if(yDiff>=0.0f)\n        {\n            yDiff=pow(yDiff,LIGHT_INTENSITY);\n        }\n        shadowMap=vec3(yDiff);\n    }\n#endif\n    \n#if APPLY_FALLOFF \n    // Apply Falloff\n    float diff = falloff(uv,0.0f);\n    if(h-diff<0.0f)\n    {\n        insideMap=false;\n    }\n    h = clamp(h-diff, 0.0f, 1.0f);\n    col=vec3(h);\n#endif\n\n#if COLOR_MAP\n    // Get Color from Region\n    int index = get_region_index(h);\n    col = regions[index];\n#endif\n\n    // Blend Region Colors\n#if BLEND_REGIONS\n    float h2 = ((index+1)<8?heights[index+1]:1.0f);\n    float off = linear_step(heights[index],h2,h);\n    //off=smoothstep(heights[index],h2,h);\n    if(off>=MIX_THRESHOLD/2.0f)\n    {\n       applyShadow=true;\n    }\n    if(off>=MIX_THRESHOLD)\n    {\n        col = mix(col, mix(col, regions[index+1], off), MIX_FACTOR);\n    }\n#endif\n    \n    // Apply Cloud Cover\n#if DRAW_CLOUDS\n    if(insideMap)\n    {\n        float cH=cloud_map(uv);\n        vec3 cloud = vec3(cH);\n        if(cH>0.0f)\n        {\n            col = (cloud*CLOUD_BLEND)+col*(1.0f-CLOUD_BLEND);\n        }\n    }\n#endif\n\n    if(insideMap && index>2 && applyShadow)\n    {\n        col*=shadowMap;\n    }\n    \n    return col;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = get_color(uv);\n    \n#if GAMMA_CORRECTION\n    col = pow(col, vec3(1.0f / 2.2f));\n#endif\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 222, 251, 251, 411], [413, 438, 484, 484, 518], [632, 769, 790, 790, 851], [853, 853, 902, 902, 1145], [3808, 3844, 3884, 3936, 5122], [5653, 5701, 5723, 5723, 5797], [5799, 5831, 5869, 5869, 6066], [6068, 6119, 6143, 6143, 6183], [6185, 6227, 6273, 6273, 6818], [6820, 6862, 6912, 6912, 8782], [8784, 8835, 8864, 8864, 9017], [9019, 9054, 9090, 9090, 9259], [9261, 9281, 9308, 9308, 9477], [10295, 10342, 10373, 10373, 10577], [10578, 11003, 11028, 11028, 12989], [12990, 13101, 13158, 13158, 13357]], "test": "untested"}
{"id": "sd33WS", "name": "Slowtember 01-03: Street/Walk", "author": "klemek", "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/", "tags": ["slowtember"], "likes": 4, "viewed": 99, "published": "Public API", "date": "1630564706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415927\n#define E .001\n\nfloat n(float c) {\n    return min(1., max(.0, c));\n}\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 color(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nvec3 n3(vec3 c) {\n    return min(vec3(1), max(vec3(0), c));\n}\n\nvec3 mask(vec3 c0, vec3 c1, float m) {\n    return n3(c0 * (1.0 - m) + c1 * m);\n}\n\nfloat circle(vec2 uv, vec2 center, float size, float e) {\n    uv -= center;\n    return smoothstep(size * .5 + e,size * .5 - e, length(uv));\n}\n\nfloat ellipse(vec2 uv, vec2 center, vec2 size, float e) {\n    uv -= center;\n    uv.y *= size.x / size.y;\n    return circle(uv, vec2(.0), size.x, e);\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    return vec2(\n        cos(angle * PI) * uv.x - sin(angle * PI) * uv.y,\n        sin(angle * PI) * uv.x + cos(angle * PI) * uv.y\n    );\n}\n\nfloat rect(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return \n        smoothstep(size.x * .5 + e, size.x * .5 - e, uv.x) *\n        smoothstep(-size.x * .5 - e, -size.x * .5 + e, uv.x) *\n        smoothstep(size.y * .5 + e, size.y * .5 - e, uv.y) *\n        smoothstep(-size.y * .5 - e, -size.y * .5 + e, uv.y);\n}\n\nfloat rrect(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    vec2 isize = size - vec2(r);\n    vec2 v1 = isize * .5;\n    vec2 v2 = v1 * vec2(-1, 1);\n    return n(\n        circle(uv, + v1, r, e) +\n        circle(uv, - v1, r, e) +\n        circle(uv, + v2, r, e) +\n        circle(uv, - v2, r, e) +\n        rect(uv, vec2(.0), vec2(size.x, isize.y), .0, e) + \n        rect(uv, vec2(.0), vec2(isize.x, size.y), .0, e)\n    );\n}\n\nfloat rrect2(vec2 uv, vec2 center, vec2 size, float r, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    return n(\n        rrect(uv, vec2(.0), size, r, .0, E) +\n        rect(uv, vec2(.0, - size.y * .5 + r * .5), vec2(size.x, r), .0, E)\n    );\n}\n\nfloat triangle(vec2 uv, vec2 center, vec2 size, float angle, float e) {\n    uv -= center;\n    uv = rotate(uv, angle);\n    uv += vec2(0, size.y * .5);\n    return\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-size.x * .5 -e, -size.x * .5  + e, - uv.x - uv.y * size.x * .5 / size.y) *\n        smoothstep(-e, +e, uv.y);\n}\n\nfloat line(vec2 uv, vec2 p1, vec2 p2, float size, float e) {\n    vec2 diff = p2 - p1;\n\n    float angle = atan(diff.y, diff.x) / PI;\n    return n(\n        circle(uv, p1, size, e) +\n        circle(uv, p2, size, e) +\n        rect(uv, (p1 + p2) * .5, vec2(length(diff), size), -angle, e)\n    );\n}\n\nvec3 building(float x, vec2 uv, vec3 c) {\n    float height = .4 + .35 * rand(floor(x) + 8234.);\n    height -= mod(height, .1) - .07;\n\n    float color_x = rand(floor(x) + 233.);\n    vec3 bg_color = vec3(.2) + .05 * color(color_x);\n    vec3 door_color = vec3(.2, .0, .0) + .1 * color(color_x + .5);\n\n    c = mask(c, bg_color, rrect2(uv, vec2(.0, -.2 + height * .5), vec2(.3, height), .01, .0, E));\n    \n    float door_pos = .2 * (rand(floor(x) + 234.) - .5);\n\n    c = mask(c, door_color, rrect2(uv, vec2(door_pos, -.15), vec2(.08, .1), .01, .0, E));\n    c = mask(c, vec3(.5, .5, .0), circle(uv, vec2(door_pos + .02, -.15), .02, E));\n    \n    float mask_height = height - .165;\n    mask_height -= mod(mask_height, .1);\n    float window_mask = rect(uv, vec2(.0, mask_height * .5 - .04), vec2(.3, mask_height), .0, E);\n\n    vec2 uv2 = mod(uv + .05, .1) - .05;\n    float light = rand(floor(x) + 432. + floor((uv.x + .05) * 10.) * 233. + floor((uv.y + .05) * 10.) * 523.);\n    c = mask(c, light < .3 ? vec3(.1, .1, .1) : vec3(.7, .7, .5), window_mask * rrect(uv2, vec2(.0, -.0), vec2(.07, .07), .01, .0, E));\n    return c;\n}\n\nvec3 dude(vec2 uv, vec3 c, float t0) {\n    const vec2 LEG0[8] = vec2[](vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08),vec2(+.00,-.10),vec2(+.00,-.12),vec2(+.00,-.09),vec2(+.00,-.08));\n    const vec2 LEG1[8] = vec2[](vec2(+.06,-.20),vec2(+.06,-.20),vec2(-.01,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(-.03,-.20),vec2(+.02,-.18),vec2(+.06,-.15));\n    const vec2 LEG2[8] = vec2[](vec2(+.11,-.30),vec2(+.06,-.30),vec2(-.02,-.30),vec2(-.06,-.30),vec2(-.09,-.28),vec2(-.12,-.25),vec2(-.04,-.20),vec2(+.01,-.25));\n    const vec2 ARM0[8] = vec2[](vec2(-.00,+.07),vec2(-.01,+.05),vec2(+.01,+.08),vec2(+.02,+.09),vec2(+.03,+.07),vec2(+.03,+.05),vec2(+.02,+.08),vec2(+.01,+.09));\n    const vec2 ARM1[8] = vec2[](vec2(-.05,+.02),vec2(-.07,+.02),vec2(+.00,+.00),vec2(+.03,+.02),vec2(+.04,+.01),vec2(+.05,+.01),vec2(+.00,+.01),vec2(-.04,+.02));\n    const vec2 ARM2[8] = vec2[](vec2(-.06,-.06),vec2(-.08,-.05),vec2(+.00,-.07),vec2(+.05,-.07),vec2(+.07,-.07),vec2(+.09,-.06),vec2(+.01,-.06),vec2(-.04,-.06));\n\n    float t = mod(t0, .8);\n    float t2 = t * 10.;\n    float t3 = mod(t, .1) * 10.;\n    \n    int ti1 = int(t2);\n    int ti1_next = int(mod(t2 + 1., 8.));\n    \n    int ti2 = int(mod(t2 + 4., 8.));\n    int ti2_next = int(mod(t2 + 5., 8.));\n    \n    vec2 l10 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l11 = (1. - t3) * LEG1[ti1] + t3 * LEG1[ti1_next];\n    vec2 l12 = (1. - t3) * LEG2[ti1] + t3 * LEG2[ti1_next];\n    \n    vec2 l20 = (1. - t3) * LEG0[ti1] + t3 * LEG0[ti1_next];\n    vec2 l21 = (1. - t3) * LEG1[ti2] + t3 * LEG1[ti2_next];\n    vec2 l22 = (1. - t3) * LEG2[ti2] + t3 * LEG2[ti2_next];\n    \n    vec2 a10 = (1. - t3) * ARM0[ti1] + t3 * ARM0[ti1_next];\n    vec2 a11 = (1. - t3) * ARM1[ti1] + t3 * ARM1[ti1_next];\n    vec2 a12 = (1. - t3) * ARM2[ti1] + t3 * ARM2[ti1_next];\n    \n    vec2 a20 = (1. - t3) * ARM0[ti2] + t3 * ARM0[ti2_next];\n    vec2 a21 = (1. - t3) * ARM1[ti2] + t3 * ARM1[ti2_next];\n    vec2 a22 = (1. - t3) * ARM2[ti2] + t3 * ARM2[ti2_next];\n    \n    vec3 c0 = color(t0 * .2);\n    \n    c = mask(c, .4 * c0, line(uv, l20, l21, .05, E));\n    c = mask(c, .4 * c0, line(uv, l21, l22, .05, E));\n    \n    c = mask(c, .4 * c0, line(uv, a20, a21, .04, E));\n    c = mask(c, .4 * c0, line(uv, a21, a22, .04, E));\n \n    c = mask(c, .5 * c0, line(uv, l10 + vec2(.0, .01), l10 + vec2(.01, .15), .1, E));\n    \n    c = mask(c, .5 * c0, line(uv, l10, l11, .05, E));\n    c = mask(c, .5 * c0, line(uv, l11, l12, .05, E));\n    \n    c = mask(c, .6 * c0, line(uv, a10, a11, .04, E));\n    c = mask(c, .6 * c0, line(uv, a11, a12, .04, E));\n    \n    c = mask(c, .5 * c0, circle(uv, l10 + vec2(.015, .25), .1, E));\n\n    return c;\n}\n\nvec3 lamp(vec2 uv, vec3 c) {\n\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, -.1), vec2(.03, .25), .01, .0, E));\n    \n    float light_mask = n(\n        triangle(uv, vec2(.23, -.1), vec2(.2, .25), .0, .01) +\n        rect(uv, vec2(.25, -.1), vec2(.04, .25), .0, .01) +\n        triangle(uv, vec2(.27, -.1), vec2(.2, .25), .0, .01) +\n        ellipse(uv, vec2(.25, -.23), vec2(.24, .1), .01)\n    );\n    \n    c = mask(c, vec3(.8, .8, .0), light_mask * .5 * n(uv.y * 2.5 + .6));\n    c = mask(c, vec3(.05), rrect2(uv, vec2(.25, .02), vec2(.06, .02), .01, .0, E));\n\n    return c;\n}\n\nvec3 road(vec2 uv, vec3 c) {\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.2));\n    c = mask(c, vec3(.05), smoothstep(E, -E, uv.y+.24));\n    c = mask(c, vec3(.1), smoothstep(E, -E, uv.y+.25));\n    c = mask(c, vec3(.2), smoothstep(E, -E, uv.y+.38));\n    \n    c = mask(c, vec3(.6), rrect(uv, vec2(.0, -.31), vec2(.05, .01), .0, .0, E));\n    \n    return c;\n}\n\nvec3 sky(vec2 uv, float x) {\n    vec3 c = vec3(0, .3 - .5 * uv.y, .5);\n    \n    float t = x * .1;\n    \n    const float size = .05;\n    vec2 uv2 = mod(uv + vec2(t, .0), size);\n    float r1 = rand(floor((uv.x + t + size) * 20.) * 223. + floor((uv.y + 10. + size) * 20.) * 523.);\n    float r2 = rand(floor((uv.x + t + size) * 20.) * 523. + floor((uv.y + 10. + size) * 20.) * 823.);\n    float r3 = rand(floor((uv.x + t + size) * 20.) * 923. + floor((uv.y + 10. + size) * 20.) * 323.);\n    if (r3 < .1) {\n    \n        float star =  n(uv.y * 2.) * n(\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .002, E) +\n            circle(mod(uv2, .05), vec2(size * .5 + size * .4 * (r1 - .5), size * .5 + size * .4 * (r2 - .5)), .005, .015)\n        );\n    \n        c = mask(c, vec3(.9, .9, .7), star);\n    }\n    \n    c = mask(c, vec3(.9, .9, .7), n(circle(uv, vec2(-.6,.25), .1, E) + circle(uv, vec2(-.6,.25), .11, .02)));\n    \n    return c;\n}\n\nvec3 image(vec2 uv, float t) {\n    float bg_time = uv.x + t * .4;\n    \n    vec3 c = sky(uv, t);\n    \n    vec2 uv1 = vec2(mod(bg_time, .2), uv.y);\n    c = road(uv1, c);\n    \n    vec2 uv2 = vec2(mod(bg_time, .32), uv.y);\n    c = building(bg_time/.32, uv2 - vec2(.15, .0), c);\n\n    vec2 uv3 = vec2(mod(bg_time, .5), uv.y);\n    c = lamp(uv3, c);\n\n    c = dude(uv + vec2(.0, .1), c, t * .6);\n    \n    return c;\n}\n\nvec3 colorShiftImage(vec2 uv, float t0, float t1, float size) {\n    vec3 c1 = image(uv + vec2(size * sin(t1), size * cos(t1)), t0);\n    vec3 c2 = image(uv + vec2(size * sin(t1 + 2.), size * cos(t1 + 2.)), t0);\n    vec3 c3 = image(uv + vec2(size * sin(t1 + 4.), size * cos(t1 + 4.)), t0);\n    \n    return vec3(c1.x, c2.y, c3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 c = colorShiftImage(uv, iTime * .5, iTime * 5., .0);\n \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 55, 55, 89], [91, 91, 115, 115, 200], [202, 202, 223, 223, 392], [394, 394, 411, 411, 455], [457, 457, 495, 495, 537], [539, 539, 596, 596, 680], [682, 682, 739, 739, 832], [834, 834, 869, 869, 1008], [1010, 1010, 1077, 1077, 1384], [1386, 1386, 1463, 1463, 1872], [1874, 1874, 1952, 1952, 2142], [2144, 2144, 2215, 2215, 2528], [2530, 2530, 2590, 2590, 2822], [2824, 2824, 2865, 2865, 3941], [3943, 3943, 3981, 3981, 6597], [6599, 6599, 6627, 6627, 7172], [7174, 7174, 7202, 7202, 7533], [7535, 7535, 7563, 7563, 8525], [8527, 8527, 8557, 8557, 8934], [8936, 8936, 8999, 8999, 9265], [9267, 9267, 9324, 9324, 9517]], "test": "untested"}
{"id": "sd3GDB", "name": "Renderer_2D_sidps", "author": "kingcrimson1112", "description": "A Shader to render 2 vertex data to Screen", "tags": ["2d", "renderer"], "likes": 0, "viewed": 39, "published": "Public", "date": "1630582186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TO_INTERPOLATE 1\n#define RENDER_TRIANGLE 0\n\n// Image Settings\nfloat yScaling = 1.0f;\n\n// Scene Settings\nvec3 bgColor = vec3(0.05f);\nvec3 objectColor = vec3(0.85f,0.2f,0.25f);\n\n// Vertex Data\n#if RENDER_TRIANGLE\n// 1. Triangle\n// a. All the vertices of 2D Object\nvec3[3] vertices = vec3[3](\nvec3(0.0f, 0.5f, 0.0f),\nvec3(0.5f, -0.5f, 0.0f),\nvec3(-0.5f, -0.5f, 0.0f)\n);\n// b. The Index order for each triangle of the Object\nint[3] indices = int[3](\n0, 1 , 2\n);\n#else\n// 2. Rectangle\n// a. All the vertices of 2D Object\nvec3[4] vertices = vec3[4](\nvec3(0.5f, 0.5f, 0.0f),\nvec3(0.5f, -0.5f, 0.0f),\nvec3(-0.5f, -0.5f, 0.0f),\nvec3(-0.5f, 0.5f, 0.0f)\n);\n// b. The Index order for each triangle of the Object\nint[6] indices=int[6](\n0, 1, 2,\n2, 3, 0\n);\n#endif\n// The Color of each vertex of Object\nvec3[4] basicColors = vec3[4](\nvec3(0.25f, 0.1f, 0.95f),\nvec3(0.5f, 0.1f, 0.95f),\nvec3(0.25f, 0.8f, 0.95f),\nvec3(0.25f, 0.1f, 0.15f)\n/*vec3(1.0f),\nvec3(1.0f, 0.0f, 0.0f),\nvec3(0.0f, 1.0f, 0.0f),\nvec3(0.0f, 0.0f, 1.0f)*/\n);\n\n// Checks if target lies of the same side of (lineA <-> lineB) as lineC \nbool valid_point(vec2 lineA, vec2 lineB, vec2 lineC, vec2 target)\n{\n    bool status = false;\n    float m = (lineB.y - lineA.y) / (lineB.x - lineA.x);\n    if(lineB.x == lineA.x)\n    {\n        m = 9999.9f;\n    }\n    float c = lineB.y - (m * lineB.x);\n    float s1 = lineC.y- (m * lineC.x) - c;\n    float s2 = target.y- (m * target.x) - c;\n    if((s1 * s2) >= 0.0f)\n    {\n        status = true;\n    }\n    return status;\n}\n\n// Gets the Point Closest to X\nint get_closest_point(vec2 A, vec2 B, vec2 C, vec2 X)\n{\n    int index = -1;\n    float dA = distance(X, A);\n    float dB = distance(X, B);\n    float dC = distance(X, C);\n    if(dA <= dB && dA <= dC)\n    {\n        index = 0;\n    }\n    else if(dB <= dA && dB <= dC)\n    {\n        index = 1;\n    }\n    else if(dC <= dB && dC <= dA)\n    {\n        index = 2;\n    }\n    return index;\n}\n\n// Returns the Minimum of A, B and C\nfloat get_min(float A, float B, float C)\n{\n    return min(min(A, B), C);\n}\n\n\n// Returns the Maximum of A, B and C\nfloat get_max(float A, float B, float C)\n{\n    return max(max(A, B), C);\n}\n\n// Cycles the value of a in the cycle [minVal, maxVal]\nfloat cycle_float(float a, float minVal, float maxVal)\n{\n    float diff = maxVal - minVal;\n    if(a > maxVal)\n    {\n        float aDiff = a - maxVal;\n        float div = float(int(aDiff / diff));\n        a = minVal + (aDiff - (div * diff));\n    }\n    else if(a < minVal)\n    {\n        float aDiff = minVal - a;\n        float div = float(int(aDiff / diff));\n        a = maxVal - (aDiff - (div * diff));\n    }\n    return a;\n}\n\n// Returns the Interpolated color for the given f value\nvec3 get_time_color(float f, float minV, float maxV)\n{\n    return mix(basicColors[int(cycle_float(f, minV, maxV))],\n        basicColors[int(cycle_float(f + 1.0f, minV, maxV))],\n        f - float(int(f)));\n}\n\n\n// Gets the Color for the Pixel based on which triangle it is inside\nvec3 get_pixel_color(vec2 pos)\n{\n    // Set Default Colors\n    float offset = 2.0f * iTime;\n    if(offset >= 4.0f)\n    {\n        offset -= 4.0f;\n    }\n    #if RENDER_TRIANGLE\n    float size = 3.0f;\n    #else\n    float size = 4.0f;\n    #endif\n    vec3[4] colors = vec3[4](\n      get_time_color(offset, 0.0f, size),\n      get_time_color(offset + 1.0f, 0.0f, size),\n      get_time_color(offset + 2.0f, 0.0f, size),\n      get_time_color(offset + 3.0f, 0.0f, size)\n    );\n    vec3 col = bgColor;\n    for(int i = 0; (i+2) < indices.length(); i = (i + 3))\n    {\n        vec2 vertexA = vec2(vertices[indices[i]]);\n        vec2 vertexB = vec2(vertices[indices[i + 1]]);\n        vec2 vertexC = vec2(vertices[indices[i + 2]]);\n        bool validPoint = false;\n        validPoint = valid_point(vertexA, vertexB, vertexC, pos);\n        validPoint = (validPoint) ? (valid_point(vertexB, vertexC, vertexA, pos)) : validPoint;\n        validPoint = (validPoint) ? (valid_point(vertexC, vertexA, vertexB, pos)) : validPoint;\n        if(validPoint)\n        {\n#if !TO_INTERPOLATE\n            int index = get_closest_point(vertexA, vertexB, vertexC, pos);\n            col = colors[indices[i + index]];\n#else\n             float dA = distance(pos, vertexA);\n             float dB = distance(pos, vertexB);\n             float dC = distance(pos, vertexC);\n             float minVal = get_min(dA, dB, dC);\n             float maxVal = get_max(dA, dB, dC);\n             dA = 1.0f - smoothstep(minVal, maxVal, dA);\n             dB = 1.0f - smoothstep(minVal, maxVal, dB);\n             dC = 1.0f - smoothstep(minVal, maxVal, dC);\n             col = ((colors[indices[i]] * dA) + \n                   (colors[indices[i+1]] * dB) +\n                   (colors[indices[i+2]] * dC));\n#endif\n        }\n    }\n    return col;\n}\n\n// Gets the Pixel in Coordinate Space\nvec2 get_pos(vec2 fragCoord)\n{\n    // From (0, 0) to (1, 1)\n    vec2 pos = fragCoord / iResolution.xy;\n    // From (-1, -1) to (1, 1)\n    pos = (pos * 2.0f) - 1.0f;\n    // From (-Y, -Y) to (Y, Y)\n    pos *= yScaling;\n    // From (-X, -Y) to (X, Y)\n    pos.x *= (iResolution.x / iResolution.y);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get Pixel Position\n    vec2 pos = get_pos(fragCoord);\n    \n    // Pixel color\n    vec3 col = get_pixel_color(pos);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3GDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1020, 1093, 1160, 1160, 1511], [1513, 1544, 1599, 1599, 1922], [1924, 1961, 2003, 2003, 2035], [2038, 2075, 2117, 2117, 2149], [2151, 2206, 2262, 2262, 2629], [2631, 2687, 2741, 2741, 2893], [2896, 2965, 2997, 3023, 4752], [4754, 4792, 4822, 4851, 5103], [5105, 5105, 5162, 5188, 5342]], "test": "untested"}
{"id": "sdcGWB", "name": "Vines at Night 2", "author": "dr2", "description": "Vine covered pillars (upgraded visuals)", "tags": ["shadow", "vine"], "likes": 19, "viewed": 180, "published": "Public API", "date": "1630574181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Vines at Night 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // = 0/1 - optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_LIT 4\n\nvec3 ltPos[N_LIT + 1], ltAx;\nvec2 gId[2];\nfloat tCur, dstFar, hgSize[2], bRad, bDel, vLev, tileHt;\nint idObj;\nconst int idVin = 1, idCol = 2, idCap = 3, idFlr = 4;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, cRad, cLen, hp, br, tw, a, s, r;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId[0] * hgSize[0]);\n  cRad = 0.1;\n  cLen = 1.;\n  tw = 1.;\n  d = dMin;\n  vLev = 0.;\n  for (float k = float (VAR_ZERO); k < 5.; k ++) {\n    tw = - tw;\n    s = (k + 1.) / 5.;\n    hp = tw * (16. - 10. * s) + bRad - 0.5;\n    br = (0.015 - 0.01 * s + 0.005 * (bRad - 0.75)) * (1.5 - 0.3 * p.y / cLen);\n    q = p;\n    q.y -= (bDel + 1.3 * s) * hp;\n    a = 2. * pi * q.y / hp;\n    q.xz = Rot2D (q.xz, (5. - 3. * bDel) * pi * (sign (bRad - 0.5) * a +\n       (0.01 * bDel + 0.3 * s) * sin (3. * a)));\n    q.x -= cRad + br;\n    r = length (q.xz) - br;\n    if (r < d) vLev = s;\n    d = SmoothMin (d, r, 0.005);\n  }\n  d = max (d, abs (p.y - cLen) - cLen);\n  DMIN (idVin);\n  q = p;\n  q.y -= cLen;\n  d = PrCylDf (q.xzy, cRad, cLen);\n  DMIN (idCol);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 6.));\n  q.y -= 2. * cLen + 0.065 - 0.1 * cos (pi * length (q.xz) / (0.5 * sqrt3 * hgSize[0]));\n  q.z = abs (q.z) - 0.04;\n  d = PrRoundBox2Df (q.yz, vec2 (0.025, 0.01), 0.01);\n  DMIN (idCap);\n  q = p;\n  q.y = abs (q.y - cLen) - cLen + 0.03;\n  d = PrCylDf (q.xzy, cRad + 0.05, 0.03);\n  DMIN (idCap);\n  return 0.7 * dMin;\n}\n\nvoid SetObjConf ()\n{\n  vec2 fRand;\n  fRand = Hashv2v2 (gId[0] + 27.1);\n  bRad = 0.5 + 0.5 * fRand.x;\n  bDel = fRand.y;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize[0] / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize[0];\n  pM = HexToPix (PixToHex (ro.xz / hgSize[0]));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId[0] = PixToHex (p.xz / hgSize[0]);\n    if (gId[0] != gIdP) {\n      gIdP = gId[0];\n      SetObjConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0. || p.y > 3.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId[1] * hgSize[1]);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = q.y - tileHt + 0.01;\n  if (d < 0.05) d = SmoothMax (abs (q.x) - 0.495 * sqrt3 * hgSize[1], d, 0.01);\n  return d;\n}\n\nvoid SetFObjConf ()\n{\n  tileHt = 0.03 + 0.02 * Hashfv2 (gId[1] + 27.1);\n}\n\nfloat FObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize[1] / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize[1];\n  pM = HexToPix (PixToHex (ro.xz / hgSize[1]));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId[1] = PixToHex (p.xz / hgSize[1]);\n    if (gId[1] != gIdP) {\n      gIdP = gId[1];\n      SetFObjConf ();\n    }\n    d = FObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 FObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId[0] = PixToHex (p.xz / hgSize[0]);\n    if (gId[0] != gIdP) {\n      gIdP = gId[0];\n      SetObjConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.07 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, mDir, vn;\n  float mRad, bs, ts;\n  mDir = normalize (vec3 (0.6, 0.03, 1.));\n  mRad = 0.025;\n  col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - 1. + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) / mRad);\n      col += vec3 (1., 0.9, 0.5) * (0.07 + 0.93 * clamp (dot (vec3 (-0.77, 0.4, 0.5), vn) *\n         (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.));\n    }\n  } else col += StarPat (rd, 6.);\n  return col;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstLim)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  for (int k = VAR_ZERO; k < N_LIT; k ++) {\n    dirGlow = ltPos[k] - ro;\n    dstGlow = length (dirGlow);\n    brGlow += smoothstep (-0.1, 0.1, dstLim - dstGlow) *\n       pow (max (dot (rd, dirGlow), 0.) / dstGlow, 2048.) / dstGlow;\n  }\n  return clamp (brGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltVec, ltDir, roo, col, c, vn, q;\n  vec2 vf;\n  float dstObj, dstFObj, atten, a, sh, y;\n  bool isBg;\n  isBg = true;\n  vf = vec2 (0.);\n  roo = ro;\n  dstFObj = FObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstFObj < min (dstObj, dstFar)) {\n    dstObj = dstFObj;\n    idObj = idFlr;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj == idFlr) {\n      vn = FObjNf (ro);\n      col4 = vec4 (0.5, 0.5, 0.5, 0.1) * (0.7 + 0.3 * Hashfv2 (17.1 * gId[1])) *\n         (1. - 0.2 * Fbm2 (32. * ro.xz));\n      vf = vec2 (32., 2. * (1. - smoothstep (0.1, 0.3, dstObj / dstFar)));\n    } else {\n      vn = ObjNf (ro);\n      q = ro;\n      q.xz -= HexToPix (gId[0] * hgSize[0]);\n      if (idObj == idVin) {\n        col4 = vec4 (0.6, 0.7, 0.4, 0.2) * (0.4 + 0.6 * vLev);\n        vf = vec2 (64., 2. * (2. - vLev));\n      } else if (idObj == idCol) {\n        col4 = vec4 (0.6, 0.5, 0.4, 0.1);\n        a = mod (16. * (atan (q.z, - q.x) / (2. * pi)), 1.);\n        vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a * a));\n        y = mod (8. * q.y, 1.) - 0.5;\n        vn.y = 0.15 * pi * sign (y) * SmoothBump (0., 0.06, 0.02, 0.5 - abs (y));\n        vn = normalize (vn);\n        vf = vec2 (64., 0.5);\n      } else if (idObj == idCap) {\n        col4 = vec4 (0.5, 0.4, 0.3, 0.1);\n        if (vn.y > 0.99 && length (q.xz) < 0.14) col4 *= 0.6;\n        vf = vec2 (32., 1.);\n      }\n    }\n    isBg = false;\n  }\n  if (! isBg) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    ltVec = roo - ro;\n    atten = 0.1 + 0.9 * smoothstep (0.7, 0.85, dot (ltAx, - normalize (ltVec))) / (1. + 0.05 * dot (ltVec, ltVec));\n    ltVec += ltPos[N_LIT];\n    ltDir = normalize (ltVec);\n    sh = ObjSShadow (ro, ltDir, length (ltVec));\n    col = atten * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n    c = vec3 (0.);\n    for (int k = VAR_ZERO; k < N_LIT; k ++) {\n      ltVec = ltPos[k] - ro;\n      ltDir = normalize (ltVec);\n      atten = 1. / (1. + 0.2 * dot (ltVec, ltVec));\n      sh = ObjSShadow (ro, ltDir, length (ltVec));\n      c += atten * col4.rgb * sh * max (dot (vn, ltDir), 0.);\n    }\n    col = mix (col, c * vec3 (0.7, 0.7, 1.), smoothstep (-0.05, 0.05, Maxv3 (c) - Maxv3 (col)));\n  }\n  if (dstObj / dstFar > 0.6) col = mix (col, SkyCol (rd), smoothstep (0.6, 1., dstObj / dstFar));\n  col = mix (col, vec3 (0.4, 0.9, 1.), min (2.5 * GlowCol (roo, rd, min (dstObj, dstFar)), 1.));\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrackPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, asp, zmFac, sr, vel, tCyc, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize[0] = 1.;\n  hgSize[1] = 1./3.;\n  vel = 0.1;\n  p1 = 0.5 * (TrackPath (vel * tCur + 0.2) + TrackPath (vel * tCur + 0.4));\n  p2 = 0.5 * (TrackPath (vel * tCur - 0.2) + TrackPath (vel * tCur - 0.4));\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2 * (2. * SmoothBump (0.25, 0.75, 0.15, mod (0.07 * vel * tCur, 1.)) - 1.);\n  ro.y = 0.7;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = 0.04 * pi * sin (0.05 * 2. * pi * tCur);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.2;\n  dstFar = 20.;\n  ltPos[N_LIT] = 0.5 * vuMat * normalize (vec3 (cos (2. * pi * (0.022 * tCur)), 1., 0.));\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  for (int k = 0; k < N_LIT; k ++) {\n    s = float (k) / float (N_LIT);\n    ltPos[k] = vec3 (Rot2D (vec2 (0., 2.5 + float (k)), 0.5 * (0.7 + 0.3 * s) * pi *\n       sin (pi * (0.05 * (1. + 0.35 * s) * (tCur + 10.) + 2. * s))) + vec2 (0., ro.z),\n       0.8 + 0.3 * sin (2. * pi * (0.07 * tCur + s))).xzy;\n  }\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGWB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 1060, 1082, 1082, 2328], [2330, 2330, 2350, 2350, 2450], [2452, 2452, 2485, 2485, 3599], [3601, 3601, 3622, 3622, 3877], [3879, 3879, 3902, 3902, 4207], [4209, 4209, 4230, 4230, 4282], [4284, 4284, 4318, 4318, 5422], [5424, 5424, 5446, 5446, 5702], [5704, 5704, 5755, 5755, 6159], [6161, 6161, 6196, 6196, 6649], [6651, 6651, 6674, 6674, 7221], [7223, 7223, 7271, 7271, 7597], [7599, 7599, 7634, 7634, 10158], [10160, 10160, 10186, 10186, 10578], [10580, 10580, 10636, 10636, 12474], [12476, 12476, 12518, 12518, 12569], [12571, 12571, 12618, 12618, 12665], [12667, 12667, 12691, 12691, 12921], [12923, 12923, 12947, 12947, 13007], [13009, 13009, 13031, 13031, 13069], [13071, 13071, 13093, 13093, 13131], [13133, 13133, 13178, 13178, 13270], [13272, 13272, 13317, 13317, 13355], [13357, 13357, 13414, 13414, 13497], [13499, 13499, 13529, 13529, 13642], [13644, 13644, 13680, 13680, 13886], [13920, 13920, 13944, 13944, 14004], [14006, 14006, 14030, 14030, 14142], [14144, 14144, 14168, 14168, 14311], [14313, 14313, 14338, 14338, 14524], [14526, 14526, 14551, 14551, 14776], [14778, 14778, 14799, 14799, 14954], [14956, 14956, 14985, 14985, 15197], [15199, 15199, 15238, 15238, 15490]], "test": "untested"}
{"id": "sddSzM", "name": "From  a single Bezier Line", "author": "shyuriken", "description": "from  a single bezier line sdf\nusing a single bezier line.", "tags": ["bezierfold"], "likes": 8, "viewed": 79, "published": "Public", "date": "1632883456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Processed by 'GLSL Shader Shrinker' (Shrunk by 7,134 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n\n\n\nfloat det2(vec3 a, vec3 b, vec3 v) { return dot(v, cross(a, b)); }\n\nvec2 rot(vec2 p, float an) {\n\tfloat cc = cos(an),\n\t      ss = sin(an);\n\treturn vec2(cc * p.x - ss * p.y, ss * p.x + cc * p.y);\n}\n\nvec4 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2) {\n\tb0 -= p;\n\tb1 -= p;\n\tb2 -= p;\n\tvec3 g, q,\n\t     d21 = b2 - b1,\n\t     d10 = b1 - b0,\n\t     d20 = (b2 - b0) * .5,\n\t     n = normalize(cross(d10, d21));\n\tfloat f, t, k,\n\t      a = det2(b0, b2, n),\n\t      b = det2(b1, b0, n),\n\t      d = det2(b2, b1, n);\n\tg = b * d21 + d * d10 + a * d20;\n\tf = a * a * .25 - b * d;\n\tt = clamp(dot(cross(b0, n) + f * g / dot(g, g), d10 - d20) / (a + b + d), 0., 1.);\n\tq = mix(mix(b0, b1, t), mix(b1, b2, t), t);\n\tk = dot(q, n);\n\treturn vec4(length(q), t, -k, -sign(f) * length(q - n * k));\n}\n\nfloat pBezier(float n, vec3 pa, vec3 pb, vec3 pc, vec3 p) {\n\tvec4 res,\n\t     b = sdBezier(p, pa, pb, pc);\n\tvec2 tmp,\n\t     q = rot(b.zw, 0.);\n\tres = vec4(99, q, b.y);\n\ttmp = q;\n\tres.x = length(tmp) - n;\n\tres.yz = tmp;\n\treturn res.x;\n}\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mRepInf(vec3 cell_size, vec3 p) { return p - cell_size * round(p * vec3(greaterThan(cell_size, vec3(0))) / cell_size); }\n\nfloat sabs(float p) { return sqrt(p * p + 1e-2); }\n\nvec3 mFold(vec3 sw, vec3 t, vec3 p) {\n\tfloat h, a,\n\t      n = sw.x,\n\t      r = sw.y;\n\tbool s = sw.z > 0.;\n\th = floor(log2(n));\n\ta = 6.2832 * exp2(h) / n;\n\tfor (int i = 0; i < int(h) + 2; i++) {\n\t\tvec2 v = normalize(vec2(-cos(a), sin(a)));\n\t\tfloat g = dot(p.xz, v);\n\t\tp.xz -= (g - ((r > 0.) ? sabs(g) : abs(g))) * v;\n\t\ta *= .5;\n\t}\n\n\tp.xz -= clamp(p.xz, s ? -t.xz : t.xz, t.xz);\n\treturn p;\n}\n\nfloat sdf(vec3 p0) {\n\tfloat d1;\n\t{\n\t\tvec3 p1 = mRepInf(vec3(5.4, -1, 5.5), p0);\n\t\t{\n\t\t\tvec3 p2 = mFold(vec3(24, 1, 1), vec3(0, 0, 1), p1);\n\t\t\t{ d1 = pBezier(.1,  vec3(-1.5,1.1*sin(iTime), 0.), vec3(.5, cos(iTime)*0.1, 0), vec3(0, -1.5, 0), mRotation(mat3(-.017452, 0, .999848, 0, 1, 0, -.999848, 0, -.017452), p2)); }\n\t\t}\n\t}\n\treturn d1;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (h < .001) break;\n\t\tt += h;\n\t\tif (t > 80.) break;\n\t}\n\n\tif (t > 80.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 2., 3. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(7, .3, 5) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.8, .3, .2) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddSzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 164, 164, 194], [196, 196, 224, 224, 324], [326, 326, 376, 376, 895], [897, 897, 956, 956, 1131], [1133, 1133, 1176, 1176, 1203], [1205, 1205, 1243, 1243, 1330], [1332, 1332, 1353, 1353, 1382], [1384, 1384, 1421, 1421, 1773], [1775, 1775, 1795, 1795, 2113], [2115, 2115, 2142, 2142, 2307], [2309, 2309, 2350, 2350, 2524], [2526, 2526, 2559, 2559, 2750], [2752, 2752, 2778, 2778, 2913], [2915, 2915, 2967, 2967, 4084]], "test": "untested"}
{"id": "sddSzr", "name": "Chair", "author": "JunYaoLiang", "description": "First try to use distancefield.Thanks to Inigo Quilez for sharing knowledge and shaders.I know the project is simple and will fill in the details later.", "tags": ["raymarching", "sdf"], "likes": 2, "viewed": 30, "published": "Public", "date": "1632530610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Games101 Homework   Final_Project\n// By JunYao Liang\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.5*ra+rb, 1.0*abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat legs(in vec3 pos)\n{\n    float z=0.3;\n    float y=-0.7;\n    float x=-0.5;\n    float xt=0.2;\n    float yt=0.65;\n    float zt=0.2;\n    vec3 ta=vec3(x+xt,y+yt,z-zt);\n    vec3 tb=vec3(x-xt,y-yt,z+zt);\n    \n    vec3 ba=vec3(0.0+x,y+0.5*yt,z);\n    vec3 bb=vec3(0.0+x,y-0.5*yt,z);\n    \n\n    float oblique=sdCappedCylinder(pos,ta,tb,0.15);\n    float straight=sdCappedCylinder(pos,ba,bb,0.7);\n    float leg=max(oblique,straight);\n    \n    pos.x=-pos.x;\n    oblique=sdCappedCylinder(pos,ta,tb,0.15);\n    straight=sdCappedCylinder(pos,ba,bb,0.7);\n    leg=min(leg,max(oblique,straight));\n    \n    \n    pos.z=-pos.z;\n    oblique=sdCappedCylinder(pos,ta,tb,0.15);\n    straight=sdCappedCylinder(pos,ba,bb,0.7);\n    leg=min(leg,max(oblique,straight));\n    \n    pos.x=-pos.x;\n    oblique=sdCappedCylinder(pos,ta,tb,0.15);\n    straight=sdCappedCylinder(pos,ba,bb,0.7);\n    leg=min(leg,max(oblique,straight));\n    \n    return leg;\n}\n\n\nfloat map( in vec3 pos )\n{\n    vec3 pfoot=pos-vec3(0.0,0.0,-1.5);\n    vec3 pCus=pos-vec3(0.0,0.0,-1.5);\n    \n    float foots=legs(pfoot*2.0)*0.5;\n    float cusion=sdRoundedCylinder(pCus*2.0,0.35,0.35,0.3)*0.5;\n    float chair=sminCubic(foots,cusion,0.1);\n    \n    \n    \n    return chair;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.0,0.8+0.5*sin(an));\n    //vec3 ro = vec3( 0.0, 0.0,1.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n        \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddSzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 114, 114, 450], [452, 452, 516, 516, 637], [638, 638, 684, 684, 770], [772, 772, 797, 797, 1690], [1693, 1693, 1719, 1719, 1982], [1985, 1985, 2017, 2017, 2256], [2276, 2276, 2333, 2358, 3930]], "test": "untested"}
{"id": "sdG3DK", "name": "Voxel Panda", "author": "iuryBorgesRodrigues", "description": "Voxel Panda", "tags": ["voxel", "panda"], "likes": 7, "viewed": 50, "published": "Public", "date": "1632182835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}    \n\nvec2 scene(in vec3 p) {\n\n    vec3 pe=p;\n    p/=vec3(1.);\n    vec3 p1=p;\n    p1.z=abs(p1.z);\n    \n    vec3 p2=p;\n    p2.z=abs(p2.z);\n   \n   \n    float d1 =sdBox(p,vec3(0.5));\n    float d2 = sdBox(p1+vec3(0.5,0.4,-0.34),vec3(0.15,0.1,0.15));\n    float d3 = sdBox(p2+vec3(-0.25,0.2,-0.55),vec3(0.2,0.3,0.05));\n    float d4 = sdBox(p1+vec3(0.38,-0.55,-0.36),vec3(0.1,0.05,0.08));\n    float d5 = sdBox(p1+vec3(0.38,-0.55,-0.42),vec3(0.05,0.1,0.08));\n    float d6 = sdBox(p1+vec3(0.38,-0.2,-0.3),vec3(0.15,0.1,0.15));\n    float d7 = sdBox(p1+vec3(0.36,-0.2,-0.3),vec3(0.15,0.1,0.15));\n    float d8 = sdBox(p1+vec3(0.5,-0.2,-0.3),vec3(0.025,0.025,0.025));\n    float d9 = sdBox(p1+vec3(0.49,-0.2,-0.3),vec3(0.025,0.025,0.025));\n    float d10 =sdBox(p+vec3(0.5,-0.0,-0.0),vec3(0.05));\n    float d11 =sdBox(p+vec3(0.5,0.05,-0.0),vec3(0.05,0.05,0.1));\n    \n    d1=max(d1,-d6);\n    d1=max(d1,-d8);\n    \n    vec2 scene = opUnion(\n          vec2(sdPlane(pe+vec3(0.0,0.8,0.0)), 1.0),\n          vec2(d1, 0.2)\n    );\n    \n    \n    scene = opUnion(scene,vec2(d2*0.3,0.1));\n    scene = opUnion(scene,vec2(d3*0.3,0.1));\n    scene = opUnion(scene,vec2(d4*0.3,0.1));\n    scene = opUnion(scene,vec2(d7*0.3,0.1));\n    scene = opUnion(scene,vec2(d9*0.3,0.2));\n    scene = opUnion(scene,vec2(d10*0.3,0.1));\n    scene = opUnion(scene,vec2(d11*0.3,0.2));\n    \n    \n    \n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.002;\n    \n    for (int i = 0; i < 10000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.0001 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material ==1.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material == 0.2) {\n            // Metallic objects\n            baseColor = vec3(1.0);\n            roughness = 0.9;\n        }else if (material == 0.1) {\n            // Metallic objects\n            baseColor = vec3(0.0);\n            roughness = 0.9;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\nconst int AA=2;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\nvec3 tot = vec3(0.0);\n\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n     vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; \n\t\n\t\n\n    // Normalized coordinates\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    // Aspect ratio\n   // p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 1.0, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n    \n    tot += color;\n    \n    }\n\n    tot /= float(AA*AA);\n\t\n\tfragColor =  vec4(tot,1.0) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdG3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 256, 282, 282, 300], [302, 302, 338, 338, 366], [368, 368, 405, 405, 463], [465, 465, 497, 497, 533], [534, 534, 565, 565, 652], [658, 658, 681, 681, 2019], [2021, 2199, 2248, 2248, 2542], [2544, 2544, 2594, 2594, 2920], [2922, 2922, 2953, 2953, 3273], [3275, 3446, 3467, 3467, 3515], [3517, 3517, 3578, 3663, 3860], [3862, 3862, 3935, 4027, 4227], [4229, 4229, 4271, 4351, 4405], [4407, 4407, 4456, 4456, 4504], [4506, 4506, 4579, 4636, 4849], [4851, 4851, 4871, 4871, 4894], [4896, 5080, 5130, 5214, 5572], [5574, 5574, 5629, 5686, 5946], [5948, 6150, 6183, 6239, 6425], [6427, 6427, 6466, 6466, 6509], [6511, 6687, 6755, 6775, 9811], [9813, 9999, 10063, 10063, 10315], [10333, 10333, 10388, 10388, 11428]], "test": "untested"}
{"id": "sdG3WV", "name": "Another spiraly flower", "author": "rah", "description": "just playing around", "tags": ["flower"], "likes": 5, "viewed": 65, "published": "Public", "date": "1632194964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nvec4 coolMistake1(out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 bg = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\tvec4 red = vec4(rgb(225.0, 50.0, 70.0), 1.0);\n    vec4 color = red;\n    \n    // Get point normalized from center of the screen\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy);\n    \n    // angle of the point\n    float a = atan(p.x,p.y);\n    \n    // scale the radius\n    float r = length(p) * 0.75f;\n    \n    // interesting discontinuity\n    float x = cos(a * 10.0f);\n    //x += sin(a * 10.0f) * 0.5f;\n        \n    radius -= x * 40.0f * sin(iTime);\n\n\t\n\t// Circle\n\tvec4 layer2 = circle(uv, center, radius, vec3(color));\n    \n    radius -= 40.0f;\n    vec4 layer3= circle(uv, center, radius, vec3(bg));\n    \n    return mix(bg, layer2, layer2.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 bg = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\tvec4 red = vec4(rgb(160.0, 0.0, 70.0), 1.0);\n    vec4 blue = vec4(rgb(125.0, 200.0, 250.0), 1.0);\n    \n    // Get point normalized from center of the screen\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // scale the radius\n    float r = length(p) * 0.5f;\n    \n    // Spiraling animation\n\n    // Create a \"bump\" signal based on distance from origin (sin pattern radiating out)\n    float rotationFactor = cos(r * 6.0 + 1.0);\n    // Intensify the bump amplitude the further you are from center, pow makes amplitude increase logrithmic\n    rotationFactor *= pow(r, 0.5) ;\n    // Oscillate the direction of the spin\n    rotationFactor *= sin(iTime);\n    // make it animate over time (spin!)\n    rotationFactor += iTime;\n\n    // rotate p around the origin using our spinning animation\n    p = rotatePoint2d(p, vec2(0.0, 0.0), rotationFactor);\n    \n    // angle of the rotated point\n    float a = atan(p.x,p.y);\n    \n    // create an interesting discontinuity\n    float bumpFactor = bias(cos(a * 10.0), 0.9);\n    // add an extra bumpy factor to exaggerate the points\n    bumpFactor += sin(a * 10.0);\n    \n    // make bump factor amplitude oscillate\n    float bumpFactorScale = sin(iTime) * 30.0;\n    // Compute the radius\n    radius -= bumpFactor * bumpFactorScale;\n\t\n\t// Color red or blue based on the positive or negative bump contribution\n    vec4 color = mix(red, blue, pow(1.0-(bumpFactor * 0.5), 1.0));\n\tvec4 layer2 = circle(uv, center, radius, vec3(color));\n    \n    fragColor = mix(bg, layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdG3WV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 113, 150, 150, 199], [201, 264, 325, 325, 429], [431, 491, 546, 546, 820], [823, 823, 853, 853, 907], [909, 909, 968, 968, 1788], [1790, 1790, 1847, 1847, 3556]], "test": "untested"}
{"id": "sdG3zw", "name": "palette washing spirals", "author": "HaleyHalcyon", "description": "a", "tags": ["perlinnoise"], "likes": 1, "viewed": 67, "published": "Public", "date": "1631242320", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\nfloat perlin(vec2 uv, float offset) {\n  vec2 i = floor(uv);\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 2.5);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  float dist = log(uv.x * uv.x + uv.y * uv.y);\n  float angle = atan(uv.y, uv.x) / TAU;\n\n  float noise = perlin(uv * 10.5, time);\n  noise += 0.5 * perlin(uv * 34.0, -2. * time);\n  noise *= max(0.0, dist * 0.2 + 2.);\n  \n  float dark = smoothstep(\n      0.0, 0.4, (0.2 + length(uv)) * sin(TAU * 2. * time + 0.6 * dist) + 0.3 * noise\n  );\n  \n  const vec3 colBaseL = vec3(92, 128, 1) / 255.;\n  const vec3 colSp1L = vec3(124, 181, 24) / 255.;\n  const vec3 colSp2L = vec3(251, 176, 45) / 255.;\n  \n  const vec3 colBaseD = vec3(50, 13, 109) / 255.;\n  const vec3 colSp1D = vec3(0, 36, 0) / 255.;\n  const vec3 colSp2D = vec3(251, 97, 7) / 255.;\n  \n  vec3 colBase = mix(colBaseL, colBaseD, dark);\n  vec3 colSp1  = mix(colSp1L,  colSp1D, dark);\n  vec3 colSp2  = mix(colSp2L,  colSp2D, dark);\n  \n  float spiral1 = step(fract(0.2 * noise + 2. * angle + 0.5 * dist + time), 0.4);\n  float spiral2 = step(fract(0.2 * noise + 2. * angle + 0.5 * dist + 2. * time + 0.5), 0.2);\n  \n  vec3 col = mix(\n      mix(\n          colBase, colSp1, spiral1\n      ), colSp2, spiral2\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdG3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 98, 117, 117, 274], [275, 314, 333, 333, 384], [385, 402, 434, 434, 607], [608, 628, 665, 665, 1085], [1087, 1087, 1144, 1144, 2457]], "test": "untested"}
{"id": "sdG3zy", "name": "lazy rainbow bubbles", "author": "abjectadvect", "description": "rainbow bubbles", "tags": ["art"], "likes": 2, "viewed": 80, "published": "Public", "date": "1631737080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float TAU = PI*2.;\nconst int S_BUBBLES = 1;\nconst float EPS = 0.0001;\n\nfloat mag(vec3 v) { return sqrt(dot(v, v)); }\n\n\nfloat line(vec3 p, vec3 q, vec3 d, float width) {\n    return mag(p - (q + d*dot(p-q, d)/dot(d,d))) - width;\n}\n\nfloat sphere(vec3 p, vec3 center, float radius) {\n    return mag(p - center) - radius;\n}\n\nvec3 twist(vec3 p, vec3 center, float dist) {\n    vec3 v = p - center;\n    \n    vec2 polar = vec2(sqrt(dot(v.xy, v.xy)), atan(v.y, v.x));\n    float rad = polar.x;\n    float theta = polar.y;\n    \n    \n    float r = 2. * PI * polar.x / dist;\n    \n    float angle = theta + r;\n    \n    v = vec3(rad * cos(angle), rad * sin(angle), v.z);\n \n    return v + center;\n}\n\nfloat unionSDF(float a, float b) { return min(a, b); }\n\nfloat lerps(float a, float b, float s) { return s * b + (1.0 - s) * a; }\nvec3 lerpv(vec3 a, vec3 b, float s) { return s * b + (1.0 - s) * a; }\n\nfloat bubbles(vec3 p) {\n    float d = 1000.;\n    int n = 100;\n    for (int i = 0; i < n; i++) {\n        vec3 displace = vec3(\n            (float(i)-(float(n)/2.-0.5)) / float(n) + sin(iTime*(2.*cos(float(i*29))) + float(i)*91.)*0.05*cos(float(i)), \n            -mod((iTime/19. * (0.1 + abs(sin(float(i)))) + abs(cos(float(i) * 1337.))), 1.0) + 0.5, \n            0.\n        );\n        float s = sphere(p + displace, vec3(0., 0., 0.), \n            lerps(0.01, 0.03, max(0., abs(sin(float(i)*7. + iTime/7.)) - p.y)));\n        if (s < d) {\n            d = s;\n        }\n    }\n    return d;\n}\n\nfloat sceneSDF(vec3 p, int part) {\n    if (part == S_BUBBLES) return bubbles(p);\n    return 1000.;\n}\n\nvec3 sceneNormal(vec3 p, int part) {\n    vec3 x0 = p - vec3(EPS, 0., 0.);\n    vec3 x1 = p + vec3(EPS, 0., 0.);\n    vec3 y0 = p - vec3(0., EPS, 0.);\n    vec3 y1 = p + vec3(0., EPS, 0.);\n    vec3 z0 = p - vec3(0., 0., EPS);\n    vec3 z1 = p + vec3(0., 0., EPS);\n    vec3 n = vec3(\n        sceneSDF(x1, part) - sceneSDF(x0, part),\n        sceneSDF(y1, part) - sceneSDF(y0, part),\n        sceneSDF(z1, part) - sceneSDF(z0, part)\n    );\n    return -n / mag(n);\n}\n\n\nvec4 raymarch(vec3 eye, int part) {\n    float sd = 1000.;\n    vec3 p = eye;\n    vec3 dir = vec3(0., 0., 1.);\n    for (int i = 0; i < 100; i++) {\n       float d = sceneSDF(p, part);\n       if (d > sd) break;\n       \n       sd = d;\n       if (d <= EPS) break;\n       p = p + sd * dir;\n    }\n    return vec4(p.xyz, sd);\n}\n\nvec3 hsv2rgb(vec3 hsv) {\n    float h = hsv.x;\n    float s = hsv.y;\n    float v = hsv.z;\n    float c = v * s;\n    float x = c * (1. - abs(mod(h/60., 2.) - 1.));\n    float m = v - c;\n    vec3 mv = vec3(m, m, m);\n    if (h < 60.) return vec3(c, x, 0.) + mv;\n    if (h < 120.) return vec3(x, c, 0.) + mv;\n    if (h < 180.) return vec3(0., c, x) + mv;\n    if (h < 240.) return vec3(0., x, c) + mv;\n    if (h < 300.) return vec3(x, 0., c) + mv;\n    return vec3(c, 0., x) + mv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.xx;\n    \n    vec3 eye = vec3(uv.x, uv.y, -10.);\n    \n    \n    float value = 0.3;\n    vec4 bubbles = raymarch(eye, S_BUBBLES);\n    if (bubbles.w <= EPS) {\n        vec3 normal = sceneNormal(bubbles.xyz, S_BUBBLES);\n        vec3 light = vec3(sin(iTime), cos(iTime), -3.);\n        vec3 L = bubbles.xyz - light;\n        vec3 V = (eye - bubbles.xyz) / mag(eye - bubbles.xyz);\n        vec3 R = reflect(L, normal) / mag(L);\n        value = max(value, max(0., dot(normal, L)/mag(L)) + pow(max(0., dot(R, V)), 50.));\n    }\n    \n    vec3 col = hsv2rgb(vec3((uv.x + 0.5) * 360., 1., value));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdG3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 151], [154, 154, 203, 203, 263], [265, 265, 314, 314, 353], [355, 355, 400, 400, 715], [717, 717, 751, 751, 771], [773, 773, 813, 813, 845], [846, 846, 883, 883, 915], [917, 917, 940, 940, 1503], [1505, 1505, 1539, 1539, 1605], [1607, 1607, 1643, 1643, 2063], [2066, 2066, 2101, 2101, 2384], [2386, 2386, 2410, 2410, 2858], [2860, 2860, 2917, 2967, 3663]], "test": "untested"}
{"id": "sdGGDV", "name": "Right Angled Hexagons", "author": "stevejtrettel", "description": "Parameterizing a 3-dimensional subset of the Teichmuller space of the genus 2 surface (the surfaces with zero twist parameter, which are tiled by four congruent right angled hexagons).", "tags": ["hyperbolic"], "likes": 4, "viewed": 135, "published": "Public", "date": "1632246708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A tiling of the hyperbolic plane by right angled hexagons determines a genus 2 surface\n//doubling such a hexagon along a triplet of alternating sides gives a pair of pants,\n//and doubling that pair of pants across its boundary gives a genus 2 surface\n\n\n\nfloat PI=3.14159;\n\n//------------------------------------------\n//Define hyperbolic half spaces, reflections\n//------------------------------------------\n\n//vertical line to reflect in\n//side=+1 means the half space contains points to the right, -1 to the left\nstruct Line{\n    float pos;\n    float side;\n};\n\n\n//semicircle centered on real line to reflect in\n//side =+1 means the halfspace contains points below, -1 means above\nstruct Circle{\n    float center;\n    float radius;\n    float side;\n};\n\n\n\n//reflection in vertical line defining a half space\n//this is done by conjugating reflection in the line x=0\n//by the translation taking this line there\nvoid invert(inout vec2 p, Line line){\n\n    p.x -= line.pos;\n    p.x *= -1.;\n    p.x += line.pos;\n\n}\n\n//reflection in a circle defining a half space\n//this is done by conjugating inversion in the unit circle\n//with a similarity transformation taking the given circle to the unit circle\nvoid invert(inout vec2 p, Circle circle){\n\n    p.x -= circle.center;\n    p /= circle.radius;\n    p /= dot(p,p);\n    p *= circle.radius;\n    p.x += circle.center;\n\n}\n\n//check if inside a half space bounded by a line:\nbool inside(vec2 p, Line line){\n    if(line.side>0.){//check if we are on the right side\n        return p.x>line.pos;\n    }\n    else{//check if we are on the left side\n        return p.x<line.pos;\n    }\n}\n\n//check if inside a half space bounded by a circle\nbool inside(vec2 p, Circle circle){\n    if(circle.side>0.){//check if we are inside the semicircle\n        return length(p-vec2(circle.center,0))<circle.radius;\n    }\n    else{//check if we are outside the semicircle\n        return length(p-vec2(circle.center,0))>circle.radius;\n    }\n}\n\n\n//check if we are inside\nvoid reflectIn(inout vec2 p, Circle circle, inout float invCount){\n    if(!inside(p,circle)){\n        invert(p,circle);\n        invCount+=1.;\n    }\n}\n\nvoid reflectIn(inout vec2 p, Line line, inout float invCount){\n    if(!inside(p,line)){\n        invert(p,line);\n        invCount+=1.;\n    }\n}\n\n\n\n//------------------------------------------\n//some hyperbolic geometry\n//------------------------------------------\n\n//do a rotation in the upper half plane of angle theta about i\nfloat rot(float x, float theta){\n    float c=cos(theta/2.);\n    float s=sin(theta/2.);\n    mat2 mat=mat2(c,s,-s,c);\n    vec2 p=mat*vec2(x,1.);\n    return p.x/p.y;\n}\n\n\n//the above is only a rotational mobius transformation applied to the real line\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 mobiusTransf(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n    float Z2=length(z)*length(z);\n    float term1=c*z.x+d;\n    float term2=c*z.y;\n    float denom=term1*term1+term2*term2;\n\n    term1=a*c*Z2+b*d+(a*d+b*c)*z.x;\n    term2=(a*d-b*c)*z.y;\n\n    return vec2(term1,term2)/denom;\n}\n\n\n//measure the distance to a vertical line geodesic\nfloat dist(vec2 p, Line line){\n    //translate line to oriign\n    p.x-=line.pos;\n    float secTheta=length(p)/abs(p.y);\n    return acosh(secTheta);\n}\n\n//measure the distance to a circle geodesic\nfloat dist(vec2 p, Circle circle){\n    float end1=circle.center-circle.radius;\n    float end2=circle.center+circle.radius;\n    vec4 mob=vec4(1.,-end1,1.,-end2);\n\n    //do the mobius transformation making this segment vertical:\n    vec2 z=mobiusTransf(mob, p);\n\n    //now measure the distance to this vertical line\n    return dist(z,Line(0.,1.));\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n//Give names to the sides of the shape\nCircle C0,C1,C2,L12,L20;\nLine L01;\n\n//function that defines these sides\n//a right angled hexagon is determined by three moduli\n//here we list them as a,b,h: these directly specify the \"C-Circles\"\n//then we build the \"L-Circles\" from them\nvoid setUpFD(float a, float b, float h){\n\n    C0=Circle(0.,1.,1.);\n    C1=Circle(0.,a,-1.);\n    C2=Circle(h,b,-1.);\n\n    //the radius of the short circles depends on these as calculated:\n    //Lij is the circle intersecting Ci and Cj orthogonally\n\n    float u=(h*h+a*a-b*b)/(2.*h);\n    float r=sqrt(u*u-a*a);\n    float v=(h*h+1.-b*b)/(2.*h);\n    float R=sqrt(v*v-1.);\n\n    L01=Line(0.,1.);\n    L12=Circle(u,r,-1.);\n    L20=Circle(v,R,-1.);\n}\n\n\n//takes in 3 floats all in (0,1) and puts them into an acceptable triple (a,b,h)\n//rules: x is in (0,1): this just becomes a.\n//given a, the value of h is constrained to lie in (a,1)\n//thus y is sent to h=a+(1-a)y\n//given a,h, the radius b is constrained so that the circle endpoints h-b, h+b lie in the\n//interval (a,1)\n//thus h-b>a, and h+b<1.  Re-arranging, b<h-a, and b<1-h.  Thus b<min(h-a,1-h)\n//so we send z to b=min(h-a,1-h)z\nvec3 parametersFD(float x, float y, float z){\n\n    float a=x;\n    float h=a+(1.-a)*y;\n    float b=min(h-a,1.-h)*z;\n\n    return vec3(a,b,h);\n}\n\n\n//measuring the distance tot edes which are exterior to the entire surface fundamental domain\n//not drawing the internal edges that we reflect in from the hexagon tile\nfloat edgeDistance(vec2 p){\n\n    float d1=dist(p,C1);\n    float d12=dist(p,L12);\n    float d2=dist(p,C2);\n    float d20=dist(p,L20);\n    float d01=dist(p,L01);\n\n    //this is the minimum distance away from any edge that we care about\n    float d=min(min(d1,d12),min(d2,d20));\n\n    return d;\n}\n\n\n\n//------------------------------------------\n//reflect points into fundamental domain\n//------------------------------------------\n\n\n//this function takes in a point p, and looks at each side of the fundamental domain\n//if p is not within the half space defined by that side, we reflect it\n//if p is already in that half space, we leave it alone\nvoid reflectInFD(inout vec2 p,inout float invCount){\n\n    reflectIn(p,C0,invCount);\n    reflectIn(p,C1,invCount);\n    reflectIn(p,C2,invCount);\n    reflectIn(p,L01,invCount);\n    reflectIn(p,L12,invCount);\n    reflectIn(p,L20,invCount);\n\n}\n\n\n//while the program's reflection group algorithm will use just the right angled hexagon\n//throughout most computation, we will at times want to draw a fundamental domain for the surface\n//which consists of 4 hexagons.\n//this function reflects in the two internal walls, to help with that\nvoid reflectInternally(inout vec2 p){\n\n    if(!inside(p,C0)){\n        invert(p,C0);\n    }\n\n    if(!inside(p,L01)){\n        invert(p,L01);\n    }\n}\n\n\n\n//this function checks if p is inside our fundamental domain or not\nbool insideFD(vec2 p){\n    bool within=inside(p,C0);\n    within=within&&inside(p,C1);\n    within=within&&inside(p,C2);\n    within=within&&inside(p,L01);\n    within=within&&inside(p,L12);\n    within=within&&inside(p,L20);\n    return within;\n}\n\n\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec2 p,inout float invCount){\n\n\n    for(int i=0;i<25;i++){\n\n        reflectInFD(p,invCount);\n\n        if(insideFD(p)){\n            return;\n        }\n\n    }\n\n    invCount=-1.;\n\n}\n\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n\n//just packing the sinusoidal oscillation which oscillates between a and b into its own function\nfloat osc(float a,float b, float t){\n    return abs(b-a)/2.*(1.+sin(t))+a;\n}\n\n\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n\n    //rescale this how you like\n    uv = 4.*vec2(1,iResolution.y/iResolution.x)*uv;\n\n    return uv;\n}\n\n\n//starting from Poincare Disk:\nvec2 toUHP(vec2 uv){\n\n    //move to half plane\n    float Re = 2.*uv.x;\n    float Im = 1.-dot(uv,uv);\n    vec2 temp=vec2(1.-uv.y,uv.x);\n    float Scale = dot(temp,temp);\n    vec2 p = 1./Scale*vec2(Re,Im);\n\n    return p;\n\n}\n\n\n//this function takes coordinates in poincare disk,\n//uses mouse position to make a mobius transformation\nvec2 mouseTransform(vec2 z){\n    if (iMouse.x > 10.0) {\n        vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        // Unit disc inversion\n        m /= dot(m,m);\n        z -= m;\n        float k = (dot(m,m)-1.0)/dot(z,z);\n        z *= k;\n        z += m;\n    }\n    return z;\n}\n\n\n//transformations done at setup in the Poincare Disk model\nvec2 transformPD(vec2 z){\n\n    if (iMouse.z > 0.) {\n        z=mouseTransform(z);\n    }\n    else{\n        //do a rotation slowly\n        float c=cos(iTime/6.);\n        float s=sin(iTime/6.);\n        z=mat2(c,s,-s,c)*z;\n    }\n\n    return z;\n}\n\n\n\n//transformations done in setup to the Upper Half Plane Model\nvec2 transformUHP(vec2 p){\n\n    //if there is no mouse press\n    if (iMouse.z < 0.) {\n        //apply a hyperbolic\n        p*=osc(0.4,0.8,iTime/2.);\n\n        //reflect up to the upper half plane:\n        p.y=abs(p.y);\n    }\n\n    return p;\n\n}\n\n\n\n//------------------------------------------\n//assigning color to points in the fundamental domain\n//------------------------------------------\n\n\n//get the color of the edges\nvec3 edgeColor(vec2 p, bool insideDisk){\n\n    if(insideDisk) return vec3(170,210,255)/255.;\n    if(!insideDisk) return 0.35*vec3(140,60,40)/255.;\n\n    return vec3(0.);\n}\n\n\n\n//get the color for the interior tiles\nvec3 tilingColor(float invCount,bool insideDisk){\n\n    vec3 tilingColor;\n\n    if(invCount<0.){\n        //if we didnt get into the fundamental domain\n        //color it black//BETTER: A DEBUG COLOR\n        tilingColor=vec3(0,0,0);\n    }\n\n    else {\n        //we did get into the fundamental domain:\n        float parity=mod(invCount, 2.);\n\n        if (insideDisk){\n            if (parity==0.){\n                tilingColor=vec3(116, 161, 250)/255.;\n            }\n            else { //parity=1.\n                tilingColor=vec3(120, 170, 250)/255.;\n            }\n        }\n\n        //if we are outside, make complementary colored.\n        else {\n            if (parity==0.){\n                tilingColor=0.25*vec3(230,129,56)/255.;\n            }\n            else { //parity=1.\n                tilingColor=0.25*vec3(230,99,90)/255.;\n            }\n        }\n    }\n\n    return tilingColor;\n\n}\n\n\n\n//get a color for a point in the fundamental domain\nvec3 getColor(vec2 p,float invCount,bool insideDisk,bool insideDomain){\n\n    bool onEdge=(edgeDistance(p)<0.05);\n\n    if(onEdge){\n        return edgeColor(p, insideDisk);\n    }\n    else if(insideDomain){\n        return tilingColor(invCount,insideDisk)+vec3(0.3,0,0);\n    }\n    else{\n        return tilingColor(invCount,insideDisk);\n    }\n\n    return vec3(0.);\n}\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n\n    //keep track of if we start outside the poincare disk\n    bool insideDisk=(length(uv)<1.);\n\n    //apply a mobius transformation from mouse position\n    //this is done in disk model still\n    uv=transformPD(uv);\n\n    //map to upper half plane for computation:\n    vec2 p = toUHP(uv);\n\n    //apply some transformations in the UHP model\n    p=transformUHP(p);\n\n    //setup the fundamental domain we are working with\n    float x=osc(0.1,0.9,iTime/3.);\n    float y=osc(0.2,0.8,iTime);\n    float z=osc(0.2,0.8,iTime/2.);\n    vec3 params=parametersFD(x,y,z);\n    setUpFD(params.x,params.y,params.z);\n\n\n    //before changing p around, separately make a copy to color the original fundamental domain\n    vec2 q=p;\n    //reflect in the two internal walls: this gets one full copy of the fundamnetal domain\n    reflectInternally(q);\n    bool insideDomain=insideFD(q)&&insideDisk&&(edgeDistance(q)>0.05);\n\n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n\n    // color the pixel based on this\n    vec3 col=getColor(p,invCount,insideDisk,insideDomain);\n\n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[757, 910, 947, 947, 1009], [1011, 1195, 1236, 1236, 1359], [1361, 1411, 1442, 1442, 1615], [1617, 1668, 1703, 1703, 1954], [1957, 1982, 2048, 2048, 2131], [2133, 2133, 2195, 2195, 2274], [2396, 2459, 2491, 2491, 2623], [2626, 2833, 2869, 2869, 3169], [3172, 3223, 3253, 3284, 3372], [3374, 3418, 3452, 3452, 3765], [3969, 4171, 4211, 4211, 4612], [4615, 5049, 5094, 5094, 5190], [5193, 5361, 5388, 5388, 5653], [5790, 6003, 6055, 6055, 6242], [6245, 6533, 6570, 6570, 6678], [6682, 6750, 6772, 6772, 6991], [6996, 7177, 7226, 7226, 7374], [7517, 7614, 7650, 7650, 7690], [7694, 7822, 7863, 7923, 8077], [8080, 8111, 8131, 8157, 8332], [8335, 8441, 8469, 8469, 8726], [8729, 8788, 8813, 8813, 9028], [9032, 9094, 9120, 9154, 9335], [9485, 9514, 9554, 9554, 9683], [9687, 9726, 9775, 9775, 10611], [10615, 10667, 10738, 10738, 11028], [11031, 11146, 11203, 11227, 12391]], "test": "untested"}
{"id": "sdGGW3", "name": "[pastel]", "author": "vantaxyz", "description": "edited version of the starting shader ", "tags": ["color"], "likes": 0, "viewed": 27, "published": "Public", "date": "1632292803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.9 + 0.2*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGGW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 186]], "test": "untested"}
{"id": "sdK3Dc", "name": "basic geometric images", "author": "jorge2017a2", "description": "basic geometric images\n\n", "tags": ["basicgeometricimages"], "likes": 2, "viewed": 119, "published": "Public API", "date": "1632363708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//basic geometric images\n\n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n///por jorge2017a2...2021-sep-19\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nvec3 circulosvarios(vec2 p, vec3 col, float pradio  )\n{\n    float pr=0.272;\n    p.x=mod(p.x,pr);\n    p.y=mod(p.y,pr);\n    float r1=iTime/100.0;    \n    r1=pradio;\n    float c1=sdCircle( p-vec2(.0,.0), r1 );\n    float c2=sdCircle( p-vec2(.25,.0),r1 );\n    float c3=sdCircle( p-vec2(.0,.25),r1 );\n    float c4=sdCircle( p-vec2(.25,.25),r1 );\n    \n    col= DrawFigBorde(vec3(1.0), col, abs(c1) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c2) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c3) );\n    col= DrawFigBorde(vec3(1.0), col, abs(c4) );\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);    \n    //vec3 col=vec3(0.4,0.4,0.4);\n    vec3 col=vec3(0.6);\n    \n    col= circulosvarios(uv, col,0.2); \n    col= circulosvarios(uv, col,0.15+0.07*sin(iTime)); \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Dc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 329, 365, 365, 410], [415, 415, 454, 454, 498], [500, 544, 591, 591, 618], [619, 619, 662, 662, 689], [690, 690, 738, 738, 766], [772, 772, 834, 834, 966], [968, 968, 1025, 1025, 1091], [1093, 1093, 1128, 1128, 1151], [1153, 1153, 1208, 1208, 1716], [1719, 1719, 1776, 1776, 2052]], "test": "untested"}
{"id": "sdK3Dm", "name": "SDF exp", "author": "green92", "description": "sdf", "tags": ["sdfunion"], "likes": 0, "viewed": 39, "published": "Public", "date": "1631705952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Inter {\n    float t;\n    vec3 n;\n    vec3 c;\n};\n\nRay CameraRay(vec2 pix, vec3 camPos, vec3 camTarget) {\n    vec2 pixm11 = 2.0 * pix / iResolution.xy - 1.0;\n    vec3 f = normalize(camTarget - camPos);\n    vec3 r = cross(f, vec3(0, 0, 1));\n    vec3 up = cross(r, f);\n    float ar = iResolution.y / iResolution.x;\n    return Ray(camPos, normalize(pixm11.x * r + pixm11.y * ar * up + f));\n}\n\nfloat SphereDist(vec3 center, float r, vec3 p) {\n    return length(p - center) - r;\n}\n\nfloat AABBDist(vec3 lower, vec3 upper, vec3 p) {\n    p -= (lower+upper) * 0.5;\n    vec3 b = upper - lower;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat OpSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SpheresUnion(vec3 p) {\n    vec3 s1c = vec3(0, sin(iTime / 2.0), cos(0.5*iTime));\n    vec3 s2c = vec3(0, cos(iTime / 10.0), sin(iTime));\n    vec3 s3c = vec3(sin(iTime), sin(iTime), 0.5);\n    float r = 1.0;\n    float d1 = SphereDist(s1c, 1.0, p);\n    float d2 = SphereDist(s2c, 1.0, p);\n    float d3 = SphereDist(s3c, 0.8, p);\n    float d4 = AABBDist(vec3(-0.25, -0.25, 0.25), vec3(0.25, 0.25, 0.75), p);\n    return OpSmoothUnion(OpSmoothUnion(OpSmoothUnion(d1, d2, 0.5), d3, 0.5), d4, 0.5);\n}\n\n#define f(p) SpheresUnion(p)\n\n//https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 CalcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n\nInter RayMarch(Ray r) {\n    const int maxIter = 50;\n    vec3 p = r.o;\n    float t = 0.0;\n    float prevMinDist = 1e9;\n    for (int i=0; i<maxIter; i++) {\n        p = r.o + t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 1e-2) {\n            return Inter(t, CalcNormal(p), vec3(0, 1, 0));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            return Inter(1e9, vec3(0), vec3(0));\n        }\n        prevMinDist = minDist;\n        t += minDist;\n    }\n    return Inter(1e9, vec3(0), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(vec2(cos(iTime), sin(iTime)) * 5.0, 10);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 L = normalize(camTarget - camPos);\n    const vec3 E = vec3(0.9, 0.9, 0.9);\n    Ray r = CameraRay(fragCoord, camPos, camTarget);\n\n    Inter i = RayMarch(r);\n    vec3 col = vec3(0);\n    \n    if (i.t < 1e9) {\n        col = dot(-L, i.n) * E * i.c;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Dm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 151, 151, 434], [436, 436, 484, 484, 521], [523, 523, 571, 571, 720], [722, 792, 842, 842, 941], [943, 943, 971, 971, 1440], [1472, 1540, 1591, 1591, 1879], [1881, 1881, 1904, 1904, 2406], [2408, 2408, 2465, 2465, 2882]], "test": "untested"}
{"id": "sdK3Dt", "name": "Squishy mouse toy", "author": "dysangel", "description": "left click to squish", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "segment"], "likes": 3, "viewed": 51, "published": "Public", "date": "1632426181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a line segment. Tutorial on how to derive\n//\n// the formula and code: https://www.youtube.com/watch?v=PMltMdi1Wzg\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n   \nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.5 * (length(p - m)/2.);\n    \n\tfloat d = udSegment( p, v1, v2 ) - th;\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.7*sin(iTime / 2. + (iResolution.x * 0.01)+(iResolution.y * 0.01)),0.4*sin(iTime + (iResolution.x * 0.01)+(iResolution.y * 0.01)),.1);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = udSegment(m, v1, v2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Dt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1216, 1377, 1429, 1429, 1552], [1554, 1554, 1611, 1611, 2554]], "test": "untested"}
{"id": "sdK3Dy", "name": "Assignment #5 Animation and Laye", "author": "Sentray7294", "description": "assignment", "tags": ["assignment"], "likes": 0, "viewed": 22, "published": "Public", "date": "1632415595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float drawCircle(vec2 center, float radius, vec2 uv)\n{\n    return step(distance(center, uv), radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    uv *= aspect;\n    \n    // 1\n    vec3 circle2Color = vec3(255.0,0.0,0.0);\n    float circle2 = drawCircle(vec2(0.5,(cos(9.0 * iTime)*0.1+0.5)) * aspect, 0.1, uv);\n    \n    \n    // 2\n    \n    vec3 PulseCol = vec3(1.0*cos(iTime*10.0),1.0*cos(iTime*5.0),1.0*cos(iTime*5.0));\n    \n    // 3\n    \n    vec4 circle3Color = vec4(0.0,255.0,0.0,1.0);\n    float circle3 = drawCircle(vec2(0.5,(cos(3.0 * iTime)*0.1+0.5)) * aspect, 0.1, uv);\n    vec4 circle4Color = vec4(0.0,0.0,0.0,255.0);\n    float circle4 = drawCircle(vec2((cos(5.0 * iTime)*0.1+1.5),1.45) * aspect, 0.1, uv);\n    vec4 circle5Color = vec4(0.0,0.0,255.0,255.0);\n    float circle5 = drawCircle(vec2(0.5,(cos(8.0 * iTime)*0.1+0.5)) * aspect, 0.1, uv);\n    \n    vec3 col;\n    col = mix(vec3(0.0, 0.0, 0.0), PulseCol, circle2);\n    \n    \n    vec3 col2 = mix(vec3(0.0, 63.0, 0.0), PulseCol, circle3);\n    vec3 col3 = mix(vec3(0.0, 0.0, 0.0), PulseCol, circle4);\n    vec3 col4 = mix(vec3(0.0, 0.0, 0.0), PulseCol, circle5);\n    // 4\n    \n    vec3 col5;\n    float Screen1WidthPercent = .5;\n    \n    if(uv.x <= Screen1WidthPercent)\n    {\n        /*vec3 tex = sin(iTime + texture(iChannel0, uv));\n        col5 = tex;*/\n    }\n    else\n    {\n        vec3 colorChange = texture(iChannel1, uv).rgb;\n        \n        col5 = sin(iTime + colorChange);\n        \n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col + col2 + col3 + col4 + col5,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Dy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 103], [105, 105, 162, 212, 1716]], "test": "untested"}
{"id": "sdK3R1", "name": "Animated Aesthetic Palm Tree", "author": "axx0009", "description": "simple first animated shader built from demos by IQ and World of Zero", "tags": ["procedural", "80s", "animated", "neon", "synthetic", "miami"], "likes": 3, "viewed": 110, "published": "Public API", "date": "1631116853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//built from palm tree tutorial by Inigo Quilez, with grid shader by World of Zero, animation by me\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //time variable bounce\n    float b = 0.5*cos(iTime);    \n    \n    //Center of origin\n    vec2 q = uv - vec2(0.3,0.7);\n\n    // Time varying background color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //variable radius\n    float r = 0.2;\n    \n    //float scale = 15.0 + 5.0*cos(iTime); \n    float scale=15.0;\n    float gridPointX = step(float(mod(uv.x * scale, 0.75)), 0.1);\n    float gridPointY = step(float(mod(uv.y * scale, 1.0)), 0.1);\n    float gridPoint = min(1.0, gridPointX + gridPointY);\n\n    // Output to screen\n//    fragColor = vec4(gridPoint, gridPoint, gridPoint, 1.0);\n    \n    //modulated wave on radius r\n    r +=0.1*cos(atan(q.y,q.x-0.025*b)*10.0 + 20.0*(q.x+0.01*b) + 1.0 + 0.05*b);\n    \n    //render canopy\n    col *= smoothstep(r,r+0.005,length(q+.01*b));\n    \n    //trunk width\n    float w = 0.02;\n    //trunk texture\n    w += 0.002*cos(120.0*q.y);\n    //trunk taper\n    w -= 0.005*cos(2.0*q.y);\n    //ground union\n    w+= exp(-40.0*uv.y);    \n    //trunk curve\n    float c = 0.2 * sin(2.0 * (q.y+0.05*b));\n    \n    //render trunk\n    col *= 1.0 -(1.0-smoothstep(w,w+0.001,abs(q.x - c)))*(1.0-smoothstep(0.0,0.001,q.y));\n    \n    //superimpose black grid\n    col -= (gridPoint,gridPoint,gridPoint);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 158, 208, 1556]], "test": "untested"}
{"id": "sdK3Ry", "name": "less complicated hexagon grid", "author": "HaleyHalcyon", "description": "a", "tags": ["grid", "hexagon"], "likes": 5, "viewed": 101, "published": "Public", "date": "1631764072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Instead of generating regular hexagons right away,\n// it generates a hexagon made of 45 degree angles\n// after squishing the input coordinates to get the right proportions.\n// This resulting hexagon will be 2 units wide and 4 units tall,\n// and tiles diagonally at coordinate offset (1, 3).\n\n// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n\n// converts rgb hex code to a vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    // loop around to tile\n    uv = abs(\n        mod(\n            uv + vec2(1.0, 3.0),\n            vec2(2.0, 6.0)\n        ) - vec2(1.0, 3.0)\n    );\n    // return whichever is closer:\n    // distance towards the top right side,\n    // or distance towards the right side\n    // (i.e. absolute value of x coordinate)\n    return max(\n        (uv.x + uv.y) / 2.,\n        uv.x\n    );\n}\n\nfloat map(float minv, float maxv, float x) {\n    if (minv == maxv) {return step(minv, x);}\n    return clamp(0., 1., (x - minv) / (maxv - minv));\n}\n\n// map the range [0, 1) to stripes of colors\n// you can change the number of colors by changing the constant here\n// and adding more colors and thresholds\n#define COLOR_COUNT 4\n// mixing sharpness. set to 0.0 to make it pixely\n#define BLEND_FACT 0.02\nvec3 colorize(float value) {\n    const vec3 color[COLOR_COUNT] = vec3[](\n        HEX(0x000000),\n        HEX(0x300060),\n        HEX(0x8000C0),\n        HEX(0xFF66FF)\n    );\n    const float thres[COLOR_COUNT] = float[](\n        0.0, // ignored\n        0.5,\n        0.8,\n        0.95\n    );\n    // loop around\n    value = fract(value);\n    // i don't like using for loops, but it's the best way\n    // i could think of to adapt to any number of colors.\n    vec3 color_out = mix(\n        color[COLOR_COUNT - 1],\n        color[0],\n        map(0.0, BLEND_FACT, value)\n    );\n    for (int i = 1; i < COLOR_COUNT; i++) {\n        if (value > thres[i]) {\n            color_out = mix(\n                color[i - 1],\n                color[i],\n                map(thres[i], thres[i] + BLEND_FACT, value)\n            );\n        } else {\n            return color_out;\n        }\n    }\n    return color_out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // makes it loop\n    float time = fract(iTime / 2.);\n    // Scales coords so that the diagonals are all a known distance from center\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // Scales coords to the right proportions, and also scale the hexagons down\n    uv *= vec2(1., SQRT3) * 8.;\n    \n    // time changing colors\n    vec3 col = colorize(\n        // i make 2 rectangle grids, because 1 triangle grid is too hard\n        min(\n            // grid with a hexagon centered at the screen\n            hex(uv),\n            // grid with 4 hexagons surrounding the center\n            hex(uv + vec2(1.0, 3.0))\n        // and finally make the colors shift outward with time\n        ) * 0.5 - time\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Ry.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 526, 546, 573, 926], [928, 928, 972, 972, 1074], [1253, 1327, 1355, 1355, 2217], [2219, 2219, 2276, 2297, 3070]], "test": "untested"}
{"id": "sdK3Rz", "name": "ray marching and gamma test", "author": "PrenexNormalForm", "description": "the bands on the sphere and bottom of the screen are in order: linear, gamma 2.2, sRGB", "tags": ["raymarching"], "likes": 2, "viewed": 32, "published": "Public", "date": "1631056383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float signedDistance(vec3 pos) {\n    vec4 sphere = vec4(0, 0, 0, 0.3);\n    return length(pos - sphere.xyz) - sphere.w;\n}\n\n//from https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragment position on the view plane\n    vec2 fragPos = (fragCoord - iResolution.xy * 0.5) / iResolution.yy;\n    vec3 cameraPos = vec3(0, 0, 2);\n    vec3 cameraForward = vec3(0, 0, -1);\n    vec3 viewDir = normalize(vec3(fragPos, 0) - cameraPos);\n    \n    //ray march\n    float maxDepth = 10.0;\n    float depth = 0.0;\n    float signedDist;\n    int i = 0;\n    for(; i < 1000; i++) {\n        signedDist = signedDistance(cameraPos + viewDir * depth);\n        if (signedDist < 0.0001) {\n            break;\n        }\n        depth += signedDist;\n        if (depth >= maxDepth) {\n            depth = -1.0;\n            break;\n        }\n    }\n    \n    //lighting\n    vec3 color = vec3(0);\n    \n    if (depth > 0.0) {\n        vec3 hit = cameraPos + viewDir * depth;\n        vec3 normal = normalize(vec3(\n                signedDistance(hit + vec3(0.00001, 0, 0)) - signedDistance(hit - vec3(0.00001, 0, 0)),\n                signedDistance(hit + vec3(0, 0.00001, 0)) - signedDistance(hit - vec3(0, 0.00001, 0)),\n                signedDistance(hit + vec3(0, 0, 0.00001)) - signedDistance(hit - vec3(0, 0, 0.00001))\n            ));\n        \n        float ambientLight = 0.01;\n            \n        float diffuseIntensity = 0.7;\n        vec3 lightDir = normalize(vec3(cos(iTime), 0.5 * cos(iTime - 1.0), sin(iTime)));\n        float diffuseLight = diffuseIntensity * clamp(dot(normal, lightDir), 0.0, 1.0);\n        \n        color = vec3(ambientLight + diffuseLight);\n    }\n    \n    // Output to screen\n    if (fragPos.y < -0.1) color = encodeSRGB(color);\n    else if (fragPos.y < 0.1) color = pow(color, vec3(0.4545));\n    \n    \n    if (fragPos.y < -0.35) {\n        color = vec3(fragCoord.x / iResolution.x);\n        if (fragPos.y < -0.45) {\n            color = encodeSRGB(color);\n        } \n        else if (fragPos.y < -0.4) {\n            float gamma = 2.2;\n            color = pow(color, vec3(1.0 / gamma));\n        }\n    }\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 120], [122, 167, 200, 200, 368], [370, 370, 427, 469, 2387]], "test": "untested"}
{"id": "sdK3W1", "name": "Ray Marching Tutorial_01", "author": "willis", "description": "Ray Marching Tutorial_01", "tags": ["raymarching"], "likes": 2, "viewed": 42, "published": "Public", "date": "1632823469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n#define Sat(a) clamp(a, 0., 1.)\n\nfloat smin(float a, float b, float k){\n    float h = Sat(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdSphere(vec3 p, vec4 s){\n    return length(p - s.xyz) - s.w;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    p = abs(p) - b;\n    return length(max(vec3(0.), p)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p){\n    float sphere = sdSphere(p, vec4(0., 0., 0., 0.8));\n    float box = sdBox(p - vec3(sin(iTime * 0.5)* 2., 0., 0.), vec3(0.5));\n    float plane = p.y + 1.2;\n    \n    float d = smin(sphere, box, 0.3);\n    \n    d = min(plane, d);\n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(\n                        GetDist(p + e.xyy) - GetDist(p - e.xyy),\n                        GetDist(p + e.yxy) - GetDist(p - e.yxy),\n                        GetDist(p + e.yyx) - GetDist(p - e.yyx)\n                    ));\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float d = 0., sd = 0.;\n    for(int i = 0; i < MAX_STEP; i++){\n        d = GetDist(p);\n        sd += d;\n        if(d < SURF_DIST || sd > MAX_DIST) break;\n        p = p + d * rd;\n    }\n    return sd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0., 2., -8.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.5, 2.));\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        vec3 lightPos = vec3(3., 4., -5.);\n        vec3 N = GetNormal(p);\n        vec3 L = normalize(lightPos - p);\n        \n        float dif = Sat(dot(N, L));\n        \n        d = RayMarch(p + N * SURF_DIST * 2., L);\n        if(d < length(lightPos - p)) dif *= 0.5;\n        \n        col = vec3(dif);\n        \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdK3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 138, 138, 228], [230, 230, 261, 261, 299], [301, 301, 329, 329, 423], [425, 425, 447, 447, 692], [694, 694, 717, 717, 994], [997, 997, 1030, 1030, 1251], [1253, 1253, 1310, 1310, 1940]], "test": "untested"}
{"id": "sdKGRR", "name": "twisty star rose (const colors)", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 3, "viewed": 36, "published": "Public", "date": "1631241480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float PI_2 = PI / 2.;\n\nfloat fold(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\nfloat foldPlus(float x) {\n    return log(0.5 + fold(x));\n}\n\nfloat smoothThres(float x, float strength) {\n    return smoothstep(0.5 - strength, 0.5 + strength, x);\n}\n\nfloat smoothFold(float x, float strength) {\n    return smoothThres(fold(x), strength);\n}\n\nvec3 colMap(float x, vec3 a, vec3 b) {\n    return a * (1.0 - x) + b * x;\n}\n\nfloat star(float angle, float d, float roundness) {\n    return foldPlus(angle * 10.) + d * roundness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 8.);\n    \n    // Normalized pixel coordinates\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= iResolution.xy / scale / 2.;\n    uv *= 2.;\n    float dist = log(uv.x*uv.x+uv.y*uv.y); // not real distance, but useful for log spirals\n    float angle = t - atan(uv.x, -uv.y) / PI / 2.;\n    float angleLayer = t / 5.;\n    float offsetLayer = t * 3.;\n    float spaceLayer = 0.5;\n    vec3 colA = vec3(1.0, 0.0, 0.6);\n    vec3 colB = vec3(0.1, 0.5, 1.0);\n    vec3 colC = vec3(1.0, 0.8, 0.0);\n    vec3 col = vec3(fold(t * 16.));\n    \n    if (dist >= -8.) {\n        for (float iRing = 0.; iRing < 25.; iRing += 1.) {\n            if (star(angle - (iRing * angleLayer), dist, 1.1) < spaceLayer * (iRing - offsetLayer) - 7.){\n                switch (int(iRing) % 3) {\n                    case 0:\n                        col = colA;\n                        break;\n                    case 1:\n                        col = colB;\n                        break;\n                    case 2:\n                        col = colC;\n                }\n                break;\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 116], [118, 118, 143, 143, 176], [178, 178, 222, 222, 282], [284, 284, 327, 327, 372], [374, 374, 412, 412, 448], [450, 450, 501, 501, 553], [555, 555, 612, 612, 1826]], "test": "untested"}
{"id": "sdKGWt", "name": "大龙猫 - Quicky#059", "author": "totetmatt", "description": "Some lighting (wrongly working)  and camera move. Quite happy with the result overall ", "tags": ["quicky"], "likes": 5, "viewed": 175, "published": "Public API", "date": "1632420449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 ln ;\nvec2 sdf(vec3 p){\n\n    vec2 h;\n  vec3 ph=p;\n    ph.x += asin(.2*sin(p.y*10.))*.2;\n  h.x=length(ph.xz)-1.;\n    h.y=1.;\n  \n  \n  vec2 t;\n  vec3 pt = p;\n    pt.y +=+iTime*.35;\n    float idy = floor(pt.y);\n    pt.xz *=rot(iTime*.33+idy);\n    pt.xz = abs(pt.xz)-1.;\n \n    pt.y = fract(pt.y)-.5;\n    t.x  = min(.25,length(pt)-(.2+fract(iTime)*.2));\n    t.y = 2.+ mod(idy,2.);\n    ln = pt;\n   \n  h = t.x < h.x ? t:h;\n\n  \n    \n  \n  return h;\n }\n#define q(s) s*sdf(p+s).x\n\n float ao(vec3 rp, vec3 n, float k){\n    vec2 d = sdf(rp+n*k);\n    if(d.y==2.){\n       return 1.;\n      }\n     return d.x /k;\n   }\n\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n float timer = fract(iTime*.06);\n \n  vec3 col = vec3(.1);\n\n  vec3 ro = mix(vec3(0.,0.,-7.),vec3(0.,100.,-1.25),timer);\n  vec3 rt = mix(vec3(0.,0.,-0.),vec3(0.,110.,-0.),timer);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  \n  vec3 rp = ro;\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.));\n  \n  vec3 light = vec3(1.,2.,-3.);\n  float dd =0.;\n  vec3 acc = vec3(0.);\n  bool nohit = false;\n  for(float i=0.;i<=128.;i++){\n    \n      vec2 d = sdf(rp);\n    \n    dd +=abs(d.x);\n    if(dd > 60.){nohit= true; break;}\n    \n    if(d.y==2. && d.x <.1){\n      \n        acc += vec3(1.,.30,.0)*exp(-abs(d.x))/18.;\n        d.x = max(.002,abs(d.x));\n      }\n      if(d.x <.001){\n          vec3 l2 = normalize(ln);\n          vec3 n = norm(rp,.0003);\n          float diff = max(0.,dot(normalize(light-rp),n));\n          float diff2 = max(0.,dot(l2,n));\n     \n          if(d.y==1.) { \n            col = vec3(.1)*diff+ vec3(1.,.30,.0)*diff2;;  \n             rd = reflect(rd,n);\n             rp+=rd*.1;\n           \n          } else if (d.y==3.){\n              col = vec3(.1,.1,.1)*diff;\n                break;\n              }\n          \n    \n       \n          \n          }\n          rp+=rd*d.x;\n }\n  col +=acc;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKGWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [76, 76, 93, 93, 511], [540, 540, 575, 575, 669], [671, 671, 698, 698, 774], [775, 775, 832, 882, 2253]], "test": "untested"}
{"id": "sdt3W2", "name": "Hypnotic Hallway", "author": "Drakyen", "description": "I'm starting to get decent at actually making interesting things! :D", "tags": ["3d", "raymarching", "transparency", "glow"], "likes": 10, "viewed": 89, "published": "Public", "date": "1630688696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a)) //basic rotation matrix thingy yay\n\nfloat t; vec3 glw; //global time and glow variables\n\nfloat bx(vec3 p, vec3 s) //like a cube right, but better, because it can be SCALED!\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)), 0.) + length(max(q,0.));\n}\n\nfloat cyl(vec3 p, float r) //a cylinder. do you know where the ends of it are? I sure don't...\n{\n  return length(p.xz)-r; \n}\n\nfloat tor(vec3 p, vec2 t) //mmn donut shape - ITS A TORUS OKAY?\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat crys(vec3 p, vec3 pp) //makes a cool fluidy warping crystal thingy, p = result centre, pp = kifs centre\n{\n  for(float i=0.;i<4.;i++) //blah blah blah kifs yay funky lots of cubes\n  {\n      pp.xy*=rot(i - 2.+0.1); //rotate it and do fun stuff with \"i\"\n      pp.xy=abs(pp.xy)-i*0.2; //free duplication tactics here\n      pp.xy=abs(pp.xy)-2.1; //more high performance cloning\n      pp.yz*=rot(i); //some more rotation just to make sure it's REALLY messed up by now\n  }\n  float b=bx(pp*0.9,vec3(2))-0.03; //create a rando cube in the middle lets go\n  b=mix(b,bx(p,vec3(1)),0.5); //mix is actually amazing with SDFs, this turns the whole mess of cubes into something actually interesting and cool. comment out to see the mess instead\n  float g=length(p); //i just calculated the distance to the centre of this world or something\n  glw+=0.01/(0.01+g*g)*mix(vec3(1,0,0.2),vec3(0.2,0.5,1),sin(t/4.)*0.5+0.5); //glow glow glow glow glow glow glow glow glow\n  return b; //\"box\"\n}\n\nvec2 mp(vec3 p) //scene goes here yes\n{  \n  float i = clamp(10.-t,0.,10.); //smooth intro morph variable yay cool\n  float z = (sin(t/3.)*0.5+0.5)*1.5; //slow z warping for better effect\n  float ta = 1.-pow(1.-mod(t,3.) * 0.3,2.);\n  vec3 co=mix(vec3(1,0,0.2),vec3(0.2,0.5,1),sin(-t/4.)*0.5+0.5); //funky colours yup\n  vec3 pp=p-vec3(0,0,i+z); //second position for things yes\n  vec3 ppp=p; //more positions because why not\n  pp.xy*=rot(-t/3.); //rotate it\n  ppp.xy*=rot(t*0.1); //rotate it too\n  vec2 cry = vec2(crys(ppp,pp),1.); //it's a glowy crystal, go cry about it - but if you wanna see a different varient, swap ppp and pp in this line\n  pp=p;pp.yz*=rot(1.57); //reset pp so we can reuse it and also rotate it aprox 90 degrees\n  float tr = tor(pp-vec3(0,12.*ta,0), vec2(16.*ta,0.01)); //donut time!\n  cry.x=min(cry.x,tr); //add donut we don't really care about the material it's just for glow\n  glw+=0.01/(0.01+tr)*co; //do the glowy :D\n  pp=p-vec3(0,9,12);pp.x=abs(pp.x)-11.;pp.x*=0.3;//hooray for free cloning technology\n  float br=bx(pp,vec3(0.5,30,100))-0.2; //make background walls exist\n  pp.z-=mod(t*5.,20.)+5.; pp.z=abs(pp.z)-10.;pp.z=abs(pp.z)-10.;//bars, he says, BARS!\n  float g=bx(pp,vec3(0.8,30,2));//glow amount for bars\n  br=min(br,g);//combine so that we don't get messyness\n  vec3 coco=vec3(1,1,1)-co; //inverted col\n  glw+=0.01/(0.01+g)*coco*0.2; //weird outer glowy stuff idk either but hey it looks neat\n  ppp=p;ppp.y=abs(ppp.y)-5.;//get position make position mirror on Y;\n  vec2 flr = vec2(bx(ppp-vec3(0,4,0),vec3(50,1,100)),2); //make floor/roof stuff\n  flr.x=min(flr.x,br); //actually add the side bits to the raymarch so they don't just get sad and become messy\n  return flr.x<cry.x?flr:cry; //and that's that - i wanted to add more bits on the floor/roof but it was causing issues with lighting :(\n}\n\nvec2 tr(vec3 ro, vec3 rd, float f) //standard raymarching stuff with a distance field multiplier so we can flip things inside out for transparency\n{\n  vec2 d = vec2(0); //d=distance, duh. But it also keeps track of the material ID\n  for(int i = 0; i < 256; i++) //loopy loopy looping loop\n  {\n    vec3 p=ro+rd*d.x; //the position is HERE!\n    vec2 s=mp(p);s.x*=f; //grab the scene SDF\n    d.x+=s.x;d.y=s.y; //move and update material id\n    if(d.x>64.||s.x<0.001)break; //break if we reached something or went too far\n  }\n  if(d.x>64.)d.y=0.;return d; //return distance and ID\n}\n\nvec3 nm(vec3 p)\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x)); //normals hooray\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 n) //pixel.. shader? it shades pixels, okay? got it? cool.\n{\n  vec4 bg=vec4(0.1,.1,0.1,1); //background colour\n  if(h.a==0.)return bg; //oh no we hit the background how sad\n  vec4 a=h.a==1.?vec4(0.,1.,1.,0.2):vec4(0.1,0.1,0.15,1); //give it some colour, except not because the glow does most of it\n  float d=dot(n,-rd); //ahha this surface is pointy - OR IS IT?!\n  float dd=max(d,0.); //diffuse lighting that makes things actually look like things instead of not looking like things\n  float f=pow(1.-d,4.); //reflecty edges that aren't really reflecty but look reflecty because they're edges\n  float s=(pow(abs(dot(reflect(rd,n),-rd)),40.)*10.); //light bright BUT ONLY WHERE IT NEEDS TO BE\n  if(h.a>1.)s*=0.05;//make id 2 more matt instead of shiny\n  float ao=clamp(1.-mp(h.xyz+n*0.1).x*14.,0.,1.)*0.9; //sorry, we don't want lighting where things are too close to each other :(\n  return vec4(mix(a.rgb*(dd-ao)+s,bg.rgb,f),a.a); //mix it all together - you can replace the whole thing with a vec4(a.rgb*oneofthevalueshere,1.) if you just wanna see what a thing looks like\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) //time to do all the stuff\n{\n  t=iTime; //time is only temporary\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y); //u? v? u,v, uv!\n  uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1.); //but now in the middle\n  float ts=1.,io=1.14; //ooh fun variables to track transparency bits\n  vec3 ro=vec3(0,0,-10),rd=normalize(vec3(uv,1.)),oro=ro,ord=rd,cp,cn,rc,cc; //cam pos and ray dir and even more variables for the transparency loop\n  for(int i=0;i<4;i++) //transparency loop! increase the iterations for more transparency depth but less performance if you feel like it. 4 seems like a good middle to me.\n  {\n    vec2 fh=tr(oro,ord,1.); //go find front of object or something\n    cp=oro+ord*fh.x;cn=nm(cp); //figure out the position and normal of the hit\n    vec4 c=px(vec4(cp,fh.y),ord,cn); //grab shaded colour for pixel\n    if(fh.y==0.||c.a==1.) {cc=mix(cc,c.rgb,ts); break;} //oh no it's the background we gotta get out of here!!\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./io); //inject ourselves into the object so we can go THROUGH it!\n    vec2 bh=tr(ro,rd,-1.);//go through inverted distance field to find the exiting face of the object we're currently traversing because yes.\n    cp=ro+rd*bh.x;cn=nm(cp); //figure out position and normal again because we forgot it already duh\n    oro=cp+cn*0.01;ord=refract(rd,-cn,io); //inject ourselves back.. out? outject ourselves? whatever, we back outside again now\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn); //TOTAL INTERNAL REFRACTION D: (but actually it looks sick so whatever)\n    cc=mix(cc,c.rgb,ts);ts-=c.a; //finally we update the colour\n    if(ts<=0.)break; //if we're still transparent, keep going. If not... time to BREAK OUT OF THIS LOOP!\n  }\n  fragColor=vec4(cc+glw,1.); //dude we gotta see things somehow, this does that\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 139, 224, 224, 306], [308, 308, 404, 404, 432], [434, 434, 499, 499, 564], [566, 566, 677, 677, 1541], [1543, 1543, 1582, 1582, 3374], [3376, 3376, 3524, 3524, 3954], [3956, 3956, 3973, 3973, 4093], [4095, 4095, 4185, 4185, 5199], [5201, 5201, 5283, 5283, 7064]], "test": "untested"}
{"id": "sdt3Wj", "name": "Hyper power fractal", "author": "phodopus", "description": "Will a complex hyper power converge?", "tags": ["fractal"], "likes": 3, "viewed": 39, "published": "Public", "date": "1630678945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Maximum number of iterations.\n#define MAX 1024\n\n// Point at which to stop and consider it will not converge.\n#define INF 1.0e20\n\n// Any value >1 will give that number of sub-samples on each of X and Y.\n#define AA 0\n\nprecision highp float;\n\n\n// Sorry for the state of the code.\n\nint iterations( vec2 x0 )\n{\n    float r = length( x0 );\n    float theta = atan( x0.y, x0.x );\n    float ln_r = log( r );\n    \n    float a = x0.x;\n    float b = x0.y;\n    \n    for ( int i = 0; i < MAX; i++ )\n    {\n        float r1 = exp( a * ln_r - b * theta );\n        float theta1 = b * ln_r + a * theta;\n        if ( abs( r1 ) > INF )\n        {\n            return i;\n        }\n        \n        a = r1 * cos( theta1 );\n        b = r1 * sin( theta1 );\n    }\n    return MAX;\n}\n\nvec4 run( vec2 p )\n{\n    float scale = 20.0;\n    vec2 origin = vec2( -0.25, 0.0 );\n\n    vec2 zoomPoint = vec2( 0.2795586372245285, -0.15761016844585213 );\n    \n    float frame = 400.0 * ( 1.0 - cos( iTime * 0.5 ) );\n    \n    float zoomFactor = pow( 0.99, frame );\n    \n    scale *= zoomFactor;\n    \n    origin = ( 1.0 - zoomFactor ) * zoomPoint + zoomFactor * origin;\n\n    p = p * scale - origin;\n\n    int it = iterations( p );\n    float r = ( cos( float( it ) / 16.0 ) + 1.0 ) * 0.5;\n    float g = ( cos( float( it ) / 16.0 + 2.094395102 ) + 1.0 ) * 0.5;\n    float b = ( cos( float( it ) / 16.0 - 2.094395102 ) + 1.0 ) * 0.5;\n    \n    return it == MAX ? vec4(0.0, 0.0, 0.0, 1.0 ) : vec4(r, g, b, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n#if AA > 1\n    vec4 result = vec4( 0.0 );\n    for ( int j = 0; j < AA; j++ )\n    {\n        for ( int i = 0; i < AA; i++ )\n        {\n            vec2 offset = vec2( i, j ) / float( AA ) - 0.5;\n            vec2 p = ( ( fragCoord + offset ) * 2.0 / iResolution.x ) - vec2( 1.0, iResolution.y / iResolution.x );\n            result += run( p );\n        }\n    }\n    fragColor = result / float( AA * AA );\n#else\n    vec2 p = ( fragCoord * 2.0 / iResolution.x ) - vec2( 1.0, iResolution.y / iResolution.x );\n    fragColor = run( p );\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 281, 308, 308, 756], [758, 758, 778, 778, 1462], [1465, 1465, 1522, 1522, 2058]], "test": "untested"}
{"id": "sdt3WS", "name": "Slow Vibe", "author": "didididi", "description": "just having fun", "tags": ["colorful"], "likes": 0, "viewed": 102, "published": "Public API", "date": "1630599779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q= p-vec2(0.5,0.5);\n    // Time varying pixel color\n    //vec3 col =mix(vec3 (0.8, 0.5,0.9),vec3(1.0, 0.8, 0.5),sqrt(p.y));\n    vec3 col =mix(vec3 (0.8, 0.5,0.9),vec3(1.0, 0.8, 0.5),sin(iTime+p.y));\n    //vec3 col = 0.8 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    \n    \n    //create spikes\n    float r = 0.2+0.1*cos(atan(q.y,q.x)*(1.0+iTime)+220.0*q.x+iTime*2.0);\n    \n    \n    col *= smoothstep(r,r+0.01, length(q));\n    \n   \n    r=0.02;\n     \n    //openning\n    col *= smoothstep(iTime*0.1, 0.001, abs(q.x+0.1*sin(20.0*q.y)));\n    \n    //background stuffs\n    col *= smoothstep(r, r+0.01, abs(q.x+1.0*sin(220.0*(q.y-0.08)+iTime*0.02)));\n    col *= smoothstep(r, r+0.001, abs(q.x+1.0*cos(22.0*(q.x-0.7)+iTime*0.005)));\n    col *= smoothstep(r, r+0.07, abs(2.0*cos(22.0*(q.x-0.7)+1.0*sin(22.0*(q.y-0.08))+iTime*0.5)));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1037]], "test": "untested"}
{"id": "sdtGWf", "name": "Plane Fitting", "author": "oneshade", "description": "Fitting points with a plane.", "tags": ["plane", "optimization", "points", "fitting"], "likes": 7, "viewed": 64, "published": "Public", "date": "1630794536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iTime (0.25 * iTime)\n\n#define PI 3.14159265359\n#define AA 2\n\n// Convenience structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct TraceInfo {\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    int id;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 nor;\n};\n\n#define N 10\nPlane planeFitting(in vec3[N] points) {\n    float Jxx = 0.0, Jyy = 0.0;\n    float Jxy = 0.0, Jxz = 0.0, Jyz = 0.0;\n    float Jx = 0.0, Jy = 0.0, Jz = 0.0;\n    for (int n=0; n < N; n++) {\n        vec3 p = points[n];\n        Jxx += p.x * p.x, Jyy += p.y * p.y;\n        Jxy += p.x * p.y, Jxz += p.x * p.z, Jyz += p.y * p.z;\n        Jx += p.x, Jy += p.y, Jz += p.z;\n    }\n\n    // Precomputation\n    float P = float(N);\n    float c1 = Jx * Jyy - Jy * Jxy;\n    float c2 = Jx * Jy  - P  * Jxy;\n    float c3 = Jx * Jyz - Jy * Jxz;\n    float c4 = Jx * Jxy - Jy * Jxx;\n\n    // Solve for plane coefficients: z = ax + by + c\n    float a = (c1 * (Jx * Jz - P * Jxz) - c2 * c3) / (c1 * (Jx * Jx - P * Jxx) - c2 * c4);\n    float b = (c3 - c4 * a) / c1;\n    float c = (Jxz - Jxx * a - Jxy * b) / Jx;\n\n    // Compute position and normal\n    vec3 n = vec3(a, b, -1.0);\n    float l2 = a * a + b * b + 1.0;\n    return Plane(-n * c / l2, n / sqrt(l2));\n}\n\n// Double integral of mod(floor(x) + floor(y), 2) from a to b\nfloat integrateCheckers(in vec2 a, in vec2 b) {\n    vec2 u = b - a, v = abs(mod(b, 2.0) - 1.0) - abs(mod(a, 2.0) - 1.0);\n    return 0.5 * (u.x * u.y - v.x * v.y);\n}\n\n// 2D rotation matrix\nmat2 Rotate2D(in float theta) {\n    float c = cos(theta), s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n// Primitive intersectors\nvoid addPlane(in vec3 pos, in vec3 nor, in int id, in Ray ray, inout TraceInfo scene) {\n    float d = dot(ray.dir, nor);\n    if (d != 0.0) {\n        float t = dot(pos - ray.pos, nor) / d;\n        if (t > 0.0 && (scene.id != 0 ? t < scene.dist : true)) {\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = nor;\n            scene.id = id;\n        }\n    }\n}\n\nvoid addSphere(in vec3 pos, in float radius, in int id, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - radius * radius;\n\n    float discr = b * b - a * c;\n    if (discr > 0.0) {\n        float t = (-b - sign(c) * sqrt(discr)) / a;\n        if (t > 0.0 && (scene.id != 0 ? t < scene.dist : true)) {\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = scene.pos / radius;\n            scene.id = id;\n            scene.pos += pos;\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(-1.0, vec3(0.0), vec3(0.0), 0);\n\n    vec3 o = vec3(sin(iTime + 1.0), cos(2.0 * iTime - 1.0), sin(iTime - 1.0));\n    vec3 d = normalize(vec3(sin(2.0 * iTime), cos(iTime), sin(iTime) * cos(3.0 * iTime)));\n\n    vec3[N] points;\n    for (float n=0.0; n < float(N); n++) {\n        float s1 = 0.2 * n, s2 = cos(n), s3 = sin(n);\n        vec3 point = 5.0 * vec3(sin(s1 * iTime) * cos(s1 * iTime), cos(s2 * iTime), sin(s3 * iTime));\n        point -= d * dot(point - o, d);\n        point += d * sin(point.x) * cos(point.y);\n        addSphere(point, 0.2, 1, ray, scene);\n        points[int(n)] = point;\n    }\n\n    Plane fitting = planeFitting(points);\n    addPlane(fitting.pos, fitting.nor, 2, ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Mouse rotation\n    mat2 yaw = Rotate2D(-mouse.x);\n    mat2 pitch = Rotate2D(-mouse.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            vec3 color;\n\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -1.0)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Render\n            TraceInfo scene = traceScene(camRay);\n            if (scene.id != 0) {\n                vec3 mat = vec3(1.0, 0.0, 0.0);\n                if (scene.id == 2) {\n                    vec3 u = normalize(vec3(-scene.nor.z, 0.0, scene.nor.x));\n                    vec3 v = cross(u, scene.nor);\n                    vec2 texCoords = scene.pos * mat2x3(u, v);\n                    float filt = scene.dist * scene.dist / 2500.0; // Hack filter\n                    mat = vec3(integrateCheckers(texCoords - filt, texCoords + filt) / (4.0 * filt * filt));\n                }\n\n                float shade = max(0.1, dot(scene.nor, -camRay.dir));\n                if (scene.id == 2) shade = 1.0;\n                color = mat * shade;\n            }\n\n            else color = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * camRay.dir.y);\n            fragColor.rgb += pow(color, vec3(0.75));\n        }\n    }\n\n    // Average\n    fragColor.rgb /= float(AA * AA);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 276, 315, 315, 1209], [1211, 1273, 1320, 1320, 1437], [1439, 1461, 1492, 1492, 1566], [1568, 1594, 1681, 1681, 1996], [1998, 1998, 2090, 2090, 2609], [2611, 2625, 2659, 2659, 3407], [3409, 3409, 3464, 3464, 5283]], "test": "untested"}
{"id": "sdtSRH", "name": "18/49", "author": "tono", "description": "Day", "tags": ["49"], "likes": 3, "viewed": 54, "published": "Public", "date": "1632670547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat rand(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise(vec3 p)\n{\n    vec3 fp = floor(p);\n\tvec3 fs = fract(p);\n    vec3 sf = vec3(1.,0.,0.);\n    \n    float a = rand(fp);\n    float b = rand(fp + sf);\n    float c = rand(fp + sf.yxz);\n    float d = rand(fp + sf.xxz);\n    float e = rand(fp + sf.yyx);\n    float f = rand(fp + sf.xyx);\n    float g = rand(fp + sf.yxx);\n    float h = rand(fp + sf.xxx);\n    \n    vec3 u = smoothstep(0.,1.,fs);\n  //  u = pow(fs,vec3(3.));\n    \n    return mix(mix(\n        \t\tmix(a,b,u.x),\n        \t\tmix(c,d,u.x),u.y),\n               mix(\n                mix(e,f,u.x),\n                mix(g,h,u.x),u.y),u.z\n            );\n}\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat fbm(vec3 p)\n{\n    float v = 0.;\n    float a = .5;\n    float f = 0.;\n    for(int i=0;i<3;i++)\n    {\n        v+=a*noise(p);\n        p*=2.;\n        a*=.5;\n    }\n    return v;\n}\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    vec2 dir = vec2(1.,1.);\n    vec2 wave = vec2(0.);\n    for(int i = 0; i< 3;i++)\n    {\n        dir *= rot(.2);\n    \twave += dir * iTime/3.;\n    \tp.y -= (1. - pow(noise(p.xz/(3. + float(i) ) + wave),4. ) )/2.;\n    }\n\n    o = -p.y + 0.;\n    if(o < 1.)\n    {\n        o -= fbm(p/2.1 + iTime/1.)/3.;\n    }\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 256 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        if(depth > 200.)break;\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\nvec3 skyColor(vec3 rd,vec3 sun,float starToggle)\n{\n    vec3 sky = rd;\n    rd.y = abs(rd.y);\n    vec3 sunPos = sun;\n    sky = vec3(0.);\n    float ld = dot(sun,vec3(0.,1.,0.));\n    float sd = abs( dot(sun,vec3(0.,0.,1.)) );\n    vec3 rd2 = rd;\n    rd2.xz *= rot(iTime/18.);\n    vec3 star = vec3(0.,0.5,1.) + sin( rand(rd2)*10. );\n    star *= step(fbm(rd2*200.), 0.2);\n    star *= (sin(iTime*1. + fbm(rd2*50.)*30. ) + 1.)/2.;\n    star = clamp( star - .05,vec3(0.),vec3(1.)) * starToggle;\n    \n    sky += vec3(0.,0.1,.4);\n    sky += vec3(0.3,0.5,0.5) * ld;\n    sky += max(0.,pow((1. - ld),8.) ) * star;\n    sky += vec3(0.6,0.0,-0.1) * sd;\n    float siz = .1;\n    float srd = clamp(dot(sunPos,rd) - siz,0.,1.) + siz;\n    float s = mix(.3,1.3,ld);\n    srd = pow( srd , 3.) - .7 + pow( srd , 120.);\n    sky += max(0.01 , srd);\n    return sky;\n}\n\nvec3 seaCol(vec3 rd,vec3 N,vec3 dist,vec3 pos,vec3 l)\n{\n    vec3 o = vec3(0.);\n    float dd = max(dot(rd,vec3(0.,1.,0.)),0.);\n    float diff = max(0.,dot(-l,N));\n    float fr = clamp(1.0 - dot(N, -rd), 0.0, 1.0);\n    fr = pow(fr, 13.0) * 0.65;\n    vec2 e = vec2(1.0, -1.0) * 0.05;\n    vec3 N2 = normalize(\n              e.xyy * map(pos + e.xyy).x +\n              e.yyx * map(pos + e.yyx).x +\n              e.yxy * map(pos + e.yxy).x +\n              e.xxx * map(pos + e.xxx).x);\n    vec3 ref = reflect(rd,N2);\n    vec3 sky = vec3(.8,.8,1.);\n    \n    sky = skyColor( mix(rd,ref, 1.) ,l,1.);\n    vec3 sea = vec3(.1,.3,.7)/2.;\n    o =  mix(vec3(0.),vec3(1.),dd);\n    o += mix(sea,vec3(0.,0.,0.),dd);\n    o += mix(dd,1.,.3) * fr * mix(sea * 3. , sea , dd ) + fr/10.;\n    o += max(sky/2. - vec3(.5) , 0.);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 cp = vec3(0.,0.,-6.);\n    vec3 target = vec3(0.);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    vec3 sun = normalize(vec3(0.,0.1,1.));\n    sun.yz *= rot(iTime/6.);\n    vec3 sky  = skyColor(rd,sun,1.);\n    col = sky;\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * 0.0005;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        col = N;\n    \t\n    \t// diff = mix(diff , 1.,.1);\n        vec3 mat = seaCol(rd,N,pos - cp,pos,sun);\n        col = mat;\n        sky  = skyColor(rd,sun,0.);\n\t\tfloat t = 1. - exp(-.000003 * d.x * d.x * d.x);\n        col = mix(mat, sky, t);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtSRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [62, 62, 82, 82, 177], [178, 178, 199, 199, 781], [782, 795, 822, 822, 939], [941, 1028, 1054, 1054, 1571], [1572, 1572, 1591, 1591, 1751], [1752, 1752, 1770, 1770, 2141], [2143, 2143, 2174, 2174, 2473], [2474, 2474, 2524, 2524, 3310], [3312, 3312, 3367, 3367, 4127], [4129, 4129, 4186, 4186, 5351]], "test": "untested"}
{"id": "sdtXRn", "name": "Septa", "author": "supah", "description": "I don't really know", "tags": ["lines", "light", "atan", "orange", "angle", "septa"], "likes": 3, "viewed": 39, "published": "Public", "date": "1632512501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define STEP 12\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat angle(vec2 uv, float i) {\n    float inc = i / float(STEP) * PI * 2.;\n    float time = sin(2. * iTime + i * .12) * .5 + .5;\n    uv.x += sin(inc) * time * .45;\n    uv.y += cos(inc) * time * .45;\n    uv = rotate(uv, -inc);\n    float c = smoothstep(-PI * float(STEP), PI, atan(uv.x, uv.y));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(1.);    \n    for (int i = 0; i < STEP; i++) {\n        col *= angle(uv, float(i));\n    }\n    col = smoothstep(0.6, .9, col);\n    col = mix(vec3(1., 0., 0.), vec3(1.0, .9, 0.), col.r);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 69, 69, 153], [155, 155, 186, 186, 463], [465, 465, 522, 522, 858]], "test": "untested"}
{"id": "sdV3Wh", "name": "Euler Spiral", "author": "oneshade", "description": "Rotozooming euler spiral.", "tags": ["spiral", "eulerspiral", "fresnelintegral"], "likes": 14, "viewed": 84, "published": "Public", "date": "1631589700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROTOZOOM\n#define dt 0.05\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    float time = 0.1 * iTime;\n    vec3 color = vec3(1.0);\n\n    // Point moving along the spiral\n    vec2 pPrev = vec2(0.0), pCur = vec2(0.0);\n    float pos = 10.0 * sin(time);\n    for (float t=0.0; t < abs(pos); t += dt) {\n        float t2 = t * t;\n        vec2 dp = vec2(cos(t2), sin(t2)) * sign(pos) * dt;\n        pPrev += dp;\n        if (t + dt < abs(pos)) pCur += dp;\n    }\n\n    float lerp = fract(pos / dt);\n    if (pos > 0.0) lerp = 1.0 - lerp;\n    vec2 p = mix(pPrev, pCur, lerp);\n\n    // Rotozoom\n    #ifdef ROTOZOOM\n    float pos2 = pos * pos;\n    float rot = -atan(sin(pos2), cos(pos2)) + 1.57;\n    uv *= Rotate2D(rot);\n    float zoom = abs(cos(time));\n    uv *= zoom;\n    unit *= zoom;\n    uv += p;\n    #endif\n\n    // Parametric plot\n    vec2 suv = uv * sign(uv.x);\n    vec2 prev = vec2(0.0);\n    for (float t=0.0; t < 10.0; t += dt) {\n        float t2 = t * t;\n        vec2 cur = prev + vec2(cos(t2), sin(t2)) * dt; // Integrate (cos(t^2), sin(t^2))\n        drawSDF(sdLine(suv, prev, cur), vec3(0.0));\n        prev = cur;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdV3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 128, 155, 155, 221], [223, 231, 278, 278, 386], [388, 388, 436, 436, 468], [470, 470, 525, 544, 1731]], "test": "untested"}
{"id": "sdV3zh", "name": "Causticss", "author": "supah", "description": "Caustic waves. Attempt.", "tags": ["waves", "wave", "sea", "caustics"], "likes": 3, "viewed": 160, "published": "Public", "date": "1631112359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec3 rgb(float r, float g, float b) {\n    return vec3(r/255., g/255., b/255.);\n}\n\nfloat caustic(vec3 n) {\n    float c = snoise(n);\n    c = length(vec2(c * 2.));\n    return smoothstep(0.02, 0.04, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // perspective\n    uv.x *= (2.2 * (.4 + uv.y * .5));\n    \n    uv.x -= uv.y;\n\n    // caustics\n    float z = 8.;\n    float n = caustic(vec3(uv.x * z, uv.y * z, iTime * .2));\n    float n1 = caustic(vec3(uv.x * z, uv.y * z, iTime * .49));\n    float n2 = caustic(vec3(uv.x * z, uv.y * z, iTime * .44));\n\n    // colors\n    vec3 baseCol = rgb(140., 134., 106.);\n    vec3 topCol = rgb(79., 150., 153.);\n    vec3 gradient = mix(baseCol, topCol, uv.y);\n    vec3 col = gradient;\n    \n    // mix\n    col *= vec3(1. - n * .1);\n    col *= vec3(1. - n1 * .1);\n    col *= vec3(1. - n2 * .1);\n    col += col * 1.1;\n    \n    // noise\n    col += .03 * snoise(vec3(uv.x * 100., uv.y * 500., uv.x * 200.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdV3zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2079, 2079, 2163], [2165, 2165, 2202, 2202, 2245], [2247, 2247, 2270, 2270, 2365], [2367, 2367, 2424, 2474, 3238]], "test": "untested"}
{"id": "sdVGDV", "name": "Hello shadertoy. Newbie here", "author": "fyisic123", "description": "Hello shadertoy community =)  I am new to shaders and shadertoy, Here is my first  and hopefully not final upload. \nCriticism is very welcome =)", "tags": ["voronoi", "psychedelic", "hue", "psy"], "likes": 5, "viewed": 170, "published": "Public API", "date": "1632245310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(v) ( .6 + .6 * cos( 2.*PI*(v) + vec3(0,-2.*PI/3.,2.*PI/3.) ) )     // Credit: https: shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n#define rotate(a) mat2(cos( a + vec4(0,33,11,0)))                             // or on shadertoy: FabriceNeyret2                  \n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n\nvec2 hash22(vec2 p)  // Random noise. Credit: https://www.youtube.com/watch?v=l-07BXzNdPw\n{\n    vec3 a = fract(p.xyx * vec3(123.34,234.34,345.65));    \n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 UV = (2.0 * fragCoord - iResolution.xy) / iResolution.y;  // Convert coordinate to (-1,-1) -> (1.0, 1.0)                    \n    \n        \n    UV += smoothstep(0.25  ,  -0.25, length(UV)-0.6); // Distortion effect    \n    UV *= (3.0 + (3.0 * abs(sin(t * 0.05))));  // Animate camera zoom    \n    UV *= rotate(sin((t+ sin(1.2)) * 0.5)); // Animate camera rotation        \n    UV += (2.0 + (1.0 * sin(t))) * vec2(sin(t), cos(t)); // Animate camera panning;\n    \n    \n    \n    vec2 GV = fract(UV) - 0.5;    // Voronoi  Credit: https://www.youtube.com/watch?v=l-07BXzNdPw\n    float minDist = 100.0;\n    vec2 ide = floor(UV);    \n    for (float y = -1.0; y <= 1.0; y++)\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n            vec2 n = hash22(ide + offs);\n            vec2 p = offs + sin(n * t) * 0.5;\n            float d = length(GV - p);\n            \n            if (d < minDist)\n            {\n                minDist = d;                \n                               \n            }\n            \n        }                       // end of Voronoi\n        \n        \n    \n    minDist = abs(sin(minDist * (4.0 + (3.0 * sin(t))))); // Animate mindist\n    \n    minDist -= smoothstep(0.8, 1.0, minDist); // make spaces between voronoi black\n    vec3 col = hue(fract(t * 0.1) + (0.85 *fract(minDist + (t * 0.2))));    // Apply hue color\n    fragColor = vec4(mix(vec3(0), col, minDist),1) ; // final color output\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 456, 456, 597], [600, 600, 657, 657, 2142]], "test": "untested"}
{"id": "sdVGWW", "name": "SDF_Death_Star", "author": "Urnguk", "description": "Something like a death star.. or not.", "tags": ["sdf"], "likes": 3, "viewed": 108, "published": "Public API", "date": "1631583899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 6 );\nconst vec3  light    = vec3  ( 0.0, 1.0, 5.0 );\nconst int   maxSteps = 100;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, float r, in vec3 c )\n{\n\treturn length ( p - c ) - r;\n}\n\nfloat dMoon ( vec3 p, in vec3 c )\n{\n    float rad = length(c.xz);\n    vec3 pos = vec3(rad*sin(0.2*iTime), c.y, rad*cos(0.2*iTime));\n\treturn length ( p - pos ) - 0.2 + 0.005*sin(p.x*50.0 + 3.0*iTime) + 0.007*sin(p.y*20.0) +  0.005*sin(p.z*50.0);\n}\n\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\n    return length ( p.xz - c.xy ) - c.z;\n}\n\nfloat dPlane ( vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length ( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dBox ( vec3 p, vec3 b, vec3 c )\n{\nreturn length ( max ( abs ( p - c ) - b, 0.0 ) );\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    return \n        min(\n            max(\n                max(\n                    dSphere(q, 1.0, vec3(0,0,0)), -dTorus(q, vec2(1.0, 0.05))\n                ), \n                -dSphere(q, 0.4 + 0.005*sin((0.6*q.y + q.z)*100.0), vec3(0, 0.6, 1))\n            ), dMoon(q, vec3(1.5, 1.5, 2.2)) \n        );\n  \n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 1, 1 );\n\t} \n    // output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 185, 212, 212, 359], [361, 399, 426, 426, 573], [575, 575, 621, 621, 653], [655, 655, 690, 690, 901], [904, 904, 933, 933, 1001], [1003, 1003, 1032, 1032, 1119], [1122, 1122, 1155, 1155, 1235], [1237, 1237, 1268, 1268, 1311], [1313, 1313, 1346, 1346, 1383], [1385, 1385, 1417, 1417, 1489], [1491, 1491, 1530, 1530, 1582], [1584, 1584, 1626, 1626, 1696], [1699, 1699, 1735, 1735, 2063], [2065, 2065, 2132, 2132, 2447], [2449, 2449, 2501, 2501, 2870], [2872, 2872, 2929, 2984, 3849]], "test": "untested"}
{"id": "sdVGzG", "name": "My Pulsing Flower", "author": "Drysmall", "description": "A pulsing flower.", "tags": ["cis566"], "likes": 1, "viewed": 22, "published": "Public", "date": "1631754413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n    float t = clamp(d, 0.0, 1.0);\n    \n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\nfloat bias(float t, float b) {\n    return (t/((((1.0/b)-2.0)*(1.0-t))+1.0));\n}\n\nfloat radiusWithAngle(float inner_radius, float bulging_length, float numBulges, float angle){\n    return inner_radius + bias(sin(iTime), 0.1) * clamp(sin(iTime), 0.0, 1.0) *\n           sin(numBulges * angle) * bulging_length;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n    float angle = atan(uv.x - center.x, uv.y - center.y);\n    float radius = radiusWithAngle(0.25 * iResolution.y, 0.125 * iResolution.y, 20.0, angle);\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 113, 150, 150, 199], [201, 264, 325, 325, 437], [439, 499, 554, 554, 828], [830, 830, 860, 860, 908], [910, 910, 1004, 1004, 1138], [1140, 1140, 1197, 1197, 1657]], "test": "untested"}
{"id": "sdy3Dd", "name": "Haru86_PartyHole", "author": "Haru86_", "description": "Raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 123, "published": "Public", "date": "1632405911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\nuniform vec2 resolution;\nuniform float time;\n\n#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat cube(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.));\n}\n\nvec2 fmod(vec2 p,float r){\n  float a=atan(p.x,p.y)+PI/r;\n  float n=(2.*PI)/r;\n  a=floor(a/n)*n;\n  return rot(a)*p;\n}\n\n\nfloat m1(vec3 p){\n p.xz*=rot(iTime);\n\nfor(int i=0;i<5;i++){\n  p=abs(p)-0.5;\n  if(p.x<p.y)p.xy=p.yx;\n  if(p.x<p.z)p.xz=p.zx;\n  if(p.y<p.z)p.yz=p.zy;\n\n  p.xy=fmod(p.xy,24.0);\n p.x-=abs(p.x)-0.5;\n p.y=abs(p.y)-0.15;\n\n float t=floor(iTime*0.25)+pow(fract(iTime*0.25),.5);\n  p.xy*=rot(t+0.123);\n  p.yz*=rot(iTime+0.456);\n   p.xz*=rot(iTime+.789)*1.025;\n\n p.z-abs(p.z)-0.45;\n\n\n\n\n}\n\np.yz=fmod(p.yz,12.0);\np.xz=fmod(p.xz,6.0);\n\n  float m=cube(p,vec3(.5,3.,2.));\n\n\n  return m;\n}\n\nfloat map(vec3 p){\n\n p.z-=iTime*20.;\n\n   float t=floor(iTime*2.0)+pow(fract(iTime*2.0),.75);\np.xy*=rot(t);\n\n  p.xy=fmod(p.xy,12.0);\nfloat k=10.5;\np=mod(p,k)-k*0.5;\n\n  float m=m1(p);\n\n\n  return m;\n}\n\nvec3 gn(vec3 p){\n  vec2 t=vec2(0.001,0.0);\n  return normalize(\n      vec3(\n        map(p+t.xyy)-map(p-t.xyy),\n        map(p+t.yxy)-map(p-t.yxy),\n        map(p+t.yyx)-map(p-t.yyx)\n        )\n    );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st=(gl_FragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n      vec3 ro=vec3(0,0,10.0);\n      vec3 rd=vec3(st,-1.0);\n\n      vec3 col=vec3(0,0,0);\n      float d,t,acc=0.0;\n\n      for(int i=0;i<64;i++){\n        d=map(ro+rd*t);\n        if(d<0.001||t>1000.0)break;\n        t+=d;\n        acc+=exp(-3.0*d);\n      }\n\n    vec3 refo=ro+rd*t;\n     vec3 n=gn(refo);\n    rd=reflect(refo,n);\n    ro=refo;\n    t=0.1;\n    float acc2=0.;\n\n    for(int i=0;i<32;i++){\n      d=map(ro+rd*t);\n      if(d<0.001||t>1000.0){\n        t+=d;\n        acc2=exp(-3.0*d);\n      }\n\n    }\n\n\n    col=vec3(1.,0.5,1.)*acc*0.1;\n    col+=vec3(0.,.5,1.)*acc2*0.075;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3Dd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 170, 170, 207], [209, 209, 235, 235, 325], [328, 328, 345, 345, 797], [799, 799, 817, 817, 996], [998, 998, 1014, 1014, 1195], [1200, 1200, 1257, 1257, 1948]], "test": "untested"}
{"id": "sdy3Rh", "name": "Twisted Squares 2", "author": "jin_x", "description": "One more twisted squares :)", "tags": ["squares", "twist"], "likes": 4, "viewed": 69, "published": "Public", "date": "1631044402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (y = -0.5..0.5, x = -xres/yres/2..xres/yres/2)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.x *= ar;\n\n    // Background\n    float grad = cos(iTime);\n    float mult = (sin((atan(uv.y, uv.x)+iTime*0.3)*20.)+.5)*.2;\n    if (mult < 0.) { mult = 0.; }\n    vec3 col = vec3(mult*(grad+.5), mult*(.5-grad), 0.);\n    \n    float size = .0025;\n    grad = grad*.5 + .5;\n    for (int i = 0; i < 100; ++i) {\n        // Rotate image\n        float a = iTime*(3.-float(i/2)*.07), sa = sin(a), ca = cos(a);\n        vec2 uvr = uv * mat2(ca, -sa, sa, ca);\n        // Calculate color\n        if (abs(uvr.x) < size && abs(uvr.y) < size) {\n            float rg = float(100-i)*.05;\n            if ((i & 1) == 0) { col = vec3(rg*(1.-grad), rg*grad, 1.); }\n            else { col = vec3(0.); }\n            break;\n        }\n        size *= (i & 1) == 0 ? 1.075 : 1.025;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 137, 1059]], "test": "untested"}
{"id": "sdy3RW", "name": "Voxels in 428 chars", "author": "Xor", "description": "How'd I do? Should I publish the original?", "tags": ["voxel", "golf"], "likes": 17, "viewed": 321, "published": "Public", "date": "1631159845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    A tiny voxel renderer in only 480 chars.\n\n    You can turn the camera with the mouse.\n    The level of detail is adjustable!\n    Just change z = 8. to another scale.\n*/\n#define M (length(mod(a,4.)-2.)-2.)\n#define R *= mat2(cos(vec4(0,11,33,0)+c\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 a = iResolution, b=iMouse.xyz,\n    c = 3.*(b/a-.5)*sign(b),\n    d = vec3(a.y,I+I-a.xy),\n    p = d-d; p.x = iTime;\n    d.xz R.y)); d.xy R.x));\n    d /= length(d);\n   \n    float i=0.,z = 8.;\n    for(c = p; i++<1e3 && M*z>.8;)\n    \n        b = min(a = (trunc(c*z+sign(d))-c*z)/d, min(a.y,a.z)).xxx,\n        c += d*b/z,\n        a = (ceil(c*z+d*step(a,b))-.5)/z;\n\n    O = (sin(a.x+vec4(0,2,4,a=c))+1.)*(M*2e1+2.)/(9.+dot(p-=c,p));\n}\n\n/*\n// Original (607 chars):\n\n#define n normalize\n#define m(p) (length(mod(p,4.)-2.)-2.)\n\nfloat t(vec3 p, inout vec3 d)\n{\n    float m,z = 8.;\n    vec3 a,b,c = p;\n    for(int i = 0; i++<999 && z<9.;)\n    {\n        a = sign(d);\n        b = fract(-c*z*a);\n        b += step(b,-b);\n        a *= b/d;\n        b = min(a.xxx,min(a.y,a.z));\n        c += d*b/z;\n        m = m(ceil(c*z+d*step(a,b))/z-.5/z)*z;\n        z *= m<1.8?2.:1.;\n    }\n    d = c;\n    return z;\n}\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 r = iResolution.xy,m=iMouse.xy,\n    a = 3.*(m/r-.5)*sign(m);\n    vec3 x = vec3(cos(a.x+vec2(0,11))*cos(a.y),sin(a.y)),\n    y = n(vec3(-x.y,x.x,0)),\n    z = n(cross(x,y)),\n    \n    d = n(mat3(x,y,z) * vec3(r.y,I+I-r)),\n    p = d-d; p.x=iTime;\n\tfloat h = t(p,d),\n    l = 9./(9.+dot(p-d,p-d));\n    l *= mod(dot(ceil(d),d-d+1.),2.)+.4;\n    O += l*m(d)*h/6.-O;\n}\n*/\n\n/*\n//528 chars:\n\n#define V vec3\n#define m(p) (length(mod(p,4.)-2.)-2.)\n#define R mat2(cos(vec4(0,11,33,0)+a\n\nV t(V p, V d)\n{\n    float z = 8.;\n    V a,b,c = p;\n    for(int i = 0; i++<999 && z<9.;)\n    {\n        a = sign(d);\n        b = fract(-c*z*a);\n        b += step(b,-b);\n        a *= b/d;\n        b = min(a.xxx,min(a.y,a.z));\n        c += d*b/z;\n        z *= m(ceil(c*z+d*step(a,b))/z-.5/z)*z<.8?2.:1.;\n    }\n    return c;\n}\nvoid mainImage(out vec4 O, vec2 I)\n{\n    V r = iResolution, m=iMouse.xyz,\n    a = 3.*(m/r-.5)*sign(m),\n    d = V(r.y,I+I-r.xy),\n    p = d-d; p.x=iTime;\n    d.xz *= R.y)); d.xy *= R.x));\n\tV v = t(p,normalize(d)),\n    l = V(8)+dot(p-v,p-v);\n    l = mod(dot(ceil(v),V(2))+1.,4.)/l;\n    O.rgb = l+l*m(v)/.1;\n}\n*/\n\n/*\n//485 chars:\n\n#define V vec3\n#define m(p) (length(mod(p,4.)-2.)-2.)\n#define R mat2(cos(vec4(0,11,33,0)+c\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    V a = iResolution, b=V(iMouse),\n    c = 3.*(b/a-.5)*sign(b),\n    d = V(a.y,I+I-a.xy),\n    p = V(iTime,0,0);\n    d.xz *= R.y)); d.xy *= R.x));\n    d /= length(d);\n   \n    c = p;\n    float i=0.,z = 8.;\n    for(;i++<1e3 && z<9.;)\n    {\n        a = sign(d);\n        b = fract(-c*z*a);\n        b += step(b,-b);\n        a *= b/d;\n        b = min(a.xxx,min(a.y,a.z));\n        c += d*b/z;\n        z *= m(ceil(c*z+d*step(a,b))/z-.5/z)*z<.8?2.:1.;\n    }\n\n    O.rgb = mod(dot(ceil(c),V(2))+1.,4.)/V(8.+dot(p-c,p-c))*(m(c)/z*1e2+1.);\n}\n*/\n\n/*\n//468 chars:\n\n#define m(p) (length(mod(p,4.)-2.)-2.)\n#define R *= mat2(cos(vec4(0,11,33,0)+c\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 a = iResolution, b=iMouse.xyz,\n    c = 3.*(b/a-.5)*sign(b),\n    d = vec3(a.y,I+I-a.xy),\n    p = d-d; p.x = iTime;\n    d.xz R.y)); d.xy R.x));\n    d /= length(d);\n   \n    float i=0.,z = 8.;\n    for(c = p; i++<1e3 && z<9.; z *= m(a=ceil(c*z+d*step(a,b))/z-.5/z)*z<.8?2.:1.)\n        a = sign(d),\n        b = fract(-c*z*a),\n        a *= (b+step(b,-b))/d,\n        b = min(a.xxx,min(a.y,a.z)),\n        c += d*b/z;\n\n    O = (sin(a.x+vec4(0,2,4,0))+1.)*(m(c)/z*2e2+2.)/(8.+dot(p-c,p-c));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdy3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 253, 289, 289, 726]], "test": "untested"}
{"id": "sdyGRW", "name": "smoothstep test123456789", "author": "JuanDeager", "description": "ye", "tags": ["test"], "likes": 1, "viewed": 38, "published": "Public", "date": "1631157665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float foob = iTime * .5;\n    float myTime = (int(foob) % 2 == 0 ? fract(foob) : 1.0 - fract(foob));\n\n    vec2 loc1 = vec2(myTime, .67);\n    if (distance(uv, loc1) < .01)\n        col = vec3(1);\n\n    vec2 loc2 = vec2(smoothstep(0.0, 1.0, myTime), .33);\n    if (distance(uv, loc2) < .01)\n        col = vec3(1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 607]], "test": "untested"}
{"id": "sdyGWK", "name": "Roksinus", "author": "roknus", "description": "sinus", "tags": ["sinus"], "likes": 1, "viewed": 44, "published": "Public", "date": "1632177914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    \n    float uv = uvTrue.y - .5;\n    \n    //float glowWidth = abs(10. / (500.0 * uv));\n    float glowWidth = 1. - pow(abs(uv + sin(uvTrue.x * 10. + iTime ) / 5.), .13);\n    vec3 color = vec3(glowWidth * 2. , glowWidth, glowWidth);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyGWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 105, 423]], "test": "untested"}
{"id": "ss33D2", "name": "Nirvana2", "author": "debadhir", "description": "Peace and Nirvana2", "tags": ["nirvana2"], "likes": 1, "viewed": 29, "published": "Public", "date": "1630652276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float tex(vec2 uv, float s)\n{    \n    float col;\n    float ntiles = 10.0;\n    \n    // Calculate the shape of the LEDs\n    vec2 r = mod(uv * ntiles, 1.0) - vec2(0.5);\n    col = 1.0 - dot(r, r);\n    \n    // Add some light to the tunnel\n    vec4 n = texture(iChannel1, floor(uv * ntiles) / ntiles);\n    col *= mod(n.r * n.g * n.b * s + iTime * 0.1 + clamp(s, 0.0, 0.6), 1.0);    \n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv1 = uv * 2.0 - 1.0;\n    \n    uv1.x *= iResolution.x / iResolution.y;\n    \n    // Calculate new UV coordinates\n    vec2 center = vec2(0.0, 0.0) + \n        vec2(0.075*(0.5 + 0.5 * sin(iTime*4.0)),\n             0.05*(0.5 + 0.5 * sin(iTime*0.01 + 1.7)));\n    vec2 p = uv1 - center;\n    float r = length(p);\n    float a = atan(p.y, p.x) * 3.0 / 3.14;\n    vec2 uv2= vec2(1.0 / r + iTime*0.25, a);\n\n    // Read the sound texture\n    float sound = texture(iChannel2, vec2(0.01, 1.0 - r)).r;\n    sound = pow(sound, 1.5);\n    \n    // Calculate the colors\n    vec3 c1 = vec3(0.02, 0.1, 4.02);\n    vec3 c2 = mix( vec3(2.0, 0.6, 0.6), vec3(0.6, 0.6, 1.0), vec3(0.5 + 0.5 * sin(iTime*0.1)));\n    vec3 c  = mix(c1, c2, r);\n    vec3 coltunnel =  sound * c * tex(uv2, sound) + ( 0.15 * texture(iChannel0, uv2).rgb);\n    vec3 colback   = vec3(0.15,0.15,0.14);\n\n    // Mix the colors\n\tfragColor = vec4(r * coltunnel + (3.0 - r) * colback, 2.6);\n}\n\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 411], [413, 413, 470, 470, 1451]], "test": "untested"}
{"id": "ss33Rl", "name": "Vapor Cube Durability Testing", "author": "Tater", "description": "cubes", "tags": ["3d", "raymarching", "glow"], "likes": 19, "viewed": 308, "published": "Public API", "date": "1630549573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 220.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nvec3 glow = vec3(0);\nvec3 rlim(vec3 p, float c, vec3 l ){\n    return p-c*clamp(round(p/c),-l,l);\n}\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(43.234,25.433)))*944.3434);\n}\nfloat frame(vec3 p, vec3 b, float e){\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n/*\nfloat ebox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n*/\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n//https://www.desmos.com/calculator/dxixbmrvmb\nfloat easeOutElastic(float x) {\n    float c4 = (2. * pi) / 3.;\n    return x = pow(1.63,-10.*x) * sin((x*5.25-.75)*c4)+1.;\n}\n//I would like to make a more procdeural version of this but so far this one still\n//looks the best. \nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n    if (x < 1. / d1) {\n        return n1 * x * x;\n    } else if (x < 2. / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n}\n//https://www.shadertoy.com/view/fdsXRf\nfloat timeRemap (float t, float s1, float s2){\n    return (s1-s2)*(fract(t)*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;\n}\nvec2 map(vec3 p){\n    float t = iTime*0.8*(6./5.);\n    float ttt = t;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    float m= 2.4;\n    vec2 id = floor(clamp(p.xz,-13.,13.)/m-0.5);\n    float off = 0.;\n    \n    float cycle = mod(floor(t/4.0+0.5),6.0);\n    //cycle = .0;\n    if(cycle == 0.0){\n        t+=length(id+1.0)*0.07;\n    }\n    if(cycle == 1.0){\n        t+=length(id-21.0)*0.07-1.685;\n    }\n    if(cycle == 2.0){\n        if(mod(id.y+mod(id.x,2.0),2.0)<1.0)t+=0.15;\n        id = abs(id+1.);\n        t+=max(id.x,id.y)*0.2;\n        t-=0.15;\n    }\n    if(cycle == 3.0){\n        t+=0.562;\n        t+=id.y*0.08;\n        t+=id.x*0.01;\n    }\n    /*\n    if(cycle == 4.0){\n        t+=0.4;\n        //id=id+1.0;\n        id.y+=1.0;\n        id.x+=7.0;\n        float ang = atan(id.x,id.y)*0.2;\n        t+=ang;\n    }\n    */\n    if(cycle == 4.0){\n        t+=0.3;\n        id+=1.0;\n        t+=(mod(id.y,2.0)*3.0-2.0)*abs(id.x)*0.0175;\n    }\n    if(cycle == 5.0){\n        t+=h21(id);\n    }\n    t = timeRemap(t,1.0,0.0);//changing the third value here makes some interesting bugs\n    \n\n    \n    \n    float tt = t;\n    t = (mod(t,2.0)>1.0)?easeOutBounce(fract(t))+floor(t):easeOutElastic(fract(t))+floor(t);\n    \n    if(mod(tt,2.0)<1.0) off = t-floor(tt);\n    else off = 1.0-(t-floor(tt));\n    \n    //CUBES\n    p.y-=off*13.;\n    p = rlim(p,m,vec3(5,0,5));\n    a.x = box(p,vec3(0.99));\n    //CUBE FRAMES\n    b.x = frame(p,vec3(1.0),0.06)*0.8;\n    float gl = 0.05;\n    glow+=gl/(gl+b.x*b.x)*vec3(0.373,0.200,1.000)*clamp((0.5-abs(0.5-off))*5.0,0.0,1.0);\n    \n    a=(a.x<b.x)?a:b;\n\n    //Domain fuckery\n    //#define rdt(a) pow(smoothstep(0.5,1.0,abs(a)),2.0)*1.0\n    vec3 d = abs(p)-vec3(m/1.7,0,m/1.7);\n    vec3 d2 = abs(po)-m*5.4;\n    float domBox = max(d.x,d.z);\n    float outBox = max(d2.x,d2.z);\n    domBox = min(-outBox,domBox);\n    a.x = min(-domBox,a.x);\n    \n    //Floor\n    p = po;\n    b.x = box(p-vec3(0,-31,0),vec3(13,30,13));\n    b.y = 3.0;\n    a=(a.x<b.x)?a:b;\n    \n    //BOX RINGS\n    t = ttt;\n    float sz = 16.;\n    p.y+=-t*14.0;\n    p.y = pmod(p.y,8.0);\n    b.x = box(p,vec3(sz,1,sz));\n    b.x = max(-box(p,vec3(sz-1.,6,sz-1.)),b.x);\n    b.x = max(po.y-3.,b.x);\n    \n    glow+=0.1/(0.1+b.x*b.x)*vec3(0.733,0.000,1.000)*0.2*smoothstep(4.0,-6.0,po.y);\n    b.y = 5.0;\n    a=(a.x<b.x)?a:b;\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.001,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,12,-30);\n    ro.zx*=rot(iTime*0.15*pi/3.*(6./5.));\n    \n    vec3 lk = vec3(0,2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.7+uv.x*r+uv.y*cross(f,r);\n    vec3 p = vec3(0);\n    vec2 d = vec2(0);\n    float dO = 0.;\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        \n        if((d.x)<0.005){\n            if(d.y == 5.0){\n                d.x = 0.08;\n            }\n            else{\n            hit = true;\n            break;\n            }\n        }\n        if(dO>MDIST){\n            p = ro+rd*MDIST;\n            dO = MDIST;\n            break;\n        }\n        dO+=d.x*0.9;\n    }\n    vec3 al = vec3(0);\n    if(hit){\n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);\n        if(d.y==1.0) al = vec3(0.000,0.984,1.000)*1.4;\n        if(d.y==2.0) al = vec3(0.004,0.137,0.537);\n        if(d.y==3.0) {\n        al = vec3(0.588,0.180,1.000);\n        al+=smoothstep(0.95,1.0,sin(p.x*pi*0.75+pi/2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.y*pi*0.75+2.0))*1.6;\n        al+=smoothstep(0.95,1.0,sin(p.z*pi*0.75+pi/2.0))*1.6;\n        }\n        //Lighting EQs from blackle\n        float diff = length(sin(n*3.)*.5+.5)/sqrt(3.);\n        float spec = length(sin(r*2.)*.4+.6)/sqrt(3.);\n        col = al*diff+pow(spec,8.0)*0.4*vec3(1.000,0.722,0.910);\n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(0.05,n,p)*AO(0.1,n,p);\n        ao*=smoothstep(-.4,.4,map(p+n*.4).x*2.1);\n        col*=pow(ao,0.7);\n    }\n    else{\n        col = mix(vec3(0),vec3(0.055,0.000,0.161),length(pow(uv,vec2(3.0))));\n    \n    }\n    //col = sqrt(col);\n    col+=glow*0.07;\n    fragColor = vec4(col,1.0);\n}\n\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            glow = vec3(0);\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 208, 208, 249], [250, 250, 268, 268, 330], [331, 331, 368, 368, 648], [649, 770, 796, 796, 854], [855, 902, 933, 933, 1025], [1026, 1128, 1158, 1158, 1487], [1488, 1528, 1574, 1574, 1646], [1647, 1647, 1664, 1664, 3969], [3970, 3970, 3988, 3988, 4115], [4117, 4117, 4171, 4171, 5988], [6033, 6033, 6090, 6090, 6532]], "test": "untested"}
{"id": "ss33Wf", "name": "Vidya Mouse Tracker", "author": "vidya", "description": "simple mouse tracking with transparent circle", "tags": ["mousetacking"], "likes": 0, "viewed": 60, "published": "Public", "date": "1630735065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspectRatio;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x *= aspectRatio;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if(length(uv-mouse) < 0.1) {\n        fragColor = vec4(col*0.9, 1.0);\n    }\n    else {\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 553]], "test": "untested"}
{"id": "ss3GDs", "name": "Jack with weird spinning torus", "author": "Spartansky", "description": "Following multiple tutorials from The Art of Code and Inigo Quilez. Then did something weird. Also made a jack on accident which is cool.\n\nFor an extremely broken test version: https://www.shadertoy.com/view/fd33Ds", "tags": ["raymarching", "torus", "beginner"], "likes": 3, "viewed": 61, "published": "Public", "date": "1630864618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPentagon2d( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat GetDist(vec3 p){\n    vec2 torRad = vec2(1.3, 1.);\n    vec2 cp = vec2(length(p.xz) - torRad.x, p.y);\n    float a = atan(p.x, p.z); // polar angle between -pi and pi\n    cp *= Rot(a * 3. + iTime * 3.);\n    cp.y = abs(cp.y) - .3;\n    \n    float d = length(cp) - torRad.y;\n    d = sdPentagon2d(cp, .1) - .1;\n    \n    float t = 1. * abs(sin(iTime * 3.));\n    t = 3.;\n    float displacement = sin(t * p.x) * cos(t * p.y) * sin(t * p.z) * .3;\n    float disp = sin(t * p.x) * sin(t * p.y) * sin(t * p.z) * sin(t * 5.);\n    \n    return min(d + displacement, sdSphere(p, .5) + disp);\n    //return sdSphere(p - vec3(0., 0., 0.), .1);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    \n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lp){\n    vec3 l = normalize(lp - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*2., l);\n    \n    if(d < length(lp - p)) dif *= .6;\n    \n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n    vec3 f = normalize(l - p),\n        r = normalize(cross(vec3(0, 1, 0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u,\n        d = normalize(i);\n        \n     return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14 + 1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0, 0), 1.);\n    vec3 col = vec3 (0.);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        float dif = GetLight(p, vec3(3, 4, -3));\n        dif += GetLight(p, vec3(-3, -4, 3));\n        col = vec3(.2, .9, .2) * dif;\n    }\n    \n    col *= pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3GDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 85, 85, 161], [163, 163, 195, 195, 223], [225, 225, 270, 270, 552], [554, 554, 576, 576, 1184], [1186, 1186, 1219, 1219, 1445], [1446, 1446, 1469, 1469, 1672], [1674, 1674, 1706, 1706, 1925], [1927, 1927, 1976, 1976, 2188], [2190, 2190, 2247, 2247, 2843]], "test": "untested"}
{"id": "ss3SR7", "name": "Ray Marched Portals", "author": "FrostBT", "description": "Ray marchers with portals.\n\nThe \"other world\" is just whenever light passes through a portal.\nNote that the \"other world\" has it's colors swizzled to demonstrate how lighting works through portals.\n\nBased on https://www.shadertoy.com/view/XlGBW3", "tags": ["raymarcher", "portal", "noneuclidean"], "likes": 5, "viewed": 69, "published": "Public", "date": "1633014384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n//\n// Modified by FrostBT\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON .01\n#define PORTAL_TRANSLATE vec3(10, 0, 0)\n#define PORTAL_WIDTH 1.\n\n#define NUM_LIGHTS 3\nvec3[] lightDirs = vec3[NUM_LIGHTS] (\n    vec3(1, .2, -1),\n    vec3(-1, .3, -1),\n    vec3(0, .1, 1)\n);\n\nvec3[] lightCols = vec3[NUM_LIGHTS] (\n    vec3(1.2, .7, .4),\n    vec3(.8, .8, 1.),\n    vec3(.5)\n);\n\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat intersectPlane(\n        vec3 rayOrigin,\n        vec3 rayDirection,\n        vec3 planeNormal,\n        vec3 planeOrigin) {\n    float denom = dot(planeNormal, rayDirection);\n    vec3 p0l0 = planeOrigin - rayOrigin;\n    return dot(p0l0, planeNormal) / denom;\n}\n\nfloat intersectPortal(\n        vec3 rayOrigin,\n        vec3 rayDirection,\n        vec3 planeNormal,\n        vec3 planeOrigin,\n        float t) {\n        \n    if (t < 0.) {\n      return 0.;\n    }\n    \n    vec3 p = rayOrigin + rayDirection * t;\n    p = mod(p + PORTAL_TRANSLATE * .5, PORTAL_TRANSLATE) - PORTAL_TRANSLATE * .5;\n\n    if (abs(p.x) < PORTAL_WIDTH && abs(p.y) < 3.) {\n      return sign(dot(rayDirection, planeNormal));\n    } else {\n      return 0.;\n    }\n}\n\n\n// Note that the \"other world\" and the main world have the same geometry,\n// otherwise one could use a different GetDist depending on which world they\n// were starting in.\nfloat GetDist(vec3 op) {\n\tvec4 s = vec4(0, 1, 0, 1);\n    \n    float d = MAX_DIST;\n    { // Spheres\n        vec3 p = mod(op + PORTAL_TRANSLATE, PORTAL_TRANSLATE * 2.) - PORTAL_TRANSLATE;\n        d = min(d, sdSphere(p + vec3(0, -1, -2.1 + sin(iTime)), 1.));\n    }\n    { // Cubes\n        vec3 p = mod(op, PORTAL_TRANSLATE * 2.) - PORTAL_TRANSLATE;\n        d = min(d, sdBox(p + vec3(0, -1, -2.1 + cos(iTime)), vec3(1.)));\n    }\n    { // Frame\n        vec3 p = mod(op + PORTAL_TRANSLATE*.5, PORTAL_TRANSLATE) - PORTAL_TRANSLATE*.5;\n        p.x = -abs(p.x);\n        d = min(d, sdBox(p + vec3(PORTAL_WIDTH, 0, 0), vec3(.1, 3, .1)));\n        d = min(d, sdBox(p + vec3(0, -3, 0), vec3(PORTAL_WIDTH+.1, .1, .1)));\n    }\n\n    d = min(d, op.y);\n    return d;\n}\n\nmat3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    float world = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        // Calculate step.\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        \n        // Determine if we passed through a portal.\n        float t = intersectPlane(p, rd, vec3(0, 0, 1), vec3(0));\n        float portal = intersectPortal(p, rd, vec3(0, 0, 1), vec3(0), t);\n        if (portal != 0. && t < dS) {\n          ro += PORTAL_TRANSLATE;\n          dS = t + EPSILON;\n          world += sign(dot(rd, vec3(0, 0, 1)));\n        }\n        \n        // Determine if we should stop.\n        dO += dS;\n        if (dO>MAX_DIST) {\n            dO = MAX_DIST;\n            break;\n        } else if (dS<EPSILON) {\n            break;\n        }\n    }\n    \n    mat3 result;\n    result[0] = vec3(ro + rd * dO);\n    result[1] = vec3(dO, 0, 0);\n    result[2] = vec3(world, 0, 0);\n    return result;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetSun(vec3 p, vec3 lightAngle, vec3 lightCol, float world) {\n    vec3 l = normalize(lightAngle);\n    vec3 n = GetNormal(p);\n    \n    // Shadow\n    float dif = clamp(dot(n, l), 0., 1.);\n    mat3 hit = RayMarch(p+n*EPSILON*2., l);\n    float d = hit[1].x;\n    world += hit[2].x;\n    if(d < MAX_DIST) dif = 0.;\n    \n    // The other world gets other lighting.\n    if (world != 0.) {\n      lightCol.xyz = lightCol.zxy;\n    }\n    \n    return lightCol * dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Who doesn't like interaction? (even if minimal)\n    float mouseX = iMouse.x/iResolution.x;\n    float mouseY = iMouse.y/iResolution.x;\n    vec3 focus = vec3(0, 1, 0);\n    vec3 ro = vec3(sin(mouseX)*-8. + iTime, (-sin(mouseY)+.7)*4., -10.);\n    vec3 at = ro - focus;\n    \n    // Point camera at origin (overkill for this example)\n    vec3 camZ = -normalize(at);\n    vec3 camX = cross(vec3(0, 1, 0), camZ);\n    vec3 camY = -cross(camX, camZ);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    fragColor = vec4(normalize(uv.x*camX + uv.y*camY + camZ),1.);\n\n    // Distance\n    mat3 hit = RayMarch(ro, rd);\n    vec3 p = hit[0];\n    float d = hit[1].x;\n    float world = hit[2].x;\n\n    vec3 lights = vec3(0);\n    for (int iLight = 0; iLight < NUM_LIGHTS; iLight++) {\n      lights += GetSun(p, lightDirs[iLight], lightCols[iLight], world);\n    }\n    col = vec3(lights);\n    \n    \n    // Sky color\n    vec3 sky = vec3(0);\n    for (int iLight = 0; iLight < NUM_LIGHTS; iLight++) {\n      float amount = clamp(dot(rd, lightDirs[iLight]), 0., 1.);\n      sky += amount * lightCols[iLight];\n    }\n    \n    // Fade off\n    col = mix(col, sky, d/MAX_DIST);\n    \n    // Gamma correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3SR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 663, 696, 696, 722], [724, 724, 755, 755, 846], [848, 848, 974, 974, 1110], [1112, 1112, 1256, 1256, 1578], [1581, 1753, 1777, 1777, 2501], [2503, 2503, 2536, 2536, 3413], [3415, 3415, 3439, 3439, 3628], [3630, 3630, 3696, 3696, 4089], [4091, 4091, 4148, 4148, 5490]], "test": "untested"}
{"id": "ss3SRn", "name": "Fractal 82_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 34, "viewed": 371, "published": "Public", "date": "1632471200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    float i=0.,g=0.,e,s;\n    for(;i++<99.;)\n    {\n        p=g*d-vec3(.05*sin(iTime*.5),.1,1.8);\n        p=R(p,normalize(vec3(1,-2,2)),iTime*.5);\n        s=2.;\n        vec4 q=vec4(p,sin(iTime*.4)*.5);\n\t\tfor(int j=0;j++<8;)\n        {\n            q=abs(q);\n            q=q.x<q.y?q.zwxy:q.zwyx;\n            s*=e=2.3/clamp(dot(q,q),.2,1.5);\n            q=q*e-vec4(1,4,2,1);\n        }\n        g+=e=min(\n                length(q.w)/s,\n                length(cross(q.xyw,vec3(.577)))/s-.3e-4\n            )+.001;\n        O.rgb+=mix(r/r,H(log(s)*2.),.3)*.015*exp(-.03*i*i*e);\n    }\n    O*=O*O*O;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3SRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 140, 140, 812]], "test": "untested"}
{"id": "sscGWB", "name": "Colorful Recursive Squares", "author": "pdkl95", "description": "Just some layered grids that fade to simulate depth. Also features pseudo-random colors that derive from a hash of the local cell coordinate.", "tags": ["grid", "recursvelayers", "hashcolor"], "likes": 5, "viewed": 55, "published": "Public", "date": "1630575636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n\n#define MAXSTEPS 8.0\n#define CELLSIZE 128.0\n#define EDGESIZE 0.05\n#define SHRINK   0.93\n#define ROTSIZE  (TAU/256.0)\n#define ROTSPEED 0.85\n#define MOUSEAMP 4.0\n#define DRIFTSPEED vec2(1.2, 1.8)\n\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 point, in float rads)\n{\n    float cs = cos(rads);\n    float sn = sin(rads);\n    return point * mat2(cs, -sn, sn, cs);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 px = fragCoord.xy - (iResolution.xy / 2.0);\n    vec2 position = px / CELLSIZE;\n    vec3 color = vec3(1.0);\n\n    vec2 drift = iTime * DRIFTSPEED;\n    position += drift;\n\n    vec2 mouse = ((iMouse.xy/iResolution.xy) * 2.0) - 1.0;\n    vec2 smouse = vec2(0.0);\n    if (mouse.x > -1.0) {\n        smouse = mouse * (1.0/SHRINK) * MOUSEAMP;\n    }\n\n    vec2 rpos = position;\n    for (float i = 0.0; i < 1.0; i += (1.0/MAXSTEPS)) {\n        vec2 cellnum = floor(rpos);\n        vec2 cellpos = fract(rpos);\n        //cellpos = abs((cellpos * 2.0) - 1.0);\n\n        float cellhash = hash21(cellnum);\n\n        if ((min(cellpos.x, cellpos.y) < EDGESIZE) ||\n            (max(cellpos.x, cellpos.y) > (1.0 - EDGESIZE))) {\n            color = hsv2rgb(vec3(cellhash, (1.0-i) * 0.78, 0.95));\n            break;\n        }\n\n        rpos -= drift;\n        rpos -= smouse;\n        rpos /= SHRINK;\n        rpos = rotate(rpos, ROTSIZE * sin( iTime * ROTSPEED ));  \n        rpos += smouse;\n        rpos += drift;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 325, 325, 494], [496, 496, 539, 539, 635], [637, 637, 692, 692, 1731]], "test": "untested"}
{"id": "sscSDn", "name": "Geometric Lanterns", "author": "Flopine", "description": "What a creativity boost it is! To be able to experiment on a new technique :D <3", "tags": ["raymarching", "repetition", "animation", "glow"], "likes": 11, "viewed": 124, "published": "Public", "date": "1632920609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// Still exploring repetition trick presenting by Blackle on Perfect Pistons <3 \n// https://youtu.be/I8fmkLK1OKg\n// https://www.shadertoy.com/view/WtXcWB\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define od(p,d) (dot(p,normalize(sign(p)))-d)\n#define hash21(x) fract(sin(dot(x,vec2(13.4,32.7)))*134.5) \n\nvec2 edge (vec2 p)\n{\n    vec2 p2 = abs(p);\n    return (p2.x>p2.y) ? vec2((p.x<0.) ? -1. : 1., 0.) : vec2(0., (p.y<0.) ? -1. : 1.);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = max(abs(p),abs(p.yzx));\n    return min(p.x, min(p.y,p.z))-d;\n}\n\nfloat g1=0.;\nfloat prim1 (vec3 p, float size) \n{\n    float odile = od(p,size*.75);\n    g1 += 0.001/(0.001+odile*odile);\n    return min(odile,\n                max(-sc(p,size*.75),\n                     box(p,vec3(size))\n                   )\n               );\n}\n\nvec2 center;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    vec2 id = floor(p.yz)+.5;\n    p.y += (mod(id.y,2.)<=0.5) ? iTime*0.2 : -iTime*0.2;\n    center = floor(p.yz)+.5; \n    vec2 neighbour = center+edge(p.yz-center);    \n    \n    float size = clamp(hash21(center+0.5)/2.,0.1,0.36),\n    me = prim1(p-vec3(0.,center),size),\n    next = box(p-vec3(0.,neighbour),vec3(0.45));\n    \n    return min(me,next);\n}\n\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return clamp(SDF(p+eps*n)/eps,0.,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(uv*3.,-30.), rd=vec3(0.,0.,1.), p=ro,\n    col = vec3(0.), l = normalize(vec3(1.5,-2.,-2.));\n\n    bool hit = false;\n    for (float i=0.;i<100.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {hit = true; break;}\n        d *= 0.95+dither*0.1;\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.), ao = AO(0.1,p,n)+AO(0.2,p,n)+AO(0.38,p,n);\n        col = vec3(light)*ao/3.;\n    }\n\n    col += g1*0.2*vec3(0.45,.8,hash21(center));\n\n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[370, 725, 745, 745, 857], [859, 859, 887, 887, 972], [974, 974, 1002, 1002, 1073], [1088, 1088, 1123, 1123, 1333], [1348, 1348, 1368, 1368, 1784], [1787, 1787, 1810, 1810, 1923], [1925, 1925, 1963, 1963, 2001], [2003, 2003, 2060, 2060, 2731]], "test": "untested"}
{"id": "sscXWn", "name": "Torus flip", "author": "fizzgig", "description": "how you turn a torus inside out by cheating", "tags": ["torus", "stereographic", "flip"], "likes": 3, "viewed": 154, "published": "Public API", "date": "1632921619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nvec4 stereographicProj(vec3 point) {\n    vec4 p4 = vec4(point, 2.0);\n    float norm = length(p4);\n    return 4.0*p4/(norm*norm) - vec4(vec3(0.0),1.0);\n}\n\nfloat torus4SDF(vec4 point, vec4 pl1, vec4 pl2, float radius) {\n    float dp1 = dot(point,pl1);\n    float dp2 = dot(point,pl2);\n    vec4 pp = pl1*dp1 + pl2*dp2;\n    vec4 ppp = point - pp;\n    vec4 cp = pp/length(pp);\n    vec4 ppmcp = pp-cp;\n    return sqrt(dot(ppmcp,ppmcp) + dot(ppp,ppp)) - radius;\n}\n\nfloat sceneSDF(vec3 point) {\n    float theta = iTime;//PI/2.0*sin(iTime)*sin(iTime);\n    return torus4SDF(stereographicProj(point), \n                    vec4(0.0,1.0,0.0,0.0),\n                    vec4(cos(theta),0.0,0.0,sin(theta)),\n                    0.8);\n    /*return min(\n        min(\n            min(\n                sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n                sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n            ),\n            sphereSDF(vec3(0.0), 1.0, point)\n        ),\n        planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n      );*/\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(1.0, 0.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(0.0, 1.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(20.0*cos(lightangle), 5.0, 20.0*sin(lightangle)), 1000.0, vec3(0.0, 0.0, 1.0));\n    \n    float disttoscreen = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(5.0, 2.0*cos(iTime*2.0+PI) + 6.0, -7.0 + 3.0*cos(iTime*2.0+PI));\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(0.7 + 0.4*cos(iTime*2.0+PI), 0.5, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    bool invert = scenedist < 0.0;\n    if (invert) scenedist = -scenedist;\n    float raydist = 0.0;\n    \n    float epsilon = 0.01;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = invert ? -sceneSDF(point) : sceneSDF(point);\n        \n        raydist += scenedist;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.3));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscXWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1338, 1338, 1454], [1456, 1456, 1519, 1519, 1757], [1759, 1759, 1787, 1787, 2325], [2327, 2327, 2377, 2377, 2733], [2735, 2735, 2768, 2768, 2823], [2825, 2825, 2861, 2861, 2909], [2911, 2911, 2940, 2940, 2998], [3000, 3000, 3109, 3109, 3549], [3551, 3551, 3608, 3608, 5525]], "test": "untested"}
{"id": "ssG3DK", "name": "Punctured Torus Deformation", "author": "stevejtrettel", "description": "Just a first test of making a hyperbolic tiling in shadertoy", "tags": ["hyperbolic"], "likes": 2, "viewed": 47, "published": "Public", "date": "1632186855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A tiling of the hyperbolic plane by ideal quadrilaterals determines a punctured torus\n//by taking each pair of opposite sides, and gluing them with the hyperbolic isometry\n// which identifies the closest pair of points on each to one another.\n//To draw this tiling, instead of translating by these isometries,\n//I generate it by reflecting in the sides\n\n\n\n\n//------------------------------------------\n//Define hyperbolic half spaces, reflections\n//------------------------------------------\n\n//vertical line to reflect in\n//side=+1 means the half space contains points to the right, -1 to the left\nstruct Line{\nfloat pos;\nfloat side;\n};\n\n\n//semicircle centered on real line to reflect in\n//side =+1 means the halfspace contains points below, -1 means above\nstruct Circle{\nfloat center;\nfloat radius;\nfloat side;\n};\n\n\n\n//reflection in vertical line defining a half space\n//this is done by conjugating reflection in the line x=0\n//by the translation taking this line there\nvoid invert(inout vec2 p, Line line){\n\n    p.x -= line.pos;\n    \n    p.x *= -1.;\n    \n    p.x += line.pos;\n    \n}\n\n\n\n//reflection in a circle defining a half space\n//this is done by conjugating inversion in the unit circle\n//with a similarity transformation taking the given circle to the unit circle\nvoid invert(inout vec2 p, Circle circle){\n\n    p.x -= circle.center;\n    p /= circle.radius;\n    \n    p /= dot(p,p);\n    \n    p *= circle.radius;\n    p.x += circle.center;\n \n}\n\n//check if inside a half space bounded by a line:\nbool inside(vec2 p, Line line){\n    if(line.side>0.){//check if we are on the right side\n        return p.x>line.pos;\n    }\n    else{//check if we are on the left side\n        return p.x<line.pos;\n    }\n}\n\n//check if inside a half space bounded by a circle\nbool inside(vec2 p, Circle circle){\n    if(circle.side>0.){//check if we are inside the semicircle\n        return length(p-vec2(circle.center,0))<circle.radius;\n    }\n    else{//check if we are outside the semicircle\n        return length(p-vec2(circle.center,0))>circle.radius;\n    }\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n//Give names to the sides of the shape\nLine side0;\nLine side1;\nCircle side2;\nCircle side3;\n\n\n//function that defines these sides in terms of two deformation parameters a,b\n//this generates a quadrilateral with vertices at infinity, -a, 0 and b.\nvoid setUpFD(float a, float b){\n\nside0=Line(-1.*a,1.);\nside1=Line(b,-1.);\nside2=Circle(-a/2.,a/2.,-1.);\nside3=Circle(b/2.,b/2.,-1.);\n\n}\n\n\n\n//------------------------------------------\n//reflect points into fundamental domain\n//------------------------------------------\n\n\n//this function takes in a point p, and looks at each side of the fundamental domain\n//if p is not within the half space defined by that side, we reflect it\n//if p is already in that half space, we leave it alone\nvoid reflectInFD(inout vec2 p,inout float invCount){\n\n   \n        if(!inside(p,side0)){\n            invert(p,side0);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side1)){\n            invert(p,side1);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side2)){\n            invert(p,side2);\n            invCount+=1.;\n        }\n        \n        if(!inside(p,side3)){\n            invert(p,side3);\n            invCount+=1.;\n        }\n    \n}\n\n\n\n//this function checks if p is inside our fundamental domain or not\nbool insideFD(vec2 p){\n  return inside(p,side0)&&inside(p,side1)&&inside(p,side2)&&inside(p,side3);\n}\n\n\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec2 p,inout float invCount){\n  \n    \n    for(int i=0;i<20;i++){\n    \n        reflectInFD(p,invCount);\n    \n    if(insideFD(p)){\n            break;\n         }\n  \n    }\n}\n\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n    \n    //rescale this how you like\n    uv = 4.*vec2(1,iResolution.y/iResolution.x)*uv;\n    \n    return uv;\n}\n\n\n\n\n//starting from Poincare Disk:\n//if you want to draw this picture in the half plane (where we did the computation)\n//simply delete the contents of this function and just have it \"return uv\"\nvec2 toUHP(vec2 uv){\n\n//do a rotation slowly\n    float c=cos(iTime/5.);\n    float s=sin(iTime/5.);\n    uv=mat2(c,s,-s,c)*uv;\n    \n\n//move to half plane\n    float Re = 2.*uv.x;\n    float Im = 1.-dot(uv,uv);\n    vec2 temp=vec2(1.-uv.y,uv.x);\n    float Scale = dot(temp,temp);\n    return 1./Scale*vec2(Re,Im);\n   \n\n    //return uv;\n  }\n  \n  \n//just packing the sinusoidal oscillation which oscillates between a and b into its own function\nfloat osc(float a,float b, float t){\nreturn abs(b-a)/2.*(1.+sin(t))+a;\n}\n\n\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n    \n    //if you are outside the poincare disk, make black\n    if(length(uv)>1.){\n        fragColor=vec4(0,0,0,1);\n        return;\n      }\n    \n    //map to upper half plane for computation:\n    vec2 p = toUHP(uv);\n    \n    //setup the fundamental domain we are working with\n    setUpFD(osc(0.01,1.,iTime/3.),osc(0.5,2.5,iTime/1.));\n   \n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n\n    // color the pixel based on this\n    //right now this is a very boring coloring: \n    //we just count if theres an even or odd number of reflections!\n    float evenOdd=mod(invCount,2.);\n    vec3 col=vec3(0.3,0.6-evenOdd,evenOdd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssG3DK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[821, 974, 1011, 1011, 1087], [1091, 1275, 1316, 1316, 1450], [1452, 1502, 1533, 1533, 1706], [1708, 1759, 1794, 1794, 2045], [2267, 2419, 2450, 2450, 2554], [2691, 2904, 2956, 2956, 3375], [3379, 3447, 3469, 3469, 3548], [3553, 3734, 3783, 3783, 3923], [4065, 4193, 4234, 4291, 4453], [4458, 4648, 4668, 4692, 4980], [4987, 5084, 5120, 5120, 5156], [5161, 5276, 5333, 5357, 6125]], "test": "untested"}
{"id": "ssGGRd", "name": "a~–@~@•@•@–•–", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 2, "viewed": 36, "published": "Public", "date": "1631944287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nfloat ease(float x) {\n    x = clamp(x, 0., 1.);\n    return smoothstep(0., 1., x);\n}\n\nfloat ripple(vec2 uv, vec2 lightDir, float scale, float time) {\n    \n    return sin(\n        length(uv) * scale - time * TAU\n    ) * dot(\n        lightDir,\n        normalize(uv) *\n        ease(length(uv) * scale * 0.5)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 10.0);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    vec2 lightDir = vec2(sin(time * TAU), cos(time * TAU));\n    \n    vec2 center0 = 0.5*vec2(sin(TAU*time), cos(TAU*time));\n    vec2 center1 = 0.5*vec2(sin(TAU*(time+1./3.)), cos(TAU*(time+1./3.)));\n    vec2 center2 = 0.5*vec2(sin(TAU*(time-1./3.)), cos(TAU*(time-1./3.)));\n    \n    const float sizeScale = 30.;\n    const float timeScale = 10.;\n    \n    vec3 col = HEX(0x4080c0) + 0.15 * (\n        ripple(\n            uv - center0, lightDir,\n            sizeScale, 0.2 + time * timeScale\n        ) + ripple(\n            uv - center1, lightDir,\n            sizeScale, 0.4 + time * timeScale\n        ) + ripple(\n            uv - center2, lightDir,\n            sizeScale, 0.8 + time * timeScale\n        )\n    );\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 119, 119, 181], [183, 183, 246, 246, 410], [412, 412, 469, 497, 1432]], "test": "untested"}
{"id": "ssGGW1", "name": "CG1", "author": "helgust", "description": "Simple Shader", "tags": ["phong", "cg"], "likes": 1, "viewed": 17, "published": "Public", "date": "1632149541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 eye = vec3(0,0,10);\nconst vec3 light = vec3(0.0,5.0,10.0);\nconst int maxSteps = 100;\nconst float eps = 0.01;\n\n\nfloat smin (float a, float b, float k)\n{\n    float res = exp(-k*a)+exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\nreturn length ( p.xz - c.xy ) - c.z+0.03* cos(5.0*p.y + iTime)+0.02 * sin(20.0*p.z + iTime) ;\n}\n\nfloat dSphere (vec3 p, vec3 c)\n{\n    return length(p - c) - 1.0 +0.03 * sin(20.0*p.y + iTime);\n}\n\nfloat dEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat length8 (in vec2 p)\n{\n    return pow(pow(p.x,8.0) + pow (p.y,8.0),1.0/8.0);\n}\n\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus (vec3 p, vec3 t)\n{\n    vec2  q=vec2(length8 (p.xz) - t.x,p.y);\n    return length8(q) - t.y;\n}\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1,0,0),\n            vec3(0,c,-s),\n            vec3(0,s,c));\n}\n\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,-s,0),\n            vec3(s,c,0),\n            vec3(0,0,1));\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,0,s),\n            vec3(0,1,0),\n            vec3(-s,0,c));\n}\n\nfloat sdf (in vec3 p,in mat3 m)\n{\n    vec3 q = m*p;\n    vec3 o = q*rotateX(90.0);\n    \n    return smin(smin(dEllipsoid(q,vec3(1,5,1)),dCyl(rotateX(-90.0)*q,vec3(0,0,1)),7.0),smin(dSphere(q,vec3(0,5,0)),dSphere(q,vec3(0,-5,0)),8.0),9.0);\n}  \nvec3 generateNormal (vec3 z, float d,in mat3 m)\n{\n    float e  = max(d * 0.5,eps);\n    float dx1 = sdf(z+ vec3(e,0,0),m);\n    float dx2 = sdf(z- vec3(e,0,0),m);\n    float dy1 = sdf(z+ vec3(0,e,0),m);\n    float dy2 = sdf(z- vec3(0,e,0),m);\n    float dz1 = sdf(z+ vec3(0,0,e),m);\n    float dz2 = sdf(z- vec3(0,0,e),m);\n    \n    return normalize (vec3 (dx1 - dx2,dy1-dy2,dz1-dz2));\n}\n\n\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.0;\n    \n    hit =false;\n    \n    for (int steps = 0; steps < maxSteps; steps++)\n    {\n        float dist = sdf(p,m);\n        \n        if(dist < 0.001)\n        {\n            hit = true;\n        }\n        totalDist+=dist;\n        \n        if(totalDist > 20.0)\n            break;\n           p+=dist*dir;\n    }\n    \n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 12.0 * iResolution.xy / max(iResolution.x,iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2 (0.5));\n    vec3 dir = normalize (vec3 (uv,0) - eye);\n    vec4 color = vec4(0,0,0,1);\n    vec3 p = trace(eye,dir,hit,m);\n    \n    if(hit)\n    {\n     vec3 l = normalize(light - p);\n     vec3 v = normalize(eye - p);\n     vec3 n = generateNormal(p,0.001,m);\n     vec3 r = l-2.0*max(0.0,dot(l,n))*n;\n     float nl = max(0.0,dot(n,l));\n     vec3 h = normalize(l+v);\n     float hn = max(0.0,dot(-v,r));\n     float sp = pow (hn,90.0);\n     \n     \n     color = 0.5*vec4(nl) + sp*vec4(1,0,0,1);\n    }\n\n    // Output   to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 162, 162, 225], [227, 227, 259, 259, 330], [332, 332, 363, 363, 459], [461, 461, 493, 493, 557], [559, 559, 595, 595, 678], [680, 680, 707, 707, 763], [766, 766, 795, 795, 882], [885, 885, 916, 916, 991], [993, 993, 1020, 1020, 1155], [1157, 1157, 1184, 1184, 1319], [1321, 1321, 1348, 1348, 1483], [1485, 1485, 1518, 1518, 1723], [1726, 1726, 1775, 1775, 2106], [2110, 2110, 2174, 2174, 2545], [2546, 2546, 2603, 2653, 3469]], "test": "untested"}
{"id": "ssGGWw", "name": "Wet beach sand", "author": "jarble", "description": "Based on wachel's [url=https://www.shadertoy.com/view/ltcGDl]desert terrain[/url], inspired by TekF's [url=https://www.shadertoy.com/view/ldfXzS]\"Wet Sand\" terrain[/url].", "tags": ["terrain", "sand", "dune", "beach"], "likes": 11, "viewed": 214, "published": "Public API", "date": "1631639657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//thank for https://www.shadertoy.com/view/MdX3Rr by iq\n\n#define PI 3.14159265359\n\n\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x/2.)+cos(uv.y*2.);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    for (int i = 0; i < octaves; i++)\n    {\n        n1 = (noise(uv * freq-n1)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-(n1) * amplitude);\n        \n        amplitude *= 1./3.;\n        \n        freq *= 2.;\n        \n        uv = uv.yx;\n        value *= .6+.1*noise(uv+n1*value);\n        \n        //value *= .9;\n\n}\n    \n    return value;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\nfloat terrainH( in vec2 p)\n{\n    p.x += iTime/2.;\n    return fbm(p*1.5)*1.5;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.1;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1./8.;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col = render( vec3(time,1.8,0.0), rd );\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 110, 110, 150], [171, 171, 206, 255, 742], [744, 744, 766, 766, 796], [797, 797, 825, 825, 875], [877, 877, 920, 941, 1194], [1197, 1197, 1270, 1270, 1458], [1461, 1461, 1502, 1502, 1743], [1745, 1745, 1784, 1784, 3253], [3255, 3255, 3312, 3312, 4174]], "test": "untested"}
{"id": "ssGGzD", "name": "jiahao：【CRT1-1】标准CRT，好理解", "author": "LokaHer", "description": "      ", "tags": [], "likes": 0, "viewed": 68, "published": "Public", "date": "1631255047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat scanline(vec2 coord){\n    //coord.y范围：【0,iResolution.y】\n    float sinNum = 10.0;//一个画面存在多少个正弦波\n    float scale = iResolution.y/sinNum;//每个正弦波的长度占多少像素\n    float intensity = 0.2;//叠加的强度\n    float speed = 1.0; //每秒走掉正弦波的数量\n\n\treturn sin(2.*3.1415926*coord.y/scale - 2.*3.1415926*iTime) * intensity; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor.rgb = texture(iChannel0, uv).rgb;\n\n\tfragColor.rgb += scanline(fragCoord);\n}\n\n", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 72, 394], [397, 397, 453, 453, 582]], "test": "untested"}
{"id": "ssK3Dt", "name": "Moving Star Constellations", "author": "Scintoth", "description": "Modified version of https://www.shadertoy.com/view/3lsGW2", "tags": ["stars"], "likes": 2, "viewed": 183, "published": "Public API", "date": "1632427907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distLine( vec2 p, vec2 a, vec2 b){\n    vec2 pa = (p - a) / 2.0;\n    vec2 ba = (b - a) / 2.0;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0,1.0);\n    return length(pa - ba*t);\n}\n\nfloat noiseFloat(vec2 p){\n    p = fract(p * vec2(213.53, 970.19));\n    p = p + dot(p, p+548.23);\n    return fract(p.x * p.y);\n}\n\nvec2 noiseVector(vec2 p){\nfloat n = noiseFloat(p);\n    return vec2(n, noiseFloat(p+n) * 1.0);\n}\n\n\nvec2 GetPos(vec2 id, vec2 offsets){\nvec2 n = noiseVector(id + offsets) * 500.0 * ((iDate.w + 8000.0 + iTime) / 50000.0);\n    return (sin(n) * 0.9) + offsets;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = smoothstep(0.15, 0.01, d * 10.0);\n    m = m * smoothstep(0.9, 0.32, length(a-b));\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord -1.0*iResolution.xy)/iResolution.y * 6.0;\n\t\n    float m = 0.0;\n    uv = uv * 10.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for(float y = -1.0; y<=1.0; y++){\n    \tfor(float x = -1.0; x<=1.0; x++){\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    for(int i=0; i<9; i++){\n    \tm = m + Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 2.0;\n        float sparkle = 0.1/dot(j, j) * (50.0 / (8000.0 + iTime));\n      \n        m = m + sparkle * (sin(((8000.0 + iTime)+p[i].x)* 0.5)*0.5 + 0.9);\n    }\n    \n    m = m + Line(gv, p[1], p[3]);\n    m = m + Line(gv, p[1], p[5]);\n    m = m + Line(gv, p[7], p[3]);\n    m = m + Line(gv, p[7], p[5]);\n    \n    vec3 col = vec3(m * 0.28, m * 0.28, m * 0.4);    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3Dt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 185], [187, 187, 212, 212, 314], [316, 316, 341, 341, 411], [414, 414, 449, 449, 573], [575, 575, 610, 610, 751], [754, 754, 811, 861, 1733]], "test": "untested"}
{"id": "ssK3DW", "name": "ray tracer Yeganeh", "author": "Unique417", "description": "ray tracer", "tags": ["reflection", "shadow", "pointlight"], "likes": 0, "viewed": 30, "published": "Public", "date": "1631594538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Camera\n{\n    vec3 position;\n    float cameraDistance;\n};\n\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambient;\n    float reflection;\n};\n    \nconst Material material1 = Material(0.6, 0.3, 50., 1., 1.);\nconst Material material2 = Material(0.4, 0.4, 100., 0.2, 1.);\n    \n#define SPHERES_COUNT 2\nstruct Sphere \n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    Material material;\n} spheres[SPHERES_COUNT];   \n\nstruct Point_Light\n{\n    vec3 position;\n    vec3 color; // Not used for now\n    float intensity;\n} lights[1];\n    \nconst Sphere sphere1 = Sphere(vec3(0.0, 0., 0.),vec3(0.1, 0.4, 0.3), 0.1,\tmaterial1);\n\nconst Camera camera = Camera( vec3(0., 0., -0.2), 0.4);\n\nPoint_Light light1 = Point_Light(vec3(0.1, 0.2, -0.2), vec3(1., 1., 1.), 30.);                \n\n# define PLANES_COUNT 1\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n    Material material;\n} planes[PLANES_COUNT];\n\nPlane surface = Plane(vec3(0., -0.4, 0.), vec3(0., 1., 0.2),vec3(1., 1., 1.), material2);\n\n#define SPHERE 0\n#define PLANE 1\n\nvoid setupScene()\n{\n\tspheres[0] = sphere1;\n    \n    planes[0] = surface;\n    \n    lights[0] = light1;\n}    \n\nbool quadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nMaterial getMaterial(int type, int index)\n{\n    if (type == SPHERE)\n    {\n        return spheres[index].material;\n    }\n    \n    if (type == PLANE)\n    {\n        return planes[index].material;\n    }\n}\n\nbool intersectSphere(\n    vec3 origin, \n    vec3 direction, \n    Sphere sphere, \n    out float dist, \n    out vec3 surfaceNormal, \n    out vec3 Hit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (quadratic(a, b, c, t0, t1))\n    {        \n        if (t0 > t1) \n        {\n        \tfloat temp = t0;\n            t0 = t1;\n            t1 = temp;\n        } \n \n        if (t0 < 0.)\n        { \n            t0 = t1; \n            if (t0 < 0.) return false; \n        }  \n             \n        dist = t0;\n       \n        Hit = origin + dist * direction;\n        surfaceNormal = normalize(Hit - sphere.position);               \n        \n        return true;\n    }  \n     \n    return false;\n}\n\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float t, out vec3 hit) \n{    \n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        t = dot(p0l0, plane.normal) / denom; \n        \n        if (t >= 0.)\n        {\n            hit = origin + rayDirection * t;\n            return true;\n        }             \n    } \n \n    return false; \n} \n\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in Point_Light Point_Light, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - Point_Light.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.1, 2.) / pow(length(lightVector), 2.)) * Point_Light.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambient * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.0), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\nvoid shadow(vec3 hit, inout vec3 finalColor, float ambient, int type, int index)\n{\n    vec3 shadowSurfaceNormal;\n    vec3 shadowRay = lights[0].position - hit;\n    vec3 shadowRayDirection = normalize(shadowRay);\n    float distanceToLight = sqrt(dot(shadowRay, shadowRay));\n    vec3 shadowHit;\n    \n    float dist; \n    \n    for(int i = 0; i < 2; ++i)\n\t{\n        if (type == SPHERE && index == i)\n        {\n            continue;  \n        }\n    \n        if (intersectSphere(hit, shadowRay, spheres[i], dist, shadowSurfaceNormal, shadowHit))\n        {\n            if (dist > 0. && distanceToLight > dist)\n            {\n            \tfinalColor *= 2. * ambient;\n            }\n        }\n    }\n    \n    for(int i = 0; i < PLANES_COUNT; ++i)\n\t{\n \t\tif (type == PLANE && index == i)\n        {\n            continue;\n        }\n        \n        if (intersectPlane(planes[i], hit, shadowRay, dist, shadowHit))\n        {    \n            if (dist < distanceToLight)\n            {                \n \t\t\t\tfinalColor *= 2. * ambient;        \n            }\n        }\n    }     \n}\n\nvec3 rayTrace(in vec3 rayDirection, in vec3 rayOrigin)\n{\n    vec3 finalColor = vec3(0.);\n    \n    int BOUNCES = 2;\n    \n    int prevType = -1;\n    int prevIndex = -1;  \n   \n\tvec3 hit = rayOrigin; \n    vec3 passHit;\n    \n    for (int bounce = 0; bounce < BOUNCES; bounce++)\n    {    \n        float dist = 1. / 0.;\n        float objectHitDistance = dist;\n \n        vec3 surfaceNormal;\n        \n        int type = -1;\n    \tint index = -1;   \n        \n        vec3 passColor = vec3(0.);\n\n        for (int i = 0; i < SPHERES_COUNT; ++i)\n        {          \n            if (prevType == SPHERE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectSphere(rayOrigin, rayDirection, spheres[i], objectHitDistance, surfaceNormal, hit))\n            {                \n                if (objectHitDistance < dist)\n                {\n                    dist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, hit, spheres[i].color, lights[0], surfaceNormal, spheres[i].material);\n                    shadow(hit, passColor, spheres[i].material.ambient, SPHERE, i);\n                    \n                    type = SPHERE;\n                    index = i;\n                    passHit = hit;\n                }\n            }\n        }\n\n        for(int i = 0; i < PLANES_COUNT; ++i)\n        {\n            if (prevType == PLANE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectPlane(planes[i], rayOrigin, rayDirection, objectHitDistance, hit))\n            {\n                if (objectHitDistance <= dist)\n                {    \n\t\t\t\t\tdist = objectHitDistance;\n                    passColor = getLitColor(rayDirection, hit, planes[i].color, lights[0], planes[i].normal, planes[i].material);        \n\n                    surfaceNormal = planes[i].normal;\n\n                    shadow(hit, passColor, planes[i].material.ambient, PLANE, i);\n                \n                \ttype = PLANE;\n                    index = i;                    \n                    passHit = hit;                    \n                }\n            }\n        } \n    \n        if (bounce == 0)\n        {\n            finalColor += passColor;\n        }\n        else\n        {\n        \tfinalColor += getMaterial(type, index).specular * passColor;\n        }\n        \n        if (type < 0) break;\n        \n        rayOrigin = passHit;\n        rayDirection = reflect(rayDirection, surfaceNormal);\n        \n        prevType = type;\n        prevIndex = index;\n    }\n    \n    return finalColor / float(BOUNCES);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupScene();\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 clipPlanePosition = vec3(uv.x, uv.y, camera.position.z + camera.cameraDistance);\n    vec3 rayDirection = normalize(clipPlanePosition - camera.position);\n     \n    vec3 finalColor = rayTrace(rayDirection, camera.position);\n    fragColor = vec4(finalColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3DW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1088, 1088, 1107, 1107, 1191], [1197, 1197, 1268, 1268, 1561], [1563, 1563, 1606, 1606, 1763], [1765, 1765, 1915, 1915, 2616], [2618, 2618, 2721, 2721, 3062], [3065, 3065, 3224, 3224, 3930], [3932, 3932, 4014, 4014, 4990], [4992, 4992, 5048, 5048, 7587], [7589, 7589, 7644, 7644, 8030]], "test": "untested"}
{"id": "ssK3W1", "name": "RotatingArrow", "author": "samikganguly", "description": "2D rotating arrow", "tags": ["2d"], "likes": 2, "viewed": 29, "published": "Public", "date": "1631516058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932384626433832795f;\n\nfloat make_arrow(\n    in vec2 uv, \n    in float tailW, in float tailL, \n    in float headW, in float headL, \n    in float bottom, in float left\n) {\n    if(uv.y > bottom && uv.y < bottom + tailL) {\n        float hTOff = (headW - tailW) / 2.f;\n        return float(uv.x > left + hTOff && uv.x < left + tailW + hTOff);\n    } else if(uv.y >= bottom + tailL && uv.y < bottom + tailL + headL) {\n        float slope = headL / headW * 2.f;\n        if(uv.x > left && uv.x < left + headW / 2.f) {\n            return float(slope * (uv.x - left) > uv.y - bottom - tailL);\n        } else if(uv.x >= left + headW / 2.f && uv.x < left + headW) {\n            return float(slope * (uv.x - left - headW / 2.f) < bottom + tailL + headL - uv.y);\n        }\n    }\n    return 0.f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float angle = pi / 6.f * iTime; //varying angle with time, 1 degree = pi/180 radian\n    uv -= 0.5f; // move arrow to centre\n    uv = vec2(uv.x * aspect * cos(angle) - uv.y * sin(angle), uv.x * aspect * sin(angle) + uv.y * cos(angle)); //rotate\n    float mask = make_arrow(uv, 0.01f, 0.4f, 0.05f, 0.1f, 0.f, 0.f); // generate arrow at origin\n    vec3 bgcol = vec3(0);\n    vec3 fgcol = vec3(0.75);\n\n    // Output to screen\n    fragColor = vec4(mask * fgcol + bgcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3W1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 201, 201, 813], [815, 815, 872, 922, 1492]], "test": "untested"}
{"id": "ssK3zt", "name": "Sandstone canyons", "author": "jarble", "description": "Yet another awe-inspiring desert terrain.\nBased on Karang's [url=https://www.shadertoy.com/view/XdVSW1]\"Desert biome\"[/url] shader.", "tags": ["procedural", "terrain", "mountain", "desert", "canyon", "erosion", "cliff"], "likes": 3, "viewed": 136, "published": "Public API", "date": "1631995871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////\n// Terrain generation section //\n////////////////////////////////\n\nfloat snoise(vec2 p) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\nfloat terrain(in vec2 uv,int octaves)\n{\n    //float scale_factor = 1.;\n    //uv /= scale_factor;\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = .5;\n    float n1 = 0.;\n    \n    //float f2 = .1; //this constant changes the variation in mountain height\n    \n    //float f1 = f2;\n    //float f3 = 1.-f1;\n    //vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        //uv += vec2(amplitude,freq);\n        n1 = (noise((uv) * freq-n1*value)-n1);\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        \n        \n        value = (value+n1 * amplitude);\n        freq *= 2.5-amplitude;\n        amplitude *= 1./2.;\n        \n        \n        //float f1 = f2*(f3+f1)*noise(uv);\n        //uv = uv.yx;\n        uv = uv.yx-n1/freq;\n        //uv1 = uv1.yx;\n        //uv = uv.yx/(1.+amplitude);\n        //uv = uv.yx+noise(uv/freq)*amplitude+noise(uv.yx*amplitude)*freq;\n        //value *= f3+f1;\n        //freq += f1;\n        \n        //value *= .9;\n\n}\n    return value;\n}\n\n\nvec2 map(vec3 p, int octaves) {\n\tfloat dMin = 28.0;\n\tfloat d;\n\tfloat mID = -1.0;\n\t\n\t// Mountains\n\tfloat h = terrain(p.xz, octaves);\n\t//h += smoothstep(0.0, 1.1, h);\n    //h += smoothstep(-0.1, 1.0, p.y)*0.6;\n\td = p.y - h;\n\tif (d<dMin) { \n\t\tdMin = d;\n\t\tmID = 0.0;\n\t}\n\n\treturn vec2(dMin, mID);\n}\n\n////////////////////\n// Render section //\n////////////////////\n\nvec2 castRay(vec3 ro, vec3 rd, int octaves) {\n\tconst float p = 0.001;\n\tfloat t = 0.0;\n\tfloat h = p * 2.0;\n\tfloat m = -1.0;\n\tfor (int i=0; i<36; i++) {\n\t\tif (abs(h)<=p || t>=28.0) break;\n        t += h;\n        vec2 res = map(ro + rd*t, octaves);\n        h = res.x;\n        m = res.y;\n\t}\n\tif (t>28.0) m = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p, int octaves) {\n\tconst vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,\n\t\t\t       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,\n\t\t\t       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );\n}\n\nfloat shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {\n    float res = 1.0;\n\tfloat t = 0.1;\n\tfor(int i=0; i<22; i++) {\n        if (t>=tMax) break;\n        float h = map(ro + rd*t, octaves).x;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res, 0.2, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tconst int geoLOD = 4;\n\t\n\tvec2 res = castRay(ro, rd, geoLOD);\n\t\n\tvec3 lPos = normalize(vec3(1.0, 0.5, 0.0));\n\tvec3 lCol = vec3(1.0, 0.9, 0.8);\n\t\n\tvec3 pos = ro + rd*res.x;\n\t\n\t// mat -1 = Background / sky\n    vec3 color = vec3(0.45,0.5,0.6);\n    float sun = clamp(dot(rd,lPos),0.0,1.0);\n    color += 0.6 * lCol * sun*sun;\n    if (res.y < -0.5) {\n\t\treturn color;\n\t}\n    \n    vec3 skyColor = color;\n\t\n\tint norLOD = int(max(2.0, 12.0-11.0*res.x/28.0));\n\tvec3 nor = calcNormal(pos, norLOD);\n\t\n\t// mat 0 = Rock / mountain\n\tif (res.y>-0.5 && res.y<0.5) {\n\t\t// Base rock\n\t\tcolor = mix( vec3(0.4, 0.1, 0.0), vec3(0.7, 0.6, 0.3), step(0.9, nor.y) );\n\t\t\n\t\t// Layer noise\n\t\tfloat n = 0.5*(snoise(pos.xy*vec2(2.0, 15.0))+1.0);\n\t\tcolor = mix( vec3(0.6, 0.5, 0.4), color, n*smoothstep(0.0, 0.7, 1.0-nor.y) );\n\t\t\n        // Sand on top\n        color = mix(color, vec3(0.7, 0.6, 0.3), smoothstep(0.0, 0.2, nor.y-0.8));\n\t}\n\t// mat 1 = Sand\n\tif (res.y>0.5) {\n\t\t// Base sand and rock color\n\t\tcolor = mix( vec3(0.3, 0.2, 0.0), vec3(0.7, 0.6, 0.3), nor.y );\n\t}\n\t\n    // Lighting and shadows\n    float lAmb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float lDif = clamp( dot( nor, lPos ), 0.0, 2.0);\n\n    if (lDif>0.05) lDif *= shadows(pos, lPos, 8.0, 12.0, geoLOD);\n\n    color += (0.4*lAmb) * lCol;\n    color *= (1.8*lDif) * lCol;\t\n    \n\t// Fog\n\tfloat fog = exp(-0.003 *res.x*res.x);\n\tcolor = mix(skyColor, color, fog);\n\t\t\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\tpos.x *= iResolution.x / iResolution.y;\n    float t1 = iTime;\n\t// Camera\n\tfloat x = 0.0 + (0.5*t1);\n\tfloat y = 0.0;\n\tfloat z = 0.0 + sin(0.1*t1);\n\tvec3 cPos = vec3(x, y, z);\n\tcPos.y = terrain(cPos.xz, 1) + 2.5;\n\t\n\tconst vec3 cUp = vec3(0., 1., 0.);\n\tvec3 cLook = vec3(cPos.x + 1.0, cPos.y*0.85, 0.0);\n\t\n\t// Camera matrix\n\tvec3 ww = normalize( cLook-cPos );\n\tvec3 uu = normalize( cross(ww, cUp) );\n\tvec3 vv = normalize( cross(uu, ww) );\n\t\n\tvec3 rd = normalize( pos.x*uu + pos.y*vv + 2.0*ww );\n\t\n\t// Render\n\tvec3 color = render(cPos, rd);\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssK3zt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 100, 122, 122, 356], [358, 358, 383, 383, 417], [419, 419, 458, 564, 1475], [1478, 1478, 1509, 1509, 1771], [1773, 1837, 1882, 1882, 2168], [2170, 2170, 2208, 2208, 2463], [2465, 2465, 2532, 2532, 2759], [2761, 2761, 2792, 2792, 4209], [4211, 4211, 4268, 4268, 4902]], "test": "untested"}
{"id": "ssKGDz", "name": "Driving in the Rain", "author": "Dave_Green", "description": "The Art of Code, Driving home tut", "tags": ["rain"], "likes": 4, "viewed": 62, "published": "Public", "date": "1631823357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat noise(float t)\n{\n    return fract(sin(t*3456.)*6547.);\n}\n\nvec4 noise14(float t)\n{\n    return fract(sin(t*vec4(123., 1024., 3567., 8745.))*vec4(4568., 345, 9821., 8632.));\n}\n\nstruct ray\n{\n    vec3 origin, direction;\n};\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom)\n{\n    ray a;\n    a.origin = camPos;\n    \n    // Basis vectors for the camera.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0., 1., 0.), forward);\n    vec3 up = cross(forward, right);\n    vec3 centerScreen = a.origin + forward*zoom;\n    vec3 intersectionPoint = centerScreen + uv.x*right + uv.y*up;\n    \n    a.direction = normalize(intersectionPoint - a.origin);\n    \n    return a;\n}\n\nvec3 closestPoint(ray r, vec3 point)\n{\n    return r.origin + max(0., dot(point - r.origin, r.direction))*r.direction;\n}\n\nfloat distToRay(ray r, vec3 point)\n{\n    return length(point - closestPoint(r, point));\n}\n\nfloat bokeh(ray r, vec3 point, float size, float blur)\n{\n    float dist = distToRay(r, point);\n    size *= length(point);\n    float s = S(size, size*(1.-blur), dist);\n    s *= mix(.6, 1., S(size*.8, size, dist));\n    return s;\n}\n\nvec3 streetLights(ray r, float time)\n{\n    float side = step(r.direction.x, 0.);\n    r.direction.x = abs(r.direction.x);\n    \n    float s = 1./10.; // 0.1\n    float mask = 0.;\n    for(float i = 0.; i < 1.; i += s)\n    {\n        float ti = fract(time + i + side*s*.5);\n        vec3 point = vec3(2., 2., 100. -ti*100.);\n    \n    \tmask += bokeh(r, point, .05, .1)*ti*ti*ti;\n    }\n    \n    return vec3(1., .5, 0.)*mask;\n}\n\nvec3 envLights(ray r, float time)\n{\n    float side = step(r.direction.x, 0.);\n    r.direction.x = abs(r.direction.x);\n    \n    float s = 1./10.; // 0.1\n    vec3 col_1 = vec3(0.);\n    for(float i = 0.; i < 1.; i += s)\n    {\n        float ti = fract(time + i + side*s*.5);\n        \n        vec4 noise = noise14(i+side*100.);\n        float fade = ti*ti*ti;\n        \n        float occlusion = sin(ti*6.28*10.*noise.x)*.5+.5;\n        \n        fade = occlusion; \n        float x = mix(2.5, 10., noise.x);\n        float y = mix(.1, 1.5, noise.y);\n        vec3 point = vec3(x, y, 50. -ti*50.);\n        \n        vec3 col_2 = noise.wzy;\n    \n    \tcol_1 += bokeh(r, point, .05, .1)*fade*col_2*.5;\n    }\n    \n    return col_1;\n}\n\nvec3 headLights(ray r, float time)\n{\n    time *= 2.;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./30.; // 0.1\n    float mask = 0.;\n    \n    for(float i = 0.; i < 1.; i += s)\n    {\n        float noise = noise(i);\n        \n        if(noise > .1)\n        {\n            continue;\n        }\n        \n        float ti = fract(time + i);\n        float z = 100. -ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n    \tmask += bokeh(r, vec3(-1.-w1, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(-1.+w1, .15, z), size, .1)*fade;\n        \n        mask += bokeh(r, vec3(-1.-w2, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(-1.+w2, .15, z), size, .1)*fade;\n        \n        float reflection = 0.;\n        reflection += bokeh(r, vec3(-1.-w2, -.15, z), size*3., 1.)*fade;\n        reflection += bokeh(r, vec3(-1.+w2, -.15, z), size*3., 1.)*fade;\n        \n        mask += reflection*focus;\n        \n    }\n    \n    return vec3(.9, .9, 1.)*mask;\n}\n\nvec3 tailLights(ray r, float time)\n{\n    time *= .25;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./15.;\n    float mask = 0.;\n    \n    for(float i = 0.; i < 1.; i += s)\n    {\n        float noise = noise(i);\t\t// At this point noise is between 0 - 1.\n        \n        if(noise > .5)\n        {\n            continue;\n        }\n        \n        // If we get this far we know that noise value is between 0 - 0.5\n        \n        // This says if noise is < 0.25 then lane = 0\n        // If noise is > 0.25 then lane = 1\n        float lane = step(.25, noise);\n        \n        float ti = fract(time + i);\n        float z = 100. -ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        float laneShift = S(1., .96, ti);\n        float x = 1.5 - lane * laneShift;\n        float indicator = step(0., sin(time*500.))*7.*lane*step(.96, ti);\n        \n        // Left bokeh\n    \tmask += bokeh(r, vec3(x-w1, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(x+w1, .15, z), size, .1)*fade;\n        \n        // Right bokeh\n        mask += bokeh(r, vec3(x-w2, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(x+w2, .15, z), size, .1)*fade*(1.+ indicator);\n        \n        float reflection = 0.;\n        reflection += bokeh(r, vec3(x-w2, -.15, z), size*3., 1.)*fade;\n        reflection += bokeh(r, vec3(x+w2, -.15, z), size*3., 1.)*(1.+ indicator*.1);\n        \n        mask += reflection*focus;\n        \n    }\n    \n    return vec3(1., .1, .03)*mask;\n}\n\nvec2 rain(vec2 uv, float time)\n{\n    time *= 40.;\n    vec2 a = vec2(3., 1.);\n    vec2 st = uv*a;\n    vec2 id = floor(st);\n    st.y += time*.22;\n    float noise = fract(sin(id.x*76.34)*758.58);\n    st.y += noise;\n    uv.y += noise;\n    uv.x += noise*.08;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    time += fract(sin(id.x*76.34 +id.y*135.97)*758.58)*6.28;\n    \n    float y = -sin(time+sin(time+sin(time)*.5))*.43;\n    vec2 pos_1 = vec2(0., y);\n    vec2 offset_1 = (st-pos_1)/a;\n    float dist = length((st - pos_1)/a);\n    \n    float mask_1 = S(.07, .0, dist);\n    vec2 offset_2 = (fract(uv*a.x*vec2(1., 2.))-.5)/vec2(1., 2.);\n    \n    dist = length(offset_2);\n    \n    float mask_2 = S(.3*(.5-st.y), .0, dist)*S(-.1, .1, st.y-pos_1.y);\n    //if(st.x > .46 || st.y > .49)\n    //{\n    //    mask_1 = 1.;\n    //}\n    \n    return vec2(mask_1*offset_1*30.+mask_2*offset_2*10.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x -= .75;\n    uv.y -= .35;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 camPos = vec3(.5, .2, 0.);\n    vec3 lookAt = vec3(.5, .2, 1.);\n    float time = iTime * .04+m.x;\n    \n    //uv.x += sin(uv.y*40.)*.1;\n    \n    vec2 rainDistort = rain(uv*5., time)*.1;\n    rainDistort += rain(uv*9., time)*.45;\n    \n    uv.x += sin(uv.y*20.)*.009;\n    uv.y += sin(uv.y*90.)*.004;\n    ray r = getRay(uv-rainDistort*.5, camPos, lookAt, 2.0);\n    \n    vec3 col = streetLights(r, time);\n    \n    col += headLights(r, time);\n    col += tailLights(r, time);\n    col += envLights(r, time);\n    col += (r.direction.y+.25)*vec3(.2, .1, .5);\n\n    //col = vec3(rainDistort, 0.);\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKGDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 62, 62, 102], [104, 104, 127, 127, 218], [265, 265, 324, 324, 735], [737, 737, 775, 775, 856], [858, 858, 894, 894, 947], [949, 949, 1005, 1005, 1177], [1179, 1179, 1217, 1217, 1596], [1598, 1598, 1633, 1633, 2314], [2316, 2316, 2352, 2352, 3363], [3365, 3365, 3401, 3401, 4908], [4910, 4910, 4942, 4942, 5792], [5798, 5798, 5855, 5906, 6715]], "test": "untested"}
{"id": "ssKGWW", "name": "Spongy Holes", "author": "Bedragaren", "description": "SDF test", "tags": ["raymarching", "sdf", "shadows", "menger"], "likes": 1, "viewed": 125, "published": "Public API", "date": "1631583377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LIGHT_BRIGHTNESS 2.\n#define SPHERE_RADIUS 3. \n// Radiuses 2. and 4. are also worth a look \n\nconst vec3  eye      = vec3 ( 0, 0, 0.5);\n vec3  light    = vec3  ( 0.0, 0.1, 5 );\nconst int   maxSteps = 700;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c, float r )\n{\n\treturn length ( p - c ) - r;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2 q = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat menger ( in vec3 p )\n{\n   float d = dBox(p,vec3(1.0));\n\n   float s = 1.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return d;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p + vec3(0,0,-5)*iTime;\n    q.xyz -= 2.5;\n    q = mod(q, 5.0) - 2.5;\n    \n    //return dSphere ( p, vec3 ( 2, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn max (menger(q/2.5), -dSphere ( q, vec3 ( 0, 0, 0 ), SPHERE_RADIUS ));\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, in float maxDist, out float softShadow)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n    softShadow = 1.0;\n    float prevDist = 1e20;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat dist = sdf ( p, m );\n        \n\t\tif ( dist < 0.001 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n        \n        float y = dist*dist/(2.0*prevDist);\n        float d = sqrt(dist*dist-y*y);\n\t\tsoftShadow = min(softShadow, 200. * d / max(0.0, max(totalDist, 0.) - y));\n        prevDist = dist;\n        \n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > maxDist )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n    \n    if (hit) {\n        softShadow = 0.;\n    }\n\t\n\treturn p;\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m) {\n    const float defaultMaxDist = 100.;\n    float softShadow = 0.;\n    return trace ( from, dir, hit, m, defaultMaxDist, softShadow);\n}\n\nfloat traceLightBulb ( in vec3 from, in vec3 dir, out bool hit, in vec3 lightPos, in mat3 m)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat dist = dSphere ( m * p, lightPos, 0.1 );\n        \n\t\tif ( dist < 0.001 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n        \n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 20. )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn totalDist;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateY ( 6.0*mouse.x) *  rotateX ( -6.0*mouse.y );\n    vec2 scale = 3.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec3 color = vec3 ( 0 );\n    vec3 p     = trace ( eye, dir, hit, m );\n    vec3 solidColor = vec3(228, 155, 15) / 255.;\n    vec3 lightColor = vec3(255, (sin(iTime)+0.5)/2.*255., 255) / 255.;\n    \n    light = vec3(5. * -cos(iTime / 2.), 1.5 * sin(iTime + 1.) + 0.1, 5. * sin(iTime / 2.));\n    float hitDist = length( eye - p );\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light*m - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  r  = reflect(l, n);\n        float hn = max ( 0.0, dot ( r, v ) );\n        float sp = pow ( hn, 4.0 );\n        \n        if (dot(l, n) <= 0.) {\n            sp = 0.;\n        }\n\t\t\n\t\tcolor = 1. * solidColor * nl  + solidColor * sp * 0.2;\n        color *= lightColor ;\n        \n        float dist = length(light*m - p);\n        float shadow = 1.;\n        \n        trace(p + l * 0.1, l, hit, m, dist, shadow);\n        \n        color *= LIGHT_BRIGHTNESS / pow(dist, 2.) * shadow;\n        color += 0.001 * solidColor * lightColor / pow(dist, 2.);\n\t}\n    \n    float bulbDist = traceLightBulb(eye, dir, hit, light, m);\n    \n    if (hit && bulbDist < hitDist) {\n        float alpha = clamp(0., 1., pow(abs(bulbDist - length(light*m - eye))*10., 2.));\n        color = (1.-alpha)*color + alpha * (lightColor * 0.5 + vec3(1) * alpha*alpha);\n    }\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(color), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 279, 306, 306, 453], [455, 493, 520, 520, 667], [669, 669, 715, 715, 747], [749, 749, 779, 779, 866], [869, 869, 902, 902, 981], [983, 983, 1025, 1025, 1095], [1097, 1097, 1125, 1125, 1479], [1481, 1481, 1517, 1517, 1783], [1785, 1785, 1891, 1891, 2510], [2512, 2512, 2578, 2578, 2713], [2715, 2715, 2809, 2809, 3158], [3160, 3160, 3212, 3212, 3581], [3583, 3583, 3616, 3616, 3784], [3786, 3786, 3843, 3898, 5690]], "test": "untested"}
{"id": "ssKGzh", "name": "VOXELTRACER - FUNCTIONAL GOLFING", "author": "ENDESGA", "description": "The idea of \"functional golfing\" is to keep something usable and adjustable.\nIt's like multi-golfing for each section of the renderer.\nGolfing with QOL and usability features, if you will.\n\n(control camera with mouse!)", "tags": ["voxel"], "likes": 7, "viewed": 245, "published": "Public API", "date": "1631138623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define T (iTime*.5)\n#define M iMouse\n\n#define DMAX 300.\n#define LOOP_N 77\n\nconst float CUBEH = sqrt( 3. );\nconst float CUBEH2 = CUBEH * 2.;\n\nfloat smin( float a, float b ) { // a mix between SmoothUnion and RoundUnion\n    float r = 10.; // some value\n    float h = max(r-abs(a-b),0.0);\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn ((max(r, min (a, b)) - length(u)) + (min(a, b) - h*h*0.25/r)) * .5;\n}\n\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\n\n// thanks iq <3\nfloat sdf_link( vec3 p, float le, float r1, float r2 ) {\n    vec3 q = vec3( p.x, max( abs( p.y ) - le, 0.0 ), p.z );\n    return length( vec2( length( q.xy ) - r1, q.z )) - r2;\n}\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\nfloat map( in vec3 p )\n{\n\nvec3 q = p - vec3(0.,0.,0.);\n        q = opRepLim(q,((sin(T)*5.)+20.),vec3(-4,-4,-4),vec3(4,4,4));\n        //return length(p) -  10.;\n    return sub( length( q ) - (8. - (cos(T*3.)*3.)), min(\n            min(\n                min( length( p + vec3( 20.,20.,20. ) ) - 40., length( p + vec3( -20.,20.,20. ) ) - 40.),\n                min( length( p + vec3( 20.,-20.,20. ) ) - 40., length( p + vec3( 20.,20.,-20. ) ) - 40.)),\n            min(\n                min( length( p + vec3( -20.,-20.,20. ) ) - 40., length( p + vec3( 20.,-20.,-20. ) ) - 40.),\n                min( length( p + vec3( -20.,20.,-20. ) ) - 40., length( p + vec3( -20.,-20.,-20. ) ) - 40.))\n            )\n        );\n}\n\n// GOLF COURSE\n\nvoid mainImage( out vec4 O, in vec2 I ) {\n\n    vec2 UV = (I / R.xy - .5);\n    UV.x /= R.y / R.x;\n\n    vec3 ro = vec3( 100.0 * sin( M.x * .00777 ), ( 100.0 * cos( M.x * .00777 )), (( M.y / R.y ) - .5) * -100. );\n    vec3 rs = ro; // ray stepped\n    vec3 rl = vec3( 0.0, 0., (( M.y / R.y ) - .5) * 50. ); // ray look\n    vec3 n, trs, ww = normalize( rl - ro ), uu = normalize( cross( ww, vec3( 0.0, 0.0, 1.0 ))); // Z will always be up in 3D space!\n    vec3 rd = normalize( UV.x * uu + UV.y * cross( uu, ww ) + ww ); // ray direction\n\n    bool B; // global break bool\n    float t, d;\n    \n    // 2-step ray marcher (big volume, then voxel)\n    for( int j = 0; j < 7; j++ ) {\n        \n        B = false;\n        trs = rs;\n        t = 0.;\n        \n        // big sdf volume jumps\n        for( int i = 0; i < LOOP_N; i++) {\n            rs = trs + rd * t;\n            d = map( rs );\n            if( d <= -CUBEH2 ) { break; } else if( d > DMAX ) { B = true; break; }\n            t += d;\n        }\n        if( B ) break;\n\n        trs = rs;\n        vec3 c = floor(rs);\n        vec3 ts = ( c + max( vec3( 0. ), sign( rd )) - rs) / rd;\n        \n        // higher precision for voxels\n        for( int i = 0; i < LOOP_N; i++) {\n            n = step( ts, ts.yzx ) * step( ts, ts.zxy );\n            c += sign( rd ) * n;\n            float d = map( c );\n            if( d <= -CUBEH ) {\n                rs = trs + rd * min( ts.x, min( ts.y, ts.z ));\n                break;\n            }\n            vec3 dd = sign( rd ) / rd * n;\n            ts += dd;\n        }\n        rs = trs + rd * min( ts.x, min( ts.y, ts.z ));\n    }\n    if( B ) { O = vec4(0.); return; }\n    \n    float D = distance( rs, ro );\n    if( D > DMAX ) O = vec4( 0. ); else {\n        //calculate diffuse with light direction / scaled distance\n        vec3 C = vec3( 5. + dot( n * -sign( rd ), vec3( .5, 1., .5 ))) / ( D * .5 );\n        // sRGB encoding + contrast mapping\n        C = mix( 12.92 * C, 1.055 * pow( C, vec3( 1.0 / 2.4 )) - 0.055, step( vec3( 0.0031308 ), C ));\n        O = vec4( clamp( C, vec3( 0. ), vec3( 1. )), 1.0f );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 196, 240, 432], [434, 434, 467, 467, 489], [491, 507, 563, 563, 684], [686, 686, 754, 754, 800], [802, 802, 826, 826, 1509], [1511, 1527, 1568, 1568, 3619]], "test": "untested"}
{"id": "sslGzX", "name": " First Shader ", "author": "personalizedrefrigerator", "description": "A very simple shader, my first on Shadertoy, made a while ago, but just made public.", "tags": ["color"], "likes": 4, "viewed": 52, "published": "Public", "date": "1631838088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float getCol(vec2 uv)\n{\n    vec2 pos = vec2(cos(uv.x * 10.0) + pow(sin(uv.y * 10.0), 3.0), uv.x / uv.y + cos(iMouse.x / (iMouse.y + 0.001))) * uv.x;\n    float z = tan(pos.x/tan(pos.y + 0.001) - sin(iTime)) * sin(cos(pos.y / (pos.x + 0.001) / cos(pos.x)) - iTime);\n    \n    return 0.5 * sin(z) + 0.5 + 0.1/tan(uv.x * uv.y);\n}\n\nfloat getBlurredCol(vec2 uv)\n{\n    float result = 0.0;\n    float divBy = 0.0;\n    float BLUR_SIZE = 0.03 * (1.0 + sin(uv.x * uv.y * 0.8 - 0.3));\n    float BLUR_STEP = 0.015 * (0.7 + 0.5 * sin(uv.x / uv.y));\n    \n    for (float x = -BLUR_SIZE; x < BLUR_SIZE; x+=BLUR_STEP) \n    {\n        for (float y = -BLUR_SIZE; y < BLUR_SIZE; y+=BLUR_STEP)\n        {\n            result += getCol(uv + vec2(x, y));\n            divBy++;\n        }\n    }\n    \n    return result / divBy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.9 + tan(iTime * 0.2);\n    float scaleFactor = 1.0 / iResolution.x;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = scaleFactor * (fragCoord - iMouse.xy) * zoom * vec2(1.0, -1.0);\n    float z = getBlurredCol(uv);\n    vec3 col = vec3(sin(1.0 / z) / 4.0 + 0.1, 0.5 * z, z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 324], [326, 326, 356, 356, 796], [798, 798, 855, 855, 1224]], "test": "untested"}
{"id": "sst3Df", "name": "Fission Machine", "author": "104", "description": "how u doin?", "tags": ["2d"], "likes": 7, "viewed": 88, "published": "Public", "date": "1630841651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SceneDurationSeconds = 4.;\nconst float Complexity = 7.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage(out vec4 o, vec2 C)\n{\n    vec2 uv = C/max(iResolution.x, iResolution.y);\n    uv.x --;\n    uv /= 4.;\n\n    float scene = floor((iTime+98.)/SceneDurationSeconds);\n    vec4 hscene = hash42(vec2(scene));\n    uv += scene;\n    \n    float t = iTime*mix(.01,.06,hscene.y);\n    uv -= t*.5;\n\n    vec2 uvn = C/iResolution.xy-.5;\n    float ds = max(abs(uvn.x), abs(uvn.y))*2.;\n    \n    for (float i = 1.; i < Complexity; ++ i) {\n        vec2 c = floor(uv);\n        vec4 h = hash42(c);\n        vec2 p = fract(uv);\n        vec2 a = abs(p-.5);\n        float sd = .5-max(a.x, a.y);\n        o = h*sqrt(sd)*4.;\n        uv *= 2.;\n        float sc = 1./i;\n        uv += fract(abs(fract(uv.yx/sc+t)-.5)*sc-1.) * sign(hscene.x - .5);\n    }\n    o = clamp(o * hscene,0.,1.);\n    o.rgb = mix(vec3(o.r+o.g+o.b)/3., o.rgb, 1.-ds*ds);\n    o += (hash42(C+iTime).r-.5)*.15;\n    o *= 1.-dot(uvn,uvn*2.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 90, 90, 238], [240, 240, 276, 276, 1128]], "test": "untested"}
{"id": "sst3Ws", "name": "Double Helix Assembly Kit", "author": "Tater", "description": "Really pleased I was able to figure out the math for the stacking effect, in the end it wasn't that complicated but I tried a lot of things that didn't work. Part of me still feels it can be massively simplified but idk", "tags": ["3d", "raymarching", "stack", "helix", "stacking"], "likes": 15, "viewed": 235, "published": "Public API", "date": "1631181006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 140.\n#define MDIST 100.\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x)) \n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//#define elon(p,h) (p-clamp(p,-h,h))\n\n//iq palette \nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n//iq segment\nfloat seg(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n//iq extrude\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat layers(vec2 p, float t){\n    p.xy*=rot(t*0.1);\n    float off = (sin(t*0.1)*0.5+0.5)*4.0+6.0;\n    vec2 p2 = p;\n    p2.x = abs(p.x)-off;\n    float c = length(p2.xy)-1.5;\n    if(mod(t,7.0)<1.0){\n        //if(mod(id,2.0)<1.0) p.xz*=rot(pi/2.);\n        c = min(c,seg(p.xy,vec2(off,0),vec2(-off,0))-1.5);\n    }\n    return c;\n\n}\n\nvec2 map(vec3 p){\n    float t = iTime;\n    //p.y-=t*8.-20.;\n    vec3 po = p;\n    vec2 a = vec2(1);\n    float spd = 8.0;\n    t*=spd;\n    float dh = 0.28; //Disk Height\n\n    float lscl = 1.0; //Leading Edge Scale\n    float le = -mod(t * lscl,lscl); //Lead Edge\n    float tscl = 5.; //Trailing Edge Scale\n    float te = tscl - mod(t * tscl,tscl); //Trailing Edge\n    float scl = 0.; //Final Scale for later\n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n    \n        //Transitional domain\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            //Alternative where the transitional domain slows down before stopping on the stack\n            //npy = mod(p.y-le,te-le);\n            //scl = te-le;\n            \n            mid = true;\n            id = floor(t);\n        }\n        //The stacked tower\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        //The falling part\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    \n    //Get Layer\n    float c = layers(p.xz,id);\n    \n    a.x = ext(p, c, dh);\n    a.x-=0.15;\n    \n    //The most annoying domain artifact fixing\n    if(!mid) a.x = min(a.x,max(-(abs(p.y)-scl*0.65),0.01));\n    else {\n        a.x = min(a.x,max(-(-po.y+le),0.1));\n    }\n    \n    a.y = id;\n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,15,-35);\n    ro.xz*=rot(iTime*pi/3.0*0.3);\n    vec3 lk = vec3(0,-3,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.9+uv.x*r+uv.y*cross(f,r));\n    float dO = 0.;\n    vec2 d = vec2(0);\n    vec3 p = vec3(0);\n    bool hit = false;\n    \n    for(float i = 0.; i<STEPS; i++){\n         p = ro+rd*dO;\n         d = map(p);\n         dO+=d.x*1.3; //Idk why this doesn't cause artifacts but whatever\n         if(abs(d.x)<0.005){\n             hit = true;\n             break;\n         }\n         if(dO>MDIST){\n             dO=MDIST;\n             break;\n         }\n    }\n    vec3 al = vec3(0);\n    if(hit){\n        vec3 e = vec3(0.5);\n        al = pal(d.y*0.5+iTime*0.1,e,e,e*2.0,vec3(0,0.33,0.66));\n        //Atlernative coloring by @Gaktan\n        //al = pal(p.y*0.005+d.y*0.5+iTime*0.05,e,e,e*2.0,vec3(0,0.33,0.66));\n        al*=1.5;\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.,0.1,1));\n        vec3 h = normalize(ld-rd);\n        float spec = pow(max(dot(n,h),0.0),5.0);\n        float fres = 1.-abs(dot(rd,n))*.98;\n        float diff = dot(n, ld)*0.4+0.6;\n        col=al*diff+pow(spec,2.0)*0.3*vec3(0.008,0.133,0.078);\n        col*=1.2-fres;\n    }\n    col = sqrt(col);\n    col = mix(col,vec3(0.016,0.102,0.204)*(0.7-dot(uv,uv)),pow(min(dO/68.,1.0),3.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 203, 270, 270, 313], [314, 327, 361, 361, 476], [477, 490, 526, 526, 608], [610, 610, 640, 640, 937], [939, 939, 956, 956, 2497], [2498, 2498, 2516, 2516, 2644], [2645, 2645, 2702, 2702, 4161]], "test": "untested"}
{"id": "sstXRn", "name": "Voxels in 303 chars", "author": "Xor", "description": "A further minimization of [url=https://www.shadertoy.com/view/sdy3RW]this[/url] (removing LOD and some safety checks).", "tags": ["voxel", "golf"], "likes": 13, "viewed": 197, "published": "Public", "date": "1632513232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/sdy3RW\n\n#define M (length(mod(a,18.)-9.)-8.+sin(a-c*.2).x)\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec3 i,a,b,c,p,d = normalize(iResolution.yxy-vec3(0,I+I));\n    //i=a=b=c=p=d-d;\n    \n    for(c.x=p.x=iTime; i.x++<1e2 && M > 1.5; a = ceil(p += d*b)-.5)\n        b = min(a = (trunc(p+sign(d))-p)/d+1e-4, min(a.y,a.z)).xxx;\n\n    O = (sin(a.x+vec4(0,2,4,a = p))+1.)*M/exp((p-c).x/20.+1.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 93, 129, 129, 421]], "test": "untested"}
{"id": "sstXz4", "name": "Evangelion Leliel Angel", "author": "boddiul", "description": "...", "tags": ["waves"], "likes": 0, "viewed": 100, "published": "Public API", "date": "1632782379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 120;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 my_mod( vec3 p, float m) {\n    return p - m * round(p / m);\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length(p-c) - 1.0;////length ( my_mod(p, 5.0) - c ) - 1.0;\n}\n\nfloat dObj ( vec3 p )\n{\n\n    //p.x = sin(p.x);\n    \n    //p.y = sin(p.y);\n    \n    //return length(p)-1.0;\n    \n    int n = 0;\n\n\n    /*if (mod(p.x,2.0)<1.0)\n        {p=vec3(0.0,p.z,p.y);}\n        \n        \n     \n    \n    return length(p) - 1.0;*/\n    \n    /*\n    if (p.x>0.0 )\n        return length(p)-10.0;//return length(p) - 1.0;\n    else\n    {\n        \n    }*/\n    \n    \n    \n    if (p.x<-5.0)\n    {\n        return -iTime-sin(p.x*2.0+p.y*2.0);\n    }\n    else\n    {\n        if (length(p)<10.0 )\n            return sin(p.x+iTime/2.0+p.y-p.z)+10.0*cos(iTime*p.x+p.y-p.z);\n        else\n            return length(p)-10.0;\n    \n    }\n    \n    \n    \n    \n    \n    \n    /*\n    vec3 +1 = vec3(10,10,10);\n\tvec3 a2 = vec3(-10,-10,10);\n\tvec3 a3 = vec3(10,-10,-10);\n\tvec3 a4 = vec3(-10,10,-10);\n    vec3 cc;\n    vec3 z = p;\n    int Iterations = 100;\n    float Scale = 0.5;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < Iterations) {\n\t\t cc = a1; dist = length(z-a1);\n\t        d = length(z-a2); if (d < dist) { cc = a2; dist=d; }\n\t\t d = length(z-a3); if (d < dist) { cc = a3; dist=d; }\n\t\t d = length(z-a4); if (d < dist) { cc = a4; dist=d; }\n\t\tz = Scale*z-cc*(Scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(z) * pow(Scale, float(-n));*/\n    \n    /*\n    int Iterations = 100;\n    float Scale = 0.5;\n    vec3 Offset;\n    vec3 z = p;\n    float r;\n    int n = 0;\n    while (n < Iterations) {\n       if(z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.0) z.zy = -z.yz; // fold 3\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    return (length(z) ) * pow(Scale, -float(n));\n    */\n\n}\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   q += 30.0-min(iTime,20.0) ;\n    \n    //return dSphere ( q, vec3 ( 0, 0, 0 ) );\n    return dObj ( q);\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\t//return smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 100.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstXz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 185, 212, 212, 359], [361, 399, 426, 426, 573], [575, 575, 606, 606, 641], [643, 643, 680, 680, 749], [751, 751, 774, 857, 2372], [2373, 2373, 2402, 2402, 2470], [2472, 2472, 2501, 2501, 2588], [2591, 2591, 2624, 2624, 2705], [2707, 2707, 2749, 2749, 2819], [2821, 2821, 2846, 2941, 2985], [2987, 2987, 3023, 3023, 3289], [3291, 3291, 3358, 3358, 3674], [3676, 3676, 3728, 3728, 4097], [4099, 4099, 4156, 4211, 5077]], "test": "untested"}
{"id": "ssV3R3", "name": "Blob Walk", "author": "deerfeeder", "description": "walk", "tags": ["basic"], "likes": 1, "viewed": 28, "published": "Public", "date": "1631895847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=8.0;\n    uv.x+=iTime*0.25;\n\n    float x = (1.0 + cos(uv.x*6.28*2.0)) * 0.3;\n    float y = (1.0 + sin(uv.y*6.28)) * 0.5;\n \n    float col = (x+y);\n    float phaseA = abs(tan(iTime+uv.y*2.0));\n    col = smoothstep(col,0.1+phaseA*0.3,0.40);\n    if(col > 0.8) {\n        col = log(sin(col*0.1));\n    }\n    fragColor = vec4(vec3(col,col,0.1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 498]], "test": "untested"}
{"id": "ssV3zG", "name": "566 Lab 1 part 1", "author": "emma20", "description": "using functions to transform circle", "tags": ["noise"], "likes": 0, "viewed": 19, "published": "Public", "date": "1631757645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author rah, inspired by jonobr1 / http://jonobr1.com/\n */\n\n// Make a vec3 color from rgb values [0, 255]\nvec3 rgb(float r, float g, float b)\n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/* \n * Output circle colors at given center pos and radius\n */\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n\tfloat d = length(center - uv) - radius;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\n/* \n * Rotate an input point about some center by angle\n */\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat easeInExpo(float x){\nif(x <= .001)\n{\nreturn x;\n}\nelse\n{\nreturn pow(2.5, 2.5 * x - 2.5);\n} \n}\nfloat deformAlongSin(in vec2 uv, in vec2 center){\n    vec2 newUV = normalize(uv - center);\n    float amp = 35.0 * cos(iTime);\n   \n    float res =  sin(atan(newUV.x, newUV.y) * 25.0) * amp;\n    return res;\n}\n\nfloat bias(float a, float t)\n{\n    return pow(t, log(a) / log(0.5));\n}\n\n\nfloat deformFlower(in vec2 uv, in vec2 center){\n    //vec2 newUV = rotatePoint2d(newUV, center, sin(iTime) * 5.0);\n    vec2 newUV = normalize(uv - center);\n    float amp = 40.0 * cos(iTime);\n    float res = sin(atan(newUV.x, newUV.y) * 5.0);\n   \n    res = (res + 1.0) / 2.0;\n    res = sqrt(res) * 2.0;\n    //res = easeInExpo(res);\n    return res * amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n    \n    // Background layer\n\tvec4 layer1 = vec4(rgb(255.0, 255.0, 210.0), 1.0);\n\t\n    // Deform Circle\n    float deformRadius = deformAlongSin(uv, center);\n    //float deformRadius = deformFlower(uv, center);\n    \n\t// Circle\n\tvec3 red = rgb(225.0, 50.0, 70.0);\n    vec2 newUV = rotatePoint2d(uv, center, 30.f);\n\tvec4 layer2 = circle(uv, center, radius + deformRadius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3zG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 113, 150, 150, 199], [201, 264, 325, 325, 429], [431, 491, 546, 546, 820], [821, 821, 868, 868, 962], [964, 964, 990, 990, 1062], [1063, 1063, 1112, 1112, 1269], [1271, 1271, 1301, 1301, 1341], [1344, 1344, 1391, 1458, 1698], [1700, 1700, 1757, 1757, 2300]], "test": "untested"}
{"id": "ssV3zy", "name": "test {L*esXu9\\T,8vW;&", "author": "moka", "description": "https://bit.ly/2XjhKha", "tags": ["test"], "likes": 1, "viewed": 52, "published": "Public", "date": "1631770616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n//https://bit.ly/2XjhKha\n    // Time varying pixel color\n   // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n //   fragColor = vec4(col,1.0);\n    \n\tvec4 p=vec4((fragCoord.xy/4e2),1,-4);\n\tfor(int i=0;i<9;++i)p+=vec4(sin(-(p.x+iTime*.2))+atan(p.y*p.w),cos(-p.x)+atan(p.z*p.w),cos(-(p.x+sin(iTime*.8)))+atan(p.z*p.w),0);\n\tfragColor=p;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssV3zy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 322, 518]], "test": "untested"}
{"id": "ssVGRy", "name": "hexagon grid tdhgdhctdgdhg", "author": "HaleyHalcyon", "description": "grid", "tags": ["hexagon"], "likes": 2, "viewed": 55, "published": "Public", "date": "1631763138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n// converts rgb hex code to a vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    // loop around to tile\n    uv = abs(\n        mod(\n            uv + vec2(1.0, SQRT3),\n            vec2(2., SQRT3 * 2.)\n        ) - vec2(1.0, SQRT3)\n    );\n    // vector from the center to the midpoint of the top right side\n    const vec2 s = vec2(1, SQRT3) * 0.5;\n    // return whichever is closer:\n    // distance towards the top right side,\n    // or distance towards the right side\n    // (i.e. absolute value of x coordinate)\n    return max(\n        dot(uv, s),\n        uv.x\n    );\n}\n\n// map the range [0, 1) to stripes of colors\n#define COLOR_COUNT 4\n// uniforms can't be declared inside a function\n// so sadly it is out here\nconst vec3 color[COLOR_COUNT] = vec3[](\n    HEX(0x000000),\n    HEX(0x300060),\n    HEX(0x8000C0),\n    HEX(0xFF66FF)\n);\nconst float thres[COLOR_COUNT] = float[](\n    0.0, // ignored\n    0.4,\n    0.7,\n    0.9\n);\nvec3 colorize(float value) {\n    value = fract(value);\n    vec3 color_out = color[0];\n    for (int i = 1; i < COLOR_COUNT; i++) {\n        if (value > thres[i]) {\n            color_out = color[i];\n        } else {\n            return color_out;\n        }\n    }\n    return color_out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 2.);\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 8.;\n    \n    float dist = \n        min(\n            // grid with a hexagon centered at the screen\n            hex(uv),\n            // grid with 4 hexagons surrounding the center\n            hex(uv + vec2(1.0, SQRT3))\n        );\n    vec3 col = colorize(\n        dist * dist - time\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 229, 249, 276, 740], [809, 1093, 1121, 1121, 1375], [1377, 1377, 1434, 1434, 1996]], "test": "untested"}
{"id": "ssVGWc", "name": "Fractal 81_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 150, "published": "Public", "date": "1632353095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos((h)*6.3+vec3(0,23,21))*.5+.5\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdHexagon(vec2 p, float r)\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    float i=0.,g=0.,e,s;\n    for(;++i<99.;){\n        p=d*g;\n        p=R(p,vec3(1),.3);\n        p.z+=iTime*.2;\n        p=asin(sin(p*4.));\n        float sdf=sdHexagon(p.xy,2.);\n        p.xy=vec2(sdf);\n        s=3.;\n        for(int i=0;i++<6;){\n\t\t\tp=vec3(3.2,6.8,5.2)-abs(p-vec3(3.4,4.8,2.4));            \t\t\t\n          \tp=p.x<p.y?p.zxy:p.zyx;\n            s*=e=17.8/min(dot(p,p),11.8);\n            p=abs(p)*e;\n        }\n        g+=e=abs(p.y)/s+.001;\n        O.xyz+=(H(log(s)*.8)+.5)*exp(sin(i))/e*3e-5;\n    }\n    O*=O*O*O;\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVGWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 184, 218, 218, 408], [410, 410, 446, 446, 1053]], "test": "untested"}
{"id": "ssVGWm", "name": "Hypnotic flower", "author": "xlat", "description": "Very simple.", "tags": ["fragmentshader"], "likes": 2, "viewed": 49, "published": "Public", "date": "1631687962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///----------------------------------------------------------------------------|\n/// XLAT\n/// www.cyberforum.ru\n///----------------------------------------------------------------------------:\n/// (... written on the knee, no optimizations or obfuscations ...)\n///----------------------------------------------------------------------------:\n\n///------------------------|\n/// Config.                |\n///------------------------:\nconst float RADIUSS  =  0.7;\nconst float NSEC     = 18.0;\n      float SPEED    =  0.3;\n///------------------------.\n\nconst vec4  WHITE    = vec4(0.9, 0.9, 0.9, 1.);\nconst vec4  BLUE     = vec4(0.0, 0.0, 0.6, 1.);\nconst vec4  RED      = vec4(0.6, 0. , 0. , 1.);\nconst vec4  BGROUND  = vec4(0.0, 0.0, 0.2, 1.);\nconst vec4  YELLOW   = vec4(0.0, 0.0, 0.0, 1.);\n\nconst float PIx2     = 6.2831853;\n\n/// not use\n////////////////////////////////////////////////////////////////////////////////\nhighp float rand_(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n\n    return fract(sin(sn) * c);\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m )\n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat rand( float x ) { return floatConstruct(hash(floatBitsToUint(x+iTime))); }\nfloat rand( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\nfloat rand( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\nfloat rand( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v+iTime))); }\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 tonsin(float minn, float maxx, float a)\n{   a = a - minn;\n    float x = 1.57 / (maxx - minn);\n    float c  = 0.3  * cos(a * x);\n    return vec4(c, c, c, 0.9);\n}\n\nfloat distance_x2(vec2 p1, vec2 p2)\n{   vec2   dp = p1 - p2;\n    return dp.x * dp.x + dp.y * dp.y;\n}\n\nbool isCircle(vec2 p, float radius)\n{   float d = distance_x2(p, vec2(0., 0.));\n    float r = radius * radius;\n    if( d < r && d > r * 0.8 ) return true ;\n                               return false;\n}\n\n#define step_t vec2\n\nfloat Speed ;\nfloat Speed1;\nfloat Speed2;\nfloat RADIUS;\n\n#define SIN  sin(Speed)\n#define SIN1 sin(Speed1)\n#define SIN2 sin(Speed2)\n#define COS  cos(Speed) \n#define COS1 cos(Speed1)\n#define COS2 cos(Speed2)\n\n#define STEP(amplitude_x, speed_x, amplitude_y, speed_y) step_t( \\\n                              -abs(amplitude_x * sin(speed_x)),  \\\n                                   amplitude_y * sin(speed_y))\n\n#define NO if(false)\n\nvec4 colorArrayCircles(vec2 pos, bool odd)\n{   \n\n//NO\n    if(isCircle(pos + step_t(-abs(0.2 * sin(Speed     )), 0.01), 0.05 * SIN + 0.1)) \n        return vec4(0.5*COS + 0.5, 0.5*SIN+0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO    \n    if(isCircle(pos + STEP(0.3, Speed, 0.1, Speed + 1.), 0.1 * SIN2 + 0.3)) \n        return vec4(0.5*SIN+0.5, 0.5*COS + 0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO    \n    if(isCircle(pos + STEP(0.4, Speed+1., 0.2, Speed+1.), 0.15 * SIN1 + 0.3)) \n        return vec4(0.5*SIN2+0.5, 0.2*SIN2+0.2, 0.5*COS2 + 0.5, 1.0);\n        \n//NO    \n    if(isCircle(pos + step_t(-abs(0.4 * sin(Speed1 + 2.)),\n                                  0.05 * sin(Speed + 1.)), 0.06)) \n        return vec4(0.2*SIN1+0.2, 0.5*SIN1+0.5, 0.5*COS1 + 0.5, 1.0);\n        \n//NO    \n    if(isCircle(pos + step_t(-abs(-0.2  * sin(Speed2 + 2.)),\n                                   0.2  * sin(Speed2 + 1.)), 0.2)) \n        return vec4(0.2*SIN2+0.8, 0.0, 0.2*COS2+0.2, 1.);\n        \n    return vec4(-1.0);\n}\n\nvec4 colorArrayCircles2(vec2 pos, bool odd)\n{\n//NO    \n    if(isCircle(pos + step_t(-abs(-0.2  * sin(Speed2 + 2.)),\n                                   0.2  * sin(Speed2 + 1.)), 0.2)) \n        return vec4(0.2*SIN2+0.8, 0.0, 0.2*COS2+0.2, 1.);\n\n//NO    \n    if(isCircle(pos + step_t(-abs(0.4 * sin(Speed1 + 2.)),\n                                  0.05 * sin(Speed + 1.)), 0.06)) \n        return vec4(0.2*SIN1+0.2, 0.5*SIN1+0.5, 0.5*COS1 + 0.5, 1.0);\n   \n//NO    \n    if(isCircle(pos + STEP(0.4, Speed+1., 0.2, Speed+1.), 0.15 * SIN1 + 0.3)) \n        return vec4(0.5*SIN2+0.5, 0.2*SIN2+0.2, 0.5*COS2 + 0.5, 1.0);\n\n//NO    \n    if(isCircle(pos + STEP(0.3, Speed, 0.1, Speed + 1.), 0.1 * SIN2 + 0.3)) \n        return vec4(0.5*SIN+0.5, 0.5*COS + 0.5, 0.2*SIN+0.2, 1.0);\n        \n//NO\n    if(isCircle(pos + step_t(-abs(0.2 * sin(Speed     )), 0.01), 0.05 * SIN + 0.1)) \n        return vec4(0.5*COS + 0.5, 0.5*SIN+0.5, 0.2*SIN+0.2, 1.0);\n                 \n    return vec4(-1.0);\n}\n\nvec2 rot(vec2 p, float a)\n{   return vec2( p.x * cos(a) - p.y * sin(a),\n                 p.x * sin(a) + p.y * cos(a) );\n}\n\nfloat getAngle(vec2 pos)\n{   vec2 p = normalize(pos);\n    \n    if(p.y > 0.0) return        acos(p.x);\n    else          return PIx2 - acos(p.x);\n}\n\nvec4 colorBorder(vec2 pos)\n{   if(pos.y < 0.05) return tonsin(0., 0.05, pos.y);\n    if(pos.y > 0.95) return tonsin(0.95, 1., pos.y);\n    if(pos.x < 0.05) return tonsin(0., 0.05, pos.x);\n    if(pos.x > 0.95) return tonsin(0.95, 1., pos.x);\n    return vec4(0.);\n}\n\nvec4 colorSectors(vec2 pos)\n{\n    pos = rot(pos - 0.5, Speed);\n\n    if(RADIUS * RADIUS < pos.x * pos.x + pos.y * pos.y) return BGROUND;\n\n    float asector = PIx2 / NSEC  ;\n    float a       = getAngle(pos);\n\n    for(float i = asector, j = 0.; i < PIx2; i += asector, j += 1.)\n    {\n        if(a < i)\n        {   \n            if(mod(j, 2.) == 0.)\n            {\n                vec4 color = colorArrayCircles(rot(pos, -i), false);\n                if(color.a > 0.)\n                {   return color + vec4( 0., 0., fract(a)/3., 0.);\n                }\n            }\n            else\n            {   float t =  i - asector - a - a;\n                vec4 color = colorArrayCircles2(rot(pos, t), true );\n                if(color.a > 0.)\n                {   return color + vec4( fract(t)/3., fract(t)/3., fract(t)/3., 0.);\n                }\n            }\n\n            return vec4(0.3*sin(i)+0.4, 0.0, 0.0, 1.0);\n        }\n    }\n\n    return RED;\n}\n\n///----------------------------------------------------------------------------|\n/// Run.\n///----------------------------------------------------------------------------:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   float xx = iChannelResolution[0].x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float a = ((SPEED+.6)*sin(iTime/ 5.) - 1.6) / iTime;\n    \n    Speed    = iTime * (SPEED+a)      ;\n    Speed1   = iTime * (SPEED+a) * 1.2;\n    Speed2   = iTime * (SPEED+a) * 1.5;\n    \n    RADIUS   = iTime / 5.; if(RADIUS > RADIUSS) RADIUS = RADIUSS;\n\n    vec4 b = colorBorder(uv);\n    if(  b.a > 0.) fragColor = vec4(mix( colorSectors(uv).xyz, b.xyz, 0.8), 1.);\n    else           fragColor = colorSectors(uv);\n}\n", "image_inputs": [{"id": "MtlSDj", "previewfilepath": "https://soundcloud.com/russian-mafia-deep/grivina-mickey-riot-chocolate-boom", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/russian-mafia-deep/grivina-mickey-riot-chocolate-boom", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVGWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1146, 1217, 1238, 1238, 1369], [1371, 1371, 1393, 1393, 1451], [1452, 1452, 1474, 1474, 1532], [1533, 1533, 1555, 1555, 1613], [1615, 1773, 1805, 1805, 2225], [2227, 2276, 2299, 2299, 2356], [2357, 2357, 2380, 2380, 2437], [2438, 2438, 2461, 2461, 2518], [2519, 2519, 2542, 2542, 2599], [2601, 2683, 2729, 2729, 2848], [2850, 2850, 2887, 2887, 2950], [2952, 2952, 2989, 2989, 3154], [3604, 3604, 3648, 3657, 4591], [4593, 4593, 4638, 4647, 5565], [5567, 5567, 5594, 5594, 5688], [5690, 5690, 5716, 5716, 5836], [5838, 5838, 5866, 5866, 6099], [6101, 6101, 6130, 6130, 7037], [7039, 7210, 7267, 7267, 7771]], "test": "untested"}
{"id": "ssy3Wh", "name": "Heart of Sufi ", "author": "Radical_Ed", "description": "Heart of the Sufi\n\n\"In your light I learn how to love. In your beauty, how to make poems. You dance inside my chest where no-one sees you, but sometimes I do, and that sight becomes this art.\" Rumi", "tags": ["universe"], "likes": 2, "viewed": 45, "published": "Public", "date": "1631437197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// rework of this GLSL Shader https://glslsandbox.com/e#67349.0\n\n\nprecision mediump float;\n\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n#define MAX 4.0\n#define NUM_LAYERS 2.\n\nmat2 rot(float angle){\n    float s=sin(angle),c=cos(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash21(vec2 p){\n    p=fract(p*vec2(52.34,5.21));\n    p+=dot(p,p+45.32);\n    return fract(p.x*p.y);\n}\n\nfloat star(vec2 uv,float flare){\n    float d=length(uv);\n    float m=.04/d;\n    float rays=max(0.,1.-abs(uv.x*uv.y*1000.));\n    m+=rays*flare;\n    uv*=rot(3.1415/4.);\n    rays=max(0.,1.-abs(uv.x*uv.y*1000.));\n    m+=rays*.3*flare;\n    m*=smoothstep(1.,.2,d);\n    return m;\n}\n\nvec3 universe(vec2 uv){\n    vec3 col=vec3(0);\n    vec2 gv=fract(uv)-.5;\n    vec2 id=floor(uv);\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs=vec2(x,y);\n            float n=hash21(id+offs);// random [0,1]\n            float size=fract(n*354.32);\n            float st=star(gv-offs-vec2(n,fract(n*34.))+.5,smoothstep(.9,1.,size)*.6);\n            vec3 color=sin(vec3(1.3392,.2882,.0988))*.8+.5;\n            st*=sin(iTime*3.+n*6.2831)*.5+1.;\n            col+=st*size*color;\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    int j = 0;\n    \n   \n    //vec2 p = (fragColor.xy * 2.0 - iResolution) / min(iResolution.x, iResolution.y);\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)  / min(iResolution.x, iResolution.y);\n    \n    //p = p*0.1. ;\n    p = rotate (p, 1.6);\n\t\t\n    vec2  x = p + vec2(-0.3, -0.1); \n    float y = 1.5; \n    vec2  z = vec2(0.0, 0.0);      \n    \n    for(int i = 0; i < 360; i++){\n        j++;\n        if(length(z) > 1.0) {break;}\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * (sin(iTime*6.7)*0.3+1.) * z.x * z.y) +  x * 0.4* y;\n\t\n    }\n\t\n     vec3 rgb = vec3(0.2,0.0,0.0);\n   \n    for(float i=0.;i<1.;i+=1./NUM_LAYERS){\n        float depth=fract(i+iTime);\n        float scale=mix(20.,.5,depth);\n        float fade=depth*smoothstep(1.,0.9*abs(sin(iTime)),depth);\n        rgb+=universe(p*rot(iTime*sin(i*30.))*scale+i*453.2)*fade;\n    }\n\t\n    \n\t\n    \n    \n    float t = float(j) / 130.0 ;\n    \n    \n    fragColor = vec4(rgb * t , 1.0);\n\t\n}", "image_inputs": [{"id": "XtsXW2", "previewfilepath": "https://soundcloud.com/bz-akira-santjago/and-that-sight-becomes-this-art-bz-akira-santjago", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bz-akira-santjago/and-that-sight-becomes-this-art-bz-akira-santjago", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssy3Wh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 94, 124, 124, 208], [249, 249, 271, 271, 337], [339, 339, 360, 360, 445], [447, 447, 479, 479, 721], [723, 723, 746, 746, 1260], [1263, 1263, 1319, 1319, 2264]], "test": "untested"}
{"id": "ssyGRm", "name": "t-spin", "author": "HaleyHalcyon", "description": "a11", "tags": ["a"], "likes": 4, "viewed": 66, "published": "Public", "date": "1631248413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n#define MINSCALE 0.001\n#define SHAPECOUNT 8u\n#define TILE true\n\nfloat fold(float x) {\n    return abs(2. * fract(x) - 1.);\n}\n\n// returns vec2(mask, distanceFromCenter)\nvec2 tshape(vec2 uv, float angle) {\n    if (TILE) {\n    uv = mod(uv + 6.0, 12.0) - 6.0;\n    }\n    vec2 uvRot = vec2(\n        uv.x * cos(angle * TAU) + uv.y * sin(angle * TAU),\n        uv.x * sin(angle * TAU) - uv.y * cos(angle * TAU)\n    );\n    \n    float rectHriz = max(0., max(abs(uvRot.x) - 2., abs(uvRot.y)));\n    float rectVert = max(0., max(abs(uvRot.x), abs(uvRot.y) - 2.));\n    if (uvRot.y < 0.) {rectVert = rectHriz;}\n    float value = 1. - min(rectHriz, rectVert);\n    float mask = step(0.0, value);\n    return vec2(mask, mask * (value));\n}\n\nfloat timeAdj(float time){\n    return 0.25 * (smoothstep(0.0, 0.2, fract(4. * time)) + floor(4. * time));\n}\nvec3 hex(int hexcode){\n    return vec3(\n        (hexcode >> 16) & 255,\n        (hexcode >> 8) & 255,\n        hexcode & 255\n    ) / 255.;\n}\nvec3 tcolor(vec2 md, float layer, float time) {\n    vec3 color0Base  = hex(0x4a089a);\n    vec3 color0Light = hex(0x7d3ecd);\n    vec3 color1Base  = hex(0x9a2cC3);\n    vec3 color1Light = hex(0xfc69f8);\n    \n    float mixFactor = step(fract(layer * -5.6), 0.3);\n    \n    vec3 colorBase  = mix(color0Base , color1Base , mixFactor);\n    vec3 colorLight = mix(color0Light, color1Light, mixFactor);\n    \n    return mix(\n        colorBase, colorLight, 0.5 + 0.5 * sin(TAU * fract(md.y + 2. * time))\n    );\n}\n\nfloat grid(vec2 uv, float scale) {\n    return max(fold(uv.x * scale), fold(uv.y * scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = fract(iTime / 4.);\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 2.;\n    \n    float dist = length(uv);\n    \n    vec2 t = vec2(0);\n    uint i = 0u;\n    \n    for (; i < SHAPECOUNT; i++) {\n        float prog = (float(i) + time);\n        t = tshape(\n            uv / (exp(prog) * MINSCALE),\n            timeAdj(time + float(i) * -0.01)\n        );\n        if (t.x > 0.) {\n            break;\n        }\n    }\n    // Time varying pixel color\n    vec3 col = tcolor(t, float(i) + time, time);\n    float gridV = step(0.9, grid(uv, 12.0 * exp2(fract(time))));\n    gridV = mix(gridV, step(0.9, grid(uv, 6.0 * exp2(fract(time)))), fract(time));\n    col -= 0.05 * gridV;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 111, 111, 149], [151, 193, 228, 228, 743], [745, 745, 771, 771, 852], [853, 853, 875, 875, 991], [992, 992, 1039, 1039, 1491], [1493, 1493, 1527, 1527, 1585], [1587, 1587, 1644, 1644, 2511]], "test": "untested"}
{"id": "ssyGRy", "name": "Morphing Femme Leopard Skin", "author": "Edvid", "description": "No description thus far", "tags": ["fragment"], "likes": 0, "viewed": 12, "published": "Public", "date": "1631731938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 nobles[240];\nconst float PI = 3.14159265359;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 dir;\n    for(int i = 0; i < nobles.length(); i++){\n    \tnobles[i] = vec3(\n        \tfract(pow(float(i),1.2)*1.0 + sin(iTime*1.0/20.0*PI*2.0+float(i%60))*0.25),\n            fract(pow(float(i),1.3)*1.0 + cos(iTime*1.0/20.0*PI*2.0+float(i%60))*0.25),\n            fract(float(i) * 2123.2345)\n        );\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, 0.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, 0.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, 0.0)),2.0);\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, 1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, 1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, 1.0)),2.0);\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, -1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, -1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, -1.0)),2.0);\n        \n    }\n    \n    vec3 col;\n    \n    if(abs(atan(dir.y, dir.x) - 0.5) < 0.03) col = vec3(0.8, 0.8, 0.8);\n    else if(abs(atan(dir.y, dir.x) - 0.5) < 0.1)  col = vec3(0.2, 0.2, 0.2);\n    else col = vec3(0.65, 0.25, 0.6);\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyGRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 162, 1844]], "test": "untested"}
{"id": "ssyGWW", "name": "Demo 1 - SDF, Phong", "author": "steps3d", "description": "Example of SDF animated shape with Phong shading", "tags": ["sdf"], "likes": 0, "viewed": 30, "published": "Public", "date": "1631543624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0 + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length8 ( p.xz ) - t.x, p.y );\n\t\n\treturn length8 ( q ) - t.y;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdf ( in vec3 p )\n{\n    //return dSphere ( p, vec3 ( 0, 0, 0 ) );\n    //return dBox ( p, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn dTorus ( p, vec2 ( 0.73, 0.5 ) );\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n    \n    //return dSphere ( p, vec3 ( 2, 0, 0 ) );\n    //return dBox ( q, vec3 ( 0.5, 0.2, 0.7 ) );\n\treturn smin ( dTorus ( q, vec2 ( 0.73, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( 0, 1, 0, 1 );\n\t} \n\n    // Output to screen\n    fragColor = color;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyGWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 184, 211, 211, 358], [360, 398, 425, 425, 572], [574, 574, 611, 611, 676], [678, 678, 707, 707, 775], [777, 777, 806, 806, 893], [896, 896, 929, 929, 1010], [1012, 1012, 1054, 1054, 1124], [1126, 1126, 1151, 1246, 1290], [1292, 1292, 1328, 1328, 1539], [1541, 1541, 1608, 1608, 1923], [1925, 1925, 1977, 1977, 2346], [2348, 2348, 2405, 2460, 3326]], "test": "untested"}
{"id": "ssyGzG", "name": "pre-surgical anxiety swirl", "author": "abjectadvect", "description": "anxiety swirls", "tags": ["art"], "likes": 3, "viewed": 43, "published": "Public", "date": "1631729301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\nfloat mag2(vec3 v) { return dot(v, v); }\nfloat mag(vec3 v) { return sqrt(dot(v, v)); }\n\n\nfloat line(vec3 p, vec3 q, vec3 d, float width) {\n    return mag(p - (q + d*dot(p-q, d)/dot(d,d))) - width;\n}\n\nvec3 twist(vec3 p, vec3 center, float dist) {\n    vec3 v = p - center;\n    \n    vec2 polar = vec2(sqrt(dot(v.xy, v.xy)), atan(v.y, v.x));\n    float rad = polar.x;\n    float theta = polar.y;\n    \n    \n    float r = 2. * PI * polar.x / dist;\n    \n    float angle = theta + r;\n    \n    v = vec3(rad * cos(angle), rad * sin(angle), v.z);\n \n    return v + center;\n}\n\nfloat lerps(float a, float b, float s) { return s * b + (1.0 - s) * a; }\nvec3 lerpv(vec3 a, vec3 b, float s) { return s * b + (1.0 - s) * a; }\n\nfloat scene(vec3 p) {\n\n    p.xy += vec2(sin(p.y*10. + iTime)*0.05, 0.);\n\n    float swirl1 = line(\n            twist(p, vec3(sin(iTime)/5.0, cos(iTime)/5.0, 0.), 0.08), \n            vec3(0., 0., 0.), \n            vec3(-0.4, 1., 0.), \n            lerps(0.03, 0.3, abs(sin((iTime + 7.)*2.3))));\n            \n    float swirl2 = line(\n        twist(p, vec3(-0.25, -0.25, 0.), lerps(0.01, 0.1, sin(iTime))), \n        vec3(0., 0., 0.), \n        vec3(0.4, 1., 0.), \n        lerps(0.03, 0.3, abs(sin((iTime + 7.)*2.3))));\n       \n\n    return max(swirl1, swirl2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.xx;\n    \n    vec3 eye = vec3(uv.x, uv.y, -10.);\n    \n    float sd = 1000.;\n    vec3 p = eye;\n    vec3 dir = vec3(0., 0., 1.);\n    for (int i = 0; i < 100; i++) {\n       float d = scene(p);\n       if (d > sd) break;\n       \n       sd = d;\n       if (d <= 0.001) break;\n       p = p + sd * dir;\n    }\n    \n    float anxiety = max(0., (sd > 0.001 ? lerps(1.0, 0.0, sd*lerps(1.0, 10.0, abs(sin(iTime*2.7)))) : 1.0));\n\n    vec3 col = lerpv(vec3(1.0, 0.5, 0.), vec3(1.0, 0., 0.), anxiety);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyGzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 50, 50, 70], [71, 71, 90, 90, 116], [119, 119, 168, 168, 228], [230, 230, 275, 275, 590], [592, 592, 632, 632, 664], [665, 665, 702, 702, 734], [736, 736, 757, 757, 1291], [1293, 1293, 1350, 1400, 2000]], "test": "untested"}
{"id": "wtVyDz", "name": "Triange Incircle", "author": "iq", "description": "The three bisectors of a triangle meet at a single point which is also the point that is equidistant to the three sides. And so, it's also the center of the incircle of the triangle.", "tags": ["2d", "incircle", "bisectors"], "likes": 17, "viewed": 385, "published": "Public API", "date": "1631153560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The three bisectors of a triangle meet at a single point\n// which is also the point that is equidistant to the three\n// sides. And so, it's also the center of the incircle of\n// the triangle.\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1-p0; vec2 v0 = p-p0;\n\tvec2 e1 = p2-p1; vec2 v1 = p-p1;\n\tvec2 e2 = p0-p2; vec2 v2 = p-p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot2(e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot2(e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot2(e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot2( pq0 ), cro(v0,e0) ),\n                       vec2( dot2( pq1 ), cro(v1,e1) )),\n                       vec2( dot2( pq2 ), cro(v2,e2) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v0, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v1, ce )));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(0.005,0.001,sdSegment( p, v2, ce )));\n    \n    // draw equicenter in yellow\n    col = mix(col,vec3(1.0,1.0,0.0),smoothstep(0.005,0.001,sdDisk(p,ce,0.02)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyDz.jpg", "access": "shaders20k", "license": "mit", "functions": [[1078, 1275, 1336, 1336, 1472], [1531, 1560, 1610, 1610, 1638], [1640, 1670, 1722, 1722, 1842], [1844, 1880, 1914, 1914, 1940], [1941, 1941, 1966, 1966, 1985], [1986, 1986, 2053, 2053, 2544], [2546, 2603, 2660, 2660, 3731]], "test": "untested"}
